<html>
<head>
<title>A Journey With Quarkus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与夸库斯的旅行</h1>
<blockquote>原文：<a href="https://itnext.io/a-journey-with-quarkus-ff73fc64cfe1?source=collection_archive---------7-----------------------#2019-08-07">https://itnext.io/a-journey-with-quarkus-ff73fc64cfe1?source=collection_archive---------7-----------------------#2019-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="66a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2019年5月，我出席了<a class="ae kl" href="https://www.devoxx.co.uk/" rel="noopener ugc nofollow" target="_blank"> Devoxx UK event </a>，在那里我看到了由Sanne Grinovero演示的来自Red Hat的名为Quarkus的新Java框架演示。我对它感兴趣，主要是因为我整天都在使用Spring environment，学习新技术和从不同的角度看解决方案很重要。</p><p id="60eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我决定用Quarkus创建一个简单的API。我在本文中的目标是描述我的框架开发之旅，我学到了什么，并展示如何用不同的工具开发软件。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/45590b16cae83389d880ccfc05bd0b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjouG98RUaG-szScpeKnBg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">https://quarkus.io/<a class="ae kl" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><h2 id="23e6" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">应用特征</h2><p id="0fa0" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为了开发API，我使用了:</p><ul class=""><li id="fc07" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">Java 11</li><li id="7f88" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">专家</li><li id="c3f9" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">龙目岛</li><li id="ac65" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">Quarkus 0.20.0(与Quarkus Hibernate Panache一起使用)</li><li id="9d91" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">PostgreSQL数据库和H2数据库(测试范围)</li><li id="67cb" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">码头工人和码头工人组成。</li></ul><h2 id="a6b7" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">编写代码</h2><p id="9301" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我创建了一个技术商店解决方案。为了保持项目的简单，我只使用了一个模型，还有Lombok。遵循Quarkus模型:</p><pre class="kn ko kp kq gt mo mp mq mr aw ms bi"><span id="a0fb" class="lc ld iq mp b gy mt mu l mv mw">@AllArgsConstructor<br/>@NoArgsConstructor<br/>@Data<br/>@Entity<br/>@Builder<br/><strong class="mp ir">public class </strong>Product <strong class="mp ir">extends </strong>PanacheEntity {<br/><br/>    <strong class="mp ir">private </strong>String <strong class="mp ir">name</strong>;<br/>    <strong class="mp ir">private </strong>String <strong class="mp ir">description</strong>;<br/>    <strong class="mp ir">private double price</strong>;<br/>}</span></pre><p id="7263" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，在Quarkus，我们扩展了PanacheEntity。这个抽象类表示一个具有生成的长ID的实体。因此，我们不需要在模型中声明ID属性。此外，PanacheEntity扩展了PanacheEntityBase，它生成所有有用的数据库方法，如查找、删除、持久化等。</p><p id="95b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您不需要在Quarkus中实现存储库类。<a class="ae kl" href="https://quarkus.io/guides/hibernate-orm-panache-guide" rel="noopener ugc nofollow" target="_blank">如官方文档</a>所示，可以直接使用模型类执行数据库命令:</p><pre class="kn ko kp kq gt mo mp mq mr aw ms bi"><span id="fbaf" class="lc ld iq mp b gy mt mu l mv mw">if(product.isPersistent()) product.delete();</span></pre><p id="4ce5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的项目中，我决定创建一个类来简化可视化。</p><p id="ef7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了用默认值初始化数据库，我用@ApplicationScoped声明了一个bean，并使用StartupEvent在启动时运行我的方法。用@Transactional注释这个方法很重要，这样Quarkus就可以打开和关闭事务。</p><pre class="kn ko kp kq gt mo mp mq mr aw ms bi"><span id="fc2f" class="lc ld iq mp b gy mt mu l mv mw">@ApplicationScoped<br/><strong class="mp ir">public class </strong>AppLifecycleBean {<br/><br/>    <strong class="mp ir">private static final </strong>Logger <strong class="mp ir"><em class="mx">LOGGER </em></strong>= LoggerFactory.<em class="mx">getLogger</em>(<strong class="mp ir">"Listener bean"</strong>);<br/><br/>    @Transactional<br/>    <strong class="mp ir">void </strong>onStart(@Observes StartupEvent event) {<br/>        <strong class="mp ir"><em class="mx">LOGGER</em></strong>.info(<strong class="mp ir">"Application starting..."</strong>);<br/>        createDB();<br/>    }<br/><br/>    <strong class="mp ir">private void </strong>createDB() {<br/>        Stream.<em class="mx">of</em>(<strong class="mp ir">new </strong>Product(<strong class="mp ir">"Mouse"</strong>, <strong class="mp ir">"Really good mouse"</strong>, 20),<br/>                <strong class="mp ir">new </strong>Product(<strong class="mp ir">"Notebook"</strong>, <strong class="mp ir">"Great notebook"</strong>, 1000),<br/>                <strong class="mp ir">new </strong>Product(<strong class="mp ir">"Keyboard"</strong>, <strong class="mp ir">"Great keyboard"</strong>, 300),<br/>                <strong class="mp ir">new </strong>Product(<strong class="mp ir">"Headphones"</strong>, <strong class="mp ir">"Great headphones"</strong>, 60),<br/>                <strong class="mp ir">new </strong>Product( <strong class="mp ir">"Touchscreen"</strong>, <strong class="mp ir">"Great screen"</strong>, 500))<br/>                .forEach(product -&gt; product.persist());<br/>    }<br/>}</span></pre><p id="0c8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也可以只在<em class="mx"> import.sql </em>文件中添加SQL语句，<a class="ae kl" href="https://quarkus.io/blog/hibernate-orm-config-profiles/" rel="noopener ugc nofollow" target="_blank">根据官方文档</a>。</p><p id="6ac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在REST端点实现中，由于Quarkus使用了JAX-RS，所以我用@Produces和@Consumes注释了这个类，而不是注释每个方法。</p><pre class="kn ko kp kq gt mo mp mq mr aw ms bi"><span id="29df" class="lc ld iq mp b gy mt mu l mv mw">@Path(<strong class="mp ir">"/products"</strong>)<br/>@Produces(<strong class="mp ir"><em class="mx">APPLICATION_JSON</em></strong>)<br/>@Consumes(<strong class="mp ir"><em class="mx">APPLICATION_JSON</em></strong>)<br/><strong class="mp ir">public class </strong>StoreController {<br/><br/>    @Inject<br/>    <strong class="mp ir">private </strong>ProductRepo <strong class="mp ir">productRepo</strong>;<br/><br/>    @GET<br/>    <strong class="mp ir">public </strong>List&lt;Product&gt; getProducts() {<br/>        <strong class="mp ir">return productRepo</strong>.getProducts();<br/>    }<br/><br/>    @GET<br/>    @Path(<strong class="mp ir">"/{id}"</strong>)<br/>    <strong class="mp ir">public </strong>Response getProductById(@PathParam(<strong class="mp ir">"id"</strong>) <strong class="mp ir">long </strong>id) {<br/>        <strong class="mp ir">if</strong>(<strong class="mp ir">productRepo</strong>.getProductById(id).isPresent()) <strong class="mp ir">return </strong>Response.<em class="mx">ok</em>(<strong class="mp ir">productRepo</strong>.getProductById(id).get()).build();<br/>        <strong class="mp ir">else return </strong>Response.<em class="mx">status</em>(<strong class="mp ir"><em class="mx">NOT_FOUND</em></strong>).build();<br/>    }<br/><br/>    @POST<br/>    <strong class="mp ir">public </strong>Response addProduct(Product newProduct) {<br/>        Product p = <strong class="mp ir">productRepo</strong>.addProduct(newProduct);<br/>        <strong class="mp ir">return </strong>Response.<em class="mx">ok</em>(p).build();<br/>    }<br/><br/>    @PUT<br/>    @Path(<strong class="mp ir">"/{id}"</strong>)<br/>    <strong class="mp ir">public </strong>Response updateProduct(@PathParam(<strong class="mp ir">"id"</strong>) <strong class="mp ir">final long </strong>id, Product product) {<br/>        <strong class="mp ir">productRepo</strong>.updateProduct(id, product);<br/>        <strong class="mp ir">return </strong>Response.<em class="mx">ok</em>(product).build();<br/>    }<br/><br/>    @DELETE<br/>    @Path(<strong class="mp ir">"/{id}"</strong>)<br/>    <strong class="mp ir">public </strong>Response deleteProduct(@PathParam(<strong class="mp ir">"id"</strong>) <strong class="mp ir">final long </strong>id) {<br/>        <strong class="mp ir">productRepo</strong>.deleteProduct(id);<br/>        <strong class="mp ir">return </strong>Response.<em class="mx">noContent</em>().build();<br/>    }<br/>}</span></pre><p id="4d2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完成开发，我使用Docker和Docker Compose来编排PostgreSQL容器和我的应用程序。遵循以下Dockerfile文件:</p><pre class="kn ko kp kq gt mo mp mq mr aw ms bi"><span id="b9af" class="lc ld iq mp b gy mt mu l mv mw">FROM fabric8/java-centos-openjdk11-jre</span><span id="e7f2" class="lc ld iq mp b gy my mu l mv mw">ENV JAVA_OPTIONS="-Dquarkus.http.host=0.0.0.0 -Djava.util.logging.manager=org.jboss.logmanager.LogManager -Xmx256m"<br/>ENV AB_ENABLED=jmx_exporter</span><span id="1500" class="lc ld iq mp b gy my mu l mv mw">COPY target/lib/* /deployments/lib/<br/>COPY target/*-runner.jar /deployments/app.jar</span><span id="3d20" class="lc ld iq mp b gy my mu l mv mw">ENTRYPOINT [ "/deployments/run-java.sh" ]</span></pre><p id="95ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所见，<em class="mx">目标/库</em>文件夹被完全复制到容器中。在<a class="ae kl" href="https://quarkus.io/guides/getting-started-guide" rel="noopener ugc nofollow" target="_blank"> Quarkus文档中引用了</a>:<em class="mx">注意这不是一个超级jar，因为依赖项被复制到了</em> <code class="fe mz na nb mp b"><em class="mx">target/lib</em></code> <em class="mx">目录中。</em></p><p id="4300" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在docker-compose.yml文件:</p><pre class="kn ko kp kq gt mo mp mq mr aw ms bi"><span id="392f" class="lc ld iq mp b gy mt mu l mv mw"><strong class="mp ir">version</strong>: <strong class="mp ir">'3.1'<br/><br/>services</strong>:<br/>  <strong class="mp ir">quarkus</strong>:<br/>   <strong class="mp ir">build</strong>:<br/>     <strong class="mp ir">context</strong>: .<br/>     <strong class="mp ir">dockerfile</strong>: Dockerfile<br/>   <strong class="mp ir">depends_on</strong>:<br/>     - postgres<br/>   <strong class="mp ir">ports</strong>:<br/>     - 8080:8080<br/><br/>  <strong class="mp ir">postgres</strong>:<br/>    <strong class="mp ir">image</strong>: postgres:latest<br/>    <strong class="mp ir">environment</strong>:<br/>      - POSTGRES_PASSWORD=test<br/>      - POSTGRES_USER=test<br/>      - POSTGRES_DB=testdb<br/>    <strong class="mp ir">ports</strong>:<br/>      - <strong class="mp ir">"5432:5432"</strong></span></pre><h2 id="0a25" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">我的经历</h2><p id="207c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在整个开发过程中，我了解到Quarkus是一个新的开源项目，而且进展很快。我从Quarkus 0.17.0开始开发，现在是0.20.0版本。我可以通过在资源库中打开一个问题来为项目做贡献:<a class="ae kl" href="https://github.com/quarkusio/quarkus/issues/2961" rel="noopener ugc nofollow" target="_blank">https://github.com/quarkusio/quarkus/issues/2961</a>。</p><p id="09e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在REST端点注释和CDI events @Observes注释中看到的那样，Quarkus看起来和感觉上都像Java EE。<a class="ae kl" href="https://quarkus.io/extensions/" rel="noopener ugc nofollow" target="_blank">扩展模型</a>允许与第三方代码集成。你可以使用官方网站上的<a class="ae kl" href="https://quarkus.io/guides/" rel="noopener ugc nofollow" target="_blank">指南开始一个新项目，如果你有困难，可以查看Github </a>中的<a class="ae kl" href="https://github.com/quarkusio/quarkus-quickstarts" rel="noopener ugc nofollow" target="_blank">快速启动项目。</a></p><p id="e028" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用Quarkus通过GraalVM编译成本地映像，这样您就不需要JRE来运行您的Java应用程序。如果你不了解GraalVM，我建议你看一下GraalVM的官方文档，以及如何使用这两种解决方案构建一个本地可执行文件。</p><p id="ad03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在Sanne的Devoxx 中的<a class="ae kl" href="https://www.youtube.com/watch?v=za5CSBX-UME" rel="noopener ugc nofollow" target="_blank">演示以及这篇关于Oleg elajev</a>的<a class="ae kl" href="https://medium.com/graalvm/lightweight-cloud-native-java-applications-35d56bc45673" rel="noopener">轻量级云原生Java应用的文章中所看到的，使用GraalVM的一些好处是启动速度更快，运行时内存需求更少。</a></p><h2 id="e0c5" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">结论</h2><p id="357f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">使用Quarkus可以轻松快速地创建解决方案。我的建议是，也将永远是，学习更多。因此，去那里测试新的Quarkus，与你已经完成的项目进行比较，检查用它编码的感觉如何。</p><p id="d5a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以从我的Github下载这个项目:<a class="ae kl" href="https://github.com/andreybevilacqua/techstore." rel="noopener ugc nofollow" target="_blank">https://github.com/andreybevilacqua/techstore.</a>按照Readme.md文件中的步骤执行应用程序。</p></div></div>    
</body>
</html>