<html>
<head>
<title>Type Yoga: Typing Flexible Functions with TypeScript’s Advanced Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Type Yoga:使用TypeScript的高级特性键入灵活的函数</h1>
<blockquote>原文：<a href="https://itnext.io/type-yoga-typing-flexible-functions-with-typescripts-advanced-features-6bb3292732bb?source=collection_archive---------4-----------------------#2019-07-18">https://itnext.io/type-yoga-typing-flexible-functions-with-typescripts-advanced-features-6bb3292732bb?source=collection_archive---------4-----------------------#2019-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4c10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个月前，我决定将TypeScript绑定添加到我的库中。如果您不熟悉，<em class="km"> shades </em>提供了一种快速和声明性地描述对象路径的方法，可以用来提取它的值，甚至不变地“修改”它(通过创建一个值已更改的新对象)。如果你想更多地了解这些坏男孩(我认为你应该了解)，你可以看看我在Reactathon的演讲。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ks kt l"/></div></figure><p id="a797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们如何输入如此灵活的函数呢？例如，<a class="ae kl" href="https://github.com/jamesmcnamara/shades#get" rel="noopener ugc nofollow" target="_blank"><em class="km">get</em></a><em class="km"/>可以将代表路径的可变数量的不同输入输入到一个对象中，并且仍然推断出该路径末端的输出类型:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ku"><img src="../Images/0efbaa8efade7e25dbcf7e040dfdc174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r5BNT1MvGCXXZ2pMZYhbMw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">魔法</figcaption></figure><p id="daf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图中，<code class="fe lf lg lh li b">get</code> <em class="km"> </em>正在创建一个函数，该函数获取一个<strong class="jp ir">用户</strong>对象，提取其<code class="fe lf lg lh li b">friends</code> <em class="km"> </em>属性，过滤出只有<code class="fe lf lg lh li b">goldMember</code> <em class="km"> </em>状态为<code class="fe lf lg lh li b">true</code>的用户，然后从该列表中传递并选择出黄金会员的每个名字。那最终的结果是什么？一个<code class="fe lf lg lh li b">string[]</code>。</p><p id="1282" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更重要的是，<code class="fe lf lg lh li b">get</code>在一个<strong class="jp ir">用户</strong>被传入之前创建了完成所有这些工作的函数。这意味着它不知道它将对一个<strong class="jp ir">用户</strong>进行类型检查。事实上，任何具有<code class="fe lf lg lh li b">friends</code>属性的对象，也就是具有<code class="fe lf lg lh li b">goldMember</code> <em class="km"> </em>和<code class="fe lf lg lh li b">name</code> <em class="km"> </em>属性的对象列表，都可以使用新的getter函数，并且会生成一个列表，其中包含新对象上的<code class="fe lf lg lh li b">name</code>内容。</p><p id="77c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们如何给如此普通的东西赋予一个有意义的类型呢？嗯，如果我们看看这种新型吸气剂，它有点吓人。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lj"><img src="../Images/f78f032f092300f2c35de323b2d6a1d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEZanuCP8ChWJUwejrlccw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">Wowzers</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lk"><img src="../Images/d382d5b269148061c8698c1c424fe3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OF5_o60usk4e2xK1HjJhUg.jpeg"/></div></div></figure><p id="1c25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请继续关注我几分钟，我们将构建一个这个函数类型的完整版本，包括所有的附加功能。如果您从未使用过<em class="km"> shades </em>，请不要担心，我们将从头开始构建一切，我们将慢慢进入这个池，这样我们就不会失去任何人。您所需要的只是熟悉TypeScript及其一些特性。</p><h1 id="7a5d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">婴儿学步</h1><p id="ba87" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我们将从创建一个简化版本的<code class="fe lf lg lh li b">get</code>开始。这个<code class="fe lf lg lh li b">get</code>只接受代表键的字符串，并产生一个新函数，该函数可以接受某个对象并从该对象中提取路径。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/8b294204f6752f4a068ec21605fbeb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*wtfltQ1lRuejA6NupeBwow.png"/></div></figure><p id="16cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始输入之前，我们将创建一个名为<strong class="jp ir"> HasKey </strong>的助手类型，这样就不会太混乱了。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/32ed05854a09cc7f56d31bca66b5151b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*W6eikZBSguQrzqOODnurNg.png"/></div></figure><p id="9763" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> HasKey </strong>是一个<a class="ae kl" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" rel="noopener ugc nofollow" target="_blank">映射类型</a>。它表示一个对象，该对象将某个给定的字符串<code class="fe lf lg lh li b">K</code>映射到某个值。注意，它需要第二个可选参数<code class="fe lf lg lh li b">V</code>，让我们在<code class="fe lf lg lh li b">K</code>指定类型，但它默认为<code class="fe lf lg lh li b">any</code>。</p><p id="91dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果我们想定义一个类型<strong class="jp ir"> HasName </strong>，它有一个映射到<strong class="jp ir">字符串的<code class="fe lf lg lh li b">name</code>属性，</strong>我们可以这样做:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/04d441be5e9876879535e398027f36fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*FIz2dBuHVCDLjTPw9b1u6A.png"/></div></figure><p id="a869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> HasKey </strong>是一个很一般的类型，乍一看好像不是特别有用。诀窍是我们可以在函数中使用它作为约束来保证我们的输入有我们需要的键。有了这些，我们就可以编写我们的第一个<code class="fe lf lg lh li b">get</code> <em class="km"> </em>函数了。</p><h2 id="bcf0" class="mr lm iq bd ln ms mt dn lr mu mv dp lv jy mw mx lz kc my mz md kg na nb mh nc bi translated">V1:线一直往下</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/075c39365ca4accb950e76172fbadb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*PK0lg_SDdoZmYpOZ0IL7mg.png"/></div></figure><p id="8837" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的函数接受一个字符串<code class="fe lf lg lh li b">K</code>并产生一个新函数，该函数接受任何对象<em class="km">，只要该对象</em>将<code class="fe lf lg lh li b">K</code>作为键。这就是<strong class="jp ir"> HasKey </strong>的神奇之处；我们可以用它作为一个<code class="fe lf lg lh li b">extends</code>子句的一部分，来强制我们得到的任何东西都有我们想要的密钥。那么结果类型就是<code class="fe lf lg lh li b">S</code>上<code class="fe lf lg lh li b">K</code>键的类型。</p><p id="bbb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以将这些堆叠在一起，得到嵌套的访问器:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c427585541f76f4c769c07e4b8509de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*3d6zaqN_INARbOfZjD6HuQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">嵌套玩偶</figcaption></figure><p id="7fec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们现在如何使用可选的第二个参数<strong class="jp ir"> HasKey </strong>？我们指定我们的输入<code class="fe lf lg lh li b">S</code>必须是带有某个键<code class="fe lf lg lh li b">K1</code> <em class="km">的对象，它本身是带有某个键<code class="fe lf lg lh li b">K2</code>的对象</em>。我们可以不断重复这个过程，以保证任何数量的关键点和任何深度路径。</p><h1 id="de59" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">s[现在怎么办？]</h1><p id="a175" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">返回类型中的那个<code class="fe lf lg lh li b">S[K]</code>可能不熟悉。它被称为<a class="ae kl" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#index-types" rel="noopener ugc nofollow" target="_blank">指数类型</a>。这是TypeScript的一个内置特性，允许我们在事先不知道某个对象的键的情况下引用该键的类型。虽然它在我们上面的例子中工作得很好，但坏消息是当我们开始将更多抽象路径如<a class="ae kl" href="https://github.com/jamesmcnamara/shades#traversals" rel="noopener ugc nofollow" target="_blank">遍历</a>和<a class="ae kl" href="https://github.com/jamesmcnamara/shades#virtual-lenses" rel="noopener ugc nofollow" target="_blank">虚拟透镜</a>混合到我们的getters中时，它将无法处理。</p><p id="dc71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好消息是，TypeScript为我们提供了滚动我们自己的索引类型所需的工具，这些索引类型将与我们需要的任何值组合一起工作。银弹是<a class="ae kl" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types" rel="noopener ugc nofollow" target="_blank">条件类型</a>。</p><p id="3dad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">条件类型就像类型的if语句。事实上，他们正是如此。它们让你问一个关于类型的问题，并根据答案返回不同的类型。我们可以用它来创建我们自己的索引类型，称为<strong class="jp ir"> KeyAt。</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ne"><img src="../Images/b96a0722e61d4c4e1b3c8b4f368dd8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*19iwlmI0vEep1ArvBCey3w.png"/></div></div></figure><p id="e582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> KeyAt </strong>接受一个对象和一个字符串，而<em class="km">如果</em>该对象将该字符串作为键，则返回该键的类型。如果没有，它只是返回<strong class="jp ir"> never </strong>，一个(顾名思义)永远不可能存在的内置类型。当密钥丢失时，<strong class="jp ir"> KeyAt </strong>仍然可以做<em class="km">某事</em>这一事实将允许我们在这样的情况下使用它:我们<em class="km">知道一个对象将有正确的密钥，但是TS在没有一点帮助的情况下无法证明它。这将是编写更复杂的<code class="fe lf lg lh li b">get</code>函数的关键。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/5e69a55e87bc039fcba85a0694c911b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*MS0Brx-y06K9NBNXuhdyrw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">KeyAt的作用类似于类型的函数</figcaption></figure><h2 id="58c1" class="mr lm iq bd ln ms mt dn lr mu mv dp lv jy mw mx lz kc my mz md kg na nb mh nc bi translated">V2:打他们</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ng"><img src="../Images/9a9dd27252afa5a691784d93ce0077f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUndGfTd6FfrvGoRV1w7yw.png"/></div></div></figure><p id="33da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个版本几乎是相同的，除了它使用了与我们在新的<strong class="jp ir">键</strong>上使用的<strong class="jp ir"> HasKey </strong>相同的嵌套技巧。<strong class="jp ir"> </strong>注意嵌套发生在相反的方向:我们询问什么对象是<code class="fe lf lg lh li b">KeyAt&lt;S, K1&gt;</code>，从结果中我们将提取<code class="fe lf lg lh li b">K2</code>。</p><p id="d886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在已经创建了一个函数，它接受一个或两个字符串，并产生一个访问器函数，该函数可以接受任何具有给定键的对象，并从中提取正确的类型。我们已经创造了一些相当灵活和真实的世界，我们应该给自己拍一下背。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nh kt l"/></div></figure><p id="6ab1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们到了真正要开始用煤气做饭的时候了。</p><h1 id="e263" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">遍历</h1><p id="d7a7" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/jamesmcnamara/shades#traversals" rel="noopener ugc nofollow" target="_blank"> Traversals </a>表示一种方法，用于过滤我们沿途遇到的对象的<em class="km">集合</em>，并继续从集合中的<em class="km">单个</em>对象中提取值，将结果汇总到输出的集合中。例如，在我们的intro中，<code class="fe lf lg lh li b">matching</code>是一个遍历，它过滤掉了<code class="fe lf lg lh li b">friends</code>列表，只过滤了拥有黄金会员身份的用户，然后我们能够将他们的所有名字提取到一个列表中。这种行为在<em class="km">阴影</em>中是最引人注目的，所以我们肯定想看看如何键入它。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/79f59aa4cf91d8b6c53e11dca2fd3e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*_4lHUFDGFLgwd39vYEP6Fw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">什么是<strong class="bd ln">遍历</strong>？嗯这只是一个<strong class="bd ln">遍历</strong></figcaption></figure><p id="84b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">遍历</strong>描述了一个遍历对象的形状。奇怪的是，我们实际上并不需要它来容纳任何东西。它只是作为一个标记，给<code class="fe lf lg lh li b">get</code>一个信号，路径中的这个位置将是<code class="fe lf lg lh li b">Item</code>的集合。正因为如此，我们将能够使用同一个对象来处理任何集合类型(比如一个<strong class="jp ir">数组</strong>，一个<strong class="jp ir">对象</strong>，ES2015 <strong class="jp ir">映射</strong> s和<strong class="jp ir">集合</strong>，甚至是不可变的. js集合)。对于我们的例子，我们将只使用数组来保持简单(目前)。</p><h2 id="60e5" class="mr lm iq bd ln ms mt dn lr mu mv dp lv jy mw mx lz kc my mz md kg na nb mh nc bi translated">V3:遍历和字符串进入酒吧</h2><p id="8fd7" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">让我们从一个激励人心的例子开始。我们将把用户的<code class="fe lf lg lh li b">friends</code>过滤到那些拥有5个以上好友的人，然后将他们的名字提取到一个列表中。我们将使用函数<code class="fe lf lg lh li b">matching</code>进行过滤，该函数从<code class="fe lf lg lh li b">A</code>到<code class="fe lf lg lh li b">boolean</code>接受一个过滤函数，并产生一个<code class="fe lf lg lh li b">Traversal&lt;A&gt;</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/3831098c8ee4dd7a1f2bd4df913125f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*INRwlshRrbOIHjNXjbEyyQ.png"/></div></figure><p id="aa42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始之前，让我们考虑一下这个问题。我们首先要遍历我们的集合，这意味着我们以某种方式过滤数组。但是过滤根本不会改变输出类型的类型，到目前为止，一切顺利。但是接下来我们要提取名字，所以我们会得到一个字符串列表。这方面的天真尝试会遇到问题:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e92f613577024b9859507edb0b951295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*LAes4mFmIsKP0T7MRp-kZw.png"/></div></figure><p id="a59a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在返回类型中从我们的<strong class="jp ir">键处</strong>得到一个<code class="fe lf lg lh li b">never</code>类型。这是因为<code class="fe lf lg lh li b">S</code>并不代表一个<strong class="jp ir">用户</strong>对象。是一个<strong class="jp ir">用户[] </strong>。我们能从中提取的唯一密钥是<code class="fe lf lg lh li b">length</code>、<code class="fe lf lg lh li b">map</code>等。我们可以用一些技巧来解决这个问题:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/cbe1f8031142bdc3d511b3c40cf365ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*mQbitDLvAnZlVvjd_FR5hQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">如果没有类型签名，沃尔多在哪里</figcaption></figure><p id="124c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你看出区别了吗？我们将类型约束<code class="fe lf lg lh li b">S</code>改为集合的<em class="km">元素</em>，然后说我们的输入将是一个数组<code class="fe lf lg lh li b">S</code>。</p><p id="2c90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们知道一个容器将要拥有的结构(在本例中是一个<strong class="jp ir">数组</strong>)并且我们想要约束或引用元素类型时，这种方法非常好用。然而，它有一个很大的缺点，而且，我已经在最后一句话里说过了。它要求我们<em class="km">知道</em>集装箱将要拥有的结构。我们希望能够编写通用函数，能够同时处理许多不同类型的容器，如<strong class="jp ir"> Map </strong> s、<strong class="jp ir"> Set </strong> s、<strong class="jp ir"> Array </strong> s和<strong class="jp ir"> Object </strong> s。为此，我们需要拿出大枪。</p><h1 id="f1dc" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">拆包和收集</h1><p id="bd0d" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">还记得我们之前讨论过的那些条件类型吗？我们可以使用它们来创建一个非常强大的实用程序类型，名为<strong class="jp ir"> Unpack: </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/02ead42361bf6fb32070d9107d9d27ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*Wj8FOWub6OIpaDpscYnoSw.png"/></div></figure><p id="f45b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你首先想到的可能是<code class="fe lf lg lh li b">infer</code>关键字。这是为我们工作的秘方。当我们问一个条件类型的问题时，例如“这是给定的<code class="fe lf lg lh li b">F</code>一个<code class="fe lf lg lh li b">A</code>的数组吗？”我们可能不知道确切的类型<code class="fe lf lg lh li b">A</code>。<code class="fe lf lg lh li b"><a class="ae kl" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types" rel="noopener ugc nofollow" target="_blank">infer</a></code>让我们给我们<em class="km">不知道但TypeScript知道的内部类型命名。因此<strong class="jp ir">解包</strong>所做的是允许我们询问给定对象是否是任意数量的集合类型之一(<strong class="jp ir">数组</strong>、<strong class="jp ir">集合</strong>、<strong class="jp ir">映射</strong>、<strong class="jp ir">承诺</strong>等)。)，并计算出该集合中的<em class="km">是什么类型。</em></em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/80fef3b61723e3ea33bf856b43187ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*tIK-KuSH0PGB7vJAs85Jwg.png"/></div></figure><p id="3f66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们的<code class="fe lf lg lh li b">get</code>函数接受多种类型的容器作为输入的第一步。接下来，让我们创建一个<strong class="jp ir">容器</strong>类型，它将包含我们可能想要遍历的所有集合。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/82fb9a21edb16bd0cf26c51ed5a569cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*1AxCpsSsAuFkVVOdlOjNtw.png"/></div></figure><p id="745f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在，如果我们回到我们的原始V3，用集合<strong class="jp ir">替换所有的<strong class="jp ir">数组</strong>，并放入一个精心放置的<strong class="jp ir">解包</strong>，我们将<em class="km">几乎</em>拥有一些工作的东西。</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi np"><img src="../Images/4ba0135a5196a7080f5f02d61709ee07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2ZXaC9FGza4LSoeIRI8iw.png"/></div></div></figure><p id="1da3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你能看出我们结果的问题吗？</p><p id="40fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TS只知道我们的输出是一个<code class="fe lf lg lh li b">Collection&lt;string, any&gt;</code>，但是我们知道它实际上应该是一个<code class="fe lf lg lh li b">string[]</code>。这个错误是因为，这正是我们告诉它的。</p><h1 id="f2d8" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">高等类型</h1><p id="afdc" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">先来个简短的题外话，说说为什么上面是个问题。想象一下，你正在编写一个版本的<code class="fe lf lg lh li b">Array::map</code>，它适用于各种不同的类型，例如<code class="fe lf lg lh li b">A[] =&gt; B[]</code>和<code class="fe lf lg lh li b">Map&lt;K, A&gt; =&gt; Map&lt;K, B&gt;</code>。你会怎么做？(嘶！如果你想要这个，它的<a class="ae kl" href="https://github.com/jamesmcnamara/shades#map" rel="noopener ugc nofollow" target="_blank">可用</a>在<em class="km">阴影</em>。传统的面向对象方法是创建一个接口<code class="fe lf lg lh li b">Mappable</code>，然后我们为所有的容器类实现<code class="fe lf lg lh li b">Mappable</code>。但是有一个大问题:这将产生与上面相同的问题。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/52ba997c585b6e13cada7d656d76f1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*S90sK9AA8vkWr9MK79tCnw.png"/></div></figure><p id="cd7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接口<strong class="jp ir">mapable</strong>不知道它将要实现的容器类的类型，所以它只是说函数<code class="fe lf lg lh li b">map</code>将返回一个<code class="fe lf lg lh li b">Mappable&lt;B&gt;</code>。当我们在我们的<strong class="jp ir">列表</strong>容器类上实现这个时，我们将类型签名匹配到我们的接口，我们的<code class="fe lf lg lh li b">List::map</code>也返回一个<code class="fe lf lg lh li b">Mappable&lt;B&gt;</code>。但是这意味着我们丢失了类型信息！<code class="fe lf lg lh li b">List::map</code>可以返回任何其他实现<strong class="jp ir">可映射</strong>的类。</p><p id="f7e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更重要的是，这意味着TS不知道<code class="fe lf lg lh li b">out</code>是一个<strong class="jp ir">列表</strong>，所以我们不能在我们的输出上调用任何<strong class="jp ir">列表</strong>方法，或者将它传递给一个期望一个<strong class="jp ir">列表</strong>的函数。如果我们想在数据容器上有一个通用的接口，比如列表<strong class="jp ir">列表</strong> s，<strong class="jp ir">地图</strong> s，<strong class="jp ir">集合</strong> s，等等，这确实是个麻烦。(注意，精通TS的用户可能会注意到，这个确切的用例实际上是可以修复的，但是一般来说，TS不能处理像<code class="fe lf lg lh li b">map</code>这样的功能，我们将把重点放在那些更一般的问题上。)我们真正想要的是这样的东西:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nr"><img src="../Images/0bd9effa4a097d3c85c5b4eda5a60c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1d-5arF4ayPvk2u_PU_VVw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">对容器进行抽象</figcaption></figure><p id="dca4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种能够说<code class="fe lf lg lh li b">F</code>是某种通用容器的想法，我们的函数返回<code class="fe lf lg lh li b">F&lt;A&gt;</code>被称为<strong class="jp ir"> <em class="km">更高级的多态</em> </strong>，是Scala和Haskell等语言的关键部分。唉，TS不支持(<a class="ae kl" href="https://github.com/microsoft/TypeScript/issues/1213" rel="noopener ugc nofollow" target="_blank"> <em class="km">还没</em> </a>)。</p><p id="4e8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们要假装。</p><h1 id="b6e0" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">函子</h1><p id="fbb6" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">最常见的更高级类型是<strong class="jp ir">函子</strong>，它正是上面的<code class="fe lf lg lh li b">Mappable&lt;F, A&gt;</code>:它接受某个类型<code class="fe lf lg lh li b">F&lt;A&gt;</code>，一个<code class="fe lf lg lh li b">(a: A) =&gt; B</code>函数，并返回一个<code class="fe lf lg lh li b">F&lt;B&gt;</code>，<em class="km">，不管那个</em> <code class="fe lf lg lh li b">F</code> <em class="km">是什么。它实际上只是代表了一种你可以调用的类型。如上所述，我们实际上不能在TS中实现这一点，但是我们<em class="km">可以</em>选择我们可能想要映射的所有类型，并编写一个版本的<strong class="jp ir">仿函数</strong>来处理其中的任何一个。怎么会？对于我们的老伙伴条件类型:</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ns"><img src="../Images/444f061b8cce411b73bcbb4a646995e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*f3XWC4zMGmEU7YS_i7XptQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">穷人的函子</figcaption></figure><p id="ed7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用我们的类型<code class="fe lf lg lh li b">F</code>并依次询问它是否是这些容器中的任何一个:<strong class="jp ir">数组</strong>、<strong class="jp ir">对象</strong>、<strong class="jp ir">集合</strong>等等。如果我们得到一个命中结果，我们会指出正确的<code class="fe lf lg lh li b">F&lt;B&gt;</code>返回类型应该是什么。</p><h1 id="f630" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">最终草案</h1><p id="cf94" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">好吧，这是一个漫长的过程，你一直很有耐心。让我们重温一下我们的V3，用我们的<strong class="jp ir">仿函数</strong>增强它:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nt"><img src="../Images/a324d437eef8821954952c789c0ac2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzNsZtJMPfD4UMaahBZLIg.png"/></div></div></figure><p id="497f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有用！</p><p id="0a8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看到底发生了什么变化。我们没有返回一个<strong class="jp ir">集合</strong>，而是使用我们的<strong class="jp ir">仿函数</strong>类来计算出我们想要返回的集合。<strong class="jp ir">函子</strong>想要两个参数:</p><ol class=""><li id="e5e6" class="nu nv iq jp b jq jr ju jv jy nw kc nx kg ny kk nz oa ob oc bi translated">我们正在转换的整个集合对象:<code class="fe lf lg lh li b">S</code>。</li><li id="d152" class="nu nv iq jp b jq od ju oe jy of kc og kg oh kk nz oa ob oc bi translated">集合的新成员类型。这和以前是一样的；我们希望提取出<code class="fe lf lg lh li b">S</code>的成员项上键<code class="fe lf lg lh li b">K</code>的类型。我们使用我们的伙伴<strong class="jp ir">打开</strong>来提取集合<code class="fe lf lg lh li b">S</code>中的任何内容，然后使用<strong class="jp ir"> KeyAt </strong>来获得正确的密钥。</li></ol><p id="0ed5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们后退一步；我们已经逐步做到了这一点，所以它可能看起来还不是很酷。我们有一个函数<code class="fe lf lg lh li b">get</code>，它可以接受一些通用的<strong class="jp ir">遍历</strong>对象和一个随机字符串，并将它们解释为到一些未知对象的抽象路径。我们得到一个函数，它将接受任何与抽象路径匹配的对象，解释该路径对这个对象的意义，并为这个用例构造一个精确而有用的返回类型。</p><p id="c9bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它甚至会捕捉细微的错误！例如，如果我们输入<code class="fe lf lg lh li b">namez</code>而不是<code class="fe lf lg lh li b">name</code>会怎么样？TS将捕获它，并彻底分析出了什么问题:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oi"><img src="../Images/b4ca7668409f23cbb8ca82fa11d7e4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkkC3QMSceQMAO0a3t1YCQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">你不能冒险</figcaption></figure><p id="c46f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TS做了大量的工作，创建了一个足够灵活的类型系统来处理我们JavaScript程序员使用的所有奇怪的技巧。我们只需要舒服地驾驭它那令人敬畏的力量。</p></div></div>    
</body>
</html>