<html>
<head>
<title>Stateful Applications in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中的有状态应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/stateful-applications-in-kubernetes-808a60bc109?source=collection_archive---------0-----------------------#2020-11-05">https://itnext.io/stateful-applications-in-kubernetes-808a60bc109?source=collection_archive---------0-----------------------#2020-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3e51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes以管理无状态服务而闻名，但它并不局限于无状态服务。下面这篇文章收集了我关于在Kubernetes中运行有状态应用程序的笔记。如果您发现任何不准确之处，想要分享您的经验或想要提出更改建议，请随时联系我；)</p><p id="8049" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个地方写下关于有状态应用程序的所有内容是一个过于雄心勃勃的目标。因此，您可以在这里找到简短的陈述，并参考包含每个特定陈述更多详细信息的页面。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5e346c6b42148090a1fcdf3154ecd7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyML8NGyguGVJHBO6zl72A.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://ghibli.fandom.com/wiki/Susuwatari" rel="noopener ugc nofollow" target="_blank"> Susuwatari </a>携带他们的资产<a class="ae lb" href="http://www.ghibli.jp/gallery/chihiro014.jpg" rel="noopener ugc nofollow" target="_blank">吉卜力</a></figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="d6a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有状态应用程序—是一种使用本地文件系统来保存自己的数据的应用程序。在Kubernetes中有两种方法可以运行这样的应用程序:</p><ul class=""><li id="e787" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">StatefulSets — Kubernetes对象，它管理一组pod，并提供关于这些pod的排序和唯一性的保证。</li><li id="649e" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><a class="ae lb" href="https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application/" rel="noopener ugc nofollow" target="_blank">单实例有状态应用</a> —具有单个副本和附加卷的部署对象。就我个人而言，我想象不出任何有效的用例能比使用单个副本的StatefulSet更有价值。</li></ul><p id="d951" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为，要在Kubernetes中运行有状态应用程序，我必须:</p><ul class=""><li id="3314" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">理解什么是状态集合以及如何使用它们；</li><li id="c51e" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">持久层在Kubernetes中是如何表示的；</li><li id="dbae" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">为了正确处理应用程序状态，我必须理解pod生命周期。</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="a9a3" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">1.状态集</h2><p id="8fc9" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">1.1.<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank"> <em class="mv"> StatefulSets </em> </a>为其中的每个pod提供两个稳定的唯一身份:</p><ul class=""><li id="d345" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><em class="mv">网络标识</em>:无论重启次数多少，pod都分配有相同的DNS名称。请注意，IP地址可能仍然不同，因此消费者应该依赖于DNS名称(或者观察变化并更新内部缓存)</li><li id="3766" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="mv">存储标识</em>:相同的网络标识总是接收相同的存储实例，不管它在哪个节点上被重新调度。</li></ul><p id="8bb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.2.每个StatefulSet应该有关联的Kubernetes服务实例来管理其网络身份。如果StatefulSet不需要内部或外部IP的服务，它可以使用<a class="ae lb" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" rel="noopener ugc nofollow" target="_blank">无头服务</a></p><p id="7396" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个pod根据模式接收DNS名称:<code class="fe mw mx my mz b">{statefulset_name}-{0..N-1}.{service_name}.{namespace_name}.svc.cluster.local</code>。比如<code class="fe mw mx my mz b">cassandra-0.cassandra-headless.dev-namespace.svc.cluster.local</code>。</p><p id="f40d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.3.声明集是围绕安全第一原则构建的——在每一个有争议/有问题的情况下，Kubernetes团队都会选择数据安全。例如，默认情况下，当StatefulSet被删除或扩展时，关联的卷不会被删除。</p><p id="7a99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.4.由于StatefulSets处理数据，我们在停止pod实例时应该小心:给足够的时间将数据从内存持久化到磁盘，完成启动的操作，等等。仍然可能有有效的理由执行<a class="ae lb" href="https://kubernetes.io/docs/tasks/run-application/force-delete-stateful-set-pod/" rel="noopener ugc nofollow" target="_blank">强制删除</a>，例如，当<a class="ae lb" href="https://medium.com/tailwinds-navigator/kubernetes-tip-how-statefulsets-behave-differently-than-deployments-when-node-fails-d29e36bca7d5" rel="noopener"> Kubernetes节点失败</a>时。</p><p id="4103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.5.<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#deployment-and-scaling-guarantees" rel="noopener ugc nofollow" target="_blank">部署和升级</a></p><p id="6e97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，StatefulSet按顺序转出:按从0到N-1的顺序创建；从N-1到0终止。可以将其更改为并行模式，但大多数情况下并不需要</p><p id="df9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个有趣的属性，部署参数是<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions" rel="noopener ugc nofollow" target="_blank">分区</a>:它允许金丝雀从盒子中释放。</p><p id="80ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.6.我强烈建议浏览这些精彩的教程:</p><ul class=""><li id="20ac" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><a class="ae lb" href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/" rel="noopener ugc nofollow" target="_blank"> StatefulSet Basics </a>，主要讲述基本操作</li><li id="f31e" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><a class="ae lb" href="https://kubernetes.io/docs/tutorials/stateful-application/zookeeper/" rel="noopener ugc nofollow" target="_blank">运行ZooKeeper </a>，它考虑了一个真实世界的场景，并显示了更高级的主题，例如，pod-affinity和disruption-budget。</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="4d10" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">2.持久卷</h2><p id="0a1b" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">2.1.主要对象:</p><ul class=""><li id="6df6" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><a class="ae lb" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank"> PersistentVolume </a> (PV) —集群中参考物理数据位置的一块存储</li><li id="4279" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><a class="ae lb" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims" rel="noopener ugc nofollow" target="_blank">PersistentVolumeClaim</a>(PVC)—用户的存储请求。通常用于将状态集映射到PVs</li><li id="6cf1" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><a class="ae lb" href="https://kubernetes.io/docs/concepts/storage/storage-classes/" rel="noopener ugc nofollow" target="_blank"> StorageClass </a>定义PV的参数:provisioner (AzureDisk、AWSElasticBlockStore等)、回收策略、允许调整大小等</li></ul><blockquote class="na nb nc"><p id="ea26" class="jn jo mv jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">它类似于一个豆荚。Pods消耗节点资源，PV消耗PV资源。Pods可以请求特定级别的资源(CPU和内存)。声明可以请求特定的大小和访问模式</p></blockquote><p id="6eea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.2.卷配置:</p><ul class=""><li id="2c6a" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><em class="mv">静态</em>:管理员预先创建卷和PV，然后PVC消耗现有PV。</li><li id="74f1" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="mv">动态</em>:创建PVC时，集群尝试配置卷。</li></ul><p id="2187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当没有定义<em class="mv">存储类</em>时，集群使用<code class="fe mw mx my mz b">DefaultStorageClass</code></p><p id="94a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.3.<a class="ae lb" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reclaiming" rel="noopener ugc nofollow" target="_blank">回收</a></p><p id="830d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有以下回收政策:</p><ul class=""><li id="4053" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><em class="mv">保留</em>:如果PVC被删除，PV会保留，但对其他用户不可用(因为可能会有数据！).操作员应决定如何处理卷:按原样将其分配给新的pod，在分配前清理或删除。</li><li id="b9d3" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="mv">删除</em>:从Kubernetes中删除<em class="mv"> PersistentVolume </em>对象，以及外部基础设施中的相关存储资产(并非所有提供商都支持)</li></ul><p id="f7fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.4.卷插件:</p><ul class=""><li id="5e91" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><em class="mv"> in-tree </em>:源代码在主Kubernetes git-repository中</li><li id="f0ed" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="mv">树外</em>:插件，使存储供应商能够创建定制的存储插件，而无需将其插件源代码添加到Kubernetes存储库:<a class="ae lb" href="https://github.com/container-storage-interface/spec/blob/master/spec.md" rel="noopener ugc nofollow" target="_blank">容器存储接口</a> (CSI)和FlexVolume</li></ul><p id="2b78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很可能，CSI是Kubernetes的未来，但并不是每个人都支持它(例如，目前亚马逊EBS <a class="ae lb" href="https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html" rel="noopener ugc nofollow" target="_blank"> CSI驱动程序处于测试阶段</a>，Azure只有预览版中的<a class="ae lb" href="https://docs.microsoft.com/en-us/azure/aks/azure-disk-csi" rel="noopener ugc nofollow" target="_blank"> CSI驱动程序)。此外，CSI卷可以在PVC创建时被克隆。</a></p><p id="2cd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.5.<a class="ae lb" href="https://kubernetes.io/docs/concepts/storage/volume-snapshots" rel="noopener ugc nofollow" target="_blank">卷快照</a>(1.17中的测试版)</p><ul class=""><li id="8f1d" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">如<em class="mv">持续卷</em>和<em class="mv">持续卷声明</em> — <em class="mv">卷快照内容</em>和<em class="mv">卷快照</em></li><li id="4161" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">可以被安排</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="09e1" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">3.Pod生命周期</h2><p id="f059" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">3.1.通常，在StatefulSet中，我们运行更复杂的应用程序，需要预热、领导者选举、数据处理等。因此，StatefulSet中的pod可能对如何开始/停止、何时接收流量等有特殊的要求。</p><p id="e999" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为，一旦你不得不使用状态集，你就必须仔细阅读<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" rel="noopener ugc nofollow" target="_blank"> Pod生命周期文档</a>，它解释了所有可能的状态以及它们之间的转换</p><p id="c41c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.2.<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes" rel="noopener ugc nofollow" target="_blank">探头</a>:</p><ul class=""><li id="2788" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><code class="fe mw mx my mz b">startupProbe</code>表示pod准备好接收其他探针的时间。该探针仅在开始时执行，而接下来的两个探针在整个pod生命周期内执行</li><li id="ab90" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe mw mx my mz b">livenessProbe</code>表示容器是否正在运行。当探针出现故障时— pod重新启动。</li><li id="16d4" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe mw mx my mz b">readinessProbe</code>表示pod是否应该接收入口流量。当探针出现故障时— pod从端点移除(例如iptables)</li></ul><p id="718a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.3.<a class="ae lb" href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks" rel="noopener ugc nofollow" target="_blank">挂钩</a></p><ul class=""><li id="0efc" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><code class="fe mw mx my mz b">PostStart</code>钩子在容器创建后立即执行(甚至可能在容器入口点之前！)</li><li id="0aed" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe mw mx my mz b">PreStop</code>这个钩子在容器终止之前被调用。可能有助于准备终止pod:停止接收新请求，将内存中的数据转储到磁盘，等等。</li></ul><p id="9e0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.4.<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination" rel="noopener ugc nofollow" target="_blank"> Pod终止</a></p><p id="affb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当API服务器收到删除Pod的命令时，它:</p><ul class=""><li id="0351" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">更新<em class="mv">端点</em>，导致iptables、Ingress和DNS发生变化</li><li id="fc4f" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">向<em class="mv"> kubelet </em>发送命令以停止pod，这将调用<em class="mv"> preStop </em>钩子并等待<em class="mv">terminationgraceperiodes</em>秒(默认为30秒)</li></ul><p id="5766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于pod正常关闭的非常详细的解释:【https://learnk8s.io/graceful-shutdown.<a class="ae lb" href="https://learnk8s.io/graceful-shutdown." rel="noopener ugc nofollow" target="_blank"/>它给出了很好的可视化效果，并在最后提出了一个有趣的模式来处理长时间运行的pod:在新版本发布期间，不是更新相同的部署，而是创建一个新的部署(我不想重复文章内容，如果你很好奇，可以去看看)。</p><p id="c82e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.5.<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/" rel="noopener ugc nofollow" target="_blank">中断</a>可能是:</p><ul class=""><li id="7eba" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><em class="mv">自愿</em>:删除部署或吊舱、秤等</li><li id="9131" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><em class="mv">非自愿</em>:虚拟机故障，硬件故障，<a class="ae lb" href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/" rel="noopener ugc nofollow" target="_blank"> OOM </a></li></ul><p id="c231" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了减少中断:</p><ul class=""><li id="023e" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">使用资源配额</li><li id="5100" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">复制应用程序</li><li id="2659" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">使用<a class="ae lb" href="https://kubernetes.io/docs/tasks/run-application/configure-pdb/" rel="noopener ugc nofollow" target="_blank">中断预算</a></li></ul><p id="f7ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">借助中断预算，您可以:</p><ul class=""><li id="201f" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">定义最小可用或最大不可用的实例数量；</li><li id="5847" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">除非中断预算被消除，否则防止任何重新安排</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="c019" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">4.多方面的</h2><p id="7462" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">以下主题不属于以上任何一组，但仍然值得一提</p><p id="07f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.1.最初，状态集被命名为<a class="ae lb" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/apps/stateful-apps.md#history" rel="noopener ugc nofollow" target="_blank">petset</a></p><p id="903c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">4.2.</p><blockquote class="na nb nc"><p id="294b" class="jn jo mv jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">在相应的后端工作负载之前创建服务</p></blockquote><ul class=""><li id="9533" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">k8s在创建时为每个容器提供带有服务主机/端口的环境变量，如果pod是在服务之前创建的—没有环境变量</li><li id="54fe" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">服务创建导致新的DNS记录。如果pod在创建服务之前查询DNS不存在的结果会被缓存一段时间</li></ul><p id="bd65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.3.<code class="fe mw mx my mz b">imagePullPolicy: Always</code>并不是每次都随便拉图。它每次都会查询容器注册表，并且仅当(a)映像不在本地虚拟机缓存中或者(b)本地缓存的映像摘要与容器注册表中的不同时，才会提取映像。</p><p id="fb04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">4.4.</p><blockquote class="na nb nc"><p id="217b" class="jn jo mv jp b jq jr js jt ju jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj kk ij bi translated">支持所有权管理的卷被修改为由fsGroup中指定的GID拥有和可写</p></blockquote><p id="def0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，您可以使用<code class="fe mw mx my mz b">securityContext.fsGroup</code>,而不是编写定制的所有权变更脚本</p></div></div>    
</body>
</html>