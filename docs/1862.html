<html>
<head>
<title>Easy patterns: Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单模式:代理</h1>
<blockquote>原文：<a href="https://itnext.io/easy-patterns-proxy-45fc3a648020?source=collection_archive---------12-----------------------#2019-02-11">https://itnext.io/easy-patterns-proxy-45fc3a648020?source=collection_archive---------12-----------------------#2019-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bd7393f7387d83c9e863123cddc0b00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aOHbP1nUix0lxyS7hi03ZA.png"/></div></div></figure><p id="dc4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是easy patterns系列描述的延续，介绍了一个名为Proxy的结构模式，它为另一个对象提供了一个占位符来控制对它的访问。</p><p id="cd30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也请参考其他模式文章:</p><h2 id="f002" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">创作模式:</h2><blockquote class="lp lq lr"><p id="fa0f" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-simple-factory-b946a086fd7e"> <strong class="ka ir">简易工厂</strong> </a></p><p id="2004" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-factory-method-5f27385ac5c"> <strong class="ka ir">工厂法</strong> </a></p><p id="8fab" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-builder-d85655bcf8aa"> <strong class="ka ir">建造者</strong> </a></p><p id="0e6b" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-singleton-283356fb29bf"> <strong class="ka ir">单个</strong> </a></p><p id="73db" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-abstract-factory-2325cb398fc6"> <strong class="ka ir">抽象工厂</strong> </a></p><p id="9d90" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-prototype-e03ec6962f89"> <strong class="ka ir">原型</strong> </a></p></blockquote><h2 id="b2ad" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结构模式:</h2><blockquote class="lp lq lr"><p id="4425" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-adapter-9b5806cb346f"> <strong class="ka ir">适配器</strong> </a></p><p id="5343" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-decorator-eaa96c0550ea"> <strong class="ka ir">装饰者</strong> </a></p><p id="a7f3" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-bridge-28d50dc25f9f"> <strong class="ka ir">桥</strong> </a></p><p id="2353" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158"> <strong class="ka ir">复合</strong> </a></p><p id="2cca" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-facade-8cb185f4f44f"> <strong class="ka ir">立面</strong> </a></p><p id="9d1e" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-flyweight-dab4c018f7f5"> <strong class="ka ir">飞锤</strong> </a></p><p id="797a" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-proxy-45fc3a648020"> <strong class="ka ir">代理</strong> </a>(本文)</p></blockquote><h2 id="c975" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">行为模式:</h2><blockquote class="lp lq lr"><p id="052a" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-visitor-b8ef57eb957"> <strong class="ka ir">来访者</strong> </a></p><p id="8f4d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-mediator-e0bf18fefdf9"> <strong class="ka ir">调解员</strong> </a></p><p id="ee43" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-observer-63c832d41ffd"> <strong class="ka ir">观察者</strong> </a></p><p id="2da6" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-memento-ce966cec7478"> <strong class="ka ir">纪念品</strong> </a></p><p id="e199" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-iterator-f5c0dd85957"> <strong class="ka ir">迭代器</strong> </a></p><p id="f257" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-chain-of-responsibility-9a84307ad837"> <strong class="ka ir">责任链</strong> </a></p><p id="e67d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-strategy-ecb6f6fc0ef3"> <strong class="ka ir">策略</strong> </a></p><p id="07ca" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-state-ec87a1a487b4"> <strong class="ka ir">状态</strong> </a></p></blockquote><h1 id="d753" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">主要本质</h1><p id="b206" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">代理模式在需要比简单指针更通用、更复杂的对象引用的情况下非常有用。代理在适当的时候将请求转发给主题，这取决于代理的类型。</p><p id="c597" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些常见的代理有:</p><ul class=""><li id="b0df" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><strong class="ka ir">远程代理</strong> —提供某个远程对象的本地表示(例如，在将数据发送到服务器之前收集一些数据块进行保存，以避免网络的额外负载)</li><li id="45d2" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">虚拟代理——用轻量级表示代替昂贵的对象。仅在需要时创建这种昂贵的对象(例如图像占位符。用户滚动到文档中的适当位置，只有在这种情况下，我们才应该加载相当大的图片)</li><li id="6c68" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">一个<strong class="ka ir">保护代理</strong> —控制对原始对象的访问(例如，在对某些功能具有单独访问权限的情况下，如具有授权分离的某些内容)</li><li id="ef4c" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">一个<strong class="ka ir">智能引用</strong>——控制主题是否应该被锁定(由于其他用户的编辑过程)或计算主题的点击次数等</li></ul><p id="ebe6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种模式包括两个主要角色:</p><ul class=""><li id="fd23" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><strong class="ka ir">代理</strong> —维护一个引用，允许代理访问真实主体，提供一个与主体相同的接口用于合法替换，并控制对被替换主体的访问。</li><li id="b503" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><strong class="ka ir">主题</strong>—定义代理代表的对象。</li></ul><p id="0dba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种模式也被称为<strong class="ka ir">代理</strong>。</p><p id="c7b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript语言中，有一个名为Proxy的特殊类。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="d0c6" class="kw kx iq nm b gy nq nr l ns nt">const proxyObject = new Proxy(subject, handlerObject);<br/>// subject - target object<br/>// handlerObject - object with a traps (hooks) for a specific operations with a subject</span></pre><p id="e0ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在这里描述一些陷阱:</p><ul class=""><li id="76f8" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><code class="fe nu nv nw nm b">get(target, property, receiver)</code> —当<code class="fe nu nv nw nm b">target</code>对象的特定<code class="fe nu nv nw nm b">property</code>为红色时触发。<code class="fe nu nv nw nm b">receiver</code>在大多数情况下是代理本身。</li><li id="cca0" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><code class="fe nu nv nw nm b">set(target, property, receiver)</code> —在写入代理的情况下触发。</li><li id="05e1" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><code class="fe nu nv nw nm b">has(target, query)</code> —在目标对象中检查到属性存在时触发。(操作员<code class="fe nu nv nw nm b">in</code>)</li></ul><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="5a56" class="kw kx iq nm b gy nq nr l ns nt">const subject = {<br/>  name: 'Pavel',<br/>  age: 20<br/>};</span><span id="d5d5" class="kw kx iq nm b gy nx nr l ns nt">const proxyObject = new Proxy(subject, {<br/>  has(target, property) {<br/>    console.log(`${property} is accessed`);<br/>    return true;<br/>  }<br/>});</span><span id="f388" class="kw kx iq nm b gy nx nr l ns nt">console.log('someNonExistingProp' in proxyObject); // true</span></pre><ul class=""><li id="92fd" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><code class="fe nu nv nw nm b">deleteProperty</code> —在<code class="fe nu nv nw nm b">delete</code>操作时触发。如果删除成功，应该返回true</li><li id="7a8b" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><code class="fe nu nv nw nm b">apply(target, thisArg, argsList)</code> —当代理对象是一个函数时，在调用它之后立即触发。<code class="fe nu nv nw nm b">thisArg</code>是调用的上下文(<code class="fe nu nv nw nm b">this</code>)，而<code class="fe nu nv nw nm b">argsList</code>是传递给函数的参数列表</li><li id="8f32" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><code class="fe nu nv nw nm b">construct(target, argsList)</code> —实例化流程出现时触发(带<code class="fe nu nv nw nm b">new</code>运算符)。</li></ul><p id="91c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于代理类实现的所有列表和更多信息你可以在这里找到<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="c045" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">使用示例</h1><p id="9fb6" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">让我们创建一个具有内部状态(<code class="fe nu nv nw nm b">isOn</code>)和两个控制开关的咖啡机。代理的职责是控制对这些方法的访问——如果机器已经打开，就没有必要再打开。机器关闭时的情况也是如此。在这种情况下，我们希望向用户显示机器已经打开或关闭的消息，而无需任何进一步的操作。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9262" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个简单的<strong class="ka ir">访问代理</strong>的例子。</p><h1 id="f230" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">利润</h1><p id="72e7" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><strong class="ka ir">当访问一个对象时，代理模式引入了一个间接层。</strong></p><p id="6135" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种间接方式有许多用途:</p><ul class=""><li id="fd54" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">保护代理允许控制访问过程</li><li id="7b21" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">智能引用代理允许收集关于主题使用的信息</li><li id="ff93" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">虚拟代理可以执行各种优化(比如按需创建对象和避免系统过载)</li><li id="f91a" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">远程代理可以从不同的地址空间提供对远程对象的访问</li></ul><p id="447f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一种有用的方法叫做<strong class="ka ir">写时复制</strong>优化。这与按需创作有关。复制一个大而复杂的对象可能是一个昂贵的操作，如果副本从不被修改，那么这样的成本是没有用的。使用这种方法，我们确保只有在需要返回被修改的复杂对象时才使用复制过程。如果没有，我们应该只返回一个到现有链接的链接，并增加对它的引用计数。</p><h1 id="299c" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">薄弱的地方</h1><p id="c2f6" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><strong class="ka ir">当访问一个对象时，代理模式引入了一个间接层。</strong></p><p id="04e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这会导致创建额外的实例，在一些简单的情况下，这可能是一种开销。</p><h1 id="bdc1" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">结论</h1><p id="d8af" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">代理模式的主要协作:它根据代理的种类，在适当的时候将请求转发给Subject。</p><p id="3a1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代理模式有几种常见的用例:</p><ul class=""><li id="8249" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">远程代理</li><li id="bc04" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">虚拟代理</li><li id="3c6f" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">保护代理</li><li id="0015" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">智能引用代理</li></ul><p id="e229" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代理对象包装主题本身。通常，为了安全起见，您甚至可以重写一个指向原始主题的链接:</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="8545" class="kw kx iq nm b gy nq nr l ns nt">let payload = {<br/>  name: 'Pavel',<br/>  age: 20<br/>};</span><span id="1f9f" class="kw kx iq nm b gy nx nr l ns nt">payload = new Proxy(payload, {<br/>  ... // some proxy hooks<br/>});</span><span id="e84f" class="kw kx iq nm b gy nx nr l ns nt">// payload object here is already wrapped by proxy</span></pre><p id="6513" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一些其他相关的设计模式，如<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-adapter-9b5806cb346f">适配器</a>和<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-decorator-eaa96c0550ea">装饰器</a>。</p><p id="36c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">适配器</strong>为它所适配的对象提供不同的接口，而代理为它的主体提供相同的接口。并且代理模式也用于可以拒绝执行操作的访问保护。</p><p id="6f7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">装饰器向对象添加一个或多个职责，而代理控制对包装对象的访问。然而，装饰者可以拥有与代理类似的实现。</p><p id="7649" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您觉得这篇文章有帮助，请点击👏按钮并在下面随意评论！</p></div></div>    
</body>
</html>