<html>
<head>
<title>Testing APIs using advanced REST client. Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用高级REST客户端测试API。第三部分</h1>
<blockquote>原文：<a href="https://itnext.io/testing-apis-using-advanced-rest-client-part-iii-173906d7abea?source=collection_archive---------2-----------------------#2019-06-25">https://itnext.io/testing-apis-using-advanced-rest-client-part-iii-173906d7abea?source=collection_archive---------2-----------------------#2019-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/70a8661f77504fd0ee23c8f67a3864c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r04qzIs5FznuoZU1kR9BJA.jpeg"/></div></div></figure><p id="5fb4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">翻新</strong>是一个类型安全的Java HTTP客户端。它是在客户机-服务器应用程序中使用API不可或缺的工具。我个人在工作中很少使用这个库。主要是因为大多数情况下这个库都是在Android开发环境中使用的。</p><p id="374f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该库提供了一种使用接口的改进方法。你不写代码本身，你写一个描述，即宣布他将能够。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="7319" class="li lj it le b gy lk ll l lm ln"><strong class="le iu">public interface </strong>UserService {<br/>    @FormUrlEncoded<br/>    @Post(<strong class="le iu">"/users"</strong>)<br/>    @Header(<strong class="le iu">"ContentType: application/json"</strong>)<br/>    Response&lt;User&gt; createUser(@Field(<strong class="le iu">"id"</strong>) String id,<br/>                              @Field(<strong class="le iu">"name"</strong>) String name,<br/>                              @Field(<strong class="le iu">"username"</strong>) String username,<br/>                              @Field(<strong class="le iu">"email"</strong>) String email);<br/>}</span></pre><p id="a664" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，我们创建了用户服务，并为这个服务指定了一个方法。此方法创建一个用户。请求的url被传递给post注释。我们还传递我们需要的关于头部的信息。由于参数指定我们将有电子邮件和密码。从这个例子中可以看出，这是一个非常简单的声明性描述，允许我们几乎不使用代码就可以发出HTTP请求。</p><p id="8369" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要使用翻新，您将需要以下三个类:</p><ul class=""><li id="6347" class="lo lp it kd b ke kf ki kj km lq kq lr ku ls ky lt lu lv lw bi translated">用作JSON模型的模型类</li><li id="24ed" class="lo lp it kd b ke lx ki ly km lz kq ma ku mb ky lt lu lv lw bi translated">定义可能的HTTP操作的接口</li><li id="eea8" class="lo lp it kd b ke lx ki ly km lz kq ma ku mb ky lt lu lv lw bi translated">阶级改造。构建器—使用构建器接口和API为HTTP操作定义url端点定义的实例</li></ul><p id="0b30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">改造可以两种方式连接:Gradle或Maven。</p><p id="4196" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Gradle </strong> <br/>连接到构建文件。Gradle在应用程序模块的dependencies部分插入一行:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="ea1b" class="li lj it le b gy lk ll l lm ln">implementation 'com.squareup.retrofit2:retrofit:2.6.0'</span></pre><p id="3267" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Maven </strong> <br/> <br/>如果使用Maven，依赖片段会是这样的:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="1b62" class="li lj it le b gy lk ll l lm ln">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.squareup.retrofit2&lt;/groupId&gt;<br/>  &lt;artifactId&gt;retrofit&lt;/artifactId&gt;<br/>  &lt;version&gt;2.6.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="db63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个接口方法都是可能的API调用之一。它必须有HTTP注释(GET、POST等。)来指定请求类型和相对URL。返回值以预期的结果类型完成Call对象中的响应。</p><p id="eb6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，为了表明需要一个<strong class="kd iu"> GET </strong>请求，我们需要在方法之前编写一个<strong class="kd iu"> GET </strong>注释:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="e8c4" class="li lj it le b gy lk ll l lm ln"><strong class="le iu">public interface </strong>UserService{<br/>    @GET(<strong class="le iu">"/users"</strong>)<br/>    Call&lt;List&lt;User&gt;&gt; getUsers();<br/>}</span></pre><p id="eed7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用占位符块和查询参数来自定义URL。使用{}将替换块添加到相对URL。对方法参数使用@Path注释，该参数的值被绑定到特定的替换块。</p><p id="91c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想发送一个带有参数的请求，那么在Retrofit()中有一个@Query注释:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="b7fc" class="li lj it le b gy lk ll l lm ln"><strong class="le iu">public interface </strong>UserService {<br/>    @GET(<strong class="le iu">"/posts"</strong>)<br/>    <strong class="le iu">public </strong>Call&lt;List&lt;Post&gt;&gt; getPostOfUser(@Query(<strong class="le iu">"Id"</strong>) <strong class="le iu">int </strong>id);<br/>}</span></pre><p id="8705" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了形成该方法的查询体，我们对传递的参数使用@Body注释。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="f298" class="li lj it le b gy lk ll l lm ln"><strong class="le iu">public interface </strong>UserService{<br/>    @POST(<strong class="le iu">"/users/new"</strong>)<br/>    Call&lt;User&gt; createUser(@Body User user);<br/>}</span></pre><p id="1a78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">改造可以自动转换Java对象到JSON和回来。她还知道如何使用XML、协议缓冲区等</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="1d27" class="li lj it le b gy lk ll l lm ln"><strong class="le iu">public interface </strong>UserService{<br/>    @PUT(<strong class="le iu">"/users"</strong>)<br/>    Response&lt;User&gt; getUser(@Body User user);<br/>}</span></pre><p id="3a8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下示例显示了翻新如何与集管一起工作:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="c945" class="li lj it le b gy lk ll l lm ln"><strong class="le iu">public interface </strong>UserService {<br/>    @Headers({<br/> <strong class="le iu">"ContentType:application/json"</strong>,<strong class="le iu">"User-Agent: Retrofit-Sample-App" </strong>})<br/>    @GET(<strong class="le iu">"/service/me"</strong>) Response getMe();<br/>}</span></pre><p id="8e3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目标地址放在请求类型的括号中。但是一个描述并不以注释结束，这些注释必须被描述。并将抽象描述为接口(interface)中的规则。下面描述基于GET和DELETE请求的示例。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="15b0" class="li lj it le b gy lk ll l lm ln"><strong class="le iu">public interface </strong>UserService {<br/>    @FormUrlEncoded<br/>    @POST(<strong class="le iu">"/users"</strong>)<br/>    Response createUser(@Field(<strong class="le iu">"id"</strong>) String id,<br/>                        @Field(<strong class="le iu">"name"</strong>) String name,<br/>                        @Field(<strong class="le iu">"username"</strong>) String username,<br/>                        @Field(<strong class="le iu">"email"</strong>) String email);<br/><br/>    @GET(<strong class="le iu">"/users/{id}"</strong>)<br/>    Response getUser(@Path(<strong class="le iu">"id"</strong>) String id);<br/><br/>    @DELETE(<strong class="le iu">"/service/users/{id}"</strong>)<br/>    Response deleteUser(@Path(<strong class="le iu">"id"</strong>) String id);<br/>}</span></pre><p id="e471" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个界面描述了我们工作中需要的所有功能:创建、读取和删除用户。</p><p id="1186" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们应用“魔术”改造。创建<strong class="kd iu">改型</strong>，指定我们将使用Gson(以便在Java中修改JSON对象并返回)，指定基本url，并创建我们接口的实例。在返回我们接口的实例后，我们将能够完全使用我们的Java API。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="d91f" class="li lj it le b gy lk ll l lm ln"><strong class="le iu">public static </strong>UserService createUserService() {<br/><br/>    Gson gson = <strong class="le iu">new </strong>GsonBuilder()<br/>            .setDateFormat(<strong class="le iu">"yyyy-MM-dd'T'HH:mm:ssZ"</strong>)<br/>            .create();<br/><br/>    Retrofit retrofit = <strong class="le iu">new </strong>Retrofit().Builder()<br/>            .baseUrl(<strong class="le iu">"https://api.company.com/"</strong>)<br/>            .addConverterFactory(GsonConverterFactory.create(gson))<br/>            .build();<br/>    <br/>    <strong class="le iu">return </strong>retrofit.create(UserService.<strong class="le iu">class</strong>);<br/>}</span></pre><p id="6ba0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在自动化脚本中，您可以如下使用<strong class="kd iu">改型</strong>库:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="938d" class="li lj it le b gy lk ll l lm ln"><strong class="le iu">public class </strong>SimpleTest {<br/>    <strong class="le iu">private </strong>UserService <strong class="le iu">userService </strong>= createUserService();<br/>    <strong class="le iu">private </strong>User <strong class="le iu">user</strong>;<br/><br/>    @Before<br/>    <strong class="le iu">public void </strong>createUser() {<br/>        <strong class="le iu">user </strong>= <strong class="le iu">userService</strong>.createUser(randomEmail(), randomPassword());<br/>    }<br/><br/>    @Test<br/>    <strong class="le iu">public void </strong>testUserPage() {…}<br/><br/>    @After<br/>    <strong class="le iu">public void </strong>deleteUser() {<br/>        <strong class="le iu">userService</strong>.deleteUser(<strong class="le iu">user</strong>.getId());<br/>    }<br/>}</span></pre><p id="21d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们创建了一个用户服务。在测试运行之前，通过调用createUser方法创建一个用户。测试运行后，用户被删除。</p><p id="f0d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">改进</strong>允许你以两种方式查询和检索数据——同步和异步。<br/> <br/>对于同步(阻塞)接收，我们对Call类型的对象使用execute()方法。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="fbf1" class="li lj it le b gy lk ll l lm ln">Response <strong class="le iu">response </strong>= App.getApi().getData(<strong class="le iu">"users"</strong>, 50).execute();</span></pre><p id="2ca0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该执行返回一个类型为Response的对象，从中可以通过body()方法获得一个经过解析的响应。</p><p id="a7b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于异步接收，必须替换execute() enqueue()，其中的参数传递给回调函数。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="27ce" class="li lj it le b gy lk ll l lm ln">App.getApi().getData(<strong class="le iu">"bash"</strong>, 50).enqueue(<strong class="le iu">new </strong>Callback&lt;List&lt;PostModel&gt;&gt;() {<br/>     @Override<br/>     <strong class="le iu">public void </strong>onResponse(Call&lt;List&lt;PostModel&gt;&gt; call, Response&lt;List&lt;PostModel&gt;&gt; response) {<br/>         <em class="mc">//check response.body() on null<br/>     </em>}<br/>     @Override<br/>     <strong class="le iu">public void </strong>onFailure(Call&lt;List&lt;PostModel&gt;&gt; call, Throwable t) {<br/>         <em class="mc">//Error<br/>     </em>}<br/> });</span></pre><p id="bb0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">改装实际上有很多可能性，但是有一个小缺点。很遗憾，此库不允许传输文件列表。</p><p id="c56e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，这就是我在这篇文章中想说的。我自己的一些想法:因为有大量的库，我的项目使用Spring和与之相关的所有东西，但是如果我现在必须写一个客户端，我会选择Groovy，因为所有的东西都简单、容易和快速。</p></div></div>    
</body>
</html>