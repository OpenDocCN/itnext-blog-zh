<html>
<head>
<title>Refactoring in Swift: Setup Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的重构:设置闭包</h1>
<blockquote>原文：<a href="https://itnext.io/refactoring-in-swift-setup-closures-d06b896c412c?source=collection_archive---------0-----------------------#2018-09-09">https://itnext.io/refactoring-in-swift-setup-closures-d06b896c412c?source=collection_archive---------0-----------------------#2018-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="79d0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">快速了解一个简单的函数如何让你的设置闭包更加整洁</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0fc905d91bd9012c1f475e09e2067add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5k5noaA_d9o4ie2-fCDdg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">简洁！</figcaption></figure><p id="e700" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">视图控制器顶部的一个经典场景是正在实例化的视图列表，以及在每个视图上设置的一些属性:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="1697" class="lw lx iq ls b gy ly lz l ma mb">let contentView: UIView = {<br/>    let v = UIView()<br/>    v.backgroundColor = .red<br/>    v.clipsToBounds = true<br/>    return v<br/>}()</span><span id="d8ed" class="lw lx iq ls b gy mc lz l ma mb">let titleLabel: UILabel = {<br/>    let l = UILabel()<br/>    l.font = .systemFont(ofSize: 22)<br/>    l.textColor = .red<br/>    l.text = "WELCOME"<br/>    return l<br/>}()</span><span id="d5e0" class="lw lx iq ls b gy mc lz l ma mb">let stackView: UIStackView = {<br/>    let s = UIStackView()<br/>    s.axis = .vertical<br/>    s.distribution = .fillEqually<br/>    s.alignment = .center<br/>    s.spacing = 8<br/>    return s<br/>}()</span></pre><p id="de40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我查看这些代码时，我不禁觉得其中有一些冗余和重复的信息，具体来说:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/063f014ff01ceb9fe5f40c86eb3b8345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNrABs7fIJooKaw2mW1YAQ.png"/></div></div></figure><p id="397b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我创建了一个函数，可以用来使设置闭包变得更加整洁:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="39e0" class="lw lx iq ls b gy ly lz l ma mb">func create&lt;T&gt;(_ setup: ((T) -&gt; Void)) -&gt; T where T: NSObject {<br/>    let obj = T()<br/>    setup(obj)<br/>    return obj<br/>}</span></pre><p id="e5e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数位于一切之上，可以实例化任何不需要传递给它的<code class="fe me mf mg ls b">init</code>的参数的<code class="fe me mf mg ls b">NSObject</code>子类。现在，如果我们要重写我们的设置闭包列表，它将只有编译器要求的最低限度的搭建:</p><pre class="kg kh ki kj gt lr ls lt lu aw lv bi"><span id="90f9" class="lw lx iq ls b gy ly lz l ma mb">let contentView: UIView = create {<br/>    $0.backgroundColor = .red<br/>    $0.clipsToBounds = true<br/>}</span><span id="10c3" class="lw lx iq ls b gy mc lz l ma mb">let titleLabel: UILabel = create {<br/>    $0.font = .systemFont(ofSize: 22)<br/>    $0.textColor = .red<br/>    $0.text = "WELCOME"<br/>}</span><span id="58f9" class="lw lx iq ls b gy mc lz l ma mb">let stackView: UIStackView = create {<br/>    $0.axis = .vertical<br/>    $0.distribution = .fillEqually<br/>    $0.alignment = .center<br/>    $0.spacing = 8<br/>}</span></pre><p id="48eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这通过利用以下Swift语言功能来实现:</p><ul class=""><li id="62fe" class="mh mi iq kx b ky kz lb lc le mj li mk lm ml lq mm mn mo mp bi translated">函数的返回值一般可以通过它被赋值的类型来推断，例如<code class="fe me mf mg ls b">func x&lt;ReturnType&gt;() -&gt; ReturnType</code></li><li id="f2ba" class="mh mi iq kx b ky mq lb mr le ms li mt lm mu lq mm mn mo mp bi translated">函数的最后一个闭包参数可以写成函数外部的闭包，例如<code class="fe me mf mg ls b">array.forEach { … }</code></li><li id="5ad0" class="mh mi iq kx b ky mq lb mr le ms li mt lm mu lq mm mn mo mp bi translated">闭包参数不需要命名；也可以用<code class="fe me mf mg ls b">$0</code>来代替，例如<code class="fe me mf mg ls b">array.compactMap { $0 }</code></li></ul><p id="eb1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以现在属性的类型只需要出现一次，我们不需要在一个闭包的范围内创建一个我们立即调用的变量！</p></div></div>    
</body>
</html>