<html>
<head>
<title>Docker inside Docker for Jenkins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">詹金斯的码头工人</h1>
<blockquote>原文：<a href="https://itnext.io/docker-inside-docker-for-jenkins-d906b7b5f527?source=collection_archive---------0-----------------------#2020-09-01">https://itnext.io/docker-inside-docker-for-jenkins-d906b7b5f527?source=collection_archive---------0-----------------------#2020-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9a36a946d65409ccc4167f51d3d698a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kaHKTC1VOY8Ct1dMAKm_Hw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.reddit.com/user/SaladDayZ/" rel="noopener ugc nofollow" target="_blank"> SaladDayZ </a>原图发布于<a class="ae kc" href="https://www.reddit.com/r/mildlyinteresting/comments/3gmenb/this_is_what_shipping_containers_look_like/" rel="noopener ugc nofollow" target="_blank">https://www . Reddit . com/r/mildlyinterising/comments/3g menb/this _ is _ what _ shipping _ containers _ look _ like/</a></figcaption></figure><p id="c9d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们公司，我们目前在dockers上运行所有内部服务，例如Gitlab、YouTrack和Jenkins。它提供了高度的灵活性，但也产生了一些特定的问题。今天我想谈谈其中的一个——docker inside docker。我假设你已经知道Docker、Jenkins和Ubuntu(或者其他Linux)，因为我们用它们做例子。</p><p id="b1fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的CI，我们决定使用詹金斯。我们用的是dockerized版本:【https://hub.docker.com/r/jenkins/jenkins/<a class="ae kc" href="https://hub.docker.com/r/jenkins/jenkins/" rel="noopener ugc nofollow" target="_blank">。我们构建多个不同的项目，这些项目需要不同的环境。因此，我们选择在单独的dockers中运行所有任务。这样，我们可以为每个项目设置不同的设置。这种环境由开发人员管理，与他们的机器和预览服务器上的环境相同。当我们这样做时，我们在docker内部运行docker。经过一些研究，我们决定用一个主机守护进程来运行docker，而不是在容器内部运行一个容器。这样，我们就遇到了对<em class="lb"> docker.sock </em>的权限问题。让我们走完每一步，一起解决所有问题。</a></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="cdc9" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">这是怎么回事？</h1><p id="aa9d" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">我们先来了解一下是怎么回事。</p><p id="328d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的主机是詹金斯容器的主机。当Jenkins需要运行任务时，它会构建一个docker容器，并在其上运行特定的命令。所以我们和詹金斯一起在码头工作。如果您尝试在虚拟机上运行虚拟机，您会遇到许多问题。</p><p id="77d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是有办法在我们的容器之外直接在主机上运行所有的dockers。在这种情况下，容器内部调度的所有docker命令都将在主机上处理。怎么会这样呢？所有docker命令都由docker服务运行，docker服务可通过socket获得。当我们运行cli时，应用程序通过该套接字向服务发送命令。默认情况下，socket是作为一个文件公开的，例如<em class="lb"> /var/run/docker.sock </em>。因此，如果我们在容器上运行cli，它将与主机上的服务通信，而不是与容器上的服务通信，那么我们将有可能从容器中在主机上运行docker。我们需要做的唯一事情是在容器中安装暴露的套接字，而不是它的默认套接字。让我们和詹金斯一起做吧。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="aa5c" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">调整Jenkins容器</h1><p id="dad7" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">首先，我们需要为jenkins容器创建自己的图像。以下是Dockerfile:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="82d9" class="mv lk iq mr b gy mw mx l my mz">FROM jenkins/jenkins<br/>USER root<br/>RUN apt-get -y update &amp;&amp; \<br/> apt-get -y install apt-transport-https ca-certificates curl gnupg-agent software-properties-common &amp;&amp; \<br/> curl -fsSL <a class="ae kc" href="https://download.docker.com/linux/ubuntu/gpg" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/ubuntu/gpg</a> | apt-key add — &amp;&amp; \<br/> add-apt-repository \<br/> “deb [arch=amd64] <a class="ae kc" href="https://download.docker.com/linux/$(." rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/$(.</a> /etc/os-release; echo “$ID”) \<br/> $(lsb_release -cs) \<br/> stable” &amp;&amp; \<br/> apt-get update &amp;&amp; \<br/> apt-get -y install docker-ce docker-ce-cli containerd.io<br/>RUN curl -L “<a class="ae kc" href="https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname</a> -s)-$(uname -m)” -o /usr/local/bin/docker-compose &amp;&amp; \<br/> chmod +x /usr/local/bin/docker-compose &amp;&amp; \<br/> ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose<br/>USER jenkins</span></pre><p id="2960" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们声明我们的基础映像。接下来，我们切换到根用户。我们基于的镜像不包含docker，所以我们安装它。最后，我们默认切换到jenkins用户来使用它。现在我们需要使用该映像来运行我们的容器。为此，我们将使用docker-compose。下面是我们的<em class="lb"> docker-compose.yml </em>:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="f049" class="mv lk iq mr b gy mw mx l my mz">version: '3.1'<br/>services:<br/>    jenkins:<br/>        build:<br/>            context: ./<br/>        restart: unless-stopped<br/>        volumes:<br/>            - ${HOST_DOCKER}:/var/run/docker.sock<br/>            - ${HOST_JENKINS_DATA}:/var/jenkins_home<br/>        ports:<br/>            - "${HOST_WWW}:8080"<br/>            - "${HOST_OTHER}:50000"</span></pre><p id="cb48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们用<em class="lb">完成docker环境变量的配置。env </em>文件:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0c74" class="mv lk iq mr b gy mw mx l my mz">HOST_WWW=8180<br/>HOST_OTHER=8181<br/>HOST_DOCKER=/var/run/docker.sock<br/>HOST_JENKINS_DATA=/srv/www/jenkins</span></pre><p id="61b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您在主机上看到的，我们将有<em class="lb"> /srv/www/jenkins </em>，它将作为<em class="lb"> /var/jenkins_home </em>安装在容器上。这使我们有可能在重启容器时保留所有Jenkins配置。主机上的端口8180将被映射为容器上的8080，端口8181将被映射为50000。我将不解释HTTP在主机上的配置，因为这不是那篇文章的主题。这里最重要的是从主机上安装<em class="lb"> /var/run/docker.sock </em>，作为容器上的<em class="lb"> /var/run/docker.sock </em>。这样，容器中的docker cli将与主机上的docker服务进行通信。</p><p id="b5a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们准备好了，我们运行<code class="fe na nb nc mr b">docker-compose build</code>和<code class="fe na nb nc mr b">docker-compose up</code>。我们用<code class="fe na nb nc mr b">docker-compose exec jenkins bash</code>连接到容器。现在在容器内部，当我们运行<code class="fe na nb nc mr b">docker ps</code>命令时，我们应该看到所有的容器都运行在我们的主机上，而不是运行在我们的jenkins容器上。但是当我们运行该命令时，我们收到了权限被拒绝错误。让我们修理它。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="e0f7" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">拒绝解决docker.sock权限</h1><p id="231c" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">在大多数情况下，我们使用特定的用户运行docker守护进程，其他所有用户都无权访问它。</p><p id="3aa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先说主机配置。在我们的例子中，我们创建了具有sudo权限的用户jenkins。让我们以该用户身份登录并运行<code class="fe na nb nc mr b">docker ps</code>命令。我们应该在docker.sock上获得被拒绝的许可。如果我们用sudo运行该命令，它将会工作。有一个具有所需权限的docker用户组，因此我们将jenkins用户添加到该组并重新启动docker:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="6282" class="mv lk iq mr b gy mw mx l my mz">usermod -aG docker jenkins<br/>sudo service docker restart</span></pre><p id="b6eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要注销并重新登录，然后重新运行<code class="fe na nb nc mr b">docker ps</code>。这一次，主机上的一切都正常，但是当我们在容器上运行<code class="fe na nb nc mr b">docker ps</code>时，仍然会得到相同的错误。为什么？</p><p id="0527" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，容器和主机是两个独立的环境。在两者中创建的所有用户也是独立的。如果我们想要相同的用户，我们需要正确地配置他们。我们在主机和容器上已经有了jenkins用户，但是他们是不同的用户。用户由uid标识，而不是用户名。所以我们需要确保两个用户有相同的uid。<br/>首先，我们需要验证主机上的uid:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="6bdb" class="mv lk iq mr b gy mw mx l my mz">&gt; id -u jenkins<br/>1004</span></pre><p id="1b06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们收到了uid — 1004。我们将更改docker文件来重新配置容器上的jenkins用户。我们通过在Dockerfile中添加两行来实现。首先在文件的顶部(在基本映像声明之后)定义可接受的构建参数:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2a9d" class="mv lk iq mr b gy mw mx l my mz">ARG HOST_UID=1004</span></pre><p id="b7dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，在我们切换到jenkins用户之前，要更改用户uid:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="1eac" class="mv lk iq mr b gy mw mx l my mz">RUN usermod -u $HOST_UID jenkins</span></pre><p id="12d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们更改docker-compose.yml中的构建定义:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="17b4" class="mv lk iq mr b gy mw mx l my mz">services:<br/>    jenkins:<br/>        build:<br/>            context: ./<br/>            args:<br/>                HOST_UID: ${HOST_UID}</span></pre><p id="f7bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们在。环境:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b64a" class="mv lk iq mr b gy mw mx l my mz">HOST_UID=1004</span></pre><p id="aaf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们的uid是正确的，但是我们仍然有一个问题——为什么？主机和容器都把我们的用户看做是一样的(他们还是不同的用户，只是我们骗过了用户验证)。权限是为用户组而不是特定用户设置的。容器中还有哪些jenkins用户不属于该组。我们讨论docker用户群。主机和容器中的组具有相同的名称，但组id不同(与用户的问题相同)。首先，我们需要知道主机上docker组的gid:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4e4e" class="mv lk iq mr b gy mw mx l my mz">&gt;getent group | grep docker<br/>docker:x:999:jenkins</span></pre><p id="8408" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据的第三部分包含gid —在我们的例子中是999。接下来，我们调整docker文件，以确保docker组在主机和容器上具有相同的id，并且jenkins用户在该组中。首先，我们添加一个新的参数来构建:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ea15" class="mv lk iq mr b gy mw mx l my mz">ARG HOST_GID=999</span></pre><p id="c89a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们更改组并修改用户，然后切换到jenkins用户:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="eba2" class="mv lk iq mr b gy mw mx l my mz">RUN groupmod -g $HOST_GID docker<br/>RUN usermod -aG docker jenkins</span></pre><p id="b694" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们再次更改docker-compose.yml中的构建定义:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3227" class="mv lk iq mr b gy mw mx l my mz">services:<br/>    jenkins:<br/>        build:<br/>            context: ./<br/>            args:<br/>                HOST_UID: ${HOST_UID}<br/>                HOST_GID: ${HOST_GID}</span></pre><p id="4580" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还在中添加了正确的变量。环境文件:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="114d" class="mv lk iq mr b gy mw mx l my mz">HOST_GID=999</span></pre><p id="25df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们再次构建docker映像并运行容器(<code class="fe na nb nc mr b">docker-compose build</code>、<code class="fe na nb nc mr b">docker-compose up</code>)。从现在开始，我们的Jenkins可以在主机上运行docker的容器，不会有任何问题。</p><p id="e310" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您不能使用jenkins due权限运行容器来处理jenkins文件，您需要在主机上调整文件的所有权。正如你所记得的，我们对用户id做了一点改动，这可能是一个问题。在我们的示例中，我们需要在主机上运行:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="102b" class="mv lk iq mr b gy mw mx l my mz">sudo chgrp -R /srv/www/jenkins jenkins<br/>sudo chown -R /srv/www/jenkins jenkins</span></pre><p id="e4fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这些了。有了这个配置，我们可以在docker中运行Jenkins，并使用docker进行构建。你可以在这里的<a class="ae kc" href="https://github.com/smoogie/jenkins_docker_example" rel="noopener ugc nofollow" target="_blank">https://github.com/smoogie/jenkins_docker_example</a>中找到<em class="lb"> Dockerfile </em>和<em class="lb"> docker-compose.yml </em>的例子</p></div></div>    
</body>
</html>