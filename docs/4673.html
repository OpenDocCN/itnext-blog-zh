<html>
<head>
<title>A newbie way to play with ScalaCheck</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个新手玩ScalaCheck的方法</h1>
<blockquote>原文：<a href="https://itnext.io/a-newbie-way-to-play-with-scalacheck-ac409a8205a2?source=collection_archive---------1-----------------------#2020-08-20">https://itnext.io/a-newbie-way-to-play-with-scalacheck-ac409a8205a2?source=collection_archive---------1-----------------------#2020-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7c0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第2部分:属性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fdb4353bf40d2d8e177133d65353a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIQMx1HUu8SFrdel9IvZaA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.flickr.com/people/wicker-furniture/" rel="noopener ugc nofollow" target="_blank">https://www.flickr.com/people/wicker-furniture/</a></figcaption></figure><p id="9f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是关于使用ScalaCheck工具进行测试的系列文章的第二部分。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/a-newbie-way-to-play-with-scalacheck-333cbabfc00a">的第一部分</a>描述了<strong class="lb iu">生成器，</strong>为代码中的参数生成数据。而这一部分则深入探讨了<strong class="lb iu">属性</strong>。</p><p id="d7c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">奇闻</strong></p><p id="f8bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个测试者走进酒吧。他点了一杯啤酒。然后他点了0杯啤酒。他点了一瓶啤酒。过了一段时间，他点了999999999瓶啤酒。</p><p id="e83f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个真正的顾客走进一家酒吧，问道:“厕所在哪里？”。</p><p id="2112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个动作的结果是，一个酒吧着火了，烧到了地上。</p><p id="0719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个故事的寓意是“正确测试你的代码”，正如我的导师一直强调的那样。事实上，大多数情况下，程序员会试图如上所述精确地测试他的代码。</p><p id="984d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">基于属性的测试简介</strong></p><p id="9eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">" ScalaCheck教你研究函数的属性."—我的Scala导师(<a class="lv lw ep" href="https://medium.com/u/a43d48be8213?source=post_page-----ac409a8205a2--------------------------------" rel="noopener" target="_blank">文德森·费雷拉</a>)说。例如，它与您用JUnit编写的普通测试有什么不同？而一个<strong class="lb iu">属性</strong>到底是什么？</p><p id="6800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JUnit中，您可能会这样检查一个求和函数:2 + 3 = 5。这是一个明显的例子。你可能会写一组这样不同的例子，检查“通常的嫌疑”(所谓的常见边缘情况):零，非常大的数字和-1。在作为具体示例编写的测试中，您的测试代码显示了您的应用程序在个别情况下是如何工作的。你的测试总是会产生一个非常详细的，但是不完整的代码评估。</p><p id="ad22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ScalaCheck中，你检查a + b == b + a！在本例中，您将检查数学求和函数的行为。这是一种更复杂的测试方式。ScalaCheck将自动生成参数来测试所有<em class="lx"> a </em>和<em class="lx"> b </em>的可能性，而不仅限于一些“常见的疑点”，正如你通常在具体的测试代码中看到的那样。数学函数的这种特定行为在ScalaCheck中被翻译成代码的抽象行为，或者一个<strong class="lb iu">属性</strong>。</p><p id="fe90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">动手操作示例</strong></p><p id="28e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有兴趣测试这个ScalaCheck系列的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/a-newbie-way-to-play-with-scalacheck-333cbabfc00a">第一部分</a>中的一个<em class="lx">计算器</em>类<em class="lx">T3。加法<em class="lx">选项</em>的行为是什么，或者在ScalaCheck语言中，两个数求和的<strong class="lb iu">属性</strong>是什么？</em></p><p id="8608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，让我们从两个整数的相加开始。从一个数据类型为<em class="lx"> Int </em>的例子开始比较容易，因为<em class="lx"> BigDecimal </em>有它自己的特点。尽管如此，我将为这两者提出一个解决方案。</p><p id="379b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">一个简单的例子:用<em class="lx">Int</em>T17】求和的性质</strong></p><p id="b4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我用四种方法创建了一个名为<em class="lx"> SimpleCalculator </em>的对象:加、减、乘、除。这是两个数字之间的常规数学运算，在本例中是两个整数之间的运算。</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="c644" class="md me it lz b gy mf mg l mh mi">#code for <em class="lx">SimpleCalculator</em> </span><span id="d639" class="md me it lz b gy mj mg l mh mi">object SimpleCalculator {<br/><br/>  def summate(a: Int, b: Int): Int = {<br/>    a + b<br/>    }<br/><br/>  def subtract(a: Int, b: Int): Int = {<br/>    a - b<br/>  }<br/><br/>  def multiply(a: Int, b: Int): Int = {<br/>    a * b<br/>  }<br/><br/>  def divide(a: Int, b: Int): Int = {<br/>    a / b<br/>  }<br/><br/>}</span></pre><p id="8de3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ScalaCheck中创建属性最常见的方法是使用来自<em class="lx"> org.scalacheck.Prop </em>类的<em class="lx"> Prop.forAll </em>方法。此外，如果您想将几个属性组合在一起，可以使用<em class="lx">org . Scala check . properties</em>类来实现。下面的代码展示了如何使用继承来实现它(“扩展”选项)。</p><p id="1cea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想把重点放在所有通话内容的更多细节上。一般来说，如果方法包含的逻辑表达式对于所有元素都为真，则<em class="lx"> forAll </em>方法返回真，否则返回假。在下面的例子中，泛型<em class="lx"> a </em>和<em class="lx">b</em>——两个整数参数——被输入到用于所有调用的<em class="lx">中，该调用通过布尔逻辑检查求和方法的行为。ScalaCheck测试的棘手部分恰恰在于定义这个布尔表达式，因为它必须模拟要测试的函数的行为。</em></p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="115f" class="md me it lz b gy mf mg l mh mi">#code for Property “summation”</span><span id="2bd7" class="md me it lz b gy mj mg l mh mi">import org.scalacheck.{Prop, Properties}<br/>import org.scalacheck.Prop.forAll</span><span id="b138" class="md me it lz b gy mj mg l mh mi">object SimpleCalculatorProps extends Properties ("SimpleCalculator")  <br/>{<br/><br/>  <em class="lx">property</em>("summate") = <em class="lx">forAll </em>{ (a: Int, b: Int) =&gt;<br/>    val result = SimpleCalculator.<em class="lx">summate</em>(a, b)<br/>    result == a + b &amp;&amp; result == b + a<br/>  }</span><span id="a472" class="md me it lz b gy mj mg l mh mi">...</span><span id="b553" class="md me it lz b gy mj mg l mh mi">}</span></pre><p id="4ec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们并没有集中在<em class="lx"> a </em>和<em class="lx"> b </em>的具体例子上。它由ScalaCheck <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/a-newbie-way-to-play-with-scalacheck-333cbabfc00a"> <strong class="lb iu">发电机</strong> </a>为我们打理，是自动生产的。我们定义了一个布尔表达式，它反映了<em class="lx">求和</em>方法的一个特定属性，即功能对称性。如果所有生成的数字都符合布尔表达式，ScalaCheck将批准您的代码。</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="27cb" class="md me it lz b gy mf mg l mh mi">#ScalaCheck testing output for <em class="lx">Int</em> arguments</span><span id="f4de" class="md me it lz b gy mj mg l mh mi">+ SimpleCalculator.summate: OK, passed 100 tests.</span></pre><p id="b493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个成功的ScalaCheck测试的典型输出。或者在这种情况下，成功输出100个测试。请注意，所有测试都有随机输入参数，并且是并行执行的。如果你的代码不能处理大量同时发生的事情(并发访问)，那么ScalaCheck会立刻让你的代码失败。默认的测试次数是100，但是你可以根据你的需求来调整。</p><p id="8270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">一个简单的例子:用<em class="lx">BigDecimal</em>T3】求和的失败性质</strong></p><p id="e89a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在前面例子的代码中将数据类型从<em class="lx"> Int </em>更改为<em class="lx"> BigDecimal </em>，那么ScalaCheck将使您的程序失败。</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="21f2" class="md me it lz b gy mf mg l mh mi">#ScalaCheck testing output for<em class="lx"> BigDecimal</em> arguments</span><span id="080c" class="md me it lz b gy mj mg l mh mi">! SimpleCalculator.summate: Falsified after 1 passed tests.<br/>&gt; ARG_0: -0.00001131560419259331<br/>&gt; ARG_0_ORIGINAL: -0.3707897181828976<br/>&gt; ARG_1: 0.00001108784593808157497528613518274946<br/>&gt; ARG_1_ORIGINAL: 6702191619228002457</span></pre><p id="edea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个ScalaCheck输出显示，一个使用<em class="lx"> BigDecimal </em>作为参数的代码在一个实际上已经通过的测试之后被篡改。在输出中，您可以看到传递给所有调用的<em class="lx">的初始或原始(ARG_0_ORIGINAL)参数，以及没有传递布尔表达式的<em class="lx"> a </em> (ARG_0)和<em class="lx"> b </em> (ARG_1)的简化参数。</em></p><p id="82fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试用例简化是ScalaCheck的一个特性，它可以发现代码中的bug。碰巧的是，ScalaCheck缩小了代码失败行为的范围，并打印出导致代码失败的最简单的参数集。通常，当您检查原始输入和简化的参数时，代码中的弱点就变得很明显了。在<em class="lx"> BigDecimal </em>的情况下，首先想到的是“为什么点后的位数不同？”嗯，可能是<em class="lx"> BigDecimal </em>的舍入不一致？*</p><p id="7515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">进阶示例:与<em class="lx">BigDecimal</em>T23】相加的性质</strong></p><p id="2bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<em class="lx">计算器</em>类的例子，在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/a-newbie-way-to-play-with-scalacheck-333cbabfc00a">第一部分</a>中有描述。它得到两个参数，即<em class="lx"> a: Int </em>和<em class="lx"> b: BigDecimal </em>并有一个<em class="lx">计算器</em>方法，带有四个<em class="lx">选项</em>(加、减、除、乘)。加法<em class="lx">选项</em>是两个数的基本求和。为了测试这个选项，我们可以使用与上面演示的相同的布尔逻辑a + b == b + a。然而，我们需要应用一个<em class="lx"> round </em>方法来处理<em class="lx"> BigDecimal </em>参数的精度。</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="4662" class="md me it lz b gy mf mg l mh mi"># code for property “ADDITION”</span><span id="3070" class="md me it lz b gy mj mg l mh mi">package caskApi</span><span id="8181" class="md me it lz b gy mj mg l mh mi">import caskApi.Operation.<em class="lx">ADDITION</em></span><span id="592c" class="md me it lz b gy mj mg l mh mi">import org.scalacheck.Properties<br/>import org.scalacheck.Prop.forAll<br/>import java.math.MathContext</span><span id="df0d" class="md me it lz b gy mj mg l mh mi">object CalculatorProps extends Properties ("Calculator") {<br/><br/>  <em class="lx">property</em>("ADDITION") = <em class="lx">forAll </em>{ (a: Int, b: BigDecimal) =&gt;<br/>    val result = Calculator(a, b).calculator(<em class="lx">ADDITION</em>).round(new MathContext(4))<br/>    result == (a + b).round(new MathContext(4))  &amp;&amp; result == (b + a).round(new MathContext(4))<br/>  }</span><span id="c900" class="md me it lz b gy mj mg l mh mi">...</span><span id="b8cf" class="md me it lz b gy mj mg l mh mi">}</span></pre><p id="246c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用指定的BigDecimal精度快速运行加法属性测试将通过ScalaCheck自动生成的所有测试。</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="c826" class="md me it lz b gy mf mg l mh mi">#ScalaCheck test output</span><span id="7b53" class="md me it lz b gy mj mg l mh mi">+ Calculator.ADDITION: OK, passed 100 tests.</span></pre><p id="98f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，尝试猜测其他数学运算的ScalaCheck解决方案，即减法、乘法和除法，并在我对该项目的<a class="ae ky" href="https://gitlab.com/ullien/flask_in_scala" rel="noopener ugc nofollow" target="_blank">报告</a>中检查您的猜测。警告:组织是一个真正的傻瓜！</p><p id="5485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">总结</strong></p><p id="1ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ScalaCheck是一个基于属性的测试工具。简单地说，ScalaCheck通过生成随机数据来测试代码块的抽象行为，从而检查数百甚至数千个具体测试。它将尽最大努力去证伪这种行为，即<strong class="lb iu">地产</strong>。尽管如此，如果所有这些具体的测试都将通过，那么ScalaCheck将认为这个属性是有效的，您可以认为您的应用程序已经过很好的测试。</p><p id="f120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">*如果你遇到BigDecimal 的问题，那么首先检查你的项目使用的Scala版本。您可能遇到过版本回归(<a class="ae ky" href="https://github.com/scala/bug/issues/11590" rel="noopener ugc nofollow" target="_blank"> lchoran </a>非常清楚地总结了这一点)。</p></div></div>    
</body>
</html>