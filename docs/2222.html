<html>
<head>
<title>Using overlay mounts with Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上使用覆盖安装</h1>
<blockquote>原文：<a href="https://itnext.io/using-overlay-mounts-with-kubernetes-960375c05959?source=collection_archive---------2-----------------------#2019-04-18">https://itnext.io/using-overlay-mounts-with-kubernetes-960375c05959?source=collection_archive---------2-----------------------#2019-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="30bf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您是否曾经想要授予Kubernetes pod对持久卷的读/写访问权限，但不想让pod的更改持久保存在备份存储中？这不同于简单地以只读方式挂载卷，因为出于某种原因，pod需要能够写入文件系统。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/dd896ddf7fa463e043bac7fd4b9c2884.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*AL36GU1jDozbD83xS77YLw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">豆荚体积的变化是短暂的</figcaption></figure><h2 id="30cb" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">我的使用案例</h2><p id="c03f" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">我遇到的特定用例必须提供一组标准的基本<a class="ae mc" href="https://www.anaconda.com/" rel="noopener ugc nofollow" target="_blank"> <em class="md">【康达】</em> </a>环境，同时让pod定制环境。对于那些不熟悉的人来说，<em class="md"> conda </em>是一个软件包管理器，通常用于分发科学软件包。每个环境都是一组独立的包，类似于Python环境。在这个用例中，我们提供了一组库存环境，但是如果pod(用户)认为我们缺少他们真正想要的包，他们可以简单地将该包临时安装到他们的pod中，并且不让库存环境的其他用户看到它。也就是说，这个解决方案可以应用于许多其他的用例——你不需要对conda一无所知就可以继续阅读。</p><h2 id="301e" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">核心理念</h2><p id="154a" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">标准的Linux覆盖文件系统正是这样做的。它允许您获取一个公共(通常是只读)文件系统，并挂载它，允许用户以读/写模式与公共文件系统中的所有内容进行交互，而不会影响原始文件系统。</p><h2 id="62a2" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">简单溶体</h2><p id="883d" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">最简单的做法是在容器内部使用覆盖挂载。容器将以只读方式访问公共卷，并创建一个覆盖挂载。但不幸的是，这不符合我的要求，因为这要求最终用户的容器具有升级的权限(SYS_ADMIN)和覆盖挂载的知识。在我的例子中，终端用户的容器可以运行任意的终端用户代码，因此需要被严格锁定。</p><h1 id="4544" class="me lf iq bd lg mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr ms mt lv mu bi translated">完全解决方案</h1><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/57e4f2fe67d3d9b196debbd27ab0fcde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m628IS1CoEWBvWuKdE9eFQ.png"/></div></div></figure><p id="b7c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Sidecar / Setup容器:</strong>你需要一个新的Sidecar容器来存放运行的映像。这个边车负责</p><ul class=""><li id="e574" class="na nb iq jw b jx jy kb kc kf nc kj nd kn ne kr nf ng nh ni bi translated">创建一个覆盖挂载，用一个emptyDir临时挂载覆盖只读的原始conda环境。</li><li id="f90e" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nf ng nh ni bi translated">传播挂载，以便运行时映像可以访问覆盖图。</li><li id="122c" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nf ng nh ni bi translated">安装额外的软件包或创建一个全新的env —基于最终用户定义的任何内容。</li></ul><p id="3daf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">运行时容器:</strong>运行时容器访问与<strong class="jw ir">设置</strong>容器相同的<em class="md"> conda-mount </em>卷，所有更改可见。在我的用例中，我选择将结果挂载为只读，以避免用户进一步填满<strong class="jw ir">覆盖</strong>卷。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="260f" class="me lf iq bd lg mf no mh lj mi np mk lm ml nq mn lp mo nr mq ls mr ns mt lv mu bi translated">细节</h1><h2 id="6f3d" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">卷装载</h2><ol class=""><li id="fbd0" class="na nb iq jw b jx lx kb ly kf nt kj nu kn nv kr nw ng nh ni bi translated"><strong class="jw ir"> local-vol </strong> —这是一个主机路径卷，用于访问主机上的基本conda环境。注意，这可以是任何类型的持久卷—为了简单起见，我只是碰巧使用了hostPath。</li><li id="7453" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nw ng nh ni bi translated"><strong class="jw ir">覆盖</strong> —这是一个包含覆盖上层和工作目录的空目录(对pod来说是暂时的，但是存储在主机上)。这是所有对<strong class="jw ir">本地卷</strong>的更改被存储的地方。<br/>注意:如果你真的不想保存在磁盘上，你可以用内存备份，但是那会耗尽主机内存，所以要避免这样做。</li><li id="d938" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nw ng nh ni bi translated"><strong class="jw ir"> conda-mount </strong> —这是一个实际上保存零数据的空目录。我们将它用作最终conda环境的挂载点(/opt/anaconda3)。该卷在pod中的两个容器之间共享，并利用装载传播。</li></ol><h2 id="9df5" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">安装传播</h2><pre class="kt ku kv kw gt nx ny nz oa aw ob bi"><span id="f211" class="le lf iq ny b gy oc od l oe of">volumeMounts:<br/>- mountPath: /opt/anaconda3<br/>  name: conda-mount<br/>  <a class="ae mc" href="https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation" rel="noopener ugc nofollow" target="_blank">mountPropagation: Bidirectional</a></span></pre><p id="48a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<strong class="jw ir">设置</strong>容器中对conda-mount卷所做的任何挂载更改都会传播到主机，因此也允许<strong class="jw ir">运行时</strong>容器看到覆盖挂载。这才是真正的神奇。</p><p id="5a34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，传播的挂载是包含零数据的<strong class="jw ir"> conda-mount </strong>。它只是覆盖挂载点。原始的<strong class="jw ir"> local-vol </strong>内容不受影响。</p><p id="4b01" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它要求<strong class="jw ir">设置</strong>容器在特权模式下运行(k8s强制执行这一点)。</p><pre class="kt ku kv kw gt nx ny nz oa aw ob bi"><span id="3408" class="le lf iq ny b gy oc od l oe of">securityContext:<br/>  privileged: true</span></pre><p id="7abc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意<strong class="jw ir">运行时</strong>容器不需要<em class="md">而不是</em>特权运行。这就是我们想要的，因为运行时容器可以运行任意代码。</p><h2 id="47b6" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">安装容器</h2><p id="e3b1" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated"><strong class="jw ir">任务:</strong><strong class="jw ir">设置</strong>容器负责:</p><pre class="kt ku kv kw gt nx ny nz oa aw ob bi"><span id="0f4b" class="le lf iq ny b gy oc od l oe of">args:<br/>— mkdir -p /data/{upper,work}; <br/>  mount -t overlay -o lowerdir=/condaro/,upperdir=/data/upper,workdir=/data/work overlay /opt/anaconda3; <br/>  . /opt/anaconda3/etc/profile.d/conda.sh; <br/>  conda activate dlipy3; <br/>  conda install agate -y; <br/>  conda deactivate; <br/>  touch /opt/anaconda3/setup_complete; <br/>  tail -f /dev/null;</span></pre><ol class=""><li id="1a33" class="na nb iq jw b jx jy kb kc kf nc kj nd kn ne kr nw ng nh ni bi translated">设置覆盖安装。它使用短暂的<strong class="jw ir">覆盖</strong>卷来托管覆盖挂载的<em class="md">上部</em>和<em class="md">工作目录</em>(这是所有更改持续的地方)。</li><li id="0ad2" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nw ng nh ni bi translated">进行短暂的修改——在这种情况下，它激活<strong class="jw ir"> dlipy3 </strong> conda环境，安装<em class="md"> agate </em>包，然后停用该环境(以避免阻止将来的卸载)。</li><li id="84b1" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nw ng nh ni bi translated">添加指示安装完成的标志。这是共享覆盖挂载中的一个文件，允许<strong class="jw ir">运行时</strong>容器等待，直到<strong class="jw ir">设置</strong>容器完成。</li><li id="0ae2" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nw ng nh ni bi translated">现在它在等待——我们必须保持容器运行。</li></ol><p id="7d83" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当你使用挂载传播时，你必须卸载一些东西。如果不这样做，Kubernetes将使pod处于<em class="md">终止</em>状态，因为卷没有清理。因此，我们添加了一个preStop钩子来确保覆盖挂载被移除。</p><pre class="kt ku kv kw gt nx ny nz oa aw ob bi"><span id="823e" class="le lf iq ny b gy oc od l oe of">lifecycle:<br/>  preStop:<br/>    exec:<br/>      command: [“umount”, “/opt/anaconda3”]</span></pre><h2 id="3aad" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">运行时容器</h2><p id="dc3a" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">运行时容器简单地挂载<strong class="jw ir"> conda-mount </strong>卷(覆盖挂载点)，并检查共享挂载中是否存在<em class="md"> setup_complete </em>文件，以获取readinessProbe。这很重要，这样容器在准备好之前不会开始消耗挂载。</p><pre class="kt ku kv kw gt nx ny nz oa aw ob bi"><span id="c8be" class="le lf iq ny b gy oc od l oe of">readinessProbe:<br/>  exec:<br/>    command:<br/>    — cat<br/>    — /opt/anaconda3/setup_complete<br/>  initialDelaySeconds: 0<br/>  periodSeconds: 1<br/>  failureThreshold: 300</span></pre></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="25d2" class="me lf iq bd lg mf no mh lj mi np mk lm ml nq mn lp mo nr mq ls mr ns mt lv mu bi translated">把所有的放在一起</h1><p id="2fa1" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">这是完整的yaml示例。一个简单的<code class="fe og oh oi ny b">kubernetes create -f example.yaml</code>应该就可以了。您可能希望修改主机路径路径。</p><pre class="kt ku kv kw gt nx ny nz oa aw ob bi"><span id="49c0" class="le lf iq ny b gy oc od l oe of">kind: Deployment<br/>metadata:<br/>  name: k8s-overlay-mounts<br/>  labels:<br/>    app: test-me<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: test-me<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test-me          <br/>    spec:            <br/>      containers:<br/>      - securityContext:<br/>          privileged: true<br/>        image: ubuntu:18.04<br/>        name: setup<br/>        command: [ "/bin/bash", "-c", "--" ]<br/>        args:<br/>        - mkdir -p /data/{upper,work}; <br/>          mount -t overlay -o lowerdir=/condaro/,upperdir=/data/upper,workdir=/data/work overlay /opt/anaconda3; <br/>          . /opt/anaconda3/etc/profile.d/conda.sh; <br/>          conda activate dlipy3; <br/>          conda install agate -y; <br/>          conda deactivate; <br/>          touch /opt/anaconda3/setup_complete; <br/>          tail -f /dev/null;<br/>        volumeMounts:<br/>        - mountPath: /condaro<br/>          name: local-vol<br/>          readOnly: true<br/>        - mountPath: /data<br/>          name: overlay<br/>        - mountPath: /opt/anaconda3<br/>          name: conda-mount<br/>          mountPropagation: Bidirectional<br/>        lifecycle:<br/>          preStop:<br/>            exec:<br/>              command: ["umount", "/opt/anaconda3"]<br/>      - image: ubuntu:18.04<br/>        name: run<br/>        command: [ "tail", "-f", "/dev/null" ]<br/>        volumeMounts:<br/>        - mountPath: /opt/anaconda3<br/>          name: conda-mount<br/>          readOnly: true<br/>        readinessProbe:<br/>          exec:<br/>            command:<br/>            - cat<br/>            - /opt/anaconda3/setup_complete<br/>          initialDelaySeconds: 0<br/>          periodSeconds: 1<br/>          failureThreshold: 300<br/>      volumes:<br/>      - name: local-vol<br/>        hostPath: <br/>          path: /opt/anaconda3/<br/>      - name: overlay<br/>        emptyDir: {}<br/>        #          medium: Memory<br/>      - name: conda-mount<br/>        emptyDir: {}</span></pre></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="ec59" class="me lf iq bd lg mf no mh lj mi np mk lm ml nq mn lp mo nr mq ls mr ns mt lv mu bi translated">你为什么不做…？</h1><p id="d16c" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">为什么不使用initContainer进行设置？ <br/> 因为有人要卸载覆盖。如果我们不这样做，Kubernetes无法清理吊舱，因为一个悬挂的安装。所以我们需要清理出口处的支架。</p><p id="8aba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以在<em class="md">运行</em>容器中卸载它，但是<em class="md">运行</em>容器需要是一个特权容器——这是我们不想要的。</p><p id="6ca0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="md">为什么不用run容器安装新东西？</em> </strong> <br/>因为我希望运行时容器在修改底层conda环境方面没有任何智能。这里没有要求——无论用户是否请求对conda环境进行更改，都希望保持事物的通用性。我们还在运行时容器中运行任意代码，并希望尽可能锁定运行时容器。</p><p id="961c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为什么不使用initContainer将文件复制到临时卷中？  <br/>因为慢。它可以达到同样的技术效果，但是非常昂贵。</p><p id="4516" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="md">为什么不直接挂载conda环境只读，利用Conda对~/的使用。康达？</em> </strong> <br/>如果您的conda基础安装是只读的，那么conda会自动将新的环境和包缓存放入~/.conda中。对于我们来说，这不是一个完整的解决方案有两个原因:</p><ol class=""><li id="8cef" class="na nb iq jw b jx jy kb kc kf nc kj nd kn ne kr nw ng nh ni bi translated">这对于修改一个现有的环境不起作用(例如:<code class="fe og oh oi ny b">conda install X</code>)。更新现有环境比创建一个具有相同内容的全新环境要快得多(取决于环境的大小)。</li><li id="b441" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nw ng nh ni bi translated">Conda不能利用跨文件系统的硬链接。因此，当你在<code class="fe og oh oi ny b">~/.conda/</code>创建一个新环境时，它会制作文件的副本，而不是只做硬链接，这增加了存储空间和时间。</li></ol></div></div>    
</body>
</html>