# 现代 C++代码的出现:第 20 天

> 原文：<https://itnext.io/modern-c-in-advent-of-code-day20-be8b657e7f86?source=collection_archive---------2----------------------->

今天是[代码](https://adventofcode.com/2021)问世的第二十天。今天，我们将阅读并增强一幅黑白图像。

![](img/0091a39ea57e8e1ae53d77844eee6d11.png)

一如既往，请先尝试解决问题，然后再看解决方案。对于这个系列的所有文章，[看看这个列表](https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e)。

# 第 20 天

我们分两部分接收我们的输入。第一行代表我们的“增强”过滤器，后面是初始图像数据的网格。

今天问题的主要复杂性来自应用增强过滤器。对于每个像素，我们查看该像素周围的 3×3 网格，并将像素视为一个数字中的位(从左到右、从上到下阅读)。例如，这代表`0b010110001 == 177`:

```
.#.
##.
..#
```

之后，解码的数字表示增强过滤器数据中的位置，它告诉我们该像素在结果图像中应该是开还是关。

当应用过滤器时，我们需要一次全部应用，即我们需要生成图像的新实例。此外，该图像表示无限平面的一小部分。该平面从所有像素关闭开始；然而，我们需要小心边界像素，并将滤镜“应用”到无限平面。这听起来可能很疯狂，是的，一般来说确实如此，但是我们的输入表现良好，因此我们将只支持滤波器将零块映射到一个块的情况，即`0b000000000<->0b111111111`。

## 图像

我们需要存储过滤器数据和图像数据:

对于解析和序列化，我们现在可以让范围来承担重任:

行视图(第 3 行)将跳过最初的空白，逐字符读取直到行尾，并将' # '转换为真值和'.'错误的价值观。

## 增强？

解析完输入之后，我们现在可以继续讨论实际的增强功能了。我们将需要两个主要方法，一个从 3x3 网格构造二进制数，另一个应用过滤器:

我们需要在边界上小心，在那里 3x3 网格将超出我们的图像数据，我们需要使用来自无限平面的值(第 8 行)。

结果可能是每边大一个像素(第 14 行)。然而，我们不必考虑该区域(第 20 行)之外的像素，因为均匀无限平面只会影响该边界(因为 3x3 网格编码)。

## 增强！

完成后，剩下的就是把这些放在一起:

# 链接和技术说明

每日解决方案存储库位于:[https://github.com/HappyCerberus/moderncpp-aoc-2021](https://github.com/HappyCerberus/moderncpp-aoc-2021)。

查看此列表，了解《代码降临日》的其他相关文章。

请不要忘记亲自尝试一下[代码](https://adventofcode.com/2021)的问世。

# 感谢您的阅读

感谢您阅读这篇文章。你喜欢吗？

我还在 T4 的 YouTube 上发布视频。你有问题吗？在 Twitter 或 LinkedIn 上联系我。