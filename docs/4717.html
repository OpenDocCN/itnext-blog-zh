<html>
<head>
<title>How to test React.js application with Jest and Enzyme — testing tutorial for beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Jest和Enzyme测试React.js应用程序——初学者测试教程</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-test-react-js-application-with-jest-and-enzyme-testing-tutorial-for-beginners-7f3a200f29d7?source=collection_archive---------1-----------------------#2020-08-31">https://itnext.io/how-to-test-react-js-application-with-jest-and-enzyme-testing-tutorial-for-beginners-7f3a200f29d7?source=collection_archive---------1-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/df7695b58aacfc9fb4b27d6987842301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-wrUVi1Pz-FFx6YN1eHhA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.blog.duomly.com/testing-react-app-with-jest-and-enzyme/" rel="noopener ugc nofollow" target="_blank">用Jest和酶测试ReactJS应用</a></figcaption></figure><p id="81ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文原载于<a class="ae kf" href="https://www.blog.duomly.com/testing-react-app-with-jest-and-enzyme/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/testing-react-app-with-jest-and-enzyme/</a></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="9a33" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">前端应用测试简介</h1><p id="19de" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">编写高质量的web应用程序需要测试，以避免一个组件在另一个组件发生变化时意外崩溃。有必要在开始时理解逻辑并计划测试用例，以便很好地测试应用程序。</p><p id="3272" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我想更深入地探讨开发概念，比如测试驱动开发(TDD)，并向您解释为什么测试应用程序是必不可少的。除此之外，我将讨论测试的利与弊，并描述测试web应用程序时使用的三种测试类型。</p><p id="517f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我将进入实用部分，在这里我将使用Jest和Enzyme一步一步地测试一个简单的React.js应用程序。您可以在我们的<a class="ae kf" href="https://github.com/Duomly/reactjs-hooks-tutorial" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到应用程序的代码。</p><p id="bc46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是视频教程，我正在测试这个应用程序，所以如果你更多的是在观看而不是阅读，请加入我的Youtube。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="baf8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开始吧！</p><h1 id="50b7" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">为什么测试很重要？</h1><p id="4c32" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">应用程序中的测试是检查编写的代码是否正确执行并带来所需的结果。</p><p id="1c00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们编码的时候测试应用程序真的很有价值，可以为开发过程带来很多好处，对于未来的应用程序维护也是如此。</p><p id="672b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试应用程序的最大好处是防止回归。感谢测试，如果新代码没有再次带来旧的错误，我们可以很容易地捕捉到。回归大大减慢了开发速度，如果有办法防止它，就应该这样做。</p><p id="0da4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试应用程序还提供了关于我们创建的代码的快速反馈，而不是使用多个<code class="fe mz na nb nc b">console.log</code>和手动测试，我们可以找出什么可行，什么不可行。</p><p id="82a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，测试帮助我们确保复杂的组件和逻辑在不同的情况下都能很好地工作，所以当我们试图与某些功能进行交互时，不会有意外的惊喜。</p><p id="645f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试帮助开发人员创建较少错误的应用程序，并允许我们尽早发现和修复错误。它还简化了新功能的添加，降低了构建应用程序的成本。</p><h1 id="bdfd" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">测试的利与弊</h1><p id="a53a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">即使单元测试是必不可少的，它也有一些优点和缺点，开发者应该意识到这一点。</p><p id="5379" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试的优点是:</p><ul class=""><li id="c145" class="nd ne it ki b kj kk kn ko kr nf kv ng kz nh ld ni nj nk nl bi translated">尽早发现错误并尽早修复的可能性</li><li id="4624" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">写得好的测试提供了某种文档，这有助于新开发人员理解应用程序中发生了什么</li><li id="7c32" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">它减少了手动测试的时间</li><li id="84ef" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">有助于轻松维护和改进应用程序，减少错误</li></ul><p id="bb84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试的缺点是:</p><ul class=""><li id="fbc8" class="nd ne it ki b kj kk kn ko kr nf kv ng kz nh ld ni nj nk nl bi translated">编写测试很耗时</li><li id="5771" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">需要做更多的代码</li><li id="aee7" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">写得不好的测试可以跳过重要的错误</li></ul><h1 id="bc58" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">什么是测试驱动开发？</h1><p id="29fb" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">测试驱动开发是一种方法，它假设测试是在代码之前编写的，任务是创建通过测试的代码。</p><p id="d3ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试驱动开发的编码过程分为六个步骤:</p><ol class=""><li id="6908" class="nd ne it ki b kj kk kn ko kr nf kv ng kz nh ld nr nj nk nl bi translated">编写测试</li><li id="1b18" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld nr nj nk nl bi translated">运行所有新的和现有的测试。在这一步，新的测试应该会失败，因为还没有现有的代码。</li><li id="ca44" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld nr nj nk nl bi translated">编写通过测试的最少代码。</li><li id="4e79" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld nr nj nk nl bi translated">再次运行测试以检查它是否通过。</li><li id="7852" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld nr nj nk nl bi translated">如有必要，重构代码。</li><li id="8a09" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld nr nj nk nl bi translated">重复一遍。</li></ol><p id="160c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于开发高质量的应用程序来说，TDD是一个很好的解决方案，但是它有优点，也有缺点。</p><p id="2ce2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看TDD的优点是什么:</p><ul class=""><li id="3bfd" class="nd ne it ki b kj kk kn ko kr nf kv ng kz nh ld ni nj nk nl bi translated">在开发过程中编写小测试迫使代码模块化</li><li id="105a" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">TDD支持良好的架构和模块化</li><li id="304f" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">这有助于简化维护</li><li id="29ad" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">它有助于从一开始就阐明项目的需求，并有助于避免误解</li><li id="2c9b" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">它在应用程序中提供了高覆盖率的测试</li></ul><p id="4d40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TDD的缺点是:</p><ul class=""><li id="cf24" class="nd ne it ki b kj kk kn ko kr nf kv ng kz nh ld ni nj nk nl bi translated">这可能很难写</li><li id="d1fc" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">由于编写额外的代码，它会减慢开发速度</li><li id="94ef" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated">很难应用于现有的或者遗留的代码测试，有时需要重构</li></ul><p id="e89a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了纯粹的TDD，还有一个解决方案可以考虑，尤其是在前端。在测试驱动开发的情况下，我们正在测试实现，在小的更改之后，测试很容易失败。</p><p id="f671" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果我们测试应用程序的行为，那么实现中的小变化不会使我们改变测试。这种方法被称为行为驱动开发，在前端项目增长的情况下，这是一个值得考虑的解决方案。</p><h1 id="a425" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">测试类型</h1><p id="e54f" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在测试应用程序时，我们可以将测试分为三种类型:</p><ul class=""><li id="8df2" class="nd ne it ki b kj kk kn ko kr nf kv ng kz nh ld ni nj nk nl bi translated"><strong class="ki iu">单元测试</strong> —这种类型的测试集中在被称为单元的单个组件、功能和模块上。单元测试隔离特定的单元，并分别进行测试，以确保应用程序的每个部分都经过测试并按预期工作。在这种测试中，我们不是测试每个单元的集成。</li><li id="9004" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated"><strong class="ki iu">组件测试</strong> —这种类型的测试侧重于测试作为应用程序的一个单独部分的单个组件。</li><li id="ec5f" class="nd ne it ki b kj nm kn nn kr no kv np kz nq ld ni nj nk nl bi translated"><strong class="ki iu">快照测试</strong> —快照测试用于确保UI不会发生意外变化。框架从组件创建一个快照，然后将其与当前状态进行比较，检查是否有变化。</li></ul><p id="977d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们用Jest和Enzyme来测试ReactJS应用程序。</p><h1 id="f791" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">如何用Jest和酵素一步步测试ReactJS app？</h1><p id="8b6d" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这是本文的实践部分，我想一步一步地测试我现有的ReactJS应用程序。</p><p id="ecae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想加入并和我一起做，你可以在我们的<a class="ae kf" href="https://github.com/Duomly/reactjs-hooks-tutorial" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到代码。</p><p id="f85f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了测试，我将使用Jest和酶。Jest是一个专注于简单性的Javascript测试框架。它可以与大多数现代前端框架和纯Javascript一起工作。</p><p id="a89a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Enzyme是一个用于测试ReactJS组件的库，使用起来非常简单和直观。</p><h2 id="a913" class="ns lm it bd ln nt nu dn lr nv nw dp lv kr nx ny lz kv nz oa md kz ob oc mh od bi translated">1.装置</h2><p id="f297" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">让我们从安装所有必需的库开始。使用<code class="fe mz na nb nc b">yarn</code>或<code class="fe mz na nb nc b">npm</code>打开应用程序和控制台，安装Jest、Enzyme和一些附加插件。</p><p id="6141" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你用<code class="fe mz na nb nc b">create-react-app</code>创建了你的应用，你不需要安装<code class="fe mz na nb nc b">Jest</code>，它已经存在了。</p><pre class="mo mp mq mr gt oe nc of og aw oh bi"><span id="fffd" class="ns lm it nc b gy oi oj l ok ol">yarn add enzyme enzyme-adapter-react-16 react-test-renderer<br/>yarn add enzyme-to-json</span></pre><p id="611e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你的项目中还没有<code class="fe mz na nb nc b">Jest</code>，你可以用下面的命令安装它:</p><pre class="mo mp mq mr gt oe nc of og aw oh bi"><span id="e6bb" class="ns lm it nc b gy oi oj l ok ol">yarn add jest</span></pre><p id="1685" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">准备就绪后，我们可以打开应用程序代码并开始设置测试环境。</p><p id="a5ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">准备就绪后，我们可以打开应用程序代码并开始设置测试环境。</p><h2 id="c5a0" class="ns lm it bd ln nt nu dn lr nv nw dp lv kr nx ny lz kv nz oa md kz ob oc mh od bi translated">2.设置测试文件</h2><p id="646c" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">请打开<code class="fe mz na nb nc b">setupTest.js</code>文件，我们需要在这里配置适配器，以便在Jest环境中正确使用Enzyme。</p><pre class="mo mp mq mr gt oe nc of og aw oh bi"><span id="bb64" class="ns lm it nc b gy oi oj l ok ol">import { configure } from "enzyme";<br/>import Adapter from "enzyme-adapter-react-16";<br/>configure({ adapter: new Adapter() });</span></pre><p id="9d92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当准备好并保存后，下一步将是考虑测试用例。</p><h2 id="18f2" class="ns lm it bd ln nt nu dn lr nv nw dp lv kr nx ny lz kv nz oa md kz ob oc mh od bi translated">3.准备测试用例</h2><p id="c279" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当我们开始测试任何应用程序时，我们需要知道我们想在里面测试什么。这就是为什么在这一步中，我们要考虑对我们来说很重要的测试案例。</p><p id="6a22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的ReactJS应用程序中，我们有一个非常简单的功能。组件被渲染，然后有一个按钮改变框中的值。当余额框为1000或更少时，我们通过更改类来显示通知。</p><p id="74d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，首先，让我们测试的是所有的组件都被渲染了。</p><p id="ac82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们来检查一下通过组件传递的道具是否正确。</p><p id="f123" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以检查逻辑，所以如果单击按钮，两个帐户的值都会改变。</p><p id="1761" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以测试快照。</p><p id="845d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们有四组主要的测试想要测试。</p><h2 id="9c83" class="ns lm it bd ln nt nu dn lr nv nw dp lv kr nx ny lz kv nz oa md kz ob oc mh od bi translated">4.测试组件是否正在呈现</h2><p id="f8c7" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">让我们从第一组开始，我们将测试我们的组件是否被正确渲染。我们将使用<code class="fe mz na nb nc b">describe</code>对其进行分组。</p><p id="70c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们打开<code class="fe mz na nb nc b">App.test.js</code>文件，我们将在其中放置所有的测试。因为应用程序并不大，所以我们不打算把它放在不同的文件中。但是在比两个组件更大的应用程序的情况下，为每个组件分别创建一个测试文件是非常好的。</p><pre class="mo mp mq mr gt oe nc of og aw oh bi"><span id="8eff" class="ns lm it nc b gy oi oj l ok ol">import React from 'react';<br/>import App from './App';<br/>import AccountBalance from './AccountBalance.jsx';<br/>import Notification from './Notification.jsx';<br/>import { shallow, mount } from 'enzyme';<br/>import toJson from "enzyme-to-json";<br/><br/>const userBalance = {<br/>  balance: 1100,<br/>  savingBalance: 103,<br/>}<br/><br/>describe("rendering components", () =&gt; {<br/>  it("renders App component without crashing", () =&gt; {<br/>    shallow(&lt;App /&gt;);<br/>  });<br/>  it("renders App component header without crashing", () =&gt; {<br/>    const wrapper = shallow(&lt;App /&gt;);<br/>    const header = (&lt;h1 className="has-text-centered title is-1"&gt;Welcome in the personal finance app!&lt;/h1&gt;);<br/>    expect(wrapper.contains(header)).toEqual(true);<br/>  });<br/>  it("renders Notification component without crashing", () =&gt; {<br/>    shallow(&lt;Notification /&gt;);<br/>  });<br/>  it("renders button", () =&gt; {<br/>    const wrapper = mount(&lt;AccountBalance accounts={userBalance} /&gt;);<br/>    const label = wrapper.find("#balance-button").text();<br/>    expect(label).toEqual("Send 100$");<br/>  });<br/>});</span></pre><p id="a9ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你在代码中看到的，我们首先使用的是<code class="fe mz na nb nc b">shallow</code>，它负责呈现没有子组件的组件。如果我们需要查看组件中是否呈现了任何额外的元素，我们可以通过定义元素并使用<code class="fe mz na nb nc b">.contain()</code>方法来检查它是否存在。</p><p id="0eb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我已经创建了一个<code class="fe mz na nb nc b">userBalance</code>对象，这是一个道具的模拟，将在下一步中使用。</p><h2 id="8105" class="ns lm it bd ln nt nu dn lr nv nw dp lv kr nx ny lz kv nz oa md kz ob oc mh od bi translated">5.测试通过道具</h2><p id="4d5a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">现在，我们可以进入下一个测试用例，即将道具传递给组件。让我们用组内的<code class="fe mz na nb nc b">describe().</code>创建另一个组，我将设置三个测试，检查道具是否被接受，它们是否正确显示，以及通知道具是否通过。</p><pre class="mo mp mq mr gt oe nc of og aw oh bi"><span id="6db0" class="ns lm it nc b gy oi oj l ok ol">describe("passing props", () =&gt; {<br/>  const accountWrapper = mount(&lt;AccountBalance accounts={userBalance} /&gt;);<br/>  const notificationWrapper = mount(&lt;Notification balance={userBalance.balance} /&gt;);<br/>  it("accepts user account props", () =&gt; {<br/>    expect(accountWrapper.props().accounts).toEqual(userBalance);<br/>  });<br/>  it("contains savingBalance value", () =&gt; {<br/>    const value = accountWrapper.find(".savings").text();<br/>    const expectedValue = userBalance.savingBalance + "$";<br/>    expect(value).toEqual(expectedValue);<br/>  });<br/>  it("notification accepts props", () =&gt; {<br/>    expect(notificationWrapper.props().balance).toEqual(userBalance.balance);<br/>  });<br/>});</span></pre><p id="7f78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，现在我们可以确定我们的道具被成功地传递给了子组件。现在让我们测试一下应用程序的逻辑。</p><h2 id="0877" class="ns lm it bd ln nt nu dn lr nv nw dp lv kr nx ny lz kv nz oa md kz ob oc mh od bi translated">6.测试逻辑</h2><p id="4d9d" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们测试的下一步是检查逻辑是否正常工作。这里的逻辑并不复杂，因为最重要的功能是在按钮点击事件时更改帐户值。</p><p id="541d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mz na nb nc b">App.test.js</code>中，我们再添加一个<code class="fe mz na nb nc b">describe()</code>组。</p><pre class="mo mp mq mr gt oe nc of og aw oh bi"><span id="0805" class="ns lm it nc b gy oi oj l ok ol">describe("logic", () =&gt; {<br/>  const wrapper = mount(&lt;AccountBalance accounts={userBalance} /&gt;);<br/>  wrapper.find("#balance-button").simulate("click");</span><span id="7613" class="ns lm it nc b gy om oj l ok ol">  it("button click - update savings", () =&gt; {<br/>    const savingsValue = wrapper.find(".savings").text();<br/>    const expectedValue = userBalance.savingBalance + 100 + '$';<br/>    expect(savingsValue).toEqual(expectedValue);<br/>  });<br/>  it("button click - update balance", () =&gt; {<br/>    const balanceValue = wrapper.find(".balance").text();<br/>    const expectedBalanceValue = userBalance.balance - 100 + '$';<br/>    expect(balanceValue).toEqual(expectedBalanceValue);<br/>  });<br/>});</span></pre><p id="3b90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我定义了AccountBalance组件包装器；然后我用了。simulate()方法模拟选中按钮上的click事件。接下来，我们有两个测试来检查点击事件后的功能。</p><h2 id="f504" class="ns lm it bd ln nt nu dn lr nv nw dp lv kr nx ny lz kv nz oa md kz ob oc mh od bi translated">7.快照</h2><p id="53dd" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">测试我们简单应用程序的最后一步是快照。为此，我们将使用在本教程开始时安装的附加插件<code class="fe mz na nb nc b">enzyme-to-json</code>。在这个组中，我还将定义三个案例，一个用于App组件，一个用于AccountBalance，一个用于通知组件。</p><pre class="mo mp mq mr gt oe nc of og aw oh bi"><span id="3e14" class="ns lm it nc b gy oi oj l ok ol">describe("snapshots", () =&gt; {<br/>  it("App snapshot", () =&gt; {<br/>    const tree = shallow(&lt;App/&gt;);<br/>    expect(toJson(tree)).toMatchSnapshot();<br/>  });<br/>  it("Accounts snapshots", () =&gt; {<br/>    const accountBalanceTree = shallow(&lt;AccountBalance accounts={userBalance} /&gt;);<br/>    expect(toJson(accountBalanceTree)).toMatchSnapshot();<br/>  });<br/>  it("Notification snapshot", () =&gt; {<br/>    const notificationTree = shallow(&lt;Notification /&gt;);<br/>    expect(toJson(notificationTree)).toMatchSnapshot();<br/>  });<br/>});</span></pre><p id="5eaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果UI中有一些更新，并且快照测试失败，您可以使用<code class="fe mz na nb nc b">u</code>来更新快照。</p><p id="affa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，在首次完成快照测试后，您会在应用程序中看到一个名为<code class="fe mz na nb nc b">__snapshots__</code>的新文件夹，快照将保存在该文件夹中。</p><h2 id="a22d" class="ns lm it bd ln nt nu dn lr nv nw dp lv kr nx ny lz kv nz oa md kz ob oc mh od bi translated">8.测试</h2><p id="3ebf" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">现在，是时候真正测试我们的应用程序并运行测试了。让我们打开终端，并运行以下命令:</p><p id="3468" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mz na nb nc b">yarn test</code> <br/>或<br/> <code class="fe mz na nb nc b">npm test</code></p><p id="43ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后你应该会看到测试正在运行，你会看到你的测试列表，你会看到他们是否通过。<br/>你可以玩玩测试，看看它失败时是什么样子。</p><p id="c342" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我的结果:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/a6ab07974d2195cc888fb08c5b17193c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*azTNEKRDb9dOr8gIITQxRw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用Jest和酶结果进行ReactJS测试</figcaption></figure><h1 id="c4d3" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">结论</h1><p id="b678" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在本文中，我介绍了测试web应用程序的好处，并指出了测试的一些优点和缺点。除此之外，我还介绍了什么是测试驱动开发，以及它的优点和缺点。我还经历了前端应用程序测试中的三种测试。</p><p id="783d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，我参加了一个实际的任务，在ReactJS中有一个应用程序需要测试。我已经安装了所有必要的插件和库；在那之后，我们已经计划了测试用例并通过了测试。</p><p id="419b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这篇文章对您有所帮助，尤其是如果您是测试初学者的话。本教程将帮助您理解什么是测试，它带来了什么好处，以及如何测试您的应用程序。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/03d18bac6abce30b3e43642dbc2e8504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkPMC44a-mwUTL1FE_VBlw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.duomly.com?code=lifetime-80" rel="noopener ugc nofollow" target="_blank"> Duomly —编程在线课程</a></figcaption></figure><p id="798b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，<br/>安娜</p></div></div>    
</body>
</html>