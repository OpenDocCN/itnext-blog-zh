<html>
<head>
<title>Descriptive assertions in Kotlin for clearer tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中用于更清晰测试的描述性断言</h1>
<blockquote>原文：<a href="https://itnext.io/descriptive-assertions-in-kotlin-for-clearer-tests-32df71236919?source=collection_archive---------4-----------------------#2019-09-28">https://itnext.io/descriptive-assertions-in-kotlin-for-clearer-tests-32df71236919?source=collection_archive---------4-----------------------#2019-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b555" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经写了关于科特林的<a class="ae kl" href="https://hceris.com/mock-verification-in-kotlin/" rel="noopener ugc nofollow" target="_blank">模仿。在那篇文章中，我用</a><a class="ae kl" href="https://github.com/robstoll/atrium" rel="noopener ugc nofollow" target="_blank">心房</a>来写我的断言。此后我给了<a class="ae kl" href="https://github.com/robfletcher/strikt" rel="noopener ugc nofollow" target="_blank"> Strikt </a>一个尝试，这是另一个很酷的小库。与此同时，我在工作中使用了AssertJ ,所以我最近有机会尝试了很多！</p><p id="f9d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我觉得有两个小技巧值得分享:</p><ul class=""><li id="ee72" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">数据类的断言</li><li id="3cbd" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">自定义断言</li></ul><h1 id="0036" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><a class="ae kl" href="https://kotlinlang.org/docs/reference/data-classes.html" rel="noopener ugc nofollow" target="_blank">数据类的断言</a></h1><p id="210b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们的函数接收并返回数据类。这意味着我们的测试通常会期望一个这样的类的特定实例。对于断言，我们首先使用<code class="fe me mf mg mh b">isEqualTo</code>来比较整个实例。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="62c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着类变得越来越复杂，这种方法就成了一个问题。也许它们包含其他实体，或者有列表或地图。生成一个合适的实例来让<code class="fe me mf mg mh b">isEqualTo</code>开心最终会是一项繁重的工作。</p><p id="085a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们只想检查一些属性。我更喜欢在一个测试中避免多重断言，但是在这种情况下，我认为这是不可避免的。这是我为<em class="km"> AssertJ </em>使用的解决方案，随后是为<em class="km"> Strikt </em>使用的解决方案</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="773f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的很喜欢<em class="km"> Strikt </em>解决方案的紧凑性。公平地说，我们可以用<code class="fe me mf mg mh b">apply</code>来压缩<em class="km">资产</em>资产。但是我更喜欢第二个。</p><p id="c115" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">错误消息是什么？拥有不同断言的一个缺点是，您会得到一个缺乏上下文的错误消息:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5a25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不仔细看测试，谁能理解呢？幸运的是，我们的解决方案提供了更有意义的信息:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="fbc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好多了，不是吗？</p><h1 id="c1cb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自定义断言</h1><p id="185c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让断言说得更多的一个方法是根据我们的需要扩展它们。例如，我最近一直在玩<a class="ae kl" href="https://arrow-kt.io/" rel="noopener ugc nofollow" target="_blank"> Arrow </a>(我相信它本身可以成为博客帖子的无尽来源)。我尽可能避免使用异常，而是使用数据类型。或者<em class="km"> Monad </em>，好像我真的不知道自己在说什么。</p><p id="6619" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论如何，我有一个包含我想要测试的功能的存储库。</p><p id="c51e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">fun find(id: Int): Either&lt;Int, RecipeDetails&gt;</code></p><p id="5a55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我正在调用这个方法，并且想要断言我得到了一个有效的返回(<code class="fe me mf mg mh b">Either.Right</code>)。然后，我想检查输出的一些属性:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2ef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码有点不尽人意。我必须检查该值是否是一个<code class="fe me mf mg mh b">Right</code>值，转换它，然后在开始断言之前获取实际内容。对我们来说幸运的是，<em class="km"> Strikt </em>允许您编写<a class="ae kl" href="https://strikt.io/wiki/custom-assertions/" rel="noopener ugc nofollow" target="_blank">定制断言</a>，非常适合这种情况。在敲了一会儿键盘后，我找到了这个助手:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a35d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我是这样使用的:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="cdc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变化不大。然而，它增加了这个小片段的可读性，并使其背后的意图更加清晰。我喜欢用心良苦的代码。</p><p id="fc3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对<a class="ae kl" href="https://arrow-kt.io/docs/arrow/core/option/" rel="noopener ugc nofollow" target="_blank">选项数据类型</a>也可以这样做:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="6883" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么呢？</h1><p id="65c5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们完成了什么？在我看来，有两件事:</p><ul class=""><li id="d07f" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">测试将更好地讲述测试的内容和原因。</li><li id="4d64" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">当他们失败时，就更容易找出原因。</li></ul></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="bb81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">原载于2019年9月28日</em><a class="ae kl" href="https://hceris.com/descriptive-assertions-in-kotlin/" rel="noopener ugc nofollow" target="_blank"><em class="km">https://hceris.com</em></a><em class="km">。</em></p></div></div>    
</body>
</html>