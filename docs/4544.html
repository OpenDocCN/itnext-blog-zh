<html>
<head>
<title>Advanced NestJS techniques — Part 3 — Logging Elasticsearch queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级NestJS技术—第3部分—记录弹性搜索查询</h1>
<blockquote>原文：<a href="https://itnext.io/advanced-nestjs-techniques-part-3-logging-elasticsearch-queries-ae118a7a9d4c?source=collection_archive---------1-----------------------#2020-07-21">https://itnext.io/advanced-nestjs-techniques-part-3-logging-elasticsearch-queries-ae118a7a9d4c?source=collection_archive---------1-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/868c4c1e11a95b903f93beecb18e0c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*ayYByQ3D88-uHUMcrBu8yg.jpeg"/></div></figure><p id="fb2f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我将向您展示如何很好地记录NestJS应用程序对Elasticsearch进行的每个HTTP查询。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="0638" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">目标</h1><p id="8b23" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">本系列的第2部分是关于记录对外部HTTP服务的HTTP请求，无论它们是您的堆栈中的其他服务还是公共API。</p><p id="abb0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">记录业务逻辑很容易(或者至少开始很容易):创建一个记录器或者从某个地方获得它(实际上我更喜欢从工厂获得一个新的实例)，然后开始记录与您的业务逻辑相关的任何东西。</p><blockquote class="md me mf"><p id="3ac1" class="ju jv mg jw b jx jy jz ka kb kc kd ke mh kg kh ki mi kk kl km mj ko kp kq kr ij bi translated">但是我有一个更大的目标，那就是记录我的应用程序所依赖的服务的每个调用(HTTP或其他任何东西)。</p></blockquote><p id="5254" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，使用Postgres和Sequelize ORM记录SQL查询很容易:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="1f45" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将HTTP查询记录到Elasticsearch有点棘手，因为正如这里的<a class="ae mc" href="https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/7.x/observability.html" rel="noopener ugc nofollow" target="_blank">所描述的</a>，Elasticsearch没有提供默认的记录方式，我们必须通过一个关联ID来关联请求和响应。所以让我们开始吧。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="f684" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">警告</h1><p id="0b41" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">如果你担心创建一个无限循环，因为你的应用程序已经向Elasticsearch发送日志，那么我建议你停止这样做。</p><p id="8dd1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个<a class="ae mc" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">十二要素应用</a>的12个核心原则之一是，将日志发送到特定存储不应该是应用本身的责任。应用程序通常应该将日志输出到stdout / stderr，底层基础架构应该路由、增加相关元数据并在适当的位置存储这些日志。</p><p id="b594" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些原则的目标是拥有一个无需重大更改即可轻松部署到任何现代云平台的应用程序。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="db71" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是我们将通过日志记录改进的基本应用程序:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="ba38" class="kz la iq bd lb lc mq le lf lg mr li lj lk ms lm ln lo mt lq lr ls mu lu lv lw bi translated">探测</h1><p id="5441" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">下面是观察Elasticsearch客户端在不同情况下如何表现的第一步:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="93b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们做了两件事:</p><ul class=""><li id="9d24" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr na nb nc nd bi translated">用UUID替换默认生成的ID(一个递增的数字)。如果/当我们的服务器重启时，它将避免重复使用id</li><li id="c90d" class="mv mw iq jw b jx ne kb nf kf ng kj nh kn ni kr na nb nc nd bi translated">将此ID记录到控制台</li></ul><p id="2835" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们应该已经观察到:</p><ul class=""><li id="9cea" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr na nb nc nd bi translated">如果请求成功，事件“请求”被触发一次，事件“响应”被触发一次</li><li id="3ab7" class="mv mw iq jw b jx ne kb nf kf ng kj nh kn ni kr na nb nc nd bi translated">如果请求因为Elasticsearch关闭而失败，客户端将重试几次，我们将得到多个“请求”事件，但只有一个“响应”事件</li><li id="6434" class="mv mw iq jw b jx ne kb nf kf ng kj nh kn ni kr na nb nc nd bi translated">如果请求无效(“索引_未找到_异常”等)。)，没有重试，我们得到每个事件的单个事件</li></ul><p id="235a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以利用这一点。</p><h1 id="82e4" class="kz la iq bd lb lc mq le lf lg mr li lj lk ms lm ln lo mt lq lr ls mu lu lv lw bi translated">履行</h1><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5f30" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">非常简单的实现。如果需要，我们可以通过查看响应主体的内容来记录更多的内容，比如返回的点击次数、碎片等。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="8732" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="363b" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">如果你一直在关注第一部分的<a class="ae mc" href="https://medium.com/@paztek/advanced-nestjs-techniques-part-1-custom-decorators-aa6d7f85c5b6" rel="noopener">和第二部分</a>的<a class="ae mc" href="https://medium.com/@paztek/advanced-nestjs-techniques-part-2-logging-outgoing-http-requests-3c75d47c5768" rel="noopener">，你可能会注意到出现了两种模式:</a></p><ol class=""><li id="9454" class="mv mw iq jw b jx jy kb kc kf mx kj my kn mz kr nj nb nc nd bi translated">当我们需要在应用程序开始时连接一些东西，并且不再与它交互时，看起来模块生命周期的“onModuleInit()”方法是放置代码的最佳位置。</li><li id="1962" class="mv mw iq jw b jx ne kb nf kf ng kj nh kn ni kr nj nb nc nd bi translated">为了避免AppModule上拥挤的“onModuleInit()”方法，我声明了像HttpModule或ElasticsearchModule这样的专用模块来处理这些初始化步骤。</li></ol><p id="e9af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我喜欢这些模式，但如果您对在哪里/如何进行这些初始化步骤有其他意见，我会更喜欢受到挑战。</p><p id="6d82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">像往常一样，我留给你完整资源库的链接:【https://github.com/paztek/nestjs-elasticsearch-example T4】</p><p id="f256" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第4部分将讨论记录对Redis的调用。敬请关注。</p></div></div>    
</body>
</html>