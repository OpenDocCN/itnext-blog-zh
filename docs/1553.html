<html>
<head>
<title>Lazy loading polyfills with WebPack and dynamic imports</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WebPack和动态导入延迟加载聚合填充</h1>
<blockquote>原文：<a href="https://itnext.io/lazy-loading-polyfills-4b85c4951e73?source=collection_archive---------1-----------------------#2018-11-22">https://itnext.io/lazy-loading-polyfills-4b85c4951e73?source=collection_archive---------1-----------------------#2018-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/72d47bb64f23dfaceb209f0fbbf955d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9wFznBmPhRzaiRpLkmlhQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://medium.com/beginners-guide-to-mobile-web-development/introduction-to-polyfills-their-usage-9cd6db4b1923" rel="noopener">形象信用</a></figcaption></figure><p id="118c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都喜欢ES6，有了<a class="ae kc" href="https://babeljs.io" rel="noopener ugc nofollow" target="_blank"> Babel </a>，我们能够在还不支持它的浏览器中使用最新的语法。然而，一些浏览器不仅缺乏对最新语法的支持，而且还缺乏一些更新的功能，这些功能是Babel无法通过简单的代码转换来添加的。</p><p id="41f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种特性的一个很好的例子是异步的<code class="fe lb lc ld le b"><a class="ae kc" href="https://caniuse.com/#feat=fetch" rel="noopener ugc nofollow" target="_blank">fetch</a></code>，这在例如IE 11中是不可用的。</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lf"><img src="../Images/060b3c52d5a3c7b7d41c371643f71888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNUxQ9KRXEuLrL9Yqj_5yg.png"/></div></div></figure><p id="660f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们需要导入一个库，只有在不支持它的浏览器中运行时，它才会添加一个缺失的特性。这种常见的技术被称为<a class="ae kc" href="https://en.wikipedia.org/wiki/Polyfill_(programming)" rel="noopener ugc nofollow" target="_blank">聚合填充</a>。</p><p id="56b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe lb lc ld le b">fetch</code>有一个很好的聚合填充，叫做<code class="fe lb lc ld le b"><a class="ae kc" href="https://www.npmjs.com/package/whatwg-fetch" rel="noopener ugc nofollow" target="_blank">whatwg-fetch</a></code>，所以在这种情况下我们通常会做的是安装包:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="3552" class="lo lp iq le b gy lq lr l ls lt">npm i --save <!-- -->whatwg-fetch</span></pre><p id="2471" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在入口文件(<code class="fe lb lc ld le b">index.js</code>)中引用它，以确保它在应用程序的其余部分加载之前执行:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="7db4" class="lo lp iq le b gy lq lr l ls lt">import '<!-- -->whatwg-fetch'</span></pre><p id="cadc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样我们不需要在任何其他模块中引用它，并且当浏览器已经本地支持<code class="fe lb lc ld le b">fetch</code>时，包本身什么也不做。</p><h1 id="e72c" class="lu lp iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">绩效</h1><p id="79fa" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">这对你的应用性能有什么影响？<code class="fe lb lc ld le b">whatwg-fetch</code>包大约是8k (3k gzipped)，所以很可能不会有很大的影响，但仍然需要所有浏览器进行不必要的加载和处理，这感觉有点浪费。</p><p id="428d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得庆幸的是ES6 <strong class="kf ir"> </strong> <a class="ae kc" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">动态导入</strong> </a>提议(这里也可以阅读<a class="ae kc" href="http://2ality.com/2017/01/import-operator.html" rel="noopener ugc nofollow" target="_blank"/>)，加上Webpack分块，非常方便，允许我们只在真正需要的时候懒惰地加载这些依赖项。</p><p id="6dd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，动态导入不是引用一个模块，而是返回一个<code class="fe lb lc ld le b">Promise</code>，一旦模块被完全加载，它就会被满足:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="a376" class="lo lp iq le b gy lq lr l ls lt">import('module/path/file.js')<br/>  .then(someModule =&gt; someModule.foo())<br/>  .catch((e) =&gt; console.error(e))</span></pre><p id="ecc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这允许我们等待执行应用程序的其余部分，直到惰性加载的模块完全可用。</p><h1 id="8e52" class="lu lp iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">惰性装填聚合填料</h1><p id="aec1" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">假设您的应用程序已经在使用Webpack和babel，您需要做的第一件事就是在Babel中启用动态导入支持:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="e463" class="lo lp iq le b gy lq lr l ls lt">npm i --save-dev @babel/plugin-syntax-dynamic-import</span></pre><p id="73ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后将其添加到<code class="fe lb lc ld le b">babel.config.js</code></p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="0cd2" class="lo lp iq le b gy lq lr l ls lt">plugins: [<br/>  '@babel/plugin-syntax-dynamic-import'<br/>]</span></pre><p id="0877" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以只在需要的时候修改<code class="fe lb lc ld le b">index.js</code>和延迟加载<code class="fe lb lc ld le b">fetch</code> polyfill:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="b452" class="lo lp iq le b gy lq lr l ls lt">if (!window.fetch) {<br/>  fetch.push(import(/* webpackChunkName: "polyfill-fetch" */ 'whatwg-fetch'))<br/>}</span></pre><p id="0e32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Webpack很聪明，知道当解析动态导入时，我们不需要立即使用这个文件。所以它会自动将它移到一个单独的块中。运行build后，我们将得到:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="5d5b" class="lo lp iq le b gy lq lr l ls lt">app.js<br/>polyfill-fetch.js</span></pre><p id="5818" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lb lc ld le b">webpackChunkName</code>指令定义这个附加文件的名称，如果需要，我们可以将许多聚合填充组合成一个块。太棒了。</p><h1 id="e57b" class="lu lp iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">等待加载所需的聚合填料</h1><p id="8542" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">然而，我们可能无法继续应用程序，直到这样一个多填充加载。假设我们的<code class="fe lb lc ld le b">index.js</code>看起来很受欢迎:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="bf38" class="lo lp iq le b gy lq lr l ls lt">import '<!-- -->whatwg-fetch'</span><span id="a76e" class="lo lp iq le b gy ne lr l ls lt">import app from './app.js'</span><span id="05a3" class="lo lp iq le b gy ne lr l ls lt">app()</span></pre><p id="9d4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，由于我们正在延迟加载<code class="fe lb lc ld le b">fetch</code>，我们将等到它可用:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="3cd6" class="lo lp iq le b gy lq lr l ls lt">import app from './app.js'</span><span id="2f4b" class="lo lp iq le b gy ne lr l ls lt">const polyfills = []</span><span id="3819" class="lo lp iq le b gy ne lr l ls lt">if (!window.fetch) {<br/>  polyfills.push(import(/* webpackChunkName: "polyfill-fetch" */ 'whatwg-fetch'))<br/>}</span><span id="952e" class="lo lp iq le b gy ne lr l ls lt">Promise.all(polyfills)<br/>  .then(app)<br/>  .catch((error) =&gt; {<br/>    console.error('Failed fetching polyfills', error)<br/>  })</span></pre><p id="0f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lb lc ld le b">polyfills</code>数组为空，将立即执行<code class="fe lb lc ld le b">app</code>。否则，对于缺少<code class="fe lb lc ld le b">fetch</code>的浏览器来说，它会一直等到加载完毕。</p><h1 id="9272" class="lu lp iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">等一堆polyfills</h1><p id="e956" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">如果您需要等待一组聚合填充，您可能需要处理将它们加载到单独文件中的逻辑:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="a6ed" class="lo lp iq le b gy lq lr l ls lt">// polyfills/a.js</span><span id="c863" class="lo lp iq le b gy ne lr l ls lt">const polyfillA = []</span><span id="0a04" class="lo lp iq le b gy ne lr l ls lt">if (<em class="nf">condition</em>) {<br/>  polyfillA.push(import(/* webpackChunkName: "polyfill-a" */ 'a..'))<br/>}</span><span id="326f" class="lo lp iq le b gy ne lr l ls lt">export default polyfillA</span><span id="9b84" class="lo lp iq le b gy ne lr l ls lt">// polyfills/b.js</span><span id="bdbf" class="lo lp iq le b gy ne lr l ls lt">const polyfillB = []</span><span id="6404" class="lo lp iq le b gy ne lr l ls lt">if (<em class="nf">condition</em>) {<br/>  polyfillB.push(import(/* webpackChunkName: "polyfill-b" */ 'b..'))<br/>  polyfillB.push(import(/* webpackChunkName: "polyfill-b" */ 'c..'))<br/>}</span><span id="03d1" class="lo lp iq le b gy ne lr l ls lt">export default polyfillB</span></pre><p id="7592" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后可以连接成一个<code class="fe lb lc ld le b">polyfills/index.js</code></p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="78f2" class="lo lp iq le b gy lq lr l ls lt">import polyfillA from './a'<br/>import polyfillB from './b'</span><span id="3a90" class="lo lp iq le b gy ne lr l ls lt">export default [<br/>  ...polyfillA,<br/>  ...polyfillB<br/>]</span></pre><p id="6e3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并在<code class="fe lb lc ld le b">index.js</code>中并行加载</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="2ab8" class="lo lp iq le b gy lq lr l ls lt">import <!-- -->polyfills<!-- --> from './<!-- -->polyfills<!-- -->'<br/>import app from './app.js'</span><span id="ea02" class="lo lp iq le b gy ne lr l ls lt">Promise.all(polyfills)<br/>  .then(app)<br/>  .catch((error) =&gt; {<br/>    console.error('Failed fetching polyfills', error)<br/>  })</span></pre><h1 id="fc39" class="lu lp iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">替代解决方案</h1><p id="1e17" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">最受欢迎的替代解决方案之一是<a class="ae kc" href="https://polyfill.io" rel="noopener ugc nofollow" target="_blank"> polyfill.io </a>服务，它使用基于用户代理识别的服务器端特征检测。虽然也可以使用类似于本文中介绍的<a class="ae kc" href="https://polyfill.io/v2/docs/examples#feature-detection" rel="noopener ugc nofollow" target="_blank">客户端特性检测</a>。</p><p id="a5c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使本解决方案更好的是:</p><ul class=""><li id="2882" class="ng nh iq kf b kg kh kk kl ko ni ks nj kw nk la nl nm nn no bi translated">完全受控的客户端功能检测</li><li id="f4ae" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated">完全受控的polyfill库选择(和版本)</li><li id="6f82" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated">网络包摇树</li><li id="a11c" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated">纯粹使用您自己的域(以防<a class="ae kc" href="https://polyfill.io" rel="noopener ugc nofollow" target="_blank"> polyfill.io </a>被您的客户端防火墙阻止)</li></ul><h1 id="0a42" class="lu lp iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结论</h1><p id="986c" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">对于运行现代浏览器的大多数用户来说，将聚合填充拆分为单独的块有助于限制应用程序的大小。但仍能让老年人使用。</p><p id="bc64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">延迟并行加载polyfills限制了它们的负面影响，特别是对于HTTP1.0，但是请记住，旧浏览器通常会一次下载大约4个javascript文件。</p><p id="bc47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看实施所述解决方案的<a class="ae kc" href="https://github.com/pkuczynski/medium-lazy-load-polyfills" rel="noopener ugc nofollow" target="_blank">演示项目</a>。</p><p id="f2a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nf">感谢</em> <a class="nu nv ep" href="https://medium.com/u/c8ff24782d8f?source=post_page-----4b85c4951e73--------------------------------" rel="noopener" target="_blank"> <em class="nf">马特恩</em> </a> <em class="nf">对本文的校对。</em></p></div></div>    
</body>
</html>