<html>
<head>
<title>Levenshtein Distance in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿中的Levenshtein距离</h1>
<blockquote>原文：<a href="https://itnext.io/levenshtein-distance-in-typescript-6de81ea2fb63?source=collection_archive---------3-----------------------#2020-07-04">https://itnext.io/levenshtein-distance-in-typescript-6de81ea2fb63?source=collection_archive---------3-----------------------#2020-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="426c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">模糊字符串比较去神秘化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d51e3abece3a9b9691ef48b3db730828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqTJaOoAo_XK9Figy05yAg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">杰森·登特在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fbd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模糊字符串匹配在编程中有很多应用，但实现起来并不容易。有许多不同的方式可以使两根弦不同，但仍然看起来与人眼相似。确定两个字符串“相同”的一种(可编程的)方法是计算需要对一个字符串进行的单个字符修改的数量，以便将转换为另一个字符串。这叫做两根弦之间的Levenshtein距离。</p><p id="eb7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了计算Levenshtein距离，我们确定了从一个字符串到另一个字符串所需的最小编辑量。允许的修改是替换、添加或删除字符串中的单个字符。有了这个数字，如果我们记住字符串的长度，我们可以说两个字符串有多相似。对长度为三的字符串进行三次编辑操作当然与对长度为三十个字符的字符串进行三次操作不同。</p><h1 id="e8cd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基本实现</h1><p id="fc95" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">实现Levenshtein最简单的方法是使用递归函数的强力方法。在计算编辑距离时，我们从字符串的前两个字符开始，将它们之间的距离加上其余两个字符串之间的距离。在查看两个字符串时，我们需要考虑四种不同的情况:</p><ul class=""><li id="058e" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">第一个字符串为空。在这种情况下，距离是第二个字符串的长度，因为我们需要对该字符串中的每个字符进行插入操作。</li><li id="06da" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">第二个字符串为空。这里我们返回第一个字符串的长度，原因同上。</li><li id="1ff4" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">第一个字符串的第一个字符等于第二个字符串的第一个字符。我们不需要对第一个字符进行编辑，所以距离就是其余两个字符串的距离。</li><li id="96ef" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">第一个字符不相等。在这种情况下，编辑距离是1加上其余两个字符串的编辑距离。这里我们有一个难题:我们对当前第一个字符使用的操作将影响其余字符串的编辑距离。这就是强力部分发挥作用的地方。我们计算所有可能操作的编辑距离，然后使用距离最小的一个。</li></ul><p id="8414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在TypeScript中，这可以如下所示实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是一个相对容易编写和推理的函数，但它的效率也非常低。<code class="fe ni nj nk nl b">levenshtein(‘barbaz’, ‘bazbar’)</code>将调用<code class="fe ni nj nk nl b">levenshtein</code>函数141次，输入<code class="fe ni nj nk nl b">(‘z’, ‘’)</code>和<code class="fe ni nj nk nl b">(‘’, ‘r’)</code>将分别被处理22次。而且这个数字会在弦变长的时候快速增长。</p><h1 id="95a1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">动态编程实现</h1><p id="be8e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在动态编程中找到了一种更有效、更好的计算两个字符串之间的Levenshtein距离的方法。这里我们使用一个矩阵，其中两个字符串组成了<code class="fe ni nj nk nl b">x</code>和<code class="fe ni nj nk nl b">y</code>轴，值是从它们的索引开始的字符串之间的距离。这可以用一些例子来说明:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/201a218b48b70104db3f1dc1b4428725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*nL5P_gH0Z5hzNIVJnm4tkg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片取自<a class="ae ky" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="e603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种矩阵中的最小距离是右下角的值。我们可以计算矩阵中的所有值，而不必重新计算两个字符串之间的距离两次。用子串之间的距离填充矩阵分几个步骤完成:</p><ul class=""><li id="b011" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">创建一个长度为<code class="fe ni nj nk nl b">a</code>乘以<code class="fe ni nj nk nl b">b</code>的矩阵。所有值都应该用<code class="fe ni nj nk nl b">0</code>初始化。</li><li id="3224" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">用它们各自的索引填充左侧垂直轴和顶部水平轴。这些值是正确的，因为我们可以通过使用<code class="fe ni nj nk nl b">n</code>插入从空字符串创建一个字符串。</li><li id="ca5e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">之后我们遍历矩阵中的每个单元。为了确定一个槽的值，我们不需要像以前的实现那样对每条路径进行强力运算。我们可以通过回顾矩阵并将成本加到该单元的当前成本来计算每个操作的成本。对于删除，我们将<code class="fe ni nj nk nl b">i</code>降低1，对于插入，我们将<code class="fe ni nj nk nl b">j</code>降低1，以获得正确的单元格。对于这两个操作，我们总是增加一个成本。为了替换，我们将<code class="fe ni nj nk nl b">i</code>和<code class="fe ni nj nk nl b">j</code>降低一个，只有当我们实际上必须替换字符时才增加成本。我们再次将可能的最短距离作为该单元的成本。</li></ul><p id="a944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实际实施中，我们还需要在回顾矩阵时考虑零参考误差。完整的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="661f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这种实现已经比强制距离有效得多，但是仍然有更有效的算法来计算Levenshtein距离。可以只使用两行矩阵，并减少需要存储和计算的单元数量。还有一个版本使用了分而治之的方法<em class="nn"> ( </em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Hirschberg%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="nn">【赫希伯格】</em> </a> <em class="nn"> ) </em>，性能甚至更好。但是这些都只是标准动态编程实现的改进版本，所以如果您感兴趣的话，我会让您自己去查找。</p><h1 id="8c5c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="600b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们研究了多种比较模糊字符串的方法。这在搜索、拼写检查和其他处理文本的软件中有应用，这些文本需要以人类逻辑的方式进行比较。我希望你喜欢阅读这篇文章。</p></div></div>    
</body>
</html>