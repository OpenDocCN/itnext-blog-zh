<html>
<head>
<title>Expanding on UUIDv1 Security Issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展UUIDv1安全问题</h1>
<blockquote>原文：<a href="https://itnext.io/expanding-on-uuidv1-security-issues-751a02460f81?source=collection_archive---------0-----------------------#2022-10-20">https://itnext.io/expanding-on-uuidv1-security-issues-751a02460f81?source=collection_archive---------0-----------------------#2022-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bd03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个星期，几乎毫无例外，我都会遇到一件让我困惑、娱乐或者最常见的激怒我的事情。我决定记录我的冒险经历。</p><p id="1bc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本周早些时候，Daniel Thatcher 发表了一篇关于<a class="ae kl" href="https://www.intruder.io/research/in-guid-we-trust" rel="noopener ugc nofollow" target="_blank">滥用安全应用中的UUIDv1 </a>令牌的文章。那篇博客的要点和这篇文章的要点一样:<strong class="jp ir">只在安全应用中使用UUIDv4】。我们将在本周和下周更深入地研究UUIDv1(以及扩展的UUIDv2)令牌。</strong></p><h1 id="ebb5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">背景</h1><p id="2470" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">诚然，我花了很长时间通读post和RFC，才真正理解UUIDv1是一种编码机制，而不是散列机制。正如Daniel在<a class="ae kl" href="https://github.com/intruder-io/guidtool" rel="noopener ugc nofollow" target="_blank">他的工具</a>中所展示的，该工具主要是利用Python <a class="ae kl" href="https://github.com/python/cpython/blob/main/Lib/uuid.py" rel="noopener ugc nofollow" target="_blank"> UUID库</a>(为什么要重新创建功能代码)，UUIDv1令牌的分解如下:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/fe12108334a3f77a932b22d674425e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MgyHF88DHOm-6oV7"/></div></div></figure><p id="37a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，这是完全可逆的。虽然“众所周知”UUIDv1的使用具有泄露MAC地址的隐私后果(见鬼，甚至<a class="ae kl" href="https://stackoverflow.com/questions/534839/how-to-create-a-guid-uuid-in-python" rel="noopener ugc nofollow" target="_blank"> stackoverflow警告了这一点</a>)，但大多数文档并没有强调它在多用户环境中生成UUIDs所固有的潜在随机性不足。真的，所有的UUID文档都应该有一个警告，表明你是否在寻找random——uuid v4是你想要的。</p><p id="e5e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，有没有这样一种情况，UUIDv1仍然可以合理地安全使用呢？好吧，合理可能不是正确的措辞——我称之为“商业可接受”。这个术语与“学术上可接受的”形成对比，在“学术上可接受的”中，没有1000个开发者争论的研究人员经常哀叹为什么所有假设的问题没有被立即解决。</p><h1 id="4964" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题是</h1><p id="16bb" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在我们的场景中，假设您在一个安全上下文中发现了一个使用UUIDv1的服务，但是开发人员无法确定修复的优先级，有没有什么情况下这并不重要？</p><p id="54c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们应该记住，Daniel博客中描述的主要问题是被多个用户使用的服务。这种配置意味着同一台服务器正在生成UUIDv1令牌，这实际上导致了令牌的MAC部分和时钟序列(62位)被泄露。作为一个因素，这将UUIDv1的安全窗口减少到了时间，正如我们所看到的，这可能是一个问题。</p><p id="9486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想强调三种备选方案，并对它们进行研究:</p><ol class=""><li id="78bd" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">一种服务，其中用户向服务器提供UUIDv1令牌来唯一地表示他们自己(考虑这类似于Duo Device Health如何使用MachineGUID来唯一地标识主机，尽管那是UUIDv4)</li><li id="313d" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">一个向用户提供UUIDv1令牌散列版本的服务(<em class="mp">作者注:我实际上在阅读一些SAML代码</em>时看到了一个这样的例子)</li><li id="9dac" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">一个以明文形式向用户提供UUIDv1令牌的服务，但支持纳秒级的时间组件(这与Daniel的博客场景相同，但支持符合<a class="ae kl" href="https://datatracker.ietf.org/doc/html/rfc4122" rel="noopener ugc nofollow" target="_blank">RFC</a>的UUIDv1)</li></ol><p id="4efd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样的实现“安全”吗？</p><h1 id="bcd1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">解决方案</h1><p id="e0a5" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在前两种情况下，问题归结为猜测MAC地址。MAC地址并不是完全随机的，并且有固定的数量，但是正如你们大多数人所知，MAC地址只由6对十六进制数字组成。对此最天真的解释是16种可能的组合(刚好超过281万亿种组合)。从表面上看，即使确切的时序和时钟序列是已知的，这也会对MAC搜索空间进行彻底的暴力攻击，这是非常不合理的。</p><p id="62df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这并没有说明OUIs。MAC地址的前三个八位字节保留用于识别网络接口的制造商(<em class="mp">作者注:主要是在全球MAC中，下周会有更多关于此的内容</em>)。查看由IEEE 维护的<a class="ae kl" href="https://standards-oui.ieee.org/" rel="noopener ugc nofollow" target="_blank"> OUI列表，人们会立即被各种可能不生产客户端硬件的制造商所震惊。因此，大致了解你的目标使用什么类型的硬件可以大大减少你的搜索空间。例如，如果你知道你的目标使用苹果设备，而不是281万亿台苹果电脑，你只剩下1600多万个可能的选择。</a></p><p id="9005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景1 </strong></p><p id="f698" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在场景1中，攻击者可能需要为每个可能的时间戳发送大约1600万个请求(加上一些额外的序列)。该博客指出了关于该时间戳的最重要的信息之一，即尽管能够达到100纳秒的间隔(每秒1000万个)，但“系统在生成GUIDs时使用这种精度水平是不常见的”，而不是使用毫秒精度，这意味着每秒钟有1000个可能的时间戳值(<em class="mp">作者注:粗略检查后，我实际上无法， 要在node之外找到这样做的任何实现，</em> <a class="ae kl" href="https://github.com/python/cpython/pull/11189" rel="noopener ugc nofollow" target="_blank"> <em class="mp">当然不是Python </em> </a> <em class="mp"> —因此场景3 </em> ) —这在一秒钟内将搜索空间从1600万增加到160亿，但平均会在80亿次请求后完成。</p><p id="0234" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">场景1的主要问题是，即使中央服务在同一个网络上，它也在验证这个请求，因此存在网络和处理延迟，假设即使每秒<a class="ae kl" href="https://ubiq.co/tech-blog/increase-apache-requests-per-second/" rel="noopener ugc nofollow" target="_blank"> 160个请求</a>，平均仍需要2年时间才能发生冲突。<strong class="jp ir">所以，大部分类似场景1的网络攻击都是不现实的。</strong></p><p id="a426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景二</strong></p><p id="660e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是场景2呢，在这个场景中，攻击者有一个哈希的UUIDv1，一旦他们与哈希冲突，他们就会知道服务器的MAC地址。相比之下，这有一些独特的优势，时间多少是已知的，更重要的是，攻击可以离线完成。此外，一旦完成，我们就拥有了与最初的博客相同的信息，攻击也大致相同(只是由于增加了哈希运算而稍微慢了一点)。</p><p id="c89e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器硬件有时很容易猜测。数据中心产品中通常只使用有限的网卡子集。同样，公司内部的物理硬件通常也是标准化的。这意味着来自任何组织的任何UUIDv1都有可能(可能)与他们的其余服务器反映相同的MAC OUI。此外，正在使用的编排器和虚拟机通常允许有限的搜索空间。例如，Docker似乎总是分配相同的MAC(大约65K):</p><pre class="lq lr ls lt gt mq mr ms mt aw mu bi"><span id="0d1b" class="mv kn iq mr b gy mw mx l my mz">The MAC address is generated using the IP address allocated to the container to avoid ARP collisions, using a range from 02:42:ac:11:00:00 to 02:42:ac:11:ff:ff</span></pre><p id="1895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，VMWare使用“00:50:56”作为VSphere主机的前缀，VirtualBox主机使用“08:00:27”等。与前面提到的主机不同，EC2和GCP计算实例似乎有随机的MAC地址。当然，这些MAC不是真正随机的，很可能是基于主机的网络/IP地址生成的，而是基于\_(ツ)_/。</p><p id="d5b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设使用的MAC范围有时可以合理地猜测，那么场景2归结为猜测，在最坏的情况下，该提供商的所有MAC(1600万)，如果我们这样做一秒钟(1000毫秒)，我们将生成大约160亿个散列。尽管这与场景1的复杂性相似，但场景2是离线的。原来现代的图形处理器可以在一两秒钟内完成。这也只需要在每台服务器上做一次，所以回报是相当不错的。<strong class="jp ir">因此，这种攻击是完全可行的。</strong></p><p id="f5ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想测试这种攻击有多可行，因为它已经正确地猜出了MAC地址的前6个字节(<em class="mp">作者注:这让我经历了一次如何确定MAC地址的冒险，我们将在下周的博客</em>中讨论)。<a class="ae kl" href="https://github.com/csanders-git/uuidv1-bruteforcing" rel="noopener ugc nofollow" target="_blank">这项工作的解决方案</a>花了大约10秒钟为我的苹果M1上的所有序列和MAC生成一个有效的UUID。每隔3秒做一次需要20，000，000次迭代，这在我的电脑上需要9年时间。当然，这是在没有并行化的情况下，同时使用低效的python，并且不使用任何GPU增强。</p><p id="8189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景3 </strong></p><p id="1766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">早些时候，我做了一个值得重复的附加声明。虽然最初的作者稍微掩饰了一下这个事实，但是如果uuidv1实现<em class="mp">确实遵循了RFC 请求的<a class="ae kl" href="https://datatracker.ietf.org/doc/html/rfc4122" rel="noopener ugc nofollow" target="_blank">纳秒/100实现，那么<strong class="jp ir">就会发现一个正确的UUIDv1实现实际上对于偶然的攻击是相当安全的。</strong>即使考虑到最初博客中描述的弱点，也需要每秒1000万次请求(平均500万次<strong class="jp ir"> ) </strong>才能正确实现。这在我们的光学场景中变得更加糟糕。对于场景1，对所有MAC地址的一秒间隔搜索将需要160万亿次请求。即使在第二种情况下，搜索是使用已知的OUI离线完成的，攻击者也需要生成16万亿个哈希来进行碰撞，这相当于每次碰撞需要大约6个小时的计算，而这只是为了获得服务器的MAC和序列。</a></em></p><p id="48f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">总之，服务仍然不应该依赖UUIDv1，而是应该使用UUIDv4。我们已经表明，在一些网络环境中，当UUIDv1s由客户端而不是单个服务器生成时，弱点是存在的，但不容易被利用。然而，我们已经能够扩大攻击的范围，甚至在服务器的MAC地址没有直接暴露时(例如通过散列UUIDv1)，我们已经表明攻击者完全有能力滥用这个用例。</strong></p></div></div>    
</body>
</html>