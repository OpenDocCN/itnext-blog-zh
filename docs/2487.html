<html>
<head>
<title>Node.js: Module wiring and dependencies explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js:解释了模块连接和依赖关系</h1>
<blockquote>原文：<a href="https://itnext.io/node-js-module-wiring-and-dependencies-explained-9fa5784c5840?source=collection_archive---------0-----------------------#2019-06-01">https://itnext.io/node-js-module-wiring-and-dependencies-explained-9fa5784c5840?source=collection_archive---------0-----------------------#2019-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/76fd0f9d2bacae957e213e4f291748fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBAAzp2dbEan-3sRgVT6yw.jpeg"/></div></div></figure><p id="5185" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">任何实质性的软件项目都由多个文件组成。在JavaScript的早期，让这些文件很好地一起播放并避免名称冲突是令人沮丧的主要原因之一。</p><p id="9685" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Node.js引入的模块化系统解决了这个主要问题。这个系统叫做CommonJs，多亏了它，组件名冲突已经成为过去，每个模块都有自己的作用域，这是组件的避风港。</p><p id="9f7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，即使解决了这个问题，接线模块仍然必须小心处理。您为将组件连接在一起而设置的系统可以决定项目的成败。虽然从一开始就不需要过度工程化，但是知道如何正确地连接模块肯定是值得的。</p><h1 id="413e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">凝聚力和耦合度</h1><p id="d25a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们先复习一下基础知识。</p><p id="ba1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">内聚性衡量你的模块及其组件在做好一件事情上的表现。例如，如果您有一个专门用于识别和过滤垃圾邮件的模块，该模块可能具有很高的内聚性。另一方面，如果你有一个模块公开了修改不同种类的数据库对象的方法，比如<code class="fe mc md me mf b">user</code>、<code class="fe mc md me mf b">account</code>、<code class="fe mc md me mf b">post</code>等等。则该模块将具有较低粘结性。</p><p id="4831" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">耦合度量组件对其他组件的依赖程度。如果一个模块直接访问和修改另一个模块的数据或一些全局变量，那么这个模块就是紧密耦合的，很难对其进行修改。如果两个模块通信的唯一方式是通过它们的函数参数交换值，那么这些模块就是松散耦合的。</p><p id="c1d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据经验，为了创建可伸缩和可维护的系统，您希望以高内聚和松耦合为目标。</p><h1 id="032c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">有状态和无状态模块</h1><p id="780d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在Node.js中，模块可以是无状态的或有状态的:</p><ul class=""><li id="220d" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">stateful——公开某个有状态对象实例的模块<em class="mp">(数据库连接、第三方服务实例、套接字等)。</em></li><li id="e014" class="mg mh it kd b ke mq ki mr km ms kq mt ku mu ky ml mm mn mo bi translated">无状态——公开无状态实体(如类或实用程序方法)的模块。</li></ul><p id="7a34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当使用有状态模块时，你应该有一个单例模式来确保所有其他需要有状态模块的模块访问同一个实例。有了Node.js，由于CommonJs系统的机制，您不必担心以单例模式显式包装有状态模块。</p><p id="2dc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一次需要您的模块时，Node.js将缓存该实例，并在随后的需求中服务于同一个实例。只有当您需要当前包之外的实例时，此操作才会失败。原因是在缓存实例时，Node.js使用该实例的包地址作为键。</p><p id="e0ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用有状态模块比使用无状态模块更重要。虽然无状态模块中的紧密耦合可能对您的架构不利，但是不良连接的影响远没有有状态实例的影响严重。</p><h1 id="ce18" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">属国</h1><p id="2dca" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">当考虑Node.js依赖关系时，首先想到的可能是<code class="fe mc md me mf b">node_modules</code>文件夹的内容。然而，模块正常工作所需的任何组件或数据都属于依赖项。依赖关系可以是任何东西，从数据库连接实例到带有文件路径的简单字符串。</p><p id="fcb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能听说过“硬编码依赖”和“依赖注入”这两个术语，并想知道它们之间的区别。虽然听起来有点模糊，但区别很简单:</p><ul class=""><li id="f36e" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">硬编码的依赖关系指的是模块连接模式，其中您在模块内部硬编码依赖关系的名称，可能使用<code class="fe mc md me mf b">require</code>函数。</li><li id="5173" class="mg mh it kd b ke mq ki mr km ms kq mt ku mu ky ml mm mn mo bi translated">依赖注入是一种连接模式，其中依赖不是硬编码的，而是由外部实体作为输入提供的。</li></ul><p id="a5f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了更好地说明差异，让我们使用两种方法为电影建议构建一个简单的有状态模块:</p><h2 id="78a3" class="mv la it bd lb mw mx dn lf my mz dp lj km na nb ln kq nc nd lr ku ne nf lv ng bi translated">硬编码依赖项</h2><p id="7635" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们从公开数据库连接的模块开始:</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3daf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本模块中，我们启动一个简单的数据库连接实例并将其导出。</p><p id="90b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们的电影建议模块，我们将通过硬编码来指定我们的数据库连接依赖。为了示例的简洁，我省略了方法的实现:</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2ef7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看<code class="fe mc md me mf b">app</code>模块，它将作为主入口点并启动服务器:</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="539c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的例子是开发人员通常如何连接他们的依赖关系——通过将它们硬编码到模块中。以下是使用这种方法的一些优点和缺点:</p><p id="be1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">优点</strong>:</p><ul class=""><li id="0288" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">直观且易于理解——您可以轻松理解并遵循程序的工作流程，因为所有依赖项都是静态注入的。</li><li id="2dc5" class="mg mh it kd b ke mq ki mr km ms kq mt ku mu ky ml mm mn mo bi translated">更容易调试。</li></ul><p id="f3b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缺点</strong>:</p><ul class=""><li id="8c22" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">模块不太灵活，并且与它们的依赖项紧密耦合——在我们的例子中，如果不直接修改movies模块，就不能使用不同的数据库实例。</li><li id="b557" class="mg mh it kd b ke mq ki mr km ms kq mt ku mu ky ml mm mn mo bi translated">更难进行单元测试——因为我们的依赖关系是硬编码的，所以更难为单元测试提供虚拟数据。</li></ul><p id="6b7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">硬编码你的依赖是可以接受的，并且在大多数时候是完全有效的，没有必要过度设计。然而，通过使用依赖注入，我们可以在灵活性和可重用性方面做得更好。</p><h1 id="66a3" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">依赖注入</h1><p id="fea1" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在这个例子中，我们将重构我们的电影建议服务，改为使用依赖注入。让我们从数据库连接模块开始:</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e899" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们的模块公开了一个工厂函数，而不是实例。如您所见，建立连接所需的所有硬编码数据都是由外部实体通过<code class="fe mc md me mf b">settings</code>参数提供的。接下来，让我们重构我们的电影建议模块:</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1a01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的主要依赖——数据库连接也是由外部实体提供的。现在，这个模块为电影建议服务提供了一个工厂函数。最后，让我们看看负责将所有依赖关系正确连接在一起的<code class="fe mc md me mf b">app</code>模块:</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fd69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，我们将设置依赖关系的责任从组件模块转移到了应用程序模块。这是依赖注入的主要概念之一:<strong class="kd iu">将处理依赖关系的工作转移到更高层的组件，这些组件将负责将依赖关系分发给更低层的组件。</strong>这背后的原因是更高级别的组件不太可能被重用或更改，并且更适合紧密耦合。</p><p id="f830" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法的利弊:</p><p id="d2ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">优点</strong>:</p><ul class=""><li id="4182" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">更高的可重用性——在我们的例子中，通过不同的数据库实例使用我们的电影建议服务要容易得多。</li><li id="05ce" class="mg mh it kd b ke mq ki mr km ms kq mt ku mu ky ml mm mn mo bi translated">更容易的单元测试——为单元测试提供虚拟数据变得微不足道。</li></ul><p id="b214" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缺点</strong>:</p><ul class=""><li id="8eb8" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">依赖关系是在运行时连接的——因为我们的依赖关系是在运行时连接到组件的，所以仅通过查看组件很难理解逻辑流程。在我们的例子中，没有增加太多的复杂性，但是你的应用程序越大，管理这些依赖性就越困难。</li></ul><h1 id="3ded" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">依赖注入的类型</h1><p id="0755" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在前面的例子中，我们使用了依赖注入的一种变体——工厂注入。还有两种变化:</p><ul class=""><li id="843f" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">构造函数注入—当您在对象初始化期间定义依赖关系时</li></ul><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ul class=""><li id="a128" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">属性注入——不如前两种健壮，但是当模块之间存在循环依赖时，这种变化有时可能是必要的。</li></ul><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="1663" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">连接模块是构建Node.js应用程序的一个重要方面，花一些时间进行规划是值得的。尝试以模块间的高内聚和松耦合为目标，尤其是在使用有状态模块时。</p><p id="be97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我们讨论了模块连接的两种方法:硬编码依赖和使用依赖注入。这两种方法各有优缺点，了解它们并根据项目的复杂性和需求正确使用它们非常重要。</p><p id="a0ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="35fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原文发表于<a class="ae nu" href="https://isamatov.com/node-module-wiring-dependencies/" rel="noopener ugc nofollow" target="_blank">isamatov.com</a></p></div></div>    
</body>
</html>