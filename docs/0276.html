<html>
<head>
<title>Javascript closures are more than just functions with scope.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript闭包不仅仅是有范围的函数。</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-closures-are-more-than-just-functions-with-scope-f088ee63139e?source=collection_archive---------3-----------------------#2018-02-06">https://itnext.io/javascript-closures-are-more-than-just-functions-with-scope-f088ee63139e?source=collection_archive---------3-----------------------#2018-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="io ip gp gr iq ir"><div class="bz fp l di"><div class="is it l"/></div></figure><div class=""/><div class=""><h2 id="1733" class="pw-subtitle-paragraph jt iv iw bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">什么是结束，你为什么需要它？</h2></div><h1 id="d63f" class="kl km iw bd kn ko kp kq kr ks kt ku kv kc kw kd kx kf ky kg kz ki la kj lb lc bi translated">什么是终结？</h1><p id="2dd8" class="pw-post-body-paragraph ld le iw lf b lg lh jx li lj lk ka ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这是区分新手开发者和菜鸟开发者的最可靠的问题之一。现在有一种趋势，就是“把它弄得很简单”,或者把几乎所有的东西都给人们TLDR，这样他们就可以对天底下的每一个概念都有一个粗略的了解，然后继续他们的生活，做一个无所不能的万事通。闭包也不例外。<a class="ae lz" href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" rel="noopener">这篇博文</a>对这些概念进行了深入的探讨。但是(总有一个)，用“有状态函数”回答提示的tweet形式的非常优雅的定义，从一开始就提供了一个过于简单的定义，这给人们带来了伤害。因为大多数人会读完然后继续前进。我知道这一点，因为我就是这么做的，而且我很确定这让我丢了工作。不管怎样，废话不多说，下面是引擎盖下发生的事情。</p><h1 id="70d9" class="kl km iw bd kn ko kp kq kr ks kt ku kv kc kw kd kx kf ky kg kz ki la kj lb lc bi translated"><strong class="ak">环境</strong></h1><p id="bce4" class="pw-post-body-paragraph ld le iw lf b lg lh jx li lj lk ka ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了深入理解闭包，我们必须首先了解使用环境管理变量的概念。</p><p id="fd77" class="pw-post-body-paragraph ld le iw lf b lg ma jx li lj mb ka ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated"><em class="mf">“当程序执行进入变量的作用域时，变量就存在了。”</em></p><p id="8e01" class="pw-post-body-paragraph ld le iw lf b lg ma jx li lj mb ka ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated"><em class="mf">摘自:阿克塞尔·劳施迈尔。“说JavaScript。”</em></p><p id="2606" class="pw-post-body-paragraph ld le iw lf b lg ma jx li lj mb ka ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">这意味着它们只在被传递时才开始占用内存(有两种方法)。</p><h2 id="8074" class="mg km iw bd kn mh mi dn kr mj mk dp kv lm ml mm kx lq mn mo kz lu mp mq lb mr bi translated">方法1:动态维度:调用函数。</h2><p id="9a27" class="pw-post-body-paragraph ld le iw lf b lg lh jx li lj lk ka ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当一个函数被调用时，它包含的参数和变量的适当空间被清除。这个空间以后应该可以用于垃圾收集。</p><h2 id="194b" class="mg km iw bd kn mh mi dn kr mj mk dp kv lm ml mm kx lq mn mo kz lu mp mq lb mr bi translated">方法2:词法(静态)维度:与周围的作用域保持联系。</h2><p id="ae4c" class="pw-post-body-paragraph ld le iw lf b lg lh jx li lj lk ka ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一个变量总是可以访问周围作用域的变量，这意味着内存也被分配给这些变量。每次调用函数时，它都需要访问自己的局部变量及其周围的作用域。为了访问创建函数的作用域，内部属性<a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Glossary/Scope" rel="noopener ugc nofollow" target="_blank"> [[Scope]] </a>。</p><p id="aa0e" class="pw-post-body-paragraph ld le iw lf b lg ma jx li lj mb ka ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">下面的例子和图表来自阿克塞尔的书，让事情更清楚。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2abe" class="mg km iw mx b gy nb nc l nd ne">1.function myFunction(myParam){ <br/>2.    let myVar = 123;<br/>3.    return myFloat;<br/>4.    }<br/>5. let myFloat = 1.3; <br/>6. myFunction('abc'); //1.3</span></pre><figure class="ms mt mu mv gt ir gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/a29de0fde9f5bf4115918c7cf2f736c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*WouDemhMW-G9DRndG8C1nA.png"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">如果你对我明目张胆的剽窃有任何问题，请不要犹豫。</figcaption></figure><p id="2114" class="pw-post-body-paragraph ld le iw lf b lg ma jx li lj mb ka ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">这是一个很好的例子，因为它一次演示了执行上下文堆栈的整个范围，总共六行简洁的代码。</p><p id="9767" class="pw-post-body-paragraph ld le iw lf b lg ma jx li lj mb ka ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">以下步骤概述了在周期的每个点对范围的访问。</p><h1 id="1754" class="kl km iw bd kn ko kp kq kr ks kt ku kv kc kw kd kx kf ky kg kz ki la kj lb lc bi translated">第一步</h1><p id="0152" class="pw-post-body-paragraph ld le iw lf b lg lh jx li lj lk ka ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在第1–5行调用函数之前，程序可以访问全局环境中的变量myFunction和myFloat，全局环境由左边的#0框表示。</p><h1 id="32d0" class="kl km iw bd kn ko kp kq kr ks kt ku kv kc kw kd kx kf ky kg kz ki la kj lb lc bi translated">第二步</h1><p id="983c" class="pw-post-body-paragraph ld le iw lf b lg lh jx li lj lk ka ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一旦在第6行调用了该函数，就会生成一个新的环境(#1)，该环境只能由该函数访问。它可以通过外部访问全球环境。</p><h1 id="875e" class="kl km iw bd kn ko kp kq kr ks kt ku kv kc kw kd kx kf ky kg kz ki la kj lb lc bi translated">闭包本身</h1><p id="01d7" class="pw-post-body-paragraph ld le iw lf b lg lh jx li lj lk ka ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">闭包利用这些环境为函数创建一个封闭的作用域，以避免全局变量的问题以及与变量命名相关的常见问题。一个函数将保留已经附加到它的[[作用域]]的变量，即使它离开了那个环境。再次<a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">Mozilla文档中的一个例子</a>比我微不足道的文字更好地解释了这个概念。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="13bf" class="mg km iw mx b gy nb nc l nd ne">function makeAdder(x) { <br/>    return function(y) { <br/>         return x + y;<br/>     };<br/>}</span><span id="0d14" class="mg km iw mx b gy no nc l nd ne">let add5 = makeAdder(5);<br/>let add10 = makeAdder(10);</span><span id="08ce" class="mg km iw mx b gy no nc l nd ne">console.log(add5(2)); //7<br/>console.log(add10(2)); //12</span></pre><p id="7d6d" class="pw-post-body-paragraph ld le iw lf b lg ma jx li lj mb ka ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">正如我们在函数makeAdder的<code class="fe np nq nr mx b">add5</code>变量实例中所看到的(它们基本上是相同的概念)，该函数在它的局部[[Scope]]中保留了第一次被调用时的初始值作为它的'<code class="fe np nq nr mx b">x</code>,并推断下一个值作为它的y值传递。</p><h1 id="ed8b" class="kl km iw bd kn ko kp kq kr ks kt ku kv kc kw kd kx kf ky kg kz ki la kj lb lc bi translated">一些结束</h1><figure class="ms mt mu mv gt ir gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/88274176e7211b258bffbe97c1dc5593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*qgN4V5pnAfmrUaImYP-bVg.jpeg"/></div></figure><p id="a9e0" class="pw-post-body-paragraph ld le iw lf b lg ma jx li lj mb ka ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated">它们比看起来要复杂得多，使用闭包并不需要完全理解这些东西，但是它确实很有帮助。</p><figure class="ms mt mu mv gt ir gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/2a5bb574eea256b4619b604b54d3ad2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8HxRS_7l06b3EuJ2Kf_MQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">【https://www.youtube.com/watch?v=DdCYMvaUcrA T4】</figcaption></figure><h1 id="82ee" class="kl km iw bd kn ko kp kq kr ks kt ku kv kc kw kd kx kf ky kg kz ki la kj lb lc bi translated">特别感谢</h1><p id="c884" class="pw-post-body-paragraph ld le iw lf b lg lh jx li lj lk ka ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><a class="nm nn ep" href="https://medium.com/u/7fab51e62203?source=post_page-----f088ee63139e--------------------------------" rel="noopener" target="_blank"> Axel Rauschmayer </a>和speakingJS，此处<a class="ae lz" href="http://speakingjs.com/es5/index.html" rel="noopener ugc nofollow" target="_blank">为免费，此处</a><a class="ae lz" href="http://shop.oreilly.com/product/0636920029564.do?cmp=af-prog-books-videos-product_cj_9781449364984_%25zp" rel="noopener ugc nofollow" target="_blank">为付费。</a></p><p id="bf95" class="pw-post-body-paragraph ld le iw lf b lg ma jx li lj mb ka ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated"><a class="nm nn ep" href="https://medium.com/u/b1236ccd62f0?source=post_page-----f088ee63139e--------------------------------" rel="noopener" target="_blank">杰夫·波兹纳</a>，让我看到了光明。</p><h1 id="0c70" class="kl km iw bd kn ko kp kq kr ks kt ku kv kc kw kd kx kf ky kg kz ki la kj lb lc bi translated">资源</h1><p id="56f7" class="pw-post-body-paragraph ld le iw lf b lg lh jx li lj lk ka ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Closures</a></p><p id="ce05" class="pw-post-body-paragraph ld le iw lf b lg ma jx li lj mb ka ll lm mc lo lp lq md ls lt lu me lw lx ly ij bi translated"><a class="ae lz" href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36" rel="noopener">https://medium . com/JavaScript-scene/master-the-JavaScript-interview-what-a-a-closure-b2f0d 2152 b 36</a></p></div></div>    
</body>
</html>