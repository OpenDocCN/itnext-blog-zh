<html>
<head>
<title>Eventual Consistency with Spring for Apache Kafka: Part 1 of 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Kafka与Spring的最终一致性:第1部分，共2部分</h1>
<blockquote>原文：<a href="https://itnext.io/eventual-consistency-with-spring-for-apache-kafka-cfbbed450b5e?source=collection_archive---------1-----------------------#2021-05-17">https://itnext.io/eventual-consistency-with-spring-for-apache-kafka-cfbbed450b5e?source=collection_archive---------1-----------------------#2021-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc1e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Spring for Apache Kafka跨多个微服务管理MongoDB中的分布式数据模型</h2></div><p id="c491" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设一个现代的<a class="ae le" href="https://en.wikipedia.org/wiki/Distributed_computing" rel="noopener ugc nofollow" target="_blank">分布式系统</a>由多个微服务组成，每个微服务拥有一个域集合数据的子集，那么这个系统几乎肯定会有一些数据重复。鉴于这种重复，我们如何保持数据的一致性？在这个<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/eventual-consistency-with-spring-for-apache-kafka-part-2-of-2-23bedd512ccf">的两部分</a>的帖子中，我们将探索这个挑战的一个可能的解决方案——<a class="ae le" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡</a>和<a class="ae le" href="https://en.wikipedia.org/wiki/Eventual_consistency" rel="noopener ugc nofollow" target="_blank">最终一致性</a>的模型。</p><h1 id="5f1a" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">介绍</h1><p id="a135" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Apache Kafka是一个开源的分布式事件流平台，能够处理数万亿条消息。根据最初被认为是消息队列的<a class="ae le" href="https://www.confluent.io/what-is-apache-kafka" rel="noopener ugc nofollow" target="_blank"> Confluent </a>，Kafka基于分布式提交日志的抽象。自2011年由LinkedIn创建并开源以来，Kafka已经从一个消息队列迅速发展成为一个成熟的事件流媒体平台。</p><p id="6576" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://en.wikipedia.org/wiki/Eventual_consistency" rel="noopener ugc nofollow" target="_blank">维基百科</a>的说法，最终一致性是一种在分布式计算中使用的一致性模型，以实现高可用性，非正式地保证如果给定数据项没有新的更新，最终对该项目的所有访问都将返回上次更新的值。我之前在2017年5月的帖子<a class="ae le" href="http://programmaticponderings.com/2017/05/15/eventual-consistency-decoupling-microservices-with-spring-amqp-and-rabbitmq/" rel="noopener ugc nofollow" target="_blank">最终一致性:用Spring AMQP和RabbitMQ解耦微服务中，提到了使用RabbitMQ在分布式系统中实现最终一致性的话题。这篇文章出现在Pivotal的RabbitMQ网站上。</a></p><h1 id="b3ad" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">领域驱动设计</h1><p id="96ae" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">为了给讨论打下基础，让我们来看一个常见的例子——在线店面。使用<a class="ae le" href="https://en.wikipedia.org/wiki/Domain-driven_design" rel="noopener ugc nofollow" target="_blank">领域驱动设计(DDD) </a>方法，我们期望我们的<a class="ae le" href="https://en.wikipedia.org/wiki/Problem_domain" rel="noopener ugc nofollow" target="_blank">问题领域</a>，在线店面，由多个<a class="ae le" href="https://en.wikipedia.org/wiki/Domain-driven_design#Bounded_context" rel="noopener ugc nofollow" target="_blank">有界上下文</a>组成。有界上下文可能包括购物、客户服务、营销、安全、履行、会计等等，如下面的<a class="ae le" href="https://en.wikipedia.org/wiki/Domain-driven_design#Context_map" rel="noopener ugc nofollow" target="_blank">上下文图</a>所示。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/5ca60471ea9b5252e5b4b62045bdaf8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D_LzhEsYtiADkcIf.png"/></div></div></figure><p id="83a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给定这个问题域，我们可以假设我们有客户的概念。此外，我们可以假设定义客户的独特属性很可能分布在几个有界的上下文中。要全面了解客户，您需要从多个环境中收集数据。例如，会计环境可以是主要客户信息的<a class="ae le" href="https://en.wikipedia.org/wiki/System_of_record" rel="noopener ugc nofollow" target="_blank">记录系统</a>，例如客户的姓名、联系信息、联系偏好以及帐单和送货地址。营销部门可能掌握关于客户使用商店忠诚度计划和在线购物活动的额外信息。履行部门可能会保留一份运送给客户的所有订单的记录。安全部门可能持有客户的访问凭证、帐户访问历史和隐私设置。</p><p id="69a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是用黄色显示的客户数据对象。橙色代表每个有界上下文中的逻辑责任划分。在我们的在线店面示例中，这些部门将表现为单独的微服务。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mo"><img src="../Images/5fbd3bdef883661d67a71356531e74b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UpyRPNG_WkV7UnrD.png"/></div></div></figure><h1 id="fd21" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">分布式数据一致性</h1><p id="718f" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">让我们同意，我们领域的数据模型的架构需要跨有界的上下文或者甚至在同一上下文中的服务之间的一些数据复制。我们必须确保数据的一致性。举个例子，一个客户改变了他们的家庭地址或电子邮件。让我们假设会计环境是这些数据字段的记录系统。但是，为了完成订单，配送上下文可能还需要维护客户的当前家庭地址。同样，负责选择加入电子邮件广告的营销上下文也需要了解电子邮件的变化并更新其客户记录。</p><p id="a6ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果某个共享数据发生了变化，那么做出变化的一方应该负责传达这一变化，而不要期待响应。他们在陈述事实，而不是提问。相关方可以选择是否以及如何根据变更通知采取行动。这种解耦的通信模型通常被描述为事件承载的状态转移，由ThoughtWorks的<a class="ae le" href="https://twitter.com/martinfowler" rel="noopener ugc nofollow" target="_blank"> Martin Fowler </a>在其见解深刻的文章<a class="ae le" href="https://martinfowler.com/articles/201701-event-driven.html" rel="noopener ugc nofollow" target="_blank">中定义，“事件驱动”是什么意思？</a>。对一段数据的更改可以被认为是一个状态更改事件，即包含已更改数据的详细信息的事件。巧合的是，Fowler在文章中使用了一个客户地址变更作为事件携带状态转移的例子。前思想工作者Graham Brooks也在他的文章<a class="ae le" href="http://www.grahambrooks.com/event-driven-architecture/patterns/stateful-event-pattern/" rel="noopener ugc nofollow" target="_blank">中详述了这个概念，事件携带状态转移模式</a>。</p><h2 id="dbf8" class="mp lg it bd lh mq mr dn ll ms mt dp lp kr mu mv lr kv mw mx lt kz my mz lv na bi translated">一致性策略</h2><p id="2f8b" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">可以采用多种架构方法来解决分布式系统中的数据一致性问题。例如，您可以使用带有共享模式的单个关系数据库来持久化数据，完全避免分布式数据模型。然而，有人可能会争辩说，使用单一的数据库只是把你的分布式系统变成了一个整体。</p><p id="a959" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用<a class="ae le" href="https://en.wikipedia.org/wiki/Change_data_capture" rel="noopener ugc nofollow" target="_blank">变更数据捕获</a> (CDC)来跟踪每个数据库的变更，并将这些变更的记录发送到Kafka主题，供感兴趣的人使用。<a class="ae le" href="https://www.confluent.io/product/connectors/" rel="noopener ugc nofollow" target="_blank"> Kafka Connect </a>是一个很好的选择，如Confluent的Robin Moffatt的文章<a class="ae le" href="https://www.confluent.io/blog/no-more-silos-how-to-integrate-your-databases-with-apache-kafka-and-cdc" rel="noopener ugc nofollow" target="_blank">No More Silos:How Integrate your Databases with Apache Kafka and CDC</a>中所述。</p><p id="3c27" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，我们可以使用独立的数据服务，独立于域的其他业务服务，其唯一的作用是确保跨域的数据一致性。如果消息在Kafka中持续存在，该服务还可以通过消息重放提供数据可审计性。当然，另一组服务增加了系统操作的复杂性。</p><p id="b229" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章有些简单的架构中，业务微服务将通过从它们订阅的多个Kafka主题中产生和消费消息来保持它们各自领域的一致性。卡夫卡<a class="ae le" href="https://docs.confluent.io/current/clients/producer.html" rel="noopener ugc nofollow" target="_blank">的生产者</a>也可能是我们领域内的<a class="ae le" href="https://docs.confluent.io/current/clients/consumer.html" rel="noopener ugc nofollow" target="_blank">消费者</a>。</p><h1 id="ea83" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">店面示例</h1><p id="1c6c" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在本帖中，我们的在线店面API将使用<a class="ae le" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>和<a class="ae le" href="https://openjdk.java.net/projects/jdk/16/" rel="noopener ugc nofollow" target="_blank"> OpenJDK 16 </a>用Java构建。我们将通过为Apache Kafka项目使用<a class="ae le" href="https://kafka.apache.org/intro" rel="noopener ugc nofollow" target="_blank">发布/订阅模型</a>和<a class="ae le" href="https://spring.io/projects/spring-kafka" rel="noopener ugc nofollow" target="_blank"> Spring来确保分布式数据的一致性。当一个Spring Boot微服务更改一条数据时，如果合适，该状态更改将触发状态更改事件，该事件将使用Kafka主题与其他微服务共享。</a></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nb"><img src="../Images/ef95427fbb0563678293e419e8728a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7b5pY1_Fy0siXx7k3HfaOA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">Kiali的店面API视图</figcaption></figure><p id="2a7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将探索利用Spring Kafka来传达与客户通过在线店面下订单的特定用例相关的状态变化事件的不同方法。下图显示了店面订购流程的简略视图。箭头表示数据的交换。Kafka将作为一种分离服务的手段，同时仍然确保数据是分布式的。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ng"><img src="../Images/637988cd04eb0fa869333d4cac3c82f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XeWaP-VZrNWc9Df0ogp4qA.png"/></div></div></figure><p id="2d6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给定下订单的用例，我们将检查组成我们的店面API的三个服务的交互:会计绑定上下文中的帐户服务、实现上下文中的实现服务和订单管理上下文中的订单服务。我们将研究这三个服务如何使用Kafka以完全完整的方式相互交流状态变化(对其数据的变化)。</p><p id="af06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图显示了帖子中讨论的子系统之间的事件流。下面的编号对应于上面订购过程中的编号。我们将查看三个事件流2、5和6。我们将模拟事件流3，即购物车服务创建的订单。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nh"><img src="../Images/b56ce6a0397a1e6296e154130f02c3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_lWEbeG7TQ8uv0eQc2bSA.png"/></div></div></figure><p id="0977" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是从所涉及的主要子系统的角度来看在线店面的视图。尽管该图过于简化，但它应该会让您了解Kafka和Kafka当前的集群管理器Zookeeper 在一个典型的、高度可用的、基于微服务的分布式应用平台中的位置。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/2e1bc6ac7344c5beab2b1dd48556395e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SYsomFzXr0ZjVFVh.png"/></div></div></figure><p id="edcb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章将关注店面的后端API——它的服务、数据库和消息传递子系统。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/0ee337bd800e6a6f18872a31a343d578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PZPbtrjN2tkYLF68.png"/></div></div></figure><h1 id="5070" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">店面微服务</h1><p id="cde9" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们将探索三个微服务的功能，以及它们如何使用<a class="ae le" href="https://www.confluent.io/blog/kafka-2-8-0-features-and-improvements-with-early-access-to-kip-500/" rel="noopener ugc nofollow" target="_blank"> Kafka 2.8 </a>共享状态改变事件。每个店面API服务都是使用<a class="ae le" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot 2.0 </a>和<a class="ae le" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>构建的。每个Spring Boot服务包括<a class="ae le" href="https://projects.spring.io/spring-data-rest/" rel="noopener ugc nofollow" target="_blank"> Spring Data REST </a>，<a class="ae le" href="https://projects.spring.io/spring-data-mongodb/" rel="noopener ugc nofollow" target="_blank"> Spring Data MongoDB </a>，<a class="ae le" href="https://spring.io/projects/spring-kafka" rel="noopener ugc nofollow" target="_blank"> Spring for Apache Kafka </a>，<a class="ae le" href="https://cloud.spring.io/spring-cloud-sleuth/" rel="noopener ugc nofollow" target="_blank"> Spring Cloud Sleuth </a>，<a class="ae le" href="http://springfox.github.io/springfox/" rel="noopener ugc nofollow" target="_blank"> SpringFox </a>，以及<a class="ae le" href="https://spring.io/guides/gs/actuator-service/" rel="noopener ugc nofollow" target="_blank"> Spring Boot执行器</a>。为了简单起见，<a class="ae le" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank">卡夫卡溪流</a>和<a class="ae le" href="https://cloud.spring.io/spring-cloud-stream/" rel="noopener ugc nofollow" target="_blank">春云溪流</a>的使用不在此贴。</p><h2 id="23ef" class="mp lg it bd lh mq mr dn ll ms mt dp lp kr mu mv lr kv mw mx lt kz my mz lv na bi translated">源代码</h2><p id="c633" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">店面的微服务源代码在GitHub上公开。可以使用以下命令克隆四个GitHub项目:</p><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="962d" class="mp lg it nk b gy no np l nq nr">git clone --branch 2021-istio \<br/>    --single-branch --depth 1 \<br/>    <a class="ae le" href="https://github.com/garystafford/storefront-demo-accounts.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/storefront-demo-accounts.git</a></span><span id="69dd" class="mp lg it nk b gy ns np l nq nr">git clone --branch 2021-istio \<br/>    --single-branch --depth 1 \<br/>    <a class="ae le" href="https://github.com/garystafford/storefront-demo-orders.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/storefront-demo-orders.git</a></span><span id="e21b" class="mp lg it nk b gy ns np l nq nr">git clone --branch 2021-istio \<br/>    --single-branch --depth 1 \<br/>    <a class="ae le" href="https://github.com/garystafford/storefront-demo-fulfillment.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/storefront-demo-fulfillment.git</a></span><span id="cab5" class="mp lg it nk b gy ns np l nq nr">git clone --branch 2021-istio \<br/>    --single-branch --depth 1 \<br/>    <a class="ae le" href="https://github.com/garystafford/storefront-demo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/storefront-demo.git</a></span></pre><p id="d8ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nt">本帖中的代码示例显示为</em><a class="ae le" href="https://help.github.com/articles/about-gists/" rel="noopener ugc nofollow" target="_blank"><em class="nt">Gists</em></a><em class="nt">，在某些移动和社交媒体浏览器上可能无法正确显示。还提供了到gists的链接。</em></p><h2 id="5fb3" class="mp lg it bd lh mq mr dn ll ms mt dp lp kr mu mv lr kv mw mx lt kz my mz lv na bi translated">账户服务</h2><p id="3dbc" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">帐户服务负责管理基本的客户信息，如姓名、联系信息、地址和购物信用卡。下面显示了Accounts服务的数据模型的局部视图。这个域对象的<a class="ae le" href="https://martinfowler.com/bliki/DDD_Aggregate.html" rel="noopener ugc nofollow" target="_blank">集群代表客户账户</a><a class="ae le" href="https://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks" rel="noopener ugc nofollow" target="_blank">集合</a>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nu"><img src="../Images/3eeaed089ba3c631d5da5369012843a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UvhIu8yBZ7FlVAfx.png"/></div></div></figure><p id="1c08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Accounts服务的主要数据实体<code class="fe nv nw nx nk b">Customer</code>类保存在Accounts MongoDB数据库中。下面我们看到一个<code class="fe nv nw nx nk b">Customer</code>的表示，作为<code class="fe nv nw nx nk b">customer.accounts</code> MongoDB数据库集合中的<a class="ae le" href="https://www.mongodb.com/json-and-bson" rel="noopener ugc nofollow" target="_blank"> BSON </a>文档。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f492" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了主要的<code class="fe nv nw nx nk b">Customer</code>实体，账户服务还包含一个<code class="fe nv nw nx nk b">CustomerChangeEvent</code>类。作为Kafka生产者，账户服务使用<code class="fe nv nw nx nk b">CustomerChangeEvent</code> <a class="ae le" href="https://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks" rel="noopener ugc nofollow" target="_blank">域事件</a>对象来携带当添加新客户或对现有客户进行更改时账户服务希望共享的客户端的状态信息。<code class="fe nv nw nx nk b">CustomerChangeEvent</code>对象不是<code class="fe nv nw nx nk b">Customer</code>对象的精确副本。例如，<code class="fe nv nw nx nk b">CustomerChangeEvent</code>对象不与其他消息消费者(<code class="fe nv nw nx nk b">CreditCard</code>数据对象)共享敏感的信用卡信息。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi oa"><img src="../Images/9c0d832659f5d64717e60ab66e23d538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LT8oyDvorafUal30.png"/></div></div></figure><p id="c412" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe nv nw nx nk b">CustomerChangeEvent</code>域事件对象在MongoDB中没有持久化，我们可以在Kafka中查看它的JSON消息有效载荷来检查它的结构。请注意MongoDB中的<code class="fe nv nw nx nk b">Customer</code>文档和Kafka <code class="fe nv nw nx nk b">CustomerChangeEvent</code>消息有效负载之间的数据结构(模式)差异。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="cbed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为简单起见，我们假设其他服务不会更改客户的姓名、联系信息或地址，这是帐户服务的唯一职责。</p><p id="637f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">账户服务的源代码可以在<a class="ae le" href="https://github.com/garystafford/storefront-demo-accounts/tree/2021-istio" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。使用项目的最新<code class="fe nv nw nx nk b">2021-istio</code>分支。</p><h2 id="22a5" class="mp lg it bd lh mq mr dn ll ms mt dp lp kr mu mv lr kv mw mx lt kz my mz lv na bi translated">订单服务</h2><p id="4b5c" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">订单服务负责管理客户过去和当前的订单；这是记录客户订单历史的系统。订单服务的数据模型的局部视图如下所示。这个域对象集群代表客户订单集合。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ob"><img src="../Images/64f0dd1e90822e83b9427d3f4d8fe669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qbikNwxzb8SKEy-H.png"/></div></div></figure><p id="c36b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">订单服务的主要数据实体<code class="fe nv nw nx nk b">CustomerOrders</code>类在MongoDB中持久化。该实体包含所有客户订单的历史记录(<code class="fe nv nw nx nk b">Order</code>数据对象)，以及客户的姓名、联系信息和地址。在Orders MongoDB数据库中，一个<code class="fe nv nw nx nk b">CustomerOrders</code>，在<code class="fe nv nw nx nk b">customer.orders</code>数据库集合中表示为一个BSON文档，如下所示:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="10b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了主要的<code class="fe nv nw nx nk b">CustomerOrders</code>实体，订单服务还包含了<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>类。作为Kafka的生产者，Orders服务使用<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>域事件对象来携带关于已批准订单的状态信息，准备执行。它发送给Kafka供履行服务消费。<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>对象只包含它需要共享的信息。我们的示例共享一个<code class="fe nv nw nx nk b">Order</code>，以及客户的姓名、联系信息和送货地址。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ob"><img src="../Images/0612137d878039304b609d4e3db7cf67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iyPTPIRm1h4eQMcb.png"/></div></div></figure><p id="5e3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>域事件对象在MongoDB中没有持久化，所以我们可以在Kafka中查看它的JSON消息有效载荷。再次注意MongoDB中的<code class="fe nv nw nx nk b">CustomerOrders</code>文档和Kafka中的<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>消息负载之间的模式差异。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0e06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">订单服务的源代码可以在<a class="ae le" href="https://github.com/garystafford/storefront-demo-orders/tree/2021-istio" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。使用项目的最新<code class="fe nv nw nx nk b">2021-istio</code>分支。</p><h2 id="ebd4" class="mp lg it bd lh mq mr dn ll ms mt dp lp kr mu mv lr kv mw mx lt kz my mz lv na bi translated">履行服务</h2><p id="760b" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">最后，履行服务负责履行订单。履行服务的数据模型的局部视图如下所示。这个域对象集群代表实现集合。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi oc"><img src="../Images/2752acc781957023c9ad3840395aaf3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tmQwNZBmmampBm_y.png"/></div></div></figure><p id="1b93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现服务的主要实体,<code class="fe nv nw nx nk b">Fulfillment</code>类被保存在MongoDB中。这个实体包含一个单独的<code class="fe nv nw nx nk b">Order</code>数据对象，以及客户的姓名、联系信息和送货地址。履行服务还使用<code class="fe nv nw nx nk b">Fulfillment</code>实体来存储最新的运输状态，例如“已发货”、“在途”和“已收到”。客户的姓名、联系信息和送货地址由帐户服务管理，复制到订单服务，并通过Kafka使用<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>实体传递给履行服务。</p><p id="50a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Fulfillment MongoDB数据库中，<code class="fe nv nw nx nk b">Fulfillment</code>对象在<code class="fe nv nw nx nk b">fulfillment.requests</code>数据库集合中表示为BSON文档，如下所示:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="08a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了主<code class="fe nv nw nx nk b">Fulfillment</code>实体，履行服务还有一个<code class="fe nv nw nx nk b">OrderStatusChangeEvent</code>类。作为Kafka生产者，履行服务使用<code class="fe nv nw nx nk b">OrderStatusChangeEvent</code>域事件对象来携带关于订单履行状态的状态信息。<code class="fe nv nw nx nk b">OrderStatusChangeEvent</code>对象包含订单的UUID、时间戳、发货状态和可选的订单状态注释。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi od"><img src="../Images/32e7bdf79840b61b08748fc277b6900f.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/0*4FZvoS4XC9MJE3Fq"/></div></figure><p id="f22d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe nv nw nx nk b">OrderStatusChangeEvent</code>域事件对象在MongoDB中没有持久化，所以我们可以再次在Kafka中查看它的JSON消息有效负载。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8ce7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">履行服务的源代码可在<a class="ae le" href="https://github.com/garystafford/storefront-demo-fulfillment/tree/2021-istio" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。使用项目的最新<code class="fe nv nw nx nk b">2021-istio</code>分支。</p><h1 id="09a6" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">状态更改事件消息流</h1><p id="2eae" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">本帖中展示了三个状态更改事件消息流。</p><ol class=""><li id="257e" class="oe of it kk b kl km ko kp kr og kv oh kz oi ld oj ok ol om bi translated">对客户的更改触发了由账户服务产生的事件消息，该消息被发布在<code class="fe nv nw nx nk b">accounts.customer.change</code> Kafka主题上并由订单服务消费；</li><li id="2662" class="oe of it kk b kl on ko oo kr op kv oq kz or ld oj ok ol om bi translated">订单批准触发由订单服务产生的事件消息，该消息发布在<code class="fe nv nw nx nk b">orders.order.fulfill</code> Kafka主题上，并由履行服务消费；</li><li id="14ff" class="oe of it kk b kl on ko oo kr op kv oq kz or ld oj ok ol om bi translated">订单状态的改变触发了由履行服务产生的事件消息，该消息被发布在<code class="fe nv nw nx nk b">fulfillment.order.change</code> Kafka主题上，并被订单服务消费；</li></ol><p id="2ea8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Kafka主题的生产者和消费者端，每个状态改变事件消息流都遵循相同的架构模式。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi os"><img src="../Images/858421f8fb1b47a8f3c4241b97c41e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CH3pjOWgbaCbMXGodMcHow.png"/></div></div></figure><p id="9035" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们检查每个状态改变事件消息流及其背后的代码。</p><h2 id="188f" class="mp lg it bd lh mq mr dn ll ms mt dp lp kr mu mv lr kv mw mx lt kz my mz lv na bi translated">客户状态变化</h2><p id="26f5" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">当Accounts service创建或更新一个新的客户实体时，会生成一条<code class="fe nv nw nx nk b">CustomerChangeEvent</code>消息并发送给<code class="fe nv nw nx nk b">accounts.customer.change</code> Kafka主题。该消息由订单服务检索和使用。这就是订单服务最终拥有所有可能下订单的客户的记录的方式。通过Kafka，可以说订单的客户联系信息<a class="ae le" href="https://en.wikipedia.org/wiki/Eventual_consistency" rel="noopener ugc nofollow" target="_blank">最终与账户的客户联系信息</a>一致。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/6f30010506d5db753ba5bdd05a1c2710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rv8ydDFjY8a-MESR.png"/></div></div></figure><p id="762c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有不同的方法来触发要发送给卡夫卡的消息。对于这种特定的状态更改，帐户服务使用一个侦听器。监听器类扩展了<a class="ae le" href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/mapping/event/AbstractMongoEventListener.html" rel="noopener ugc nofollow" target="_blank">AbstractMongoEventListener</a>，监听客户实体的<a class="ae le" href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/mapping/event/AbstractMongoEventListener.html#onAfterSave-org.springframework.data.mongodb.core.mapping.event.AfterSaveEvent-" rel="noopener ugc nofollow" target="_blank"> onAfterSave </a>事件。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b857" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">侦听器通过用客户信息实例化一个新的<code class="fe nv nw nx nk b">CustomerChangeEvent</code>来处理事件，并将其传递给<code class="fe nv nw nx nk b">Sender</code>类。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9adf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx nk b">SenderConfig</code>类处理<code class="fe nv nw nx nk b">Sender</code>的配置。这个Spring Kafka producer配置类使用Spring Kafka的<a class="ae le" href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/support/serializer/JsonSerializer.html" rel="noopener ugc nofollow" target="_blank"> JsonSerializer </a>类将<code class="fe nv nw nx nk b">CustomerChangeEvent</code>对象序列化为JSON消息有效负载。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e8aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx nk b">Sender</code>使用<a class="ae le" href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/core/KafkaTemplate.html" rel="noopener ugc nofollow" target="_blank"> KafkaTemplate </a>向<code class="fe nv nw nx nk b">accounts.customer.change</code> Kafka主题发送消息，如下所示。由于消息顺序对于确保按顺序处理对客户信息的更改至关重要，因此所有消息都被发送到具有单个分区的单个主题。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ot"><img src="../Images/6fd3c4e24570669a1c520032ce11470a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PqIVOhxHdGWm0AJzy2wujQ.png"/></div></div></figure><p id="0b9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">订单服务的<code class="fe nv nw nx nk b">Receiver</code>类使用账户服务产生的<code class="fe nv nw nx nk b">CustomerChangeEvent</code>消息。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5c42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与履行服务相比，订单服务的<code class="fe nv nw nx nk b">Receiver</code>类的配置有所不同。订单服务接收来自多个主题的消息，每个主题包含具有不同负载结构的消息。每种类型的消息都必须反序列化为不同的对象类型。为了完成这个任务，<code class="fe nv nw nx nk b">ReceiverConfig</code>类使用了Apache Kafka的<a class="ae le" href="https://kafka.apache.org/0102/javadoc/org/apache/kafka/common/serialization/StringDeserializer.html" rel="noopener ugc nofollow" target="_blank"> StringDeserializer </a>。订单服务的<code class="fe nv nw nx nk b">ReceiverConfig</code>引用了Spring Kafka的<code class="fe nv nw nx nk b">AbstractKafkaListenerContainerFactory</code>类<a class="ae le" href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/config/AbstractKafkaListenerContainerFactory.html#setMessageConverter-org.springframework.kafka.support.converter.MessageConverter-" rel="noopener ugc nofollow" target="_blank"> setMessageConverter </a>方法，该方法允许动态对象类型匹配。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fc4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">订单服务消费消息的每个Kafka主题都与<code class="fe nv nw nx nk b">Receiver</code>类中的一个方法相关联(如上所示)。该方法接受特定的对象类型作为输入，表示消息负载需要反序列化到的对象类型。这样，我们可以接收从多种对象类型序列化的多个消息有效负载，并成功地将每种类型反序列化为正确的数据对象。在<code class="fe nv nw nx nk b">CustomerChangeEvent</code>的情况下，订单服务调用<code class="fe nv nw nx nk b">receiveCustomerOrder</code>方法来消费消息并正确地反序列化它。</p><p id="1f95" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于所有服务，每个服务的<code class="fe nv nw nx nk b">resources</code>目录中的Spring <code class="fe nv nw nx nk b">application.yaml</code>属性文件包含Kafka配置(第11–19行)。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="f269" class="mp lg it bd lh mq mr dn ll ms mt dp lp kr mu mv lr kv mw mx lt kz my mz lv na bi translated">订单被批准履行</h2><p id="d848" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">当<code class="fe nv nw nx nk b">CustomerOrders</code>实体中的<code class="fe nv nw nx nk b">Order</code>的状态从“已创建”更改为“已批准”时，会生成一条<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>消息并发送给<code class="fe nv nw nx nk b">orders.order.fulfill</code> Kafka主题。该消息由履行服务检索和消费。这就是执行服务如何记录哪些订单可以执行的原因。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ou"><img src="../Images/299c4921487eafbcf76caadb5b3673ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3q5-J3jvWUkBrywV.png"/></div></div></figure><p id="0449" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们没有为这篇文章创建购物车服务，所以Orders服务模拟一个订单批准事件，包含一个通过Kafka从购物车服务接收的批准订单。订单服务可以为每个客户创建一个随机的订单历史，以模拟订单的创建和批准。此外，订单服务可以扫描包含“已创建”和“已批准”订单状态的所有客户订单。对于所有符合这些标准的订单，此状态将作为事件消息传递给Kafka。生成一个<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>,其中包含要履行的订单，以及客户的联系方式和发货信息。将<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>传递给<code class="fe nv nw nx nk b">Sender</code>类。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="df2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx nk b">SenderConfig</code>类处理<code class="fe nv nw nx nk b">Sender</code>类的配置。这个Spring Kafka producer配置类使用Spring Kafka的<a class="ae le" href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/support/serializer/JsonSerializer.html" rel="noopener ugc nofollow" target="_blank"> JsonSerializer </a>类将<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>对象序列化为JSON消息有效负载。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b912" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx nk b">Sender</code>类使用<code class="fe nv nw nx nk b">KafkaTemplate</code>将消息发送到<code class="fe nv nw nx nk b">orders.order.fulfill</code> Kafka主题，如下所示。由于消息顺序并不重要，如果消息量需要，可以将消息发送到具有多个分区的主题。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ot"><img src="../Images/49be5e8409b3fa7ffc2f8d4cb130b193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L8lJ2xlfNDTjAB6_Kca8BQ.png"/></div></div></figure><p id="3018" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现服务的<code class="fe nv nw nx nk b">Receiver</code>类使用来自Kafka主题的<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>并实例化一个<code class="fe nv nw nx nk b">Fulfillment</code>对象，包含在<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>消息有效负载中传递的数据。<code class="fe nv nw nx nk b">Fulfillment</code>对象包括要履行的订单和客户的联系和运输信息。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f354" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现服务的<code class="fe nv nw nx nk b">ReceiverConfig</code>类定义了<code class="fe nv nw nx nk b">DefaultKafkaConsumerFactory</code>和<code class="fe nv nw nx nk b">ConcurrentKafkaListenerContainerFactory</code>，负责将来自JSON的消息有效负载反序列化为<code class="fe nv nw nx nk b">FulfillmentRequestEvent</code>对象。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="a10d" class="mp lg it bd lh mq mr dn ll ms mt dp lp kr mu mv lr kv mw mx lt kz my mz lv na bi translated">履行订单状态状态更改</h2><p id="ced5" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">当履行实体中的订单状态更改为除<strong class="kk iu">已批准</strong>之外的任何状态时，履行服务会生成一条<code class="fe nv nw nx nk b">OrderStatusChangeEvent</code>消息，并发送给<code class="fe nv nw nx nk b">fulfillment.order.change</code> Kafka主题。该消息由订单服务检索和使用。这就是订单服务如何跟踪从最初的<strong class="kk iu">创建</strong>状态到最终的<strong class="kk iu">接收</strong>状态的所有<code class="fe nv nw nx nk b">CustomerOrder</code>生命周期事件。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/908574fa43e269224708bdaa616d30c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zX7QAqF_H4nu5PAN.png"/></div></div></figure><p id="a383" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">履行服务通过<code class="fe nv nw nx nk b">FulfillmentController</code>类公开几个端点，模拟订单状态的变化。它们允许订单的状态从<strong class="kk iu">批准</strong>到<strong class="kk iu">处理</strong>，到<strong class="kk iu">发货</strong>，到<strong class="kk iu">在途</strong>，最后到<strong class="kk iu">接收</strong>。此更改适用于符合标准的所有订单。</p><p id="860e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些状态变化中的每一个都会触发MongoDB中实现文档的变化。每个更改还会生成一个Kafka消息，在消息有效负载中包含<code class="fe nv nw nx nk b">OrderStatusChangeEvent</code>。履行服务的<code class="fe nv nw nx nk b">Sender</code>类处理这一点。</p><p id="30ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，在这个例子中，这两个事件不是在原子事务中处理的。更新数据库或发送消息可能会各自失败，这将导致数据一致性的丧失。在现实世界中，我们必须确保这两个独立的操作作为单个事务成功或失败，以确保数据一致性，使用少数几种常见的架构模式中的任何一种。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9b6d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx nk b">SenderConfig</code>类处理<code class="fe nv nw nx nk b">Sender</code>类的配置。这个Spring Kafka producer配置类使用Spring Kafka的<a class="ae le" href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/support/serializer/JsonSerializer.html" rel="noopener ugc nofollow" target="_blank"> JsonSerializer </a>类将<code class="fe nv nw nx nk b">OrderStatusChangeEvent</code>对象序列化为JSON消息有效负载。该类几乎与订单和账户服务中的<code class="fe nv nw nx nk b">SenderConfig</code>类相同。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="00f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nv nw nx nk b">Sender</code>类使用<code class="fe nv nw nx nk b">KafkaTemplate</code>将消息发送到<code class="fe nv nw nx nk b">fulfillment.order.change</code> Kafka主题，如下所示。由于记录了时间戳，因此消息顺序并不重要，从而确保可以维护订单状态事件的正确顺序。如果消息量需要，可以将消息发送到具有多个分区的主题。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ot"><img src="../Images/f94f6755f2afad5d423e983216bf6b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvPYAGLxUi0AwJz7LtAj3w.png"/></div></div></figure><p id="6ffb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">订单服务的<code class="fe nv nw nx nk b">Receiver</code>类负责消费由履行服务产生的<code class="fe nv nw nx nk b">OrderStatusChangeEvent</code>消息。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2ee8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所述，订单服务的配置不同于从Kafka接收消息的履行服务。订单服务接收来自多个主题的消息。<code class="fe nv nw nx nk b">ReceiverConfig</code>类使用<code class="fe nv nw nx nk b">StringDeserializer</code>反序列化所有消息。订单服务的<code class="fe nv nw nx nk b">ReceiverConfig</code>类引用了Spring Kafka <code class="fe nv nw nx nk b">AbstractKafkaListenerContainerFactory</code>类的<a class="ae le" href="https://docs.spring.io/spring-kafka/api/org/springframework/kafka/config/AbstractKafkaListenerContainerFactory.html#setMessageConverter-org.springframework.kafka.support.converter.MessageConverter-" rel="noopener ugc nofollow" target="_blank"> setMessageConverter </a>方法，该方法允许动态对象类型匹配。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="306b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">订单服务消费消息的每个Kafka主题都与<code class="fe nv nw nx nk b">Receiver</code>类中的一个方法相关联(如上所示)。该方法接受特定的对象类型作为输入参数，表示消息负载需要反序列化到的对象类型。对于<code class="fe nv nw nx nk b">OrderStatusChangeEvent</code>消息，调用<code class="fe nv nw nx nk b">receiveOrderStatusChangeEvents</code>方法来消费来自<code class="fe nv nw nx nk b">fulfillment.order.change</code> Kafka主题的消息。</p><h1 id="9dc3" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">第二部分</h1><p id="0672" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在这篇文章的第二部分中，我们将回顾如何使用<a class="ae le" href="https://minikube.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>将storefront API组件部署并运行到一个本地开发环境中，该环境运行在带有<a class="ae le" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>的Kubernetes上。为了提供运营可见性，我们将在我们的系统中添加观察工具，如雅虎的<a class="ae le" href="https://github.com/yahoo/CMAK" rel="noopener ugc nofollow" target="_blank">CMAK</a>(Apache Kafka的集群管理器)<a class="ae le" href="https://github.com/mongo-express/mongo-express" rel="noopener ugc nofollow" target="_blank">蒙戈快车</a>、<a class="ae le" href="https://kiali.io/" rel="noopener ugc nofollow" target="_blank">基亚利</a>、<a class="ae le" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>和<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank">格拉法纳</a>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nb"><img src="../Images/ef95427fbb0563678293e419e8728a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7b5pY1_Fy0siXx7k3HfaOA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">Kiali的店面API视图</figcaption></figure></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="53d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇博客代表我自己的观点，而不是我的雇主亚马逊网络服务公司(AWS)的观点。所有产品名称、徽标和品牌都是其各自所有者的财产。</p></div></div>    
</body>
</html>