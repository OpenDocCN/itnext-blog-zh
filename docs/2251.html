<html>
<head>
<title>Introducing: Redux Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简介:Redux挂钩</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-redux-hooks-1bf9c568ecc2?source=collection_archive---------1-----------------------#2019-04-24">https://itnext.io/introducing-redux-hooks-1bf9c568ecc2?source=collection_archive---------1-----------------------#2019-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0bab969b9c80fbeddf75f622222a5d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lqQvfalonBM4-gT0IIjHw.jpeg"/></div></div></figure><p id="41cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">刚刚发布，随之而来的是一套全新的钩子，可能会改变你在React应用中编写redux的方式。在这篇文章中，我将让你了解为什么花了这么长时间才发布，API是什么，以及最后我对移植到hooks的想法。</p><h2 id="bf2d" class="la lb iq bd lc ld le dn lf lg lh dp li kj lj lk ll kn lm ln lo kr lp lq lr ls bi translated">我们不是已经有了吗？</h2><p id="699e" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ij bi translated">虽然<a class="ae ly" href="https://github.com/facebookincubator/redux-react-hook" rel="noopener ugc nofollow" target="_blank">第三方库</a>已经支持这个功能，但是这个功能我已经期待很久了，因为所有现有的解决方案都不是面向性能的。到目前为止，任何允许你使用像<code class="fe kw kx ky kz b">useRedux</code>或<code class="fe kw kx ky kz b">useConnect</code>这样的东西的现有库都不能解决一个关键的性能相关问题，这导致你的挂钩组件在任何时候<strong class="ka ir">任何状态</strong>改变时重新呈现，不管你的组件是否监听这个特定的状态。这是因为<code class="fe kw kx ky kz b">6.x.x</code>。版本<code class="fe kw kx ky kz b">react-redux</code>试图充分利用新的React上下文API，不幸的是没有渲染保释技术。这意味着，无论何时一个<code class="fe kw kx ky kz b">Context.Provider</code>更新，那么每个<code class="fe kw kx ky kz b">Context.Consumer</code>也必须更新。因此，任何带有类似于<code class="fe kw kx ky kz b">useRedux</code>或<code class="fe kw kx ky kz b">useConnect</code>的钩子的组件将总是更新，而不管<strong class="ka ir"> </strong>是否正在监听被更新的状态片。这个特殊的问题是<code class="fe kw kx ky kz b">react-redux</code>不得不发布一个新的主要版本(即<code class="fe kw kx ky kz b">7.x.x</code>)的原因，在这个版本中，它重写了代码，将自己从以前的上下文API实现中分离出来，现在已经准备好支持一组全新的钩子了！</p><h2 id="8da2" class="la lb iq bd lc ld le dn lf lg lh dp li kj lj lk ll kn lm ln lo kr lp lq lr ls bi translated">这将如何影响我的代码？</h2><p id="287d" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ij bi translated">嗯，看情况。新的挂钩允许您使用redux连接您的组件，而不再需要<code class="fe kw kx ky kz b">connect()</code> HOCs。我个人认为这对于使用redux的大型应用程序来说是一个巨大的胜利，因为现在你实际上可以创建<strong class="ka ir">自定义的可重用钩子</strong>而不需要额外的容器组件。到目前为止，React钩子很棒，但是你实际上不能创建一个钩子来从redux读取一些状态或者分派给它。因此，定制钩子非常适合react-only的东西，而当代码与redux有任何关系时，它们不会是首选。</p><p id="a186" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些新的redux挂钩的好处是，你不再需要用<code class="fe kw kx ky kz b">mapStateToProps</code>、<code class="fe kw kx ky kz b">mapDispatchToProps</code>和<code class="fe kw kx ky kz b">connect</code>来维护单独的容器/表示文件，而是可以立即读取功能组件内部的状态。此外，您可以将任何现有的定制钩子与redux集成，而不是将状态数据作为参数传递给钩子，钩子本身现在可以直接从redux状态中读取它！</p><h2 id="22f0" class="la lb iq bd lc ld le dn lf lg lh dp li kj lj lk ll kn lm ln lo kr lp lq lr ls bi translated">炮兵</h2><p id="934c" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ij bi translated">虽然在撰写本文时，支持钩子的<code class="fe kw kx ky kz b">react-redux</code>版本还只是alpha版本，但是您仍然可以在非生产的<strong class="ka ir">级别上试验它们。</strong></p><p id="418d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要安装它，只需运行:</p><pre class="lz ma mb mc gt md kz me mf aw mg bi"><span id="756c" class="la lb iq kz b gy mh mi l mj mk">npm install react-redux@next</span><span id="8288" class="la lb iq kz b gy ml mi l mj mk">// or</span><span id="972e" class="la lb iq kz b gy ml mi l mj mk">yarn add react-redux@next</span></pre><p id="f29a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，有一套4个挂钩，包括:</p><h2 id="df1d" class="la lb iq bd lc ld le dn lf lg lh dp li kj lj lk ll kn lm ln lo kr lp lq lr ls bi translated"><strong class="ak">使用选择器()</strong></h2><p id="841a" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ij bi translated">从Redux存储状态中提取值并订阅存储的钩子。这本质上类似于在钩子中实现的<code class="fe kw kx ky kz b">mapStateToProps</code>函数，但是有一些小的不同。</p><p id="f6e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，没有可用的<code class="fe kw kx ky kz b">ownProps</code>，应该使用自定义逻辑使用<code class="fe kw kx ky kz b">useCallback</code>或<code class="fe kw kx ky kz b">useMemo</code>来获得它们。</p><p id="e3b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，用于选择状态片的选择器函数不会被缓存，除非您向<code class="fe kw kx ky kz b">useSelector()</code>提供第二个参数。第二个参数是一个值数组，无论何时更改，选择器函数都将重新计算。如果您的选择器函数<strong class="ka ir">依赖于<code class="fe kw kx ky kz b">state</code>之外的其他变量</strong>，那么您需要以数组的形式将这些变量作为第二个参数添加到这个钩子中。如果你的选择函数只依赖于状态，那么就忘记这个钩子的第二个参数。如果有帮助的话，这正是您在<code class="fe kw kx ky kz b">useCallback</code>中要做的，在这里，只要作为第二个参数传入的值不变，相同的函数就会被重用。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">useSelector示例</figcaption></figure><p id="e44d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除此之外，同样的智能渲染保释技术仍然适用，如果新的映射道具与旧的映射道具相同，您的组件将不会重新渲染。</p><p id="379f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于React Redux中使用的批处理行为，一个调度的动作导致同一个组件中的多个<code class="fe kw kx ky kz b">useSelector()</code>重新计算它们的值，<em class="ms">应该</em>只导致一次“挂钩”组件的重新呈现。因此，请放心，组件中的<code class="fe kw kx ky kz b">useSelector()</code>钩子的数量<strong class="ka ir">与该组件将拥有的重新渲染的数量</strong>无关。在上面的例子中，我们可以将单个<code class="fe kw kx ky kz b">useSelector()</code>拆分成两个独立的部分(一个读取标题，另一个读取内容),这样<strong class="ka ir">和</strong>在性能&amp;渲染数量上完全相同。</p><h2 id="046b" class="la lb iq bd lc ld le dn lf lg lh dp li kj lj lk ll kn lm ln lo kr lp lq lr ls bi translated"><code class="fe kw kx ky kz b">useDispatch()</code></h2><p id="a8d6" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ij bi translated">一个暴露商店内部<code class="fe kw kx ky kz b">dispatch</code>方法的钩子。每当一个组件需要触发redux动作时，这个钩子就是你所需要的。不幸的是，没有对应的<code class="fe kw kx ky kz b">mapDispatchToProps</code>钩子，所以无论何时你想要触发任何动作，你都需要使用<code class="fe kw kx ky kz b">dispatch(myActionCreator())</code>调用它的动作创建者。启动这样一个动作可能看起来是违反直觉的，因为你已经习惯于通过你的<code class="fe kw kx ky kz b">connect()</code> HOC调用一个已经用<code class="fe kw kx ky kz b">dispatch</code>包装好的道具，但是钩子在这里是为了让事情更习惯化，并且给你的代码带来额外的清晰。</p><p id="949f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，现在，无论何时您想要触发一个动作作为对用户事件的响应，您都必须创建一个匿名函数，如下所示:<code class="fe kw kx ky kz b">() =&gt; dispatch(myActionCreator())</code>。由于匿名函数的性质，这将在每次重新渲染时获得一个新的引用。因此，如果您将它作为道具传递给另一个组件，那么后者将永远无法受益于渲染保释技术(<code class="fe kw kx ky kz b">shouldComponentUpdate</code>、<code class="fe kw kx ky kz b">memo</code>、<code class="fe kw kx ky kz b">PureComponent</code>)。为了实现这一点，您必须使函数具有相同的引用，这在hooks世界中转化为将整个匿名函数包装在一个<code class="fe kw kx ky kz b">useCallback()</code>中。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">使用Dispatch示例</figcaption></figure><h2 id="5f5a" class="la lb iq bd lc ld le dn lf lg lh dp li kj lj lk ll kn lm ln lo kr lp lq lr ls bi translated">使用商店()</h2><p id="6a65" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ij bi translated">返回Redux store实例的挂钩。每当您创建一个需要访问由消费者应用程序定义的商店实例的库时，这是很有用的(即<code class="fe kw kx ky kz b">connected-react-router</code>)。如果出于某种原因，一个组件使用了不同于其余组件的存储，或者如果你正在对一个没有用<code class="fe kw kx ky kz b">Provider</code>包装的组件进行单元测试，这也可能是有用的。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">使用商店示例</figcaption></figure><h2 id="3764" class="la lb iq bd lc ld le dn lf lg lh dp li kj lj lk ll kn lm ln lo kr lp lq lr ls bi translated">想法和要点</h2><p id="d021" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ij bi translated">我应该把我的<code class="fe kw kx ky kz b">connect()</code> HOCs转换成钩子吗？嗯——还是那句话——这要看情况。首先，您失去了很多由<code class="fe kw kx ky kz b">connect()</code>提供的<strong class="ka ir">自动</strong>引用缓存。这会导致您失去任何性能提升，除非您大量使用<code class="fe kw kx ky kz b">useCallback()</code>(特别是对于正在使用<code class="fe kw kx ky kz b">dispatch</code>的函数)。其次，如果你的代码依赖于<code class="fe kw kx ky kz b">mapStateToProps</code>内的<code class="fe kw kx ky kz b">ownProps</code>，你可能会用redux钩子比用<code class="fe kw kx ky kz b">connect()</code> HOC写出更多的代码。第三，您失去了<code class="fe kw kx ky kz b">mapDispatchToProps</code>为动作创建者提供的依赖注入。</p><p id="5f19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">遗憾的是，从redux HOCs到redux hooks没有一行移植。你不能简单地用一个“useConnect()”钩子替换掉你的单个<code class="fe kw kx ky kz b">connect()</code> HOC，因为没有任何钩子。在最初的alpha版本中曾经有一个<code class="fe kw kx ky kz b">useRedux()</code>钩子，但是它很快就被废弃了，因为它没有给你适当地记忆你的动作创建者的能力，这导致了性能问题(如果你想知道为什么，我建议你阅读我关于<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/3-small-tips-for-better-redux-performance-in-a-react-app-9cde549df6af"> redux performance </a>的文章)。这意味着你现在拥有的每一个<code class="fe kw kx ky kz b">connect(mapStateToProps, mapDispatchToProps)</code>吊钩都需要被两个独立的吊钩替换，如果使用<code class="fe kw kx ky kz b">ownProps</code>的话，你的<em class="ms"> mapStateToProps </em>可能会有<strong class="ka ir">额外的</strong>变化。因此，如果您想防范潜在的性能问题，您必须编写的代码比您按照<code class="fe kw kx ky kz b">connect()</code>的方式编写的代码要多。</p><p id="c9c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不管上面说的是什么，我们通常做的是有意地将我们的非智能层和智能层分开。这使得我们既可以重用单独的层，又可以通过将这两个层作为不同的实体来处理来简化测试过程(如果你想了解更多，我强烈建议你阅读我的关于UI &amp;状态层的<a class="ae ly" href="https://levelup.gitconnected.com/the-importance-of-state-ui-actors-in-web-apps-f69cc523798b" rel="noopener ugc nofollow" target="_blank">重要性的文章)。另一方面，钩子试图将这两者合并在一起，本质上是从智能&amp;哑层创建一个单一的实体。这是一个新趋势，始于2018年hooks的发布。原因是，在大多数情况下，表示组件只与特定的容器组件相关，本质上组件的可重用性不是问题。另一方面，为了解决这个问题，测试发生了变化，很多人慢慢地从单元&amp;实现测试(</a><a class="ae ly" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酶</a>)迁移到集成&amp;用户输出测试(<a class="ae ly" href="https://github.com/kentcdodds/react-testing-library" rel="noopener ugc nofollow" target="_blank">反应测试库</a>)。</p><p id="4952" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于这些原因，合并非智能层和智能层可能是赢也可能是输，这取决于你的应用的架构和测试方式。虽然钩子可以增加可读性(不再需要在两个地方检查)和可维护性(关于文件组织和结构)，一些成熟的代码库可能希望保持现有的层分离，因为这对他们来说更好。</p><p id="7acf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，在一天结束时，钩子只是hoc或渲染道具组件的替代物，很可能你公司的利润不会依赖于它们。它们是实现细节。任何可以写成特设的东西都可以被重写为渲染道具或自定义钩子，反之亦然。我写这篇文章不是为了贬低钩子，而是为了让人们在快速跳上钩子重构的列车之前多思考一点。我个人对新redux挂钩的建议如下:</p><blockquote class="mt"><p id="f159" class="mu mv iq bd mw mx my mz na nb nc kv dk translated">在您的定制钩子中选择它们，但是只有当连接逻辑简单并且性能不成问题时才在组件中使用它们。</p></blockquote><p id="7333" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">如果这太严格，就忽略它，总是选择钩子，但是如果它变得很麻烦，不要害怕切换到非钩子实现。</p><p id="1aaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读:)</p><p id="b79c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="ms"/></strong>👋<strong class="ka ir"> <em class="ms">嗨，我是</em></strong><a class="ae ly" href="https://aggelosarvanitakis.me" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="ms">Aggelos</em></strong></a><strong class="ka ir"><em class="ms">！如果你喜欢这个，考虑一下</em> </strong> <a class="ae ly" href="https://twitter.com/AggArvanitakis" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="ms">在twitter上关注我</em> </strong> </a> <strong class="ka ir"> <em class="ms">并与你的朋友分享这个故事</em>😀</strong></p></div></div>    
</body>
</html>