<html>
<head>
<title>Effectively communicate between Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务之间的有效通信</h1>
<blockquote>原文：<a href="https://itnext.io/effectively-communicate-between-microservices-de7252ba2f3c?source=collection_archive---------0-----------------------#2018-08-01">https://itnext.io/effectively-communicate-between-microservices-de7252ba2f3c?source=collection_archive---------0-----------------------#2018-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3621" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在http/1.1和gRPC之间选择。TL；DR:使用gRPC </strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/33667fd558a0b90e962f659549ccbdcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJUw4oS0gD1Q3l-j-wp_3Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">有效沟通</figcaption></figure><p id="03a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微服务之间的通信方式会影响应用程序的性能和可伸缩性。服务之间的通信可以是同步的，也可以是异步的。在这篇博文中，我们将关注同步。我们有两个共同的协议</p><ul class=""><li id="ec5e" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir"> HTTP/1.1 </strong>:“默认”HTTP调用</li><li id="7299" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> gRPC: </strong>高性能远程过程调用(RPC框架)。<a class="ae lp" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"><em class="lq">grpc . io</em></a><em class="lq"/>有一个全面的文档以及它是如何工作的。</li></ul><p id="69a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一些样本代码，并运行一些性能测试来挑选我们的选择。</p><h1 id="143c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">非集群模式</h1><p id="9ef6" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">让我们从小处着手，尝试让一个微服务与另一个微服务对话。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/30ff644e2cb79cb9a4b2380724da0f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYpApAVghgPvO23EjIik2g.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">简单的应用程序架构图</figcaption></figure><p id="40ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的应用程序包含以下组件</p><ul class=""><li id="017d" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir">负载测试工具:</strong> <a class="ae lp" href="https://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank"> jMeter </a></li><li id="038c" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">服务A: 向服务b发出请求并返回响应。</li><li id="d296" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir">服务B: </strong>在所有API延迟10ms后，用静态JSON进行回复</li><li id="f071" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir">虚拟机:</strong>这两个虚拟机都是Amazon EC2 T2 . x大型机器</li></ul><h1 id="14bc" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">HTTP/1.1</h1><p id="9431" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">这是我们使用任何HTTP客户端库(如<a class="ae lp" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>、<a class="ae lp" href="https://github.com/visionmedia/superagent" rel="noopener ugc nofollow" target="_blank"> superagent </a>)时的默认请求。</p><p id="d253" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建<code class="fe mv mw mx my b">ServiceB</code>来实现我们的API。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">具有HTTP/1.1实现的服务B</figcaption></figure><p id="e160" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们创建用HTTP/1.1调用<code class="fe mv mw mx my b">ServiceB</code>的<code class="fe mv mw mx my b">ServiceA</code></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">具有HTTP/1.1实现的服务A</figcaption></figure><p id="ea1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着这两个服务的运行，我们现在可以启动我们的<code class="fe mv mw mx my b">jMeter</code>来运行一些性能测试。我们将使用50个用户，每个用户将有2000个请求。正如我们在下面的截图中看到的，我们的中位数是<code class="fe mv mw mx my b">37ms</code>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/d03b10071280e872aa248f79682468e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PMxYnmGK1K5oXGxkKCCNWg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">非集群模式下HTTP/1.1的性能结果</figcaption></figure><h1 id="1c48" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">gRPC</h1><p id="f1bc" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">gRPC默认使用<a class="ae lp" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>。除了<code class="fe mv mw mx my b">serviceA</code>和<code class="fe mv mw mx my b">serviceB</code>，我们还需要一个<code class="fe mv mw mx my b">proto</code>文件来定义我们的远程调用。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">公开的RPC的原型文件</figcaption></figure><p id="5639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次实现<code class="fe mv mw mx my b">serviceB</code>，这次使用<code class="fe mv mw mx my b">gRPC</code></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">实施gRPC的服务B</figcaption></figure><p id="d9ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的几件事:</p><ul class=""><li id="e652" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">我们在<code class="fe mv mw mx my b">line 4</code>创建<code class="fe mv mw mx my b">grpc</code>服务器</li><li id="c06a" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">我们在<code class="fe mv mw mx my b">line 16</code>的服务器上增加了一项服务</li><li id="7f9f" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">我们在第23行绑定<code class="fe mv mw mx my b">port</code>和<code class="fe mv mw mx my b">credentials</code></li></ul><p id="580b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mv mw mx my b">serviceA</code>使用gRPC的实现如下</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">实施gRPC的服务A</figcaption></figure><p id="b3ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的几件事:</p><ul class=""><li id="450e" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">我们在<code class="fe mv mw mx my b">line 4</code>创建<code class="fe mv mw mx my b">grpc</code>客户端</li><li id="48d6" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">我们在<code class="fe mv mw mx my b">line 6</code>进行远程呼叫</li></ul><p id="8c47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次运行jMeter工具测试。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/5ed49e2a902d3c0b2f5c26ee6496ac3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MNtHT_0KfpzYpna643Hnw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">gRPC在非集群模式下的性能结果</figcaption></figure><p id="e67f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这些数据中我们可以看出，<code class="fe mv mw mx my b">gRPC</code>比普通的HTTP/1.1请求快27%</p><h1 id="9da0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">集群模式下的应用架构</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/941706de879225417e3d0db95c8f6772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnkw91_0suff7O4w2HqkXQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">应用架构</figcaption></figure><p id="ce22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在生产环境中运行任何东西，很可能您正在运行任何给定服务的许多实例。在这种情况下，我们进行了以下更改:</p><ul class=""><li id="e3cc" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">在不同的端口上运行我们服务的三个实例</li><li id="efb0" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">我们使用NGINX作为负载平衡器</li></ul><h1 id="cd9f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">HTTP/1.1</h1><p id="11dc" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">在服务方面不需要任何改变。我们所需要做的就是配置我们的<code class="fe mv mw mx my b">nginx</code>来负载平衡<code class="fe mv mw mx my b">serviceB</code>的流量。我们可以将<code class="fe mv mw mx my b">/etc/nginx/sites-available/default</code>修改成这样</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用HTTP/1.1的nginx</figcaption></figure><p id="92f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以启动我们的3个<code class="fe mv mw mx my b">serviceB</code>实例，并运行我们的性能测试</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nd"><img src="../Images/632fb4f180374c04b3f5d6c8288a5c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNDezfbmXLPeSdHxguGKTQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">HTTP/1.1在集群模式下的性能结果</figcaption></figure><h1 id="5520" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">gRPC</h1><p id="0b16" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">最近，nginx版本1增加了对gRPC的支持..13.10 。因此，我们需要获得最新的版本，因为默认的<code class="fe mv mw mx my b">sudo apt-get install nginx</code>将不起作用。</p><p id="f47a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们没有在<a class="ae lp" href="https://nodejs.org/api/cluster.html" rel="noopener ugc nofollow" target="_blank">集群</a>模式下使用节点，因为gRPC<a class="ae lp" href="https://github.com/grpc/grpc/issues/6976" rel="noopener ugc nofollow" target="_blank">不受</a>支持。</p><p id="23c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照以下步骤获取最新的<code class="fe mv mw mx my b">nginx</code></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">获取最新的nginx</figcaption></figure><p id="94be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要ssl证书。我们可以使用<a class="ae lp" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> openSSL </a>创建自签名证书</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">创建自签名证书的命令</figcaption></figure><p id="6ba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要修改我们的<code class="fe mv mw mx my b">/etc/nginx/sites-available/default</code>文件来开始使用<code class="fe mv mw mx my b">gRPC</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">带gRPC的nginx</figcaption></figure><p id="3562" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。让我们再次运行我们的性能测试</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/5b5728540a8a30a73874865dd9b33f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXIJQj26Ch3wrjDIsbNnSQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">gRPC在非集群模式下的性能结果</figcaption></figure><p id="8582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所见,<code class="fe mv mw mx my b">gRPC</code>比HTTP/1.1快31%</p><h1 id="10bd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="6b5f" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">gRPC很快。在上面的测试中，我们通过改变我们之间的交流方式，比HTTP/1.1多了31% 。</p><p id="7263" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的源代码可以在<a class="ae lp" href="https://github.com/abhinavdhasmana/interserviceCommunication" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到</p></div></div>    
</body>
</html>