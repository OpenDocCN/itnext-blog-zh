<html>
<head>
<title>Async and Await in JavaScript, the extension to a promise.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Async和Await，是对承诺的扩展。</h1>
<blockquote>原文：<a href="https://itnext.io/async-and-await-in-javascript-the-extension-to-a-promise-f4e0048964ac?source=collection_archive---------0-----------------------#2019-05-07">https://itnext.io/async-and-await-in-javascript-the-extension-to-a-promise-f4e0048964ac?source=collection_archive---------0-----------------------#2019-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9a19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">学习JavaScript中的承诺是我发现学习起来非常有趣的基础之一。我一直在练习面试问题，JavaScript承诺是一个热门话题。在这段旅程中，我遇到了Async和wait，它们是承诺的扩展，允许我们编写更干净、更可读的代码。如果你不知道什么是承诺，请看看我的另一篇文章<a class="ae ko" href="https://medium.com/@mattdoering86/what-is-a-promise-really-9074e7526ec3" rel="noopener">什么是真正的承诺？</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">via <a class="ae ko" href="https://giphy.com/gifs/life-interesting-footage-ZVik7pBtu9dNS/links" rel="noopener ugc nofollow" target="_blank"> giphy </a></figcaption></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="9855" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">异步</strong></h1><p id="f03a" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我们可以从可以放在函数前面的特殊关键字async开始。该函数将通过事件循环异步操作一个函数，使用隐式承诺返回其结果。如果你需要一个事件循环的复习，看看这个非常棒的<a class="ae ko" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">视频</a>！一个异步函数仅仅意味着一个承诺将被返回，如果一个承诺没有被返回，JavaScript将自动把它包装在一个解析的承诺中，返回值在那个函数中。这看起来就像写return Promise.resolve('hello ')。您可以简单地通过将async关键字放在您正在创建的函数前面来编写一个异步函数。</p><div class="kp kq kr ks gt ab cb"><figure class="mk kt ml mm mn mo mp paragraph-image"><img src="../Images/26dbcf72cfff01a2875eb6b614725a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*3QQNJfgz0G198Yfbdp5wbA.png"/></figure><figure class="mk kt ms mm mn mo mp paragraph-image"><img src="../Images/4559fe59868e7abf5374341c8e7ddadf.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*rUtdPsv1KlSYIvyg5q9OFA.png"/></figure></div><p id="7e07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在上面看到，运行代码会给出一个承诺的输出以及异步函数中返回的值。你也可以明确地回复一个承诺，和下面写的一样。</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="9d99" class="my li it mu b gy mz na l nb nc">async function foo() {<br/> return Promise.resolved('hello');<br/>}</span><span id="035b" class="my li it mu b gy nd na l nb nc">foo().then(alert); // hello</span></pre><p id="ba6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很酷，async关键字允许我们编写一个函数，返回一个承诺，并在其中包装一个非承诺。</p><h1 id="5532" class="lh li it bd lj lk ne lm ln lo nf lq lr ls ng lu lv lw nh ly lz ma ni mc md me bi translated"><strong class="ak">等待</strong></h1><p id="f688" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">关键字await用于等待承诺。它只能在异步函数中使用。这个关键字让JavaScript一直等到这个承诺实现并返回结果。这里有一个例子，承诺在2秒内解决。</p><div class="kp kq kr ks gt ab cb"><figure class="mk kt nj mm mn mo mp paragraph-image"><img src="../Images/9786d9d32464fdeb0021b8bdf114e053.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*mBVRQIbPOdSNN4_gTIuasw.png"/></figure><figure class="mk kt nk mm mn mo mp paragraph-image"><img src="../Images/dfbbef66d22d305ead380edc1b8ad361.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*Co9RvXI1i4TXDs3MZoWH8g.png"/></figure></div><p id="5833" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与使用promise.then相比，这是一种更好的获得promise结果的方式。现在，我们可以将一个只使用fetch关键字的函数转换成一个异步函数，并看看它在清晰度上有什么不同。</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="e395" class="my li it mu b gy mz na l nb nc">function jsonData(url) {<br/>  return fetch(url)<br/>    .then(res =&gt; {<br/>      if (res.status == 200) {<br/>        return res.json();<br/>      } else {<br/>        throw new Error(res.status);<br/>      }<br/>    });<br/>}<br/><br/>jsonData('non') /<br/>  .catch(alert); // Error: 404</span></pre><p id="392f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以使用await更新为下面的异步函数。</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="da53" class="my li it mu b gy mz na l nb nc">async function jsonData(url) { // (1)<br/>  let res = await fetch(url); // (2)<br/><br/>  if (res.status == 200) {<br/>    let json = await res.json(); // (3)<br/>    return json;<br/>  }<br/><br/>  throw new Error(res.status);<br/>}<br/><br/>jsonData('no-such-user.json')<br/>  .catch(alert); // Error: 404 (4)</span></pre><h1 id="71be" class="lh li it bd lj lk ne lm ln lo nf lq lr ls ng lu lv lw nh ly lz ma ni mc md me bi translated">需要注意的重要事项</h1><p id="1cd0" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">不能在常规函数中使用await关键字。这将导致语法错误。Await只需要在异步函数中使用。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/22b56494bef2b136d6066932f34ca518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*HyY_Q3LTQdEf9ekuSdzqQg.png"/></div></figure><p id="4e0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管我们现在可以让代码看起来同步，但重要的是要记住执行仍然是异步的！这一点很重要，因为如果使用不当，会显著增加执行时间。下面的两个例子展示了使用异步函数的正确方法。如果我们在每个单独的函数上使用await，JavaScript编译器将在执行第二个函数之前等待第一个函数被解析。事件循环的要点是避免像第一个例子那样阻塞代码。如果我们需要等待多个承诺，我们可以将它们包装在一个Promise.all中，然后在Promise关键字之前使用await。</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="c65e" class="my li it mu b gy mz na l nb nc">// This would be the bad way to do this as you are blocking b from running until the a function returns. <br/>const makeSomething = async() =&gt; {<br/> const a = await getSomething('apples')<br/> const b = await getSomething('strawberry')<br/>  return [a, b]<br/>}</span><span id="7bcb" class="my li it mu b gy nd na l nb nc">// This is how you would allow your functions to run simultaneously <br/>const makeSomething = async() =&gt; {<br/> const a = getSomething(‘apples’)<br/> const b = getSomething(‘strawberry’)<br/>   const result = await Promise.all([a, b])</span><span id="ba8e" class="my li it mu b gy nd na l nb nc">  return result;<br/>}</span><span id="4984" class="my li it mu b gy nd na l nb nc">// wrapping our fetch in a Promise.all would allow them to run concurrently. <br/>let results = await Promise.all([<br/>  fetch(url1),<br/>  fetch(url2),<br/>]);</span></pre><h1 id="019e" class="lh li it bd lj lk ne lm ln lo nf lq lr ls ng lu lv lw nh ly lz ma ni mc md me bi translated">结论</h1><p id="009e" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">Async / await允许我们编写读起来像同步代码的异步代码。当处理承诺时，它允许一些更好的可读性！为了在标记为async的函数中进行重述，可以将await关键字放在返回承诺的表达式前面。当您这样做时，异步函数的执行会暂停，直到承诺被解析。</p><h1 id="1f38" class="lh li it bd lj lk ne lm ln lo nf lq lr ls ng lu lv lw nh ly lz ma ni mc md me bi translated">参考</h1><p id="f4c0" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">请检查所有写这篇博客的材料。有很多很棒的资料可以让你了解更多关于这种良好的语法糖方法的承诺和异步JavaScript。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/afc5d01c5b44067f334dc7f9ae934579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*NvWUmkXPfjc8AnlkQySfyw.png"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn kv l"/></div></figure><div class="no np gp gr nq nr"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">异步功能</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">异步函数声明定义了一个异步函数，该函数返回一个异步函数对象。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">developer.mozilla.org</p></div></div><div class="oa l"><div class="ob l oc od oe oa of mq nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://javascript.info/async-await" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">异步/等待</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">有一种特殊的语法以更舒适的方式处理承诺，称为“async/await”。令人惊讶的是…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">javascript.info</p></div></div><div class="oa l"><div class="og l oc od oe oa of mq nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://hackernoon.com/javascript-async-await-the-good-part-pitfalls-and-how-to-use-9b759ca21cda" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">JavaScript async/await:优点、缺陷和使用方法</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">ES7引入的async/await是JavaScript异步编程的一个巨大改进。它提供了…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">hackernoon.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of mq nr"/></div></div></a></div></div></div>    
</body>
</html>