<html>
<head>
<title>Easy patterns: Iterator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单模式:迭代器</h1>
<blockquote>原文：<a href="https://itnext.io/easy-patterns-iterator-f5c0dd85957?source=collection_archive---------5-----------------------#2019-01-21">https://itnext.io/easy-patterns-iterator-f5c0dd85957?source=collection_archive---------5-----------------------#2019-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9497b154c86a3ba571a5f77acd9ddc69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUSLZydF5PcPwY8hn3by3w.png"/></div></div></figure><p id="2079" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是easy patterns系列描述的延续，介绍了一个名为迭代器的行为模式，它提供了一种访问某个序列(聚合对象)的元素而不暴露其内部表示的方法。</p><p id="cd30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也请参考其他模式文章:</p><h2 id="f002" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">创作模式:</h2><blockquote class="lp lq lr"><p id="fa0f" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-simple-factory-b946a086fd7e"> <strong class="ka ir">简易工厂</strong> </a></p><p id="2004" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-factory-method-5f27385ac5c"> <strong class="ka ir">工厂法</strong> </a></p><p id="8fab" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-builder-d85655bcf8aa"> <strong class="ka ir">建造者</strong> </a></p><p id="0e6b" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-singleton-283356fb29bf"> <strong class="ka ir">单个</strong> </a></p><p id="73db" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-abstract-factory-2325cb398fc6"> <strong class="ka ir">抽象工厂</strong> </a></p><p id="9d90" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-prototype-e03ec6962f89"> <strong class="ka ir">原型</strong> </a></p></blockquote><h2 id="b2ad" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结构模式:</h2><blockquote class="lp lq lr"><p id="4425" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-adapter-9b5806cb346f"> <strong class="ka ir">适配器</strong> </a></p><p id="5343" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-decorator-eaa96c0550ea"> <strong class="ka ir">装饰者</strong> </a></p><p id="a7f3" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-bridge-28d50dc25f9f"> <strong class="ka ir">桥</strong> </a></p><p id="2353" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158"> <strong class="ka ir">复合</strong> </a></p><p id="2cca" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-facade-8cb185f4f44f"> <strong class="ka ir">立面</strong> </a></p><p id="9d1e" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-flyweight-dab4c018f7f5"> <strong class="ka ir">飞锤</strong> </a></p><p id="1533" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-proxy-45fc3a648020"> <strong class="ka ir">代理</strong> </a></p></blockquote><h2 id="c975" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">行为模式:</h2><blockquote class="lp lq lr"><p id="052a" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-visitor-b8ef57eb957"> <strong class="ka ir">来访者</strong> </a></p><p id="8f4d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-mediator-e0bf18fefdf9"> <strong class="ka ir">调解员</strong> </a></p><p id="ee43" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-observer-63c832d41ffd"> <strong class="ka ir">观察者</strong> </a></p><p id="2da6" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-memento-ce966cec7478"> <strong class="ka ir">纪念品</strong> </a></p><p id="e199" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-iterator-f5c0dd85957"> <strong class="ka ir">迭代器</strong> </a> <strong class="ka ir"> <em class="iq"> </em> </strong>(本文)</p><p id="b365" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-chain-of-responsibility-9a84307ad837"> <strong class="ka ir">责任链</strong> </a></p><p id="e67d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-strategy-ecb6f6fc0ef3"> <strong class="ka ir">策略</strong> </a></p><p id="f43d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-state-ec87a1a487b4">状态<strong class="ka ir">状态</strong>状态</a></p></blockquote><h1 id="7d7d" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">主要本质</h1><p id="7dba" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">迭代器模式的关键思想是让你以你想要的方式访问和遍历列表。所有这些功能都将放在迭代器对象中。iterator类定义了一个访问列表元素的接口。迭代器对象还负责跟踪当前元素以及哪些元素已经被遍历。</p><p id="9c15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建一个迭代器实例，客户端应该提供一个列表来遍历它。一旦迭代器实例准备就绪，客户机就可以顺序访问列表中的元素。</p><p id="8375" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个迭代器类都需要实现公共接口:</p><ul class=""><li id="4f04" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><code class="fe nc nd ne nf b">.currentItem</code>方法返回列表中的当前元素</li><li id="47fa" class="mt mu iq ka b kb ng kf nh kj ni kn nj kr nk kv my mz na nb bi translated"><code class="fe nc nd ne nf b">.next</code>方法将当前元素推进到聚合对象中的下一个元素</li><li id="91c1" class="mt mu iq ka b kb ng kf nh kj ni kn nj kr nk kv my mz na nb bi translated"><code class="fe nc nd ne nf b">.isDone</code>方法测试我们是否到达了聚集对象的末尾。</li></ul><p id="29d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">遍历机制与list对象的分离让我们可以为不同的遍历算法定义迭代器，而无需在list接口中声明它们。例如，一些<strong class="ka ir"> FilterIterator </strong>只能从列表中返回满足特定约束的元素。</p><p id="2d8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种模式包括两个主要角色:</p><ul class=""><li id="279e" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><strong class="ka ir">迭代器</strong> —定义访问和遍历元素的接口及其实现</li><li id="929a" class="mt mu iq ka b kb ng kf nh kj ni kn nj kr nk kv my mz na nb bi translated"><strong class="ka ir"> Aggregate </strong> —定义创建迭代器对象的接口及其实现。</li></ul><p id="103f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种模式也称为<strong class="ka ir">光标</strong>，应该用于以下情况:</p><ul class=""><li id="a409" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">要访问聚集对象内容</li><li id="6d43" class="mt mu iq ka b kb ng kf nh kj ni kn nj kr nk kv my mz na nb bi translated">支持聚合对象的多次遍历</li><li id="e589" class="mt mu iq ka b kb ng kf nh kj ni kn nj kr nk kv my mz na nb bi translated">为了提供用于遍历不同集合结构统一接口</li></ul><h1 id="9794" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">使用示例</h1><p id="2fca" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">在我们的例子中，我们将创建一个聚合对象，并用几个迭代器实例遍历它。</p><p id="685d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个迭代器对象将根据聚集对象<code class="fe nc nd ne nf b">from</code>和<code class="fe nc nd ne nf b">to</code>边界中定义的直接顺序返回相关数据项。</p><p id="f973" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个迭代器对象将以相反的顺序返回定义的边界中的相关数据。</p><p id="7287" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这只是使用迭代器模式的迭代控制的一个小演示。潜在地，当您处理非常复杂的数据时，由于数据和迭代逻辑之间的关注点分离，这种模式可以极大地降低代码的复杂性并提高其可读性。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a9f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要以自定义方式查看迭代过程，您可以使用<code class="fe nc nd ne nf b">for..of</code>迭代，而不是展开<strong class="ka ir">运算符</strong>。</p><pre class="nl nm nn no gt nr nf ns nt aw nu bi"><span id="37d9" class="kw kx iq nf b gy nv nw l nx ny">for (let item of ascendingIterator) {<br/>  console.log(item);<br/>}</span></pre><p id="7311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将为您返回与第一个示例相同的结果。也可以在Codepen中随意使用它:</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="nz nq l"/></div></figure><h1 id="b245" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">利润</h1><p id="42b1" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">迭代器模式使得聚合遍历中的变化成为可能。复杂的集合体可以以多种方式遍历。迭代器使得改变遍历算法变得很容易——只需用不同的迭代器实例替换它。</p><p id="e1d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">迭代器简化了集合对象的接口，因为它可以将遍历问题完全委托给迭代器对象本身。聚合对象应该知道并担心迭代器如何遍历它的元素。</p><p id="4243" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">聚合对象可以有任意多的并行遍历。迭代器跟踪自己的遍历状态。</p><p id="0b5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">聚合对象可能没有长度属性，如果在运行时没有剩余的元素，就进行定义。同样，不仅可以迭代数组和列表。</p><h1 id="9f11" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">薄弱的地方</h1><p id="98d2" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">在大多数情况下，迭代器的使用可能是一种开销。它需要实现特定的方法才能工作。它的逻辑可能不明显，尤其是如果它没有用在正确的地方。通常JavaScript在很多地方使用迭代器模式:对于字符串和数组对象，<strong class="ka ir"> spread </strong>操作符返回迭代器的聚合对象。</p><p id="cbf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以创建无限的迭代器来生成无限的数据序列。因此，与<code class="fe nc nd ne nf b">for..of</code>一起调用这样的迭代器也将是无限的。这种灵活性需要在这样的代码中对退出点进行额外的控制(例如使用一些<code class="fe nc nd ne nf b">break</code>操作符)。</p><h1 id="8dc7" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">结论</h1><p id="d9d8" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">迭代器是一个可以遍历其他对象的对象。在JavaScript中，这种能力需要实现<code class="fe nc nd ne nf b">Symbol.iterator</code>方法并返回<code class="fe nc nd ne nf b">next</code>方法的实现。</p><p id="4796" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript中有很多地方都在使用这种模式:<strong class="ka ir"> spread </strong>操作符、<strong class="ka ir">数组</strong>和<strong class="ka ir"> String </strong>对象。</p><p id="b71f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经常与<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158">复合模式</a>一起使用。通常迭代器应用于递归结构。</p><p id="2791" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-factory-method-5f27385ac5c">工厂方法</a>通常与迭代器模式一起使用来实例化适当的迭代器子类。</p><p id="6cd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Memento 模式通常与迭代器模式结合使用。迭代器可以使用它在内部捕获迭代的状态。</p><p id="71d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您觉得这篇文章有帮助，请点击👏按钮并在下面随意评论！</p></div></div>    
</body>
</html>