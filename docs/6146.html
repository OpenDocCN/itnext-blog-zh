<html>
<head>
<title>Terraform For Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适合初学者的地形</h1>
<blockquote>原文：<a href="https://itnext.io/terraform-for-beginners-dd8701c1ebdd?source=collection_archive---------0-----------------------#2021-09-01">https://itnext.io/terraform-for-beginners-dd8701c1ebdd?source=collection_archive---------0-----------------------#2021-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b0155423995db249facbaa33eac66ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WfT-nF7tgxSx4fns.jpg"/></div></div></figure><div class=""/><h1 id="011c" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="82c2" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你听说过Terraform，对吧？但是你实际上不知道它是什么或者它是如何工作的？好了，读者朋友们，请为我的初学者指南系好安全带。</p><p id="01df" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这篇文章中，我将向你解释Terraform的基本概念，你如何使用它，它是如何工作的，并告诉你为什么它在过去几年中获得了如此强大的追随者。我打算简单介绍一下Terraform的基本语法和它所使用的配置语言，而不会在更高级的主题上做太深入的探讨。我将在这篇博客之后更深入地研究这项技术。</p><p id="673e" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我开始写这篇文章的时候，我以为这只是一件简单的小事，但是当我开始写的时候，我意识到Terraform实际上是非常复杂的，所以这篇文章也随之发展。因此，如果你没有很多时间，只想消化摘要，请随意跳到底部，在那里你会找到TL；灾难恢复版本🙂</p><h1 id="7e22" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是Terraform，为什么这么大惊小怪？</h1><p id="0884" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好的，所以你找到这个博客的可能是因为你公司里有人说过“我们应该为此使用Terraform”，或者因为你遇到了一个git repo，上面写着“你可以使用这些Terraform脚本来部署这个解决方案”，而不想举手询问他们在谈论什么。亲爱的读者，不要害怕，12个多月前，我确实处在你的位置上，努力从困惑中挣脱出来。</p><h2 id="6c16" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">一言以蔽之</h2><p id="441e" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在其最基本的形式中，Terraform是一种将称为HCL <em class="ml"> (Hashicorp配置语言)</em>的配置文件转换为现实世界基础设施的应用程序，通常在AWS、Azure或谷歌云平台等云提供商中。</p><p id="e5e6" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这种获取配置文件并将其转换成实际资源的概念被称为IaC <em class="ml">(基础设施即代码)</em>，是软件工程领域的新热点。它现在变得如此热门的原因是因为这些代码可以在repos中与你的应用程序代码共存，可以进行版本控制，并且可以轻松集成到你的CI/CD管道中。</p><h2 id="cc1a" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">代码输入资源输出…简单！(不完全是)</h2><p id="fcee" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因此，正如你们中的许多人可能已经看到的那样，IaC的概念并不新鲜，十多年来人们一直试图自动化他们的云部署，那么为什么这个平台会变得如此受欢迎呢？</p><p id="4714" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">简单来说；Terraform是一个状态驱动的云平台供应引擎。它利用抽象工具(称为<em class="ml">提供者</em>和<em class="ml">后端</em>)使我们能够编写代码，这些代码可以被解释和翻译成一致的、确定性的、特定于云提供者的CRUD api调用，从而消除了我们的大量跑腿工作和压力。</p><figure class="mn mo mp mq gt is gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/2883f944d15ca9f15695244e3bb1d817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*VaN9B7uOD8jQnwb4UidEBw.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Terraform如何工作的高级视图</figcaption></figure><h1 id="1a3b" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">基础设施作为代码</h1><p id="0bb7" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好了，你已经有了基本的电梯间推介，但这实际上意味着什么呢？简而言之，IaC试图解决以下问题:</p><ul class=""><li id="b26f" class="mv mw jb ky b kz lu ld lv lh mx ll my lp mz lt na nb nc nd bi translated">不再需要单独的团队来管理基础架构供应和应用程序代码开发。</li><li id="a715" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">允许我们使用现代源代码控制工具(如git)来保存、创作/审查对我们基础架构的更改，并为我们提供基础架构历史/发展的良好概述。</li><li id="12e7" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">使我们能够执行应用程序和基础架构的持续集成和持续部署(CI/CD );这意味着这两种元素可以同时部署。</li><li id="e253" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">允许我们轻松保持多个环境同步，而无需手动更新。</li><li id="8cc2" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">无需定制基础架构配置脚本和/或内部构建的工具。</li><li id="3842" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">消除了人为错误，因为自动化代码部署消除了人为因素。</li></ul><p id="da5e" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="ml">需要注意的是，IaC并不是一个新概念，事实上它在云平台的早期就以不同的形式出现了(AWS有CloudFormation，Azure有ARM模板)</em></p><h2 id="c20e" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">简单的例子</h2><p id="1b19" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">作为一名系统开发人员，我意识到我需要配置一些云存储。没什么特别的，但是我需要一个转储文件的地方和一个读取文件的地方。让我们看看当我们使用Azure和“物理”云基础设施时，这在概念上是什么样子的:</p><figure class="mn mo mp mq gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/581b80308e3ee176722fb8f2c5b64416.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*Rntqtu48ZfYacgtKPQn_1A.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">概念系统架构</figcaption></figure><p id="6e57" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以我在这里使用微软Azure术语，但希望这对不熟悉这个平台的人来说不会造成很大的混乱。基本上我需要一个资源组(因为在Azure中，事物存在于资源组中)，一个存储帐户和一个存储容器。有了所有这些东西，我就可以安全地将我的文件存储在云中的所述容器中🙂</p><p id="ad93" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，让我们将这个概念模型转换成Terraform HCL，看看它是什么样子:</p><pre class="mn mo mp mq gt nk nl nm nn aw no bi"><span id="1217" class="lz jz jb nl b gy np nq l nr ns">terraform {<br/>  required_providers {<br/>    azurerm = "~&gt; 2.64"<br/>  }<br/>}</span><span id="08fd" class="lz jz jb nl b gy nt nq l nr ns">provider "azuread" <!-- -->{<br/>}</span><span id="4347" class="lz jz jb nl b gy nt nq l nr ns">resource "azurerm_resource_group" "example" {<br/>  name     = "example-resources"<br/>  location = "West Europe"<br/>}<br/><br/>resource "azurerm_storage_account" "example" {<br/>  name                     = "examplestoracc"<br/>  resource_group_name      = azurerm_resource_group.example.name<br/>  location                 = azurerm_resource_group.example.location<br/>  account_tier             = "Standard"<br/>  account_replication_type = "LRS"<br/>}<br/><br/>resource "azurerm_storage_container" "example" {<br/>  name                  = "content"<br/>  storage_account_name  = azurerm_storage_account.example.name<br/>  container_access_type = "private"<br/>}</span></pre><p id="130e" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果用我们得到的HCL注释我们的概念设计:</p><figure class="mn mo mp mq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/a5762a8d3e3782272f5e463d7e8616cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgoVvppryj_l9O9wnZPwlg.png"/></div></div></figure><h1 id="2b67" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">分解它</h1><p id="089a" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好的，我知道我说过我不会深入解释HCL的语法，但是我认为一点概述可能有助于解释事情。</p><p id="023d" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们以存储客户的HCL为例，一步一步地进行分解:</p><pre class="mn mo mp mq gt nk nl nm nn aw no bi"><span id="9c60" class="lz jz jb nl b gy np nq l nr ns">terraform {<br/>  required_providers {<br/>    azurerm = "~&gt; 2.64"<br/>  }</span><span id="8ddf" class="lz jz jb nl b gy nt nq l nr ns">  backend "azurerm" {<br/>  }<br/>}</span><span id="3592" class="lz jz jb nl b gy nt nq l nr ns">provider "azuread" <!-- -->{<br/>}</span><span id="a75e" class="lz jz jb nl b gy nt nq l nr ns">resource "azurerm_resource_group" "example" {<br/>  name     = "example-resources"<br/>  location = "West Europe"<br/>}</span><span id="ba10" class="lz jz jb nl b gy nt nq l nr ns">resource "azurerm_storage_account" "example" {<br/>  name                     = "examplestoracc"<br/>  resource_group_name      = azurerm_resource_group.example.name<br/>  location                 = azurerm_resource_group.example.location<br/>  account_tier             = "Standard"<br/>  account_replication_type = "LRS"<br/>}</span></pre><p id="a582" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">直接查看这个语法，您可以很容易地发现它与JSON等语言的一些相似之处。但是每个部分(或者说<strong class="ky jc">阻挡</strong>是什么意思呢？</p><ul class=""><li id="3d04" class="mv mw jb ky b kz lu ld lv lh mx ll my lp mz lt na nb nc nd bi translated"><code class="fe nv nw nx nl b"><strong class="ky jc">terraform</strong></code>:允许您配置<strong class="ky jc"> Terraform </strong>本身的一些行为，比如您希望使用哪个<strong class="ky jc">提供者</strong>以及它需要下载的版本。记住:你不能使用来自提供者的资源，除非你首先指示Terraform你想使用那些提供者，就像我们的C#代码中的nuget包依赖或JavaScript中的npm包。<a class="ae ny" href="https://www.terraform.io/docs/language/settings/index.html" rel="noopener ugc nofollow" target="_blank">欲了解更多信息，请参见此处的文档</a></li><li id="cfbc" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><code class="fe nv nw nx nl b"><strong class="ky jc">backend</strong></code>:允许我们指定希望Terraform使用哪个<strong class="ky jc">后端</strong>。后端决定了两件关键的事情，我们的状态存储在哪里，我们的操作在哪里执行。本质上，如果我们正在使用Azure，并且想要将我们的状态持久化到云中，我们可以使用<code class="fe nv nw nx nl b">azurerm</code>后端来实现。如果我们不指定后端，那么就使用默认的后端，这通常被称为<code class="fe nv nw nx nl b">local</code>。<a class="ae ny" href="https://www.terraform.io/docs/language/settings/backends/index.html" rel="noopener ugc nofollow" target="_blank">在此查看官方文件</a></li><li id="673b" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><code class="fe nv nw nx nl b"><strong class="ky jc">provider</strong></code> : <strong class="ky jc">提供商</strong>是Terraform用来与不同云提供商接口的插件。一些提供程序允许您在这些块中添加额外的配置。<a class="ae ny" href="https://www.terraform.io/docs/language/providers/index.html" rel="noopener ugc nofollow" target="_blank">在此查看官方文件</a></li><li id="3ca1" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><code class="fe nv nw nx nl b"><strong class="ky jc">resource</strong></code>:HCL中的一个关键字，表示这是您想要提供的<strong class="ky jc">资源</strong>。<a class="ae ny" href="https://www.terraform.io/docs/language/resources/index.html" rel="noopener ugc nofollow" target="_blank">官方文件在此</a></li><li id="ef98" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><code class="fe nv nw nx nl b"><strong class="ky jc">"azure_reosurce_group</strong>"</code>:这是你想要的“资源”的“类型”。当它运行时，Terraform将尝试并确定哪个“提供者”包含这个“类型”,并对其执行正确的CRUD操作。(我将在本文后面更详细地介绍这些CRUD操作)</li><li id="43b0" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><code class="fe nv nw nx nl b"><strong class="ky jc">"example"</strong></code>:这是Terraform脚本中资源的名称/标识符。<strong class="ky jc">请不要将这与您将在Azure门户</strong>中看到的资源名称混淆。最好以同样的方式来考虑这一点，在代码语言中，如Go或C#等，你会有变量名。请注意，我是如何将我的两个资源称为同一个“示例”标识符的，这是因为如果资源类型和标识符的组合是唯一的，Terraform允许复制。</li><li id="a14e" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><code class="fe nv nw nx nl b"><strong class="ky jc">name</strong></code>和<code class="fe nv nw nx nl b"><strong class="ky jc">location</strong></code>:这些是“资源”的属性或特性。这些决定了“提供商”将如何在云中调配资源。如果你使用过Azure，我相信你会意识到名字和位置是你在资源上设置的常见事物。这里<code class="fe nv nw nx nl b">name</code>指定了您将在Azure门户中看到的资源的名称。</li><li id="0c8d" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">好了，现在事情变得有趣了，这就是Terraform的真正力量开始显现的地方。这里我们将一个资源的“输出”传递给另一个资源。这里我们说的是<code class="fe nv nw nx nl b">azurerm_storage_account</code>的<code class="fe nv nw nx nl b">resource_group_name</code>属性依赖于名为<code class="fe nv nw nx nl b">example</code>的<code class="fe nv nw nx nl b">azure_resource_group</code>的输出。很聪明吧？</li></ul><p id="5e64" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">好了，希望这能让您对如何配置资源以及如何将一个资源的输出链接到另一个资源有一个很好的了解。这种资源的“链接”实际上是Terraform中一个非常重要的概念，因为它允许引擎构建其资源图。通过明确定义资源之间的依赖关系，它将确保引擎知道以正确的顺序供应它们(例如:在它必须进入的资源组之前，它不会尝试做存储帐户)，并将帮助Terraform将资源转换为其状态<strong class="ky jc"/>。</p><h1 id="58b9" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">沃特州？？？那是从哪里来的？？</h1><p id="e0fc" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好了，如果你没有从这篇博文中得到什么，请记住它的核心就是一个状态驱动的工作流引擎。正是这种状态引擎使得Terraform能够运行，也使得它如此受开发者欢迎。因此，我们必须了解什么是国家，以及它是如何运作的。</p><p id="636b" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">好的，让我们想象你在一家餐馆里，当服务员来到你的桌子前，你点了以下几样菜:</p><ul class=""><li id="5364" class="mv mw jb ky b kz lu ld lv lh mx ll my lp mz lt na nb nc nd bi translated">汤</li><li id="af7e" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">牛排</li><li id="dc3f" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">薯片一侧</li><li id="ee3e" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">冰淇淋</li></ul><p id="fe16" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在Terraform术语中，这是你的<strong class="ky jc"> <em class="ml">【期望状态】</em> </strong>，为了让你满意，你想要你已经订购的所有4个项目。所以厨房得到命令，开始做饭，但是你关心他们怎么做吗？如果你像我一样，认为他们会正确理解你的订单，按照他们的食谱，最终食物会按照你的要求到达你的餐桌，供你食用。</p><p id="018f" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">好的Terraform完全一样，在Terraform术语中，当我们的<strong class="ky jc"> <em class="ml">【期望状态】</em> </strong>显现为现实时，就变成了所谓的<strong class="ky jc"> <em class="ml">【实际状态】</em> </strong>。</p><h1 id="4d38" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Pfffft这个国家的事情似乎很容易…对不对？</h1><p id="df0c" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好吧，我讨厌听起来像一张卡住的唱片，但是你理解状态的概念对地球的重要性真的很重要。完全诚实地说；让你的头脑了解这个概念是破解Terraform技术的关键。</p><p id="1d97" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们告诉Terraform进行部署时，它会执行一系列步骤:</p><ol class=""><li id="9391" class="mv mw jb ky b kz lu ld lv lh mx ll my lp mz lt nz nb nc nd bi translated">它将解析我们的HCL配置/代码文件。</li><li id="8abc" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">使用我们的HCL中的信息，Terraform将构建一个我们想要供应的所有资源的图表<strong class="ky jc"> <em class="ml">【所需状态】</em> </strong>，并找出它们之间的任何依赖关系，以尝试并决定它们需要创建的逻辑顺序。</li><li id="ad5c" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform接下来将检查它的状态，以更好地了解它已经部署和尚未部署的内容(如果这是我们的第一次部署，状态将为空)。这就是所谓的<strong class="ky jc"> <em class="ml">感知状态。</em> </strong>之所以是感知状态，是因为Terraform“认为”存在的东西和“实际”存在的东西之间存在脱节。</li><li id="b657" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform接下来执行我们的<strong class="ky jc">期望状态</strong>和它所知道的我们的<strong class="ky jc"> <em class="ml">感知状态之间的逻辑增量。</em> </strong>然后它决定需要执行哪些CRUD动作，以及执行它们的顺序，以便使我们的<strong class="ky jc"> <em class="ml">感知状态</em> </strong>与我们的<strong class="ky jc"> <em class="ml">期望状态</em> </strong>一致。</li><li id="bc59" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform接下来执行所有必要的操作，以达到<strong class="ky jc"> <em class="ml">期望状态</em> </strong>。该操作的结果将是资源可能开始出现在我们的Azure订阅中，然后这被称为<strong class="ky jc"> <em class="ml">实际状态。</em>T29】</strong></li><li id="346b" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform更新状态以反映它所做的事情。</li></ol><p id="045c" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们用图形来检查这个流程(用与上述步骤相对应的数字标注的图):</p><figure class="mn mo mp mq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/842568e9cefabc5851eca49d43ac3e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZd8HVAf21maY0cJx1vSsg.png"/></div></div></figure><p id="76fe" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如你所见，状态持久性使Terraform能够在配置执行之间做出决定。</p><h2 id="6e70" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">但是为什么我们要区分“感知状态”和“实际状态”我听到你哭了？</h2><p id="c1b4" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们想象一下，你在办公室工作，你有一张每天都要坐的桌子和椅子。让我们想象一下，这是一个共享的办公室，其他人每天都来来去去。</p><p id="4ec4" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在如果我问你“你的椅子在你的桌子上吗？”…你的答案会是什么？</p><p id="7567" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你们当中那些说“是的，当然，如果那是我的椅子，我会知道它在那里，因为那是我放它的地方”的人不幸地落入了大多数人在使用Terraform时都会犯的常见错误；如果不先检查，就无法知道<strong class="ky jc"> <em class="ml">感知状态</em> </strong>是否与<strong class="ky jc"> <em class="ml">实际状态</em> </strong>匹配。</p><p id="3827" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在桌子和椅子的例子中，没有办法知道(不在那里看)办公室里的其他人没有“移走”你的椅子并且没有归还它。同样，在Terraform中，有可能有人已经“移除”了您的资源，因此Terraform必须首先检查我们的资源是否首先存在于状态中(也就是先前已经创建)，然后它必须检查Azure以确保实际状态与它期望找到的相匹配。</p><p id="6fbc" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请注意:通常给这个操作链的术语是:<strong class="ky jc">调和；</strong>地形<strong class="ky jc"> <em class="ml">将</em> </strong>期望状态调和为实际状态。</p><h1 id="eda6" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">这是一种精神状态</h1><p id="04dc" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好了，我们已经准备好了所有的资源，工作完成了吗？时间在流逝，出于某种原因，我们需要重新部署，但是让我们想象在这段时间里，有人删除了我们的资源组😱当我们重新运行我们的地形时会发生什么？</p><p id="8060" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如我们已经讨论过的，希望Terraform足够聪明来解决这个问题:</p><ol class=""><li id="90fb" class="mv mw jb ky b kz lu ld lv lh mx ll my lp mz lt nz nb nc nd bi translated">Terraform解析我们的HCL配置。</li><li id="d5a4" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">它看到我们想要的状态是拥有一个资源组</li><li id="1547" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">它检查我们的状态，看是否有状态标识符为<code class="fe nv nw nx nl b">example</code>的资源组条目(如前所述，注意资源被标识为“example ”,而不是名称属性“example-resources ”,就像其他语言中的变量一样)</li><li id="96e1" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform看到状态包含一个条目<strong class="ky jc"><em class="ml">(percieved State)</em></strong>，于是接下来去Azure查询资源组的<strong class="ky jc"> <em class="ml">实际状态</em> </strong>。</li><li id="4ba7" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Azure报告了一个404，我们的提供者会将其解释为资源组不存在😱</li><li id="5bb2" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform现在执行<strong class="ky jc"> <em class="ml">【期望状态】</em> </strong>和<strong class="ky jc"> <em class="ml">【实际状态】</em> </strong>之间的增量，并意识到要执行的必要动作是创建它。</li><li id="8345" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform执行必要的操作来创建资源组</li><li id="d55b" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform会根据需要更新其状态。</li></ol><figure class="mn mo mp mq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/1a4937a75a2a2c592ba75457d3c95e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L71LFqidAEEELZiQcLg6Cg.png"/></div></div></figure><p id="3416" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请注意，这次的关键区别在于，状态中某些东西的存在改变了Terraform的运行方式，因为它“感知”到了资源的存在，因为它知道云中应该有资源，所以它转向云提供商(Azure)并询问该资源的“实际状态”。然后，它会根据结果决定要做什么。</p><p id="dfa1" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果Terraform发现它已经拥有了我们想要的资源，这一系列事件将会一直发生。但这并不是说结果永远是创造。例如，如果有人重命名了资源组，那么结果将是Terraform执行资源更新，使实际状态和期望状态一致。</p><h1 id="486d" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">国家可能是一把双刃剑</h1><p id="1b27" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因此，如果国家是Terraform操作的大脑，当它变得腐败时会发生什么？让我告诉你的朋友们，如果我每次看到人们删除他们的状态，然后试图用Terraform做些什么，我就有5英镑，我现在已经是一个非常富有的人了。</p><p id="87f8" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">好了，让我们来探究一下，假设设置与之前完全相同，我们已经部署了资源组，然后出于某种原因，我们删除了所有状态(相信我，很容易做到)。这次会发生什么？</p><p id="260a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="ml">“显然什么都没发生”</em>我听到你们都在哭泣…但你们又一次落入了我的陷阱😉</p><p id="90d1" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">事实上这次发生的是:</p><ol class=""><li id="8b4b" class="mv mw jb ky b kz lu ld lv lh mx ll my lp mz lt nz nb nc nd bi translated">Terraform解析我们的HCL配置/代码文件。</li><li id="2ddd" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform将建立一个我们想要的所有资源的图表。</li><li id="e1c0" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform检查状态，发现它是空的。</li><li id="617f" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform在我们期望的状态和它的状态之间做逻辑增量，并决定它需要创建一个资源(记住，Terraform没有查询Azure，因为<strong class="ky jc">状态文件不存在/为空</strong>)</li><li id="3ebb" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">Terraform试图创建一个名为“示例-资源”的资源组……<strong class="ky jc">BANG！！！💥</strong></li><li id="2d8a" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt nz nb nc nd bi translated">我们现在有一个Terraform错误的情况，因为Azure已经有了一个同名的资源组，我们无法创建另一个同名的资源组。</li></ol><h2 id="079b" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">这里要记住的关键是:</h2><blockquote class="ob"><p id="9476" class="oc od jb bd oe of og oh oi oj ok lt dk translated">Terraform不知道您的云提供商提供的任何资源，除非它处于状态</p></blockquote><h1 id="1a15" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj ol kl km kn om kp kq kr on kt ku kv bi translated">这全是一派胡言</h1><p id="ebd4" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好了，我想我已经讲过了状态，以及它的重要性，现在够了。是时候看看Terraform如何决定执行哪些操作了。正如我之前提到的，Terraform只是一个状态引擎，它根据当前对世界(状态)和现实世界的理解做出决定。说到底，Terraform能做的实际行动只有3个。这些通常被称为CRUD，是<strong class="ky jc">CR</strong>eat、<strong class="ky jc"> U </strong> pdate或<strong class="ky jc"> D </strong> elete的缩写。</p><p id="af66" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">那么什么情况会导致执行哪种操作呢？</p><h2 id="f268" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated"><em class="oo">创建</em></h2><ul class=""><li id="d550" class="mv mw jb ky b kz la ld le lh op ll oq lp or lt na nb nc nd bi translated">我们的地形状态中不存在所需的资源。</li><li id="85f6" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">一个期望的资源以Terraform状态存在，但最终实际上并不存在于我们的云中。</li></ul><h2 id="31e7" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">更新</h2><ul class=""><li id="0f40" class="mv mw jb ky b kz la ld le lh op ll oq lp or lt na nb nc nd bi translated">所需的资源存在于Terraform状态，但在我们的云中配置不同。</li></ul><h2 id="4a94" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">删除</h2><ul class=""><li id="0b4c" class="mv mw jb ky b kz la ld le lh op ll oq lp or lt na nb nc nd bi translated">一个资源从我们期望的状态中移除，但是仍然存在于我们的地形状态中。</li></ul><h1 id="9d2e" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">这是地球生命的循环</h1><p id="7600" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好了，现在我们已经了解了state和CRUD(看，我告诉过你它们很重要),我们可以更仔细地看看我们是如何执行Terraform的。</p><p id="827a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们在命令行上运行Terraform时，需要执行3个不同的步骤。让我们在这里浏览一下:</p><h2 id="13d8" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">初始化</h2><blockquote class="os ot ou"><p id="1396" class="kw kx ml ky b kz lu lb lc ld lv lf lg ov lw lj lk ow lx ln lo ox ly lr ls lt ij bi translated"><code class="fe nv nw nx nl b">$ terraform init</code></p></blockquote><p id="0f36" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们需要运行的第一个命令是<code class="fe nv nw nx nl b">init</code>。该命令用于初始化包含Terraform配置文件的工作目录，并指示Terraform询问HCL文件，确定所需的提供程序，下载它们，并初始化一个状态(如果该状态不存在)。多次运行<code class="fe nv nw nx nl b">init</code>是绝对安全的，事实上，如果您在<code class="fe nv nw nx nl b">Terraform</code>块中添加新的提供者或更改任何设置，您可能需要这样做。</p><p id="047a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">关于<code class="fe nv nw nx nl b">init</code>命令<a class="ae ny" href="https://www.terraform.io/docs/cli/commands/init.html" rel="noopener ugc nofollow" target="_blank">的更多详细信息，你可以查看这里的所有文档</a>。</p><h2 id="33e5" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">规划</h2><blockquote class="os ot ou"><p id="5d99" class="kw kx ml ky b kz lu lb lc ld lv lf lg ov lw lj lk ow lx ln lo ox ly lr ls lt ij bi translated"><code class="fe nv nw nx nl b">$ terraform plan</code></p></blockquote><p id="e2ea" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们运行的下一个命令是<code class="fe nv nw nx nl b">plan</code>。这个命令指示Terraform解析我们的HCL文件，构建我们的资源图，检查它的状态，并尝试提出一个要执行的执行计划。我们的<code class="fe nv nw nx nl b">init</code>成功了，但我们的<code class="fe nv nw nx nl b">plan</code>失败了，这是完全合理的。这是因为<code class="fe nv nw nx nl b">init</code>并不真正关心试图确定我们的任何资源是否有效或者它们是否存在。只有当Terraform开始解释我们的“期望状态”时，我们才会开始在我们的文件中发现语法错误。</p><p id="4e97" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe nv nw nx nl b">plan</code>命令的输出将是Terraform决定执行的操作的复杂列表。强烈建议您检查这些更改，以确保它们与您预期看到的更改相匹配，因为如果操作失误，破坏性操作的成本会很高。请将此视为所有地形的“预演”。</p><p id="edc9" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">同样值得注意的是，计划的输出可以保存到一个文件中，并用于下一步<code class="fe nv nw nx nl b">apply</code>，因为这确保了在计划的和应用的之间没有混淆/差异。</p><p id="7905" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">关于<code class="fe nv nw nx nl b">plan</code>命令的更多详细信息，可以在这里找到<a class="ae ny" href="https://www.terraform.io/docs/cli/commands/plan.html" rel="noopener ugc nofollow" target="_blank">文档。</a></p><h2 id="fece" class="lz jz jb bd ka ma mb dn ke mc md dp ki lh me mf km ll mg mh kq lp mi mj ku mk bi translated">应用</h2><blockquote class="os ot ou"><p id="6acb" class="kw kx ml ky b kz lu lb lc ld lv lf lg ov lw lj lk ow lx ln lo ox ly lr ls lt ij bi translated"><code class="fe nv nw nx nl b">$ terraform apply</code></p></blockquote><p id="280a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">简单地说，这个操作告诉Terraform执行所有计划好的操作。这通常会导致Terraform重做其计划(除非为命令提供了计划文件)，然后向您显示“您确定吗？”提示。这是你的不归路。如果你说是，那么Terraform将开始真正为你提供东西。</p><p id="fbaa" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这可能是所有命令中最简单的一个，但是它确实有一些有趣的功能，比如“自动批准”和增加或减少执行并行化的能力。</p><p id="42fb" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">与其他命令一样，<a class="ae ny" href="https://www.terraform.io/docs/cli/commands/apply.html" rel="noopener ugc nofollow" target="_blank">完整文档在此处可用</a></p><h1 id="b864" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">最后一句警告！</h1><p id="78e0" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">请记住亲爱的读者，Terraform使用我们在HCL中指定的标识符来标识状态中的资源。</p><p id="f33c" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，如果我执行了下面的HCL:</p><pre class="mn mo mp mq gt nk nl nm nn aw no bi"><span id="0edb" class="lz jz jb nl b gy np nq l nr ns">resource "azurerm_resource_group" "example" {<br/>  name     = "example-resources"<br/>  location = "West Europe"<br/>}</span></pre><p id="42bc" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">…那么这意味着在成功完成后，在我的状态文件中应该有一个标识符设置为<code class="fe nv nw nx nl b">example</code>的<code class="fe nv nw nx nl b">azurerm_resource_group</code>资源的条目</p><p id="56fd" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">人们在使用Terraform时容易陷入的一个常见陷阱是，他们会看到自己不喜欢的资源标识符，或者有时会看到错别字，并认为“哦，我会清理掉的”…但是请非常非常小心！</p><p id="79c6" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我将上面的代码改为:</p><pre class="mn mo mp mq gt nk nl nm nn aw no bi"><span id="1e90" class="lz jz jb nl b gy np nq l nr ns">resource "azurerm_resource_group" "my_resource_group" {<br/>  name     = "example-resources"<br/>  location = "West Europe"<br/>}</span></pre><p id="e896" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">请注意从<code class="fe nv nw nx nl b">example</code>到<code class="fe nv nw nx nl b">my_resource_group</code>的变化，现在我处于一个非常危险的境地。下次我的Terraform运行时，它会看到这个资源，查看它的状态，但没有找到任何条目(因为旧的条目被命名为<code class="fe nv nw nx nl b">example</code>)，这意味着它将决定创建一个新的资源组，当然这意味着删除旧的资源组！</p><p id="6b7a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这甚至更危险，因为资源组是Azure中的顶级对象，这意味着它还会导致属于该资源组的所有内容也被销毁和重新创建！！！！这对于生产环境来说绝对是灾难性的。</p><p id="33fe" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以我的建议是朋友们:</p><blockquote class="ob"><p id="a149" class="oc od jb bd oe of og oh oi oj ok lt dk translated">如果您要重命名资源标识符，请确保这种更改是非常非常必要的！</p></blockquote><p id="2903" class="pw-post-body-paragraph kw kx jb ky b kz oy lb lc ld oz lf lg lh pa lj lk ll pb ln lo lp pc lr ls lt ij bi translated">注意:有一些方法可以解决这个问题，还有导入状态的方法等等。但是这超出了初学者指南的简单本质。</p><h1 id="7f2c" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">总之(TL；博士)</strong></h1><ul class=""><li id="d45f" class="mv mw jb ky b kz la ld le lh op ll oq lp or lt na nb nc nd bi translated">Terraform是一个状态驱动的引擎，使我们能够轻松、一致地调配云基础架构。</li><li id="639d" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">Terraform利用了被称为HCL (Hashicorp配置语言)的代码</li><li id="e17a" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">HCL使用关键字<code class="fe nv nw nx nl b">resource</code>来定义我们希望在云中提供的“资源”。</li><li id="5569" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">HCL允许我们将一个资源的配置/输出用作另一个资源的配置/属性的输入。</li><li id="bdea" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">Terraform使用提供商与不同的云技术接口。</li><li id="8f9d" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">当terraform运行时，它将解析HCL文件，并构建我们想要的资源图——称为<strong class="ky jc">期望状态</strong></li><li id="641e" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">通过将资源“链接”在一起，它使Terraform能够在其图形中的对象之间建立显式的依赖关系。</li><li id="c383" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">Terraform在一个名为<strong class="ky jc">状态文件的文件中存储了它以前提供的所有资源的信息。</strong></li><li id="1956" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">状态文件的内容称为<strong class="ky jc">感知状态</strong>—terra form上次使用我们的HCL文件运行时离开环境的状态。</li><li id="bab7" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">Terraform使用后端来决定状态应该如何持久化。</li><li id="14d1" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">根据我们使用的云服务提供商以及我们希望Terraform如何保持状态，可以使用许多不同的后端。</li><li id="9918" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">当Terraform想要供应资源，并且该资源以其感知状态存在时，它将询问云提供商以确定<strong class="ky jc">实际状态。</strong></li><li id="f37f" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">如果<strong class="ky jc">期望</strong>、<strong class="ky jc">感知</strong>和<strong class="ky jc">实际</strong>状态之间存在差异，Terraform将确定所需的纠正措施，以使实际符合期望。</li><li id="3e01" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">Terraform有3个不同的生命周期阶段:<code class="fe nv nw nx nl b">init</code>、<code class="fe nv nw nx nl b">plan</code>和<code class="fe nv nw nx nl b">apply</code></li><li id="cd63" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated">如果你重命名一个资源标识符，Terraform将会把它当作一个从未见过的全新资源，并清除所有与旧标识符相关的资源。</li></ul><h1 id="f47b" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">最后的想法</h1><p id="bb4d" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正如我在这篇文章中无数次提到的，如果你没有从这篇文章中拿走任何东西。请记住:</p><blockquote class="ob"><p id="f2b1" class="oc od jb bd oe of og oh oi oj ok lt dk translated">Terraform所做的一切都围绕着国家。如果不了解Terraform如何管理和维护状态；你不明白地形是如何运作的</p></blockquote><p id="28f8" class="pw-post-body-paragraph kw kx jb ky b kz oy lb lc ld oz lf lg lh pa lj lk ll pb ln lo lp pc lr ls lt ij bi translated">所以剩下的就是感谢您的时间，我希望这篇文章能对未来的Terraform开发者有所帮助。</p><figure class="mn mo mp mq gt is gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/ac6f974aa3f60487f7246ab50436746b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*PVdgldDKOn-96NGR.gif"/></div></figure><h1 id="e31b" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">延伸阅读:</h1><ul class=""><li id="3b85" class="mv mw jb ky b kz la ld le lh op ll oq lp or lt na nb nc nd bi translated">HashiCorp的terra form—terra form平台的创建者为其编写的官方文档。</li><li id="c651" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><a class="ae ny" href="https://www.hashicorp.com/blog/products/terraform" rel="noopener ugc nofollow" target="_blank">hashi corp Blog:terra form</a>—对于想要了解平台最新变化的人来说，必须阅读/关注。</li><li id="3b5a" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><a class="ae ny" href="https://www.hashicorp.com/resources" rel="noopener ugc nofollow" target="_blank"> HashiCorp资源库</a>—terra form平台目前提供的所有资源和提供商的库。</li><li id="fe48" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><a class="ae ny" href="https://docs.microsoft.com/en-us/azure/developer/terraform/overview" rel="noopener ugc nofollow" target="_blank">使用Terraform和Azure |微软文档</a>—Azure开发者快速入门指南。</li><li id="10ab" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><a class="ae ny" href="https://www.youtube.com/watch?v=h970ZBgKINg" rel="noopener ugc nofollow" target="_blank">介绍hashi corp terra form with Armon dad gar—YouTube</a>—这是一个很好的视频，为喜欢视觉概述的人提供了上述大部分信息。</li><li id="3115" class="mv mw jb ky b kz ne ld nf lh ng ll nh lp ni lt na nb nc nd bi translated"><a class="ae ny" href="https://spacelift.io/blog/terraform-tutorial" rel="noopener ugc nofollow" target="_blank">AWS上的Terraform入门| Sumeet ni nawe</a>——space lift的peeps撰写的掌握Terraform和AWS的伟大指南(感谢<a class="ae ny" href="https://pl.linkedin.com/in/mariusz-micha%C5%82owski" rel="noopener ugc nofollow" target="_blank"> Mariusz Michalowski </a>让我意识到这篇伟大的帖子)</li></ul></div></div>    
</body>
</html>