<html>
<head>
<title>How to backup your object storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何备份您的对象存储</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-backup-your-object-storage-29bfb9fe7584?source=collection_archive---------4-----------------------#2020-01-25">https://itnext.io/how-to-backup-your-object-storage-29bfb9fe7584?source=collection_archive---------4-----------------------#2020-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/9766cc95c1d918ed3a48b4911e203313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Q8FbelbyczVdsPMmBJygUQ.png"/></div></figure><p id="65de" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">用这个简单的脚本备份你的空间。</p><h1 id="7d4b" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="53a0" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">长话短说:<a class="ae ly" href="https://github.com/GeoPablo/s3-backup" rel="noopener ugc nofollow" target="_blank">这里是脚本(js代码)</a>这里是<a class="ae ly" href="https://m.do.co/c/f0f252058644" rel="noopener ugc nofollow" target="_blank"> <strong class="jz iu"> 100$ </strong>作为引荐链接到数字海洋测试一下。</a>下载它，运行它，享受它。😀</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d475" class="kv kw it bd kx ky mg la lb lc mh le lf lg mi li lj lk mj lm ln lo mk lq lr ls bi translated">在幕后</h1><p id="3e78" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">如何编写nodejs脚本来备份您的对象存储。</p><h2 id="5d65" class="ml kw it bd kx mm mn dn lb mo mp dp lf ki mq mr lj km ms mt ln kq mu mv lr mw bi translated">项目设置</h2><ol class=""><li id="4d26" class="mx my it jz b ka lt ke lu ki mz km na kq nb ku nc nd ne nf bi translated">创建<strong class="jz iu"> package.json </strong>文件</li><li id="aa97" class="mx my it jz b ka ng ke nh ki ni km nj kq nk ku nc nd ne nf bi translated">安装依赖项</li><li id="ed19" class="mx my it jz b ka ng ke nh ki ni km nj kq nk ku nc nd ne nf bi translated">创建两个文件<strong class="jz iu"> index.js </strong>和<strong class="jz iu">。env </strong> <em class="nl">(环境变量可选)</em></li></ol><p id="a588" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi">— — — — — — — — — — — — — — — — — — — — — —</p><ol class=""><li id="f2a7" class="mx my it jz b ka kb ke kf ki nm km nn kq no ku nc nd ne nf bi translated">创建一个新文件夹，并在其中运行该命令以生成<strong class="jz iu"> package.json </strong>文件:</li></ol><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="be87" class="ml kw it nu b gy ny nz l oa ob">npm init -y</span></pre><blockquote class="oc od oe"><p id="382b" class="jx jy nl jz b ka kb kc kd ke kf kg kh of kj kk kl og kn ko kp oh kr ks kt ku im bi translated"><strong class="jz iu"> <em class="it"> -y </em> </strong> <em class="it">将创建文件而不询问任何问题</em></p></blockquote><p id="c040" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">2.我们需要安装这个依赖项:<strong class="jz iu"> <em class="nl"> aws-sdk，colors，inquirer，单行日志</em> </strong></p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="8304" class="ml kw it nu b gy ny nz l oa ob">npm i aws-sdk colors inquirer single-line-log</span></pre><p id="1e55" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">3.创建文件并放入<strong class="jz iu">中。env </strong>添加您的凭据</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="9f84" class="ml kw it nu b gy ny nz l oa ob">SPACE_ENDPOINT=<br/>SPACE_ACCESS_KEY=<br/>SPACE_SECRET_KEY=<br/>BUCKET_TO_BACKUP=</span></pre><figure class="np nq nr ns gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ad72444bde14cbf1e83e89815dc0993a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*15t1CNXojv5DGL3qFHXFHw.png"/></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">项目结构和。环境内容</figcaption></figure><h2 id="89f6" class="ml kw it bd kx mm mn dn lb mo mp dp lf ki mq mr lj km ms mt ln kq mu mv lr mw bi translated">代码📃</h2><ol class=""><li id="95a5" class="mx my it jz b ka lt ke lu ki mz km na kq nb ku nc nd ne nf bi translated">添加依赖项</li></ol><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="95ff" class="ml kw it nu b gy ny nz l oa ob">const path = require(“path”);<br/>const fs = require(“fs”);<br/>const AWS = require(“aws-sdk”);<br/>const colors = require(“colors”);<br/>const inquirer = require(“inquirer”);<br/>const log = require(“single-line-log”).stdout;<br/>require(“dotenv”).config();</span></pre><blockquote class="oc od oe"><p id="a415" class="jx jy nl jz b ka kb kc kd ke kf kg kh of kj kk kl og kn ko kp oh kr ks kt ku im bi translated"><strong class="jz iu">要求(“dotenv”)。config()；</strong>会得到我们在里面写的环境变量。环境文件</p></blockquote><p id="ba68" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">2.声明该脚本所需的所有变量</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="94b4" class="ml kw it nu b gy ny nz l oa ob">let TOTAL_BYTES_TO_DOWNLOAD = 0;<br/>let BYTES_DOWNLOADED = 0;</span><span id="dab6" class="ml kw it nu b gy on nz l oa ob">const endpoint = process.env.SPACE_ENDPOINT.trim();<br/>const accessKeyId = process.env.SPACE_ACCESS_KEY.trim();<br/>const secretAccessKey = process.env.SPACE_SECRET_KEY.trim();<br/>const BUCKET_TO_BACKUP = process.env.BUCKET_TO_BACKUP.trim();</span><span id="880c" class="ml kw it nu b gy on nz l oa ob">if (!(endpoint.length &amp;&amp;accessKeyId.length &amp;&amp; secretAccessKey.length &amp;&amp; BUCKET_TO_BACKUP.length)) {<br/>  console.log(“Paste your credentials inside .env file.”.red);<br/>  console.log(“================= Program Started =================”.bgMagenta);<br/>  return;<br/>}</span><span id="80ec" class="ml kw it nu b gy on nz l oa ob">const OUTPUT_DIR = `backup-${BUCKET_TO_BACKUP}-${Date.now()}`;<br/>const s3 = new AWS.S3({<br/>  endpoint,<br/>  accessKeyId,<br/>  secretAccessKey<br/>});</span></pre><blockquote class="oc od oe"><p id="df84" class="jx jy nl jz b ka kb kc kd ke kf kg kh of kj kk kl og kn ko kp oh kr ks kt ku im bi translated"><strong class="jz iu"> TOTAL_BYTES_TO_DOWNLOAD，BYTES_DOWNLOADED </strong> —将用于跟踪下载进度</p></blockquote><p id="bde6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来我们使用一个if语句来停止程序if<strong class="jz iu">。env </strong>文件为空，并且凭证不存在。</p><blockquote class="oc od oe"><p id="2014" class="jx jy nl jz b ka kb kc kd ke kf kg kh of kj kk kl og kn ko kp oh kr ks kt ku im bi translated"><strong class="jz iu"> OUTPUT_DIR </strong> —下载文件的文件夹名(存储桶名+时间戳)</p></blockquote><p id="17eb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后创建一个<strong class="jz iu">新的S3 </strong>实例。</p><blockquote class="oo"><p id="b3bb" class="op oq it bd or os ot ou ov ow ox ku dk translated">就我个人而言，我用大写字母来写全局变量名称，以便更好地区分它们。</p></blockquote><p id="7fc3" class="pw-post-body-paragraph jx jy it jz b ka oz kc kd ke pa kg kh ki pb kk kl km pc ko kp kq pd ks kt ku im bi translated">3.创建两个助手函数:一个将字节转换为MB或GB，另一个打印进度(单行日志)</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="6015" class="ml kw it nu b gy ny nz l oa ob">function bytesToSize(bytes) {<br/>  const sizes = [“Bytes”, “KB”, “MB”, “GB”, “TB”];<br/>  if (bytes == 0) return “0 Byte”;<br/>  var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));<br/>  return Math.round(bytes / Math.pow(1024, i), 2) + “ “ + sizes[i];<br/>}</span><span id="0a52" class="ml kw it nu b gy on nz l oa ob">function printTotalProgress(current, total) {<br/>  const percentage = (current * 100) / total;<br/>  log(`${bytesToSize(current)} / ${bytesToSize(total)}  (${Math.floor(percentage)}%)`);<br/>}</span></pre><blockquote class="oc od oe"><p id="81e6" class="jx jy nl jz b ka kb kc kd ke kf kg kh of kj kk kl og kn ko kp oh kr ks kt ku im bi translated"><strong class="jz iu"> log() </strong> —该函数来自<strong class="jz iu"> const log = require("单行日志")。stdout</strong>这将在单行上打印一条消息；</p></blockquote><p id="4a2a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">4.写一个下载文件的函数</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="7469" class="ml kw it nu b gy ny nz l oa ob">async function downloadFile(outputDir, fileKey) {<br/>  const params = {<br/>    Bucket: BUCKET_TO_BACKUP,<br/>    Key: fileKey<br/>  };<br/>  const outputPath = path.join(__dirname, outputDir, fileKey);<br/>  const fileStream = fs.createWriteStream(outputPath);</span><span id="a469" class="ml kw it nu b gy on nz l oa ob">  s3.getObject(params)<br/>    .createReadStream()<br/>    .on(“error”, function(err) {<br/>      console.log(err);<br/>      })<br/>    .on(“data”, function(chunk) {<br/>      BYTES_DOWNLOADED += chunk.length;<br/>      printTotalProgress(BYTES_DOWNLOADED, TOTAL_BYTES_TO_DOWNLOAD);<br/>    })<br/>    .pipe(fileStream);<br/>}</span></pre><p id="9b9b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该函数将根据文件密钥(文件名)从对象存储器下载一个文件，并将其写入<strong class="jz iu"> outputDir + fileKey </strong>(这意味着该文件将保持其原始名称和扩展名，并将被放在同一文件夹中)</p><blockquote class="oc od oe"><p id="0687" class="jx jy nl jz b ka kb kc kd ke kf kg kh of kj kk kl og kn ko kp oh kr ks kt ku im bi translated"><strong class="jz iu">。on('data') </strong> —从对象存储器中读取文件时，该事件将开始</p><p id="bb80" class="jx jy nl jz b ka kb kc kd ke kf kg kh of kj kk kl og kn ko kp oh kr ks kt ku im bi translated"><strong class="jz iu"> chunk </strong> — chunk.length将给出字节大小</p></blockquote><blockquote class="oo"><p id="c331" class="op oq it bd or os pe pf pg ph pi ku dk translated">file key——不仅表示文件名，还表示您的bucket中该图像的完整路径；例如，如果您的图像名称“my-img.png”放在名为“folder1”的文件夹中，则密钥将为:foder1/my-img.png </p></blockquote><p id="23e7" class="pw-post-body-paragraph jx jy it jz b ka oz kc kd ke pa kg kh ki pb kk kl km pc ko kp kq pd ks kt ku im bi translated">4.编写一个函数，在您的<strong class="jz iu"> outputDir </strong>中创建与您的bucket相同的文件夹结构</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="18d5" class="ml kw it nu b gy ny nz l oa ob">async function createFolderStructure(outputDir, Prefix = “”) {<br/>  const params = {<br/>  Bucket: BUCKET_TO_BACKUP,<br/>  Delimiter: “/”,<br/>  Prefix<br/>  };</span><span id="e974" class="ml kw it nu b gy on nz l oa ob">  const { CommonPrefixes } = await s3.listObjects(params).promise();<br/>  if (CommonPrefixes.length) {<br/>    for (let i = 0; i &lt; CommonPrefixes.length; i++) {<br/>      const { Prefix } = CommonPrefixes[i];<br/>      const dirPath = path.join(__dirname, outputDir, Prefix);<br/>      fs.mkdirSync(dirPath);<br/>      await createFolderStructure(outputDir, Prefix);<br/>    }<br/>  }<br/>}</span></pre><blockquote class="oc od oe"><p id="0c9e" class="jx jy nl jz b ka kb kc kd ke kf kg kh of kj kk kl og kn ko kp oh kr ks kt ku im bi translated"><strong class="jz iu">CommonPerfixes</strong>——你可以说这将是一个数组，其中包含你的桶中的文件夹</p></blockquote><p id="0b8e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您的bucket中有任何文件夹，这个递归函数将在您的目录中创建相同的文件夹结构。</p><p id="ce33" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是必需的，因为如果你记得我们说过用于下载文件的<strong class="jz iu"> fileKey </strong>不仅包含文件名，还包含文件的完整路径，包括文件夹。</p><p id="d1f2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">5.编写一个函数，遍历bucket中的所有文件夹，并列出所有文件的关键字。</p><p id="656a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该函数将返回如下所示的对象数组:</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="pk pl di pm bf pn"><div class="gh gi pj"><img src="../Images/bcb2d0145e8e884f9fe6f04207afb219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BE0CxfwaMLuBreypi8RVcw.png"/></div></div></figure><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="5508" class="ml kw it nu b gy ny nz l oa ob">async function getAListWithAllFiles() {<br/>  const output = [];<br/>  async function clojure(Prefix = “”) {<br/>    const params = {<br/>      Bucket: BUCKET_TO_BACKUP,<br/>      Delimiter: “/”,<br/>      Prefix<br/>    };<br/>    const { Contents, CommonPrefixes } = await<br/>    s3.listObjects(params).promise();<br/>    if (Contents.length) {<br/>      Contents.forEach(content =&gt; {<br/>        const { Size, Key } = content;<br/>        output.push({<br/>          size: Size,<br/>          key: Key<br/>        });<br/>      });<br/>    }<br/>    if (CommonPrefixes.length) {<br/>      for (let i = 0; i &lt; CommonPrefixes.length; i++) {<br/>        const { Prefix } = CommonPrefixes[i];<br/>        await clojure(Prefix);<br/>      }<br/>    }<br/>  }<br/>  await clojure();<br/>  return output;<br/>}</span></pre><blockquote class="oc od oe"><p id="189e" class="jx jy nl jz b ka kb kc kd ke kf kg kh of kj kk kl og kn ko kp oh kr ks kt ku im bi translated">内容——这是你的文件</p></blockquote><p id="d968" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">5.最后调用所有这些函数来变魔术</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="6eba" class="ml kw it nu b gy ny nz l oa ob">(async function() {<br/>  console.log(“”.white);<br/>  console.log(“================= Program Started   =================”.bgMagenta);</span><span id="57bd" class="ml kw it nu b gy on nz l oa ob">  const makeQuestion = (totalFilesLength, totalSize) =&gt; {<br/>    return [<br/>      {<br/>        type: “confirm”,<br/>        default: false,<br/>        name: “startProgram”,<br/>        message: `Are you sure you want to download        ${totalFilesLength} files (${bytesToSize(totalSize)})?`,<br/>        filter: function(val) {<br/>          return val.toLowerCase().trim();<br/>        }<br/>      }<br/>    ];<br/>  };</span><span id="2f03" class="ml kw it nu b gy on nz l oa ob">  const allFiles = await getAListWithAllFiles();<br/>  const totalSizeOfFilesToDownload = allFiles.map(file =&gt;    file.size).reduce((prev, curr) =&gt; prev + curr, 0);</span><span id="68ac" class="ml kw it nu b gy on nz l oa ob">  TOTAL_BYTES_TO_DOWNLOAD = totalSizeOfFilesToDownload;</span><span id="58e3" class="ml kw it nu b gy on nz l oa ob">  const { startProgram } = await inquirer.prompt(<br/>    makeQuestion(allFiles.length, totalSizeOfFilesToDownload)<br/>  );</span><span id="9783" class="ml kw it nu b gy on nz l oa ob">  if (!startProgram) {<br/>    console.log(“================= Program Stopped=================”.bgRed);<br/>    return;<br/>  }</span><span id="b350" class="ml kw it nu b gy on nz l oa ob">  fs.mkdirSync(OUTPUT_DIR);<br/>  await createFolderStructure(OUTPUT_DIR);</span><span id="88d3" class="ml kw it nu b gy on nz l oa ob">  allFiles.forEach(file =&gt; {<br/>    downloadFile(OUTPUT_DIR, file.key);<br/>  });<br/>})();</span></pre><blockquote class="oc od oe"><p id="91a4" class="jx jy nl jz b ka kb kc kd ke kf kg kh of kj kk kl og kn ko kp oh kr ks kt ku im bi translated">makeQuestion() —该函数将创建一个问题，我们将使用<strong class="jz iu">查询者</strong>模块提示该问题</p></blockquote><p id="a78e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个<strong class="jz iu">life</strong>将首先从我们的对象存储中创建一个包含所有文件的列表，并以字节为单位计算总大小。</p><p id="dc9a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用<strong class="jz iu">询问器</strong>我们将询问用户是否真的想要下载所有文件，我们将显示文件的总数和它们所需的磁盘大小</p><figure class="np nq nr ns gt ju gh gi paragraph-image"><div class="gh gi po"><img src="../Images/d30910135f4d51077eacb55203094939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*TSCnYoWnI-TQQROI8RRLYg.png"/></div></figure><p id="5669" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果用户按下<strong class="jz iu"> y </strong>，那么我们将创建输出目录(放置下载文件的文件夹)，之后我们将在其中创建与我们在bucket中相同的文件夹结构，最后我们将下载每个文件。</p><h1 id="278b" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">结论</strong></h1><p id="61d4" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">完整的代码可以在github 上找到。在那里你会看到这段代码和另一个版本，它允许你跟踪下载的文件，这样每次你做一个新的备份时，你可以只下载新添加的文件。</p><p id="78f6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你想测试这个代码或任何其他云功能，这里有一个<a class="ae ly" href="https://m.do.co/c/f0f252058644" rel="noopener ugc nofollow" target="_blank">到数字海洋</a>的链接，100美元可以玩。</p></div></div>    
</body>
</html>