<html>
<head>
<title>How to use APIs with Pandas and store the results in Redshift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对Pandas使用API并将结果存储在Redshift中</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-call-rest-apis-with-pandas-and-store-the-results-in-redshift-2b35f40aa98f?source=collection_archive---------0-----------------------#2018-05-26">https://itnext.io/how-to-call-rest-apis-with-pandas-and-store-the-results-in-redshift-2b35f40aa98f?source=collection_archive---------0-----------------------#2018-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="bc3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个简单的教程来帮助理解如何使用Pandas从RESTFUL API获取数据，并存储到AWS Redshift的数据库中。</p><p id="7e12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对Python(包括Requests、Pandas和JSON库)、REST APIs、Jupyter Notebook、AWS S3和Redshift有一些基本的了解会很有用。</p><p id="79e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本教程的目标是使用CSV文件中提供的地理坐标(经度和纬度)来调用外部API，并对坐标进行反向地理编码(即获取位置详细信息)，最后将响应数据存储在红移表中。<strong class="js iu">请注意，您可能需要API数据供应商的缓存批准。</strong></p><p id="2dad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用Pandas加载CSV，使用请求库调用API，将响应存储到Pandas系列，然后存储到CSV，上传到S3存储桶，并将最终数据复制到红移表中。上面提到的步骤绝不是实现这一点的唯一方法，可以通过许多不同的方式来执行该任务。</p><p id="64f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用的数据集包含世界银行2013年测量的国家人口，可在以下网站上找到。</p><p id="f0c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们开始吧。</p><h1 id="62e1" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤1-下载数据集</h1><h2 id="1010" class="lm kp it bd kq ln lo dn ku lp lq dp ky kb lr ls lc kf lt lu lg kj lv lw lk lx bi translated">指向列说明和数据集的链接</h2><p id="5de6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><a class="ae md" href="https://developer.here.com/documentation/geovisualization/topics/sample-datasets.html" rel="noopener ugc nofollow" target="_blank">https://developer . here . com/documentation/geo visualization/topics/sample-datasets . html</a></p><p id="2f29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae md" href="http://js.cit.datalens.api.here.com/datasets/starter_pack/Global_country_populations_2013.csv" rel="noopener ugc nofollow" target="_blank">http://js . cit . data lens . API . here . com/datasets/starter _ pack/Global _ country _ populations _ 2013 . CSV</a></p><p id="8d97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一件事就是从上面的网站下载CSV文件。</p><h1 id="f634" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤2 —启动Jupyter Notebook，并使用Python将数据集加载到内存中</h1><p id="d271" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">安装Jupyter Notebook(带有Anaconda或其他版本),并在您希望保存笔记本的目录中，通过在终端中键入以下命令来启动它。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/d98f1308c45d5c8b6603757621f6c3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Rlkdm4hil51MZ7jWUuyCg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">推出Jupyter笔记本</figcaption></figure><p id="786e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您已经安装了所需的库，让我们将CSV文件加载到内存中。</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="6df7" class="lm kp it mv b gy mz na l nb nc">import pandas as pd<br/>import requests<br/>import json<br/>import time<br/>from pandas.io.json import json_normalize<br/> <br/>df = pd.read_csv('Global_country_populations_2013.csv') <br/>df = df[['CountryName','lat','lon']]<br/>df.head()</span></pre><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nd"><img src="../Images/84e3a9a2807a0e1828c961c3da434e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vqJjKkJAGhWZ45GiUvySUw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">将数据加载到Pandas数据框架中</figcaption></figure><p id="aeaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还导入了其他库，因为我们以后会需要它们。“read_csv()”方法会将您的csv文件读入Pandas数据帧。请注意，如果文件不在同一个目录中，您需要在这里指定文件的路径。然后我们截断数据帧，只保留我们主要需要的列["CountryName "，" lat "，" lon"]。</p><h1 id="ec52" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤3 —定义调用API的函数</h1><p id="23d2" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们将用于反向地理编码的API是LocationIQ(来自Unwired Labs ),它提供免费的非商业使用，速率为每分钟60次调用和每天10，000次调用。</p><div class="ne nf gp gr ng nh"><a href="https://locationiq.org/" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">来自无线实验室的LocationIQ免费快速地理编码和反向地理编码服务</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">从纽约到东京，通过OpenStreetMap、Open Addresses和其他来源的数据获得全球覆盖。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">locationiq.org</p></div></div></div></a></div><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="4b56" class="lm kp it mv b gy mz na l nb nc">def get_reverse_geocode_data(row):<br/>    try:<br/>        YOUR_API_KEY = 'xxxxxxxxxxx'<br/>        url = '<a class="ae md" href="https://eu1.locationiq.org/v1/reverse.php?key='" rel="noopener ugc nofollow" target="_blank">https://eu1.locationiq.org/v1/reverse.php?key='</a> + YOUR_API_KEY + '&amp;lat=' + str(row['lat']) + '&amp;lon=' + str(row['lon']) + '&amp;format=json'<br/>        <br/>        response = (requests.get(url).text)<br/>        response_json = json.loads(response)<br/>        time.sleep(0.5)<br/>        return response_json<br/>    <br/>    except Exception as e:<br/>        raise e</span></pre><p id="6eae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，我们定义了一个函数— get_reverse_geocode_data(row)。注册后，您将获得一个API密钥，您需要将它与端点或URL以及可以从文档中获得的必需参数一起包含在这里。参数“row”指的是Pandas数据帧的列“lat”和“lon”的每一行，它们将作为输入传递给API。请求库用于向url发出HTTPS GET请求，并使用。“文本”方法。</p><p id="9449" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用' json.loads()'将响应从json字符串转换为易于使用的JSON对象。由于自由层计划设置的限制(每分钟60次调用)，使用“time.sleep(0.5)”参数来控制对API的调用。对于商业大批量计划，这是没有必要的。</p><h1 id="1c75" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤4 —使用数据帧列作为参数调用函数</h1><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="d4f2" class="lm kp it mv b gy mz na l nb nc">df['API_response'] = df.apply(get_reverse_geocode_data,axis=1)<br/>df['API_response'].head()</span></pre><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nq"><img src="../Images/6c9f6c6589abb4a619301c8b307991a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zk_yZlmGH1s4pVVG6rI2ZA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">以DataFrame列作为输入调用函数</figcaption></figure><p id="f2ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用“df.apply()”方法将函数应用于整个数据帧。“轴=1”参数用于跨列应用函数。我们之前使用的“row”参数使我们能够引用我们希望用作输入的数据帧的任何列，并将该行的列值作为该特定执行的输入。</p><h1 id="cbad" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤5——规格化或扁平化JSON响应</h1><p id="b04a" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">现在，您已经成功地从API接收到JSON响应，是时候将它展平成列并挑选出您希望保留的字段了。</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="ba4c" class="lm kp it mv b gy mz na l nb nc">new_df = json_normalize(df['API_response'])<br/>new_df = new_df[['lat','lon','display_name']]<br/>new_df</span></pre><p id="9bd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“json_normalize()”函数非常适合这种情况。您可以将希望规范化的Pandas系列作为参数传入，它将返回一个新的Pandas DataFrame，其中的列是扁平的。然后，您可以使用外键将这个新的数据帧连接到旧的数据帧，或者在这种情况下，我们将只使用新的数据帧。让我们只保留“显示名称”字段(来自API_response)以及“纬度”和“经度”。下面是新的数据框架</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nr"><img src="../Images/272386c5c676a668baec3d51a6a112b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TivJ4WxucRupgMUOeO9HMw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">规范化JSON以获得新的数据帧</figcaption></figure><p id="c5ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们也为每一行添加一个唯一的标识符</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="e832" class="lm kp it mv b gy mz na l nb nc">import uuid<br/>new_df['id'] = pd.Series([uuid.uuid1() for i in range(len(new_df))])<br/>new_df</span></pre><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ns"><img src="../Images/b95a01d7c0db9ade8a48adfb86d7a583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckA1BMurM47OfC7qhGK3Fw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">添加唯一标识符</figcaption></figure><h1 id="a114" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">第6步—生成CSV文件并上传至S3存储桶</h1><p id="b20c" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">下面的代码从Pandas DataFrame到指定的目录中创建一个CSV文件。</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="ba9e" class="lm kp it mv b gy mz na l nb nc">new_df.to_csv(path_or_buf=file_name,index=False)</span></pre><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nt"><img src="../Images/3761d257af1503c707192f82076da1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4AMxjuhLf5pQdYmKZ9t5FQ.png"/></div></div></figure><p id="3a5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Pandas的“to_csv”方法会自动创建一个索引列，因此我们可以通过设置“index=False”来避免这种情况。CSV现在已创建，我们可以将其上传到S3。</p><p id="8975" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本教程中，我们将使用tinys 3&lt;<a class="ae md" href="https://github.com/smore-inc/tinys3" rel="noopener ugc nofollow" target="_blank">https://github.com/smore-inc/tinys3</a>&gt;这是一个非常容易使用的库与S3。如果您愿意，也可以使用Boto3。</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="c8e7" class="lm kp it mv b gy mz na l nb nc">import tinys3<br/>import os<br/>access_key = 'xxxxxxxxx'<br/>secret_key = 'xxxxxxxxx'<br/>endpoint = 'xxxxxxxx'<br/>Bucket_name = 'xxxxxxxx'</span><span id="7dc1" class="lm kp it mv b gy nu na l nb nc">conn = tinys3.Connection(access_key, secret_key, tls=False, endpoint)</span><span id="3f6c" class="lm kp it mv b gy nu na l nb nc">f = open(file_name,'rb')</span><span id="c3d1" class="lm kp it mv b gy nu na l nb nc">conn.upload(file_name, f, Bucket_name)</span><span id="b173" class="lm kp it mv b gy nu na l nb nc">f.close()<br/>os.remove(file_name)</span></pre><p id="85c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">文档非常简单明了，基本上是说添加您的AWS访问密钥、秘密访问密钥和存储桶名称。然后，您可以创建一个到S3的连接，并上传相关文件。然后，我们使用“os.remove(file_name)”从驱动器中删除该文件。</p><h1 id="deed" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤7-创建红移表并将数据复制到其中</h1><p id="0f9b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在将数据复制到红移表之前，您需要创建一个红移表。这可以通过使用Psycopg2执行PostgreSQL数据库的标准SQL命令来完成，psycopg 2是Python的PostgreSQL库。</p><h2 id="c3aa" class="lm kp it bd kq ln lo dn ku lp lq dp ky kb lr ls lc kf lt lu lg kj lv lw lk lx bi translated">创建表格</h2><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="263b" class="lm kp it mv b gy mz na l nb nc">import psycopg2    </span><span id="2127" class="lm kp it mv b gy nu na l nb nc">my_db = 'xxxxxxx'<br/>my_host = 'xxxxxxx'<br/>my_port = 'xxxx'<br/>my_user = 'xxxxxxxx'<br/>my_password = 'xxxxxxx'</span><span id="1833" class="lm kp it mv b gy nu na l nb nc">con = psycopg2.connect(dbname=my_db,host=my_host,port=my_port,user=my_user,password=my_password) </span><span id="fee8" class="lm kp it mv b gy nu na l nb nc">cur = con.cursor()  </span><span id="2a98" class="lm kp it mv b gy nu na l nb nc">sql_query = "CREATE TABLE reverse_geocode_location (lat varchar(255),lon varchar(255),display_name varchar(255),id varchar(255),PRIMARY KEY (id));"</span><span id="4d2c" class="lm kp it mv b gy nu na l nb nc">cur.execute(sql_query)<br/>con.commit()</span><span id="c708" class="lm kp it mv b gy nu na l nb nc">cur.close()<br/>con.close()</span></pre><p id="3c78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Psycopg2，可以很容易地通过Python在Redshift或任何其他PostgreSQL引擎数据库中执行SQL命令。我们首先需要创建一个连接，然后创建一个游标，最后执行我们的SQL查询。不要忘记在SQL查询成功执行后关闭到数据库的连接。</p><h2 id="1db6" class="lm kp it bd kq ln lo dn ku lp lq dp ky kb lr ls lc kf lt lu lg kj lv lw lk lx bi translated">将数据从S3复制到红移</h2><p id="be12" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们现在准备好了教程的最后一步——将CSV文件从S3复制到红移。我们之所以使用COPY而不是SQL Alchemy或其他SQL客户端，是因为Redshift针对列存储进行了优化，并且这种方法可以非常快速地将数据加载到其中，而不是逐行加载数据。为此，我们可以再次使用Psycopg2。</p><p id="91cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">请注意，CSV文件和红移表之间的列数据类型必须相同，并且顺序相同，否则复制命令将会失败。您可以通过读取STL_LOAD_ERRORS表来检查任何加载错误。</strong></p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="8535" class="lm kp it mv b gy mz na l nb nc">import psycopg2</span><span id="7b5a" class="lm kp it mv b gy nu na l nb nc">my_db = 'xxxxxxx'<br/>my_host = 'xxxxxxx'<br/>my_port = 'xxxx'<br/>my_user = 'xxxxxxxx'<br/>my_password = 'xxxxxxx'</span><span id="1e84" class="lm kp it mv b gy nu na l nb nc">con = psycopg2.connect(dbname=my_db,host=my_host,port=my_port,user=my_user,password=my_password)</span><span id="66a2" class="lm kp it mv b gy nu na l nb nc">cur = con.cursor()</span><span id="89e2" class="lm kp it mv b gy nu na l nb nc">sql_query = ""copy reverse_geocode_location from 's3://YOUR_BUCKET_NAME/YOUR_FILE_NAME' credentials 'aws_access_key_id=YOUR_ACCESS_KEY;aws_secret_access_key=YOUR_SECRET_ACCESS_KEY' csv IGNOREHEADER 1 NULL 'NaN' ACCEPTINVCHARS;""</span><span id="d376" class="lm kp it mv b gy nu na l nb nc">cur.execute(sql_query)<br/>con.commit()</span><span id="4e6b" class="lm kp it mv b gy nu na l nb nc">cur.close()<br/>con.close()</span></pre><p id="eaa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的COPY命令中，我们需要指定bucket名称、文件名、安全密钥和一些标志。可以在此处找到对所用标志的解释:</p><div class="ne nf gp gr ng nh"><a href="https://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">复制-亚马逊红移</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">将数据从数据文件或Amazon DynamoDB表加载到表中。这些文件可以在亚马逊简单的…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">docs.aws.amazon.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa mo nh"/></div></div></a></div><p id="acc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">请注意:您需要授予正确的IAM角色权限，以便将数据从S3复制到Redshift。</strong></p><h1 id="f6ae" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤8-从表中读取数据进行验证</h1><p id="8cef" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">一旦你成功地完成了上述步骤，你现在应该已经把数据复制到你的红移表中了。您可以通过在Python或任何其他SQL客户机中使用Psycopg2读取数据来验证它。</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="9477" class="lm kp it mv b gy mz na l nb nc">select * from reverse_geocode_location</span></pre><h1 id="2fb7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论和下一步措施</h1><p id="8198" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">本教程涵盖了关于使用Pandas系列作为输入来调用REST API并将结果存储在AWS红移中的一些基础知识。但是，如果数据规模相当大，重要的是:</p><ol class=""><li id="7241" class="ob oc it js b jt ju jx jy kb od kf oe kj of kn og oh oi oj bi translated">订阅高性能、高容量处理API。</li><li id="edc9" class="ob oc it js b jt ok jx ol kb om kf on kj oo kn og oh oi oj bi translated">通过重复写入磁盘来减少内存处理，或者使用Dask等库来执行并行处理。</li><li id="609a" class="ob oc it js b jt ok jx ol kb om kf on kj oo kn og oh oi oj bi translated">使用Apache Spark或其他类似的技术来处理非常大的数据处理。</li><li id="a78e" class="ob oc it js b jt ok jx ol kb om kf on kj oo kn og oh oi oj bi translated">根据性能要求正确选择数据库技术。</li></ol><p id="e1e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这篇教程对你有所帮助，如果你有任何问题，请通过评论联系我们。</p></div></div>    
</body>
</html>