<html>
<head>
<title>Adding Vue components to old school web apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Vue组件添加到旧的学校web应用程序中</h1>
<blockquote>原文：<a href="https://itnext.io/adding-vue-components-to-old-school-web-apps-1f6c2339d599?source=collection_archive---------4-----------------------#2019-09-06">https://itnext.io/adding-vue-components-to-old-school-web-apps-1f6c2339d599?source=collection_archive---------4-----------------------#2019-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1cc58d98451a96ba51a28541c5cbc9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwg5784e8SkdQYWc3NQyNg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:<a class="ae kc" href="https://techspirited.com/things-that-will-become-obsolete-in-next-10years" rel="noopener ugc nofollow" target="_blank">科技精神</a></figcaption></figure><p id="f92a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue对于单页面应用程序来说是一个极好的工具，但是试图将它集成到用PHP或Python编写的现有CMS中可能是一项令人生畏的任务(除非您正在使用Laravel)。当你面对捆绑器、入口点、块、资产、公共路径和资源根时，尤其是在一个插件/插件驱动的架构(a-la Wordpress)中，这一切很快变得非常痛苦。</p><p id="5986" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有人想再处理jQuery了，尤其是在基于数据突变重新呈现组件的时候。乍一看，Vue似乎是从jQuery迭代迁移到现代前端堆栈的一个可行的候选对象(比React或Angular更合适)。然而，当你开始这段旅程时，你会遇到许多问题和难以做出的决定。由于内联脚本和属性绑定，将整个页面作为Vue组件挂载通常是不可能的，并且会导致各种兼容性问题和冲突。试图基于element #id挂载多个Vue实例会导致大量重复的JS调用，并导致混乱的构建过程。如果项目使用RequireJS，那么构建多个库目标还会有其他问题。棘手的问题不胜枚举。</p><p id="89f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们可以构建一个单一的入口点作为调度程序，加载必要的Vue组件，并将占位符转换为Vue的挂载实例，会怎么样？</p><p id="7d15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近参加了在Brandung 举行的Vue会议，会上我们看到了一个有趣的方法，他们在TYPO3模板中加入了交互式Vue组件。我对这种方法很感兴趣，因为它似乎是我已经努力了一段时间的东西，我开始对它进行修补，看看我能想出什么。</p><p id="36a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想在页面上出现的所有卡片上添加一个like按钮，那么我们应该在卡片的Twig模板上添加这样的东西。如果您使用不同的模板语言或纯HTML，请确保将JSON数据正确编码到元素属性中。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="74e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们创建我们的<code class="fe lh li lj lk b">LikeButton</code> Vue组件。这只是一个例子，所以有点傻——我想说的是，当存在可变的内部组件状态时，为什么你不想使用jQuery。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="bb1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在要做的是在DOM中查询所有具有<code class="fe lh li lj lk b">data-vue</code>属性的元素，加载在<code class="fe lh li lj lk b">data-component</code>中引用的组件，准备道具，并用挂载的Vue实例替换我们的占位符元素。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="143c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您正在处理位于不同目录中的大量组件，您可以使用我编写的一个<a class="ae kc" href="https://www.npmjs.com/package/@hypejunction/vue-scanner" rel="noopener ugc nofollow" target="_blank"> cli脚本</a>将所有组件解析到一个JSON对象中，并从中读取组件路径。</p><p id="34e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要设置我们的构建过程。我喜欢使用<code class="fe lh li lj lk b"><a class="ae kc" href="https://laravel-mix.com/" rel="noopener ugc nofollow" target="_blank">laravel-mix</a></code>，但是也欢迎你建立自己的构建过程。这里有一个<code class="fe lh li lj lk b">package.json</code>和<code class="fe lh li lj lk b">webpack.mix.js</code>的样本。我的项目叫<code class="fe lh li lj lk b">api_launcher</code>。我用我的项目名命名我的块，并使用<code class="fe lh li lj lk b">requestChunks</code>标志将每个单独的组件提取到它自己的块中，这有助于我保持运行时非常轻量级，只在需要安装组件和依赖项时加载它们。当在挂载期间导入组件时，webpack使用已经通过<code class="fe lh li lj lk b">vue-scanner</code>定义并导入到我的索引中的正确块(在上面的例子中没有显示)。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="5ab8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这是您将在许多页面上使用的内容，请将编译好的<code class="fe lh li lj lk b">index.js</code>加载到您的全局模板的文档<code class="fe lh li lj lk b">&lt;head&gt;</code>中。在我的例子中，只要我有一个占位符<code class="fe lh li lj lk b">data-vue</code> div，我就加载RequireJS模块。</p><p id="d923" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你现在要做的就是跑<code class="fe lh li lj lk b">npm run dev</code>或者<code class="fe lh li lj lk b">npm run prod</code>，你就万事俱备了。</p><p id="3f3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用过时的技术不一定会很痛苦:)</p><p id="08cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="ll">更新Sep 8:我在PHP </em> </strong>  <strong class="kf ir"> <em class="ll">中拼凑了一个</em> </strong> <a class="ae kc" href="https://github.com/hypeJunction/vue-oldschool" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="ll">完全工作的例子。您会注意到，我对最初的方法做了一些更改——我意识到安装一个包装器组件会更容易，它将呈现一个动态组件</em> </strong> <code class="fe lh li lj lk b"><strong class="kf ir"><em class="ll">&lt;component :is=""&gt;</em></strong></code> <strong class="kf ir"> <em class="ll">，由Vue从其异步注册中解析，从而允许我们跳过需要查找和导入引用组件的部分。</em> </strong></a></p><div class="lm ln gp gr lo lp"><a href="https://github.com/hypeJunction/vue-oldschool" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd ir gy z fp lu fr fs lv fu fw ip bi translated">hypeJunction/vue-oldschool</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">在PHP应用程序中使用vue的演示。在GitHub上创建一个帐户，为hypeJunction/vue-oldschool的发展做出贡献。</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>