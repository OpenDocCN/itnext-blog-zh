<html>
<head>
<title>A beginners guide to Ramda (Part 1) — Currying and composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ramda初学者指南(第一部分)——涂抹和构图</h1>
<blockquote>原文：<a href="https://itnext.io/a-beginners-guide-to-ramda-part-1-7e4a34972e97?source=collection_archive---------3-----------------------#2018-07-10">https://itnext.io/a-beginners-guide-to-ramda-part-1-7e4a34972e97?source=collection_archive---------3-----------------------#2018-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b77d0f877ea7c795fd4f62d45fc44f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cBXCliHk1hLC7YCU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@kazdenc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kazden Cattapan </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a6e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Ramda对我来说是一个看起来很酷的库，但是它的大小让我再三考虑把它添加到我们的前端。自从我最近转向后端开发(node.js)后，我开始使用Ramda，并慢慢意识到它的强大。这份指南基本上是我在过去几个月里学到的，另外还附带了一些例子。</p><h1 id="ce33" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自动currying</h1><p id="65b5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Ramda中的所有函数都是自动生成的。这意味着您可以用比它需要的更少的参数调用该函数，并且它将返回一个部分应用的函数。函数将不断返回用它们的最终参数调用过的函数，此时它们将计算结果。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9f6d" class="mn lc iq mj b gy mo mp l mq mr">R.add(1, 2)<br/>&gt; 3</span><span id="be20" class="mn lc iq mj b gy ms mp l mq mr">R.add(1)(2) <br/>&gt; 3</span><span id="4d52" class="mn lc iq mj b gy ms mp l mq mr">const increment = R.add(1)<br/>&gt; fn</span><span id="847d" class="mn lc iq mj b gy ms mp l mq mr">increment(2)<br/>&gt; 3</span></pre><p id="d394" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个名为<code class="fe mt mu mv mj b">R.curry</code>的功能，它可以让你将任何正常的功能变成自动定制的功能。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e176" class="mn lc iq mj b gy mo mp l mq mr">const add = (a, b) =&gt; a + b</span><span id="b0d0" class="mn lc iq mj b gy ms mp l mq mr">add(1, 2)<br/>&gt; 3</span><span id="2caa" class="mn lc iq mj b gy ms mp l mq mr">add(1)(2)<br/>&gt; Uncaught TypeError: add(...) is not a function</span><span id="2a4f" class="mn lc iq mj b gy ms mp l mq mr">const curriedAdd = R.curry(add)</span><span id="ceb3" class="mn lc iq mj b gy ms mp l mq mr">curriedAdd(1, 2)<br/>&gt; 3</span><span id="b38b" class="mn lc iq mj b gy ms mp l mq mr">curriedAdd(1)(2)<br/>&gt; 3</span></pre><h2 id="b170" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">为什么奉承很重要？</h2><p id="c781" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Currying允许我们做两件在函数式编程中很重要的事情。即专业化和复合化。</p><p id="d0e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">专门化</strong>来源于部分应用定制功能的能力。我们可以将这些部分应用的函数存储为变量，以便以后再次使用。在下面的例子中，我们可以重用<code class="fe mt mu mv mj b">addTitle</code>函数的部分应用版本。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c3f0" class="mn lc iq mj b gy mo mp l mq mr">const bev = {name: 'Bev', gender: 'female'}<br/>const rich = {name: 'Rich', gender: 'male'}</span><span id="bbca" class="mn lc iq mj b gy ms mp l mq mr">const addTitle = (title, name) =&gt; `${title}. ${name}`<br/>const curriedAddTitle = R.curry(addTitle)<br/>const addMs = curriedAddTitle('Ms')<br/>const addMr = curriedAddTitle('Mr')</span><span id="f9b6" class="mn lc iq mj b gy ms mp l mq mr">addMs(bev.name)<br/>&gt; 'Ms. Bev'</span><span id="f514" class="mn lc iq mj b gy ms mp l mq mr">addMr(rich.name)<br/>&gt; 'Mr. Rich'</span></pre><p id="0ce9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以继续为<code class="fe mt mu mv mj b">addMrs</code>、<code class="fe mt mu mv mj b">addMiss</code>、<code class="fe mt mu mv mj b">addDr</code>等等创建函数。通过这样做，我们可以创建一个定义良好的接口，而不是每次都用两个参数调用<code class="fe mt mu mv mj b">addTitle</code>。</p><p id="aa76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于currying的另一件令人敬畏的事情是它允许我们更容易地将<strong class="kf ir">功能组合在一起。在下一节中，我们将了解如何做到这一点。</strong></p><h1 id="c1e8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">功能组成</h1><p id="2ee7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">什么是函数构成？根据维基百科:</p><blockquote class="nh ni nj"><p id="1c62" class="kd ke nk kf b kg kh ki kj kk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">在数学中，函数合成是将一个函数逐点应用于另一个函数的结果以产生第三个函数</p></blockquote><p id="5721" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在编程中，我们可以将其概括为将任意数量的函数组合在一起，产生一个新函数。这里有一个简单的例子:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f39d" class="mn lc iq mj b gy mo mp l mq mr">const increment = (x) =&gt; x + 1<br/>const double = (x) =&gt; x * 2</span><span id="06e4" class="mn lc iq mj b gy ms mp l mq mr">const doublePlusOne = (x) =&gt; increment(double(x))<br/>doublePlusOne(10)<br/>&gt; 21</span></pre><p id="1414" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们创建了一个新函数，它返回调用传递给它的值的结果。我们将这些功能组合在一起。这看起来很好，但是当我们想要将两个以上的函数组合在一起时会发生什么呢？</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2a67" class="mn lc iq mj b gy mo mp l mq mr">const square = (x) =&gt; x * x<br/>const halve = (x) =&gt; x / 2</span><span id="73e3" class="mn lc iq mj b gy ms mp l mq mr">const calculateThings = (x) =&gt; halve(square(increment(double(x))))<br/>calculateThings(10)<br/>&gt; 220.5</span></pre><p id="47a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在它开始显得笨重。不仅括号堆积在一边，而且我们需要从右向左读取函数调用。</p><h2 id="ae8c" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">管道救援</h2><p id="8580" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Ramda给了我们一个很棒的函数叫做<code class="fe mt mu mv mj b">pipe</code>。它将任意数量的函数作为其参数，并返回一个函数，该函数依次调用这些函数以产生结果。让我们使用管道函数重写<code class="fe mt mu mv mj b">calculateThings</code>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a239" class="mn lc iq mj b gy mo mp l mq mr">const calculateThings = R.pipe(double, increment, square, halve)</span><span id="cc41" class="mn lc iq mj b gy ms mp l mq mr">calculateThings(10) // still 220.5</span></pre><p id="c178" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">pipe</code>去掉了所有的括号，也让我们以更易于阅读的从左到右的顺序来指定我们的函数。</p><p id="0f81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了第一个函数，所有传递给<code class="fe mt mu mv mj b">pipe</code>的函数都必须是<a class="ae kc" href="https://en.wikipedia.org/wiki/Unary_function" rel="noopener ugc nofollow" target="_blank">一元函数</a>。因为每个函数被调用时前面都有函数的结果，所以每个函数只接收一个参数。</p><p id="96f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外值得一提的是，还有一个类似于<code class="fe mt mu mv mj b">pipe</code>的函数叫做<code class="fe mt mu mv mj b">compose</code>，只不过它会以相反的顺序调用这些函数。你喜欢哪个由你决定，但是<code class="fe mt mu mv mj b">pipe</code>对我来说更直观。</p><p id="307c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得我们讨论过currying如何使组合功能变得更容易吗？因为Ramdas的函数是自动执行的，所以我们可以将部分应用的调用传递到管道中。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="51ae" class="mn lc iq mj b gy mo mp l mq mr">// With partially applied functions<br/>const mathPipe = R.pipe(<br/>  R.multiply(4),<br/>  R.add(2),<br/>  R.divide(2)<br/>)</span><span id="920d" class="mn lc iq mj b gy ms mp l mq mr">mathPipe(10)<br/>&gt; 21</span></pre><p id="fefa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Ramdas的数学函数<code class="fe mt mu mv mj b">add</code>、<code class="fe mt mu mv mj b">multiply</code>和<code class="fe mt mu mv mj b">divide</code>都有两个参数，但是我们只传入第一个参数，第二个值将通过管道传入。</p><p id="ad1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部分应用的函数也可以用在任何需要一元函数的地方。例如，我们可以将部分应用的函数作为参数传递给Ramdas的<code class="fe mt mu mv mj b">map</code>函数。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="820d" class="mn lc iq mj b gy mo mp l mq mr">const people = ['James', 'Hadley', 'Terry', 'Trev', 'Szab']<br/>const addTitle = R.curry((title, name) =&gt; `${title}. ${name}`)</span><span id="2390" class="mn lc iq mj b gy ms mp l mq mr">R.map(addTitle('Mr'), people);<br/>&gt; ['Mr. James', 'Mr. Hadley', 'Mr. Terry', 'Mr. Trev', 'Mr. Szab']</span><span id="cb65" class="mn lc iq mj b gy ms mp l mq mr">R.map(addTitle('Dr'), people);<br/>&gt; ['Dr.  James', 'Dr.  Hadley', 'Dr. Terry', 'Dr. Trev', 'Dr. Szab']</span></pre><h1 id="ac31" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">总结</h1><p id="44bc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">希望你已经从这篇文章中得到了一些有用的东西，并且像我喜欢写这篇文章一样喜欢阅读它。本系列的第二部分将是关于Ramda的镜头功能。请继续关注，它很快就会出现。</p></div></div>    
</body>
</html>