<html>
<head>
<title>Git Bisect — How to track down a broken commit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git二等分——如何跟踪一个中断的提交</h1>
<blockquote>原文：<a href="https://itnext.io/git-bisect-how-to-track-down-a-broken-commit-4fc82ae98ed6?source=collection_archive---------4-----------------------#2020-05-04">https://itnext.io/git-bisect-how-to-track-down-a-broken-commit-4fc82ae98ed6?source=collection_archive---------4-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/866aff31ba903788f2f8ab9dfc58915e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggq1z83zDQZuRYbzsqFUUw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>在<a class="ae kf" href="https://unsplash.com/s/photos/roads?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="8583" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">时不时——时有发生:<em class="le">有人</em>折断了主枝。根据项目规模的不同，回归测试可能会非常困难和令人疲惫。在几个合并的提交之后，人们注意到最后50个提交中的一个确实引入了回归，并且上游主分支被破坏。</p><p id="a7d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你手动地<em class="le">发现这个引入回归的提交，例如一个接一个地测试提交，这是困难和令人疲惫的。如果你在一个已知的工作配置和不工作的配置之间有五次提交，这可能是你可以做的。您只需一个接一个地检查提交，检查错误是否已经存在。但是如果有，你能做什么呢..在工作和非工作提交之间是50、100还是500次提交？</em></p><blockquote class="lf"><p id="a154" class="lg lh it bd li lj lk ll lm ln lo ld dk translated">git平分救援！</p></blockquote><p id="ab30" class="pw-post-body-paragraph kg kh it ki b kj lp kl km kn lq kp kq kr lr kt ku kv ls kx ky kz lt lb lc ld im bi translated"><strong class="ki iu"> Git </strong></p><p id="7c45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想现在每个开发人员都应该知道git了。如果没有:我写了两篇关于git的文章，您可能想先看看:</p><div class="lu lv gp gr lw lx"><a rel="noopener  ugc nofollow" target="_blank" href="/become-a-git-terminal-pro-ab6d1955606f"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">成为Git终端Pro</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">一些有用的提示，可以提高您在命令行中使用git的效率。</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">itnext.io</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml jz lx"/></div></div></a></div><p id="50a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和</p><div class="lu lv gp gr lw lx"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-undo-a-commit-in-git-2c7d49deabe0"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">如何在git中撤销提交</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">许多开发人员在git中努力撤销提交。这有助于您撤销提交！</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">itnext.io</p></div></div><div class="mg l"><div class="mm l mi mj mk mg ml jz lx"/></div></div></a></div><p id="7c40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，引用我自己的话(是的——我知道)</p><blockquote class="mn mo mp"><p id="5703" class="kg kh le ki b kj kk kl km kn ko kp kq mq ks kt ku mr kw kx ky ms la lb lc ld im bi translated">Git是一个版本控制系统，可以让你在开发软件的时候跟踪代码的变化。当你在团队中工作时，它是有用的，但当你独自工作时，它也是有用的——git是必须的。</p></blockquote><h1 id="0303" class="mt mu it bd mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq bi translated"><strong class="ak"> Git平分</strong></h1><p id="3373" class="pw-post-body-paragraph kg kh it ki b kj nr kl km kn ns kp kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">为了跟踪一个<em class="le">失败的</em>提交，git给了我们一个非常方便的工具叫做<code class="fe nw nx ny nz b">git bisect</code>。Git二等分执行一次二分搜索法来查找中断的提交。好吧，那么什么是二分搜索法呢？</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="f3b7" class="mt mu it bd mv mw oh my mz na oi nc nd ne oj ng nh ni ok nk nl nm ol no np nq bi translated"><strong class="ak">二分搜索法</strong></h1><p id="9b6a" class="pw-post-body-paragraph kg kh it ki b kj nr kl km kn ns kp kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">你可能还记得很久很久以前的研究..二分搜索法是一种算法，它接受一个列表，反复地把它分成两半，直到你缩小问题的范围。</p><blockquote class="mn mo mp"><p id="09cd" class="kg kh le ki b kj kk kl km kn ko kp kq mq ks kt ku mr kw kx ky ms la lb lc ld im bi translated">二分搜索法是一种有效的算法，用于从排序的项目列表中查找项目。它的工作原理是重复地将列表中可能包含该项目的部分分成两半，直到您将可能的位置缩小到只有一个。</p></blockquote><p id="47e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个简单的例子是猜谜游戏。让我们假设你想到一个0到100之间的数字。所以我问你:数字是否高于50？没有吗？好的:现在我把可能的范围从0到100分成两半。从0到50因为我知道它不在50到100的范围内，因为你说的数字不高于50。好的:这个数字是否高于25？什么事？好的:现在我再把0到50的范围分成两半。一个范围从0到25，另一半从25到50——我知道它一定在第二个范围内。我继续这样做，直到找到正确的数字。那是二分搜索法。如果你想了解更多:<a class="ae kf" href="https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search" rel="noopener ugc nofollow" target="_blank">这篇</a>是一篇相当有帮助的文章。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="4b20" class="mt mu it bd mv mw oh my mz na oi nc nd ne oj ng nh ni ok nk nl nm ol no np nq bi translated"><strong class="ak"> Git平分</strong></h1><p id="cb99" class="pw-post-body-paragraph kg kh it ki b kj nr kl km kn ns kp kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">好吧——回到<code class="fe nw nx ny nz b">git bisect</code>。我们如何在git中做同样的事情？基本原理是这样的:首先你要告诉git你想用<code class="fe nw nx ny nz b">git bisect start</code>做一个二等分。然后你挑一个知道<em class="le">不好的</em>跟<code class="fe nw nx ny nz b">git bisect bad &lt;commit&gt;</code>犯。如果您将<code class="fe nw nx ny nz b">&lt;commit&gt;</code>留空，git会将您当前的<code class="fe nw nx ny nz b">HEAD</code>视为错误提交。如果我们将它与上面提到的猜谜游戏进行比较，这将是一个更高的结果:100。</p><p id="b422" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不需要选择一个零，或者我们范围的起点。这是<strong class="ki iu">最后一次已知工作的</strong>提交。所以找到提交散列并键入类似于<code class="fe nw nx ny nz b">git bisect good eb02f47e20</code>的内容。一旦您指定了一个好的和一个坏的提交，git二等分应该打印如下内容:</p><pre class="om on oo op gt oq nz or os aw ot bi"><span id="a24d" class="ou mu it nz b gy ov ow l ox oy">Bisecting: 493 revisions left to test after this (roughly 9 steps)<br/>[c0b028f205a78ecc748e69d62450b4a804784da9] mb/google/cyan: Adjust ACPI interrupt triggering for audio codecs</span></pre><p id="dee4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好的，我们现在做的是:我们将一个提交(这是在我们的已知错误的提交之后的493个提交)作为一个好的提交。Git二分现在开始二进制搜索，以找到破坏树的提交。</p><p id="0b2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您可以再次构建您的项目—测试它，看看它是否工作。如果是:键入<code class="fe nw nx ny nz b">git bisect good</code>如果不是:<code class="fe nw nx ny nz b">git bisect bad</code>。通过这种方式，您可以告诉git二等分要么继续在一个提交中搜索，要么在提交的另一半中搜索。</p><p id="0c2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个过程中，git二分总是会告诉您还有多少可能的提交，以及(大致)还需要采取多少步骤。</p><pre class="om on oo op gt oq nz or os aw ot bi"><span id="6315" class="ou mu it nz b gy ov ow l ox oy">Bisecting: 7 revisions left to test after this (roughly 3 steps)<br/>[a38fee31b59acd8e3f07ec89d4328e98b6979611] nb/intel/sandybridge: Rename raminit_ivy.c</span></pre></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="a1e9" class="mt mu it bd mv mw oh my mz na oi nc nd ne oj ng nh ni ok nk nl nm ol no np nq bi translated"><strong class="ak">为什么？</strong></h1><p id="6eb7" class="pw-post-body-paragraph kg kh it ki b kj nr kl km kn ns kp kq kr nt kt ku kv nu kx ky kz nv lb lc ld im bi translated">所以问题是——为什么使用git二等分而不是一个接一个地检查您的提交？你可能已经注意到:Git平分<em class="le">总是</em>大约需要9个步骤。因此，不要一个人完成200次提交，你可以完成9次提交，测试一下，然后就有答案了！</p><p id="b250" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">黑客快乐！</p></div></div>    
</body>
</html>