<html>
<head>
<title>How to use Azure API from Go SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Go SDK中的Azure API</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-azure-api-from-go-sdk-ea3443e5ce96?source=collection_archive---------4-----------------------#2018-10-08">https://itnext.io/how-to-use-azure-api-from-go-sdk-ea3443e5ce96?source=collection_archive---------4-----------------------#2018-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9eb7fd2baed624a011b4449e62d7f1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4XNtE-9MrAPApyb2fJGyg.jpeg"/></div></div></figure><p id="8e4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将通过一些基本的例子来说明如何在go中使用Azure SDK。我们将要经历的示例程序非常简单。首先，它获取Azure订阅中所有资源组的列表，然后遍历每个资源组中的所有虚拟机。你猜怎么着..它使用Go令人敬畏的并发性(go go goroutines)完成所有这些工作。听起来很简单，但实际上我们在例子中所做的操作应该给你一个如何使用Azure的SDK和API的很好的概述。</p><p id="cee3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该程序位于<a class="ae kw" href="https://github.com/nordcloud/azure-go-example" rel="noopener ugc nofollow" target="_blank"> github库</a>中，你可以自由地克隆它、派生它并对其进行操作。您只需要有一个正常工作的go和dep安装。</p><p id="79bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开始吧！然而，在我们继续之前，我们首先需要以某种方式验证Azure API。对于Azure，这意味着创建一个服务主体帐户，我们的程序将使用该帐户进行身份验证，并承担具有执行API操作所需权限的角色。</p><p id="5176" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建服务主体，让我们使用Azure CLI，如下所示。该命令将输出一个身份验证文件，其中包含客户端id、客户端机密和连接Azure所需的一系列信息。记得保管好！</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="e8af" class="lg lh iq lc b gy li lj l lk ll"><em class="lm">az ad sp create-for-rbac —sdk-auth &gt; my.auth</em></span></pre><p id="ad05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经创建了服务主体，克隆示例的repo</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b415" class="lg lh iq lc b gy li lj l lk ll"><em class="lm">git clone </em><a class="ae kw" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank"><em class="lm">git@github.com</em></a><em class="lm">:nordcloud/azure-go-example.git</em></span></pre><p id="3fbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个程序非常简单，只包含一个文件— <code class="fe ln lo lp lc b"><em class="lm">main.go</em></code>。在我们继续之前，我们需要运行<code class="fe ln lo lp lc b"><em class="lm">dep ensure</em></code>,在我们的程序目录中出售golang SDK依赖项。</p><p id="3cd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">代码</strong></p><p id="1f0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们打开main.go文件，看看<code class="fe ln lo lp lc b"><em class="lm">main()</em></code>方法。</p><p id="93a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你能看到的是示例程序的一般流程。首先，它使用我们在前面步骤中创建的服务提供商身份进行授权，然后获取订阅中所有资源组的列表，最后，对于每个资源组，它列出所有虚拟机。</p><p id="fc37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好，让我们看看代码中发生了什么。再来看<code class="fe ln lo lp lc b"><em class="lm">newSessionFromFile</em> </code>法。有趣的是我们用SDK的方法<code class="fe ln lo lp lc b"><em class="lm">NewAuthorizerFromFile</em>.</code>得到授权者的那一行</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="760c" class="lg lh iq lc b gy li lj l lk ll">func newSessionFromFile() (*AzureSession, error) {</span><span id="0575" class="lg lh iq lc b gy lq lj l lk ll">authorizer, err := auth.NewAuthorizerFromFile(azure.PublicCloud.ResourceManagerEndpoint)</span><span id="f1c9" class="lg lh iq lc b gy lq lj l lk ll">if err != nil {<br/>    return nil, errors.Wrap(err, "Can't initialize authorizer")<br/>}</span><span id="ac36" class="lg lh iq lc b gy lq lj l lk ll">authInfo, err := readJSON(os.Getenv("AZURE_AUTH_LOCATION"))</span><span id="ca62" class="lg lh iq lc b gy lq lj l lk ll">if err != nil {<br/>    return nil, errors.Wrap(err, "Can't get authinfo")<br/>}</span><span id="0dcf" class="lg lh iq lc b gy lq lj l lk ll">sess := AzureSession{<br/>    SubscriptionID: (*authInfo)["subscriptionId"].(string),<br/>    Authorizer:     authorizer,<br/>}</span><span id="a775" class="lg lh iq lc b gy lq lj l lk ll">return &amp;sess, nil<br/>}</span></pre><p id="d349" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个方法假设<code class="fe ln lo lp lc b"><em class="lm">AZURE_AUTH_LOCATION</em></code> env变量包含我们之前创建的服务主体auth文件的路径。它读取文件并返回一个授权者，该授权者随后被传递给资源API客户端。我们将授权者和订阅id一起打包到<code class="fe ln lo lp lc b"><em class="lm">AzureSession</em></code>结构中。我们使用<code class="fe ln lo lp lc b"><em class="lm">readJSON()</em></code>方法从同一个auth file文件中读取订阅的id。</p><p id="03a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到<code class="fe ln lo lp lc b"><em class="lm">main()</em></code>的方法。现在，我们有了一个工作会话，我们需要获得一个资源组列表。为此我让我们看看<code class="fe ln lo lp lc b"><em class="lm">getGroups</em></code> <em class="lm"> </em>的方法。它将一个会话作为参数，并为groups API创建一个新的客户机。客户端被传递给一个我们在上一步中创建的授权者。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="a280" class="lg lh iq lc b gy li lj l lk ll"><em class="lm">grClient := resources.NewGroupsClient(sess.SubscriptionID)</em></span></pre><blockquote class="lr ls lt"><p id="ce61" class="jy jz lm ka b kb kc kd ke kf kg kh ki lu kk kl km lv ko kp kq lw ks kt ku kv ij bi translated">创建客户端并执行其方法的模式(通常是<code class="fe ln lo lp lc b"><em class="iq">List</em></code>、<code class="fe ln lo lp lc b"><em class="iq">Get</em></code>、<code class="fe ln lo lp lc b"><em class="iq">CreateOrUpdate</em></code>)对于SDK中的所有资源都是相同的。一旦你掌握了诀窍，你就可以在Go中使用Azure API而不用查看doc。</p></blockquote><p id="3b33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了获得资源组列表，我们遍历由资源组客户机的<code class="fe ln lo lp lc b"><em class="lm">ListComplete</em></code>方法返回的所有资源组的列表，并将它们添加到一个列表中。</p><blockquote class="lr ls lt"><p id="ef45" class="jy jz lm ka b kb kc kd ke kf kg kh ki lu kk kl km lv ko kp kq lw ks kt ku kv ij bi translated">Azure SDKs是自动生成的，或多或少非常RESTful。每个资源类型都有相同的方法，比如<code class="fe ln lo lp lc b"><em class="iq">CreateOrUpdate</em></code>、<code class="fe ln lo lp lc b"><em class="iq">List</em></code>等等。您可以在这里看到API描述，这里描述的方法将映射到SDK方法，并将类型返回到Go结构。</p></blockquote><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="222e" class="lg lh iq lc b gy li lj l lk ll">for list, err := grClient.ListComplete(context.Background(), "", nil); list.NotDone(); err = list.Next() {</span><span id="e49f" class="lg lh iq lc b gy lq lj l lk ll">if err != nil {<br/>        return nil, errors.Wrap(err, "error traversing RG list")<br/>    }<br/>    rgName := *list.Value().Name<br/>    tab = append(tab, rgName)<br/>}</span></pre><p id="25e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我们所做的就是授权我们，并获得一个资源组列表。现在，对于每个组，我们将列出该组中的所有虚拟机。此外，我们将使用go例程同时完成这一任务！<code class="fe ln lo lp lc b"><em class="lm">main()</em></code>方法中的For循环遍历由<code class="fe ln lo lp lc b"><em class="lm">getGroups</em></code>方法返回的资源组，并且对于每个返回的<code class="fe ln lo lp lc b"><em class="lm">rg</em></code>，它使用<code class="fe ln lo lp lc b"><em class="lm">go</em></code>关键字运行一个并发的goroutine。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5d96" class="lg lh iq lc b gy li lj l lk ll"><em class="lm">go getVM(sess, group, &amp;wg)</em></span></pre><p id="8d72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">goroutine在<code class="fe ln lo lp lc b">getVM</code>方法中实现。该方法做与<code class="fe ln lo lp lc b"><em class="lm">getGroups</em></code>类似的事情。它创建一个虚拟机客户端(<code class="fe ln lo lp lc b"><em class="lm">NewVirtualMachinesClient</em></code>)并遍历所有打印它们的虚拟机。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="a2ca" class="lg lh iq lc b gy li lj l lk ll">for vm, err := vmClient.ListComplete(context.Background(), rg); vm.NotDone(); err = vm.Next() {<br/>    if err != nil {<br/>        log.Print("got error while traverising RG list: ", err)<br/>    }<br/>    i := vm.Value()<br/>    fmt.Printf("(%s) VM %s\n", rg, *i.Name)<br/>}</span></pre><p id="f377" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主线程使用<code class="fe ln lo lp lc b"><em class="lm">WaitGroup</em></code>原语及其<code class="fe ln lo lp lc b"><em class="lm">Wait()</em></code>方法等待所有并发go routines的终止，该方法在这里用于实现一个等待所有go例程完成的屏障。你可以在这里阅读更多关于<code class="fe ln lo lp lc b"><em class="lm">WaitGroups</em></code>和同步<a class="ae kw" href="https://golang.org/pkg/sync/#WaitGroup" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="8656" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们运行程序之前，我们首先需要导出带有服务主体信息的<code class="fe ln lo lp lc b"><em class="lm">my.auth</em></code>文件路径的<code class="fe ln lo lp lc b"><em class="lm">AZURE_AUTH_LOCATION</em></code>变量。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3803" class="lg lh iq lc b gy li lj l lk ll"><em class="lm">export AZURE_AUTH_LOCATION=/path/to/my.auth go run main.go</em></span></pre><p id="ed8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会看到类似这样的输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="7174" class="lg lh iq lc b gy li lj l lk ll">(rg1) VM ubuntu<br/>(rg1) VM ubuntutest<br/>(rg2) VM ubuntu2<br/>(rg2) VM ubuntu3<br/>(rg2) VM ubuntu5<br/>(rg2) VM ubuntu44<br/>(rg2) VM ubuntu333<br/>(rg2) VM ubuntu3<br/>(myGroup) VM windows<br/>(myGroup) VM Windas<br/>(testGroup233) VM vm-1-west<br/>(testGroup233) VM vm-2-west<br/>(testGroup233) VM vm-3-west<br/>(testGroup233) VM vm-4-west<br/>...</span></pre><p id="3e07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一篇文章中，我们将向你展示如何使用Go中的GCP SDK🙂</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="f1b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm">原载于2018年10月8日</em><a class="ae kw" href="https://nordcloud.com/how-to-use-azure-api-from-go-sdk/" rel="noopener ugc nofollow" target="_blank"><em class="lm">nordcloud.com</em></a><em class="lm">。</em></p></div></div>    
</body>
</html>