<html>
<head>
<title>Kubernetes Readiness Probes — Examples &amp; Common Pitfalls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes就绪性调查—示例和常见陷阱</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-readiness-probes-examples-common-pitfalls-136e3a9a058d?source=collection_archive---------2-----------------------#2021-01-11">https://itnext.io/kubernetes-readiness-probes-examples-common-pitfalls-136e3a9a058d?source=collection_archive---------2-----------------------#2021-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="31fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作者Levent Ogut</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/260088600ac2f96f3e477f27dce6d5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*leoA3FOsOlXp4zEF"/></div></div></figure><p id="efd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes是部署我们的微服务和应用的绝佳平台。其中一个出色的特性是，当pods不能正常工作时，它会被重启或从服务中删除。Kubernetes需要我们的帮助来了解一个pod是否在工作。这是通过容器探测器配置的。</p><p id="9340" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何应用程序都可能由于错误、缺少对外部资源的依赖等原因而处于不健康状态。为了确保我们的流量正确流动，我们需要确保配置了探测器。</p><p id="5245" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">探针是kubelet对健康检查的回答，有三个处理程序:</p><ul class=""><li id="74ed" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><a class="ae lg" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#execaction-v1-core" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> ExecAction </strong> </a>:命令执行检查，如果命令的退出状态为0，则认为成功。</li><li id="6f51" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir"> TCPSocketAction </strong> : TCP检查确定端口是否打开，如果打开，则认为成功。</li><li id="1e8a" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir"> HTTPGetAction </strong> : HTTP检查确定状态码是否等于或大于200且小于400。</li></ul><p id="c334" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每种类型的探测器都有通用的可配置字段:</p><ul class=""><li id="3c0b" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><strong class="jp ir"> initialDelaySeconds </strong>:容器启动后<code class="fe lm ln lo lp b">initialDelaySeconds</code>后探头开始运行(默认值:0)</li><li id="a2be" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">周期秒</strong>:探头运行的频率(默认值:10)</li><li id="289d" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">超时秒数</strong>:探头超时(默认值:1)</li><li id="c139" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">成功阈值</strong>:标记容器健康/就绪所需的成功探测次数(默认值:1)</li><li id="9c1a" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">失败尿道阈值</strong>:当探针失败时，它将尝试<code class="fe lm ln lo lp b">failureThreshold</code>次，然后才认为不健康/未准备好(默认值:3)</li></ul><p id="7a0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些参数需要根据您的应用规范进行配置。</p><p id="5677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Exec action只有一个字段，就是检查命令的<code class="fe lm ln lo lp b">command.</code>退出状态，状态为零(0)表示健康，其他值表示不健康。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="e1f7" class="lu lv iq lp b gy lw lx l ly lz">        readinessProbe:<br/>          initialDelaySeconds: 1<br/>          periodSeconds: 5<br/>          timeoutSeconds: 1<br/>          successThreshold: 1<br/>          failureThreshold: 1<br/>          exec:<br/>            command:<br/>            - cat<br/>            - /etc/nginx/nginx.conf</span></pre><p id="a9cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要定义<code class="fe lm ln lo lp b">host</code>和<code class="fe lm ln lo lp b">port</code>参数，<code class="fe lm ln lo lp b">host</code>参数默认为集群内部的pod IP。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="ca10" class="lu lv iq lp b gy lw lx l ly lz">        readinessProbe:<br/>          initialDelaySeconds: 1<br/>          periodSeconds: 5<br/>          timeoutSeconds: 1<br/>          successThreshold: 1<br/>          failureThreshold: 1<br/>          tcpSocket:<br/>            host:<br/>            port: 80</span></pre><p id="35a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP探测器有额外的选项可以配置。</p><ul class=""><li id="3d14" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><strong class="jp ir">主机</strong>:要连接的主机/IP(默认:pod IP)</li><li id="89eb" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">方案</strong>:发出请求时使用的方案(默认:HTTP)</li><li id="7768" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">路径</strong>:路径</li><li id="aeb0" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir"> httpHeaders </strong>:定义为头/值映射的头数组</li><li id="8aea" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">端口</strong>:要连接的端口</li></ul><p id="0474" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提示:如果需要设置HTTP的主机头，请在httpHeaders上这样做，而不是Host参数。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="2eb4" class="lu lv iq lp b gy lw lx l ly lz">        readinessProbe:<br/>          initialDelaySeconds: 1<br/>          periodSeconds: 2<br/>          timeoutSeconds: 1<br/>          successThreshold: 1<br/>          failureThreshold: 1<br/>          httpGet:<br/>            host:<br/>            scheme: HTTP<br/>            path: /<br/>            httpHeaders:<br/>            - name: Host<br/>              value: myapplication1.com<br/>            port: 80<br/>          initialDelaySeconds: 5<br/>          periodSeconds: 5</span></pre><h1 id="c938" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">Kubernetes的就绪性调查</h1><p id="90e0" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">Kubernetes运行就绪探测，以了解何时可以向pod发送流量，即将pod转换到<code class="fe lm ln lo lp b">Ready</code>状态。例如，如果一个pod被用作服务的后端端点，则就绪性探测将确定该pod是否会接收流量。在pod的整个生命周期中执行就绪探测；这意味着就绪探测在到达<code class="fe lm ln lo lp b">Ready</code>状态后继续执行。此外，我们的应用程序可以通过用不同的值响应探测器，使自己不可用于维护或一些后台任务。</p><p id="c722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">pod会转换以下状态:</p><ul class=""><li id="530d" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><strong class="jp ir"> PodScheduled </strong> : Pod被调度在一个可用的节点上</li><li id="9794" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">集装箱就绪</strong>:所有集装箱处于<code class="fe lm ln lo lp b">Ready</code>状态</li><li id="8fb9" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">初始化</strong>:所有初始化容器都被启动</li><li id="18dc" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">就绪</strong> : Pod准备接收流量(就绪探测)</li></ul><h1 id="c235" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">就绪性探测的常见陷阱</h1><p id="6d11" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">就绪探测器在容器的生命周期内检查配置的动作；因此，回答中的任何中断或延迟都可能导致服务中断。有时，应用程序需要读取大量数据，遇到延迟问题或进行昂贵的计算，这可能会阻止提供这样的答案。在配置就绪探测器时，应该考虑这种行为。强烈建议在使用就绪探测器之前进行彻底的测试。</p><h1 id="a888" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">连锁故障</h1><p id="0b69" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">考虑到这一点，我们已经用HTTPGet配置了一个就绪探测器，我们的应用程序在应答探测器之前检查数据库连接。让我们假设有一个数据库问题；在这种情况下，除非数据库恢复，否则所有pod都将无法访问。我们想要这种行为吗？当然不是，我们可以将数据库错误反馈到前端，并通知用户不可用；即使我们增加<code class="fe lm ln lo lp b">failureThreshold</code>，我们也可能无法避免连锁故障。在任何情况下，我都建议避免对就绪性探测答案的外部依赖。</p><h1 id="4f65" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">外部依赖性</h1><p id="dfba" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">让我们假设您有一个用于缓存的键/值存储，并且您的就绪探测端点也检查这个连接。应用程序能够在没有键/值存储的情况下运行，因为它只会降低速度，但它会在每次需要访问数据时运行完整的数据库查询。在这种情况下，如果准备就绪探测因为键/值存储不可用而失败，那么您的整个应用程序将停机一段时间——直到您修复了键/值存储，这当然是不希望的。</p><p id="d993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要清楚地设计您的探测器，考虑您的应用程序在出现故障时的行为和响应。您可能希望重启pod(通过活性检查)或使用就绪探测器将其从服务中移除。</p><h1 id="0340" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">示例:Nginx部署示例</h1><p id="dfb2" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">为了查看就绪探测器的运行情况，我们可以配置一个示例应用程序，在本例中是一个简单的NGINX web服务器。这里我们定义了一个简单的部署配置:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="3913" class="lu lv iq lp b gy lw lx l ly lz">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: k8s-probes<br/>  labels:<br/>    app: nginx<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx<br/>        ports:<br/>        - containerPort: 80<br/>        readinessProbe:<br/>          initialDelaySeconds: 1<br/>          periodSeconds: 2<br/>          timeoutSeconds: 1<br/>          successThreshold: 1<br/>          failureThreshold: 1<br/>          httpGet:<br/>            host:<br/>            scheme: HTTP<br/>            path: /<br/>            httpHeaders:<br/>            - name: Host<br/>              value: myapplication1.com<br/>            port: 80</span></pre><p id="0024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将该配置保存到一个名为k8s-probes-deployment.yaml的文件中，并使用<code class="fe lm ln lo lp b">kubectl apply -f k8s-probes-deployment.yaml</code>应用它。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="ea90" class="lu lv iq lp b gy lw lx l ly lz">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: nginx<br/>  name: nginx<br/>  namespace: default<br/>spec:<br/>  ports:<br/>  - name: nginx-http-port<br/>    port: 80<br/>  selector:<br/>    app: nginx<br/>  sessionAffinity: None<br/>  type: NodePort</span></pre><p id="f78c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将这个配置保存到一个名为k8s-probes-svc.yaml的文件中，并使用<code class="fe lm ln lo lp b">kubectl apply -f k8s-probes-svc.yaml</code>应用它。</p><p id="3885" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就绪探测没有单独的端点，但是我们可以使用<code class="fe lm ln lo lp b">kubectl describe pods &lt;POD_NAME&gt;</code>命令访问事件，例如，获取当前状态。</p><p id="88de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe lm ln lo lp b">kubectl get pods</code>命令查看pod的状态。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="c4b0" class="lu lv iq lp b gy lw lx l ly lz">kubectl get pods</span></pre><p id="265e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">pod及其状态和就绪状态将会显示出来，我们的pod正在按预期运行。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="bbb7" class="lu lv iq lp b gy lw lx l ly lz">NAME                          READY   STATUS    RESTARTS   AGE<br/>k8s-probes-7d57f897dd-td2q2   1/1     Running   0          1m23s</span></pre><p id="e91c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与<code class="fe lm ln lo lp b">kubectl describe pod &lt;POD_NAME&gt;</code></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="43eb" class="lu lv iq lp b gy lw lx l ly lz">kubectl describe pod k8s-probes-755b4bf57c-jgcqw</span></pre><p id="987c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在输出的底部会显示<code class="fe lm ln lo lp b">Events</code>:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="e2fb" class="lu lv iq lp b gy lw lx l ly lz">Events:<br/>  Type    Reason     Age   From               Message<br/>  ----    ------     ----  ----               -------<br/>  Normal  Scheduled  15m   default-scheduler  Successfully assigned default/k8s-probes-755b4bf57c-jgcqw to k8s-probes<br/>  Normal  Pulling    15m   kubelet            Pulling image "nginx"<br/>  Normal  Pulled     15m   kubelet            Successfully pulled image "nginx" in 1.418647753s<br/>  Normal  Created    15m   kubelet            Created container nginx<br/>  Normal  Started    15m   kubelet            Started container nginx</span></pre><p id="b139" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用<code class="fe lm ln lo lp b">kubectl get endpoints</code>命令来看看端点。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="5400" class="lu lv iq lp b gy lw lx l ly lz">kubectl get endpoints</span></pre><p id="c577" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到Nginx服务有一个端点。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="7f89" class="lu lv iq lp b gy lw lx l ly lz">NAME         ENDPOINTS           AGE<br/>kubernetes   10.132.0.42:16443   8h<br/>nginx        10.1.85.203:80      6m11s</span></pre><p id="3302" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查看更多细节，我们可以使用<code class="fe lm ln lo lp b">kubectl describe endpoints nginx</code>命令。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="b5df" class="lu lv iq lp b gy lw lx l ly lz">Name:         nginx<br/>Namespace:    default<br/>Labels:       app=nginx<br/>Annotations:  endpoints.kubernetes.io/last-change-trigger-time: 2020-11-13T20:34:13Z<br/>Subsets:<br/>  Addresses:          10.1.85.203<br/>  NotReadyAddresses:  &lt;none&gt;<br/>  Ports:<br/>    Name             Port  Protocol<br/>    ----             ----  --------<br/>    nginx-http-port  80    TCP</span></pre><p id="854d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将就绪探针的<code class="fe lm ln lo lp b">port</code>参数配置为81，并应用配置。</p><p id="a5c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次检查pod状态</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="0bb2" class="lu lv iq lp b gy lw lx l ly lz">kubectl get pods</span></pre><p id="4db8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，我们已经更新了部署，因此创建了一个新的pod，正如您所看到的，它没有处于就绪状态。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="d966" class="lu lv iq lp b gy lw lx l ly lz">NAME                          READY   STATUS    RESTARTS   AGE<br/>k8s-probes-755b4bf57c-jgcqw   1/1     Running   0          13m<br/>k8s-probes-7d57f897dd-td2q2   0/1     Running   0          2m49s</span></pre><p id="0eba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的状态是正在运行，但是<code class="fe lm ln lo lp b">READY</code>状态确定我们的pod尚未准备好。让我们用<code class="fe lm ln lo lp b">kubectl describe pods &lt;POD_NAME&gt;</code>命令来研究状态和事件。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="40cb" class="lu lv iq lp b gy lw lx l ly lz">kubectl describe pod k8s-probes-7d57f897dd-td2q2</span></pre><p id="4d91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，由于连接被拒绝，就绪探测失败，因此pod不会接收任何流量。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="3675" class="lu lv iq lp b gy lw lx l ly lz">Events:<br/>  Type     Reason     Age                From               Message<br/>  ----     ------     ----               ----               -------<br/>  Normal   Scheduled  58s                default-scheduler  Successfully assigned default/k8s-probes-7d57f897dd-td2q2 to k8s-probes<br/>  Normal   Pulling    57s                kubelet            Pulling image "nginx"<br/>  Normal   Pulled     56s                kubelet            Successfully pulled image "nginx" in 1.211289526s<br/>  Normal   Created    56s                kubelet            Created container nginx<br/>  Normal   Started    56s                kubelet            Started container nginx<br/>  Warning  Unhealthy  4s (x10 over 49s)  kubelet            Readiness probe failed: Get "http://10.1.85.202:81/": dial tcp 10.1.85.202:81: connect: connection refused</span></pre><p id="132e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们直接检查状态:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="fe3d" class="lu lv iq lp b gy lw lx l ly lz">kubectl get pods k8s-probes-7d57f897dd-td2q2 -o jsonpath='{.status.containerStatuses[0].state}'</span></pre><p id="148d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态是“正在运行”。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="8e03" class="lu lv iq lp b gy lw lx l ly lz">{"running":{"startedAt":"2020-11-17T11:47:21Z"}}</span></pre><p id="26e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看就绪状态:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="db4d" class="lu lv iq lp b gy lw lx l ly lz">kubectl get pods k8s-probes-7d57f897dd-td2q2 -o jsonpath='{.status.containerStatuses[0].ready}'</span></pre><p id="096c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，集装箱还没准备好。</p><p id="b67c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再来看看端点:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="43b2" class="lu lv iq lp b gy lw lx l ly lz">kubectl get endpoints</span></pre><p id="a4b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">列出了服务和相关端点:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="ba62" class="lu lv iq lp b gy lw lx l ly lz">NAME         ENDPOINTS           AGE<br/>kubernetes   10.132.0.42:16443   8h<br/>nginx                            11m</span></pre><p id="dd91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们可以看到，我们的Nginx服务没有任何端点，因为容器还没有准备好接受流量。</p><h1 id="bf5a" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">结论</h1><p id="9f25" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">我们已经看到了就绪探测的效果，并研究了我们可以配置的参数。虽然我们进行了HTTP检查，但是这里显示的概念也适用于其他检查。您需要了解您的应用程序的体系结构和依赖性，以便能够配置和操作就绪探测器。了解您的应用程序是至关重要的，因为配置不当的就绪性探测器可能会导致您的应用程序不可用。请不要忘记，准备就绪探测将在容器的整个生命周期中运行。</p><h1 id="321f" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">进一步阅读</h1><ul class=""><li id="4dd3" class="kx ky iq jp b jq mx ju my jy nc kc nd kg ne kk lc ld le lf bi translated"><a class="ae lg" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#probe-v1-core" rel="noopener ugc nofollow" target="_blank"> Kubernetes核心探测文件</a></li><li id="d4c0" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><a class="ae lg" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank">配置活跃度、就绪和启动探测器</a></li><li id="6cc3" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><a class="ae lg" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes" rel="noopener ugc nofollow" target="_blank"> Kubernetes集装箱探测器文档</a></li><li id="5013" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><a class="ae lg" href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/" rel="noopener ugc nofollow" target="_blank">容器生命周期挂钩文档</a></li></ul><p id="0872" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lg" href="https://unsplash.com/@i_m_polo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ildefonso Polo </a>在<a class="ae lg" href="https://unsplash.com/s/photos/telecommunications?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="ea39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nm">原发布于</em><a class="ae lg" href="https://loft.sh/blog/kubernetes-readiness-probes-examples-common-pitfalls/" rel="noopener ugc nofollow" target="_blank"><em class="nm">https://loft . sh</em></a><em class="nm">。</em></p></div></div>    
</body>
</html>