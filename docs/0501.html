<html>
<head>
<title>How to Make AJAX API Calls in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中进行AJAX API调用</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-make-ajax-api-calls-in-react-8ee7b8ee539d?source=collection_archive---------5-----------------------#2018-03-20">https://itnext.io/how-to-make-ajax-api-calls-in-react-8ee7b8ee539d?source=collection_archive---------5-----------------------#2018-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7d6cadab144da06d53b471edc64339c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vVzwGLvNK8Il14IP7ACUYw.jpeg"/></div></div></figure><p id="1447" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将介绍在React中使用AJAX的不同方法，以及在哪里调用AJAX？<code class="fe kw kx ky kz b">componentDidMount()</code>vs<code class="fe kw kx ky kz b">componentWillMount()</code>vs ES6类构造函数。</p><p id="9711" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过一个简单的例子，我们将了解如何通过不同的机制，如<strong class="ka ir"> Axios </strong>库、<strong class="ka ir"> XMLHttpRequest </strong>或现代浏览器的<strong class="ka ir"> fetch </strong> API，使用React发出AJAX请求或API调用(GET、POST、PUT和DELETE)来获取、创建、更新和删除数据。</p><p id="2d0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React是一个视图库，用于构建用户界面，而不是一个完整的框架，例如Angular或AngularJS。在MVC架构中，React代表了<strong class="ka ir">V</strong>view部分。因此，如果你以前使用过客户端框架，你会注意到缺少许多抽象，比如进行HTTP调用的服务(相当于AngularJS中的<strong class="ka ir"> $http </strong>)。</p><p id="7219" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以——如果你问发送AJAX调用的反应相当于什么？没有！</p><p id="1282" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不应该认为这是这个库的弱点，因为React不应该处理通常由框架处理的所有任务。React的全部目的是使用来自<strong class="ka ir"> props </strong>和<strong class="ka ir"> state </strong>(通常从API服务器获取)的数据来呈现无状态组件(没有数据的转储组件)和有状态组件。</p><p id="c6e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么如何从远程HTTP服务器获取数据呢？或者如何进行API调用？</p><p id="493d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从外部库到浏览器API，您有太多的选择。您所要做的就是根据您的需求选择合适的解决方案。</p><h1 id="fbbc" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">选择正确的HTTP调用机制</h1><p id="fa94" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">有许多具有不同特性的库，可以用来从远程服务器获取数据。</p><ul class=""><li id="0fbe" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated">如果你觉得使用JavaScript Promises很舒服，你可以使用Axios。</li><li id="e2a9" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">如果你喜欢使用前沿标准，你可以使用<code class="fe kw kx ky kz b">fetch</code> api</li><li id="b9b6" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">您也可以使用jQuery，但是不建议为了进行API调用而包含整个库。</li><li id="1d39" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">可以使用<a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequest </a>接口。</li></ul><p id="99bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看一个实际的例子，使用浏览器的fetch api。</p><p id="1342" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将创建一个简单的React应用程序，它向Reddit服务器发送API调用来获取一些subreddit帖子。</p><p id="a2ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以继续创建一个新的React项目。我正在使用和推荐<strong class="ka ir"> create-react-app </strong>，因为它让你从配置WebPack的麻烦中解脱出来，让你快速生成一个启动项目来构建你的应用。</p><p id="54da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您决定这样做，您可以使用npm来安装<strong class="ka ir"> create-react-app </strong>,其中包含:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="ac25" class="na lb iq kz b gy nb nc l nd ne">npm install -g create-react-app</span></pre><p id="c168" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以使用以下内容生成一个新的React项目:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="a425" class="na lb iq kz b gy nb nc l nd ne">create-react-app react-ajax-demo <br/>cd react-ajax-demo <br/>npm start</span></pre><h1 id="d1ea" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何使用Fetch API？</h1><p id="3554" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">根据<a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> Mozilla MDN </a></p><blockquote class="nf ng nh"><p id="2937" class="jy jz ni ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><em class="iq">Fetch API提供了一个JavaScript接口，用于访问和操作HTTP管道的各个部分，例如请求和响应。它还提供了一个全局fetch()方法，该方法提供了一种简单、逻辑的方法来通过网络异步获取资源。</em></p></blockquote><p id="3401" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们从Reddit获取一些数据。在<code class="fe kw kx ky kz b">App.js</code>中，更新代码以反映这些变化。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="b0af" class="na lb iq kz b gy nb nc l nd ne">import React, { Component } from 'react';<br/>import logo from './logo.svg';<br/>import './App.css';<br/><br/>class App extends Component {<br/><br/>  constructor(props) {<br/>    super(props);<br/><br/>    this.state = {<br/>      posts: []<br/>    };<br/>  }  <br/>  fetchFirst(url) {<br/>    var that = this;<br/>    if (url) {<br/>      fetch('<a class="ae mm" href="https://www.reddit.com/r/" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/</a>' + url + '.json').then(function (response) {<br/>        return response.json();<br/>      }).then(function (result) {<br/><br/>        //console.log(result.data.children);<br/><br/>        that.setState({ posts: result.data.children, lastPostName: result.data.children[result.data.children.length - 1].data.name });<br/><br/>        console.log(that.state.posts);<br/>      });<br/>    }<br/>  }  <br/>  componentWillMount() {<br/><br/>      this.fetchFirst("reactjs");<br/><br/>  }    <br/>  render() {<br/><br/>    return (<br/>      &lt;div className="App"&gt;<br/>        &lt;header className="App-header"&gt;<br/>          &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>          &lt;h1 className="App-title"&gt;React AJAX Example&lt;/h1&gt;<br/>        &lt;/header&gt;<br/>        &lt;p className="App-intro"&gt;<br/>          &lt;ul&gt;<br/>            {this.state.posts.map(post =&gt;<br/>              &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;<br/>            )}<br/>          &lt;/ul&gt;          <br/>        &lt;/p&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/><br/>export default App;</span></pre><p id="248c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就在<code class="fe kw kx ky kz b">fetchFirst()</code>方法中，我们发送一个GET请求，使用下面的代码从<code class="fe kw kx ky kz b">'https://www.reddit.com/r/' + url + '.json'</code>获取数据:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="4945" class="na lb iq kz b gy nb nc l nd ne">fetch('<a class="ae mm" href="https://www.reddit.com/r/" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/</a>' + url + '.json').then(function (response) {<br/>        return response.json();<br/>}).then(function (result) {<br/>    console.log(result.data.children);<br/>});</span></pre><p id="6d62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">API很简单，唯一需要的参数是资源的URI。在我们的例子中，它是一个JSON文件，但也可以是任何类型的资源，如图像或其他类型。</p><p id="286d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有额外的参数，默认情况下<code class="fe kw kx ky kz b">fetch(url)</code>发送一个<strong class="ka ir"> GET </strong> HTTP请求。</p><p id="3378" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还可以通过在第二个参数中显式指定方法名来调用其他HTTP方法，如POST、PUT或DELETE。例如，下面是我们如何用<code class="fe kw kx ky kz b">fetch()</code>发送POST请求</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="6261" class="na lb iq kz b gy nb nc l nd ne">var form = new FormData(document.getElementById('login-form'));<br/>fetch("/login", {<br/>  method: "POST",<br/>  body: form<br/>});</span></pre><h1 id="abe7" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">在哪里发出AJAX请求:componentWillMount vs componentDidMount？</h1><p id="8586" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">React应用程序是一组组件，包括根组件、父组件、顶级组件和子组件(以及子组件的子组件),它们可以被可视化为一个树形结构。React社区中出现了许多问题——如何处理数据？数据如何从获取数据的组件流向其他组件？最重要的是，在哪里放置获取数据的代码？</p><p id="dd3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在前面的例子中，我们调用了来自<code class="fe kw kx ky kz b">componentWillMount()</code>生命周期事件的数据获取逻辑，当组件将要挂载时，在组件的第一次渲染之前调用。</p><p id="74d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有许多地方可以获取数据，例如:</p><ul class=""><li id="f73e" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated">component render()方法:这是个坏主意！您应该避免在组件的<code class="fe kw kx ky kz b">render()</code>方法中放置任何异步代码，即改变应用程序状态或导致副作用的代码。</li><li id="3553" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">生命周期事件<code class="fe kw kx ky kz b">componentDidMount()</code>:React文档推荐的地点。</li><li id="091a" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">生命周期事件<code class="fe kw kx ky kz b">componentWillMount()</code>:根据React文档，不推荐。</li><li id="848b" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">ES6中组件的构造函数:它被认为是反模式！但是可以像<code class="fe kw kx ky kz b">componentWillMount()</code>一样使用。</li></ul><p id="53dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们来看看获取数据时需要遵循的最佳实践。</p><h1 id="f0e0" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">正在获取componentDidMount()事件中的数据</h1><p id="246d" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">这是最简单的方法。我们在<code class="fe kw kx ky kz b">componentDidMount()</code>而不是<code class="fe kw kx ky kz b">componentWillMount()</code>从远程服务器获取数据，这样我们可以避免<code class="fe kw kx ky kz b">fetch()</code> API的任何副作用。</p><h2 id="77fe" class="na lb iq bd lc nm nn dn lg no np dp lk kj nq nr lo kn ns nt ls kr nu nv lw nw bi translated">componentDidMount()与componentWillMount()</h2><p id="3f76" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在组件第一次渲染之前调用了<code class="fe kw kx ky kz b">componentWillMount()</code>方法。这可能会让任何人误以为这是获取数据的最佳地点。但事实并非如此！因为fetch调用是异步的，这意味着调用可能不会在组件呈现之前返回，从而导致组件呈现空数据。您可以采取一些预防措施，例如设置初始状态，以便组件在数据到达并触发另一个呈现周期之前能够正确呈现。</p><p id="276e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">componentDidMount()</code>方法在组件第一次渲染后被调用，所以这是你可以安全放置任何获取数据、有副作用或操作DOM的异步代码的地方。</p><ul class=""><li id="dd96" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated">当您采用这种方法时，您已经正确地设置了初始状态，以处理尚不可用的数据或未定义的状态。</li><li id="fd43" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">对于服务器端渲染，<code class="fe kw kx ky kz b">componentWillMount()</code>将被服务器调用两次，又被客户端调用一次，因此获取数据的请求将被发送两次，从而与服务器进行不必要的往返。另一方面，<code class="fe kw kx ky kz b">componentDidMount()</code>在客户端只被调用一次。</li></ul><p id="b53e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的示例将更新为类似这样的内容:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="ac07" class="na lb iq kz b gy nb nc l nd ne">componentDidMount() {<br/>    this.fetchFirst("reactjs");<br/>}</span></pre><h2 id="ca7b" class="na lb iq bd lc nm nn dn lg no np dp lk kj nq nr lo kn ns nt ls kr nu nv lw nw bi translated">componentWillMount() vs构造函数</h2><p id="9bde" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在ES6 React中，构造函数就在类被实例化之前被调用，所以问题是当使用JavaScript 2015 (ES6)类时，你能放弃<code class="fe kw kx ky kz b">componentWillMount()</code>而支持类构造函数吗？</p><p id="1dea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，<code class="fe kw kx ky kz b">componentWillMount()</code> lifecycle event只有在您使用React with old JavaScript(即ES5) through，<code class="fe kw kx ky kz b">React.createClass()</code>方法时才需要，因为您无法定义构造函数。因此，我们可以假设可以使用构造函数来代替装载后生命周期事件。但那不是100%正确！因为如果在你的组件构造函数中有副作用，而不是在<code class="fe kw kx ky kz b">componentWillMount()</code>事件中，React会抛出警告。因此，如果您的代码需要更新其他组件中的状态，最好避免使用构造函数。我们之前也看到了React开发者不鼓励<code class="fe kw kx ky kz b">componentWillMount()</code>vs<code class="fe kw kx ky kz b">componentDidMount()</code>。最后一个结论:对任何不会产生副作用的初始化代码使用构造函数，比如状态更新，否则使用<code class="fe kw kx ky kz b">componentDidMount()</code>。在React repository上甚至还有一个公开的问题，即<a class="ae mm" href="https://github.com/facebook/react/issues/7671" rel="noopener ugc nofollow" target="_blank">反对挂载后事件</a>。</p><h1 id="4c89" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">通过props传递数据</h1><p id="7c02" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">另一种方法是将数据从父组件传递给子组件。但是当然父组件也应该避免前面的获取数据的方法，那么在哪里呢？父组件可以使用React路由器钩子(比如onEnter()钩子)来获取数据，然后通过<strong class="ka ir"> props </strong>将它们传递给子组件。</p><p id="31e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的简单示例中，我们只有一个组件，但这可以很容易地分解为如下内容:</p><p id="81eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Fetch.js</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="0023" class="na lb iq kz b gy nb nc l nd ne">export default {<br/>fetchFirst: function(url){<br/>    fetch('<a class="ae mm" href="https://www.reddit.com/r/" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/</a>' + url + '.json').then(function (response) {<br/>            return response.json();<br/>    }).then(function (result) {<br/>         return result.data.children;   <br/>    }); <br/>}  <br/>}</span></pre><p id="0e3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">RedditPost.js</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="c296" class="na lb iq kz b gy nb nc l nd ne">import React from "react";<br/><br/>class RedditPost extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/><br/>    this.state = {<br/>      title: props.title,<br/>      id: props.id<br/>    }<br/>  }<br/><br/>  componentWillReceiveProps(nextProps) {<br/>    this.setState(nextProps);<br/>  }<br/><br/>  render() {<br/>            &lt;li key={this.state.id}&gt;{this.state.title}&lt;/li&gt;<br/>      );<br/>    }<br/>  }<br/>}<br/><br/>RedditPost.propTypes = {<br/>  id: React.PropTypes.number,<br/>  title: React.PropTypes.string<br/>};<br/><br/>RedditPost.defaultProps = {<br/>  id: null,<br/>  title: ""<br/><br/>};<br/><br/>export default RedditPost;</span></pre><p id="9321" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">App.js</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="6819" class="na lb iq kz b gy nb nc l nd ne">import fetchFirst from "./Fetch";<br/><br/>import React, { Component } from 'react';<br/>import logo from './logo.svg';<br/>import './App.css';<br/><br/>class App extends Component {<br/><br/>  constructor(props) {<br/>    super(props);<br/><br/>    this.state = {<br/>      posts: []<br/>    };<br/>  }  <br/><br/>  componentDidMount() {<br/><br/>      fetchFirst("reactjs").then((posts)=&gt;{<br/>          this.state.posts = posts;<br/>      });<br/><br/>  }    <br/>  render() {<br/><br/>    return (<br/>      &lt;div className="App"&gt;<br/>        &lt;header className="App-header"&gt;<br/>          &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>          &lt;h1 className="App-title"&gt;React AJAX Example&lt;/h1&gt;<br/>        &lt;/header&gt;<br/>        &lt;p className="App-intro"&gt;<br/>          &lt;ul&gt;<br/>            {this.state.posts.map(post =&gt;<br/>              &lt;RedditPost {...post}/&gt;<br/>            )}<br/>          &lt;/ul&gt;          <br/>        &lt;/p&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/><br/>export default App;</span></pre><h1 id="004d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用Redux状态管理器</h1><p id="b714" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">第三种方法是使用像Redux这样的状态管理器。在这种情况下，可以从代码中的任何地方获取数据，然后存储在一个全局存储中，供所有其他组件使用。</p><h1 id="7f2f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="e16d" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">AJAX允许获取数据，然后更新用户界面，而无需刷新页面。这是当前现代应用程序的要求。客户端框架结合了服务来轻松地进行HTTP调用，但是对于React这样的库，你需要依赖其他库，或者更好的是，使用浏览器标准:旧的接口<strong class="ka ir"> XMLHttpRequest </strong>非常复杂(但是你可以将它封装在函数中或者使用jQuery这样的外部库)，或者现代浏览器的<strong class="ka ir"> fetch </strong> API(如果你想支持旧的浏览器，你可以使用polyfills)。</p><p id="516b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ni">原载于</em><a class="ae mm" href="https://www.techiediaries.com/react-ajax/" rel="noopener ugc nofollow" target="_blank"><em class="ni">www.techiediaries.com</em></a><em class="ni">。</em></p></div></div>    
</body>
</html>