<html>
<head>
<title>How and why to use Git Submodules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以及为什么使用Git子模块</h1>
<blockquote>原文：<a href="https://itnext.io/how-and-why-to-use-git-submodules-44a452b42a08?source=collection_archive---------2-----------------------#2021-12-12">https://itnext.io/how-and-why-to-use-git-submodules-44a452b42a08?source=collection_archive---------2-----------------------#2021-12-12</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/b9fdc3eb7a43c78183157d99da2c30e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qu1r699o0_qCtM4G.png"/></div></div></figure><p id="b89c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有时我们需要在一个Git仓库中使用另一个的内容。一个典型的例子是在多个应用程序中使用共享库的源代码。使用Git子模块，我们可以配置一个或多个其他存储库来作为子存储库签出。</p><p id="f9a0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">使用Git子模块会增加项目的复杂性。在走这条路之前，你应该确定结果是值得复杂的。正如他们所说:</p><blockquote class="la lb lc"><p id="af48" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz in bi translated"><em class="iu">一个程序员遇到了版本控制问题，他说:“我知道，我会使用子模块。”现在他们有两个问题。</em></p></blockquote><p id="a13b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是一个关于正则表达式的著名笑话。正则表达式非常有用，您必须确定它们是正确的解决方案。类似地，Git子模块非常有用，您必须确定它们是您的问题的正确解决方案。</p><p id="4781" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">通过子模块特性，您可以有效地将子Git存储库嵌入到父存储库中。子存储库的文件出现在父存储库的文件树中。但是子存储库中的更改是由子存储库而不是父存储库跟踪的。父存储库中的唯一记录是要在子存储库中使用的提交的SHA提交标识符。</p><p id="ad13" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">对于包含或嵌入一个或多个其他存储库的Git存储库，您能做什么？</p><p id="f9b4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在其核心，子模块允许您构建一个包含来自多个位置的数据(源文件)的目录层次结构。这个层次结构的子部分(也称为子模块)是独立管理的，每个子部分都有自己的版本。每个子模块可以被多个父项目使用。每个父项目都可以控制每个子项目所使用的版本，并且每个父项目都可以将变更推送到子项目。</p><p id="05dc" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这些属性是对优势的粗略总结。但是，如前所述，这增加了复杂性。两个例子是:</p><ol class=""><li id="ab18" class="lh li iu ke b kf kg kj kk kn lj kr lk kv ll kz lm ln lo lp bi translated">任何克隆父存储库的人都必须记住运行Git命令，以使子模块存储库也被检出。</li><li id="8a34" class="lh li iu ke b kf lq kj lr kn ls kr lt kv lu kz lm ln lo lp bi translated">如果子模块的存储库中有提交，则子模块SHA提交引用将不会更新，除非您必须为此运行Git命令。</li></ol><h1 id="8c81" class="lv lw iu bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">为什么要使用Git子模块？</h1><p id="dd5d" class="pw-post-body-paragraph kc kd iu ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz in bi translated">我使用Git很多年了，不需要了解子模块。我确信我们大多数人可能会在整个软件开发生涯中不使用像子模块这样的东西。使用它们会增加复杂性，所以最好值得你花时间。</p><p id="5274" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为什么我决定研究使用子模块？这是一个关于<a class="ae my" href="https://github.com/akashacms/akashacms-website" rel="noopener ugc nofollow" target="_blank"> AkashaCMS网站</a>的源代码库的问题。</p><p id="1d6c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">该网站记录了AkashaCMS系列工具，一个静态网站生成器平台。AkashaCMS涉及许多模块，每个模块在相应的存储库中都有文档。<code class="fe mz na nb nc b">akashacms/akashacms-website</code>存储库保存了出现在<code class="fe mz na nb nc b">akashacms.com</code>上的一部分内容，其余的内容分布在各个AkashaCMS包的存储库中。因此，每个包的文档随着它的变化而被跟踪。但是，让所有的文档都显示在<code class="fe mz na nb nc b">akashacms.com</code>上需要将所有的东西放在一个源代码树中。</p><p id="4bef" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">换句话说，构建<code class="fe mz na nb nc b">akashacms.com</code>网站需要将十几个或更多Git存储库的内容组装到一个目录树中。</p><p id="6280" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">过去，这是通过将文档嵌入每个npm包中来处理的。这意味着文档可以在<code class="fe mz na nb nc b">node_modules</code>目录树中找到。但是当我决定从npm包中删除文档文件，以减小包的大小时，这意味着要找到另一个解决方案。这个问题引出了Git子模块，现在我们来了。</p><p id="b469" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">使用Git子模块的一个更典型的原因是一组应用程序的开发人员需要在这些应用程序中包含相同的库。例如，有人可能已经创建了一个非常好的MP3库，用于多个音频播放器应用程序。应用程序开发人员可能会选择将MP3库直接嵌入到他们编译的应用程序中，而不是依赖于作为共享库安装在任何安装了该应用程序的计算机上。</p><p id="6d6d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一般来说，一个或多个应用程序作者可能会在他们的应用程序中直接嵌入一个给定的库。</p><p id="da93" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这样的应用程序作者可以很容易地同时在共享库中和应用程序中处理代码。他们可能会发现将共享库存储库配置为子模块最方便，因此它都在同一个托管源代码树中，并且每个开发应用程序的开发人员都在同一个页面上。</p><p id="0c5e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有充分的理由使用子模块。确保你理解他们，确保他们是你所需要的。接下来是使用Git子模块的教程。</p><p id="05cb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">记住这一点，让我们开始了解如何使用Git子模块。</p><h1 id="3704" class="lv lw iu bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">使用子模块添加子Git存储库</h1><p id="5ebb" class="pw-post-body-paragraph kc kd iu ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz in bi translated">请记住，Git子模块是对另一个Git存储库的引用。该引用存储在父存储库中。</p><p id="923b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">要将Git子模块引用添加到父Git存储库，请使用以下命令:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="e354" class="nl lw iu nc b gz nm nn l no np">$ git submodule add GIT-URL-FOR-REPOSITORY path/to/submodule</span></pre><p id="e0aa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">GIT-URL可以是本地文件系统引用，或者GIT支持的任何其他URL。典型的选择是在HTTPS和SSH URLs之间。</p><p id="3d17" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe mz na nb nc b">path/to/submodule</code>是可选的，指定子模块将要登陆的目录。如果省略，则选择URL的<em class="ld">规范</em>部分。例如，如果URL是<code class="fe mz na nb nc b">git@github.com:akashacms/akashacms-external-links.git</code>，那么默认的模块目录名是<code class="fe mz na nb nc b">akashacms-external-links</code>。指定<code class="fe mz na nb nc b">path/to/module</code>会用您喜欢的任何目录名覆盖缺省值。</p><p id="1427" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了在实践中使用这个特性，让我们在GitHub、GitLab或您喜欢的Git服务上创建一对存储库。创建一个<code class="fe mz na nb nc b">parent</code>和另一个<code class="fe mz na nb nc b">child</code>。这将有助于您初始化每个自述文件。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="2776" class="nl lw iu nc b gz nm nn l no np">$ git clone git@github.com:robogeek/parent.git<br/>Cloning into 'parent'... <br/>... <br/>$ cd parent <br/>$ git checkout -b main <br/>$ touch main.html <br/>$ git add . <br/>$ git commit -a -m 'Initial revision' <br/>$ git push<br/>...</span></pre><p id="9769" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">从父存储库开始。为您创建的存储库使用正确的URL。注意，我使用了SSH URL，因为这是能够将更改推送到存储库的最简单的方法。我们还确保有一个名为<code class="fe mz na nb nc b">main</code>的分支，以及一个提交到存储库的文件，并且该文件被推送到存储库。最后几个步骤确保存储库中至少有一个文件，并且主分支被命名为<code class="fe mz na nb nc b">main</code>。</p><p id="9cc4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">对于子存储库，在同级目录中执行相同的步骤。在子存储库中，不要创建<code class="fe mz na nb nc b">main.html</code>，而是创建<code class="fe mz na nb nc b">child.html</code>，这样我们就可以快速区分它们。这为我们提供了两个存储库，每个存储库中都有一些文件。</p><p id="8dcb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">接下来，将您的目录更改为<code class="fe mz na nb nc b">parent</code>目录，并运行以下命令:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="f6aa" class="nl lw iu nc b gz nm nn l no np">$ cd ../parent <br/>$ git submodule add git@github.com:robogeek/child.git</span></pre><p id="0aef" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将向父存储库添加一个新的子模块。子模块引用指定URL处的存储库。注意，我再次使用了SSH URL，您应该为您的子存储库使用正确的URL。我们稍后将讨论为什么这里使用SSH URLs，以及何时应该使用HTTPS URL。</p><p id="f4e6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">该命令创建一个名为<code class="fe mz na nb nc b">.gitmodules</code>的文件。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="83f0" class="nl lw iu nc b gz nm nn l no np">$ cat .gitmodules <br/>[submodule "child"]<br/>   path = child<br/>   url = git@github.com:robogeek/child.git</span></pre><p id="f359" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">您将看到这是一个简单的数据文件，给出了添加的子模块的详细信息。<code class="fe mz na nb nc b">.git/config</code>支持子模块中也有条目。创建了一个目录<code class="fe mz na nb nc b">child</code>，该目录中包含了该存储库的内容。</p><p id="1f3b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以检查状态:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="2a01" class="nl lw iu nc b gz nm nn l no np">$ git submodule status<br/> a7192d1b027f624fe250aa53a746b194f88ec72b child (heads/main)</span></pre><p id="0476" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">第一部分是子模块的当前签出提交的SHA-1。第二部分是模块的路径。记住这个SHA-1标识符，因为我们会在后面的例子中多次看到它。</p><p id="beef" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">需要注意的最后一件有趣的事情是在<code class="fe mz na nb nc b">.git/modules</code>中，您会发现一个新目录<code class="fe mz na nb nc b">child</code>。进入该目录，您会发现它是<code class="fe mz na nb nc b">child</code> Git库的克隆。运行<code class="fe mz na nb nc b">git log</code>，你会发现这个库的头就是刚才显示的提交。</p><h1 id="939d" class="lv lw iu bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">将Git子模块配置提交到存储库</h1><p id="b108" class="pw-post-body-paragraph kc kd iu ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz in bi translated">我们创建了一个父存储库，子存储库作为子模块。我们可以多次重复这个过程，引入其他子模块库。但是，现在怎么办？特别是，我们如何与团队的其他成员共享这个子模块配置？</p><p id="5198" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe mz na nb nc b">git submodule</code>命令将子模块的数据记录在一个名为<code class="fe mz na nb nc b">.gitmodules</code>的文件中。这个文件需要被添加到您的工作空间，以及由<code class="fe mz na nb nc b">git status -s</code>命令列出的其他文件。<code class="fe mz na nb nc b">.gitmodules</code>和<code class="fe mz na nb nc b">child</code>的状态都处于<code class="fe mz na nb nc b">A</code>状态，这意味着它们是新添加的。</p><p id="8557" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这意味着这两个文件已经准备好提交并推送到父存储库。这正是将子模块配置共享给原始存储库，并从那里与其他团队成员共享所需要的。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="3f42" class="nl lw iu nc b gz nm nn l no np">$ git commit -a -m 'Add submodule' <br/>$ git push<br/>...</span></pre><p id="93b8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将添加文件<code class="fe mz na nb nc b">.gitmodules</code>和<code class="fe mz na nb nc b">child</code>，并将它们推送到存储库。回到您的浏览器并检查<code class="fe mz na nb nc b">parent</code>库。您会发现有一个<code class="fe mz na nb nc b">.gitmodules</code>文件和一个名为<code class="fe mz na nb nc b">child</code>的目录。但是，与Git存储库中的常规目录不同，它看起来像这样:</p><figure class="nd ne nf ng gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj nq"><img src="../Images/71897d300c995c415074964c6a9eab93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZKZho9dtobZZ0AWQ.jpg"/></div></div></figure><p id="e0c3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">注意，它显示的是<code class="fe mz na nb nc b">@ a7192d1</code>。这个十六进制字符串是<code class="fe mz na nb nc b">child</code>存储库中提交的SHA-1代码。请注意，该代码与前面显示的SHA-1的前导数字相匹配。它表示<code class="fe mz na nb nc b">child</code>目录实际上是对<code class="fe mz na nb nc b">child</code>存储库中特定提交的引用。</p><h1 id="0469" class="lv lw iu bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">克隆包含子模块的Git存储库</h1><p id="8efa" class="pw-post-body-paragraph kc kd iu ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz in bi translated">我们已经向我们的存储库添加了一个子模块，并将子模块配置共享给Git服务器。我们的开发伙伴应该能够克隆存储库并准备好，对吗？抱歉，没有。</p><p id="75ae" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">要查看这一点，请尝试以下命令:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="9e44" class="nl lw iu nc b gz nm nn l no np">$ git clone git@github.com:robogeek/parent.git parent2 ... <br/>$ cd parent2 <br/>$ ls<br/>child    main.html<br/>$ ls child</span></pre><p id="93b1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">也就是说，将存储库克隆为一个新名称，以模仿同事克隆存储库。您会发现主存储库中的文件被检出，但不是针对<code class="fe mz na nb nc b">child</code>存储库的。</p><p id="910b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">最简单的解决方法是，在执行初始<code class="fe mz na nb nc b">git clone</code>时添加这个选项，<code class="fe mz na nb nc b"> --recurse-submodules</code>，像这样:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="151a" class="nl lw iu nc b gz nm nn l no np">$ git clone --recurse-submodules git@github.com:robogeek/parent.git parent3 <br/>Cloning into 'parent3'... <br/>remote: Enumerating objects: 6, done. <br/>remote: Counting objects: 100% (6/6), done. <br/>remote: Compressing objects: 100% (4/4), done. <br/>Receiving objects: 100% (6/6), done. <br/>remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0 <br/>Submodule 'child' (git@github.com:robogeek/child.git) registered for path 'child' <br/>Cloning into '/Volumes/Extra/akasharender/t/parent3/child'... <br/>remote: Enumerating objects: 3, done.         <br/>remote: Counting objects: 100% (3/3), done.         <br/>remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0         <br/>Receiving objects: 100% (3/3), done. <br/>Submodule path 'child': checked out 'a7192d1b027f624fe250aa53a746b194f88ec72b'</span></pre><p id="0783" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这次<code class="fe mz na nb nc b">git clone</code>消息谈到了检查子模块。签入<code class="fe mz na nb nc b">parent3/child</code>，您会看到文件在那里，注意这里显示的SHA-1代码仍然与我们之前看到的相匹配。</p><p id="281c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">注意这个命令被克隆到了<code class="fe mz na nb nc b">parent3</code>中。因此，<code class="fe mz na nb nc b">parent2</code>目录与我们离开时一样。有了它，我们可以考虑另一个场景，在这个场景中，您有一个工作区的现有克隆，并且需要更新它以包含已经添加的新的子模块。换句话说，如何在不重新运行<code class="fe mz na nb nc b">git clone</code>的情况下更新现有存储库中的子模块？</p><p id="edf5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了找到答案，让我们进入<code class="fe mz na nb nc b">parent2</code>(没有更新)并运行一个命令。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="263c" class="nl lw iu nc b gz nm nn l no np">$ cd ../parent2 <br/>$ git submodule update --init --recursive child <br/>Submodule 'child' (git@github.com:robogeek/child.git) registered for path 'child' <br/>Cloning into '/Volumes/Extra/akasharender/t/parent2/child'... <br/>Submodule path 'child': checked out 'a7192d1b027f624fe250aa53a746b194f88ec72b'</span></pre><p id="6611" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是一种方法，使用带有这两个选项的<code class="fe mz na nb nc b">submodule update</code>命令。最后一个参数是子模块的路径。如果未指定子模块路径，则<code class="fe mz na nb nc b">update</code>操作将为每个子模块运行。</p><p id="8f6b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是，那两个命令行选项呢？第一个是<code class="fe mz na nb nc b">--init</code>，确保子模块已经正确初始化。第二个是<code class="fe mz na nb nc b">--recursive</code>，确保检查所有子模块，包括子模块的子模块。</p><p id="bae2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这两个选项是分别运行这两个命令的简写:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="be3a" class="nl lw iu nc b gz nm nn l no np">$ git submodule init<br/>...<br/>$ git submodule update --recursive<br/>...</span></pre><p id="1eba" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe mz na nb nc b">submodule update</code>导致注册的子模块被更新以匹配父存储库中的期望。它通过克隆任何缺失的子模块并检查与SHA-1提交散列相关的文件来实现这一点。</p><h1 id="099e" class="lv lw iu bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">子模块中HTTPS和SSH URLs的区别</h1><p id="0238" class="pw-post-body-paragraph kc kd iu ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz in bi translated">到目前为止，我们已经对子模块库使用了SSH URLs。这种URL需要对存储库的用户进行更多的身份验证。SSH URLs的用户必须向远程Git服务器注册他们的SSH密钥，否则他们会得到错误消息。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="2018" class="nl lw iu nc b gz nm nn l no np">$ git clone git@github.com:robogeek/parent.git <br/>Cloning into 'parent'... <br/>Could not create directory '/var/lib/jenkins/.ssh'. <br/>The authenticity of host 'github.com (192.30.255.113)' can't be established. <br/>ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM. <br/>Are you sure you want to continue connecting (yes/no/[fingerprint])? yes <br/>Failed to add the host to the list of known hosts (/var/lib/jenkins/.ssh/known_hosts). <br/>git@github.com: Permission denied (publickey). <br/>fatal: Could not read from remote repository.  </span><span id="032f" class="nl lw iu nc b gz nr nn l no np">Please make sure you have the correct access rights and the repository exists.</span></pre><p id="e6ce" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是由一个没有SSH密钥的用户ID执行的，并且肯定没有在Git服务器上注册。这意味着它不存在的SSH密钥不能被验证，并且通常禁止该用户ID克隆存储库。这就是信息向我们展示的。</p><p id="c2f3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">您的存储库可能只支持拥有SSH身份验证的开发人员，以及将变更提交到存储库的开发人员。如果是这样，要求SSH密钥认证是合适的。</p><p id="33f8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是如果要与公众共享存储库，而公众显然还没有向您的存储库注册他们的SSH密钥，那么您必须使用一个不同的Git URL，它允许未经认证的克隆。最简单的是使用HTTPS网址。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="979c" class="nl lw iu nc b gz nm nn l no np">$ git clone https://github.com/robogeek/parent.git <br/>Cloning into 'parent'... <br/>remote: Enumerating objects: 6, done. <br/>remote: Counting objects: 100% (6/6), done. <br/>remote: Compressing objects: 100% (4/4), done. <br/>remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0 <br/>Unpacking objects: 100% (6/6), 546 bytes | 182.00 KiB/s, done. <br/>$ cd parent/ <br/>$ ls <br/>child  main.html <br/>$ ls child/</span></pre><p id="c09f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是，子模块没有被检出。如果我们尝试更新子模块:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="c06f" class="nl lw iu nc b gz nm nn l no np">$ git submodule update --init --recursive child <br/>... <br/>git@github.com: Permission denied (publickey). <br/>fatal: Could not read from remote repository. <br/>...</span></pre><p id="7e49" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们得到和以前一样的错误信息。问题在于子模块配置中使用的SSH URL。</p><p id="2c65" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有些库，比如<code class="fe mz na nb nc b">akashacms/akashacms-website</code>，必须对任何人开放，以便在没有预先设置的情况下克隆这个库。因此，这类网站的子模块需要HTTPS URL。</p><p id="97bd" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果子模块是这样设置的:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="41c0" class="nl lw iu nc b gz nm nn l no np">$ git submodule add <a class="ae my" href="https://github.com/robogeek/child.git" rel="noopener ugc nofollow" target="_blank">https://github.com/robogeek/child.git</a></span></pre><p id="6c85" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后子模块配置改为具有HTTPS URL，并且<code class="fe mz na nb nc b">submodule update</code>命令将正确执行。但是如果你想把提交从<code class="fe mz na nb nc b">child</code>库推到它的源头，这就产生了一个不同的问题。</p><p id="269c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当然，将提交推送到Git存储库需要认证。对于SSH URL，身份验证是SSH密钥。使用HTTPS URL时，身份验证通过其他方式处理。</p><p id="b20c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在过去的GitHub时代，我们会被提示输入用户名和密码，然后就万事大吉了。但是，安全需求决定了变革。今天，如果我们尝试这样做，我们会发现在2021年8月13日，GitHub取消了对HTTPS网址密码认证的支持。发布公告的<a class="ae my" href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/" rel="noopener ugc nofollow" target="_blank">博客帖子</a>说我们应该使用<em class="ld">个人访问令牌</em>来代替。做这件事的<a class="ae my" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token" rel="noopener ugc nofollow" target="_blank">文档很简单</a>。</p><p id="6d5c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">幸运的是，获得这个令牌很容易，并且有很好的文档记录。一旦我们生成了个人访问令牌，这就起作用了。文档显示，令牌可以用来代替使用HTTPS URL时要求的密码。我们还被指示给令牌一个时间限制和有限的访问权限。</p><h1 id="34c1" class="lv lw iu bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">如何将子模块中的变更推送到它的存储库中</h1><p id="b672" class="pw-post-body-paragraph kc kd iu ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz in bi translated">我们刚刚讨论了将提交推送到子模块仓库，但没有讨论如何做。愚蠢的我们，超越了自己。</p><p id="fb53" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在一个正确克隆的<code class="fe mz na nb nc b">parent</code>存储库中，其中的<code class="fe mz na nb nc b">child</code>存储库被正确检出，键入以下命令:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="4011" class="nl lw iu nc b gz nm nn l no np">$ cd child <br/>$ touch about.html <br/>$ git add . <br/>$ git commit -a -m 'Add about page' <br/>$ git push <br/>fatal: You are not currently on a branch. <br/>To push the history leading to the current (detached HEAD) state now, use</span><span id="89fd" class="nl lw iu nc b gz nr nn l no np">    git push origin HEAD:&lt;name-of-remote-branch&gt;</span></pre><p id="8d3e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">最后一个失败了，给出了一个有点难以理解的信息。此消息告诉您子模块存储库处于分离状态。事实上，它没有当前签出的分支。</p><p id="b205" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了了解如何解决这个问题，让我们从一个新签出的存储库开始。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="2dc0" class="nl lw iu nc b gz nm nn l no np">$ git clone --recurse-submodules git@github.com:robogeek/parent.git parent5</span></pre><p id="ecd8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将建立一个新的存储库克隆，所有子模块都被检出。</p><p id="8bcd" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">试试这个:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="d138" class="nl lw iu nc b gz nm nn l no np">$ cd parent5/child <br/>$ git pull <br/>You are not currently on a branch.</span></pre><p id="0984" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这确认了新初始化的存储库不在分支上，并且处于分离的head状态。在GitHub/GitLab/etc存储库中，确定主分支的名称。这可能是<code class="fe mz na nb nc b">main</code>或<code class="fe mz na nb nc b">master</code>或别的什么。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="5037" class="nl lw iu nc b gz nm nn l no np">$ git checkout main <br/>Previous HEAD position was a7192d1 Initial revision <br/>Switched to branch 'main' <br/>Your branch is up to date with 'origin/main'.</span></pre><p id="dddf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们已经签出了<code class="fe mz na nb nc b">main</code>分支，它与GitHub存储库上的主分支相同。这更新了存储库的头，并表明它与<code class="fe mz na nb nc b">origin/main</code>一致。一切都好。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="31ad" class="nl lw iu nc b gz nm nn l no np">$ touch news.html <br/>$ git add . <br/>$ git commit -a -m 'Add news page' <br/>[main 6a1f930] Add news page <br/> 1 file changed, 0 insertions(+), 0 deletions(-)<br/> create mode 100644 news.html <br/>$ git push <br/>Enumerating objects: 3, done. <br/>Counting objects: 100% (3/3), done. <br/>Delta compression using up to 4 threads <br/>Compressing objects: 100% (2/2), done. <br/>Writing objects: 100% (2/2), 254 bytes | 254.00 KiB/s, done. <br/>Total 2 (delta 0), reused 0 (delta 0), pack-reused 0 <br/>To github.com:robogeek/child.git<br/>    001f8e0..6a1f930  main -&gt; main</span></pre><p id="db4d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们继续添加我们的新文件，我们可以简单地使用<code class="fe mz na nb nc b">git push</code>将更改发送到GitHub服务器。</p><h1 id="a093" class="lv lw iu bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">如果子模块的存储库已经更改，如何更新子模块</h1><p id="a208" class="pw-post-body-paragraph kc kd iu ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz in bi translated">在上一节中，我们将提交推送到子模块。难道我们不应该能够对存储库进行新的克隆，并看到这种变化吗？</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="6d21" class="nl lw iu nc b gz nm nn l no np">$ git clone  --recurse-submodules  \<br/>           git@github.com:robogeek/parent.git parent6<br/>... <br/>$ cd parent6/child <br/>$ ls <br/>child.html</span></pre><p id="920d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">好吧，那没有像预期的那样起作用。我们期望<code class="fe mz na nb nc b">parent6/child</code>包含我们在上一步中推送到<code class="fe mz na nb nc b">child</code>存储库的文件。怎么了？这与父存储库中记录的SHA-1提交有关。如果您查看GitHub上的<code class="fe mz na nb nc b">parent</code>库，您会发现提交散列并没有改变。请记住，当我们克隆存储库时，子模块是相对于SHA-1提交散列来检出的。</p><p id="1b81" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">解决方法是在<code class="fe mz na nb nc b">parent</code>存储库中运行这个命令:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="d404" class="nl lw iu nc b gz nm nn l no np">$ cd .. <br/>$ git submodule update --recursive --remote <br/>Submodule path 'child': checked out '6a1f93010a657c3453ea82b9d69d41462402638c' <br/>$ ls child/ <br/>about.html child.html news.html</span></pre><p id="02da" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在<code class="fe mz na nb nc b">child</code>存储库被更新为其存储库中的最新提交。请注意，SHA-1已经发生了变化。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="2c07" class="nl lw iu nc b gz nm nn l no np">$ git status -s<br/>  M child</span></pre><p id="b103" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">此外，我们在<code class="fe mz na nb nc b">parent</code>存储库中提交了一个变更，这是更新后的SHA-1提交散列。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="37a1" class="nl lw iu nc b gz nm nn l no np">$ git commit -a -m 'Update submodule references' <br/>[main 1356324] Update submodule references <br/> 1 file changed, 1 insertion(+), 1 deletion(-) <br/>$ git push <br/>Enumerating objects: 3, done. <br/>Counting objects: 100% (3/3), done. <br/>Delta compression using up to 4 threads <br/>Compressing objects: 100% (2/2), done. <br/>Writing objects: 100% (2/2), 314 bytes | 314.00 KiB/s, done. <br/>Total 2 (delta 0), reused 0 (delta 0), pack-reused 0 <br/>To github.com:robogeek/parent.git<br/>    b5c3802..1356324  main -&gt; main</span></pre><p id="9558" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将更新GitHub存储库。让我们验证我们现在可以正确地克隆存储库了:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="aefb" class="nl lw iu nc b gz nm nn l no np">$ git clone --recurse-submodules git@github.com:robogeek/parent.git parent7 <br/>Cloning into 'parent7'... <br/>... <br/>$ ls parent7/child/ <br/>about.html child.html news.html</span></pre><p id="3ee1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">事实上，这是正确的检查。</p><h1 id="78fb" class="lv lw iu bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">从Git储存库中删除子模块配置</h1><p id="6bf5" class="pw-post-body-paragraph kc kd iu ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz in bi translated">对于要学习的最后一个任务，我们可能已经决定子模块比我们想要处理的要复杂得多。或者可能有删除子模块配置的其他原因。</p><p id="01f7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">无论您的理由是什么，让我们学习如何从Git存储库中删除子模块，然后将更改提交给GitHub存储库。</p><p id="5e86" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们应该从检查存储子模块配置的跟踪开始:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="6b8e" class="nl lw iu nc b gz nm nn l no np">$ cat .gitmodules  <br/>[submodule "child"]<br/>     path = child<br/>     url = git@github.com:robogeek/child.git</span><span id="373d" class="nl lw iu nc b gz nr nn l no np">$ cat .git/config<br/>[core]<br/>     ...<br/>[submodule]<br/>     active = .<br/>[remote "origin"]<br/>     url = git@github.com:robogeek/parent.git<br/>     fetch = +refs/heads/*:refs/remotes/origin/*<br/>[branch "main"]<br/>     remote = origin<br/>     merge = refs/heads/main<br/>[submodule "child"]<br/>     url = git@github.com:robogeek/child.git</span><span id="52c4" class="nl lw iu nc b gz nr nn l no np">$ ls .git/modules/<br/>child</span></pre><p id="6d93" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这里有三个东西，<code class="fe mz na nb nc b">.gitmodules</code>文件，<code class="fe mz na nb nc b">.git/config</code>文件，以及<code class="fe mz na nb nc b">.git/modules</code>中的一个目录。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="41ec" class="nl lw iu nc b gz nm nn l no np">$ git submodule deinit child <br/>Cleared directory 'child' <br/>Submodule 'child' (git@github.com:robogeek/child.git) unregistered for path 'child'</span></pre><p id="9148" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将从<code class="fe mz na nb nc b">.git/config</code>中删除条目，并以其他方式确保<code class="fe mz na nb nc b">git submodule init</code>和其他命令不会作用于子节点。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="ceae" class="nl lw iu nc b gz nm nn l no np">$ git rm child/ <br/>rm 'child'</span></pre><p id="68c4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将删除包含子模块的目录，并删除<code class="fe mz na nb nc b">.gitmodules</code>中的条目。</p><p id="e8c4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">此时<code class="fe mz na nb nc b">.git/modules/child</code>仍然存在:</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="c50c" class="nl lw iu nc b gz nm nn l no np">$ rm -rf .git/modules/child/</span></pre><p id="873a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是删除目录的老方法。不清楚为什么其他命令没有删除它。</p><pre class="nd ne nf ng gu nh nc ni nj aw nk bi"><span id="5fab" class="nl lw iu nc b gz nm nn l no np">$ git status -s <br/>M  .gitmodules <br/>D  child  </span><span id="f9d5" class="nl lw iu nc b gz nr nn l no np">$ git commit -a -m 'Remove child submodule' <br/>[main 48380f1] <br/>Remove child submodule  2 files changed, 4 deletions(-)  <br/>delete mode 160000 child  <br/>$ git push <br/>Enumerating objects: 3, done. <br/>Counting objects: 100% (3/3), done. <br/>Delta compression using up to 4 threads <br/>Compressing objects: 100% (2/2), done. <br/>Writing objects: 100% (2/2), 258 bytes | 258.00 KiB/s, done. <br/>Total 2 (delta 0), reused 0 (delta 0), pack-reused 0 <br/>To github.com:robogeek/parent.git<br/>    1356324..48380f1  main -&gt; main</span></pre><p id="af07" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们要提交更改。我们提交这些变更，并将它们推送到存储库。而且，如果你去GitHub你会发现子模块参考不见了。</p><h1 id="4209" class="lv lw iu bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">摘要</h1><p id="da03" class="pw-post-body-paragraph kc kd iu ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz in bi translated">我们已经了解了Git的一个重要部分，我们大多数人都不会使用它。使用子模块，我们可以将一个存储库的内容嵌入到另一个存储库中。</p><p id="f1b0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这样做有几个可能的原因，我们前面讨论过。它是一个潜在的强大工具，但是像许多强大的工具一样，必须小心使用。</p><p id="2c73" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">自动化管理流程总是最好的。在这种情况下，所需要的只是shell脚本(或类似的东西)。过程越复杂，自动化就越重要，以减少你在一系列晦涩难懂的命令中忘记一两步的可能性。</p><p id="8c9d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">以下是一些有用的参考资料:</p><ul class=""><li id="f5dc" class="lh li iu ke b kf kg kj kk kn lj kr lk kv ll kz ns ln lo lp bi translated"><a class="ae my" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/book/en/v2/Git-Tools-Submodules</a></li><li id="81ad" class="lh li iu ke b kf lq kj lr kn ls kr lt kv lu kz ns ln lo lp bi translated"><a class="ae my" href="https://chrisjean.com/git-submodules-adding-using-removing-and-updating/" rel="noopener ugc nofollow" target="_blank">https://Chris jean . com/git-sub modules-添加-使用-移除-更新/ </a></li><li id="cd39" class="lh li iu ke b kf lq kj lr kn ls kr lt kv lu kz ns ln lo lp bi translated"><a class="ae my" href="https://github.blog/2016-02-01-working-with-submodules/" rel="noopener ugc nofollow" target="_blank">https://github.blog/2016-02-01-working-with-submodules/</a></li><li id="9172" class="lh li iu ke b kf lq kj lr kn ls kr lt kv lu kz ns ln lo lp bi translated"><a class="ae my" href="https://gist.github.com/gitaarik/8735255" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/gitaarik/8735255</a></li></ul><h1 id="d56d" class="lv lw iu bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">关于作者</h1><p id="bf48" class="pw-post-body-paragraph kc kd iu ke b kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz in bi translated"><a class="ae my" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ke iv"> <em class="ld">大卫·赫伦</em> </strong> </a> <em class="ld">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl nt nu hy nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="in io ip iq ir"><p id="d1ab" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><em class="ld">原载于</em><a class="ae my" href="https://techsparx.com/software-development/git/submodules.html" rel="noopener ugc nofollow" target="_blank"><em class="ld">https://techsparx.com</em></a><em class="ld">。</em></p></div></div>    
</body>
</html>