<html>
<head>
<title>Redis Streams in Action — Part 4 (Serverless Monitoring service)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis Streams在运行—第4部分(无服务器监控服务)</h1>
<blockquote>原文：<a href="https://itnext.io/redis-streams-in-action-part-4-serverless-monitoring-service-faef52ee58db?source=collection_archive---------4-----------------------#2021-06-30">https://itnext.io/redis-streams-in-action-part-4-serverless-monitoring-service-faef52ee58db?source=collection_archive---------4-----------------------#2021-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="99af" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">最后，构建一个无服务器的Go应用程序来监控Tweets处理器应用程序</h2></div><p id="c11a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎阅读这一系列的博客文章，这些文章通过一个实际的例子介绍了Redis流。我们将使用一个示例应用程序来实时搜索和查询Twitter数据。<a class="ae lb" href="https://redisearch.io/" rel="noopener ugc nofollow" target="_blank"> RediSearch </a>和<a class="ae lb" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank"> Redis Streams </a>是这个解决方案的主干，它由几个合作组件组成，我们将在一篇专门的博客文章中介绍每一个组件。</p><ul class=""><li id="5670" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-1-intro-and-overview-135f66d3ab58">第一部分</a></li><li id="5d7c" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-2-tweets-consumer-app-674fd3b45f6f">第二部分</a></li><li id="4b62" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-3-tweets-processor-app-254161838973">第三部分</a></li><li id="6a48" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">第4部分—本博客</li></ul><blockquote class="lq lr ls"><p id="7097" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">本GitHub回购中有代码—</em><a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://github.com/abhirockzz/redis-streams-in-action</em></a></p></blockquote><p id="e94a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从上一篇博客文章停止的地方继续，看看如何构建一个监控应用程序，使整个系统在面对高负载或故障场景时更加健壮。这是因为我们的数据处理应用程序经常会因为数据量过大而变慢，甚至会因为我们无法控制的情况而崩溃/停止。如果我们的Tweets处理应用程序出现这种情况，分配给特定实例的消息将不会被处理。这篇博文中提到的监控组件检查未决推文(使用<code class="fe lx ly lz ma b">XPENDING</code>)、声明(<code class="fe lx ly lz ma b">XCLAIM</code>)、处理(使用<code class="fe lx ly lz ma b">HSET</code>将它们存储为<code class="fe lx ly lz ma b">HASH</code>)并最终确认它们(<code class="fe lx ly lz ma b">XACK</code>)。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/beba8a71bd3cff2bd6ef4079155f2e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JPM9FFQd731xRb3t.jpg"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">高层建筑</figcaption></figure><p id="8641" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个将部署到Azure Functions的Go应用程序——是的，我们将使用无服务器模型，其中监控系统将基于预定义的计时器触发器执行。像往常一样，我们将首先配置它并将其部署到Azure，观察它的工作情况，最后遍历代码。</p><p id="68a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们继续之前，这里有一些关于Azure函数中Go支持的背景。</p><h1 id="8e07" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">多亏了自定义处理程序，Azure上的无服务器Go应用程序</h1><p id="a008" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">那些使用过Azure函数的人可能还记得Go是默认支持的语言处理程序之一。这就是<a class="ae lb" href="https://docs.microsoft.com/azure/azure-functions/functions-custom-handlers?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank">定制处理程序</a>发挥作用的地方。</p><p id="963a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，自定义处理程序是一个轻量级web服务器，它从函数主机接收事件。在您最喜欢的运行时/语言中，您唯一需要实现的定制处理程序是— HTTP支持！</p><p id="c487" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事件触发器(通过HTTP、存储、事件中心等。)调用函数主机。定制处理程序与传统函数的不同之处在于，函数主机充当中间人:它向定制处理程序(函数)的web服务器发出请求有效负载，以及包含触发器、输入绑定数据和函数的其他元数据的<em class="lt">有效负载</em>。函数将响应返回给函数宿主，宿主将响应中的数据传递给函数的输出绑定进行处理。</p><p id="a7f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是自定义处理程序如何工作的概要(下图摘自文档)</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi no"><img src="../Images/905063043618df3de8c7d4af738482e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_ynU0FZU2V52koGo.png"/></div></div></figure><p id="90e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在让我们转到实际的部分。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="5107" class="mr ms iq bd mt mu nw mw mx my nx na nb jw ny jx nd jz nz ka nf kc oa kd nh ni bi translated">先决条件</h1><p id="f9e7" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">请务必阅读本系列的第2、3部分，并启动和运行相应的应用程序。我们的监控应用程序将构建在您部署的Tweets生产者和处理器服务之上。</p><p id="aa89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你需要一个Azure账户<a class="ae lb" href="https://dev.to/abhirockzz/(https://azure.microsoft.com/free/?WT.mc_id=data-17927-abhishgu)" rel="noopener ugc nofollow" target="_blank">，你可以免费获得</a>和<a class="ae lb" href="https://docs.microsoft.com/cli/azure/install-azure-cli?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure CLI </a>。确保<a class="ae lb" href="https://golang.org/dl/" rel="noopener ugc nofollow" target="_blank">下载并安装Go </a>(如果你还没有的话)并安装<a class="ae lb" href="https://docs.microsoft.com/azure/azure-functions/functions-run-local?tabs=macos%2Ccsharp%2Cbash&amp;WT.mc_id=data-17927-abhishgu#v2" rel="noopener ugc nofollow" target="_blank"> Azure functions核心工具</a>——这将允许你使用CLI部署该功能(并在本地运行测试和调试)</p><p id="0fa1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来的章节将指导你如何部署和配置Azure功能。</p><h1 id="681f" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">将监控服务部署到Azure功能</h1><p id="8985" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">您将:</p><ul class=""><li id="8c97" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">创建Azure Functions应用程序</li><li id="7bac" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">配置它</li><li id="3b41" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">将该功能部署到您创建的应用程序</li></ul><p id="0e1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先创建一个<a class="ae lb" href="https://docs.microsoft.com/azure/azure-resource-manager/management/manage-resource-groups-portal?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank">资源组</a>来托管解决方案的所有组件。</p><p id="c796" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Azure门户中搜索<strong class="kh ir">功能App </strong>，点击<strong class="kh ir">添加</strong></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ob"><img src="../Images/bdb2973a1af18460ddf69d5ffba87f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QZOQ5R2kT5541LlX.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">添加新的功能应用程序</figcaption></figure><p id="c991" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入所需的详细信息:您应该选择<strong class="kh ir">自定义处理程序</strong>作为<strong class="kh ir">运行时堆栈</strong></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ob"><img src="../Images/0e449184309c762c0f47a84bb677dbfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5yAZ1e3DpBCHFme6.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">输入功能应用信息</figcaption></figure><p id="7c2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kh ir">托管</strong>部分，分别为<strong class="kh ir">操作系统</strong>和<strong class="kh ir">计划类型</strong>选择<strong class="kh ir"> Linux </strong>和<strong class="kh ir">消费(无服务器)</strong>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ob"><img src="../Images/d850da21123eda8b7c0872728d1b816b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kyGiy3tjIV9szQn5.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">选择操作系统、计划等。</figcaption></figure><ul class=""><li id="4bad" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">启用应用洞察(如果需要)</li></ul><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ob"><img src="../Images/4c820116fa1048f30b9a067cd43768d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rjuGPXRA0BUpMq3b.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">启用应用洞察</figcaption></figure><ul class=""><li id="70a1" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">查看最终设置并点击<strong class="kh ir">创建</strong>继续</li></ul><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ob"><img src="../Images/f5d146e785860484f28026a942cf9eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JSjZyGDaZN6PFPEL.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">启动创建</figcaption></figure><p id="f105" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该过程完成后，还将创建以下资源和功能应用程序:</p><ul class=""><li id="636a" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" href="https://docs.microsoft.com/azure/app-service/overview-hosting-plans?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank"> App服务计划</a>(本例为消费/无服务器计划)</li><li id="dc06" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">一个<a class="ae lb" href="https://docs.microsoft.com/azure/storage/common/storage-account-overview?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure存储帐户</a></li><li id="8c9b" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">一个<a class="ae lb" href="https://docs.microsoft.com/azure/azure-monitor/app/app-insights-overview?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure应用洞察</a>功能)</li></ul><h2 id="f4eb" class="oc ms iq bd mt od oe dn mx of og dp nb ko oh oi nd ks oj ok nf kw ol om nh on bi translated">更新功能应用程序配置</h2><p id="6228" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">我们的函数需要一些环境变量才能正常工作——这些变量可以使用Azure portal作为函数配置添加。以下是清单:</p><p id="7aab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Redis连接详细信息:</p><ul class=""><li id="d088" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><code class="fe lx ly lz ma b">REDIS_HOST</code>-Redis实例的主机和端口，例如myredis:10000</li><li id="badd" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><code class="fe lx ly lz ma b">REDIS_PASSWORD</code>-Redis实例的访问密钥(密码)</li></ul><p id="f989" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Redis流信息:</p><ul class=""><li id="99ee" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><code class="fe lx ly lz ma b">STREAM_NAME</code>-Redis流的名称(使用<code class="fe lx ly lz ma b">tweets_stream</code>作为值)</li><li id="6886" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><code class="fe lx ly lz ma b">STREAM_CONSUMER_GROUP_NAME</code>-Redis Streams消费群的名称(使用<code class="fe lx ly lz ma b">redisearch_app_group</code>作为值)</li></ul><p id="7cf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">监控应用程序元数据:</p><ul class=""><li id="a56f" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><code class="fe lx ly lz ma b">MONITORING_CONSUMER_NAME</code> -监控应用程序所代表的消费者实例的名称(它是上述消费者组的一部分)</li><li id="7894" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><code class="fe lx ly lz ma b">MIN_IDLE_TIME_SEC</code> -仅声明早于指定时间间隔的待处理消息</li></ul><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ob"><img src="../Images/75b11946e854c4e565172e819440ef3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gTZ2pDBFg64DYAdu.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">更新应用配置</figcaption></figure><h2 id="c89f" class="oc ms iq bd mt od oe dn mx of og dp nb ko oh oi nd ks oj ok nf kw ol om nh on bi translated">我们现在已经准备好部署这个功能了</h2><p id="6a77" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">首先，克隆GitHub repo并构建函数:</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="e683" class="oc ms iq ma b gy os ot l ou ov">git clone https://github.com/abhirockzz/redis-streams-in-action<br/>cd redis-streams-in-action/monitoring-app</span><span id="6e53" class="oc ms iq ma b gy ow ot l ou ov">GOOS=linux go build -o processor_monitor cmd/main.go</span></pre><blockquote class="lq lr ls"><p id="69bb" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><code class="fe lx ly lz ma b"><em class="iq">GOOS=linux</em></code> <em class="iq">用于构建</em> <code class="fe lx ly lz ma b"><em class="iq">Linux</em></code> <em class="iq">可执行既然我们选择了</em> <code class="fe lx ly lz ma b"><em class="iq">Linux</em></code> <em class="iq"> OS为我们的功能App </em></p></blockquote><p id="beee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要进行部署，请使用Azure Functions核心工具CLI:</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="6795" class="oc ms iq ma b gy os ot l ou ov">func azure functionapp publish &lt;enter name of the Azure Function app&gt;</span></pre><p id="f751" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，您应该会看到以下日志:</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="4667" class="oc ms iq ma b gy os ot l ou ov">Getting site publishing info...<br/>Uploading package...<br/>Uploading 3.71 MB [###############################################################################]<br/>Upload completed successfully.<br/>Deployment completed successfully.<br/>Syncing triggers...<br/>Functions in streams-monitor:<br/>    monitor - [timerTrigger]</span></pre><p id="1889" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该也能在Azure门户中看到该功能:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ob"><img src="../Images/65356999ca21431104c5e7c37eea9a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uawz6K3yDF91YCm-.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">作为Azure功能部署的监控应用程序</figcaption></figure><p id="1e11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该功能配置为每<code class="fe lx ly lz ma b">20</code>秒触发一次(根据<a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action/blob/master/monitoring-app/monitor/function.json" rel="noopener ugc nofollow" target="_blank"> function.json </a>):</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="59b5" class="oc ms iq ma b gy os ot l ou ov">{<br/>    "bindings": [<br/>        {<br/>            "type": "timerTrigger",<br/>            "direction": "in",<br/>            "name": "req",<br/>            "schedule": "*/20 * * * * *"<br/>        }<br/>    ]<br/>}</span></pre></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="deff" class="mr ms iq bd mt mu nw mw mx my nx na nb jw ny jx nd jz nz ka nf kc oa kd nh ni bi translated">监控监控app！</h1><p id="7b36" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">和以前一样，可以使用<code class="fe lx ly lz ma b">redis-cli</code>检查我们系统的状态——执行<a class="ae lb" href="https://redis.io/commands/XPENDING" rel="noopener ugc nofollow" target="_blank">expending</a>命令:</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="14d8" class="oc ms iq ma b gy os ot l ou ov">XPENDING tweets_stream redisearch_app_group</span></pre><p id="2915" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将得到与此类似的输出(根据您运行的tweets处理器实例的数量和运行时间的不同，这个数字会有所不同):</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="e9a6" class="oc ms iq ma b gy os ot l ou ov">1) (integer) 209<br/>2) "1620973121009-0"<br/>3) "1621054539960-0"<br/>4) 1) 1) "consumer-1f20d41d-e63e-40d2-bc0f-749f11f15026"<br/>      2) "3"<br/>   2) 1) "monitoring_app"<br/>      2) "206"</span></pre><p id="f70d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，监控应用程序将<em class="lt">声明</em>其他消费者(活动或非活动)尚未处理的未决消息。在上面的输出中，请注意当前由<code class="fe lx ly lz ma b">monitoring_app</code>(我们的消费者的名称)处理的消息号是<code class="fe lx ly lz ma b">206</code>——它实际上从另一个消费者实例声明了这些消息。一旦这些消息被声明，它们的所有权就从最初的消费者转移到了<code class="fe lx ly lz ma b">monitoring_app</code>消费者。</p><blockquote class="lq lr ls"><p id="0131" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">您可以再次使用</em> <code class="fe lx ly lz ma b"><em class="iq">XPENDING tweets_stream redisearch_app_group</em></code> <em class="iq">进行同样的检查，但是可能很难检测到，因为消息实际上处理得非常快。</em></p></blockquote><p id="1122" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在被声明的<code class="fe lx ly lz ma b">206</code>消息中，只有在最后<code class="fe lx ly lz ma b">10</code>秒内没有被处理的消息(这是我们指定的<code class="fe lx ly lz ma b">MIN_IDLE_TIME_SEC</code>)将被处理——其他消息将被忽略，并在下一次运行时被<code class="fe lx ly lz ma b">XPENDING</code>调用获取(如果它们仍处于未处理状态)。这是因为我们想给我们的消费者应用程序一些时间来完成他们的工作——对于涉及使用<code class="fe lx ly lz ma b">HSET</code>然后使用<code class="fe lx ly lz ma b">XACK</code>保存到<code class="fe lx ly lz ma b">HASH</code>的处理来说，10秒是一个相当大的时间范围。。</p><blockquote class="lq lr ls"><p id="b6b9" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">请注意，上面使用的10秒时间间隔仅用作示例，您应根据您的数据管道/处理所需的端到端延迟来确定这些数字。</em></p></blockquote><p id="502c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就如何运行/操作这样一个“监控”组件而言，您拥有完全的灵活性。我选择了一个无服务器的函数，但是你可以把它作为一个独立的程序运行，作为一个预定的Cron任务或者甚至作为一个Kubernetes任务！</p><p id="43ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记执行<code class="fe lx ly lz ma b">RediSearch</code>查询，以验证您可以基于多个标准搜索推文:</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="26f1" class="oc ms iq ma b gy os ot l ou ov">FT.SEARCH tweets-index hello<br/>FT.SEARCH tweets-index hello|world<br/>FT.SEARCH tweets-index "@location:India"</span><span id="764c" class="oc ms iq ma b gy ow ot l ou ov">FT.SEARCH tweets-index "@user:jo* @location:India"<br/>FT.SEARCH tweets-index "@user:jo* | @location:India"</span><span id="f108" class="oc ms iq ma b gy ow ot l ou ov">FT.SEARCH tweets-index "@hashtags:{cov*}"<br/>FT.SEARCH tweets-index "@hashtags:{cov*|Med*}"</span></pre><p id="a65e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经看到了实际操作，让我们来研究一下代码。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="3340" class="mr ms iq bd mt mu nw mw mx my nx na nb jw ny jx nd jz nz ka nf kc oa kd nh ni bi translated">代码遍历</h1><blockquote class="lq lr ls"><p id="3589" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">请参考GitHub </em> 上的 <a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action/tree/master/monitoring-app/cmd" rel="noopener ugc nofollow" target="_blank"> <em class="iq">代码</em></a></p></blockquote><p id="4e39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序使用了优秀的<a class="ae lb" href="https://github.com/go-redis/redis" rel="noopener ugc nofollow" target="_blank"> go-redis客户端库</a>。像往常一样，这一切都从连接到Redis开始(注意<code class="fe lx ly lz ma b">TLS</code>的用法):</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="f086" class="oc ms iq ma b gy os ot l ou ov">client := redis.NewClient(&amp;redis.Options{Addr: host, Password: password, TLSConfig: &amp;tls.Config{MinVersion: tls.VersionTLS12}})</span><span id="099f" class="oc ms iq ma b gy ow ot l ou ov"> err = client.Ping(context.Background()).Err()<br/> if err != nil {<br/>     log.Fatal(err)<br/> }</span></pre><p id="f30b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来是大部分处理发生的部分——把它想象成包含子部分的工作流:</p><p id="94c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe lx ly lz ma b">XPENDING</code>来检测未决消息的数量，例如<code class="fe lx ly lz ma b">XPENDING tweets_stream group1</code></p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="15f1" class="oc ms iq ma b gy os ot l ou ov">numPendingMessages := client.<strong class="ma ir">XPending</strong>(context.Background(), streamName, consumerGroupName).Val().Count</span></pre><p id="6ceb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了获得待处理的消息，我们调用另一个不同的<code class="fe lx ly lz ma b">XPENDING</code>变量，向其传递我们在之前的调用中获得的消息数量</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="3ac5" class="oc ms iq ma b gy os ot l ou ov">xpendingResult := client.<strong class="ma ir">XPendingExt</strong>(context.Background(), &amp;redis.XPendingExtArgs{Stream: streamName,Group: consumerGroupName, Start: "-", End: "+", Count: numPendingMessages})</span></pre><p id="cc32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以声明挂起的消息——这些消息的所有权将从以前的消费者变更为我们指定了名称的新消费者(<code class="fe lx ly lz ma b">monitoringConsumerName</code>)</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="1508" class="oc ms iq ma b gy os ot l ou ov">xclaim := client.<strong class="ma ir">XClaim</strong>(context.Background(), &amp;redis.XClaimArgs{Stream: streamName, Group: consumerGroupName, Consumer: monitoringConsumerName, MinIdle: time.Duration(minIdleTimeSec) * time.Second, Messages: toBeClaimed})</span></pre><p id="6358" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦所有权转移，我们就可以处理它们。这包括将tweet信息添加到<code class="fe lx ly lz ma b">HASH</code>(使用<code class="fe lx ly lz ma b">HSET</code>)并确认成功处理(<code class="fe lx ly lz ma b">XACK</code>)。<code class="fe lx ly lz ma b">goroutine</code>用于保持事情的效率，例如，如果我们批量获得<code class="fe lx ly lz ma b">100</code>个声明的消息，则执行分散-收集过程，其中产生一个<code class="fe lx ly lz ma b">goroutine</code>来处理这些消息中的每一个。一个<a class="ae lb" href="https://golang.org/pkg/sync/#WaitGroup" rel="noopener ugc nofollow" target="_blank">同步。WaitGroup </a>用于在寻找下一组未决消息(如果有)之前“等待”当前批处理完成。</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="42eb" class="oc ms iq ma b gy os ot l ou ov">for _, claimed := range xclaim.Val() {<br/>            if exitSignalled {<br/>                return<br/>            }<br/>            waitGroup.Add(1)</span><span id="8c12" class="oc ms iq ma b gy ow ot l ou ov">            go func(tweetFromStream redis.XMessage) {<br/>                hashName := fmt.Sprintf("%s%s", indexDefinitionHashPrefix, tweetFromStream.Values["id"])</span><span id="c04f" class="oc ms iq ma b gy ow ot l ou ov">                processed := false<br/>                defer func() {<br/>                    waitGroup.Done()<br/>                }()</span><span id="0faa" class="oc ms iq ma b gy ow ot l ou ov">                err = client.HSet(context.Background(), hashName, claimed.Values).Err()</span><span id="711a" class="oc ms iq ma b gy ow ot l ou ov">                if err != nil {<br/>                    return // don't proceed (ACK) if HSET fails<br/>                }</span><span id="a216" class="oc ms iq ma b gy ow ot l ou ov">                err = client.XAck(context.Background(), streamName, consumerGroupName, tweetFromStream.ID).Err()<br/>                if err != nil {<br/>                    return<br/>                }<br/>                processed = true<br/>            }(claimed)<br/>        }<br/>        waitGroup.Wait()</span></pre><p id="d89d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们深入其他领域之前，通过探索代码(顺便说一下，这相对简单)来理解本质可能会有所帮助</p><h2 id="901b" class="oc ms iq bd mt od oe dn mx of og dp nb ko oh oi nd ks oj ok nf kw ol om nh on bi translated">关于应用程序结构的快速说明</h2><p id="b1bf" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">下面是应用程序的设置方式(文件夹结构):</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="d00a" class="oc ms iq ma b gy os ot l ou ov">.<br/>├── cmd<br/>│   └── main.go<br/>├── monitor<br/>│   └── function.json<br/>├── go.mod<br/>├── go.sum<br/>├── host.json</span></pre><p id="0122" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lx ly lz ma b">host.json</code>通过指向能够处理HTTP事件的web服务器，告知函数主机向何处发送请求。注意<code class="fe lx ly lz ma b">customHandler.description.defaultExecutablePath</code>，它定义了<code class="fe lx ly lz ma b">processor_monitor</code>是用于运行web服务器的可执行文件的名称。</p><pre class="mc md me mf gt oo ma op oq aw or bi"><span id="5a7c" class="oc ms iq ma b gy os ot l ou ov">{<br/>    "version": "2.0",<br/>    "extensionBundle": {<br/>        "id": "Microsoft.Azure.Functions.ExtensionBundle",<br/>        "version": "[1.*, 2.0.0)"<br/>    },<br/>    "customHandler": {<br/>        "description": {<br/>            "defaultExecutablePath": "processor_monitor"<br/>        },<br/>        "enableForwardingHttpRequest": true<br/>    },<br/>    "logging": {<br/>        "logLevel": {<br/>            "default": "Trace"<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="785d" class="mr ms iq bd mt mu nw mw mx my nx na nb jw ny jx nd jz nz ka nf kc oa kd nh ni bi translated">这是一个总结！</h1><p id="bad9" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">这就把我们带到了这个博客系列的结尾。让我们回顾一下我们所学的内容:</p><ul class=""><li id="59db" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">在第一部分中，您了解了用例、架构及其组件的概述，以及Redis流和<code class="fe lx ly lz ma b">RediSearch</code>的介绍。它为该系列的其余部分设置了场景。</li><li id="1470" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">第二部分讨论了基于Rust的tweets消费者应用程序的细节，该应用程序使用Twitter流API，并将tweets在Redis流中排队以供进一步处理。</li><li id="f339" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">第三部分是关于Java应用程序，它通过利用Redis Streams消费者组特性和跨多个实例扩展处理来处理这些推文。</li><li id="2898" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">…最后一部分(这一部分)是关于Go应用程序，用于监控由于处理失败或消费者实例失败而被放弃(在待定条目列表中)的推文。</li></ul><p id="88a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望您发现这很有用，并将其应用于使用Redis流构建可伸缩的解决方案。编码快乐！</p></div></div>    
</body>
</html>