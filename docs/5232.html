<html>
<head>
<title>Backup and Restore of Kubernetes Stateful Application Data with CSI Volume Snapshots</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CSI卷快照备份和恢复Kubernetes有状态应用程序数据</h1>
<blockquote>原文：<a href="https://itnext.io/backup-and-restore-of-kubernetes-stateful-application-data-with-csi-volume-snapshots-14ce9e6f3778?source=collection_archive---------1-----------------------#2021-01-18">https://itnext.io/backup-and-restore-of-kubernetes-stateful-application-data-with-csi-volume-snapshots-14ce9e6f3778?source=collection_archive---------1-----------------------#2021-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/805728d5acd61ed9e05dd70f4191bd10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vrXo-_RdGpY7mWop.jpg"/></div></div></figure><p id="9970" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着卷快照的<a class="ae kz" href="https://kubernetes.io/blog/2020/12/10/kubernetes-1.20-volume-snapshot-moves-to-ga/" rel="noopener ugc nofollow" target="_blank">正式发布</a>，用于有状态应用程序数据备份和恢复的CSI卷快照更加成熟。本文探讨了我们如何使用标准的Kubernetes快照资源来备份和恢复位于PV上的数据。</p><p id="48ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用IBM事件流作为测试目标。它基于Strimizi运算符运行Kafka的statefulset K8s资源。假设我们有statefulset的3个副本，数据保存在PVC中，分别命名为data-es-kafka-0、data-es-kafka-1、data-es-kafka-2。PVC由Rook Ceph提供。</p><h2 id="8f23" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">卷快照类</h2><p id="132d" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">正如PVC可以通过storage类动态创建PV一样，当请求卷快照资源时，可以通过snapshot类动态创建卷快照内容，即实际的快照数据。</p><p id="0f2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Rook operator的情况下，如果RBD快照类还没有创建，我们需要应用来自GitHub source的YAML文件，<code class="fe ly lz ma mb b">rook/cluster/examples/kubernetes/ceph/csi/rbd/snapshotclass.yaml</code>这将允许快照通过CSI驱动程序动态创建。快照类名定义为<code class="fe ly lz ma mb b">csi-rbdplugin-snapclass</code></p><h2 id="f6b3" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">申请的状态</h2><p id="c071" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">在我们拍摄PVC上的数据快照之前，让我们通过在UI上显示演示主题的消息来记录应用程序的当前状态。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/55e522226b78d0075682ac95b3f7a51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aOUGa5pRrEn436p-6nRu-Q.png"/></div></div></figure><p id="974d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">屏幕截图中显示了每个分区的偏移量。当我们此时使用快照进行恢复时，预计会出现相同的数据。</p><h2 id="1eca" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">卷快照</h2><p id="5b43" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">创建快照类后，我们可以动态请求快照。对于每个Kafka代理的PVC，使用以下YAML文件创建快照，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="d23f" class="la lb it mb b gy ml mm l mn mo">apiVersion: snapshot.storage.k8s.io/v1beta1<br/>kind: VolumeSnapshot<br/>metadata:<br/>  name: snapshot-data-es-kafka-0-1610889673<br/>spec:<br/>  volumeSnapshotClassName: csi-rbdplugin-snapclass<br/>  source:<br/>    persistentVolumeClaimName: data-es-kafka-0</span></pre><p id="6413" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如上面的YAML所示，我们要求快照类<code class="fe ly lz ma mb b">csi-rbdplugin-snapclass</code>根据PVC <code class="fe ly lz ma mb b">data-es-kafka-0</code>为第一个状态集的副本创建一个快照。为所有的PVC创建YAML。</p><p id="0022" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">应用YAML文件后，我们可以验证快照内容是否已创建，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="55e1" class="la lb it mb b gy ml mm l mn mo">oc get volumesnapshotcontent | grep snapshot-data-es-kafka</span><span id="7580" class="la lb it mb b gy mp mm l mn mo"><strong class="mb iu">snapcontent-6c3cf764-2ebd-4788-a5bd-296b0544689a</strong>   true         4294967296    Delete           rook-ceph.rbd.csi.ceph.com   csi-rbdplugin-snapclass   snapshot-data-es-kafka-2-1610889673   3h20m<br/>snapcontent-7b1202d6-8b8e-49bb-975d-a3a741d11457   true         4294967296    Delete           rook-ceph.rbd.csi.ceph.com   csi-rbdplugin-snapclass   snapshot-data-es-kafka-0-1610889673   3h20m<br/>snapcontent-ddad6d12-c930-4bb3-9b85-61cb427fc930   true         4294967296    Delete           rook-ceph.rbd.csi.ceph.com   csi-rbdplugin-snapclass   snapshot-data-es-kafka-1-1610889673   3h20m</span></pre><p id="8ea0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以进一步转到Rook Ceph工具箱来检查快照是否已创建，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="9055" class="la lb it mb b gy ml mm l mn mo">oc -n rook-ceph exec -it rook-ceph-tools-78cdfd976c-wqvl4 -- rbd ls replicapool</span><span id="53b2" class="la lb it mb b gy mp mm l mn mo">csi-snap-091267a8-586f-11eb-9e04-0a580a830011<br/>csi-snap-0c1e1883-586f-11eb-9e04-0a580a830011<br/>csi-snap-0f255227-586f-11eb-9e04-0a580a830011</span></pre><h2 id="61cc" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">灾难…</h2><p id="9ed5" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">让我们模拟一个灾难，PVC的文件系统对于所有三个副本都是满的。(PVC创建时只有4GB大小)</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="02a0" class="la lb it mb b gy ml mm l mn mo">oc exec -i es-kafka-0 -- sh -c "fallocate -l 5G /var/lib/kafka/data/huge"</span><span id="a526" class="la lb it mb b gy mp mm l mn mo">oc exec -i es-kafka-1 -- sh -c "fallocate -l 5G /var/lib/kafka/data/huge"</span><span id="6b72" class="la lb it mb b gy mp mm l mn mo">oc exec -i es-kafka-2 -- sh -c "fallocate -l 5G /var/lib/kafka/data/huge"</span></pre><p id="b8bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">卡夫卡经纪人然后陷入崩溃的循环。</p><h2 id="1374" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">从快照恢复</h2><p id="783f" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">在我们恢复PVC的数据之前，让我们通过将副本缩放到零来停止operator和statefulset。这是为了确保在恢复过程中PVC不会中断。</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="8dfe" class="la lb it mb b gy ml mm l mn mo">oc scale deploy eventstreams-cluster-operator --replicas=0</span><span id="cfa4" class="la lb it mb b gy mp mm l mn mo">oc scale sts es-kafka --replicas=0</span></pre><p id="603d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们删除原始的PVC，因为我们已经从快照中获得了备份，因此我们可以安全地删除损坏的数据</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="c036" class="la lb it mb b gy ml mm l mn mo">oc delete pvc data-es-kafka-0 pvc data-es-kafka-1 data-es-kafka-2</span></pre><p id="329a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用相同的名称创建PVC，但是这次我们通过定义数据源从快照中恢复它。</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="4f79" class="la lb it mb b gy ml mm l mn mo">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: data-es-kafka-0<br/>spec:<br/>  storageClassName: rook-ceph-block<br/><strong class="mb iu">  dataSource:<br/>    name: snapshot-data-es-kafka-0-1610889673<br/>    kind: VolumeSnapshot<br/>    </strong>apiGroup: snapshot.storage.k8s.io<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 4Gi</span></pre><p id="b48d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，对于PVC <code class="fe ly lz ma mb b">data-es-kafka-0</code>，dataSource指向一个名为<code class="fe ly lz ma mb b">snapshot-data-es-kafka-0–1610889673 </code>的VolumeSnapshot对象，这是我们在灾难发生前拍摄的。新的PVC将从该快照中恢复。</p><p id="ebb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦绑定了新的PVC，我们就可以将运营商部署规模调整回1。并观看Kafka应用程序正常运行，状态恢复如下所示，</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/55e522226b78d0075682ac95b3f7a51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aOUGa5pRrEn436p-6nRu-Q.png"/></div></div></figure><h2 id="c78d" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">使用Velero自动执行快照备份</h2><p id="7ddf" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">实际上，通过手动创建YAML来拍摄快照有点麻烦。Velero能够帮助我们实现流程自动化。</p><h2 id="bd01" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">Minio依赖</h2><p id="4298" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">假设我们使用OpenShift集群在本地环境中设置Velero。首先，我们安装并配置Minio以满足对象存储的Velero需求。</p><p id="f956" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们需要运行一些特权操作，所以用特权SCC创建一个服务帐户，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="36cf" class="la lb it mb b gy ml mm l mn mo">oc new-project minio<br/>oc create sa minio-privileged<br/>oc adm policy add-scc-to-user privileged -z minio-privileged</span></pre><p id="487d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过舵图安装Minio，添加minio repo，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="7276" class="la lb it mb b gy ml mm l mn mo">helm repo add minio <a class="ae kz" href="https://helm.min.io" rel="noopener ugc nofollow" target="_blank">https://helm.min.io</a></span></pre><p id="01b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建以下values.yaml文件，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="e0cd" class="la lb it mb b gy ml mm l mn mo">persistence:<br/>  enabled: true<br/>  size: 100Gi<br/>defaultBucket:<br/>  enabled: true<br/>  name: bucket<br/>serviceAccount:<br/>  name: minio-privileged<br/>makeBucketJob:<br/>  podAnnotations:<br/>  annotations:<br/>  securityContext:<br/>    enabled: true<br/>    runAsUser: 0<br/>    runAsGroup: 0<br/>    fsGroup: 1000</span></pre><p id="e5ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后展开迷你头盔图，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="27e7" class="la lb it mb b gy ml mm l mn mo">helm install minio -n minio -f values.yaml minio/minio</span></pre><p id="c761" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将S3服务公开为OpenShift路由，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="1cc5" class="la lb it mb b gy ml mm l mn mo">oc expose svc/minio</span></pre><p id="fc5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同时，记下登录的accesskey和secretkey的minio秘密。准备一个文件，<code class="fe ly lz ma mb b">minio.secret</code>，如下所示，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="0da2" class="la lb it mb b gy ml mm l mn mo">[default]<br/>aws_access_key_id = xxxxxxxxxxxxx<br/>aws_secret_access_key = xxxxxxxxxxxxx</span></pre><h2 id="4764" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">Velero的安装</h2><p id="bfed" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">Velero的安装很简单，下载客户端，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="064a" class="la lb it mb b gy ml mm l mn mo">curl -LO <a class="ae kz" href="https://github.com/vmware-tanzu/velero/releases/download/v1.5.2/velero-v1.5.2-linux-amd64.tar.gz" rel="noopener ugc nofollow" target="_blank">https://github.com/vmware-tanzu/velero/releases/download/v1.5.2/velero-v1.5.2-linux-amd64.tar.gz</a></span><span id="1d2e" class="la lb it mb b gy mp mm l mn mo">tar zxvf velero-v1.5.2-linux-amd64.tar.gz<br/>sudo cp velero-v1.5.2-linux-amd64/velero /usr/local/bin</span></pre><p id="7568" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后安装Velero服务器端组件，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="ed74" class="la lb it mb b gy ml mm l mn mo">velero install \<br/> --provider aws \<br/> --plugins velero/velero-plugin-for-aws:v1.1.0,velero/velero-plugin-for-csi:v0.1.2  \<br/> --bucket bucket  \<br/> --secret-file minio.secret  \<br/> <strong class="mb iu">--use-volume-snapshots=true</strong> \<br/> --backup-location-config region=default,s3ForcePathStyle="true",s3Url=<a class="ae kz" href="http://minio-minio.apps.dev3-ocp46.ibmcloud.io.cpak" rel="noopener ugc nofollow" target="_blank">http://minio-minio.apps.dev3-ocp46.ibmcloud.io.cpak</a>  \<br/> --snapshot-location-config region=default \<br/> <strong class="mb iu">--features=EnableCSI</strong></span></pre><p id="6324" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我已经启用了CSI和卷快照。</p><p id="f0d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，我们需要注释Velero的snapshot类，以使用它来创建快照，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="bffa" class="la lb it mb b gy ml mm l mn mo">oc label VolumeSnapshotClass csi-rbdplugin-snapclass velero.io/csi-volumesnapshot-class=true </span><span id="dd01" class="la lb it mb b gy mp mm l mn mo">oc label VolumeSnapshotClass csi-cephfsplugin-snapclass velero.io/csi-volumesnapshot-class=true</span></pre><h2 id="7952" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">Velero在行动</h2><p id="58d6" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">一旦安装了Velero，我们就可以对名称空间进行备份(创建基于计划的备份或临时备份)</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="40f6" class="la lb it mb b gy ml mm l mn mo">velero backup create evs-backup-2021-01-18-14-51-47 --include-namespaces eventstreams --wait</span></pre><p id="7b2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个命令将以json格式创建所有Kubernetes对象的备份，并将它们保存到S3对象存储中。同时，还使用相应的快照类来拍摄快照。</p><p id="a0e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果我们在Velero backup调用后检查快照，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="2eca" class="la lb it mb b gy ml mm l mn mo">oc get volumesnapshots</span><span id="8625" class="la lb it mb b gy mp mm l mn mo">NAME                               READYTOUSE   SOURCEPVC             SOURCESNAPSHOTCONTENT   RESTORESIZE   SNAPSHOTCLASS             SNAPSHOTCONTENT                                    CREATIONTIME   AGE<br/>velero-data-es-kafka-0-7fb7f       true         data-es-kafka-0                               4Gi           csi-rbdplugin-snapclass   snapcontent-4ec929ef-3868-427b-a7b5-dc1dbcc6537a   2m47s          2m49s<br/>velero-data-es-kafka-1-gszdn       true         data-es-kafka-1                               4Gi           csi-rbdplugin-snapclass   snapcontent-7ebc61a1-b2de-4fa2-8591-49e2f45b83d1   2m42s          2m44s<br/>velero-data-es-kafka-2-7hbcm       true         data-es-kafka-2                               4Gi           csi-rbdplugin-snapclass   snapcontent-b620a877-7bca-4b74-92f7-67e249d2b381   2m37s          2m39s<br/>velero-data-es-zookeeper-0-4k782   true         data-es-zookeeper-0                           2Gi           csi-rbdplugin-snapclass   snapcontent-ecffa6a6-463e-4463-a3ae-10fdf48a19e7   2m32s          2m34s<br/>velero-data-es-zookeeper-1-c9fcg   true         data-es-zookeeper-1                           2Gi           csi-rbdplugin-snapclass   snapcontent-08658983-3143-4fdf-a3e4-bd43e41fadda   2m27s          2m28s<br/>velero-data-es-zookeeper-2-ngw67   true         data-es-zookeeper-2                           2Gi           csi-rbdplugin-snapclass   snapcontent-0016b15b-5c8d-4c91-86f7-fd0b954a3c1c   2m22s          2m23s</span></pre><p id="3d70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有PVC都将在备份过程中创建其快照。如果我们描述其中一个，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="ba24" class="la lb it mb b gy ml mm l mn mo">oc describe volumesnapshot velero-data-es-kafka-0-7fb7f | head -10</span><span id="05fa" class="la lb it mb b gy mp mm l mn mo">Name:         velero-data-es-kafka-0-7fb7f<br/>Namespace:    eventstreams<br/><strong class="mb iu">Labels:       velero.io/backup-name=evs-backup-2021-01-18-14-51-47</strong><br/>Annotations:  &lt;none&gt;<br/>API Version:  snapshot.storage.k8s.io/v1beta1<br/>Kind:         VolumeSnapshot<br/>Metadata:<br/>  Creation Timestamp:  2021-01-18T06:52:17Z<br/>  Finalizers:<br/>    snapshot.storage.kubernetes.io/volumesnapshot-as-source-protection</span></pre><p id="d6eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快照标有Velero备份名称。这就是Velero在调用恢复时如何找到要使用的正确快照。</p><p id="ed7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，万一发生灾难，我们可以恢复PVC数据。在实际恢复之前，让我们停止所有潜在的中断，如本文开头部分的手动方法所示，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="b5a8" class="la lb it mb b gy ml mm l mn mo">oc scale deploy eventstreams-cluster-operator --replicas=0</span><span id="ce86" class="la lb it mb b gy mp mm l mn mo">oc scale sts es-kafka --replicas=0</span><span id="2c10" class="la lb it mb b gy mp mm l mn mo">oc delete pvc data-es-kafka-0 data-es-kafka-1 data-es-kafka-2</span></pre><p id="95dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们删除PVC，因为Velero恢复不会覆盖任何现有的K8s资源。用Velero修复，</p><pre class="md me mf mg gt mh mb mi mj aw mk bi"><span id="0c27" class="la lb it mb b gy ml mm l mn mo">velero restore create evs-restore-test --from-backup <strong class="mb iu">evs-backup-2021-01-18-14-51-47</strong> --wait</span></pre><p id="e431" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入Velero的备份名称，通过标签找到正确的快照。然后可以恢复PVC，并且可以恢复statefulset应用程序。</p><h2 id="a55e" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">讨论</h2><p id="c758" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">因为快照是由Rook Ceph snapshot类执行的，所以快照内容实际上存储在Rook集群中。如果您打算备份PVC数据并在不同的Kubernetes集群中恢复它，这里描述的方法不适用。您将需要有Velero的restic备份和恢复选项。</p></div></div>    
</body>
</html>