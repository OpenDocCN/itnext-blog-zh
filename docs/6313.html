<html>
<head>
<title>Unit testing Kubernetes operators using mocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模拟对Kubernetes运算符进行单元测试</h1>
<blockquote>原文：<a href="https://itnext.io/unit-testing-kubernetes-operators-using-mocks-ba3ba2483ba3?source=collection_archive---------1-----------------------#2021-10-15">https://itnext.io/unit-testing-kubernetes-operators-using-mocks-ba3ba2483ba3?source=collection_archive---------1-----------------------#2021-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9a8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">在这篇文章中，我将带你了解使用模拟对Kubernetes操作符进行单元测试的想法，为什么你需要它们，以及如何实际编写一个！虽然这些想法和概念也可以在用其他语言/框架编写的操作符上实现，但我还是坚持使用Golang、</em> <a class="ae km" href="https://github.com/kubernetes-sigs/controller-runtime" rel="noopener ugc nofollow" target="_blank"> <em class="kl">控制器-运行时</em> </a> <em class="kl">，以及</em> <a class="ae km" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank"> <em class="kl">验证</em> </a> <em class="kl">库。本文还假设对Kubernetes、操作人员和软件测试有很好的理解</em></p><blockquote class="kn ko kp"><p id="8d4a" class="jn jo kl jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">在整篇文章中，我将引用可以在中找到的<code class="fe kt ku kv kw b">example-operator</code>。</p></blockquote><h1 id="faeb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">单元测试和模拟——什么和为什么？</h1><p id="8304" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在我们真正进入模拟测试之前，让我们试着理解单元测试的重要性。顾名思义，单元测试处理的是测试软件的单个“单元”。它确保代码的这些独立单元或组件按预期工作，独立于代码的其他部分或外部依赖项。单元测试使你更容易发现软件的问题。软件中不同单元之间的交互只有在这些单元本身被保证能正确工作时才能正确工作——这就是单元测试重要的原因！</p><p id="6b93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Kubernetes控制器的上下文中，这个“单元”可以被认为是一个与Kubernetes API交互(通过一个客户端)并对Kubernetes对象和资源进行操作的单一函数(或方法)。因为这些函数需要与Kubernetes API对话，所以对它们进行单元测试变得有些困难，因为它们不需要额外的服务或API来执行。这不仅是因为我们想要隔离我们正在测试的逻辑，还因为有时，设置这些资源可能有点昂贵，并且会减慢测试过程。</p><p id="afd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是嘲讽的用处！它允许您模仿或模拟代码组件所依赖的服务——在本例中是Kubernetes客户端。模拟可以帮助您验证控制器与Kubernetes API的交互(比如断言是否执行了某些操作),而无需实际与Kubernetes集群进行交互。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/af0b2e9ba0c08e1784bd1e7a711fe717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqoFxrRY589FhjPHc1kHOA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">图1 —模拟测试</figcaption></figure><p id="2fee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过查看一些代码来更好地理解这一点！</p><h1 id="958b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">代码走查</h1><p id="9649" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">每当一个<code class="fe kt ku kv kw b">Deployment</code>对象被操作时，我们的控制器的协调循环就被触发。控制器基于<code class="fe kt ku kv kw b">container/inject=true</code>标签-值对的存在，通过向pod模板中注入一个额外的容器来协调<code class="fe kt ku kv kw b">Deployments</code>。</p><blockquote class="kn ko kp"><p id="aa04" class="jn jo kl jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">这个控制器实际上并不做任何有用的事情，只是为了本文而编写的。</p></blockquote><p id="fb3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以在<code class="fe kt ku kv kw b"><a class="ae km" href="https://github.com/mayankshah1607/example-operator/blob/master/controller/controller.go" rel="noopener ugc nofollow" target="_blank">controller/controller.go</a></code>找到的<code class="fe kt ku kv kw b"><a class="ae km" href="https://github.com/mayankshah1607/example-operator/blob/master/controller/controller.go#L31" rel="noopener ugc nofollow" target="_blank">Reconcile</a></code>方法是所有和解相关活动的切入点。</p><pre class="mb mc md me gt mq kw mr ms aw mt bi"><span id="cb75" class="mu ky iq kw b gy mv mw l mx my">// ... controller/controller.go</span><span id="fca2" class="mu ky iq kw b gy mz mw l mx my">type MyReconciler struct {<br/> client.Client<br/> Scheme *runtime.Scheme<br/>}</span><span id="9780" class="mu ky iq kw b gy mz mw l mx my">func (r *MyReconciler) Reconcile(<br/> ctx context.Context, req ctrl.Request) (ctrl.Result, error) {</span><span id="b7b3" class="mu ky iq kw b gy mz mw l mx my">// STEP 1: get the deployment object<br/> deployment := &amp;appsv1.Deployment{}<br/> err := r.Get(ctx, req.NamespacedName, deployment)<br/> if err != nil {<br/>  return ctrl.Result{}, err<br/> }</span><span id="5aa7" class="mu ky iq kw b gy mz mw l mx my">// STEP 2: reconcile<br/> if err := r.handleDeploymentReconciliation(ctx, deployment); err != nil {<br/>  return ctrl.Result{}, err<br/> }<br/> return ctrl.Result{}, nil<br/>}</span></pre><p id="037b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">核心协调逻辑封装在<code class="fe kt ku kv kw b"><a class="ae km" href="https://github.com/mayankshah1607/example-operator/blob/master/controller/controller.go#L48" rel="noopener ugc nofollow" target="_blank">handleDeploymentReconciliation</a></code>方法中，这就是我们将要编写单元测试的目的。这里我们想要模拟的依赖项是由<a class="ae km" href="https://github.com/kubernetes-sigs/controller-runtime" rel="noopener ugc nofollow" target="_blank">控制器-运行时</a>提供的Kubernetes客户端。</p><h2 id="a8fc" class="mu ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">为Kubernetes客户端编写模拟</h2><p id="1690" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><a class="ae km" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">stretchr/evidence</a>模块提供了<a class="ae km" href="https://github.com/stretchr/testify#mock-package" rel="noopener ugc nofollow" target="_blank"> mock </a>包，用于方便地编写定制的mock对象，这些对象可以在编写单元测试时用来代替真实对象。让我们使用提供的机制为Kubernetes客户端编写一个模拟对象。</p><blockquote class="kn ko kp"><p id="a9f7" class="jn jo kl jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">所有与模拟相关的代码都可以在<code class="fe kt ku kv kw b"><a class="ae km" href="https://github.com/mayankshah1607/example-operator/blob/master/utils/testutil.go" rel="noopener ugc nofollow" target="_blank">utils/tesutil.go</a></code>中找到。</p></blockquote><p id="1f60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是通过将<code class="fe kt ku kv kw b">mock.Mock</code>嵌入到它的结构中，为客户机创建一个模拟对象。</p><pre class="mb mc md me gt mq kw mr ms aw mt bi"><span id="8a1e" class="mu ky iq kw b gy mv mw l mx my">// ... utils/testutil.go</span><span id="c74c" class="mu ky iq kw b gy mz mw l mx my">type Client struct {<br/> mock.Mock</span><span id="0e2d" class="mu ky iq kw b gy mz mw l mx my">  ....<br/>}</span></pre><p id="fc3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要为这个模拟<code class="fe kt ku kv kw b">Client</code>设置所需的方法，它将被<code class="fe kt ku kv kw b">handleDeploymentReconciliation</code>方法调用。</p><pre class="mb mc md me gt mq kw mr ms aw mt bi"><span id="a9ba" class="mu ky iq kw b gy mv mw l mx my">// ... utils/testutil.go</span><span id="9166" class="mu ky iq kw b gy mz mw l mx my">func (c *Client) Update(ctx context.Context, obj client.Object, opts ...client.UpdateOption) error {<br/> args := c.Called(ctx, obj, opts)<br/> return args.Error(0)<br/>}</span></pre><p id="caf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kt ku kv kw b">Update</code>方法在这里不需要做任何有用的事情。它只是通知模拟对象它已经被调用，并返回没有任何错误。这个方法对真正的客户机有用，但是因为我们想模仿它，我们简单地把它去掉。</p><blockquote class="kn ko kp"><p id="0635" class="jn jo kl jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">为了保持简洁，我只展示了一个<code class="fe kt ku kv kw b">Update</code>方法的例子。为了实际使用<code class="fe kt ku kv kw b">Client</code>模拟对象，它需要实现在<code class="fe kt ku kv kw b">Client</code>接口中定义的所有方法。此外，您还可以使用<a class="ae km" href="https://github.com/vektra/mockery" rel="noopener ugc nofollow" target="_blank">mock</a>来轻松地自动生成模拟代码。</p></blockquote><h2 id="ab68" class="mu ky iq bd kz na nb dn ld nc nd dp lh jy ne nf ll kc ng nh lp kg ni nj lt nk bi translated">编写您的单元测试</h2><p id="bada" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在我们已经有了一个模拟客户端，让我们看看如何使用它来编写单元测试。单元测试可以在<code class="fe kt ku kv kw b"><a class="ae km" href="https://github.com/mayankshah1607/example-operator/blob/master/controller/controller_test.go" rel="noopener ugc nofollow" target="_blank">controller/controller_test.go</a></code>中找到。</p><pre class="mb mc md me gt mq kw mr ms aw mt bi"><span id="25ff" class="mu ky iq kw b gy mv mw l mx my">// ... <!-- -->controller/controller_test.go</span><span id="5fe2" class="mu ky iq kw b gy mz mw l mx my">func TestHandleDeploymentReconciler(t *testing.T) {<br/> client := utils.NewClient()</span><span id="66c1" class="mu ky iq kw b gy mz mw l mx my">// setup expectations<br/> client.On("Update",<br/>  mock.IsType(context.Background()),<br/>  mock.IsType(&amp;appsv1.Deployment{}),<br/>  mock.Anything,<br/> ).Return(nil)</span><span id="88aa" class="mu ky iq kw b gy mz mw l mx my">ctx := context.Background()<br/> reconciler := &amp;MyReconciler{<br/>  Client: client,<br/>  Scheme: newTestScheme(),<br/> }</span><span id="6bef" class="mu ky iq kw b gy mz mw l mx my">err := reconciler.handleDeploymentReconciliation(ctx, newTestDeployment())<br/> require.NoError(t, err)<br/> client.AssertExpectations(t)</span><span id="71db" class="mu ky iq kw b gy mz mw l mx my">}</span></pre><p id="400b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<a class="ae km" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">验证</a>工具包提供的机制来断言对<code class="fe kt ku kv kw b">Update</code>的预期函数调用使用了正确类型的参数和返回值。</p><ul class=""><li id="329d" class="nl nm iq jp b jq jr ju jv jy nn kc no kg np kk nq nr ns nt bi translated"><code class="fe kt ku kv kw b">client.On</code>设置关于必须调用哪个客户端方法(在本例中为<code class="fe kt ku kv kw b">Update</code>)的预期，以及使用哪种类型的参数和返回值。</li><li id="2c0d" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><code class="fe kt ku kv kw b">mock.IsType</code>帮助断言使用<code class="fe kt ku kv kw b">client.On</code>设置的预期方法(在本例中为<code class="fe kt ku kv kw b">Update</code>)是用正确的参数类型调用的。</li><li id="f7fe" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><code class="fe kt ku kv kw b">client.AssertExpectations</code>检查预期是否实际达到。如果调用了意外的方法，没有调用预期的方法，或者使用意外的参数类型调用了预期的方法，则测试会出现混乱。</li><li id="166e" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">最后，<code class="fe kt ku kv kw b">require.NoError</code>断言<code class="fe kt ku kv kw b">handleDeploymentReconciliation</code>没有错误地返回。</li></ul><p id="eb26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要运行该测试，只需在您的终端上执行以下命令:</p><pre class="mb mc md me gt mq kw mr ms aw mt bi"><span id="d091" class="mu ky iq kw b gy mv mw l mx my">$ go test -timeout 30s -run ^TestHandleDeploymentReconciler$ \ ./controller</span><span id="d0a2" class="mu ky iq kw b gy mz mw l mx my">ok   github.com/mayankshah1607/example-operator/controller 0.941s</span></pre><p id="78a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单干净，不是吗？</p><h1 id="970d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="838c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">虽然单元测试和Kubernetes操作符是一个很大的主题，但是本文简要地向您介绍了一种使用模拟为Kubernetes操作符编写单元测试的有效方法。模拟对象对于测试代码和它所依赖的外部API之间的交互非常有用。我们看看如何使用<a class="ae km" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">evidence</a>工具包为Kubernetes客户端编写模拟，并在您的单元测试中使用它。虽然本文关注的是使用Golang和<a class="ae km" href="https://github.com/kubernetes-sigs/controller-runtime" rel="noopener ugc nofollow" target="_blank">控制器-运行时</a>编写的操作符，但是这些想法和概念也可以跨各种其他框架实现。</p><p id="b9c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你觉得这篇文章有帮助，请考虑鼓掌并与你的朋友和同事分享。您可以在以下网址找到我:</p><ul class=""><li id="91ea" class="nl nm iq jp b jq jr ju jv jy nn kc no kg np kk nq nr ns nt bi translated">推特—【https://twitter.com/mayankshah__ T4】</li><li id="bb9a" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">领英—<a class="ae km" href="https://www.linkedin.com/in/mayankshah1607/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/mayankshah1607/</a></li><li id="a309" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">GitHub—<a class="ae km" href="https://github.com/mayankshah1607" rel="noopener ugc nofollow" target="_blank">https://github.com/mayankshah1607</a></li></ul><p id="ee1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">感谢您花时间阅读本文！</em></p><h1 id="d0fe" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">参考</h1><ul class=""><li id="cd4f" class="nl nm iq jp b jq lv ju lw jy nz kc oa kg ob kk nq nr ns nt bi translated"><a class="ae km" href="https://book.kubebuilder.io/" rel="noopener ugc nofollow" target="_blank">https://book.kubebuilder.io/</a></li><li id="a33a" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><a class="ae km" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">https://github.com/stretchr/testify</a></li><li id="c61d" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><a class="ae km" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Unit_testing</a></li><li id="00b5" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><a class="ae km" href="https://blog.mayadata.io/testing-kubernetes-operators" rel="noopener ugc nofollow" target="_blank">https://blog.mayadata.io/testing-kubernetes-operators</a></li><li id="53de" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><a class="ae km" href="https://flugel.it/devops/building-custom-kubernetes-operators-article-iv-automatic-testing-using-operator-sdk/" rel="noopener ugc nofollow" target="_blank">https://flugel . it/devo PS/building-custom-kubernetes-operators-article-iv-automatic-testing-using-operator-SDK/</a></li></ul></div></div>    
</body>
</html>