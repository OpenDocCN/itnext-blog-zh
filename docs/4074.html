<html>
<head>
<title>Why isn’t async/await working in a .forEach cycle?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么async/await不在. forEach循环中工作？</h1>
<blockquote>原文：<a href="https://itnext.io/why-async-await-in-a-foreach-is-not-working-5f13118f90d?source=collection_archive---------0-----------------------#2020-04-22">https://itnext.io/why-async-await-in-a-foreach-is-not-working-5f13118f90d?source=collection_archive---------0-----------------------#2020-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6f22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">三种不同的方式让它工作</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c0b6047d0e2a82e0d93d8fd76aaecf74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LC6Yun3zv1TjRczM-CJAjQ.png"/></div></div></figure><p id="0ce1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们面对现实:自从引入async/await模式以来，我们已经尝试在任何地方使用它。</p><p id="e8d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">javascript回调和承诺的大链时代已经一去不复返(几乎)被遗忘了。解决方案:现在所有的函数都以<code class="fe la lb lc ld b">async</code>开头，即使它不包含异步代码...以防万一:)</p><p id="f929" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是Javascript的某些部分还没有准备好使用这种模式。其中一个部分是<code class="fe la lb lc ld b">.forEach</code>(不与async/await一起使用的其他方法有<code class="fe la lb lc ld b">.map</code>、<code class="fe la lb lc ld b">.filter</code>和<code class="fe la lb lc ld b">.reduce</code>，但我会就这些写另一篇文章)。</p><p id="2e71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">。forEach </strong>是一个数组方法，<strong class="js iu">允许在数组</strong>的每个元素上调用一个函数。简单对吗？</p><p id="705b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个<code class="fe la lb lc ld b">.forEach</code>的例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="15ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我将这个脚本保存在food.js文件中，然后运行<code class="fe la lb lc ld b">node food.js</code>，输出如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lg"><img src="../Images/754d2cd83163eeb32542ab8b3ddfd06a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJ8O9qWiM6Zu9yhJgCJk5g.png"/></div></div></figure><p id="ac27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以一切都是正确的:对数组的每个元素都调用了该函数，数组的顺序与console.log输出的顺序相匹配。耶！✨</p><h2 id="2dfa" class="lh li it bd lj lk ll dn lm ln lo dp lp kb lq lr ls kf lt lu lv kj lw lx ly lz bi translated">但是，如果函数比单个console.log更复杂，会发生什么呢？</h2><p id="bf44" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们在前面部分写的代码很棒，但是我想要更多。我想知道我喜欢的食物的种类(肉、鱼、蔬菜、水果)。</p><p id="932b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mf">假设</em> </strong>我用javascript创建了一个复杂的算法，输入一个食物的名字，它就能返回这个类。很棒，是吧？这是我最好的代码。🚀</p><p id="7c6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该算法使用大量的计算能力和数据库资源，因此它将返回一个承诺。</p><p id="12c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很明显，我不能在这里与你分享这个难以置信的代码(不，我不会回应任何关于这个算法根本不存在的轻率言论)，所以为了这篇文章，我将使用一个模拟它的假函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="03cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了调用这个函数，我将在我的<code class="fe la lb lc ld b">.forEach</code>中使用一个<code class="fe la lb lc ld b">await</code>。让我们稍微修改一下前面的代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="128d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为在全局状态下使用async await还不标准，所以我创建了一个包装代码的函数<strong class="js iu"> run </strong>。在里面。forEach函数(现在是一个异步函数)我们用<code class="fe la lb lc ld b">await</code>调用AIFoodRecognition并打印结果。</p><p id="d048" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很简单，对吧？结果应该以“开始”开始，然后将打印所有我喜欢的食物类，然后将打印“结束”。</p><p id="187e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来试试:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mg"><img src="../Images/be2f83ae37678b707633266387a403c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTf72jocBOoWc0bSH-7QTw.png"/></div></div></figure><p id="64e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯……和我们预想的不太一样。那是因为。forEach只调用函数，它不会等待函数结束，每个AIFoodRecognition函数预计至少在500毫秒后结束，这比主线程完成。每次循环和打印结束。<strong class="js iu">真令人失望！</strong></p><p id="2a7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，这个问题有一些解决方案。</p><ul class=""><li id="28a9" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">重写。forEach支持<strong class="js iu">await/async；</strong></li><li id="06c3" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">使用for()循环；</li><li id="f71d" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">使用Promise.all</li></ul><p id="a75f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从最不方便的开始，即使它看起来是最好的:</p><h1 id="c620" class="mv li it bd lj mw mx my lm mz na nb lp nc nd ne ls nf ng nh lv ni nj nk ly nl bi translated">重写。forEach支持await/async</h1><p id="e20d" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">这似乎是一个很好的解决方案！让我们找到代码。对于每个polyfill，让我们用一个异步函数包装所有东西，然后…获利！💰💰💰</p><p id="8332" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个简单的<code class="fe la lb lc ld b">.forEach</code>聚合填充:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="02cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将其更改为支持异步/等待:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="53c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我们在第1行的函数之前添加了一个async，然后在callback.call之前，我们将使用await。我们将用此方法替换Array.prototype中的forEach方法。</p><p id="a9ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧！现在让我们试着在前面的代码中使用它:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="009c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次运行后，输出将是…</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/fd5a778060f843a03bd852a41b11e338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bUcSJskxLByQFTPs9VARQ.png"/></div></div></figure><p id="2a70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哎哟。</p><p id="1dc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为我们忘记了一些重要的事情:现在forEach是一个异步函数，所以为了等待它的结束，我们需要在调用它之前使用await。</p><p id="66b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们只是在forEach前面加上<code class="fe la lb lc ld b">await</code>，就像这样</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="ff6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们得到了正确的结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nn"><img src="../Images/d44a8a8ac4948352f70959837903b640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdEjwoSJ-ez8M0Tj_kri2Q.png"/></div></div></figure><p id="ede7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们应该只在已经使用过的地方添加await。forEach并将其包装在异步函数中… <strong class="js iu">不值得。</strong></p><p id="df6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，覆盖一些默认的类方法也是一种不好的做法，因为将来你可能会忘记这个覆盖，或者其他开发人员可能会跳进项目，花上几个小时或几天的时间试图找到错误，并找到报复你的方法。</p><p id="dc9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试着找到一些其他的解决方案，也许不那么黑客式的。</p><h1 id="1469" class="mv li it bd lj mw mx my lm mz na nb lp nc nd ne ls nf ng nh lv ni nj nk ly nl bi translated">利用我们良好的旧for()循环</h1><p id="08fb" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">老谋的报复()循环。我们把过去到处都换成新的更好看的。现在我们回来请求原谅。</p><p id="4da3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试着在代码中使用它:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="c074" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而且…我们第一次尝试就成功了！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi no"><img src="../Images/f425eb624cb10b683e9fabdf3f796733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jaP-VmZTf5_Tsr7PO_VHsw.gif"/></div></div></figure><h2 id="c3f1" class="lh li it bd lj lk ll dn lm ln lo dp lp kb lq lr ls kf lt lu lv kj lw lx ly lz bi translated">略好:用于…的</h2><p id="7f41" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">for()循环的一个变体是使用<strong class="js iu"> for…of </strong>模式:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="26ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我认为有比这更好的东西，也许可以帮助我们减少等待时间。</p><h1 id="8a31" class="mv li it bd lj mw mx my lm mz na nb lp nc nd ne ls nf ng nh lv ni nj nk ly nl bi translated">使用Promise.all来提高性能时间🕐</h1><p id="2fba" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">直到现在，为了结束我们的程序，我们等待了3秒钟(foodArray中的每个元素都是500毫秒)。这是因为等待在循环中。但是如果我们在foodArray中有100个元素呢？还是1000？等待的时间将是可怕的。</p><p id="16c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许有一种方法可以并行进行所有的食物识别，而不是等到每一个完成后再开始下一个？是的，有:它被称为Promise . all。Promise的这个方法接受一个数组作为参数，只有当数组内的所有元素都完成时才会返回，返回一个新的结果数组。</p><p id="f879" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将对代码进行一些修改，但我向您保证这是值得的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="cc69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了一个名为promises的新数组。因此，我们将添加每个AIFoodRecognition函数调用，这样我们可以并行启动每个识别。记住:AIFoodRecognition返回一个承诺，所以我们仍然不能从这个数组中获取我们的类。为此，我们需要使用带有单个await的<strong class="js iu"> Promise.all </strong>,这将返回一个新数组，其中包含我们的promises数组的每个元素的返回。现在我们只需要循环这个数组来打印结果，我们就完成了！✨</p><p id="0a3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看Promise.all和for()循环之间的区别(我为这些gif设置了1500毫秒的延迟，而不是500毫秒)</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/f6012657f47cf513b999602a023c0f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XDzH5vL7M1ry7DmESfjNng.gif"/></div></div></figure><p id="0e18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，Promise.all方法比for()循环快得多。因此，如果您不需要前一个周期的输出结果，您应该始终使用Promise.all版本在一个周期中运行一些async/await代码。</p><p id="7698" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我知道你的想法，或者如果你有其他方法在循环中使用await，你可以在Twitter上找到我<a class="ae nq" href="https://twitter.com/urcoilbisurco" rel="noopener ugc nofollow" target="_blank">💛</a></p></div></div>    
</body>
</html>