<html>
<head>
<title>I’m making an offline first WordPress PWA, part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我正在做一个离线的第一个WordPress PWA，第5部分</h1>
<blockquote>原文：<a href="https://itnext.io/im-making-an-offline-first-wordpress-pwa-part-5-e3293faefb88?source=collection_archive---------5-----------------------#2018-07-31">https://itnext.io/im-making-an-offline-first-wordpress-pwa-part-5-e3293faefb88?source=collection_archive---------5-----------------------#2018-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="63cc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">先离线</h2></div><p id="10b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个系列之前:我反对我的原则，用<a class="ae lb" href="https://vuejs.org" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>从服务器端切换到客户端渲染。这种方法的优点是我可以使用<a class="ae lb" href="https://developers.google.com/web/fundamentals/architecture/app-shell" rel="noopener ugc nofollow" target="_blank">应用程序外壳模型</a>并将博客的“外壳”保存在缓存中。博客文章是用AJAX从WordPress JSON API获取的，这意味着只需要通过网络下载非常少量的数据。</p><p id="72da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缺点是，如果用户离线或处于不稳定的“虚假”连接中，他/她将只能看到占位符，而没有实际内容。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/53132d68a4cfb3c1b31969f0a1e5727e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zverv3XCpq_ASzhTk7bJEw.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">如果没有网络连接，对JSON API的fetch调用将会失败。</figcaption></figure><p id="665e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它仍然比浏览器内置的“您没有连接到互联网”页面要好，但它可以用更好的方式来完成！</p><h2 id="5497" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">重新验证时过时</h2><p id="cc4f" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">解决方案是使用服务工作器将来自JSON API的数据保存在缓存中。无论何种连接方式或网速，访问者都可以阅读博客文章。</p><p id="1f09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是哪种策略是最好的。被排除了，因为它会再次给我同样的问题——访问者将永远看不到新的博客文章。</p><p id="6089" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mq mr ms mt b">staleWhileRevalidate()</code>是一种可能的策略。它直接从缓存中提供数据，但无论如何都会在后台发出网络请求。然后，新数据被保存在缓存中，并将在下次访问时使用。</p><blockquote class="mu"><p id="6137" class="mv mw iq bd mx my mz na nb nc nd la dk translated">博客几乎可以即时加载，但问题当然是用户需要访问博客两次才能看到新帖子。</p></blockquote><p id="20f9" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">下面的视频对此进行了说明。新帖子发布后，博客必须重新加载两次。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="41bb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">网络优先</h2><p id="7957" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在这种情况下，新数据的优先级高于速度。<code class="fe mq mr ms mt b">staleWhileRevalidate()</code>更适合CSS和JavaScript，它们不像内容那样重要。</p><p id="813f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么<code class="fe mq mr ms mt b">networkFirst()</code>策略更适合的原因。顾名思义，它将首先通过网络发送请求。如果服务器由于某种原因没有响应，以前缓存的响应将作为后备。</p><p id="d579" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当JSON API被处理时，这就是服务人员现在的样子。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><p id="92e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的电影中，你可以看到一篇新的博客文章是如何在一次重新加载后发布和显示的。如果你在Chrome开发工具中切换到离线模式并再次重新加载，博客仍然可以工作，因为JSON数据现在也存储在缓存中。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b1f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着这个目标的实现，我实际上已经用WordPress制作了一个离线的第一个渐进式网络应用程序。但是我仍然有一些有趣的问题要解决。到目前为止，博客只包含一个页面，所以需要创建一个<code class="fe mq mr ms mt b">single.php</code>页面。问题是怎么做？</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="3332" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以前的零件:</p><ul class=""><li id="d065" class="nt nu iq kh b ki kj kl km ko nv ks nw kw nx la ny nz oa ob bi translated">第一部分:HTTPS </li><li id="17b3" class="nt nu iq kh b ki oc kl od ko oe ks of kw og la ny nz oa ob bi translated">第二部分:Manifest.json </li><li id="36ac" class="nt nu iq kh b ki oc kl od ko oe ks of kw og la ny nz oa ob bi translated"><a class="ae lb" href="https://medium.com/@stefanledin/im-making-an-offline-first-wordpress-pwa-part-3-1ddf61891121" rel="noopener">第3部分:带工具箱的服务人员</a></li><li id="7300" class="nt nu iq kh b ki oc kl od ko oe ks of kw og la ny nz oa ob bi translated"><a class="ae lb" href="https://medium.com/@stefanledin/im-making-an-offline-first-wordpress-pwa-part-4-be2d06e6ff28" rel="noopener">第四部分:应用外壳模型</a></li></ul></div></div>    
</body>
</html>