<html>
<head>
<title>One Node.js CLS API to rule them all</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个Node.js CLS API来管理它们</h1>
<blockquote>原文：<a href="https://itnext.io/one-node-js-cls-api-to-rule-them-all-1670ac66a9e8?source=collection_archive---------1-----------------------#2020-03-14">https://itnext.io/one-node-js-cls-api-to-rule-them-all-1670ac66a9e8?source=collection_archive---------1-----------------------#2020-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ff37fe25ea86cb8be24d3413a5679220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xrn_iq4qkWHcStGd"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@jareeign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在位</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="4284" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Node.js v13.10.0引入了内置的CLS API，即位于众所周知的实验<code class="fe lb lc ld le b">async_hooks</code>模块中的新类<code class="fe lb lc ld le b"><a class="ae jd" href="https://nodejs.org/api/async_hooks.html#async_hooks_class_asynclocalstorage" rel="noopener ugc nofollow" target="_blank">AsyncLocalStorage</a></code>。在这篇短文中，我将试着解释为什么它如此重要。</p><h1 id="de3a" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">CLS API 101</h1><p id="cf99" class="pw-post-body-paragraph kd ke jg kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">CLS代表连续本地存储，是多线程世界中线程本地存储概念的异步变体。CLS API允许您通过异步执行链关联和跟踪上下文。如果没有这样的API，您必须要么显式传递上下文对象(有时这不是一个选项)，要么处理Node.js中所有异步API的大量猴子补丁。</p><p id="9815" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">CLS API通常用于各种云平台中Node.js的应用性能监控(APM)工具。但是有些情况下，你可能想在你的应用程序中直接或间接使用CLS，也就是说，它可能在你的依赖项中使用。请求id跟踪就是这样的用例之一。你可以在我的<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/request-id-tracing-in-node-js-applications-c517c7dab62d">上一篇博文</a>中读到更多关于这个话题的内容。</p><p id="075e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是让我们回到<code class="fe lb lc ld le b">AsyncLocalStorage</code>。为了让您对API有一个印象，这里有一个例子，展示了如何使用<code class="fe lb lc ld le b">AsyncLocalStorage</code>来构建一个具有请求id跟踪功能的原始日志记录器。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="bdd1" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么异步本地存储很重要？</h1><p id="10ff" class="pw-post-body-paragraph kd ke jg kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">现在，当您对这个主题有了更好的理解时，让我们来看一下新API的一系列优点。</p><ol class=""><li id="d4e5" class="mo mp jg kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">有几个Node.js用户土地模块实现了CLS，其中最流行的是<code class="fe lb lc ld le b"><a class="ae jd" href="https://github.com/othiym23/node-continuation-local-storage" rel="noopener ugc nofollow" target="_blank">continuation-local-storage</a></code>和它的继任者<code class="fe lb lc ld le b"><a class="ae jd" href="https://github.com/Jeff-Lewis/cls-hooked" rel="noopener ugc nofollow" target="_blank">cls-hooked</a></code>。不幸的是，它们都没有在社区中被广泛采用，许多Node.js库不能很好地处理这些模块，导致各种上下文丢失问题。作为标准库的一部分，<code class="fe lb lc ld le b">AsyncLocalStorage</code>有机会改变这一点，因为库的维护者更有可能修复与核心API相关的问题，而不是第三方。</li><li id="ef85" class="mo mp jg kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated"><code class="fe lb lc ld le b">AsyncLocalStorage</code>提供了一个简单的高级API，隐藏了异步钩子的复杂性和底层细节。因此，它比它所构建的API更稳定(就兼容性而言),并且有可能被移到一个单独的、稳定的模块中。</li><li id="8059" class="mo mp jg kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">性能方面<code class="fe lb lc ld le b">AsyncLocalStorage</code>明显快于其用户地竞争对手(参见下一节的基准测试结果)。主要是因为它避免了使用<code class="fe lb lc ld le b">destroy</code>钩子(感谢<code class="fe lb lc ld le b"><a class="ae jd" href="https://nodejs.org/api/async_hooks.html#async_hooks_async_hooks_executionasyncresource" rel="noopener ugc nofollow" target="_blank">executionAsyncResource</a></code>)。</li></ol><h1 id="4511" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">性能比较</h1><blockquote class="nc nd ne"><p id="fe32" class="kd ke nf kf b kg kh ki kj kk kl km kn ng kp kq kr nh kt ku kv ni kx ky kz la ij bi translated">免责声明。这种比较有意保持尽可能简单，即它只考虑在开发机器上收集的基准运行系列的平均结果。</p></blockquote><p id="60e3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能已经知道，Node.js core包括一组由核心团队维护的各种基准。其中一个基准(即<code class="fe lb lc ld le b"><a class="ae jd" href="https://github.com/nodejs/node/blob/ec204d86b06e4cc9259c1308e365a3e104212a16/benchmark/async_hooks/async-resource-vs-destroy.js" rel="noopener ugc nofollow" target="_blank">async-resource-vs-destroy.js</a></code>和必要的修改)用于比较<code class="fe lb lc ld le b">AsyncLocalStorage</code>和替代方案。该基准旨在模拟一个或多或少标准的web应用程序。为此，它启动一个HTTP服务器，该服务器调度一个<code class="fe lb lc ld le b">setTimeout</code>，然后在处理传入请求时读取一个文件(都在相同的CLS上下文中)。</p><p id="438b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们看看<code class="fe lb lc ld le b">AsyncLocalStorage</code>与<code class="fe lb lc ld le b">cls-hooked</code>相比如何，后者是最受欢迎的用户-CLS API之一。</p><figure class="mi mj mk ml gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/63f47c49b8eadbd3283f999504a84864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*2oygeKU6FkwLh86kAGf0UA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">以cls为基准-挂钩</figcaption></figure><p id="5d59" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在上面的图表中看到的，<code class="fe lb lc ld le b">AsyncLocalStorage</code>在普通回调和异步/等待语法上都比<code class="fe lb lc ld le b">cls-hooked</code>快得多。</p><p id="f842" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们试着测量一下新API与同样的web应用相比的开销，这个web应用有一个无操作的CLS实现，即一个什么也不做的实现(因此，没有启用任何异步挂钩)。</p><figure class="mi mj mk ml gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/20240896e253cfe5b9ff7ce67faaccc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*kJ4E4J2eGv04LVl2fshV0g.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">以不采取行动的CLS为基准</figcaption></figure><p id="44e9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，当您的代码基于回调时，开销几乎为零。使用async/await语法时，这变得更加明显，但是代价并没有那么高，并且还有一些空间<a class="ae jd" href="https://twitter.com/stephenbelanger/status/1234395447327805440?s=20" rel="noopener ugc nofollow" target="_blank">用于将来的改进。</a></p><h1 id="f918" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">行动呼吁</h1><p id="cfb4" class="pw-post-body-paragraph kd ke jg kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">此时，你可能会好奇<code class="fe lb lc ld le b">AsyncLocalStorage</code>的成熟度，以及它是否足够稳定，可以在你的应用或库中使用。</p><p id="78ea" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我要说的是，API在这一点上(2020年3月)需要一些时间来“安顿下来”(例如，<a class="ae jd" href="https://github.com/nodejs/node/pull/31950" rel="noopener ugc nofollow" target="_blank">这个PR </a>涉及到明显的变化)，但是早起的鸟儿有虫吃。</p><p id="f7a8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦<code class="fe lb lc ld le b">AsyncLocalStorage</code>在API方面变得更加稳定，像<code class="fe lb lc ld le b">cls-hooked</code>这样处理用户土地CLS库的开发者肯定应该考虑切换到核心模块。此外，对Node.js v12的反向移植正在进行中，因此应该有助于更广泛的采用。</p><p id="f91b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为Node.js社区成员，我要感谢所有使<code class="fe lb lc ld le b">AsyncLocalStorage</code>成为可能的核心合作者(尤其是<a class="nk nl ep" href="https://medium.com/u/b662fb63374b?source=post_page-----1670ac66a9e8--------------------------------" rel="noopener" target="_blank"> Vladimir de Turckheim </a>为API投入了大量精力)。另一方面，作为这个核心CLS API的合著者，我承诺尽我所能传播消息，并支持<code class="fe lb lc ld le b">AsyncLocalStorage</code>将Node.js作为一个平台和生态系统做得更好。</p><p id="0cfb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">更新</strong>。<code class="fe lb lc ld le b">AsyncLocalStorage</code>在Node.js v12.17.0和v14.0.0中也有</p></div></div>    
</body>
</html>