# 使用角度解析器在页面加载上实现更平滑的 UX

> 原文：<https://itnext.io/smoother-ux-on-page-load-with-angular-resolvers-e063ef035124?source=collection_archive---------0----------------------->

## 使用角度解析器快速解析数据可以改善页面加载和用户体验，并让您可以立即处理错误。我们将创建一个配置文件解析器来解析配置文件数据。

![](img/0ff7e84b3fe399e6bb8c45b22971ba9d.png)

你的页面加载 UX

# 为什么要使用角旋变器？

作为开发人员，**你总是希望优化你的代码**。这包括向用户呈现满载 UI 的速度，这通常取决于来自数据库的数据。

不可避免地，您开始寻找在导航到应用程序的新页面/区域时立即解析数据的方法，而不会让用户遇到所谓的 page **JANK** 。

> 这是指页面在加载某些组件时上下移动。它可以显著影响 UX，以至于它看起来“漏洞百出”。

Angular 提供了一种在路线加载之前**预取数据的直观方法；在导航路线解析之前。**

它被称为**角度分解器。**

角度解算器本质上是一种角度服务。**您在路由配置中提供给路由模块的可注入类。**当导航到包含路由时，注入并执行这种特殊类型的服务。

解析器然后在页面加载之前解析数据，**通过** `**ActivatedRoute**` **服务**变得可用。这提供了一种简单而有效的方法来确保您的用户在对初始页面加载很重要的组件需要数据之前尽快获得数据。

**使用角度解析器的另一种方式是将其作为一种方法来即时填充 SEO 元数据。**

> 有了解析器，你就可以保证数据在页面加载之前就存在了，确保初始化时所有东西都有了。

# 让我们分解一下角分解器

**角度解析器是一个实现** `**Resolve**` **接口的类。**`Resolve`接口要求你在名为`resolve`的类中实现一个函数。

这是解析接口签名…

```
export interface Resolve<T> {
    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<T> | Promise<T> | T {
        return 'data';
    }
}
```

> 正如我们从接口签名中看到的，它需要一个通用参数`T`，这将是我们解析的数据的类型。

**resolve** 函数返回一个`Observable`、`Promise`或者只是类型为`T`的数据。因此，**建议异步处理这个问题**，尤其是从数据库中检索数据的时候。

resolve 函数的主要目的是**它必须完成**。在可观测量中检索数据时，需要记住这个事实。**可观察必须完成**。毕竟是解析器。

**如果观察不完整，那么数据将永远无法解析，页面将永远无法加载**。因此，您需要定义一个点，在这个点上您不需要再获取任何值，并且数据可以解析，因为您已经从数据库中获得了所有需要的内容。当使用异步数据流时，例如 observables，**这是来自 [RXJS](http://www.learnrxjs.io) 的可管道化操作符**的用例。

当想到**根据条件**完成数据流时，脑海中浮现的可管道化操作符是`[filter](https://www.learnrxjs.io/learn-rxjs/operators/filtering/filter)`、`[take](https://www.learnrxjs.io/learn-rxjs/operators/filtering/take)`、`[first](https://www.learnrxjs.io/learn-rxjs/operators/filtering/first)`的组合。有了这个组合，你可以过滤掉所有你不想取的值，比如`null`或者`undefined`或者一个空数组`[]`，然后用`take(1)`过滤掉第一个有效值`take`。

当遇到问题或错误时，可能需要**尽早完成一个可观察的操作符，其中您将希望返回 null 或重定向，这些操作符是`[catchError](https://www.learnrxjs.io/learn-rxjs/operators/error_handling/catch)`和`[timeout](https://www.learnrxjs.io/learn-rxjs/operators/utility/timeout)`。如果您的数据花费太长时间**并且您想要返回`null`以便您可以在组件内部重试，或者您想要重定向，那么`timeout`和`catchError`的组合**非常有用。**

> 如果您的数据不能快速解析，基于复杂的过滤、逻辑和大量的数据库调用，您可能会不时地遇到问题。

**最好确定成功、优雅地加载页面所需的最少数据库调用量、**和最少数据量。

因此，在实现解析器之前，花些时间将“文件夹之上”的内容从页面初始化时可以加载的数据中分离出来，可能会对您有所帮助。

因此，您可以将平滑 UX 所需的数据与可以从组件而不是解析器调用的其他数据分开。

**然后，您可以通过解析器专门处理文件夹上方的最小内容。**

> **使用** [**骨架**](https://uxdesign.cc/what-you-should-know-about-skeleton-screens-a820c45a571a) 可以辅助这种动态的页面加载方法。因此，如果用户立即向下滚动，您可以提示用户内容正在加载，从而提高 UX。

[](https://uxdesign.cc/what-you-should-know-about-skeleton-screens-a820c45a571a) [## 关于骷髅屏幕你需要知道的一切

### 我们如何知道骨架屏幕实际上是有效的？

uxdesign.cc](https://uxdesign.cc/what-you-should-know-about-skeleton-screens-a820c45a571a) 

# 步骤 1:创建解析程序

我们需要创建角度分解器。然而，**没有一个 Angular CLI 命令可以生成解析器。**因此，我们将不得不自己编写装饰器(解析器元数据)。

幸运的是，只有几行代码构成了解析器的样板文件，如果您很难记住，我们可以从现有的服务中获取**可注入的装饰器。**

## 用一个可注入的装饰器来注释概要解析器类

首先，我们在配置中提供带有`providedIn: any`的可注入装饰器。

```
@Injectable({ providedIn: 'any'})
```

然后我们将通过**附加约定** `**Resolver**`来命名我们的解析器。对于这个例子，我们将解析概要文件数据(用户数据)，所以我们称之为`**ProfileResolver**`。

因为它是一个解析器，并且 **Angular 识别解析器**的功能，我们可以实现`Resolve`类，它将提供我们必须在解析函数中实现的签名，以成功解析数据。

```
@Injectable({providedIn: 'any'})
export class ProfileResolver implements Resolve<Profile> {
}
```

我们的 resolve 函数将返回一个可观察的**，其数据符合** `**Profile**` **接口**。因此，我们将提供`Profile`接口作为解析器类和`resolve()`函数的**通用参数。这样，我们就符合了旋变器的角度要求。**

```
resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<T> | Promise<T> | T {
        return;
}
```

**如果需要的话，resolve 实现会给我们两个参数:** `**route**` **和** `**state**` 。这些是自动填充的，可以从我们的`resolve()`函数中访问。

接下来，我们需要实际解析数据库中的真实数据，这将是我们的下一步。

## 从数据库中检索数据

为了检索 resolve 函数的数据，我们需要注入提供数据的服务；一个与数据库交互的人。

我们从它那里得到我们需要的东西来快速解决，这样用户就能快速成功地导航。出于演示的目的，我们不会担心处理数据库的底层服务。我们将在 `**ProfileResolver**` **类**的构造函数参数中使用依赖注入来注入服务。

由于我们的数据是以可观察数据流的形式出现的，其中多个值异步发出**，我们只需要使用从`rxjs/operator`导入的可管道操作符**`**take**`**`**take(1)**`**。否则，可观测性将永远不会完成，解析器将永远不会…解析。****

**我们只需要一个发射/值和`take`来完成我们的可观测。**

****创建一个解析器就这么简单**；我们只需要在 angular 将处理订阅的`resolve()`函数中返回可观察值。**

**ProfileResolver 类**

**我们通过重定向到父路由来处理检索数据中的任何错误。**

## **额外收获:在加载路线之前，快速填充动态 SEO 元数据**

**填充我们的`<meta>`标签的好处显而易见。我们的 SEO 元数据填充得越快，**我们的 SEO 就越能正确、准确地反映页面内容。****

**这意味着机器人，如谷歌和必应等搜索引擎操作的机器人，抓取你的网站并检索内容更加容易和快捷。**

> **T **这对于预渲染页面或由 Angular Universal** 渲染的页面并不重要，因为所有的渲染都是在机器人接收内容之前完成的。**

**然而，如果您依赖 google robots 为您的 SEO 解析 javascript 的能力(通常是有问题的)，或者您已经有了像 puppeteer 这样的按需解决方案，需要在返回呈现的 DOM 之前确保 SEO 是正确的，那么包含 SEO 的解析器应该会有所帮助。所以当爬虫有时间限制的时候它是有帮助的。**

****它还将关注点从组件**中分离出来，这样组件就不必处理任何与 SEO 相关的事情。我喜欢解析器的主要原因之一。**

# **步骤 2:将解析器注入路由模块**

**我们将在其中提供解析器的 **ProfileRoutingModule** 是一个延迟加载的模块。因此，我们的根路径将是空的，带有参数标记`userSlug`，我们将需要它来检索正确的概要文件数据。**

**为了提供解析器，我们只需提供一个对象，将数据的名称作为键，将特定的解析器作为负责解析该数据的值。**

**你可以给这个键起任何你喜欢的名字，但是我们就称它为**数据**。**

**我们的 ProfileRoutingModule 模块**

**这就是路由模块中使用解析器所需的全部内容。**

**接下来，**我们需要在组件中检索和使用我们的数据。****

# **步骤 3:用解析的数据初始化组件**

**现在我们已经解析了路由激活的数据，**可以通过** `**ActivatedRoute**` **服务**访问这些数据。由于我们在整个应用程序中处理可观测量，**我们将创建一个绑定到** `**data**` **属性的流，它将是我们解析的数据**。**

**首先，我们将把`ActivatedRoute`注入到`ProfileComponent`的构造函数中。接下来，我们将把`this.route.data`分配给`profile$`可观测值。**当更新的数据从数据库到达时，我们也想切换到使用可观察的，这样当我们与应用程序交互时，我们就有了新的数据。****

**为此，我们将使用`startWith`，这样我们就可以从`this.route.snapshot.data`中容易访问的值开始我们的流。然后我们像访问`this.route.snapshot.data['data']`一样访问`data`属性。`startWith`表示一个开始值，作为我们流的第一次发射。**

**我们的个人资料组件**

## **可立即访问的数据对组件有什么作用**

**可立即访问的数据减少了加载该页面各个部分所花费的时间，**，这被用户观察到**。不使用这样的解析器的结果是页面可能看起来以一种支离破碎的方式加载，这在视觉上是不令人愉快的。**

**因此，您需要注意 HTML 模板的哪些元素依赖于哪些数据。然后你应该编写解析器来支持这些元素和页面加载 UX 的整体效果。**

## ****组件可以通过多种方式加载碎片****

*   **其中之一是如果你的 HTML 模板的多个部分都有一个`ngIf`。**
*   **再一个是`ngFor`。**

> **最好的做法是限制你写的单个`ngIf`的数量，目的是限制浏览器必须做的调整大小的数量。**

****在获取数据之前加载页面会导致页面的某些部分不断跳跃、滞后和调整大小，**导致 UX 受损。**

**实现一个解析器可能是**用户经历 3-5 秒的跳跃和调整大小与 0.5 秒的差别，**这通常太快而不会损害整体 UX。**

## ****就是这样！我们有一个解析器，它改进了页面加载的 UX。****

> **有任何问题，请在评论中告诉我！**

 **[## 角度分解器

### Angular 是一个构建移动和桌面 web 应用程序的平台。加入数百万开发者的社区…

angular.io](https://angular.io/api/router/Resolve)** **[](https://www.learnrxjs.io) [## 介绍

### 是当今 web 开发中最热门的库之一。提供强大的功能方法来处理…

www.learnrxjs.io](https://www.learnrxjs.io)**