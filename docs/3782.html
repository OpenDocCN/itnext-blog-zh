<html>
<head>
<title>Keeping Original Value When Transforming in RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在RxJS中转换时保持原始值</h1>
<blockquote>原文：<a href="https://itnext.io/keeping-original-value-when-transforming-in-rxjs-f4650e12c4cf?source=collection_archive---------3-----------------------#2020-02-24">https://itnext.io/keeping-original-value-when-transforming-in-rxjs-f4650e12c4cf?source=collection_archive---------3-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc5c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">来自“方便的RxJS操作符”系列</h2></div><p id="8230" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2022年2月28日最新更新:更新代码以支持RxJS 7等。</p><p id="3e62" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">异步流是新时代编程最可爱的地方。当我用Java开发的时候，RxJava是唯一让Java变得可以忍受的东西。当我开始在Angular上开发时，我很高兴一切都是原生的RxJS。然后，当我在新工作岗位上开始创建Node.js后端项目时，我把所有东西都做成RxJS。但是，有时候API会让你的代码看起来乏味或者混乱。</p><p id="3141" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在许多情况下，当使用<code class="fe lf lg lh li b">map</code>(或<code class="fe lf lg lh li b">mergeMap</code>)转换一个可观察对象时，您也想访问原始值。使用当前的RxJS API，有几种方法可以做到这一点。</p><h1 id="761f" class="lj lk it bd ll lm ln lo lp lq lr ls lt jz lu ka lv kc lw kd lx kf ly kg lz ma bi translated">不良做法</h1><p id="5401" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">一种方法是将值存储在局部变量中，然后对其进行转换:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">清单1。将可观察值存储在局部变量中</figcaption></figure><p id="9ab8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样做有很多缺点。一般来说，变异会伤害你的代码。当你在异步语言/范式/平台中变异你的变量时，你创造了<a class="ae mr" href="https://fallout.gamepedia.com/Super_mutant_suicider" rel="noopener ugc nofollow" target="_blank">自杀的超级变种人</a>，它们发出嘟嘟声等待爆炸。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/517fd23395ea407f1c5457e4e81c4b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*TzzKFIuI9Oao0MdNahdaLQ.jpeg"/></div></figure><p id="c792" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个很好的例子:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">清单2。使用这种方法的缺点是:整型和字符串型值不同步</figcaption></figure><p id="1bdf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果转换需要一些时间来完成(例如，当在数据库中存储一些东西并检索更新的文档时)，访问存储的原始值可能太晚了。在清单2中，<code class="fe lf lg lh li b">value</code>在第一次被访问之前被覆盖。</p><h1 id="db5d" class="lj lk it bd ll lm ln lo lp lq lr ls lt jz lu ka lv kc lw kd lx kf ly kg lz ma bi translated">良好实践</h1><p id="79af" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">更好的做法是将值转换为包含原始值的元组:</p><pre class="mg mh mi mj gt mv li mw mx aw my bi"><span id="2fd1" class="mz lk it li b gy na nb l nc nd">map(v =&gt; ([v, `${v}`]))</span></pre><p id="50f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，当转换返回一个可观察值时，它看起来会很乏味:</p><pre class="mg mh mi mj gt mv li mw mx aw my bi"><span id="2a9f" class="mz lk it li b gy na nb l nc nd">flatMap(id =&gt; zip(of(id), repository.getById(id)))</span></pre><p id="96a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个活生生的例子:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">清单3。使用zip进行转换并保持原始值</figcaption></figure><h1 id="1726" class="lj lk it bd ll lm ln lo lp lq lr ls lt jz lu ka lv kc lw kd lx kf ly kg lz ma bi translated">更好的实践</h1><p id="ad9e" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">两个操作符<code class="fe lf lg lh li b">zipMap</code>和<code class="fe lf lg lh li b">flatZipMap</code>提供了现成的“转换结果的压缩”。</p><pre class="mg mh mi mj gt mv li mw mx aw my bi"><span id="9907" class="mz lk it li b gy na nb l nc nd">zipMap(x =&gt; `${v}`)</span></pre><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/405f0b15f8688dac9d68ca9171c55993.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*ndtFa94FjZnkicshJyg-pA.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图一。zipMap的大理石图</figcaption></figure><p id="fc8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，当转换返回一个可观察值时，它看起来很简洁:</p><pre class="mg mh mi mj gt mv li mw mx aw my bi"><span id="942b" class="mz lk it li b gy na nb l nc nd">flatZipMap(repository.getById)</span></pre><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9025ff3bc5cc397f8ac3e9c1fa9c59cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*o8ENdVN8M1BAGe3MuEPyAQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图二。flatZipMap的大理石图</figcaption></figure><p id="ee33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用清单3中的<code class="fe lf lg lh li b">flatZipMap</code>，代码如下所示:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">清单4。使用flatZipMap来转换</figcaption></figure><h1 id="374c" class="lj lk it bd ll lm ln lo lp lq lr ls lt jz lu ka lv kc lw kd lx kf ly kg lz ma bi translated">结论</h1><p id="aa7e" class="pw-post-body-paragraph ki kj it kk b kl mb ju kn ko mc jx kq kr md kt ku kv me kx ky kz mf lb lc ld im bi translated">要使用可观察对象的原始值，将可观察对象的值转换为元组，并将原始值保留为坐标之一。操作符<code class="fe lf lg lh li b">zipMap</code>和<code class="fe lf lg lh li b">flatZipMap</code>使得这样做很容易。此外，当其中一个值不再需要时，可以使用操作符<code class="fe lf lg lh li b">projectToFormer</code>和<code class="fe lf lg lh li b">projectToLatter</code>轻松地将其删除:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">清单5。使用projectToLatter</figcaption></figure><p id="534b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要了解更多信息，请参考以下链接:</p><ul class=""><li id="a440" class="ng nh it kk b kl km ko kp kr ni kv nj kz nk ld nl nm nn no bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/13-handy-rxjs-operators-ab5a9a1db60">《13个得心应手的RxJS操作者》</a>中篇</li><li id="f51d" class="ng nh it kk b kl np ko nq kr nr kv ns kz nt ld nl nm nn no bi translated"><a class="ae mr" href="https://github.com/rxjsx/rxjsx" rel="noopener ugc nofollow" target="_blank"> RxJSx GitHub库</a></li><li id="5d23" class="ng nh it kk b kl np ko nq kr nr kv ns kz nt ld nl nm nn no bi translated">在Twitter 上关注<a class="ae mr" href="https://twitter.com/MohammadAliEN" rel="noopener ugc nofollow" target="_blank">我，获取关于该主题的更多更新</a></li></ul></div></div>    
</body>
</html>