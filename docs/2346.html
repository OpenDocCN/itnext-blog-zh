<html>
<head>
<title>Multi Page Application with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带React的多页面应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/building-multi-page-application-with-react-f5a338489694?source=collection_archive---------0-----------------------#2019-05-09">https://itnext.io/building-multi-page-application-with-react-f5a338489694?source=collection_archive---------0-----------------------#2019-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ccf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在web开发领域，我们可以列出web应用程序的两种主要设计模式:多页面应用程序(MPA)和单页面应用程序(SPA)。在这篇博文中，我将重点介绍react库在多页面应用程序中的集成。传统架构需要重新加载网页，以便在用户浏览器中从服务器加载数据或向服务器发送数据。</p><p id="ab35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我打算做的是准备一个Webpack配置，将React组件包含到生成的静态页面(即html文件)中。我将介绍项目创建和设置的步骤。</p><p id="6add" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为一张图片，或者在这种情况下，一些代码，胜过千言万语，这里有一个示例来说明上面静态页面的概念:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6429a3fe864f67a16ca69f1658647c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvViaaSEUlXzu0tNkd9iuw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">添加到静态页面的几个React组件。</figcaption></figure><h1 id="70ba" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">先决条件列表</h1><p id="0b9b" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">本教程假设您已经安装了带有npm的节点:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="5f70" class="mm lf it mi b gy mn mo l mp mq">$ node -v<br/>v10.11.0</span><span id="60a1" class="mm lf it mi b gy mr mo l mp mq">$ npm -v<br/>6.4.1</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="8cda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事不宜迟，让我们创建<em class="mz"> package.json </em>文件:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="c8f5" class="mm lf it mi b gy mn mo l mp mq">$ npm init</span></pre><p id="a964" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mz">注意:添加-y/ — yes标志以跳过问题并使用默认值</em></p><p id="466d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们要准备项目的结构，如下所示:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="2ebb" class="mm lf it mi b gy mn mo l mp mq">├── src<br/>|   ├── components/<br/>|   |   └── Menu.js<br/>|   └── pages/<br/>|       ├── products/<br/>|       |   ├── product-1.js<br/>|       |   └── product-1.html<br/>|       ├── contact.js<br/>|       ├── contact.html<br/>|       ├── index.js<br/>|       └── index.html<br/>├── package.json<br/>└── webpack.config.js</span></pre><p id="e55f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了加快这个过程，我们可以执行这个命令:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="646a" class="mm lf it mi b gy mn mo l mp mq">$ touch webpack.config.js &amp;&amp; mkdir -p src/components &amp;&amp; mkdir -p src/pages/products &amp;&amp; touch src/components/Menu.js &amp;&amp; touch src/pages/products/product-1.js &amp;&amp; touch src/pages/products/product-1.html &amp;&amp; touch src/pages/contact.js &amp;&amp; touch src/pages/contact.html &amp;&amp; touch src/pages/index.js &amp;&amp; touch src/pages/index.html</span></pre><p id="4170" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，我们在pages目录中看到的是一堆文件名相同的js和html文件。这个文件名提示webpack将适当的js文件链接到html文件。例如，对于成对的index.html和index.js文件，webpack生成包含index.js文件的index.html文件，该文件又导入React组件。在我深入研究webpack配置之前，让我们在那些空文件中编写一些代码。</p><p id="b606" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们定义菜单组件:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">/src/components/菜单. js</figcaption></figure><p id="e478" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，在index.js中，放置以下代码，该代码将导入在上一步中创建的菜单组件:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">/src/pages/index.js —将粘贴代码复制到contact.js和product-1.js文件中</figcaption></figure><p id="3c32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，编辑将呈现<menu> react组件的index.html文件:</menu></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">/src/pages/index.html —将代码复制粘贴到contact.html和product-1.html文件中，更改<title>标记</title></figcaption></figure><p id="a35f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">html文件中最有趣的部分是带有id HTML属性“menu”的<em class="mz"> &lt; div &gt; </em>标签，菜单组件将放置在该标签中。在此之前，我们需要设置一些工具，比如捆绑器和开发服务器，它们将帮助我们完成这项工作。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="5811" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">安装依赖关系</strong></p><p id="ac64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于该项目，我们将安装webpack模块捆绑器、<strong class="js iu"> webpack-cli </strong>以在命令行中使用webpack(即，在package.json文件中)、<strong class="js iu"> html-webpack-plugin </strong>以生成包含所有webpack捆绑包的html文件，以及<strong class="js iu"> webpack-dev-server </strong>作为提供实时重新加载的开发服务器:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="1822" class="mm lf it mi b gy mn mo l mp mq">$ npm i webpack webpack-cli webpack-dev-server html-webpack-plugin --save-dev</span></pre><p id="de46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来我们安装<strong class="js iu"> react </strong>和<strong class="js iu"> react-dom </strong>(它是react和dom之间的粘合剂，允许它呈现组件和访问DOM):</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="35d1" class="mm lf it mi b gy mn mo l mp mq">$ npm i react react-dom --save</span></pre><p id="cffc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了React，我们还需要安装巴别塔插件，增加对ES6和JSX的支持:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="5666" class="mm lf it mi b gy mn mo l mp mq">$ npm i @babel/core @babel/preset-env @babel/preset-react babel-loader --save-dev</span></pre><p id="a18c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们安装好之后，我们可以将<em class="mz">构建</em>和<em class="mz">启动</em>脚本添加到<em class="mz"> package.json: </em></p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="a2a3" class="mm lf it mi b gy mn mo l mp mq">{<br/>   "name": "multi-page-app-with-react",<br/>   "version": "1.0.0",<br/>   "description": "Multi Page Application with React",<br/>   "main": "index.js",<br/>   <strong class="mi iu">"scripts": { <br/>      "build": "webpack — mode production", <br/>      "start": "webpack-dev-server — mode development — hot — open — port 3100" <br/>   }<br/>   </strong>"keywords": [],<br/>   "author": "",<br/>   "license": "ISC"<br/>}</span></pre><p id="d6c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mz">构建</em> </strong> <em class="mz">脚本在生产模式下运行，以缩短加载时间(即缩减代码、减轻源代码映射等)<br/> </em> <strong class="js iu"> <em class="mz">启动</em> </strong> <em class="mz">脚本在开发模式下运行服务器，进行热模块替换，并在服务器启动后打开浏览器。</em></p><p id="7fdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在运行这些脚本之前，我们需要编辑和设置<strong class="js iu"> webpack.config.js </strong>文件。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="5f82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">网络包配置</strong></p><p id="0158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先我们要通过配置webpack.comfig.js文件中的<strong class="js iu"> entry </strong>属性来定义入口点。我们想告诉Webpack每个页面只使用一个入口点。这可以通过将定义了entryChunkName键的对象和js文件的路径作为值传递来实现:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="e465" class="mm lf it mi b gy mn mo l mp mq">module.exports = {<br/>  entry: {<br/>    'index' : './src/index.js',<br/>    'products/product-1': './src/pages/products/product-1.js',<br/>    'contact' : './src/pages/contact.js'<br/>  }<br/>};</span></pre><p id="7798" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显然，我们不想像上面那样硬编码，因为每当我们添加一个新页面时，这个配置都必须更新。期望的解决方案是找到所有。js文件，并根据结果生成一个带有入口点的对象。</p><p id="b24e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们将在files.js中实现<em class="mz"> getFilesFromDir </em>函数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">/config/files . js-getFilesFromDir递归函数返回由文件扩展名筛选出的给定目录中的文件路径</figcaption></figure><p id="4b83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们可以用<em class="mz"> getFilesFromDir </em>函数的修改结果导入并替换条目属性:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="6eb2" class="mm lf it mi b gy mn mo l mp mq">const path = require("path");<br/><strong class="mi iu">const getFilesFromDir = require("./config/files");</strong><br/>const PAGE_DIR = path.join("src", "pages", path.sep);</span><span id="fcfc" class="mm lf it mi b gy mr mo l mp mq">const jsFiles = <strong class="mi iu">getFilesFromDir</strong>(PAGE_DIR, ["<strong class="mi iu">.js</strong>"]);<br/>const <strong class="mi iu">entry</strong> = jsFiles.reduce( (obj, filePath) =&gt; {<br/>   const entryChunkName = filePath.replace(path.extname(filePath), "").replace(PAGE_DIR, "");<br/>   obj[entryChunkName] = `./${filePath}`;<br/>   return obj;<br/>}, {});</span><span id="7ad4" class="mm lf it mi b gy mr mo l mp mq">module.exports = {<br/>  <strong class="mi iu">entry: entry</strong><br/>};</span></pre><p id="0be9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mz">注意:webpack.config.js文件的最终版本可以在下面找到(见要点文件)。</em></p><p id="5702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当入口点设置好后，我们就可以跳转到<strong class="js iu"> html-webpack-plugin </strong>部分的配置了。这个插件的主要目标是生成一个html文件(在<strong class="js iu"> dist </strong>文件夹中)，包括相应的javascript文件。例如，如果我们已经生成了一个联系页面，我们期望将带有<em class="mz"> contact.js </em>文件的<em class="mz">contact.html</em>包含在<em class="mz">&lt;body&gt;</em>by<em class="mz">&lt;script&gt;</em>标签中。至少，我们希望提供三种配置选项:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="f1e7" class="mm lf it mi b gy mn mo l mp mq">plugins:[<br/>  new HtmlWebPackPlugin({<br/>    chunks:["contact", "vendor"],<br/>    template: "src/pages/contact.html",<br/>    filename: "contact.html"<br/>})]</span></pre><p id="fc11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> chunks </strong>属性<strong class="js iu"> </strong>通过<em class="mz"> &lt;脚本&gt; </em>标签定义包含在<strong class="js iu">模板</strong>文件<strong class="js iu"> </strong>中的代码库，并生成名为<strong class="js iu">文件名</strong>的html文件作为输出。<br/>由于我们希望将供应商(即第三方库)和应用程序代码拆分成单独的包，我们必须将<strong class="js iu"> "vendor" </strong>元素添加到<strong class="js iu"> chunks </strong>表中。在讨论优化时，我会写得更多。</p><p id="a282" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个插件配置是正确的，但是如果我们想要遵循这个结构，我们必须为每个html文件硬编码创建HtmlWebPackPlugin对象。出于与入口点定义相同的原因，我们不想这样做。这就是为什么我们将再次使用<strong class="js iu"> getFileFromDir </strong>函数，但这次我们将只搜索html文件:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="00df" class="mm lf it mi b gy mn mo l mp mq">const HtmlWebPackPlugin = require("html-webpack-plugin");<br/>const htmlFiles = <strong class="mi iu">getFilesFromDir</strong>(PAGE_DIR, ["<strong class="mi iu">.html</strong>"]);</span><span id="9d9c" class="mm lf it mi b gy mr mo l mp mq">const <strong class="mi iu">htmlPlugins</strong> = htmlFiles.map( filePath =&gt; {<br/>  const fileName = filePath.replace(PAGE_DIR, "");<br/>  return new HtmlWebPackPlugin({<br/>    chunks:[fileName.replace(path.extname(fileName), ""), "vendor"],<br/>    template: filePath,<br/>    filename: fileName})<br/>});</span><span id="ee90" class="mm lf it mi b gy mr mo l mp mq">module.exports = {<br/>  entry: entry,<br/>  <strong class="mi iu">plugins: [...htmlPlugins]</strong><br/>};</span></pre><p id="0d4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了更容易地导入模块，我们还可以通过为模块解析器设置<em class="mz">别名</em>来别名常用的“组件”和“src”文件夹:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="ac3f" class="mm lf it mi b gy mn mo l mp mq">module.exports = {<br/>  entry: entry,<br/>  plugins: [...htmlPlugins],<br/>  <strong class="mi iu">resolve:{<br/>     alias:{<br/>        src: path.resolve(__dirname, "src"),<br/>        components: path.resolve(__dirname, "src", "components")<br/>     }<br/>  }</strong>,<br/>};</span></pre><p id="f55f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，Webpack将在解析模块导入时使用此别名，如下所示:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="1681" class="mm lf it mi b gy mn mo l mp mq">import Menu from "components/Menu";</span></pre><p id="d059" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而不是对文件位置变化敏感的默认导入机制，即:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="e4da" class="mm lf it mi b gy mn mo l mp mq">import Menu from "../../components/Menu";</span></pre><p id="fe82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后但同样重要的是，我们必须设置babel-loader来使React工作(即把ES6转换成ES5代码，把JSX转换成javascript):</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="56b4" class="mm lf it mi b gy mn mo l mp mq">module.exports = {<br/>  <em class="mz"> // put previously defined properties here (entry, plugins etc)<br/> </em> <strong class="mi iu"> module: {<br/>      rules: [{<br/>         test: /\.js$/,<br/>         exclude: /node_modules/,<br/>         use: {<br/>            loader:”babel-loader”,<br/>               options:{<br/>                  presets: [<br/>                     “@babel/preset-env”,<br/>                     “@babel/preset-react”<br/>                  ]<br/>               }<br/>         }<br/>      }]<br/>   },</strong><br/>}</span></pre><p id="2b01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mz">注:也可将预置放入。babelrc文件</em></p><p id="c910" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们可以构建项目:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="6714" class="mm lf it mi b gy mn mo l mp mq">$ npm run build</span></pre><p id="a31a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">瞧！如果一切顺利，我们应该看到<strong class="js iu"> dist </strong>目录，其中包含基于“pages”文件夹生成的html和js文件。</p><p id="ee6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，我们的js文件仍然有一个问题。如果你编辑它们中的任何一个，你会看到它们包括一个应用和第三方源代码(即与其他库反应)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/916f3b8f9bb28ed86ca5a6eab6d3c58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkW3TbFXKC_b-uOYGdWtaQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">优化前index.js文件的内容包括React和其他库的代码。</figcaption></figure><p id="b035" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这产生了两个问题:</p><ol class=""><li id="b23d" class="nd ne it js b jt ju jx jy kb nf kf ng kj nh kn ni nj nk nl bi translated">一个巨大的文件意味着当我们改变一行代码时，用户必须重新下载整个文件</li><li id="b441" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">每个js文件都包含并下载了相同的第三方源代码。我的意思是index.js、contact.js和product-1.js文件包含相同的React代码。</li></ol><p id="cd7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题的解决方案是将第三方库分离到一个单独的<em class="mz"> vendor.js </em>文件中。因此，让我们使用splitChunksPlugin将我们的包拆分到一个单独的文件中，splitChunksPlugin成为Webpack4中代码拆分的默认解决方案。</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="8a88" class="mm lf it mi b gy mn mo l mp mq">module.exports = {<br/>  <em class="mz"> // put previously defined properties here (entry, plugins etc)</em><br/>   <strong class="mi iu">optimization: {<br/>      splitChunks: {<br/>         cacheGroups: {<br/>            vendor: {<br/>               test: /node_modules/,<br/>               chunks: "initial",<br/>               name: "vendor",<br/>               enforce: true<br/>            }<br/>         }<br/>      }<br/>   }</strong><br/>}</span></pre><p id="8385" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是最终的<strong class="js iu"> webpack.config.js </strong>文件<strong class="js iu"> </strong>经过所有修改后的样子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">网络包.配置. js</figcaption></figure><p id="565c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以再次构建我们的应用程序:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="d933" class="mm lf it mi b gy mn mo l mp mq">$ npm run build</span></pre><p id="c53b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是这次构建完成后，我们将在<em class="mz"> dist </em>文件夹中看到新的<em class="mz"> vendor.js </em>文件。此文件仅包含第三方源代码，其他*。图中可见的js文件现在应该没有这段代码了。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nr"><img src="../Images/5d3f575b67962c82569c685c0b32b6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*cXof5pd7baWZosVZKHGUpQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">优化后生成的文件</figcaption></figure><p id="1a81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们准备好所有这些元素后，我们最终可以通过输入以下命令在开发模式下运行project:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="be9e" class="mm lf it mi b gy mn mo l mp mq">$ npm start</span></pre><p id="9237" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是什么？</p><p id="fa08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">众所周知，总有改进的空间，所以我们可以很容易地扩展CSS/SCSS加载器的配置，添加linter，hashes到。js文件名(用于缓存失效目的)和做许多其他很酷的事情。对于任何想要克隆这个配置并进行上述改进的人，我准备了这个<a class="ae ns" href="https://github.com/przemek-nowicki/multi-page-app-with-react" rel="noopener ugc nofollow" target="_blank"> github库</a>。</p><div class="nt nu gp gr nv nw"><a href="https://github.com/przemek-nowicki/multi-page-app-with-react" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">przemek-nowicki/多页应用程序-使用-反应</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">扳手:一个轻量级、灵活的webpack设置，带有React，用于多页面应用程序开发…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ky nw"/></div></div></a></div></div></div>    
</body>
</html>