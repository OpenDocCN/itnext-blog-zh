<html>
<head>
<title>Redis Streams in Action — Part 2 (Tweets consumer app)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis Streams在行动——第二部分(Tweets消费者应用)</h1>
<blockquote>原文：<a href="https://itnext.io/redis-streams-in-action-part-2-tweets-consumer-app-674fd3b45f6f?source=collection_archive---------1-----------------------#2021-05-28">https://itnext.io/redis-streams-in-action-part-2-tweets-consumer-app-674fd3b45f6f?source=collection_archive---------1-----------------------#2021-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="93e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建一个Rust应用程序，从Twitter流API中使用</h2></div><p id="5740" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎阅读这一系列的博客文章，这些文章通过一个实际的例子介绍了<a class="ae lb" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank"> Redis Streams </a>。我们将使用一个示例应用程序来实时搜索和查询Twitter数据。<a class="ae lb" href="https://redisearch.io/" rel="noopener ugc nofollow" target="_blank">redi research</a>和<a class="ae lb" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank">redi Streams</a>是这个解决方案的主干，它由几个合作组件组成，每个组件都将在一篇专门的博客文章中介绍。</p><ul class=""><li id="865e" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-1-intro-and-overview-135f66d3ab58">第一部分</a></li><li id="6ad9" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">第二部分——这个博客</li><li id="ff2d" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-3-tweets-processor-app-254161838973">第三部分</a></li><li id="fb54" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-4-serverless-monitoring-service-faef52ee58db">第四部分</a></li></ul><blockquote class="lq lr ls"><p id="d86f" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">本GitHub回购中有代码—</em><a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://github.com/abhirockzz/redis-streams-in-action</em></a></p></blockquote><p id="8afb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一部分中，我们将关注与Twitter流API交互的服务，以消费tweets并将其移动到处理管道中的下一部分。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/87a8738131a6e944c74ceaa2678ad6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xb-k_d1E1Cu5iH3p.jpg"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">高层建筑</figcaption></figure><p id="3b6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的最终目标是能够处理推文，并通过<code class="fe mn mo mp mq b">RediSearch</code>使它们可用于搜索和查询。人们可以编写一个“尽一切努力”的服务来消费推文，并将它们直接存储在<code class="fe mn mo mp mq b">RediSearch</code>中。但是，为了扩展以处理大量的tweets，我们需要一个服务来充当缓冲，并分离我们的生产者(我们将在这篇博客中关注的应用程序)和消费者(在下一篇博客中讨论)。</p><p id="fa31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这正是我们的第一个组件所促进的——它消费流Twitter数据并将其转发到Redis流。我们将把它部署到<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/container-instances-overview?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Container实例</a>，验证它的功能，并演示它如何与代码一起工作。</p><blockquote class="lq lr ls"><p id="fabe" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">正如您将在本系列的后续部分中看到的，这也为横向扩展架构提供了基础。</p></blockquote><p id="6768" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总而言之，这篇博文短小精悍！它为解决方案的其他部分奠定了基础，这些部分将在后续的文章中讨论。请不要担心这个服务是用Rust编写的(以防你还不知道)。这种逻辑可以很容易地移植到您喜欢的编程语言中。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="8872" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">先决条件</h1><p id="eac2" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">如果你还没有一个免费的Azure账户的话，先申请一个<a class="ae lb" href="https://azure.microsoft.com/free/?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank">账户</a>，然后<a class="ae lb" href="https://docs.microsoft.com/cli/azure/install-azure-cli?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank">安装Azure CLI </a>。</p><p id="dead" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用常规的Docker CLI命令将tweets消费者应用程序部署到<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/container-instances-overview?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure容器实例</a>。Docker和Azure 之间的<a class="ae lb" href="https://docs.docker.com/engine/context/aci-integration/" rel="noopener ugc nofollow" target="_blank">集成实现了这一功能。只要确保你有Docker桌面版2.3.0.5或更高版本，用于</a><a class="ae lb" href="https://desktop.docker.com/win/edge/Docker%20Desktop%20Installer.exe" rel="noopener ugc nofollow" target="_blank"> Windows </a>、<a class="ae lb" href="https://desktop.docker.com/mac/edge/Docker.dmg" rel="noopener ugc nofollow" target="_blank"> macOS </a>，或者安装<a class="ae lb" href="https://docs.docker.com/engine/context/aci-integration/#install-the-docker-aci-integration-cli-on-linux" rel="noopener ugc nofollow" target="_blank"> Docker ACI集成CLI用于Linux </a>。</p><p id="1950" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用Twitter流API，您还需要一个Twitter开发者帐户。如果您还没有，请<a class="ae lb" href="https://developer.twitter.com/en/apply-for-access" rel="noopener ugc nofollow" target="_blank">按照这些说明</a>进行设置。</p><h1 id="f43d" class="my mz iq bd na nb nv nd ne nf nw nh ni jw nx jx nk jz ny ka nm kc nz kd no np bi translated">将应用部署到Azure容器实例</h1><p id="868e" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">首先，使用这个快速入门设置Redis的Azure缓存企业层。完成此步骤后，请确保保存以下信息:Redis主机名和访问密钥</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oa"><img src="../Images/7c461ba2d6a55c644bf70a292c6d5559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8z99fiewZMudP9wf.png"/></div></div></figure><p id="b43c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">tweets消费者应用程序作为一个<a class="ae lb" href="https://hub.docker.com/r/abhirockzz/tweets-redis-streams-producer-rust" rel="noopener ugc nofollow" target="_blank"> Docker容器</a>可用——最简单的方法就是简单地重用它。如果您希望创建自己的图像，请使用GitHub repo 中的<code class="fe mn mo mp mq b"><a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action/blob/master/tweets-consumer/Dockerfile" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code> <a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action/blob/master/tweets-consumer/Dockerfile" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cc26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您将看到将它部署到Azure容器实例是多么方便，这允许您在托管的、无服务器的Azure环境中按需运行Docker容器。</p><p id="8e17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/quickstart-docker-cli?WT.mc_id=data-17927-abhishgu#create-azure-context" rel="noopener ugc nofollow" target="_blank">创建一个Azure上下文</a>将Docker与Azure订阅和资源组关联起来，这样您就可以创建和管理容器实例。</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="a035" class="of mz iq mq b gy og oh l oi oj">docker login azure<br/>docker context create aci aci-context<br/>docker context use aci-context</span></pre><p id="0879" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置环境变量—确保根据您的帐户更新Redis主机和凭据:</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="8190" class="of mz iq mq b gy og oh l oi oj">export REDIS_HOSTNAME=&lt;redis host port e.g. my-redis-host:10000&gt;<br/>export IS_TLS=true<br/>export REDIS_PASSWORD=&lt;redis access key (password)&gt;</span><span id="9a8a" class="of mz iq mq b gy ok oh l oi oj"># don't forget your twitter api credentials<br/>export TWITTER_API_KEY=&lt;api key&gt;<br/>export TWITTER_API_KEY_SECRET=&lt;api key secret&gt;<br/>export TWITTER_ACCESS_TOKEN=&lt;access token&gt;<br/>export TWITTER_ACCESS_TOKEN_SECRET=&lt;access token secret&gt;</span></pre><p id="19ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就执行好老<code class="fe mn mo mp mq b">docker run</code>:</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="6e67" class="of mz iq mq b gy og oh l oi oj">docker run -d --name redis-streams-producer \<br/>-e REDIS_HOSTNAME=$REDIS_HOSTNAME \<br/>-e IS_TLS=$IS_TLS \<br/>-e REDIS_PASSWORD=$REDIS_PASSWORD \<br/>-e TWITTER_API_KEY=$TWITTER_API_KEY \<br/>-e TWITTER_API_KEY_SECRET=$TWITTER_API_KEY_SECRET \<br/>-e TWITTER_ACCESS_TOKEN=$TWITTER_ACCESS_TOKEN \<br/>-e TWITTER_ACCESS_TOKEN_SECRET=$TWITTER_ACCESS_TOKEN_SECRET \<br/>abhirockzz/tweets-redis-streams-producer-rust</span></pre><p id="78e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在应该在Azure中创建了一个容器，您应该会看到类似如下的输出:</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="b11f" class="of mz iq mq b gy og oh l oi oj">[+] Running 2/2<br/> ⠿ Group redis-streams-producer  Created                                                                             4.2s<br/> ⠿ redis-streams-producer        Created                                                                            15.8s</span></pre><p id="79ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Azure门户对此进行验证:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oa"><img src="../Images/3d1b0b7a3c9bb7b707f1ee7ad4b172d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vAHTDXTsXzJA0tkF.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">在Azure容器实例中发布消费者应用</figcaption></figure><p id="c9ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要检查容器日志:</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="be1e" class="of mz iq mq b gy og oh l oi oj">docker logs redis-streams-producer</span></pre></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="4880" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">那么，这有用吗？</h1><p id="9ec4" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">嗯，应该的！要进行确认，请使用<code class="fe mn mo mp mq b">redis-cli</code>连接到Redis实例:</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="5295" class="of mz iq mq b gy og oh l oi oj">redis-cli -h &lt;redis cache host&gt; -p &lt;redis port&gt; -a &lt;access key&gt; --tls</span></pre><p id="cdf0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…并运行<a class="ae lb" href="https://redis.io/commands/xrange" rel="noopener ugc nofollow" target="_blank"> XRANGE </a>命令来检查Redis流:</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="30fd" class="of mz iq mq b gy og oh l oi oj">XRANGE tweets_stream - + COUNT 5</span></pre><p id="0155" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将返回前五条推文。您可以根据需要更换<code class="fe mn mo mp mq b">COUNT</code>。</p><blockquote class="lq lr ls"><p id="bdda" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq"/><code class="fe mn mo mp mq b"><em class="iq">-</em></code><em class="iq">和</em> <code class="fe mn mo mp mq b"><em class="iq">+</em></code> <em class="iq">特殊ID分别表示流内可能的最小ID和最大ID</em></p></blockquote><p id="5d86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是确认我们的应用程序能够消费tweets并将其添加到Redis流所需的全部内容。如前所述，我们解决方案中的其余组件将构建在此基础之上。</p><p id="9212" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以暂时暂停应用程序，也可以将其删除:</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="7031" class="of mz iq mq b gy og oh l oi oj">#to pause<br/>docker stop redis-streams-producer</span><span id="67ed" class="of mz iq mq b gy ok oh l oi oj">#to delete<br/>docker rm redis-streams-producer</span></pre><p id="1d96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然您已经看到了运行中的应用程序，让我们快速浏览一下“如何”工作。如果您对探索Rust代码感兴趣，您会发现它很有用。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="7950" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">代码遍历</h1><blockquote class="lq lr ls"><p id="0bde" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">你可以</em> <a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action/tree/master/tweets-consumer/src" rel="noopener ugc nofollow" target="_blank"> <em class="iq">参考这里的代码</em> </a></p></blockquote><p id="123d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序使用以下库:</p><ul class=""><li id="d6f2" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">用于访问<a class="ae lb" href="https://github.com/tesaguri/twitter-stream-rs" rel="noopener ugc nofollow" target="_blank"> Twitter流API </a>的Rust库(使用<a class="ae lb" href="https://github.com/tokio-rs/tokio" rel="noopener ugc nofollow" target="_blank"> tokio </a></li><li id="0d7e" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://github.com/mitsuhiko/redis-rs" rel="noopener ugc nofollow" target="_blank"> redis-rs </a>，redis的Rust库，有高级和低级API</li><li id="28fb" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://github.com/serde-rs/serde" rel="noopener ugc nofollow" target="_blank"> serde </a>和<a class="ae lb" href="https://github.com/serde-rs/json" rel="noopener ugc nofollow" target="_blank"> serde json </a></li></ul><p id="28fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它首先连接到Redis和Twitter:</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="b083" class="of mz iq mq b gy og oh l oi oj">fn connect_redis() -&gt; redis::Connection {<br/>    println!("Connecting to Redis");<br/>    let redis_host_name =<br/>        env::var("REDIS_HOSTNAME").expect("missing environment variable REDIS_HOSTNAME");<br/>    let redis_password = env::var("REDIS_PASSWORD").unwrap_or_default();</span><span id="561f" class="of mz iq mq b gy ok oh l oi oj">    //if Redis server needs secure connection<br/>    let uri_scheme = match env::var("IS_TLS") {<br/>        Ok(_) =&gt; "rediss",<br/>        Err(_) =&gt; "redis",<br/>    };</span><span id="d9dc" class="of mz iq mq b gy ok oh l oi oj">    let redis_conn_url = format!("{}://:{}@{}", uri_scheme, redis_password, redis_host_name);<br/>    println!("redis_conn_url {}", redis_conn_url);</span><span id="9db3" class="of mz iq mq b gy ok oh l oi oj">    let client = redis::Client::open(redis_conn_url).expect("check Redis connection URL");<br/>    client.get_connection().expect("failed to connect to Redis")<br/>}</span></pre><p id="3126" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需连接到<a class="ae lb" href="https://developer.twitter.com/en/docs/twitter-api/tweets/sampled-stream/api-reference/get-tweets-sample-stream" rel="noopener ugc nofollow" target="_blank"> Twitter样本流</a>，就可以实时访问大约1%的推文，而不是跟踪一组特定的关键词或用户:</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="0e30" class="of mz iq mq b gy og oh l oi oj">let token = twitter_token();</span><span id="6fbb" class="of mz iq mq b gy ok oh l oi oj">    TwitterStream::sample(&amp;token)<br/>        .try_flatten_stream()<br/>        .try_for_each(|json| {<br/>            let msg: model::StreamMessage =<br/>                serde_json::from_str(&amp;json).expect("failed to convert tweet JSON to struct");<br/>            process(msg, c.clone());<br/>            future::ok(())<br/>        })<br/>        .await<br/>        .expect("error connecting to Twitter stream!");</span></pre><p id="7613" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大部分逻辑封装在<code class="fe mn mo mp mq b">process</code>函数中。让我们一点一点来看。<br/> <code class="fe mn mo mp mq b">twitter-stream</code> crate以原始JSON形式返回每条tweet。它被转换成一个<code class="fe mn mo mp mq b">model::StreamMessage</code>，这是一个根据我们打算从原始推文中提取的数据建模的结构。</p><p id="39e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe mn mo mp mq b">serde_json</code>来完成这项工作:</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="3f9e" class="of mz iq mq b gy og oh l oi oj">serde_json::from_str(&amp;json).expect("json to struct conversion failed");</span></pre><p id="0b49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后它和一个<a class="ae lb" href="https://docs.rs/redis/0.20.0/redis/struct.Connection.html" rel="noopener ugc nofollow" target="_blank"> redis::Connection </a>一起被传递给<code class="fe mn mo mp mq b">process</code>函数。</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="2f63" class="of mz iq mq b gy og oh l oi oj">let conn = connect_redis();<br/>let c = Arc::new(Mutex::new(conn));<br/>...<br/>fn process(msg: model::StreamMessage, conn: Arc&lt;Mutex&lt;redis::Connection&gt;&gt;) {<br/>    //omitted<br/>}</span></pre><p id="4feb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是为什么要把它包在<a class="ae lb" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html" rel="noopener ugc nofollow" target="_blank">互斥</a>的<a class="ae lb" href="https://doc.rust-lang.org/std/sync/struct.Arc.html" rel="noopener ugc nofollow" target="_blank">弧</a>中呢？</p><p id="6422" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为我们需要将<code class="fe mn mo mp mq b">redis::Connection</code>传递给<code class="fe mn mo mp mq b">FnMut</code>闭包。它<a class="ae lb" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="noopener ugc nofollow" target="_blank">移动</a>连接，因此我们需要使用一个共享引用，这是<code class="fe mn mo mp mq b">Arc</code>提供的。但是<code class="fe mn mo mp mq b">Arc</code>是不够的，因为我们不允许改变数据。因此，我们使用一个<code class="fe mn mo mp mq b">Mutex</code>来锁定连接对象Rust编译器可以确信一次只有一个线程可以访问它(保持不变性)</p><p id="efb0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">加工部分比较简单。这都是关于使用<a class="ae lb" href="https://docs.rs/redis/0.20.0/redis/trait.Commands.html#method.xadd_map" rel="noopener ugc nofollow" target="_blank"> xadd_map </a>函数将推文添加到Redis流。它接受一个<a class="ae lb" href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html" rel="noopener ugc nofollow" target="_blank"> BTreeMap </a>，这是我们从<code class="fe mn mo mp mq b">model::StreamMessage</code>中的信息创建的tweet文本、twitter用户(屏幕)名称、ID、位置和标签(如果有的话)。最终，目标是能够在<code class="fe mn mo mp mq b">RediSearch</code>中索引这些内容，并灵活地查询它们。</p><pre class="ly lz ma mb gt ob mq oc od aw oe bi"><span id="d5ef" class="of mz iq mq b gy og oh l oi oj">let mut stream_entry: BTreeMap&lt;String, String&gt; = BTreeMap::new();<br/>                stream_entry.insert("id".to_string(), tweet.id.to_string());<br/>                stream_entry.insert("user".to_string(), tweet.user.screen_name);<br/>                stream_entry.insert("text".to_string(), tweet.text);<br/>                stream_entry.insert("location".to_string(), tweet.user.location);</span></pre><p id="2df3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这部分到此为止。</p><h1 id="f5bc" class="my mz iq bd na nb nv nd ne nf nw nh ni jw nx jx nk jz ny ka nm kc nz kd no np bi translated">继续下一个…</h1><p id="5b30" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">我们才刚刚开始！这是我们服务中的第一个组件，为处理推文并通过<code class="fe mn mo mp mq b">RediSearch</code>进行查询奠定了基础。在接下来的博客中，我们将深入探讨如何使用基于Java的应用程序消费和处理来自Redis流的tweets。敬请期待！</p></div></div>    
</body>
</html>