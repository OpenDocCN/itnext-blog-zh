<html>
<head>
<title>Abstracting State with NGRX Facades</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NGRX外观抽象状态</h1>
<blockquote>原文：<a href="https://itnext.io/abstracting-state-with-ngrx-facades-4f1f2491041c?source=collection_archive---------8-----------------------#2019-05-27">https://itnext.io/abstracting-state-with-ngrx-facades-4f1f2491041c?source=collection_archive---------8-----------------------#2019-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/475e0ad4dae382c3077d51e369cb1022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TggmpinSAPh1ndMBoTj0bw.png"/></div></div></figure><p id="fcdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是系列文章的第四篇，也是最后一篇，旨在详细解释用NGRX构建Angular应用程序的一步一步的方法。</p><ul class=""><li id="f57c" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在本系列的第一篇文章中，我写了一篇关于NGRX平台所有概念的概述。</li><li id="aa62" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">在<a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/architecting-the-store-in-ngrx-e4955641d746">这个系列的第二篇文章</a>中，我开始编写应用程序的存储和状态的实体。</li><li id="e524" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">在<a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/building-side-effects-in-ngrx-deb0d856096d">这个系列的第三篇文章</a>中，我们构建了负责从Coincap的API获取资产和价格的效果</li></ul><h2 id="354f" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">摘要</h2><p id="ab5b" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">总结一下我在以前的文章中介绍的内容，我们有一个应用程序，旨在显示一个带有加密货币价格的仪表板。</p><p id="c694" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该应用程序的逻辑是使用三个服务模块构建的，每个模块管理我们商店的不同功能。</p><p id="1e29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些是:</p><ul class=""><li id="5c62" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir"> dashboard </strong>，它管理仪表板及其平铺的逻辑</li><li id="4f90" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir">资产，</strong>从<a class="ae lf" href="https://coincap.io" rel="noopener ugc nofollow" target="_blank"> Coincap的</a> API获取的资产列表</li><li id="ed11" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir">价格，</strong>来自Coincap的WebSocket API的价格流</li></ul><p id="7475" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">应用程序的外观:</strong></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/5271496f780c68798b6622c4ffc1a775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*R3-0VFvXB2rq-rAtWyNwxA.gif"/></div></div></figure><h2 id="fc3e" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">在本文中，我们将学习:</h2><ul class=""><li id="8be2" class="kw kx iq ka b kb me kf mf kj mo kn mp kr mq kv lb lc ld le bi translated">什么是门面服务，以及我们如何将它应用到NGRX</li><li id="e9c1" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">使用<strong class="ka ir">外观</strong>创建与<em class="mr">商店</em>连接的精益UI组件</li></ul><h1 id="89df" class="ms lm iq bd ln mt mu mv lq mw mx my lt mz na nb lw nc nd ne lz nf ng nh mc ni bi translated">什么是门面？</h1><p id="ee8b" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">从软件工程的角度来看，门面是作为一个对象来实现的，它在一个更复杂的系统背后提供了一个统一的、更简单的接口。</p><p id="8f0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，它将复杂的系统(<em class="mr"> NGRX </em>)抽象为单一的<em class="mr">服务</em>。</p><p id="52fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对我们有什么用？</p><ul class=""><li id="44e9" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">我们从使用的状态管理中抽象出UI组件</li><li id="35f2" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">我们使用清晰的小方法来简化界面</li><li id="fa08" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">我们最小化一个组件所使用的依赖项的数量</li><li id="d673" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">我们提供一个中央服务来获取数据和分发命令</li></ul><h2 id="d06c" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">优势</h2><ul class=""><li id="185b" class="kw kx iq ka b kb me kf mf kj mo kn mp kr mq kv lb lc ld le bi translated"><strong class="ka ir">抽象</strong> <br/>假设我们使用<em class="mr"> NGRX </em>开始这个项目，有一天我们决定切换到<em class="mr"> NGXS </em>、<em class="mr"> Akita </em>，或者其他一些状态管理工具。通过使用facades，我们永远不必重构依赖于所用库的组件和服务。</li><li id="9876" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir">简单性<br/> </strong>一个facade将对消费者隐藏我们使用的库的技术细节和实现，这导致组件变得精简和简单。</li><li id="68cf" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">可重用性<br/>facade将有助于重用一些用于分派和创建动作的代码，或者从存储中选择片段，因为你永远不需要写两次。</li></ul><p id="1c25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，在NGRX中使用Facade服务也有一些缺点，我建议您阅读文章<a class="ae lf" href="https://auth0.com/blog/ngrx-facades-pros-and-cons/" rel="noopener ugc nofollow" target="_blank"> NgRx Facades:利与弊</a>以获得更好的解释。</p><h1 id="dcd2" class="ms lm iq bd ln mt mu mv lq mw mx my lt mz na nb lw nc nd ne lz nf ng nh mc ni bi translated">实践中的门面服务</h1><p id="40cb" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">但是现在，让我们回到我们的应用程序，应用我们所学的关于立面的知识。</p><p id="05a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将为我们在前几篇文章中构建的每个商店模块实现一个门面服务。</p><p id="74a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Facade服务将是导入商店模块的模块与其内部智能组件之间的接口。</p><p id="7ae4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要构建的唯一功能模块是仪表板功能模块，它将负责定义UI容器和组件，这些组件将通过从商店模块导出的外观服务进行连接。</p><p id="6bf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将构建4个组件:</p><ul class=""><li id="ca35" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">仪表板组件</strong>，它将向商店查询已订阅的资产。最初，没有选择任何资产。</li><li id="2d56" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir"> Tile组件，</strong>将<strong class="ka ir"> </strong>包含资产选择器，如果该Tile没有资产被订阅，否则，如果用户订阅了资产，它将显示资产价格</li><li id="2d51" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir">资产选择器，</strong>用户可以用来选择资产(例如比特币)</li><li id="a871" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir">资产价格器，</strong>显示所选资产的价格以及每个价格的趋势</li></ul><p id="0e08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开始前有几件事:</p><ul class=""><li id="f4c1" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">这些组件将由<a class="ae lf" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank">角形材料</a>提供动力</li><li id="b5ea" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">为了简洁起见，省略了所有的导入，但是将提供到源代码的链接</li></ul><h2 id="9bbe" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">仪表板组件</h2><p id="4f05" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">仪表板组件将负责两件事:</p><ul class=""><li id="a82d" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">初始化时加载资产，使用<em class="mr">资产外观</em></li><li id="40da" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">使用<em class="mr">仪表板外观</em>查询并显示商店中的所有瓷砖</li></ul><p id="190b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们构建组件之前，让我们看一下外观。</p><p id="e531" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先创建<strong class="ka ir">仪表板外观</strong>:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ef56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来分解一下:</p><ul class=""><li id="b034" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir"> tiles$ </strong>是一个从商店中选择所有牌的可观察对象</li><li id="ceca" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">我们有两个方法，<strong class="ka ir"> addTile，</strong>和<strong class="ka ir"> updateTileAsset，</strong>将向商店发送添加和更新磁贴的操作</li></ul><p id="6094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先创建<strong class="ka ir">资产外观</strong>:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9cc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个很简单，我们有:</p><ul class=""><li id="292c" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">从商店中选择的资产列表</li><li id="f5ab" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">使用API调度到效果以获取资源的动作</li></ul><p id="2cdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在来看看UI方面的东西。我们定义了仪表板组件的控制器，它将使用我们上面定义的两个外观:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="0081" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">该组件的模板将使用角形材料的网格列表组件显示瓷砖</li><li id="d25f" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">每个图块的状态被传递给组件<strong class="ka ir"> cf-tile </strong></li><li id="3edf" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">按钮(<code class="fe nl nm nn no b">mat-icon-button</code>)显示在它自己的区域中，用于添加新的空区域</li></ul><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="69ea" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">瓷砖组件</h2><p id="efc5" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">tile组件负责显示资产下拉列表或资产价格(如果已经订阅)。这个组件需要两个立面:</p><ul class=""><li id="4021" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">我们之前定义的仪表板外观</li><li id="0480" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">价格外观，以便在选择资产后创建订阅</li></ul><p id="d09d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们继续定义Pricer外观:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d13c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们打破我们的定义:</p><ul class=""><li id="d93e" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">我们为分派动作定义了两个私有方法:方法<code class="fe nl nm nn no b">addInitalPrice</code>将为订阅的资产创建初始价格，该价格最初为空；另一个方法<code class="fe nl nm nn no b">createSubscription</code>将启动WebSocket订阅，正如我们在上一篇文章中定义效果时看到的<a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/building-side-effects-in-ngrx-deb0d856096d">。</a></li></ul><p id="dac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">瓷砖组件非常简单:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e9e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在模板中，如果定义了<code class="fe nl nm nn no b">assetId</code>，我们简单地使用一个<code class="fe nl nm nn no b">ngSwitch</code>来显示价格，如果没有定义，则使用选择器。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4e5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户选择一个资产时，组件<code class="fe nl nm nn no b">cf-asset-selector</code>将发送一个输出，该输出将调用方法<code class="fe nl nm nn no b">updateTile</code>，该方法将通过为其分配一个<code class="fe nl nm nn no b">assetId</code>来更新tile，然后将调用该方法来创建价格订阅并开始传输资产价格。</p><h2 id="2af2" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">资产选择器组件</h2><p id="b89a" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">资产选择器组件只是一个带有可用资产的下拉列表，当选择了一个资产时，它将发送一个输出。从资产外观中查询资产。简单吧？</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7635" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模板由角形材料制成的<code class="fe nl nm nn no b">mat-select</code>组件驱动，尽管简单的选择就可以完成这项工作。我们只需创建一个select并迭代资产来创建可用选项。</p><p id="9881" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个选项被选中时，输出<code class="fe nl nm nn no b">assetSelected</code>将发出一个新的事件。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="72d0" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">资产定价组件</h2><p id="7ace" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">Asset Pricer组件负责显示价格，并显示价格何时上涨或下跌2秒钟。</p><p id="b5b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到了，这个组件很酷。我们接收一个资产ID作为输入，并创建一个对商店的订阅，以便将价格传递给组件。</p><blockquote class="np nq nr"><p id="39fb" class="jy jz mr ka b kb kc kd ke kf kg kh ki ns kk kl km nt ko kp kq nu ks kt ku kv ij bi translated">从技术上讲，这是一个智能组件，应该将数据传递给非智能组件，但是为了简洁起见，我认为最好在一个组件中显示所有代码</p></blockquote><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ac0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个组件稍微复杂一点，所以我们可能需要分解一下。我们的目标是:</p><ul class=""><li id="0c50" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">当价格下跌时显示红色价格</li><li id="2798" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">价格上涨时显示绿色价格</li><li id="5844" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">2秒钟后价格回到正常状态(白色)</li></ul><p id="1da3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事情是这样的:</p><ul class=""><li id="0dd2" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">我们通过facade方法<code class="fe nl nm nn no b">getPriceForAsset</code>得到一个价格，并简单地映射到它的格式化版本</li><li id="a78d" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">我们将通过<code class="fe nl nm nn no b">shareReplay(1)</code>收到的最新价格存储在内存中，这样我们可以重用订阅来计算趋势</li><li id="85dc" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">每当我们得到一个新价格，我们就创建一个计时器，将价格状态映射到<code class="fe nl nm nn no b">Stale</code></li><li id="e6b9" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">我们使用运算符<code class="fe nl nm nn no b">pairwise</code>,它给出了当前订阅的当前值和以前值，因此我们可以计算出价格是上涨了还是下跌了</li><li id="905c" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">趋势是价格变化时发出的可观察信号，通过合并计时器和趋势结果获得。每当我们有一个价格变化时，它首先变成红色或绿色，然后在2秒钟后当可观察的<code class="fe nl nm nn no b">timer$</code>发出一个值时回到正常状态</li></ul><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b68a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模板非常简单，就是商店获得的价格，在价格未定义时由微调器替换，这意味着订阅仍在进行中。</p><p id="a6f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加了类<code class="fe nl nm nn no b">trend-up</code>和<code class="fe nl nm nn no b">trend-down</code>来设计价格的颜色。</p><h1 id="c196" class="ms lm iq bd ln mt mu mv lq mw mx my lt mz na nb lw nc nd ne lz nf ng nh mc ni bi translated">最后的话</h1><p id="be9c" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">NGRX是一个非常强大的工具。当然，有时它可能需要一些RxJS的深入知识，但是只要有一点耐心，它真的可以彻底改变你编写软件的方式。</p><p id="6ea9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇教程能帮助你理解如何建立一个基本的(可扩展的)文件夹结构，以及开始用Angular和NGRX编写强大的反应式应用程序的基础知识。</p><p id="52c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于任何澄清或如果有事情你会做得不同，随时给我发电子邮件或评论如下。</p><h2 id="4f6e" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">源代码</h2><p id="7947" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">该项目的完整源代码可以在<a class="ae lf" href="https://github.com/Gbuomprisco/cryptofolio" rel="noopener ugc nofollow" target="_blank">https://github.com/Gbuomprisco/cryptofolio</a>看到</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="673f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你喜欢这篇文章，如果你同意，不同意，或者如果你想做任何不同的事情，请留言！</p><p id="0f11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，请关注我的<a class="ae lf" href="https://medium.com/@.gc" rel="noopener"><em class="mr">Medium</em></a><em class="mr">或</em><a class="ae lf" href="https://twitter.com/home" rel="noopener ugc nofollow" target="_blank"><em class="mr">Twitter</em></a><em class="mr">以获得更多关于Angular、RxJS、Typescript等的文章！</em></p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="7c72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mr">最初发布于</em><a class="ae lf" href="https://frontend.consulting/abstracting-state-with-ngrx-facades" rel="noopener ugc nofollow" target="_blank"><em class="mr">https://frontend . consulting</em></a><em class="mr">。</em></p></div></div>    
</body>
</html>