<html>
<head>
<title>All Hail Tracing: A Go, Redis, and Jaeger Tale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有冰雹追踪:一个去，雷迪斯和耶格的故事</h1>
<blockquote>原文：<a href="https://itnext.io/all-hail-tracing-a-go-redis-and-jaeger-tale-7904743d0fd?source=collection_archive---------2-----------------------#2021-07-28">https://itnext.io/all-hail-tracing-a-go-redis-and-jaeger-tale-7904743d0fd?source=collection_archive---------2-----------------------#2021-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2bedc9f2e3469e7198e453bd6e3f94d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SW2GuwsI1WWlCywWBWDUlA.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Jaeger对我们的HTTP和DB服务生成的痕迹进行了可视化</figcaption></figure><p id="c9d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文是对DevelopersBR组织的<a class="ae le" href="https://www.meetup.com/pt-BR/DevelopersBr/events/279237414/" rel="noopener ugc nofollow" target="_blank">会议</a>的补充，旨在涵盖分布式跟踪的一些基础知识，以及如何使用open telemetry observability framework工具来应用它。</p><p id="fe1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让事情更实际，我们将创建一个Golang HTTP应用程序，它使用Redis后端，并依赖Jaeger来接收和可视化跟踪。将此视为黄带整体难度，但所有专业水平都可以利用它来学习或记住重要概念。</p><p id="1c4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想直接跳到行动，完整的容器化演示可以在<a class="ae le" href="https://github.com/filipecosta90/opentelemetry-go-http-sample" rel="noopener ugc nofollow" target="_blank">https://github . com/Filipe Costa 90/open telemetry-go-http-sample</a>查阅，如下所示:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="fe71" class="lo lp it lk b gy lq lr l ls lt">git clone github.com/filipecosta90/opentelemetry-go-http-sample<br/>cd opentelemetry-go-http-sample<br/>make build-docker<br/>make start-docker</span></pre><p id="0cf8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请务必查看<a class="ae le" href="https://opentelemetry.io/docs/go/" rel="noopener ugc nofollow" target="_blank">https://opentelemetry.io/docs/go/</a>以获取更多参考和示例。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="5059" class="mb lp it bd kf mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">1)在开始行动之前，介绍一些分布式跟踪的基础知识</h1><p id="6d18" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在实际应用跟踪之前，让我们先了解一下可观测性、opentelemetry和分布式跟踪的一些基础知识。</p><h2 id="928a" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">什么是可观测性？</h2><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/3c9904e621d72d5d0beb7cf477511ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fz5CGVzPJ45qTfyAP77p5g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">可观察性的三大支柱</figcaption></figure><p id="a499" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">您可以使用不同的工具和不同的方式来实现可观察性，但是独立于可观察性解决方案，它们都分为三个主要的垂直领域——度量、日志和分布式跟踪。具体到这篇博文和演讲，我们将重点讨论后者。</strong></p><h2 id="c316" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">OpenTelemetry在可观测性工作中处于什么位置？</h2><p id="6045" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">特别关注追踪支柱:</p><blockquote class="np nq nr"><p id="1c06" class="kg kh no ki b kj kk kl km kn ko kp kq ns ks kt ku nt kw kx ky nu la lb lc ld im bi translated"><strong class="ki iu">分布式跟踪是一种由跟踪工具实现的方法，用于跟踪、分析和调试跨多个软件组件的事务。</strong><br/><a class="ae le" href="https://www.w3.org/TR/trace-context/#problem-statement" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/TR/trace-context/#problem-statement</a></p></blockquote><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/31c90293ebe1d39e8a67cdc4faf8ec3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0IYHErcPS-9zpSTM.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在线精品微服务演示应用，由11个不同语言编写的微服务组成。谷歌用这个应用程序来演示像现在已经过时的OpenCensus这样的技术的使用。</figcaption></figure><p id="7094" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以想象，在多供应商环境中，这导致了互操作性问题，例如:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/29915bf4a7fc228226b221c7a83dd999.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*4Smkraf7sXeHRdrr.jpg"/></div></figure><ul class=""><li id="f08c" class="nx ny it ki b kj kk kn ko kr nz kv oa kz ob ld oc od oe of bi translated">由于没有共享的唯一标识符，不同跟踪供应商收集的跟踪无法相互关联。意味着从头到尾都没有关联。</li><li id="409e" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated">不能确保特定于供应商的元数据在系统交换之间得到保留。</li><li id="3729" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated">云平台供应商、中介和服务提供商无法真正保证支持跟踪上下文传播，因为没有标准可循。</li></ul><p id="1356" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是像CNCF的OpenTelemetry及其前身OpenTracing(出现于2016年)这样的项目对促进数据收集标准化至关重要的地方。多亏了它们，我们现在可以利用一种普遍认可的格式来交换跟踪上下文传播数据——称为跟踪上下文。您可以在https://www.w3.org/TR/trace-context/#design-overview的<a class="ae le" href="https://www.w3.org/TR/trace-context/#design-overview" rel="noopener ugc nofollow" target="_blank">跳转到W3C跟踪上下文定义。</a></p><p id="d977" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OpenTelemetry <a class="ae le" href="https://oreil.ly/GpGD5" rel="noopener ugc nofollow" target="_blank">多库</a>包括一系列规范，以及各种语言的API和参考实现，<a class="ae le" href="https://oreil.ly/vSO7k" rel="noopener ugc nofollow" target="_blank">包括</a> go。</p><h2 id="334b" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">用OpenTelemetry跟踪的概念？</h2><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/9d3d47339d2b16b5d0d5652ab13cdb11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsaXwAWaJUiYTr_yWIRQIg.png"/></div></div></figure><p id="f490" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上图中的图表代表了一个样本跟踪。跟踪是链接范围的集合，是跟踪中最小的工作单元。</p><p id="8462" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，跟踪跨越了几个服务边界，从应用程序层一直到数据库层，以及请求在系统中流动时所涉及的任何单个服务或组件。</p><p id="f714" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与每个span相关联的是一个span上下文，它是一组全局唯一标识符，表示每个<code class="fe om on oo lk b">span</code>都是其中一部分的唯一请求。一个<code class="fe om on oo lk b">span</code>提供了请求、错误和持续时间(红色)度量，可用于调试可用性和性能问题，并包含关于每个操作的元数据，如名称、开始和结束时间戳、属性、事件和状态。</p><p id="4039" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以通过检查跨度的根来检索请求的整个端到端延迟。</p><h2 id="e94d" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">开放式遥测跟踪约定</h2><p id="f240" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">OpenTelemetry提供了一个描述公共属性的模式，以便后端可以轻松地解析和识别相关信息。为了规范化您的数据并提高其效用，在编写测量时理解这些约定非常重要。</p><p id="c59f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为跟踪定义了以下语义约定:</p><ul class=""><li id="f448" class="nx ny it ki b kj kk kn ko kr nz kv oa kz ob ld oc od oe of bi translated"><a class="ae le" href="https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/span-general.md" rel="noopener ugc nofollow" target="_blank">通用</a>:通用的语义属性，可以用来描述不同种类的操作。</li><li id="75c6" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated"><a class="ae le" href="https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md" rel="noopener ugc nofollow" target="_blank">HTTP</a>:HTTP客户端和服务器的跨度。</li><li id="3d4e" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated"><a class="ae le" href="https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/database.md" rel="noopener ugc nofollow" target="_blank">数据库</a>:SQL和NoSQL客户端调用的跨度。</li><li id="7e6f" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated">RPC/RMI :远程过程调用的跨度(例如gRPC)。</li><li id="6e1a" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated"><a class="ae le" href="https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md" rel="noopener ugc nofollow" target="_blank">消息传递</a>:与消息传递系统(队列、发布/订阅等)交互的跨度。).</li><li id="a80a" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated"><a class="ae le" href="https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/faas.md" rel="noopener ugc nofollow" target="_blank"> FaaS </a>:跨越功能即服务(如AWS Lambda)。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f86e" class="mb lp it bd kf mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">2)创建一个简单的Golang REST API来测试跟踪</h1><p id="d17c" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在本节中，我们将使用位于<a class="ae le" href="https://github.com/filipecosta90/opentelemetry-go-http-sample" rel="noopener ugc nofollow" target="_blank">https://github . com/Filipe Costa 90/open telemetry-go-http-sample</a>的示例代码。</p><p id="8370" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开始应该很简单:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="bcea" class="lo lp it lk b gy lq lr l ls lt">git clone github.com/filipecosta90/opentelemetry-go-http-sample<br/>cd opentelemetry-go-http-sample</span><span id="d62d" class="lo lp it lk b gy op lr l ls lt"># spin the web server, redis, and jaeger<br/>make <!-- -->start-docker</span></pre><p id="01d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们来解释一下它的内容。</p><p id="2038" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了测试跟踪概念，我们将创建一个简单的REST API，它将公开端点以允许访问和操作关于“作者”的信息。我们的简单API将允许的操作有:</p><ul class=""><li id="4f9d" class="nx ny it ki b kj kk kn ko kr nz kv oa kz ob ld oc od oe of bi translated"><strong class="ki iu">创建</strong>新作者，以响应在<code class="fe om on oo lk b">/author/{id}</code>的有效帖子请求；</li><li id="cb85" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated"><strong class="ki iu">响应于在<code class="fe om on oo lk b">/author/{id}</code>的有效PUT请求，更新</strong>现有作者；</li><li id="72b0" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated"><strong class="ki iu">响应于在<code class="fe om on oo lk b">/author/{id}</code>的有效GET请求，通过作者标识符获取现有作者信息；</strong></li></ul><p id="ac33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，</p><ul class=""><li id="875b" class="nx ny it ki b kj kk kn ko kr nz kv oa kz ob ld oc od oe of bi translated">为了保存我们的作者信息，我们将使用Redis作为我们的存储层。要连接到它，我们将使用go-redis客户端。</li><li id="33a9" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated">为了处理HTTP请求路由，将它们匹配到各自的处理程序，我们将使用<code class="fe om on oo lk b">gorilla/mux</code>包。</li></ul><h2 id="12a4" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">定义我们的作者信息结构</h2><p id="f6ca" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">为了尽可能简单，每个作者将有一个相关的作者姓名、用户名和一个关于他自己的部分，可以映射到下面的<code class="fe om on oo lk b">Author</code>结构。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2869" class="lo lp it lk b gy lq lr l ls lt">// The Author struct represents the data in the JSON/JSONB column.<br/>// We can use struct tags to control how each field is encoded.<br/>type Author struct {<br/>   Name     string `json:"Name"`<br/>   Username string `json:"Username"`<br/>   About    string `json:"About"`<br/>}</span></pre><p id="2663" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们知道了我们想要保存的关于作者的信息，让我们检查一下如何保存这些信息。</p><h2 id="c546" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">将我们的作者状态存储在外部数据库中:Redis</h2><p id="e7fa" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">如上所述，我们将使用Redis来持久化我们的作者数据，并且在我们的作者属性和我们的持久层(Redis)之间有一个直接的映射，我们将使用Redis散列。你可以在https://redis.io/topics/data-types-intro<a class="ae le" href="https://redis.io/topics/data-types-intro" rel="noopener ugc nofollow" target="_blank">阅读更多关于redis数据类型的内容。</a></p><p id="49d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">旋转web服务器的同一个bash命令也旋转Redis，所以现在让我们只关注Redis，在讨论Author struct和我们的存储层之间的映射时，通过连接它使事情变得更实际:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="fb5b" class="lo lp it lk b gy lq lr l ls lt"># spin the web server, redis, and jaeger<br/>make <!-- -->start-docker<br/>redis-cli</span></pre><p id="ea49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个作者将与Redis中的一个<code class="fe om on oo lk b">author:&lt;id&gt;</code>键相关联，在内部将字符串属性名映射到字符串值，即<code class="fe om on oo lk b">Name</code>、<code class="fe om on oo lk b">Username</code>和<code class="fe om on oo lk b">About</code>。如果你跟着做，即使不看go代码，我们也可以模拟我们将在Redis中用来存储和检索作者数据的预期命令。即:</p><h2 id="fe49" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated"><strong class="ak">创建新作者，以响应</strong> <code class="fe om on oo lk b"><strong class="ak">/author/{id}</strong></code>的有效帖子请求</h2><p id="d99a" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">对<code class="fe om on oo lk b">/author/{id}</code>的POST请求将映射到Redis中的<code class="fe om on oo lk b">HSET</code>命令。更实际的情况是，如果您请求创建一个id为1、姓名为“John Doe”、用户名为“john.doe”、关于部分为“Redis Geek”的作者，这将映射到以下HSET命令:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="d288" class="lo lp it lk b gy lq lr l ls lt">127.0.0.1:6379&gt; hset author:1 Name "John Doe" Username "johndoe" About "Redis Geek"</span><span id="9450" class="lo lp it lk b gy op lr l ls lt">(integer) 3</span></pre><h2 id="4307" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated"><strong class="ak">响应于</strong> <code class="fe om on oo lk b"><strong class="ak">/author/{id}</strong></code>的有效上传请求，更新现有作者</h2><p id="f431" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">更新将映射到几乎相同的Create request/redis命令流，只是我们可以对特定属性进行部分更新。</p><p id="6092" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您请求更新一个id为1的作者，将它的About部分改为“DevelopersBR Redis Geek”</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="f2e1" class="lo lp it lk b gy lq lr l ls lt">127.0.0.1:6379&gt; hset author:1 About "DevelopersBR Redis Geek"</span><span id="638e" class="lo lp it lk b gy op lr l ls lt">(integer) 0</span></pre><h2 id="9149" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated"><strong class="ak">响应于在</strong> <code class="fe om on oo lk b"><strong class="ak">/author/{id}</strong></code>的有效GET请求，通过作者标识符获取现有作者信息</h2><p id="d6a1" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在<code class="fe om on oo lk b">/author/{id}</code>的GET请求将映射到一个不同的redis命令，即HGETALL，它返回存储在Redis键的所有字段和值。</p><p id="2be6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想获得id为1的John Doe作者的最新信息，那么对<code class="fe om on oo lk b">/author/1</code>的get请求将映射到下面的Redis命令并回复</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="5fcd" class="lo lp it lk b gy lq lr l ls lt">127.0.0.1:6379&gt; hgetall author:1</span><span id="6033" class="lo lp it lk b gy op lr l ls lt">1) "Name"</span><span id="7b10" class="lo lp it lk b gy op lr l ls lt">2) "John Doe"</span><span id="b190" class="lo lp it lk b gy op lr l ls lt">3) "Username"</span><span id="359a" class="lo lp it lk b gy op lr l ls lt">4) "johndoe"</span><span id="c6f4" class="lo lp it lk b gy op lr l ls lt">5) "About"</span><span id="6d00" class="lo lp it lk b gy op lr l ls lt">6) "DevelopersBR Redis Geek"</span></pre><h1 id="44ff" class="mb lp it bd kf mc oq me mf mg or mi mj mk os mm mn mo ot mq mr ms ou mu mv mw bi translated">从API规范到正确的go代码</h1><p id="9bf2" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">如果您检查我们的示例repo，您会注意到只有<code class="fe om on oo lk b">author.go</code>、<code class="fe om on oo lk b">main.go</code>、<code class="fe om on oo lk b">storage.go</code>和<code class="fe om on oo lk b">routes.go</code>包含我们整个应用程序所需的go逻辑。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="3685" class="lo lp it lk b gy lq lr l ls lt">opentelemetry-go-http-sample % tree .<br/>.<br/>├── author.go<br/>├── main.go<br/>└── routes.go<br/>└── storage.go</span></pre><p id="6342" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述每个文件在我们的应用程序中都有不同的职责:</p><ul class=""><li id="75c7" class="nx ny it ki b kj kk kn ko kr nz kv oa kz ob ld oc od oe of bi translated"><code class="fe om on oo lk b">author.go</code>，包含我们的作者业务逻辑，以及作者struct如何映射到/从不同的序列化格式；<a class="ae le" href="https://github.com/filipecosta90/opentelemetry-go-http-sample/blob/main/author.go" rel="noopener ugc nofollow" target="_blank">【GH代码在此】</a></li><li id="c71a" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated"><code class="fe om on oo lk b">routes.go</code>，包含三个请求路由逻辑，将URL路径映射到处理程序；<a class="ae le" href="https://github.com/filipecosta90/opentelemetry-go-http-sample/blob/main/routes.go" rel="noopener ugc nofollow" target="_blank">【GH代码在此】</a></li><li id="caa5" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated"><code class="fe om on oo lk b">storage.go</code>，包含存储层逻辑，能够在外部数据库中存储我们的作者状态:Redis这是以一种DB不可知的方式构建的，因此如果您决定使用另一个DB，这将是除了在<code class="fe om on oo lk b">main.go</code>中设置的连接之外唯一需要更改逻辑的文件。<a class="ae le" href="https://github.com/filipecosta90/opentelemetry-go-http-sample/blob/main/storage.go" rel="noopener ugc nofollow" target="_blank">【GH代码在此】</a></li><li id="5ab5" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated"><code class="fe om on oo lk b">main.go</code>，包含能够连接到多个软件组件(在我们的例子中，Redis和Jaeger)的初始化、配置和抽象层。<a class="ae le" href="https://github.com/filipecosta90/opentelemetry-go-http-sample/blob/main/main.go" rel="noopener ugc nofollow" target="_blank">【GH代码在此】</a></li></ul><h2 id="f8ee" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">关于我们的<code class="fe om on oo lk b">main.go</code>以及我们为什么添加以下服务器结构的进一步说明:</h2><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="f8dc" class="lo lp it lk b gy lq lr l ls lt">type server struct {<br/>   client *redis.Client<br/>   router *mux.Router<br/>}</span></pre><p id="a37d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于一系列原因，必须尽可能地将业务逻辑从外部组件中抽象出来:</p><ul class=""><li id="6f1f" class="nx ny it ki b kj kk kn ko kr nz kv oa kz ob ld oc od oe of bi translated">更改底层路由器实现细节不应该影响您的应用程序逻辑代码。也就是说，如果将来我们从<code class="fe om on oo lk b">gorilla/mux</code>转换到<code class="fe om on oo lk b">DefaultServeMux</code>或任何其他的web工具包，你应该能够这样做，而不需要改变你的应用程序逻辑go文件。</li><li id="4efc" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated">这同样适用于DB层组件。如果将来我们决定使用另一个Redis客户机，甚至是一个完全不同的DB，您的路由器代码和业务逻辑代码就不必更新它们的输入。</li></ul><p id="d8b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么我们将所有非业务组件打包在服务器类型中，然后我们可以在服务管道的所有阶段使用它们，同时保持它们的领域非常紧密。</p><p id="19fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们已经使用了一些redis-cli命令来实际测试我们的redis数据建模，我们现在可以通过向我们新定义的API发送一些HTTP请求来测试整个REST API和Redis流。<br/>假设您已经通过运行<code class="fe om on oo lk b">make start-docker</code>让web服务器在端口7777上运行，让我们使用curl添加一个新作者:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="d152" class="lo lp it lk b gy lq lr l ls lt"># spin the web server, redis, and jaeger<br/>make <!-- -->start-docker</span><span id="8362" class="lo lp it lk b gy op lr l ls lt"><br/># create a new Author<br/>$ curl -X POST -d "{\"Name\":\"Filipe\", \"Username\":\"filipecosta90\", \"About\":\"Redis Geek\"}" http://localhost:7777/author/2</span><span id="ea2a" class="lo lp it lk b gy op lr l ls lt">{"Name":"Filipe","Username":"filipecosta90","About":"Redis Geek"}</span><span id="5a47" class="lo lp it lk b gy op lr l ls lt"># update one of it's properties<br/>$ curl -X PUT -d "{\"Name\":\"Filipe Oliveira\"}" http://localhost:7777/author/2</span><span id="bbb8" class="lo lp it lk b gy op lr l ls lt">{"Name":"Filipe Oliveira","Username":"filipecosta90","About":"Redis Geek"}</span></pre><p id="ac93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们已经做好了所有的设置，并正确地解释了如何开始在Go中记录跟踪数据。</p><h1 id="693f" class="mb lp it bd kf mc oq me mf mg or mi mj mk os mm mn mo ot mq mr ms ou mu mv mw bi translated">3)在Go中跟踪</h1><h2 id="5342" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">如何在Go中使用OpenTelemetry记录跟踪数据？</h2><p id="97dc" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">为了在OpenTelemetry中创建和管理跨度，OpenTelemetry API提供了<code class="fe om on oo lk b">tracer</code>接口。该对象负责跟踪您流程中的活动<code class="fe om on oo lk b">span</code>,并允许您对其执行操作，例如添加属性、事件，并在它跟踪的工作完成时结束它。</p><p id="5a80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在实践中，可以从示踪剂提供者处获得示踪剂。</p><p id="6c8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的示例中，我们将使用Jaeger作为我们的跟踪提供者，并遵循Jaeger <a class="ae le" href="https://pkg.go.dev/go.opentelemetry.io/otel/exporters/trace/jaeger#NewExportPipeline" rel="noopener ugc nofollow" target="_blank"> godoc </a>来利用<code class="fe om on oo lk b">NewExportPipeline()</code>方法，该方法使用跟踪提供者的推荐设置来建立完整的导出管道。为了简化设置过程，我们将otel设置打包成一种叫做<code class="fe om on oo lk b">initTracer()</code>的方法。下面的要点关注它，它是项目中<a class="ae le" href="https://github.com/filipecosta90/opentelemetry-go-http-sample/blob/main/main.go" rel="noopener ugc nofollow" target="_blank"> main.go </a>文件的一部分。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="bd78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您在上面所注意到的，除了设置跟踪提供程序之外，我们还:</p><ul class=""><li id="0781" class="nx ny it ki b kj kk kn ko kr nz kv oa kz ob ld oc od oe of bi translated"><strong class="ki iu">出于演示目的，定义100%的跟踪采样率:</strong>鉴于任何给定进程的跟踪开销都与单位时间内创建的跟踪数量成比例，对于高吞吐量的在线服务，保持较低的采样率非常重要。过去，谷歌每1024个候选人收集1个采样轨迹，这意味着0.1%的采样率。<a class="ae le" href="https://static.googleusercontent.com/media/research.google.com/en//archive/papers/dapper-2010-1.pdf" rel="noopener ugc nofollow" target="_blank">【第4.4节短小精悍的纸张】</a>。一个更高级的选择是考虑“基于尾部”的采样方法，这种方法在做出采样决定之前分析整个轨迹，从而确保保留“重要的轨迹”。我们将在后续文章中关注“基于尾部”的采样。</li><li id="a09f" class="nx ny it ki b kj og kn oh kr oi kv oj kz ok ld oc od oe of bi translated"><strong class="ki iu">最后，分布式跟踪需要上下文传播</strong> —这意味着跟踪可以扩展到单个流程之外。为此，我们需要每个服务都知道调用者的跟踪，并且我们调用的每个服务都需要知道它也包含在跟踪中。为了在go中做到这一点，我们利用了<code class="fe om on oo lk b">TextMapPropagator()</code>方法，该方法将横切关注点值作为字符串键/值对注入和提取到载体中，该载体在客户端(注入器)和服务器(提取器)上跨流程边界带内传播。</li></ul><h2 id="7b26" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">go-redis客户端的自动检测</h2><p id="2e63" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">正如官方opentelemetry文档中所述，自动仪器指的是您没有编写的仪器代码。OpenTelemetry for Go通过许多流行的框架和库周围的包装器和助手函数来支持这一过程，在已知的仪器包中是通过<code class="fe om on oo lk b"><a class="ae le" href="https://github.com/go-redis/redis/blob/v8.0.0-beta.5/redisext/otel.go" rel="noopener ugc nofollow" target="_blank">github.com/go-redis/redis/v8/redisext</a></code>包的<code class="fe om on oo lk b">go-redis</code>。</p><p id="f337" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的Redis连接设置过程中，我们只需添加如下的<code class="fe om on oo lk b"><a class="ae le" href="https://github.com/go-redis/redis/blob/v8.0.0-beta.5/redisext/otel.go" rel="noopener ugc nofollow" target="_blank">redisotel.TracingHook{}</a></code>:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="0615" class="lo lp it lk b gy lq lr l ls lt">func initRedis(address string) *redis.Client {<br/>   redisClient := redis.NewClient(&amp;redis.Options{<br/>      Addr: address,<br/>   })<br/>   redisClient.AddHook(redisotel.TracingHook{})<br/>   return redisClient<br/>}</span></pre><h2 id="78e5" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">让我们用Jaeger追踪并可视化它？</h2><p id="f497" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">为了测试我们的跟踪HTTP API，并验证我们的跟踪是从我们的应用程序go code和go-redis instrumentation正确生成和发出的，并到达分布式跟踪后端(Jaeger)，我们将再次使用docker-compose脚本。</p><p id="3deb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让事情变得更有趣，如果您记得在一个跟踪中，每个span <code class="fe om on oo lk b">span</code>提供请求、错误和持续时间(红色)度量，让我们也做一些不好的请求HTTP调用来尝试一下。</p><p id="7717" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你已经有了<code class="fe om on oo lk b">make start-docker</code>，你可以跳过下面这组命令的第一行。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="3d7e" class="lo lp it lk b gy lq lr l ls lt"># spin the web server, redis, and jaeger<br/>make <!-- -->start-docker</span><span id="f728" class="lo lp it lk b gy op lr l ls lt"># create a new Author<br/>$ curl -X POST -d "{\"Name\":\"Gopher\", \"Username\":\"gopher.tracing\", \"About\":\"Go Geek\"}" http://localhost:7777/author/3</span><span id="d917" class="lo lp it lk b gy op lr l ls lt"># will result in 400 bad request<br/>curl -X POST <a class="ae le" href="http://localhost:7777/author/4" rel="noopener ugc nofollow" target="_blank">http://localhost:7777/author/4</a></span><span id="8d35" class="lo lp it lk b gy op lr l ls lt"># will result in 404 Not Found<br/>curl -X GET <a class="ae le" href="http://localhost:7777/author/4" rel="noopener ugc nofollow" target="_blank">http://localhost:7777/author/4</a></span></pre><h2 id="b4b7" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">我们终于可以用耶格来可视化痕迹了</h2><p id="4831" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在浏览器中，导航到<a class="ae le" href="http://localhost:16686" rel="noopener ugc nofollow" target="_blank"> http://localhost:16686 </a>以访问Jaeger UI。</p><p id="65ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> 1)搜索404未找到请求痕迹</strong></p><p id="48d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1.1)在搜索面板中，确保选择了<strong class="ki iu"> sampleHTTPServer </strong>服务。将操作视为全部。将标签设置为<code class="fe om on oo lk b">http.status_code=404</code>,并点击Find Traces按钮。您应该看到以下内容:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/b4758c62f88a1f5edb729e9c3bb729c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxkGngQUstV_IC7Bbf7eJQ.png"/></div></div></figure><p id="67a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> 2。)搜索专门针对一个用户代理的400个不良请求跟踪</strong></p><p id="186f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.1)在搜索面板中，确保选择了<strong class="ki iu"> sampleHTTPServer </strong>服务。将操作视为全部。将标签设置为<code class="fe om on oo lk b">http.status_code=404 http.user_agent=”curl/7.64.1”</code>并点击查找轨迹按钮。您应该看到以下内容:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/907b16b40c220a59e28281b58521ce6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5DqJUqS3OCJOTcVZugMIg.png"/></div></div></figure><p id="15aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> 3。)搜索go-redis仪器相关标签</strong></p><p id="7482" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.1)在搜索面板中，确保选择了<strong class="ki iu"> sampleHTTPServer </strong>服务。将操作视为全部。将标签设置为<code class="fe om on oo lk b">db.system=redis</code>并点击Find Traces按钮。您应该看到以下内容:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/eea9e5f92b98491321f2df24137ea24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SeZtpX5ynfxFknZN9sCqsw.png"/></div></div></figure><h2 id="0da8" class="lo lp it bd kf nc nd dn mf ne nf dp mj kr ng nh mn kv ni nj mr kz nk nl mv nm bi translated">最后的想法</h2><p id="0f6a" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在前面几节之后，您应该对分布式跟踪的任务、范围和实现示例有了基本的了解。</p><p id="7c1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，重要的是要强调跟踪本身并不能完成工作。跟踪应该作为指标分析的补充，因为这些应该给出应用程序性能的完整图像，而跟踪将使您能够解释为什么那些全局指标会达到那个状态。<br/>举个简单的例子:</p><blockquote class="np nq nr"><p id="3d5f" class="kg kh no ki b kj kk kl km kn ko kp kq ns ks kt ku nt kw kx ky nu la lb lc ld im bi translated"><em class="it">通过查看跟踪报告，您应该无法计算并分析应用程序的99%延迟，因为您没有生成系统聚合状态的总数据——因为我们以1/1000、1/10000甚至更小的跟踪率对应用程序请求进行采样。</em></p></blockquote><p id="21d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">然而</strong>，尽管单独的整体度量不能(或者至少更难)容易地解释为什么会出现性能问题，但是跟踪确实在解释为什么会出现总体问题(或者如果我们使用基于尾部的采样，甚至是某一类问题)方面显示出了它的价值，假设我们保留了所有参与软件组件的完整请求集，包括您构建或使用的组件。</p><p id="53c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为结束语，我强烈推荐奥斯汀·帕克、丹尼尔·斯普恩霍、乔纳森·梅斯、本·西格曼和丽贝卡·艾萨克斯的《实践中的分布式跟踪》<a class="ae le" href="https://www.oreilly.com/library/view/distributed-tracing-in/9781492056621/" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu"/></a><strong class="ki iu"/>。</p></div></div>    
</body>
</html>