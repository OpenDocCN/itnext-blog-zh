<html>
<head>
<title>How to build a Chrome Extension to analyze the text as you write</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建一个Chrome扩展来分析你写的文本</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-a-chrome-extension-to-analyze-text-as-you-write-a1c0ab1923f9?source=collection_archive---------0-----------------------#2020-07-26">https://itnext.io/how-to-build-a-chrome-extension-to-analyze-text-as-you-write-a1c0ab1923f9?source=collection_archive---------0-----------------------#2020-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="78bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建你自己的chrome扩展来计算你写作时的字数、字符数和每字价格</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b8e88800f77997c18e002103a1c5dcbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cZpzFkhsMFQoW2f4"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@andrewtneel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德鲁·尼尔</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="bdae" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">介绍</h1><p id="be81" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">不久前，我开始在Medium上写作，作为兼职，与我的自由职业交替进行。不是英语母语的人，我发现使用chrome扩展像Grammarly真的很有帮助。(如果你还不知道，这是一个数字写作工具，它使用人工智能和自然语言处理来帮助进行语法检查、拼写检查、抄袭检测以及关于清晰度、正式程度、语气和词汇的建议)。无论如何，我没有使用它的所有功能，因为它有不同的计划(免费，个人高级和商业高级)，或者至少我没有必要使用这些功能。所以我想开发自己的chrome扩展，只实现我需要的功能，以便了解这项技术提供的可能性。</p><p id="c228" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，扩展并不仅仅针对谷歌浏览器。其他流行的浏览器如Microsoft Edge和Mozilla Firefox也支持扩展，但扩展对每个人来说都是一样的:它们是使用HTML、CSS和JavaScript构建的小应用程序，以特定的方式与配置文件打包在一起。<br/>他们需要遵循<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions" rel="noopener ugc nofollow" target="_blank"> Web扩展API标准</a>，该标准受到基于Chromium的浏览器的支持，如谷歌Chrome、微软Edge、Mozilla Firefox和微软Edge。</p><h2 id="3e5d" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">Chrome扩展是干什么用的？</h2><p id="7997" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Chrome扩展不仅仅用于文本分析。他们可以使用权限与Chrome浏览器的标签进行交互，检测URL匹配，注入代码(例如HTML、JavaScript、CSS)，执行API调用，等等。<br/>如果我们查看一下<a class="ae le" href="https://chrome.google.com/webstore/category/extensions" rel="noopener ugc nofollow" target="_blank"> Chrome网上商店</a>，我们可以查看所有不同的类别:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mu"><img src="../Images/0019611932f376b1a2360c822741d0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8utZD3oPrP6aLqIwEsyDA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Chrome网上商店的类别</figcaption></figure><h1 id="f935" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们要建造什么？</h1><p id="0ccc" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们将建立一个扩展来计算我们输入的文本字段或输入的单词和字符，并计算你将获得的钱总数(例如，为自由撰稿人)设置每个单词的价格(PPW)。我们将称之为<strong class="js iu"> ChETA </strong>，代表<strong class="js iu">Ch</strong>Rome<strong class="js iu">E</strong>extension代表<strong class="js iu">T</strong>ext<strong class="js iu">A</strong>analysis，在我的祖国阿根廷，这意味着酷/棒。</p><p id="3c1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当从Extensions选项卡打开时，我们的扩展将如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/c01a46efb029050d31aafbc07a1422d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74Ictq8XGRcLocKs1LoaUA.png"/></div></div></figure><p id="ceb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将要求用户找到他想要使用的输入。然后，他需要在上面写下<em class="mw"> &lt; cheta &gt; </em>(在输入的任何地方添加或替换内容，都一样)并点击开始。可选地，他将能够设定每个词的价格(<strong class="js iu"> PPW </strong>从现在开始)。</p><p id="8344" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，在谷歌的输入上:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/01e0f69966c29bcb1ad0469fee452ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17_AMAOPP5bFWFG1W7Euiw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">预览:在ChETA上单击开始之前</figcaption></figure><p id="7fed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单击“开始”时，我们将在页面HTML代码中注入我们需要的内容，开始使用浮动容器监听输入的变化:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/d864cbdbe4e577a1c8e44a5caa7c4fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nuShVPmaJVa42UBavsn-7A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">预览:点击ChETA上的开始后</figcaption></figure><h1 id="662c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">扩展架构</h1><p id="1e4b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">扩展由相互交互的不同组件组成。组件可以包括<strong class="js iu">后台脚本</strong>、<strong class="js iu">内容脚本</strong>、一个<strong class="js iu">选项页面</strong>、<strong class="js iu"> UI元素</strong>以及各种<strong class="js iu">逻辑文件</strong>。扩展组件是用web开发技术创建的:HTML、CSS和JavaScript。扩展的组件将取决于它的功能，可能不需要每个选项。</p><ol class=""><li id="d093" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated">manifest.json:描述源包中的内容。它定义了浏览器可以在哪里找到背景、内容脚本、弹出窗口和选项页面。它还描述了扩展所需的权限(例如，允许扩展检查所有选项卡、仅检查当前选项卡、使用存储等)</li><li id="9824" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">background.js:当扩展启动时启动的一个脚本或一段代码，直到扩展被移除或浏览器关闭时才会终止。这个文件可以访问所有chrome APIs，其他部分仅限于此。这个脚本不包含UI，并且不能访问DOM。</li><li id="6d9a" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">popup.html:当用户点击“浏览器操作”时显示的用户界面，这是浏览器地址栏右侧的按钮，扩展位于该按钮上。大多数扩展需要一个弹出窗口作为入口，但是它们也可以被开发成在页面上右击来调用。</li><li id="1e9c" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">选项:它是扩展的可选部分，不是所有的扩展都包括它。它被用作扩展的配置UI，以便启用多个视图。</li><li id="f7fa" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">内容脚本:在具有特定URL模式的选项卡中运行的脚本或代码片段，在manifest.json中定义。如果URL与清单描述匹配，浏览器将启动内容脚本。当URL更改或选项卡关闭时，它将被终止。需要它来操作DOM。<br/>当我们需要在web流的特定URL或特定实例上启动我们的脚本时，URL匹配会很有用。</li></ol><p id="5756" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于本教程，我们将使用React.js来构建扩展。源代码可以在Github(<a class="ae le" href="https://github.com/juancurti/cheta-extension" rel="noopener ugc nofollow" target="_blank">https://github.com/juancurti/cheta-extension</a>)上找到。</p><h1 id="e07b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">让我们建立扩展</h1><p id="7c56" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先，我们将创建react应用程序，并删除我们不会使用的不必要文件:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="1f1d" class="mi lg it no b gy ns nt l nu nv">npx create-react-app cheta-extension<br/>cd cheta-extension/<br/>cd src/<br/>rm -rf setupTests.js serviceWorker.js logo.svg index.css App.test.js App.js App.css</span></pre><p id="883f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将安装node-sass，这不是强制性的，但它将帮助我们编写更快的CSS代码:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="0966" class="mi lg it no b gy ns nt l nu nv">npm i node-sass — save</span></pre><p id="a896" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们将替换位于与React.js相关的<strong class="js iu"> public/ </strong>文件夹中的manifest.json，用于对应于上面解释的<strong class="js iu"> manifest.json </strong>概念的以下代码:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="e73c" class="mi lg it no b gy ns nt l nu nv">{<br/> “name”: “ChETA: Chrome Extension for Text Analysis”,<br/> “version”: “1.0.0”,<br/> “manifest_version”: 2,<br/> “description”: “ChETA: Chrome Extension for Text Analysis”,<br/> “icons”: {<br/> “512”: “logo512.png”<br/> },<br/> “permissions”: [“activeTab”],<br/> “browser_action”: {<br/> “default_icon”: “logo512.png”,<br/> “default_popup”: “popup.html”<br/> }<br/>}</span></pre><p id="8c8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mw">注:logo512.png文件可以在资源库上找到:</em> </strong> <a class="ae le" href="https://github.com/juancurti/cheta-extension/blob/master/cheta-extension/public/logo512.png" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> <em class="mw">链接此处</em> </strong> </a></p><p id="287b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，Chrome扩展的起始点应该是一个popup.html，所以我们将创建一个构建脚本，将React build生成的index.html重命名为popup.html。<br/>我们将添加一个新文件:<strong class="js iu"> script/build.sh </strong>，内容如下:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="d779" class="mi lg it no b gy ns nt l nu nv">#!/bin/bash</span><span id="5e14" class="mi lg it no b gy nw nt l nu nv">build() {<br/> echo ‘building react’</span><span id="ff48" class="mi lg it no b gy nw nt l nu nv">rm -rf dist/*</span><span id="39b1" class="mi lg it no b gy nw nt l nu nv">export INLINE_RUNTIME_CHUNK=false<br/> export GENERATE_SOURCEMAP=false</span><span id="0e4c" class="mi lg it no b gy nw nt l nu nv">react-scripts build</span><span id="7bd0" class="mi lg it no b gy nw nt l nu nv">mkdir -p dist<br/> cp -r build/* dist</span><span id="9c61" class="mi lg it no b gy nw nt l nu nv">mv dist/index.html dist/popup.html<br/>}</span><span id="0acd" class="mi lg it no b gy nw nt l nu nv">build</span></pre><h2 id="bf88" class="mi lg it bd lh mj mk dn ll ml mm dp lp kb mn mo lt kf mp mq lx kj mr ms mb mt bi translated">重要的是要知道！</h2><p id="60b0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">INLINE_RUNTIME_CHUNK设置为false是为了禁用HTML中的webpack内联JavaScript生成，因为通常它会将自己的运行时放入脚本中，这是浏览器扩展标准所不允许的。</p><p id="f483" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要使用以下命令向脚本添加权限:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="0668" class="mi lg it no b gy ns nt l nu nv">chmod +x script/build.sh</span></pre><p id="caf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们需要修改我们的<strong class="js iu"> package.json </strong>文件，开始用我们的脚本而不是react-scripts构建。替换以下内容的构建脚本:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="92f6" class="mi lg it no b gy ns nt l nu nv">"scripts": {<br/>    "build": "./script/build.sh"<br/>},</span></pre><h1 id="40d7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用用户界面</h1><p id="f113" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如前所述，我们将使用node-sass而不是简单的CSS，只是为了在本教程中少写几行。创建一个新文件<strong class="js iu"> src/styles/styles.scss </strong>，内容如下:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="8a4f" class="mi lg it no b gy ns nt l nu nv"><a class="ae le" href="http://twitter.com/import" rel="noopener ugc nofollow" target="_blank">@import</a> url('<a class="ae le" href="https://fonts.googleapis.com/css2?family=Special+Elite&amp;display=swap'" rel="noopener ugc nofollow" target="_blank">https://fonts.googleapis.com/css2?family=Special+Elite&amp;display=swap'</a>);<br/>html{<br/>  width:100%;<br/>}<br/>body{<br/>  margin: 0px;<br/>  height: 400px;<br/>  width: 280px;<br/>  font-family: 'Special Elite', sans-serif;<br/>  background: white;</span><span id="0f77" class="mi lg it no b gy nw nt l nu nv">.header {<br/>    width: 280px;<br/>    height: 50px;<br/>    margin: 0px;<br/>    background-color: #B0FF8B;<br/>    padding: 12px 0px;</span><span id="9afe" class="mi lg it no b gy nw nt l nu nv">h1 {<br/>      font-family: 'Special Elite';<br/>      font-size: 28px;<br/>      opacity: 0.9;<br/>      margin: 0px 4px 0px 4px;<br/>      font-weight: 500;<br/>    }</span><span id="3c8b" class="mi lg it no b gy nw nt l nu nv">p {<br/>      margin: 0px 4px;<br/>      font-family: 'Special Elite';<br/>      font-weight: 400;<br/>      font-size: 14px;<br/>    }</span><span id="ba60" class="mi lg it no b gy nw nt l nu nv">input, #priceperwordInput {<br/>      text-align: center;<br/>      font-family: 'Special Elite';<br/>      font-weight: 400;<br/>      font-size: 14px;<br/>    }</span><span id="8a12" class="mi lg it no b gy nw nt l nu nv">#priceperwordInput {<br/>      width: 80px;<br/>    }<br/>  }</span><span id="18a8" class="mi lg it no b gy nw nt l nu nv">.footer {<br/>    width: 280px;<br/>    height: 40px;<br/>    margin: 0px;<br/>    background-color: #B0FF8B;<br/>    padding: 6px 0px;<br/>    text-align: center;</span><span id="b6a0" class="mi lg it no b gy nw nt l nu nv">a {<br/>      text-decoration: none;<br/>    }<br/>  }</span><span id="c026" class="mi lg it no b gy nw nt l nu nv">.contentBox {<br/>    width: 280px;<br/>    height: 310px;</span><span id="7ec3" class="mi lg it no b gy nw nt l nu nv">.resalted {<br/>      background-color: rgba(176, 255, 139, 0.7);<br/>      text-decoration: underline;<br/>    }</span><span id="6807" class="mi lg it no b gy nw nt l nu nv">.no-tf-dtctd {<br/>      margin: 0 10px;<br/>      text-align: center;<br/>      font-size: 14px;<br/>      position: relative;<br/>      top: 50%;<br/>      transform: translateY(-50%);</span><span id="427a" class="mi lg it no b gy nw nt l nu nv">a {<br/>        text-align: right;<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="fccf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们清理我们的<strong class="js iu"> index.js </strong>文件，并为我们的扩展设置一个入口点:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="1ba5" class="mi lg it no b gy ns nt l nu nv">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import './styles/styles.scss';<br/>import Home from './Home';</span><span id="519c" class="mi lg it no b gy nw nt l nu nv">ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;Home /&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  document.getElementById('root')<br/>);</span></pre><p id="b112" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们创建我们的组件。我们需要在文件的顶部添加/* global chrome*/，以防止ESLint将其检测为错误。使用以下格式创建<strong class="js iu"> src/Home.js </strong>:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="3624" class="mi lg it no b gy ns nt l nu nv">/*global chrome*/<br/>import React, { Component } from 'react';</span><span id="fee5" class="mi lg it no b gy nw nt l nu nv">class Home extends Component {</span><span id="20ed" class="mi lg it no b gy nw nt l nu nv">}</span><span id="0523" class="mi lg it no b gy nw nt l nu nv">export default Home;</span></pre><p id="1dcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将添加一个构造函数。我们要使用的变量基本上有两个:</p><ol class=""><li id="cf42" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated">uniqueCode:这将是用户需要键入的字符串，以便检测工作输入。在状态中有这个变量，让我们可以根据自己的需要去摆弄它；例如，如果我们想制作这个应用程序的付费版本，这个代码可以在30分钟内有效，然后用户需要充值他的帐户才能继续使用它。</li><li id="2b36" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">输入:有了这个映射，我们将负责React应用程序的输入。我使用一个地图，而不是一个变量，以便在需要其他文本字段的情况下能够放大。</li></ol><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="e4f5" class="mi lg it no b gy ns nt l nu nv">constructor(props){<br/>    super(props);<br/>    this.state = {<br/>      uniqueCode: `&lt;cheta&gt;`,<br/>      inputs: {<br/>        priceperword: '0.05'<br/>      }<br/>    }<br/>  }</span></pre><p id="8836" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们需要添加一个helper函数来检测输入变化(在我们的chrome扩展中，而不是在DOM中),以更新我们的price per word变量。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="d9d5" class="mi lg it no b gy ns nt l nu nv">handleInputChange = event =&gt; {<br/>    const { name, value } = event.target;<br/>    var inputs = this.state.inputs;<br/>    inputs[name] = value;<br/>    this.setState({<br/>      inputs: inputs<br/>    })<br/>  }</span></pre><p id="d92f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将添加<strong class="js iu"> render() </strong>方法，这个方法大部分是HTML。我们已经添加了样式(用。scss文件)，现在我们将添加如下图所示的结构:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/ca8fb33b40aae3abccbf75115ad242fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlQbOk6SPKRgGRj9mxZK0w.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">ChETA用户界面示意图</figcaption></figure><p id="6207" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以从这里复制粘贴，这样会更快:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="8313" class="mi lg it no b gy ns nt l nu nv">render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;div className="header"&gt;<br/>          &lt;h1&gt;ChETA&lt;/h1&gt;<br/>          &lt;p&gt;Chrome Extension for Text Analysis&lt;/p&gt;<br/>        &lt;/div&gt;<br/>        &lt;div className="contentBox"&gt;<br/>          &lt;div className="no-tf-dtctd"&gt;<br/>            &lt;p&gt;To start analysing a textfield, &lt;span className="resalted"&gt;follow the steps&lt;/span&gt;:&lt;/p&gt;<br/>            &lt;p&gt;1. &lt;span className="resalted"&gt;Locate the field&lt;/span&gt; you want to analyze&lt;/p&gt;<br/>            &lt;p&gt;2. Replace or &lt;span className="resalted"&gt;add&lt;/span&gt; anywhere on the field &lt;span className="resalted"&gt;the following code&lt;/span&gt;:&lt;/p&gt;<br/>            &lt;p&gt;Code: &lt;span className="resalted"&gt;{this.state.uniqueCode}&lt;/span&gt;&lt;/p&gt;<br/>            &lt;p&gt;3. When ready, click start&lt;/p&gt;<br/>            &lt;a href="#" onClick={this.nextTapped_det}&gt;Start&lt;/a&gt;<br/>            &lt;hr/&gt;<br/>            &lt;p&gt;Price per word (Optional): &lt;/p&gt;&lt;input id="priceperwordInput" name="priceperword" value={this.state.inputs.priceperword} onChange={this.handleInputChange} type="number" step="0.01"/&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;div className="footer"&gt;<br/>          &lt;a href="<a class="ae le" href="https://juancurti.com" rel="noopener ugc nofollow" target="_blank">https://juancurti.com</a>" target="_blank"&gt;&lt;p&gt;Juan Curti - 2020&lt;/p&gt;&lt;/a&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  };</span></pre><p id="e94f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的最后一件事，我们需要添加我们的<strong class="js iu"> nextTapped_det </strong>方法，当按下开始按钮时会调用该方法。在这里，我们将做几件事:</p><ol class=""><li id="9318" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated">声明一个配置映射，它将被发送到目标DOM。如果我们想将动态数据从我们的扩展发送到DOM，这真的很重要。在这个映射中，我们将添加我们的脚本将尝试查找的唯一代码和每个单词的价格，前提是它高于0.00；如果不是，那么我们不会显示每字计数器的价格，因为它总是为零。</li><li id="26c7" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">然后我们声明一个CSS文件来注入。我们还使用@import方法发送自定义字体。利用<strong class="js iu"> chrome API </strong>，我们使用<strong class="js iu"> insertCSS </strong>方法来注入它。</li><li id="551a" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">执行我们稍后将编写的自定义脚本，但只能在声明我们的配置变量之后。</li></ol><p id="de85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> nextTapped_det </strong>方法的代码如下</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="010e" class="mi lg it no b gy ns nt l nu nv">nextTapped_det = () =&gt; {<br/>    var config = {<br/>      code: this.state.uniqueCode<br/>    };</span><span id="2584" class="mi lg it no b gy nw nt l nu nv">if(this.state.inputs.priceperword &gt; 0) {<br/>      config['priceperword'] = this.state.inputs.priceperword;<br/>    }</span><span id="349a" class="mi lg it no b gy nw nt l nu nv">var css = "<a class="ae le" href="http://twitter.com/import" rel="noopener ugc nofollow" target="_blank">@import</a> url('<a class="ae le" href="https://fonts.googleapis.com/css2?family=Special+Elite&amp;display=swap'" rel="noopener ugc nofollow" target="_blank">https://fonts.googleapis.com/css2?family=Special+Elite&amp;display=swap'</a>); #cheta-flt-dv { padding: 8px; z-index: 999; position: fixed; width: 140px; bottom: 40%; right: 40px; background-color: #B0FF8B; color: black; border-radius: 20px; text-align: center; box-shadow: 2px 2px 3px #999; } .cheta-flt-p { margin: 2px; font-family: 'Special Elite'; font-size: 22px; } .cheta-pfnt { margin: 2px; font-family: 'Special Elite'; font-size: 14px; }";<br/>    chrome.tabs.insertCSS({code: css});</span><span id="948c" class="mi lg it no b gy nw nt l nu nv">chrome.tabs.executeScript({<br/>      code: 'var config = ' + JSON.stringify(config)<br/>    }, function() {<br/>      chrome.tabs.executeScript({<br/>        file: 'chetalib/chetalib.js'<br/>      });<br/>    })</span><span id="917c" class="mi lg it no b gy nw nt l nu nv">}</span></pre><h1 id="1f20" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">最后一步:实时分析</h1><p id="d344" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">最后，我们需要添加脚本来检测输入，监听变化，并开始分析文本。如果没有包含我们正在寻找的代码的文本字段，我们将终止脚本。此外，我们将利用一个助手函数来检测输入和文本区域，这是最常见的场景。</p><p id="173a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在src/之外的<strong class="js iu"> public </strong>文件夹<strong class="js iu"> chetalib/chetalib.js </strong>中创建如下内容:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="dc82" class="mi lg it no b gy ns nt l nu nv">function init() {<br/>  console.log("Initializing ChETA");<br/>  var link = document.createElement('link');<br/>  link.setAttribute('rel', 'stylesheet');<br/>  link.setAttribute('type', 'text/css');<br/>  link.setAttribute('href', '<a class="ae le" href="https://fonts.googleapis.com/css2?family=Special+Elite&amp;display=swap'" rel="noopener ugc nofollow" target="_blank">https://fonts.googleapis.com/css2?family=Special+Elite&amp;display=swap'</a>);<br/>  document.head.appendChild(link);</span><span id="1d3d" class="mi lg it no b gy nw nt l nu nv">if(!config.code) {<br/>    console.log("Error loading ChETA: Unique code not found")<br/>    return;<br/>  }<br/>  var inputs = getInputsByValue(config.code);<br/>  if(inputs.length == 0) {<br/>    console.log("Error loading ChETA: Input not found")<br/>    return;<br/>  }<br/>  var text = inputs[0].value.split(config.code).reverse()[0];<br/>  // alert(text)<br/>  inputs[0].value = inputs[0].value;<br/>  inputs[0].addEventListener('input', (e) =&gt; {<br/>    var inputs = getInputsByValue(config.code);<br/>    if(inputs.length == 0) {<br/>      console.log("Error loading ChETA: Input not found");<br/>      return;<br/>    }<br/>    var text = inputs[0].value.split(config.code).reverse()[0];<br/>    var wordCountSpan = document.getElementById("cheta-data-wordcount");<br/>    wordCountSpan.textContent = ""+text.split(" ").length;</span><span id="524e" class="mi lg it no b gy nw nt l nu nv">var charCountSpan = document.getElementById("cheta-data-charcount");<br/>    charCountSpan.textContent = ""+text.length;</span><span id="14a4" class="mi lg it no b gy nw nt l nu nv">if(config.priceperword) {<br/>      var pricePerWord = document.getElementById("cheta-data-priceperword");<br/>      var priceVal = text.split(" ").length * config.priceperword;<br/>      pricePerWord.textContent = ""+priceVal.toFixed(2);<br/>    }<br/>  });<br/>  const div = document.createElement('div');<br/>  var finalHTML = '&lt;div id="cheta-flt-dv"&gt;&lt;p class="cheta-flt-p"&gt;ChETA&lt;/p&gt;';<br/>  finalHTML += '&lt;p class="cheta-pfnt"&gt;Words: &lt;span id="cheta-data-wordcount"&gt;'+text.split(" ").length+'&lt;/span&gt;&lt;/p&gt;';<br/>  finalHTML += '&lt;p class="cheta-pfnt"&gt;Chars: &lt;span id="cheta-data-charcount"&gt;'+text.length+'&lt;/span&gt;&lt;/p&gt;';<br/>  if(config.priceperword) {<br/>    var priceVal = text.split(" ").length * config.priceperword;<br/>    finalHTML += '&lt;p class="cheta-pfnt"&gt;Total PPW: $&lt;span id="cheta-data-priceperword"&gt;'+priceVal.toFixed(2)+'&lt;/span&gt;&lt;/p&gt;';<br/>  }<br/>  finalHTML += '&lt;/div&gt;';<br/>  div.innerHTML = finalHTML;<br/>  document.body.appendChild(div);<br/>}</span><span id="4908" class="mi lg it no b gy nw nt l nu nv">function getInputsByValue(value)<br/>{<br/>    var allInputs = document.getElementsByTagName("input");<br/>    var results = [];<br/>    for(var x=0;x&lt;allInputs.length;x++)<br/>        if(allInputs[x].value.includes(value))<br/>            results.push(allInputs[x]);</span><span id="8686" class="mi lg it no b gy nw nt l nu nv">var allTextArea = document.getElementsByTagName("textarea");<br/>    for(var x=0;x&lt;allTextArea.length;x++)<br/>        if(allTextArea[x].value.includes(value))<br/>            results.push(allTextArea[x]);</span><span id="8033" class="mi lg it no b gy nw nt l nu nv">return results;<br/>}</span><span id="7231" class="mi lg it no b gy nw nt l nu nv">init();</span></pre><h1 id="58ce" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">测试您的新扩展</h1><p id="9068" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">现在我们完成了，让我们测试我们的扩展。首先，我们需要构建我们的项目，我们将生成dist/ folder。为此，让我们运行我们的项目文件夹:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="3a83" class="mi lg it no b gy ns nt l nu nv">npm run build</span></pre><p id="79aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一切顺利，我们应该在命令行中看到这条消息:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/0cfd69f0230bf64ad16f296b0e92d222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKPnvoBJqr-j4IANXJ50Og.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">npm运行构建的结果— ChETA</figcaption></figure><p id="2e4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在打开谷歌Chrome，进入chrome://extensions。在屏幕的右上角，您应该会看到启用开发人员模式的选项。让我们激活它:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/029536ea4edfc25bc0bc4aa29906c0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTwH7dx0hku8KIZ2OVVfSg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">在chrome://extensions中启用开发者模式</figcaption></figure><p id="a06d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你可以上传了！点击<strong class="js iu"> Load unpacked </strong>按钮，找到您的dist/ folder，并加载。最后，和所有扩展一样，你只需要点击这个小按钮就可以看到它:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/ebe7b6e365ee188866ca231abf19ea1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRywAloUMSdLTzWRL0VyyQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">激活ChETA扩展</figcaption></figure><p id="76a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，为了测试它，我们可以去<strong class="js iu">shrib.com</strong>，激活我们的扩展，看看结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/c8b5353440d6b1792d5c9cad09cfbac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lL93cTJrLcvLd8A7V6XMJA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我们新的Chrome文本分析扩展的结果</figcaption></figure><h1 id="8170" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="d4d7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">开发Chrome扩展并没有人们想象的那么难。在JavaScript中，可能性是无限的。</p><p id="b303" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为家庭作业，你可以尝试实现情感分析(在我的另一个教程中解释过，<a class="ae le" href="https://medium.com/analytics-vidhya/sentiment-analysis-of-restaurant-reviews-542727dc24e2" rel="noopener">链接此处</a>)以检测文本的语气(肯定——否定)，或者实现谷歌视觉API来为盲人大声朗读给定网页上图像的文本(<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/convert-paper-based-notes-to-html-content-with-google-vision-api-e398fdb45cb9">在此解释</a>)。</p></div></div>    
</body>
</html>