<html>
<head>
<title>Building Kubernetes CICD pipeline with GitHub Actions, ArgoCD and Reliza Hub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过GitHub Actions、ArgoCD和Reliza Hub建设Kubernetes CICD管道</h1>
<blockquote>原文：<a href="https://itnext.io/building-kubernetes-cicd-pipeline-with-github-actions-argocd-and-reliza-hub-e7120b9be870?source=collection_archive---------2-----------------------#2020-05-11">https://itnext.io/building-kubernetes-cicd-pipeline-with-github-actions-argocd-and-reliza-hub-e7120b9be870?source=collection_archive---------2-----------------------#2020-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b28a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新4(2021年6月):</strong>我们现在使用Kustomize和Reliza CLI来解析每个环境的定义</p><p id="bcca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新3(2021年5月):新增</strong>使用Reliza Hub构建基于Helm的CD教程—<a class="ae kl" href="https://worklifenotes.com/2021/05/22/helm-cd-with-reliza-hub-tutorial/" rel="noopener ugc nofollow" target="_blank">https://worklife notes . com/2021/05/22/Helm-CD-with-Reliza-Hub-tutorial/</a></p><p id="08cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新2: </strong>如果你想实现类似的东西并获得帮助，请随时加入我们新的DevOps &amp; DataOps Discord频道—<a class="ae kl" href="https://discord.gg/UTxjBf9juQ" rel="noopener ugc nofollow" target="_blank">https://discord.gg/UTxjBf9juQ</a>。我很乐意回答问题并提供帮助。</p><p id="f905" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新1:</strong>Reliza Hub中现在有一个新功能，从使用cron调度程序的<a class="ae kl" href="https://worklifenotes.com/2020/05/20/on-demand-builds-on-github-actions-with-reliza/" rel="noopener ugc nofollow" target="_blank">到按需GitHub操作构建</a>改进了这个故事。</p><p id="32a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我想描述一下我们是如何为一个简单的游戏项目组装CICD管道的。我描述的项目你可以在这里找到<a class="ae kl" href="https://mafia.brolia.com" rel="noopener ugc nofollow" target="_blank"/>——这是一个黑手党或狼人游戏的洗牌应用。</p><h1 id="7b90" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">项目构成</h1><p id="ab9f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们的黑手党游戏项目是完全开源的，有两个关键组件:</p><ol class=""><li id="a329" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">使用Vue.js构建的UI组件—<a class="ae kl" href="https://github.com/taleodor/mafia-vue" rel="noopener ugc nofollow" target="_blank">https://github.com/taleodor/mafia-vue</a></li><li id="9d68" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">使用Express构建的后端组件—<a class="ae kl" href="https://github.com/taleodor/mafia-express" rel="noopener ugc nofollow" target="_blank">https://github.com/taleodor/mafia-express</a></li></ol><h1 id="a9ca" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">每个组件的持续集成</h1><p id="998d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们从为每个组件构建CI系统开始。我对每个组件进行CI的理念是通过容器化——使用Dockerfiles。</p><p id="a7b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，这意味着像GitHub Actions这样的CI工具只需要做3件事:检查代码，从Dockerfile构建映像，并将该映像推送到docker registry。构建逻辑本身存储在Dockerfile文件中。</p><p id="29e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以我们在UI项目中使用的<a class="ae kl" href="https://github.com/taleodor/mafia-vue/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>为例。它有两个阶段。在称为“构建阶段”的第一阶段，我们构建Vue.js项目，将其转换为静态UI文件；在称为“工件阶段”的第二阶段，我们使用nginx图像作为基础，并在上面复制我们编译的UI文件。</p><p id="3238" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">后端项目的Dockerfile 更简单。它所做的一切—它将Express应用程序包装在base Node.js映像中。</p><p id="ff39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们的docker文件准备好了，我们需要再做两步——首先，在<a class="ae kl" href="https://relizahub.com" rel="noopener ugc nofollow" target="_blank"> Reliza Hub </a>上建立项目。在Reliza Hub UI中，我创建了一个组织“Mafia Game ”,并设置了我们的2个组件项目，外加一个用于部署数据的额外项目——我将在后面描述。下图显示了这一切在Reliza Hub中的外观:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/9a9a45bcf3ba6d5e745248df2dfacb95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WLTznGQ8eawJGLYZRQBwbw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">雷丽莎中心的黑手党游戏项目</figcaption></figure><p id="a613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要做的第二步是准备Docker注册表。黑手党游戏项目是开源的，因此我使用Docker Hub上的公共图像— <a class="ae kl" href="https://hub.docker.com/r/taleodor/mafia-vue" rel="noopener ugc nofollow" target="_blank"> taleodor/mafia-vue </a>作为UI项目，使用<a class="ae kl" href="https://hub.docker.com/r/taleodor/mafia-express" rel="noopener ugc nofollow" target="_blank"> taleodor/mafia-express </a>作为后端。</p><p id="e0b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，是GitHub动作脚本的时候了。因为他们所做的只是构建Docker图像并发布它们，所以这些脚本对于后端和UI项目来说本质上是相同的。例如，你可以在这里找到<a class="ae kl" href="https://github.com/taleodor/mafia-vue/blob/master/.github/workflows/dockerhub.yml" rel="noopener ugc nofollow" target="_blank"> UI GitHub动作脚本</a>。</p><p id="5948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该脚本使用了以下秘密:Docker _ log in(DOCKER注册表上的用户登录)、DOCKER_TOKEN(来自DOCKER注册表的编程用户令牌)、IMAGE_NAMESPACE —这是我们的DOCKER图像名称空间、IMAGE_NAME —这是我们的图像名称本身、RELIZA_API_ID和RELIZA_API_KEY。在GitHub上通过我们项目的设置-&gt;秘密菜单来设置秘密，如下所示。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mt"><img src="../Images/0ed2ba5dc3e19cd10bb20be02ac8a7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FuIhYMB0ynu_5nWCzljPfw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">GitHub上定义的秘密</figcaption></figure><p id="641e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了我们的秘密集，我们的<a class="ae kl" href="https://github.com/taleodor/mafia-vue/blob/master/.github/workflows/dockerhub.yml" rel="noopener ugc nofollow" target="_blank"> GitHub动作工作流</a>将执行以下操作:</p><ol class=""><li id="9cf3" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">请致电Reliza Hub获取此版本的版本。通过Reliza Hub，项目和分支版本控制是高度可配置的(关于这个过程的更多细节，请参见我的<a class="ae kl" href="https://worklifenotes.com/2020/02/27/automatic-version-increments-with-reliza-hub-2-strategies/" rel="noopener ugc nofollow" target="_blank">以前的博文</a>)。</li><li id="c233" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">构建Docker映像并将其推送到Docker Hub。</li><li id="97e2" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">记录所有图像元数据并将其发送到Reliza Hub，这样我们就有了所有构建细节的记录。Reliza Hub中的最终发布记录如下所示:</li></ol><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mu"><img src="../Images/d017d0f6db8962f2d5771918bcd017fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2nEML_RTD2EzRvy_ZoRNA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">在Reliza Hub中发布元数据</figcaption></figure><p id="21f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们每个组件的CI流程都准备好了！每次我们将代码推送到GitHub，GitHub Actions脚本都会构建一个新的Docker映像，将其推送到Docker Hub，并将所有相关的元数据流式传输到Reliza Hub。</p><h1 id="139b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">构建部署脚本</h1><p id="cf88" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">CI步骤准备就绪后，是时候将我们的部署策略组合在一起了。我们首先创建一个部署Git项目，我在前面简单地提到过。这是GitHub上的这个项目。</p><p id="8507" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始使用Kubernetes之前，我喜欢做的第一件事是准备基本的docker-compose脚本。对于黑手党游戏项目，这样的脚本可以在<a class="ae kl" href="https://github.com/taleodor/mafia-deployment/tree/master/compose" rel="noopener ugc nofollow" target="_blank">这里</a>找到。拥有compose文件允许进行快速的本地测试。</p><p id="7948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我修改了stack，这样它就可以在Kubernetes上运行了，结果文件可以在我的<a class="ae kl" href="https://github.com/taleodor/mafia-deployment/tree/master/k8s" rel="noopener ugc nofollow" target="_blank"> k8s目录</a>中找到(注意这个目录使用了<a class="ae kl" href="https://kubectl.docs.kubernetes.io/guides/introduction/kustomize/#2-create-variants-using-overlays" rel="noopener ugc nofollow" target="_blank"> Kustomize覆盖模式</a>)。</p><p id="649a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，有了docker-compose和Kubernetes定义，是时候建立我们的实例了。对于这个项目，我们使用两个环境，每个环境都由自己独立的k8s集群组成:测试和生产。这是一个小项目，所以2个环境足够了。</p><p id="b611" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通过UI将这些实例添加到Reliza Hub，如下所示:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/d6a7ad1557226683850068f9a12e834b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*chVEw66LgN4bgIs17Ndu0w.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Reliza Hub上的黑手党游戏实例</figcaption></figure><p id="9502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在我们的部署项目中，我们为最终的k8s定义创建2个目录——每个实例一个目录。最初，两个目录都是空的。对于测试实例，我们使用<a class="ae kl" href="https://github.com/taleodor/mafia-deployment/tree/master/k8s_test_gcp" rel="noopener ugc nofollow" target="_blank"> k8s_test_gcp </a>，对于生产实例，我们使用<a class="ae kl" href="https://github.com/taleodor/mafia-deployment/tree/master/k8s_prod_gcp" rel="noopener ugc nofollow" target="_blank"> k8s_prod_gcp </a>。</p><p id="314b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将ArgoCD指向每个实例，从其各自的目录中提取。下面我展示了来自我们测试实例的ArgoCD配置。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mw"><img src="../Images/01a2c397986f08bb01f1f963b98cfa14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9BIKJ7IXGiEBB5vN0woQJA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">测试实例上的ArgoCD配置</figcaption></figure><p id="d029" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们希望对部署存储库本身进行版本控制。为此，我们在每次推送时都创建GitHub Actions CI工作流——每次推送时，它都会向Reliza Hub上的mafia-deployment项目发送发布元数据。这个项目的GitHub动作脚本可以在<a class="ae kl" href="https://github.com/taleodor/mafia-deployment/blob/master/.github/workflows/reliza.yml" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="fa26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，因为这里除了源代码没有工件，我们提交工件类型作为“文件”,发送Git SHA1作为工件摘要。</p><h1 id="6f0e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">将k8s与Reliza合并为最终定义</h1><p id="8156" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果您还记得，我们为测试和生产实例设置了目录。然而，这些目录起初是空的。问题是我们如何用自动化的方式来填充它们？</p><p id="d09c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决版本问题，我们将在Kustomize结果上使用Reliza Hub功能。</p><p id="41f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但首先，让我们在Reliza Hub设置菜单中定义我们的批准矩阵。对于黑手党游戏，我们允许任何最新的<strong class="jp ir">完成的</strong>版本被部署来测试。但是要在生产中部署，发布将需要PM的批准。</p><p id="8032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这反映在如下所示的批准矩阵中:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mx"><img src="../Images/20a54bfe01a58ab9ab5ff89433058b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTqZvHkMV1LfgbeDAz11Iw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">雷丽莎中心黑手党游戏的批准矩阵</figcaption></figure><p id="1a36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，在Reliza Hub UI中，我们创建了一个名为“Mafia”的产品来跟踪我们两个微服务(后端和UI)的版本的<a class="ae kl" href="https://worklifenotes.com/2020/03/04/microservices-combinatorial-explosion-of-versions/" rel="noopener ugc nofollow" target="_blank">的多种排列。</a></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi my"><img src="../Images/dff3c6d8b6154972e990b5fe2f1304f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_TVJlW25NPS1TSnsqeC7A.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Reliza中心的黑手党产品</figcaption></figure><p id="6ad2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步，我们转到Reliza Hub UI中的Mafia测试实例，并将其设置为集成Mafia产品。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mz"><img src="../Images/6d81dda083a757f64e341fa9106b7fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sU6RLdkZnWQQyCGg8W7kxg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">添加产品版本以测试Mafia实例</figcaption></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi na"><img src="../Images/bf4e3f301e341c54d3ec0681624a0cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0I3K5jCc9CFNL2cFSLIEw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">将Mafia产品添加到测试实例</figcaption></figure><p id="10d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，我们将Mafia产品添加到生产实例中，但是这一次我们选择“FOLLOW”集成类型，而不是“INTEGRATE”。“INTEGRATE”类型意味着每次Reliza Hub在实例上检测到新的项目排列时，都会生成一个新的产品版本。“FOLLOW”类型意味着Reliza Hub将根据批准状态向实例客户端提交工件详细信息。</p><p id="9714" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们利用Reliza CLI 的Kustomize和<a class="ae kl" href="https://github.com/relizaio/reliza-cli#72-use-case-replace-tags-on-deployment-templates-to-inject-correct-artifacts-for-gitops-using-instance-and-revision" rel="noopener ugc nofollow" target="_blank"> replacetags功能，并在GitHub Actions </a>中创建一个<a class="ae kl" href="https://github.com/taleodor/mafia-deployment/blob/master/.github/workflows/gitopsUpdateFromReliza.yml" rel="noopener ugc nofollow" target="_blank"> GitOps作业。它的作用——它从<strong class="jp ir"> k8s </strong>目录中定制定义，并将处理后的文件写入<strong class="jp ir"> k8s_test_gcp </strong>和<strong class="jp ir"> k8s_prod_gcp </strong>目录，其中包含来自Reliza Hub的各个实例的解析版本。</a></p><p id="fb14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具体来说，下面的bash代码包含了用于测试的解析逻辑:</p><pre class="me mf mg mh gt nb nc nd ne aw nf bi"><span id="8a96" class="ng kn iq nc b gy nh ni l nj nk"># test                                 <br/>docker run --rm -v ${PWD}/k8s:/sourcek k8s.gcr.io/kustomize/kustomize:v4.1.3 build /sourcek/overlays/test &gt; k8s_test_gcp/kustomized_defs.yaml<br/>docker run --rm -u root -v ${PWD}/k8s_test_gcp/kustomized_defs.yaml:/values.yaml relizaio/reliza-cli replacetags -i $RELIZA_API_ID -k $RELIZA_API_KEY --instanceuri testmafia.brolia.com --infile /values.yaml --provenance=false &gt; k8s_test_gcp/mafia_defs.yaml<br/>rm k8s_test_gcp/kustomized_defs.yaml</span></pre><p id="47a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们通过Reliza Hub在GitHub Actions上配置按需构建，如本文中的<a class="ae kl" href="https://worklifenotes.com/2020/05/20/on-demand-builds-on-github-actions-with-reliza/" rel="noopener ugc nofollow" target="_blank">所述。本质上，对于来自我们前端或后端项目的任何触发器，我们将相应地触发我们的GitOps脚本来运行和填充k8s测试和k8s生产目录。</a></p><h1 id="47cd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">解析来自实例的反馈以跟踪变化</h1><p id="2c4a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">最后一步——我们想知道我们的每个实例上当前部署了什么版本的软件，以及它们如何与目标版本相对应。为此，我们利用<a class="ae kl" href="https://worklifenotes.com/2020/01/25/kubernetes-list-all-deployed-images-with-sha256-hash/" rel="noopener ugc nofollow" target="_blank"> kubectl命令列出已部署映像</a>的所有SHA256摘要，并将这些数据从每个实例传输到cron调度器上的Reliza Hub。<a class="ae kl" href="https://github.com/taleodor/mafia-deployment/blob/master/send_instance_data_to_reliza.sh" rel="noopener ugc nofollow" target="_blank">在我们的部署库</a>中定义了一个用于传输此类数据的脚本。</p><p id="7215" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，我们有一个<a class="ae kl" href="https://github.com/taleodor/mafia-deployment/blob/master/send_argo_data_to_reliza.sh" rel="noopener ugc nofollow" target="_blank">脚本</a>来流传输ArgoCD使用的Git提交的SHA1，以跟踪我们在每个实例上的部署项目的版本。</p><p id="995c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当Reliza Hub从实例接收这些数据时，它会根据CI步骤中先前保存的元数据解析SHA256或SHA1摘要。</p><p id="46ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们在Reliza Hub中有一张图片，显示了在我们的实例上到底部署了什么:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nl"><img src="../Images/6d7948c45c3f3fb8b51b762d5949721f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8XyvpSen69yrnM4SVE4GPA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Reliza Hub上的Mafia生产实例</figcaption></figure><p id="90b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，每个修订都会被跟踪，您可以按日期搜索变更和部署。</p><h1 id="e2ec" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">批准</h1><p id="e99c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">到目前为止，我们所取得的成果是，每一个最新完成的版本都被自动部署到我们的测试实例中。然后，测试实例将有关它的信息提交给Reliza Hub。Reliza Hub发布新产品。</p><p id="4591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，该产品由PM批准(记住我们上面讨论的批准矩阵):</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nm"><img src="../Images/088762a9e33becef9fbb099ba3d5e793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7K8RM18lM97OeIHlePiCw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">经项目经理批准后发布</figcaption></figure><p id="a250" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦发布被批准，我们的生产实例将获得它，并通过GitOps和ArgoCD自动部署到生产中。请参见<a class="ae kl" href="https://www.youtube.com/watch?v=PzdZjMby6Is" rel="noopener ugc nofollow" target="_blank">我关于批准的视频</a>，了解Reliza Hub签署流程的更多详情。</p><h1 id="15db" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">我们取得了什么？</h1><p id="5bdd" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们现在有了一个按钮式CI/CD管道，可以在每次推送时自动构建映像。最新完成的发布会自动部署到我们的测试实例中。从测试服务器上，Reliza Hub记录我们产品的工作包。一旦相关方根据我们的批准矩阵批准了一个包(在上面的例子中，由PM批准)，它就会被部署到生产实例中。</p><p id="5f1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的是，每一个变化都被跟踪和搜索。可以简单地通过不认可组件来进行回滚。我们总是知道我们的应用程序的版本，追溯到它的源代码部署在我们的每个实例上。</p><h1 id="56e1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">有兴趣试试Reliza Hub吗？</h1><p id="5b12" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Reliza Hub正处于早期阶段，正在为所有SaaS版本进行公开预览/免费工作，直到2020年底。支持私有云或本地安装，但需要付费。</p><p id="2fbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有兴趣为你的项目尝试Reliza Hub，我很乐意提供支持，并与你合作，使它成为一个成功的故事。为此，请通过<a class="ae kl" href="https://www.linkedin.com/in/pshukhman/" rel="noopener ugc nofollow" target="_blank">我的LinkedIn </a>或<a class="ae kl" href="https://twitter.com/taleodor" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我。</p></div></div>    
</body>
</html>