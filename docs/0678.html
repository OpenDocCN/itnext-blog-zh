<html>
<head>
<title>Sharded MongoDB on Kubernetes using local persistent volumes on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS上的本地持久卷在Kubernetes上分片MongoDB</h1>
<blockquote>原文：<a href="https://itnext.io/sharded-mongodb-on-kubernetes-using-local-persistent-volumes-on-aws-cb4e1092a69c?source=collection_archive---------1-----------------------#2018-05-05">https://itnext.io/sharded-mongodb-on-kubernetes-using-local-persistent-volumes-on-aws-cb4e1092a69c?source=collection_archive---------1-----------------------#2018-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="587a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文将展示如何在AWS上使用本地持久卷创建分片的mongodb集群。</p><p id="e906" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">i3系列实例配有高随机IO性能SSD存储、出色的网络带宽，强烈建议用于MongoDB等NoSQL工作负载。我们对它的MongoDB集群使用相同的方法。现在，这要求我们使用本地持久卷，Kubernetes在1.9中通过延迟卷绑定改进了对本地持久卷的支持。本地持久卷也记录在这里<a class="ae ks" href="https://github.com/kubernetes-incubator/external-storage/tree/master/local-volume" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes-incubator/external-storage/tree/master/local-volume</a>。通过所有这些，不明显的是Kubernetes使得使用本地持久卷变得非常容易。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="3766" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">启用本地持久卷</h1><p id="b9a0" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们将使用Kubespray v2.5.0来启动和管理我们的Kubernetes集群。要启用本地永久卷，请在<code class="fe lw lx ly lz b">inventory/&lt;folder&gt;/group_vars/k8s-cluster.yml</code>中将以下属性设置为真</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="5301" class="mi ku iq lz b gy mj mk l ml mm">persistent_volumes_enabled: true<br/>local_volume_provisioner_enabled: true</span></pre><p id="305d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将启用Kubernetes <code class="fe lw lx ly lz b">PersistentLocalVolumes</code>功能门以及<code class="fe lw lx ly lz b">VolumeScheduling</code>和<code class="fe lw lx ly lz b">MountPropagation</code>。</p><p id="f1c1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还要注意以下两个变量</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="a6a3" class="mi ku iq lz b gy mj mk l ml mm">local_volume_provisioner_base_dir: /mnt/disks<br/>local_volume_provisioner_mount_dir: /mnt/disks</span></pre><p id="d9e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在开始启动集群。在这篇文章中，我启动了一个集群，其中有3个配置节点i3/other和6个i3 . 2x大型实例用于分片。</p><p id="88bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦您使用Kubespray启动了集群，您应该能够看到您的节点</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="ecd2" class="mi ku iq lz b gy mj mk l ml mm">kubectl get nodes</span></pre><p id="fe0f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，您应该标记您的节点，以区分什么是配置，什么是碎片。做这件事有不同的方法。但基本上它相当于发布了类似</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="19ef" class="mi ku iq lz b gy mj mk l ml mm">kubectl label nodes &lt;node name&gt; component=mongo-config<br/>kubectl label nodes &lt;node name&gt; component=mongo-shard</span></pre><p id="6e19" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们稍后将使用这些标签为我们的pod指定<code class="fe lw lx ly lz b">nodeAffinity</code>，以便我们将它们绑定到正确的实例集。</p><h1 id="7d34" class="kt ku iq bd kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq bi translated">设置本地永久卷</h1><p id="cf8d" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在，我们将了解如何调配本地pvs。我们需要做的就是将本地磁盘挂载到/mnt/disks。它们将被自动检测，然后作为本地pv自动提供。</p><p id="fc39" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有几种方法可以做到这一点。您可以使用daemonset或者使用一个简单的脚本来为每个标记为mongo-shard的节点执行此操作。</p><figure class="ma mb mc md gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f6e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的脚本会发现i3实例中的每个磁盘，并使用xfs格式化它们(这是MongoDB 推荐的<a class="ae ks" href="https://scalegrid.io/blog/xfs-vs-ext4-comparing-mongodb-performance-on-aws-ec2/" rel="noopener ugc nofollow" target="_blank">)并挂载到/mnt/disks。它还将条目添加到fstab中，以便在节点重新启动后装载是持久的。</a></p><p id="b645" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在Kubernetes魔术发生了，这些卷是自动可用的！下面的代码片段显示了同样的情况(但是在绑定到pod之后)</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="0449" class="mi ku iq lz b gy mj mk l ml mm">kubectl get pv</span><span id="598f" class="mi ku iq lz b gy mv mk l ml mm">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM                                        STORAGECLASS    REASON    AGE</span><span id="210c" class="mi ku iq lz b gy mv mk l ml mm">local-pv-1756e029                          442Gi      RWO            Delete           Bound     default/data-mongo-shard0-1                  local-storage             9d</span><span id="40ee" class="mi ku iq lz b gy mv mk l ml mm">local-pv-277d7925                          442Gi      RWO            Delete           Bound     default/data-mongo-shard1-0                  local-storage             9d</span><span id="b319" class="mi ku iq lz b gy mv mk l ml mm">local-pv-5e05e368                          442Gi      RWO            Delete           Bound     default/data-mongo-shard1-1                  local-storage             9d</span><span id="16f0" class="mi ku iq lz b gy mv mk l ml mm">local-pv-6836da3e                          442Gi      RWO            Delete           Bound     default/data-mongo-shard0-2                  local-storage             9d</span><span id="504c" class="mi ku iq lz b gy mv mk l ml mm">local-pv-a66723f4                          442Gi      RWO            Delete           Bound     default/data-mongo-shard0-0                  local-storage             9d</span><span id="2cf0" class="mi ku iq lz b gy mv mk l ml mm">local-pv-d3c10f22                          442Gi      RWO            Delete           Bound     default/data-mongo-shard1-2                  local-storage             9d</span></pre></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="afcb" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建密钥文件</h1><p id="e2cf" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们现在将创建密钥文件。我们将以可重复的方式做这件事。</p><figure class="ma mb mc md gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1dfd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个脚本基本上创建了一个mongodb-keyfile，如果它在Kubernetes中不作为秘密存在的话</p><p id="53bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们稍后将在mongo-config、mongo-shard等的所有yaml中引用这个密钥文件秘密。</p><h1 id="8168" class="kt ku iq bd kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq bi translated">启动mongo配置</h1><p id="51a2" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">接下来，我们将调出mongo-config吊舱</p><p id="ce31" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在这里找到YAML<a class="ae ks" href="https://github.com/sabarishs/sharded-mongo-kube-local-pv/blob/master/src/mongo-config.yaml" rel="noopener ugc nofollow" target="_blank">https://github . com/sabar ishs/sharded-mongo-kube-local-PV/blob/master/src/mongo-config . YAML</a></p><p id="3e30" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意我们是如何使用statefulset并将我们的pods绑定到mongo-config标记的节点上的</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="069c" class="mi ku iq lz b gy mj mk l ml mm">affinity:<br/>  nodeAffinity:<br/>    requiredDuringSchedulingIgnoredDuringExecution:<br/>      nodeSelectorTerms:<br/>      - matchExpressions:<br/>      - key: node.ignite.harman.com/component<br/>      operator: In<br/>      values: ["mongo-config"]</span></pre><p id="6f83" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们需要初始化配置复制集</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="6768" class="mi ku iq lz b gy mj mk l ml mm">kubectl exec mongo-config-0 -- mongo --eval "rs.initiate({_id: \"crs\", configsvr: true, members: [ {_id: 0, host: \"mongo-config-0.mongo-config-svc.default.svc.cluster.local:27017\"}, {_id: 1, host: \"mongo-config-1.mongo-config-svc.default.svc.cluster.local:27017\"}, {_id: 2, host: \"mongo-config-2.mongo-config-svc.default.svc.cluster.local:27017\"} ]});"</span></pre><h1 id="7c94" class="kt ku iq bd kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq bi translated">旋转mongo查询路由器盒</h1><p id="0a29" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">接下来，我们将介绍几个查询路由器。Mongo最佳实践建议您应该在每个需要mongo访问的节点上运行这个。您可以将它作为<code class="fe lw lx ly lz b">daemonset</code>运行，并将其绑定到所有需要访问mongo的节点。</p><p id="4cc6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在这里找到YAML<a class="ae ks" href="https://github.com/sabarishs/sharded-mongo-kube-local-pv/blob/master/src/mongo-qr.yaml" rel="noopener ugc nofollow" target="_blank">https://github . com/sabar ishs/sharded-mongo-kube-local-PV/blob/master/src/mongo-QR . YAML</a></p><p id="ded9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意我们如何使用nodeAffinity将它绑定到所有类型为“api”的节点</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="9518" class="mi ku iq lz b gy mj mk l ml mm">nodeAffinity:<br/>  requiredDuringSchedulingIgnoredDuringExecution:<br/>    nodeSelectorTerms:<br/>    - matchExpressions:<br/>      - key: node.ignite.harman.com/component<br/>      operator: In<br/>      values:<br/>      - api</span></pre><p id="ffed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，所有API pods现在都可以使用<node-host-name> :27017访问本地查询路由器</node-host-name></p><p id="5b88" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以在API pod中将它作为一个额外的容器来运行，但是这将意味着多个查询路由器将在一个API节点中运行，并将导致开放mongo连接的数量膨胀。通过作为daemonset运行，我们将其限制为每个候选节点一个。</p><h1 id="f522" class="kt ku iq bd kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq bi translated">旋转mongo-shard</h1><p id="60aa" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">接下来我们将带来一个mongo-shard。因为您想要处理多个分片，所以标准的做法是拥有一个模板，然后通过替换分片索引来为每个分片生成实际的yaml工件。</p><p id="a3fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在这里找到YAML<a class="ae ks" href="https://github.com/sabarishs/sharded-mongo-kube-local-pv/blob/master/src/mongo-shard.yaml" rel="noopener ugc nofollow" target="_blank">https://github . com/sabar ishs/sharded-mongo-kube-local-PV/blob/master/src/mongo-shard . YAML</a></p><p id="21a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将为每个分片生成一个副本，然后初始化副本集，最后在循环中将分片添加到查询路由器。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="494a" class="mi ku iq lz b gy mj mk l ml mm">while [[ $shards -lt $shardcount ]]<br/>do</span><span id="1595" class="mi ku iq lz b gy mv mk l ml mm">  sed "s/shard0/shard$shards/g" mongo-shard.yaml &gt; mongo-shard$shards.yaml</span><span id="b0ed" class="mi ku iq lz b gy mv mk l ml mm">  kubectl apply -f mongo-shard$shards.yaml</span><span id="92b7" class="mi ku iq lz b gy mv mk l ml mm">  kubectl exec mongo-shard$shards-0 -- mongo --eval "rs.initiate({_id: \"shard$shards\", members: [ {_id: 0, host: \"mongo-shard$shards-0.mongo-shard$shards-svc.default.svc.cluster.local:27017\"}, {_id: 1, host: \"mongo-shard$shards-1.mongo-shard$shards-svc.default.svc.cluster.local:27017\"}, {_id: 2, host: \"mongo-shard$shards-2.mongo-shard$shards-svc.default.svc.cluster.local:27017\"} ]});"</span><span id="bba7" class="mi ku iq lz b gy mv mk l ml mm">  kubectl exec $qrPod -- mongo --eval "sh.addShard(\"shard$shards/mongo-shard$shards-0.mongo-shard$shards-svc.default.svc.cluster.local:27017\");"</span><span id="19e5" class="mi ku iq lz b gy mv mk l ml mm">  shards=$(($shards+1))</span><span id="a4e3" class="mi ku iq lz b gy mv mk l ml mm">done</span></pre><p id="6503" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">精彩！我们完了。如果我们现在检查pv，我们会看到它们被绑定。我们的碎片现在与Kubernetes上的本地持久卷同步。干得好！</p><p id="d561" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我的github<a class="ae ks" href="https://github.com/sabarishs/sharded-mongo-kube-local-pv" rel="noopener ugc nofollow" target="_blank">https://github.com/sabarishs/sharded-mongo-kube-local-pv</a>中可以找到所有这些工件和将它们联系在一起的引导脚本</p><p id="f8be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我建议您查看引导脚本。它可以重新运行任何次数，也有助于扩展碎片的数量。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="39e1" class="mi ku iq lz b gy mj mk l ml mm">#the following sets up 2 sharded cluster<br/>mongo-bootstrap.sh 2</span><span id="311e" class="mi ku iq lz b gy mv mk l ml mm">#the following adds another shard to make it a 3 shard cluster<br/>mongo-bootstrap.sh 3</span></pre><h1 id="d6e8" class="kt ku iq bd kv kw mn ky kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq bi translated">确认</h1><p id="3484" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">如果没有Paul Done和Sunny的这些精彩博文，我不可能在3天内完成所有这些工作。</p><p id="2bdd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="http://pauldone.blogspot.in/2017/06/deploying-mongodb-on-kubernetes-gke25.html" rel="noopener ugc nofollow" target="_blank"> Paul Done的优秀博客</a><br/>T3】Sunny的中等博客</p></div></div>    
</body>
</html>