<html>
<head>
<title>Effective Algorithms for Dart and Flutter. Big O.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">飞镖和颤振的有效算法。大o。</h1>
<blockquote>原文：<a href="https://itnext.io/effective-algorithms-for-dart-and-flutter-big-o-874627c433ba?source=collection_archive---------0-----------------------#2021-06-16">https://itnext.io/effective-algorithms-for-dart-and-flutter-big-o-874627c433ba?source=collection_archive---------0-----------------------#2021-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/77886c367ecc5ecd30524c5456f3281b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsnUkqE3uqaALgvFSSgnzw.png"/></div></div></figure><p id="3caf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可能技术面试最重要的部分是算法和数据结构的知识检查。这是任何语言的专业程序员学习曲线的必备部分，尤其是对于Flutter。</p><p id="7752" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Flutter的荣耀使命是为移动设备编写代码。移动设备需要特别关注其算法的性能和有效的内存使用。我们没有通过升级服务器硬件来获得更高CPU和内存的纵向扩展。加上高效算法的强大功能，你可以为Android和IOS创建更快、更稳定的代码。这就是为什么面试官会对你的能力进行压力测试。</p><p id="6e22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在进一步阅读之前，让我们做一个检查。你听说过<a class="ae kw" href="https://leetcode.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> leetcode </strong> </a>吗？如果是，就继续读下去。如果没有，请花10-15分钟浏览一下这个网站的问题和社区页面。这是行业趋势在面试和选择一个工作或远程项目的新程序员的整个过程中的反映。</p><p id="d25c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，我将在本主题接下来的部分解释一些最重要的leetcode问题。</p><p id="cc32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天我们将试着理解核心原理，甚至是定律，我们可以用它来估计任何算法的效率。</p><p id="4627" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些知识，加上一些提高效率的技巧和方法的知识地图，形成了这个“可怕”的部分。</p><h1 id="0c29" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">算法很重要</h1><p id="7109" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">攻击算法和数据结构的第一步是理解它们为什么如此重要。</p><p id="1fbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来考虑一个非常简单的Flutter app。这个应用程序必须计算像[1，2，3，4，…]这样的整数递增序列的总和。</p><p id="b196" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用<a class="ae kw" href="http://flutlab.io" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> FlutLab.io </strong> </a>，你也可以从<a class="ae kw" href="https://widgetbay.flutlab.io/widget/algorithms-matter" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> FlutLab的WidgetBay </strong> </a>中抓取初始项目。如果你以前没有使用FlutLab，这是一个在线Flutter IDE，你可以在这里免费注册和构建你的应用程序。如果您已经有一个帐户，请转到WidgetBay上的初始项目<a class="ae kw" href="https://widgetbay.flutlab.io/widget/algorithms-matter" rel="noopener ugc nofollow" target="_blank">并单击“Fork to FlutLab IDE”。</a></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/8130c6d33b25ef515af9613647ce75cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24Nc07uAmjWDe0GtXLrnxg.png"/></div></div></figure><p id="6f0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以在您的个人资料中找到这个项目:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/08d31f621f82629677da19d02b1fb476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0jmUgfjefhKfqkR7YgU8Q.png"/></div></div></figure><p id="dd2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进入该项目并运行Web Build。您应该在Web模拟器的中心看到“结果:0 ”:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/2503fe5d306e24de94d3722027b5aa5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4i1OjmkdzyqPpeFgpgCOvw.png"/></div></div></figure><p id="b13a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此应用程序的计算部分是作为一个名为“Algo”的独立Dart类制作的:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/64b6e63b52a2fa3bbe31f07c2ad8e8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*BzHw7ORi-u7Pm2y9UWBkaA.png"/></div></figure><p id="95dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前它只包含方法“perform”的占位符，返回0。</p><p id="39da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是为什么我们在运行这个应用程序时可以看到“结果:0”:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/babf65a32888f3bac2252e8c6a80229b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FfCtDNbCKonnj_j92Amrw.png"/></div></div></figure><p id="ac40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们实现Algo来计算列表元素的总和:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/c75abfa0a069ff6842edbe3884eb826f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8maA4Tj9cEDacYES9o4MUQ.png"/></div></div></figure><p id="2d2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很简单，对吧？让我们再次运行web build或热重装:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/d13152830147e3dc9e16b007eebe9bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gO2-JxfB9UIdRJQJYmM-zg.png"/></div></div></figure><p id="7429" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切看起来不错。实际上，普通的Flutter开发者会很高兴地止步于此。</p><p id="8b6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们能改进这个解决方案吗？</p><p id="5fa4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是啊！</p><p id="c759" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何看出这个方案并不理想？让我们打开包含算法单元测试的项目的另一部分:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/08a4eb872a729849f4abd8710b3e54a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7tCMh3GM1ImLQx8ReGvrA.png"/></div></div></figure><p id="c532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们有两个单元测试:</p><ul class=""><li id="0400" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">算法应该工作正常</li><li id="590d" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">算法应该有效地工作</li></ul><p id="d532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过单击“运行测试”按钮来运行这个测试包:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/a474780fe77ebf7aaa3e38d4cea008bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*rSGtjy5gBrvx08l-1RdU9g.png"/></div></figure><p id="c05d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，第一个测试“算法应该正确工作”通过了，但第二个测试“算法应该有效工作”——失败了。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/43710ae0819885c32f91a6f5f126d95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GgAuHjjy8uiK00fE61fzOg.png"/></div></div></figure><p id="f6b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为它花费了超过100毫秒的时间，这是算法执行的最大允许时间:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b7d4c91dc890adfa7f5dd8adecb907b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*O6PgjT_tR2nHbAjGoMYPiA.png"/></div></figure><h1 id="d269" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">大O来帮忙了</h1><p id="2700" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们可以改变单元测试的代码，可以注意到，这个测试通过了一些不是很大的数组。</p><p id="7351" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们的算法需要完成的时间是它的输入——数字数组——的大小的函数。</p><p id="2fe9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大O符号给了我们简单的标准来估计我们算法的速度或时间复杂度。</p><p id="8be6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种方法中，我们不需要估计算法所需的物理时间。因为这个时间取决于我们电脑的性能和它在做多少后台工作。</p><p id="1c46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们可以相对于输入数据的大小来估计当时的<strong class="ka ir">阶</strong>。</p><p id="99d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，完成时间(让我们用<strong class="ka ir">时间复杂度</strong>术语)可以是1，n，n等。其中n是要处理的数据的大小。</p><p id="3e2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相应地，算法的时间复杂度可以是O(1)，O(n)，O(n)</p><p id="9dab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">O(1)是算法和数据结构的圣杯——最优化的算法都有这个时间复杂度。</p><p id="92d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">O(n)可以接受，但不太好。而O(n)是纯粹的邪恶。</p><p id="3683" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何计算我们算法实现的时间复杂度？</p><p id="e0b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过计算操作！</p><p id="905f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们有一个大小为n的输入数组，我们的代码需要多少次逻辑运算？</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/7362f1e587e2b0ea65314eb4d41a27d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*Nh2z_YT7tFN7TFGi_dF0aA.png"/></div></figure><p id="c816" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1求和初始化操作</p><p id="8137" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">循环的n次操作</p><p id="84fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1个返回值的操作</p><p id="cc6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太棒了。我们有O(n + 2)的时间复杂度。没那么快。当我们需要知道时间复杂度的阶数时，我们应该截断所有的常数。不管我们有O(2n)，O(4n+3)还是O(1000n + 2000)，我们只要提一个事实，时间复杂度是n的线性函数，这里的正确答案是O(n)。</p><p id="2d07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您仍然没有完全理解大o的概念，请不要担心。我们将重新讨论不同算法的时间和空间复杂度的计算。</p><p id="00a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">等一下！—你可以说。我们真的可以把这个算法重新加工成一个常数的阶，O(1)。是的，我的朋友，我们可以。</p><p id="87f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们记住，我们是在对线性增长的数字求和。从1开始，每个下一个值都比1大。</p><p id="46c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以画一个小图，在数字要求和的地方用深色标出:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b8019235fccf8d71526df8bc389af65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*3t83h4XI_rdPyOL11Dv78g.png"/></div></figure><p id="193f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中X轴是数组项的位置，Y轴是它的值。我们添加了值为0的0的元素，以展示一个有趣的现象:所有项目的总和是矩形n*(n+1)的总面积除以2。事实上，黑暗细胞正好占据了大矩形空间的一半。</p><p id="6f4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们的新算法应该是这样的</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/b220807e088d4add2f641afad4171c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*PnKCp3H0CbdeKZUe9nLwtQ.png"/></div></figure><p id="957e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是2次运算，与输入数组的大小无关。所以，是O(1)。</p><p id="264e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这一改变，我们所有的测试都成功通过了:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/14b1c600d12dff2043c766da834c2c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLo2ZHGUfE0Fv7EkfnUMuQ.png"/></div></div></figure><p id="d9dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结论。算法和数据结构是一个复杂而广泛的知识库。但是，我们可以在实践中学习。它的方法和术语的关键的、小的子集允许我们编写更有效的代码并通过编码面试。今天我们了解到，即使是最简单的算法也可以通过计算其运算次数来优化。还有，我们遇到了大O符号。我们将很快看到更多的例子来巩固我们的大O本能，形成我们的新心态。</p><p id="b274" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">待续..</p></div></div>    
</body>
</html>