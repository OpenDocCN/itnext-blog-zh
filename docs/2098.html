<html>
<head>
<title>Redis 5.X under the hood: 3 — Writing a Redis Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis 5。幕后x:3—编写Redis模块</h1>
<blockquote>原文：<a href="https://itnext.io/redis-5-x-under-the-hood-3-writing-a-redis-module-43fa42a6367d?source=collection_archive---------1-----------------------#2019-03-31">https://itnext.io/redis-5-x-under-the-hood-3-writing-a-redis-module-43fa42a6367d?source=collection_archive---------1-----------------------#2019-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6a4b2816307975dd5ef0f065b98d9b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EdjHjNBNJ_RjDaBcWochg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><strong class="bd kf">奥克兰海湾大桥</strong> —这张照片是2019年3月30日在旧金山海湾拍摄的——当时我在写这篇文章，为RedisConf 19做准备</figcaption></figure><p id="de4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管Redis支持许多数据类型和丰富的特性，但有时您可能会被要求在数据上添加核心Redis不支持的定制逻辑。当这种情况发生时，您有两种选择来实现相同的需求，要么通过Lua脚本，要么通过Redis模块。Lua脚本是一种“组合”现有数据结构和命令的方法，但不是一种将系统功能扩展到它没有设计覆盖的用例的方法。与Lua脚本相比，Redis模块具有以下优势:</p><ul class=""><li id="ae7c" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">使用Redis模块可以创建新的数据结构，而使用Lua脚本只能使用现有的数据结构。</li><li id="53d1" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">作为C库，Redis模块运行速度更快，开销更少，同时还允许您调用外部第三方库。</li><li id="e53d" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">通过Redis模块添加的命令可以通过Redis客户端直接调用，就好像它们是Redis的本地命令一样，而对于Lua，脚本必须通过EVAL/EVALSHA调用。</li><li id="7996" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">暴露给Redis模块的API比暴露给Lua脚本的API丰富得多。</li></ul><h2 id="7a8c" class="ls lt it bd kf lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">Redis模块为什么成功？</h2><p id="dfc7" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">早在2016年，Salvatore Sanfilippo在他的博客上写了关于模块作为系统功能<a class="ae mp" href="http://antirez.com/news/106" rel="noopener ugc nofollow" target="_blank">的文章:</a></p><blockquote class="mq"><p id="3fa3" class="mr ms it bd mt mu mv mw mx my mz ld dk translated">模块可能是系统中最有趣的特性，同时也是最有问题的特性:版本之间的API不兼容、低质量的模块使系统崩溃、缺乏可扩展系统的身份都是可能的问题。</p></blockquote><p id="208f" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">Redis模块API是为未来的兼容性而设计的，所以今天编写的模块可以在4年后使用相同的API工作，而不管Redis核心的变化。从这些基础出发，为了访问Redis数据空间，诞生了两种不同的API:</p><ul class=""><li id="bf01" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">一个是低级API，提供非常快速的访问和一组操作Redis数据结构的函数。Redis开发人员可以创建与Redis本地命令一样强大和快速的命令。</li><li id="9c3e" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">另一个API更高级，允许调用Redis命令并获取结果，类似于Lua脚本访问Redis的方式。</li></ul><p id="a9c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Redis模块使Redis用户走得更快，而不会危及Redis核心及其开发，因为这两个基础API被承诺在未来几年不会有突破性的变化。API将得到改进，但具有完全的向后兼容性，因为模块注册需要给定的API版本。</p><p id="337c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将进一步检查底层API，但是首先，我们将介绍如何加载现有的Redis模块。</p><p id="b603" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将展示如何用一个操作列表编写一个简单的Redis模块。FILTER，这将使我们能够过滤列表中的低值和高值(实现通常所说的低值和高值过滤器)。</p><h1 id="a765" class="nf lt it bd kf ng nh ni lw nj nk nl lz nm nn no mc np nq nr mf ns nt nu mi nv bi translated">0.1在我们深入探讨之前:</h1><p id="11e4" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们决定记录这个相互学习的旅程，以更好地理解核心Redis 5及其顶级扩展如何工作，讨论这个新版本中的新特性，因此阅读这一系列文章的人可以就它适合和不适合的不同用例做出明智的决定。</p><p id="cf7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们会认为你对Redis 5有一个整体的了解。x和一个Redis 5。x服务器实例运行，正如我们在本系列的前几篇文章中所描述的:</p><p id="2429" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">— <a class="ae mp" href="https://medium.com/@fcosta_oliveira/redis-5-x-under-the-hood-1-downloading-and-installing-redis-locally-3373fe67a154" rel="noopener"> Redis 5。幕后x:1—Redis-服务器启动并运行</a></p><p id="29f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">——<a class="ae mp" href="https://medium.com/@fcosta_oliveira/redis-5-x-under-the-hood-2-intro-to-redis-commands-and-data-structures-part-1-41f05501cb52" rel="noopener">Redis 5。引擎盖下的x:2—Redis命令和数据结构介绍—第1部分</a></p><p id="ae11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">— <a class="ae mp" href="https://medium.com/@fcosta_oliveira/straightforward-time-series-dbs-with-redis-5-x-part-1-redistimeseries-module-79aa616159eb" rel="noopener">直截了当的时间序列DBs与Redis 5。X —第1部分::RedisTimeSeries模块</a></p><h1 id="2bfd" class="nf lt it bd kf ng nh ni lw nj nk nl lz nm nn no mc np nq nr mf ns nt nu mi nv bi translated">1 —加载和构建模块</h1><p id="365b" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">有许多Redis模块可以用来扩展Redis的功能。在撰写本文时，这些是Github stars的顶级模块:</p><ul class=""><li id="0b90" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><a class="ae mp" href="https://github.com/antirez/neural-redis" rel="noopener ugc nofollow" target="_blank"> neural-redis </a>:作为redis数据的在线可训练神经网络</li><li id="d3b4" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">【Redis搜索【Redis上的全文搜索</li><li id="e4c6" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae mp" href="https://github.com/RedisLabsModules/redisjson" rel="noopener ugc nofollow" target="_blank">Redis JSON</a>:Redis的JSON数据类型</li><li id="8f34" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae mp" href="https://github.com/RedBeardLab/rediSQL" rel="noopener ugc nofollow" target="_blank"> rediSQL </a>:一个Redis模块，提供了一个快速的、内存中的SQL引擎(嵌入了SQLite)</li><li id="1883" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae mp" href="https://github.com/brandur/redis-cell" rel="noopener ugc nofollow" target="_blank">redis-cell</a>:Redis模块，在Redis中以单个命令的形式提供速率限制</li><li id="ce3e" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae mp" href="https://github.com/RedisLabsModules/RedisGraph" rel="noopener ugc nofollow" target="_blank"> RedisGraph </a>:使用稀疏邻接矩阵的基于密码的查询语言的图形数据库</li><li id="86b2" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae mp" href="https://github.com/RedisLabsModules/redisml" rel="noopener ugc nofollow" target="_blank"> RedisML </a>:机器学习模型服务器</li><li id="ebff" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae mp" href="https://github.com/RedisLabsModules/RedisTimeSeries" rel="noopener ugc nofollow" target="_blank">Redis Time series</a>:Redis的时序数据结构。如果您还记得，我们曾经写过一篇文章，提供了深入的使用示例—<a class="ae mp" href="https://medium.com/@fcosta_oliveira/straightforward-time-series-dbs-with-redis-5-x-part-1-redistimeseries-module-79aa616159eb" rel="noopener">Redis 5中简单的时间序列数据库。X — part 1 :: RedisTimeSeries模块</a>。</li></ul><h2 id="7c4d" class="ls lt it bd kf lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">1.1—构建RedisJSON模块:</h2><p id="64e2" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">通过在您的终端上执行以下命令，从GitHub下载RedisJSON的源代码:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="1e51" class="ls lt it ob b gy of og l oh oi">git clone --depth 1 <a class="ae mp" href="https://github.com/RedisLabsModules/redisjson.git" rel="noopener ugc nofollow" target="_blank">https://github.com/RedisLabsModules/redisjson.git</a> &amp;&amp; cd redisjson<br/>cd src<br/>make</span></pre><p id="9470" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模块二进制文件将被生成为<strong class="ki iu"> rejson.so </strong></p><h2 id="ed9d" class="ls lt it bd kf lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">1.2 —加载RedisJSON模块:</h2><p id="c88c" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">使用以下<code class="fe oj ok ol ob b">redis.conf</code>配置指令加载模块:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="3416" class="ls lt it ob b gy of og l oh oi">loadmodule <strong class="ob iu">/path/to/</strong><strong class="ob iu">rejson</strong><strong class="ob iu">.so</strong></span></pre><p id="7650" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="24de" class="ls lt it ob b gy of og l oh oi">redis-server <strong class="ob iu">/path/to</strong><strong class="ob iu">/redis.conf &amp;<br/></strong>redis-cli <br/>127.0.0.1:6379&gt;</span></pre><p id="63f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还可以在运行时使用MODULE LOAD命令加载一个模块，该命令带有我们要加载的Redis模块的路径:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="0b19" class="ls lt it ob b gy of og l oh oi">MODULE LOAD <strong class="ob iu">/path/to/</strong><strong class="ob iu">rejson</strong><strong class="ob iu">.so</strong></span></pre><p id="7b83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果模块是通过模块加载命令加载的，那么当服务器停止时，它将被自动卸载。</p><p id="fb27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要列出所有加载的模块，请使用:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="bb1e" class="ls lt it ob b gy of og l oh oi">127.0.0.1:6379&gt; module list<br/>1) 1) "name"<br/>   2) "ReJSON"<br/>   3) "ver"<br/>   4) (integer) 10004</span></pre><p id="e992" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，您可以使用以下命令卸载(如果愿意，以后可以重新加载)模块:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="6d6c" class="ls lt it ob b gy of og l oh oi">MODULE UNLOAD <strong class="ob iu">*name of the module*</strong></span></pre><p id="30dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你应该知道，如果我们加载的模块导出了一个或多个模块端的数据类型，就像<strong class="ki iu">redis son</strong>所做的那样，我们就不能在运行时卸载它。我们应该从<code class="fe oj ok ol ob b">redis.conf</code>文件中删除配置指令，然后重启redis-server。如果您尝试在运行时卸载ReJSON，您应该会看到以下错误消息:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="5b4f" class="ls lt it ob b gy of og l oh oi">127.0.0.1:6379&gt; <strong class="ob iu">MODULE UNLOAD ReJSON</strong></span><span id="ffc5" class="ls lt it ob b gy om og l oh oi">(error) ERR Error unloading module: the module exports one or more module-side data types, can't unload</span></pre><h1 id="1204" class="nf lt it bd kf ng nh ni lw nj nk nl lz nm nn no mc np nq nr mf ns nt nu mi nv bi translated">2—编写我们的Redis模块</h1><p id="1fb8" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">编写Redis模块最简单直接的方法是从Redis的官方<a class="ae mp" href="https://github.com/antirez/redis/blob/5.0/src/redismodule.h" rel="noopener ugc nofollow" target="_blank">库</a>下载一份<code class="fe oj ok ol ob b">redismodule.h</code>头文件，将它包含在我们的源代码树中，编写模块，链接我们想要的所有库，并创建一个导出了<code class="fe oj ok ol ob b">RedisModule_OnLoad() </code>函数符号的动态库。</p><p id="29b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以用C++或任何具有C绑定功能的语言编写模块。</p><p id="12e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要用C语言实现一个Redis模块LIST_EXTEND，带有一个新的命令过滤器，可以调用如下:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="ffa0" class="ls lt it ob b gy of og l oh oi">127.0.0.1:6379&gt; <strong class="ob iu">LIST_EXTEND.FILTER</strong> source_list destination_list low_value high_value</span></pre><p id="d8bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该命令获取一个Redis列表<strong class="ki iu"> source_list </strong>并尝试创建另一个Redis列表<strong class="ki iu"> destination_list </strong>，其元素如果是数字，将被条件过滤:</p><ul class=""><li id="d88c" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">低_值≥元素值≤高_值</li></ul><p id="90aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果low_value大于high_value，则返回一个空列表。</p><p id="557f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">low_value和high_value可以是-inf和+inf，这样您就可以只实现低过滤器、高过滤器或两者都实现。默认情况下，由low_value和high_value指定的间隔是封闭的(包含)。</p><p id="aa34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">返回值<br/> </strong>整数回复:过滤操作后destination_list列表的长度。</p><p id="b827" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果执行了以下命令:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="e1f4" class="ls lt it ob b gy of og l oh oi">127.0.0.1:6379&gt; <strong class="ob iu">LPUSH</strong> source_list 20 2 30 1 40<br/>(integer) 4<br/>127.0.0.1:6379&gt; <strong class="ob iu">LIST_EXTEND.FILTER</strong> source_list destination_list 2 20<br/>(integer) 3<br/>127.0.0.1:6379&gt; <strong class="ob iu">LRANGE</strong> destination_list 0 -1<br/>1) "1"<br/>2) "2"<br/>3) "20"</span></pre><p id="eb21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">destination_list将具有[1，2，20],因为source_list的其他值没有验证低值和高值过滤条件。</p><h2 id="4c06" class="ls lt it bd kf lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">2 .1—编写我们的LIST_EXTEND模块</h2><h2 id="a9ce" class="ls lt it bd kf lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">项目结构</h2><p id="8c88" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">让我们首先创建一个名为<code class="fe oj ok ol ob b">list_extend.c</code>的文件，并包含名为<code class="fe oj ok ol ob b">redismodule.h</code>的C头文件。</p><figure class="nw nx ny nz gt ju"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="e59c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要担心复制代码的每个要点。完整的模块项目文件夹可以在GitHub的以下<a class="ae mp" href="https://github.com/filipecosta90/list_extend" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。</p><h2 id="82f1" class="ls lt it bd kf lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">模块入口点</h2><p id="31d5" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">每个Redis模块的入口点是一个名为<code class="fe oj ok ol ob b">RedisModule_OnLoad()</code>的函数，使它能够被初始化，注册它的命令，以及它使用的其他私有数据结构。对于模块来说，调用命令的一个好习惯是在模块名后面跟一个点，最后是命令名。在我们的例子中，我们的命令将以下面的方式调用<code class="fe oj ok ol ob b">LIST_EXTEND.FILTER</code>。这样就不太可能发生碰撞。下面是我们的<code class="fe oj ok ol ob b">RedisModule_OnLoad()</code>实现:</p><figure class="nw nx ny nz gt ju"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="9976" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe oj ok ol ob b">RedisModule_OnLoad()</code>内部，第一个要调用的函数应该是<code class="fe oj ok ol ob b">RedisModule_Init()</code>。以下是函数原型:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="54cc" class="ls lt it ob b gy of og l oh oi">int RedisModule_Init(RedisModuleCtx *ctx, const char *modulename, int module_version, int api_version);</span></pre><p id="3235" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oj ok ol ob b">Init</code>函数通知Redis核心模块有一个给定的名称、它的版本(由<code class="fe oj ok ol ob b">MODULE LIST</code>报告)以及愿意使用的API版本。</p><p id="47c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个函数名为<code class="fe oj ok ol ob b">RedisModule_CreateCommand()</code>，用于将命令注册到Redis核心中，具有以下函数原型:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="ad24" class="ls lt it ob b gy of og l oh oi">int RedisModule_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep);</span></pre><p id="28d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标志集“strflags”指定了命令的行为，应该作为由空格分隔的单词组成的C字符串传递。因为我们的命令修改数据，所以我们添加了“写入”。我们的命令也将使用额外的内存，并且应该在内存不足的情况下被拒绝，因此我们添加了标志“deny-oom”。在我们的例子中，“strflags”将是“write deny-oom”。</p><p id="4b3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除非有错误，否则RedisModule_OnLoad()的返回值应该是REDISMODULE_OK。</p><h2 id="87f2" class="ls lt it bd kf lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">创建命令处理程序</h2><p id="2157" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">要创建一个新命令，上述函数需要上下文、命令名和实现该命令的函数的函数指针，它必须具有以下原型:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="e5dd" class="ls lt it ob b gy of og l oh oi">int mycommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);</span></pre><p id="b2b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，实现该命令的函数将是<code class="fe oj ok ol ob b">ListExtendFilter_RedisCommand()</code>，如下面的代码片段所示:</p><figure class="nw nx ny nz gt ju"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="1140" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的参数只是上下文，将传递给所有其他API调用、命令参数向量和用户传递的参数总数。参数作为指向特定数据类型<code class="fe oj ok ol ob b">RedisModuleString</code>的指针(**argv)提供。这是一个不透明的数据类型，你有API函数来访问和使用，直接访问它的字段是不需要的。</p><h2 id="0cc1" class="ls lt it bd kf lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">2.1.3.1描述命令逻辑</h2><p id="81aa" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在函数内部，我们首先检查命令参数的数量是否正确。由于该命令需要四个参数(source_list、destination_list、low_value、high_value ),包括命令本身，因此命令参数的数量应为5。</p><p id="f32d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们要求Redis自动管理命令处理程序中的资源和内存，只需调用<strong class="ki iu">Redis module _ auto memory</strong>(CTX)。</p><p id="65c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们通过使用低级API <strong class="ki iu"> RedisModule_OpenKey </strong>()，开始访问Redis键source_list，一个Redis列表。这个API返回一个指向RedisModuleKey的指针，它是Redis键的处理程序。</p><p id="8ffe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过使用<strong class="ki iu"> RedisModule_KeyType </strong>()来检查键类型，以确保输入是列表或空的。现在我们知道我们有一个列表或空列表，我们使用<strong class="ki iu"> RedisModule_ValueLength </strong>()检查元素的数量。如果键指针为空，由于类型为空，<strong class="ki iu">RedisMoudule _ value length()</strong>返回零，这正是我们的函数逻辑所需要的。如果有零个元素，我们通过<strong class="ki iu">redis module _ ReplyWithLongLong()</strong>向客户端发送一个0的整数回复来结束函数调用。</p><p id="af71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们检查是否正确设置了限制，可能的值是参数lower_limit ( argv[3])的一个<strong class="ki iu">整数</strong> <strong class="ki iu">或</strong> <strong class="ki iu"> -inf </strong>，以及参数lower_limit ( argv[4])的一个<strong class="ki iu">整数或+inf </strong>。由于我们使用了long long limit常量(LONG_MIN和LONG_MAX ),我们还需要包含&lt; limits.h &gt;头文件。</p><p id="06f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一步包括循环遍历<strong class="ki iu">源列表</strong>，并将每个元素的值分配给<strong class="ki iu">目的列表</strong>，如果它们都是整数并且在定义的限制内。我们通过<strong class="ki iu"> RedisModule_ListPop() </strong>从列表尾部弹出source_list中的每个元素，通过<strong class="ki iu">redismodulestringlonglong()</strong>将返回的RedisModuleString转换为长整型，检查限制条件，然后如果满足条件，将长整型转换回RedisModuleString，并通过<strong class="ki iu"> RedisModule_ListPush </strong>()，将其推送到<strong class="ki iu"> destination_list </strong>的头部。</p><p id="4341" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用<strong class="ki iu">Redis module _ replicate verbal</strong>(CTX)将命令传播到所有Redis副本。</p><p id="4ebc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们通过<strong class="ki iu">redis module _ replywithlong()</strong>向客户端发送一个整数回复，其中包含添加到<strong class="ki iu"> destination_list </strong>中的商品数量。<strong class="ki iu">redis module _ ReplyWithLongLong()</strong>总是返回<code class="fe oj ok ol ob b">REDISMODULE_OK</code>。</p><p id="77af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oj ok ol ob b">list_extend.c</code>的最终版本可以在GitHub的以下<a class="ae mp" href="https://github.com/filipecosta90/list_extend/blob/master/list_extend.c" rel="noopener ugc nofollow" target="_blank">链接</a>中获得。</p><h2 id="99eb" class="ls lt it bd kf lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">2.1.3.1汇编列表_ENTEXD</h2><p id="59e5" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">现在我们已经完全设置好了我们的模块，我们只需要编译它并将它加载到Redis中(如1.2节所示)。</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="0214" class="ls lt it ob b gy of og l oh oi">gcc -fPIC -shared -std=gnu99 -o list_extend.o list_extend.c</span></pre><p id="ca3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们工作命令的一个例子:</p><pre class="nw nx ny nz gt oa ob oc od aw oe bi"><span id="974e" class="ls lt it ob b gy of og l oh oi">127.0.0.1:6379&gt; MODULE LOAD /Users/filipeoliveira/redis-porto/list-extend/list_extend.o<br/>OK</span><span id="f89f" class="ls lt it ob b gy om og l oh oi">127.0.0.1:6379&gt; lpush origin 1 20 25 40 50 string1 1.1 4<br/>(integer) 8</span><span id="3c68" class="ls lt it ob b gy om og l oh oi">127.0.0.1:6379&gt; list_extend.filter origin dest -inf 10<br/>(integer) 2</span><span id="bd9d" class="ls lt it ob b gy om og l oh oi">127.0.0.1:6379&gt; lrange dest 0 -1<br/>1) "4"<br/>2) "1"</span></pre><h2 id="d0c0" class="ls lt it bd kf lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">3 —后续步骤:</h2><p id="645f" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这个基本设置让您对Redis模块的功能有了一点了解。我们鼓励您尝试构建自己的模块。如果您喜欢我们的低值和高值过滤器命令，作为一个建议，尝试对排序的集合实现它。</p><p id="34c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在以下链接中查看Redis模块API参考和官方介绍:</p><ul class=""><li id="5040" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><a class="ae mp" href="https://redis.io/topics/modules-api-ref" rel="noopener ugc nofollow" target="_blank">https://redis.io/topics/modules-api-ref</a></li><li id="6705" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae mp" href="https://redis.io/topics/modules-intro" rel="noopener ugc nofollow" target="_blank">https://redis.io/topics/modules-intro</a></li></ul></div></div>    
</body>
</html>