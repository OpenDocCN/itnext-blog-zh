<html>
<head>
<title>Dynamically Import ESM Modules From A CDN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从CDN动态导入ESM模块</h1>
<blockquote>原文：<a href="https://itnext.io/dynamically-import-esm-modules-from-a-cdn-5a6f741e2a1c?source=collection_archive---------1-----------------------#2021-09-27">https://itnext.io/dynamically-import-esm-modules-from-a-cdn-5a6f741e2a1c?source=collection_archive---------1-----------------------#2021-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c090" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Lazy从内容交付网络加载JavaScript代码，只在用户需要时提供他们需要的服务。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e05276e2be1d57dadf950b62c1d38a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hC1zkJeJsjBGN56FMa5mJA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@danborn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·波恩</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="d21f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我告诉你，现代浏览器可以在运行时从CDN本地导入一个或一组JavaScript库包，会怎么样？这难道不会带来新的可能性吗？</p><p id="76f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息。这不是假设，而是事实。如今，所有现代浏览器都可以从🥳.内容交付网络公司动态导入JavaScript模块</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="51fd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="fce9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在开发web前端应用程序时，有许多支持模块使用的库和框架。大多数应用程序和库将使用像<a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>、<a class="ae ky" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>这样的工具或者使用像<a class="ae ky" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"> esbuild </a>这样更新的捆绑器来“捆绑”它们的文件。</p><p id="ab6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了这些工具，JavaScript代码可以被分析、构建和分割成更小的块。</p><p id="02db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这种方法非常有效，但它也有不好的一面，即无论是否执行，ES模块都会被导入。</p><p id="0e8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您想使用一个很棒的库，比如<a class="ae ky" href="https://github.com/jakearchibald/idb-keyval" rel="noopener ugc nofollow" target="_blank"> idb-keyval </a>来打印存储在IndexedDB中的值，但是goal只为管理员保留该功能。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b1ae" class="ne md it na b gy nf ng l nh ni">import { get } from 'idb-keyval';<br/><br/>const print = async (admin) =&gt; {<br/>  if (!admin) {<br/>    return;<br/>  }<br/>  <br/>  console.log(await get('hello'));<br/>}</span></pre><p id="5eb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果代码是静态构建的，那么无论如何，第三方依赖都会被添加到ES模块中。结果，所有用户，不管是不是管理员，都必须下载相关的代码，即使他们从来不需要它。</p><p id="0442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是动态导入开始发挥作用的时候，它是官方TC39提案的一部分，并且已经用ECMAScript 2020标准化。</p><p id="1949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它告诉浏览器按需加载代码，并且只在需要的时候加载。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c1f5" class="ne md it na b gy nf ng l nh ni">const print = async (admin) =&gt; {<br/>  if (!admin) {<br/>    return;<br/>  }<br/><br/>  const { get } = await import('idb-keyval');<br/><br/>  console.log(await get('hello'));<br/>}</span></pre><p id="6413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在只有管理员需要下载第三方库的代码。</p><p id="3b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nj">注意:动态导入不是强制性的，你的代码都没问题。捆绑器和浏览器对你的库和应用程序的许多模块做了令人难以置信的工作。在某些情况下，这很有帮助。就像上面的例子一样，或者当大型模块需要时间来加载时。它有助于提高启动时的性能。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b4c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动态导入+ CDN …但是为什么呢？</h1><p id="8754" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设现在您正在开发一个与后端交互的应用程序。无论您是实现自己的API还是使用第三方云提供商，与您的数据交互的代码通常都可以在您的前端应用程序中找到位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/7b5d3555d65c11cae0fc645e64780e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQ5N22V_d5PVclZ7Ups0jg.png"/></div></div></figure><p id="aad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在前一章中所看到的，如果您没有利用“动态导入”的优势，所有用户都可能因此下载代码来与后端(在模式中显示为“服务”)进行交互，不管他们是否使用它。</p><p id="b4f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这可能通常不是问题——毕竟，如果应用程序使用API，所有用户都有很大机会使用它——但随着时间的推移，它可能会成为一个问题，因为这样的设计会受到供应商的限制。</p><p id="e94e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一天，你可能不得不将应用程序迁移到一个新的后端或另一个云提供商，升级的复杂性可能会成为一个问题。</p><p id="4ada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这样的问题，你可以提取库的“服务”,给你更多的灵活性来预见陷阱。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/6227608013b6ffeec891b1d197c10f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zppU1zdm2fm1va-X3WRWxw.png"/></div></div></figure><p id="130d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果没有“动态导入”，所有用户可能仍然会下载所有代码，如果您在某个时候将应用程序与“旧”和“新”服务一起发布，这将是非常不幸的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/708fb1d07c08b80098b1211ef4780847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09yQFPIiesplbZikZN2tEA.png"/></div></div></figure><p id="8c67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再想象一下，一切都在现在的位置。该应用程序利用“动态导入”，将“旧”和“新”服务提取到单独的库。</p><p id="0e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管一切都尽善尽美，但在这一点上，前端应用程序直接依赖于这些库(想想<code class="fe nn no np na b">npm i lib --save</code>)。</p><p id="13ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对服务进行任何更改，您必须重新构建和重新部署一切，这很快就会变得棘手。尤其是如果你得到的不仅仅是两项服务，而是很多项服务。</p><p id="e386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是“动态导入”和CDN的结合最终要大放异彩的地方。</p><p id="17a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种策略一起应用可以将前端应用程序从一个整体转变为一个模块化的解决方案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/3f24d45a916b06a70dfcd31f957dd842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4niQVYzosDUo96OS6jr7Q.png"/></div></div></figure><p id="ae44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个用户请求，在诸如环境配置的特定条件下，前端应用程序可以在运行时仅请求执行特定查询所需的功能、代码段。</p><p id="f031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做，不仅用户只下载执行查询所需的内容，而且应用程序也变得几乎独立于服务。修补这些甚至添加一个新的后端现在可以开发和部署没有任何变化的应用程序！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="69f3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">给我看一些代码</h1><p id="0a23" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个很长的介绍和解释，我希望你还在这里😅。几个代码往往胜过千言万语，因此以下是如何从CDN动态导入功能的方法:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="49bb" class="ne md it na b gy nf ng l nh ni">import { Component, ComponentInterface, h } from '@stencil/core';<br/><br/>@Component({<br/>  tag: 'app-home',<br/>  styleUrl: 'app-home.css',<br/>  shadow: true,<br/>})<br/>export class AppHome implements ComponentInterface {<br/><br/>  async componentDidLoad() {<br/>    const cdn = 'https://cdn.jsdelivr.net/npm/idb-keyval@6/+es';<br/><br/>    const {get, set} = await import(cdn);<br/><br/>    await set('hello', 'world');<br/>    console.log(await get('hello'));<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;mark&gt;dynamic import esm + cdn = ❤️&lt;/mark&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="db82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码出现在一个<a class="ae ky" href="https://stenciljs.com/" rel="noopener ugc nofollow" target="_blank">模板</a> web组件中，以强调它可以在任何现代浏览器中工作的事实。</p><p id="66c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当组件被挂载时，它会创建一个<code class="fe nn no np na b">string</code>变量，指向需要加载的es模块。</p><p id="d670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种临时的<code class="fe nn no np na b">string</code>值对TypeScript很有用。没有它，编译器会抛出一个错误<code class="fe nn no np na b">TS2307: Cannot find module 'https://...' or its corresponding type declarations.</code></p><p id="29da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CDN上库的URL可用于动态导入我们感兴趣的功能，<code class="fe nn no np na b">await import(cdn)</code>，瞧，这就是🥳.</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1c80" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">类型安全</h1><p id="9a3d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">动态导入是一个本机特性，因此JavaScript支持开箱即用。为了改进TypeScript的语法，我建议使用消费者(前端应用程序)和库(“服务”)可以共享的接口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/4367c605e1689a85d70fef5071bf13f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*ZP2hO1-pD2NH0vLPqDvfJg.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="db49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以声明一个表示“hello”的函数的<code class="fe nn no np na b">interface</code>:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="de8c" class="ne md it na b gy nf ng l nh ni">export interface SayHello {<br/>  ({name}: {name: string}): Promise&lt;string&gt;;<br/>}</span></pre><p id="8371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np na b">library</code>可以按如下方式实现:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="27bb" class="ne md it na b gy nf ng l nh ni">export const say: SayHello = <br/>               async ({name}: {name: string}): Promise&lt;string&gt; =&gt; {<br/>  return `Hello ${name}`;<br/>}</span></pre><p id="bde1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np na b">app</code>也可以使用类型来改进语法:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2a68" class="ne md it na b gy nf ng l nh ni">(async function() {<br/>  const cdn = 'https://..../index.esm.js';<br/><br/>  const {say}: {say: SayHello} = await import(cdn);<br/><br/>  await say({name: 'David'});<br/>}());</span></pre><p id="fbbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，提取接口和类型还可以简化未来的新开发。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb60" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="fe86" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种“动态导入+ CDN”的方式，对我来说不仅仅是文字。它是<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>下一个主要版本的核心架构。</p><p id="d344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的主要应用程序(来源<a class="ae ky" href="https://github.com/deckgo/deckdeckgo/tree/main/studio" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)核心是一个幻灯片的离线编辑器，它不依赖于任何API。</p><p id="f0d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它“只”使用一个库(source <a class="ae ky" href="https://github.com/deckgo/deckdeckgo/tree/main/utils/editor" rel="noopener ugc nofollow" target="_blank"> GitHub </a>),该库描述并公开了如果配置了后端就可以使用的端点接口。</p><p id="53e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们目前在生产中同时使用<a class="ae ky" href="https://firebase.google.com/products/firestore" rel="noopener ugc nofollow" target="_blank"> Google Firestore </a>(参见<a class="ae ky" href="https://github.com/deckgo/deckdeckgo/tree/main/providers/firebase" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)和<a class="ae ky" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>(参见<a class="ae ky" href="https://github.com/deckgo/deckdeckgo/tree/main/providers/api" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)，因此有两个服务在运行时通过CDN动态导入，以执行这些云提供商的操作。</p><p id="b55a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与此同时，我们还开发了一个(成功的)概念验证，将我们的web应用程序移植到<a class="ae ky" href="https://dfinity.org/" rel="noopener ugc nofollow" target="_blank"> DFINITY </a>的互联网计算机上，我们将继续朝着这个方向努力，因为，剧透一下，这是未来。这就是另一个服务与区块链网络交互的原因(参见<a class="ae ky" href="https://github.com/deckgo/deckdeckgo/tree/main/providers/ic" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)。</p><p id="6b81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，由于模块化架构，如果一些客户希望在内部使用我们的编辑器，我们可以快速将它集成到任何网络中。</p><p id="21cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结:我们是面向未来的🚀。</p><p id="fd3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到无限和更远的地方！</p><p id="595c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="85e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以通过<a class="ae ky" href="https://twitter.com/daviddalbusco" rel="noopener ugc nofollow" target="_blank">推特</a>或者我的<a class="ae ky" href="https://daviddalbusco.com/" rel="noopener ugc nofollow" target="_blank">网站</a>联系我。</p><p id="b0dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的幻灯片中，请尝试使用<a class="ae ky" href="https://deckdeckgo.com/" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://deckdeckgo.com"><div class="gh gi ns"><img src="../Images/d4d889bbd4f2544ca83ec9d5b9273a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yK-FB4pxtdmZYGgY.png"/></div></a></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fcfc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资助计划</h1><p id="1f9b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们非常幸运地被DFINITY <a class="ae ky" href="https://dfinity.org/grants/#utm_source=home&amp;utm_medium=banner&amp;utm_campaign=grants" rel="noopener ugc nofollow" target="_blank">开发者资助计划</a>选中，以支持开发者生态系统，奖励团队在互联网计算机上构建dapps、工具和基础设施。</p><p id="3d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有一个很棒的项目，你一定要申请，这一点我怎么强调都不为过。到目前为止，这是一次不亚于惊人的经历，只是给人一种参与超前事物的感觉。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的所有图形都是用<a class="ae ky" href="https://excalidraw.com/" rel="noopener ugc nofollow" target="_blank"> Excalidraw </a>开发的，多么巧妙的绘图工具。</p></div></div>    
</body>
</html>