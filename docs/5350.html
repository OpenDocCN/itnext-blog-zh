<html>
<head>
<title>The ins and outs of Angular-*ngFor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular-*ngFor的来龙去脉</h1>
<blockquote>原文：<a href="https://itnext.io/the-ins-and-outs-of-angular-ngfor-88fece4b319c?source=collection_archive---------3-----------------------#2021-02-14">https://itnext.io/the-ins-and-outs-of-angular-ngfor-88fece4b319c?source=collection_archive---------3-----------------------#2021-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="21b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎阅读我的第二篇文章“Angular的来龙去脉”,在这篇文章中，我深入研究了Angular的代码库，了解并展示了Angular在幕后为我们做了什么，让Angular变得如此伟大。今天的主题是*ngFor，这是最常用的指令之一。</p><p id="ed19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">角度定义:"<em class="kl">为集合中的每一项呈现模板的[结构指令]。该指令放在一个元素上，该元素成为克隆模板的父级。<br/>简单地说，这些指令接受一个任意数组(对象、数字，甚至空值),并为每次迭代提供模板。如果我们给定一个包含5个元素的数组(array . length = = = 5 ), ngFor指令将呈现5个HTML元素，它们的父元素是ng-container。</em></p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="a36c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对ngfore的深入研究从setter开始，它是NgForOf的一个输入(ngfore是一个简写，在编译中变成NgForOf)。它接收ngi changeable类型的数据，这意味着它可以接收任何可迭代的对象(记住，数组是一种独特的对象类型)。<br/>这种唯一可迭代的一个例子是<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList" rel="noopener ugc nofollow" target="_blank">节点列表</a></p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/dc1646d20c94068283f89fb7f3d6d6f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owHafO8qyJC51Fh60A9PTA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">ngFor的入口点</figcaption></figure><p id="9358" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Angular利用自己生命周期的优势来更新DOM。它使用“ngDoCheck ”,这是另一个(但很少见的)生命周期事件。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi lk"><img src="../Images/09509337d56c5405a9132fbd087b184c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9SbGWRg9ZkdGo1cUW1-yQ.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">ngFor的ngDoCheck生命周期函数</figcaption></figure><p id="3f47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DoCheck是一个为指令创建的生命周期类，它的工作是通知指令发生了一个变更检测事件(这是所有事件中最神奇的)。当调用ngDoCheck时，它检查:<br/> 1。有一个要迭代的值。<br/> 2。检查与之前的状态是否有所不同(减少不必要的DOM操作。<br/> 3。从先前的数据对象获取更新的数据对象的变化。</p><p id="6437" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果前面列表中的所有复选框都为真，它将最终调用_ applyChanages函数，该函数接收可迭代数据的差异，并开始更新DOM。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ll"><img src="../Images/ed22d7789048a7b9d140feca76c10631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgDF4gC_k88OCGGJSXXNQw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">迭代修改并更新DOM</figcaption></figure><p id="f4a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在_applyChanges中，它将迭代每个更改。每次迭代将有3个参数注入其中。<br/> 1。记录:将成为DOM的数据将被呈现/重新呈现。<br/> 2。previous index:DOM容器中的前一个索引(如果是新的，可以为空)。<br/> 3。current index:DOM容器中的当前索引(如果移除，可以为空)。<br/>function _ apply changes相当复杂，所以我将使用一个图表来解释流程。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi lm"><img src="../Images/137dfe1e8ae94b022783bfd58d82fd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPL5MwSt32Ugc_6mYPDOWw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">ngFor如何在DOM中构建项目列表</figcaption></figure><p id="68c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们构建了包含DOM中所有条目的Tupel列表之后，我们需要将数据插入其中。为此，我们迭代Tupel中的条目列表，并将数据插入每一行的上下文中。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ln"><img src="../Images/7feee875d304c51cf35d20f6de0a75d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVNvGsktV6Ui_mH5QW--Kg.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">将索引的数据添加到该迭代的隐式中，但不将其放入DOM中</figcaption></figure><p id="e752" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一个迭代要完成，就是最终将or数据嵌入到DOM中。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi lo"><img src="../Images/6f1d299857c010ee61af543166564856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3wv3uFTjeX82MbfU4LUFg.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">将更新后的数据逐个呈现到DOM中</figcaption></figure><p id="0328" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我们所做的迭代次数来看，性能似乎应该很差，我们对许多不同形式的数据进行了多次迭代。Angular做了很多工作来保护我们的代码和它本身免受不良实践的影响。这是有代价的，但是在非常大的列表中有两个解决方案。第一种方法是使用一个带有角度/CDK的虚拟滚动条(<a class="ae kt" href="https://material.angular.io/cdk/scrolling/overview" rel="noopener ugc nofollow" target="_blank">链接</a>)。或者使用提供的“<em class="kl">跟踪”选项。</em></p><p id="82c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TrackBy是一个函数，它获取每个项目及其索引，并创建一个哈希映射，以使跟踪算法更好地满足您的应用程序/网络应用程序需求<br/>track by的一个示例:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi lp"><img src="../Images/eaea801a66c6184826888c3b41c52a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wigXcpw81mCJUXQwGvx9WA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">跟踪比的例子</figcaption></figure><p id="dbbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结:</p><p id="9a07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NgFor是一个复杂的指令，它首先考虑的是用户体验，而不是每次都从头开始渲染，多次迭代相同的数组，所有这些都是为了保护我们的UI不被破坏，并为我们的用户提供更无缝的体验。<br/>ngFor lot使用独特的类来给它一个更“干净”的代码视图，其中许多“硬”工作都是在这些类中完成的(IterableDiffers，IterableChangeRecord <em class="kl">，</em> NgForOfContext <em class="kl">)。代码看起来非常光滑小巧，但是我觉得我们都知道，这通常意味着隐藏在引擎盖下的东西更多。</em></p><p id="82a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">在这篇关于ngFor如何工作的文章中，我将尽可能地深入。希望这是有帮助的，并随时评论联系</em></p></div></div>    
</body>
</html>