<html>
<head>
<title>How to Make Form Submissions Secure on an API Website</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在API网站上安全提交表单</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-make-form-submissions-secure-on-an-api-website-d80bcfdb5149?source=collection_archive---------1-----------------------#2018-10-16">https://itnext.io/how-to-make-form-submissions-secure-on-an-api-website-d80bcfdb5149?source=collection_archive---------1-----------------------#2018-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/64ce2ea8f9ffb316c040ccc89016f3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPFK3k7O7K9Yw3VDsh7ljg@2x.png"/></div></div></figure><p id="881e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个Vue.js网站上实现表单？拥有一个只读网站是小菜一碟。使用headless CMS易于开发，易于维护，完全不用担心安全性。但是，如果你想在你的网站上有一个联系方式呢？你打算把提交的表格存放在哪里？你将如何保护它免受机器人和其他形式的误用？</p><p id="e80f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们开始讨论表单和处理人们提交的数据时，我们需要处理三个重要部分:</p><ol class=""><li id="682f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">表单定义</strong> <br/>我们要显示哪些字段，以什么顺序显示</li><li id="7589" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">表单提交存储</strong> <br/>我们将提交的表单数据存储在哪里</li><li id="5d98" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">表单安全性 <br/>我们如何保护表单免受机器人和邪恶的人的攻击</li></ol><p id="379c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从网站访问者处收集数据时，您可能需要遵守GDPR。如果是这种情况，确保收集访问者对处理数据的同意，并将数据存储在GDPR合规服务中。</p><p id="417c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将展示我的个人网站上的所有步骤，就像之前的文章一样。</p><h1 id="8e26" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">表单定义</h1><p id="ceed" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">当你决定要在你的网站上有一个表单——用户输入的方法——时，你可能已经知道你想从网站访问者那里得到什么样的数据。在大多数情况下，这是一个简单的联系形式。列出您想要收集数据的字段是有益的。在我的例子中，这个列表是这样的:</p><ul class=""><li id="6e77" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv mo lc ld le bi translated">名字</li><li id="3d72" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv mo lc ld le bi translated">电子邮件</li><li id="9bb8" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv mo lc ld le bi translated">消息</li></ul><p id="0e6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不想用太多的字段淹没访问者，因为那会降低他们实际提交消息的概率。因此，表单非常简单，但所有字段都是必填的。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/7b980d5a376be50d26237234136161f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWs-ipMteJ-FO4EOTEqm5g.png"/></div></div></figure><h1 id="9e93" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">表单提交存储</h1><p id="7604" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">好了，表单已经定义好了，包含了所有的字段，但是动作URL是什么呢？表单的目标是什么？</p><p id="dd37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是乐趣的开始！我们将使用外部服务来存储提交的表单中的所有数据。到目前为止，我们已经使用<a class="ae lk" href="http://bit.ly/2QzUALM" rel="noopener ugc nofollow" target="_blank">headless CMS Kentico Cloud</a>作为外部服务，为我们的网站提供内容。然而，headless CMS不是为存储表单提交而设计的。它的目的是维护内容并将其交付给各种渠道，在我们的例子中是一个网站。表单提交总是包含私有数据，这些数据永远不会在网站上发布。</p><p id="45f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们需要选择一个专为此任务设计的服务。我偶然发现了几个能做到这一点的服务:</p><ul class=""><li id="a54f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv mo lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2Opl3ht" rel="noopener ugc nofollow" target="_blank">表格io </a></li><li id="b442" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv mo lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2IPr3Km" rel="noopener ugc nofollow" target="_blank">Formstack.com</a></li><li id="9b14" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv mo lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2AfZ0Bh" rel="noopener ugc nofollow" target="_blank">Formkeep.com</a></li></ul><p id="71b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你做更多的研究，你很可能会找到其他人。我选择Form.io有一个特别的原因——每月1000次提交是免费的。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/502b86f4e4fc8e0d868fc7988f7fb749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQ4xX5kMdNtMJCzUI6Ba_A.png"/></div></div></figure><p id="6fd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">快速注册后，管理界面允许您创建表单定义。这定义了存储提交数据的字段。在我的情况下，我只是按照我之前编写的列表，并为名称，电子邮件和消息定义字段。</p><p id="ee2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简化向该表单提交数据的整个过程，请切换到Access选项卡，并通过API启用匿名访问。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/3fd6cb756d94bccc24b2bdd17420af4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5PryjdRor5vfYVS6scteGA.png"/></div></div></figure><p id="cd97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">匿名API访问听起来有点不安全，对吧？为了将数据发布到Form.io表单，即使是匿名发布，也需要知道API路径。因此，只要您对API路径保密，您就没有什么可担心的。我将在后面解释为什么匿名访问在这里更容易。</p><h1 id="4b65" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">表单安全性</h1><p id="c542" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">表单被定义，表单提交存储被选择，让我们把它们放在一起！</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/89f0bdae9287ad3e37caaa777fe54ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2W_eMVwQ6yR3HaTIpFhziw@2x.png"/></div></div></figure><p id="1cbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，还没有。可以将我前面介绍的联系人表单与Form.io表单直接连接起来，但是这将使它非常脆弱。</p><p id="a447" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么？任何人都可以无限期地重复张贴联系表单。这将对网站的可用性产生负面影响。此外，Form.io的免费计划只包括一定数量的API调用，这些调用很快就会被超过。你能想象把垃圾邮件和真实邮件分开会是一场噩梦吗？</p><p id="0fa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们需要保护表单。过去我一直使用谷歌的reCaptcha控件。我相信你已经在很多网站上看到了它的作用。你勾选一个方框，等一会儿，你就可以提交表格了。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/fe27ce378db1157938bcfaac782ab8f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LQU-lEQgez_ft9JEBNp9Q.png"/></div></div></figure><p id="f3a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我们也需要在服务器上验证这个过程。否则，任何提交表单的人都可以重复向表单端点发出的HTTP请求，而不管您是否有reCaptcha。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4fd1d2a46aaa602f7ac460d076b05533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVVX3NnSvCGVyg7RLgmcaw@2x.png"/></div></div></figure><p id="ba8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了进行这种验证，您需要一个允许您处理一点代码的服务。我决定使用免费的Webtask.io。但是你也可以轻松地利用Azure函数(查看这篇由<a class="ae lk" href="http://bit.ly/2CdjrQR" rel="noopener ugc nofollow" target="_blank">布莱恩·索尔蒂斯</a>撰写的<a class="ae lk" href="http://bit.ly/2Pw8q0y" rel="noopener ugc nofollow" target="_blank">关于Azure函数</a>的伟大文章)。</p><p id="205b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Webtask.io上的服务器功能将检查提交是否包含所有必填字段的数据，还将验证提交的reCaptcha代码。如果有任何问题，它将通过适当的消息进行响应。否则它会直接将数据发送到Form.io API。</p><h1 id="62b8" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">让我们开始吧</h1><p id="9d4b" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">最后一个模式看起来工作量很大吗？这就是微服务架构的美妙之处。它看起来可能很复杂，但是当你看到实际的代码时，它非常简短、清晰、易于理解。把这些放在一起只花了我几个小时，包括所有的注册和弄清楚API的细节，因为我以前没有使用Webtask.io或Form.io的经验。</p><h1 id="36fb" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">谷歌reCaptcha</h1><p id="aef3" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">首先让我们将reCaptcha添加到网站上。在<a class="ae lk" href="http://bit.ly/2yzhkDl" rel="noopener ugc nofollow" target="_blank"> Google reCaptcha </a>上注册应用程序后，有一个JavaScript文件需要包含在HTML头中:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="6b20" class="nb lm iq mx b gy nc nd l ne nf">...<br/>&lt;script src='https://www.google.com/recaptcha/api.js?onload=recaptchaLoaded'&gt;&lt;/script&gt;<br/>...</span></pre><p id="2506" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我添加了带有<code class="fe ng nh ni mx b">recaptchaLoaded</code>值的属性<code class="fe ng nh ni mx b">onload</code>。ReCaptcha在使用之前需要初始化，这个属性确保一旦初始化，它将调用方法<code class="fe ng nh ni mx b">recaptchaLoaded</code>。当然，这个方法是需要实现的。我把它添加到了<code class="fe ng nh ni mx b">app.js</code>文件的底部:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="d12a" class="nb lm iq mx b gy nc nd l ne nf">...<br/>var recaptchaLoaded = function(){<br/> bus.$emit('recaptchaLoaded');<br/>}<br/>...</span></pre><p id="cebb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你注意到<code class="fe ng nh ni mx b">bus</code>这个变量了吗？干得好！整个表单是一个Vue.js组件，因此它处理自身的所有功能。这包括数据提交、表单呈现等等。因此，我们需要告诉组件reCaptcha已经初始化，表单可以提交了。简单的方法是使用Vue.js中的事件。我们只需要为此创建一个Vue.js的专用实例。我把它加到了<code class="fe ng nh ni mx b">components.js</code>文件的开头，因为它是第一个。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="b2ca" class="nb lm iq mx b gy nc nd l ne nf">var bus = new Vue();<br/>...</span></pre><h1 id="380d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Vue.js实现</h1><p id="4864" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在让我们呆在<code class="fe ng nh ni mx b">components.js</code>文件中，看看表单组件的实现。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="09f2" class="nb lm iq mx b gy nc nd l ne nf">...<br/>data: function(){<br/> return {<br/>  name: null,<br/>  email: null,<br/>  message: null,<br/>  errors: [],<br/>  formGood: false,<br/>  disabled: true,<br/>  sending: false<br/> }<br/>},<br/>...</span></pre><p id="aed4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ng nh ni mx b">data</code>函数现在包含了几个新的属性。每个表单字段(<code class="fe ng nh ni mx b">name</code>、<code class="fe ng nh ni mx b">email</code>、<code class="fe ng nh ni mx b">message</code>)、错误消息数组(<code class="fe ng nh ni mx b">errors</code>)和三个状态字段(<code class="fe ng nh ni mx b">formGood</code>、<code class="fe ng nh ni mx b">disabled</code>、<code class="fe ng nh ni mx b">sending</code>)都有一个属性。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="b6b1" class="nb lm iq mx b gy nc nd l ne nf">...<br/>template: `<br/> &lt;form&gt;<br/>  &lt;div class="fields" v-if="!formGood"&gt;<br/>  …<br/>  &lt;input type="text" v-model="name" id="name" required /&gt;<br/>  …<br/>  &lt;input type="email" v-model="email" id="email" required /&gt;<br/>  …<br/>  &lt;textarea v-model="message" id="message" rows="4"&gt;&lt;/textarea&gt;<br/>  …<br/>  &lt;div class="g-recaptcha" data-sitekey="{your-site-key}"&gt;&lt;/div&gt;<br/>  …<br/>  &lt;div class="field" v-if="errors.length"&gt;<br/>  …<br/>  &lt;li v-for="error in errors"&gt;{{error}}&lt;/li&gt;<br/>  …<br/>  &lt;ul class="actions" v-if="!formGood"&gt;<br/>   &lt;li&gt;&lt;input type="submit" value="Send Message" @click.prevent="submitForm" :disabled="disabled" /&gt;&lt;/li&gt;<br/>  &lt;/ul&gt;<br/>  &lt;div v-if="formGood"&gt;<br/>   &lt;h3&gt;Thank you!&lt;/h3&gt;<br/>   &lt;p&gt;Your message was submitted. I will get back to you as soon as I can.&lt;br /&gt;Ondrej&lt;/p&gt;<br/>  &lt;/div&gt;<br/>  …<br/>  &lt;div v-if="sending" class="form-overlay"&gt;&lt;i class="fa fa-circle-o-notch fa-spin"&gt;&lt;/i&gt;&lt;/div&gt;<br/> &lt;/form&gt;<br/>`,<br/>...</span></pre><p id="3404" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe ng nh ni mx b">v-model</code>属性将表单字段的属性绑定到各自的输入。状态属性<code class="fe ng nh ni mx b">formGood</code>将确保在表单成功提交时显示<em class="nj">感谢</em>消息。在处理表单提交时，属性<code class="fe ng nh ni mx b">sending</code>将在表单上方呈现一个简单的覆盖图。最后，<code class="fe ng nh ni mx b">disabled</code>属性将确保表单在reCaptcha初始化之前不会被提交。还记得<code class="fe ng nh ni mx b">recaptchaLoaded</code>功能吗？当reCaptcha初始化时发出事件<code class="fe ng nh ni mx b">recaptchaLoaded</code>的那个。表单组件的<code class="fe ng nh ni mx b">created</code>函数将监听这个事件。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="9655" class="nb lm iq mx b gy nc nd l ne nf">...<br/>created: function(){<br/> bus.$on('recaptchaLoaded', this.enable);<br/>},<br/>...</span></pre><p id="b4d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建表单组件时执行<code class="fe ng nh ni mx b">created</code>功能。这在reCaptcha初始化之前很久就发生了，所以当这种情况发生时，form已经在等待事件，并随后调用<code class="fe ng nh ni mx b">enable</code>方法，该方法又通过<code class="fe ng nh ni mx b">disabled</code>属性启用提交按钮。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="0205" class="nb lm iq mx b gy nc nd l ne nf">...<br/>methods: {<br/> enable(){<br/>  this.$data.disabled = false;<br/> },<br/> submitForm(){<br/>  this.sending = true;<br/>  this.errors = [];<br/>  this.formGood = false;<br/>  fetch({webtask.io/your-function-endpoint}, {<br/>   body: JSON.stringify({<br/>    name: this.$data.name,<br/>    email: this.$data.email,<br/>    message: this.$data.message,<br/>    recaptcha: grecaptcha.getResponse()<br/>   }),<br/>   headers: { 'content-type':'application/json' },<br/>   method: 'POST'<br/>  })<br/>  .then(res =&gt; res.json())<br/>  .then(res =&gt; {<br/>   if (res.status){<br/>    this.$data.formGood = true;<br/>   } else {<br/>    grecaptcha.reset();<br/>    this.$data.errors = res.errors;<br/>   }<br/>   this.$data.sending = false;<br/>  });<br/> }<br/>}<br/>...</span></pre><p id="3b2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面重点介绍一下<code class="fe ng nh ni mx b">submitForm</code>的方法。我正在使用<code class="fe ng nh ni mx b">fetch</code>从Webtask.io函数中获取一个带有响应的Promise对象。在此类请求的正文中，您可以找到JSON格式的联系人表单中的所有字段。注意，reCaptcha代码需要使用<code class="fe ng nh ni mx b">getResponse()</code>方法直接从表示reCaptcha的JavaScript对象中获得。</p><p id="0c18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对提交请求的响应也是JSON格式。在解析它并检查状态之后，有两种可能性。提交成功并且表单数据被转发到Form.io，或者存在一些问题。在这种情况下，错误被复制到本地数据集中，并通过Vue.js显示给访问者。</p><p id="992c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在提交处理结束时，我们可以重置<code class="fe ng nh ni mx b">sending</code>标志，以便覆盖图再次隐藏。</p><h1 id="eaeb" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Webtask.io函数</h1><p id="4dd3" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我几次提到Webtask.io函数，但是实现是什么样子的呢？基本上有两个任务需要解决:</p><ol class=""><li id="a9eb" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">验证所有必填字段</li><li id="91a6" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">验证reCaptcha</li></ol><p id="6e2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是函数的基本实现:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="d25c" class="nb lm iq mx b gy nc nd l ne nf">'use strict';<br/>const request = require('request');<br/>module.exports = (context, cb) =&gt; {<br/> // gather the form fields from body<br/> let form = context.body;<br/> checkForm(context.body, context.secrets.recaptcha)<br/>  .then(result =&gt; {<br/>   if (result.errors.length){<br/>    cb(null, {status: false, errors: result.errors});<br/>   }else{<br/>    // here we will store data in Form.io<br/>    sendToFormIo(context.body)<br/>     .then(result =&gt; {<br/>      if (result.errors.length){<br/>       cb(null, {status: false, errors: result.errors});<br/>      }else{<br/>       cb(null, {status: true});<br/>      }<br/>     });<br/>   }<br/> });<br/>}<br/>...</span></pre><p id="b217" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">包含JSON中表单字段数据的主体在<code class="fe ng nh ni mx b">context.body</code>属性中可用。在函数<code class="fe ng nh ni mx b">checkForm</code> <em class="nj"> </em>中，我们检查表单的必填字段并验证reCaptcha。如果请求有效，使用<code class="fe ng nh ni mx b">sendToFormIo</code>函数将数据提交给Form.io，否则我们用错误消息和状态进行响应。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="8423" class="nb lm iq mx b gy nc nd l ne nf">...<br/>function checkForm(f, recaptchaKey){<br/> return new Promise((resolve) =&gt; {<br/>  let errors = [];<br/>  if (!f.name || f.name.trim() === '')<br/>   errors.push("Please fill in your name.");<br/>  if (!f.email || f.email.trim() === '')<br/>   errors.push("Please fill in your email address.");<br/>  if (!f.message || f.message.trim() === '')<br/>   errors.push("Please fill in your message.");<br/>  <br/>  request.post('https://www.google.com/recaptcha/api/siteverify', {<br/>   form: {<br/>    secret: recaptchaKey,<br/>    response: f.recaptcha<br/>   }<br/>  }, (err, resp, body) =&gt; {<br/>   if (!JSON.parse(body).success){<br/>    errors.push('Please complete captcha validation.');<br/>   }<br/>   resolve({errors: errors});<br/>  });<br/> });<br/>}<br/>...</span></pre><p id="89fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ng nh ni mx b">checkForm</code> <em class="nj"> </em>函数中，看看如何验证reCaptcha代码。需要有一个对Google API的POST请求，作为回报，Google用验证结果进行响应。请注意，为了验证reCaptcha代码，您需要提供reCaptcha API密钥。我把它作为秘密变量存储在Webtask.io secrets中:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/2e5774fcb3b6115c876b7f66df38bdf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfae5cDO2wIvZpe_LCR60g.png"/></div></div></figure><p id="c586" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你用同样的方法，你可以在函数的实现中使用<code class="fe ng nh ni mx b">context.secrets.recaptcha</code>来引用这个值。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="23dd" class="nb lm iq mx b gy nc nd l ne nf">...<br/>function sendToFormIo(f){<br/> return new Promise((resolve) =&gt; {<br/>  let errors = [];<br/>  request.post('{your-form.io-api-path}/{form.io-form-name}/submission', {<br/>   body: {<br/>    data: {<br/>     name: f.name,<br/>     email: f.email,<br/>     message: f.message<br/>    }<br/>   },<br/>   json: true<br/>  }, (err, resp, body) =&gt;<br/>  {<br/>   if (resp.statusCode !== 201){<br/>    console.log(resp);<br/>    errors.push('Your submission could not be saved. Please try again later.');<br/>   }<br/>   resolve({errors: errors});<br/>  });<br/> });<br/>}</span></pre><p id="b7e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Webtask.io函数的最后一部分，您可以看到我基本上是在将相同的消息转发给Form.io API。还记得我建议您在Form.io表单上启用的匿名访问吗？这使我能够将消息直接发布到Form.io API。否则，我必须调整函数的实现，首先在认证请求中获取<code class="fe ng nh ni mx b">jwt-token</code>,然后在另一个认证请求中发送表单数据。因为Webtask.io和Form.io之间的通信是私有的，API路径是保密的，所以这里不需要担心认证的问题。</p><p id="df6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，在响应处理逻辑附近有一个<code class="fe ng nh ni mx b">console.log(resp)</code>。如果出现问题，并且由于服务之间的通信失败而导致请求无法处理，则使用<code class="fe ng nh ni mx b">console.log</code>将带有错误代码和描述的实际响应存储在日志中，稍后可以在Webtask.io管理界面中进行调查。</p><p id="8cda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一部分中，我从Raymond Camden在他的博客<a class="ae lk" href="http://bit.ly/2yDZcbo" rel="noopener ugc nofollow" target="_blank">上发表的</a><a class="ae lk" href="http://bit.ly/2PHoRXS" rel="noopener ugc nofollow" target="_blank">伟大文章</a>中获得了实现的灵感。</p><h1 id="93ba" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="e6ef" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">一旦你全部实现了，就开始试运行吧。首次成功提交表单后，您将在data选项卡下的Form.io表单中看到表单数据。</p><p id="bd12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将会看到，将服务连接在一起并创建一个以安全方式运行和处理敏感数据的网站是很容易的。你不需要照看任何运行在昂贵的主机方案上的大型解决方案，或者更糟，在租用的虚拟服务器上。</p><p id="7f57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我的网站目前使用以下服务:</p><ul class=""><li id="1586" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv mo lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2QzUALM" rel="noopener ugc nofollow" target="_blank">无头API CMS Kentico Cloud </a>(免费)</li><li id="a27a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv mo lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2yCjNgl" rel="noopener ugc nofollow" target="_blank"> Webtask.io函数</a>(免费)</li><li id="c9b8" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv mo lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2Opl3ht" rel="noopener ugc nofollow" target="_blank">表单. io表单带AP </a> I(自由)</li><li id="f66d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv mo lc ld le bi translated">少量静态文件的托管空间(在我的例子中是4.2美元/年)</li></ul><p id="cc7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很酷，对吧？您对软件即服务服务有什么体验？你用了吗？你会选择和我不同的吗？留下评论。</p><p id="38c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的下一篇文章中，我将关注安全性、SEO、性能和其他更高级的特性。</p><h2 id="a716" class="nb lm iq bd ln nl nm dn lr nn no dp lv kj np nq lz kn nr ns md kr nt nu mh nv bi translated">该系列的其他文章:</h2><ol class=""><li id="5a27" class="kw kx iq ka b kb mj kf mk kj nw kn nx kr ny kv lb lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2Duglu1" rel="noopener ugc nofollow" target="_blank">第一次如何开始创建一个令人印象深刻的网站</a></li><li id="fc53" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">如何为你的网站决定最好的技术？</li><li id="fb09" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2zLRE8a" rel="noopener ugc nofollow" target="_blank">如何用Vue.js和最少的努力启动你的网站</a></li><li id="0654" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2CyDnhX" rel="noopener ugc nofollow" target="_blank">如何把无头CMS和一个Vue.js网站混在一起，零付费</a></li><li id="4260" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">如何在API网站上安全提交表单</strong></li><li id="723d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">用CMS建立一个超级快速安全的网站没什么大不了的。或者是？</li><li id="ab9c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2PN46Jy" rel="noopener ugc nofollow" target="_blank">如何用Vue.js快速生成静态网站</a></li><li id="384f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="http://bit.ly/2Dv2UGS" rel="noopener ugc nofollow" target="_blank">如何快速建立静态站点的构建流程</a></li></ol></div></div>    
</body>
</html>