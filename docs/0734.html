<html>
<head>
<title>Storing Go Structs in Redis using ReJSON</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ReJSON在Redis中存储Go结构</h1>
<blockquote>原文：<a href="https://itnext.io/storing-go-structs-in-redis-using-rejson-dab7f8fc0053?source=collection_archive---------1-----------------------#2018-05-17">https://itnext.io/storing-go-structs-in-redis-using-rejson-dab7f8fc0053?source=collection_archive---------1-----------------------#2018-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/3d6f0ec554f7988d7ec05befa5ca5c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*w3hPEpsPFtHs36dJMUdl7w.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图片提供:<a class="ae jy" href="https://redislabs.com/blog/redis-go-designed-improve-performance/" rel="noopener ugc nofollow" target="_blank">https://redis labs . com/blog/redis-go-designed-improve-performance/</a></figcaption></figure><p id="517e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">你们很多人可能对<a class="ae jy" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb ir"> Redis </strong> </a>很熟悉。对于外行来说，redis即使不是最流行的，也是最广泛采用的数据库/缓存之一。</p><p id="8644" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">官方文档将<a class="ae jy" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> redis </a>描述为，</p><blockquote class="kx ky kz"><p id="3f12" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ij bi translated">Redis是一个开源的(BSD许可的)、内存中的数据结构存储，用作数据库、缓存和消息代理。它支持数据结构，如字符串、哈希、列表、集合、带有范围查询的排序集合、位图、超级日志和带有radius查询的地理空间索引。Redis具有内置的复制、Lua脚本、LRU驱逐、事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster的自动分区提供高可用性。</p></blockquote><p id="2971" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">redis与其他(传统)数据库的不同之处在于它是一个<a class="ae jy" href="https://en.wikipedia.org/wiki/Key-value_database" rel="noopener ugc nofollow" target="_blank">键值</a>存储(除此之外，它位于内存中)。这意味着在这样的数据库中，所有的值都存储在一个键中(比如字典)。</p><p id="5afa" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然而，我跑题了，这个帖子不是关于redis的，所以我们继续吧！</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="c890" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用Go与Redis交互</h1><p id="df38" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">作为一名使用redis的Go开发人员，有时我们需要在redis中缓存我们的对象。让我们看看如何使用Redis中的<code class="fe mo mp mq mr b">HMSET</code>来实现这一点。</p><p id="74b5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">一个简单的go结构应该是这样的，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="2442" class="na lm iq mr b gy nb nc l nd ne">type SimpleObject struct {<br/>    FieldA string<br/>    FieldB int<br/>}</span><span id="13a1" class="na lm iq mr b gy nf nc l nd ne">simpleObject := SimpleObject{“John Doe”,24}</span></pre><p id="7c77" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">很明显，要在redis中存储对象，我们需要将它转换成一个键值对。我们通过使用Go Struct字段名作为键和根据它存储的结构值来实现这一点。</p><p id="1831" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">一个<strong class="kb ir">散列</strong>将是一个完美的候选，它将属于一个对象的所有字段绑定回对象本身。从<code class="fe mo mp mq mr b">redis-cli</code>开始，我们将执行以下操作:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="6c45" class="na lm iq mr b gy nb nc l nd ne">127.0.0.1:6379&gt; HMSET simple_object fieldA “John Doe” fieldB 24<br/>OK</span></pre><p id="b403" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">使用<code class="fe mo mp mq mr b">HGETALL</code>命令获取的结果将是，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="87cf" class="na lm iq mr b gy nb nc l nd ne">127.0.0.1:6379&gt; HGETALL simple_object<br/>fieldA<br/>John Doe<br/>fieldB<br/>24</span></pre><p id="5268" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">好了，现在我们知道了对象是如何被封送到数据库中的。让我们以编程的方式继续做这件事吧！</p><p id="ab47" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">虽然redis有相当多的go客户，但我考虑与Redigo合作。它在github上有一个很棒的社区，并且是redis最受欢迎的go-client之一，拥有超过100名4K明星。</p><h2 id="9f2c" class="na lm iq bd ln ng nh dn lr ni nj dp lv kk nk nl lz ko nm nn md ks no np mh nq bi translated">Redigo助手— AddFlat和ScanStruct</h2><p id="2142" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">Redigo配备了一组很棒的助手函数，其中一个我们将使用<code class="fe mo mp mq mr b">AddFlat</code>，在将它添加到redis之前，展平我们的结构。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="37e3" class="na lm iq mr b gy nb nc l nd ne">// Get the connection object<br/>conn, err := redis.Dial(“tcp”, “localhost:6379”)<br/>if err != nil {<br/>    return<br/>}</span><span id="55f8" class="na lm iq mr b gy nf nc l nd ne">// Invoke the command using the Do command<br/>_, err = conn.Do(“HMSET”, redis.Args{“simple_object”}.AddFlat(simpleObject)…)<br/>if err != nil {<br/>    return<br/>}</span></pre><p id="f29e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在如果你想把这个对象读回你的对象，我们可以用<code class="fe mo mp mq mr b">HGETALL</code>命令来完成，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="e7bc" class="na lm iq mr b gy nb nc l nd ne">value, err := redis.Values(conn.Do(“HGETALL”, key))<br/>if err != nil {<br/>    return<br/>}</span><span id="f319" class="na lm iq mr b gy nf nc l nd ne">object := SimpleStruct{}<br/>err = redis.ScanStruct(value, &amp;object)<br/>if err != nil {<br/>    return<br/>}</span></pre></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><blockquote class="nr"><p id="8ebc" class="ns nt iq bd nu nv nw nx ny nz oa kw dk translated">够简单了吧？让我们看看更复杂的东西…</p></blockquote><h2 id="64a7" class="na lm iq bd ln ng ob dn lr ni oc dp lv kk od nl lz ko oe nn md ks of np mh nq bi translated">Go结构中的嵌入对象</h2><p id="48b7" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">现在让我们来看一个更复杂的结构，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="c9ef" class="na lm iq mr b gy nb nc l nd ne">type Student struct {<br/>    Info *StudentDetails `json:”info,omitempty”`<br/>    Rank int `json:”rank,omitempty”`<br/>}</span><span id="bcf4" class="na lm iq mr b gy nf nc l nd ne">type StudentDetails struct {<br/>    FirstName string<br/>    LastName string<br/>    Major string<br/>}</span><span id="421f" class="na lm iq mr b gy nf nc l nd ne">studentJD := Student{<br/>    Info: &amp;StudentDetails{<br/>        FirstName: “John”,<br/>        LastName: “Doe”,<br/>        Major: “CSE”,<br/>    },<br/>    Rank: 1,<br/>}</span></pre><p id="babc" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们现在拥有的是一个<strong class="kb ir">嵌入的</strong>结构，带有<code class="fe mo mp mq mr b">StudentDetails</code>，作为<code class="fe mo mp mq mr b">Student</code>对象的成员。</p><p id="8ebe" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">让我们再次尝试使用<code class="fe mo mp mq mr b">HMSET</code>，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="cac1" class="na lm iq mr b gy nb nc l nd ne">// Invoke the command using the Do command<br/>_, err = conn.Do(“HMSET”, redis.Args{“JohnDoe”}.AddFlat(studentJD)…)<br/>if err != nil {<br/>    return<br/>}</span></pre><p id="058c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果我们现在查看redis，我们会看到info对象被存储为–</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="f34d" class="na lm iq mr b gy nb nc l nd ne">127.0.0.1:6379&gt; HGETALL JohnDoe<br/>Info<br/>&amp;{John Doe CSE}<br/>Rank<br/>1</span></pre><p id="840e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这就是问题所在。当我们试图将信息检索回对象中时，<strong class="kb ir"> ScanStruct </strong>失败，并出现<strong class="kb ir">错误</strong>，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="1e43" class="na lm iq mr b gy nb nc l nd ne"><strong class="mr ir">redigo.ScanStruct: cannot assign field Info: cannot convert from Redis bulk string to *main.StudentDetails</strong></span></pre><blockquote class="nr"><p id="d12d" class="ns nt iq bd nu nv og oh oi oj ok kw dk translated">史诗失败！</p></blockquote><p id="985a" class="pw-post-body-paragraph jz ka iq kb b kc ol ke kf kg om ki kj kk on km kn ko oo kq kr ks op ku kv kw ij bi translated">发生这种情况是因为在redis中，所有东西都被存储为一个<strong class="kb ir">字符串</strong> <em class="la">【对于较大的对象是批量字符串】。</em></p><h2 id="2953" class="na lm iq bd ln ng nh dn lr ni nj dp lv kk nk nl lz ko nm nn md ks no np mh nq bi translated">现在怎么办？</h2><p id="e7de" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">快速搜索会带你找到几个解决方案。其中一个解决方案建议使用封送拆收器(<code class="fe mo mp mq mr b">JSON</code> marshal)，其他的建议使用<code class="fe mo mp mq mr b">MessagePack</code>。</p><p id="4875" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我将在下面展示基于<code class="fe mo mp mq mr b">JSON</code>的解决方案。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="1e98" class="na lm iq mr b gy nb nc l nd ne">b, err := json.Marshal(&amp;studentJD)<br/>if err != nil {<br/>    return<br/>}</span><span id="7281" class="na lm iq mr b gy nf nc l nd ne">_, err = conn.Do(“SET”, “JohnDoe”, string(b))<br/>if err != nil {<br/>    return<br/>}</span></pre><p id="878d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">要检索它，只需使用<code class="fe mo mp mq mr b">GET</code>命令读回<code class="fe mo mp mq mr b">JSON</code>字符串</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="dbe8" class="na lm iq mr b gy nb nc l nd ne">objStr, err = redis.String(conn.Do(“GET”, “JohnDoe”))<br/>if err != nil {<br/>    return<br/>}</span><span id="d304" class="na lm iq mr b gy nf nc l nd ne">b := []byte(objStr)</span><span id="26a3" class="na lm iq mr b gy nf nc l nd ne">student := &amp;Student{}</span><span id="f4b2" class="na lm iq mr b gy nf nc l nd ne">err = json.Unmarshal(b, student)<br/>if err != nil {<br/>    return<br/>}</span></pre><p id="dc14" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果我们想要做的是<strong class="kb ir"> <em class="la">完整地缓存对象</em> </strong>，这就太棒了。</p><p id="b799" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果我们只想添加、修改或读取其中一个字段，例如，如果John Doe<strong class="kb ir"><em class="la"/></strong>将其专业从<strong class="kb ir"><em class="la">【CSE</em></strong><em class="la">更改为<strong class="kb ir"> <em class="la"> EE </em> </strong>该怎么办？？</em></p><p id="4755" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们可以做到这一点的唯一方法是读取JSON字符串，将它解封到对象中，修改对象并将其重新写入redis。看起来工作量很大！</p><blockquote class="kx ky kz"><p id="84f4" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ij bi translated"><em class="iq">如果你想知道，通过使用</em> <code class="fe mo mp mq mr b"><em class="iq">HGET</em></code> <em class="iq"> / </em> <code class="fe mo mp mq mr b"><em class="iq">HSET</em></code> <em class="iq">命令，用</em> <code class="fe mo mp mq mr b"><em class="iq">Hash</em></code> <em class="iq">做这件事很简单。要是那样就好了——</em><strong class="kb ir"><em class="iq"/></strong><em class="iq">！</em></p></blockquote><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/1e790d0b7cf4f642a7cc3a0241d44c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*ed0x40y1Y30I4NB_ahm6WQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">因为，没有模因，任何网络帖子都不可能存在…</figcaption></figure><h2 id="21ca" class="na lm iq bd ln ng nh dn lr ni nj dp lv kk nk nl lz ko nm nn md ks no np mh nq bi translated">瑞森</h2><p id="c264" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">RedisLabs的优秀团队为我们带来了一个解决方案，让我们可以像对待传统对象一样对待我们的对象。</p><p id="cd25" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">让我们直接进入主题。我直接从rejson文档中挑选了这个例子，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="1258" class="na lm iq mr b gy nb nc l nd ne">127.0.0.1:6379&gt; JSON.SET amoreinterestingexample . ‘[ true, { “answer”: 42 }, null ]’<br/>OK<br/>127.0.0.1:6379&gt; JSON.GET amoreinterestingexample<br/>“[true,{\”answer\”:42},null]”<br/>127.0.0.1:6379&gt; JSON.GET amoreinterestingexample [1].answer<br/>“42”<br/>127.0.0.1:6379&gt; JSON.DEL amoreinterestingexample [-1]<br/>1<br/>127.0.0.1:6379&gt; JSON.GET amoreinterestingexample<br/>“[true,{\”answer\”:42}]”</span></pre><p id="91dd" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">为了以编程方式做到这一点，我们肯定可以使用原始形式的<code class="fe mo mp mq mr b">Redigo</code>。[这意味着支持Redis支持的任何命令，使用<code class="fe mo mp mq mr b">conn.Do(…)</code>方法]。</p><p id="562b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然而，我花了一些时间将所有的<code class="fe mo mp mq mr b">ReJSON</code>命令转换成一个Go便利包，名为<a class="ae jy" href="https://github.com/nitishm/go-rejson" rel="noopener ugc nofollow" target="_blank"> go-rejson </a>。</p><p id="6383" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">回到我们的<code class="fe mo mp mq mr b">Student</code>对象，我们可以使用下面的步骤通过编程将其添加到Redis中。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="e437" class="na lm iq mr b gy nb nc l nd ne">import "github.com/nitishm/go-rejson"</span><span id="6c0a" class="na lm iq mr b gy nf nc l nd ne">_, err = rejson.JSONSet(conn, “JohnDoeJSON, “.”, studentJD, false, false)<br/>if err != nil {<br/>    return<br/>}</span></pre><p id="5ae7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><code class="fe mo mp mq mr b">redis-cli</code>中的快速检查给了我们，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="e1a1" class="na lm iq mr b gy nb nc l nd ne">127.0.0.1:6379&gt; JSON.GET JohnDoeJSON<br/>{“info”:{“FirstName”:”John”,”LastName”:”Doe”,”Major”:”CSE”},”rank”:1}</span></pre><p id="0a9b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果我希望只从redis条目中读取信息字段，我将执行如下的<code class="fe mo mp mq mr b">JSON.SET</code>,</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="f7fa" class="na lm iq mr b gy nb nc l nd ne">127.0.0.1:6379&gt; JSON.GET JohnDoeJSON .info<br/>{“FirstName”:”John”,”LastName”:”Doe”,”Major”:”CSE”}</span></pre><p id="c8fc" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">类似地，对于<strong class="kb ir">等级</strong>字段，我可以引用<code class="fe mo mp mq mr b">.rank</code>，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="1a43" class="na lm iq mr b gy nb nc l nd ne">127.0.0.1:6379&gt; JSON.GET JohnDoeJSON .rank<br/>1</span></pre><p id="2ccb" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">为了以编程方式检索学生对象，我们将通过<code class="fe mo mp mq mr b">JSONGet()</code>方法使用<code class="fe mo mp mq mr b">JSON.GET</code>命令，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="3074" class="na lm iq mr b gy nb nc l nd ne">v, err := rejson.JSONGet(conn, “JohnDoeJSON, “”)<br/>if err != nil {<br/>    return<br/>}</span><span id="cc3d" class="na lm iq mr b gy nf nc l nd ne">outStudent := &amp;Student{}<br/>err = json.Unmarshal(outJSON.([]byte), outStudent)<br/>if err != nil {<br/>    return<br/>}</span></pre><p id="0b8a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">为了设置<strong class="kb ir">等级</strong>字段，我们可以使用<code class="fe mo mp mq mr b">JSONSet()</code>方法对<code class="fe mo mp mq mr b">.rank</code>字段使用<code class="fe mo mp mq mr b">JSON.SET</code>命令，</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="8f52" class="na lm iq mr b gy nb nc l nd ne">_, err = rejson.JSONSet(conn, “JohnDoeJSON, “.info.Major”, “EE”, false, false)<br/>if err != nil {<br/>    return<br/>}</span></pre><p id="7db4" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">检查<code class="fe mo mp mq mr b">redis-cli</code>中的条目，我们得到:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="c3fb" class="na lm iq mr b gy nb nc l nd ne">127.0.0.1:6379&gt; JSON.GET JohnDoeJSON{“info”:{“FirstName”:”John”,”LastName”:”Doe”,”Major”:”EE”},”rank”:1}</span></pre></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="6849" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">运行此示例</h1><h2 id="0ee8" class="na lm iq bd ln ng nh dn lr ni nj dp lv kk nk nl lz ko nm nn md ks no np mh nq bi translated">使用Docker用rejson模块启动redis</h2><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="5d11" class="na lm iq mr b gy nb nc l nd ne">docker run -p 6379:6379 --name redis-rejson redislabs/rejson:latest</span></pre><h2 id="bb05" class="na lm iq bd ln ng nh dn lr ni nj dp lv kk nk nl lz ko nm nn md ks no np mh nq bi translated">从github克隆这个例子</h2><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="bbdc" class="na lm iq mr b gy nb nc l nd ne"># git clone <a class="ae jy" href="https://github.com/nitishm/rejson-struct.git" rel="noopener ugc nofollow" target="_blank">https://github.com/nitishm/rejson-struct.git</a><br/># cd rejson-struct<br/># go run main.go</span></pre></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="1eeb" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="la">要了解更多关于</em><strong class="kb ir"><em class="la">Go-ReJSON</em></strong><em class="la">包的信息，请访问</em><a class="ae jy" href="https://github.com/nitishm/go-rejson" rel="noopener ugc nofollow" target="_blank"><strong class="kb ir"><em class="la">【https://github.com/nitishm/go-rejson】</em></strong></a><em class="la">。</em></p><p id="ec7a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="la">阅读更多关于</em> <strong class="kb ir"> <em class="la">雷吉森</em> </strong> <em class="la">在他们的官方文档页面，</em><a class="ae jy" href="http://rejson.io/." rel="noopener ugc nofollow" target="_blank"><strong class="kb ir"><em class="la">http://rejson.io/</em></strong><em class="la">。</em>T55】</a></p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="e6b1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果你喜欢这篇文章并觉得它很有用，别忘了给它一个👏！！</p><p id="ba9b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果能得到一些反馈，我将不胜感激！请务必留下您的评论。</p><p id="756a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">也可以看看我之前(第一篇)的帖子——“<em class="la">在Golang构建微服务框架”在</em><a class="ae jy" href="https://medium.com/@nitishmalhotra/building-a-microservice-framework-in-golang-dd3c9530dff9" rel="noopener">https://medium . com/@ nitishmalhotra/Building-a-microservice-framework-in-Golang-dd3c 9530 dff 9</a></p></div></div>    
</body>
</html>