<html>
<head>
<title>The magic of RXJS sharing operators and their differences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RXJS共享运算符的魔力及其差异</h1>
<blockquote>原文：<a href="https://itnext.io/the-magic-of-rxjs-sharing-operators-and-their-differences-3a03d699d255?source=collection_archive---------0-----------------------#2019-02-05">https://itnext.io/the-magic-of-rxjs-sharing-operators-and-their-differences-3a03d699d255?source=collection_archive---------0-----------------------#2019-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fd94adb87a2e80a8c7641b47c256dc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_-h7Ux1K7EeDO07PE71LQ.jpeg"/></div></div></figure><p id="d55c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始讨论共享操作符之前，我们首先需要确定在RxJs中存在什么样的可观测量。通常有两种可观察的，热的和冷的。有一篇很棒的文章<a class="ae kw" href="https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339" rel="noopener">热与冷的对比</a>，但总的来说主要区别在于</p><blockquote class="kx ky kz"><p id="238b" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><strong class="ka ir"> cold </strong> observables中的通知生成者是由可观察对象自身创建的，并且只有当观察者订阅它时才会创建。</p></blockquote><p id="44e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如<code class="fe le lf lg lh b">interval()</code>创造冷可观察。在可观测范围内创建数据，并且对于每个新的订阅，将创建新的间隔</p><blockquote class="kx ky kz"><p id="5bbd" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><strong class="ka ir"> hot </strong> observables中的通知生成器是在observables之外创建的，不管是否有订户</p></blockquote><p id="1593" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如,<code class="fe le lf lg lh b">fromEvent()</code>创建热可观察对象，因为通知生产者在DOM中，并且不管订阅者的数量如何都存在。</p><p id="f585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时我们需要让冷的可观察对象表现为热的，例如对于http请求。考虑下面的Angular中的http请求示例</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="7c07" class="lq lr iq lh b gy ls lt l lu lv">ngOnInit() {<br/>   this.user$ = this.http.get(`api/user/1`)</span><span id="7a6f" class="lq lr iq lh b gy lw lt l lu lv">   this.name$ = this.user$.pipe(<br/>      map(user =&gt; user.name)<br/>   );</span><span id="0ad0" class="lq lr iq lh b gy lw lt l lu lv">   this.age$ = this.user$.pipe(<br/>      map(user =&gt; user.age)<br/>   );</span><span id="647c" class="lq lr iq lh b gy lw lt l lu lv">}</span></pre><p id="de3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用异步管道在模板中显示用户的姓名和年龄(假设在不同的地方，所以不可能将其包装在一个异步管道中)</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="61cb" class="lq lr iq lh b gy ls lt l lu lv">&lt;div&gt;{{name$ | async}}&lt;/div&gt;<br/>&lt;div&gt;{{<!-- -->age<!-- -->$ | async}}&lt;/div&gt;</span></pre><p id="7c58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在浏览器的网络选项卡中，我们将看到两个请求。原因是Angular的Http创建了cold observable，所以每个新用户都等于新请求。我们绝对不希望有几个请求。首先让我们解决这个问题，然后看看它是如何工作的。</p><p id="5012" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决这个问题其实很简单。我们需要做的就是像这样添加<code class="fe le lf lg lh b">share()</code>或<code class="fe le lf lg lh b">publish(), refCount()</code></p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="6911" class="lq lr iq lh b gy ls lt l lu lv"><em class="la">this</em>.user$ = <em class="la">this</em>.http.get(`api/user/1`).pipe(<em class="la"><br/>  </em>share()<br/>);</span><span id="7cdc" class="lq lr iq lh b gy lw lt l lu lv">//or </span><span id="6b6d" class="lq lr iq lh b gy lw lt l lu lv">this.user$ = this.http.get(`api/user/1`).pipe(<br/> publish(),<br/> refCount()<br/>);</span></pre><p id="692d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在“网络”选项卡中，我们有一个请求，因为数据在所有订户之间共享。那么<code class="fe le lf lg lh b">share()</code>或<code class="fe le lf lg lh b">publish()</code>是如何神奇地解决这个问题的？如果他们做同样的事情，他们之间有什么区别？</p><blockquote class="lx"><p id="4ca3" class="ly lz iq bd ma mb mc md me mf mg kv dk translated">TL；DR share()、publish()和其他多播运营商使冷的可观察对象表现为热的</p></blockquote><p id="57f0" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">为了理解共享操作符是如何工作的，我们需要理解什么是<em class="la">多播。</em></p><blockquote class="kx ky kz"><p id="ecf7" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">当所有用户从同一个生产者那里获得数据时，热观测值被<strong class="ka ir">多播</strong>。冷可观测量是<strong class="ka ir">单播</strong>，因为每个用户从不同的生产者那里获得数据。</p></blockquote><h2 id="f68e" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">多播()</h2><p id="68aa" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">RxJs有<code class="fe le lf lg lh b">multicast()</code>操作符，它接受主题或主题工厂并返回<code class="fe le lf lg lh b">ConnectableObservable</code>。作为参数传递的主题就像多播观察中的中间人。它只是将来自可观察源的数据转发给所有订户。<code class="fe le lf lg lh b">ConnectableObservable</code>是一个常规的可观察对象，但在调用<code class="fe le lf lg lh b">connect()</code>方法之前，它不会订阅源。让我们用<code class="fe le lf lg lh b">multicast()</code>改变上面的例子来理解它是如何工作的。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="919e" class="lq lr iq lh b gy ls lt l lu lv"><em class="la">this</em>.user$ = <em class="la">this</em>.http.get(`api/user/1`).pipe(<em class="la"><br/>  </em><strong class="lh ir">multicast(new Subject())</strong><br/>);</span></pre><p id="a9cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">光靠这个不行，因为我们需要手动调用<code class="fe le lf lg lh b">connect()</code></p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="c813" class="lq lr iq lh b gy ls lt l lu lv">this.name$ = this.user$.pipe(<br/>      map(user =&gt; user.name)<br/>   );</span><span id="2774" class="lq lr iq lh b gy lw lt l lu lv">this.age$ = this.user$.pipe(<br/>      map(user =&gt; user.age)<br/>   );</span><span id="fd2d" class="lq lr iq lh b gy lw lt l lu lv"><strong class="lh ir">this.user$.connect();</strong></span></pre><p id="a525" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此之后，我们将看到同样的行为，将只有一个http调用，而不是两个。手动连接和断开可能很难实现，因此有一个<code class="fe le lf lg lh b">refCount()</code>操作符，它将自动<code class="fe le lf lg lh b">connect()</code>第一次订阅，记录订阅数并保持<em class="la">主题</em>连接到<em class="la">源</em>，只要至少有一个订阅者。当S<em class="la">subscriptions</em>计数降至零时，<em class="la"> Subject </em>将与<em class="la"> Source </em>断开。</p><p id="0938" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">Source</em><em class="la">observable</em>在我们的例子中是由<strong class="ka ir">this . http . get()</strong><br/><em class="la">Subject</em>是作为参数传递给<strong class="ka ir">multicast()</strong><br/><em class="la">subscription或observer</em>是<strong class="ka ir"> this.name$ </strong>和<strong class="ka ir"> this.age$ </strong>以及订阅Subject的其他observer。</p><p id="1bb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，我们所有的订户都将订阅主题X(传递给多播)，而主题X(T42)本身将订阅我们的http呼叫。当http调用返回的observable发出时，我们的<em class="la"> subject X </em>将获取该值并在所有订阅者之间共享。</p><blockquote class="lx"><p id="e54e" class="ly lz iq bd ma mb mc md me mf mg kv dk translated">多播的一般思想是主体订阅源，多个观察者订阅主体。</p></blockquote><figure class="nj nk nl nm nn jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/1e179e7089ef4e75ddd37fae8a164835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_trxWw965KWpqhomPl-f0w.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">RXJS中多播的工作原理</figcaption></figure><p id="7eff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们修改代码来使用<code class="fe le lf lg lh b">refCount()</code>，这样我们就不需要手动连接了。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="4d7e" class="lq lr iq lh b gy ls lt l lu lv"><em class="la">this</em>.user$ = <em class="la">this</em>.http.get(`api/user/1`).pipe(<em class="la"><br/>  </em>multicast(new Subject()),<br/>  <strong class="lh ir">refCount()</strong><br/>);</span></pre><p id="46dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们不需要手动调用connect()而担心断线。第一次订阅时将主题连接到源，当不再有观察者时将断开连接。<br/>事实上，之前我们使用了<code class="fe le lf lg lh b">publish(), refCount()</code>的组合，这与<code class="fe le lf lg lh b">multicast(new Subject()), refCount()</code>完全相同</p><h2 id="7792" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">发布()</h2><p id="6273" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">RxJs有<code class="fe le lf lg lh b">publish()</code>操作符，如果我们查看源代码，我们会看到它使用了带有Subject()的多播</p><blockquote class="kx ky kz"><p id="a66f" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">publish() ===多播(新主题())</p></blockquote><p id="d1ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">publish()</code>可选地接受选择器函数，事实上它改变了操作者的行为，值得自己的文章。我们将跳过这一部分，考虑使用没有选择器功能的<code class="fe le lf lg lh b">publish()</code>。</p><p id="0ac7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以当我们使用<code class="fe le lf lg lh b">publish()</code>时，我们实际上使用的是旧的<code class="fe le lf lg lh b">multicast()</code>和<code class="fe le lf lg lh b">Subject()</code>，所以我们要么需要手动进行连接和断开，要么使用<code class="fe le lf lg lh b">refCount()</code>来自动完成这个过程。</p><p id="e72c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们通常将<code class="fe le lf lg lh b">publish()</code>与<code class="fe le lf lg lh b">refCount()</code>一起使用，所以有一个非常相似的操作符，它在内部使用<code class="fe le lf lg lh b">refCount()</code>，并且行为相似。那就是<code class="fe le lf lg lh b">share()</code></p><h2 id="11b2" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">共享()</h2><blockquote class="kx ky kz"><p id="ffa4" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">share() ===多播(()= &gt;新主题())。refCount()</p></blockquote><p id="63d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的第一个例子中，我们看到<code class="fe le lf lg lh b">share()</code>和<code class="fe le lf lg lh b">publish(), refCount()</code>做同样的事情，在大多数情况下它们是一样的。<code class="fe le lf lg lh b">share()</code>是内部使用<code class="fe le lf lg lh b">refCount()</code>的运算符，我们不需要调用它。<code class="fe le lf lg lh b">share()</code>就像<code class="fe le lf lg lh b">publish()</code>使用<code class="fe le lf lg lh b">multicast()</code>一样，但不同之处在于传递给<code class="fe le lf lg lh b">multicast().</code>的参数</p><blockquote class="lx"><p id="48f0" class="ly lz iq bd ma mb mc md me mf mg kv dk translated"><code class="fe le lf lg lh b">publish()</code>使用主题实例— <code class="fe le lf lg lh b">multicast(new Subject())</code></p><p id="d647" class="ly lz iq bd ma mb mc md me mf mg kv dk translated"><code class="fe le lf lg lh b">share()</code>使用返回主题实例的工厂函数— <code class="fe le lf lg lh b">multicast(() =&gt; new Subject()).refCount()</code></p></blockquote><p id="443a" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">这是我们不能说<code class="fe le lf lg lh b">share()</code>和<code class="fe le lf lg lh b">publish() + refCount()</code>一样的唯一原因。当源完成时，这种差异会导致后期订阅者不同行为。</p><h2 id="600b" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">share()和publish() + refCount()之间的区别</h2><p id="eed6" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">然而，他们都使用<code class="fe le lf lg lh b">refCount()</code>来管理订阅</p><blockquote class="kx ky kz"><p id="88d2" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">publish() + refCount() </code> —只要Subject至少有一个订阅者，就会发出值。一旦没有订户，主题将与源断开连接。<strong class="ka ir">对于所有新订户，如果源已完成，他们将收到“已完成”发射</strong>，但是<strong class="ka ir">如果源未完成，受试者将重新订阅源</strong></p><p id="1774" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">share()</code> —只要Subject至少有一个订阅者，就会发出值。一旦没有订户，主题将与源断开连接。<strong class="ka ir">对于任何新订阅者，无论Source是否已完成，都将使用新主题再次订阅Source</strong></p></blockquote><p id="fdb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种差别很微妙，但非常重要。让我们修改代码，让它有一个更新用户数据的按钮。当点击它时，将从服务器重新获取数据。<br/>首先让我们使用<code class="fe le lf lg lh b">share()</code></p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="41ea" class="lq lr iq lh b gy ls lt l lu lv">ngOnInit() {<br/>   this.user$ = this.http.get(`api/user/1`).pipe(<br/>      <strong class="lh ir">share()</strong><br/>   )</span><span id="bc7a" class="lq lr iq lh b gy lw lt l lu lv">this.name$ = this.user$.pipe(<br/>      map(user =&gt; user.name)<br/>   );</span><span id="81c0" class="lq lr iq lh b gy lw lt l lu lv">this.age$ = this.user$.pipe(<br/>      map(user =&gt; user.age)<br/>   );</span><span id="4140" class="lq lr iq lh b gy lw lt l lu lv">}</span><span id="f563" class="lq lr iq lh b gy lw lt l lu lv"><strong class="lh ir">update() {<br/>  <em class="la">this</em>.name$ = <em class="la">this</em>.user$.pipe(<br/>    map(user =&gt; user.name + 'update')<br/>  );<br/>  <em class="la">this</em>.age$ = <em class="la">this</em>.user$.pipe(<br/>    map(user =&gt; user.age + 'updated')<br/>  );<br/>}</strong></span></pre><p id="c8bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们最初加载数据时,<code class="fe le lf lg lh b">refCount()</code>会统计所有引用。所以我们将有两个主题的引用。一旦我们从服务器获取数据，主题将从源和完整的数据。我们的两个订户都将从Subject和complete获得数据，这意味着<code class="fe le lf lg lh b">refCount() </code>中的参考号将为0。在这种情况下，受试者将与源断开连接。<br/>当我们执行<code class="fe le lf lg lh b">update()</code>方法时，将创建新的Subject()实例并订阅源。所以每次执行update()都会向服务器发送请求。</p><p id="7230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在考虑与<code class="fe le lf lg lh b">publish(), refCount()</code>相同的例子</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="fc8c" class="lq lr iq lh b gy ls lt l lu lv">this.user$ = this.http.get(`api/user/1`).pipe(<br/><strong class="lh ir"> publish(),<br/> refCount()</strong><br/>);</span></pre><p id="d952" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，我们将<code class="fe le lf lg lh b"> refCount()</code>计数器设置为2，一旦源发射并完成，计数器将为0。但是当我们执行<code class="fe le lf lg lh b">update()</code>方法时，什么也不会发生，也不会向服务器发出请求。如上所述，如果源完成，新订户将仅获得“完成”通知。</p><p id="4372" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他们如此表现的原因在<code class="fe le lf lg lh b">multicast()</code>。因为<code class="fe le lf lg lh b">publish()</code>使用Subject实例，所以当Source完成时，Subject也将完成，所以该Subject的任何新订阅者将只收到“完成”通知。<br/> <code class="fe le lf lg lh b">share()</code>使用返回主题实例的工厂函数。当Source完成时，Subject也将完成，但是对于新的订阅者，将创建新的Subject实例并订阅Source。</p><h2 id="50bb" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">具有不同主题类型的多播()</h2><p id="feeb" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">到目前为止，我们讨论了使用主题的多播。很少有其他类型的主题——重放主题、行为主题和异步主题。向多播传递不同的主题将返回ConnectableObservable，但它们的行为会有所不同。</p><p id="285b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先让我们看看<code class="fe le lf lg lh b">ReplaySubject(n)</code>，它将number作为参数，这是它将保存在缓冲区中的发射计数。对于任何新的用户，它将重放n次。</p><p id="ba31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们将ReplaySubject(n)传递给multicast()，所有新的订阅者都将获得n个重播值。</p><h2 id="a25b" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">发布重放()</h2><blockquote class="kx ky kz"><p id="29be" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">publishReplay() ===多播(new ReplaySubject())</p></blockquote><p id="147a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">publishReplay()</code>返回<code class="fe le lf lg lh b">ConnectableObservable</code>，所以我们需要使用<code class="fe le lf lg lh b">connect()</code>或者使用<code class="fe le lf lg lh b">refCount()</code>来管理连接。让我们修改一下我们的例子，这样每个新的订阅者都会得到缓冲值。所以当我们点击<code class="fe le lf lg lh b">update()</code>时，我们不会收到新的数据，但会得到缓存的值。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="e641" class="lq lr iq lh b gy ls lt l lu lv">this.user$ = this.http.get(`api/user/1`).pipe(<br/><strong class="lh ir"> publishReplay(1),<br/> refCount()</strong><br/>);</span></pre><p id="6832" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Source完成之前，ReplaySubject的所有订阅者都将获得发出的值(在我们的例子中只有1个值，因为Http只发出一次)。对于所有新订户，ReplaySubject将重放N个缓冲值。</p><p id="5ab5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们大多用<code class="fe le lf lg lh b">publishReplay()</code>搭配<code class="fe le lf lg lh b">refCount()</code>，所以有一个非常相似的运算符，它在内部使用引用计数机制，行为也很相似。那就是<code class="fe le lf lg lh b">shareReplay()</code></p><h2 id="86a8" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">共享重播()</h2><p id="1297" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated"><code class="fe le lf lg lh b">shareReplay()</code>是非常有趣的运算符。它的行为方式与<code class="fe le lf lg lh b">publishReplay() + refCount()</code>相似，但这取决于我们如何使用这个操作符。</p><p id="9fb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在RxJs版本6.4.0之前，<code class="fe le lf lg lh b">shareReplay()</code>中的引用计数机制以不同的方式工作。从6.4.0开始，我们可以显式地传递一个参数给<code class="fe le lf lg lh b"> shareReplay()</code>来使用“正常”的引用计数机制。让我们更详细地看看</p><h2 id="ea93" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">share replay({ ref count:true })(RXJS 6 . 4 . 0或更高版本)</h2><p id="c7cd" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated"><code class="fe le lf lg lh b">refCount: true</code>告诉<code class="fe le lf lg lh b">shareReplay()</code>使用参考计数机制，类似于<code class="fe le lf lg lh b">refCount()</code>。在这种情况下<code class="fe le lf lg lh b">shareReplay({refCount: true})</code>与<code class="fe le lf lg lh b">publishReplay() + refCount()</code>几乎相同。让我们修改我们的例子来使用shareReplay。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="88ad" class="lq lr iq lh b gy ls lt l lu lv">this.user$ = this.http.get(`api/user/1`).pipe(<br/><strong class="lh ir"> shareReplay({refCount: true, bufferSize: 1})</strong><br/>);</span></pre><p id="63bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们不再使用<code class="fe le lf lg lh b">refCount()</code>，因为<code class="fe le lf lg lh b">shareReplay({refCount: true})</code>使用它自己的引用计数机制。结果将是一样的。只要ReplaySubject发出值，它的所有订阅者都将获得这些值。所有新订户将获得N个缓冲值。<br/>在说shareReplay的其他使用方法之前，我们先来看看它们的区别。</p><h2 id="5e84" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">shareReplay({refCount: true})和publishReplay() + refCount()之间的区别</h2><p id="00e0" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">他们都使用<code class="fe le lf lg lh b">ReplaySubject()</code>但是<code class="fe le lf lg lh b">shareReplay()</code>没有用<code class="fe le lf lg lh b">multicast()</code>实现。</p><blockquote class="kx ky kz"><p id="2242" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">publishReplay(n) + refCount()</code> — <em class="iq">只要至少有一个订阅者，源ReplaySubject将发出值，一旦没有订阅者，ReplaySubject将与源断开连接。</em> <strong class="ka ir"> <em class="iq">任何新订阅者将从ReplaySubject中获取最后N个值，如果源尚未完成，则使用相同的ReplaySubject再次重新订阅源。</em> </strong></p><p id="c403" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe le lf lg lh b"><em class="iq">shareReplay({refCount: true, bufferSize: n}) </em></code> <em class="iq"> —只要至少有一个订阅者ReplaySubject就会发出值，一旦没有订阅者ReplaySubject就会与源断开连接。</em> <strong class="ka ir"> <em class="iq">对于新订阅者，如果源已完成，它将从ReplaySubject发出最后N个值，但如果源未完成，或出错，它将仅使用新ReplaySubject再次订阅源</em> </strong></p></blockquote><p id="6930" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了看出区别，让我们使用<code class="fe le lf lg lh b">interval()</code>,这样对于新的订户来说，源将不会被完成</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3a24" class="lq lr iq lh b gy ls lt l lu lv"><em class="la">this</em>.source = interval(1000).pipe(<br/>  publishReplay(1),<br/>  refCount()<br/>);<br/><em class="la">const </em>sub1 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 1', x));<br/><em class="la">const </em>sub2 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 2', x));<br/><br/>setTimeout(() =&gt; {<br/>  sub1.unsubscribe();<br/>  sub2.unsubscribe();<br/>}, 2000);</span></pre><p id="54da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有2个ReplaySubject订阅，sub1和sub2。2秒钟后，他们都将取消订阅主题。因为当不再有订阅者时，我们使用<code class="fe le lf lg lh b">refCount()</code>(例如，引用计数下降到零)，它将从源断开ReplaySubject。到目前为止，我们将在控制台中看到。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="4541" class="lq lr iq lh b gy ls lt l lu lv"> sub 1– 0<br/> sub 2– 0<br/> sub 1– 1<br/> sub 2– 1</span></pre><p id="3165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，假设我们将创建新的订阅者，通过单击按钮来ReplaySubject。(在refCount降至零之后)</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="7f40" class="lq lr iq lh b gy ls lt l lu lv"><br/>newSub() {<br/> <em class="la">const </em>sub3 = <em class="la">this</em>.source.subscribe(x =&gt; console.log(‘sub 3’, x));<br/>}</span></pre><p id="44da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当<code class="fe le lf lg lh b">newSub()</code>被执行时，sub3将从ReplaySubject(将是<strong class="ka ir"> 1 </strong>)获取最后一个缓冲值，并检查Source是否已完成。如果完成，sub3将收到“已完成”通知，并且也将完成。但是，因为我们使用的是<code class="fe le lf lg lh b">interval()</code>，Source将不会完成，内部ReplaySubject将再次重新订阅Source。结果将会是</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="30af" class="lq lr iq lh b gy ls lt l lu lv"> sub 1– 0<br/> sub 2– 0<br/> sub 1– 1<br/> sub 2– 1<br/><em class="la">/**** execution of newSub() ****/</em><br/> <strong class="lh ir">sub 3– 1 &lt;- replayed value</strong><br/> sub 3– 0 &lt;- new subscription<br/> sub 3– 1<br/> sub 3– 2<br/>...</span></pre><p id="f7ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">内部重放主体向新的观察者重放缓冲的值，并根据源完成的状态完成或重新订阅源。</p><p id="9569" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在使用<code class="fe le lf lg lh b">shareReplay({refCount:true })</code>的相同<code class="fe le lf lg lh b">interval()</code>示例</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="2259" class="lq lr iq lh b gy ls lt l lu lv"><em class="la">this</em>.source = interval(1000).pipe(<br/>  shareReplay({refCount: true, bufferSize: 1})<br/>);<br/><em class="la">const </em>sub1 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 1', x));<br/><em class="la">const </em>sub2 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 2', x));<br/><br/>setTimeout(() =&gt; {<br/>  sub1.unsubscribe();<br/>  sub2.unsubscribe();<br/>}, 2000);</span><span id="cbe6" class="lq lr iq lh b gy lw lt l lu lv">//execute newSub() after sub1 and sub2 unsubscribe<br/>newSub() {<br/> <em class="la">const </em>sub3 = <em class="la">this</em>.source.subscribe(x =&gt; console.log(‘sub 3’, x));<br/>}</span></pre><p id="91ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">shareReplay()</code>未通过<code class="fe le lf lg lh b">multicast</code>实现，但它在内部使用工厂函数，如果我们将它与<code class="fe le lf lg lh b">refCount: true</code>一起使用，并且引用计数降至零，对于任何新订户，如果源已完成，它将重放缓冲值并发出“完成”通知。如果任何新订阅者的源尚未完成，将创建新的ReplaySubject并订阅源。<br/>运行上面的代码并执行<code class="fe le lf lg lh b">newSub()</code>后，我们将看到结果。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ccef" class="lq lr iq lh b gy ls lt l lu lv"> sub 1– 0<br/> sub 2– 0<br/> sub 1– 1<br/> sub 2– 1<br/><em class="la">/**** execution of newSub() ****/</em><br/> sub 3– 0 &lt;- new subscription<br/> sub 3– 1<br/> sub 3– 2<br/>...</span></pre><p id="1ab7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，sub3没有重放任何值。原因是，当sub1和sub2取消订阅时，ref计数将为零，并且如果源已完成，所有新订阅者(如sub3)将获得所有缓冲值和“已完成”通知，但是由于我们正在使用<code class="fe le lf lg lh b">interval()</code>并且源不会完成，ReplaySubject将被销毁，任何新订阅者(如sub3)将创建新的ReplaySubject实例并再次订阅源。</p><h2 id="9baf" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">不带refCount的shareReplay()</h2><p id="2643" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">到目前为止，我们使用<code class="fe le lf lg lh b">shareReplay</code>和<code class="fe le lf lg lh b">refCount: true</code>。我们可以使用shareReplay，将refCount设置为false或者根本不设置，只指定缓冲区大小——例如<code class="fe le lf lg lh b">shareReplay({refCount: false, bufferSize: 3})</code>和<code class="fe le lf lg lh b">shareReplay(3) </code>是相同的。这意味着ReplaySubject将发出最后3个值，refCount将为false。这并不意味着没有引用计数机制，只是行为不同而已。</p><blockquote class="kx ky kz"><p id="2b6a" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">默认情况下，<code class="fe le lf lg lh b">shareReplay()</code>中的<code class="fe le lf lg lh b">refCount</code>被设置为<code class="fe le lf lg lh b">false</code></p></blockquote><p id="3e8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">refCount: false</code>表示首次订阅ReplaySubject时，它将订阅Source。但它不会断开ReplaySubject与源的连接，因为源中不再有ReplaySubject的订阅者。让我们使用refCount false再次修改我们的示例</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="de25" class="lq lr iq lh b gy ls lt l lu lv"><em class="la">this</em>.source = interval(1000).pipe(<br/>  <strong class="lh ir">shareReplay({refCount: false, bufferSize: 2})<br/>  //or just shareReplay(2)</strong><br/>);<br/><em class="la">const </em>sub1 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 1', x));<br/><em class="la">const </em>sub2 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 2', x));<br/><br/>setTimeout(() =&gt; {<br/>  sub1.unsubscribe();<br/>  sub2.unsubscribe();<br/>}, 2000);</span><span id="5612" class="lq lr iq lh b gy lw lt l lu lv"><strong class="lh ir">setTimeout(() =&gt; {<br/> <em class="la">const </em>sub3 = <em class="la">this</em>.source.subscribe(x =&gt; console.log(‘sub 3’, x));<br/>}, 4000);</strong></span></pre><p id="bfc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">sub1和sub2订阅ReplaySubject，ReplaySubject订阅源间隔。2秒钟后，sub1和sub2将取消订阅，但在这种情况下，ReplaySubject不会取消订阅源。即使没有订阅者来获取这些值，源也将继续发出这些值。<br/>4秒后，新订户将订阅ReplaySubject，并将获取最后2个缓冲值，并继续从源获取值。结果将会是</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="046e" class="lq lr iq lh b gy ls lt l lu lv"> sub 1– 0<br/> sub 2– 0<br/> sub 1– 1<br/> sub 2– 1<br/><em class="la">/**** after 4 seconds  ****/<br/> </em><strong class="lh ir">sub 3– 2 &lt;- replayed values<br/> sub 3– 3 &lt;-</strong><br/> sub 3– 4 &lt;- continues receiving values<br/> sub 3– 5<br/>...</span></pre><p id="0e79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">sub1和sub2订阅，打印值并在两秒后取消订阅，但因为源尚未完成，ReplaySubject将从源接收数据，因此当4秒后sub3订阅ReplaySubject时，它将获得的不是作为缓冲值的<strong class="ka ir"> 0 </strong>和<strong class="ka ir"> 1 </strong>，而是<strong class="ka ir"> 2 </strong>和<strong class="ka ir"> 3 </strong>、<strong class="ka ir"> </strong>，因为在此时间内<strong class="ka ir"/>replay subject设法从源获得新值ReplaySubject取消订阅源的唯一情况是当源完成或出错时。在这种情况下，任何新订户都将获得重播值并完成。</p><blockquote class="kx ky kz"><p id="2447" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe le lf lg lh b"><em class="iq">shareReplay(n) </em></code> <em class="iq"> — </em> <strong class="ka ir"> <em class="iq">无论是否有活动订户，主体都将继续发出值并保持与源的连接，直到源完成或出错</em> </strong> <em class="iq">。</em><strong class="ka ir"><em class="iq"/></strong><em class="iq">【任何新订户都将获得最后N个值(如果不出错)。如果源尚未完成，新订户将继续从源获取值</em></p></blockquote><h2 id="c5e5" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">发布行为()</h2><p id="155b" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated"><code class="fe le lf lg lh b">publishBehavior()</code>将<code class="fe le lf lg lh b">multicast</code>用于另一个主题。行为主体</p><blockquote class="kx ky kz"><p id="e815" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">publishBehavior() ===多播(新的BehaviorSubject())</p></blockquote><p id="ce8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">publishBehavior()</code>返回<code class="fe le lf lg lh b">ConnectableObservable</code>，所以我们需要使用<code class="fe le lf lg lh b">refCount()</code>或者手动连接。</p><p id="bf2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">publishBehavior()</code>接受缺省值作为参数，如果Source没有发出，将把该值发送给所有订阅者。考虑这个例子</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="06b0" class="lq lr iq lh b gy ls lt l lu lv"><em class="la">this</em>.source = interval(1000).pipe(<br/> <strong class="lh ir">publishBehavior(47),<br/>  refCount()</strong><br/>);<br/><em class="la">const </em>sub1 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 1', x));<br/><em class="la">const </em>sub2 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 2', x));<br/><br/>setTimeout(() =&gt; {<br/>  sub1.unsubscribe();<br/>  sub2.unsubscribe();<br/>}, 2000);</span><span id="87af" class="lq lr iq lh b gy lw lt l lu lv">setTimeout(() =&gt; {<br/>  <em class="la">const </em>sub3 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 3', x));<br/>}, 4000);</span></pre><p id="93fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果将会是</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="a511" class="lq lr iq lh b gy ls lt l lu lv"> <strong class="lh ir">sub 1– 47 &lt;- default values<br/> sub 2– 47 &lt;-</strong><br/> sub 1– 0<br/> sub 2– 0<br/> sub 1– 1<br/> sub 2– 1<br/><em class="la">/**** after 4 seconds ****/</em><br/> <strong class="lh ir">sub 3– 1 &lt;- last buffered value</strong><br/> sub 3– 0<br/> sub 3– 1<br/>...</span></pre><p id="bebd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为interval是异步的，当sub1和sub2订阅BehaviorSubject时，那时Source还没有发出，所以sub1和sub2将从BehaviorSubject获取默认值。两秒钟后，sub1和sub2将取消订阅BehaviorSubject，BehaviorSubject本身将取消订阅Source。4秒钟后，sub3将订阅BehaviorSubject，因为Source尚未完成，sub3将获取最后发出的值，并使用相同的BehaviorSubject重新订阅Source。</p><blockquote class="kx ky kz"><p id="9d51" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe le lf lg lh b"><em class="iq">publishBehavior(default_value) </em></code> <em class="iq"> — </em> <strong class="ka ir"> <em class="iq">如果在源发出值之前订阅了行为主体，行为主体会将默认值传递给该订阅者。</em> </strong> <em class="iq">只要至少有一个订阅者对源行为Subject就会发出值。一旦没有订户，行为主体将与源断开连接。</em> <strong class="ka ir"> <em class="iq">如果源尚未完成，新订阅者将从BehaviorSubject获取最后一个值，并使用相同的BehaviorSubject重新订阅源。如果源已完成，所有新订户将仅获得“已完成”通知。</em> </strong></p></blockquote><h2 id="df7c" class="lq lr iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">publishLast()</h2><p id="7a76" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated"><code class="fe le lf lg lh b">publishLast()</code>使用带有异步主题的多播</p><blockquote class="kx ky kz"><p id="3d54" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">publishLast() ===多播(new AsyncSubject())</p></blockquote><p id="2227" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与所有多播操作符一样，<code class="fe le lf lg lh b">publishLast()</code>最好与<code class="fe le lf lg lh b">refCount()</code>一起使用。<br/>这个运算符中使用的AsyncSubject很有意思。它不会发出值，如果订阅，直到完成后，发出最后一个值。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="d542" class="lq lr iq lh b gy ls lt l lu lv"><em class="la">this</em>.source = interval(1000).pipe(<br/> <strong class="lh ir">take(2),<br/> publishLast(),<br/> refCount()</strong><br/>);</span><span id="facf" class="lq lr iq lh b gy lw lt l lu lv"><em class="la">const </em>sub1 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 1', x));<br/><em class="la">const </em>sub2 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 2', x));<br/><br/>setTimeout(() =&gt; {<br/>  <em class="la">const </em>sub3 = <em class="la">this</em>.source.subscribe(x =&gt; console.log('sub 3', x));<br/>}, 7000);</span></pre><p id="bcbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为区间是无限可观测的，我们使用了<code class="fe le lf lg lh b">take(2)</code>,所以它将发出2个值并完成。这就是结果</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="f233" class="lq lr iq lh b gy ls lt l lu lv"> sub 1– 1 //completed<br/> sub 2– 1 //completed<br/><em class="la">/**** after 7 seconds ****/</em><br/> sub 3– 1 //completed</span></pre><p id="825e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当sub1和sub2订阅AsyncSubject时，在源完成之前，它们不会收到任何值。当源完成时，AsyncSubject将把最后一个值传递给所有观察器，并且也完成。7秒钟后，sub3订阅AsyncSubject，因为它已完成，所以它也会将最后一个值和“已完成”通知传递给sub3。</p><blockquote class="kx ky kz"><p id="46ba" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe le lf lg lh b"><em class="iq">publishLast() </em></code> <em class="iq"> —无论有多少订户连接到<br/> AsyncSubject、</em> <strong class="ka ir"> <em class="iq">都不会发出任何值，直到Source完成</em> </strong> <em class="iq">、</em> <strong class="ka ir"> <em class="iq">，但是任何副作用都会被执行</em> </strong> <em class="iq">。</em> <strong class="ka ir"> <em class="iq">当源完成异步时，主题也完成，并且</em> </strong> <em class="iq"> </em> <strong class="ka ir"> <em class="iq">向所有订户(当前订户和新订户)发出最后一个值和“完成”通知。</em> </strong></p></blockquote><p id="a321" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Rxjs中有很多正在进行的事情，多播是图书馆中最重要的事情之一。希望这篇文章能帮助你理解共享操作符是如何工作的，它们有什么不同。感谢阅读。</p></div></div>    
</body>
</html>