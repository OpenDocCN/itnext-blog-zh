<html>
<head>
<title>NewsCast — Using Sagas with Choreography and Orchestration Patterns — A Java 17 / Kotlin example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新闻广播——将Sagas与编排和编排模式结合使用——Java 17/kot Lin示例</h1>
<blockquote>原文：<a href="https://itnext.io/newscast-using-sagas-in-choreography-and-orchestration-patterns-a-java-17-and-kotlin-example-e3d0ec17b910?source=collection_archive---------0-----------------------#2021-10-13">https://itnext.io/newscast-using-sagas-in-choreography-and-orchestration-patterns-a-java-17-and-kotlin-example-e3d0ec17b910?source=collection_archive---------0-----------------------#2021-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4262b5d156d065c2074cde652affc896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ur-3RZ8XiJLxjwduaLVUxQ.jpeg"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="e61c" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">介绍</h1><p id="d14e" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">aga是在事件源架构中使用的企业集成模式。当弹性、负载能力和性能很重要时，它们很有用。电信公司经常使用这种方法来传递数据，以保持重要的指标，如请求的持续时间、可能的同时请求数量、应用程序的响应速度以及符合<strong class="li iu">SLA</strong>(服务级别协议)的弹性。这种模式在1987年由<a class="ae mn" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" rel="noopener ugc nofollow" target="_blank">埃克托·加西亚-莫利纳和肯尼斯·塞勒姆</a>首次公之于众。这个想法是为了解决与<strong class="li iu"> LLTs </strong>(长期事务)相关的一个问题。这些交易被认为是A.C.I.D .交易，但是花费了大量的时间。这里的关键词是原子性、一致性、隔离性和持久性。对于消耗大量资源的事务这样做，会导致<strong class="li iu"> LLTs </strong>持续很长时间，甚至几天或几周。这显然带来了延迟问题和过度的资源消耗。通过拆分一个事务，将不可能遵守隔离或原子性。失去一致性的风险也很高。为了利用<strong class="li iu">llt</strong>并将它们转换为可管理的事务并尽快释放资源，他们设计了一个系统，有两个变体，具有定义的布局计划来执行特定的操作以应对故障。在一个<strong class="li iu"> LLT </strong>中，这将是回滚。在Sagas中，如果任何一个子进程失败，这些智能进程能够回滚或使系统达到期望的状态。这些子流程仍然是事务，它们严格遵循A.C.I.D .范例。我们将探索我在GitHub<a class="ae mn" href="https://github.com/jesperancinha/news-cast-explorer" rel="noopener ugc nofollow" target="_blank"><strong class="li iu"/></a>中创建的例子。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="cb86" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">2.情况</h1><p id="b0cd" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们希望在我们的数据库中存储来自特定新闻提要的所有新闻。然后，我们希望允许用户对它们进行评论，我们希望控制我们可能遇到的所有错误流。我们还希望尽可能缩短响应时间，提供高可用性和弹性，并确保用户尽快获得他们的评论。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="fbd6" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">3.项目布局</h1><p id="bc24" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> F </span>对于这个项目，我们将使用<a class="ae mn" href="https://eventuate.io/" rel="noopener ugc nofollow" target="_blank">最终框架</a>，结合<a class="ae mn" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank">弹簧框架</a>:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/5cd48ef4ded39368418cfb8728913b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FK_DdCF3OU7z7IlBhv3-xA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">概述</figcaption></figure><p id="be56" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在该模式中，我们可以看到两个重要的主要部分。第一个由Fetcher和模拟提要组成。这两者为我们的传奇架构提供了原始数据。作为默认运行，我将Fetcher设置为每分钟运行一次，最长30秒，直到它收到100条新闻消息。这意味着要么它将在30秒内完成100条以下的消息，要么它将在更早的时间内完成总共100条消息。由于这不是一个在线社交媒体平台，也不是一个真正的新闻提要，所以在这个例子中，您将总是会收到100条消息。本文的目的不是演示这是如何工作的，但是我认为让您了解所有这些背后有三个正在运行的线程是很重要的。一个负责检查队列中的传入消息。第二个负责向模拟新闻提要发出请求。最后，如果30秒已经过去，第三个将停止整个过程。</p><p id="eac2" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">一旦我们获得了数据，我们就可以继续探索传奇。提取过程将无限期继续。这是图表的第二部分。</p><p id="437e" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">我们的saga实施将消耗像本例中这样的有效载荷:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="5bb3" class="nh kj it nd b be ni nj l nk nl">{ <br/>"idPage": 1, <br/>"pageComment": "I love this", <br/>"idAuthor": 2,<br/>"authorComment": "This is my favourite author", <br/>"idMessage": 3, <br/>"messageComment": "I agree", <br/>"authorRequestId":123,<br/>"pageRequestId":456,<br/>"messageRequestId":789 <br/>}</span></pre><p id="8a8e" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">关于这个有效载荷，重要的是要知道<code class="fe nm nn no nd b"><strong class="li iu"><em class="np">idPage</em></strong></code>、<code class="fe nm nn no nd b"><strong class="li iu"><em class="np">idAuthor</em></strong></code>、<strong class="li iu">、<em class="np">、</em>、</strong>和<code class="fe nm nn no nd b"><strong class="li iu"><em class="np">idMessage</em></strong></code>。这些id没有被编程为外键，因此当发送附加到页面、作者和消息的评论时，它们应该能够匹配现有的数据。否则，数据将被记录为<strong class="li iu">不可用</strong>。有一个层次结构，那就是页面- &gt;作者- &gt;消息。例如，如果作者不存在，则不会记录消息注释，但会记录页面和作者注释，并且它们会被标记为不可用。这种情况当然在现实中并不存在。这只是一个虚构的案例，展示如何利用传奇故事为我们造福。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="0a8b" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">4.实践中的传奇</h1><p id="1937" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们详细关注本文的目标。我们想看看传奇如何为我们服务。Sagas也是一种将客户端请求从实际处理中分离出来的方法。客户端发出POST请求，Saga将确保请求到达数据库。然而，如果某个东西失败了，那么Saga必须具有执行回滚或其他可预测操作的智能。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/ee4bce21afe9807e2c6f8dc66d6f42ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOCQeQCB1CAiaqe-HXQ-2g.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">传奇概述</figcaption></figure><p id="0baf" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">从外部来看，我们可以看到解耦是通过一个流引擎提供的。在我们的例子中，我们将使用卡夫卡。出于流的目的，我们可以使用任何我们想要的机制。不强制使用卡夫卡。请查看<a class="ae mn" href="https://eventuate.io/" rel="noopener ugc nofollow" target="_blank"> eventuate.io </a>网站，了解更多关于其他兼容机制的信息。为了更好地想象幕后将要发生的事情，我们来看看这个序列图。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/4b200be4dc0e89ea7c75d288e714895c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FdTyWm-SuBbtJt-8OOWZw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">通用序列图</figcaption></figure><p id="9bad" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在这个图中，我们可以看到，当我们使用所描述的两种Saga类型中的任何一种发出请求时，我们的请求将被发送到数据库。它被持久化，继续的唯一方法是将其发送到流中。在我们的例子中，它流向卡夫卡的溪流。eventuate团队创建了一个CDC服务来完成这项工作。然而，出于这个例子的目的，管理起来相当复杂，这就是为什么我创建了我自己的<strong class="li iu"> CDC模仿的</strong>版本。本质上，它从一个名为messages的表中选取数据，并将未发布的数据原样发送到Kafka流中。我们将在本文后面详细了解这是如何工作的。一旦CDC选择了消息并将它们发送到Kafka，我们的Saga代码将在另一个线程中选择它并继续执行Saga。此时，我们的用户已经收到了200 OK，这意味着消息正在处理中。最后，如果我们检查数据库中的评论，我们将根据发送的内容看到结果。也许我们会看到被标记为不可用的评论，或者我们会看到评论被完全正确地处理。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="a7c2" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">4.1.最终疾病控制中心服务</h1><p id="040e" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">CDC服务的实现无非是<strong class="li iu"> Kafka </strong>客户端的实现。为此我们创建一个<strong class="li iu"><em class="np">KafkaProducerFactory</em></strong>:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="2d70" class="nh kj it nd b be ni nj l nk nl">class KafkaProducerFactory {<br/>    companion object {<br/>        fun createProducer(brokers: String): Producer&lt;Long?, String?&gt; {<br/>            val props = Properties()<br/>            props[ProducerConfig.BOOTSTRAP_SERVERS_CONFIG] = brokers<br/>            props[ProducerConfig.CLIENT_ID_CONFIG] = CdcConstants.CLIENT_ID<br/>            props[ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG] = LongSerializer::class.java.name<br/>            props[ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java.name<br/>            return KafkaProducer(props)<br/>        }<br/>    }<br/>}</span></pre><p id="5c89" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">消息的内容和形式确实取决于数据库中注册的内容。对于最终的Saga实现，我们首先需要创建一个数据库。这个数据库的脚本可以在他们的网站上获得，在许多地方。我把它们都总结在这里:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="65ad" class="nh kj it nd b be ni nj l nk nl">-- from:<br/>-- https://github.com/eventuate-tram/eventuate-tram-sagas/blob/master/postgres/tram-saga-schema.sql<br/><br/>CREATE SCHEMA IF NOT EXISTS eventuate;<br/><br/>DROP Table IF Exists eventuate.saga_instance_participants;<br/>DROP Table IF Exists eventuate.saga_instance;<br/>DROP Table IF Exists eventuate.saga_lock_table;<br/>DROP Table IF Exists eventuate.saga_stash_table;<br/>drop table if exists eventuate.message;<br/>drop table if exists eventuate.received_messages;<br/>drop table if exists eventuate.cdc_monitoring ;<br/><br/>CREATE TABLE eventuate.saga_instance_participants<br/>(<br/>    saga_type   VARCHAR(255) NOT NULL,<br/>    saga_id     VARCHAR(100) NOT NULL,<br/>    destination VARCHAR(100) NOT NULL,<br/>    resource    VARCHAR(100) NOT NULL,<br/>    PRIMARY KEY (saga_type, saga_id, destination, resource)<br/>);<br/><br/>CREATE TABLE eventuate.saga_instance<br/>(<br/>    saga_type       VARCHAR(255)  NOT NULL,<br/>    saga_id         VARCHAR(100)  NOT NULL,<br/>    state_name      VARCHAR(100)  NOT NULL,<br/>    last_request_id VARCHAR(100),<br/>    end_state       BOOLEAN,<br/>    compensating    BOOLEAN,<br/>    saga_data_type  VARCHAR(1000) NOT NULL,<br/>    saga_data_json  VARCHAR(1000) NOT NULL,<br/>    PRIMARY KEY (saga_type, saga_id)<br/>);<br/><br/>create table eventuate.saga_lock_table<br/>(<br/>    target    VARCHAR(100) PRIMARY KEY,<br/>    saga_type VARCHAR(255) NOT NULL,<br/>    saga_Id   VARCHAR(100) NOT NULL<br/>);<br/><br/>create table eventuate.saga_stash_table<br/>(<br/>    message_id      VARCHAR(100) PRIMARY KEY,<br/>    target          VARCHAR(100)  NOT NULL,<br/>    saga_type       VARCHAR(255)  NOT NULL,<br/>    saga_id         VARCHAR(100)  NOT NULL,<br/>    message_headers VARCHAR(1000) NOT NULL,<br/>    message_payload VARCHAR(1000) NOT NULL<br/>);<br/><br/>-- from<br/>-- https://github.com/eventuate-tram/eventuate-tram-core/blob/master/eventuate-tram-in-memory/src/main/resources/eventuate-tram-embedded-schema.sql<br/><br/><br/>CREATE TABLE eventuate.message<br/>(<br/>    ID            VARCHAR(1000) PRIMARY KEY,<br/>    DESTINATION   VARCHAR(1000) NOT NULL,<br/>    HEADERS       VARCHAR(1000) NOT NULL,<br/>    PAYLOAD       VARCHAR(1000) NOT NULL,<br/>    CREATION_TIME BIGINT,<br/>    PUBLISHED     BIGINT<br/>);<br/><br/><br/>CREATE TABLE eventuate.received_messages<br/>(<br/>    CONSUMER_ID   VARCHAR(1000),<br/>    MESSAGE_ID    VARCHAR(1000),<br/>    CREATION_TIME BIGINT,<br/>    PRIMARY KEY (CONSUMER_ID, MESSAGE_ID)<br/>);<br/><br/>create table eventuate.cdc_monitoring<br/>(<br/>    reader_id VARCHAR(1000) PRIMARY KEY,<br/>    last_time BIGINT<br/>);</span></pre><p id="871e" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">如果我们仔细看看消息表，我们可以看到CDC有效负载到Kafka的所有重要字段。我们需要ID，它由eventuate框架、报头、有效载荷在内部使用，我们使用published来确定消息是否已经发送给kafka。我选择0表示不发送，1表示已发送。这样，我们可以使用apache kafka库轻松地创建我们的kafka客户端:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="208f" class="nh kj it nd b be ni nj l nk nl">@SpringBootApplication<br/>@EnableScheduling<br/>open class CdcProcessLauncer(<br/>    private val messageRepository: MessageRepository,<br/>    @Value("\${org.jesperancinha.newscast.host.kafka.brokers}")<br/>    private val brokers: String<br/>) {<br/>    private val producer = KafkaProducerFactory.createProducer(brokers)<br/><br/><br/>    @Scheduled(cron = "0/5 * * ? * *")<br/>    fun fetchAndPublish() {<br/>        messageRepository.findAllByPublishedIs(0).forEach {<br/>            val objectMapper = ObjectMapper()<br/>            val headers = objectMapper.readTree(it.headers)<br/>            val command = KafkaCommand(it.payload, headers)<br/>            val commandPayload = objectMapper.writeValueAsString(command)<br/>            val record = ProducerRecord&lt;Long?, String?&gt;(it.destination, commandPayload)<br/>            producer.send(record).get()<br/>            messageRepository.save(it.copy(published = 1))<br/>            println("Sent: $commandPayload")<br/>        }<br/>    }<br/><br/>    companion object {<br/>        @JvmStatic<br/>        fun main(args: Array&lt;String&gt;) {<br/>            SpringApplication.run(CdcProcessLauncer::class.java, *args)<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="f302" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">4.2.传奇编舞</h1><p id="6df8" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">传奇编排非常依赖于事件和事件处理程序。对于代码应该如何干预，通常没有单一的定义结构:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/0e81acc93e0e644456b58aab435cbbe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q7QR6cHpsUOKg9HMNicGGQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Saga编排概述</figcaption></figure><p id="981a" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在上图中，我们看到我们有不同的事件，它们包装相同的类型。这是<strong class="li iu"> <em class="np">新闻播报评论</em> </strong>:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="a949" class="nh kj it nd b be ni nj l nk nl">data class NewsCastComments(<br/>    val idPage: Long? = null,<br/>    val pageComment: String? = null,<br/>    val idAuthor: Long? = null,<br/>    val authorComment: String? = null,<br/>    val idMessage: Long? = null,<br/>    val messageComment: String? = null,<br/>    var authorRequestId: Long? = null,<br/>    var pageRequestId:Long? = null,<br/>    var messageRequestId:Long? = null<br/>)</span></pre><p id="7fc2" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">如果我们希望我们的链像传奇一样，它需要共享相同的有效载荷。把这想象成一个食谱，你创造一种配料，让它流过你的食谱。它永远不会离开食谱，它可以被修改，但它会一直存在到最后。上面的整个模式可以用下面的代码简化:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="a90f" class="nh kj it nd b be ni nj l nk nl">class NewsCastEventConsumer(<br/>    private val domainEventPublisher: DomainEventPublisher,<br/>    private val newsCasePageCommentService: NewsCastPageCommentService,<br/>    private val newsCastAuthorCommentService: NewsCastAuthorCommentService,<br/>    private val newsCastMessageCommentService: NewsCastMessageCommentService,<br/>    private val pageService: PageService,<br/>    private val authorService: AuthorService,<br/>    private val messageService: MessageService,<br/><br/>    ) {<br/><br/>    private val logger = KotlinLogging.logger {}<br/><br/>    fun domainEventHandlers(): DomainEventHandlers {<br/>        return DomainEventHandlersBuilder<br/>            .forAggregateType("org.jesperancinha.newscast.saga.data.NewsCastComments")<br/>            .onEvent(NewsCastEvent::class.java, ::handleCreateNewsCastCommentEvent)<br/>            .onEvent(NewsCastPageCommentEvent::class.java, ::handleCreatePageCommentEvent)<br/>            .onEvent(NewsCastPageRejectCommentEvent::class.java, ::handleRejectPageCommentEvent)<br/>            .onEvent(NewsCastAuthorCommentEvent::class.java, ::handleCreateAuthorCommentEvent)<br/>            .onEvent(NewsCastAuthorRejectCommentEvent::class.java, ::handleRejectAuthorCommentEvent)<br/>            .onEvent(NewsCastMessageCommentEvent::class.java, ::handleCreateMessageCommentEvent)<br/>            .onEvent(NewsCastMessageRejectCommentEvent::class.java, ::handleRejectMessageCommentEvent)<br/>            .onEvent(NewsCastDoneEvent::class.java, ::handleDone)<br/>            .build()<br/>    }<br/>...<br/>}</span></pre></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="8283" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">4.3.Saga编排</h1><p id="9ff2" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">世家编排有着非常不同的形式，但与世家编排非常相似。在前一种情况下，所有的事件和处理程序都必须很好地相互编排。本质上，这就是它被如此称呼的原因。处理程序需要知道在每种情况下发送哪个事件。就Saga编排而言，有一个向前的计划和一个向后的计划。没有复杂的方法来定义回滚。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/73ebef6c5d10863ac89f858beda7c39f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_b7v0XuhyrPioNmMY3pjNw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Saga编排概述</figcaption></figure><p id="065c" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在上面的例子中，我们看到，当我们使用不同的参与者处理数据时，我们会经历不同的处理程序。在这种情况下，它们也会被触发，但不是由事件触发，而是由命令调用。它只是几乎做同样事情的另一个名字。</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="3fbd" class="nh kj it nd b be ni nj l nk nl">class CreateCommentSaga : SimpleSaga&lt;NewsCastComments&gt; {<br/>    private val logger = KotlinLogging.logger {}<br/><br/>    private val sagaDefinition = this.step()<br/>        .invokeLocal(this::startSaga)<br/>        .step()<br/>        .invokeParticipant(this::recordPageComment)<br/>        .onReply(PageComment::class.java, this::savedPageComment)<br/>        .withCompensation(this::rejectPageComment)<br/>        .onReply(PageComment::class.java, this::rejectedPageComment)<br/>        .step()<br/>        .invokeParticipant(this::recordAuthorComment)<br/>        .onReply(AuthorComment::class.java, this::savedAuthorComment)<br/>        .withCompensation(this::rejectAuthorComment)<br/>        .onReply(AuthorComment::class.java, this::rejectedAuthorComment)<br/>        .step()<br/>        .invokeParticipant(this::recordMessageComment)<br/>        .onReply(MessageComment::class.java, this::savedMessageComment)<br/>        .withCompensation(this::rejectMessageComment)<br/>        .onReply(MessageComment::class.java, this::rejectedMessageComment)<br/>        .step()<br/>        .invokeLocal(this::done)<br/>        .build()<br/><br/>    private fun startSaga(newsCastComments: NewsCastComments) = logger.info("Saga has started: $newsCastComments")<br/><br/>    private fun recordPageComment(newsCastComments: NewsCastComments): CommandWithDestination =<br/>        send(NewsCastPageCommand(<br/>            idPage = newsCastComments.idPage,<br/>            requestId = newsCastComments.pageRequestId,<br/>            comment = newsCastComments.pageComment<br/>        )).to("pageChannel").build()<br/>...<br/>}</span></pre></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="3154" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">5.运行示例</h1><p id="f9d5" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了运行此示例并测试一切是如何工作的，请运行:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="1611" class="nh kj it nd b be ni nj l nk nl">make docker-clean-build-start</span></pre><p id="958b" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">这个命令需要一段时间，它将构建整个项目，为docker映像准备二进制文件，并启动所有必要的容器。为了快速参考，这是所使用的docker-compose文件:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="80c3" class="nh kj it nd b be ni nj l nk nl">networks:<br/>  newscast:<br/><br/>services:<br/>  news_cast_postgres:<br/>    hostname: news_cast_postgres<br/>    container_name: news_cast_postgres<br/>    command: -c 'max_connections=400' -c 'shared_buffers=100MB'<br/>    build:<br/>      context: ./docker-files/docker-psql/.<br/>    environment:<br/>      - POSTGRES_USER=postgres<br/>      - POSTGRES_PASSWORD=admin<br/>      - POSTGRES_MULTIPLE_DATABASES=ncexplorer,eventuate<br/>    networks:<br/>      - newscast<br/>    deploy:<br/>      resources:<br/>        limits:<br/>          memory: 200M<br/>        reservations:<br/>          memory: 200M<br/>    healthcheck:<br/>      test: [ "CMD", "pg_isready", "-U", "postgres" ]<br/>      interval: 30s<br/>      timeout: 30s<br/>      retries: 10<br/>      start_period: 0s<br/><br/>  news_cast_kafka:<br/>    hostname: news_cast_kafka<br/>    container_name: news_cast_kafka<br/>    build:<br/>      context: ./docker-files/kafka/.<br/>    deploy:<br/>      resources:<br/>        limits:<br/>          memory: 1000M<br/>        reservations:<br/>          memory: 1000M<br/>    networks:<br/>      - newscast<br/>    depends_on:<br/>      news_cast_postgres:<br/>        condition: service_healthy<br/><br/>  news_cast_mock:<br/>    hostname: news_cast_mock<br/>    container_name: news_cast_mock<br/>    build:<br/>      context: news-cast-mock/.<br/>    restart: on-failure<br/>    networks:<br/>      - newscast<br/>    deploy:<br/>      resources:<br/>        limits:<br/>          memory: 400M<br/>        reservations:<br/>          memory: 400M<br/>    depends_on:<br/>      news_cast_postgres:<br/>        condition: service_healthy<br/><br/>  news_cast_cdc:<br/>    hostname: news_cast_cdc<br/>    container_name: news_cast_cdc<br/>    build:<br/>      context: news-cast-explorer-cdc/.<br/>    restart: on-failure<br/>    deploy:<br/>      resources:<br/>        limits:<br/>          memory: 300M<br/>        reservations:<br/>          memory: 300M<br/>    networks:<br/>      - newscast<br/>    depends_on:<br/>      news_cast_postgres:<br/>        condition: service_healthy<br/><br/>  news_cast_fetcher:<br/>    hostname: news_cast_fetcher<br/>    container_name: news_cast_fetcher<br/>    build:<br/>      context: news-cast-explorer-fetcher/.<br/>    deploy:<br/>      resources:<br/>        limits:<br/>          memory: 200M<br/>        reservations:<br/>          memory: 200M<br/>    networks:<br/>      - newscast<br/>    depends_on:<br/>      news_cast_postgres:<br/>        condition: service_healthy<br/>    healthcheck:<br/>      test: ["CMD", "curl", "--silent", "http:/127.0.0.1:8080/api/newscast/fetcher/actuator"]<br/>      interval: 5s<br/>      timeout: 240s<br/>      retries: 60<br/><br/>  news_cast_choreography:<br/>    hostname: news_cast_choreography<br/>    container_name: news_cast_choreography<br/>    build:<br/>      context: news-cast-explorer-saga-choreography/.<br/>    restart: on-failure<br/>    deploy:<br/>      resources:<br/>        limits:<br/>          memory: 300M<br/>        reservations:<br/>          memory: 300M<br/>    networks:<br/>      - newscast<br/>    depends_on:<br/>      news_cast_postgres:<br/>        condition: service_healthy<br/><br/>  news_cast_orchestration:<br/>    hostname: news_cast_orchestration<br/>    container_name: news_cast_orchestration<br/>    build:<br/>      context: news-cast-explorer-saga-orchestration/.<br/>    restart: on-failure<br/>    deploy:<br/>      resources:<br/>        limits:<br/>          memory: 300M<br/>        reservations:<br/>          memory: 300M<br/>    networks:<br/>      - newscast<br/>    depends_on:<br/>      news_cast_postgres:<br/>        condition: service_healthy<br/><br/>  news_cast_fe:<br/>    hostname: news_cast_fe<br/>    container_name: news_cast_fe<br/>    build:<br/>      context: docker-files/nginx/.<br/>    restart: on-failure<br/>    deploy:<br/>      resources:<br/>        limits:<br/>          memory: 300M<br/>        reservations:<br/>          memory: 300M<br/>    networks:<br/>      - newscast<br/>    depends_on:<br/>      news_cast_fetcher:<br/>        condition: service_healthy</span></pre><p id="f726" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">一旦一切开始，请前往<a class="ae mn" href="http://localhost:9000." rel="noopener ugc nofollow" target="_blank">T5 http://localhost:9000。</a>你会发现这样一个页面:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/4f4793f012d16f1388f738da63f12dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTowxnGotFzYoRtyyREm4Q.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">新闻广播浏览器的图形用户界面</figcaption></figure><p id="a9a8" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">一旦完成了这些，您就可以测试不同的编排类型了:</p><p id="4fc6" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">编排—端口8082:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="6d9d" class="nh kj it nd b be ni nj l nk nl">curl -X POST http://localhost:8082/api/saga/orchestration -H 'Content-Type: application/json' --data '{ "idPage": 1, "pageComment": "I love this", "idAuthor": 2, "authorComment": "This is my favourite author", "idMessage": 3, "messageComment": "I agree", "authorRequestId":123,"pageRequestId":456,"messageRequestId":789 }'</span></pre><p id="1f40" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">编排—端口8083:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="1b7f" class="nh kj it nd b be ni nj l nk nl">curl -X POST http://localhost:8083/api/saga/choreography -H 'Content-Type: application/json' --data '{ "idPage": 1, "pageComment": "I love this", "idAuthor": 2, "authorComment": "This is my favourite author", "idMessage": 3, "messageComment": "I agree", <br/>"authorRequestId":123,"pageRequestId":456,"messageRequestId":789 }'</span></pre><p id="b75d" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">检查端口5432上的PostgresSQL数据库和数据库<strong class="li iu"><em class="np">event</em></strong>，并检查<strong class="li iu"><em class="np">event</em></strong>模式和<strong class="li iu"> <em class="np"> public </em> </strong>模式中的表变化。也就是说，我们要查看<strong class="li iu"> <em class="np"> eventuate </em> </strong>模式中的表message、saga_instance和received_messages以及<strong class="li iu"> <em class="np"> public </em> </strong>模式中的所有注释表。让我们尝试不同的Id组合，看看会发生什么。</p><p id="0a58" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">只是为了提供一个例子，我现在将发送一个请求，我知道这将使整个传奇失败:</p><pre class="mp mq mr ms gt nc nd ne bn nf ng bi"><span id="130e" class="nh kj it nd b be ni nj l nk nl">curl -X POST http://localhost:8082/api/saga/orchestration -H 'Content-Type: application/json' --data '{ "idPage": 1, "pageComment": "I love this", "idAuthor": 2, "authorComment": "This is my favourite author", "idMessage": 999999, "messageComment": "I agree", "authorRequestId":200,"pageRequestId":500,"messageRequestId":800 }'</span></pre><p id="4e6a" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">这是因为我正在发送id为999999 <strong class="li iu">的消息。</strong>在当前的id生成系统中，获取这个id需要很长时间，所以我非常确定我们没有这个Id的消息。</p><p id="fc48" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">对于编排，我们将得到:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/d1e56c5a952c98b27093986b6f043c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDyHFsxRp3FDs87s8WlBOA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><strong class="bd kk"><em class="nw">Saga _ instance</em></strong>表中的saga注册</figcaption></figure><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/f986abc29492992661194b3b6cf33b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMx8EwHRqc4f9KFatqwRlQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">消息登记在<strong class="bd kk">消息<em class="nw">表</em>消息</strong>表中</figcaption></figure><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/9cbbd31cd8520ecce4d53e21aae7ca77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SY_RHXZQ_NLbBep7Xvaamw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">收到的消息登记在<strong class="bd kk"> <em class="nw">接收_消息</em> </strong>表中</figcaption></figure><p id="9a25" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">最后，我们可以看到当流程正确和不正确时，注释表会发生什么</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/b1f4ce9eba5768871ce9370d465f13d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6YTdZkbi-J1OtLdpPwLAw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><strong class="bd kk">页_注释</strong>表中的页表注释</figcaption></figure><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/f7fa3163cd94ef5bb5baf4b817c9b2d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8N2-3Pve836O8KkrTuowQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><strong class="bd kk">表中的作者表注释作者_注释</strong>表</figcaption></figure><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/9749b5c57b4f9a08ebe6c5dfe81d450b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q485LN_UwNjMD4c0Ysrzrg.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><strong class="bd kk">消息_注释</strong>表中的消息表注释</figcaption></figure><p id="cc60" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">我们也可以对编舞表做同样的事情。结果是非常相似的，所以我留给你去尝试。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="578e" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">8.结论</h1><p id="9a83" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们在这个例子中看到的，传奇是管理事务的一种很好的方式。他们以一种分离的方式工作，并且在他们的子流程中遵循A.C.I.D原则。它们为LLT延迟和性能下降提供了解决方案。</p><p id="b0f3" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">我们在这两种情况下都看到了优势:</p><p id="ff93" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">对于编排，我们看到没有工作流，这反过来可以减少性能开销。也不需要额外的框架来支持它。它是一种事件驱动的实现形式，允许以一种已知的方式实现不同系统元素之间的松散耦合。</p><p id="cfc4" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">对于流程编排，我们看到我们可以防止流程复杂化，因为它是命令驱动的，而不是事件驱动的。这意味着在实践中，编排将遵循内置的错误处理工作流。它能让我们更好地了解正在做的事情。因为它迫使我们遵循一个特定的标准，这个标准已经被测试和证明了，它也防止了代码中太多的定制变化，这些变化通常是容易出错的。</p><p id="2562" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">我已经将这个应用程序的所有源代码放在了<a class="ae mn" href="https://github.com/jesperancinha/news-cast-explorer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中</p><p id="2f3c" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">我希望你能像我喜欢写这篇文章一样喜欢它。我试着让它简洁明了，我忽略了许多小细节。</p><p id="4ed4" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">我很想听听你的想法，所以请在下面留下你的评论。</p><p id="18f8" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">提前感谢您的帮助，感谢您的阅读！</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="0dbc" class="ki kj it bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">参考</h1><div class="ob oc gp gr od oe"><a href="https://microservices.io/patterns/data/saga.html" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">微服务模式:Sagas</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">您已经按照服务模式应用了数据库。每个服务都有自己的数据库。一些商业交易…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">微服务. io</p></div></div><div class="on l"><div class="oo l op oq or on os jz oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://www.nicolaferraro.me/2018/04/25/saga-pattern-in-apache-camel/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">《阿帕奇骆驼》中的传奇模式</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">Apache Camel (2.21.0)中添加了一种新的企业集成模式:“Saga”模式。这篇文章将…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">www.nicolaferraro.me</p></div></div><div class="on l"><div class="ot l op oq or on os jz oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">Saga模式:使用微服务的应用事务</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">事务是应用程序的重要组成部分。没有它们，就不可能保持数据的一致性…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">blog.couchbase.com</p></div></div><div class="on l"><div class="ou l op oq or on os jz oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://docs.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">Saga分布式事务- Azure设计模式</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">saga设计模式是一种在分布式事务场景中跨微服务管理数据一致性的方法…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">docs.microsoft.com</p></div></div><div class="on l"><div class="ov l op oq or on os jz oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://nlogn.in/the-saga-pattern-for-distributed-transactions-in-microservices/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">微服务中分布式事务的SAGA模式</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">在一个整体架构中，所有的服务和数据库运行在同一个服务器上，因此很容易…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">n登录. in</p></div></div><div class="on l"><div class="ow l op oq or on os jz oe"/></div></div></a></div><p id="d122" class="pw-post-body-paragraph lg lh it li b lj mx ll lm ln my lp lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated"><a class="ae mn" href="https://www.ibm.com/cloud/architecture/architectures/event-driven-saga-pattern" rel="noopener ugc nofollow" target="_blank">https://www . IBM . com/cloud/architecture/architectures/event-driven-saga-pattern</a></p></div></div>    
</body>
</html>