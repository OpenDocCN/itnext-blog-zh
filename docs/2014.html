<html>
<head>
<title>Using React Hooks with Canvas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对画布使用React挂钩</h1>
<blockquote>原文：<a href="https://itnext.io/using-react-hooks-with-canvas-f188d6e416c0?source=collection_archive---------0-----------------------#2019-03-17">https://itnext.io/using-react-hooks-with-canvas-f188d6e416c0?source=collection_archive---------0-----------------------#2019-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/dacc0aaf389b295d73a2d64002c2ae23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*Y9rDBfi4l7Yv6k5i.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">这个应用程序并不能弥补我在绘画技巧上的不足</figcaption></figure><p id="dc9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我将使用React钩子创建一个html画布绘图网站。我将使用<em class="kw"> Create React App </em>初学者工具包从零开始。<a class="ae kx" href="https://han-hooks.netlify.com/" rel="noopener ugc nofollow" target="_blank">生成的应用</a>提供了<code class="fe ky kz la lb b">Clear</code>、<code class="fe ky kz la lb b">Undo</code>等基本功能，并使用本地存储保存图纸。</p><p id="edf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我将向您展示钩子如何使用<em class="kw">自定义钩子</em>来使有状态逻辑的组合和重用成为可能。</p><p id="99ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注:</strong>文章<a class="ae kx" href="https://blog.koenvangilst.nl/react-hooks-with-canvas/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">使用React挂钩与画布</strong> </a>最早出现在我自己的个人博客上。为了更好的阅读体验，我会推荐看看那个帖子，因为<em class="kw"> Medium不支持正确的语法高亮显示</em>。</p><h1 id="4651" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">基本设置</h1><p id="135a" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我们将从使用<code class="fe ky kz la lb b">create-react-app</code>创建一个新的React应用开始。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="b48d" class="mn ld iq lb b gy mo mp l mq mr">$ npx create-react-app canvas-and-hooks<br/>$ cd canvas-and-hooks/<br/>$ yarn start</span></pre><p id="e854" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的浏览器应该会打开<code class="fe ky kz la lb b">http://localhost:3000/</code>，您应该会看到一个旋转的React徽标。您现在可以开始了！</p><h1 id="3c32" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第一个挂钩:useRef</h1><p id="f63d" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">在您喜欢的编辑器中打开文件<code class="fe ky kz la lb b">src/App.js</code>,并用以下代码替换其中的内容:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="f6ee" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="efc9" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  return (<br/>    &lt;canvas<br/>      width={window.innerWidth}<br/>      height={window.innerHeight}<br/>      onClick={e =&gt; {<br/>        alert(e.clientX)<br/>      }}<br/>    /&gt;<br/>  )<br/>}</span><span id="711a" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="5771" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在打开的浏览器窗口中单击某处，现在应该会显示一个弹出警告，告诉您鼠标单击的x坐标。</p><p id="5c62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，成功了！</p><p id="c42a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们画点东西。为此，我们需要一个<code class="fe ky kz la lb b">ref</code>到画布元素，我们的第一个钩子<code class="fe ky kz la lb b">useRef</code>将帮助我们完成这个任务。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="26a9" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="c52c" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  const canvasRef = React.useRef(null)<br/>  return (<br/>    &lt;canvas<br/>      ref={canvasRef}<br/>      width={window.innerWidth}<br/>      height={window.innerHeight}<br/>      onClick={e =&gt; {        <br/>         const canvas = canvasRef.current        <br/>         const ctx = canvas.getContext('2d')        <br/>         // implement draw on ctx here<br/>      }}<br/>    /&gt;<br/>  )<br/>}</span><span id="1f38" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="376e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常在React中你不需要<code class="fe ky kz la lb b">ref</code>来更新一些东西，但是canvas不像其他DOM元素。大多数DOM元素都有一个类似于<code class="fe ky kz la lb b">value</code>的属性，可以直接更新。画布与允许你画东西的上下文(在我们的应用中是<code class="fe ky kz la lb b">ctx</code>)一起工作。为此，我们必须使用一个<code class="fe ky kz la lb b">ref</code>，它是对实际canvas DOM元素的引用。</p><p id="f30b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了画布背景，是时候画点什么了。为此，我将复制粘贴绘制SVG挂钩的代码。和钩子没什么关系，不完全理解也不用担心。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="4bb8" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="d2b1" class="mn ld iq lb b gy ms mp l mq mr">const HOOK_SVG =  'm129.03125 63.3125c0-34.914062-28.941406-63.3125-64.519531-63.3125-35.574219 0-64.511719 28.398438-64.511719 63.3125 0 29.488281 20.671875 54.246094 48.511719 61.261719v162.898437c0 53.222656 44.222656 96.527344 98.585937 96.527344h10.316406c54.363282 0 98.585938-43.304688 98.585938-96.527344v-95.640625c0-7.070312-4.640625-13.304687-11.414062-15.328125-6.769532-2.015625-14.082032.625-17.960938 6.535156l-42.328125 64.425782c-4.847656 7.390625-2.800781 17.3125 4.582031 22.167968 7.386719 4.832032 17.304688 2.792969 22.160156-4.585937l12.960938-19.71875v42.144531c0 35.582032-29.863281 64.527344-66.585938 64.527344h-10.316406c-36.714844 0-66.585937-28.945312-66.585937-64.527344v-162.898437c27.847656-7.015625 48.519531-31.773438 48.519531-61.261719zm-97.03125 0c0-17.265625 14.585938-31.3125 32.511719-31.3125 17.929687 0 32.511719 14.046875 32.511719 31.3125 0 17.261719-14.582032 31.3125-32.511719 31.3125-17.925781 0-32.511719-14.050781-32.511719-31.3125zm0 0'</span><span id="76e7" class="mn ld iq lb b gy ms mp l mq mr">const HOOK_PATH = new Path2D(HOOK_SVG)<br/>const SCALE = 0.3<br/>const OFFSET = 80</span><span id="df35" class="mn ld iq lb b gy ms mp l mq mr">function draw(ctx, location) {<br/>  ctx.fillStyle = 'deepskyblue'<br/>  ctx.shadowColor = 'dodgerblue'<br/>  ctx.shadowBlur = 20  ctx.save()<br/>  ctx.scale(SCALE, SCALE)  ctx.translate(location.x / SCALE - OFFSET, location.y / SCALE - OFFSET)<br/>  ctx.fill(HOOK_PATH)<br/>  ctx.restore()<br/>}</span><span id="eb44" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  const canvasRef = React.useRef(null)</span><span id="9d58" class="mn ld iq lb b gy ms mp l mq mr">  return (<br/>    &lt;canvas<br/>      ref={canvasRef}<br/>      width={window.innerWidth}<br/>      height={window.innerHeight}<br/>      onClick={e =&gt; {<br/>        const canvas = canvasRef.current<br/>        const ctx = canvas.getContext('2d')<br/>        draw(ctx, { x: e.clientX, y: e.clientY })<br/>      }}<br/>    /&gt;<br/>  )<br/>}</span><span id="a720" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="145c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这只是画一个SVG形状(一个鱼钩！)在位置<code class="fe ky kz la lb b">x</code>和<code class="fe ky kz la lb b">y</code>上。由于它与本教程无关，我将从现在开始省略它。</p><p id="b42d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">试试看，看有没有效果！</p><h1 id="b939" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第二个挂钩:使用状态</h1><p id="4cd9" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我们想添加的下一个功能是<code class="fe ky kz la lb b">Clean</code>和<code class="fe ky kz la lb b">Undo</code>按钮。为此，我们需要跟踪用户与<code class="fe ky kz la lb b">useState</code>钩子的交互。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="2bcf" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="e1fd" class="mn ld iq lb b gy ms mp l mq mr">// ...<br/>// canvas draw function<br/>// ...</span><span id="d916" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  const [locations, setLocations] = React.useState([])<br/>  const canvasRef = React.useRef(null)</span><span id="6e2e" class="mn ld iq lb b gy ms mp l mq mr">  return (<br/>    &lt;canvas<br/>      ref={canvasRef}<br/>      width={window.innerWidth}<br/>      height={window.innerHeight}<br/>      onClick={e =&gt; {<br/>        const canvas = canvasRef.current<br/>        const ctx = canvas.getContext('2d')<br/>        const newLocation = { x: e.clientX, y: e.clientY }<br/>        setLocations([...locations, newLocation])<br/>        draw(ctx, newLocation)<br/>      }}<br/>    /&gt;<br/>  )<br/>}</span><span id="c9e4" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="d4a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那里！我们在应用程序中添加了状态。您可以通过在<code class="fe ky kz la lb b">return</code>上方添加一个<code class="fe ky kz la lb b">console.log(locations)</code>来验证这一点。在控制台中，您应该会看到越来越多的用户点击。</p><h1 id="fb5b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第三个挂钩:使用效果</h1><p id="e0a5" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">目前我们没有对那个州做任何事情。我们就像以前一样画钩子。让我们看看如何用<code class="fe ky kz la lb b">useEffect</code>挂钩解决这个问题。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="2524" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="7c79" class="mn ld iq lb b gy ms mp l mq mr">// ...<br/>// canvas draw function<br/>// ...</span><span id="852a" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  const [locations, setLocations] = React.useState([])<br/>  const canvasRef = React.useRef(null)</span><span id="4829" class="mn ld iq lb b gy ms mp l mq mr">  React.useEffect(() =&gt; {<br/>    const canvas = canvasRef.current<br/>    const ctx = canvas.getContext('2d')<br/>    ctx.clearRect(0, 0, window.innerHeight, window.innerWidth)<br/>    locations.forEach(location =&gt; draw(ctx, location))<br/>  })</span><span id="30af" class="mn ld iq lb b gy ms mp l mq mr">  return (<br/>    &lt;canvas<br/>      ref={canvasRef}<br/>      width={window.innerWidth}<br/>      height={window.innerHeight}<br/>      onClick={e =&gt; {<br/>        const newLocation = { x: e.clientX, y: e.clientY }<br/>        setLocations([...locations, newLocation])<br/>      }}<br/>    /&gt;<br/>  )<br/>}</span><span id="c259" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="5c37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了很多事情，让我们来分析一下。我们已经将绘图功能从onClick处理程序转移到了<code class="fe ky kz la lb b">useEffect</code>回调函数中。这很重要，因为在画布上画画是由应用程序状态决定的副作用。稍后我们将使用localStorage添加持久性，这也是状态更新的副作用。</p><p id="7993" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还对画布上的实际绘图做了一些修改。在当前的实现中，每次渲染首先清除画布，然后绘制所有位置。我们可以比这更聪明，但为了简单起见，我将把它留给读者来进一步优化。</p><p id="acd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经完成了所有的艰苦工作，现在添加新功能应该很容易了。让我们创建<code class="fe ky kz la lb b">Clear</code>按钮。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="dd07" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="6f5f" class="mn ld iq lb b gy ms mp l mq mr">// ...<br/>// canvas draw function<br/>// ...</span><span id="303d" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  const [locations, setLocations] = React.useState([])<br/>  const canvasRef = React.useRef(null)</span><span id="9083" class="mn ld iq lb b gy ms mp l mq mr">  React.useEffect(() =&gt; {<br/>    const canvas = canvasRef.current<br/>    const ctx = canvas.getContext('2d')<br/>    ctx.clearRect(0, 0, window.innerHeight, window.innerWidth)<br/>    locations.forEach(location =&gt; draw(ctx, location))<br/>  })</span><span id="930c" class="mn ld iq lb b gy ms mp l mq mr">  function handleCanvasClick(e) {<br/>    const newLocation = { x: e.clientX, y: e.clientY }<br/>    setLocations([...locations, newLocation])<br/>  }</span><span id="8944" class="mn ld iq lb b gy ms mp l mq mr">  function handleClear() {<br/>    setLocations([])<br/>  }</span><span id="e2fa" class="mn ld iq lb b gy ms mp l mq mr">  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={handleClear}&gt;Clear&lt;/button&gt;<br/>      &lt;canvas<br/>        ref={canvasRef}<br/>        width={window.innerWidth}<br/>        height={window.innerHeight}<br/>        onClick={handleCanvasClick}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="1bf9" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="0598" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Clear特性只是一个简单的状态更新:我们通过将状态设置为空数组<code class="fe ky kz la lb b">[]</code>来清除状态。很简单，对吧？</p><p id="aa56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还利用这个机会清理了一下，将canvas <code class="fe ky kz la lb b">onClick</code>处理程序移动到一个单独的函数中。</p><p id="8bbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们做另一个特性:按钮。同样的原理，尽管这个状态更新有点复杂。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="dc77" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="69c4" class="mn ld iq lb b gy ms mp l mq mr">// ...<br/>// canvas draw function<br/>// ...</span><span id="67f4" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  const [locations, setLocations] = React.useState([])<br/>  const canvasRef = React.useRef(null)</span><span id="a917" class="mn ld iq lb b gy ms mp l mq mr">  React.useEffect(() =&gt; {<br/>    const canvas = canvasRef.current<br/>    const ctx = canvas.getContext('2d')<br/>    ctx.clearRect(0, 0, window.innerHeight, window.innerWidth)<br/>    locations.forEach(location =&gt; draw(ctx, location))<br/>  })</span><span id="b4ee" class="mn ld iq lb b gy ms mp l mq mr">  function handleCanvasClick(e) {<br/>    const newLocation = { x: e.clientX, y: e.clientY }<br/>    setLocations([...locations, newLocation])<br/>  }</span><span id="15f1" class="mn ld iq lb b gy ms mp l mq mr">  function handleClear() {<br/>    setLocations([])<br/>  }</span><span id="cc04" class="mn ld iq lb b gy ms mp l mq mr">  function handleUndo() {<br/>    setLocations(locations.slice(0, -1))<br/>  }</span><span id="dec2" class="mn ld iq lb b gy ms mp l mq mr">  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={handleClear}&gt;Clear&lt;/button&gt;<br/>      &lt;button onClick={handleUndo}&gt;Undo&lt;/button&gt;<br/>      &lt;canvas<br/>        ref={canvasRef}<br/>        width={window.innerWidth}<br/>        height={window.innerHeight}<br/>        onClick={handleCanvasClick}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="5165" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="3f6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为React中的任何状态更新都必须是不可修改的，所以我们不能使用类似于<code class="fe ky kz la lb b">locations.pop()</code>的东西从数组中删除最近的条目。我们必须在不改变原始<code class="fe ky kz la lb b">locations</code>数组的情况下完成。方法是使用<code class="fe ky kz la lb b">slice</code>，即将所有元素切掉，直到最后一个。您可以用<code class="fe ky kz la lb b">locations.slice(0, locations.length - 1)</code>来实现，但是<code class="fe ky kz la lb b">slice</code>足够聪明，可以将<code class="fe ky kz la lb b">-1</code>解释为数组中的最后一项。</p><p id="8144" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们继续之前，让我们清理html并添加一些css。在按钮周围添加以下<code class="fe ky kz la lb b">div</code>:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="d0fa" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="e247" class="mn ld iq lb b gy ms mp l mq mr">import './App.css'<br/>// ...<br/>// canvas draw function<br/>// ...</span><span id="8b2d" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  // ...</span><span id="7709" class="mn ld iq lb b gy ms mp l mq mr">  return (<br/>    &lt;&gt;<br/>      &lt;div className="controls"&gt;<br/>        &lt;button onClick={handleClear}&gt;Clear&lt;/button&gt;<br/>        &lt;button onClick={handleUndo}&gt;Undo&lt;/button&gt;<br/>      &lt;/div&gt;<br/>      &lt;canvas<br/>        ref={canvasRef}<br/>        width={window.innerWidth}<br/>        height={window.innerHeight}<br/>        onClick={handleCanvasClick}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="bc4f" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="a158" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并用以下内容替换<code class="fe ky kz la lb b">App.css</code>中的css:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="4176" class="mn ld iq lb b gy mo mp l mq mr">*,<br/>*:before,<br/>*:after {<br/>  box-sizing: border-box;<br/>}</span><span id="3656" class="mn ld iq lb b gy ms mp l mq mr">body {<br/>  background-color: black;<br/>}</span><span id="4466" class="mn ld iq lb b gy ms mp l mq mr">.controls {<br/>  position: absolute;<br/>  top: 0;<br/>  left: 0;<br/>}</span><span id="a0c9" class="mn ld iq lb b gy ms mp l mq mr">button {<br/>  height: 3em;<br/>  width: 6em;<br/>  margin: 1em;<br/>  font-weight: bold;<br/>  font-size: 0.5em;<br/>  text-transform: uppercase;<br/>  cursor: pointer;<br/>  color: white;<br/>  border: 1px solid white;<br/>  background-color: black;<br/>}</span><span id="a723" class="mn ld iq lb b gy ms mp l mq mr">button:hover {<br/>  color: black;<br/>  background-color: #00baff;<br/>}</span><span id="706e" class="mn ld iq lb b gy ms mp l mq mr">button:focus {<br/>  border: 1px solid #00baff;<br/>}</span><span id="3d3d" class="mn ld iq lb b gy ms mp l mq mr">button:active {<br/>  background-color: #1f1f1f;<br/>  color: white;<br/>}</span></pre><p id="18fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来不错，让我们开始下一个功能:坚持！</p><h1 id="e5c1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">添加本地存储</h1><p id="793f" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">如前所述，我们也希望我们的图纸被保存到<code class="fe ky kz la lb b">localStorage</code>。由于这是另一个副作用，我们将添加另一个<code class="fe ky kz la lb b">useEffect</code>。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="e3bf" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="59dd" class="mn ld iq lb b gy ms mp l mq mr">import './App.css'</span><span id="6dc0" class="mn ld iq lb b gy ms mp l mq mr">// ...draw function</span><span id="0b52" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  const [locations, setLocations] = React.useState(<br/>    JSON.parse(localStorage.getItem('draw-app')) || []  )<br/>  const canvasRef = React.useRef(null)</span><span id="e52e" class="mn ld iq lb b gy ms mp l mq mr">  React.useEffect(() =&gt; {<br/>    const canvas = canvasRef.current<br/>    const ctx = canvas.getContext('2d')<br/>    ctx.clearRect(0, 0, window.innerHeight, window.innerWidth)<br/>    locations.forEach(location =&gt; draw(ctx, location))<br/>  })</span><span id="a099" class="mn ld iq lb b gy ms mp l mq mr">  React.useEffect(() =&gt; {<br/>    localStorage.setItem('draw-app', JSON.stringify(locations))<br/>  })</span><span id="6d31" class="mn ld iq lb b gy ms mp l mq mr">  function handleCanvasClick(e) {<br/>    const newLocation = { x: e.clientX, y: e.clientY }<br/>    setLocations([...locations, newLocation])<br/>  }</span><span id="481b" class="mn ld iq lb b gy ms mp l mq mr">  function handleClear() {<br/>    setLocations([])<br/>  }</span><span id="0201" class="mn ld iq lb b gy ms mp l mq mr">  function handleUndo() {<br/>    setLocations(locations.slice(0, -1))<br/>  }</span><span id="f026" class="mn ld iq lb b gy ms mp l mq mr">  return (<br/>    &lt;&gt;<br/>      &lt;div className="controls"&gt;<br/>        &lt;button onClick={handleClear}&gt;Clear&lt;/button&gt;<br/>        &lt;button onClick={handleUndo}&gt;Undo&lt;/button&gt;<br/>      &lt;/div&gt;<br/>      &lt;canvas<br/>        ref={canvasRef}<br/>        width={window.innerWidth}<br/>        height={window.innerHeight}<br/>        onClick={handleCanvasClick}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="34df" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="4781" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在已经完成了我们计划构建的所有特性，但是我们还没有完成。关于钩子最酷的事情之一是你可以使用现有的钩子来组成新的定制钩子。让我通过创建一个定制的<code class="fe ky kz la lb b">usePersistentState</code>钩子来演示一下。</p><h1 id="8494" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第一个自定义挂钩:usePersistentState</h1><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="1918" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="f69b" class="mn ld iq lb b gy ms mp l mq mr">import './App.css'</span><span id="bf68" class="mn ld iq lb b gy ms mp l mq mr">// ...draw function</span><span id="ad25" class="mn ld iq lb b gy ms mp l mq mr">// our first custom hook!<br/>function usePersistentState(init) {<br/>  const [value, setValue] = React.useState(<br/>    JSON.parse(localStorage.getItem('draw-app')) || init<br/>  )</span><span id="6b07" class="mn ld iq lb b gy ms mp l mq mr">  React.useEffect(() =&gt; {<br/>    localStorage.setItem('draw-app', JSON.stringify(value))<br/>  })<br/>  return [value, setValue]}</span><span id="2de3" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  const [locations, setLocations] = usePersistentState([])<br/>  const canvasRef = React.useRef(null)</span><span id="bced" class="mn ld iq lb b gy ms mp l mq mr">  React.useEffect(() =&gt; {<br/>    const canvas = canvasRef.current<br/>    const ctx = canvas.getContext('2d')<br/>    ctx.clearRect(0, 0, window.innerHeight, window.innerWidth)<br/>    locations.forEach(location =&gt; draw(ctx, location))<br/>  })</span><span id="5865" class="mn ld iq lb b gy ms mp l mq mr">  function handleCanvasClick(e) {<br/>    const newLocation = { x: e.clientX, y: e.clientY }<br/>    setLocations([...locations, newLocation])<br/>  }</span><span id="f313" class="mn ld iq lb b gy ms mp l mq mr">  function handleClear() {<br/>    setLocations([])<br/>  }</span><span id="0300" class="mn ld iq lb b gy ms mp l mq mr">  function handleUndo() {<br/>    setLocations(locations.slice(0, -1))<br/>  }</span><span id="6a59" class="mn ld iq lb b gy ms mp l mq mr">  return (<br/>    // ...<br/>  )<br/>}</span><span id="213a" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="f9d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那里！我们已经创建了第一个定制钩子，所有与保存和从<em class="kw"> localStorage </em>获取状态相关的逻辑都是从<em class="kw"> App </em>组件中提取的。我们这样做是为了让钩子<code class="fe ky kz la lb b">usePersistentState</code>可以被其他组件重用。这里没有任何特定于这个组件的内容。</p><p id="f0b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们为与画布相关的逻辑重复这个技巧。</p><h1 id="8e94" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第二个自定义挂钩:usePersistentCanvas</h1><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="3cc6" class="mn ld iq lb b gy mo mp l mq mr">import React from 'react'</span><span id="737a" class="mn ld iq lb b gy ms mp l mq mr">import './App.css'</span><span id="4e12" class="mn ld iq lb b gy ms mp l mq mr">// ...draw function</span><span id="f6fd" class="mn ld iq lb b gy ms mp l mq mr">// our first custom hook<br/>function usePersistentState(init) {<br/>  const [value, setValue] = React.useState(<br/>    JSON.parse(localStorage.getItem('draw-app')) || init<br/>  )</span><span id="6bc3" class="mn ld iq lb b gy ms mp l mq mr">  React.useEffect(() =&gt; {<br/>    localStorage.setItem('draw-app', JSON.stringify(value))<br/>  })</span><span id="9080" class="mn ld iq lb b gy ms mp l mq mr">  return [value, setValue]<br/>}</span><span id="118f" class="mn ld iq lb b gy ms mp l mq mr">// our second custom hook: a composition of the first custom hook // and React's useEffect + useRef<br/>function usePersistentCanvas() {<br/>  const [locations, setLocations] = usePersistentState([])<br/>  <br/>  const canvasRef = React.useRef(null)<br/>  <br/>  React.useEffect(() =&gt; {<br/>    const canvas = canvasRef.current<br/>    const ctx = canvas.getContext('2d')<br/>    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight)<br/>    locations.forEach(location =&gt; draw(ctx, location))<br/>  })</span><span id="9fe8" class="mn ld iq lb b gy ms mp l mq mr">  return [locations, setLocations, canvasRef]<br/>}</span><span id="5bf1" class="mn ld iq lb b gy ms mp l mq mr">function App() {<br/>  const [locations, setLocations, canvasRef] = usePersistentCanvas()<br/>  function handleCanvasClick(e) {<br/>    const newLocation = { x: e.clientX, y: e.clientY }<br/>    setLocations([...locations, newLocation])<br/>  }</span><span id="fc26" class="mn ld iq lb b gy ms mp l mq mr">  function handleClear() {<br/>    setLocations([])<br/>  }</span><span id="02fb" class="mn ld iq lb b gy ms mp l mq mr">  function handleUndo() {<br/>    setLocations(locations.slice(0, -1))<br/>  }</span><span id="b3ce" class="mn ld iq lb b gy ms mp l mq mr">  return (<br/>    &lt;&gt;<br/>      &lt;div className="controls"&gt;<br/>        &lt;button onClick={handleClear}&gt;Clear&lt;/button&gt;<br/>        &lt;button onClick={handleUndo}&gt;Undo&lt;/button&gt;<br/>      &lt;/div&gt;<br/>      &lt;canvas<br/>        ref={canvasRef}<br/>        width={window.innerWidth}<br/>        height={window.innerHeight}<br/>        onClick={handleCanvasClick}<br/>      /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="44d9" class="mn ld iq lb b gy ms mp l mq mr">export default App</span></pre><p id="4a48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们的<em class="kw">应用</em>组件已经变得相当小了。所有与在localStorage中存储状态和在画布上绘图相关的逻辑都被提取到自定义钩子中。您可以通过将钩子移动到一个<em class="kw">钩子</em>文件中来进一步清理这个文件。这样，其他组件就可以重用这个逻辑，比如组成更好的钩子。</p><h1 id="14b0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="b5b5" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">如果将钩子与生命周期方法(如<code class="fe ky kz la lb b">componentDidMount</code>、<code class="fe ky kz la lb b">componentDidUpdate</code>)相比，是什么让它们如此特别？看上面的例子:</p><ul class=""><li id="ce68" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">钩子允许你在不同的组件中重用生命周期逻辑</li><li id="1f1b" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">有了钩子，你可以使用<strong class="ka ir">组合</strong>来创建更丰富的定制钩子，就像你可以使用组合来创建更丰富的UI组件一样</li><li id="ba5d" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">钩子变得更短、更干净——不再有臃肿、有时令人困惑的生命周期方法</li></ul><p id="31b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在判断钩子是否真的能解决所有这些问题还为时过早——以及它们可能会产生什么新的不良做法——但是看着上面的内容，我对React的未来感到非常兴奋和乐观！</p><p id="c522" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我知道你的想法！你可以在推特上用<a class="ae kx" href="https://twitter.com/vnglst" rel="noopener ugc nofollow" target="_blank"> @vnglst </a>联系我。</p><p id="4185" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://github.com/vnglst/react-hooks-canvas" rel="noopener ugc nofollow" target="_blank">Github上也有源代码。</a></p></div></div>    
</body>
</html>