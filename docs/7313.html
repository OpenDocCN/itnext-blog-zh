<html>
<head>
<title>Kubernetes Draining Nodes Properly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes正确排出节点</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-draining-nodes-properly-79e18dca4d5e?source=collection_archive---------2-----------------------#2022-08-18">https://itnext.io/kubernetes-draining-nodes-properly-79e18dca4d5e?source=collection_archive---------2-----------------------#2022-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/09d524a73bab045022526b6a8b34a454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLfAbgJEj05_oOscoAn6tA.png"/></div></div></figure><p id="1478" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我叫Guillermo Quiros，是topcloudops.com的一名AWS解决方案架构师和Kubernetes专家。</p><p id="fcdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我只想分享一些最佳实践，当我们的所有顾问需要在不中断他们所拥有的服务的情况下耗尽一个节点时，我们会强制执行这些实践。</p><p id="5bd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里要理解的主要事情是，如果我们耗尽一个节点，在该节点上运行的所有pod都将被终止。而不管群集中运行的副本数量是否正确。<br/>为了避免我们正在耗尽一个节点的情况，我们希望避免可能的服务中断，我们需要创建一个所谓的PodDisruptionBudget。</p><p id="dbfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一个包含两个节点(节点1和节点2)的环境，我们有一个这样的部署:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="81be" class="lg lh iq lc b gy li lj l lk ll">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: apache-deployment<br/>  labels:<br/>    app: webserver<br/>    name: webserver<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      app: webserver<br/>      name: webserver<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: webserver<br/>        name: webserver<br/>    spec:<br/>      containers:<br/>      - name: apache<br/>        image: fedora/apache<br/>        ports:<br/>        - containerPort: 80</span></pre><p id="783c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个部署的两个pod都在node1中运行。现在我们需要对node1进行维护，以升级机器的硬件。我们还要求我们的apache服务需要始终可用。</p><p id="795f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了确保在我们的集群上始终运行最少数量的Pods，我们将通过以下方式创建PodDisruptionBudget:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="adf4" class="lg lh iq lc b gy li lj l lk ll">apiVersion: policy/v1beta1<br/>kind: PodDisruptionBudget<br/>metadata:<br/>  name: apache-disruption-budget-min-available<br/>spec:<br/>  minAvailable: 2<br/>  selector:<br/>    matchLabels:<br/>      app: webserver</span></pre><p id="e15b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将告诉Kubernetes，无论发生什么情况，他需要确保我们总是有最小数量的符合标签的pod运行。</p><p id="6256" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以定义一个PDB，指定与标签匹配的不可用pod的最大百分比:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="502b" class="lg lh iq lc b gy li lj l lk ll">apiVersion: policy/v1beta1<br/>kind: PodDisruptionBudget<br/>metadata:<br/>  name: apache-disruption-budget-max-unavailable<br/>spec:<br/>  maxUnavailable: "50%"<br/>  selector:<br/>    matchLabels:<br/>      app: webserver</span></pre><p id="056d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们告诉Kubernetes不可用的apache pods的最大数量是1。</p><p id="cb0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，它被保存以开始清空节点1，我们将使用以下命令来完成此操作:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="f791" class="lg lh iq lc b gy li lj l lk ll">kubectl drain node1</span></pre><p id="1826" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">drain命令要做的第一件事是封锁节点，<strong class="ka ir">封锁</strong>禁用node1上的pods调度。一旦节点1被封锁，Kubernetes就开始驱逐pod，但要遵守系统上配置的pdb上定义的规则。</p><p id="665a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们希望在维护完成后再次启用节点1。我们需要记住运行<strong class="ka ir"> uncordon </strong>命令来允许在node1上调度pod。我们通过运行以下命令来实现这一点:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="dab3" class="lg lh iq lc b gy li lj l lk ll">kubectl uncordon node1</span></pre><p id="a495" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这对你有所帮助！</p></div></div>    
</body>
</html>