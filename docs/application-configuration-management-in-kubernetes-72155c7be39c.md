# Kubernetes 中的应用程序配置管理

> 原文：<https://itnext.io/application-configuration-management-in-kubernetes-72155c7be39c?source=collection_archive---------3----------------------->

[![](img/b3ac28d184e093b761392353eaa96628.png)](https://www.giantswarm.io/)

一般来说，云原生应用的特点是被打包到容器中的称为微服务的小型独立功能单元。将应用程序设计为微服务[有望带来许多好处](https://www.cio.com/article/3201193/7-reasons-to-switch-to-microservices-and-5-reasons-you-might-not-succeed.html)，但是部署它们需要很多仔细的考虑。

部署需要自动化、有弹性、可伸缩、可发现，等等。 [Kubernetes](https://kubernetes.io/) 集群通常是这些容器化工作负载的首选交付主机，因为它开箱即可满足所有这些运营要求。

Kubernetes [使用声明式模型](https://www.giantswarm.io/blog/understanding-basic-kubernetes-concepts-using-deployments-manage-services-declaratively)运行；用户定义想要的“世界状态”, Kubernetes 负责将世界的实际状态转换成想要的状态。定义“世界的状态”意味着定义一个应用程序以及它在集群中的运行方式。为了帮助解决这个问题，Kubernetes 公开了一个 API，它支持[许多不同的资源](https://kubernetes.io/docs/reference/kubectl/overview/#resource-types)，用于抽象工作负载以及它们应该运行的方式。这些资源的定义主要是由基于 YAML 的清单构成的，尽管也支持 JSON 定义。

对于负责定义云原生应用的 DevOps 团队来说，这意味着创建许多不同的 YAML 文件，或者包含多个定义的大型单个文件。离散服务的完整定义可能不仅包括工作负载抽象(如部署)，还包括名称空间、服务帐户、角色、角色绑定、服务、入口、配置映射、机密等等。当应用程序包含多个服务时，这些定义会成倍增加，当一个集群包含大量应用程序时，这些定义会迅速增加。

创作这些定义绝非易事，但管理它们的持续存在和发展也是一个挑战。这就是为什么以受控的方式管理这些定义很重要，这可以通过使用源代码版本控制系统，比如 [Git](https://git-scm.com/) 来轻松实现。当配置由于强制性应用的变更而漂移时，它提供了“单一的事实来源”,并且是开发运维团队熟悉的变更管理系统。

但是，在 Kubernetes 中，控制对期望状态的更改只是应用程序配置管理棘手问题的一个方面。

# 应用程序配置难题

是的，定义一个多服务应用程序的整个配置可能是繁重的，但是如果定义是受控的，并且它们的发展是受管理的，那么艰苦的工作是值得的。随着新特性和补丁在持续集成/交付(CI/CD)管道中的传播，修改后的定义会被测试、提交和应用，Kubernetes 会处理这些定义以可靠和安全地托管应用程序。

然而，当我们开始考虑如何在简单的部署场景之外使用应用程序时，问题就出现了。

**让我们考虑几个备选方案:**

虽然应用程序的定义对于每个环境应该保持基本不变，但是完全有理由认为每个环境都需要一些小的配置更改。一个环境中的服务可能使用配置映射来存储端点详细信息以访问测试数据库，而生产设置中的等效服务可能需要不同的配置映射用于生产数据库。

*我们如何在很大程度上提供相同的配置，但针对不同的环境进行调整？*

最简单的方法可能是为每个应用程序复制这个公共配置，但是有没有更微妙、更有效、更可组合的技术来处理这个问题呢？

*如何无缝更新共享配置，而无需返工每个单独受影响的项目？*

*组织如何确保始终遵循最佳实践？*

一个应用程序消费者会以一种方式运行应用程序，而另一个会以完全不同的方式运行。因此，提供一套单一的 YAML 定义是不够的。

*软件提供商如何在不损害最终用户可能需要的许多不同场景的情况下实现一组配置定义？*

这些都是需要解决的棘手问题，公平地说，在 Kubernetes 社区中没有普遍接受的解决方案。然而，有一些技术和工具试图解决这个难题，我们将在本系列接下来的文章中讨论这些。但是，首先，让我们来看看在 Kubernetes 中用来尝试和修复应用程序配置管理的一些方法。

# 配置管理的方法

通常，在 Kubernetes 中有四种不同的方法来处理应用配置管理。每次都试图解决配置难题的一个或多个方面。

**复制和定制**

这是迄今为止最简单的方法，只需要复制一个现有的有效定义。然后定义可以被定制以适合手边的目的。虽然这种方法利用了前人的努力，并且只涉及很少的工作来实现目标的适应性，但它也是最不灵活的。

如果最初的定义被认为是有问题的应用程序的“同类最佳”配置，那么它的作者随后的任何更改都很可能是重要的和相关的。复制和定制的副本将需要返工，以反映这些变化。消费者有责任监控上游的变化，并在发生变化时应用这些变化。

当这种方法被大规模采用时，它很快就站不住脚了，因此，它通常被认为是不切实际的。

**参数化模板**

在这种方法中，为应用程序提供了资源定义，但是它们被模板化以满足定制需求。插入到模板中的参数既可以使用相同的默认值，也可以应用用户提供的替代值。这迎合了应用程序的一般配置，但也允许在迎合替代场景方面的灵活性。所提供的灵活性水平与模板的参数化程度直接相关。

Helm package manager 是应用这种方法的社区工具的一个例子。

**叠加配置**

应用程序配置管理的另一种方法是使用覆盖配置。在这种方法中，提供了“基本”配置，它反映了应用程序的一般配置。但是，可以用定制配置的片段“覆盖”基本配置，以针对特定目的对定义进行细微调整。基底与覆盖层有效地合并在一起。这样，覆盖配置可以用于处理应用程序的多个部署场景。

Kustomize 就是这样一个覆盖配置工具，内置于本地 Kubernetes CLI ku bectl 中。

**程序化配置**

谈到应用程序配置管理，最后一个学派是编程学派。这种方法的本质是使用专门构建的领域特定语言(DSL)或更通用的编程语言。这使得能够为应用程序的配置创建默认定义，但也提供了用特定值替换默认配置项的功能。也许这种方法最吸引人的好处是能够使用熟悉的编程结构，如条件、循环和函数。编程配置还有助于配置定义的重用。

这种方法的例子包括 jk、Dhall、Cue、Tanka 和 Pulumi。

# 结论

Kubernetes 1.0 于 2015 年年中发布，虽然在这期间发生了很多变化，但其声明性模型仍然完全相同。尽管如此，应用程序配置管理难题的解决方案仍然存在。

多年来，各种工具和方法来来去去，或者至少经历了重大的功能变化，这一事实证明了这一点。社区内有丰富的活动、健康的辩论和许多强烈的观点，所有这些都预示着问题的最终解决。更好的是，我们可能最终会有几个可供选择的解决方案。

本文中强调的 Kubernetes 中的应用程序配置管理方法受到许多不同社区工具的支持。没有一种方法是对或错的，有许多不同的解决方案可供选择。在这一系列文章中，我们将仔细研究一些最流行和最有趣的技术，这些技术试图解决配置管理问题。

我们将探索以下工具，看看它们能提供什么，并了解它们的优缺点:

[**掌舵包经理**](https://www.giantswarm.io/blog/application-configuration-management-helm) **草泽
卡皮坦
坦卡
普鲁米**

敬请关注该系列的第一集，如果你有任何问题，请在 Twitter 上告诉我们！

由 [Puja Abbassi](https://twitter.com/puja108) 撰写——开发者倡导者@ [巨型群体](https://giantswarm.io/)

[](https://twitter.com/puja108) [## Puja Abbassi

### Puja Abbassi 的最新推文(@puja108)。开发者关系&产品@ GiantSwarm 研究员；主题…

twitter.com](https://twitter.com/puja108)