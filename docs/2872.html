<html>
<head>
<title>React — Micro-Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React —微型组件</h1>
<blockquote>原文：<a href="https://itnext.io/react-micro-components-2a8547dd253a?source=collection_archive---------4-----------------------#2019-08-19">https://itnext.io/react-micro-components-2a8547dd253a?source=collection_archive---------4-----------------------#2019-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4eba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">重新考虑你的JSX——停止使用div和类名</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b03c805fd01a58d65919daf7ac5b8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpp6ZBSNrqxIilM16hrt1g.jpeg"/></div></div></figure><p id="0d14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我将提出一种用React创建UI组件的思路，包括删除div和类名。这种思维方式的目标是简化创建UI组件的生产线(特别是使CSS-in-JS之类的事情变得更容易)。简而言之，这种思维方式包括将UI组件看作是具有name属性的微组件的集合，而不是具有classname属性的div的集合。</p><p id="4e9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个概念并不是全新的；BEM CSS命名惯例还包括将UI组件(<em class="ln">块</em>)视为<em class="ln">元素</em>的集合。事实上，我将采用BEM提供的许多理念，并将它们应用到React工作流中。</p><p id="10f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我继续之前，我想解决我认为创建UI模块时最重要的问题:</p><ul class=""><li id="fe82" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">相互作用</li><li id="ac2c" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">式样</li><li id="3f4b" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">配置</li><li id="39b4" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">主题</li></ul><p id="0587" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React并没有提供任何现成的解决方案来处理最后三个问题，但是使用<a class="ae lo" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">状态和钩子</a>可以很容易地处理<em class="ln">交互</em>。尽管如此，在创建UI组件时，我只剩下我认为的三个最高级别的关注点(如果不是<em class="ln">三个最高关注点的话)，没有标准的方法来大规模处理它们。如果你对什么是最重要的关注点有不同的看法，那么不管怎样，继续读下去，在很大程度上你可以把这些关注点去掉，这篇文章的前提仍然适用。但是对于这篇文章来说，在讨论样式时，我们将使用反应JSS。</em></p><p id="5075" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们考虑一个基本的功能组件示例，然后考虑我们可能希望如何向它公开样式、配置和我们项目的主题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1293" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">BEM告诉我们，每个UI组件都是作为一个抽象的<em class="ln">块</em>存在的，然后它可以有一些可选的子<em class="ln">元素</em>。通过以类似的方式观察我们的React组件，我们可以重新塑造我们的JSX，将常见的重复行为转移到引擎盖下。在探索<em class="ln">微型元件</em>的概念之前，让我们先来看看为什么我们可能需要它们。将我们的主题、风格和配置与上面的<code class="fe mf mg mh mi b">MyComponent</code>例子挂钩，可能会给我们留下类似下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="b014" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在CodeSandbox 上查看上述代码<a class="ae lo" href="https://codesandbox.io/s/rough-feather-fb8z1" rel="noopener ugc nofollow" target="_blank">的工作演示。让我们看看发生了什么…</a></p><ul class=""><li id="7461" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">该组件有一个元配置对象，作为一个需要评估的功能存在(并且需要项目的主题)</li><li id="d4f1" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">该项目的主题来自React-JSS的<code class="fe mf mg mh mi b">useTheme</code>钩子(我们必须导入)</li><li id="de43" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">我们的styles对象作为一个需要被传递以作出反应的函数存在——JSS的<code class="fe mf mg mh mi b">createUseStyles</code>实用程序(我们必须导入)——我们将其分配给一个<code class="fe mf mg mh mi b">useStyles</code>引用</li><li id="c13b" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">除了组件的道具之外，我们还想将组件的配置暴露给样式，所以我们将它们都传递给了<code class="fe mf mg mh mi b">useStyles</code>实例</li></ul><p id="6b43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是我可能期望看到的没有<em class="ln">微组件</em>或某种<em class="ln">包装组件</em>或第三方库的React UI组件的存在方式。虽然我们目前所拥有的并没有什么本质上的错误，但我认为这涉及到了相当多的设置(考虑对你所有的UI组件重复这个设置)。我想提出以下建议更好，我会解释为什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="554f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们限制自己将UI组件的JSX编写为最终要呈现的原始HTML标签(例如<code class="fe mf mg mh mi b">div</code>)时，我们每次都必须处理任何设置来预先获得它们相应的道具/参数(我们通常谈论的是<code class="fe mf mg mh mi b">className</code>或<code class="fe mf mg mh mi b">style</code>)。事实证明，对于您创建的每个UI组件来说，很多这样的设置通常是相同的，会产生重复，从而导致臃肿的JSX。</p><p id="b527" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在React思维中，您经常会遇到利用<code class="fe mf mg mh mi b">&lt;Provider&gt;</code>组件将数据传递给孩子的概念，通常是以<a class="ae lo" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> <em class="ln">上下文</em> </a>的形式(例如当使用主题或某些CSS-in-JS解决方案时)。我们可以同时使用类似于<code class="fe mf mg mh mi b">&lt;Block&gt;</code>组件的东西来<em class="ln">为后代组件提供</em>样式和配置之类的东西，同时还可以从同一个组件呈现一个DOM元素(这样就不需要每个UI组件都有一个单独的、专用的<em class="ln"> Provider </em>元素来提供样式之类的东西)。我们提供给<code class="fe mf mg mh mi b">&lt;Block&gt;</code>的值也可以在呈现父DOM元素时使用(<em class="ln">块</em>)。在引擎盖下，<code class="fe mf mg mh mi b">&lt;Block&gt;</code>和<code class="fe mf mg mh mi b">&lt;Component&gt;</code>组件自动执行我们之前手动执行的操作。如果我们使用一个原始的<code class="fe mf mg mh mi b">div</code>(或者一些其他的HTML元素)，我们将没有办法利用它的幕后道具。</p><p id="f39f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不管你如何区分UI组件的优先级，样式毫无疑问是最重要的。因此，当我们考虑React中样式化<code class="fe mf mg mh mi b">div</code>的实际需要时，当我们将主题化和配置之类的东西混合在一起，没有任何构造它们的约定，你最终会在你的UI组件中重复许多平凡的设置。通过将UI组件中的元素视为微组件(或任何您喜欢的词)而不是divs/HTML标签，我们可以将许多这种平凡的重复移到幕后，留下我们的源代码清洁器和JSX干燥器。我们所需要的就是创建我们的<code class="fe mf mg mh mi b">Block</code> / <code class="fe mf mg mh mi b">Component</code>组件来处理行为。</p><h2 id="cc49" class="mj mk iq bd ml mm mn dn mo mp mq dp mr la ms mt mu le mv mw mx li my mz na nb bi translated"><code class="fe mf mg mh mi b">&lt;Block&gt;</code> &amp; <code class="fe mf mg mh mi b">&lt;Component&gt;</code></h2><p id="9a58" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">我试图传达这些包装组件的具体性质是不相关的；重点是，通过以这种方式查看您的UI组件，您可以将您最终为每个UI组件及其子元素重复的任何工作/设置抽象到这些包装器中(每个包装器对应于一个呈现的DOM节点)。我提出样式、主题和配置是重要的关注点，并展示了在没有包装器的情况下，与它们相关的某些东西在多大程度上是容易重复的。以我们之前的例子为例，我将向您展示在这种情况下包装<code class="fe mf mg mh mi b">Block</code> / <code class="fe mf mg mh mi b">Component</code>组件可能是什么样子(尽管取决于您自己的关注点，可能会有所不同):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="381b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…以及:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="632b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在<a class="ae lo" href="https://codesandbox.io/s/btm1l" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>上观看现场演示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh me l"/></div></figure><h2 id="db77" class="mj mk iq bd ml mm mn dn mo mp mq dp mr la ms mt mu le mv mw mx li my mz na nb bi translated">结论</h2><p id="c9f7" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">通过将UI组件视为带有子<em class="ln">组件</em>的<em class="ln">块</em>，而不是HTML元素的集合，并为它们创建适当的包装器，您可以通过抽象与高度关注的事情相关的设置代码来简化创建UI组件的过程，例如主题化、样式化、上下文和配置，否则这些会在UI组件之间重复。</p><h2 id="e295" class="mj mk iq bd ml mm mn dn mo mp mq dp mr la ms mt mu le mv mw mx li my mz na nb bi translated">进一步的想法</h2><p id="28fb" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">查看我就类似主题撰写的其他文章:</p><ul class=""><li id="3173" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated"><a class="ae lo" href="https://medium.com/@ESR360/props-state-config-theming-based-styling-with-react-jss-ce06f70985de" rel="noopener">道具，状态，配置&amp;基于主题的造型，带反应JSS </a></li><li id="17ca" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated"><a class="ae lo" href="https://levelup.gitconnected.com/lifting-props-up-f1be43a1d7a4" rel="noopener ugc nofollow" target="_blank">提升道具—使用React的上下文API访问父道具</a></li><li id="8d35" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated"><a class="ae lo" href="https://medium.com/valtech-design/creating-scalable-uis-theming-configuration-d49d6c22654c" rel="noopener">创建可伸缩的ui:主题化&amp;配置</a></li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/0f4eaa82f76695a20f09ba4fa9fd37ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbifSkjSDCs7zGgIwXMiwg.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated"><a class="ae lo" href="https://twitter.com/esr360" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae lo" href="https://github.com/esr360" rel="noopener ugc nofollow" target="_blank"> Github </a></figcaption></figure></div></div>    
</body>
</html>