<html>
<head>
<title>Getting started with Protobuffer and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Protobuffer和Python入门</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-protobuffer-and-python-2ea749924412?source=collection_archive---------0-----------------------#2021-05-13">https://itnext.io/getting-started-with-protobuffer-and-python-2ea749924412?source=collection_archive---------0-----------------------#2021-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aa6d92f2d3c47347bf0fa23040fc907d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2Be20iO3w0iuSlFR.png"/></div></div></figure><p id="d6d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将讨论<a class="ae kw" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> Proto Buffers </a>以及如何在Python中使用它们在网络间传递消息。简而言之，协议缓冲区或<em class="kx"> Porobuf </em>用于数据序列化和反序列化。在讨论Protobuf之前，我想先讨论一下数据序列化和序列化。</p><h1 id="e5b2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数据序列化和反序列化</h1><p id="d848" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">根据维基百科</p><blockquote class="mb mc md"><p id="189c" class="jy jz kx ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">串行化是将<a class="ae kw" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>或<a class="ae kw" href="https://en.wikipedia.org/wiki/Object_(computer_science)" rel="noopener ugc nofollow" target="_blank">对象</a>状态转换成可以存储(例如，在<a class="ae kw" href="https://en.wikipedia.org/wiki/Computer_file" rel="noopener ugc nofollow" target="_blank">文件</a>或内存<a class="ae kw" href="https://en.wikipedia.org/wiki/Data_buffer" rel="noopener ugc nofollow" target="_blank">数据缓冲区</a>中)或传输(例如，通过<a class="ae kw" href="https://en.wikipedia.org/wiki/Computer_network" rel="noopener ugc nofollow" target="_blank">计算机网络</a>)的格式，并在以后重构(可能在不同的计算机环境中)</p></blockquote><p id="536f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，您将简单和复杂的数据结构和对象转换成字节流，以便它们可以传输到其他机器或存储在某些存储器中。</p><p id="78af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据反序列化是恢复原始格式以备将来使用的相反过程。</p><p id="f5cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据序列化和数据序列化都不是谷歌发明的。大多数编程语言都支持它。Python提供<a class="ae kw" href="https://docs.python.org/3/library/pickle.html#:~:text=%E2%80%9CPickling%E2%80%9D%20is%20the%20process%20whereby,back%20into%20an%20object%20hierarchy." rel="noopener ugc nofollow" target="_blank"> pickle </a>，PHP提供<a class="ae kw" href="https://www.w3schools.com/php/func_var_serialize.asp" rel="noopener ugc nofollow" target="_blank"> serialize </a>函数。类似地，许多其他语言也提供了类似的功能。问题是这些序列化/反序列化机制没有标准化，只有当源和目标使用相同的语言时才有用。需要一种标准格式，可以在整个系统中使用，而不管底层的编程语言是什么。</p><p id="a8f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能会想，嘿，为什么不直接使用XML或JSON呢？问题是，这些格式是文本形式，如果数据结构很大，它们可能会变得很大，如果通过网络发送，可能会使事情变得很慢。<em class="kx">另一方面，Protobuf </em>是二进制格式，如果发送大量数据，其大小可能会更小。</p><p id="eb39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，Protobuf不是第一个二进制格式的数据序列化格式。<a class="ae kw" href="https://bsonspec.org/" rel="noopener ugc nofollow" target="_blank">MongoDB开发的BSON </a>(二进制JSON)和<a class="ae kw" href="https://msgpack.org/index.html" rel="noopener ugc nofollow" target="_blank"> MessagePack </a>也支持这样的设施。</p><p id="bf88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谷歌的Protobuf不仅仅是数据交换。它还提供了一组规则来定义和交换这些消息。除此之外，它还被大量用于gRPC，Google的方式<em class="kx">远程过程调用</em>。因此，如果你计划用任何编程语言在gRPC上工作，你必须有写<code class="fe mh mi mj mk b">.proto</code>文件的想法。</p><h1 id="dc77" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">装置</h1><p id="a57b" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">为了使用基于<code class="fe mh mi mj mk b">.proto</code>的消息，你必须在你的机器上安装一个原型编译器，你可以根据你的操作系统从<a class="ae kw" href="https://github.com/protocolbuffers/protobuf/releases" rel="noopener ugc nofollow" target="_blank">这里</a>下载。由于我在macOS上，我就简单的用<em class="kx">自制</em>安装了。一旦安装正确，你可以运行命令<code class="fe mh mi mj mk b">protoc --version</code>来测试版本。截至目前，我的机器上安装的是最新版本的<code class="fe mh mi mj mk b">libprotoc 3.9.1</code>。</p><p id="c3bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们编写第一个原型消息。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/592c8510ebc08d4f11829487bdc643e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/0*U_-Z6dYKZspev5y_.png"/></div></figure><p id="ab8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一行指出您应该使用哪个版本的<em class="kx"> protobuf </em>消息。如果你不指定一个，它将是版本2。第二行是关于包装你的信息，以避免任何冲突。对于这个特别的消息，你可以忽略它。代码生成后，<code class="fe mh mi mj mk b">package</code>行在不同的编程语言中表现不同。在Python中，它没有任何区别，而在Go和Java语言中，它被用作包名，而在C++中，它被用作名称空间。</p><p id="098e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一行以<code class="fe mh mi mj mk b">message</code>开始，后跟消息类型。在我们的例子中是<code class="fe mh mi mj mk b">Employee</code>。然后，它由字段及其类型组成。例如，它是<code class="fe mh mi mj mk b">string</code>和<code class="fe mh mi mj mk b">int32</code>类型字段。如果你使用过像C和Go这样的语言，你会发现它和<code class="fe mh mi mj mk b">struct</code>很相似。</p><p id="7d7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里提到了两个字段:<code class="fe mh mi mj mk b">string</code>类型的<code class="fe mh mi mj mk b">Name</code>和<code class="fe mh mi mj mk b">int32</code>类型的<code class="fe mh mi mj mk b">age</code>。您可以通过在数据类型名称前添加<code class="fe mh mi mj mk b">required</code>来使字段成为强制字段。默认情况下都是<code class="fe mh mi mj mk b">optional</code>。有三种类型的规则:</p><ul class=""><li id="e557" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated"><em class="kx">必填</em> :-表示该字段为必填。</li><li id="130b" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><em class="kx">可选</em> :-您可以离开该字段。</li><li id="e48b" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><em class="kx">重复</em>:该字段可以重复0次或多次。</li></ul><p id="0c9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会注意到每个字段都被分配了一个编号。这不是一个典型的变量赋值，而是用于标记识别和<a class="ae kw" href="https://developers.google.com/protocol-buffers/docs/encoding" rel="noopener ugc nofollow" target="_blank">编码</a>目的。只是澄清一下，这种编号<a class="ae kw" href="https://developers.google.com/protocol-buffers/docs/encoding#order" rel="noopener ugc nofollow" target="_blank">并不像许多人建议的那样是出于排序的目的</a>，你不能保证这些字段将以何种顺序编码。</p><p id="ff15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，消息已经准备好了，现在我们必须序列化它。为此，我们将使用<code class="fe mh mi mj mk b">protoc</code>编译器，它可以生成多种语言的代码。由于我使用的是Python，所以我将使用以下命令:</p><p id="13d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">protoc -I=. --python_out=. ./test.proto</code></p><ul class=""><li id="0314" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated"><strong class="ka ir"> -I </strong>用于查找各种依赖关系和原型文件的路径。我提到了一个点(。)获取当前目录。</li><li id="df7c" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><strong class="ka ir"> -python_out </strong>用于存储生成的python文件的路径。同样，它是在当前文件夹中生成的。</li><li id="6c00" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">最后一个未命名的参数是传递原型文件路径。</li></ul><p id="f599" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当它运行时，它生成一个格式为<strong class="ka ir"> &lt;的文件，原始文件名&gt; _pb2.py. </strong>在我们的例子中，它是<code class="fe mh mi mj mk b">test.proto</code>，所以生成的文件名是<code class="fe mh mi mj mk b">test_pb2.py</code>。</p><p id="736f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时您不需要担心生成的文件。现在，你所要关心的是如何使用这个文件。我正在创建一个新文件，<code class="fe mh mi mj mk b">test.py</code>，它包含以下代码:</p><pre class="mm mn mo mp gt ne mk nf ng aw nh bi"><span id="5268" class="ni kz iq mk b gy nj nk l nl nm">import test_pb2 as Test</span><span id="03a4" class="ni kz iq mk b gy nn nk l nl nm">obj = Test.Employees()<br/>obj.Name = 'Adnan'<br/>obj.age = 20<br/>print(obj.SerializeToString())</span></pre><p id="fa63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很简单。我导入了生成的文件，并从那里实例化了<code class="fe mh mi mj mk b">Employees</code>对象。这个<code class="fe mh mi mj mk b">Employees</code>来自我们在<code class="fe mh mi mj mk b">.proto</code>文件中定义的消息类型。然后，您只需为字段赋值。最后一行是打印对象值。当我运行程序时，它会打印:</p><p id="531c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">b'\n\x05Adnan\x10\x14'</code></p><p id="911d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我把年龄设为字符串呢？它给出了错误:</p><pre class="mm mn mo mp gt ne mk nf ng aw nh bi"><span id="f049" class="ni kz iq mk b gy nj nk l nl nm">Traceback (most recent call last):<br/>  File "test.py", line 5, in &lt;module&gt;<br/>    obj.age = "20"<br/>TypeError: '20' has type str, but expected one of: int, long</span></pre><p id="7858" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太棒了，所以它也在验证是否传递了正确的数据。现在让我们将这个输出保存在一个二进制文件中。</p><p id="2342" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们用JSON格式保存类似的东西呢？代码现在看起来如下所示:</p><pre class="mm mn mo mp gt ne mk nf ng aw nh bi"><span id="181f" class="ni kz iq mk b gy nj nk l nl nm">import test_pb2 as Test</span><span id="8f65" class="ni kz iq mk b gy nn nk l nl nm">obj = Test.Employees()<br/>obj.Name = 'Adnan'<br/>obj.age = 20<br/>print(obj.SerializeToString())</span><span id="ec5d" class="ni kz iq mk b gy nn nk l nl nm">with open('output.bin','wb') as f:<br/>    f.write(obj.SerializeToString())</span><span id="2bcb" class="ni kz iq mk b gy nn nk l nl nm">json_data = '{"Name": "Adnan","Age": 20}'</span><span id="02e5" class="ni kz iq mk b gy nn nk l nl nm">with open('output.json','w',encoding='utf8') as f:<br/>    f.write(json_data)</span></pre><p id="d1cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我做一个<code class="fe mh mi mj mk b">ls - la</code>，结果如下:</p><pre class="mm mn mo mp gt ne mk nf ng aw nh bi"><span id="c9bc" class="ni kz iq mk b gy nj nk l nl nm">➜  LearningProtoBuffer ls -l output*<br/>-rw-r--r--  1 AdnanAhmad  staff   9 May 13 18:05 output.bin<br/>-rw-r--r--  1 AdnanAhmad  staff  27 May 13 18:05 output.json</span></pre><p id="4da6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JSON one的大小为<strong class="ka ir"> 27字节</strong>，而<em class="kx"> protobuf </em> one仅占用<strong class="ka ir"> 9字节</strong>。你很容易就能看出谁是赢家。想象一下发送一个JSONified数据流，它肯定会增加延迟。通过以二进制格式发送数据，你可以压缩许多字节，提高系统的效率。</p><h1 id="57bd" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="d723" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在这篇文章中，您了解了如何使用协议缓冲区高效地发送和存储大量数据，协议缓冲区可以生成多种语言的代码，从而使数据交换更加容易，而不必担心底层编程语言。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="c583" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">原载于2021年5月13日</em><a class="ae kw" href="http://blog.adnansiddiqi.me/getting-started-with-protobuffer-and-python/" rel="noopener ugc nofollow" target="_blank"><em class="kx">http://blog . adnansiddiqi . me</em></a><em class="kx">。</em></p></div></div>    
</body>
</html>