<html>
<head>
<title>Promise loading with Three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Promise用Three.js加载</h1>
<blockquote>原文：<a href="https://itnext.io/promise-loading-with-three-js-78a6297652a5?source=collection_archive---------2-----------------------#2018-04-30">https://itnext.io/promise-loading-with-three-js-78a6297652a5?source=collection_archive---------2-----------------------#2018-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c763" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一篇关于我最近使用(原生)ES6承诺简化Three.js项目中加载处理的经验的快速帖子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f1bd50b805e531ee862f559ec42eaac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MNcMKEek_Y8q9_HHyNewQ.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="80aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过Three.js示例，加载几何体和相应纹理的常见模式如下所示:</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="f057" class="lj lk iq lf b gy ll lm l ln lo">const material = new THREE.MeshStandardMaterial({<br/>  map: new THREE.TextureLoader().load('map.jpg'),<br/>  normalMap: new THREE.TextureLoader().load('normalMap.jpg')<br/>});</span><span id="0770" class="lj lk iq lf b gy lp lm l ln lo">const loader = new THREE.JSONLoader();</span><span id="2063" class="lj lk iq lf b gy lp lm l ln lo">loader.load('geometry.json', geometry =&gt; {<br/>  const mesh = new THREE.Mesh(geometry, material);<br/>  <br/>  scene.add(mesh);<br/>});</span></pre><p id="1d1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lq lr ls lf b">TextureLoader.load()</code>返回一个纹理，当图像加载时更新。向<code class="fe lq lr ls lf b">JSONLoader.load()</code>传递一个onComplete回调，在JSON被加载和处理时调用这个回调。当回调被调用时，一个网格被创建，无论纹理是否被加载。</p><p id="33e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时这种行为是需要的；你要尽快向<em class="lt">展示一些东西</em>。但也有一些问题，我相信你们以前都见过。如果几何图形在纹理之前加载，在纹理一个接一个弹出之前，模型看起来是无纹理的，<em class="lt">裸露的</em>。当它们被处理并上传到GPU时，会有明显的丢帧现象。</p><p id="35fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，使用<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>很容易解决这些问题。</p><p id="8f9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们围绕一个<code class="fe lq lr ls lf b">JSONLoader</code>和一个<code class="fe lq lr ls lf b">Promise</code>创建一个包装函数。</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="3fc7" class="lj lk iq lf b gy ll lm l ln lo">function loadJSON(url) {<br/>  return new Promise(resolve =&gt; {<br/>    new THREE.JSONLoader.load(url, resolve);<br/>  });<br/>}</span></pre><p id="aca3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数返回一个承诺，在加载文件时，该承诺将与加载的几何图形一起解析。</p><p id="5be7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们可以在一个<code class="fe lq lr ls lf b">TextureLoader</code>周围做一个类似的包装。</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="ed50" class="lj lk iq lf b gy ll lm l ln lo">function loadJSON(url) {<br/>  return new Promise(resolve =&gt; {<br/>    new THREE.TextureLoader().load(url, resolve);<br/>  });<br/>}</span></pre><p id="b679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，<code class="fe lq lr ls lf b">TextureLoader</code>也有一个类似于<code class="fe lq lr ls lf b">TextureLoader</code>的onComplete回调，尽管使用频率较低。事实上，我非常确定所有三个. js加载器都符合这个约定。</p><p id="dad1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们围绕纹理承诺编写另一个包装器，它将通过一个Material实例来解决。</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="2e0b" class="lj lk iq lf b gy ll lm l ln lo">function loadMaterial() {<br/>  const textures = {<br/>    map: 'map.jpg',<br/>    normalMap: 'normalMap.jpg'<br/>  };<br/>  <br/>  const params = {};<br/>  <br/>  const promises = Object.keys(textures).map(key =&gt; {<br/>    return loadTexture(textures[key]).then(texture =&gt; {<br/>      params[key] = texture;  <br/>    });<br/>  });<br/>  <br/>  return Promise.all(promises).then(() =&gt; {<br/>    return new THREE.MeshStandardMaterial(params);<br/>  });<br/>}</span></pre><p id="0605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lq lr ls lf b"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">Promise.all()</a></code>接受一个承诺数组，并返回一个承诺，该承诺在所有子承诺都解析后解析。</p><p id="aba7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们可以将几何和材料承诺包装器组合成一个最终的majestic包装器函数，再次依赖于<code class="fe lq lr ls lf b">Promise.all()</code>。</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="5f7e" class="lj lk iq lf b gy ll lm l ln lo">function loadMesh() {<br/>  const promises = [<br/>    loadGeometry(),<br/>    loadMaterial()<br/>  ];<br/>  <br/>  return Promise.all(promises).then(result =&gt; {<br/>    return new THREE.Mesh(result[0], result[1]);<br/>  });<br/>}</span></pre><p id="d429" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lq lr ls lf b">Promise.all()</code>以与您提供的承诺(或值)顺序相同的值数组进行解析。在这种情况下，<code class="fe lq lr ls lf b">result</code>数组看起来像<code class="fe lq lr ls lf b">[geometry, material]</code>。</p><p id="0b23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用上面的代码，我们基本上创建了一个迷你加载管理器，一旦所有的资产都被加载，它就创建一个网格，所有的都使用很少的(本地)JavaScript。干净利落。</p><p id="b0dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再充实一点。下面的代码只是实现这一点的许多可能方法中的一种。</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="cff8" class="lj lk iq lf b gy ll lm l ln lo">const model = {<br/>  geometry: {<br/>    url: 'geometry.json'<br/>  },<br/>  material: {<br/>    map: 'map.jpg',<br/>    normalMap: 'normalMap.jpg',<br/>    metalness: 0.0,<br/>    roughness: 1.0<br/>  }<br/>};</span><span id="b9a3" class="lj lk iq lf b gy lp lm l ln lo">loadMesh(model).then(mesh =&gt; {<br/>  scene.add(mesh);<br/>});</span><span id="12f0" class="lj lk iq lf b gy lp lm l ln lo">function loadMesh(model) {<br/>  const promises = [<br/>    loadGeometry(model.geometry),<br/>    loadMaterial(model.material)<br/>  ];<br/>  <br/>  return Promise.all(promises).then(result =&gt; {<br/>    return new THREE.Mesh(result[0], result[1]);<br/>  });<br/>}<br/><br/>function loadGeometry(model) {<br/>  return new Promise(resolve =&gt; {<br/>    new THREE.JSONLoader().load(model.url, resolve);<br/>  });<br/>}<br/><br/>const textureKeys = ['map', 'normalMap']; // etc...<br/><br/>function loadMaterial(model) {<br/>  const params = {};<br/>  const promises = Object.keys(model).map(key =&gt; {<br/>    // load textures for supported keys<br/>    if (textureKeys.indexOf(key) !== -1) {<br/>      return loadTexture(model[key]).then(texture =&gt; {<br/>        params[key] = texture;<br/>      });<br/>    // just copy the value otherwise  <br/>    } else {<br/>      params[key] = model[key];<br/>    }<br/>  });<br/>  <br/>  return Promise.all(promises).then(() =&gt; {<br/>    return new THREE.MeshStandardMaterial(params);<br/>  });<br/>}</span></pre><p id="013c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lq lr ls lf b">model</code>描述网格的资产和任何附加设置。这是一个有用的抽象。我们可以创建许多模型，并使用上面的代码来创建相应的网格。如果你需要同时管理多个型号，可以很容易地将<code class="fe lq lr ls lf b">createMesh</code>功能放到另一个<code class="fe lq lr ls lf b">Promise.all()</code>中。从头到尾都是承诺。</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="53ed" class="lj lk iq lf b gy ll lm l ln lo">const promises = models.map(model =&gt; {<br/>  return loadMesh(model).then(mesh =&gt; {<br/>    scene.add(mesh);<br/>  });<br/>});</span><span id="acaa" class="lj lk iq lf b gy lp lm l ln lo">Promise.all(promises).then(() =&gt; {<br/>  // load complete! begin rendering<br/>});</span></pre><p id="5572" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法的另一个好处是，可以用现有的或缓存的值来解决承诺，而无需对我们的API进行任何更改。这使得混合加载的和生成的资产变得容易。</p><pre class="km kn ko kp gt le lf lg lh aw li bi"><span id="79f8" class="lj lk iq lf b gy ll lm l ln lo">const model = {<br/>  geometry: {<br/>    geometry: new THREE.SphereGeometry()<br/>  },<br/>  material: {...}<br/>};<br/><br/>...<br/><br/>function loadGeometry(model) {<br/>  if (model.geometry) {<br/>    return Promise.resolve(model.geometry);<br/>  }<br/>  <br/>  if (model.url) {<br/>    return new Promise(resolve =&gt; {<br/>      new JSONLoader().load(model.url, resolve);<br/>    });  <br/>  }<br/>}</span></pre><p id="52e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些年来，我写了一些加载管理器，我可以告诉你，承诺大大简化了事情。您仍然需要添加自己的逻辑(缓存、错误处理、不同的加载器、附加参数等)，但是不必自己处理并发的异步请求可以节省大量时间。</p><p id="19a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的片段可以在<a class="ae lu" href="https://gist.github.com/zadvorsky/a79787a4703ecc74cab2fdbd05888e9b" rel="noopener ugc nofollow" target="_blank">这里</a>找到。代码片段06包含了所有的最终函数，如果你粘贴它，应该可以工作。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="179d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在<a class="ae lu" href="https://nike-react.com/" rel="noopener ugc nofollow" target="_blank">https://nike-react.com/</a>使用了一个类似的方法，这是迄今为止我做过的最重资产管理的项目。承诺，尤其是<code class="fe lq lr ls lf b">Promise.all()</code>，有助于保持事情可控。</p></div></div>    
</body>
</html>