<html>
<head>
<title>Creating Linked Lists In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript创建链表</h1>
<blockquote>原文：<a href="https://itnext.io/creating-linked-lists-in-javascript-2980b0559324?source=collection_archive---------3-----------------------#2019-04-29">https://itnext.io/creating-linked-lists-in-javascript-2980b0559324?source=collection_archive---------3-----------------------#2019-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0efea29e77f9c04fe3bf2f2955281147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjtQcZTs7GASlBZHtvmRwg.png"/></div></div></figure><h1 id="27eb" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是链表？</h1><p id="ebb6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">单链表是一种表示一系列节点的数据结构，其中每个节点指向列表中的下一个节点。相反，双向链表的节点指向它前后的元素。</p><p id="3478" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">与数组不同，链表不提供对列表中特定索引的固定时间访问。因此，如果您需要列表中的第三个元素，您必须遍历第一个和第二个节点才能到达它。</p><p id="38d1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">链表的一个好处是能够在固定的时间内从列表的开始和结尾添加和删除项目。</p><p id="0b49" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这些是在技术面试中会被问到的流行数据结构，所以让我们直接进入主题。</p><p id="fc47" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">单链表可以是<strong class="lb iu"> LIFO(后进先出)</strong>或<strong class="lb iu"> FIFO(先进先出)。</strong>如果列表使用LIFO方法，节点将从同一端添加和删除。如果使用FIFO，节点将被添加到一端，并从另一端删除。</p><p id="eef5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">此外，可以对链表进行排序。这意味着当每个节点被添加到列表中时，它被放置到相对于其他节点的适当位置。</p><h1 id="dd46" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结节</h1><p id="f8f5" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">链表只是一系列节点，所以让我们从节点对象开始。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/05f398fb51d453b377940926e580b9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4LESYDAteiryl6e34Bhe5g.png"/></div></div></figure><p id="2c41" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">一个节点有两条信息:</p><ul class=""><li id="c6e7" class="mh mi it lb b lc lx lg ly lk mj lo mk ls ml lw mm mn mo mp bi translated">指向列表中下一个项目的指针或引用(对于单链表)</li><li id="a012" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated">节点的值</li></ul><p id="670a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">对于我们的节点，我们将创建一个函数，该函数接受一个值，并返回一个包含上述两个值的对象:指向下一个节点的指针和该节点的值。注意，我们可以只声明<code class="fe mv mw mx my b">value</code>而不是<code class="fe mv mw mx my b">value: value</code>。这是因为变量具有相同的名称。你可以在这里了解更多关于对象属性简写<a class="ae mz" href="https://alligator.io/js/object-property-shorthand-es6/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="6dcc" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">节点列表</h1><p id="432f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在，让我们深入研究NodeList类。这只是:一个节点列表。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0efea29e77f9c04fe3bf2f2955281147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjtQcZTs7GASlBZHtvmRwg.png"/></div></div></figure><p id="5085" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们的节点列表将包含五个方法:</p><ul class=""><li id="c521" class="mh mi it lb b lc lx lg ly lk mj lo mk ls ml lw mm mn mo mp bi translated"><code class="fe mv mw mx my b">push(value)</code>:将一个值推到链表的末尾</li><li id="82ef" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated"><code class="fe mv mw mx my b">pop()</code>:从列表中弹出最后一个值</li><li id="9ee4" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated"><code class="fe mv mw mx my b">get(index)</code>:从给定的索引中返回一个项目</li><li id="da35" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated"><code class="fe mv mw mx my b">delete(index)</code>:从给定索引中删除一个项目</li><li id="0ce1" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated"><code class="fe mv mw mx my b">isEmpty()</code>:返回一个布尔值，表示列表是否为空</li><li id="228e" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated"><code class="fe mv mw mx my b">printList()</code>:一个方法，不是链表自带的，它将打印出我们的列表；它主要用于调试目的</li></ul><h2 id="d90f" class="nc kc it bd kd nd ne dn kh nf ng dp kl lk nh ni kp lo nj nk kt ls nl nm kx nn bi translated">构造器</h2><p id="a013" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我将使用JavaScript类语法，尽管您也可以使用闭包来创建链表。所以让我们来设置构造函数。</p><p id="68c7" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们在构造函数中需要三条信息:</p><ul class=""><li id="4e2e" class="mh mi it lb b lc lx lg ly lk mj lo mk ls ml lw mm mn mo mp bi translated"><code class="fe mv mw mx my b">head</code>:对列表开头节点的引用</li><li id="1eb2" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated"><code class="fe mv mw mx my b">tail</code>:对列表末尾节点的引用</li><li id="91ff" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated"><code class="fe mv mw mx my b">length</code>:列表中有多少个节点</li></ul><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="7d01" class="nc kc it bd kd nd ne dn kh nf ng dp kl lk nh ni kp lo nj nk kt ls nl nm kx nn bi translated">IsEmpty</h2><p id="237e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><code class="fe mv mw mx my b">isEmpty()</code>方法是一个helper函数，如果列表为空，它将返回true。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="009a" class="nc kc it bd kd nd ne dn kh nf ng dp kl lk nh ni kp lo nj nk kt ls nl nm kx nn bi translated">打印列表</h2><p id="a3e0" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这个实用程序方法将打印列表中的节点。这仅仅是为了调试的目的。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="d8ba" class="nc kc it bd kd nd ne dn kh nf ng dp kl lk nh ni kp lo nj nk kt ls nl nm kx nn bi translated">推</h2><p id="ad8e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们的push方法需要在添加新节点之前检查列表是否为空。我们如何知道列表是否为空？两种方式:</p><ul class=""><li id="da44" class="mh mi it lb b lc lx lg ly lk mj lo mk ls ml lw mm mn mo mp bi translated">我们的<code class="fe mv mw mx my b">isEmpty()</code>方法返回true(列表的长度为零)</li><li id="7762" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated"><code class="fe mv mw mx my b">head</code>指针为空</li></ul><p id="9f5b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">对于本例，我们将检查head是否为null，尽管这两种解决方案都很好。</p><p id="9652" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果列表中没有条目，我们可以简单地设置指向新节点的<code class="fe mv mw mx my b">head</code>和<code class="fe mv mw mx my b">tail</code>指针，并更新列表的长度。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b654" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果列表不为空，我们必须执行以下操作:</p><ul class=""><li id="2e16" class="mh mi it lb b lc lx lg ly lk mj lo mk ls ml lw mm mn mo mp bi translated">设置<code class="fe mv mw mx my b">tail.next</code>指向新节点</li><li id="26c2" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated">设置<code class="fe mv mw mx my b">tail</code>指向新节点</li><li id="bb37" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated">增加列表长度</li></ul><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/048a68874b8ed0322624546c04badb14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FMFrPwSaugDXBocMvSoOA.png"/></div></div></figure><p id="e583" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">以下是我们完整的推送方法:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="8d8d" class="nc kc it bd kd nd ne dn kh nf ng dp kl lk nh ni kp lo nj nk kt ls nl nm kx nn bi translated">流行音乐</h2><p id="5c0e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们的pop方法需要在移除列表中的最后一项之前检查以下两件事:</p><ul class=""><li id="0b8c" class="mh mi it lb b lc lx lg ly lk mj lo mk ls ml lw mm mn mo mp bi translated">检查列表是否为空</li><li id="f0c2" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated">检查列表中是否只有一个项目</li></ul><p id="80f6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们可以使用我们的<code class="fe mv mw mx my b">isEmpty</code>方法来检查一个列表是否包含节点。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b182" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们如何知道列表中是否只有一个节点？如果<code class="fe mv mw mx my b">head</code>和<code class="fe mv mw mx my b">tail</code>指向同一个节点。但是在这种情况下我们需要做什么呢？移除唯一的节点意味着我们实际上是在重置列表。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3597" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果列表中有多个元素，我们可以执行以下操作:</p><pre class="md me mf mg gt np my nq nr aw ns bi"><span id="420f" class="nc kc it my b gy nt nu l nv nw">while there are nodes in the list<br/>  if the next node in the list is the tail<br/>    update tail to point to the current node<br/>    set the current node to point to null<br/>    decrement the length of the list<br/>    return the previous tail element</span></pre><p id="6ae4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">它看起来会像这样:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d287" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果你很难想象这一点，让我们走一遍。</p><p id="3a6b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">第6–10行:</strong>如果列表中的下一个节点是最后一个项目，则当前项目是新的“tail ”,因此我们需要保存它的引用。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/be88b916fb5fa458b0e0a7697fb2fc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-z8KxctfLOIhdq4Wn71GTQ.png"/></div></div></figure><p id="b94b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">第15行:</strong>更新<code class="fe mv mw mx my b">secondToLastNode</code>指向空。这是从列表中“弹出”最后一个元素的行为。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/b1c8d59300ac67789bb7925c0858d2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3v3-_f_cNFYv74XBEtGztw.png"/></div></div></figure><p id="4c11" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">第16行:</strong>更新<code class="fe mv mw mx my b">tail</code>指向<code class="fe mv mw mx my b">secondToLastNode</code>。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/04b705d4fc878b1c4133db61721891af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvZuyZ0pTeOeOmPCLA-UmQ.png"/></div></div></figure><p id="d10b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">第17行:</strong>减少列表的长度，因为我们刚刚删除了一个节点。</p><p id="c91d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">第18行:</strong>返回我们刚刚弹出的节点。</p><p id="b7e8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这是我们的完整pop方法:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="58b7" class="nc kc it bd kd nd ne dn kh nf ng dp kl lk nh ni kp lo nj nk kt ls nl nm kx nn bi translated">得到</h2><p id="5973" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们的get方法必须检查三种情况:</p><ul class=""><li id="e21c" class="mh mi it lb b lc lx lg ly lk mj lo mk ls ml lw mm mn mo mp bi translated">请求的索引超出了列表的界限</li><li id="ae2d" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated">列表是空的</li><li id="716f" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated">我们要求第一个元素</li></ul><p id="5571" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果请求的索引不在列表中，则返回null。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ac63" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果列表为空，则返回null。你可以组合这些if语句，但是为了清楚起见，我把它们分开了。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4a33" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果我们请求第一个元素，返回头部。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0dbc" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">否则，我们就一个接一个地遍历列表，直到找到我们要找的索引。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a2be" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">下面是完整的<code class="fe mv mw mx my b">get(index)</code>方法:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="2333" class="nc kc it bd kd nd ne dn kh nf ng dp kl lk nh ni kp lo nj nk kt ls nl nm kx nn bi translated">删除</h2><p id="4424" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们的删除方法还必须考虑三种特殊的用例:</p><ul class=""><li id="af14" class="mh mi it lb b lc lx lg ly lk mj lo mk ls ml lw mm mn mo mp bi translated">我们要删除的索引超出了列表的界限</li><li id="abfe" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated">列表是空的</li><li id="7080" class="mh mi it lb b lc mq lg mr lk ms lo mt ls mu lw mm mn mo mp bi translated">我们想删除头部</li></ul><p id="2cce" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果我们要删除的索引不在列表中，返回null。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c7f4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果列表为空，则返回null。您可以将这个逻辑与确定索引是否超出列表边界的逻辑结合起来，但是为了清楚起见，我将它们分开。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8fb4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果我们想要删除头部，将<code class="fe mv mw mx my b">head</code>设置为列表中的下一个值，减少长度，并返回我们刚刚删除的值。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1591" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果这些布尔值都不为真，则删除节点的逻辑如下:</p><pre class="md me mf mg gt np my nq nr aw ns bi"><span id="a63b" class="nc kc it my b gy nt nu l nv nw">while the iterator isn't the index we're looking for<br/>  increase the iterator<br/>  move the previous and current pointers up by one<br/>save the current value as the node to be deleted<br/>update the previous node's pointer to point to the next node<br/>if the next value is null<br/>  set tail to the new last node<br/>decrement list length<br/>return the deleted node</span></pre><p id="abc7" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果你需要可视化的帮助，请参考Pop部分的图表。</p><p id="dc6d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">delete方法和pop方法的区别在于，pop方法总是删除列表中的最后一项。相反，delete方法可以删除介于0和列表长度之间的索引。</strong></p><p id="2b0c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">下面是完整的删除方法:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="dd9d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果你想玩代码，请随意使用我的<a class="ae mz" href="https://codepen.io/emmawedekind/pen/zXbWzq?editors=0012" rel="noopener ugc nofollow" target="_blank">代码笔</a>。</p></div></div>    
</body>
</html>