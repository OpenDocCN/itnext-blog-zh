<html>
<head>
<title>Build a library with esbuild (vol. 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用esbuild构建一个库(第2卷)</h1>
<blockquote>原文：<a href="https://itnext.io/build-a-library-with-esbuild-vol-2-c0e3caa25150?source=collection_archive---------1-----------------------#2022-07-05">https://itnext.io/build-a-library-with-esbuild-vol-2-c0e3caa25150?source=collection_archive---------1-----------------------#2022-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fd91f93a28de3749a973f88adf760c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OCuN_lShUlE2vb_V"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约瑟夫·格雷夫在<a class="ae kf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="dd8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一年前我分享了一个<a class="ae kf" href="https://medium.com/geekculture/build-a-library-with-esbuild-23235712f3c" rel="noopener">帖子</a>，解释了如何用<a class="ae kf" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"> esbuild </a>构建一个库。虽然它仍然是一个有效的解决方案，但自从它发布以来，我对我的工具进行了一些改进。</p><p id="cf8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我希望对你的项目有用的几个附件。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="3c6b" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">源和输出</h2><p id="5c8a" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">为库定义一个以上的入口点有时会很有用——也就是说，不只是使用一个唯一的<code class="fe mj mk ml mm b">index.ts</code>文件作为入口，而是使用多个源来提供逻辑上独立的代码组。esbuild通过参数<a class="ae kf" href="https://esbuild.github.io/api/#entry-points" rel="noopener ugc nofollow" target="_blank">入口点</a>支持该选项。</p><p id="79f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，在我的项目中，我经常列出我的<code class="fe mj mk ml mm b">src</code>文件夹中的所有TypeScript文件，并将它们作为单独的条目。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="40d9" class="ll lm it mm b gy mv mw l mx my">import {<br/>  readdirSync,<br/>  statSync<br/>} from "fs";<br/>import { join } from "path";<br/><br/>// Select all typescript files of src directory as entry points<br/>const entryPoints = readdirSync(join(process.cwd(), "src"))<br/>  .filter(<br/>    (file) =&gt;<br/>      file.endsWith(".ts") &amp;&amp;<br/>      statSync(join(process.cwd(), "src", file)).isFile()<br/>  )<br/>  .map((file) =&gt; `src/${file}`);</span></pre><p id="502b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于每个构建之前的输出文件夹可能已经被删除了，所以我也希望在继续之前通过创建它来确保它存在。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="2c71" class="ll lm it mm b gy mv mw l mx my">import {<br/>  existsSync,<br/>  mkdirSync<br/>} from "fs";<br/>import { join } from "path";<br/><br/>// Create dist before build if not exist<br/>const dist = join(process.cwd(), "dist");<br/><br/>if (!existsSync(dist)) {<br/>  mkdirSync(dist);<br/>}<br/><br/>// Select entryPoints and build</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="835b" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">未定义全局</h2><p id="6d99" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">构建ESM目标时，您的库可能会使用某些依赖项，从而导致构建错误<em class="mz">“未捕获的引用错误:未定义全局”</em>。根本原因是依赖关系期望一个<code class="fe mj mk ml mm b">global</code>对象(如在NodeJS中),而浏览器需要<code class="fe mj mk ml mm b">window</code>。</p><p id="0b13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，esbuild有一个<a class="ae kf" href="https://esbuild.github.io/api/#define" rel="noopener ugc nofollow" target="_blank"> define </a>选项，可以用来用常量表达式替换全局标识符。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="6d43" class="ll lm it mm b gy mv mw l mx my">import esbuild from "esbuild";<br/><br/>esbuild<br/>  .build({<br/>    entryPoints,<br/>    outdir: "dist/esm",<br/>    bundle: true,<br/>    sourcemap: true,<br/>    minify: true,<br/>    splitting: true,<br/>    format: "esm",<br/>    define: { global: "window" },<br/>    target: ["esnext"],<br/>  })<br/>  .catch(() =&gt; process.exit(1));</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="d430" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">esm和cjs</h2><p id="e06b" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">为了发布一个既支持CommonJS (cjs)又支持ECMAScript模块(esm)的库，我将包输出到发行目录的两个子文件夹中——例如<code class="fe mj mk ml mm b">dist/cjs</code>和<code class="fe mj mk ml mm b">dist/esm</code>。使用esbuild，这可以通过指定选项<a class="ae kf" href="https://esbuild.github.io/api/#outdir" rel="noopener ugc nofollow" target="_blank"> outdir </a>或<a class="ae kf" href="https://esbuild.github.io/api/#outfile" rel="noopener ugc nofollow" target="_blank"> outfile </a>到这些相对路径来实现。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="76c2" class="ll lm it mm b gy mv mw l mx my">import esbuild from "esbuild";<br/>import {<br/>  existsSync,<br/>  mkdirSync,<br/>  readdirSync,<br/>  statSync,<br/>  writeFileSync,<br/>} from "fs";<br/>import { join } from "path";<br/><br/>const dist = join(process.cwd(), "dist");<br/><br/>if (!existsSync(dist)) {<br/>  mkdirSync(dist);<br/>}<br/><br/>const entryPoints = readdirSync(join(process.cwd(), "src"))<br/>  .filter(<br/>    (file) =&gt;<br/>      !file.endsWith(".ts") &amp;&amp;<br/>      statSync(join(process.cwd(), "src", file)).isFile()<br/>  )<br/>  .map((file) =&gt; `src/${file}`);<br/><br/>// esm output bundles with code splitting<br/>esbuild<br/>  .build({<br/>    entryPoints,<br/>    outdir: "dist/esm",<br/>    bundle: true,<br/>    sourcemap: true,<br/>    minify: true,<br/>    splitting: true,<br/>    format: "esm",<br/>    define: { global: "window" },<br/>    target: ["esnext"],<br/>  })<br/>  .catch(() =&gt; process.exit(1));<br/><br/>// cjs output bundle<br/>esbuild<br/>  .build({<br/>    entryPoints: ["src/index.ts"],<br/>    outfile: "dist/cjs/index.cjs.js",<br/>    bundle: true,<br/>    sourcemap: true,<br/>    minify: true,<br/>    platform: "node",<br/>    target: ["node16"],<br/>  })<br/>  .catch(() =&gt; process.exit(1));<br/><br/>// an entry file for cjs at the root of the bundle<br/>writeFileSync(join(dist, "index.js"), "export * from './esm/index.js';");<br/><br/>// an entry file for esm at the root of the bundle<br/>writeFileSync(<br/>  join(dist, "index.cjs.js"),<br/>  "module.exports = require('./cjs/index.cjs.js');"<br/>);</span></pre><p id="f085" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于分发两个不同的文件夹会导致库的<code class="fe mj mk ml mm b">dist</code>路径中不再有条目文件，所以我还喜欢添加两个文件来重新导出代码。在项目中导入库时，这很有用。</p><p id="2000" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，<code class="fe mj mk ml mm b">package.json</code>条目也应该相应地更新。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="9fd4" class="ll lm it mm b gy mv mw l mx my">{<br/>  "name": "mylibary",<br/>  "version": "0.0.1",<br/>  "main": "dist/cjs/index.cjs.js",<br/>  "module": "dist/esm/index.js",<br/>  "types": "dist/types/index.d.ts",<br/>}</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="cc94" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">CSS和SASS</h2><p id="a54c" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">你知道esbuild也可以捆绑<a class="ae kf" href="https://esbuild.github.io/content-types/#css" rel="noopener ugc nofollow" target="_blank"> CSS </a>文件吗？甚至有一个<a class="ae kf" href="https://github.com/glromeo/esbuild-sass-plugin" rel="noopener ugc nofollow" target="_blank"> SASS插件</a>使它易于构建。scss文件😃。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="02ab" class="ll lm it mm b gy mv mw l mx my">npm i -D esbuild-sass-plugin postcss autoprefixer postcss-preset-env</span></pre><p id="4eae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的例子中，我捆绑了两个不同的SASS文件— <code class="fe mj mk ml mm b">src/index.scss</code>和<code class="fe mj mk ml mm b">src/doc/index.scss</code>。我使用插件来转换代码——即给CSS添加前缀——我还使用选项<a class="ae kf" href="https://esbuild.github.io/api/#metafile" rel="noopener ugc nofollow" target="_blank">图元文件</a>,它告诉esbuild以JSON格式生成一些关于构建的元数据。</p><p id="64e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用它，我可以检索生成的CSS文件的路径和名称，例如，稍后将它们包含在我的HTML文件中。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="39b0" class="ll lm it mm b gy mv mw l mx my">import esbuild  from 'esbuild';<br/><br/>import {sassPlugin}  from 'esbuild-sass-plugin';<br/>import postcss  from 'postcss';<br/>import autoprefixer  from 'autoprefixer';<br/>import postcssPresetEnv  from 'postcss-preset-env';<br/><br/>const buildCSS = async () =&gt; {<br/>  const {metafile} = await esbuild.build({<br/>    entryPoints: ['src/index.scss', 'src/doc/index.scss'],<br/>    bundle: true,<br/>    minify: true,<br/>    format: 'esm',<br/>    target: ['esnext'],<br/>    outdir: 'dist/build',<br/>    metafile: true,<br/>    plugins: [<br/>      sassPlugin({<br/>        async transform(source, resolveDir) {<br/>          const {css} = <br/>            await postcss([autoprefixer, <br/>                           postcssPresetEnv()<br/>                          ]).process(source, {<br/>              from: undefined<br/>          });<br/>          return css;<br/>        }<br/>      })<br/>    ]<br/>  });<br/><br/>  const {outputs} = metafile;<br/>  return Object.keys(outputs);<br/>};</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="6a08" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">结论</h2><p id="89ca" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated"><a class="ae kf" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"> esbuild </a>还是滑头！</p><p id="bcbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到无限远处<br/>大卫</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="dd55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多冒险，请在推特上关注我</p></div></div>    
</body>
</html>