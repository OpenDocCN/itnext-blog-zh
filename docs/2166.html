<html>
<head>
<title>How to Build a Productivity Application in React: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中构建生产力应用程序:第3部分</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-a-productivity-application-in-react-part-3-a1c4e212fdcb?source=collection_archive---------2-----------------------#2019-04-10">https://itnext.io/how-to-build-a-productivity-application-in-react-part-3-a1c4e212fdcb?source=collection_archive---------2-----------------------#2019-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="203a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将应用程序的数据添加到本地存储</h2></div><p id="27ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">欢迎回到我的教程，如何在React中构建生产力应用程序，第3部分！如果你错过了本教程的前两部分，请查看第一部分的<a class="ae le" href="https://medium.com/@claire.sinozich/how-to-build-a-productivity-application-in-react-part-1-9f0c7ee65772" rel="noopener">和第二部分的</a><a class="ae le" href="https://medium.com/@claire.sinozich/how-to-build-a-productivity-application-in-react-part-2-7a5f9b8fed3" rel="noopener"/>。如果你刚刚开始阅读第3部分，这一部分的开始代码在GitHub <a class="ae le" href="https://github.com/csinozich/productivity-app/commit/46dbb4fab6898a515a33b718fe564b9265af8705" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="6fc1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本教程的这一部分，我们将暂停更新应用程序的功能，继续将数据存储在浏览器的本地存储中。本地存储是一个非常普遍的web API，它允许您在用户的浏览器中存储小块数据，这样当他们离开页面并稍后返回时，他们的数据会保存在您的应用程序中。如果你想了解更多关于localStorage在Javascript中是如何工作的，我可以看看这篇关于localStorage方法基础的文章。</p><p id="96ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提醒一下，这个系列既是对你的启迪，也是对我的启迪，所以如果我做错了什么，请不要犹豫让我知道，或者提出问题。就这样，让我们开始吧！</p><h1 id="b778" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">将您的应用程序数据存储在本地存储上</h1><p id="3571" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">添加本地存储的第一步是在组件上设置一些生命周期功能。我们将设置我们的应用程序，使localStorage在退出应用程序时更新，然后在应用程序再次加载时再次呈现，而不是每次改变我们的<em class="mc">状态</em>时更新localStorage。</p><h2 id="418e" class="md lg it bd lh me mf dn ll mg mh dp lp kr mi mj lr kv mk ml lt kz mm mn lv mo bi translated">将本地存储中的项目添加到我们的应用程序</h2><p id="6efe" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们首先在我们的<em class="mc"> App.js </em>文件中给我们的应用程序一个名为<em class="mc"> addLocalStorage() </em>的函数。该函数将获取所有处于<em class="mc">状态</em>的项目，对照本地存储中保存的数据检查唯一标识符，并将正确的数据呈现到屏幕上。一会儿我们将把这个函数添加到我们的生命周期中。</p><p id="8318" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<em class="mc"> addLocalStorage </em>函数中，我们将首先使用<em class="mc"> for </em>关键字来检查存在于<em class="mc"> this.state </em>中的所有项目。在这些条目中，我们将使用<em class="mc"> if </em>关键字来确定处于<em class="mc">状态</em>的每个条目的唯一标识符(键)是否与本地存储中条目的唯一标识符(键)相匹配。当键匹配时，我们希望将这些项目返回到屏幕上。</p><p id="07ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们声明一个名为<em class="mc"> value </em>的变量，根据其唯一标识符从本地存储中抓取一个项目(使用<em class="mc"> getItem </em>方法)。然后，同样在我们的<em class="mc"> if </em>语句中，我们将使用一个<a class="ae le" href="https://javascript.info/try-catch" rel="noopener ugc nofollow" target="_blank"> try-catch块</a>。这种模式本质上试图执行我们的<em class="mc"> try </em>块中的代码，如果失败，我们的<em class="mc"> catch </em>块中的代码将会执行。这是一种错误处理的方法，以确保您的应用程序不会因错误而中断。</p><p id="d784" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<em class="mc"> try </em>块中，您将看到我们将值设置为另一个名为<em class="mc"> JSON.parse()的函数。</em>因为本地存储只能读取字符串，所以你必须包含这个方法来将这些项目字符串转换成JavaScript对象。然后，我们的应用程序可以将JS对象作为todo任务来读取。在我们解析之后，我们将用一个惟一的标识符将任务设置为从本地存储中提取的已解析的JSON值。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/42fb221949fb7e9299d9ce9d013eb868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yfrapSrIp0AF8suTUxnPA.png"/></div></div></figure><p id="2965" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数不会做任何事情，因为我们还没有将它添加到组件的生命周期中。但是别担心，我们会成功的！在我们开始我们的生命周期方法之前，让我们也添加一个<em class="mc"> saveLocalStorage </em>函数。这个函数将收集关于我们的<em class="mc">状态</em>的所有信息，并在注销时将其保存到本地存储器。</p><h2 id="0067" class="md lg it bd lh me mf dn ll mg mh dp lp kr mi mj lr kv mk ml lt kz mm mn lv mo bi translated">将状态中的项目添加到我们的本地存储</h2><p id="8d4d" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">虽然前面的函数将用于在加载应用程序时呈现项目，但我们还需要一个在离开应用程序时将项目添加到本地存储的函数。为此，我们将向我们的<em class="mc"> App.js </em>文件添加一个名为<em class="mc"> saveLocalStorage </em>的函数。该函数将收集所有关于<em class="mc">状态</em>的信息，并将其保存到本地存储器中。</p><p id="2883" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当这个函数被调用时，我们将首先再次使用关键字的<em class="mc">，并检查处于<em class="mc">状态</em>的所有项目。对于其中的每一项，我们将使用localStorage上的<em class="mc"> setItem() </em>方法，使用其唯一标识符和实际任务将每一项添加到我们的本地存储中。您将在这里看到方法<em class="mc"> JSON.stringify() </em>，它接受每个JS对象任务并以字符串格式返回。我们这样做是因为，就像我们之前说过的，localStorage只能读取字符串。</em></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nb"><img src="../Images/1da8fa6af03dab7c8f34890f6360e67b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IN-GmbD34Iv9ZwpJ03StFA.png"/></div></div></figure><h2 id="00b1" class="md lg it bd lh me mf dn ll mg mh dp lp kr mi mj lr kv mk ml lt kz mm mn lv mo bi translated">将我们的方法添加到组件生命周期中</h2><p id="8b52" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在，我们将把我们的方法<em class="mc"> addLocalStorage() </em>和<em class="mc"> saveLocalStorage() </em>添加到组件的生命周期中。为此，我们将首先使用标准的生命周期函数，<em class="mc"> componentDidMount() </em>。在加载应用程序时，该函数将允许我们将那些已经保存到本地存储的项目提取出来，并将其呈现到页面上。</p><p id="d94d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将在装载页面时调用<em class="mc"> this.addLocalStorage() </em>，这将把我们保存的每个待办任务呈现到页面上。之后，我们将在卸载之前向名为<em class="mc">的窗口添加一个事件监听器。这个事件监听器名副其实:它在卸载我们的应用程序时调用函数，并确保在我们卸载之前运行我们的<em class="mc"> saveLocalStorage() </em>函数。</em></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2efe81510862ffb23f93f39f48b1d813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*FBmAZXRTdfadW2pdi6MOBA.png"/></div></figure><p id="15b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，让我们确保在卸载应用程序时删除窗口上的事件侦听器，以便进行清理:</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nd"><img src="../Images/5329cd77213df397c3bd0b780820cfa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTzwbvo_8nU2oE4BEGj95Q.png"/></div></div></figure><p id="f4e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！现在，您应该能够将项目保存到本地存储。如果你想看到这被添加到本地存储的效果，请使用你的Chrome开发工具。在Application选项卡上，您应该会看到一个名为local storage的部分，它会在您每次向应用程序添加任务时进行更新:</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/583d76d2ddb0cc7aabda477e365b9bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*JyJdd9Lf51alJZ85nEe_Og.png"/></div></figure><p id="3996" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">去玩你的应用程序吧！你对你的每一段代码和Chrome开发工具的每一个方面越熟悉，你就越能理解。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="add3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是关于如何在React中创建生产力应用程序的教程系列的第3部分。查看第1部分<a class="ae le" href="https://medium.com/@claire.sinozich/how-to-build-a-productivity-application-in-react-part-1-9f0c7ee65772" rel="noopener">这里</a>，第2部分<a class="ae le" href="https://medium.com/@claire.sinozich/how-to-build-a-productivity-application-in-react-part-2-7a5f9b8fed3" rel="noopener">这里</a>，并留意第4部分，加入我们的番茄定时器，即将推出！</p><p id="2517" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mc">特别感谢</em><a class="ae le" href="https://hackernoon.com/@ryanjyost" rel="noopener ugc nofollow" target="_blank"><em class="mc">@</em></a><em class="mc">ryanjyost at HackerNoon为他的</em> <a class="ae le" href="https://hackernoon.com/how-to-take-advantage-of-local-storage-in-your-react-projects-a895f2b2d3f2" rel="noopener ugc nofollow" target="_blank"> <em class="mc">文章</em> </a> <em class="mc">上本地存储着React项目。</em></p></div></div>    
</body>
</html>