<html>
<head>
<title>getDerivedStateFromState — making complex things simpler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">getDerivedStateFromState —让复杂的事情变得简单</h1>
<blockquote>原文：<a href="https://itnext.io/getderivedstatefromstate-making-complex-things-simpler-4450115e49d6?source=collection_archive---------1-----------------------#2018-04-15">https://itnext.io/getderivedstatefromstate-making-complex-things-simpler-4450115e49d6?source=collection_archive---------1-----------------------#2018-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5512e1f58414a9e18f9f9e5d4572e20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvAhthYkiJ81SSyV2pMfCA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">流动</figcaption></figure><div class=""/><blockquote class="kc kd ke"><p id="063a" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><a class="ae le" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fgetderivedstatefromstate-making-complex-things-simpler-4450115e49d6%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="7e7e" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">我喜欢反应。我喜欢React的行为方式。它不只是试图解决问题，而是试图正确地解决问题。</p><blockquote class="kc kd ke"><p id="83d5" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">特设，RenderProps，组成，组件，无状态，有状态，twitts从丹和社区，讨论，解决方案，问题和发现。</p></blockquote><p id="6604" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">在去年的生日派对上，我们得到了一种全新的处理道具变化的方法——静态<code class="fe li lj lk ll b">getDerivedStateFromProps</code>。然后屎风暴。然后打关于如何使用它的文章。然后是十几期关于某人如何不能使用它的问题。</p><blockquote class="kc kd ke"><p id="f7f4" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">JFYI: <code class="fe li lj lk ll b">getDerivedStateFromProps</code>，只是定义了如何让StateA和Props形成StateB。而且是单程过境。</p></blockquote><p id="5266" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">问题很简单，有时你必须根据你拥有的状态和道具形成一个状态。有时候你有什么道具也很重要。</p><p id="52d1" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">有成千上万的情况下，你需要它。有一个<a class="ae le" href="https://github.com/reactjs/reactjs.org/issues/721#issuecomment-378574657" rel="noopener ugc nofollow" target="_blank">讨论</a>关于从<code class="fe li lj lk ll b">componentWillReceiveProps</code>到<code class="fe li lj lk ll b">gDSFP</code>的重构。有一个<a class="ae le" href="https://github.com/reactjs/rfcs/pull/40#discussion_r180818891" rel="noopener ugc nofollow" target="_blank"> PR来“修复”它</a>。而且被拒绝了。应该是这样，因为他们忘记了一个用例。</p><h1 id="94d5" class="lm ln jf bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">测试|行为驱动的开发</h1><p id="38ba" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">为了更好地理解，让我们创建一个我们将要解决的真实世界问题，并解决它。并让它将简单的任务— <strong class="ki jg">显示一个表格</strong>。</p><blockquote class="mp"><p id="2e8c" class="mq mr jf bd ms mt mu mv mw mx my ld dk translated">显示带有分页和排序的表格。</p></blockquote><ol class=""><li id="57b9" class="mz na jf ki b kj nb kn nc lf nd lg ne lh nf ld ng nh ni nj bi translated">人们应该做什么来呈现那张桌子？</li></ol><ul class=""><li id="6733" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">获取表格数据</li><li id="83b2" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated">分类</li><li id="778e" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated">在表格数据中选取一些范围</li><li id="64f5" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated">展示一下。</li></ul><p id="8637" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">2.如果数据被更改了怎么办？</p><ul class=""><li id="6902" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">从头开始一切</li></ul><p id="2e34" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">3.怎么换一个页面？</p><ul class=""><li id="a99d" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">this . setstate({ page:new page })；</li></ul><p id="5adb" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">4.如何改变排序？</p><ul class=""><li id="1b59" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">this . setstate({ sorting:new sorting })；</li></ul><p id="3b96" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">6.如何应对状态变化？</p><ul class=""><li id="d3d1" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">不知道。说真的！</li></ul><p id="b6bd" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">6.我能使用道具而不是政府吗？</p><ul class=""><li id="085a" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">当然可以。创建一个“智能”组件，它将控制一个“笨”组件。</li><li id="816e" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated">那个“笨”的可以得到它需要的所有东西作为道具，并使用<code class="fe li lj lk ll b">gDSFP</code>实际排序它将得到的<code class="fe li lj lk ll b">data</code>作为道具，使用它可以从道具中读取的<code class="fe li lj lk ll b">sort</code>设置，并在状态中存储从<code class="fe li lj lk ll b">page</code>到<code class="fe li lj lk ll b">page+1</code>的切片。</li><li id="debd" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated">每次你可能改变任何道具，它会从头开始做所有的事情，同时排序不是一件很快的事情。</li></ul><p id="1f73" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">7.我可以用州名吗？</p><ul class=""><li id="9fab" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">不，你不能。因为你必须对状态变化做出反应，即有人改变了<code class="fe li lj lk ll b">page</code>——它应该得到<code class="fe li lj lk ll b">state.sortedData</code>，生成一个数据片并存储为<code class="fe li lj lk ll b">state.result</code>。但是没有办法对状态变化做出反应。没有办法<code class="fe li lj lk ll b">getDeviredStateFromState</code>，即使这篇文章是以它命名的。</li></ul><p id="c1d8" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">8.没有解谜的方法吗？</p><ul class=""><li id="da7c" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">嗯……我们来谈谈吧。</li></ul><h1 id="884d" class="lm ln jf bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">解开谜题</h1><h2 id="112b" class="nt ln jf bd lo nu nv dn ls nw nx dp lw lf ny nz ma lg oa ob me lh oc od mi oe bi translated"><strong class="ak">状态机方式</strong></h2><p id="26be" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">这很复杂。<strong class="ki jg">有限状态自动机</strong>定义了一个状态如何转换到另一个状态。</p><ul class=""><li id="65d0" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">当你在<code class="fe li lj lk ll b">idle</code>，收到<code class="fe li lj lk ll b">page change</code>，转到<code class="fe li lj lk ll b">recalculation state</code>。</li><li id="fee2" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated">在<code class="fe li lj lk ll b">recalculation state</code>输入—重新计算值，转换到<code class="fe li lj lk ll b">idle</code>状态。</li></ul><p id="2442" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">您可能需要为每个可能的变化定义一个<code class="fe li lj lk ll b">calculation state</code>来优化CPU的使用，这就是它应该如何工作。底下。在内心深处。更好—在白板上。</p><h2 id="284b" class="nt ln jf bd lo nu nv dn ls nw nx dp lw lf ny nz ma lg oa ob me lh oc od mi oe bi translated">反应方式</h2><p id="bda2" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">目前官方解决这个难题的方法，是在渲染时使用<strong class="ki jg">记忆。</strong></p><figure class="of og oh oi gt is"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="636a" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">它同一时间(<a class="ae le" href="https://github.com/reactjs/rfcs/pull/40#issuecomment-378956267" rel="noopener ugc nofollow" target="_blank">链接</a>):</p><blockquote class="kc kd ke"><p id="f4cc" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><a class="ae le" href="https://github.com/reactjs/reactjs.org/issues/721#issuecomment-378574657" rel="noopener ugc nofollow" target="_blank">一个解决方案建议</a>记忆该计算并每次调用它，这是一个好主意，但实际上这意味着管理缓存，当你处理一个采用多个参数的函数时，这大大增加了潜在错误和错误的发生。我不得不求助于一个奇怪的多深度<code class="fe li lj lk ll b">WeakMap</code>，并决定何时丢弃不同级别的缓存。<a class="ol om ep" href="https://medium.com/u/4e17883ba85d?source=post_page-----4450115e49d6--------------------------------" rel="noopener" target="_blank">本·斯泰尔斯</a></p></blockquote><p id="ae2d" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">让我换个说法——bug、科技债务、宇宙末日。</p><p id="c87a" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">同时，我希望有一个非常简单的东西——简单、稳定、无bug的解决方案。我不再要求什么了。只为这个。</p><h1 id="000c" class="lm ln jf bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">好的。怎么会？！</h1><p id="20b8" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">要解决这个任务，任何类似的任务，任何不像这样，但类似的任务，你可能只需要两样东西。你认识他们两个。</p><h2 id="9252" class="nt ln jf bd lo nu nv dn ls nw nx dp lw lf ny nz ma lg oa ob me lh oc od mi oe bi translated">1.第一件事——瀑布。</h2><p id="d545" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">我知道瀑布很烂，敏捷法则。但是你知道些什么呢？维基百科的第一行包含了我们需要的一切:</p><blockquote class="kc kd ke"><p id="060f" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><strong class="ki jg">瀑布模型</strong>是相对线性的<a class="ae le" href="https://en.wikipedia.org/wiki/Sequence" rel="noopener ugc nofollow" target="_blank">顺序</a>设计<a class="ae le" href="https://en.wikipedia.org/wiki/Design" rel="noopener ugc nofollow" target="_blank">设计</a>。</p></blockquote><p id="f86a" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">它描述了<strong class="ki jg"> <em class="kh">如何一个接一个</em> </strong>。可预测的、强制性的方法。</p><blockquote class="mp"><p id="8bc7" class="mq mr jf bd ms mt mu mv mw mx my ld dk translated">首先—排序。第二—切片。第三—渲染。</p></blockquote><p id="0fb0" class="pw-post-body-paragraph kf kg jf ki b kj nb kl km kn nc kp kq lf on kt ku lg oo kx ky lh op lb lc ld ij bi translated">你可以定义一次“工作方式”,它总是一样的。</p><h2 id="2f0c" class="nt ln jf bd lo nu nv dn ls nw nx dp lw lf ny nz ma lg oa ob me lh oc od mi oe bi translated">2.第二件事——重新选择。</h2><p id="1b00" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">重新选择是选择和记忆库。很多人更喜欢它而不是其他级联的记忆库。</p><blockquote class="mp"><p id="505e" class="mq mr jf bd ms mt mu mv mw mx my ld dk translated">有两个记忆值，如何形成最终的记忆值。(简单)</p></blockquote><h2 id="dcbf" class="nt ln jf bd lo nu oq dn ls nw or dp lw lf os nz ma lg ot ob me lh ou od mi oe bi translated">但是</h2><p id="fca5" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">但是我同意Ben的观点——一个接一个的级联内存化函数,<em class="kh">“管理缓存，当你处理一个带有多个参数的函数时，会极大地增加你潜在的错误和错误的空间”</em>。</p><p id="72de" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">重选级联是超级强大的东西，但使用它们并不容易，只要你必须“提取”每一步所依赖的所有“真实”变量。艰难，无谓和脆弱的时刻。</p><p id="a338" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">第三件事，“流动”，可以解决这个问题。</p><h1 id="fa11" class="lm ln jf bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">流动</h1><p id="0578" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">流程，<strong class="ki jg">记忆组成</strong>，字面<code class="fe li lj lk ll b">composed</code>记忆功能列表。您可以定义如何形成最终状态，并执行序列。</p><figure class="of og oh oi gt is"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="c331" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">这比无组织的，甚至是混乱的以随机的顺序调用一些函数，或者对状态/属性的变化做出反应要好得多，只要你不能预测变化的顺序，结果可能是不确定的。</p><p id="5ae9" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">但是我不喜欢它的样子。</p><ul class=""><li id="b4d1" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">你弄脏了一个渲染函数。</li><li id="0a30" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated">您不能执行副作用，如获取选定页面的数据。因为渲染必须是纯净的。如果没有，哦，不好的事情可能会发生。</li><li id="f338" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated">有些道具被具体化为流程定义，而有些则没有。</li></ul><blockquote class="mp"><p id="b6d7" class="mq mr jf bd ms mt ov ow ox oy oz ld dk translated">一定有更好的办法！</p></blockquote><h1 id="800c" class="lm ln jf bd lo lp lq lr ls lt lu lv lw lx pa lz ma mb pb md me mf pc mh mi mj bi translated">同样的，但更好一点的方式</h1><figure class="of og oh oi gt is"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="6a0e" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">它看起来几乎与lodash版本相同，但行为不同:</p><ul class=""><li id="c449" class="mz na jf ki b kj kk kn ko lf nk lg nl lh nm ld nn nh ni nj bi translated">你提供一个<code class="fe li lj lk ll b">input</code></li><li id="c037" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated"><code class="fe li lj lk ll b">input</code>将被用来调用第一个函数。</li><li id="6469" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated"><code class="fe li lj lk ll b">output</code>将第一个函数合并回来，并用来调用第二个函数。</li><li id="2e22" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld nn nh ni nj bi translated">第二步的结果将被用作结果。</li></ul><p id="02fb" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">并且每一步都知道它将从<code class="fe li lj lk ll b">input</code>中读取哪些值，从而知道<code class="fe li lj lk ll b">input</code>中的哪些变化以及<code class="fe li lj lk ll b">flow</code>中的哪一步应该重新计算。这不是魔术，这是<code class="fe li lj lk ll b">memoize-state</code>，代理的力量(在IE11中有效)</p><div class="ip iq gp gr ir pd"><a rel="noopener  ugc nofollow" target="_blank" href="/how-i-wrote-the-worlds-fastest-react-memoization-library-535f89fc4a17"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd jg gy z fp pi fr fs pj fu fw je bi translated">我如何编写世界上最快的反应记忆库</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">实际上我已经试着写了最慢的一个，而“最快的JavaScript记忆库”是一年前写的…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">itnext.io</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ix pd"/></div></div></a></div><p id="538a" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">你从“单一的真理来源”获得数据，并把它返回。而且所有的计算都是在<code class="fe li lj lk ll b">getDerivedStateFromProps</code>内部进行的。因为MemoizedState是一个“智能”组件,“您肯定可以使用”,只是比通常的更智能。</p><h2 id="63f1" class="nt ln jf bd lo nu nv dn ls nw nx dp lw lf ny nz ma lg oa ob me lh oc od mi oe bi translated">为什么这是一个解决方案？</h2><ol class=""><li id="c0a9" class="mz na jf ki b kj mk kn ml lf ps lg pt lh pu ld ng nh ni nj bi translated">你可以从任何数据形成<code class="fe li lj lk ll b">input</code>。将你的状态和你的道具合并在一起。</li><li id="c78b" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld ng nh ni nj bi translated">您可以根据需要在<code class="fe li lj lk ll b">flow</code>中使用任意多的步骤，并且每个步骤将仅对观察到的键的变化做出反应，或者对先前步骤的结果做出反应，如果该键是在先前步骤中形成的。并且每个下一个不能使用来自前一个状态的数据。只是存在于状态中的数据，而不管其来源。</li><li id="fa40" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld ng nh ni nj bi translated">执行“顺序”总是一样的。犯一个错误是非常困难的。而且超级容易预测。</li><li id="44bc" class="mz na jf ki b kj no kn np lf nq lg nr lh ns ld ng nh ni nj bi translated">你可以控制副作用。</li></ol><p id="fc32" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">是的——你可以运行副作用。您可以定义流程中的一个步骤，在页面上触发(例如)更改，以及<code class="fe li lj lk ll b">setState</code>什么的。如果你将改变的不是页面，而是别的东西——你将<strong class="ki jg">不会运行</strong>副作用，因为调用参数没有改变——这就是记忆化函数的主要原理。</p><h1 id="4863" class="lm ln jf bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">更多证明？</h1><p id="ac66" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">这里有一个全脂的例子。看着简单，其实很简单。但是解决一个复杂的任务。</p><figure class="of og oh oi gt is"><div class="bz fp l di"><div class="pv ok l"/></div></figure><blockquote class="kc kd ke"><p id="73dc" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">再次:表单输入，再次运行序列，重新运行数据更改的“正确”步骤。</p></blockquote><h1 id="f9f5" class="lm ln jf bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">你刚才提议的是什么？</h1><p id="a280" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">我提议利用<code class="fe li lj lk ll b">react-memoize</code>的力量，更具体地说是<code class="fe li lj lk ll b">MemoizedFlow</code>组件。</p><div class="ip iq gp gr ir pd"><a href="https://github.com/theKashey/react-memoize" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd jg gy z fp pi fr fs pj fu fw je bi translated">记忆/反应-记忆</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">react-memoize -不要忘记缓存您的{props|context|state}。🤞</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">github.com</p></div></div><div class="pm l"><div class="pw l po pp pq pm pr ix pd"/></div></div></a></div><p id="512b" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">只有记忆国家才能提供的神奇记忆。你得试试。</p><p id="b394" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">MemoizedFlow是没有人添加的getDerivedStateFromState，是您可能需要的getDerivedStateFromProps。</p><h2 id="a779" class="nt ln jf bd lo nu nv dn ls nw nx dp lw lf ny nz ma lg oa ob me lh oc od mi oe bi translated">它没有解决的问题</h2><p id="8cdb" class="pw-post-body-paragraph kf kg jf ki b kj mk kl km kn ml kp kq lf mm kt ku lg mn kx ky lh mo lb lc ld ij bi translated">没有<code class="fe li lj lk ll b">prevProps</code>。你可以把它们复制到状态(作为流的最后一步？)但你可能不会“想要”它。您可能想要访问最后一个<code class="fe li lj lk ll b">derived</code>状态，甚至可能已经访问过了。</p><pre class="of og oh oi gt px ll py pz aw qa bi"><span id="e11f" class="nt ln jf ll b gy qb qc l qd qe">&lt;MemoizedFlow <br/>  input={this.state}<br/>  flow={[<br/>     ({stateVariable}) =&gt; ...<br/>     ({oldState}) =&gt; ...<br/>     ({oldState,...rest}) =&gt; this.setState({oldState: rest})<br/>  ]}<br/>&gt; </span></pre><p id="eb03" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">但是它会导致无限循环，只要你改变你所依赖的变量。但是没有超能力可能是件好事。</p><blockquote class="kc kd ke"><p id="fd4b" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">不给你创造一个非常复杂的算法的能力，让你把事情变得简单，可能是好的。</p></blockquote><p id="7f28" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">“记忆化流程”就是让复杂的事情变得简单。仅此而已。</p><p id="9ae9" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq lf ks kt ku lg kw kx ky lh la lb lc ld ij bi translated">关于本库(和本文)可以解决的“问题”的更多信息:</p><div class="ip iq gp gr ir pd"><a href="https://github.com/reactjs/rfcs/pull/40#discussion_r180818891" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd jg gy z fp pi fr fs pj fu fw je bi translated">' getDerivedStateFromProps()'中的' prevProps '由catamphetamine拉取请求#40 reactjs/rfcs</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">向getDerivedStateFromProps()添加prevProps参数如果不合适，请不要犹豫关闭这个RFC:我只是…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">github.com</p></div></div><div class="pm l"><div class="qf l po pp pq pm pr ix pd"/></div></div></a></div><div class="ip iq gp gr ir pd"><a href="https://github.com/reactjs/reactjs.org/issues/721" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd jg gy z fp pi fr fs pj fu fw je bi translated">讨论:componentWillReceiveProps vs getDerivedStateFromProps问题#721 …</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">你好，我们发现了一个场景，删除componentWillReceiveProps会鼓励我们编写更糟糕的代码…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">github.com</p></div></div><div class="pm l"><div class="qg l po pp pq pm pr ix pd"/></div></div></a></div><figure class="of og oh oi gt is"><div class="bz fp l di"><div class="qh ok l"/></div></figure></div></div>    
</body>
</html>