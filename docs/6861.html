<html>
<head>
<title>Type Enforced UserDefaults</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">键入强制用户默认值</h1>
<blockquote>原文：<a href="https://itnext.io/type-enforced-userdefaults-5535f3f7076a?source=collection_archive---------3-----------------------#2022-03-25">https://itnext.io/type-enforced-userdefaults-5535f3f7076a?source=collection_archive---------3-----------------------#2022-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7138" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在iOS上，<a class="ae kl" href="https://developer.apple.com/documentation/foundation/userdefaults" rel="noopener ugc nofollow" target="_blank"> UserDefaults </a>是一个由iOS存储和管理的持久性字典，在应用程序运行时仍然有效。它可以用来在应用程序的用户会话之间存储和检索不同数据类型的键值对。</p><p id="79af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将介绍如何定义一个新的类和特定于类型的枚举，以确保每个键只能由特定的数据类型读取/写入。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/9e162ff2a74706356136f823d69f9917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l2g729xLpQhH44ak"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae kl" href="https://unsplash.com/@monmo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒙瑟蒙莫</a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="5532" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">问题定义</h1><p id="afe3" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">给定UserDefaults的一个键，您可以存储和检索任何类型。例如:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8a4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们最初为键“MyValue”设置了一个整数类型的值，但是我们用一个字符串覆盖了这个值。如果读回的值预期是一个整数，我们可能得不到预期的结果:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="744d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UserDefaults将为同一个键静默存储不同的类型。它还会自动返回给定键的最后存储类型和您试图检索的类型之间的转换值。</p><p id="70e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这种灵活性可能很有用，但开发人员必须手动确保他们使用与每个键相关联的正确数据类型。下面是一个方法，通过它我们可以在编译时保证任何给定的键只能使用期望的类型来访问。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="fdfa" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">在UserDefaults中强制类型</h1><p id="1af4" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">让我们从创建一个新的类开始，它将管理对两种类型的UserDefaults的读/写操作:Integer和String。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f60b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，没有什么可以阻止我们遇到与用户默认值相同的问题。我们可以很容易地为任何给定的键设置整数或字符串。让我们来解决这个问题:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mo"><img src="../Images/c4211c6ba855a1a7659814778e348646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4GkyCf9r67tUQYzyXlfCQ.png"/></div></div></figure><p id="92cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成功！我们的TypeSafeUserDefaults现在阻止我们将一个字符串存储在一个预期用于存储整数的键中。更好的是，我们直接在Xcode中获得即时反馈，如果我们试图使用错误的类型，我们的项目将无法编译。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="cb3e" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">确保所有键都是唯一的</h1><p id="5fe7" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">虽然TypeSafeUserDefaults防止存储错误类型的值，但是如果两个枚举定义相同的键，我们仍然会遇到相同的问题。考虑:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7574" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，我还没有找到一种方法来获得编译时错误。幸运的是，Xcode支持单元测试，所以我们可以通过使我们的enum CaseIterable和使用一些单元测试来确认我们的键是唯一的。让我们用重复的键生成一些枚举:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b37e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们实现一个单元测试来确认所有的键都是惟一的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="14a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当单元测试运行时，我们现在将得到这个失败:</p><p id="6503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mp">xctassertflast失败— StringKey myOtherValue与已经定义的键</em>冲突</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="0f0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这能为您节省数小时的故障排除时间。尽情享受吧！</p></div></div>    
</body>
</html>