<html>
<head>
<title>Perfect Guide of Code First GraphQL Server with GraphQL.js and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL.js和TypeScript的代码优先GraphQL服务器的完美指南</h1>
<blockquote>原文：<a href="https://itnext.io/perfect-guide-of-code-first-graphql-server-with-graphql-js-and-typescript-8cfe09df97ef?source=collection_archive---------3-----------------------#2021-11-06">https://itnext.io/perfect-guide-of-code-first-graphql-server-with-graphql-js-and-typescript-8cfe09df97ef?source=collection_archive---------3-----------------------#2021-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ac743280d9b62530183173cf84dba770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H70K1-T8M5oMOMNtvnbFeQ.png"/></div></div></figure><p id="f95c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://github.com/graphql/graphql-js" rel="noopener ugc nofollow" target="_blank"> GraphQL.js </a>是GraphQL的JavaScript参考实现。这是最好的GraphQL库之一，由<a class="ae kz" href="https://nexusjs.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL Nexus </a>和<a class="ae kz" href="https://typegraphql.com/" rel="noopener ugc nofollow" target="_blank"> TypeGraphQL </a>使用。</p><p id="ad4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然GraphQL.js有很好的文档，但是关于代码优先实现和TypeScript的信息并不多。所以本文解释了如何用GraphQL.js和TypeScript实现code first GraphQL server。</p><p id="61ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文由以下3个主题组成。</p><ol class=""><li id="809d" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">如何用代码优先的方法实现GraphQL模式</li><li id="087c" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">中继样式分页</li><li id="05d2" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">如何用GraphQL代码生成器高效打字</li></ol><h1 id="f9d7" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">故事</h1><p id="b797" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">假设您创建了一个博客应用程序，并为其实现了GraphQL后端。简单的数据模型如下所示。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/633c5e9554f7ed5230aee8a714a994b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYBs8B4lmuaLhbicn_F0cw.png"/></div></div></figure><ul class=""><li id="d564" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky mw lg lh li bi translated">用户有一个配置文件</li><li id="4e71" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky mw lg lh li bi translated">用户有许多帖子</li></ul><p id="2cba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并且您希望创建包含配置文件和帖子的用户查询。</p><h1 id="0872" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">设置GraphQL服务器</h1><p id="155d" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">最小GraphQL服务器是用GraphQL.js、express和express-graphql在<a class="ae kz" href="https://github.com/egurinko/code-first-graphql-example" rel="noopener ugc nofollow" target="_blank">这个库</a>中实现的。如果你想检查完成的代码，请检查<code class="fe mx my mz na b">done</code>分支。</p><p id="bd9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">存储库的结构如下。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="0db1" class="nf lp it na b gy ng nh l ni nj">- repo_root<br/> - package.json<br/> - seed.ts    // user data is here<br/> - src/<br/>  - index.ts  // server implementation is here<br/>  - graphql/  // GraphQL implementation comes here<br/>   - schema.ts</span></pre><p id="0f00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GraphQL实现将出现在<code class="fe mx my mz na b">src/graphql</code>目录中。随着应用程序的增长，它会变得如下所示。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="ff87" class="nf lp it na b gy ng nh l ni nj">- src/<br/>  - schema.ts<br/>  - context.ts<br/>  - query.ts          // import implementations<br/>  - mutation.ts<br/>  - subscription.ts<br/>  - queries/          // query implementations<br/>  - mutations/        // mutation implementations<br/>  - subscriptions/    // subscription implementations<br/>  - types/</span></pre><h1 id="286c" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">代码优先查询实现</h1><p id="1aec" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">让我们按照代码优先方法的<a class="ae kz" href="https://graphql.org/graphql-js/constructing-types/" rel="noopener ugc nofollow" target="_blank"> GraphQL.js文档</a>创建一个用户查询！首先实现GraphQL类型的用户，配置文件和帖子。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="1d9d" class="nf lp it na b gy ng nh l ni nj">// src/graphql/types/postType.ts<br/>import { <br/>  GraphQLObjectType, <br/>  GraphQLInt, <br/>  GraphQLString,<br/>  GraphQLNonNull<br/>} from "graphql";</span><span id="c02f" class="nf lp it na b gy nk nh l ni nj">export const postType = new GraphQLObjectType({<br/>  name: "Post",<br/>  fields: {<br/>    id: { type: new GraphQLNonNull(GraphQLInt) },<br/>    title: { type: new GraphQLNonNull(GraphQLString) },<br/>    detail: { type: new GraphQLNonNull(GraphQLString) },<br/>  }<br/>});</span><span id="54fe" class="nf lp it na b gy nk nh l ni nj">// src/graphql/types/profileType.ts<br/>export const profileType = new GraphQLObjectType({<br/>  name: "Profile",<br/>  fields: {<br/>    id: { type: new GraphQLNonNull(GraphQLInt) },<br/>    name: {<br/>      type: new GraphQLNonNull(GraphQLString),<br/>      resolve: (source, _args, _ctx) =&gt; {<br/>        return source.firstName + source.lastName;<br/>      }<br/>    },<br/>  }<br/>});</span><span id="352e" class="nf lp it na b gy nk nh l ni nj">// src/graphql/types/userType.ts<br/>import { profileType } from "./profileType";<br/>import { postType } from "./postType";</span><span id="7212" class="nf lp it na b gy nk nh l ni nj">export const userType = new GraphQLObjectType({<br/>  name: "User",<br/>  fields: {<br/>    id: { type: new GraphQLNonNull(GraphQLInt) },<br/>    email: { type: new GraphQLNonNull(GraphQLString) },<br/>    profile: { type: new GraphQLNonNull(profileType) },<br/>    posts: {<br/>      type: new GraphQLNonNull(new GraphQLList(postType))<br/>    },<br/>  }<br/>});</span><span id="9ef7" class="nf lp it na b gy nk nh l ni nj">// src/graphql/types/index.ts<br/>export * from "./postType";<br/>export * from "./profileType";<br/>export * from "./userType";</span></pre><p id="f719" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">几乎所有代码都很简单，除了profileType。在种子数据中，profile数据有三个属性<code class="fe mx my mz na b">id</code>、<code class="fe mx my mz na b">firstName</code>、<code class="fe mx my mz na b">lastName</code>。但是在profileType.ts中，<code class="fe mx my mz na b">firstName</code>和<code class="fe mx my mz na b">lastName</code>使用解析器连接到<code class="fe mx my mz na b">name</code>。这种数据转换通常是因为各种原因发生，如前端DX，隐藏一些数据。</p><p id="d511" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在准备用类型实现查询本身。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="24dc" class="nf lp it na b gy ng nh l ni nj">// src/graphql/queries/users.ts<br/>import { GraphQLNonNull, GraphQLList } from "graphql";<br/>import { userType } from "../types";<br/>import { usersSeed } from "../../../seed";</span><span id="e3c9" class="nf lp it na b gy nk nh l ni nj">export const users = {<br/>  type: new GraphQLNonNull(<br/>    new GraphQLList(new GraphQLNonNull(userType))<br/>  ),<br/>  resolve: (_source: any, _args: any, _ctx: any) =&gt; {<br/>    return usersSeed;<br/>  },<br/>};</span><span id="2ff0" class="nf lp it na b gy nk nh l ni nj">// src/graphql/queries/index.ts<br/>export * from "./users";</span></pre><p id="d364" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至此，graphql类型和查询实现已经完成。您唯一要做的就是将查询集成到模式中！</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="5051" class="nf lp it na b gy ng nh l ni nj">// src/graphql/query.ts<br/>import { GraphQLObjectType } from "graphql";<br/>import * as queries from "./queries";</span><span id="5ff0" class="nf lp it na b gy nk nh l ni nj">export const queryType = new GraphQLObjectType({<br/>  name: "Query",<br/>  fields: queries,<br/>});</span><span id="3734" class="nf lp it na b gy nk nh l ni nj">// src/graphql/schema.ts<br/>import { GraphQLSchema } from 'graphql';<br/>import { queryType } from "./query";</span><span id="9141" class="nf lp it na b gy nk nh l ni nj">export const schema = new GraphQLSchema({<br/>  query: queryType, // add this line !<br/>});</span></pre><p id="3971" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查实现是否正确！只需启动服务器并检查图形。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="10dc" class="nf lp it na b gy ng nh l ni nj">$ yarn dev // and go to <a class="ae kz" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graphql</a> in browser</span></pre><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/5cf0f5329a53b8bbd27c7cb044a787a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fuuFZIY3WNQoV1QhKySNDw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">用户查询</figcaption></figure><p id="fff6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一次查询🎉<br/>总之，您需要做三件事来创建查询。</p><ol class=""><li id="37ed" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">定义返回类型</li><li id="ecf3" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">创建查询解析器(实际上与类型实现相同)</li><li id="59cb" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">向模式添加查询</li></ol><p id="3b5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也许你注意到还没有TypeScript类型注释。但是不用担心。在处理TypeScript之前，让我解释一下如何实现中继样式分页。</p><h1 id="def1" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">中继样式分页</h1><p id="9cdf" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">随着数据的增长，应用程序需要分页以获得UX和服务器性能。在GraphQL世界中，最著名的分页特定是<a class="ae kz" href="https://relay.dev/" rel="noopener ugc nofollow" target="_blank">中继</a>样式分页。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/8bb16c854b713e7d5bc80929fa7d7f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ha2M9eXtLbABsKcJaHFd3g.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">中继样式分页</figcaption></figure><p id="fc46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您在上面看到的，它是基于光标的分页。<code class="fe mx my mz na b">users</code>查询接受两个输入<code class="fe mx my mz na b">first</code>和<code class="fe mx my mz na b">after</code>。意思是“请从用户YXJy…之后抽取10个用户”。</p><p id="1e53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回值有<code class="fe mx my mz na b">pageInfo</code>和<code class="fe mx my mz na b">edges</code>。<code class="fe mx my mz na b">node</code>表示数据本身，处理每个节点的关系<code class="fe mx my mz na b">edge</code>。如果你想知道细节，请阅读阿波罗博客关于连接。</p><p id="8267" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://www.apollographql.com/blog/graphql/explaining-graphql-connections/" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/blog/graph QL/explaining-graph QL-connections/</a></p><p id="70c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好像超级难？😫幸运的是，GraphQL.js团队开发了<a class="ae kz" href="https://github.com/graphql/graphql-relay-js" rel="noopener ugc nofollow" target="_blank"> graphql-relay </a>使我们能够轻松实现分页。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="7c37" class="nf lp it na b gy ng nh l ni nj">$ yarn add graphql-relay</span></pre><p id="b6d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以让我们使用graphql-relay对用户和帖子进行分页。是的，当然你可以在多个字段中使用分页。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="3834" class="nf lp it na b gy ng nh l ni nj">// src/graphql/queries/users.ts<br/>import { GraphQLNonNull } from "graphql";<br/>import { <br/>  connectionDefinitions,<br/>  connectionArgs,<br/>  connectionFromArray<br/>} from "graphql-relay";<br/>import { userType } from "../types";<br/>import { usersSeed } from "../../../seed";</span><span id="6421" class="nf lp it na b gy nk nh l ni nj">export const users = {<br/>  type: new GraphQLNonNull(<br/>    connectionDefinitions({ nodeType: userType }).connectionType,<br/>  ),<br/>  args: connectionArgs,<br/>  resolve: (_source: any, args: any, _ctx: any) =&gt; {<br/>    return connectionFromArray(usersSeed, args);<br/>  },<br/>};</span></pre><p id="f5f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，<code class="fe mx my mz na b">type</code>应该被更改，以向模式添加<code class="fe mx my mz na b">edges</code>和<code class="fe mx my mz na b">pageInfo</code>层。但是你只需要用<code class="fe mx my mz na b">connectionDefinitions</code>改变<code class="fe mx my mz na b">type</code>就可以了。</p><p id="1c35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二，应该添加<code class="fe mx my mz na b">args</code>来接受类似<code class="fe mx my mz na b">after</code>、<code class="fe mx my mz na b">first</code>的输入。</p><p id="55ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第三，使用<code class="fe mx my mz na b">connectionFromArray</code>作为解析器。如果向它传递数组和参数，它会计算并格式化数据。</p><p id="c094" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">厉害！这很简单！接下来，让我们像我上面做的那样给文章分页。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="09de" class="nf lp it na b gy ng nh l ni nj">// src/graphql/types/userType.ts<br/>import { <br/>  GraphQLObjectType,<br/>  GraphQLInt,<br/>  GraphQLString,<br/>  GraphQLNonNull<br/>} from "graphql";<br/>import {<br/>  connectionDefinitions,<br/>  connectionArgs,<br/>  connectionFromArray<br/>} from "graphql-relay";<br/>import { profileType } from "./profileType";<br/>import { postType } from "./postType";</span><span id="fb09" class="nf lp it na b gy nk nh l ni nj">export const userType = new GraphQLObjectType({<br/>  name: "User",<br/>  fields: {<br/>    id: { type: new GraphQLNonNull(GraphQLInt) },<br/>    email: { type: new GraphQLNonNull(GraphQLString) },<br/>    profile: { type: new GraphQLNonNull(profileType) },<br/>    posts: {<br/>      // CHANGE HERE<br/>      type: new GraphQLNonNull(<br/>        connectionDefinitions({ <br/>          nodeType: postType <br/>        }).connectionType,<br/>      ),<br/>      args: connectionArgs,<br/>      resolve: (source, args, _ctx) =&gt; {<br/>        return connectionFromArray(source.posts, args)<br/>      }<br/>    },<br/>  }<br/>});</span></pre><p id="f88c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以运行服务器，在graphiql上检查一下！</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/af69c3685d287dbd618731da26d9530d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CGyk4087Cqj2m9xn9L4zuA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">对用户和帖子进行分页</figcaption></figure><p id="f4f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GraphQL和REST的一个很大的区别是，您可以用GraphQL为每个字段设置参数。当创建解析器时，每个解析器可以关注传递给它的参数。</p><h1 id="2b98" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">带有GraphQL代码生成器的TypeScript类型</h1><p id="cc21" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">到目前为止，GraphQL查询是通过代码优先的方法构建的。如果您自己编写代码，您会注意到即使是用TypeScript编写的，也没有TypeScript的优点。</p><p id="0666" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，即使您的一个字段有参数，您的编辑器也不会像下面这样显示类型断言。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/d8a04d7f6b57ca11ecc9c7e3382e5259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLHjxI0yjSmwfjhAfXSTOA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">没有带参数的断言</figcaption></figure><p id="3da4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<a class="ae kz" href="https://nexusjs.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL Nexus </a>，您可以在定义<code class="fe mx my mz na b">args</code>之后获得类型断言，因为它会观察文件变化并动态创建类型脚本类型。但由于GraphQL Nexus还不成熟，存在一些bug，还很难用于生产。</p><p id="c4c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，GraphQL.js本身不会自动生成TypeScript类型。一种简单的方法是分别定义TypeScript类型和实现GrahphQL模式。但是这不是一个聪明的方法，因为GraphQL实现本身也包含类型定义。你的代码不是干的。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/b6ac2529621eb402a1de1d47f6f59528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oae4RAhI7BK5b7O3BDD36w.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">分别定义schema和TypeScript类型。</figcaption></figure><p id="e245" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，<a class="ae kz" href="https://www.graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a>解决了这个问题，从GraphQL实现中自动生成TypeScript类型。让我们看看。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="6fe4" class="nf lp it na b gy ng nh l ni nj">$ yarn add -D <a class="ae kz" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/cli  <a class="ae kz" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/typescript <a class="ae kz" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/typescript-resolvers</span></pre><p id="e420" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，您需要创建一个codegen的配置文件。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="9448" class="nf lp it na b gy ng nh l ni nj">// codegen.yml<br/>schema: <a class="ae kz" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graphql</a><br/>generates:<br/>  ./src/graphql/generatedTypes.ts:<br/>    plugins:<br/>      - typescript<br/>      - typescript-resolvers</span></pre><p id="dd6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您应该将GraphQL模式指定给<code class="fe mx my mz na b">schema</code>选项。<code class="fe mx my mz na b">schema</code>选项也像<code class="fe mx my mz na b">.graphql</code>一样接受GraphQL模式文件。和<code class="fe mx my mz na b">typescript</code>插件从你的模式生成TypeScript类型。<code class="fe mx my mz na b">typescript-resolvers</code>生成GraphQL服务器类型，如resovers类型，它基于<code class="fe mx my mz na b">typescript</code>插件生成的类型。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="b572" class="nf lp it na b gy ng nh l ni nj">// package.json<br/>{<br/>  "scripts":{<br/>    "generate": "graphql-codegen"<br/>  }<br/>}</span><span id="8045" class="nf lp it na b gy nk nh l ni nj">$ yarn generate</span></pre><p id="4f3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行GraphQL代码生成器后，在<code class="fe mx my mz na b">src/graphql/generatedTypes.ts</code>中发现了一个新文件。这有点复杂，但你应该知道有一些类型的类型。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="e2d1" class="nf lp it na b gy ng nh l ni nj">// src/graphql/generatedTypes.ts</span><span id="4ad7" class="nf lp it na b gy nk nh l ni nj">// Response type purely based on GraphQL schema<br/>export type User = {<br/>  __typename?: 'User';<br/>  email: Scalars['String'];<br/>  id: Scalars['ID'];<br/>  posts: PostConnection;<br/>  profile: Profile;<br/>};</span><span id="94a4" class="nf lp it na b gy nk nh l ni nj">// Query Arguments type<br/>export type QueryUsersArgs = {<br/>  after?: Maybe&lt;Scalars['String']&gt;;<br/>  before?: Maybe&lt;Scalars['String']&gt;;<br/>  first?: Maybe&lt;Scalars['Int']&gt;;<br/>  last?: Maybe&lt;Scalars['Int']&gt;;<br/>};</span><span id="4e4c" class="nf lp it na b gy nk nh l ni nj">// Resolver type<br/>export type ResolversTypes = {<br/>  Boolean: ResolverTypeWrapper&lt;Scalars['Boolean']&gt;;<br/>  ID: ResolverTypeWrapper&lt;Scalars['ID']&gt;;<br/>  Int: ResolverTypeWrapper&lt;Scalars['Int']&gt;;<br/>  PageInfo: ResolverTypeWrapper&lt;PageInfo&gt;;<br/>  Post: ResolverTypeWrapper&lt;Post&gt;;<br/>  PostConnection: ResolverTypeWrapper&lt;PostConnection&gt;;<br/>  PostEdge: ResolverTypeWrapper&lt;PostEdge&gt;;<br/>  Profile: ResolverTypeWrapper&lt;Profile&gt;;<br/>  Query: ResolverTypeWrapper&lt;{}&gt;;<br/>  String: ResolverTypeWrapper&lt;Scalars['String']&gt;;<br/>  User: ResolverTypeWrapper&lt;User&gt;;<br/>  UserConnection: ResolverTypeWrapper&lt;UserConnection&gt;;<br/>  UserEdge: ResolverTypeWrapper&lt;UserEdge&gt;;<br/>};</span><span id="a451" class="nf lp it na b gy nk nh l ni nj">// Resolver parent type<br/>export type ResolversParentTypes = {<br/>  Boolean: Scalars['Boolean'];<br/>  ID: Scalars['ID'];<br/>  Int: Scalars['Int'];<br/>  PageInfo: PageInfo;<br/>  Post: Post;<br/>  PostConnection: PostConnection;<br/>  PostEdge: PostEdge;<br/>  Profile: Profile;<br/>  Query: {};<br/>  String: Scalars['String'];<br/>  User: User;<br/>  UserConnection: UserConnection;<br/>  UserEdge: UserEdge;<br/>};</span></pre><p id="c38b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您可以使用这个自动生成的类型进行注释。让我们从graphql类型开始注释。在构建graphql类型时，主要使用<code class="fe mx my mz na b">GraphQLObjectType</code>。如果你检查一下<code class="fe mx my mz na b">GraphQLObjectType</code>的类型定义，就很容易理解如何注释graphql类型。</p><div class="nu nv gp gr nw nx"><a href="https://github.com/graphql/graphql-js/blob/8261922bafb8c2b5c5041093ce271bdfcdf133c3/src/type/definition.ts#L754" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">graph QL-js/definition . ts at 8261922 ba FB 8 C2 b5 c 5041093 ce 271 BDF CDF 133 c 3 graph QL/graph QL-js</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">JavaScript-GraphQL-js/definition . ts的graph QL参考实现位于…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol jz nx"/></div></div></a></div><p id="9419" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从<code class="fe mx my mz na b">GraphqlQLLObjectType</code>定义来看，它接受两个泛型<code class="fe mx my mz na b">TSource</code>和<code class="fe mx my mz na b">TContext</code>。<code class="fe mx my mz na b">TSource</code>是特定字段父级解析器的返回值类型。已经可以批注了！所以从简单的开始。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="d52d" class="nf lp it na b gy ng nh l ni nj">// src/graphql/types/postTypes.ts<br/>import { <br/>  GraphQLObjectType,<br/>  GraphQLInt,<br/>  GraphQLString,<br/>  GraphQLNonNull<br/>} from "graphql";<br/>import { ResolversParentTypes } from "../generatedTypes";<br/>import { Context } from "../context";</span><span id="df4b" class="nf lp it na b gy nk nh l ni nj">export const postType: GraphQLObjectType&lt;ResolversParentTypes["Post"], Context&gt; = <br/>new GraphQLObjectType({<br/>  name: "Post",<br/>  fields: {<br/>    id: { type: new GraphQLNonNull(GraphQLInt) },<br/>    title: { type: new GraphQLNonNull(GraphQLString) },<br/>    detail: { type: new GraphQLNonNull(GraphQLString) },<br/>  }<br/>});</span></pre><p id="8cef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于每个源对象，GraphQL代码生成器生成<code class="fe mx my mz na b">ResolverParentTypes</code>。因为它具有所有源对象类型，所以您可以将其用于所有源类型。</p><p id="17fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然对于没有自定义解析器的graphql类型来说，TypeScript类型注释似乎没有意义，但还是为以后的自定义解析器进行注释比较好。和下面的其他graphql类型。接下来，<code class="fe mx my mz na b">profileType</code>。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="99ef" class="nf lp it na b gy ng nh l ni nj">// src/graphql/types/profileType.ts<br/>import { <br/>  ResolversParentTypes, <br/>  ResolversTypes<br/>} from "../generatedTypes";<br/>import { Context } from "../context";</span><span id="f994" class="nf lp it na b gy nk nh l ni nj">export const profileType: GraphQLObjectType&lt;ResolversParentTypes["Profile"], Context&gt; = new GraphQLObjectType({<br/>  name: "Profile",<br/>  fields: {<br/>    id: { type: new GraphQLNonNull(GraphQLInt) },<br/>    name: {<br/>      type: new GraphQLNonNull(GraphQLString),<br/>      resolve: (source, _args): ResolversTypes["String"] =&gt; {<br/>        return source.firstName + source.lastName;<br/>      }<br/>    },<br/>  }<br/>});</span></pre><p id="9f13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您的一个字段有一个自定义解析器，您可以使用<code class="fe mx my mz na b">ResolversTypes</code>作为返回类型注释。但是如果你尝试一下，可能会发现如下的类型错误。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/e92ef1314b0297981d20459c62f35876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXyVus7ZDILvz11nRIU88g.png"/></div></div></figure><p id="3e2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">什么？？<code class="fe mx my mz na b">source</code>没有<code class="fe mx my mz na b">firstName</code>和<code class="fe mx my mz na b">lastName</code>？但是source确实拥有这两者，因为它来自种子数据。如果您检查GraphQL代码生成器生成的<code class="fe mx my mz na b">Profile</code>类型和种子数据，您就能理解它。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="5b3d" class="nf lp it na b gy ng nh l ni nj">// generated Profile type in generatedTypes.ts<br/>export type Profile = {<br/>  __typename?: 'Profile';<br/>  id: Scalars['Int'];<br/>  name: Scalars['String'];<br/>};</span><span id="0ce9" class="nf lp it na b gy nk nh l ni nj">// seed data ProfileModel type<br/>export type ProfileModel = {<br/>  id: number;<br/>  firstName: string;<br/>  lastName: string;<br/>}</span></pre><p id="97f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GraphQL代码生成器从架构生成TypeScript类型。这就是为什么生成的概要文件类型只有<code class="fe mx my mz na b">name</code>属性。另外，生成的轮廓类型用于<code class="fe mx my mz na b">ResolversParentType</code>、<code class="fe mx my mz na b">ResolversTypes</code>等。这就是为什么带注释的源代码似乎没有<code class="fe mx my mz na b">firstName</code>和<code class="fe mx my mz na b">lastName</code>属性。</p><p id="27cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种模式和应用程序类型之间的不匹配通常发生在创建自定义解析器时。为了避免这种情况，您可以使用GraphQL代码生成器的mapper config。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="686d" class="nf lp it na b gy ng nh l ni nj">// codegen.yml<br/>schema: <a class="ae kz" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graphql</a><br/>generates:<br/>  ./src/graphql/generatedTypes.ts:<br/>    plugins:<br/>      - typescript<br/>      - typescript-resolvers<br/>    config:<br/>      mappers:<br/>        Profile: ../../seed#ProfileModel<br/>        User: ../../seed#UserModel</span></pre><p id="badd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为配置文件和post连接不同，所以它们都映射到应用程序类型。如果你想知道更多关于mappers配置的信息，请参考GraphQL代码生成器文档。</p><div class="nu nv gp gr nw nx"><a href="https://www.graphql-code-generator.com/docs/plugins/typescript-resolvers" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">类型脚本解析器| GraphQL代码生成器</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">这个插件为GraphQL API的解析函数生成类型脚本签名。你可以使用这个插件来…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">www.graphql-code-generator.com</p></div></div></div></a></div><p id="e2e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您再次运行<code class="fe mx my mz na b">yarn generate</code>，您将看不到任何错误！所以我们去看一下<code class="fe mx my mz na b">userType</code>。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="540d" class="nf lp it na b gy ng nh l ni nj">// src/graphql/types/userTypes.ts<br/>import { <br/>  ResolversParentTypes,<br/>  ResolversTypes,<br/>  UserPostsArgs<br/>} from "../generatedTypes";<br/>import { Context } from "../context";</span><span id="e044" class="nf lp it na b gy nk nh l ni nj">export const userType: GraphQLObjectType&lt;ResolversParentTypes["User"], Context&gt; = new GraphQLObjectType({<br/>  name: "User",<br/>  fields: {<br/>    id: { type: new GraphQLNonNull(GraphQLInt) },<br/>    email: { type: new GraphQLNonNull(GraphQLString) },<br/>    profile: { type: new GraphQLNonNull(profileType) },<br/>    posts: {<br/>      type: new GraphQLNonNull(<br/>        connectionDefinitions({ <br/>          nodeType: postType <br/>        }).connectionType,<br/>      ),<br/>      args: connectionArgs,<br/>      resolve: (source, args: UserPostsArgs, _ctx): ResolversTypes["PostConnection"] =&gt; {<br/>        return connectionFromArray(source.posts, args)<br/>      }<br/>    },<br/>  }<br/>});</span></pre><p id="23d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为posts字段有自定义解析器，并且定义了args，所以需要使用<code class="fe mx my mz na b">ResolverTypes</code>和<code class="fe mx my mz na b">UserPostsArgs</code>进行注释。每个参数类型都是完美生成的。这样打字就完成了！</p><p id="be8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一个是用户查询。当你检查<code class="fe mx my mz na b">src/graphql/query.ts</code>时，你可以知道<code class="fe mx my mz na b">users</code>查询只是GraphQL的一个字段配置。所以让我们先检查GraphQL.js的字段配置定义。</p><p id="ab9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://github.com/graphql/graphql-js/blob/c589c3d285cb1ec44b09bf0b50ec041ec083760c/src/type/definition.ts#L992" rel="noopener ugc nofollow" target="_blank">https://github . com/graph QL/graph QL-js/blob/c 589 C3 d 285 CB 1 EC 44 b 09 BF 0 b 50 EC 041 EC 083760 c/src/type/definition . ts # L992</a></p><p id="c4dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所检查的，<code class="fe mx my mz na b">GraphQLFieldConfig</code>接受3个泛型<code class="fe mx my mz na b">TSource</code>、<code class="fe mx my mz na b">TContext</code>、<code class="fe mx my mz na b">TArgs</code>。我希望你已经了解了每一种类型。</p><pre class="ms mt mu mv gt nb na nc nd aw ne bi"><span id="d367" class="nf lp it na b gy ng nh l ni nj">// src/graphql/queries/users.ts<br/>import { GraphQLNonNull, GraphQLFieldConfig } from "graphql";<br/>import { <br/>  connectionDefinitions,<br/>  connectionArgs,<br/>  connectionFromArray<br/>} from "graphql-relay";<br/>import { userType } from "../types";<br/>import { <br/>  QueryUsersArgs,<br/>  ResolversParentTypes,<br/>  ResolversTypes }<br/>from "../generatedTypes";<br/>import { Context } from "../context";<br/>import { usersSeed } from "../../../seed";</span><span id="9e5c" class="nf lp it na b gy nk nh l ni nj">export const users: GraphQLFieldConfig&lt;ResolversParentTypes["Query"], Context, QueryUsersArgs&gt; = {<br/>  type: new GraphQLNonNull(<br/>    connectionDefinitions({ nodeType: userType }).connectionType,<br/>  ),<br/>  args: connectionArgs,<br/>  resolve: (_source, args, _ctx): ResolversTypes["UserConnection"] =&gt; {<br/>    return connectionFromArray(usersSeed, args);<br/>  },<br/>};</span></pre><p id="fbc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嘣！完美！</p><p id="6314" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，GraphQL实现和代码生成步骤是完全分开的。但是，因为GraphQL代码生成器可以在监视模式下运行，所以可以用TypeScript类型实现GraphQL服务器。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="36ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文解释了如何用GraphQL.js和TypeScript实现code first GraphQL server。而且题目分的像下面这样。</p><ol class=""><li id="b5f2" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">如何用代码优先的方法实现GraphQL模式</li><li id="189c" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">中继样式分页</li><li id="140e" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">如何用GraphQL代码生成器高效打字</li></ol><p id="84c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成的代码在这个库的<code class="fe mx my mz na b"><a class="ae kz" href="https://github.com/egurinko/code-first-graphql-example/tree/done" rel="noopener ugc nofollow" target="_blank">done</a></code>分支<a class="ae kz" href="https://github.com/egurinko/code-first-graphql-example/tree/done" rel="noopener ugc nofollow" target="_blank">上。如果你有问题，随时问我。谢谢大家！</a></p><h1 id="5c64" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">参考</h1><ul class=""><li id="10eb" class="la lb it kd b ke mm ki mn km ou kq ov ku ow ky mw lg lh li bi translated"><a class="ae kz" href="https://graphql.org/graphql-js/" rel="noopener ugc nofollow" target="_blank"> GraphQL.js </a></li><li id="3057" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky mw lg lh li bi translated"><a class="ae kz" href="https://nexusjs.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL Nexus </a></li><li id="6124" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky mw lg lh li bi translated"><a class="ae kz" href="https://typegraphql.com/" rel="noopener ugc nofollow" target="_blank">类型图QL </a></li><li id="aa53" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky mw lg lh li bi translated"><a class="ae kz" href="https://www.graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a></li><li id="1907" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky mw lg lh li bi translated"><a class="ae kz" href="https://github.com/egurinko/code-first-graphql-example" rel="noopener ugc nofollow" target="_blank">范例知识库</a></li></ul></div></div>    
</body>
</html>