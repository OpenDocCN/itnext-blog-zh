<html>
<head>
<title>Taming React with Kotlin-JS and coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">驯服与Kotlin-JS和协同程序反应</h1>
<blockquote>原文：<a href="https://itnext.io/taming-react-with-kotlin-js-and-coroutines-ef0d3f72b3ea?source=collection_archive---------3-----------------------#2019-09-28">https://itnext.io/taming-react-with-kotlin-js-and-coroutines-ef0d3f72b3ea?source=collection_archive---------3-----------------------#2019-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/42f56389b2d56a34b52ec243482cc229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*F3b7ACkzXyO4QxU2Vy2zeA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">驯服野马——乔治·凯特林(<a class="ae kc" href="https://www.canvasreplicas.com/" rel="noopener ugc nofollow" target="_blank">https://www.canvasreplicas.com/</a>)</figcaption></figure><p id="3fef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇短文讲的是一个小技巧，它最终让我能够在我的<a class="ae kc" href="https://kotlinlang.org/docs/tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript.html" rel="noopener ugc nofollow" target="_blank"> Kotlin-JS </a>应用程序中充分使用<a class="ae kc" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React-js </a>组件。</p><p id="7da2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是浏览器JavaScript应用程序最流行的平台之一。它的主要思想是允许用户用javascript构建声明性UI，并自动传播状态变化，而不需要显式回调和重绘触发器。React还以其reconcile算法而闻名，该算法允许计算内存中DOM树的变化，而无需实际将它们绘制到屏幕上。</p><p id="65ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">坦率地说，我不确定Kotlin-JS是否需要React。在纯Kotlin中创建一个反应式应用程序是非常容易的，并且<code class="fe lb lc ld le b">kotlinx.html</code>库允许轻松地创建内存中的DOM结构，而不需要渲染它们。关于这一点的一些机制和考虑写在关于ploty.kt的文章中。尽管如此，我们并不是生活在真空中，当我们需要创建一个合理的UI时，我们需要依赖现有的库。我的经验表明，很难找到一个编写良好的纯JS组件库。大多数旧版本都是用旧版本的JavaScript编写的，很难阅读，甚至更难与静态类型的Kotlin-JS进行互操作。新的主要是为React、Vue或Agular框架编写的。React相当流行，有大量现成的组件，所以从它开始是有意义的。另外，在<a class="ae kc" href="https://play.kotlinlang.org/hands-on/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/" rel="noopener ugc nofollow" target="_blank"> Kotlin动手材料</a>中有一个很棒的React教程。</p><p id="d6e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，我还是遇到了一个相当严重的问题，这个问题几乎使React无法用于我的目的。问题是React真的不喜欢它内部的变化受到外部的影响。对于不与任何外部组件通信的单页React应用程序来说，这是很好的，但是如果我有一些非React应用程序，并且只想使用单独的基于React的组件，这就很方便了。当然，我可以让React感染我的应用程序，并将我自己的UI片段包装在React组件中，但我最初的想法是在我更大的应用程序中使用React组件，而不是反过来。那我该怎么帮呢？</p><p id="5169" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我一直在阅读的React教程建议将侦听器函数作为组件属性的一部分来传递。在Kotlin中，这种函数的签名看起来像<code class="fe lb lc ld le b">typealias Listener = State.()-&gt;Unit</code>或类似的东西。然后，只要我想通知外部侦听器状态的变化，就可以从组件中触发该函数。但这不是我想做的，我想通过外部触发来改变内部状态，而且不是一次，而是多次。当然，我可以创建一个允许订阅的特殊对象，将它传递给组件，然后强制组件订阅更改，但是这个解决方案看起来相当麻烦。但是在非同步实体之间传递消息是kotlin协程的完美案例。让我们看看我们能做些什么。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="eb2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要点(用依赖项和HTML文件的构建脚本部分补充)展示了如何完成。想法如下:我们创建一个协程<a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/" rel="noopener ugc nofollow" target="_blank">通道</a>，并将其作为参数传递给React组件。然后，我们所要做的就是在组件内部创建一个消费者循环，我们可以从外部完全控制我们的状态变化。我们可以发送单独的消息，定期发送或手动关闭频道。我们甚至可以使用流到通道转换来组织来自外部源的数据管道。我使用rendezvous channel，这样一旦我们的页面无法处理呈现，新的状态变化就会停止传播(这是协程提供的自动反压机制)。如果我们生成了太多的更改，那么发送方将会挂起并等待组件评估之前的请求。还可以使用由通道和流API提供的不同变体。例如，当我们有几个变化等待渲染时，我们可以只绘制最新的状态变化。</p></div></div>    
</body>
</html>