<html>
<head>
<title>Kubernetes Probes: Startup, Liveness, Readiness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes探测器:启动、活性、就绪</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-probes-startup-liveness-readiness-a9fc9ccff4b2?source=collection_archive---------2-----------------------#2021-02-16">https://itnext.io/kubernetes-probes-startup-liveness-readiness-a9fc9ccff4b2?source=collection_archive---------2-----------------------#2021-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e6d3b667f205917e8875d8236a342673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_VToRy_tzJm5SXI2Fx_-g.jpeg"/></div></div></figure><div class=""/><p id="580e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作者Levent Ogut</p><p id="af64" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubernetes具有颠覆性，因为它增加了云部署的可伸缩性、速度、可移植性和可观察性。虽然它带来了一个包含强大功能和选项的完整生态系统，并简化了复杂的部署，但它也有自己的挑战。Kubernetes带给我们的一个重要特性是高可用性。Kubernetes中有许多高可用性选项；在本文中，我们将讨论用于应用程序/微服务本身的高可用性选项。</p><p id="9d7e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">pods——Kubernetes中最小的可部署单元——一旦应用了声明性配置，就会被调度。Kube-scheduler负责计算和调度；一旦调度被接受，它就处于受控和计算的环境中，并且它被pod条件视为服务就绪或未就绪。使用启动、就绪和活动探测器，我们可以控制pod何时应该被视为启动、准备好服务或活动。我们将探讨这些条件和触发因素。</p><figure class="la lb lc ld gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi kz"><img src="../Images/32a05a17c0f07de08a664c5fec7bfe77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_Df0rg3LL2dVlIA7"/></div></div></figure><h1 id="8973" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Pod和容器状态</h1><p id="0c7b" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">豆荚有阶段和条件；容器有状态。这些状态属性可以而且将会根据探测结果而改变，所以让我们来研究一下它们。</p><p id="4180" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Pod状态对象包括一个<a class="ae mh" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase" rel="noopener ugc nofollow" target="_blank">阶段</a>字段。这个<a class="ae mh" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase" rel="noopener ugc nofollow" target="_blank">相位场</a>告诉Kubernetes和我们一个pod在哪个执行周期。</p><ul class=""><li id="36f3" class="mi mj je kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated"><strong class="kd jf"> Pending: </strong>被集群接受，容器尚未设置。</li><li id="fb1c" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd jf">运行:</strong>至少有一个容器处于运行、启动或重新启动状态。</li><li id="2d0d" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd jf">成功:</strong>所有容器退出，状态码为零；pod将不会重新启动。</li><li id="ae2e" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd jf">失败:</strong>所有容器都已终止，并且至少有一个容器以非零状态代码退出。</li><li id="f141" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd jf">未知:</strong>无法确定pod的状态。</li></ul><h1 id="5bf1" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Pod条件</h1><p id="5d0f" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">除了荚果阶段，还有荚果条件。这些还提供了关于pod所处状态的信息。</p><ul class=""><li id="faa3" class="mi mj je kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated"><strong class="kd jf"> PodScheduled: </strong>已经成功选择一个节点对pod进行调度，调度完成。</li><li id="a43e" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">集装箱准备好了:所有的集装箱都准备好了。</li><li id="84e5" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd jf">初始化</strong>:初始化容器启动。</li><li id="79ba" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd jf">准备就绪:</strong>分离舱可以服务请求；因此，它需要包含在服务和负载平衡器中。</li></ul><p id="7725" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过<code class="fe mw mx my mz b">kubectl describe pods &lt;POD_NAME&gt;</code>命令查看pod状态。</p><pre class="la lb lc ld gt na mz nb nc aw nd bi"><span id="5dac" class="ne lf je mz b gy nf ng l nh ni">kubectl describe pods &lt;POD_NAME&gt;</span></pre><p id="a84b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">示例输出如下:</p><pre class="la lb lc ld gt na mz nb nc aw nd bi"><span id="0edd" class="ne lf je mz b gy nf ng l nh ni">...<br/>Conditions:<br/>  Type              Status<br/>  Initialized       True <br/>  Ready             True <br/>  ContainersReady   True <br/>  PodScheduled      True <br/>...</span></pre><h1 id="887c" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">集装箱国家</h1><p id="e2a3" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">容器有三种简单的状态。</p><ul class=""><li id="b421" class="mi mj je kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated"><a class="ae mh" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#containerstatewaiting-v1-core" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf">等待</strong> </a> <strong class="kd jf"> : </strong>成功启动所需的进程正在运行。</li><li id="5767" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae mh" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#containerstaterunning-v1-core" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf">正在运行</strong> </a> <strong class="kd jf"> : </strong>容器正在执行。</li><li id="42f8" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae mh" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#containerstateterminated-v1-core" rel="noopener ugc nofollow" target="_blank"> <strong class="kd jf">终止</strong> </a> <strong class="kd jf"> : </strong>容器开始执行，以成功或失败结束。</li></ul><h1 id="7907" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">浏览Pod对象的状态</h1><p id="dcde" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">通过发出Kubernetes get pods -o yaml命令，我们可以从pod对象中看到<a class="ae mh" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#pod-v1-core" rel="noopener ugc nofollow" target="_blank"> pod </a>条件和容器状态。</p><pre class="la lb lc ld gt na mz nb nc aw nd bi"><span id="ba56" class="ne lf je mz b gy nf ng l nh ni">...<br/>status:<br/>  conditions:<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2021-02-08T11:11:53Z"<br/>    status: "True"<br/>    type: Initialized<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2021-02-08T11:14:20Z"<br/>    status: "True"<br/>    type: Ready<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2021-02-08T11:14:20Z"<br/>    status: "True"<br/>    type: ContainersReady<br/>  - lastProbeTime: null<br/>    lastTransitionTime: "2021-02-08T11:11:52Z"<br/>    status: "True"<br/>    type: PodScheduled<br/>  containerStatuses:<br/>  - containerID: containerd://7fc67a850ba439f64ecb51a129a2d7dcbc4a3402b253daa3a6827787f7c80e40<br/>    image: docker.io/library/nginx:latest<br/>    imageID: docker.io/library/nginx@sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aa<br/>    lastState:<br/>      terminated:<br/>        containerID: containerd://c4416e69b7348a7e7be3f7046dc9745dfb38ba537e5b8c06da5020c67b12b3d8<br/>        exitCode: 137<br/>        finishedAt: "2021-02-08T11:14:52Z"<br/>        reason: Error<br/>        startedAt: "2021-02-08T11:14:05Z"<br/>    name: nginx<br/>    ready: true<br/>    restartCount: 1<br/>    started: true<br/>    state:<br/>      running:<br/>        startedAt: "2021-02-08T11:16:28Z"<br/>  hostIP: x.x.x.x<br/>  phase: Running<br/>  podIP: 10.1.239.205<br/>  podIPs:<br/>  - ip: 10.1.239.205<br/>  qosClass: BestEffort<br/>  startTime: "2021-02-08T11:11:53Z"</span></pre><p id="28f0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你更喜欢JSON，你可以使用<code class="fe mw mx my mz b">kubectl get pods &lt;POD_NAME&gt; -o jsonpath='{.status}' | jq</code></p><pre class="la lb lc ld gt na mz nb nc aw nd bi"><span id="b29a" class="ne lf je mz b gy nf ng l nh ni">{<br/>  "conditions": [<br/>    {<br/>      "lastProbeTime": null,<br/>      "lastTransitionTime": "2021-02-08T11:11:53Z",<br/>      "status": "True",<br/>      "type": "Initialized"<br/>    },<br/>    {<br/>      "lastProbeTime": null,<br/>      "lastTransitionTime": "2021-02-08T11:14:20Z",<br/>      "status": "True",<br/>      "type": "Ready"<br/>    },<br/>    {<br/>      "lastProbeTime": null,<br/>      "lastTransitionTime": "2021-02-08T11:14:20Z",<br/>      "status": "True",<br/>      "type": "ContainersReady"<br/>    },<br/>    {<br/>      "lastProbeTime": null,<br/>      "lastTransitionTime": "2021-02-08T11:11:52Z",<br/>      "status": "True",<br/>      "type": "PodScheduled"<br/>    }<br/>  ],<br/>  "containerStatuses": [<br/>    {<br/>      "containerID": "containerd://7fc67a850ba439f64ecb51a129a2d7dcbc4a3402b253daa3a6827787f7c80e40",<br/>      "image": "docker.io/library/nginx:latest",<br/>      "imageID": "docker.io/library/nginx@sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aa",<br/>      "lastState": {<br/>        "terminated": {<br/>          "containerID": "containerd://c4416e69b7348a7e7be3f7046dc9745dfb38ba537e5b8c06da5020c67b12b3d8",<br/>          "exitCode": 137,<br/>          "finishedAt": "2021-02-08T11:14:52Z",<br/>          "reason": "Error",<br/>          "startedAt": "2021-02-08T11:14:05Z"<br/>        }<br/>      },<br/>      "name": "nginx",<br/>      "ready": true,<br/>      "restartCount": 1,<br/>      "started": true,<br/>      "state": {<br/>        "running": {<br/>          "startedAt": "2021-02-08T11:16:28Z"<br/>        }<br/>      }<br/>    }<br/>  ],<br/>  "hostIP": "x.x.x.x",<br/>  "phase": "Running",<br/>  "podIP": "10.1.239.205",<br/>  "podIPs": [<br/>    {<br/>      "ip": "10.1.239.205"<br/>    }<br/>  ],<br/>  "qosClass": "BestEffort",<br/>  "startTime": "2021-02-08T11:11:53Z"<br/>}</span></pre><h1 id="98fd" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Kubernetes的探针</h1><p id="1bae" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">Kubernetes提供探针(健康检查)来监控和处理pod的状态或条件，以确保只有健康的pod才能服务于交通。</p><p id="cdbc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubelet负责运行健康检查，用相关信息更新API服务器。</p><h1 id="f09c" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">探测处理器</h1><p id="3856" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">三个可用的处理程序可以覆盖几乎任何场景。</p><h2 id="3fa3" class="ne lf je bd lg nj nk dn lk nl nm dp lo km nn no ls kq np nq lw ku nr ns ma nt bi translated">执行操作</h2><p id="3ac3" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated"><a class="ae mh" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#execaction-v1-core" rel="noopener ugc nofollow" target="_blank"> ExecAction </a>在容器内部执行命令；这也是一个网关功能，可以处理任何事情，因为我们可以运行任何可执行文件；这可能是一个运行几个curl请求来确定状态的脚本，或者是一个连接到外部依赖项的可执行文件。确保可执行文件不会创建僵尸进程。</p><h2 id="339b" class="ne lf je bd lg nj nk dn lk nl nm dp lo km nn no ls kq np nq lw ku nr ns ma nt bi translated">TCP套接字操作</h2><p id="05c6" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated"><a class="ae mh" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#tcpsocketaction-v1-core" rel="noopener ugc nofollow" target="_blank"> TCPSocketAction </a>连接到一个已定义的端口，检查该端口是否打开，主要用于不进行HTTP对话的端点。HTTP获取操作</p><p id="0b81" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">向定义的路径发送HTTP Get请求作为探测；HTTP响应代码决定探测是否成功。</p><h1 id="1455" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">通用探头参数</h1><p id="3f06" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">每种类型的探测器都有通用的可配置字段:</p><ul class=""><li id="a25c" class="mi mj je kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated"><strong class="kd jf"> initialDelaySeconds </strong>:容器启动后、探头启动前的秒数。(默认值:0)</li><li id="353c" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd jf">周期秒</strong>:pod的频率。(默认值:10)</li><li id="6bc0" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd jf">超时秒数</strong>:预期响应超时。(默认值:1)</li><li id="b836" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd jf"> successThreshold </strong>:收到多少成功结果，从失败状态转换到健康状态。(默认值:1)</li><li id="bfef" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd jf">失败尿道阈值</strong>:接收到多少失败结果，以从健康状态转换到失败状态。(默认值:3)</li></ul><p id="9be7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，我们可以详细配置探头。为了成功配置探针，我们需要分析我们的应用/微服务的需求和依赖性。</p><h1 id="f211" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">启动探测器</h1><p id="ce51" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">如果您的流程需要时间来准备，读取文件、解析大型配置、准备一些数据等等，您应该使用<a class="ae mh" href="https://loft.sh/blog/kubernetes-startup-probes-examples-common-pitfalls/" rel="noopener ugc nofollow" target="_blank">启动探测器</a>。如果探测失败，超过阈值，它将重新启动，以便操作可以重新开始。您需要相应地调整initialDelaySeconds和periodSeconds，以确保该过程有足够的时间来完成。否则，您会在重启的循环中找到您的pod。</p><h1 id="04e8" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">就绪探测</h1><p id="cfba" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">如果您想控制发送到pod的流量，您应该使用就绪探测器。<a class="ae mh" href="https://loft.sh/blog/kubernetes-readiness-probes-examples-common-pitfalls/" rel="noopener ugc nofollow" target="_blank">准备就绪探测器</a>修改pod条件:准备更改Pod是否应包含在服务和负载平衡器中。当探测成功的次数足够多(阈值)时，这意味着pod可以接收流量，并且它应该包含在服务和负载平衡器中。如果您的流程有能力将自己从服务中取出进行维护，读取大量数据用于服务，等等。同样，您应该使用就绪探测器。因此，pod可以通过就绪探测器向kublet发出信号，表示它希望暂时停止服务。</p><h1 id="d86a" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">活性探针</h1><p id="f5fd" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">如果发生意外错误时容器不能自行崩溃，请使用活跃度探测器。使用活跃度探测器可以克服进程可能存在的一些错误。一旦<a class="ae mh" href="https://loft.sh/blog/kubernetes-liveness-probes-examples-common-pitfalls/index-1/" rel="noopener ugc nofollow" target="_blank">活性探针</a>失效，Kublet重启pod。</p><p id="c875" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您的进程可以通过退出来处理这些错误，您就不需要使用活跃度探测器；然而，在未知的错误被修复之前，包容它们是有利的。</p><h1 id="4c12" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">例如:Kubernetes API</h1><p id="4072" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">Kubernetes API还包括健康检查端点:healthz(已弃用)、readyz、livez。</p><p id="aa89" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看设计用于就绪探头的<code class="fe mw mx my mz b">readyz</code>端点。</p><pre class="la lb lc ld gt na mz nb nc aw nd bi"><span id="5454" class="ne lf je mz b gy nf ng l nh ni">kubectl get --raw='/readyz?verbose'</span></pre><p id="6b39" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单个服务运行状况被组合起来显示运行状况。</p><pre class="la lb lc ld gt na mz nb nc aw nd bi"><span id="45a4" class="ne lf je mz b gy nf ng l nh ni">[+]ping ok<br/>[+]log ok<br/>[+]etcd ok<br/>[+]informer-sync ok<br/>[+]poststarthook/start-kube-apiserver-admission-initializer ok<br/>[+]poststarthook/generic-apiserver-start-informers ok<br/>[+]poststarthook/start-apiextensions-informers ok<br/>[+]poststarthook/start-apiextensions-controllers ok<br/>[+]poststarthook/crd-informer-synced ok<br/>[+]poststarthook/bootstrap-controller ok<br/>[+]poststarthook/scheduling/bootstrap-system-priority-classes ok<br/>[+]poststarthook/start-cluster-authentication-info-controller ok<br/>[+]poststarthook/aggregator-reload-proxy-client-cert ok<br/>[+]poststarthook/start-kube-aggregator-informers ok<br/>[+]poststarthook/apiservice-registration-controller ok<br/>[+]poststarthook/apiservice-status-available-controller ok<br/>[+]poststarthook/kube-apiserver-autoregistration ok<br/>[+]autoregister-completion ok<br/>[+]poststarthook/apiservice-openapi-controller ok<br/>[+]shutdown ok<br/>healthz check passed</span></pre><p id="29bd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来看一下<code class="fe mw mx my mz b">livez</code>端点。</p><pre class="la lb lc ld gt na mz nb nc aw nd bi"><span id="b2f8" class="ne lf je mz b gy nf ng l nh ni">kubectl get --raw='/livez?verbose'</span></pre><p id="c5a7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">单个服务运行状况被组合起来显示运行状况。</p><pre class="la lb lc ld gt na mz nb nc aw nd bi"><span id="db9a" class="ne lf je mz b gy nf ng l nh ni">[+]ping ok<br/>[+]log ok<br/>[+]etcd ok<br/>[+]poststarthook/start-kube-apiserver-admission-initializer ok<br/>[+]poststarthook/generic-apiserver-start-informers ok<br/>[+]poststarthook/start-apiextensions-informers ok<br/>[+]poststarthook/start-apiextensions-controllers ok<br/>[+]poststarthook/crd-informer-synced ok<br/>[+]poststarthook/bootstrap-controller ok<br/>[+]poststarthook/scheduling/bootstrap-system-priority-classes ok<br/>[+]poststarthook/start-cluster-authentication-info-controller ok<br/>[+]poststarthook/aggregator-reload-proxy-client-cert ok<br/>[+]poststarthook/start-kube-aggregator-informers ok<br/>[+]poststarthook/apiservice-registration-controller ok<br/>[+]poststarthook/apiservice-status-available-controller ok<br/>[+]poststarthook/kube-apiserver-autoregistration ok<br/>[+]autoregister-completion ok<br/>[+]poststarthook/apiservice-openapi-controller ok<br/>healthz check passed</span></pre><h1 id="138f" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="488c" class="pw-post-body-paragraph kb kc je kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们探索了Kubernetes探测器；它们是高可用性等式的重要组成部分。另一方面，错误配置会对我们的应用程序/微服务的可用性产生负面影响。最重要的是适当地配置和测试不同的场景以找到最佳值；我们需要考虑外部来源的稳定性，以及我们是否会在探测响应端点上包括这种检查。我们已经看到，就绪探测器的动作是在服务和负载平衡器中删除或包含pod，而活性探测器的动作是在超过阈值的足够多的故障时重新启动pod。您可以在“进一步阅读”部分找到以前文章的链接，这些文章详细介绍了就绪性、活性和启动探测。</p><h1 id="12cf" class="le lf je bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">进一步阅读</h1><ul class=""><li id="cc21" class="mi mj je kd b ke mc ki md km nu kq nv ku nw ky mn mo mp mq bi translated"><a class="ae mh" href="https://loft.sh/blog/kubernetes-startup-probes-examples-common-pitfalls/" rel="noopener ugc nofollow" target="_blank"> Kubernetes启动探测器—示例&amp;常见陷阱</a></li><li id="9553" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae mh" href="https://loft.sh/blog/kubernetes-liveness-probes-examples-common-pitfalls/index-1/" rel="noopener ugc nofollow" target="_blank"> Kubernetes活性探针—示例&amp;常见陷阱</a></li><li id="68db" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae mh" href="https://loft.sh/blog/kubernetes-readiness-probes-examples-common-pitfalls/" rel="noopener ugc nofollow" target="_blank"> Kubernetes就绪探针—示例&amp;常见陷阱</a></li><li id="ed56" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae mh" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#probe-v1-core" rel="noopener ugc nofollow" target="_blank"> Kubernetes核心探测器文档</a></li><li id="113e" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae mh" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank">配置活性、就绪和启动探测器</a></li><li id="89d7" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae mh" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes" rel="noopener ugc nofollow" target="_blank"> Kubernetes容器探测器文档</a>。</li><li id="10fe" class="mi mj je kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae mh" href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/" rel="noopener ugc nofollow" target="_blank">容器生命周期挂钩文档</a></li></ul></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="bb73" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="oe">最初发布于</em><a class="ae mh" href="https://loft.sh/blog/kubernetes-probes-startup-liveness-readiness/" rel="noopener ugc nofollow" target="_blank"><em class="oe">https://loft . sh</em></a><em class="oe">。</em></p></div></div>    
</body>
</html>