<html>
<head>
<title>Fun JavaScript: Safely dealing with undefined/null values using functional programming.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有趣的JavaScript:使用函数式编程安全地处理未定义/空值。</h1>
<blockquote>原文：<a href="https://itnext.io/fun-javascript-safely-dealing-with-undefined-null-values-using-functional-programming-39dcbc61eb0c?source=collection_archive---------3-----------------------#2021-03-27">https://itnext.io/fun-javascript-safely-dealing-with-undefined-null-values-using-functional-programming-39dcbc61eb0c?source=collection_archive---------3-----------------------#2021-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5b3bbda247da1bcdac311f2ff64697c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKXEu9oi0HZUlhiuOuB35A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:https://www.carecreations.basf.com/</figcaption></figure><p id="03ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们假设有一个我们想要应用运算的数字，如果这个数字是未定义的/空的，我们想要避免一个错误或意想不到的结果。该操作将<em class="lb">添加</em>。</p><p id="f6e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种必不可少的方法是:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e57f" class="ll lm iq lh b gy ln lo l lp lq">const number = // getting number from somewhere (DB/network/etc)</span><span id="b601" class="ll lm iq lh b gy lr lo l lp lq">let newNumber;<br/>if (number) {<br/>    newNumber = add(number, 5);<br/>}</span><span id="209b" class="ll lm iq lh b gy lr lo l lp lq">// Another 50 lines below you might find something like this:</span><span id="5f8f" class="ll lm iq lh b gy lr lo l lp lq">if (number) {<br/>    newNumber = add(newNumber, 3);<br/>}</span></pre><p id="109d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果缺少数字<em class="lb"> </em>的话，可以打印数字到控制台或者一条消息吗？</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="cc0a" class="ll lm iq lh b gy ln lo l lp lq">const revealNumber = (number) =&gt;<br/>    console.log(number ?? 'There was no number to reveal');</span><span id="e27a" class="ll lm iq lh b gy lr lo l lp lq">revealNumber(newNumber);</span></pre><p id="193d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都知道真正的生产代码并不像这些例子那样简单，所以实际上，我们的代码库在尝试使用某个值进行某些操作之前，会被大量的样板文件检查弄得乱七八糟。我是一个函数式编程爱好者，虽然我从来没有告诉任何人它比其他范式(比如OOP)更好。相反，我鼓励开发人员学习这种范式，然后找到将其与OOP相结合的方法，取两者之长，创建一个强大的组合。</p><p id="12a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以我的拙见，JavaScript是最好的语言之一，你可以做OOP，也可以做函数式编程，这些风格都不会让语言感到尴尬，就像我在C#或Java中使用某些函数式技术时，函数式编程有时会感到尴尬。让我们看看函数式开发人员是如何处理“可能缺失但可能存在”的问题，即可能单子。如果你是Java开发人员，你可能已经熟悉了<em class="lb">Optional&lt;T&gt;T7】，如果你是C#开发人员，你可以看看我的文章<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/fun-csharp-dealing-with-null-values-in-a-safe-and-elegant-way-4ffdf86a38c8">https://it next . io/fun-cs harp-handling-with-null-values-in-a-a-safe-and-elegant-way-4 ffdf 86 a 38 C 8</a>，这里我讲的是我的LeanSharp库(<a class="ae kc" href="https://github.com/ericrey85/LeanSharp/" rel="noopener ugc nofollow" target="_blank">https://github.com/ericrey85/LeanSharp/</a>)。</em></p><p id="dc4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Maybe Monad是一个函数式编程概念，你可以在网上读到很多，它遵循三个数学定律，左等同、右等同和结合性。我在这里不是要谈论这个，如果你想更深入地研究它的数学方面，你可以在网上找到很多。出于本文的目的，可以将Maybe Monad看作一个值的容器，它将允许您对该值执行安全的操作。它如何工作的基本原理是:“如果值在那里，我将执行您的操作，但是如果它不在，什么也不会发生(我不会因为一个错误而让您失望)”。一个非常简单的定义如下:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="b44d" class="ll lm iq lh b gy ln lo l lp lq">const isNil = (o) =&gt; o == undefined;<br/>const notNil = (o) =&gt; !isNil(o);</span><span id="f9f0" class="ll lm iq lh b gy lr lo l lp lq">const Maybe = (value) =&gt; ({<br/>    map: (fn) =&gt; notNil(value) ? Maybe(fn(value)) : Maybe(),<br/>    bind: (fn) =&gt; notNil(value) ? fn(value) : Maybe(),<br/>    getOrElse: (defaultValue) =&gt; value ?? defaultValue<br/>});</span></pre><p id="ac18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是什么？让我们看看…我们有一个工厂函数(也许)，它将一个值作为参数，并使用三种方法返回一个对象:</p><p id="4ce2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1- <em class="lb"> map </em>:它接受一个函数，如果该值存在，则对该值应用该函数，并在同一个Maybe容器中返回一个新值(尽管是一个新实例)。如果值不存在，它将返回一个可能的包装<em class="lb">未定义的</em>。</p><p id="e8b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2- <em class="lb">绑定</em>:类似于<em class="lb">映射，</em>但是应用的函数返回另一个Maybe，而不是一个简单的值。</p><p id="d611" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3- <em class="lb"> getOrElse </em>:说了这么多，做了这么多，它允许我们访问包含的值，或者返回提供的默认值，如果我们在那一点上有一个<em class="lb"> Maybe(undefined) </em>。</p><p id="4e98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看如何使用这个单子。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="b446" class="ll lm iq lh b gy ln lo l lp lq">const result = Maybe(number)<br/>    .map((<em class="lb">x</em>) =&gt; <em class="lb">x</em> + 3)<br/>    .bind((<em class="lb">x</em>) =&gt; Maybe(<em class="lb">x</em> + 5))<br/>    .getOrElse('There was no number to reveal');</span><span id="0e77" class="ll lm iq lh b gy lr lo l lp lq">console.log(result);</span></pre><p id="8cc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果上面的代码对你来说有点奇怪，如果你从来没有做过函数式编程，我想是这样的，让我们用一个数组和它的函数做一些类似的事情。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="99bd" class="ll lm iq lh b gy ln lo l lp lq">const result = [number]<br/>    .filter(notNil)<br/>    .map((<em class="lb">x</em>) =&gt; <em class="lb">x</em> + 3)<br/>    .flatMap((<em class="lb">x</em>) =&gt; [<em class="lb">x</em> + 5])[0] ?? 'There was no number to reveal';</span></pre><p id="5263" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经将数字“提升”到一个容器中，在本例中是一个数组，我们已经排除了未定义/空的值(通过使用<em class="lb">过滤器</em>),这允许我们对其执行安全操作。我们Maybe的<em class="lb"> bind </em>函数<em class="lb"> </em>就像数组的<em class="lb"> flatMap </em>(这个函数也被称为<em class="lb">链</em>)。如果你还没有注意到，<strong class="kf ir"><em class="lb">【0】？？没有数字显示最后一行中的'</em> </strong>相当于Maybe的<em class="lb"> getOrElse </em>函数。显然最后这个例子并不完全相同，但是我想给你们看一些相似的，非常相似的东西，这样你们就可以和你们可能已经熟悉的东西有一个比较点。</p><p id="a4e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在结束本文之前，让我们看一个更具声明性/功能性的方法。如果你熟悉反应式编程(RxJS)，你已经知道<em class="lb">管道</em>功能。如果你不是，我现在就给你看，它是一个函数，接受一个函数数组，然后返回另一个函数。这个返回的函数取一个初始值，然后用它作为应用所有以前提供的函数的起点。这可能对你来说没什么意义，所以让我们来看看它的作用。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="0ebc" class="ll lm iq lh b gy ln lo l lp lq">const pipe = (...<em class="lb">fn</em>) =&gt; (<em class="lb">n</em>) =&gt; <em class="lb">fn</em>.reduce((<em class="lb">acc</em>, <em class="lb">fn</em>) =&gt; fn(<em class="lb">acc</em>), <em class="lb">n</em>);</span></pre><p id="ff88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样想想，如果你有两个函数，<em class="lb"> f </em>，和<em class="lb"> g </em>，一个初始值<em class="lb">x；</em>你可以这样做:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="eed6" class="ll lm iq lh b gy ln lo l lp lq">const finalResult = f(g(x));</span></pre><p id="acc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你也可以把它分解成这样:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="9d42" class="ll lm iq lh b gy ln lo l lp lq">const firstResult = g(x);<br/>const finalResult = f(firstResult);</span></pre><p id="bf5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用管道，您可以像这样完成相同的任务:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a444" class="ll lm iq lh b gy ln lo l lp lq">const getFinalResult = pipe(g, f);<br/>const finalResult = getFinalResult(x);</span></pre><p id="c34d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望它现在更有意义，<em class="lb">管道</em>，有效地允许函数组合。函数式编程中使用的另一种技术称为<em class="lb"> currying </em>，它可以被认为是一个接受另一个具有n个参数的函数，并将其转换为<em class="lb"> n个</em>函数，每个函数接受一个单一参数并返回另一个遵循相同模式的函数，直到最后一个函数返回结果。让我们来看一个curried函数:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="f5ea" class="ll lm iq lh b gy ln lo l lp lq">const add = (a) =&gt; (b) =&gt; a + b;<br/>const increment = add(1);<br/>const incrementedValue = increment(10); // 11</span></pre><p id="573a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们不会使用函数来处理我们的函数，相反，我们将手动处理它们，你可以在像ramda这样的库中找到这样的函数。请记住，在生产代码中，您将希望使用一个函数来为您处理函数(而不是手动处理)，尽管您应该知道，如果将<em class="lb">处理</em>函数和默认参数结合在一起，它们不会很好地发挥作用。如果您使用这样的函数，它看起来会像这样:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="9f4d" class="ll lm iq lh b gy ln lo l lp lq">const add = curry((a, b) =&gt; a + b);</span></pre><p id="437b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Currying是一种允许函数重用的技术(就像上面看到的<em class="lb">增量</em>，以及使用类似<em class="lb">管道</em>函数的函数组合(或者它的兄弟<em class="lb">组合</em>)。现在，让我们为可以从Maybe对象解耦的<em class="lb"> map </em>、<em class="lb"> bind </em>和<em class="lb"> getOrElse </em>提供可约束的实现:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="68eb" class="ll lm iq lh b gy ln lo l lp lq">const map = (<em class="lb">fn</em>) =&gt; (<em class="lb">o</em>) =&gt; <em class="lb">o</em>.map(<em class="lb">fn</em>);<br/>const bind = (<em class="lb">fn</em>) =&gt; (<em class="lb">o</em>) =&gt; <em class="lb">o</em>.bind(<em class="lb">fn</em>);<br/>const getOrElse = (<em class="lb">defaultValue</em>) =&gt; <br/>    (<em class="lb">o</em>) =&gt; <em class="lb">o</em>.getOrElse(<em class="lb">defaultValue</em>);</span></pre><p id="e8cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每种情况下，我们都使用了duck类型并将调用委托给传入的对象。我们现在可以像这样重写代码:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a9ee" class="ll lm iq lh b gy ln lo l lp lq">const getFinalResult = pipe(<br/>    Maybe,<br/>    map(add(3)),<br/>    bind((<em class="lb">x</em>) =&gt; Maybe(<em class="lb">x</em> + 5)),<br/>    getOrElse('There was no number to reveal')<br/>);</span><span id="a605" class="ll lm iq lh b gy lr lo l lp lq">console.log(getFinalResult(number));</span></pre><p id="e1b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意到上面使用的<em class="lb"> add </em>函数是curried版本。<em class="lb">管道</em>函数从上到下(或从左到右)阅读，如果你觉得从下到上(或从右到左)阅读更舒服，那么你想使用的函数是<em class="lb">撰写，</em>它与<em class="lb">管道</em>的功能相同，但从最底部/最右侧的函数开始。你可以这样实现<em class="lb">合成</em>(基本上是用<em class="lb"> reduceRight </em>代替<em class="lb"> reduce </em>):</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="8b0a" class="ll lm iq lh b gy ln lo l lp lq">const compose = (...<em class="lb">fn</em>) =&gt; (<em class="lb">n</em>) =&gt; <em class="lb">fn</em>.reduceRight(<br/>    (<em class="lb">acc</em>, <em class="lb">fn</em>) =&gt; fn(<em class="lb">acc</em>), <em class="lb">n<br/></em>);</span><span id="1e6c" class="ll lm iq lh b gy lr lo l lp lq">const getFinalResult = compose(<br/>    getOrElse('There was no number to reveal'),<br/>    bind((<em class="lb">x</em>) =&gt; Maybe(<em class="lb">x</em> + 5)),<br/>    map(add(3)),<br/>    Maybe<br/>);</span></pre><p id="9756" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几个JavaScript库为您提供了编写函数式程序所需的函数式结构，其中最著名的有ramda、underscorejs、lodash和folktale。我鼓励您看一看它们，并在可行和可能的时候使用它们(而不是使用您自己的实现)。</p><p id="f256" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我总是听到一些开发人员说“这种编程方式令人困惑”，或者“你不会用这样的方法编写一个完整的系统”。我开始理解那些类型的感觉，它们来自于对它的不熟悉，来自于对我们已经知道的东西的偏见。我曾用本文中展示的技术和其他单子编写过大型程序，比如要么单子，要么IO单子，等等。我逐渐意识到，这些程序比我用纯命令式方法编写的程序有更低的错误密度。我鼓励你走出你的舒适区，学习一些你还不知道或不理解的东西，我向你保证，这只会让你成为一个更好的开发人员。</p></div></div>    
</body>
</html>