<html>
<head>
<title>Handle http responses with HttpInterceptor and Toastr in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Angular中的HttpInterceptor和Toastr处理http响应</h1>
<blockquote>原文：<a href="https://itnext.io/handle-http-responses-with-httpinterceptor-and-toastr-in-angular-3e056759cb16?source=collection_archive---------0-----------------------#2018-12-18">https://itnext.io/handle-http-responses-with-httpinterceptor-and-toastr-in-angular-3e056759cb16?source=collection_archive---------0-----------------------#2018-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/20bac6d54b22fdba7f590fe2abf2fd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMtl3feXn6YGMLvbGnWE3g.png"/></div></div></figure><p id="e8b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您是否曾经需要一个集中的系统来处理您的http响应？我确信，每当您在一个有大量http请求的大项目中工作时，这个问题就会浮出水面。在本文中，我将向您展示如何处理它，通过使用http拦截器和<code class="fe kz la lb lc b">ngx-toastr</code>插件来显示这些消息。</p><p id="f6d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让HttpInterceptor工作非常简单，需要两个步骤:</p><ol class=""><li id="dfc0" class="ld le it kd b ke kf ki kj km lf kq lg ku lh ky li lj lk ll bi translated">创建一个实现<code class="fe kz la lb lc b">HttpInterceptor</code>接口的类</li><li id="b34d" class="ld le it kd b ke lm ki ln km lo kq lp ku lq ky li lj lk ll bi translated">提供拦截器</li></ol><p id="cc5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">开始吧！</p><p id="f840" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">http接收器</strong></p><p id="45a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">HttpInterceptor是一个可以由类实现的接口，它只有一个方法来拦截传出的<code class="fe kz la lb lc b">HttpRequest</code>，并有选择地转换它或响应。那个方法叫做<code class="fe kz la lb lc b">intercept.</code></p><p id="ce5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">intercept</code>方法接受两个参数:<code class="fe kz la lb lc b">req</code> (a <code class="fe kz la lb lc b">HttpRequest</code>)和<code class="fe kz la lb lc b">next</code> (a <code class="fe kz la lb lc b">HttpHandler</code>)并返回一个<code class="fe kz la lb lc b">Observable</code></p><pre class="lr ls lt lu gt lv lc lw lx aw ly bi"><span id="0273" class="lz ma it lc b gy mb mc l md me">intercept(</span><span id="b78d" class="lz ma it lc b gy mf mc l md me"><strong class="lc iu">   req: HttpRequest&lt;any&gt;,</strong></span><span id="bb66" class="lz ma it lc b gy mf mc l md me">   <strong class="lc iu">next: HttpHandler</strong></span><span id="9332" class="lz ma it lc b gy mf mc l md me">): <strong class="lc iu">Observable&lt;HttpEvent&lt;any&gt;&gt;</strong> {}</span></pre><p id="1b3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常拦截器会在返回<code class="fe kz la lb lc b">next.handle(req)</code>之前转换传出的请求。拦截器也可以选择转换响应事件流，方法是对由<code class="fe kz la lb lc b">next.handle()</code>返回的流应用额外的Rx操作符。</p><pre class="lr ls lt lu gt lv lc lw lx aw ly bi"><span id="bc7e" class="lz ma it lc b gy mb mc l md me">return next.handle(req).pipe(<br/>            <strong class="lc iu">tap(evt =&gt; {}),<br/>            catchError(error =&gt; {})</strong><br/>);</span></pre><p id="3fde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将向您展示如何处理成功和错误响应。如果我们的http请求成功，我们希望显示一条祝酒成功消息。另一方面，当http请求返回错误时，我们将通过toast显示一条错误消息。</p><p id="0849" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们开始构建拦截器之前，我们必须导入所有必要的方法、类、服务，并在构造函数中注入<code class="fe kz la lb lc b">ToastrService</code>。</p><pre class="lr ls lt lu gt lv lc lw lx aw ly bi"><span id="c92d" class="lz ma it lc b gy mb mc l md me">import { HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpResponse, HttpErrorResponse }   from '@angular/common/http';</span><span id="decb" class="lz ma it lc b gy mf mc l md me">import { Injectable } from "@angular/core"</span><span id="f45a" class="lz ma it lc b gy mf mc l md me">import { Observable, of } from "rxjs";</span><span id="84b1" class="lz ma it lc b gy mf mc l md me">import { ToastrService } from 'ngx-toastr';<br/>...</span><span id="8a9c" class="lz ma it lc b gy mf mc l md me">constructor(<strong class="lc iu">public toasterService: ToastrService</strong>) {}</span></pre><p id="62dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们首先处理成功消息。为此，我们必须确定<code class="fe kz la lb lc b">evt</code>是<code class="fe kz la lb lc b">HttpResponse</code>的一个实例</p><p id="252e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的例子中，我已经设置我的API在响应中返回一个包含消息和标题的success属性。这些是我想在吐司上展示的数据。也就是说，在这一点上，我们将检查这个响应是否有一个包含这个成功属性的主体。然后我们将显示包含三个参数的成功祝酒词:消息、标题、附加选项。(您可以在此查看所有可用选项<a class="ae mg" href="https://github.com/scttcper/ngx-toastr" rel="noopener ugc nofollow" target="_blank">)</a></p><pre class="lr ls lt lu gt lv lc lw lx aw ly bi"><span id="8ed4" class="lz ma it lc b gy mb mc l md me">tap(evt =&gt; {<br/>                if (<strong class="lc iu">evt instanceof HttpResponse</strong>) {<br/>                    if(<strong class="lc iu">evt.body</strong> &amp;&amp; <strong class="lc iu">evt.body.success</strong>)<br/>                        this.toasterService.success(evt.body.success.message, evt.body.success.title, { positionClass: 'toast-bottom-center' });<br/>                }<br/>            }),</span></pre><p id="42d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还设置了我的API，以便在发生错误时在响应中返回一个错误属性，该属性还包含一条消息和一个标题。如前所述，我们将检查<code class="fe kz la lb lc b">err</code>是否是<code class="fe kz la lb lc b">HttpErrorResponse</code>的实例</p><p id="b9b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你在下面看到的，我没有检查这个属性是否存在，但是我使用了<code class="fe kz la lb lc b">try/catch</code>表达式来显示自定义错误或者一个普通错误。</p><pre class="lr ls lt lu gt lv lc lw lx aw ly bi"><span id="60da" class="lz ma it lc b gy mb mc l md me">catchError((err: any) =&gt; {<br/><strong class="lc iu">                if(err instanceof HttpErrorResponse) {</strong><br/><strong class="lc iu">                    try {</strong><br/>                        this.toasterService.error(err.error.message, err.error.title, { positionClass: 'toast-bottom-center' });<br/>                    <strong class="lc iu">} catch(e) {</strong><br/>                        this.toasterService.error('An error occurred', '', { positionClass: 'toast-bottom-center' });<br/><strong class="lc iu">                    }</strong><br/><strong class="lc iu">                }</strong><br/>                return of(err);<br/>            }));</span></pre><p id="c6dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">拦截器的另一个用途是记录错误，而不是显示错误。或者两者都做。取决于项目。</p><p id="1353" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">把它们放在一起，这就是我们的最后一节课。将其作为<code class="fe kz la lb lc b">http.interceptor.ts</code>保存在您的<code class="fe kz la lb lc b">app</code>文件夹中。</p><pre class="lr ls lt lu gt lv lc lw lx aw ly bi"><span id="bca9" class="lz ma it lc b gy mb mc l md me">import { HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpResponse, HttpErrorResponse }   from '@angular/common/http';<br/>import { Injectable } from "@angular/core"<br/>import { Observable, of } from "rxjs";<br/>import { tap, catchError } from "rxjs/operators";<br/>import { ToastrService } from 'ngx-toastr';</span><span id="184d" class="lz ma it lc b gy mf mc l md me"><a class="ae mg" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>()<br/>export class AppHttpInterceptor implements HttpInterceptor {<br/>    constructor(public toasterService: ToastrService) {}</span><span id="2eac" class="lz ma it lc b gy mf mc l md me">intercept(<br/>        req: HttpRequest&lt;any&gt;,<br/>        next: HttpHandler<br/>      ): Observable&lt;HttpEvent&lt;any&gt;&gt; {<br/>    <br/>        return next.handle(req).pipe(<br/>            tap(evt =&gt; {<br/>                if (evt instanceof HttpResponse) {<br/>                    if(evt.body &amp;&amp; evt.body.success)<br/>                        this.toasterService.success(evt.body.success.message, evt.body.success.title, { positionClass: 'toast-bottom-center' });<br/>                }<br/>            }),<br/>            catchError((err: any) =&gt; {<br/>                if(err instanceof HttpErrorResponse) {<br/>                    try {<br/>                        this.toasterService.error(err.error.message, err.error.title, { positionClass: 'toast-bottom-center' });<br/>                    } catch(e) {<br/>                        this.toasterService.error('An error occurred', '', { positionClass: 'toast-bottom-center' });<br/>                    }<br/>                    //log error <br/>                }<br/>                return of(err);<br/>            }));<br/>    <br/>      }<br/>      <br/>}</span></pre><p id="17b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">提供拦截器</strong></p><p id="6aa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是极其简单的！打开您的<code class="fe kz la lb lc b">app.module.ts</code>文件，转到<code class="fe kz la lb lc b">providers </code>部分并在数组中添加以下代码。</p><pre class="lr ls lt lu gt lv lc lw lx aw ly bi"><span id="ceb0" class="lz ma it lc b gy mb mc l md me">{</span><span id="29e8" class="lz ma it lc b gy mf mc l md me">provide: <strong class="lc iu">HTTP_INTERCEPTORS</strong>, useClass: <strong class="lc iu">AppHttpInterceptor</strong>, multi: true</span><span id="1fd5" class="lz ma it lc b gy mf mc l md me">}</span></pre><p id="fbff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还必须导入<code class="fe kz la lb lc b">HTTP_INTERCEPTORS</code>和您的<code class="fe kz la lb lc b">AppHttpInterceptor</code></p><pre class="lr ls lt lu gt lv lc lw lx aw ly bi"><span id="c9a2" class="lz ma it lc b gy mb mc l md me">import { ..., <strong class="lc iu">HTTP_INTERCEPTORS </strong>} from '@angular/common/http';</span><span id="23c2" class="lz ma it lc b gy mf mc l md me">import { <strong class="lc iu">AppHttpInterceptor</strong> } from './http.interceptor';</span></pre><p id="d714" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样！感谢您的阅读！</p></div></div>    
</body>
</html>