<html>
<head>
<title>Multi threading and multiple process in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的多线程和多进程</h1>
<blockquote>原文：<a href="https://itnext.io/multi-threading-and-multi-process-in-node-js-ffa5bb5cde98?source=collection_archive---------0-----------------------#2018-04-12">https://itnext.io/multi-threading-and-multi-process-in-node-js-ffa5bb5cde98?source=collection_archive---------0-----------------------#2018-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/34bde87dc7c39797d4ce97a04500c9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*evOcy9n3vslkDt0Mj8mBYw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来自c-sharpcorner.com</figcaption></figure><p id="f58e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Node.js是一种单线程语言，它在后台使用多线程来执行异步代码。</p><p id="f6a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Node.js是非阻塞的，这意味着所有的函数(回调)都被委托给事件循环，它们由不同的线程执行。这由Node.js运行时处理。</p><ul class=""><li id="b8d1" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">Node.js确实支持分叉多个进程(在不同的内核上执行)。</li><li id="aa90" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">知道主进程和分叉进程之间不共享状态是很重要的。</li><li id="337c" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">我们可以通过函数send将消息传递给分叉的流程(这是不同的脚本)并从分叉的流程控制流程。</li></ul><h1 id="717b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">为什么以及何时我们需要派生另一个过程？</h1><ul class=""><li id="5a71" class="la lb iq ke b kf mm kj mn kn mo kr mp kv mq kz lf lg lh li bi translated">分支多个进程对于释放内存和卸载单个进程至关重要。</li><li id="8e96" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><strong class="ke ir">为了提高速度，当我们需要将任务委派(并行运行)给另一个进程时。</strong></li></ul><p id="8d4c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看这个例子:</p><p id="2323" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们有REST端点，它需要调用体内长时间运行的函数:</p><p id="edac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">server.js</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ad6c" class="na lp iq mw b gy nb nc l nd ne">const { fork } = require('child_process');</span><span id="a522" class="na lp iq mw b gy nf nc l nd ne">app.get('/endpoint', (request, response) =&gt; {</span><span id="d8b3" class="na lp iq mw b gy nf nc l nd ne">   // fork another process<br/>   <strong class="mw ir">const process = fork('./send_mail.js');</strong><br/>   const mails = request.body.emails;</span><span id="ad0a" class="na lp iq mw b gy nf nc l nd ne">   // send list of e-mails to forked process<br/>   <strong class="mw ir">process.send({ mails });</strong></span><span id="d000" class="na lp iq mw b gy nf nc l nd ne">   // listen for messages from forked process<br/>   <strong class="mw ir">process.on('message', (message) =&gt; {</strong><br/>     log.info(`Number of mails sent ${message.counter}`);<br/>   <strong class="mw ir">});</strong></span><span id="b8e4" class="na lp iq mw b gy nf nc l nd ne">   return response.json({ status: true, sent: true });<br/>});</span></pre><p id="8d37" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">send_mail.js</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="fad8" class="na lp iq mw b gy nb nc l nd ne">async function sendMultipleMails(mails) {</span><span id="1e75" class="na lp iq mw b gy nf nc l nd ne">   let sendMails = 0;</span><span id="099b" class="na lp iq mw b gy nf nc l nd ne">   // logic for<br/>   // sending multiple mails</span><span id="bc6e" class="na lp iq mw b gy nf nc l nd ne">   return sendMails;<br/>}</span><span id="ef87" class="na lp iq mw b gy nf nc l nd ne">// receive message from master process<strong class="mw ir"><br/>process.on('message', async (message) =&gt; {</strong></span><span id="e5c2" class="na lp iq mw b gy nf nc l nd ne">  const numberOfMailsSend = await sendMultipleMails(message.mails); <br/>  <br/>  // send response to master process<br/>  <strong class="mw ir">process.send({ counter: numberOfMailsSend });</strong><br/><strong class="mw ir">});</strong><br/></span></pre><p id="6af5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个简单的例子中，我们展示了如何将数据发送到分叉的流程，以及如何将数据发送回来。</p></div></div>    
</body>
</html>