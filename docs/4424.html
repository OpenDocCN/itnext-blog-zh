<html>
<head>
<title>React Hooks — The Ins and Outs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks —细节</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-the-ins-and-outs-a5b85bac678?source=collection_archive---------1-----------------------#2020-06-27">https://itnext.io/react-hooks-the-ins-and-outs-a5b85bac678?source=collection_archive---------1-----------------------#2020-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="2931" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><a class="ae ks" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <em class="it">挂钩</em> </a> <em class="it">是让你从功能组件“挂钩”React状态和生命周期特性的功能。</em></p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/417b79541fc0a025f7382aafb6245290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmZyPxd-Ry08TV3kNRwiWg.png"/></div></div></figure><h1 id="5950" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么是钩子</h1><h1 id="f048" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们如何重用有状态逻辑— <a class="ae ks" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> HOC </a></h1><p id="df2e" class="pw-post-body-paragraph jt ju it jw b jx md jz ka kb me kd ke mf mg kh ki mh mi kl km mj mk kp kq kr im bi translated">例如</p><pre class="ku kv kw kx gt ml mm mn mo aw mp bi"><span id="fd8d" class="mq lg it mm b gy mr ms l mt mu">import { withRouter } from "react-router-dom";<br/>import { Form } from 'antd';</span><span id="0c6f" class="mq lg it mm b gy mv ms l mt mu">function A(props) {<br/>  const {<br/>    match: { params },<br/>    history,<br/>    form<br/>  } = props;</span><span id="7a13" class="mq lg it mm b gy mv ms l mt mu">  return &lt;div&gt; test &lt;/div&gt;;<br/>}</span><span id="7f20" class="mq lg it mm b gy mv ms l mt mu">export default withRouter(Form.create()(A))</span></pre><p id="ebc0" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mf kg kh ki mh kk kl km mj ko kp kq kr im bi translated">HOC有一些缺点。</p><ul class=""><li id="69a9" class="mw mx it jw b jx jy kb kc mf my mh mz mj na kr nb nc nd ne bi translated"><strong class="jw iu">包装组件的外壳</strong>。HOC实际上返回了一个包装了原始组件的新组件。</li><li id="e902" class="mw mx it jw b jx nf kb ng mf nh mh ni mj nj kr nb nc nd ne bi translated">依赖关系不明确:从组件<strong class="jw iu"> A </strong>来看，我们无法清楚地知道<strong class="jw iu"> this.props.form </strong>来自<strong class="jw iu"> Form.create </strong> HOC，<strong class="jw iu"> this.props.history </strong>来自<strong class="jw iu"> withRouter </strong> HOC</li><li id="8b4b" class="mw mx it jw b jx nf kb ng mf nh mh ni mj nj kr nb nc nd ne bi translated">命名冲突:想象一下<strong class="jw iu"> Form.create </strong>和<strong class="jw iu"> withRouter </strong>都注入了一个同名的道具，这很容易发生，因为它们是由两个团队正确维护的两个独立的hoc</li></ul><h1 id="35e9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们如何用钩子来改进</h1><pre class="ku kv kw kx gt ml mm mn mo aw mp bi"><span id="66cc" class="mq lg it mm b gy mr ms l mt mu">import { useHistory } from "react-router-dom";<br/>import { Form } from 'antd';</span><span id="94e7" class="mq lg it mm b gy mv ms l mt mu">export default function A(props) {<br/>  const [form] = Form.useForm();<br/>  const history = useHistory();</span><span id="f56d" class="mq lg it mm b gy mv ms l mt mu">  return &lt;div&gt; test &lt;/div&gt;;<br/>}</span></pre><ul class=""><li id="a8a5" class="mw mx it jw b jx jy kb kc mf my mh mz mj na kr nb nc nd ne bi translated">不再有包装，因为它们都在同一级别</li><li id="7e47" class="mw mx it jw b jx nf kb ng mf nh mh ni mj nj kr nb nc nd ne bi translated">清除依赖关系，因为它们来自不同的钩子调用:<strong class="jw iu">表单</strong>来自<strong class="jw iu">使用表单</strong>和<strong class="jw iu">历史</strong>来自<strong class="jw iu">使用历史</strong></li><li id="eff9" class="mw mx it jw b jx nf kb ng mf nh mh ni mj nj kr nb nc nd ne bi translated">没有命名冲突，因为它们来自不同的钩子，你可以重命名钩子返回值</li></ul><h1 id="7b4c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">实践中的挂钩</h1><p id="ff64" class="pw-post-body-paragraph jt ju it jw b jx md jz ka kb me kd ke mf mg kh ki mh mi kl km mj mk kp kq kr im bi translated">要实现具有<strong class="jw iu">复位</strong>功能的受控<strong class="jw iu">输入</strong>元素，我们可以这样做<a class="ae ks" href="https://codesandbox.io/s/controlled-input-with-reset-2js6i?file=/src/App.js" rel="noopener ugc nofollow" target="_blank"/>:</p><pre class="ku kv kw kx gt ml mm mn mo aw mp bi"><span id="0572" class="mq lg it mm b gy mr ms l mt mu">import React, { useState } from "react";<br/>import { Input, Button } from 'antd';</span><span id="d4f1" class="mq lg it mm b gy mv ms l mt mu">export default function App() {<br/>  const initialValue = 'please enter something';<br/>  const [inputValue, setInputValue] = useState(initialValue);</span><span id="226c" class="mq lg it mm b gy mv ms l mt mu">  return (<br/>    &lt;div className="App"&gt;<br/>        // note the value is from e.target<br/>      &lt;Input value={inputValue} onChange={e =&gt; setInputValue(e.target.value)}/&gt;<br/>      &lt;Button onClick={() =&gt; setInputValue(initialValue)}&gt; Reset &lt;/Button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="4c9f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mf kg kh ki mh kk kl km mj ko kp kq kr im bi translated">有几个有状态的逻辑，我们可以抽象和恢复。</p><ul class=""><li id="ab72" class="mw mx it jw b jx jy kb kc mf my mh mz mj na kr nb nc nd ne bi translated">取值—例如，目标值</li><li id="4fcd" class="mw mx it jw b jx nf kb ng mf nh mh ni mj nj kr nb nc nd ne bi translated">复位逻辑—复位至初始值</li></ul><h1 id="1fee" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">自定义挂钩— <a class="ae ks" href="https://codesandbox.io/s/useeventtarget-z18i3?file=/src/useEventTarget.js" rel="noopener ugc nofollow" target="_blank">使用事件目标</a></h1><pre class="ku kv kw kx gt ml mm mn mo aw mp bi"><span id="254c" class="mq lg it mm b gy mr ms l mt mu">import { useState, useCallback } from "react";</span><span id="8d03" class="mq lg it mm b gy mv ms l mt mu">export default function useEventTarget(initialValue = "") {<br/>  const [value, setValue] = useState(initialValue);<br/>  const onChange = useCallback(e =&gt; setValue(e.target.value), []); // reusable value fetch logic<br/>  const reset = useCallback(() =&gt; setValue(initialValue), [initialValue]); // resuable reset logic</span><span id="bf34" class="mq lg it mm b gy mv ms l mt mu">  return {<br/>    value,<br/>    onChange,<br/>    reset<br/>  };<br/>}</span></pre><p id="0168" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mf kg kh ki mh kk kl km mj ko kp kq kr im bi translated">上面的例子可以用定制的useEventTarget钩子<a class="ae ks" href="https://codesandbox.io/s/useeventtarget-z18i3?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">重构</a>:</p><pre class="ku kv kw kx gt ml mm mn mo aw mp bi"><span id="486c" class="mq lg it mm b gy mr ms l mt mu">import React from "react";<br/>import { Input, Button } from "antd";<br/>import useEventTarget from "./useEventTarget";</span><span id="e6a8" class="mq lg it mm b gy mv ms l mt mu">export default function App() {<br/>  const { value, onChange, reset } = useEventTarget("please enter something");</span><span id="62a0" class="mq lg it mm b gy mv ms l mt mu">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Input value={value} onChange={onChange} /&gt;<br/>      &lt;Button onClick={reset}&gt; Reset &lt;/Button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="dc5b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">精神开销</h1><blockquote class="jq jr js"><p id="7c4e" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><em class="it"> Hooks不能代替类生命周期，尽管useEffect可以模拟生命周期的行为。Hooks有助于重用有状态逻辑，但是它也有代价。</em></p></blockquote><p id="067d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mf kg kh ki mh kk kl km mj ko kp kq kr im bi translated">假设我需要一个显示<strong class="jw iu">计数</strong>页面，该计数从零开始，每秒递增1。</p><pre class="ku kv kw kx gt ml mm mn mo aw mp bi"><span id="5a7b" class="mq lg it mm b gy mr ms l mt mu">import React, { useState, useEffect } from 'react';</span><span id="cbd4" class="mq lg it mm b gy mv ms l mt mu">export default function SetInterval() {<br/>  const [ count, setCount ] = useState(0);</span><span id="d161" class="mq lg it mm b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    const interval = setInterval(() =&gt; {<br/>      console.log("interval count", count); // count is always 0<br/>      setCount(count + 1);<br/>    }, 1000);<br/>    return () =&gt; {<br/>      clearInterval(interval)<br/>    }<br/>  }, []);</span><span id="ba0f" class="mq lg it mm b gy mv ms l mt mu">  return &lt;div&gt; normal count is { count } &lt;/div&gt;;<br/>}</span></pre><p id="ee56" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mf kg kh ki mh kk kl km mj ko kp kq kr im bi translated">当<a class="ae ks" href="https://codesandbox.io/s/setinterval-wt720?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">的代码在</a>之上时，页面上的计数将保持在1。这是由于<strong class="jw iu"> useEffect </strong>调用仅在挂载时运行(因为<strong class="jw iu"> useEffect </strong>依赖项在第14行被设置为[])并且<strong class="jw iu">计数</strong>值在该点为0(即我们在第4行用<strong class="jw iu"> useState </strong>调用设置的初始值)。每次调用interval函数时，<strong class="jw iu"> count </strong>值总是为0，因为它是一个闭包变量。因此，setCount(count + 1)将是setCount(1)。</p><h1 id="d08c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><a class="ae ks" href="https://codesandbox.io/s/setinterval-with-dependency-36fb5?file=/src/App.js:0-355" rel="noopener ugc nofollow" target="_blank">解决方案1 —使用效果依赖关系</a></h1><blockquote class="jq jr js"><p id="b19b" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><em class="it">如果您的使用效果依赖于外部变量，请指定依赖关系</em></p></blockquote><pre class="ku kv kw kx gt ml mm mn mo aw mp bi"><span id="d934" class="mq lg it mm b gy mr ms l mt mu">import React, { useState, useEffect } from "react";</span><span id="175f" class="mq lg it mm b gy mv ms l mt mu">export default function SetInterval() {<br/>  const [count, setCount] = useState(0);<br/>  useEffect(() =&gt; {<br/>    const interval = setInterval(() =&gt; {<br/>      console.log('interval count', count); // increment by one per run<br/>      setCount(count + 1);<br/>    }, 1000);</span><span id="de46" class="mq lg it mm b gy mv ms l mt mu">    return () =&gt; {<br/>      // each time count value changes (i.e per second, clear the interval and init one with new count value<br/>      console.log('interval clear', count); <br/>      clearInterval(interval);<br/>    }<br/>  }, [count]);</span><span id="b9b3" class="mq lg it mm b gy mv ms l mt mu">  return &lt;div&gt; dep count is {count} &lt;/div&gt;;<br/>}</span></pre><h1 id="217c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><a class="ae ks" href="https://codesandbox.io/s/setinterval-with-prev-vsi1y" rel="noopener ugc nofollow" target="_blank">解决方案2 —使用状态回调</a></h1><pre class="ku kv kw kx gt ml mm mn mo aw mp bi"><span id="a451" class="mq lg it mm b gy mr ms l mt mu">import React, { useState, useEffect } from "react";</span><span id="5f4a" class="mq lg it mm b gy mv ms l mt mu">export default function SetInterval() {<br/>  const [count, setCount] = useState(0);</span><span id="ec99" class="mq lg it mm b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    const interval = setInterval(() =&gt; {<br/>      // it doesnt matter what count was, it tells React to increment by one with previous value<br/>      setCount(a =&gt; a + 1);<br/>    }, 1000);</span><span id="4661" class="mq lg it mm b gy mv ms l mt mu">    return () =&gt; {<br/>      clearInterval(interval);<br/>    };<br/>  }, []);</span><span id="7554" class="mq lg it mm b gy mv ms l mt mu">  return &lt;div&gt; prev normal count is {count} &lt;/div&gt;;<br/>}</span></pre><h1 id="6f71" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><a class="ae ks" href="https://codesandbox.io/s/setinterval-with-ref-qldj0?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">解决方案3 — useRef </a></h1><pre class="ku kv kw kx gt ml mm mn mo aw mp bi"><span id="7e74" class="mq lg it mm b gy mr ms l mt mu">import React, { useRef, useState, useEffect } from "react";</span><span id="9f64" class="mq lg it mm b gy mv ms l mt mu">export default function SetInterval() {<br/>  const [count, setCount] = useState(0);<br/>  const ref = useRef();<br/>  ref.current = count;</span><span id="5d9e" class="mq lg it mm b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    const interval = setInterval(() =&gt; {<br/>      console.log("interval count", ref.current);<br/>      setCount(ref.current + 1);<br/>    }, 1000);</span><span id="4e13" class="mq lg it mm b gy mv ms l mt mu">    return () =&gt; {<br/>      clearInterval(interval);<br/>    };<br/>  }, []);</span><span id="5deb" class="mq lg it mm b gy mv ms l mt mu">  return &lt;div&gt; ref count is {count} &lt;/div&gt;;<br/>}</span></pre><h1 id="9ba9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">通知；注意</h1><ul class=""><li id="c208" class="mw mx it jw b jx md kb me mf nk mh nl mj nm kr nb nc nd ne bi translated">如果您想关注我的博客系列的最新消息/文章，请<a class="ae ks" href="https://github.com/n0ruSh/blogs/" rel="noopener ugc nofollow" target="_blank">【观看】</a>订阅。</li></ul></div></div>    
</body>
</html>