<html>
<head>
<title>Let’s create a Mini Spotify with Flutter and Riverpod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用Flutter和Riverpod创建一个迷你Spotify</h1>
<blockquote>原文：<a href="https://itnext.io/lets-create-a-mini-spotify-with-flutter-and-riverpod-24aa53ed8b66?source=collection_archive---------2-----------------------#2020-09-17">https://itnext.io/lets-create-a-mini-spotify-with-flutter-and-riverpod-24aa53ed8b66?source=collection_archive---------2-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/18bc6de8eb243fa936ac03d3d3417d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tURv02rG29DoqMfsXsg3kA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@namroud" rel="noopener ugc nofollow" target="_blank"> @namroud </a>拍摄。不溅</figcaption></figure><p id="2096" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">又见面了👋，<br/>如果你一直关注我的媒体，你就会知道我是Flutter的超级粉丝。在这么短的时间内，我们能用它做的事情真是太神奇了。我最近一直在玩一个新的包<a class="ae kf" href="https://pub.dev/packages/riverpod" rel="noopener ugc nofollow" target="_blank"> riverpod </a>(此处插入链接)，它是由<a class="le lf ep" href="https://medium.com/u/c0530952c459?source=post_page-----24aa53ed8b66--------------------------------" rel="noopener" target="_blank"> Remi Rousselet </a>(提供者<a class="ae kf" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank"/>、<a class="ae kf" href="https://pub.dev/packages/flutter_hooks" rel="noopener ugc nofollow" target="_blank"> flutter_hooks </a>和许多其他优秀包的创建者)创建的。所以我想为什么不写一篇文章来展示带有Flutter的<a class="ae kf" href="https://pub.dev/packages/riverpod" rel="noopener ugc nofollow" target="_blank"> riverpod </a>的用例。所以在今天的文章中，我们将使用Flutter和<a class="ae kf" href="https://pub.dev/packages/riverpod" rel="noopener ugc nofollow" target="_blank"> riverpod </a>创建一个迷你Spotify。我们开始吧！</p><h1 id="d7b2" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">第一步-设计:</h1><p id="70fa" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">利用图玛，我为今天的文章制作了一个模型..</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/07bc1037e7bc2f97d29d6f473606d987.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*BKbUfyxT6Olbh_sEu6OwAw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">主屏幕的模型</figcaption></figure><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/bd32bb739f5e9d579a3909375aeb3fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*tuQOJUrhGIeQ6jMpPMKKCQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">播放器屏幕的实体模型</figcaption></figure><p id="7c1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个将是主屏幕，在我们的播放列表中的歌曲列表和一个迷你播放器在屏幕底部显示当前播放的歌曲。一旦我们按下它，我们就会进入一个名为PlayerScreen的新屏幕。在这个例子中，我们可以看到关于当前正在播放的歌曲的所有信息，以及控件(比如播放/暂停、向后跳、下一个跳……)。</p><p id="6c48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将首先开始设计具有冷渐变效果的背景。就我而言，我选择了红色，但你可以选择任何你喜欢的颜色。</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/2ff8f423bfc00484420ba999dc4a62f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*2iy1W_T6KMPtH54--XfN0A.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">渐变背景</figcaption></figure><p id="c822" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">颤动中的代码:</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">带有渐变背景的主页</figcaption></figure><p id="3508" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要创建的第二个元素是播放列表中的歌曲列表。这将是一个简单的任务，因为Flutter已经有了一个名为ListTile的小部件。</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">播放列表中歌曲列表的AudioTrackTile</figcaption></figure><p id="6b10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将创建一个迷你播放器，它将出现在我们应用程序的底部，显示当前播放歌曲的基本信息和基本控制。结果应该是这样的:</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/976883d8b024ffa15fbe5f461d061d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*CLoRISi6jVrc-34q75MycA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">迷你播放器部件</figcaption></figure><p id="5a63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在颤振中做到这一点:</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">迷你播放器部件</figcaption></figure><p id="ec0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些解释:迷你播放器的布局有点像代码中看到的行和列的组合。为了获得与Spotify的迷你播放器中相同的滑块，我们需要创建一个自定义的轨道形状，这可以通过扩展类RoundedRectSliderTrackShape来完成，我们还必须使用白色作为活动轨道的颜色，白色作为不活动轨道的30%不透明度。</p><p id="cff5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">转到我们的应用程序的播放器屏幕，我们想要获得的结果显示在上面的模型中。为了实现这一点，在Flutter中，我们将使用这段代码将屏幕分成三个部分。第一部分是当前播放歌曲的图像，第二部分是艺术家姓名和歌曲名称，第三部分是音频播放器控件。对于播放器控件，我们将创建它的小部件，这样我们就不会有很多嵌套的列和行。</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="17be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们完成了设计。剩下要做的下一步是使用riverpod挂接所有内容。</p><h1 id="6156" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">第二步—状态管理:</h1><p id="fb96" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">Flutter的状态管理可能相当麻烦，尤其是对新开发人员而言。你有BLoC，Mobx，Provider(结合ChangeNotifier或者其他解决方案)，还有很多其他的，每个人都有它的优缺点。其中应用比较广泛的是Provider，这是Remi改进InheritedWidget的解决方案。尽管Provider很好，但它也有其局限性(尤其是它基于InheritedWidget这一事实)。因此，为了在不破坏现有解决方案的情况下进行改进，Remi重新设计了Provider，并创建了一个名为Riverpod的新库。</p><p id="f22e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里了解更多:<a class="ae kf" href="http://www.riverpod.dev" rel="noopener ugc nofollow" target="_blank"> riverpod官方文档</a></p><p id="11a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事不宜迟，让我们在应用程序中实现它。</p><p id="cb88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要做的第一件事是在我们的应用程序的pubspec.yaml中添加riverpod的依赖关系。riverpod是一个独立的dart包，这意味着它可以在Flutter之外使用，但由于我们现在将它与Flutter一起使用，所以我们将使用flutter_riverpod。我们将需要一个音频播放器，因此对于包asset_audio_player。</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">提供者和flutter_provider依赖关系</figcaption></figure><p id="1cf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们完成了所有这些，我们将创建一个AudioTrackModel模型。这个对象将包含我们将在应用程序中使用的音轨的基本信息。</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="75c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要创建的第二件事是我们将在应用程序中使用的提供者。第一个提供者将是我们播放列表的提供者，该列表将由<a class="ae kf" href="https://www.bensound.com/" rel="noopener ugc nofollow" target="_blank"> BenSound </a>提供的一些歌曲填充:</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">播放列表提供商</figcaption></figure><p id="16f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，由于我们的播放列表没有改变，我们将只使用一个提供者。但是，如果您想要在数据发生变化时使用数据，您可能会希望查看StateProvider或StateNotifierProvider之类的内容。</p><p id="b9a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在我们的应用程序中使用这些提供者，我们需要用ProviderScope小部件包装我们的MaterialApp:</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用ProviderScope封装应用程序的根</figcaption></figure><p id="8a6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要创建的第二个提供者是AssetAudioPlayer。这将允许我们从应用程序的任何地方访问我们的音频播放器，并执行播放/暂停、下一个等操作</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">音频播放器提供商</figcaption></figure><h2 id="86e6" class="mq lh it bd li mr ms dn lm mt mu dp lq kr mv mw lu kv mx my ly kz mz na mc nb bi translated">Riverpod的魔力:</h2><p id="1c71" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">Riverpod的神奇之处在于它不需要BuildContext来访问提供者，相反，我们可以使用<a class="ae kf" href="https://pub.dev/documentation/riverpod/latest/all/ProviderReference-class.html" rel="noopener ugc nofollow" target="_blank"> ProivderReference </a>来读取或观察它们。这意味着我们现在可以从Flutter的小部件树之外的其他提供者创建计算状态。</p><p id="3169" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:在我们的应用程序中，我们需要当前播放歌曲的状态。该状态包含诸如AudioTrackModel对象的名称、缩略图和其他字段的信息。我们可以通过简单地读取音频播放器提供程序的状态来访问该状态，获取当前播放歌曲的索引，并使用该索引从播放列表提供程序获取关于当前播放歌曲的信息。</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b7a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用提供者，我们所要做的就是简单地扩展ConsumerWidget。这个小部件有一个ScopedReader类型的特殊参数，它监视我们的提供者中的变化，并相应地重新构建我们的小部件。</p><p id="4941" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的应用程序中，我们将利用这一点，使用相同的小部件(大小不同)来显示当前播放歌曲的缩略图。为此，代码如下:</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">当前正在使用ConsumerWidget播放缩略图消费提供程序</figcaption></figure><p id="2866" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用提供者，我们也可以使用消费者小部件来构建依赖于提供者的小部件。例如，在我们的例子中，如果我们想创建一个文本来跟踪当前播放的当前位置，而不必创建一个独立的小部件，我们这样做:</p><figure class="mk ml mm mn gt ju"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在不扩展ConsumerWidget的情况下使用提供者</figcaption></figure><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1a85a6269771a585a827fcbfe10fb34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*-x1shXoLhw_6_gqfcZkWsA.gif"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">决赛成绩</figcaption></figure><p id="1e0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里查看完整的代码:</p><div class="nd ne gp gr nf ng"><a href="https://github.com/yiss/minispotify_flutter_riverpod" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">yiss/minispotify _ flutter _ river pod</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">一个新的颤振项目。这个项目是颤振应用的起点。一些帮助您入门的资源…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu jz ng"/></div></div></a></div><p id="8765" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">最后的想法:</strong></p><p id="a464" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然riverpod是一个新的软件包，但它已经显示出了很大的前景。我很快就被它的简单明了所吸引。<br/>我将针对riverpod可以节省时间的不同用例发布更多实践文章，尤其是在导航方面。下篇见，感谢阅读！</p></div></div>    
</body>
</html>