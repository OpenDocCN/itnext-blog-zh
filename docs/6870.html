<html>
<head>
<title>Setting up a NodeJS API with TypeScript: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript设置NodeJS API:第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/setting-up-a-nodejs-api-with-typescript-part-2-42e4c12f1fe7?source=collection_archive---------6-----------------------#2022-03-27">https://itnext.io/setting-up-a-nodejs-api-with-typescript-part-2-42e4c12f1fe7?source=collection_archive---------6-----------------------#2022-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="687a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">测试、安全和集装箱化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e190a5b4f59992735f19e774488512dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iUDcnUCi6gshbLE_"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">乔纳森·法伯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bc65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是系列文章的第2部分，查看<a class="ae ky" href="https://medium.com/@tudor.ioan.marin/setting-up-a-nodejs-api-with-typescript-part-1-9f7c152b2af6" rel="noopener">用TypeScript设置NodeJS API:第1部分</a>。我们将从那里开始构建代码库。你可以在这里找到完整的代码。从介绍来看:</p><blockquote class="lv lw lx"><p id="d932" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">使用TypeScript开发API时，有许多风格可供选择。[…]但是，如果您想设置一个快速服务器，使其在不使用包含电池的框架的情况下即可投入生产，该怎么办呢？本文的目的是帮助您快速获得一个简约而完整的服务器并运行。</p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="ccf4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">测试案例</h1><p id="ada8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">即使严格的测试被认为是最佳实践，为你的应用程序编写自动化测试也是一种权衡。编写测试套件需要时间，一旦代码的复杂性增加，可预测的上市时间将变得更加重要，您将真正感受到好处。然而，自动化测试将增加你的开发经验和速度。也就是说，让我们开始建立一个测试框架。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/6117cc7ae30376bb6a350b0cebd9cc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uf2jlzFVSDrSKq3WFX298g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">测试框架的JavaScript Surevey结果的状态</figcaption></figure><p id="61cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据JavaScript调查的最新<a class="ae ky" href="https://2021.stateofjs.com/en-US/libraries/testing" rel="noopener ugc nofollow" target="_blank">状态，Jest仍然是当今使用最多的测试框架，并且在兴趣和满意度方面排名前三。要设置框架并使其与TypeScript一起工作，我们需要安装以下包，并在应用程序的根目录下创建一个配置文件:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="baac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们服务器的Jest配置非常简单。我们将把<strong class="lb iu">详细</strong>参数设置为<strong class="lb iu">真</strong>，以便报告每个单独的测试。此外，我们将从<strong class="lb iu"> ts-jest </strong>加载一个<strong class="lb iu">预设</strong>配置，以便能够在TypeScript中运行我们的测试。最后，将<strong class="lb iu"> dotenv/config </strong>添加到<strong class="lb iu"> setupFiles </strong>数组将允许在测试中使用环境变量，因为数组中的任何文件将在每个测试文件中运行一次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候编写一个简单的测试来确保一切正常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj ni l"/></div></figure><p id="aace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们只有一句“你好，世界！”端点，它在应用程序文件中，我们需要重构代码并调整文件夹结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将我们的端点拆分成一个处理字符串生成的<strong class="lb iu"> hello.controller.ts </strong>将使我们能够轻松地为它编写测试。<strong class="lb iu">你好控制器</strong>将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="31bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">app文件现在将导入这个控制器，并使用它来获取响应消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，简单的测试应该导入控制器，模拟预期结果，然后将方法的实际输出与预期结果进行比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行测试套件，我们需要向package.json和Makefile添加以下命令。<strong class="lb iu">测试</strong>命令将运行所有的测试套件，而<strong class="lb iu">测试:观察</strong>命令将观察文件的变化，并重新运行与变化的文件相关的测试。它还会用一些CLI选项提示您只运行测试的子集，例如失败的测试或者基于正则表达式模式的测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fb89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行测试套件，我们可以看到没有由TypeScript语法引起的错误，并且测试通过了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/7cf062ae7478009c4c0ddd993bd49aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9OCjzDtCmeJvOCmPwkVyw.png"/></div></div></figure><h2 id="85fd" class="nl mk it bd ml nm nn dn mp no np dp mt li nq nr mv lm ns nt mx lq nu nv mz nw bi translated">输入超级测试</h2><p id="1fd1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在本系列的第一部分中，我们将express应用程序从HTTP服务器中分离出来。这一点现在变得很重要，因为我们可以使用<a class="ae ky" href="https://github.com/visionmedia/supertest" rel="noopener ugc nofollow" target="_blank"> SuperTest </a>来模拟一个HTTP调用，并在不执行网络调用的情况下测试API。让我们快速安装软件包。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="723f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在测试中使用它来确保端点相应地工作。SuperTest提供了许多HTTP断言，请务必检查它们的文档。出于本文的目的，我们将检查一些标题和状态代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了端点的单元和集成测试，并且100%覆盖。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/4c24267417f9953e1fea59120309d4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VnVpTgF_K5-ZFbXHY1h7w.png"/></div></div></figure><h1 id="ec6e" class="mj mk it bd ml mm ny mo mp mq nz ms mt jz oa ka mv kc ob kd mx kf oc kg mz na bi translated">减轻攻击</h1><p id="975f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">所以你计划在野外部署你的新服务器。当然，一旦公开，它现在很容易受到攻击。幸运的是，你可以通过一些安全包和一些管道规则获得相当不错的保护。当然，安全性是一个可以深入探讨的主题，但这不在本文的讨论范围之内。我们将只为一些众所周知的攻击奠定基础。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od ni l"/></div></figure><p id="c79b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先安装一些依赖项。它们都在你的应用中作为中间件工作，每个请求在到达你的端点之前都要经过它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.npmjs.com/package/helmet" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">头盔</strong> </a>实际上是捆绑成单个的一系列中间件。根据您打算开发的内容，通过使用缺省值或只是一个子集来启用它们是有用的。例如，返回HTML的web服务器将受益于所有这些。然而，对于REST API来说，只使用这些中间件的子集是有意义的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="cbba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.npmjs.com/package/express-rate-limit" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">速率限制</strong> </a>对一个人在一定时间内重复一个动作的频率设置了上限。这将有助于防范DDoS。请确保根据您对流量的估计来调整您的配置。在这个例子中，我们将它设置为<code class="fe oe of og oh b">1k req / 10 min</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="efd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.npmjs.com/package/cors" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a>CORS将允许你把你所接受方法类型、头文件和来源列入白名单。简而言之，任何不符合这些规则的请求都将失败。因为我们没有任何客户端应用程序来支持我们正在构建的API，所以让我们使用默认的CORS:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="3561" class="nl mk it bd ml nm nn dn mp no np dp mt li nq nr mv lm ns nt mx lq nu nv mz nw bi translated">其他规则:</h2><ul class=""><li id="d76e" class="oi oj it lb b lc nb lf nc li ok lm ol lq om lu on oo op oq bi translated">验证客户输入。这里有一个<a class="ae ky" href="https://openbase.com/categories/js/best-nodejs-data-validation-libraries" rel="noopener ugc nofollow" target="_blank">验证器列表</a>。</li><li id="b3af" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">经常扫描您的包中的漏洞。可以使用<code class="fe oe of og oh b">npm audit</code></li><li id="1427" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">使用一般的错误消息，这样你就不会透露太多，并记录具体的错误。</li><li id="32d7" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">使用强身份验证。</li></ul><h1 id="5651" class="mj mk it bd ml mm ny mo mp mq nz ms mt jz oa ka mv kc ob kd mx kf oc kg mz na bi translated">将应用程序归档</h1><p id="aabb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Docker有很多潜在的好处。这取决于您和您对它的使用，以确定它是否会有所帮助或只是增加开销。它的一些亮点是:</p><ul class=""><li id="1a7a" class="oi oj it lb b lc ld lf lg li ow lm ox lq oy lu on oo op oq bi translated">在不同的环境中运行您的软件</li><li id="7736" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">水平扩展您的软件以处理更多的用户</li><li id="7496" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">如果您使用多个服务或微服务</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od ni l"/></div></figure><p id="4bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们为服务器编写docker文件。你需要先在你的机器上安装docker。首先，您需要在项目的根目录下创建一个名为Dockerfile的文件:<code class="fe oe of og oh b">touch Dockerfile</code>。该文件将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dockerfile文件是不言自明的。我们从Node的一个基本映像开始，我选择了<strong class="lb iu"> Alpine </strong>，设置了一个工作目录，并在捆绑应用程序源代码之前复制了我们需要的文件。我还安装了<strong class="lb iu"> Make </strong> util，因为它不在映像中。然后，我们安装npm依赖项，导出一个端口并启动应用程序。之后，您将构建映像并运行容器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个命令将机器上的<code class="fe oe of og oh b">49160</code>端口映射到容器上的<code class="fe oe of og oh b">8080</code>端口。因此，运行curl命令或在浏览器中打开<code class="fe oe of og oh b">localhost:49160</code>应该会到达服务器上的<code class="fe oe of og oh b">/</code>路径。</p><p id="f90f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要启动和关闭容器，您可以运行以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="2728" class="mj mk it bd ml mm ny mo mp mq nz ms mt jz oa ka mv kc ob kd mx kf oc kg mz na bi translated"><strong class="ak">结论</strong></h1><p id="9a19" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">因此，随着测试、安全性和容器化的完成，NodeJS API就完成了。当然，目前它没有做任何事情，因为我觉得仅仅为了展示一个想法而编写业务逻辑没有什么真正的价值。我们仍然有可以探索的途径，比如API架构、持久化数据和缓存。如果你想了解更多关于这些话题的内容，请务必关注。</p><p id="2060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你觉得这篇文章有帮助，鼓掌并分享它，这样它会帮助更多的人。有问题吗？在LinkedIn上给我留言。</p></div></div>    
</body>
</html>