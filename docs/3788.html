<html>
<head>
<title>Summing Up: Container Image Building</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">总结:容器形象塑造</h1>
<blockquote>原文：<a href="https://itnext.io/summing-up-container-image-building-7287472d61c4?source=collection_archive---------9-----------------------#2020-02-24">https://itnext.io/summing-up-container-image-building-7287472d61c4?source=collection_archive---------9-----------------------#2020-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><a href="https://www.giantswarm.io/on-demand-webinar-kubernetes-hard-lessons-and-how-to-avoid-them?utm_campaign=Medium%20CTA%20Conversion&amp;utm_source=Kubernetes%20hard%20lessons_Medium&amp;utm_medium=Medium%20CTA&amp;utm_term=Kubernetes%20hard%20lessons"><div class="gh gi jn"><img src="../Images/49f7795a8134123f16e1d1b09b37fcde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rhc47g8gFVE5OGRV.png"/></div></a></figure><p id="4053" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们在这个系列下为容器图像构建的艺术状态划上一条线时，值得花点时间来思考我们的发现。</p><p id="924b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与早期因Docker而流行的集装箱化趋势相比，在集装箱形象建设游戏中有更多的玩家<a class="ae ks" href="https://blog.giantswarm.io/building-container-images-with-img/" rel="noopener ugc nofollow" target="_blank"/>。我们当然没有全部看过！</p><p id="a19b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，每个工具的存在都是由于Docker提供的原始容器构建经验的不足。每一个都有独特的角度，无论是商业的还是技术的。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi kt"><img src="../Images/7e99fb0194add0cf612094c780131c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lzxX-XpsLURvSK-B.png"/></div></div></figure><p id="2ded" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">你知道吗？我们上</strong> <a class="ae ks" href="https://medium.com/@GiantSwarm" rel="noopener"> <strong class="jw ir">中</strong> </a> <strong class="jw ir">也是！</strong> <a class="ae ks" href="https://medium.com/@GiantSwarm" rel="noopener"> <strong class="jw ir">关注我们</strong> </a> <strong class="jw ir">千万不要错过这样的资讯文章。</strong></p><h1 id="bb9e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Dockerfile文件支持</h1><p id="9f01" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">特别有趣的是，每个工具仍然支持(如果不支持的话，提升)Dockerfile作为描述容器图像的声明性方式。</p><p id="3f4a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这证明了“docker build”体验所提供的简单性、官方docker图像的流行性，以及以这种方式构建的容器图像的普遍性。当然，还有其他不使用Dockerfile的方法，但是Dockerfile似乎还会存在一段时间。</p><h1 id="94e5" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">无根建筑</h1><p id="f20c" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">越来越多的人将Kubernetes作为容器工作负载的家，这对构建映像的方向有很大的影响。</p><p id="6632" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在pod中安装Docker插座，或者运行特权构建容器(<a class="ae ks" href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" rel="noopener ugc nofollow" target="_blank"> DinD </a>)提供了不太理想的体验。尤其是对于那些需要强大安全姿态的人。今天，无根和无特权的构建是可能的，但是需要在宿主环境中进行一些次优的配置或调整。为了达到当前的状态，需要坚持不懈地将更改合并到Linux内核、Docker引擎和Kubernetes中。然而，要使这一进程真正安全，不需要不必要的特权，还有更多的工作要做。</p><h1 id="5f32" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">无梦的</h1><p id="b8fb" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">Kubernetes中的容器映像构建也推动了无后台构建的进步，对Docker后台程序的依赖慢慢成为过去。</p><p id="3586" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本系列中考虑的所有工具都是无守护进程的，尽管BuildKit必须作为一个<a class="ae ks" href="https://github.com/moby/buildkit/blob/master/examples/buildctl-daemonless/buildctl-daemonless.sh" rel="noopener ugc nofollow" target="_blank">短暂的</a>守护进程运行才能达到同样的效果。</p><figure class="ku kv kw kx gt jr gh gi paragraph-image"><a href="https://www.giantswarm.io/on-demand-webinar-kubernetes-hard-lessons-and-how-to-avoid-them?utm_campaign=Medium%20CTA%20Conversion&amp;utm_source=Kubernetes%20hard%20lessons_Medium&amp;utm_medium=Medium%20CTA&amp;utm_term=Kubernetes%20hard%20lessons"><div class="gh gi mf"><img src="../Images/3ef8462f8c5043c2475daa2b6bdff075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rU8OLgxaQhcnaAQ7CBfbXA.jpeg"/></div></a></figure><h1 id="433c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">减少构建时间</h1><p id="5c46" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">开发人员在应用程序开发过程中不断寻找加速容器映像构建的方法。</p><p id="682f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">BuildKit凭借其并发依赖性解决方案轻而易举地胜出，与竞争对手相比，其性能令人印象深刻。然而，最佳的构建缓存使用也是构建持续时间的一个关键因素。远程和分布式构建缓存技术正变得越来越重要，尤其是当不清楚构建任务将在哪个主机上结束时。在大多数新的映像构建工具中，这是一个备受关注的领域。</p><h1 id="d2a2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结构</h1><p id="8ecf" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">最后，虽然大多数应用面向x86_64架构，但随着边缘计算等范例的采用增加(由物联网推动)，映像构建需要适应不同的CPU架构。BuildKit(和隐含的Img)为跨平台图像提供了一些支持，但是其他工具还有一些工作要做。</p><h1 id="632f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="cf83" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">自从Docker引擎提供早期构建体验以来，容器映像构建已经走过了漫长的道路。</p><p id="4500" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然在集装箱化的显著增长期间，进步停滞了一段时间，但是云原生社区已经加快步伐并开始创新，以修复许多缺陷。它带来了多种解决方案，源自云环境的不同角落。在某个时候，我们可能会担心工作和方法的分散。但是，不同的解决方案将适合不同的组织和不同的使用情形。而且，作为容器图像的消费者，使用哪种工具来构建特定的图像并不重要。只要构建的映像符合<a class="ae ks" href="https://github.com/opencontainers/image-spec/blob/master/spec.md#image-format-specification" rel="noopener ugc nofollow" target="_blank"> OCI映像规范</a>，派生的容器总是会以我们期望的方式运行。</p><p id="1b34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">几年后回到这个话题，看看事情是如何变化的，将会很有趣。但是，与此同时，享受构建您的容器图像，并且不要忘记回馈社区！给我们发推特<a class="ae ks" href="https://twitter.com/giantswarm" rel="noopener ugc nofollow" target="_blank"> @giantswarm </a>，让我们知道你的想法。</p><p id="4af0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由<a class="ae ks" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank">Puja Abbas si</a>——开发者倡导者@ <a class="ae ks" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型群体</a>撰写</p><div class="mg mh gp gr mi mj"><a href="https://twitter.com/puja108" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">Puja Abbassi</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">Puja Abbassi的最新推文(@puja108)。开发者关系&amp;产品@ GiantSwarm研究员；主题…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">twitter.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx js mj"/></div></div></a></div></div></div>    
</body>
</html>