<html>
<head>
<title>How to build browser game? [Iteration 2] GUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建浏览器游戏？[迭代2]图形用户界面</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-browser-game-iteration-2-gui-6d31dbed8a8f?source=collection_archive---------3-----------------------#2018-01-24">https://itnext.io/how-to-build-browser-game-iteration-2-gui-6d31dbed8a8f?source=collection_archive---------3-----------------------#2018-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6313cda10e9f3534f47bc859493766f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhzhJHd4MNaqkmXM3cdEyQ.jpeg"/></div></div></figure><div class=""/><p id="2d39" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fhow-to-build-browser-game-iteration-2-gui-6d31dbed8a8f" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="d1b7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这些系列的目标是尽可能多的了解web开发的方方面面，尝试新的技术，学习新的有趣的东西。我们将通过创建一个基于文本的浏览器游戏来做到这一点。</p><p id="1b94" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你还没有看过之前的帖子，下面就是:</p><ul class=""><li id="fcfe" class="ky kz jb ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">【迭代0】Idea:<a class="ae kw" href="https://medium.com/@dmitrykmita/how-to-build-browser-game-iteration-0-idea-c0865d125148" rel="noopener">https://medium . com/@ dmitrykmita/how-to-build-browser-game-Iteration-0-Idea-c 0865d 125148</a></li><li id="af24" class="ky kz jb ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">【迭代1】Domains:<a class="ae kw" href="https://medium.com/@dmitrykmita/how-to-build-browser-game-iteration-1-domains-a62fbd9d9fba" rel="noopener">https://medium . com/@ dmitrykmita/how-to-build-browser-game-Iteration-1-Domains-a 62 FBD 9d 9 FBA</a></li></ul><p id="0815" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是GUI的时候了。我不擅长画画，而且，我从来都不是一个超级玩家，所以为这个游戏设计GUI确实是一个挑战。我浏览了一些游戏，谷歌了很多，查看了一些游戏开发的资源，并使用伟大的工具<a class="ae kw" href="https://wireframe.cc/" rel="noopener ugc nofollow" target="_blank">https://wireframe.cc/</a>制作了一个线框</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lm"><img src="../Images/ad7c6f9a9b71077f53dea966e6f7f8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fB1NpxB7550aAwBOdlz1OA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">通用GUI</figcaption></figure><p id="20d3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我使用了另一个伟大的工具<a class="ae kw" href="https://coolors.co/9381ff-b8b8ff-f8f7ff-ffeedd-ffd8be" rel="noopener ugc nofollow" target="_blank">https://coolors.co/</a>进行配色。</p><p id="1957" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是反应部分。这将是一个关于如何在ReactJS上构建UI的基础教程。</p><p id="ca6f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我用webpack进行捆绑，用babel编译JS。</p><p id="f59c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，要使用react创建您的前端，您可以使用react-create-app服务，或者只需在您的公共文件夹中初始化npm项目。在Symfony框架的情况下为/web)。</p><p id="ce58" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，添加一些依赖项:</p><pre class="ln lo lp lq gt lv lw lx ly aw lz bi"><span id="1b53" class="ma mb jb lw b gy mc md l me mf">npm install --save babel-core babel-loader babel-preset-es2015 babel-preset-react react react-dom webpack</span></pre><p id="e054" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经安装了用于捆绑的webpack、用于编译的babel和用于编码的react。</p><p id="b986" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来的事情是指定你将使用哪些JS预置，所以创建<strong class="ka jc">。babelrc </strong>文件，并添加您将使用的文件(在我的例子中是es2015和react jsx):</p><pre class="ln lo lp lq gt lv lw lx ly aw lz bi"><span id="1f59" class="ma mb jb lw b gy mc md l me mf">{<br/>  "presets": [<br/>    "react",<br/>    "es2015"<br/>  ]<br/>}</span></pre><p id="ec2d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，现在babel知道如何编译我们的应用程序了。</p><p id="0609" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是时候创建实际的ui代码了，于是我又创建了一个文件夹(我把它叫做<em class="kx">库</em>，不知道为什么，你可以把它叫做<em class="kx"> src </em>)并添加了一个新文件叫做Game.js</p><p id="192b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Game.js会是我前端的切入点。</p><p id="2a16" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让webpack工作，我在npm根文件夹中创建了<strong class="ka jc"> webpack.config.js </strong>文件，并添加了一些通用代码:</p><pre class="ln lo lp lq gt lv lw lx ly aw lz bi"><span id="4834" class="ma mb jb lw b gy mc md l me mf"><strong class="lw jc">const </strong>path = require('path');<br/><br/>module.exports = {<br/>    entry: './libraries/Game.js',<br/>    output: {<br/>        path: path.join(__dirname, 'dist'),<br/>        filename: 'game.js'<br/>    },<br/>    module: {<br/>        loaders: [<br/>            {<br/>                test: /\.js$/,<br/>                exclude: /node_modules/,<br/>                loader: 'babel-loader'<br/>            }<br/>        ]<br/>    }<br/>};</span></pre><p id="35e4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我正在使用NodeJS <strong class="ka jc"> path </strong>库来简化入口文件的路径。这个模块中的代码非常简单，设置入口文件，设置输出文件以及如何加载模块。</p><p id="a67f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我讨厌通过node_modules文件夹运行webpack，所以我将这个脚本添加到package.json:</p><pre class="ln lo lp lq gt lv lw lx ly aw lz bi"><span id="5531" class="ma mb jb lw b gy mc md l me mf">"scripts": {<br/>  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>  <strong class="lw jc">"dev": "webpack -wd"</strong><br/>},</span></pre><p id="3652" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在开发模式下运行webpack，并开始观察任何变化，所以现在我可以简单地运行:</p><pre class="ln lo lp lq gt lv lw lx ly aw lz bi"><span id="dac9" class="ma mb jb lw b gy mc md l me mf">npm run webpack</span></pre><p id="2953" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它应该会编译您的包。哦，但是它是空的，因为我们的Game.js是空的。让我们创建我们的新组件！</p><p id="c115" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所知道的，ReactJS是基于组件的，它们继承、协作并友好地生活在一起。</p><p id="6000" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建组件，您需要使用以下语法(有几种方法，但这被称为最正确的方法):</p><pre class="ln lo lp lq gt lv lw lx ly aw lz bi"><span id="b6d3" class="ma mb jb lw b gy mc md l me mf"><strong class="lw jc">import </strong>React <strong class="lw jc">from </strong>"react";<br/><strong class="lw jc">import </strong>ReactDOM <strong class="lw jc">from </strong>"react-dom";<br/><br/><strong class="lw jc">class </strong>Game <strong class="lw jc">extends </strong>React.Component {<br/><br/>    render() {<br/>        <strong class="lw jc">return </strong>(<br/>            &lt;div&gt;<br/>                &lt;div className="container-fluid"&gt;<br/>                    &lt;div className="row"&gt;<br/>                        &lt;div className="col-md-12"&gt;<br/>                            &lt;CharacterWidget /&gt;<br/>                            &lt;HeaderWidget /&gt;<br/>                        &lt;/div&gt;<br/>                    &lt;/div&gt;<br/>                &lt;/div&gt;<br/>                &lt;div className="container-fluid"&gt;<br/>                    &lt;div className="row"&gt;<br/>                        &lt;div className="col-md-6 text-center"&gt;<br/>                            &lt;Map /&gt;<br/>                        &lt;/div&gt;<br/>                        &lt;div className="col-md-6"&gt;<br/>                            &lt;MapDetails /&gt;<br/>                        &lt;/div&gt;<br/>                    &lt;/div&gt;<br/>                &lt;/div&gt;<br/>                &lt;Inventory /&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    }<br/>};<br/><br/><strong class="lw jc">var </strong>mountNode = document.getElementById("game");<br/><strong class="lw jc">if </strong>(mountNode) {<br/>    ReactDOM.render(&lt;Game /&gt;, mountNode);<br/>}</span></pre><p id="7508" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React组件只需要一个名为render()的方法，它返回这个特定组件的模板。正如你所看到的，我用bootstrap创建了一些愚蠢的模板。因为我们使用的是JSX，所以我们必须使用className来代替class。但是这些<strong class="ka jc"><em class="kx">&lt;character widget/&gt;&lt;header widget/&gt;&lt;Map/&gt;&lt;Map details/&gt;</em></strong>是什么？这些是我们将创建的其他组件。现在，我已经创建了所有这些组件，并把它们作为模板:</p><pre class="ln lo lp lq gt lv lw lx ly aw lz bi"><span id="60c4" class="ma mb jb lw b gy mc md l me mf">&lt;div className=”c-character-widget”&gt;Character Widget&lt;/div&gt;<br/>&lt;div className=”c-header-widget”&gt;Header Widget&lt;/div&gt;<br/>&lt;div className=”c-map”&gt;Map&lt;/div&gt;<br/>&lt;div className=”c-map-details”&gt;Map Details&lt;/div&gt;</span></pre><p id="73d4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我提到的<strong class="ka jc"> c-% </strong>类，让我们来谈谈css。</p><p id="d709" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在这个应用程序中使用了SASS，有2种方法捆绑我们的css。要么我为每个组件单独创建所有scss文件，将scss文件作为依赖项添加到每个组件，然后将sass-compiler添加到webpack(这是网站的最佳解决方案，因为这样webpack将根据组件页面使用情况为每个页面生成所需的样式)，要么创建main.scss，在其中添加所有组件scss文件并创建1个捆绑css(对我来说更好，因为游戏没有很多页面)。</p><p id="d8de" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用“某种”边界元方法来定义我的css类。这是一个带有特定项目将提供的附加功能的模块示例:</p><pre class="ln lo lp lq gt lv lw lx ly aw lz bi"><span id="24b5" class="ma mb jb lw b gy mc md l me mf">.c-extra {<br/>  margin-top: 10px;<br/>  .c-extra--title {<br/>    font-size: 13px;<br/>    color: $color-gold-primary;<br/>    text-shadow: 0 0 5px #000;<br/>  }<br/><br/>  .c-extra--item {<br/>    font-size: 12px;<br/>    color: $color-gray-light-primary;<br/><br/>    &amp;.c-extra--item__required {<br/>      color: $color-red-primary;<br/>    }<br/><br/>    .c-extra--item-stat {<br/>      display: inline-block;<br/>      margin-right: 5px;<br/>    }<br/>    .c-extra--item-value {<br/>      display: inline-block;<br/>    }<br/>  }<br/>}</span></pre><p id="c29b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是jsx模板:</p><pre class="ln lo lp lq gt lv lw lx ly aw lz bi"><span id="aaec" class="ma mb jb lw b gy mc md l me mf">&lt;div className="c-extra"&gt;<br/>    &lt;div className="c-extra--title"&gt;Extras&lt;/div&gt;<br/>    {<strong class="lw jc">this</strong>.props.item.extras.map((item, i) =&gt; {<br/>        <strong class="lw jc">return </strong>(<br/>            &lt;div key={i} className="c-extra--item"&gt;<br/>                &lt;div className="c-extra--item-stat"&gt;<br/>                  {item.attribute}<br/>                &lt;/div&gt;<br/>                &lt;div className="c-extra--item-value"&gt;<br/>                  {item.value}<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    })}<br/>&lt;/div&gt;</span></pre><p id="8c51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，尽管这些类变得有点长——很容易理解组件的结构及其可重用性，如果你把它移到应用程序的任何其他地方——它应该保持不变。组件的思想是无状态的，无论你把它放在哪里，它看起来都应该是一样的。</p><p id="724c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个非常丑陋，但工作字符部件的例子:</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/6d879c2e555f85f47d9731c186b21302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*p1LKCZAdw5M4pu4DlNKxKg.png"/></div></figure><p id="d43e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我现在还没有接触数据，因为我们所需要的只是构建UI，然后我们将继续前进。</p><p id="cb41" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为这已经足够了，如果你对ReactJS组件、sass、webpack或本文中涉及的任何内容有任何问题，请在下面的评论部分随意提问。</p><p id="f743" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我能说的是——我改变了对ReactJS的态度，因为我发现它是一个非常小巧而强大的工具，可以用来构建基于组件的ui，并使用VirtualDOM的所有功能。</p><p id="a2a3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一篇文章中，我们将谈论地图！</p></div></div>    
</body>
</html>