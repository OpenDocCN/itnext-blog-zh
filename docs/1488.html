<html>
<head>
<title>A personal review of automated testing tools in the JavaScript world</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript世界中自动化测试工具的个人评论</h1>
<blockquote>原文：<a href="https://itnext.io/a-personal-review-of-automated-testing-tools-in-the-javascript-world-3c504fe6e05d?source=collection_archive---------0-----------------------#2018-10-31">https://itnext.io/a-personal-review-of-automated-testing-tools-in-the-javascript-world-3c504fe6e05d?source=collection_archive---------0-----------------------#2018-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a2b2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我的一些开源工具的“2美分”,我已经使用或已经使用，以确保软件开发项目的质量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9e83504cf15c7ca2171847861355e6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRV92399sgFGeWbzcAHjig.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">JavaScript代码</figcaption></figure><p id="803c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我将谈谈我使用支持<strong class="kx ir"> JavaScript </strong>的工具进行<strong class="kx ir">测试自动化</strong>的经历。在这篇文章的第一部分，我将讨论图形用户界面或<strong class="kx ir"> GUI </strong>的<strong class="kx ir">自动化测试工具。在文章的第二部分，我将谈论用于<strong class="kx ir">集成测试自动化</strong>或<strong class="kx ir"> API测试</strong>的工具。在文章的第三部分，我将讨论用于<strong class="kx ir">单元测试</strong>的工具。在最后一部分，我将讨论用于静态代码分析的工具。</strong></p><h2 id="842a" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">第1部分—图形用户界面(GUI)的自动化测试</h2><h2 id="2100" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://github.com/SeleniumHQ/selenium/wiki/WebDriverJs" rel="noopener ugc nofollow" target="_blank"> Selenium Webdriver </a></h2><p id="9e30" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我对<strong class="kx ir"> Selenium Webdriver </strong>的<strong class="kx ir"> JavaScript </strong>版本的体验在使用该框架时可能完成的事情方面相当满意，它是<strong class="kx ir"> GUI测试</strong>的一个强大选项，满足了对多种浏览器的支持需求，如<strong class="kx ir"> Chrome </strong>、<strong class="kx ir"> Firefox </strong>、<strong class="kx ir"> Safari、</strong>和<strong class="kx ir"> Internet Explorer </strong>。</p><p id="8506" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其他相关点是社区支持；它是GitHub  和<strong class="kx ir">会议</strong>上的<a class="ae mk" href="https://github.com/SeleniumHQ/selenium/graphs/code-frequency" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">活动项目。2017年我有机会参加了柏林的<a class="ae mk" href="https://www.seleniumconf.de" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">SeleniumConf</strong></a>，除了更新自己，也学到了很多。</strong></a></p><p id="a26c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于文档，直到最近，它还不是最好的，但是<strong class="kx ir">版本4 </strong>正在推出优秀的<a class="ae mk" href="https://seleniumhq.github.io/docs/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">文档</strong> </a>并且坚持W3C WebDriver 的<strong class="kx ir">规范。对那些感兴趣的人来说，下面还有一个<strong class="kx ir">相关内容</strong>。</strong></p><p id="95fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Selenium </strong>的另一个优势是支持在不同浏览器中执行相同的测试用例。非常适合测试聊天和视频会议应用。</p><h2 id="2840" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="http://www.protractortest.org/#/" rel="noopener ugc nofollow" target="_blank">量角器</a></h2><p id="a731" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir">量角器</strong>是我比较有经验的<strong class="kx ir"> GUI自动化测试工具</strong>。自2014年以来，我一直在使用这个框架，在Medium  上用英文<a class="ae mk" href="https://medium.com/search?q=protractor%20walmyr" rel="noopener"> <strong class="kx ir">写内容，在WordPress </strong> </a>上用葡萄牙文<a class="ae mk" href="https://talkingabouttesting.com/?s=protractor" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">写内容，在YouTube</strong></a><a class="ae mk" href="https://www.slideshare.net/walmyrlimasilvafilho/presentations" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">上分享<a class="ae mk" href="https://www.youtube.com/user/wlsf82/videos" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">视频，在events </strong> </a>上演讲<a class="ae mk" href="https://www.slideshare.net/walmyrlimasilvafilho/presentations" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">，指导QA从业者专门研究这个主题，维护<a class="ae mk" href="https://www.npmjs.com/package/protractor-helper" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">量角器助手</strong> </a>库，创建这个库是为了帮助其他专业人士写作 写两本书(一本用<a class="ae mk" href="https://leanpub.com/end-to-end-testing-with-protractor" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">英文</strong> </a>另一本用<a class="ae mk" href="https://www.casadocodigo.com.br/products/livro-protractor" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">葡萄牙文</strong> </a>，两本书都是经验教训的集合)，把项目以<a class="ae mk" href="https://github.com/wlsf82/protractor-and-webrtc" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> codelab </strong> </a>和<a class="ae mk" href="https://github.com/wlsf82/protractor-components-and-page-objects" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">架构建议</strong> </a>的形式保存在<strong class="kx ir"> GitHub </strong>上，并在<a class="ae mk" href="http://talkingabouttesting.coursify.me/courses/arquitetura-de-testes-com-protractor" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">谈论测试学校</strong> </a>授课，如果我还没有😀</strong></a></strong></a></p><p id="e5cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与Selenium相比，<strong class="kx ir">量角器的一个显著优点是，</strong>是一个更简单的语法<a class="ae mk" href="https://www.protractortest.org/#/webdriver-vs-protractor" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"/></a>，你可以用更少的代码做同样的事情，有助于可读性和可维护性。</p><p id="7dfe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于习惯于对库进行<strong class="kx ir">单元测试的开发人员来说，比如<strong class="kx ir"> Jasmine </strong>或者<strong class="kx ir"> Mocha </strong>，两者都受到<strong class="kx ir">量角器</strong>的支持，第一个是默认的。</strong></p><p id="1ac5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于文档，我最喜欢的部分是<a class="ae mk" href="http://www.protractortest.org/#/api" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> API </strong> </a>，它总是随着新版本一起更新。</p><p id="660e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">量角器</strong>也支持市面上使用最多的浏览器，还有<strong class="kx ir"> Selenium </strong>。</p><p id="a034" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> TypeScript </strong>支持是它的另一个优势。</p><p id="e2b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后主要由<a class="ae mk" href="https://angular.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Angular </strong> </a>团队维护，由<strong class="kx ir"> Google </strong>支持。</p><h2 id="7eb1" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://www.cypress.io" rel="noopener ugc nofollow" target="_blank">柏树</a></h2><p id="c019" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir"> Cypress </strong>是我目前正在使用的<strong class="kx ir">端到端测试</strong>工具(在一些个人项目中)。到目前为止，引起我注意的是它出色的<a class="ae mk" href="https://docs.cypress.io/guides/overview/why-cypress.html#In-a-nutshell" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">文档</strong> </a>、易用性，它支持对REST API的<a class="ae mk" href="https://docs.cypress.io/api/commands/request.html#Syntax" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">测试，开发工具如<strong class="kx ir">与Chrome开发工具</strong>、<a class="ae mk" href="https://docs.cypress.io/guides/guides/debugging.html#Using" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">集成调试</strong> </a>、<a class="ae mk" href="https://docs.cypress.io/guides/core-concepts/test-runner.html#Overview" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">交互模式</strong> </a>、<a class="ae mk" href="https://docs.cypress.io/api/commands/stub.html#Differences" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">存根</strong> </a>支持、<a class="ae mk" href="https://docs.cypress.io/api/commands/exec.html#Syntax" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"/></a></strong></a></p><h2 id="c5b4" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://garris.github.io/BackstopJS/" rel="noopener ugc nofollow" target="_blank">背刺</a></h2><p id="961a" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir"> BackstopJS </strong>是我用过的最直白的<a class="ae mk" href="https://talkingabouttesting.com/?s=backstop" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">截图对比测试</strong> </a>工具，也叫<strong class="kx ir">视觉回归测试</strong>。</p><p id="e9b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我已经使用<strong class="kx ir"> BackstopJS </strong>大约一年了，我很高兴。它拥有优秀的<a class="ae mk" href="https://github.com/garris/BackstopJS" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">文档</strong> </a>，是GitHub  上相对活跃的<a class="ae mk" href="https://github.com/garris/BackstopJS/graphs/code-frequency" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">项目。它<a class="ae mk" href="https://github.com/garris/BackstopJS#using-docker-for-testing-across-different-environments" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">支持在Docker容器</strong> </a>内运行测试，支持<a class="ae mk" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">木偶</strong> </a>引擎。</strong></a></p><p id="5d72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我对<strong class="kx ir"> BackstopJS </strong>用户的两个“贡献”是<a class="ae mk" href="https://github.com/wlsf82/backstop-config" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">back stop-config</strong></a>项目(<a class="ae mk" href="https://github.com/garris/BackstopJS#tutorials-extensions-and-more" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">包含在工具</strong> </a>的官方文档中)和使用BackstopJS  进行可视化回归测试的<a class="ae mk" href="http://talkingabouttesting.coursify.me/courses/testes-de-regressao-visual-com-backstopjs" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">课程(只有葡萄牙语版本)。</strong></a></p><h2 id="d218" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">第2部分——集成测试自动化(API测试)</h2><h2 id="f9ef" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://github.com/jsdom/jsdom" rel="noopener ugc nofollow" target="_blank"> jsdom </a></h2><p id="5b5c" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir"> Jsdom </strong>是一个可以和这里将要讨论的其他工具结合使用的库，比如<strong class="kx ir"> SuperTest </strong>和<strong class="kx ir"> Chai </strong>。使用<strong class="kx ir"> jsdom </strong>，可以模拟web浏览器的子集来测试应用服务器，而不需要真正的浏览器。</p><p id="3904" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用<strong class="kx ir"> jsdom </strong>库可以做的一个例子是<strong class="kx ir">解析由<strong class="kx ir"> REST API调用</strong>返回的HTML </strong>，并执行类似于<strong class="kx ir"> querySelector </strong>函数的东西来返回一个特定的HTML元素，然后断言该元素具有给定值。例如，可以使用<strong class="kx ir"> Chai </strong>库来执行这种验证。</p><h2 id="f8a6" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://www.npmjs.com/package/supertest" rel="noopener ugc nofollow" target="_blank">超级测试</a></h2><p id="1f2e" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir"> SuperTest </strong>用于<strong class="kx ir">测试HTTP REST调用</strong>，允许你测试<strong class="kx ir">获取</strong>、<strong class="kx ir">发布</strong>、<strong class="kx ir">放置</strong>、<strong class="kx ir">删除、</strong>和<strong class="kx ir">修补</strong>的请求。</p><p id="9304" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以使用该库完成的一些可能的测试有:</p><ul class=""><li id="c873" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">验证<strong class="kx ir"> HTTP请求</strong>的响应是否返回正确/预期的<strong class="kx ir">状态代码</strong>；</li><li id="7cb3" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">验证<strong class="kx ir"> HTTP reques </strong> t的响应在其标头中返回了正确的位置值；</li><li id="1ec5" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">例如，结合像<strong class="kx ir"> jsdom </strong>和<strong class="kx ir"> chai </strong>这样的工具，它可以断言在<strong class="kx ir"> POST </strong>请求后使用特定CSS选择器返回的HTML元素的数量。</li></ul><h2 id="76c1" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://www.chaijs.com" rel="noopener ugc nofollow" target="_blank">柴</a></h2><p id="7365" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir"> Chai </strong>是一个<strong class="kx ir">断言库</strong>，不仅适用于节点环境，也适用于web浏览器，因此这个工具使得执行类似于<strong class="kx ir"> jsdom </strong>和<strong class="kx ir"> SuperTest </strong>中提到的检查成为可能。</p><p id="14c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当用于<strong class="kx ir">集成测试</strong>时，可以用<strong class="kx ir"> Chai </strong>库执行的断言的一些例子是:</p><ul class=""><li id="eab8" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">验证用HTTP请求的返回填充的特定变量包含给定的字符串或等于给定的字符串；</li><li id="9ecd" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">验证用HTTP请求的返回填充的特定变量具有一定的长度；</li><li id="fab4" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">验证用HTTP请求的返回填充的特定变量是否具有特定的属性。</li></ul><h2 id="79dc" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://www.cypress.io" rel="noopener ugc nofollow" target="_blank">柏树</a></h2><p id="6607" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">正如在关于使用<strong class="kx ir"> Cypress </strong>的<strong class="kx ir">自动化GUI测试</strong>一节中简要讨论的，除了通过图形用户界面测试交互之外，<a class="ae mk" href="https://docs.cypress.io/api/commands/request.html#Syntax" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">还可以测试REST API</strong></a>。</p><p id="af50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以用<strong class="kx ir"> Cypress </strong>进行的<strong class="kx ir"> API测试</strong>的一些例子有:</p><ul class=""><li id="ffe5" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">验证状态代码；</li><li id="da18" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">验证URL重定向；</li><li id="33a9" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">HTTP请求的响应体验证。</li></ul><h2 id="6d83" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">第3部分——单元测试自动化</h2><h2 id="67f7" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://github.com/substack/tape" rel="noopener ugc nofollow" target="_blank">磁带</a></h2><p id="d595" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir"> Tape </strong>是我用过的最直接的<strong class="kx ir">单元测试库</strong>。这样的库已经附带了断言列表，这简化了测试过程，不需要导入特定的库来执行预期结果的断言。</p><p id="2718" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae mk" href="https://github.com/wlsf82/age-discoverer" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">这里有一个GitHub </strong> </a>上的示例项目，我在那里使用<strong class="kx ir"> Tape </strong>库来练习一些技术，比如<strong class="kx ir"> TDD </strong>，增加<strong class="kx ir">代码覆盖率</strong>，<strong class="kx ir">重构</strong>，<strong class="kx ir">清理代码</strong>，等等。</p><h2 id="d288" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://jasmine.github.io" rel="noopener ugc nofollow" target="_blank">茉莉</a></h2><p id="27cb" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">Jasmine 框架使得<strong class="kx ir">行为驱动开发</strong> ( <strong class="kx ir"> BDD </strong>)在单元级别上的实践成为可能。</p><p id="a9d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该工具的一个显著优势是<strong class="kx ir">简化的语法</strong>，它允许测试<strong class="kx ir">易于编写和读取</strong>。</p><h2 id="cb00" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://mochajs.org" rel="noopener ugc nofollow" target="_blank">摩卡</a></h2><p id="3a41" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我的印象是，<strong class="kx ir"> Mocha </strong>框架是<strong class="kx ir"> JavaScript </strong>开发者在谈论<strong class="kx ir">单元测试</strong>时使用最多的。</p><p id="cfe0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个工具以一种简单的方式在节点和浏览器环境中支持<strong class="kx ir">异步测试</strong>。</p><p id="3df3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的许多功能包括:</p><ul class=""><li id="10f0" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">支持<strong class="kx ir">异步测试</strong>，包括<strong class="kx ir">承诺</strong>；</li><li id="d660" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">使用运行单个测试。仅()，或者使用跳过单个测试。skip()；</li><li id="4c48" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">代码覆盖率报告。</li></ul><h2 id="fe94" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://nodejs.org/api/assert.html" rel="noopener ugc nofollow" target="_blank"> Node.js断言</a></h2><p id="1ad0" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir"> Node.js断言</strong>是<strong class="kx ir"> Node.js </strong>模块，用于<strong class="kx ir">单元测试</strong>中的断言。</p><p id="38c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它最显著的优点是已经和<strong class="kx ir"> Node.js </strong>一起安装，不需要额外安装。</p><h2 id="d2bf" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://www.chaijs.com" rel="noopener ugc nofollow" target="_blank">柴</a></h2><p id="6131" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">正如在关于<strong class="kx ir">集成测试</strong>的章节中已经讨论过的，<strong class="kx ir"> Chai </strong>是一个<strong class="kx ir">断言库</strong>，用于节点环境，也用于web浏览器。</p><p id="dbba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了已经提到的，使用<strong class="kx ir"> Chai </strong>库，除了支持使用插件之外，还可以以<strong class="kx ir"> BDD </strong>或<strong class="kx ir"> TDD </strong>的风格进行断言，以扩展其功能。</p><h2 id="0276" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://github.com/airbnb/enzyme" rel="noopener ugc nofollow" target="_blank">酶</a></h2><p id="05b6" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir"> Enzyme </strong>是Airbnb推出的<strong class="kx ir">单元测试实用程序</strong>，用于对<strong class="kx ir"> React </strong>组件执行断言。</p><p id="f402" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以用这种工具进行测试的一个例子是表面渲染一个<strong class="kx ir">反应</strong>组件(浅层渲染)并用一个特定的CSS选择器检查返回的元素数量。</p><p id="e366" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae mk" href="https://github.com/wlsf82/hackernews" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">这是GitHub </strong> </a>上的一个示例项目，我使用<strong class="kx ir">酶</strong>对React组件进行简单的<strong class="kx ir">测试。</strong></p><h2 id="6f26" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://jestjs.io" rel="noopener ugc nofollow" target="_blank">笑话</a></h2><p id="06ab" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir"> Jest </strong>是脸书推出的<strong class="kx ir">测试框架</strong>，其中<strong class="kx ir"> React </strong>社区主要用于<strong class="kx ir">快照测试</strong>，但也可以用于需要使用<strong class="kx ir">测试替身</strong>的测试，如<strong class="kx ir">模拟</strong>。</p><p id="40c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的一些优点是:</p><ul class=""><li id="80fb" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">因为它是一个完整的框架，所以不需要安装其他的库。使用<strong class="kx ir"> Jest，</strong>您编写测试和断言，执行它们，然后可视化测试执行报告；</li><li id="7818" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">它已经支持<strong class="kx ir">代码覆盖率</strong>报告，不需要为此安装其他特定的库；</li><li id="d44c" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">开始使用它不需要配置。</li></ul><p id="bedc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx ir">酶</strong>测试部分的<strong class="kx ir"> GitHub </strong>上的同一个示例项目中，我也使用了<strong class="kx ir"> Jest </strong>框架进行<strong class="kx ir">快照测试</strong>。</p><h2 id="9ec3" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://istanbul.js.org" rel="noopener ugc nofollow" target="_blank">伊斯坦布尔</a></h2><p id="5d1c" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir">伊斯坦布尔</strong> <strong class="kx ir">不是</strong> <strong class="kx ir">单元测试</strong> <strong class="kx ir">工具</strong>而是<strong class="kx ir">从<strong class="kx ir">单元测试</strong>中提取代码覆盖度量</strong>的工具。</p><p id="58e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的主要目的是清楚地说明应用程序代码的哪些部分是通过测试执行的，或者不是通过测试执行的，这使得识别风险区域和潜在的改进区域成为可能。</p><p id="0a97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在同一个示例项目的<strong class="kx ir">磁带</strong>部分中，我使用<strong class="kx ir">伊斯坦布尔</strong>来提取<strong class="kx ir">代码覆盖</strong> <strong class="kx ir">度量</strong>。</p><h2 id="1596" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">第4部分—静态代码分析工具</h2><h2 id="fbec" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://standardjs.com" rel="noopener ugc nofollow" target="_blank">标准JS </a></h2><p id="60ec" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir"> StandardJS </strong>是我所知道的最简单的静态<strong class="kx ir"> JavaScript </strong> <strong class="kx ir">代码分析</strong>的选项，有助于<strong class="kx ir">代码格式化</strong>和<strong class="kx ir">林挺</strong>，使得在整个项目代码中遵循相同的<strong class="kx ir">风格指南</strong>成为可能，而不需要任何配置。</p><h2 id="f024" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><a class="ae mk" href="https://eslint.org" rel="noopener ugc nofollow" target="_blank"> ESLint </a></h2><p id="0b92" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">ESLint 是一个<strong class="kx ir">代码林挺</strong>库，它使开发团队能够定义他们的<strong class="kx ir">风格指南</strong>并确保遵循这样的指南。</p><p id="0501" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx ir"> ESLint </strong>中我非常喜欢的一个特性是自动修复，它自动纠正一些简单的规则，比如制表符的空格数、单引号或双引号、语句结尾缺少分号等。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="2bc9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天到此为止。</p><p id="b048" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你呢，你在不同的应用级别使用哪些工具进行<strong class="kx ir">测试自动化</strong>和<strong class="kx ir">静态代码分析</strong>？留下评论。</p><p id="455d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你喜欢你读的东西吗？请在您的社交网络上分享这些内容来帮助我。我会很感激的！</p><p id="0c28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下次再见，祝你考试顺利！✅ 👋</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="e408" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇博文最初是在<strong class="kx ir"> WordPress </strong>上用葡萄牙语发表的，在这里 可以看到<a class="ae mk" href="https://talkingabouttesting.com/2018/10/05/um-review-pessoal-de-ferramentas-para-testes-automatizados-no-mundo-javascript-parte-1/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">。</strong></a></p></div></div>    
</body>
</html>