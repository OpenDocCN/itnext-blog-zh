<html>
<head>
<title>Mastering Wire</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">母带电线</h1>
<blockquote>原文：<a href="https://itnext.io/mastering-wire-f1226717bbac?source=collection_archive---------0-----------------------#2020-01-02">https://itnext.io/mastering-wire-f1226717bbac?source=collection_archive---------0-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/afa483df544aca1b71675a392289052f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ame8NYgkljV12D8XCwTlJg.png"/></div></div></figure><h1 id="f61f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">这是什么？</h1><p id="a084" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><a class="ae lx" href="https://github.com/google/wire" rel="noopener ugc nofollow" target="_blank"> Wire </a>是Golang中的一个轻量级依赖注入工具，由Go Cloud团队开发。它自动生成代码，然后在编译时注入依赖。</p><p id="ccda" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><a class="ae lx" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>是保持软件“松耦合和易于维护”的最重要的设计原则之一。</p><p id="28a0" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这一原则广泛应用于各种开发平台，并且有许多优秀的相关工具。</p><p id="7db4" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在所有这些工具中，最著名的是<a class="ae lx" href="https://spring.io/projects/spring-framework" rel="noopener ugc nofollow" target="_blank"> Spring </a>，Spring作为IOC框架的基础对其今天的主导地位起到了决定性的作用。</p><p id="5f33" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">实际上，软件开发的<a class="ae lx" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank"> S.O.L.I.D </a>原则中的“D”就是特指这个话题。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="ab19" class="kb kc it bd kd ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky bi translated">为什么电线不一样？</h1><p id="1049" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">依赖注入是如此重要，以至于Golang社区中已经有相当多的解决方案，例如来自优步的<a class="ae lx" href="https://github.com/uber-go/dig" rel="noopener ugc nofollow" target="_blank"> dig </a>和来自脸书的<a class="ae lx" href="https://github.com/facebookgo/inject" rel="noopener ugc nofollow" target="_blank"> inject </a>。两者都通过<a class="ae lx" href="https://golang.org/pkg/reflect/" rel="noopener ugc nofollow" target="_blank">反射机制</a>实现运行时依赖注入。</p><p id="918a" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">为什么Go Cloud团队要重新发明轮子？因为在他们看来，上面的库都不符合Go的哲学:</p><blockquote class="mp mq mr"><p id="c31c" class="kz la ms lb b lc ly le lf lg lz li lj mt ma lm ln mu mb lq lr mv mc lu lv lw im bi translated"><a class="ae lx" href="https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=14m35s" rel="noopener ugc nofollow" target="_blank"> <em class="it">清晰胜过巧妙</em> </a> <em class="it">，</em> <a class="ae lx" href="https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=15m22s" rel="noopener ugc nofollow" target="_blank"> <em class="it">反思永远不清晰。</em> </a></p><p id="1d5c" class="kz la ms lb b lc ly le lf lg lz li lj mt ma lm ln mu mb lq lr mv mc lu lv lw im bi translated"><em class="it"> —抢派克</em></p></blockquote><p id="7278" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">Wire作为代码生成工具，可以在编译时生成源代码，实现依赖注入。它不需要反射或<a class="ae lx" href="https://en.wikipedia.org/wiki/Service_locator_pattern" rel="noopener ugc nofollow" target="_blank">服务定位器</a>。后面你会看到，Wire生成的代码和手写的代码没有区别。这种方法带来了一些好处:</p><ol class=""><li id="c074" class="mw mx it lb b lc ly lg lz lk my lo mz ls na lw nb nc nd ne bi translated">易于调试。如果缺少任何依赖项，编译期间将会报告错误</li><li id="38eb" class="mw mx it lb b lc nf lg ng lk nh lo ni ls nj lw nb nc nd ne bi translated">因为不需要服务定位器，所以对命名没有特殊要求</li><li id="f1b7" class="mw mx it lb b lc nf lg ng lk nh lo ni ls nj lw nb nc nd ne bi translated">避免依赖性膨胀。生成的代码将只导入您需要的依赖项，而运行时依赖项注入直到运行时才能识别未使用的依赖项。</li><li id="9996" class="mw mx it lb b lc nf lg ng lk nh lo ni ls nj lw nb nc nd ne bi translated">依赖图静态地存储在源代码中，这使得工具化和可视化更加容易</li></ol><p id="7dcb" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">设计电线的详细权衡可以在<a class="ae lx" href="https://blog.golang.org/wire" rel="noopener ugc nofollow" target="_blank"> Go博客</a>上找到。</p><p id="857f" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">虽然Wire最新发布的版本只是v0.4.0，但已经实现了团队设定的目标，相当成熟。预计未来不会有大的变化。这一点可以从团队的声明中看出:</p><blockquote class="mp mq mr"><p id="cac9" class="kz la ms lb b lc ly le lf lg lz li lj mt ma lm ln mu mb lq lr mv mc lu lv lw im bi translated"><em class="it">对于它被设计用来执行的任务来说，它工作得很好，我们希望它尽可能简单。</em></p><p id="43c8" class="kz la ms lb b lc ly le lf lg lz li lj mt ma lm ln mu mb lq lr mv mc lu lv lw im bi translated"><em class="it">我们目前不会接受新功能，但会很乐意接受错误报告和修复。</em></p><p id="4335" class="kz la ms lb b lc ly le lf lg lz li lj mt ma lm ln mu mb lq lr mv mc lu lv lw im bi translated"><em class="it"> — </em> <a class="ae lx" href="https://github.com/google/wire#project-status" rel="noopener ugc nofollow" target="_blank"> <em class="it">钢丝队</em> </a></p></blockquote><h1 id="65ee" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">入门指南</h1><p id="8492" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">安装电线很容易，只要运行</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="38f1" class="nt kc it np b gy nu nv l nw nx"> <!-- -->go get github.com/google/wire/cmd/wire<!-- --> </span></pre><p id="0677" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">你将在<code class="fe ny nz oa np b">$GOPATH/bin</code>安装<code class="fe ny nz oa np b">wire</code>命令行工具，确保<code class="fe ny nz oa np b">$GOPATH/bin</code>在<code class="fe ny nz oa np b">$PATH</code>中，然后你可以在任何目录下运行<code class="fe ny nz oa np b">wire</code>。</p><p id="3c93" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在继续之前，我们需要解释Wire中的两个核心概念:<strong class="lb iu">提供者</strong>和<strong class="lb iu">注入者</strong>。</p><p id="d450" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu">提供者</strong>:创建组件的普通函数。这些方法将所需的依赖项作为参数，创建一个组件并返回它。</p><p id="ffde" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">组件可以是对象或函数，事实上它可以是任何类型。唯一的限制是:在整个依赖图中，一个类型只能有一个提供者。所以提供者返回<code class="fe ny nz oa np b">int</code>不是一个好主意。在这种情况下，您可以通过定义类型别名来解决它。例如，首先定义<code class="fe ny nz oa np b">type Category int</code>，然后让提供者返回<code class="fe ny nz oa np b">Category</code>类型</p><p id="3da0" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">以下是典型的提供商示例:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="6c55" class="nt kc it np b gy nu nv l nw nx">// DefaultConnectionOpt provide default connection option<br/>func DefaultConnectionOpt()*ConnectionOpt{...}// NewDb provide an Db object<br/>func NewDb(opt *ConnectionOpt)(*Db, error){...}// NewUserLoadFunc provide a function which can load user<br/>func NewUserLoadFunc(db *Db)(func(int) *User, error){...}</span></pre><p id="cc50" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在实践中，一组相关的提供者通常被放在一起并组织成一个提供者集，以便于维护和切换。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="630d" class="nt kc it np b gy nu nv l nw nx">var DbSet = wire.NewSet(DefaultConnectionOpt, NewDb)</span></pre><p id="2550" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu">注入器</strong>:由wire生成的函数，按照依赖顺序调用提供者。</p><p id="6632" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">为了生成注入器，我们在<strong class="lb iu"> wire.go </strong>中定义了注入器函数签名(文件名不是强制的，但一般都是这样)。然后在以provider为参数的函数体中调用<code class="fe ny nz oa np b">wire.Build</code>(不分先后)。</p><p id="a7a6" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">由于<code class="fe ny nz oa np b">wire.go</code>中的函数并不真正返回值，为了避免编译器错误，简单地用<code class="fe ny nz oa np b">panic</code>函数包装它们。不要担心运行时错误，因为它不会实际执行，它只是生成真正代码的提示。一个简单的<code class="fe ny nz oa np b">wire.go</code>例子:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="26fd" class="nt kc it np b gy nu nv l nw nx">// <strong class="np iu"><em class="ms">+build</em></strong> wireinject<br/><br/>package main<br/><br/>import "github.com/google/wire"<br/><br/>func UserLoader()(func(int)*User, error){<br/>   panic(wire.Build(NewUserLoadFunc, DbSet))<br/>}<br/><br/>var DbSet = wire.NewSet(DefaultConnectionOpt, NewDb)</span></pre><p id="f289" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">完成这些代码后，运行命令<code class="fe ny nz oa np b">wire</code>将生成文件<code class="fe ny nz oa np b">wire_gen.go</code>，该文件保存了注射器功能的实际实现。<code class="fe ny nz oa np b">wire.go</code>中的任何非注射器代码将被原样复制到<code class="fe ny nz oa np b">wire_gen.go</code>(虽然技术上允许，但不建议这样做)。生成的代码如下:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="a888" class="nt kc it np b gy nu nv l nw nx">// Code generated by Wire. DO NOT EDIT.<br/><br/>//<strong class="np iu"><em class="ms">go:generate</em></strong> wire<br/>//<strong class="np iu"><em class="ms">+build</em></strong> !wireinject<br/><br/>package main<br/><br/>import (<br/>   "github.com/google/wire"<br/>)<br/><br/>// Injectors from wire.go:<br/><br/>func UserLoader() (func(int) *User, error) {<br/>   connectionOpt := DefaultConnectionOpt()<br/>   db, err := NewDb(connectionOpt)<br/>   if err != nil {<br/>      return nil, err<br/>   }<br/>   v, err := NewUserLoadFunc(db)<br/>   if err != nil {<br/>      return nil, err<br/>   }<br/>   return v, nil<br/>}<br/><br/>// wire.go:<br/><br/>var DbSet = wire.NewSet(DefaultConnectionOpt, NewDb)</span></pre><p id="c48d" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">上述代码中有两个有趣的地方:</p><ol class=""><li id="b606" class="mw mx it lb b lc ly lg lz lk my lo mz ls na lw nb nc nd ne bi translated"><strong class="lb iu"> wire.go </strong>而反观<strong class="lb iu"> wire_gen.go </strong>的第4行<code class="fe ny nz oa np b">// + build! Wireinject</code>。这两组相反的构建标签保证了在任何情况下，只有<strong class="lb iu"> wire.go </strong>和<strong class="lb iu"> wire_gen.go </strong>的一个文件生效，避免了编译错误“函数UserLoader已经定义”</li><li id="abbc" class="mw mx it lb b lc nf lg ng lk nh lo ni ls nj lw nb nc nd ne bi translated">自动生成的函数<code class="fe ny nz oa np b">UserLoader</code>包含错误处理。和手写代码差不多。对于这样一个简单的初始化过程，手写是可以接受的，但是当组件数量达到几十个、几百个甚至更多的时候，自动生成的优势就显现出来了。</li></ol><p id="9c70" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">有两种方式触发“生成”动作:<code class="fe ny nz oa np b">go generate</code>或<code class="fe ny nz oa np b">wire</code>。</p><p id="474e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">前者只有在<strong class="lb iu"> wire_gen.go </strong>已经存在的情况下才有效(因为<strong class="lb iu"> wire_gen.go </strong> <code class="fe ny nz oa np b">// <strong class="lb iu">go: generate</strong> wire</code>的第三行)。</p><p id="e4ab" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">而后者可以在任何时候执行。而后者支持更多的参数来微调生成行为，所以建议总是使用<code class="fe ny nz oa np b">wire</code>命令。</p><p id="d709" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">然后我们可以使用真正的注射器，例如:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="af12" class="nt kc it np b gy nu nv l nw nx">package main<br/><br/>import "log"<br/><br/>func main() {<br/>   fn, err := <strong class="np iu">UserLoader()</strong><br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   user := fn(123)<br/>   ...<br/>}</span></pre><p id="b453" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">如果您不小心忘记了某个提供者，wire将报告特定的错误，以帮助开发人员快速解决问题。例如，我们修改<strong class="lb iu">线。转到</strong>以移除<code class="fe ny nz oa np b">NewDb</code></p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="41d9" class="nt kc it np b gy nu nv l nw nx">// <strong class="np iu"><em class="ms">+build</em></strong> wireinject<br/><br/>package main<br/><br/>import "github.com/google/wire"<br/><br/>func UserLoader()(func(int)*User, error){<br/>   panic(wire.Build(NewUserLoadFunc, DbSet))<br/>}<br/><br/>var DbSet = wire.NewSet(DefaultConnectionOpt) //forgot add Db provider</span></pre><p id="dba7" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">执行<code class="fe ny nz oa np b">wire</code>命令，然后会报告一个明确的错误:“<code class="fe ny nz oa np b">no provider found for * example.Db</code></p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="c571" class="nt kc it np b gy nu nv l nw nx">wire: /usr/example/wire.go:7:1: inject UserLoader: no provider found for *example.Db<br/>      needed by func(int) *example.User in provider "NewUserLoadFunc" (/usr/example/provider.go:24:6)<br/>wire: example: generate failed<br/>wire: at least one generate failure</span></pre><p id="449d" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">同样，如果在<strong class="lb iu"> wire.go </strong>中写入未使用的提供者，也会有明确的错误消息。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="36ba" class="kb kc it bd kd ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky bi translated">高级功能</h1><p id="5e80" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">谈完基本用法后，我们来看看高级功能</p><h2 id="8982" class="nt kc it bd kd ob oc dn kh od oe dp kl lk of og kp lo oh oi kt ls oj ok kx ol bi translated">绑定接口</h2><p id="7ac8" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">有时候我们需要注入一个接口。对此有两种选择:</p><ol class=""><li id="855e" class="mw mx it lb b lc ly lg lz lk my lo mz ls na lw nb nc nd ne bi translated">更直接的方法是在provider中创建一个类，然后返回接口类型。但这不符合<a class="ae lx" href="https://github.com/golang/go/wiki/CodeReviewComments#interfaces" rel="noopener ugc nofollow" target="_blank"> Go最佳实践</a>。不推荐</li><li id="5f49" class="mw mx it lb b lc nf lg ng lk nh lo ni ls nj lw nb nc nd ne bi translated">让提供者返回类，然后在injector中声明一个接口绑定，例如:</li></ol><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="cc43" class="nt kc it np b gy nu nv l nw nx">// FooInf, an interface<br/>// FooClass, an class which implements FooInf <br/>// fooClassProvider, a provider function that provider *FooClassvar </span><span id="f3a9" class="nt kc it np b gy om nv l nw nx">set = wire.NewSet(<br/>    fooClassProvider, <br/><strong class="np iu">    wire.Bind(new(FooInf), new(*FooClass)</strong> // bind class to interface<br/>)</span></pre><h2 id="140c" class="nt kc it bd kd ob oc dn kh od oe dp kl lk of og kp lo oh oi kt ls oj ok kx ol bi translated">结构提供程序</h2><p id="5a52" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">有时我们不需要任何特定的初始化工作，我们只需创建一个struct实例，为指定的字段赋值，然后返回。当有许多领域时，这种工作可能会很乏味。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="ee34" class="nt kc it np b gy nu nv l nw nx">// provider.go<br/>type App struct {<br/>    Foo *Foo<br/>    Bar *Bar<br/>}func DefaultApp(<strong class="np iu">foo *Foo, bar *Bar</strong>)*App{<br/>    return &amp;App{<strong class="np iu">Foo: foo, Bar: bar</strong>}<br/>}<br/>// wire.go<br/>...<br/>wire.Build(provideFoo, provideBar, DefaultApp)<br/>...</span></pre><p id="d270" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在这种情况下，<code class="fe ny nz oa np b">wire.Struct</code>提供了帮助，通过指定字段名称来注入字段:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="c40d" class="nt kc it np b gy nu nv l nw nx">wire.Build(provideFoo, provideBar, <strong class="np iu">wire.Struct(new(App),"Foo","Bar"</strong>)</span></pre><p id="507a" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">如果你想注入所有字段，有一个更简化的方法:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="c0ed" class="nt kc it np b gy nu nv l nw nx">wire.Build(provideFoo, provideBar, <strong class="np iu">wire.Struct(new(App), "*"</strong>)</span></pre><p id="41f0" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">如果要忽略结构中的某些字段，可以修改结构定义:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="5c52" class="nt kc it np b gy nu nv l nw nx">type App struct {<br/>    Foo *Foo<br/>    Bar *Bar<br/>    <strong class="np iu">NoInject int `wire:"-"`</strong><br/>}</span></pre><p id="83cc" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">那么<code class="fe ny nz oa np b">NoInject</code>将被忽略。与常规的提供者相比，<code class="fe ny nz oa np b">wire.Struct</code>提供了额外的灵活性:它可以适应指针和非指针类型，并根据需要自动调整生成的代码。</p><p id="4a37" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">而<code class="fe ny nz oa np b">wire.Struct</code>确实提供了一些便利。但是它要求注入的字段是公共可访问的，这导致struct公开了本来可以隐藏的细节。</p><p id="9001" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">幸运的是，这个问题可以通过上面提到的“绑定接口”来解决。用<code class="fe ny nz oa np b">wire.Struct</code>构造一个对象，将类绑定到接口。至于如何在方便性和封装性之间做出取舍，就看你的具体情况了。</p><h2 id="6593" class="nt kc it bd kd ob oc dn kh od oe dp kl lk of og kp lo oh oi kt ls oj ok kx ol bi translated">绑定值</h2><p id="db29" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">有时，您需要将基本值绑定到一个字段。在这种情况下，可以使用<code class="fe ny nz oa np b">wire.Value</code>:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="07fa" class="nt kc it np b gy nu nv l nw nx">// provider.go<br/>type Foo struct {<br/>    X int<br/>}// wire.go<br/>...<br/>wire.Build(<strong class="np iu">wire.Value</strong>(Foo{X: 42}))<br/>...</span></pre><p id="d6ae" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">对于接口值，使用<code class="fe ny nz oa np b">wire.InterfaceValue</code></p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="c042" class="nt kc it np b gy nu nv l nw nx">wire.Build(<strong class="np iu">wire.InterfaceValue</strong>(new(io.Reader), os.Stdin))</span></pre><h2 id="8225" class="nt kc it bd kd ob oc dn kh od oe dp kl lk of og kp lo oh oi kt ls oj ok kx ol bi translated">使用结构的字段作为提供者</h2><p id="1eb1" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">有时我们需要使用结构的字段作为提供者，例如:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="e665" class="nt kc it np b gy nu nv l nw nx">// provider<br/>func provideBar(foo Foo)*Bar{<br/>    return foo.Bar<br/>}<br/>// injector<br/>...<br/>wire.Build(provideFoo, provideBar)<br/>...</span></pre><p id="6748" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在这种情况下，你可以使用<code class="fe ny nz oa np b">wire.FieldsOf</code>来简化它，避免繁琐的提供者定义:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="88b9" class="nt kc it np b gy nu nv l nw nx">wire.Build(provideFoo, <strong class="np iu">wire.FieldsOf</strong>(new(Foo), “Bar”))</span></pre><p id="b0b4" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">与<code class="fe ny nz oa np b">wire.Struct</code>类似，<code class="fe ny nz oa np b">wire.FieldsOf</code>也自动适应指针/非指针注入请求</p><h2 id="735d" class="nt kc it bd kd ob oc dn kh od oe dp kl lk of og kp lo oh oi kt ls oj ok kx ol bi translated">清理功能</h2><p id="2120" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如前所述，如果provider和injector函数返回错误，Wire会自动处理它们。此外，Wire还有另一个自动处理能力:清理功能。</p><p id="6777" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">所谓的清理函数是指带有签名<code class="fe ny nz oa np b">func()</code>的闭包。它从provider返回，以确保provider中分配的资源可以被清理。</p><p id="3a4f" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">清理功能的典型应用场景是文件资源和网络连接资源管理，例如:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="b543" class="nt kc it np b gy nu nv l nw nx">type App struct {<br/>   File *os.File<br/>   Conn net.Conn<br/>}<br/><br/>func provideFile() (*os.File, <strong class="np iu">func()</strong>, error) {<br/>   f, err := os.Open("foo.txt")<br/>   if err != nil {<br/>      return nil, nil, err<br/>   }<br/>   <strong class="np iu">cleanup</strong> := func() {<br/>      if err := f.Close(); err != nil {<br/>         log.Println(err)<br/>      }<br/>   }<br/>   return f, <strong class="np iu">cleanup</strong>, nil<br/>}<br/><br/>func provideNetConn() (net.Conn, <strong class="np iu">func()</strong>, error) {<br/>   conn, err := net.Dial("tcp", "foo.com:80")<br/>   if err != nil {<br/>      return nil, nil, err<br/>   }<br/>   <strong class="np iu">cleanup</strong> := func() {<br/>      if err := conn.Close(); err != nil {<br/>         log.Println(err)<br/>      }<br/>   }<br/>   return conn, <strong class="np iu">cleanup</strong>, nil<br/>}</span></pre><p id="3283" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">上面的代码定义了两个提供者，分别提供文件资源和网络连接资源。</p><p id="6c3a" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">钢丝.走</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="deeb" class="nt kc it np b gy nu nv l nw nx">// <strong class="np iu"><em class="ms">+build</em></strong> wireinject<br/><br/>package main<br/><br/>import "github.com/google/wire"<br/><br/>func NewApp() (*App, func(), error) {<br/>   panic(wire.Build(<br/>      provideFile,<br/>      provideNetConn,<br/>      wire.Struct(new(App), "*"),<br/>   ))<br/>}</span></pre><p id="8f9c" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">请注意，因为提供程序返回一个清理函数，所以注入器函数也必须返回它，否则将会发生错误</p><p id="5c85" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">wire_gen.go</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="ac3b" class="nt kc it np b gy nu nv l nw nx">// Code generated by Wire. DO NOT EDIT.<br/><br/>//<strong class="np iu"><em class="ms">go:generate</em></strong> wire<br/>//<strong class="np iu"><em class="ms">+build</em></strong> !wireinject<br/><br/>package main<br/><br/>// Injectors from wire.go:<br/><br/>func NewApp() (*App, func(), error) {<br/>   file, cleanup, err := provideFile()<br/>   if err != nil {<br/>      return nil, nil, err<br/>   }<br/>   conn, cleanup2, err := provideNetConn()<br/>   if err != nil {<br/>      <strong class="np iu">cleanup()</strong><br/>      return nil, nil, err<br/>   }<br/>   app := &amp;App{<br/>      File: file,<br/>      Conn: conn,<br/>   }<br/>   return app, func() {<br/>      <strong class="np iu">cleanup2()<br/>      cleanup()</strong><br/>   }, nil<br/>}</span></pre><p id="50e4" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在生成的代码中有两件事值得注意:</p><ol class=""><li id="efe1" class="mw mx it lb b lc ly lg lz lk my lo mz ls na lw nb nc nd ne bi translated"><code class="fe ny nz oa np b">cleanup()</code>在<code class="fe ny nz oa np b">provideNetConn</code>失败时被调用，保证后续的处理错误不会影响之前分配的资源的清理。</li><li id="70dd" class="mw mx it lb b lc nf lg ng lk nh lo ni ls nj lw nb nc nd ne bi translated">最终返回的闭包自动组合<code class="fe ny nz oa np b">cleanup2()</code>和<code class="fe ny nz oa np b">cleanup()</code>。这意味着无论分配多少资源，只要调用进程成功，它们的清理工作都会在一个清理函数中处理。注射器的呼叫者将负责最后的清理工作</li></ol><p id="2e43" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">可想而知，当几十个清理功能组合在一起时，手动处理上述两个问题是非常繁琐且容易出错的。电线的优点再次显示出来。</p><p id="9025" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">然后我们可以使用它:</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="01a2" class="nt kc it np b gy nu nv l nw nx">func main() {<br/>   app, cleanup, err := NewApp()<br/>   if err != nil {<br/>      log.Fatal(err)<br/>   }<br/><strong class="np iu">   defer cleanup()</strong><br/>   ...<br/>}</span></pre><p id="28eb" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">注<code class="fe ny nz oa np b">defer cleanup()</code>，保证所有资源最终回收。</p><h1 id="573e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">摘要</h1><p id="271a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本文中，我们详细介绍了Wire的概念、基本用法和各种高级功能。希望能帮助你掌握这个小巧而强大的工具。</p><p id="a170" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">又及:新年快乐！</p></div></div>    
</body>
</html>