<html>
<head>
<title>Let’s learn how to to build a chat application with Redis, WebSocket and Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们学习如何用Redis、WebSocket和Go构建一个聊天应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/lets-learn-how-to-to-build-a-chat-application-with-redis-websocket-and-go-7995b5c7b5e5?source=collection_archive---------1-----------------------#2020-04-13">https://itnext.io/lets-learn-how-to-to-build-a-chat-application-with-redis-websocket-and-go-7995b5c7b5e5?source=collection_archive---------1-----------------------#2020-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8d7a828a47668b284a2e386ff6235a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFr9d3jhfPirXdrMAJQnrA.png"/></div></div></figure><p id="8c74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b"><a class="ae la" href="https://tools.ietf.org/html/rfc6455" rel="noopener ugc nofollow" target="_blank">WebSocket</a></code>协议提供了一个双向(服务器和客户端都可以交换消息)和全双工(服务器或客户端可以同时发送消息)的通信通道，这使得它适用于实时场景，如聊天应用等。连接的聊天用户(客户端)可以向应用程序(<code class="fe kw kx ky kz b">WebSocket</code>服务器)发送消息，并且可以相互交换消息——类似于点对点设置。</p><p id="220f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博客中，我们将探索如何使用<code class="fe kw kx ky kz b">WebSocket</code>和<code class="fe kw kx ky kz b"><a class="ae la" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank">Go</a></code>构建一个简单的聊天应用程序。这个解决方案也将利用<code class="fe kw kx ky kz b"><a class="ae la" href="http://redis.io/" rel="noopener ugc nofollow" target="_blank">Redis</a></code>(不久将有更多相关内容)。</p><blockquote class="lb lc ld"><p id="1f33" class="jy jz le ka b kb kc kd ke kf kg kh ki lf kk kl km lg ko kp kq lh ks kt ku kv ij bi translated"><em class="iq">后续博客文章(第2部分)将演示如何将该应用程序部署到</em><a class="ae la" href="https://docs.microsoft.com/azure/app-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"><em class="iq">Azure App Service</em></a><em class="iq">，该服务将使用</em> <a class="ae la" href="https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">虚拟网络</em> </a> <em class="iq">集成</em>与Azure Redis缓存进行通信</p></blockquote><p id="3001" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将了解到:</p><ul class=""><li id="3d36" class="li lj iq ka b kb kc kf kg kj lk kn ll kr lm kv ln lo lp lq bi translated">Redis数据结构——这个应用程序使用<code class="fe kw kx ky kz b"><a class="ae la" href="https://redis.io/commands#set" rel="noopener ugc nofollow" target="_blank">SET</a></code>和<code class="fe kw kx ky kz b"><a class="ae la" href="https://redis.io/commands#pubsub" rel="noopener ugc nofollow" target="_blank">PUBSUB</a></code></li><li id="9308" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">使用<code class="fe kw kx ky kz b"><a class="ae la" href="https://github.com/go-redis/redis" rel="noopener ugc nofollow" target="_blank">go-redis</a></code>客户端与Redis交互</li><li id="4d14" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated"><code class="fe kw kx ky kz b"><a class="ae la" href="https://github.com/gorilla/websocket" rel="noopener ugc nofollow" target="_blank">gorilla WebSocket</a></code>库，它提供了WebSocket协议的完整且经过测试的实现</li><li id="fe22" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated"><a class="ae la" href="https://docs.microsoft.com/azure/azure-cache-for-redis/cache-overview?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Cache for Redis </a>这是云中的托管Redis产品</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8ab3" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">为什么是Redis？</h1><p id="4f06" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">让我们考虑一个聊天应用程序。当用户第一次连接时，在应用程序(<code class="fe kw kx ky kz b">WebSocket</code>服务器)中会创建一个相应的<code class="fe kw kx ky kz b">WebSocket</code>连接，它与特定的应用程序实例相关联。这种<code class="fe kw kx ky kz b">WebSocket</code>连接使我们能够在用户之间广播聊天信息。我们可以通过运行多个实例来扩展我们的应用程序(例如，考虑到大量用户)。现在，如果有新用户加入，他们可能会连接到新的实例。因此我们有一个场景，其中不同的用户(因此他们各自的<code class="fe kw kx ky kz b">WebSocket</code>连接)与不同的实例相关联。结果，他们将无法相互交换消息——这是不可接受的，即使对于我们的玩具聊天应用程序也是如此😉</p><p id="3cbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae la" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>是一个通用的键值，支持多种<a class="ae la" href="https://redis.io/commands/" rel="noopener ugc nofollow" target="_blank">丰富的数据结构</a>，如<code class="fe kw kx ky kz b">List</code>、<code class="fe kw kx ky kz b">Set</code>、<code class="fe kw kx ky kz b">Sorted Set</code>、<code class="fe kw kx ky kz b">Hash</code>等。其中一个特性还包括一个<code class="fe kw kx ky kz b">PubSub</code>功能，利用这个功能，发布者可以向Redis通道发送消息，订阅者可以在这些通道上监听消息——两者都是完全独立的，彼此之间是解耦的。这可以用来解决我们的问题。现在，我们可以使用每个聊天应用程序都可以订阅的Redis <code class="fe kw kx ky kz b">channel</code>，而不是仅仅依赖于<code class="fe kw kx ky kz b">WebSocket</code>连接。因此，发送到<code class="fe kw kx ky kz b">WebSocket</code>连接的消息现在可以通过Redis通道传输，以确保所有的应用程序实例(以及相关的聊天用户)都能接收到它们。</p><p id="34f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一节深入研究代码时，我们将对此进行更多的讨论。Github 上有<a class="ae la" href="https://github.com/abhirockzz/chat-redis-websocket-go" rel="noopener ugc nofollow" target="_blank"/></p><blockquote class="lb lc ld"><p id="f149" class="jy jz le ka b kb kc kd ke kf kg kh ki lf kk kl km lg ko kp kq lh ks kt ku kv ij bi translated">请注意，除了普通的<code class="fe kw kx ky kz b">WebSocket</code>，您还可以使用诸如<a class="ae la" href="https://docs.microsoft.com/azure/azure-signalr/signalr-overview?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure SignalR </a>之类的技术，这些技术允许应用程序将内容更新推送到连接的客户端，例如单页面web或移动应用程序。因此，更新客户端时无需轮询服务器或提交新的HTTP更新请求</p></blockquote><p id="6bfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了跟进并将该解决方案部署到Azure，您将需要一个<a class="ae la" href="https://docs.microsoft.com/azure/cosmos-db/create-cosmosdb-resources-portal?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Microsoft Azure </a>帐户。<a class="ae la" href="https://azure.microsoft.com/free/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">还没有的可以免费抢一个</a>！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="b72e" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">聊天应用程序概述</h1><p id="d4fa" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">是时候进行一次快速代码演练了。下面是应用程序结构:</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="801c" class="no me iq kz b gy np nq l nr ns">.<br/>├── Dockerfile<br/>├── chat<br/>│   ├── chat-session.go<br/>│   └── redis.go<br/>├── go.mod<br/>├── go.sum<br/>├── main.go</span></pre><p id="9726" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe kw kx ky kz b">main.go</code>中，我们<a class="ae la" href="https://golang.org/pkg/net/http/#Handle" rel="noopener ugc nofollow" target="_blank">注册我们的</a> <code class="fe kw kx ky kz b"><a class="ae la" href="https://golang.org/pkg/net/http/#Handle" rel="noopener ugc nofollow" target="_blank">WebSocket</a></code> <a class="ae la" href="https://golang.org/pkg/net/http/#Handle" rel="noopener ugc nofollow" target="_blank">处理程序</a>和<a class="ae la" href="https://golang.org/pkg/net/http/#ListenAndServe" rel="noopener ugc nofollow" target="_blank">启动web服务器</a>——所有使用的都是普通的<code class="fe kw kx ky kz b">net/http</code>包</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="c463" class="no me iq kz b gy np nq l nr ns">http.Handle("/chat/", http.HandlerFunc(websocketHandler))<br/>	server := http.Server{Addr: ":" + port, Handler: nil}<br/>	go func() {<br/>		err := server.ListenAndServe()<br/>		if err != nil &amp;&amp; err != http.ErrServerClosed {<br/>			log.Fatal("failed to start server", err)<br/>		}<br/>	}()</span></pre><p id="9c61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">WebSocket</code>处理程序处理聊天用户(只不过是<code class="fe kw kx ky kz b">WebSocket</code>客户)并开始一个新的聊天会话。</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="5a1a" class="no me iq kz b gy np nq l nr ns">func websocketHandler(rw http.ResponseWriter, req *http.Request) {<br/>	user := strings.TrimPrefix(req.URL.Path, "/chat/")</span><span id="894e" class="no me iq kz b gy nt nq l nr ns">	peer, err := upgrader.Upgrade(rw, req, nil)<br/>	if err != nil {<br/>		log.Fatal("websocket conn failed", err)<br/>	}<br/>	chatSession := chat.NewChatSession(user, peer)<br/>	chatSession.Start()<br/>}</span></pre><p id="7588" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<code class="fe kw kx ky kz b">ChatSession</code>(<code class="fe kw kx ky kz b">chat/chat-session.go</code>的一部分)代表一个用户及其对应的<code class="fe kw kx ky kz b">WebSocket</code>连接(在服务器端)</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="4c34" class="no me iq kz b gy np nq l nr ns">type ChatSession struct {<br/>	user string<br/>	peer *websocket.Conn<br/>}</span></pre><p id="55d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个会话开始时，它启动一个<code class="fe kw kx ky kz b">goroutine</code>来接受来自刚刚加入聊天的用户的消息。它通过在一个<code class="fe kw kx ky kz b">for</code>循环中调用<code class="fe kw kx ky kz b"><a class="ae la" href="https://godoc.org/github.com/gorilla/websocket#Conn.ReadMessage" rel="noopener ugc nofollow" target="_blank">ReadMessage()</a></code> <a class="ae la" href="https://godoc.org/github.com/gorilla/websocket#Conn.ReadMessage" rel="noopener ugc nofollow" target="_blank">(从</a> <code class="fe kw kx ky kz b"><a class="ae la" href="https://godoc.org/github.com/gorilla/websocket#Conn.ReadMessage" rel="noopener ugc nofollow" target="_blank">websocket.Conn</a></code> <a class="ae la" href="https://godoc.org/github.com/gorilla/websocket#Conn.ReadMessage" rel="noopener ugc nofollow" target="_blank"> ) </a>来实现。如果用户断开连接(<code class="fe kw kx ky kz b">WebSocket</code>连接关闭)或应用程序关闭(例如，使用<code class="fe kw kx ky kz b">ctrl+c</code>)，此操作将执行<code class="fe kw kx ky kz b">exits</code>。总而言之，每个用户都有一个单独的goroutine来处理聊天消息。</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="3785" class="no me iq kz b gy np nq l nr ns">func (s *ChatSession) Start() {<br/>...<br/>	go func() {<br/>		for {<br/>			_, msg, err := s.peer.ReadMessage()<br/>			if err != nil {<br/>				_, ok := err.(*websocket.CloseError)<br/>				if ok {<br/>					s.disconnect()<br/>				}<br/>				return<br/>			}<br/>			SendToChannel(fmt.Sprintf(chat, s.user, string(msg)))<br/>		}<br/>	}()</span></pre><p id="b7e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦收到来自用户的消息(通过<code class="fe kw kx ky kz b">WebSocket</code>连接)，它就使用<code class="fe kw kx ky kz b">SendToChannel</code>功能广播给其他用户，该功能是<code class="fe kw kx ky kz b">chat/redis.go</code>的一部分。它所做的就是将消息发布到Redis <code class="fe kw kx ky kz b">pubsub</code>通道</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="652b" class="no me iq kz b gy np nq l nr ns">func SendToChannel(msg string) {<br/>	err := client.Publish(channel, msg).Err()<br/>	if err != nil {<br/>		log.Println("could not publish to channel", err)<br/>	}<br/>}</span></pre><p id="6524" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的部分是等式中的<code class="fe kw kx ky kz b">sub</code>(订户)部分。与每个连接的聊天用户都有一个专用goroutine的情况相反，我们使用一个<code class="fe kw kx ky kz b">single</code> goroutine(在应用程序范围内)来订阅Redis通道，接收消息并将其广播给使用各自服务器端<code class="fe kw kx ky kz b">WebSocket</code>连接的<em class="le">所有</em>用户。</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="d31e" class="no me iq kz b gy np nq l nr ns">func startSubscriber() {<br/>	go func() {<br/>		sub = client.Subscribe(channel)<br/>		messages := sub.Channel()<br/>		for message := range messages {<br/>			from := strings.Split(message.Payload, ":")[0]<br/>			for user, peer := range Peers {<br/>				if from != user {<br/>					peer.WriteMessage(websocket.TextMessage, []byte(message.Payload))<br/>				}<br/>			}<br/>		}<br/>	}()<br/>}</span></pre><blockquote class="lb lc ld"><p id="80e1" class="jy jz le ka b kb kc kd ke kf kg kh ki lf kk kl km lg ko kp kq lh ks kt ku kv ij bi translated"><em class="iq">当应用实例关闭时，订阅结束——这又终止了通道</em> <code class="fe kw kx ky kz b"><em class="iq">for-range</em></code> <em class="iq">循环，并且goroutine退出</em></p></blockquote><p id="198e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从<code class="fe kw kx ky kz b">redis.go</code>中的<code class="fe kw kx ky kz b">init()</code>函数调用<code class="fe kw kx ky kz b">startSubscriber</code>函数。<code class="fe kw kx ky kz b">init()</code>功能从连接Redis开始，如果连接失败，应用程序退出。</p><p id="f50f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧！是时候设置一个Redis实例了，我们可以将聊天后端连接到这个实例。让我们在云端创建一个Redis服务器！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="89a0" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">Azure Redis缓存设置</h1><p id="e213" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">Azure Cache for Redis提供对托管在Azure中的安全专用Redis缓存的访问，Azure内外的任何应用程序都可以访问该缓存。</p><p id="66bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于这篇博客的目的，我们将设置一个带有<code class="fe kw kx ky kz b">Basic</code>层的Azure Redis缓存，这是一个非常适合开发/测试和非关键工作负载的单节点缓存。请注意，您还可以从<code class="fe kw kx ky kz b">Standard</code>和<code class="fe kw kx ky kz b">Premium</code>层中选择<a class="ae la" href="https://docs.microsoft.com/azure/azure-cache-for-redis/cache-overview?WT.mc_id=medium-blog-abhishgu#feature-comparison" rel="noopener ugc nofollow" target="_blank">提供不同的特性，包括持久性、集群、地理复制等</a>。</p><p id="0928" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用<a class="ae la" href="https://docs.microsoft.com/cli/azure/install-azure-cli?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure CLI </a>进行安装。如果你是浏览器人也可以用<a class="ae la" href="https://docs.microsoft.com/azure/cloud-shell/overview?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure云壳</a>！</p><p id="aeda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了快速设置Azure Redis缓存实例，我们可以使用<code class="fe kw kx ky kz b"><a class="ae la" href="https://docs.microsoft.com/cli/azure/redis?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu#az-redis-create" rel="noopener ugc nofollow" target="_blank">az redis create</a></code>命令，例如</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="a91a" class="no me iq kz b gy np nq l nr ns">az redis create --location westus2 --name chat-redis --resource-group chat-app-group --sku Basic --vm-size c0</span></pre><blockquote class="lb lc ld"><p id="2dd0" class="jy jz le ka b kb kc kd ke kf kg kh ki lf kk kl km lg ko kp kq lh ks kt ku kv ij bi translated"><em class="iq"> Checkout </em> <a class="ae la" href="https://docs.microsoft.com/azure/azure-cache-for-redis/scripts/create-cache?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">“为Redis创建Azure缓存”</em> </a> <em class="iq">获取分步指南</em></p></blockquote><p id="5c0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，您需要获取连接到Azure Redis缓存实例所需的信息，即主机、端口和访问密钥。这也可以使用CLI来完成，例如</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="b942" class="no me iq kz b gy np nq l nr ns">//host and (SSL) port<br/>az redis show --name chat-redis --resource-group chat-app-group --query [hostName,sslPort] --output tsv</span><span id="6f8d" class="no me iq kz b gy nt nq l nr ns">//primary access key<br/>az redis list-keys --name chat-redis --resource-group chat-app-group --query [primaryKey] --output tsv</span></pre><blockquote class="lb lc ld"><p id="d5d0" class="jy jz le ka b kb kc kd ke kf kg kh ki lf kk kl km lg ko kp kq lh ks kt ku kv ij bi translated"><em class="iq"> Checkout </em> <a class="ae la" href="https://docs.microsoft.com/azure/azure-cache-for-redis/scripts/cache-keys-ports?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">“获取Redis的Azure缓存的主机名、端口和密钥”</em> </a> <em class="iq">获取分步指南</em></p></blockquote><p id="294e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样…</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="704d" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">….我们聊天吧！</h1><p id="e4f7" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">为了简单起见，该应用程序以<a class="ae la" href="https://hub.docker.com/r/abhirockzz/redis-chat-go" rel="noopener ugc nofollow" target="_blank"> Docker图像</a>的形式提供</p><p id="62d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，设置几个环境变量:</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="fbf5" class="no me iq kz b gy np nq l nr ns">//use port 6380 for SSL<br/>export REDIS_HOST=[redis cache host name as obtained from CLI]:6380<br/>export REDIS_PASSWORD=[redis cache primary access key as obtained from CLI]<br/>export EXT_PORT=9090<br/>export NAME=chat1</span></pre><blockquote class="lb lc ld"><p id="4ed2" class="jy jz le ka b kb kc kd ke kf kg kh ki lf kk kl km lg ko kp kq lh ks kt ku kv ij bi translated"><em class="iq">应用程序在内部使用静态端口</em> <code class="fe kw kx ky kz b"><em class="iq">8080</em></code> <em class="iq">(用于web服务器)。我们使用一个由</em> <code class="fe kw kx ky kz b"><em class="iq">EXT_PORT</em></code> <em class="iq">指定的外部端口，并将其映射到我们容器内部的端口</em> <code class="fe kw kx ky kz b"><em class="iq">8080</em></code> <em class="iq">(使用</em> <code class="fe kw kx ky kz b"><em class="iq">-p $EXT_PORT:8080</em></code> <em class="iq"> ) </em></p></blockquote><p id="f450" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">启动Docker容器</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="7c80" class="no me iq kz b gy np nq l nr ns">docker run --name $NAME -e REDIS_HOST=$REDIS_HOST -e REDIS_PASSWORD=$REDIS_PASSWORD -p $EXT_PORT:8080 abhirockzz/redis-chat-go</span></pre><p id="44f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是时候加入聊天了！您可以使用任何WebSocket客户端。我更喜欢在终端中使用<code class="fe kw kx ky kz b"><a class="ae la" href="https://www.npmjs.com/package/wscat" rel="noopener ugc nofollow" target="_blank">wscat</a></code>或者在浏览器中使用<a class="ae la" href="https://chrome.google.com/webstore/detail/simple-websocket-client/pfdhoblngboilpfeibdedpjgfnlcodoo?hl=en" rel="noopener ugc nofollow" target="_blank"> Chrome WebSocket扩展</a></p><p id="19af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将在我的终端上使用<code class="fe kw kx ky kz b">wscat</code>来演示这一点。打开两个独立的终端来模拟不同的用户:</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="00a6" class="no me iq kz b gy np nq l nr ns">//terminal 1 (user "foo")<br/>wscat -c ws://localhost:9090/chat/foo</span><span id="5809" class="no me iq kz b gy nt nq l nr ns">//terminal 2 (user "bar")<br/>wscat -c ws://localhost:9090/chat/bar</span></pre><p id="1ab3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个<code class="fe kw kx ky kz b">foo</code>和<code class="fe kw kx ky kz b">bar</code>聊天的例子</p><p id="5327" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">foo</code>先加入并得到<code class="fe kw kx ky kz b">Welcome foo!</code>消息，<code class="fe kw kx ky kz b">foo</code>后加入的<code class="fe kw kx ky kz b">bar</code>也是如此。请注意，<code class="fe kw kx ky kz b">foo</code>被告知<code class="fe kw kx ky kz b">bar</code>已经加入。<code class="fe kw kx ky kz b">foo</code>和<code class="fe kw kx ky kz b">bar</code>在<code class="fe kw kx ky kz b">bar</code>离开之前交换了一些信息(<code class="fe kw kx ky kz b">foo</code>也收到了通知)。</p><p id="b5cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为练习，您可以启动聊天应用程序的另一个实例。为<code class="fe kw kx ky kz b">EXT_PORT</code>旋转另一个具有不同值的Docker容器，并命名为，例如</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="7be3" class="no me iq kz b gy np nq l nr ns">//use port 6380 for SSL<br/>export REDIS_HOST=[redis cache host name as obtained from CLI]:6380<br/>export REDIS_PASSWORD=[redis cache primary access key as obtained from CLI]<br/>export EXT_PORT=9091<br/>export NAME=chat2</span><span id="c8b6" class="no me iq kz b gy nt nq l nr ns">docker run --name $NAME -e REDIS_HOST=$REDIS_HOST -e REDIS_PASSWORD=$REDIS_PASSWORD -p $EXT_PORT:8080 abhirockzz/redis-chat-go</span></pre><p id="a1a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在连接端口<code class="fe kw kx ky kz b">9091</code>(或者您选择的端口)来模拟另一个用户</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="37fa" class="no me iq kz b gy np nq l nr ns">//user "pi"<br/>wscat -c ws://localhost:9091/chat/pi</span></pre><p id="3031" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe kw kx ky kz b">foo</code>仍然处于活动状态，它将得到通知，pi和foo可以相互寒暄</p><h2 id="5ec5" class="no me iq bd mf nu nv dn mj nw nx dp mn kj ny nz mr kn oa ob mv kr oc od mz oe bi translated">检查Redis</h2><p id="5b65" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">让我们通过查看Redis数据结构来确认一下。为此，您可以使用<code class="fe kw kx ky kz b"><a class="ae la" href="https://redis.io/topics/rediscli" rel="noopener ugc nofollow" target="_blank">redis-cli</a></code>。如果你正在使用Azure Redis缓存，我会推荐你使用一个非常方便的基于web的Redis控制台。</p><p id="d4d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个<code class="fe kw kx ky kz b">SET</code>(名称<code class="fe kw kx ky kz b">chat-users</code>)来存储活跃用户</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="9791" class="no me iq kz b gy np nq l nr ns">SMEMBERS chat-users</span></pre><p id="f95f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会看到结果——这意味着用户<code class="fe kw kx ky kz b">foo</code>和<code class="fe kw kx ky kz b">bar</code>当前连接到聊天应用程序，并且有一个相关的活动<code class="fe kw kx ky kz b">WebSocket</code>连接</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="7d4a" class="no me iq kz b gy np nq l nr ns">1) "foo"<br/>2) "bar"</span></pre><p id="fe87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">PubSub</code>频道呢？</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="de99" class="no me iq kz b gy np nq l nr ns">PUBUSB CHANNELS</span></pre><p id="c67e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为所有用户都使用一个通道，所以您应该从Redis服务器获得以下结果:</p><pre class="ng nh ni nj gt nk kz nl nm aw nn bi"><span id="be48" class="no me iq kz b gy np nq l nr ns">1) "chat"</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="9d20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇博文到此为止。请继续关注第2部分！</p><p id="0e9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你觉得这很有用，请不要忘记喜欢和关注🙌我很想得到你的反馈:只需在这里留言或在推特上联系🙏🏻</p></div></div>    
</body>
</html>