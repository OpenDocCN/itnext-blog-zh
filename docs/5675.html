<html>
<head>
<title>Adventures with Nexus in Kubernetes: database corruption and storage management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中的Nexus冒险:数据库损坏和存储管理</h1>
<blockquote>原文：<a href="https://itnext.io/adventures-with-nexus-in-kubernetes-database-corruption-and-storage-management-c5c5118b5e86?source=collection_archive---------0-----------------------#2021-04-30">https://itnext.io/adventures-with-nexus-in-kubernetes-database-corruption-and-storage-management-c5c5118b5e86?source=collection_archive---------0-----------------------#2021-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/d25a607dab7c5a666bca09f38b17d7de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*O9PeLUoxTcXuA_5AjklhYQ.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">望远镜储气罐第430号，帕斯卡铁厂，莫里斯，塔斯克公司的插图目录，第四版，1861年</figcaption></figure><p id="42de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">孩子们，当他们在Kubernetes教你们不要运行数据库时，请注意！我希望在Kubernetes中推出一个<a class="ae kz" href="https://www.sonatype.com/products/repository-oss" rel="noopener ugc nofollow" target="_blank"> Sonatype Nexus </a>工件库之前，我遵循了这个建议。以下是我在维护这个安装、处理磁盘空间问题和数据库损坏问题时学到的一些经验。</p><p id="1002" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用来自<a class="ae kz" href="https://artifacthub.io/packages/helm/sonatype/nexus-repository-manager/" rel="noopener ugc nofollow" target="_blank"> artifacthub.io </a>的nexus-repository-manager Helm图表在Kubernetes 1.18 <a class="ae kz" href="https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid-Integrated-Edition/index.html" rel="noopener ugc nofollow" target="_blank"> TKGI </a>集群中安装了Nexus。我为该图表的<code class="fe la lb lc ld b">values.yaml</code>中的<code class="fe la lb lc ld b">persistence</code>部分使用的初始值是:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="2357" class="lm ln it ld b gy lo lp l lq lr">persistence:<br/>  enabled: true<br/>  accessMode: ReadWriteOnce<br/>  storageSize: 100Gi</span></pre><p id="47c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我安装图表时，我使用的是helm版本2。我将图表命名为<code class="fe la lb lc ld b">nexus</code>，并将其安装在<code class="fe la lb lc ld b">default</code>名称空间中。</p><p id="ae4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">舵图创建了一个名为<code class="fe la lb lc ld b">nexus-nexus-repository-manager-data</code>的PVC，由nexus pod安装为<code class="fe la lb lc ld b">/nexus-data</code>。可以通过运行以下命令来检查PVC:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="a9e7" class="lm ln it ld b gy lo lp l lq lr">$ kubectl describe pvc nexus-nexus-repository-manager-data<br/>Name:          nexus-nexus-repository-manager-data<br/>Namespace:     default<br/>StorageClass:  standard<br/>Status:        Bound<br/>Volume:        pvc-ef01fc8d-e6e7-4888-a880-2a3c43314ff2<br/>Labels:        app.kubernetes.io/instance=nexus<br/>               app.kubernetes.io/managed-by=Tiller<br/>               app.kubernetes.io/name=nexus-repository-manager<br/>               app.kubernetes.io/version=3.22.1<br/>               helm.sh/chart=nexus-repository-manager-21.2.0<br/>Annotations:   pv.kubernetes.io/bind-completed: yes<br/>               pv.kubernetes.io/bound-by-controller: yes<br/>               volume.beta.kubernetes.io/storage-provisioner: kubernetes.io/aws-ebs<br/>               volume.kubernetes.io/selected-node: ip-10-1-1-11.us-west-1.compute.internal<br/>               volume.kubernetes.io/storage-resizer: kubernetes.io/aws-ebs<br/>Finalizers:    [kubernetes.io/pvc-protection]<br/>Capacity:      100Gi<br/>Access Modes:  RWO<br/>VolumeMode:    Filesystem<br/>Mounted By:    nexus-nexus-repository-manager-7cdc447985-fvfvc<br/>Events:        &lt;none&gt;</span></pre><p id="ceb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意<code class="fe la lb lc ld b">StorageClass</code>是<code class="fe la lb lc ld b">standard</code>。Kubernetes集群在AWS中运行，而<code class="fe la lb lc ld b">standard</code>存储类正在使用<code class="fe la lb lc ld b">aws-ebs</code> provisioner:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="48c7" class="lm ln it ld b gy lo lp l lq lr">$ kubectl describe storageclass standard <br/>Name:            standard<br/>IsDefaultClass:  Yes<br/>Annotations:     kubectl.kubernetes.io/last-applied-configuration={"allowVolumeExpansion":true,"apiVersion":"storage.k8s.io/v1","kind":"StorageClass","metadata":{"annotations":{"storageclass.kubernetes.io/is-default-class":"true"},"name":"standard"},"mountOptions":["debug"],"parameters":{"fsType":"ext4","type":"gp2"},"provisioner":"kubernetes.io/aws-ebs","reclaimPolicy":"Delete","volumeBindingMode":"WaitForFirstConsumer"}<br/>,storageclass.kubernetes.io/is-default-class=true<br/>Provisioner:           kubernetes.io/aws-ebs<br/>Parameters:            fsType=ext4,type=gp2<br/>AllowVolumeExpansion:  True<br/>MountOptions:<br/>  debug<br/>ReclaimPolicy:      Delete<br/>VolumeBindingMode:  WaitForFirstConsumer<br/>Events:             &lt;none&gt;</span></pre><p id="556c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，PVC将利用作为AWS EBS卷分配的PV。PV ID列在<code class="fe la lb lc ld b">kubectl describe pvc</code>输出的<code class="fe la lb lc ld b">Volume</code>行，可用于描述PV:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="2128" class="lm ln it ld b gy lo lp l lq lr">$ kubectl describe pv pvc-ef01fc8d-e6e7-4888-a880-2a3c43314ff2<br/>Name:              pvc-ef01fc8d-e6e7-4888-a880-2a3c43314ff2<br/>Labels:            failure-domain.beta.kubernetes.io/region=us-west-1<br/>                   failure-domain.beta.kubernetes.io/zone=us-west-1b<br/>Annotations:       kubernetes.io/createdby: aws-ebs-dynamic-provisioner<br/>                   pv.kubernetes.io/bound-by-controller: yes<br/>                   pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs<br/>Finalizers:        [kubernetes.io/pv-protection]<br/>StorageClass:      standard<br/>Status:            Bound<br/>Claim:             default/nexus-nexus-repository-manager-data<br/>Reclaim Policy:    Delete<br/>Access Modes:      RWO<br/>VolumeMode:        Filesystem<br/>Capacity:          100Gi<br/>Node Affinity:     <br/>  Required Terms:  <br/>    Term 0:        failure-domain.beta.kubernetes.io/zone in [us-west-1b]<br/>                   failure-domain.beta.kubernetes.io/region in [us-west-1]<br/>Message:           <br/>Source:<br/>    Type:       AWSElasticBlockStore (a Persistent Disk resource in AWS)<br/>    VolumeID:   aws://us-west-1b/vol-0f37482912777724e<br/>    FSType:     ext4<br/>    Partition:  0<br/>    ReadOnly:   false<br/>Events:         &lt;none&gt;</span></pre><p id="3a57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，按照线索PVC -&gt; PV -&gt; AWS EBS，我们可以看到用于存储Nexus数据的确切EBS卷ID:<code class="fe la lb lc ld b">vol-0f37482912777724e</code>。</p><p id="d2e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Nexus空间用完了怎么办？一种快速解决方法是编辑PVC对象并更改容量。您可以使用如下命令:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="6386" class="lm ln it ld b gy lo lp l lq lr">kubectl edit pvc nexus-nexus-repository-manager-data</span></pre><p id="a58d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubernetes存储类的魔力将会影响EBS和正在使用它的文件系统的大小。如果增加了一个连接到Linux EC2实例的EBS卷，就不需要运行<code class="fe la lb lc ld b">resize2fs</code>或其他类似的命令。</p><p id="6812" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的一个问题是，PVC不会调整卷的大小，除非您重新启动装载它的pod。在这种情况下，我需要删除nexus pod并等待新的pod启动。这个过程可能需要一段时间，因为pod需要装入PVC指定的卷。我见过很多这样的情况，当我在nexus pod上运行<code class="fe la lb lc ld b">kubectl describe pod</code>时，挂载操作失败，并显示如下形式的消息</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="2572" class="lm ln it ld b gy lo lp l lq lr">Warning FailedMount 79s    kubelet, ip-10-1-1-11.us-west-1.compute.internal Unable to attach or mount volumes: unmounted volumes=[nexus-nexus-repository-manager-data], unattached volumes=[nexus-nexus-repository-manager-backup default-token-2m7b6 nexus-nexus-repository-manager-data]: timed out waiting for the condition</span></pre><p id="627a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据底层EBS卷的大小，这个操作最终会在N分钟后成功(对我来说，N是10到20之间的任意值)。</p><p id="fa5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在重新启动nexus pod时看到的另一个错误情况是，Kubernetes调度程序试图在Kubernetes节点上调度新的pod，该节点与EBS卷位于不同的可用性区域。在这种情况下，错误消息的形式如下</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="b627" class="lm ln it ld b gy lo lp l lq lr">Volume is already exclusively attached to one node and can't be attached to another</span></pre><p id="a715" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我找到的解决这个问题的唯一方法是反复删除pod(可能带有<code class="fe la lb lc ld b">--force</code>标志),直到新的pod被安排在适当AZ中的一个节点上。</p><p id="5b61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在最近的一个案例中，为<code class="fe la lb lc ld b">/nexus-data</code>调整卷的大小导致了本地<a class="ae kz" href="https://www.orientdb.org/docs/3.0.x/" rel="noopener ugc nofollow" target="_blank"> OrientDB </a>数据库(包括win Nexus)中的数据库损坏(在遇到这个问题之前，我根本不知道Nexus正在使用OrientDB……)。</p><p id="0054" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们注意到将工件推送到Nexus会导致HTTP 500错误。当我查看nexus pod的日志时，我看到了以下类型的错误:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="1cc4" class="lm ln it ld b gy lo lp l lq lr">Caused by: com.orientechnologies.orient.core.storage.impl.local.paginated.atomicoperations.ONestedRollbackException: Atomic operation was rolled back by internal component, exception which caused this rollback is :<br/>com.orientechnologies.orient.core.exception.OPaginatedClusterException: Error during record creation<br/>	DB name="component"<br/>	Component Name="asset"</span></pre><p id="9760" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速的谷歌搜索揭示了这个<a class="ae kz" href="https://stackoverflow.com/questions/42951710/orientdb-corruption-state-in-nexus-repository-version-3-2-0-01" rel="noopener ugc nofollow" target="_blank">堆栈溢出帖子</a>。其中一个问题是如何停止Nexus以便修复数据库，特别是当Nexus在Kubernetes中作为pod运行时？我发现的一个解决方案如下:</p><ul class=""><li id="0730" class="ls lt it kd b ke kf ki kj km lu kq lv ku lw ky lx ly lz ma bi translated">将当前的nexus部署保存到yaml文件中:</li></ul><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="c3d2" class="lm ln it ld b gy lo lp l lq lr">$ kubectl get deployment nexus-nexus-repository-manager -o yaml &gt; nexus-nexus-repository-manager-deployment.yaml</span></pre><ul class=""><li id="df98" class="ls lt it kd b ke kf ki kj km lu kq lv ku lw ky lx ly lz ma bi translated">将<code class="fe la lb lc ld b">spec</code>部分的<code class="fe la lb lc ld b">replicas</code>值修改为<code class="fe la lb lc ld b">0</code></li><li id="df0c" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">应用新清单，这将终止正在运行的nexus pod，并且不会启动新的pod:</li></ul><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="240a" class="lm ln it ld b gy lo lp l lq lr">$ kubectl apply -f nexus-nexus-repository-manager-deployment.yaml</span></pre><ul class=""><li id="8c5c" class="ls lt it kd b ke kf ki kj km lu kq lv ku lw ky lx ly lz ma bi translated">将上面的yaml清单复制为<code class="fe la lb lc ld b">nexus-nexus-repository-manager-deployment-bash.yaml</code>，将<code class="fe la lb lc ld b">metadata</code>下的<code class="fe la lb lc ld b">deployment</code>对象的名称更改为<code class="fe la lb lc ld b">nexus-nexus-repository-manager-bash</code>，并在<code class="fe la lb lc ld b">nexus-repository-manager</code>容器中添加一个<code class="fe la lb lc ld b">command</code>:</li></ul><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="129f" class="lm ln it ld b gy lo lp l lq lr">command: ["sh", "-c", "tail -f /dev/null"]</span></pre><ul class=""><li id="0e1a" class="ls lt it kd b ke kf ki kj km lu kq lv ku lw ky lx ly lz ma bi translated">应用新的清单，这将启动一个与原始nexus pod具有完全相同的环境(容器映像、配置映射、机密、卷)的新pod，但是运行命令<code class="fe la lb lc ld b">tail -f /dev/null</code>而不是常规的nexus进程:</li></ul><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="7f6f" class="lm ln it ld b gy lo lp l lq lr">$ kubectl apply -f nexus-nexus-repository-manager-deployment-bash.yaml</span></pre><p id="d3bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，您可以<code class="fe la lb lc ld b">kubectl exec</code>进入新的pod并在bash提示符下运行各种命令:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="e025" class="lm ln it ld b gy lo lp l lq lr">$ kubectl exec -it nexus-nexus-repository-manager-bash-6d6bb4776f-hcljk -- bash</span></pre><p id="480b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据上面SO帖子中的一个答案，我跑了:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="8428" class="lm ln it ld b gy lo lp l lq lr">bash-4.4$ cd /tmp<br/>bash-4.4$ java -jar /opt/sonatype/nexus/lib/support/nexus-orient-console.jar</span><span id="2268" class="lm ln it ld b gy mg lp l lq lr">OrientDB console v.2.2.36 (build d3beb772c02098ceaea89779a7afd4b7305d3788, branch 2.2.x) <a class="ae kz" href="https://www.orientdb.com" rel="noopener ugc nofollow" target="_blank">https://www.orientdb.com</a><br/>Type 'help' to display all the supported commands.<br/><br/>orientdb&gt; CONNECT plocal:/nexus-data/db/component admin admin</span></pre><p id="0553" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我试图重建索引时，我得到了一个<code class="fe la lb lc ld b">NullPointerException</code>:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="8954" class="lm ln it ld b gy lo lp l lq lr">orientdb {db=component}&gt; REBUILD INDEX *</span><span id="e61c" class="lm ln it ld b gy mg lp l lq lr">Rebuilding index(es)...<br/>2021-04-27 15:36:34:555 WARNI {db=component} Error deserializing record with id #37:11005 send this data for debugging: ABZicm93c2Vfbm9kZTcAAAAsPQAAADxZAAAAQ8cWAAABAAAAAP1fAAABLgAeQVRMQVMtc25hcHNob3RzDG1hdmVuMswBYXRsYXMvb3JiaXRhbC1jcnVkL29yYml0YWwtY3J1ZC1wYXJlbnQvMSetcetcetcyMDA3MTUuMjMyNjE3LTEzL2BvcmJpdGFsLWNydWQtcGFyZW50LTEuMC4wLTIwMjAwNzE1LjIzMjYxNy0xMy5wb21CioEB  [ORecordSerializerBinary]$ANSI{green {db=component}} Error during index rebuild<br/>java.lang.NullPointerException<br/> at com.orientechnologies.orient.core.serialization.serializer.record.binary.ORecordSerializerBinaryV0.deserializePartial(ORecordSerializerBinaryV0.java:122)<br/> at<br/>...etc...etc<br/>com.orientechnologies.orient.core.index.OIndexAbstract.indexCluster(OIndexAbstract.java:1036)<br/> at com.orientechnologies.orient.core.index.OIndexAbstract.fillIndex(OIndexAbstract.java:539)<br/> at com.orientechnologies.orient.core.index.OIndexAbstract.rebuild(OIndexAbstract.java:500)<br/> ... 18 more</span><span id="ffa5" class="lm ln it ld b gy mg lp l lq lr">Error: com.orientechnologies.orient.core.index.OIndexException: Error on rebuilding the index for clusters: [browse_node, browse_node_2, browse_node_3, browse_node_1]<br/> DB name="component"</span><span id="f5fe" class="lm ln it ld b gy mg lp l lq lr">Error: java.lang.NullPointerException</span></pre><p id="bca3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">进一步的谷歌搜索没有发现任何有用的信息。状态:死在水里。幸运的是，我们每天都在Kubernetes集群中运行<a class="ae kz" href="https://github.com/vmware-tanzu/velero" rel="noopener ugc nofollow" target="_blank"> Velero </a>，备份所有名称空间中的所有Kubernetes对象，并将备份保存30天:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="e433" class="lm ln it ld b gy lo lp l lq lr">$ velero describe schedule<br/>Name:         dailybackup<br/>Namespace:    velero<br/>Labels:       &lt;none&gt;<br/>Annotations:  &lt;none&gt;</span><span id="0612" class="lm ln it ld b gy mg lp l lq lr">Phase:  Enabled</span><span id="84cd" class="lm ln it ld b gy mg lp l lq lr">Schedule:  0 0 * * *</span><span id="c2c4" class="lm ln it ld b gy mg lp l lq lr">Backup Template:<br/>  Namespaces:<br/>    Included:  *<br/>    Excluded:  &lt;none&gt;<br/>  <br/>  Resources:<br/>    Included:        *<br/>    Excluded:        &lt;none&gt;<br/>    Cluster-scoped:  auto<br/>  <br/>  Label selector:  &lt;none&gt;<br/>  <br/>  Storage Location:  <br/>  <br/>  Snapshot PVs:  auto<br/>  <br/>  TTL:  720h0m0s<br/>  <br/>  Hooks:  &lt;none&gt;</span><span id="f038" class="lm ln it ld b gy mg lp l lq lr">Last Backup:  2021-04-27 17:00:29 -0700 PDT</span></pre><p id="7e34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于AWS中的PV，Velero将为PV对象下的所有EBS卷创建EBS快照。</p><p id="fb2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，我可以尝试直接从Velero备份中恢复，但我更喜欢手动检索Nexus PV的EBS快照，这样我就可以更多地尝试从EBS卷手动创建PV和PVC，以应对我可能没有启动和运行Velero的其他情况。</p><p id="f4cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我用EBS快照为nexus pod装载的PV创建了一个常规EBS卷。我确保新的EBS卷与nexus PV使用的原始EBS卷创建在同一个可用性区域中。我记下了新的卷ID (vol-007a71c14f3571a43)。</p><p id="864c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我以YAML格式保存了nexus现有PV和PVC的清单:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="e9ff" class="lm ln it ld b gy lo lp l lq lr">$ kubectl get pv pvc-ef01fc8d-e6e7-4888-a880-2a3c43314ff2 -o yaml &gt; pv.yaml<br/>$ kubectl get pvc pvc-ef01fc8d-e6e7-4888-a880-2a3c43314ff2 -o yaml &gt; pvc.yaml</span></pre><p id="cc69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我复制了名为<code class="fe la lb lc ld b">pv-from-snapshot.yaml</code>和<code class="fe la lb lc ld b">pvc-from-snapshot.yaml</code>的YAML清单，并更改了卷ID和<code class="fe la lb lc ld b">pv-from-snapshot.yaml</code>中PV的名称，以引用从快照创建的新EBS卷的卷ID:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="9e86" class="lm ln it ld b gy lo lp l lq lr">$ cat pv-from-snapshot.yaml<br/>apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>  annotations:<br/>    kubernetes.io/createdby: aws-ebs-dynamic-provisioner<br/>    pv.kubernetes.io/bound-by-controller: "yes"<br/>    pv.kubernetes.io/provisioned-by: kubernetes.io/aws-ebs<br/>  labels:<br/>    failure-domain.beta.kubernetes.io/region: us-west-1<br/>    failure-domain.beta.kubernetes.io/zone: us-west-1b<br/>  name: pv-<!-- -->007a71c14f3571a43<br/>spec:<br/>  accessModes:<br/>  - ReadWriteOnce<br/>  awsElasticBlockStore:<br/>    fsType: ext4<br/>    volumeID: aws://us-west-1b/vol-007a71c14f3571a43<br/>  capacity:<br/>    storage: 100Gi<br/>  mountOptions:<br/>  - debug<br/>  nodeAffinity:<br/>    required:<br/>      nodeSelectorTerms:<br/>      - matchExpressions:<br/>        - key: failure-domain.beta.kubernetes.io/zone<br/>          operator: In<br/>          values:<br/>          - us-west-1b<br/>        - key: failure-domain.beta.kubernetes.io/region<br/>          operator: In<br/>          values:<br/>          - us-west-1<br/>  persistentVolumeReclaimPolicy: Delete<br/>  storageClassName: standard<br/>  volumeMode: Filesystem</span></pre><p id="3c49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当使用<code class="fe la lb lc ld b">kubectl apply</code>时，这个清单将创建一个名为<code class="fe la lb lc ld b">pv-007a71c14f3571a43</code>的新PV，它使用新的EBS卷作为底层存储。</p><p id="1e07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我修改了PVC清单<code class="fe la lb lc ld b">pvc-from-snapshot.yaml</code>以引用新的PV，还将PVC对象的名称改为<code class="fe la lb lc ld b">nexus-nexus-repository-manager-data-from-snapshot</code>:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="a88c" class="lm ln it ld b gy lo lp l lq lr">$ cat pvc-from-snapshot.yaml<br/>apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  annotations:<br/>    pv.kubernetes.io/bind-completed: "yes"<br/>    pv.kubernetes.io/bound-by-controller: "yes"<br/>    volume.beta.kubernetes.io/storage-provisioner: kubernetes.io/aws-ebs<br/>    volume.kubernetes.io/selected-node: ip-10-1-1-11.us-west-1.compute.internal<br/>    volume.kubernetes.io/storage-resizer: kubernetes.io/aws-ebs<br/>  labels:<br/>    app.kubernetes.io/instance: nexus<br/>    app.kubernetes.io/managed-by: Tiller<br/>    app.kubernetes.io/name: nexus-repository-manager<br/>    app.kubernetes.io/version: 3.22.1<br/>    helm.sh/chart: nexus-repository-manager-21.2.0<br/>  name: nexus-nexus-repository-manager-data-from-snapshot<br/>  namespace: default<br/>spec:<br/>  accessModes:<br/>  - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 100Gi<br/>  storageClassName: standard<br/>  volumeMode: Filesystem<br/>  volumeName: pv-007a71c14f3571a43</span></pre><p id="d4ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当使用<code class="fe la lb lc ld b">kubectl apply</code>时，该清单将创建一个名为<code class="fe la lb lc ld b">nexus-nexus-repository-manager-data-from-snapshot</code>的PVC，它引用了上一步中创建的PV <code class="fe la lb lc ld b">pv-007a71c14f3571a43</code>。</p><p id="20e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，我删除了用于通过<code class="fe la lb lc ld b">kubectl delete deploymentnexus-nexus-repository-manager-bash</code>挂载原始PVC的临时<code class="fe la lb lc ld b">deployment</code>对象，然后我修改了清单文件<code class="fe la lb lc ld b">nexus-nexus-repository-manager-deployment-bash.yaml</code>，并将PVC名称<code class="fe la lb lc ld b">nexus-nexus-repository-manager-data</code>替换为<code class="fe la lb lc ld b">nexus-nexus-repository-manager-data-from-snapshot</code>。我创建了一个新的<code class="fe la lb lc ld b">deployment</code>，它带有一个吊舱，现在可以通过<code class="fe la lb lc ld b">kubectl apply -f nexus-nexus-repository-manager-deployment-bash.yaml</code>安装新的PVC。</p><p id="727f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我能够<code class="fe la lb lc ld b">kubectl exec</code>进入新的pod并运行OrientDB命令，执行<code class="fe la lb lc ld b">component</code>数据库中所有索引的重建和<code class="fe la lb lc ld b">component</code>数据库的修复:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="06cf" class="lm ln it ld b gy lo lp l lq lr">$ kubectl exec -it nexus-nexus-repository-manager-bash-6765d58756-bdpkz -- bash</span><span id="b1f2" class="lm ln it ld b gy mg lp l lq lr">bash-4.4$ cd /tmp<br/>bash-4.4$ java -jar /opt/sonatype/nexus/lib/support/nexus-orient-console.jar</span><span id="bfe7" class="lm ln it ld b gy mg lp l lq lr">OrientDB console v.2.2.36 (build d3beb772c02098ceaea89779a7afd4b7305d3788, branch 2.2.x) <a class="ae kz" href="https://www.orientdb.com" rel="noopener ugc nofollow" target="_blank">https://www.orientdb.com</a><br/>Type 'help' to display all the supported commands.<br/><br/>orientdb&gt; CONNECT plocal:/nexus-data/db/component admin admin</span><span id="0be0" class="lm ln it ld b gy mg lp l lq lr">orientdb {db=component}&gt; REBUILD INDEX *<br/>orientdb {db=component}&gt; REPAIR DATABASE --fix-graph<br/>orientdb {db=component}&gt; REPAIR DATABASE --fix-links<br/>orientdb {db=component}&gt; REPAIR DATABASE --fix-ridbags<br/>orientdb {db=component}&gt; REPAIR DATABASE --fix-bonsai<br/>orientdb {db=component}&gt; DISCONNECT</span></pre><p id="3741" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，所有的<code class="fe la lb lc ld b">rebuild index</code>和<code class="fe la lb lc ld b">repair database</code>命令都成功了。我有一个包含良好数据库的PVC。是时候再次尝试调整PVC/EBS的大小了。我编辑了<code class="fe la lb lc ld b">pvc-from-snapshot.yaml</code>并将<code class="fe la lb lc ld b">storage</code>的值设置为<code class="fe la lb lc ld b">200Gi</code>，然后用<code class="fe la lb lc ld b">kubectl apply</code>应用这个清单。为了触发EBS调整大小，我必须删除<code class="fe la lb lc ld b">nexus-nexus-repository-manager-bash-6765d58756-bdpkz</code>窗格。一个新的pod启动了，几分钟后成功安装了现在已调整大小的PVC。我通过<code class="fe la lb lc ld b">kubectl exec</code>进入新的pod并运行上面的<code class="fe la lb lc ld b">rebuild index</code>和<code class="fe la lb lc ld b">repair database</code>命令来确保数据库仍然正常。一切都很好。</p><p id="1617" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，我删除了临时的<code class="fe la lb lc ld b">nexus-nexus-repository-manager-bash</code>部署，并修改了原来的部署清单<code class="fe la lb lc ld b">nexus-nexus-repository-manager-deployment.yaml</code>，以便将<code class="fe la lb lc ld b">replicas</code>设置回<code class="fe la lb lc ld b">1</code>(我已经将它临时设置为<code class="fe la lb lc ld b">0</code>)，并将PVC名称<code class="fe la lb lc ld b">nexus-nexus-repository-manager-data</code>替换为<code class="fe la lb lc ld b">nexus-nexus-repository-manager-data-from-snapshot</code>。然后我用<code class="fe la lb lc ld b">kubectl apply</code>应用清单并等待<code class="fe la lb lc ld b">nexus-nexus-repository-manager</code> pod准备好，然后跟踪pod的日志并确保没有错误。</p><p id="0bd9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你跟着做，你就学会了如何:</p><ul class=""><li id="4f2e" class="ls lt it kd b ke kf ki kj km lu kq lv ku lw ky lx ly lz ma bi translated">停止原来的nexus pod并启动一个临时pod，您可以<code class="fe la lb lc ld b">bash</code>进入该pod，以便对原来的PVC运行数据库修复命令</li><li id="1565" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">从未出现数据库损坏症状的卷的EBS快照创建新的PV和PVC</li><li id="c58a" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">通过运行临时pod挂载新PVC并运行OrientDB数据库修复命令，确保数据库是正确的</li><li id="4f07" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">增加PVC/EBS的大小，然后再次运行数据库修复命令，以确保没有数据库损坏错误</li><li id="daee" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">再次旋转nexus pod，这次安装新的PVC</li></ul><p id="709a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这看起来很复杂，那确实很复杂。它强调了一个事实，即Kubernetes并不是真正为有状态工作负载而设计的。如果您确实在Kubernetes中运行这样的工作负载，那么您需要确保对您的数据库进行适当的备份，或者至少(如果您在AWS中)对作为这些数据库的存储的卷进行EBS快照。</p><p id="a2b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有一个特定于Nexus的任务值得研究，那就是创建一个<a class="ae kz" href="https://help.sonatype.com/repomanager3/repository-management/cleanup-policies#CleanupPolicies-LastDownloadedBefore(Days)" rel="noopener ugc nofollow" target="_blank">清理策略</a>和一个每天运行清理的Nexus管理任务。</p></div></div>    
</body>
</html>