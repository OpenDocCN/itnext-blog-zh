<html>
<head>
<title>The long hard road out of XM(hel)L</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">走出XM(hel)L的漫漫长路</h1>
<blockquote>原文：<a href="https://itnext.io/long-hard-road-out-of-xm-hel-l-b017dfd0763f?source=collection_archive---------4-----------------------#2018-07-11">https://itnext.io/long-hard-road-out-of-xm-hel-l-b017dfd0763f?source=collection_archive---------4-----------------------#2018-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6d17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从大学时代起，我就不是XML序列化的狂热爱好者；它引入了开销，但收益不大。然而，现在有很多API，作为iOS开发者，我们需要直面它们。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4f9df805c9565a368dae5d52b3c0608b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7VXzbtw68xt2hZ-KCRXRw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">即使在瞬息万变的世界里，我们有时也会哭泣！！！</figcaption></figure><p id="a2c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我非常喜欢Swift 4中引入的<code class="fe lb lc ld le b">Decodable</code>协议。我在<code class="fe lb lc ld le b">JSONDecoder</code>和<code class="fe lb lc ld le b">PlistDecoder</code>中多次使用过它，但不幸的是，XML的标准库中没有任何东西。我在Shawn Moore的<a class="ae lf" href="https://stackoverflow.com/questions/45787760/implementing-a-custom-decoder-in-swift-4" rel="noopener ugc nofollow" target="_blank"> Stack Overflow </a>上找到了一份出色的解决方案草案，但是有很多未解决的问题，不幸的是，没有经过测试。所有这些基础给了我通过<code class="fe lb lc ld le b">XMLDecoder</code>开始这段旅程的动力(目前我既不需要名称空间也不需要编码器)。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="4894" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">案例研究:Decodable和JSON</h1><p id="7e25" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">首先，我想澄清一下<code class="fe lb lc ld le b">Decodable</code>允许一个人做什么。假设我们有这个<code class="fe lb lc ld le b">JSON</code>文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ecdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些是相关的实体:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ba3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在有了<code class="fe lb lc ld le b">JSONDecoder</code>，把它们从<code class="fe lb lc ld le b">JSON</code>翻译成<code class="fe lb lc ld le b">struct</code>就相当简单了:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">convertFromSnakeCase有助于将first_name翻译成firtsName</figcaption></figure><p id="1be6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lb lc ld le b">decode</code>方法分两步进行:</p><ul class=""><li id="639b" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">用<code class="fe lb lc ld le b">JSONSerialization.jsonObject(with: data)</code>从<code class="fe lb lc ld le b">Data</code>到<code class="fe lb lc ld le b">Any</code>；</li><li id="61f0" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">从<code class="fe lb lc ld le b">Any</code>到<code class="fe lb lc ld le b">Decodable</code>用解码器对每个实体进行拆箱和造型。</li></ul></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="f2a5" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">XML解析和规范化</h1><p id="8200" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">第一个目标是将类似于<code class="fe lb lc ld le b">&lt;root&gt;&lt;key&gt;value&lt;/key&gt;&lt;/root&gt;</code>的东西映射到类似于<code class="fe lb lc ld le b">["key": "value"]</code>的东西。我编写了一个<code class="fe lb lc ld le b">XMLTree</code>来将<code class="fe lb lc ld le b">Data</code>映射到<code class="fe lb lc ld le b">[String: Any]</code>(XML中的<em class="ng">映射</em>比JSON简单，因为<code class="fe lb lc ld le b">Any</code>可以只是<code class="fe lb lc ld le b">String</code>或<code class="fe lb lc ld le b">[String: Any]</code>)。我已经使用事件驱动的<code class="fe lb lc ld le b">XMLParser</code>构建了一个可导航的<code class="fe lb lc ld le b">XMLNode</code>树。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2ce5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一步中，我主要面临两个问题，总结为两个例子:</p><pre class="km kn ko kp gt nh le ni nj aw nk bi"><span id="703d" class="nl lo iq le b gy nm nn l no np">&lt;root&gt;<br/>  &lt;foo id="1"&gt;bar&lt;/foo&gt;<br/>&lt;/root&gt;</span></pre><p id="2096" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经选择将<em class="ng">匿名</em> <code class="fe lb lc ld le b">value</code>作为一个带有键值<strong class="jp ir">_的属性。</strong></p><pre class="km kn ko kp gt nh le ni nj aw nk bi"><span id="98c2" class="nl lo iq le b gy nm nn l no np">["key": [ "id": "1", "_value": "bar"]]</span></pre><p id="33e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道这不是最干净的解决方案，但它足够<em class="ng">快速不脏</em>通过第一版。</p><p id="4651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是继续第二个问题:</p><pre class="km kn ko kp gt nh le ni nj aw nk bi"><span id="45b4" class="nl lo iq le b gy nm nn l no np">&lt;root&gt;<br/>    &lt;foo&gt;1&lt;/foo&gt;<br/>    &lt;foo&gt;2&lt;/foo&gt;<br/>    &lt;foo&gt;3&lt;/foo&gt;<br/>    &lt;foo&gt;4&lt;/foo&gt;<br/>&lt;/root&gt;</span></pre><p id="043f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一个<code class="fe lb lc ld le b">foo</code>的访问中，我不能说它是否是一个链表元素的标量，所以我必须假设它是一个标量:<code class="fe lb lc ld le b">dictionary["foo"] = 1</code>。在第二轮中，我需要知道是否存储了以前的值，以便将新值添加到<code class="fe lb lc ld le b">dictionary["foo"]</code>，就像<code class="fe lb lc ld le b">[1, 2]</code>。从第三个开始就更简单了，因为可以将新值附加到现有值上。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="0e45" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">拆箱功能</h1><p id="4aa9" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">在第一阶段之后，我们可以专注于第二阶段:拆箱值。</p><p id="db00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现<code class="fe lb lc ld le b">Decoder</code>协议，我应该实现<code class="fe lb lc ld le b">KeyedDecodingContaier</code>、<code class="fe lb lc ld le b">UnkeyedDecodingContainer</code>和<code class="fe lb lc ld le b">SingleValueDecodingContainer</code>，但是我只是意识到我可以安全地使用<code class="fe lb lc ld le b">JSONDecoder</code>(和<code class="fe lb lc ld le b">PlistDecoder</code>)中的那些。不幸的是，那些实现都是<code class="fe lb lc ld le b">fileprivate</code>。我真的很乐意与swift社区一起找到解决方案，但在此之前，这只是简单的复制粘贴。</p><p id="e100" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到这一点，我的第二个目标是尽可能少地更改这些实现，以便有机会与未来的版本重新保持一致。</p><p id="703e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题已经被简化了:我只需要实现函数来将<strong class="jp ir">的值</strong>解装箱为期望的类型。【是<code class="fe lb lc ld le b">extension _JSONDecoder { … }</code>内标有<em class="ng">具体值表示</em>注释的块。]</p><p id="9bab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lb lc ld le b">JSONDecoder</code>支持的类型有:</p><ul class=""><li id="6912" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><code class="fe lb lc ld le b">Int</code>、<code class="fe lb lc ld le b">Int8</code>、<code class="fe lb lc ld le b">Int16</code>、<code class="fe lb lc ld le b">Int32</code>、<code class="fe lb lc ld le b">Int64</code>；</li><li id="daa6" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><code class="fe lb lc ld le b">UInt</code>、<code class="fe lb lc ld le b">UInt8</code>、<code class="fe lb lc ld le b">UInt16</code>、<code class="fe lb lc ld le b">UInt32</code>、<code class="fe lb lc ld le b">UInt64</code>；</li><li id="bd00" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><code class="fe lb lc ld le b">Float</code>、<code class="fe lb lc ld le b">Double</code>、<code class="fe lb lc ld le b">Decimal</code>；</li><li id="de53" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><code class="fe lb lc ld le b">Data</code>、<code class="fe lb lc ld le b">Date</code>、<code class="fe lb lc ld le b">URL</code>、<code class="fe lb lc ld le b">String</code>、<code class="fe lb lc ld le b">Bool</code>。</li></ul><p id="3032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于前三个家庭，我只修改了<code class="fe lb lc ld le b">guard</code>的这一部分:</p><pre class="km kn ko kp gt nh le ni nj aw nk bi"><span id="9f40" class="nl lo iq le b gy nm nn l no np">guard let number = value as? NSNumber</span></pre><p id="aca9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用:</p><pre class="km kn ko kp gt nh le ni nj aw nk bi"><span id="2ef6" class="nl lo iq le b gy nm nn l no np">guard let string = value as? String, let number = string.numberValue</span></pre><p id="3069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">声明此<code class="fe lb lc ld le b">extension</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e746" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而对于第四个家庭，我什么也没做。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="fbec" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">一的数组</h1><p id="de89" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">最后一个棘手的部分是<code class="fe lb lc ld le b">Array</code>解码。XML没有办法表示一个项目的列表。在以下情况下:</p><pre class="km kn ko kp gt nh le ni nj aw nk bi"><span id="e00f" class="nl lo iq le b gy nm nn l no np">&lt;root&gt;<br/>  &lt;key1&gt;<br/>    &lt;key2&gt;value1&lt;/key2&gt;<br/>  &lt;/key1&gt;<br/>  &lt;key1&gt;<br/>    &lt;key2&gt;value2&lt;/key2&gt;<br/>    &lt;key2&gt;value3&lt;/key2&gt;<br/>  &lt;/key1&gt;<br/>&lt;/root&gt;</span></pre><p id="1bf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lb lc ld le b">XMLTree</code>输出这个<code class="fe lb lc ld le b">Dictionary</code>:</p><pre class="km kn ko kp gt nh le ni nj aw nk bi"><span id="4313" class="nl lo iq le b gy nm nn l no np">["key1": [<br/>  ["key2": "value1"],<br/>  ["key2": ["value2", "value3"]<br/>]]</span></pre><p id="3126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逻辑上<code class="fe lb lc ld le b">key2</code>是一个<code class="fe lb lc ld le b">Array&lt;String&gt;</code>，但是在一个元素的情况下，解码器没有关于它的证据。所以我改变了最后一个<code class="fe lb lc ld le b">unbox</code>回退:</p><pre class="km kn ko kp gt nh le ni nj aw nk bi"><span id="ed15" class="nl lo iq le b gy nm nn l no np">{<br/>  self.storage.push(container: value)<br/>  defer { self.storage.popContainer() }<br/>  return try type.init(from: self)<br/>}</span></pre><p id="9605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">带有一个<code class="fe lb lc ld le b">do</code> / <code class="fe lb lc ld le b">catch</code>和一个<code class="fe lb lc ld le b">extension</code>:</p><pre class="km kn ko kp gt nh le ni nj aw nk bi"><span id="8cf7" class="nl lo iq le b gy nm nn l no np">{<br/>  self.storage.push(container: value)<br/>  defer { self.storage.popContainer() }<br/>  do {<br/>    return try type.init(from: self)<br/>  } catch {<br/>    if type is _ArrayProtocol.Type {<br/>      self.storage.push(container: [value])<br/>      return try type.init(from: self)<br/>    } else {<br/>      throw error<br/>    }<br/>  }<br/>}</span><span id="4e7e" class="nl lo iq le b gy nq nn l no np">protocol _ArrayProtocol {}<br/>extension Array : _ArrayProtocol {}</span></pre></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="441d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="24d2" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">我对我在SDK中发现的每个场景进行了单元测试，当然我100%确定还有我没有涉及的边缘情况，但是我真的很乐意提供帮助和整合建议。专门用于<code class="fe lb lc ld le b">_value</code>和<code class="fe lb lc ld le b">_ArrayProtocol</code>解决方案。</p></div></div>    
</body>
</html>