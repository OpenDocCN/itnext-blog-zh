# 网络数据的变化趋势

> 原文：<https://itnext.io/winds-of-change-in-web-data-728187331f53?source=collection_archive---------1----------------------->

![](img/d3bad58fec0f8143dd93af7ff21aacb1.png)

> 我们不会停止探索
> ，我们所有探索
> 的终点将是到达我们开始的地方
> ，并第一次了解这个地方

T.S .艾略特的话无疑是科技行业赖以生存的咒语。新趋势不时席卷我们的行业，只是为了演变成与我们以前非常相似的东西，只是现在有了新的可能性。

不久前，还没有人考虑过你会选择哪个 OSS 数据库来存储操作数据:如果你想有一个服务器供客户机连接，你可以选择 Postgres 或 MySQL。如果您有一个需要一些本地结构化数据的简单应用程序，那么您会选择 SQLite 的便利性和低设置成本。

但是由于我们不会停止探索，我们集体放弃了 SQL 的安全港，去寻找新的模型和新的横向扩展架构来满足 webscale 应用程序的需求。但随着潮水的退去，它也在流动。越来越常见的是，开发人员得出结论，随着硬件、商业环境和开发人员偏好的最近变化，Postgres 在几乎任何情况下都是一个很好且安全的选择。

但是 SQLite 呢？嵌入式简单数据库在我们的旅程中还有一席之地吗？在这篇文章中，我将探索一些变革的趋势，为如何考虑 2022 年及以后的数据库铺平道路，并介绍[chisser store](https://github.com/chiselstrike/chiselstore):一个可嵌入的分布式 zero-conf SQLite 库，它很可能对您足够好。

## 不断变化的景观

那么，什么样的转变使得我们有理由重新审视传统的解决方案呢？

**尺寸**

第一个大的变化仅仅是今天硬件的大小。现代存储设备并没有变得更小:在 AWS 上，只需点击一个按钮，[就可以产生一个带有 30 TB 附加存储的服务器](https://aws.amazon.com/ec2/instance-types/i4g/)。

当对分布式数据库的探索开始时，它主要是由不适合单个服务器的主机数据的需求驱动的。当然，这样的用例仍然存在于特定的领域。但是，在与大数据客户密切合作近十年后，我可以用一只手的手指数出他们中有多少人真正超过了 30TB 大关。一旦你走出专门的大数据世界，回到 web 应用程序，很可能你的所有数据要么可以放在一台服务器上，要么可以放在少数几台服务器上，在这种情况下，可以使用基本的分片技术。

分布仍然很重要，但它不是数据量的推动者，而是需要额外的节点来提供容错和接近用户，以获得更好的延迟。

**性能**

那些大型存储设备也没有变慢:NVMe 设备现在变得无处不在，随之而来的是操作系统接口和 API 的变化，旨在利用它们。根据我的经验，大多数人并没有真正意识到现代 NVMe 设备有多快，以及这对数据库有什么实际影响。对于很大一部分开发人员来说，当您提到“数据库”时，首先浮现在脑海中的是受存储速度限制的东西。毕竟，数据库的工作不是存储数据吗？

两位数的每秒百万次运算是存储世界的新常态。

当然，直到您的设备和软件堆栈的组合能够在单核中每秒处理 1000 万个请求。现在，您只需点击一个按钮，就可以启动一个 64 核的盒子(它有 30TB 的附加存储)，这意味着当您的单核向您的 NVMe 设备发出 1000 万个请求时，其他 63 个内核可以自由地做您想做的任何事情。

第一个直接后果是，数据库现在受到 CPU 能力的限制。但另一个有趣的结果是，计算和数据库节点必然会合并:当存储节点不再有任何特殊之处时，就没有理由将计算和存储视为具有不同访问模式和特征的独立实体。

事实上，SQLite 的一个基本版本，不需要我们做太多的调优工作，就可以在 16 个线程的情况下每秒处理超过 50 万个读请求。如果其他水手的故事是可信的，经过一些努力，这些数字可能会更高，[单个服务器就有多达 400 万次阅读](https://blog.expensify.com/2018/01/08/scaling-sqlite-to-4m-qps-on-a-single-server/)

```
[OVERALL], ThreadCount, 16
[OVERALL], RunTime(ms), 17656
[OVERALL], Throughput(ops/sec), 566379.70
```

写入速度较慢，实际上要慢得多:

```
[OVERALL], ThreadCount, 1
[OVERALL], RunTime(ms), 38478
[OVERALL], Throughput(ops/sec), 2598.88
```

但是对于 web 应用程序来说，以读取为主的用例非常常见，而且正如我们很快就会看到的那样，这并不是写入的故事的结尾。

**部署模式**

第三个架构转变是 Kubernetes 的传播，以及随之而来的心态变化。在 Kubernetes 之前，数据库节点是永久性的:无论是金属盒还是虚拟机，一旦启动，它将永远与该节点相连。但是在库伯内特人的世界里，事物本质上都是短暂的。在 Kubernetes 时代之前诞生的数据库尽可能使用各种技巧来绑定资源，并模仿它们的旧方式。

但是接受这种新现实的节点表现不同:它们是自然分布的，如果一个节点因为这样或那样的原因死亡，它不会被保留:它只是被替换。从对象存储中流式传输快照，并重放日志的增量。如果这听起来很疯狂，请记住这些服务器可能有 100Gbps 的链路和每秒几十 GB 的存储写入速度。

采用这样的设计还有其他后果:节点可以在内存中运行，因为它们无论如何都会在失败时被破坏。

对于数据适合内存的情况(请记住，2021 年的“适合内存”很容易意味着 5tb)，sqlite 要快得多:

```
[OVERALL], ThreadCount, 1
[OVERALL], RunTime(ms), 2678
[OVERALL], Throughput(ops/sec), 37341.29
```

尽管如此，内存还是太贵了，而存储越来越便宜。但这也为另一种设计敞开了大门:不要 fsync:这种存储可以作为索引大量数据的一种方式，但这一切都被视为短暂的。

对于我们的基准测试，禁用 fsync 产出:

```
[OVERALL], ThreadCount, 1
[OVERALL], RunTime(ms), 8795
[OVERALL], Throughput(ops/sec), 11370.09
```

Kubernetes 也只是冰山一角。在面向云的场景中仍然占主导地位，在今天的环境中，web 应用程序通常是完全无服务器的，它们的应用程序代码通过边缘功能在边缘计算位置上运行。像 [Vercel](https://vercel.com/) 和 [Netlify](http://www.netlify.com/) 这样的玩家用这种模型俘获了 web 开发人员的心，SQLite 的可嵌入性使其成为创新的基于边缘的数据部署的有力竞争者。

**黑拳分发共识**

最后一个经常被忽视的转变是 Raft 的商品化。不久前，分布式一致意见属于黑魔法领域，在那里，一小撮发起者可以设计出聪明的方法，在分布式系统中提供任何种类的保证。现在，几乎任何语言都有 Raft 库。

# **凿商店**

看到上面的趋势展开，是什么让我发现[凿击](http://chiselstrike.com)。虽然该公司本身仍处于私人测试阶段，知道的也不多，但我们今天公开了这个故事的一个核心组件:[chickerstore](https://github.com/chiselstrike/chiselstore/)。

![](img/6b4b9ff835d38766ab9b780e51e2549b.png)

简而言之，ChiselStore 将 sqlite 数据库包装在 Raft 库中。我们不是第一个将这两种技术结合起来的人。最值得注意的是，我们知道 [rqlite](https://github.com/rqlite/rqlite) 和 [dqlite](https://dqlite.io/) 。

rqlite 是使用 SQLite +Raft 的分布式数据库的一个很好的实现。但是它被设计为用作独立的数据库。我们认为，嵌入式版本可以释放出巨大的能量，可以像 SQLite 本身一样在边缘计算场景中以零配置方式使用。

dqlite 在概念上非常匹配 ChiselStore，但是 C 实现拒绝了我们。除了作为一个嵌入式分布式数据库，ChiselStore 是使用 LittleRaft 库用 Rust 编写的。尽管 LittleRaft 是一个新生的库，但我们非常看好 Rust，并根据经验知道它所吹嘘的安全优势并非侥幸。

诚然，SQLite 本身也是用 c 语言编写的。但同时，它可能是现存的在手机、浏览器和各种其他设备上运行的最广泛使用的数据库系统，所以在这一点上，我们将不再讨论它。

## 用木筏和铁锈分发 SQLite

ChiselStore 是一个 zero-conf 数据库库，可以像嵌入 SQLite 一样嵌入到应用程序中。使用 ChiselStore，您的应用程序使用库 API 执行 SQL 语句，如 CREATE TABLE、INSERT 或 SELECT。在内部，ChiselStore 使用 Raft consensus 协议将 SQL 语句复制到集群中的所有节点，集群将这些语句应用到它们的本地 SQLite 实例。

Raft 保证集群中的所有 SQLite 实例具有相同的内容，这使得集群即使在一些节点不可用的情况下也能继续运行。使用 Raft 的结果是，默认情况下，ChiselStore 提供了很强的一致性(线性化)。因为 SQL 语句是在 Raft 集群 leader 节点上执行的，所以在 ChiselStore 集群上执行的 SQL 语句看起来好像只有一个数据副本。

## 轻松阅读

实现强一致性的成本很高。然而，在 web 应用程序中，读取相对于写入滞后是可以接受的。对于这些场景，ChiselStore 提供了一种*宽松读取*一致性模式，允许客户端在本地节点上执行读取操作。这种模式非常适合可用性更重要的情况，即使节点与分布式数据库的其余部分断开连接，应用程序也必须提供读取服务。

正如我们所看到的，使用宽松读取的性能非常接近 SQLite 本身提供的性能

```
[OVERALL], ThreadCount, 16
[OVERALL], RunTime(ms), 17856
[OVERALL], Throughput(ops/sec), 560035.8
```

**局限性**

ChiselStore 处于初级阶段，目前不适合生产使用。特别是 LittleRaft 缺乏对 Raft 快照和联合共识的支持。也就是说，SQL 语句的复制日志永远不会被截断，节点也不可能动态地加入和离开集群。

这些是 LittleRaft 图书馆的局限性，我们认为应该尽快解除。

# 摘要

随着最近硬件的进步和行业趋势的转变，就数据库而言，我们经常发现自己处于开始旅程的同一个地方:SQL 已经足够好了。

虽然 Postgres 是一种常见且安全的选择，但在某些场景中，比如在边缘，SQLite 可能是一个强有力的竞争者。如何在 SQLite 之上拥有一个全球分布式应用程序的问题由 ChiselStore 解决。

ChiselStore 为许多用例提供了一种在无服务器环境中靠近端点复制数据的简单方法。当使用宽松读取时，它具有与 SQLite 相当的读取性能。

我们目前正致力于将 ChiselStore 与我们的无服务器运行时集成为一个可选的零配置数据库。如果你想了解更多关于我们在[凿击](http://www.chiselstrike.com)无服务器&边缘所做的事情，请[联系我们](https://calendly.com/glaubercosta/chiselstrike-private-beta)。