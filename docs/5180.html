<html>
<head>
<title>Optimising images for better LCP web vitals scores</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化图像以获得更好的LCP网络生命体征评分</h1>
<blockquote>原文：<a href="https://itnext.io/optimising-images-for-better-lcp-web-vitals-scores-7e9866087973?source=collection_archive---------1-----------------------#2021-01-04">https://itnext.io/optimising-images-for-better-lcp-web-vitals-scores-7e9866087973?source=collection_archive---------1-----------------------#2021-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/356792c5d3d98fdf49fc4fbf30cfe7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsdapYI0cZGGEbYqs3TSSw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由Soragrit Wongsa拍摄</figcaption></figure><p id="c027" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">图像是网络上最常见的内容类型之一，它们经常被用来吸引用户的注意力，通常是屏幕上最大的元素(比如横幅、英雄图像、产品图像等)，所以我们尽最大努力让它们尽快显示出来以保持良好的用户体验是非常重要的。</p><p id="d9b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看看<a class="ae la" href="https://web.dev/vitals/" rel="noopener ugc nofollow" target="_blank">谷歌的网络要害</a>有一个重要的指标是图像可以影响的，那就是“<strong class="ke ir">最大内容油漆</strong>”(LCP)，考虑到仅这一项就占了灯塔总分的<strong class="ke ir"> 25% </strong>这是一个我们不能忽视的指标。</p><blockquote class="lb"><p id="b1d8" class="lc ld iq bd le lf lg lh li lj lk kz dk translated">最大内容绘制(LCP)指标报告视窗内可见的最大<a class="ae la" href="https://web.dev/lcp/#what-elements-are-considered" rel="noopener ugc nofollow" target="_blank">图像或文本块</a>的渲染时间。</p></blockquote><p id="abb5" class="pw-post-body-paragraph kc kd iq ke b kf ll kh ki kj lm kl km kn ln kp kq kr lo kt ku kv lp kx ky kz ij bi translated">如果我们文件夹上方最大的元素是一张图片(特别是在电子商务网站上)，那么优化这张图片将会使它渲染得更快，同时提高我们的Lighthouse分数。因此，我想分享一些关于如何通过一些性能测量来改进LCP的技巧。</p><h1 id="961b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">测试对象</h1><p id="0e16" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">我将使用我的“<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/javascript-sliders-will-kill-your-website-performance-5e4925570e2b">Javascript sliders will kill your website performance</a>”文章中的演示，因为它非常简单，并且显示了电子商务产品页面中常见的布局，所以希望您能够理解。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/0a58dba60f15b9afa276aa47990f346c.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*Z8dpu96Ge0-Qf55Hh2SJhQ.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">初始演示</figcaption></figure><p id="891e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下是最初的数字，我把“<strong class="ke ir">First Contentful Paint</strong>”(FCP)也包括在内，仅供参考，因为我不想让我对LCP的优化对FCP产生负面影响:</p><p id="eab3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">FCP:</strong>1.17秒<br/><strong class="ke ir">LCP:</strong>1.59秒<br/> <strong class="ke ir">页面大小</strong> : 67.8kb</p><blockquote class="lb"><p id="aacc" class="lc ld iq bd le lf lg lh li lj lk kz dk translated">性能测试是使用iPhone 8屏幕模拟3G连接(1.6 Mbps/768 Kbps 300毫秒RTT)进行的</p></blockquote><h1 id="5dd7" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb my md me mf mz mh mi mj na ml mm mn bi translated">使用适合屏幕尺寸的正确图像</h1><p id="4d90" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">这是一个有时非常明显但经常被忽视的问题，你不会相信有多少网站发布了比它们应该大3倍的图片，因为它们只是缩小了桌面大小的图片。</p><p id="4110" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据经验，尽量不要使用比将要显示的尺寸大两倍以上的图像，如果你不介意在HiDPI设备上损失一些质量，你甚至可以使用更小的尺寸。使用<code class="fe nb nc nd ne b">srcset</code> <code class="fe nb nc nd ne b">&lt;img&gt;</code>属性或<code class="fe nb nc nd ne b">picture</code>元素显示适合屏幕尺寸的图像。</p><p id="e3d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我的演示中，产品图像将以大约<strong class="ke ir">375像素</strong>的宽度显示，所以我选择使用<strong class="ke ir">750像素</strong>宽的图像，这样它在视网膜屏幕和现代设备上看起来很好。</p><p id="c484" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看我们现在的绩效时间表:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/5f59d92cb65f8de12199f31688455c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Gb6cFVvDbOTs68-s6GxXQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">初始性能时间表</figcaption></figure><p id="cc2f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在加载的图片似乎比我们需要的要多，所以让我们试试下一步的优化。</p><h1 id="f689" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">延迟加载图像</h1><p id="4c81" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">这是你经常听到的另一个建议，不常见的是，现在你可以不用任何javascript，只需在我们的图片中使用<code class="fe nb nc nd ne b">loading="lazy"</code>属性就可以实现。</p><blockquote class="ng nh ni"><p id="9572" class="kc kd nj ke b kf kg kh ki kj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky kz ij bi translated">属性支持非常好，如果你真的需要IE/Safari支持，你仍然可以有选择地包含一个基于javascript的惰性加载器。</p></blockquote><p id="3f68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在为我们的图像添加延迟加载支持后，我们的指标如下所示:</p><p id="bcff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">FCP:</strong>1.17秒<br/><strong class="ke ir">LCP:</strong>1.98秒(+24%) <br/> <strong class="ke ir">页面大小:</strong> 50.7kb (-25%)</p><p id="69a4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">等等，为什么我们的LCP时间差！？页面尺寸减小了，这并不奇怪，因为我们少加载了一个图像，但是让我们看看我们的时间线，以了解LCP时间的增加。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/0fecdd5820bd3561a17248059877fdf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kGMlznEXdyZVKGISm4TrwQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">延迟加载后的性能时间线</figcaption></figure><p id="d088" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是延迟加载带来的一个问题:<strong class="ke ir">浏览器会降低延迟加载的图像的优先级</strong>，这对于视图之外的图像来说很好，但是如果它影响到我们的LCP元素就不太好了。</p><p id="75fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里的解决方案很简单，<strong class="ke ir">如果图像在文件夹之上，避免延迟加载图像</strong>。在这种情况下，我们只需要从第一张产品图片中删除<code class="fe nb nc nd ne b">loading="lazy"</code>属性。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/a095421f4934f6b566402941ea67c415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WSuBWu3pdWUTjiT8Q10xdg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">选择性延迟加载后的性能时间线</figcaption></figure><p id="6560" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过这样做，我们设法让浏览器更快地加载我们的LCP元素，同时仍然保持页面大小的改进:</p><p id="c360" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">FCP:</strong>1.17s<br/><strong class="ke ir">LCP:</strong>1.33s(-16%)<br/><strong class="ke ir">页面大小:</strong> 50.7kb (-25%)</p><h1 id="f64a" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">异步解码图像(可能)</h1><p id="1c52" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">另一个不太为人所知的优化技巧是使用<code class="fe nb nc nd ne b">decode="async"</code> image属性，这将告诉浏览器在不阻塞主线程的情况下异步解码图像。</p><p id="9584" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，对于这个演示来说，这似乎没有太大的区别，下面是时间线在变化前后的样子:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/bfe6c5011117a4ea9fdb48374e41562c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujo6ywAJo1i7SRuMibT6PA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">解码前= "异步"</figcaption></figure><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/d29f3f0bb2ffc4f3f773edcfeed8c58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QG4k9VYA2W-tycI3qmtmTA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">解码后=“异步”</figcaption></figure><p id="c38a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我没有注意到主线程有任何不同，即使创建了额外的光栅化线程，它似乎仍然在做同样多的工作。可能是因为演示没有加载那么多图像，但我还是想提出来，以防它对其他人有帮助，它不会对我们的指标产生负面影响，所以我选择暂时保留它。</p><h1 id="14e6" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用现代图像格式</h1><p id="590d" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">到目前为止，我一直在演示中使用JPEG来加载产品图像，但我们可以做得更好。通过将图像转换为WebP，我们可以在没有任何质量损失的情况下大幅减小图像大小，所以让我们先试试。</p><p id="8288" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">FCP:</strong>1.17s<br/><strong class="ke ir">LCP:</strong>1.26s(-20%)<br/><strong class="ke ir">页面大小:</strong> 35kb (-48%)</p><p id="63d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的页面大小几乎是原来的一半，我们的LCP时间越来越好，但是如果你喜欢生活在边缘，我们可以尝试一种更新的图像格式:<strong class="ke ir"> AVIF </strong>。</p><blockquote class="ng nh ni"><p id="573b" class="kc kd nj ke b kf kg kh ki kj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky kz ij bi translated">AVIF是基于AV1视频格式的现代图像格式。AVIF通常比WebP、JPEG、PNG和GIF有更好的压缩效果，并被设计用来取代它们。</p></blockquote><p id="0aa8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">FCP:</strong>1.17秒<br/><strong class="ke ir">LCP:</strong>1.26秒(-20%) <br/> <strong class="ke ir">页面大小:</strong> 24.2kb (-64%)</p><p id="9366" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的<strong class="ke ir"> FCP </strong>和<strong class="ke ir"> LCP </strong>时间还是一样的(可能是因为<a class="ae la" href="https://en.wikipedia.org/wiki/TCP_congestion_control#Slow_start" rel="noopener ugc nofollow" target="_blank"> TCP慢启动</a>？)但是我们的页面尺寸要小得多。AVIF的主要缺点是它还没有得到广泛的支持，但是我们可以使用<code class="fe nb nc nd ne b">&lt;picture&gt;</code>元素来显示基于浏览器支持的正确图像。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/0d02ea5ec10022169e15bdd95e5a92aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*niE0uztqyWpHI_HRJfRHDw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如果不是JPG，我更喜欢AVIF而不是WEBP</figcaption></figure><p id="8363" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">WEBP和AVIF还有另一个缺点，我将并排展示JPG版本和AVIF版本，看看你是否能发现它们的区别:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/c16ed190d4fbc5a484ba66741e3713c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*L3LqtJmDPBG5F1GP4_j5CQ.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd ls">左</strong> : JPEG版本- <strong class="bd ls">右</strong> : AVIF版本</figcaption></figure><p id="2ca3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以防你没看到，<strong class="ke ir">WEBP和AVIF都不支持渐进式加载</strong>，所以使用JPEGs，我们可以在加载图像时获得较低质量的预览，而不是一次显示所有图像。</p><p id="0c09" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想达到类似的效果，你需要自己显示较低质量的版本，对于演示，我选择使用<a class="ae la" href="https://github.com/axe312ger/sqip" rel="noopener ugc nofollow" target="_blank"> SQIP </a>来显示主图像的较低质量的SVG版本作为背景，这样它将在产品图像加载后被覆盖。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/ee09592650e2685405bf38c52e8c3db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/1*M56hMiWMlOPbt-qVQ0S0Mg.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">“渐进”渲染AVIF图像</figcaption></figure><p id="bf39" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据我的测试，这不会影响LCP时间，我不确定这是否是故意的，但<strong class="ke ir"> Chrome仍然会等到图像完全加载后才报告最大的内容元素已加载</strong>，不过这有助于提高“感知”性能，这也是一种良好的用户体验。</p><p id="c2be" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和以前一样，它似乎不会对演示中的指标产生负面影响，所以我决定保留它。</p><h1 id="26c6" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">HTTP2服务器推送</h1><p id="2a95" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">到目前为止，我们已经在前端进行了改进，以减少LCP时间，但对于这最后一个技巧，我们需要对服务器响应HTTP请求的方式进行一些调整。</p><p id="bfa6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在做任何事情之前，让我们先看看目前为止最大的瓶颈:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/e3b760b71db068c97a6828ca6e1bc231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1qa5SlV4hewFePF-L0Q2w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">绩效时间线分析</figcaption></figure><p id="1afe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">首先:</strong>HTML文档需要从上到下逐行下载并解析，这样浏览器就知道接下来需要下载什么资源以及优先级。<strong class="ke ir">然后，</strong>它发现CSS、logo和第一张产品图片需要先加载，所以它去取它们，但只是在第一步完成之后。</p><p id="a7dc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">HTTP2服务器推送允许我们在响应头中包含提示浏览器加载哪些资源的提示，这样我们就可以在HTML解析之前开始加载它们。</p><p id="5174" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">nginx和Apache等现代web服务器支持开箱即用，实现略有不同，但一般来说，它们的工作方式是在响应头中添加一个额外的<code class="fe nb nc nd ne b">Link</code>头，其中包含如下所示的资源列表:</p><pre class="mu mv mw mx gt nt ne nu nv aw nw bi"><span id="b18e" class="nx lr iq ne b gy ny nz l oa ob">Link: &lt;/style.css&gt;; as=style; rel=preload, &lt;/image.jpg&gt;; as=image; rel=preload</span></pre><p id="d227" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在很多情况下，这并不简单，如果资源是相同的，你可以通过硬编码来避免(例如:徽标、通用样式等)，但是如果它们改变了(就像产品图片的情况)，你需要一种方法来准确地知道哪些图片将根据页面被加载。</p><p id="bd44" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可能还会推送已经被浏览器缓存的资源，迫使浏览器再次重新下载这些资源，讽刺的是这会损害网站的性能。</p><p id="caca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我个人喜欢<a class="ae la" href="https://www.cloudflare.com/website-optimization/http2/serverpush/" rel="noopener ugc nofollow" target="_blank"> Cloudflare的HTTP2服务器推送服务</a>，它们有助于处理浏览器缓存的额外复杂性，但你仍然需要通过额外的<code class="fe nb nc nd ne b">Link</code>头发送资源。我将此添加到演示中，结果令人印象深刻:</p><p id="47b0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">FCP:</strong>0.70秒(-40%)<br/><strong class="ke ir">LCP:</strong>0.86秒(-35%) <br/> <strong class="ke ir">页面大小:</strong> 24.2kb (-64%)</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/d99792275d02f19f749611bb6c615277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm4HpTqSXpHbRzhbxS_epQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTTP2服务器推送后的性能时间线分析</figcaption></figure><p id="ceca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我用HTTP2服务器推送预加载了样式、徽标和主要产品图像，正如你所见，它们加载得更快了(甚至我们的<strong class="ke ir"> FCP </strong>时间也减少了将近一半)。</p><p id="40e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有时很难欣赏数字本身，因此为了透视起见，这里以幻灯片的形式比较了迄今为止所做的所有优化。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/c348fb1d8f449f428564d3ecdc00f661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpsFzYZ11uAyaJNxyurIBw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">优化的连续画面视图</figcaption></figure><h1 id="ded8" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">关键要点</h1><ol class=""><li id="85e7" class="oe of iq ke b kf mo kj mp kn og kr oh kv oi kz oj ok ol om bi translated">最低限度，惰性加载适当大小和格式的图像。</li><li id="de21" class="oe of iq ke b kf on kj oo kn op kr oq kv or kz oj ok ol om bi translated">HTTP2服务器推送可以改善FCP / LCP时间，但实现起来可能会很棘手。</li><li id="1e35" class="oe of iq ke b kf on kj oo kn op kr oq kv or kz oj ok ol om bi translated">测量和描述你所做的每一个改变，你不能改进你没有测量的东西。</li></ol></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><p id="7d3e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望这些提示能帮助你提高你的网站性能和灯塔得分，如果你在处理FCP / LCP时报时遗漏了什么，请告诉我。👋🏽</p></div></div>    
</body>
</html>