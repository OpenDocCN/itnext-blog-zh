<html>
<head>
<title>What is actually reactive programming in modern C++? Part. 2: Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++中的反应式编程实际上是什么？部分。2:操作员</h1>
<blockquote>原文：<a href="https://itnext.io/what-is-actually-reactive-programming-in-modern-c-part-2-operators-63d5ea7223cc?source=collection_archive---------1-----------------------#2022-11-07">https://itnext.io/what-is-actually-reactive-programming-in-modern-c-part-2-operators-63d5ea7223cc?source=collection_archive---------1-----------------------#2022-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6f20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好，欢迎回到C++的反应式编程世界！</p><p id="1dd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望你已经看过这个系列的第一部了。在这篇文章中，我们将探讨运营商和他们的权力。</p><p id="537b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们之前所学的，你可以在运算符的帮助下修改你的可观察对象及其事件——它们是扩展值流、添加一些复杂逻辑、变换、过滤值等的小构件。目前，在反应式编程的世界里有很多类型的操作符。让我们逐一查看，以熟悉每种类型，并探究一些示例:</p><h1 id="4e25" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">创造可观的</h1><p id="6ec7" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">首先，你需要以某种方式创造你的可观察对象。例如，您可以创建一个可观察对象来发出一个值列表，遍历某个容器或发出某个函数的结果(函数将在订阅期间执行):</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="d540" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当订户订阅它时，会发出传递的值，然后发出完成。与<code class="fe lw lx ly lz b">obs_of_doubles</code>相同，但是它会迭代vector并从中发出值。<code class="fe lw lx ly lz b">obs_of_char</code>将在订阅上执行传递的函数，发出结果值，然后发出完成。</p><p id="c7d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的是:每个新订阅都从头开始“订阅回调”。这意味着订户1在<code class="fe lw lx ly lz b">obs_of_char</code>订阅并获得值，然后订户2在<code class="fe lw lx ly lz b">obs_of_char</code>订阅，然后函数将再次执行，而不是发出“缓存的”值。</p><h1 id="cd23" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">转换</h1><p id="82e1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">然后我们可以修改我们的观察值。例如，我们可以发送第一个可观察值的部分和，并将第二个可观察值乘以10:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="fe50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">增加的运营商只有在订阅后，并且只有在从潜在的可观测量中获得新的排放时才会采取行动。换句话说:它是懒惰的计算，在实际订阅之前什么都不会发生</p><h1 id="a6bc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">过滤</h1><p id="bc8b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">并不是所有的排放都对我们有用，所以我们可以在可观测值上增加一些过滤逻辑。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="521b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们可以只过滤≤ 5的值，跳过前1次发射。</p><h1 id="24ef" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">有条件的</h1><p id="ecf2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">除了上面提供的能力之外，我们还可以提供一些关于observable什么时候可以发射值或者什么时候应该停止发射(或者哪个应该发射值)的条件。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="81e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们强制我们的字符的可观察对象发出值，直到v！= "0".当条件达到时，可观察到发送完成和退订。</p><h1 id="8220" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结合</h1><p id="32c9" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">当我们只能利用一个可观测量时，我们能利用多个可观测量做什么呢？结合他们！例如，我们可以通过<code class="fe lw lx ly lz b">concat</code>操作符将它们结合起来，它保持了可观察对象的顺序:当第一个可观察对象仅在此事件之后完成时，第二个可观察对象开始发射:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="50f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，可观测值从<code class="fe lw lx ly lz b">filtered_partial_sums_of_obs_of_ints</code>开始发射，直到完成，然后从<code class="fe lw lx ly lz b">take_while_obs_of_char</code>发送值，直到完成，然后从<code class="fe lw lx ly lz b">skiped_multiplied_obs_of_doubles</code>发送值。</p><h1 id="51a1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">订阅</h1><p id="9b0f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">那么让我们订阅这个可观察值并检查结果:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="3b7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(为了获得更好的结果，我在<code class="fe lw lx ly lz b">obs_of_symbols </code>中添加了<code class="fe lw lx ly lz b">repeat()</code>，以无限发送来自函数的值——因此，它会重新订阅可观察值并重新发出函数，直到订阅被取消；在我们的例子中，由于<code class="fe lw lx ly lz b">take_while</code>，它将被取消订阅</p><p id="f53d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能的输出:</p><pre class="lp lq lr ls gt ma lz mb mc aw md bi"><span id="98ff" class="me kn iq lz b gy mf mg l mh mi">New value 1<br/>New value 3<br/>3210123<br/>New value 51<br/>New value 50<br/>New value 49<br/>New value 103</span></pre><p id="4662" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里我们看到:<br/> <strong class="jp ir"> * </strong> 1和3 from <code class="fe lw lx ly lz b">filtered_partial_sums_of_obs_of_ints</code> : 1=0+1，3=1+2，然后6=3+3不符合v ≤ 5的条件，所以没有其他值，所以observable终止，下一个开始于<code class="fe lw lx ly lz b">concat_with</code> <br/> <strong class="jp ir"> * </strong> 3210123 —是我作为get_char的输入键入控制台的内容。Observable将chars解释为相应的代码，所以我们看到51(3)，50(2)，49(1)。然后可观测量发出0，但是<code class="fe lw lx ly lz b">take_while</code>终止了这些可观测量，所以，<code class="fe lw lx ly lz b">concat_with</code>转到最后一个可观测量<br/><strong class="jp ir">*</strong>103——就是10.3乘以10。但是由于<code class="fe lw lx ly lz b">skip(1)</code>跳过了35 (3.5*10)</p><h1 id="c571" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="ac13" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在这篇简单的文章中，我们已经检查了大多数类型的操作符，并在它们的帮助下构建了简单的例子！在下一篇文章中，我将向您展示如何使用线程和同步原语来创建可观察的多线程！</p><p id="b6ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接到<a class="ae kl" href="https://github.com/victimsnino/ReactivePlusPlus" rel="noopener ugc nofollow" target="_blank"> ReactivePlusPlus </a> (rpp)库。请自行检查，做一些实验，并在您的项目中使用它=)</p></div></div>    
</body>
</html>