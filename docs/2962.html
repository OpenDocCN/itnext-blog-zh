<html>
<head>
<title>A few handy Vue.js tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一些方便的Vue.js技巧</h1>
<blockquote>原文：<a href="https://itnext.io/a-few-handy-vue-js-tricks-832703cff426?source=collection_archive---------0-----------------------#2019-09-08">https://itnext.io/a-few-handy-vue-js-tricks-832703cff426?source=collection_archive---------0-----------------------#2019-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/37b348df842aa4325313972355037509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Yl5Hfqn5bhq1en0OcZsTA.jpeg"/></div></div></figure><h1 id="b57c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak"> 1。将父组件的所有属性转发给子组件</strong></h1><p id="66d3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果你是一个Vue.js开发人员，在某些时候你肯定会写一个仅仅是“包装”在另一个组件上的组件。一个所谓的<strong class="ky ir">包装组件</strong>通常会接受它所包装的组件也接受的所有属性。然后，您会希望将这些道具“转发”到包装的组件。不要这样做:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="1bba" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">通过这样做，您可以简单地一次转发包装组件的所有属性:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h1 id="b94b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak"> 2。确保两个组件接受相同的道具</strong></h1><p id="e847" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这一招可以和第一招强有力地结合起来。既然已经知道了如何将所有属性转发给包装的组件，有人可能会想，首先如何确保包装组件接受与包装组件相同的属性。在包装器组件中，人们很可能会这样写:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">试验</figcaption></figure><p id="dab2" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">这有一些缺点。其中之一是，如果您重写了ChildComponent并可能添加了一些新的道具，那么您也必须对包装器组件进行更改。另一个缺点是代码重复和通常糟糕的代码美学。幸运的是，这个问题有一个非常简单的解决方案:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h1 id="c608" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.将父组件的所有事件侦听器转发到子组件</h1><p id="3a44" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您希望将事件侦听器传递到的子组件位于父组件的根，则不需要这样做，因为它会获得所有默认侦听器。但是，如果情况并非如此，如以下示例所示，您可以这样做:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h1 id="a444" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.漂亮的插槽语法</h1><p id="8753" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">从Vue 2.6开始，插槽名称有了一个简写，就像事件一样，例如用<code class="fe mj mk ml mm b">@click</code>代替<code class="fe mj mk ml mm b">v-on:click</code>`。如果你有一个<code class="fe mj mk ml mm b">&lt;my-table&gt;</code>组件，它有一个名为<code class="fe mj mk ml mm b">row</code>的槽，它有一个名为<code class="fe mj mk ml mm b">item</code>的槽属性，你现在可以传递一个模板给它，并以这种方式访问<code class="fe mj mk ml mm b">item</code>属性:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h1 id="0282" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.动态指令参数</h1><p id="3748" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这可能是Vue 2.6提供的最令人印象深刻和最强大的特性:向组件动态传递指令参数。假设您有一个<code class="fe mj mk ml mm b">&lt;my-button&gt;</code>组件。出于某种原因，有时你想在上面听一个<code class="fe mj mk ml mm b">click</code>事件，但其他时候你想听<code class="fe mj mk ml mm b">dblclick</code>。您可以使用这样的动态指令来解决这个问题:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="667b" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">动态提供事件侦听器只是您可以做的许多事情之一——您可以将相同的模式应用于动态HTML属性、道具等等！</p><h1 id="20ee" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak"> 6。动态图像src </strong></h1><p id="1e4f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一个常见的用例是当你需要显示一个本地存储的图像，它的路径存储在某个变量或某个对象的属性中。虽然有多种解决方案，但我更喜欢使用webpack的<code class="fe mj mk ml mm b">require </code>功能。假设在你的Vue组件的<code class="fe mj mk ml mm b">data</code>中有一个类似这样的对象:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f841" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">您想要显示的图像的路径存储在<code class="fe mj mk ml mm b">company</code>对象的<code class="fe mj mk ml mm b">logo</code>属性中。在这个例子中，我们将假设你的项目的所有图像都在<code class="fe mj mk ml mm b">src/assets</code>，这也是建议你放置图像的地方。还有一个子文件夹叫<code class="fe mj mk ml mm b">logos</code>，里面有一堆logo图片。因此，在这种情况下，图像的完整路径应该是:<code class="fe mj mk ml mm b">src/assets/logos/cashmoneylogo.png</code>。</p><p id="1b9a" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">因此，在组件的<code class="fe mj mk ml mm b">&lt;template&gt;</code>中，您将创建一个<code class="fe mj mk ml mm b">&lt;img&gt; </code>标记并动态提供src属性:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="747b" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">这里需要考虑一些事情:</p><ul class=""><li id="badb" class="mn mo iq ky b kz ma ld mb lh mp ll mq lp mr lt ms mt mu mv bi translated">传递给<code class="fe mj mk ml mm b">require</code>函数的字符串路径是一个带有反斜杠(`…`)的<strong class="ky ir"> ES6模板字符串。</strong>这样，你可以使用<code class="fe mj mk ml mm b">${...}</code>灵活地放入一个变量，而不是使用<code class="fe mj mk ml mm b">+</code>操作符连接。</li><li id="10d1" class="mn mo iq ky b kz mw ld mx lh my ll mz lp na lt ms mt mu mv bi translated"><code class="fe mj mk ml mm b"><a class="ae nb" href="https://webpack.js.org/api/module-methods/" rel="noopener ugc nofollow" target="_blank">require</a></code> <a class="ae nb" href="https://webpack.js.org/api/module-methods/" rel="noopener ugc nofollow" target="_blank">函数</a>将<strong class="ky ir">而不是</strong>使用纯动态的路径<strong class="ky ir">，</strong>工作，因为webpack需要知道哪些文件在编译时已经被捆绑。您需要提供一个部分静态的路径表达式。然后，Webpack将捆绑所有与该表达式*匹配的文件。这就是为什么<code class="fe mj mk ml mm b">@/assets/logos</code>部分在我们的例子中是硬编码的。顺便说一下，<code class="fe mj mk ml mm b">@ </code>本质上是指“相对于<code class="fe mj mk ml mm b">src</code>文件夹”。无论你输入的文件在哪里，你都可以使用它，我强烈建议你使用它，而不是用相对形式声明难看的路径，比如<code class="fe mj mk ml mm b">./../../../</code>。另一个好处是:如果您后来决定将文件移动到其他地方，使用<code class="fe mj mk ml mm b">@</code>的路径仍然有效。</li></ul><p id="4ba3" class="pw-post-body-paragraph kw kx iq ky b kz ma lb lc ld mb lf lg lh mc lj lk ll md ln lo lp me lr ls lt ij bi translated">* <em class="nc">注意:如果有许多文件与您提供的路径表达式匹配，这可能会影响性能。如果是这种情况，请确保您的路径表达式定义得尽可能窄，或者查找Webpack提供的可能的优化。</em></p></div></div>    
</body>
</html>