<html>
<head>
<title>Automating System Updates for Kubernetes Clusters using Ansible</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Ansible自动更新Kubernetes集群的系统</h1>
<blockquote>原文：<a href="https://itnext.io/automating-system-updates-for-kubernetes-clusters-using-ansible-94a70f4e1972?source=collection_archive---------1-----------------------#2020-07-27">https://itnext.io/automating-system-updates-for-kubernetes-clusters-using-ansible-94a70f4e1972?source=collection_archive---------1-----------------------#2020-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84fd52eba37e96536136eb66922f6d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xw-rfX0f-6tlehElu4dJ0w.png"/></div></div></figure><p id="c94b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Kubespray </strong>是部署自我管理的Kubernetes集群的首选工具。Kubespray建立在ansi ble之上，它简化了Kubernetes集群的部署、更新和扩展。如果你正在部署自己的裸机Kubernetes集群，或者如果你想通过不使用云服务来节省资金，比如GKE、谷歌云、EKS、AWS或Azure，我强烈推荐你使用Kubespray。</p><p id="4c65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubespray提供了很多管理Kubernetes的工具，但是它没有提供任何管理底层基础设施的工具。在这篇文章中，我将展示如何使用Ansible来自动化Kubernetes集群的零停机系统更新。在Kubernetes集群上完成系统更新的过程是:</p><ol class=""><li id="2949" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">封锁</strong>该节点，这样就不会在该节点上安排新的单元</li><li id="1154" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">清空</strong>节点，以便将所有现有工作负载转移到其他节点</li><li id="10be" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">更新并重新启动节点</li><li id="c3b9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">最后<strong class="ka ir">解除节点的锁定</strong>,这样就可以在节点上安排新的pod</li></ol><p id="29ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法还可以用于在任何类型的集群上自动执行其他维护任务，而不会导致服务器停机。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="acc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将从Ansible剧本开始。定义行动手册有两个重要部分。首先是<code class="fe lr ls lt lu b">serial</code>设置。通常Ansible在清单中的所有节点上并行执行任务，但是一次更新和重新启动所有节点会使所有节点一次脱机，中断服务并导致Kubernetes集群进入潜在的不可恢复的不良状态。为了避免这个问题，设置<code class="fe lr ls lt lu b">serial: 1</code>将导致Ansible剧本一次在一个节点上运行。第二个设定是<code class="fe lr ls lt lu b">any_errors_fatal</code> <strong class="ka ir">。</strong>根据您的集群的规模或其重要程度，如果出现错误，您可能(也可能不会)想要暂停Ansible Playbook的操作。</p><p id="5c42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我的<code class="fe lr ls lt lu b">playbook.yml</code>文件:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="33b4" class="md me iq lu b gy mf mg l mh mi">---<br/>- hosts:<br/>    - kube-master<br/>    - kube-node<br/>  become: true<br/>  become_method: sudo<br/>  <strong class="lu ir">serial: 1</strong><br/>  <strong class="lu ir">any_errors_fatal: "{{ any_errors_fatal | default(true) }}"</strong><br/><br/>  roles:<br/>    - k8s-rolling-update</span></pre></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="b9e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在设置了<code class="fe lr ls lt lu b">serial: 1</code>之后，Ansible Playbook将在一个循环中运行<code class="fe lr ls lt lu b"> k8s-rolling-update</code>角色，一次一个节点。现在我们来看看角色。</p><p id="bcf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们要检查每个节点，确保Kubernets报告该节点处于<strong class="ka ir">就绪</strong>状态，并且<strong class="ka ir">未被许可</strong>。我们将使用Ansible的<a class="ae mj" href="https://docs.ansible.com/ansible/latest/modules/command_module.html" rel="noopener ugc nofollow" target="_blank">命令模块</a>来运行<code class="fe lr ls lt lu b">kubectl get node</code>并解析JSON输出。我们将通过命令模块而不是<a class="ae mj" href="https://docs.ansible.com/ansible/latest/modules/k8s_info_module.html" rel="noopener ugc nofollow" target="_blank"> k8s_info模块</a>运行kubectl，因为k8s_info模块需要在每个节点上安装OpenShift Python客户端。Kubespray不使用OpenShift Python客户端，并且通常不可用。</p><p id="4a27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是<code class="fe lr ls lt lu b">tasks/main.yml</code>。该任务仅在<code class="fe lr ls lt lu b">kube-master</code>库存组的第一个节点上运行<code class="fe lr ls lt lu b">kubectl get node</code>，并将输出保存到<code class="fe lr ls lt lu b">kubectl_get_node</code>变量中。我们希望这个命令只在一个节点上运行，所以我们使用了<code class="fe lr ls lt lu b">delegate_to</code>选项。然后它解析JSON输出，如果节点<strong class="ka ir">就绪</strong>且<strong class="ka ir">未被批准</strong>，该任务将运行3个其他任务。来自<code class="fe lr ls lt lu b">kubectl get node</code>的JSON输出很复杂，所以<code class="fe lr ls lt lu b"><a class="ae mj" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#json-query-filter" rel="noopener ugc nofollow" target="_blank">json_query</a></code>过滤器用于解析JSON。json_query过滤器使用<a class="ae mj" href="https://jmespath.org" rel="noopener ugc nofollow" target="_blank">JMS path</a>并且可以接受JMS path查询。</p><p id="164a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lr ls lt lu b">drain.yml</code>将完成封锁和清空(以上列表中的步骤1 &amp; 2)，<code class="fe lr ls lt lu b">ubuntu.yml</code>将完成更新和重启(以上列表中的步骤3)，<code class="fe lr ls lt lu b">uncordon.yml</code>将解除节点封锁(以上列表中的步骤4)。我用变量<code class="fe lr ls lt lu b">ansible_distribution</code>引用<code class="fe lr ls lt lu b">ubuntu.yml</code>，这样这个角色的未来更新可以包括不同Linux发行版的更新任务，而不需要更新<code class="fe lr ls lt lu b">tasks/main.yml</code>。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="05a5" class="md me iq lu b gy mf mg l mh mi">---<br/>- name: Get the node's details<br/>  command: &gt;-<br/>    {{ bin_dir }}/kubectl get node<br/>    {{ kube_override_hostname|default(inventory_hostname) }}<br/>    -o json<br/>  register: kubectl_get_node<br/>  delegate_to: "{{ groups['kube-master'][0] }}"<br/>  failed_when: false<br/>  changed_when: false<br/><br/>- name: Update Node<br/>  when:<br/>    <em class="mk"># When status.conditions[x].type == Ready then check stats.conditions[x].status for True|False<br/>    </em>- kubectl_get_node['stdout'] | from_json | json_query("status.conditions[?type == 'Ready'].status")<br/>    <em class="mk"># If spec.unschedulable is defined then the node is cordoned<br/>    </em>- not (kubectl_get_node['stdout'] | from_json).spec.unschedulable is defined<br/>  block:<br/>    - name: Cordon &amp; drain node<br/>      include_tasks: <strong class="lu ir">drain.yml</strong><br/><br/>    - name: Upgrade the Operating System<br/>      include_tasks: <strong class="lu ir">"{{ ansible_distribution }}.yml"</strong><br/><br/>    - name: Uncordon node<br/>      include_tasks: <strong class="lu ir">uncordon.yml</strong></span></pre><p id="3bea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在开始<code class="fe lr ls lt lu b">tasks/drain.yml</code>中的排水和警戒线任务。第一项任务是从第一个<code class="fe lr ls lt lu b">kube-master</code>节点运行<code class="fe lr ls lt lu b">kubectl cordon</code>命令，将工作节点与集群的其他节点隔离开来。接下来，我们将再次运行<code class="fe lr ls lt lu b">kubectl get node</code>来验证节点已经被封锁。此任务将重试10次，中间等待10秒钟，直到节点被封锁。最后，最后一个任务将在工作节点上运行<code class="fe lr ls lt lu b">kubectl drain</code>来驱逐任何正在运行的pod，这样就可以安全地升级节点上的Docker或重启节点，这将在下一步中进行。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="d5bf" class="md me iq lu b gy mf mg l mh mi">---<br/>- name: Cordon node<br/>  command: &gt;-<br/>    {{ bin_dir }}/<strong class="lu ir">kubectl cordon</strong><br/>    {{ kube_override_hostname|default(inventory_hostname) }}<br/>  delegate_to: "{{ groups['kube-master'][0] }}"<br/><br/>- name: Wait for node to cordon<br/>  command: &gt;-<br/>    {{ bin_dir }}/<strong class="lu ir">kubectl get node</strong><br/>    {{ kube_override_hostname|default(inventory_hostname) }}<br/>    -o json<br/>  register: wait_for_cordon<br/>  <strong class="lu ir">retries: 10</strong><br/>  <strong class="lu ir">delay: 10</strong><br/>  delegate_to: "{{ groups['kube-master'][0] }}"<br/>  changed_when: false<br/>  until: (wait_for_cordon['stdout'] | from_json).spec.unschedulable<br/><br/>- name: Drain node<br/>  command: &gt;-<br/>    {{ bin_dir }}/<strong class="lu ir">kubectl drain</strong><br/>    --force<br/>    --ignore-daemonsets<br/>    --grace-period {{ drain_grace_period }}<br/>    --timeout {{ drain_timeout }}<br/>    --delete-local-data {{ kube_override_hostname|default(inventory_hostname) }}<br/>  delegate_to: "{{ groups['kube-master'][0] }}"</span></pre><p id="7dd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从节点上清空所有单元后，您可以在节点上运行任何任务，而不会中断任何服务。在本例中，<code class="fe lr ls lt lu b">tasks/ubuntu.yml</code>将更新节点上的所有程序包，并在必要时重新启动服务器。首先，<a class="ae mj" href="https://docs.ansible.com/ansible/latest/modules/apt_module.html" rel="noopener ugc nofollow" target="_blank"> apt模块</a>更新节点上的所有包。然后，该任务通过检查<code class="fe lr ls lt lu b">/var/run/reboot-required</code>是否存在来查看更新后是否需要重启。如果/var/run/reboot-required存在，则使用<a class="ae mj" href="https://docs.ansible.com/ansible/latest/modules/reboot_module.html" rel="noopener ugc nofollow" target="_blank">重启模块</a>重启节点。重新启动模块将重新启动节点，等待代码重新联机，然后继续执行下一个任务。<strong class="ka ir">注意:</strong> <code class="fe lr ls lt lu b">tasks/ubuntu.yml</code>对于任何任务都不使用<code class="fe lr ls lt lu b">delegate_to</code>，我们希望将<code class="fe lr ls lt lu b">kubectl</code>命令的运行委托给一个节点，但是我们希望在轮到节点时在节点上运行更新和重启。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="3a92" class="md me iq lu b gy mf mg l mh mi">---<br/>- name: Update all packages<br/>  apt:<br/>    upgrade: dist<br/>    update_cache: true<br/>    force_apt_get: true<br/><br/>- name: Check if reboot is required<br/>  stat:<br/>    path: /var/run/reboot-required<br/>  register: reboot_required<br/><br/>- name: Reboot the server<br/>  reboot:<br/>    post_reboot_delay: 30<br/>  when: reboot_required.stat.exists</span></pre><p id="4998" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，一旦节点被更新和重新启动，我们希望取消节点的锁定，以便可以在其上安排新的pod。<code class="fe lr ls lt lu b">tasks/uncordon.yml</code>将在更新的节点上运行<code class="fe lr ls lt lu b">kubectl uncordon</code>命令，然后验证该节点确实是可调度的。</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="3476" class="md me iq lu b gy mf mg l mh mi">---<br/>- name: Uncordon node<br/>  command: &gt;-<br/>    {{ bin_dir }}/kubectl uncordon<br/>    {{ kube_override_hostname|default(inventory_hostname) }}<br/>  delegate_to: "{{ groups['kube-master'][0] }}"<br/><br/>- name: Wait for node to uncordon<br/>  command: &gt;-<br/>    {{ bin_dir }}/kubectl get node<br/>    {{ kube_override_hostname|default(inventory_hostname) }}<br/>    -o json<br/>  register: wait_for_uncordon<br/>  retries: 10<br/>  delay: 10<br/>  delegate_to: "{{ groups['kube-master'][0] }}"<br/>  changed_when: false<br/>  until: not (kubectl_get_node['stdout'] | from_json).spec.unschedulable is defined</span></pre><p id="2e27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一个节点上运行完<code class="fe lr ls lt lu b">tasks/uncordon.yml</code>之后，<code class="fe lr ls lt lu b">tasks/drain.yml</code>将在第二个节点上开始，依此类推，同样是由于剧本中的<code class="fe lr ls lt lu b">serial: 1</code>设置。就是这样！您可以使用并扩展这个示例，在任何类型的集群上执行任何任务，同样的方法应该适用于<strong class="ka ir"> Hadoop </strong>和<strong class="ka ir"> Spark </strong>集群，甚至是<strong class="ka ir"> Mysql </strong>和<strong class="ka ir"> Postgres </strong>数据库副本。</p><p id="6064" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以在<a class="ae mj" href="https://github.com/kevincoakley/ansible-role-k8s-rolling-update" rel="noopener ugc nofollow" target="_blank">https://github . com/kevincoakley/ansi ble-role-k8s-rolling-update</a>查看工作角色。</p></div></div>    
</body>
</html>