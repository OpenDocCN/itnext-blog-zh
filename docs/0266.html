<html>
<head>
<title>Fast and modern front-end setup with webpack, react, redux, router, saga and postcss, part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用webpack、react、redux、router、saga和postcss的快速现代前端设置，第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/fast-and-modern-front-end-setup-with-webpack-react-redux-router-saga-and-postcss-part-2-9ae7ad4e7cb2?source=collection_archive---------0-----------------------#2018-02-04">https://itnext.io/fast-and-modern-front-end-setup-with-webpack-react-redux-router-saga-and-postcss-part-2-9ae7ad4e7cb2?source=collection_archive---------0-----------------------#2018-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/620171a7d5b7ea51511c27079b95bdaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StKHWQTiBB_fhWdA7vgZzg.jpeg"/></div></div></figure><p id="1a1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是设置的第二部分。有不止一个部分，仅仅是因为它包含了大量的文本。</p><p id="d3f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Ffast-and-modern-front-end-setup-with-webpack-react-redux-router-saga-and-postcss-part-2–9ae7ad4e7cb2" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em> </a>上分享这篇文章</p><p id="f99f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/fast-and-modern-front-end-setup-with-webpack-react-redux-router-saga-and-postcss-1360e9715d17">这里的</a>是第一部分。</p><p id="e115" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们忘了添加commonChunksPlugin。这个插件的作用是删除重复内容。显然，它会将找到的副本放在一个单独的包中。这个插件包含在webpack中，所以我们只需要导入webpack，不需要下载:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ca08" class="lh li iq ld b gy lj lk l ll lm">const webpack = require('webpack');</span></pre><p id="4516" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并在插件中实现。最终的webpack.config.js如下所示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4f5f" class="lh li iq ld b gy lj lk l ll lm">const path = require('path');<br/>const webpack = require('webpack');</span><span id="b39e" class="lh li iq ld b gy ln lk l ll lm">const CleanWebpackPlugin = require('clean-webpack-plugin');<br/>const HtmlWebpackPlugin = require('html-webpack-plugin');<br/>const ExtractTextPlugin = require('extract-text-webpack-plugin');<br/>const extractPlugin = new ExtractTextPlugin({<br/>    filename: './style.css'<br/>});</span><span id="9b93" class="lh li iq ld b gy ln lk l ll lm">module.exports = {<br/>    entry: "./index.js",<br/>    output: {<br/>        // CHANGED LINE        <br/>        filename: '[name].bundle.js',<br/>        path: path.resolve(__dirname, 'public')<br/>    },<br/>    context: path.resolve(__dirname, 'src'),<br/>    devServer: {<br/>        contentBase: path.resolve(__dirname, 'public/assets'),<br/>        stats: 'errors-only',<br/>        open: true,<br/>        port: 8080,<br/>        compress: true<br/>    },<br/>    plugins: [<br/>        new CleanWebpackPlugin(['public']),<br/>        new HtmlWebpackPlugin({<br/>            template: 'index.html'<br/>        }),<br/>        extractPlugin,<br/>        // NEW LINES<br/>        new webpack.optimize.CommonsChunkPlugin({<br/>            name: 'common'<br/>        })<br/>    ],<br/>    module: {<br/>        rules: [{<br/>            test: /\.(jpg|png|gif|svg)$/,<br/>            use: [<br/>            {<br/>                loader: 'file-loader',<br/>                options: {<br/>                    name: '[name].[ext]',<br/>                    outputPath: './assets/',<br/>                }<br/>            }]<br/>        }, {<br/>            test: /\.scss$/,<br/>            use: extractPlugin.extract({<br/>             use: ["css-loader", "sass-loader", "postcss-loader"],<br/>             fallback: 'style-loader'<br/>            })<br/>        }, {<br/>         test: /\.js$/,<br/>         use: {<br/>          loader: 'babel-loader',<br/>          options: {<br/>           presets: ['env', 'stage-0', 'react']<br/>          }<br/>         }<br/>        }]<br/>    }<br/>}</span></pre><p id="5855" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另请注意，我们添加了一个[名称]。这是因为commonChunksPlugin将生成一个新的输出文件。现在你可以运行<code class="fe lo lp lq ld b">npm run build</code>来检查一下。</p><p id="5de2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在public/文件夹中，您现在会注意到main.bundle.js和common.bundle.js。这使得我们的最终输出更小，这意味着最终用户:D的加载时间更快</p><p id="178f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果我们运行<code class="fe lo lp lq ld b">npm start</code>，我们会注意到两件事:第一，浏览器中页面的加载时间比我们开始时慢，第二，控制台输出中有额外的一行通知我们有东西被取消优化。回过头来看，我们发现我们所做的一些事情意味着以过程本身为代价来优化最终输出。我们可以通过拆分配置文件来解决这个问题，并为开发和生产提供单独的配置。这将证明对以后的其他事情是有用的。</p><p id="5e26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们将首先在webpack.config文件旁边创建一个webpack.prod.config.js文件。</p><p id="7798" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主文件将是开发配置文件，另一个文件将从中加载并为生产优化。让我们从生产文件开始:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="13df" class="lh li iq ld b gy lj lk l ll lm">var webpack = require("webpack");</span><span id="b23e" class="lh li iq ld b gy ln lk l ll lm">module.exports = require('./webpack.config.js');</span><span id="85f1" class="lh li iq ld b gy ln lk l ll lm">delete module.exports.devtool;</span><span id="dbf3" class="lh li iq ld b gy ln lk l ll lm">module.exports.plugins.push(<br/>    new webpack.DefinePlugin({<br/>        'process.env.NODE_ENV': JSON.stringify('production')<br/>    })<br/>);</span><span id="9eb9" class="lh li iq ld b gy ln lk l ll lm">module.exports.plugins.push(<br/>    new webpack.optimize.UglifyJsPlugin({<br/>        comments: false,<br/>        warnings: false<br/>    })<br/>);</span></pre><p id="b604" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，首先我们加载webpack以便能够使用DefinePlugin和UglifyJSPlugin。接下来，我们加载主文件。我们将在这里更改一些设置，但保留主要的设置。第一个变化，删除devtool对象，我们在生产中不需要它。然后，我们将另一个插件DefinePlugin添加到插件数组中。这个允许我们设置一些全局变量。但这并不意味着它们对浏览器是全局的，只是你可以在代码中使用它们。当我们为开发和生产制作前端配置文件时，这将非常方便。</p><p id="019e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后稍微改一下丑化。如果您只是运行<code class="fe lo lp lq ld b">npm run build-prod</code>，您会注意到文件输出是单行的，非常不可读。这个过程被称为丑化，它使文件更小，以便更快地上传到用户的电脑。Webpack在生产中会自动丑化，但我们会更改这两个标志。</p><p id="f1d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要高兴，因为我们还有更多的事情要做，这只是基本的配置。我们将通过转到package.json来调用该文件，并在脚本中更改一行:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a014" class="lh li iq ld b gy lj lk l ll lm">"build-prod": "webpack -p --config webpack.prod.config.js"</span></pre><p id="773c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你可以运行<code class="fe lo lp lq ld b">npm start build-prod</code>来确保它正常工作。</p><p id="0d37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，现在来解决前面提到的两个问题。让我们首先将commonChunksPlugin转移到生产中，它会减慢我们的开发速度:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4067" class="lh li iq ld b gy lj lk l ll lm">module.exports.plugins.push(<br/>    new webpack.optimize.CommonsChunkPlugin({<br/>        name: 'common'<br/>    })<br/>);</span></pre><p id="e438" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在产品配置中添加这一行，并从主配置中删除插件。运行<code class="fe lo lp lq ld b">npm start</code>来看看它是否更快，也许改变index.js中的一些东西来测试一下。</p><p id="3fc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，但更重要的是，我们目前处理/node_modules/文件夹中所有被调用的文件。这个文件夹是加载外部库的地方。我喜欢重新处理这些文件，因为你可以很容易地找到一个未经优化的库，但我们不需要在开发中这样做。我们将通过在任何测试下添加它来避免这种情况:在加载器中:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8e73" class="lh li iq ld b gy lj lk l ll lm">exclude: /node_modules/,</span></pre><p id="7520" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并再次运行<code class="fe lo lp lq ld b">npm start</code>: d .并将其添加到生产中，添加以下内容</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="87c7" class="lh li iq ld b gy lj lk l ll lm">module.exports.module.rules.forEach(rule =&gt; {<br/>    delete rule.exclude;<br/>    return rule;<br/>});</span></pre><p id="4a40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，生产将采取和优化一切，而开发优化工作。仍有一些空间进行其他优化，可能会将其他插件传递给prod，但对我来说，速度并没有任何差异，所以这是我停下来的地方。</p><p id="e683" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是帮助你的配置文件</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="483e" class="lh li iq ld b gy lj lk l ll lm">const path = require('path');<br/>const webpack = require('webpack');</span><span id="8622" class="lh li iq ld b gy ln lk l ll lm">const CleanWebpackPlugin = require('clean-webpack-plugin');<br/>const HtmlWebpackPlugin = require('html-webpack-plugin');<br/>const ExtractTextPlugin = require('extract-text-webpack-plugin');<br/>const extractPlugin = new ExtractTextPlugin({<br/>    filename: './style.css'<br/>});</span><span id="a2f5" class="lh li iq ld b gy ln lk l ll lm">module.exports = {<br/>    entry: "./index.js",<br/>    output: {<br/>        filename: '[name].bundle.js',<br/>        path: path.resolve(__dirname, 'public')<br/>    },<br/>    context: path.resolve(__dirname, 'src'),<br/>    devServer: {<br/>        contentBase: path.resolve(__dirname, 'public/assets'),<br/>        stats: 'errors-only',<br/>        open: true,<br/>        port: 8080,<br/>        compress: true<br/>    },<br/>    plugins: [<br/>        new CleanWebpackPlugin(['public']),<br/>        new HtmlWebpackPlugin({<br/>            template: 'index.html'<br/>        }),<br/>        extractPlugin<br/>    ],<br/>    module: {<br/>        rules: [{<br/>            test: /\.(jpg|png|gif|svg)$/,<br/>            exclude: /node_modules/,<br/>            use: [<br/>            {<br/>                loader: 'file-loader',<br/>                options: {<br/>                    name: '[name].[ext]',<br/>                    outputPath: './assets/',<br/>                }<br/>            }]<br/>        }, {<br/>            test: /\.scss$/,<br/>            exclude: /node_modules/,<br/>            use: extractPlugin.extract({<br/>                use: ["css-loader", "sass-loader", "postcss-loader"],<br/>                fallback: 'style-loader'<br/>            })<br/>        }, {<br/>            test: /\.js$/,<br/>            exclude: /node_modules/,<br/>            use: {<br/>                loader: 'babel-loader',<br/>                options: {<br/>                    presets: ['env', 'stage-0', 'react']<br/>                }<br/>            }<br/>        }]<br/>    }<br/>}</span></pre><p id="9943" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和webpack.prod.config.js</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f072" class="lh li iq ld b gy lj lk l ll lm">var webpack = require("webpack");</span><span id="2753" class="lh li iq ld b gy ln lk l ll lm">const ExtractTextPlugin = require('extract-text-webpack-plugin');<br/>const extractPlugin = new ExtractTextPlugin({<br/>    filename: './style.css'<br/>});</span><span id="02e3" class="lh li iq ld b gy ln lk l ll lm">module.exports = require('./webpack.config.js');</span><span id="afa4" class="lh li iq ld b gy ln lk l ll lm">delete module.exports.devtool;</span><span id="9845" class="lh li iq ld b gy ln lk l ll lm">module.exports.plugins.push(<br/>    new webpack.DefinePlugin({<br/>        'process.env.NODE_ENV': JSON.stringify('production')<br/>    })<br/>);</span><span id="a5d3" class="lh li iq ld b gy ln lk l ll lm">module.exports.plugins.push(<br/>    new webpack.optimize.CommonsChunkPlugin({<br/>        name: 'common'<br/>    })<br/>);</span><span id="b9eb" class="lh li iq ld b gy ln lk l ll lm">module.exports.plugins.push(extractPlugin);</span><span id="27b8" class="lh li iq ld b gy ln lk l ll lm">module.exports.module.rules.forEach(rule =&gt; {<br/>    delete rule.exclude;<br/>    return rule;<br/>});</span><span id="6dd8" class="lh li iq ld b gy ln lk l ll lm">module.exports.plugins.push(<br/>    new webpack.optimize.UglifyJsPlugin({<br/>        comments: false,<br/>        warnings: false<br/>    })<br/>);</span></pre><p id="50c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">！！！搞定了。！！</p><p id="2701" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望我们没有忘记什么:d .请记住，根据您的需要，还有其他插件可能有用，但对于标题中有完整设置的文章来说，这已经是太多的webpack了。做出反应。</p><h2 id="a2b0" class="lh li iq bd lr ls lt dn lu lv lw dp lx kj ly lz ma kn mb mc md kr me mf mg mh bi translated">反应</h2><p id="87ab" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">入口文件是index.js，所以我们将在这里加载react。React需要一个装载的地方。幸运的是，我们已经在index.html用id="app "制作了一个div，看看吧。接下来，因为我忘了我们还没有做到这一点，去终端，并得到反应</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6348" class="lh li iq ld b gy lj lk l ll lm">npm i -S react react-dom prop-types</span></pre><p id="8332" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们的index.js文件:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="aa65" class="lh li iq ld b gy lj lk l ll lm">import "babel-polyfill";<br/>import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="8751" class="lh li iq ld b gy ln lk l ll lm">ReactDOM.render(<br/>  &lt;div&gt;<br/>    Hello world!<br/>  &lt;/div&gt;,<br/>  document.getElementById('app')<br/>);</span></pre><p id="9578" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，首先我们要装载巴别塔填充物。这件事到此为止，我们结束了。接下来，react和react-dom将我们的react应用程序加载到html。请注意，在render函数的第二行中，我们获取了#app元素。现在运行<code class="fe lo lp lq ld b">npm start</code>，看看你好世界！在浏览器中。</p><p id="65d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，我们现在有反应了。我们还得到了prop-types，这在代码中有更多人的时候很有用，因为它告诉他们组件期望什么样的prop。</p><p id="cf9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了真正利用react的优势，让我们在src/文件夹中创建一个组件/文件夹。我们将把组件放在这里，并将主组件命名为App.js。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="cd73" class="lh li iq ld b gy lj lk l ll lm">import React from 'react';</span><span id="21f2" class="lh li iq ld b gy ln lk l ll lm">const App = props =&gt; &lt;div&gt;Our main component&lt;/div&gt;</span><span id="83ca" class="lh li iq ld b gy ln lk l ll lm">export default App;</span></pre><p id="c13d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在每个react组件中，我们都必须导入react。const App行是我们的元素，最后一行导出它，正如我们已经看到的。我们现在可以在index.js文件中导入这个组件，这样我们就可以用components/ folder中组织的组件来构建整个应用程序:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="66ad" class="lh li iq ld b gy lj lk l ll lm">import "babel-polyfill";<br/>import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="3a5b" class="lh li iq ld b gy ln lk l ll lm">import App from './components/App';</span><span id="8b2f" class="lh li iq ld b gy ln lk l ll lm">ReactDOM.render(<br/>  &lt;App /&gt;,<br/>  document.getElementById('app')<br/>);</span></pre><p id="bb30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您已经在运行<code class="fe lo lp lq ld b">npm start</code>，您应该会立即看到变化。您也可以在我们的App.js中更改文本，以查看它重新加载并向您显示结果。</p><p id="8b62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，以防有人在这里询问热重装:这是很棒的东西，但我发现它实际上减慢了初始编码。只有当应用程序变得更大时，它才显示出它的价值，所以我不把它放在主设置中。</p><h2 id="8b6d" class="lh li iq bd lr ls lt dn lu lv lw dp lx kj ly lz ma kn mb mc md kr me mf mg mh bi translated">材料-用户界面</h2><p id="b95f" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">让我们不要重新发明轮子，使用已经构建和测试过的组件材料——ui给我们。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6537" class="lh li iq ld b gy lj lk l ll lm">npm i -S material-ui</span></pre><p id="3e61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一个更新的版本叫做next，但它仍然是测试版。对于这个版本，我们需要将所有东西封装在一个主题中，我们将在index.js文件中这样做:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="cd1e" class="lh li iq ld b gy lj lk l ll lm">import "babel-polyfill";<br/>import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="779b" class="lh li iq ld b gy ln lk l ll lm">import MuiThemeProvider from 'material-ui/styles/MuiThemeProvider';</span><span id="5e33" class="lh li iq ld b gy ln lk l ll lm">import App from './components/App';</span><span id="1717" class="lh li iq ld b gy ln lk l ll lm">ReactDOM.render(<br/>  &lt;MuiThemeProvider&gt;<br/>    &lt;App /&gt;<br/>  &lt;/MuiThemeProvider&gt;,<br/>  document.getElementById('app')<br/>);</span></pre><p id="4b11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的应用程序现在有了一个主题，我们可以在App.js文件中使用任何材质元素:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="bbb6" class="lh li iq ld b gy lj lk l ll lm">import React from 'react';<br/>import RaisedButton from 'material-ui/RaisedButton';</span><span id="7e13" class="lh li iq ld b gy ln lk l ll lm">const App = props =&gt; &lt;div&gt;<br/> &lt;RaisedButton label="CLICK ME" /&gt;<br/>&lt;/div&gt;</span><span id="f797" class="lh li iq ld b gy ln lk l ll lm">export default App;</span></pre><p id="e363" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们会在页面上看到一个按钮。</p><h2 id="489d" class="lh li iq bd lr ls lt dn lu lv lw dp lx kj ly lz ma kn mb mc md kr me mf mg mh bi translated">风格</h2><p id="b3b2" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">有两种主要的方式来组织样式。有些人分别为每个组件设计和加载样式，有一些postcss插件可以帮助完成这个任务。我喜欢尽可能地使用集群和组，所以我只加载一个样式文件，并让它加载其余的，这样就迫使自己也尝试重用这些类。我们将在index.js中添加一行</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="da4a" class="lh li iq ld b gy lj lk l ll lm">import './styles/main.scss';</span></pre><p id="ca2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在这个文件中导入Roboto字体，因为它在material-ui中使用:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="83fd" class="lh li iq ld b gy lj lk l ll lm"><a class="ae kw" href="http://twitter.com/import" rel="noopener ugc nofollow" target="_blank">@import</a> url(<a class="ae kw" href="http://fonts.googleapis.com/css?family=Roboto" rel="noopener ugc nofollow" target="_blank">http://fonts.googleapis.com/css?family=Roboto</a>);</span></pre><p id="2db9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我通常只是作为一个导入程序使用这个文件，只有导入行，然后按照我想要的方式组织文件夹。</p><h2 id="5325" class="lh li iq bd lr ls lt dn lu lv lw dp lx kj ly lz ma kn mb mc md kr me mf mg mh bi translated">状态管理</h2><p id="ca03" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">当用户与你的应用程序交互时，事情一件接一件地发生。当前的情况可以表示为一个json对象，我们可以称之为状态。状态封装了位置(url)、当前用户、用户点击了什么等等。我们想把状态从视图中分离出来。我们将让react处理视图(它将如何显示)并让redux处理状态(将显示什么)。如果这有点不清楚，让我们通过让它工作来解释它:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d39a" class="lh li iq ld b gy lj lk l ll lm">npm i -S redux react-redux</span></pre><p id="70f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先更改我们的App.js文件，看看我们将如何使用redux:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c918" class="lh li iq ld b gy lj lk l ll lm">import React from 'react';<br/>import PropTypes from 'prop-types';</span><span id="f799" class="lh li iq ld b gy ln lk l ll lm">import RaisedButton from 'material-ui/RaisedButton';</span><span id="e1cf" class="lh li iq ld b gy ln lk l ll lm">const App = props =&gt; &lt;div&gt;<br/> &lt;RaisedButton label={props.buttonText} onClick={props.onClick} /&gt;<br/>&lt;/div&gt;</span><span id="9612" class="lh li iq ld b gy ln lk l ll lm">App.propTypes = {<br/> buttonText: PropTypes.string.isRequired,<br/> onClick: PropTypes.func.isRequired<br/>}</span><span id="6dbc" class="lh li iq ld b gy ln lk l ll lm">App.defaultProps = {<br/> buttonText: 'defaultText',<br/> onClick: () =&gt; console.log('default click action')<br/>}</span><span id="41e1" class="lh li iq ld b gy ln lk l ll lm">export default App;</span></pre><p id="51e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了展示我们的目标，我们在这里看到了一些变化。首先，我们导入了prop-types模块，并为组件定义了道具类型。通过这种方式，我们允许下一个人(或者我们自己，当我们忘记了这段代码，需要继续工作的时候)快速了解需要传递给组件的道具。正如我们所看到的，我们需要一个字符串buttonText和一个函数onClick，它们都是必需的。如果我们不提供它们，浏览器会显示一个错误，你可以测试一下。</p><p id="fb12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们使用按钮中的道具对象，如您所见。最后，我们将定义默认道具，保存并签出我们的应用程序。您将在浏览器中看到一个带有默认文本的按钮，当您单击它时，控制台将记录我们的文本。</p><p id="fbad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种分离现在清楚地表明，我们希望让我们的组件显示事物，但是实际的文本和功能以及诸如此类的东西将在其他地方定义。将来，我们都可以更容易地找到一个突然出现的bug，重用组件或修改它们，而不需要接触应用程序的其他部分。</p><p id="5d23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们在src/中创建一个名为containers/的新文件夹。这个文件夹将充当react组件和状态之间的中间人。我们稍后会看到这种状态在哪里，以及如何利用它。在其中，我们将制作一个文件App.js:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="db4b" class="lh li iq ld b gy lj lk l ll lm">import { connect } from 'react-redux'<br/>import TheComponent from '../components/App';</span><span id="5745" class="lh li iq ld b gy ln lk l ll lm">const mapStateToProps = (state, ownProps) =&gt; {<br/>    return {<br/>     buttonText: state.text<br/>    }<br/>}</span><span id="e8dc" class="lh li iq ld b gy ln lk l ll lm">const mapDispatchToProps = (dispatch, ownProps) =&gt; {<br/>    return {<br/>        onClick: () =&gt; {<br/>          dispatch({type: 'BASIC_ACTION', text: 'new text'})<br/>        }<br/>    }<br/>}</span><span id="4daf" class="lh li iq ld b gy ln lk l ll lm">const App = connect(<br/>    mapStateToProps,<br/>    mapDispatchToProps<br/>)(TheComponent)</span><span id="3fec" class="lh li iq ld b gy ln lk l ll lm">export default App;</span></pre><p id="7035" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们现在看到，我们将使用它把道具传递给组件。这允许我们制作几个使用相同组件的不同容器，但是我们也可以使用具有不同组件的相同容器。在这个例子中，我们实际上导出了预加载了组件的容器，但是您不需要这样做。</p><p id="39ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在mapStateToProps中，我们将字符串、数字、数组和对象传递给组件。在mapDispatchToProps中，我们将函数传递给组件。通过将它们传递给connect()函数，我们将它们连接到状态对象。想象这个状态对象是这样的:<code class="fe lo lp lq ld b">{text: ‘some text’}</code>。我们可以获取这个属性，并在我们的组件中使用它，但我们也可以在onClick()函数中更新它(稍后显示，需要更多的工作:D)。我们还可以在其他组件中使用和更新状态对象。这意味着，我们只有一个信息来源，每当发生变化，应用程序中的所有组件都会收到通知，并做出相应的反应。</p><p id="e2a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这看起来很棒。我们正在慢慢地分离和优化我们的应用程序，现在我们需要理解这个dispatch()函数是如何更新状态的。为此，我们使用一种叫做减压器的东西。reducer是一个函数，它从dispatch()函数中获取数据，并决定如何创建新的状态。让我们创建一个名为reducers/的文件夹，并将index.js放入其中:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9e0f" class="lh li iq ld b gy lj lk l ll lm">import { combineReducers } from "redux";<br/>import basicReducer from './basicReducer';</span><span id="8eeb" class="lh li iq ld b gy ln lk l ll lm">export const reducers = combineReducers({<br/>  text: basicReducer<br/>});</span></pre><p id="992d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用它作为主减速器，并在其中装载我们的减速器。reducer结构定义了状态树结构，所以现在state.text将是basicReducer返回的任何内容。让我们将basicReducer.js放在同一个文件夹中:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1303" class="lh li iq ld b gy lj lk l ll lm">const basicReducer = (state = 'some text', action) =&gt; {<br/> switch(action.type) {<br/>  case 'BASIC_ACTION': return action.text<br/>  default: return state<br/> }<br/>}</span><span id="9684" class="lh li iq ld b gy ln lk l ll lm">export default basicReducer;</span></pre><p id="f6d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里看到，我们需要告诉reducer返回任何情况下的状态，除非action.type(强制属性)匹配某个字符串。稍后我们将在一个单独的文件中提取这些常量。所以现在，每当我们从容器中调用dispatch()时，reducer都会检查类型是否匹配。如果不是，保持现状。如果是，返回另一个状态，在这种情况下，新的状态变成action.text。在我们单击按钮后，状态将被更新为{text: 'new text'}，这个属性将被传递回组件，组件将依次显示这个文本。暂时不要测试，因为我们还没有设置redux。</p><p id="76aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里还要知道的一件事是，我们决不能改变reducer中的状态对象，只能用它来创建和传递一个新对象。减压器是纯函数，也就是说没有副作用。这带来了很多好处。例如，应用程序存储每个州的信息，这意味着我们可以很容易地通过用户操作来找到用户遇到的错误。</p><p id="6ff6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们现在设置redux，转到index.js</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d15b" class="lh li iq ld b gy lj lk l ll lm">import "babel-polyfill";<br/>import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="706f" class="lh li iq ld b gy ln lk l ll lm">import { Provider } from 'react-redux';<br/>import { createStore } from 'redux';<br/>import { reducers } from './reducers/index';</span><span id="72ca" class="lh li iq ld b gy ln lk l ll lm">import './styles/main.scss';</span><span id="eecb" class="lh li iq ld b gy ln lk l ll lm">import MuiThemeProvider from 'material-ui/styles/MuiThemeProvider';</span><span id="ce4c" class="lh li iq ld b gy ln lk l ll lm">import App from './containers/App';</span><span id="5eb1" class="lh li iq ld b gy ln lk l ll lm">let store = createStore(reducers);</span><span id="b274" class="lh li iq ld b gy ln lk l ll lm">ReactDOM.render(<br/> &lt;Provider store={store}&gt;<br/>    &lt;MuiThemeProvider&gt;<br/>      &lt;App /&gt;<br/>    &lt;/MuiThemeProvider&gt;<br/>   &lt;/Provider&gt;,<br/>  document.getElementById('app')<br/>);</span></pre><p id="cb76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们添加的内容:我们现在从redux导入redux和createStore，以及我们的reducers列表。存储保存状态对象。我们用我们的reducers创建它，并将整个应用程序封装在<provider>组件中，以允许任何组件访问状态对象。注意这个文件中的另一个变化:我们现在从。/containers/App，而不是。/components/App，我们可以<code class="fe lo lp lq ld b">npm start</code>我们的App:)。</provider></p><p id="afde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将看到带有默认文本的按钮，该文本来自我们的基本reducer中定义的状态。转到basicReducer.js并更改默认文本，然后看到按钮update。太好了，现在我们从状态对象那里得到了我们的道具。</p><p id="4c4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，当我们单击按钮时，文本会发生变化。让我们再来一遍这个循环:</p><ol class=""><li id="2b5a" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">我们单击组件中的按钮</li><li id="c627" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">组件调用容器中的函数</li><li id="5481" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">容器调度一个动作，并定义了一个类型(强制的)，如果需要的话还会调度一些数据，在本例中是新的文本</li><li id="08c6" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">reducers监听调度，当一个动作类型匹配一个定义的字符串时，它们返回定义的新状态。</li><li id="bbb1" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">store更新状态，并通知所有监听状态的组件</li><li id="a2f2" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">容器现在看到状态发生了变化，并将新的道具发送到按钮组件</li><li id="1af4" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">组件将使用新的道具重新渲染</li></ol><p id="bede" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，状态管理起作用了，但是我们将通过在一个单独的文件中提取所有那些动作类型来更好地组织它。在我们的src/文件夹中创建操作/文件夹。在其中，创建一个index.js文件来保存我们的常量:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="23c8" class="lh li iq ld b gy lj lk l ll lm">export default {<br/> BASIC_ACTION:'BASIC_ACTION' <br/>}</span></pre><p id="3c4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在dispatch和reducer中使用它，因此字符串中的任何更改都可以包含在内。组件/应用程序:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b4b0" class="lh li iq ld b gy lj lk l ll lm">import { connect } from 'react-redux';<br/>import actions from '../actions/';</span><span id="3308" class="lh li iq ld b gy ln lk l ll lm">import TheComponent from '../components/App';</span><span id="6b9e" class="lh li iq ld b gy ln lk l ll lm">const mapStateToProps = (state, ownProps) =&gt; {<br/>    return {<br/>     buttonText: state.text<br/>    }<br/>}</span><span id="8641" class="lh li iq ld b gy ln lk l ll lm">const mapDispatchToProps = (dispatch, ownProps) =&gt; {<br/>    return {<br/>        onClick: () =&gt; {<br/>          dispatch({type: actions.BASIC_ACTION, text: 'new text'})<br/>        }<br/>    }<br/>}</span><span id="82a2" class="lh li iq ld b gy ln lk l ll lm">const App = connect(<br/>    mapStateToProps,<br/>    mapDispatchToProps<br/>)(TheComponent)</span><span id="6451" class="lh li iq ld b gy ln lk l ll lm">export default App;</span></pre><p id="ed4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们导入整个动作集，然后使用我们想要的类型。我发现导入所有动作更容易，因为你经常需要更改它们或复制文件，我不再需要考虑导入了。请注意dispatch()函数中的变化。</p><p id="5398" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在basicReducer.js中:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="3c96" class="lh li iq ld b gy lj lk l ll lm">import actions from '../actions';</span><span id="a47c" class="lh li iq ld b gy ln lk l ll lm">const basicReducer = (state = 'some other text', action) =&gt; {<br/> switch(action.type) {<br/>  case actions.BASIC_ACTION: return action.text<br/>  default: return state<br/> }<br/>}</span><span id="1399" class="lh li iq ld b gy ln lk l ll lm">export default basicReducer;</span></pre><p id="0b61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，通过导入整个actions对象，我们可以很容易地扩展reducer。</p><p id="ca25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始时，状态管理可能看起来像是一种矫枉过正的行为，而且很容易如此，您需要定义是否需要redux。但是我发现，对状态树进行适当的维护意味着可以很容易地将逻辑分离到树的不同部分。例如，如果您的状态对象有用户属性和朋友属性，并且用户注销，您可以分派一个动作，然后让两个不同的reducers分别对其做出反应，从而将用户属性设置为{}，将朋友属性设置为[]。这使得国家管理变得轻而易举。</p><p id="60fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再说一次，这太长了。老实说，当我开始时，我没有意识到我们需要覆盖多少地面，但我被迫再次切割。希望对你有帮助，我一定会尽快完成第三部分。</p><p id="4452" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">期待掌声:D·:D·:D</p></div></div>    
</body>
</html>