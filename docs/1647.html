<html>
<head>
<title>How to generate client codes for Kubernetes Custom Resource Definitions (CRD)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Kubernetes自定义资源定义生成客户代码(CRD)</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-generate-client-codes-for-kubernetes-custom-resource-definitions-crd-b4b9907769ba?source=collection_archive---------1-----------------------#2018-12-20">https://itnext.io/how-to-generate-client-codes-for-kubernetes-custom-resource-definitions-crd-b4b9907769ba?source=collection_archive---------1-----------------------#2018-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b183f8e3684989d7a66a06411d1b2678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ETTnlPSIjPFB0Zzm"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Alejandro Escamilla 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6616" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">我们可以使用Kubernetes定制控制器来处理核心资源，这太棒了。但是，这些核心资源是不可编辑的。在许多场合，你会想介绍你自己的资源，你会完全控制它。CRD(自定义资源定义)[1]正是为此而设计的。</p><p id="1582" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，对于创建的每个CRD资源，都有许多样板代码。为了避免这种情况，我们可以使用<code class="fe lk ll lm ln b">k8s.io/code-generator</code>来自动生成CRD工作所需的所有信息、列表等。</p><blockquote class="lo lp lq"><p id="dfe4" class="kd ke lr kf b kg kh ki kj kk kl km kn ls kp kq kr lt kt ku kv lu kx ky kz la ij bi translated">注[2]: <code class="fe lk ll lm ln b"><a class="ae kc" href="https://github.com/kubernetes/code-generator" rel="noopener ugc nofollow" target="_blank">kubernetes/code-generator</a></code>是从<code class="fe lk ll lm ln b"><a class="ae kc" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/code-generator" rel="noopener ugc nofollow" target="_blank">k8s.io/code-generator</a></code>同步的。代码更改在那个位置进行，合并到<code class="fe lk ll lm ln b">k8s.io/kubernetes</code>，然后同步回<code class="fe lk ll lm ln b"><a class="ae kc" href="https://github.com/kubernetes/code-generator" rel="noopener ugc nofollow" target="_blank">kubernetes/code-generator</a></code>。</p></blockquote><p id="450b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将关注如何从头开始使用生成器。</p><p id="9f95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们假设我们想要创建一个属于foo.com组的CRD，并且在规范中有一个名为“HelloType”的带有“message”字段的类型:</p><pre class="lv lw lx ly gt lz ln ma mb aw mc bi"><span id="826d" class="md me iq ln b gy mf mg l mh mi"># Definition<br/>---<br/>apiVersion: apiextensions.k8s.io/v1beta1<br/>kind: CustomResourceDefinition<br/>metadata:  <br/>  name: hellotypes.foo.com<br/>spec:  <br/>  group: foo.com  <br/>  version: v1<br/>  scope: Namespaced  <br/>  names:    <br/>    kind: HelloType   <br/>    shortNames: ht<br/>    plural: hellotypes<br/>    singular: hellotype</span><span id="79ee" class="md me iq ln b gy mj mg l mh mi"># HelloType<br/>---<br/>apiVersion: foo.com/v1<br/>kind: HelloType <br/>metadata: <br/>  name: superman-hello<br/>spec:<br/>  message: hello world</span></pre><p id="a3db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要生成CRD资源代码，需要两个步骤。</p><ol class=""><li id="dc92" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">用适当的代码生成器标记编写类型定义代码</li><li id="856a" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">运行代码生成器，为您的客户资源自动创建客户端代码，包括clientset、informers、listers</li></ol><p id="2a8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用最新的go 1.11.2进行演练。</p><h2 id="171b" class="md me iq bd my mz na dn nb nc nd dp ne ko nf ng nh ks ni nj nk kw nl nm nn no bi translated"><strong class="ak"> CRD类型定义</strong></h2><p id="4a74" class="pw-post-body-paragraph kd ke iq kf b kg np ki kj kk nq km kn ko nr kq kr ks ns ku kv kw nt ky kz la ij bi translated">首先让我们创建一个名为<code class="fe lk ll lm ln b">github.com/superman/demo</code>的回购。我们将创建的框架文件布局如下:</p><pre class="lv lw lx ly gt lz ln ma mb aw mc bi"><span id="a78b" class="md me iq ln b gy mf mg l mh mi">pkg/<br/>├── apis<br/>    └── foo<br/>        └── v1<br/>            ├── doc.go<br/>            ├── register.go<br/>            └── types.go</span></pre><p id="18d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">foo </code>是我们正在定义的新资源组。其下的所有类型都属于<code class="fe lk ll lm ln b">foo.com</code>。</p><p id="5e76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你写的是低于1.0.0的资源版本，<code class="fe lk ll lm ln b">v1</code>下的所有代码都可以放在<code class="fe lk ll lm ln b">foo</code>目录下。其他版本遵循惯例，在<code class="fe lk ll lm ln b">foo</code>下单独创建<code class="fe lk ll lm ln b">v1</code>、<code class="fe lk ll lm ln b">v1beta1</code>、<code class="fe lk ll lm ln b">v2</code>等目录。在本例中，我们将为自定义资源创建版本1。</p><p id="2701" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">foo/v1/doc.go</code></p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="dd81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个文件提供了对全局标签的控制，这些标签将应用于相同版本中的每种类型的默认设置。标签位于注释块中。各个类型可以选择退出默认设置或使用不同的标签。这被称为“本地标签”。</p><p id="a7b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标签由两部分组成，函数名和正常传入的值。例如在<code class="fe lk ll lm ln b">+k8s:deepcopy-gen=package</code>中，<code class="fe lk ll lm ln b">deepcopy-gen</code>是为类型生成深层副本代码而调用的函数。<code class="fe lk ll lm ln b">package</code>表示在这种情况下将该功能应用于整个v1包。<code class="fe lk ll lm ln b">deepcopy-gen</code>函数和其他类似的生成器函数可以在“k8s.io/code-generator/cmd/”中找到。通过查找这些目录下的<code class="fe lk ll lm ln b">main.go</code>文件中的注释，您可以找到相关标签的解释。</p><p id="e6dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对这些代码实际上是如何生成的感兴趣，你可以进一步研究"k8s.io/gengo"。</p><p id="54b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文件中的另外两个标记指示为struct TypeMeta生成defaulter，并将组名设置为“foo.com”。</p><p id="f906" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">foo/v1/types.go</code></p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ed74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个文件中，我们创建了自定义类型“HelloType”。我们还定义了自定义的<code class="fe lk ll lm ln b">Status</code>和<code class="fe lk ll lm ln b">Spec</code>。任何自定义类型也必须有复数结构。在这种情况下，我们有“HelloTypeList”。</p><p id="b6ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们在此文件中使用的标签:</p><p id="35d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">+genclient</code>表示为该类型生成API客户端。</p><p id="2c53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code>表示为类型生成deepcopy时，使用运行时。对象接口。</p><p id="e433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">+optional</code>表示该字段是可选的。该字段的数据可以为空。</p><p id="1614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">foo/v1/register.go</code></p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="41cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">register.go</code>文件包含将我们刚刚创建的新类型注册到模式中的函数，这样API服务器就可以识别它们。</p><p id="bd19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">客户端代码生成</strong></p><p id="01c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了代码生成所需的所有文件。go 1.11+的这个过程有几个选项。</p><p id="b4d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选项1:不带Go模块</p><p id="14e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，<code class="fe lk ll lm ln b">$GOPATH/src</code>下的所有代码都不会使用Go模块。假设你把你的代码放在<code class="fe lk ll lm ln b">$GOPATH/src/github.com/superman/demo</code>里。</p><p id="3f70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后运行下面的代码来获取生成器和代码库:</p><pre class="lv lw lx ly gt lz ln ma mb aw mc bi"><span id="6eef" class="md me iq ln b gy mf mg l mh mi">$ go get k8s.io/code-generator</span><span id="594d" class="md me iq ln b gy mj mg l mh mi">$ go get k8s.io/apimachinery</span></pre><p id="15c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入<code class="fe lk ll lm ln b">$GOPATH/src/k8s.io/code-generator</code>，运行以下命令:</p><pre class="lv lw lx ly gt lz ln ma mb aw mc bi"><span id="8e2b" class="md me iq ln b gy mf mg l mh mi">$ ./generate-groups.sh all \<br/>    "<!-- -->github.com/superman/demo<!-- -->/pkg/client" \<br/>    "<!-- -->github.com/superman/demo<!-- -->/pkg/apis" \<br/>    foo:v1</span></pre><p id="789c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选项2:使用Go模块</p><p id="6076" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Go 1.11中引入了go模块。它提供了一种处理依赖关系的直观方式。您可以将您的存储库放在任何地方，包括在<code class="fe lk ll lm ln b">GOPATH</code>之外。</p><p id="b473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，目前<code class="fe lk ll lm ln b">code-generator</code>没有处理围棋模块。因此，让它工作起来有点棘手。</p><p id="0d31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种解决方案是使用docker。下面是Dockerfile文件和shell脚本的一个例子。同样，假设你的围棋模块名是<code class="fe lk ll lm ln b">github.com/superman/demo</code>。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4ab3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用上述选项之一完成代码生成后，您的<code class="fe lk ll lm ln b">pkg</code>文件夹结构将类似于:</p><pre class="lv lw lx ly gt lz ln ma mb aw mc bi"><span id="3743" class="md me iq ln b gy mf mg l mh mi">pkg/<br/>├── apis<br/>│   └── foo<br/>│       ├── register.go<br/>│       └── v1<br/>└── client<br/>    ├── clientset<br/>    │   └── versioned<br/>    ├── informers<br/>    │   └── externalversions<br/>    └── listers<br/>        └── foo</span></pre><p id="876d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新创建的<code class="fe lk ll lm ln b">client</code>文件夹包含所有生成的代码，类型的deepcopy代码也将驻留在类型旁边的<code class="fe lk ll lm ln b">v1</code>中。</p><p id="937e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，您可以像通常使用其他核心资源一样，为定制控制器使用生成的clientset和informers。</p><p id="bc96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">资源:</strong></p><ol class=""><li id="fdd9" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated"><a class="ae kc" href="https://blog.openshift.com/kubernetes-deep-dive-code-generation-customresources/" rel="noopener ugc nofollow" target="_blank"> Openshift:代码生成深度挖掘</a></li><li id="b068" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated"><a class="ae kc" href="https://medium.com/@trstringer/create-kubernetes-controllers-for-core-and-custom-resources-62fc35ad64a3" rel="noopener">创建控制器和CRD </a></li><li id="d1f1" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated"><a class="ae kc" href="https://medium.com/@cloudark/kubernetes-custom-controllers-b6c7d0668fdf" rel="noopener">创建自定义控制器</a></li><li id="2475" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">标签(非排气) :</li></ol><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="34cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">参考:</strong></p><ol class=""><li id="ecbb" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated"><a class="ae kc" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank"> Kubernetes自定义资源</a></li><li id="a251" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated"><a class="ae kc" href="https://github.com/kubernetes/code-generator" rel="noopener ugc nofollow" target="_blank">kubernetes/代码生成器</a></li></ol><p id="fb2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lr">免责声明:本文仅代表作者个人观点，绝不代表任何组织的观点。</em></p></div></div>    
</body>
</html>