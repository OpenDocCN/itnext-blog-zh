<html>
<head>
<title>Semirings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">半环</h1>
<blockquote>原文：<a href="https://itnext.io/semirings-c111b7c5b95f?source=collection_archive---------6-----------------------#2019-02-21">https://itnext.io/semirings-c111b7c5b95f?source=collection_archive---------6-----------------------#2019-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7e20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/semigroups-faf7a70da96a">半群&amp;幺半群</a>请先阅读我之前的文章。</p><p id="bb6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<strong class="jp ir">半群</strong>有一个追加<code class="fe km kn ko kp b">&lt;&gt;</code>运算。</p><p id="fe6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<strong class="jp ir">半环</strong>有两个追加操作<code class="fe km kn ko kp b">plus</code> ( <code class="fe km kn ko kp b">+</code>)和<code class="fe km kn ko kp b">times</code> ( <code class="fe km kn ko kp b">*</code>，以及两个各自的标识元素<code class="fe km kn ko kp b">zero</code>和<code class="fe km kn ko kp b">one</code>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/5d16d653b20d2b250864f4368bced03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8iDjeqFvibU_pNrS_ZyTUQ.png"/></div></div></figure><h2 id="019b" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">规则</h2><ul class=""><li id="e464" class="lv lw iq jp b jq lx ju ly jy lz kc ma kg mb kk mc md me mf bi translated">加法<strong class="jp ir">必须</strong>返回相同的值，而不管值的顺序。这就是所谓的<em class="mg">交换幺半群</em>。</li><li id="95d4" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated">与<code class="fe km kn ko kp b">zero</code>相乘<strong class="jp ir">必须</strong>返回<code class="fe km kn ko kp b">zero</code>。这就是通常所说的<em class="mg">歼灭</em>。</li><li id="5298" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated">就结合性而言，标准规则适用于+和*</li></ul><p id="d4a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于这个描述，我们可以编写一个类似这样的协议:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="115c" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">protocol</strong> Semiring {<br/>    <strong class="kp ir">static</strong> <strong class="kp ir">func</strong> + (lhs: Self, rhs: Self) -&gt; Self<br/>    <strong class="kp ir">static</strong> <strong class="kp ir">func</strong> * (lhs: Self, rhs: Self) -&gt; Self<br/>    <strong class="kp ir">static</strong> <strong class="kp ir">var</strong> zero: Self { <strong class="kp ir">get</strong> }<br/>    <strong class="kp ir">static</strong> <strong class="kp ir">var</strong> one: Self { <strong class="kp ir">get</strong> }<br/>}</span></pre><p id="627f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看这如何与<code class="fe km kn ko kp b">Int</code>类型一起工作。</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="4baa" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">extension</strong> Int: Semiring {<br/>    <strong class="kp ir">static</strong> <strong class="kp ir">let</strong> zero = 0<br/>    <strong class="kp ir">static</strong> <strong class="kp ir">let</strong> one = 1<br/>}</span></pre><p id="b0fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们可以免费获得<code class="fe km kn ko kp b">+</code>和<code class="fe km kn ko kp b">*</code>行为。</p><p id="bffe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我承认还不是很令人兴奋，我们还没有做任何标准Swift框架没有提供的事情。</p><p id="ec53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以用半环协议扩展Bool，这对我们下面的例子很有用…</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="86eb" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">extension</strong> Bool: Semiring {<br/>    <strong class="kp ir">static</strong> <strong class="kp ir">func</strong> + (lhs: Bool, rhs: Bool) -&gt; Bool {<br/>        <strong class="kp ir">return</strong> lhs || rhs<br/>    }</span><span id="12e2" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">    static</strong> <strong class="kp ir">func</strong> * (lhs: Bool, rhs: Bool) -&gt; Bool {<br/>        <strong class="kp ir">return</strong> lhs &amp;&amp; rhs<br/>    }</span><span id="5a69" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">    static</strong> <strong class="kp ir">let</strong> zero = <strong class="kp ir">false<br/>    static</strong> <strong class="kp ir">let</strong> one = <strong class="kp ir">true<br/></strong>}</span></pre><p id="6487" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个有点不一样。我们可以声明:</p><ul class=""><li id="3645" class="lv lw iq jp b jq jr ju jv jy mv kc mw kg mx kk mc md me mf bi translated"><code class="fe km kn ko kp b">+</code>与<code class="fe km kn ko kp b">||</code>相同，因为(<code class="fe km kn ko kp b">true || false</code> = <code class="fe km kn ko kp b">true</code>)和(<code class="fe km kn ko kp b">false || true = true</code> ) —通过第一个规则</li><li id="6dff" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><code class="fe km kn ko kp b">*</code>与<code class="fe km kn ko kp b">&amp;&amp;</code> ( <code class="fe km kn ko kp b">true &amp;&amp; false</code> = <code class="fe km kn ko kp b">false</code>)相同——通过第二个规则</li></ul><p id="cce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在我们有能力用<code class="fe km kn ko kp b">+</code>和<code class="fe km kn ko kp b">*</code>组合布尔值。</p><p id="629a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仍然不是很令人兴奋，所以让我们创建一个包装lambda的结构。</p><p id="b052" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是实现过程:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="f6f1" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">struct</strong> Function&lt;A, B&gt; {<br/>    <strong class="kp ir">let</strong> execute: (A) -&gt; B<br/>}</span></pre><p id="0f0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有能力把一个<code class="fe km kn ko kp b">Function</code>变成一个<code class="fe km kn ko kp b">Semiring</code>这样:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="01cd" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">extension</strong> Function: Semiring where B: Semiring {<br/>    <strong class="kp ir">static</strong> <strong class="kp ir">func</strong> + (lhs: Function, rhs: Function) -&gt; Function {<br/>        <strong class="kp ir">return</strong> Function { lhs.execute($0) + rhs.execute($0) }<br/>    }</span><span id="9fc9" class="lc ld iq kp b gy mu mr l ms mt">    <strong class="kp ir">static</strong> <strong class="kp ir">func</strong> * (lhs: Function, rhs: Function) -&gt; Function {<br/>        <strong class="kp ir">return</strong> Function { lhs.execute($0) * rhs.execute($0) }<br/>    }</span><span id="3ad8" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">    static</strong> <strong class="kp ir">var</strong> zero: Function {<br/>        <strong class="kp ir">return</strong> Function { <strong class="kp ir">_</strong> <strong class="kp ir">in</strong> S.zero }<br/>    }</span><span id="e403" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">    static</strong> <strong class="kp ir">var</strong> one: Function {<br/>        <strong class="kp ir">return</strong> Function { <strong class="kp ir">_</strong> <strong class="kp ir">in</strong> S.one }<br/>    }<br/>}</span></pre><p id="8ee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的操作符基本上是取两个<code class="fe km kn ko kp b">Function</code>对象，对每个对象应用(<code class="fe km kn ko kp b">A</code>)值以返回(<code class="fe km kn ko kp b">B1</code>和<code class="fe km kn ko kp b">B2</code>)，然后在两者之间应用操作符(<code class="fe km kn ko kp b">B1 +/* B2</code>)。</p><p id="426d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了返回<code class="fe km kn ko kp b">zero</code>和<code class="fe km kn ko kp b">one</code>值，我们可以只返回我们的<code class="fe km kn ko kp b">S</code>值定义的值。简单。</p><p id="f4e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了。这为许多强大的东西提供了基础，当与我们上面的<em class="mg">布尔</em>示例结合时，例如我们可以创建<em class="mg">谓词</em>。其中<code class="fe km kn ko kp b">S</code>是布尔值，<code class="fe km kn ko kp b">A</code>是我们要验证的表达式。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="addb" class="nf ld iq bd le ng nh ni lh nj nk nl lk nm nn no ln np nq nr lq ns nt nu lt nv bi translated">谓词—一个实际的例子:</h1><p id="23cf" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">为什么？我们已经有预测了。是的，这是真的，但是它不是<em class="mg">编译时安全的</em>，我们通常传入一个<code class="fe km kn ko kp b">String</code>来验证它可能对它所应用的对象没有意义。</p><p id="d3c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mg">编译时</em>比在<em class="mg">运行时</em>更容易发现问题，所以让我们尽可能支持<em class="mg">编译时</em>安全。</p><p id="b4ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以这样定义我们的<code class="fe km kn ko kp b">Predicate</code>:</p><p id="8cab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b"><strong class="jp ir">typealias</strong> Predicate&lt;A&gt; = Function&lt;A, Bool&gt;</code></p><p id="d861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以将取反运算符定义为:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="0bb0" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">prefix</strong> <strong class="kp ir">func</strong> ! &lt;A&gt; (p: Predicate&lt;A&gt;) -&gt; Predicate&lt;A&gt; {<br/>    <strong class="kp ir">return</strong> .init { !p.execute($0) }<br/>}</span></pre><p id="ce66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经讨论了积极和消极的情况，让我们创建一些函数…</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="5e1a" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">func</strong> equalTo&lt;T: Equatable&gt;(<strong class="kp ir">_</strong> value: T) -&gt; Predicate&lt;T&gt; {<br/>    <strong class="kp ir">return</strong> Predicate&lt;T&gt; { $0 == value }<br/>}</span><span id="341d" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">func</strong> greaterThan&lt;T: Comparable&gt;(<strong class="kp ir">_</strong> value: T) -&gt; Predicate&lt;T&gt; {<br/>    <strong class="kp ir">return</strong> Predicate&lt;T&gt; { $0 &gt; value }<br/>}</span><span id="13ec" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">func</strong> lessThan&lt;T: Comparable&gt;(<strong class="kp ir">_</strong> value: T) -&gt; Predicate&lt;T&gt; {<br/>    <strong class="kp ir">return</strong> Predicate&lt;T&gt; { $0 &lt; value }<br/>}</span></pre><p id="d9ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谓词与我们的<code class="fe km kn ko kp b">+</code>和<code class="fe km kn ko kp b">*</code>操作符结合是没有意义的，但是您会期望它们分别与<code class="fe km kn ko kp b">||</code>和<code class="fe km kn ko kp b">&amp;&amp;</code>结合。因此，让我们来定义这些运算符重载:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="1530" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">func</strong> || &lt;A&gt; (lhs: Predicate&lt;A&gt;, rhs: Predicate&lt;A&gt;) -&gt; Predicate&lt;A&gt; {<br/>    <strong class="kp ir">return</strong> lhs + rhs<br/>}</span><span id="8bc4" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">func</strong> &amp;&amp; &lt;A&gt; (lhs: Predicate&lt;A&gt;, rhs: Predicate&lt;A&gt;) -&gt; Predicate&lt;A&gt; {<br/>    <strong class="kp ir">return</strong> lhs * rhs<br/>}</span></pre><p id="7fe0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">酷，现在我们已经有了创建一些强大的谓词组合的框架。然而，目前我们的谓词是倒着读的，我们可以这样称呼它们:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="aad6" class="lc ld iq kp b gy mq mr l ms mt">lessThan(5).execute(0) // <strong class="kp ir">true</strong></span></pre><p id="efbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们颠倒一下这个操作，通过在<code class="fe km kn ko kp b">Comparable</code>上定义一个扩展，它使用一个<code class="fe km kn ko kp b">Predicate</code>来使它更具可读性。</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="8c36" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">extension</strong> Comparable {<br/>    <strong class="kp ir">func</strong> `is`(<strong class="kp ir">_</strong> predicate: Predicate&lt;Self&gt;) -&gt; Bool {<br/>        <strong class="kp ir">return</strong> predicate.execute(<strong class="kp ir">self</strong>)<br/>    }<br/>}</span></pre><blockquote class="nz oa ob"><p id="f313" class="jn jo mg jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated">注意:Comparable扩展了Equatable，所以这是我们在下面的例子中唯一需要的函数。</p></blockquote><p id="a2b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们想检查一个值是否在1和5之间，但不等于3。我们可以使用现有的函数定义如下:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="1b29" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">func</strong> between&lt;T: Comparable&gt;(_ a: T, and b: T) -&gt; Predicate&lt;T&gt; {<br/>    <strong class="kp ir">return</strong> greaterThan(a) &amp;&amp; lessThan(b)<br/>}</span><span id="52cc" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">let</strong> valid = between(1, and: 5) &amp;&amp; !equalTo(3)</span><span id="d7f6" class="lc ld iq kp b gy mu mr l ms mt">1.is(valid)     <em class="mg">// </em><strong class="kp ir"><em class="mg">false</em></strong><em class="mg"> -- outside of range<br/></em>2.is(valid)     <em class="mg">// </em><strong class="kp ir"><em class="mg">true</em></strong><em class="mg"> -- in range and not equalTo 3</em><br/>3.is(valid)     <em class="mg">// </em><strong class="kp ir"><em class="mg">false</em></strong><em class="mg"> -- is equalTo<br/></em>4.is(valid)     <em class="mg">// </em><strong class="kp ir"><em class="mg">true</em></strong><em class="mg"> -- in range and not equalTo 3</em><br/>5.is(valid)     <em class="mg">// </em><strong class="kp ir"><em class="mg">false</em></strong><em class="mg"> -- outside of range<br/></em>5.is(!valid)<em class="mg">    // </em><strong class="kp ir"><em class="mg">true</em></strong><em class="mg"> -- inverse of previous</em></span></pre><p id="1f81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以扩展Sequence来返回一个过滤后的数组，如下所示:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="c258" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">extension</strong> Sequence {<br/>    <strong class="kp ir">func</strong> filtered(by predicate: Predicate&lt;Element&gt;) -&gt; [Element] {<br/>        <strong class="kp ir">return</strong> filter(predicate.execute)<br/>    }<br/>}</span><span id="b5b9" class="lc ld iq kp b gy mu mr l ms mt">[0, 2, 3, 6].filtered(by: valid)<em class="mg"> // [2]</em></span></pre></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><blockquote class="of"><p id="d8f1" class="og oh iq bd oi oj ok ol om on oo kk dk translated">我听到你说…所以呢？我可以用闭包做同样的事情…</p></blockquote><p id="a67e" class="pw-post-body-paragraph jn jo iq jp b jq op js jt ju oq jw jx jy or ka kb kc os ke kf kg ot ki kj kk ij bi translated">虽然这是真的，但还是有一些<em class="mg">微妙的</em>差异使得<code class="fe km kn ko kp b">Predicates</code>(以及推而广之<code class="fe km kn ko kp b">Semirings</code>)更加<strong class="jp ir">强大</strong>:</p><ul class=""><li id="f5a5" class="lv lw iq jp b jq jr ju jv jy mv kc mw kg mx kk mc md me mf bi translated">我们可以很容易地<strong class="jp ir"> <em class="mg">组合</em> </strong>它们，没有任何令人困惑的函数签名。上面的<code class="fe km kn ko kp b">valid</code>变量是这种可读性的一个很好的例子。</li><li id="94a6" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated">我们可以在继承结构中的任何一点扩展<strong class="jp ir"><em class="mg"/></strong>它们，我们可以扩展<code class="fe km kn ko kp b">Semiring</code>、<code class="fe km kn ko kp b">Function</code>或<code class="fe km kn ko kp b">Predicate</code>来实现更多的方法，这些方法将向下流到我们的子类型。</li></ul><p id="4372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过实现一个简单的<code class="fe km kn ko kp b">apply</code>函数来探索第二点:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="1c66" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">extension</strong> Function {<br/>    <strong class="kp ir">func</strong> apply(<strong class="kp ir">_</strong> f: <strong class="kp ir">@escaping</strong> (A) -&gt; A) -&gt; Function&lt;A, B&gt; {<br/>        <strong class="kp ir">return</strong> .init { <strong class="kp ir">self</strong>.execute(f($0)) }<br/>    }<br/>}</span></pre><p id="5b21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以颠倒我们之前的例子来处理负数:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="0340" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">let</strong> validNegative: Predicate&lt;Int&gt; = valid.apply(-)</span><span id="4f0d" class="lc ld iq kp b gy mu mr l ms mt">(-2).is(validNegative) <em class="mg">// </em><strong class="kp ir"><em class="mg">true</em></strong></span></pre><p id="0353" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者在运行谓词之前将数字翻倍或减半:</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="dc3d" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">let</strong> validIfHalved = valid.apply { $0 / 2 }</span><span id="8157" class="lc ld iq kp b gy mu mr l ms mt">4.is(validIfHalved) <em class="mg">// validates 2</em></span><span id="477e" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">let</strong> validIfDoubled = valid.apply { $0 * 2 }</span><span id="d110" class="lc ld iq kp b gy mu mr l ms mt">2.is(validIfDoubled) <em class="mg">// validates 4</em></span></pre></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="8f28" class="nf ld iq bd le ng nh ni lh nj nk nl lk nm nn no ln np nq nr lq ns nt nu lt nv bi translated">单元测试——使用谓词</h1><p id="5477" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">现在我们可以再次扩展<code class="fe km kn ko kp b">Comparable</code>，并为<code class="fe km kn ko kp b">XCTAssertTrue</code>添加一个包装器。</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="5f76" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">extension</strong> Comparable {<br/>    <strong class="kp ir">func</strong> assert(<strong class="kp ir">_</strong> predicate: Predicate&lt;Self&gt;, file: StaticString = <strong class="kp ir">#file</strong>, line: UInt = <strong class="kp ir">#line</strong>) {<br/>        XCTAssertTrue(<strong class="kp ir">self</strong>.is(predicate), file: file, line: line)<br/>    }<br/>}<br/><strong class="kp ir">extension</strong> Sequence <strong class="kp ir">where</strong> Element: Comparable {<br/>    <strong class="kp ir">func</strong> assert(<strong class="kp ir">_</strong> predicate: Predicate&lt;Element&gt;, file: StaticString = <strong class="kp ir">#file</strong>, line: UInt = <strong class="kp ir">#line</strong>) {<br/>        <strong class="kp ir">for</strong> element <strong class="kp ir">in</strong> <strong class="kp ir">self</strong> {<br/>            element.assert(predicate, file: file, line: line)<br/>        }<br/>    }<br/>}</span></pre><p id="8875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以编写表达性的单元测试来断言我们的结果。</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="4b71" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">func</strong> testMinimumIsValid() {<br/>    2.assert(valid) <em class="mg">// runs single test using comparable method</em><br/>}</span><span id="87b6" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">func</strong> testNumbersAreValid() {<br/>    [2, 4].assert(valid) <em class="mg">// runs 2 tests using sequence method</em><br/>}</span><span id="9686" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">func</strong> testNumbersAreInvalid() {<br/>    [1, 3, 5].assert(!valid) <em class="mg">// runs 3 tests using sequence method<br/></em>}</span></pre><p id="c7eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们可以用这些扩展测试任何<code class="fe km kn ko kp b">Comparable</code>或<code class="fe km kn ko kp b">Equatable</code>类型，这也让我们可以替换<code class="fe km kn ko kp b">XCTAssertEqual</code>和<code class="fe km kn ko kp b">XCTAssertNotEqual</code>。</p><p id="e4f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需很少的努力，我们也可以扩展这个功能来处理<code class="fe km kn ko kp b">nil</code>类型，以取代<code class="fe km kn ko kp b">XCTAssertNil</code>和<code class="fe km kn ko kp b">XCTAssertNotNil</code>。</p><pre class="kr ks kt ku gt mm kp mn mo aw mp bi"><span id="da3c" class="lc ld iq kp b gy mq mr l ms mt"><strong class="kp ir">func</strong> isNil&lt;T&gt;() -&gt; Predicate&lt;T?&gt; {<br/>    <strong class="kp ir">return</strong> Predicate { $0 == <strong class="kp ir">nil</strong> }<br/>}</span><span id="b418" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">func</strong> isNotNil&lt;T&gt;() -&gt; Predicate&lt;T?&gt; {<br/>    <strong class="kp ir">return</strong> Predicate { $0 != <strong class="kp ir">nil</strong> }<br/>}</span><span id="13de" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">extension</strong> Optional {<br/>    <strong class="kp ir">func</strong> assert(<strong class="kp ir">_</strong> predicate: Predicate&lt;Wrapped?&gt;, file: StaticString = <strong class="kp ir">#file</strong>, line: UInt = <strong class="kp ir">#line</strong>) {<br/>        XCTAssertTrue(predicate.execute(<strong class="kp ir">self</strong>), file: file, line: line)<br/>    }<br/>}</span><span id="b16d" class="lc ld iq kp b gy mu mr l ms mt"><strong class="kp ir">let</strong> optional: Int? = 1<br/>optional.assert(!isNil())<br/>optional.assert(isNotNil())</span></pre></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="6f0d" class="nf ld iq bd le ng nh ni lh nj nk nl lk nm nn no ln np nq nr lq ns nt nu lt nv bi translated">结论</h1><p id="a2c3" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy nw ka kb kc nx ke kf kg ny ki kj kk ij bi translated">仅仅是半环力量的一个例子，它将帮助你编写更有表现力的代码。它展示了定义<code class="fe km kn ko kp b">Predicates</code>然后用一种简单而富于表现力的方式测试它们，同时拥有<em class="mg">编译时类型安全</em>是多么容易。</p><p id="7173" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">半环还有很多其他的应用，例如，你也可以返回<code class="fe km kn ko kp b">Sets</code>或者像另一个iOS例子一样——动画<a class="ae kl" href="https://bkase.github.io/slides/algebra-driven-design/#/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5ea7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Gist:</strong><br/><a class="ae kl" href="https://gist.github.com/cjnevin/92a253b59ff07ff00b3e85f2de284dfb" rel="noopener ugc nofollow" target="_blank">https://Gist . github . com/CJ nevin/92a 253 b 59 ff 07 ff 00 B3 e 85 F2 de 284 DFB</a></p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="3b67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考资料:<br/></strong>Brandon Kase:<a class="ae kl" href="https://github.com/bkase/slides/blob/master/animations-semirings/slides.md" rel="noopener ugc nofollow" target="_blank">https://github . com/bkase/slides/blob/master/animations-semi rings/slides . MD</a></p><p id="8240" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">布兰登·威廉姆斯:<a class="ae kl" href="https://www.fewbutripe.com/swift/math/algebra/semiring/2017/08/01/semirings-and-predicates.html" rel="noopener ugc nofollow" target="_blank">https://www . fewbutripe . com/swift/math/algebra/semi ring/2017/08/01/semi rings-and-predicates . html</a></p></div></div>    
</body>
</html>