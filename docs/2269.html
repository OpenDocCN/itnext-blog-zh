<html>
<head>
<title>7 things you need to know to get the most out of your Laravel Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Laravel模型中获得最大收益需要知道的7件事</h1>
<blockquote>原文：<a href="https://itnext.io/7-things-you-need-to-know-to-get-the-most-out-of-your-laravel-model-4f915acbb47c?source=collection_archive---------0-----------------------#2019-04-27">https://itnext.io/7-things-you-need-to-know-to-get-the-most-out-of-your-laravel-model-4f915acbb47c?source=collection_archive---------0-----------------------#2019-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a1458191bf20c8d3acc13c8efb584d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qxAJ4ByoRK5ZfKeX3HO6g.png"/></div></div></figure><div class=""/><p id="ab38" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我第一次开始在Laravel中开发时，我觉得在实现模型时，有很多事情可以用更好的方式来完成。在参加了雄辩的模型课程后，我发现了一些有趣的事情，你可以用你的模型做这些事情，让你的生活变得轻松许多。</p><p id="1328" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我会给你七个建议，每个使用Laravel的人都应该知道，以充分利用你的模型。</p><h2 id="8b2b" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">#1首先，让我们从创建一个模型开始</h2><p id="e121" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">通过命令行创建模型时，您可以指定应该在其中创建模型的文件夹。您只需在模型名称前键入文件夹的名称。当您的模型没有存储在默认的<em class="lx"> app </em>文件夹中时，这很有帮助。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="77b6" class="kz la je md b gy mh mi l mj mk">php artisan make:model Models/Product</span></pre><p id="b545" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将在<em class="lx"> app/Models </em>文件夹中创建一个<em class="lx">产品</em>模型，节省您手动将模型移动到正确文件夹的时间。</p><h2 id="3ca1" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">#2铸造属性</h2><p id="aab9" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated"><em class="lx"> $casts </em>属性提供了一种将属性转换为特定数据类型的方法。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="5377" class="kz la je md b gy mh mi l mj mk">protected $casts = [<br/>    'is_published' =&gt; 'boolean'<br/>];</span></pre><p id="b0c8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您访问<em class="lx"> is_publish </em>属性时，它现在将总是被转换为一个<em class="lx">布尔值</em>，即使它在您的数据库中被存储为一个<em class="lx">整数</em>。您可以将属性转换成许多类型，比如<em class="lx"> date </em>和<em class="lx"> datetime </em>。</p><p id="4ebd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我经常看到的一个错误是<em class="lx">日期</em>和<em class="lx">日期时间</em>属性在刀片模板中被格式化，就像这样:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c170" class="kz la je md b gy mh mi l mj mk">{{ $blog-&gt;created_at-&gt;format('Y-m-d') }}</span></pre><p id="2fe3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在一些Blade模板中，您会看到格式化在同一个变量上出现多次。这可以通过<em class="lx"> $casts </em>属性更有效地完成。</p><p id="6477" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于<em class="lx">日期</em>和<em class="lx">日期时间</em>转换，您可以指定格式:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="2659" class="kz la je md b gy mh mi l mj mk">protected $casts = [<br/>    'published_at' =&gt; <!-- -->'datetime:Y-m-d',<br/>];</span></pre><p id="0206" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将总是以<em class="lx"> Y-m-d </em>格式返回<em class="lx"> published_at </em>属性，因此您不必在刀片模板中进行任何格式化。</p><h2 id="bb51" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">#3可见性</h2><p id="b40e" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">有些属性不应该包含在模型的数组和JSON表示中，例如一个<em class="lx">密码</em>属性。这时，<em class="lx"> $hidden </em>属性开始发挥作用。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6439" class="kz la je md b gy mh mi l mj mk">protected $hidden = [<br/>    'password'<br/>];</span></pre><p id="e205" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">属性<em class="lx"> $hidden </em>相当于属性的黑名单。或者，您可以使用<em class="lx"> $visible </em>属性将属性列入白名单。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f552" class="kz la je md b gy mh mi l mj mk">protected $visible = [<br/>    'first_name',<br/>    'last_name'<br/>];</span></pre><p id="978c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当在模型上设置了<em class="lx"> $visible </em>属性时，其余的属性将自动隐藏。这就像<em class="lx">$可填充</em>和<em class="lx">$保护</em>属性一样。</p><h2 id="34ff" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">#4访问者</h2><p id="7f93" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">有时您想将多个属性合并成一个属性，或者您只想格式化一个属性。这可以通过Laravel中的访问器来完成。</p><p id="7229" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您有一个用户模型，它有一个<em class="lx">名字</em>和<em class="lx">姓氏</em>。如果你想显示全名，你可以这样做:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="7327" class="kz la je md b gy mh mi l mj mk">$this-&gt;first_name . ' ' . $this-&gt;last_name</span></pre><p id="6bbb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一种非常幼稚的方法。解决这个问题的最简单的方法是使用访问器。访问器是在模型中使用以下语法定义的方法:</p><p id="e97f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lx">获取【NameOfAttribute】属性</em></p><p id="4cb0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">全名的访问器如下所示:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3683" class="kz la je md b gy mh mi l mj mk">public function getFullNameAttribute() {<br/>    <strong class="md jf">return</strong> <!-- -->"{$this-&gt;first_name} {$this-&gt;last_name}"<!-- -->;<br/>}</span></pre><p id="c1a9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要访问访问者的全名值，您必须像这样调用它:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f596" class="kz la je md b gy mh mi l mj mk">$user-&gt;full_name</span></pre><h2 id="c998" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">#5变异体</h2><p id="0f21" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">赋值函数允许您操作值，并在雄辩模型的<em class="lx"> $attributes </em>属性上设置操作值。赋值函数和访问函数有相同的语法。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="809d" class="kz la je md b gy mh mi l mj mk">public function setLastNameAttribute($value) {<br/>    $this-&gt;attributes['last_name'] = ucfirst($value);<br/>}</span></pre><p id="52fe" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个赋值函数将对姓氏应用<em class="lx"> ucfirst </em>函数，并将结果存储在<em class="lx"> $attributes </em>属性中。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="4a04" class="kz la je md b gy mh mi l mj mk">$user-&gt;last_name = 'jones'; // Will result in `Jones`</span></pre><h2 id="9b43" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">#6追加值</h2><p id="a771" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">当一个模型有访问器和关系时，默认情况下它们不会被添加到模型的数组和JSON表示中。为此，您必须将访问器或关系添加到模型的<em class="lx"> $appends </em>属性中。现在让我们继续使用<em class="lx"> getFullNameAttribute </em>访问器的例子:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="bfdc" class="kz la je md b gy mh mi l mj mk">$appends = [<br/>    'full_name'<br/>];</span></pre><p id="f612" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lx">注意:<br/>添加到$appends属性的访问器在snake case中被引用，即使该访问器是在camel case中定义的。</em></p><p id="f760" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们假设用户模型与博客模型有一对多的关系。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f477" class="kz la je md b gy mh mi l mj mk">public function blogs() {<br/>    return $this-&gt;hasMany(App\Blog::class);<br/>}</span></pre><p id="761a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要将博客添加到模型中，只需将它们添加到<em class="lx"> $appends </em>属性中:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="63f0" class="kz la je md b gy mh mi l mj mk">$appends = [<br/>    'full_name',<br/>    'blogs'<br/>];</span></pre><p id="f721" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也可以指定应该附加的属性。例如，如果您只想将博客id<em class="lx">和标题<em class="lx">追加到模型中。</em></em></p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="2ffe" class="kz la je md b gy mh mi l mj mk">$appends = [<br/>    'full_name',<br/>    'blogs:id,title'<br/>];</span></pre><h2 id="1c68" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">#7触摸</h2><p id="2bfd" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">当一个模型与另一个模型有<em class="lx">隶属于</em>或<em class="lx">隶属于任何</em>关系时，在这种情况下，一个属于博客的评论，在某些情况下，当子模型被更新时，更新父模型的时间戳是有帮助的。这可以通过将关系添加到<em class="lx"> $touches </em>属性来完成。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="58eb" class="kz la je md b gy mh mi l mj mk">class Comment extends Model<br/>{<br/>    protected $touches = ['blog'];<br/><br/>    public function blog()<br/>    {<br/>        return $this-&gt;belongsTo(App\Blog::class);<br/>    }<br/>}</span></pre><p id="4fa0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当评论模型得到更新时，这也将自动更新博客的<em class="lx"> updated_at </em>属性。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="031e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我想与你分享的七件事，以充分利用你的模型。如果这些建议对你有所帮助，请务必看看我的其他帖子。如果您有任何反馈、问题或希望我写另一个与Laravel相关的主题，请随时留下您的评论。</p></div></div>    
</body>
</html>