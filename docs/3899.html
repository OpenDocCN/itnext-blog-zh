<html>
<head>
<title>Vue Async Components: Props and Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue异步组件:道具和测试</h1>
<blockquote>原文：<a href="https://itnext.io/vue-async-components-props-and-testing-cbcb1e5f89a5?source=collection_archive---------0-----------------------#2020-03-22">https://itnext.io/vue-async-components-props-and-testing-cbcb1e5f89a5?source=collection_archive---------0-----------------------#2020-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cde6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何测试并将属性传递给异步加载(async)组件的加载和错误对应项。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4be3b353ba862b3a40c22e985324d0c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oEOWCcegI4j1Hvgfkat3bw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">空巢。版权所有诺拉布朗。</figcaption></figure><p id="1134" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vue异步组件的基本用法已经被很好地记录下来了。然而，我找不到两个基本问题的答案:</p><ul class=""><li id="62d2" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">如何(手动)测试加载和错误组件？</li><li id="6042" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">如何将道具传递给加载和错误组件，使其更具重用性？</li></ul><p id="626f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会在这个帖子里分享可能的答案。</p><h1 id="de0d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Vue异步组件刷新程序</h1><p id="4bf3" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">正如我提到的，Vue 中异步组件的<a class="ae ms" href="https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components" rel="noopener ugc nofollow" target="_blank">基础在文档中有很好的介绍，其他地方</a>的<a class="ae ms" href="https://vueschool.io/articles/vuejs-tutorials/async-vuejs-components/" rel="noopener ugc nofollow" target="_blank">也有介绍。但是提醒一下:当你有一个大的(有点)组件，或者a)你的应用程序中不需要，或者b)在给定的会话中可能永远不需要时，异步组件是有用的。将异步组件与Webpack(处理代码分割)一起使用意味着您的组件可以在需要的时候被延迟加载。</a></p><p id="948a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，异步<em class="mt">路由</em>与异步<em class="mt">组件</em>相关但不同。尽管异步组件使异步路由成为可能，但每种路由的用例略有不同。一个<code class="fe mu mv mw mx b">/profile</code>页面是一个由Vue路由器处理的<a class="ae ms" href="https://router.vuejs.org/guide/advanced/lazy-loading.html" rel="noopener ugc nofollow" target="_blank">异步<em class="mt">路由</em>的良好候选:它有自己的url，并且可能永远不会在用户会话中被访问。带有表单的弹出窗口是异步组件的一个很好的候选:它没有自己的路径，当应用程序第一次加载时也不需要。</a></p><p id="74ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(补充说明:一个路由只接受一个组件，所以你通常不能像异步组件那样提供加载和错误组件，但是<a class="ae ms" href="https://medium.com/bauer-kirch/how-to-make-vue-router-play-nice-with-loading-states-3f2ff6bfd633" rel="noopener">这篇文章</a>基于<a class="ae ms" href="https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/890438c3b898d6ed921fd2d0e3b84f2fe7162d89/src/router/routes.js#L99" rel="noopener ugc nofollow" target="_blank">这篇文章</a>展示了如何解决这个限制。)</p><h1 id="38c4" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">如何测试加载和错误组件？</h1><p id="b4fb" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">你已经在你的应用中找到了一个非常适合异步加载的组件，并相应地编写代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">异步组件的基本用法，包括加载和错误组件</figcaption></figure><p id="3c9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将在加载期间或出现故障时显示的组件是静态导入的。然后，为了延迟加载我们的子组件，我们传递一个返回对象的函数，该对象具有您在上面的代码中看到的属性。</p><p id="9c96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了。当我们查看应用程序时，眼睛盯着网络选项卡，当我们单击按钮时，我们会看到子组件的JavaScript按需加载，并且子组件会显示出来。但是如何测试加载和错误组件呢？</p><p id="4633" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以像这样使用一个小助手函数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用一个助手函数来延迟组件的加载</figcaption></figure><p id="d159" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码中有两点发生了变化。首先，我们添加了助手函数<code class="fe mu mv mw mx b">asyncComponentTester</code>。它需要两个参数:</p><ul class=""><li id="fb74" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir"> importPromise </strong>，由<code class="fe mu mv mw mx b"><a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">import()</a></code> <a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">函数</a>返回的承诺</li><li id="f80c" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir">延迟</strong>，一个延迟，它是在包装承诺解析和来自<code class="fe mu mv mw mx b">import()</code>的原始承诺被返回之前的时间量，以毫秒为单位。</li></ul><p id="8a34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二，我们不直接称呼<code class="fe mu mv mw mx b">import('@/components/ChildComponent)</code>，而是称呼我们的新助手:<code class="fe mu mv mw mx b">asyncComponentTester(import('@/components/ChildComponent), 3000)</code>。</p><p id="8323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过操作<code class="fe mu mv mw mx b">delay</code>、<code class="fe mu mv mw mx b">timeout</code>和<code class="fe mu mv mw mx b">latency</code>，我们可以显示加载和错误组件。例如，使用以下值:</p><ul class=""><li id="b745" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><code class="fe mu mv mw mx b">delay</code> : 200</li><li id="9087" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><code class="fe mu mv mw mx b">timeout</code> : 1500</li><li id="de13" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><code class="fe mu mv mw mx b">latency</code> : 2000年</li></ul><p id="3fa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">200毫秒后，将显示LoadingState组件。(请记住，<code class="fe mu mv mw mx b">delay</code>是显示加载组件之前的时间量，这可以避免加载程序出现奇怪的闪烁，如果它立即显示，几毫秒后就会被真正的组件替换)。1500ms后，将显示ErrorState组件，因为我们的帮助器函数等待2000ms才能解决。</p><p id="ddfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这个沙盒里玩它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na mz l"/></div></figure><p id="1315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您将<code class="fe mu mv mw mx b">latency</code>更改为1000毫秒，您现在应该会看到加载组件在200毫秒后出现，然后是子组件在800毫秒后出现。</p><p id="ca36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要明确的是，这些代码更改只是为了测试目的，而不是为了生产。同样，如果你使用了大量的异步组件，你可能会把助手功能放在某个中心位置，或者把它合并到自动化测试中。</p><h1 id="186a" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">如何将道具传递给加载和错误组件？</h1><p id="138f" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">你要做的下一件事是给用户提供比简单的“加载中…”或“错误！”更少的一般性消息。同时，您不希望使LoadingState和ErrorState组件特定于这个特定的上下文。如果您的应用程序中有另一个异步组件，重用它们会很好。听起来像是道具的工作！</p><p id="d72f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是情况下哪里能传道具呢？子组件当然接受道具，这很简单。但是似乎没有任何方法可以为加载和错误组件提供道具。没问题——事实证明，它们实际上与子组件本身收到了相同的道具。所以，我们可以这样做:</p><pre class="km kn ko kp gt nb mx nc nd aw ne bi"><span id="3a89" class="nf lq iq mx b gy ng nh l ni nj">&lt;child-component <br/>  v-if="showChild" <br/>  message="I am the child component."<br/>  loadingMessage="Looking for child component..."<br/>  errorMessage="The child component is unavailable."&gt;<br/>&lt;/child-component&gt;</span></pre><p id="3f53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">起初，这让我觉得有点恶心。但事实上，这些特定的错误和加载消息是特定于这个子组件的，甚至可能是这个子组件的实例，所以以这种方式传递它们似乎没问题。</p><p id="0e0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mu mv mw mx b">LoadingState</code>和<code class="fe mu mv mw mx b">ErrorState</code>组件应该尽可能的轻，因为这项工作的重点是通过延迟加载较重的组件来初始化下载大小。类似于:</p><pre class="km kn ko kp gt nb mx nc nd aw ne bi"><span id="0417" class="nf lq iq mx b gy ng nh l ni nj">&lt;template functional&gt;<br/>  &lt;div&gt;&lt;b&gt;Error: {{ props.errorMessage }}&lt;/b&gt;&lt;/div&gt;<br/>&lt;/template&gt;</span><span id="b584" class="nf lq iq mx b gy nk nh l ni nj">&lt;script&gt;<br/>  export default {<br/>    name: 'ErrorState',<br/>    props: ['errorMessage']<br/>  }<br/>&lt;/script&gt;</span></pre><h1 id="b8d5" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="1a9c" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">记住，loading和error属性是关于异步加载<em class="mt">组件本身的——一旦组件被加载，它们与任何API调用或组件可能进行的其他异步操作是分开的。</em></p><p id="480a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的话，你的应用程序用户将永远保持良好、快捷的连接，永远不会看到这些精心制作的信息，永远不知道你为他们提供友好的微型副本付出了多少爱。但是，抱最好的希望，做最坏的打算。</p></div></div>    
</body>
</html>