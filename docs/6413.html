<html>
<head>
<title>Event-Driven Architectures with Kafka and Java Spring-Boot — Revision 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kafka和Java Spring-Boot的事件驱动架构—修订版1</h1>
<blockquote>原文：<a href="https://itnext.io/event-driven-architectures-with-kafka-and-java-spring-boot-revision-1-c0d43d103ee7?source=collection_archive---------0-----------------------#2021-11-11">https://itnext.io/event-driven-architectures-with-kafka-and-java-spring-boot-revision-1-c0d43d103ee7?source=collection_archive---------0-----------------------#2021-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d51c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">入门所需的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40a162fd76813e9f13d177f27b27b2a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uurtocG3tqSL2zVqM7UGFw.png"/></div></div></figure><p id="6fab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">欢迎来到我的文章<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/event-driven-architectures-with-kafka-and-java-spring-boot-6ded048e86f3">“使用Kafka和Java Spring-Boot的事件驱动架构”</a>的第一版。</p><p id="436f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/event-driven-architectures-with-kafka-and-java-spring-boot-6ded048e86f3">原文</a>中发出的事件是一个字符串。虽然这对于许多用例来说已经足够了，但是我的大多数用例都需要发送一个自定义类型的对象。</p><p id="f3e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我修改了代码和教程，使用JSON的对象序列化和反序列化。</p><p id="19e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，还有其他方法来序列化和去序列化数据。一个非常受欢迎的例子是Avro。</p><p id="e34c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然条条大路通罗马，但让我们从一条路开始，继续本教程。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="6dcb" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">介绍</h2><p id="f287" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">事件驱动架构在过去几年里已经成为一种事物，Kafka是工具方面事实上的标准。</p><p id="0cde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章提供了一个事件驱动架构的完整示例，它是用两个通过Kafka通信的Java Spring-Boot服务实现的。</p><p id="0ca3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程的主要目标是提供一个工作示例，而不涉及太多的细节，在我看来，这不必要地分散了尽快启动和运行“某些东西”的主要任务的注意力。</p><p id="15f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们主要有几个构件</p><ul class=""><li id="0483" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">基础设施(卡夫卡，动物园管理员)</li><li id="c557" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">生产者(Java Spring-Boot服务)</li><li id="e1ae" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">消费者(Java Spring-Boot服务)</li></ul><p id="4a1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生产者的唯一任务是定期向卡夫卡发送一个事件。这个事件只是带有一个时间戳。消费者的工作是监听这个事件并打印时间戳。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/17ff715e3da17157a8c1b8ea7c1e40bd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*xiYifExQ9NGRVDJz7qBoRA.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">卡夫卡</figcaption></figure><p id="fab6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">整个实现产生了下面的项目结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/7a0e4fde745f383210396da49e9ef4ed.png" data-original-src="https://miro.medium.com/v2/format:webp/1*YsxBGgQXbbwwczDOYyAShg.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">项目结构</figcaption></figure><p id="4db0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://github.com/twissmueller/event-driven-architectures/tree/main/java-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">完整的项目代码可以从这里下载。</strong> </a></p><p id="801a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可以在命令行上构建，如下所述，或者导入到IDE中，例如IntelliJ。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/829cf9544b2d18306a8e4c8590348128.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Ds3uNYk0mUMSaNJwsAdo_A.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">IntelliJ项目</figcaption></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="1327" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">基础设施</h2><p id="f529" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">尽管有这些服务，但要让基于事件的架构正常运行，只需要两个组件:Kafka和Zookeeper。</p><p id="229a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看本教程末尾的参考资料部分，获得两者的链接。</p><p id="4a1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管卡夫卡是处理事件的“主要”部分，但出于几个原因，动物园管理员是需要的。来自动物园管理员网站:</p><blockquote class="np nq nr"><p id="474b" class="ku kv ns kw b kx ky ju kz la lb jx lc nt le lf lg nu li lj lk nv lm ln lo lp im bi translated">ZooKeeper是一个集中式服务，用于维护配置信息、命名、提供分布式同步和提供组服务。</p></blockquote><p id="f432" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是启动和运行的<code class="fe nw nx ny nz b">docker-compose.yml</code>:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="930c" class="ly lz it nz b gy oe of l og oh">version: '3'<br/><br/>services:<br/><br/>    kafka:<br/>      image: wurstmeister/kafka<br/>      container_name: kafka<br/>      ports:<br/>        - "9092:9092"<br/>      environment:<br/>        - KAFKA_ADVERTISED_HOST_NAME=127.0.0.1<br/>        - KAFKA_ADVERTISED_PORT=9092<br/>        - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181<br/>      depends_on:<br/>        - zookeeper<br/><br/>    zookeeper:<br/>      image: wurstmeister/zookeeper<br/>      ports:<br/>        - "2181:2181"<br/>      environment:<br/>        - KAFKA_ADVERTISED_HOST_NAME=zookeeper</span></pre><p id="4045" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当这一切就绪时，只需要实现“业务领域”的两个Java服务。很简单:发送和接收时间戳。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="26c1" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">代码设置</h2><p id="cdf7" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">有一个非常实用的网站，在那里你可以创建并初始化一个包含所有必需依赖项的Spring项目。</p><p id="9359" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我创建了生产者应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a1059868bba29bd22bdaa15194cd7874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLhHufiVUd7anaXRKY28IQ.png"/></div></div></figure><p id="3d47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来是消费者应用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/2dd060979d6637c9fc59767eceda80a5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*26F5-PHe_ZlCKCadKpusOA.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">消费者初始化</figcaption></figure><p id="66f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我已经添加了对“Apache Kafka的Spring”的依赖。</p><p id="c160" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下载并解压缩项目文件后，是时候开始实现了。</p><p id="8735" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于生产者和消费者，每个人需要4个文件:</p><ul class=""><li id="87cd" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">应用程序</li><li id="86ab" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">配置</li><li id="4175" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">生产者，分别是消费者</li><li id="67ac" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">属性文件</li></ul><p id="c946" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在接下来的两章中解释了这些文件的内容。我不打算在这里深入讨论细节，因为本教程并不意味着是一个深入的卡夫卡教程。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="967d" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">生产者</h2><p id="2874" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如上所述，生产者正在“生产”带有时间戳的事件，并通过Kafka将它们发送给有兴趣接收它们的每个人。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="b27a" class="ly lz it nz b gy oe of l og oh">package net.wissmueller.kafkatutorial.producer;<br/><br/>import java.time.ZonedDateTime;<br/><br/>public class TimestampEvent {<br/>  private ZonedDateTime timestamp;<br/><br/>  public TimestampEvent(ZonedDateTime timestamp) {<br/>    this.timestamp = timestamp;<br/>  }<br/><br/>  public ZonedDateTime getTimestamp() {<br/>    return timestamp;<br/>  }<br/><br/>  public void setTimestamp(ZonedDateTime timestamp) {<br/>    this.timestamp = timestamp;<br/>  }<br/>}</span></pre><p id="9f4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一切都从<code class="fe nw nx ny nz b">ProducerApplication.java</code>中的应用程序类开始，它或多或少没有被改动。仅添加了生产者本身所需的<code class="fe nw nx ny nz b">@EnableScheduling</code>-注释。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="d5aa" class="ly lz it nz b gy oe of l og oh">package net.wissmueller.kafkatutorial.producer;<br/><br/>// imports ...<br/><br/>@SpringBootApplication<br/>@EnableScheduling<br/>public class ProducerApplication {<br/><br/>  public static void main(String[] args) {<br/>    SpringApplication.run(ProducerApplication.class, args);<br/>  }<br/><br/>}</span></pre><p id="695e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一些配置是需要的，我已经把它放进了<code class="fe nw nx ny nz b">ProducerConfiguration.java</code>。</p><p id="228d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nw nx ny nz b">producerFactory()</code>中，我们指定:</p><ul class=""><li id="5aae" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">哪里可以找到服务器:<code class="fe nw nx ny nz b">BOOTSTRAP_SERVERS_CONFIG</code></li><li id="a4e4" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">事件键的序列:<code class="fe nw nx ny nz b">KEY_SERIALIZER_CLASS_CONFIG</code></li><li id="2687" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">事件值的序列:<code class="fe nw nx ny nz b">VALUE_SERIALIZER_CLASS_CONFIG</code></li><li id="4d7a" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">卡夫卡群的ID:<code class="fe nw nx ny nz b">GROUP_ID_CONFIG</code></li></ul><p id="1cc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要发送事件的主题。因此我们有了返回<code class="fe nw nx ny nz b">NewTopic</code>的<code class="fe nw nx ny nz b">timestampTopic()</code>。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="cc6e" class="ly lz it nz b gy oe of l og oh">package net.wissmueller.kafkatutorial.producer;<br/><br/>// imports ...<br/><br/>public class ProducerConfiguration {<br/><br/>  @Bean<br/>  public ProducerFactory&lt;String, TimestampEvent&gt; producerFactory() {<br/>    var props = new HashMap&lt;String, Object&gt;();<br/>    props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");<br/>    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);<br/>    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);<br/>    props.put(ConsumerConfig.GROUP_ID_CONFIG, "tutorialGroup");<br/>    return new DefaultKafkaProducerFactory&lt;&gt;(props);<br/>  }<br/><br/>  @Bean<br/>  public KafkaTemplate&lt;String, TimestampEvent&gt; kafkaTemplate() {<br/>    return new KafkaTemplate&lt;&gt;(producerFactory());<br/>  }<br/><br/>  @Bean<br/>  public NewTopic timestampTopic() {<br/>    return TopicBuilder.name("timestamp")<br/>                       .build();<br/>  }<br/>}</span></pre><p id="7204" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">制作人本身在<code class="fe nw nx ny nz b">KafkaProducer.java</code>:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="f390" class="ly lz it nz b gy oe of l og oh">package net.wissmueller.kafkatutorial.producer;<br/><br/>// imports ...<br/><br/>@Component<br/>public class KafkaProducer {<br/>  private static final Logger log = LoggerFactory.getLogger(KafkaProducer.class);<br/><br/>  @Autowired<br/>  private KafkaTemplate&lt;String, TimestampEvent&gt; kafkaTemplate;<br/><br/>  @Scheduled(fixedRate = 5000)<br/>  public void reportCurrentTime() {<br/>    var event = new TimestampEvent(ZonedDateTime.now());<br/>    kafkaTemplate.send("timestamp", event);<br/>    log.info("Sent: {}", event.getTimestamp().toString());<br/>  }<br/>}</span></pre><p id="1791" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该类用<code class="fe nw nx ny nz b">KafkaTemplate</code>初始化。</p><p id="d931" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nw nx ny nz b">reportCurrentTime()</code>中，时间戳每5秒被发送到Kafka，这是通过<code class="fe nw nx ny nz b">@Scheduled</code>注释实现的。这仅在应用程序类中设置了<code class="fe nw nx ny nz b">@EnableScheduling</code>-注释时有效。</p><p id="93b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是制作人的全部。对消费者而言…</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="b52b" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">消费者</h2><p id="2694" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">是时候接收由生产者发出的带有时间戳的事件了。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="4570" class="ly lz it nz b gy oe of l og oh">package net.wissmueller.kafkatutorial.consumer;<br/><br/>import java.time.ZonedDateTime;<br/><br/>public class TimestampEvent {<br/>  private ZonedDateTime timestamp;<br/><br/>  public TimestampEvent() {}<br/><br/>  public ZonedDateTime getTimestamp() {<br/>    return timestamp;<br/>  }<br/><br/>  public void setTimestamp(ZonedDateTime timestamp) {<br/>    this.timestamp = timestamp;<br/>  }<br/>}</span></pre><p id="d6c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与生产者一样，入口点是<code class="fe nw nx ny nz b">ConsumerApplication.java</code>中的应用程序类。这一次完全不变，就像它已经由Spring Initializr生成一样。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="c870" class="ly lz it nz b gy oe of l og oh">package net.wissmueller.kafkatutorial.consumer;<br/><br/>// imports ...<br/><br/>@SpringBootApplication<br/>public class ConsumerApplication {<br/><br/>  public static void main(String[] args) {<br/>    SpringApplication.run(ConsumerApplication.class, args);<br/>  }<br/><br/>}</span></pre><p id="2aa5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">配置在<code class="fe nw nx ny nz b">ConsumerConfiguration.java</code>中，我们模拟生产者，</p><p id="80e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nw nx ny nz b">consumerFactory()</code>我们指定:</p><ul class=""><li id="33f2" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">去哪里找服务器:<code class="fe nw nx ny nz b">BOOTSTRAP_SERVERS_CONFIG</code></li><li id="03a3" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">事件关键字的描述符:<code class="fe nw nx ny nz b">KEY_DESERIALIZER_CLASS_CONFIG</code></li><li id="7639" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">事件值的描述符:<code class="fe nw nx ny nz b">VALUE_DESERIALIZER_CLASS_CONFIG</code></li><li id="dd77" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">卡夫卡群的ID:<code class="fe nw nx ny nz b">GROUP_ID_CONFIG</code></li></ul><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="0a5d" class="ly lz it nz b gy oe of l og oh">package net.wissmueller.kafkatutorial.consumer;<br/><br/>// imports ...<br/><br/>public class ConsumerConfiguration {<br/><br/>  @Bean<br/>  public ConsumerFactory&lt;String, TimestampEvent&gt; consumerFactory() {<br/>    var timestampEventDeserializer = new JsonDeserializer&lt;TimestampEvent&gt;(TimestampEvent.class);<br/>    timestampEventDeserializer.setRemoveTypeHeaders(false);<br/>    timestampEventDeserializer.addTrustedPackages("*");<br/>    timestampEventDeserializer.setUseTypeMapperForKey(true);<br/><br/>    var props = new HashMap&lt;String, Object&gt;();<br/>    props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");<br/>    props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);<br/>    props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);<br/>    props.put(ConsumerConfig.GROUP_ID_CONFIG, "tutorialGroup");<br/><br/>    return new DefaultKafkaConsumerFactory&lt;&gt;(props, new StringDeserializer(), timestampEventDeserializer);<br/>  }<br/><br/>  @Bean<br/>  public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, TimestampEvent&gt;&gt; kafkaListenerContainerFactory() {<br/>    var factory = new ConcurrentKafkaListenerContainerFactory&lt;String, TimestampEvent&gt;();<br/>    factory.setConsumerFactory(consumerFactory());<br/>    return factory;<br/>  }<br/><br/>  @Bean<br/>  public NewTopic timestampTopic() {<br/>    return TopicBuilder.name("timestamp")<br/>                       .build();<br/>  }<br/>}</span></pre><p id="8199" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后但并非最不重要的是，我们有<code class="fe nw nx ny nz b">KafkaConsumer.java</code>中的消费者。我们只需要通过使用<code class="fe nw nx ny nz b">@KafkaListener</code> -topic和动作来指定一个主题的监听器。在这种情况下，时间戳只是被记录。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="e558" class="ly lz it nz b gy oe of l og oh">package net.wissmueller.kafkatutorial.consumer;<br/><br/>// imports ...<br/><br/>@Component<br/>public class KafkaConsumer {<br/>  private static final Logger log = LoggerFactory.getLogger(KafkaConsumer.class);<br/><br/>  @KafkaListener(topics = "timestamp", containerFactory = "kafkaListenerContainerFactory")<br/>  void listener(TimestampEvent event) {<br/>    log.info("Received: {}", event.getTimestamp()<br/>                                  .toString());<br/>  }<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="f61e" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">运行示例代码</h2><p id="9503" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">是时候运行一切了。请记住以下项目结构:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="42b3" class="ly lz it nz b gy oe of l og oh">code/<br/>- docker-compose.yml<br/>- producer/<br/>-- pom.xml<br/>-- ...<br/>- consumer/<br/>-- pom.xml<br/>-- ...</span></pre><p id="26d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在目录<code class="fe nw nx ny nz b">code</code>中，卡夫卡和动物园管理员正在通过<code class="fe nw nx ny nz b">docker-compose</code>启动:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="95d2" class="ly lz it nz b gy oe of l og oh">docker-compose up -d</span></pre><p id="df49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">切换到<code class="fe nw nx ny nz b">producer</code>-目录，服务开始于:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="e3fd" class="ly lz it nz b gy oe of l og oh">mvn spring-boot:run</span></pre><p id="bf67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，在新的终端窗口中，切换到<code class="fe nw nx ny nz b">consumer</code>目录，以同样的方式启动服务:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="ec8f" class="ly lz it nz b gy oe of l og oh">mvn spring-boot:run</span></pre><p id="f8b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，你应该能看到类似这样的东西。左边是生产者的日志输出，右边是消费者的日志输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/766c8cae15285d05bb7ed6c0c5ce3f39.png" data-original-src="https://miro.medium.com/v2/format:webp/1*c8qbYR22GsU6qU-w_aSKWA.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">终端输出</figcaption></figure><p id="7ab3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于如何使用Kafka和Java Spring-Boot创建事件驱动架构的介绍性教程到此结束。</p><p id="26ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完整的项目代码可以从这里下载。 </p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><ul class=""><li id="c2f0" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">如果你喜欢这个，请<a class="ae lq" href="https://twissmueller.medium.com/" rel="noopener"> <strong class="kw iu">跟我上媒</strong> </a></li><li id="74fb" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">给我买杯咖啡让我继续前进</li><li id="1f29" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">支持我和其他媒体作者<a class="ae lq" href="https://twissmueller.medium.com/membership" rel="noopener"> <strong class="kw iu">在这里报名</strong> </a></li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="2654" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">资源</h2><ul class=""><li id="90d7" class="mw mx it kw b kx mr la ms ld oj lh ok ll ol lp nb nc nd ne bi translated"><a class="ae lq" href="https://kafka.apache.org" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡</a></li><li id="0f9f" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://zookeeper.apache.org" rel="noopener ugc nofollow" target="_blank">阿帕奇动物园管理员</a></li><li id="aff0" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://reflectoring.io/spring-boot-kafka/" rel="noopener ugc nofollow" target="_blank">用卡夫卡和Spring Boot </a></li><li id="d1c1" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae lq" href="https://thepracticaldeveloper.com/spring-boot-kafka-config/" rel="noopener ugc nofollow" target="_blank"> Spring Boot与卡夫卡——实例</a></li></ul></div></div>    
</body>
</html>