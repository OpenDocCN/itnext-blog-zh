<html>
<head>
<title>Container Runtime in Rust — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的容器运行时—第一部分</h1>
<blockquote>原文：<a href="https://itnext.io/container-runtime-in-rust-part-i-7bd9a434c50a?source=collection_archive---------2-----------------------#2021-09-18">https://itnext.io/container-runtime-in-rust-part-i-7bd9a434c50a?source=collection_archive---------2-----------------------#2021-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7168" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序结构和“监禁”容器</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/beae70d100017e90aa260a4cb29b768a.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*0uSwr_QKhg_5YHRpzTL7qg.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">锁定容器进程</figcaption></figure><p id="2e4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的第0部分中，我们已经看到了进程如何获得它们所看到的资源的受限视图。这部分将解释容器运行时如何为容器进程准备和创建一个隔离的环境。</p><p id="2879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本部分的先决条件是了解Linux文件系统如何工作，什么是inodes、符号链接和挂载点。</p><p id="c39d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的完整源代码可以在<a class="ae kx" href="https://github.com/penumbra23/pura" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="372c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们从OCI规范开始。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="9f2b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">操作</h1><p id="16a8" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在撰写本文时，OCI规范定义了最少五个标准操作:创建、启动、状态、删除和终止。考虑到这一点，使用<a class="ae kx" href="https://crates.io/crates/clap" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> clap </strong> </a>库，我们可以很快生成一个漂亮的CLI界面。它应该是这样的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8cc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将主要关注<strong class="jp ir">创建</strong>和<strong class="jp ir">启动</strong>命令，因为这是运行<code class="fe mk ml mm mn b">docker run</code>命令时最重要的两个命令。</p><p id="201a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包目录包含<strong class="jp ir"> config.json </strong>文件，该文件保存了用于创建容器的所有元数据:</p><ul class=""><li id="78df" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><em class="mx">OCI version</em>-OCI规范的版本</li><li id="2bf0" class="mo mp iq jp b jq my ju mz jy na kc nb kg nc kk mt mu mv mw bi translated"><em class="mx">进程</em>——容器执行的自定义进程(shell、数据库、web app、gRPC服务等)。)以及必要的参数和环境变量</li><li id="bcb9" class="mo mp iq jp b jq my ju mz jy na kc nb kg nc kk mt mu mv mw bi translated"><em class="mx">根目录</em>——容器根目录的子目录路径</li><li id="e683" class="mo mp iq jp b jq my ju mz jy na kc nb kg nc kk mt mu mv mw bi translated">容器的<em class="mx">主机名</em></li><li id="2fc2" class="mo mp iq jp b jq my ju mz jy na kc nb kg nc kk mt mu mv mw bi translated"><em class="mx">挂载点</em> -容器内挂载点列表</li></ul><p id="2411" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，OCI规范包含一个特定于平台的部分，支持基于运行容器的平台的自定义设置。因为我们只查看Linux容器，所以<strong class="jp ir"><em class="mx">Linux</em></strong><em class="mx"/>部分将对我们有用。</p><p id="cff8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> create </strong>命令带有容器ID和包路径。其目的是初始化容器进程，挂载所有必要的子目录，将容器“监禁”在<strong class="jp ir">根</strong>内。<strong class="jp ir"> path </strong>文件夹，更新容器中的所有系统变量(env，hostname，user，group)，执行几个钩子(我们稍后会研究这个)，给容器本身分配唯一的ID，然后等待<strong class="jp ir"> start </strong>命令被触发。在<strong class="jp ir"> create </strong>命令完成后，容器处于<em class="mx"> Created </em>状态，用户进程必须等待<strong class="jp ir"> start </strong>命令来启动实际的容器进程。</p><p id="3d41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于实现，一切似乎都很简单，但是“监禁”部分可能有点令人困惑。是怎么做到的？</p><h1 id="b72a" class="lf lg iq bd lh li nd lk ll lm ne lo lp lq nf ls lt lu ng lw lx ly nh ma mb mc bi translated">克鲁特</h1><p id="865a" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated"><a class="ae kx" href="https://man7.org/linux/man-pages/man2/chroot.2.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Chroot </strong> </a>是一个改变调用进程根目录的syscall。它以新的根路径作为参数，可以是绝对或相对路径。来自终端的chroot命令做了同样的事情，除了它需要一个额外的参数，即将要在更改的根目录中执行的进程。</p><p id="7b7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们看一个例子之前，首先我们需要准备新的rootfs。不幸的是，jail中使用的二进制文件必须驻留在chroot-ed目录中(很明显)，所以我们需要一个预制的rootfs。幸运的是，我们可以使用我们的主机操作系统二进制文件并挂载绑定已经存在的文件，最终得到如下结构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/399189d26b60cf8df588a1bde35a6102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-eiKNUxtWNTpAamvGjAbQ.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">容器文件夹的文件和目录结构</figcaption></figure><p id="ad90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您的列表不同，也不用担心，只要确保bin目录中有<em class="mx"> bash </em>和<em class="mx"> ls </em> <strong class="jp ir"> <em class="mx"> </em> </strong>即可。</p><p id="4070" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看chroot命令(使用<em class="mx"> sudo </em>运行):</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nn"><img src="../Images/f8a0fb38335249387d7e0dc45b31adbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwZdiQN817Ode7PJD7rbYw.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">和克鲁特一起坐牢</figcaption></figure><p id="318d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，列出根目录之外的目录(<em class="mx"> ls..</em>)列出了被监禁的根，似乎我们看不到外面的任何东西。此外，列出<em class="mx"> bin </em>和<em class="mx"> lib </em>目录的结果与上面的例子相同。</p><p id="2aa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以说<em class="mx">“这就是容器被囚禁的方式”</em>，然后从头开始构建容器。但是，事情并没有那么简单… Chroot既不会改变文件系统，也不会改变进程看到的挂载点。它只是改变了流程根的视图，但是一切都保持不变。而且，打破这个监狱是相当容易的，正如这里所描述的<a class="ae kx" href="https://deepsec.net/docs/Slides/2015/Chw00t_How_To_Break%20Out_from_Various_Chroot_Solutions_-_Bucsay_Balazs.pdf" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="51ad" class="lf lg iq bd lh li nd lk ll lm ne lo lp lq nf ls lt lu ng lw lx ly nh ma mb mc bi translated"><strong class="ak"> pivot_root </strong></h1><p id="2c08" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated"><a class="ae kx" href="https://man7.org/linux/man-pages/man2/pivot_root.2.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">pivot _ root</strong></a><strong class="jp ir"/>另一方面正是我们所需要的。给定当前根目录的新根目录和子目录，它将当前根目录移动到子目录，并将新根目录挂载为根目录挂载点。这样，它就改变了根目录的物理挂载文件夹。稍后，我们可以卸载“旧的”根，只留下新创建的根挂载点。</p><p id="59ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看一个例子。</p><p id="2dc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">* *注意**: pivot_root更改了根挂载点，可能会破坏您的文件系统，所以一定要遵循下面的步骤。</strong></p><p id="7390" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要一个真正的rootfs文件系统。我们不能使用上面的例子，因为我们挂载bind主机二进制文件。我们需要一个能够独立存在的独立目录。为此，我们将使用Docker从Alpine容器中导出一个新鲜的rootfs。然后我们将使用<strong class="jp ir"> unshare </strong>(还记得我们在<a class="ae kx" href="https://penumbra23.medium.com/container-runtime-in-rust-part-0-7af709415cda" rel="noopener">第0部分</a>中的朋友)来创建一个新的挂载名称空间。然后我们将在容器内旋转根。它应该是这样的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi no"><img src="../Images/e0b4770529c01125a799dfa5ca5dc079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UjxoGdw088mD9VA0ymkm1w.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">将进程禁锢在基于alpine的rootfs中</figcaption></figure><p id="b03a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地将容器中的文件复制到主机系统中的tar归档文件中。从Alpine映像导出rootfs后，我们将mount目录绑定到它自己，为什么？因为根据pivot_root系统调用的规范，<em class="mx"> new_root </em>必须是不同于“/”的挂载点的路径。</p><p id="d603" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">准备好容器根之后，我们需要创建一个新的挂载名称空间，使它与我们的主机环境不同，这样pivot_root就不会改变主机挂载名称空间上的任何内容。我们创建一个临时文件夹来保存旧根，旋转根，卸载(或与<em class="mx"> umount -l </em>解除链接)旧根<em class="mx">并最终完成交换，删除<em class="mx">旧根</em>文件夹。</em></p><p id="ba45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧啊。现在我们有一个bash进程在被监禁的容器文件夹中运行。</p><p id="be32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Rust代码中，用<a class="ae kx" href="https://docs.rs/nix/0.22.1/nix/" rel="noopener ugc nofollow" target="_blank"> nix板条箱</a>安装rootfs文件夹看起来像这样:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">在铁锈中安装rootfs</figcaption></figure><p id="126f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一次挂载将根挂载点的挂载传播更改为私有(由于显而易见的原因，<em class="mx"> pivot_root </em>不允许共享挂载传播)。</p><p id="f4aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个旋转过程的代码应该如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="75d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，<strong class="jp ir"> mount_rootfs </strong>和<strong class="jp ir"> pivot_rootfs </strong>都是在新创建的挂载名称空间中调用的。</p><h1 id="fd91" class="lf lg iq bd lh li nd lk ll lm ne lo lp lq nf ls lt lu ng lw lx ly nh ma mb mc bi translated"><strong class="ak">特殊链接&amp;挂载</strong></h1><p id="a7d3" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">OCI运行时规范定义了一组<a class="ae kx" href="https://github.com/opencontainers/runtime-spec/blob/master/runtime-linux.md" rel="noopener ugc nofollow" target="_blank">特殊符号链接</a>。这些符号链接用于将<em class="mx">标准输入</em>、<em class="mx">标准输出、</em>和<em class="mx">标准错误</em>流从容器引擎(Docker、containerd)传递到运行时，反之亦然。它只是将容器的标准流绑定到容器进程的外部文件描述符。容器运行时需要在pivot_root之前建立这些符号链接。</p><p id="781a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OCI运行时规范定义了一组需要安装在容器内部的<a class="ae kx" href="https://github.com/opencontainers/runtime-spec/blob/master/config-linux.md#default-filesystems" rel="noopener ugc nofollow" target="_blank">文件系统</a>。当从Alpine、Ubuntu、Debian等映像中提取一些<strong class="jp ir"> config.json </strong>文件时，<em class="mx"> /dev/pts </em>和<em class="mx"> /dev/shm </em>挂载点出现在运行时配置规范的<em class="mx"> mounts </em>部分中。</p><p id="74a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要更多关注的两个重要文件系统是<em class="mx"> proc </em>和<em class="mx"> sysfs。</em></p><p id="e1c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mx"> proc </em>文件系统挂载到<em class="mx"> /proc </em>目录，并作为内核内部结构的接口。对于每个进程，它有一个<em class="mx">/proc/【PID】</em>子目录，保存文件描述符、cpu和内存使用情况、挂载信息、页表和许多其他东西。例如，在没有创建这个文件系统之前，不能检查当前的挂载点(使用<em class="mx"> mount </em>命令)。安装proc fs的确切命令是:</p><pre class="km kn ko kp gt np mn nq nr aw ns bi"><span id="2c33" class="nt lg iq mn b gy nu nv l nw nx">mount -t proc proc /proc</span></pre><p id="95ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mx"> sysfs </em>文件系统是一个伪fs类的<em class="mx">进程</em>，它提供了一个到内部内核对象的接口。与<em class="mx"> proc </em>文件系统相反，它保存系统范围的信息，如块和字符设备的元数据、总线信息、驱动程序、控制组、内核信息和其他全局变量。安装<em class="mx"> sysfs </em>与<em class="mx"> proc: </em>相同</p><p id="1319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mk ml mm mn b">mount -t sysfs sysfs /sys</code></p><p id="4323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当创建新的根挂载点时，需要在pivot_root之后挂载<em class="mx"> proc </em>和<em class="mx"> sysfs </em>。</p><h1 id="fee9" class="lf lg iq bd lh li nd lk ll lm ne lo lp lq nf ls lt lu ng lw lx ly nh ma mb mc bi translated">设备</h1><p id="46b5" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在Linux中，一切都被认为是一个文件。硬盘驱动器、外围设备，甚至进程都通过文件描述符进行全面描述。设备也不例外。软盘，光驱，串口，你连接的任何设备都应该出现在根目录下的<strong class="jp ir"> /dev </strong>子目录中。设备有类型，大多数设备要么是<em class="mx">块</em>(存储某种数据)，要么是<em class="mx">字符</em>(向/从设备传输数据)。终端、伪随机数发生器甚至<em class="mx"> /dev/null </em>文件也被认为是一个设备。</p><p id="8721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OCI规范定义了每个容器所需的设备，而<strong class="jp ir"> config.json </strong>包含了一个<em class="mx">设备</em>列表，位于<strong class="jp ir"> linux </strong>部分下。容器运行时负责在容器根目录中创建这些设备。创建设备的系统调用是<a class="ae kx" href="https://man7.org/linux/man-pages/man2/mknod.2.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> mknod </strong> </a>。这个syscall(也是终端内部的命令)接受4个必需的参数:</p><ul class=""><li id="468e" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><em class="mx">路径名- </em>文件位置的完整路径</li><li id="2b26" class="mo mp iq jp b jq my ju mz jy na kc nb kg nc kk mt mu mv mw bi translated"><em class="mx">类型</em> -闭塞、字符或其他设备类型</li><li id="e178" class="mo mp iq jp b jq my ju mz jy na kc nb kg nc kk mt mu mv mw bi translated"><em class="mx">主要&amp;次要</em> -设备的唯一标识符</li></ul><p id="8068" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如主副号为1，8的char设备就是代表伪随机数发生器的<em class="mx">随机</em>设备。每当你的应用程序请求一个随机数，这个设备就会收到一个请求。</p><p id="d45c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以很容易地用nix的<strong class="jp ir"> mknod </strong>函数生成特殊设备，或者在绑定到主机设备的情况下(这是OCI规范所涵盖的),使用mount bind选项。</p><h1 id="eeaa" class="lf lg iq bd lh li nd lk ll lm ne lo lp lq nf ls lt lu ng lw lx ly nh ma mb mc bi translated">结论</h1><p id="0f62" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我们已经看到了<strong class="jp ir"> chroot </strong>如何改变当前进程的根目录视图，以及<strong class="jp ir"> pivot_root </strong>如何交换根挂载点，创建文件系统的逻辑隔离。我们还看到了如何创建标准容器设备，以及不同的容器可以在config.json文件的<em class="mx"> mounts </em>部分中请求特殊设备。</p><p id="fb23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">知道了<strong class="jp ir">取消共享</strong>和<strong class="jp ir"> pivot_root </strong>如何工作，我们就能够在终端中手动创建Linux容器。在接下来的部分中，我们将更深入地研究实现。特别是关于克隆子进程和启动容器命令的准备工作。</p><p id="305e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来:<a class="ae kx" href="https://penumbra23.medium.com/container-runtime-in-rust-part-ii-9c88e99d8cbc" rel="noopener"> <strong class="jp ir">第二部分</strong> </a></p></div></div>    
</body>
</html>