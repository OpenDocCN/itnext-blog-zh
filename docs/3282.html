<html>
<head>
<title>Hooked on React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迷上了React</h1>
<blockquote>原文：<a href="https://itnext.io/hooked-on-react-10affe4cca3c?source=collection_archive---------4-----------------------#2019-11-13">https://itnext.io/hooked-on-react-10affe4cca3c?source=collection_archive---------4-----------------------#2019-11-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/4cf08cc9d89f3a38fe05fd0f9406011b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DvKRaHTtWponwi0vy5kJg.jpeg"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">印度阿姆利则的窗户清洁工(图片由作者提供)</figcaption></figure><div class=""/><div class=""><h2 id="a73e" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">React的新钩子API如何帮助你赢得阶级战争</h2></div><p id="c0b4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk">本文假设您已经相当熟悉React。</strong></p><h1 id="5265" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">什么是钩子？</h1><p id="93e1" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated"><a class="ae mr" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>是JavaScript函数，让你从普通的函数组件中与React组件的状态和生命周期特性进行交互，而不必写一个类，或者将组件包装在更高阶的组件中。</p><p id="88ca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">钩子是在React 16.8中引入的，现在是一个稳定的特性。钩子在React Native的现代版本中也可以工作。</p><figure class="ms mt mu mv gu iw"><div class="bz fq l di"><div class="mw mx l"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">观看Dan Abramov在React Conf 2018上对React Hooks的介绍。</figcaption></figure><p id="91fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">React提供了许多内置的钩子，并为您编写自己的钩子提供了一套简单的规则。</p><h1 id="6ef8" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">useState挂钩</h1><p id="ad68" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">这个钩子可能是你最常用的钩子。它为您提供了一种简单明了的方式来访问组件的内部状态，而无需将组件声明为<code class="fe my mz na nb b">React.Component</code>的子类。</p><h2 id="0d89" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">一个例子</h2><p id="7c23" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">老路:</p><p id="c2cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><em class="no">注意</em> <a class="ae mr" href="https://www.npmjs.com/package/pluralise" rel="noopener ugc nofollow" target="_blank"> <em class="no">复数</em> </a> <em class="no">的使用是可选的，但我讨厌UI显示“1次”。</em></p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="16d2" class="nc lv jj nb b gz nt nu l nv nw">import React from 'react'</span><span id="6328" class="nc lv jj nb b gz nx nu l nv nw">class Counter extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>      count: 0<br/>    }<br/>  }</span><span id="8088" class="nc lv jj nb b gz nx nu l nv nw">  increment = () =&gt; {<br/>    this.setState({ count: this.state.count + 1 })<br/>  }</span><span id="b857" class="nc lv jj nb b gz nx nu l nv nw">  render() {<br/>    const { count } = this.state<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;You clicked {pluralise(count, 'time')}&lt;/p&gt;<br/>        &lt;button onClick={this.increment}&gt;Increment&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="8f00" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">现在使用钩子:</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="622f" class="nc lv jj nb b gz nt nu l nv nw">import React, { useState } from 'react'</span><span id="de18" class="nc lv jj nb b gz nx nu l nv nw">const Counter = () =&gt; {<br/>  const [count, setCount] = useState(0)<br/>  <br/>  const increment = () =&gt; setCount(count + 1)<br/>  <br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {pluralise(count, 'time')}&lt;/p&gt;<br/>      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><h2 id="0fcb" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">这是怎么回事？</h2><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="4d6a" class="nc lv jj nb b gz nt nu l nv nw">const [count, setCount] = useState(0)</span></pre><p id="b47e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><code class="fe my mz na nb b">useState</code>钩子返回两个东西，一个是你关心的状态，另一个是设置状态值的函数。在上面的例子中，我们关心一个叫做<code class="fe my mz na nb b">count</code>的状态，我们给了它一个默认值<code class="fe my mz na nb b">0</code>，我们希望能够设置那个<code class="fe my mz na nb b">count</code>的值。值和函数在一个两元素的数组中返回，所以我们使用<em class="no">数组析构</em>作为分配这些值的简写。</p><h1 id="6451" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">useEffect挂钩</h1><p id="f0f6" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated"><code class="fe my mz na nb b"><a class="ae mr" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>钩子允许你在函数组件中执行副作用。你可以把<code class="fe my mz na nb b">useEffect</code>钩子想象成<code class="fe my mz na nb b">componentDidMount</code>、<code class="fe my mz na nb b">componentDidUpdate</code>和<code class="fe my mz na nb b">componentWillUnmount</code>的组合。</p><h2 id="6f8d" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">例子</h2><p id="36d3" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">假设我们想在<code class="fe my mz na nb b">count</code>增加时更新页面标题。</p><p id="d6ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">老方法是:</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="e5d6" class="nc lv jj nb b gz nt nu l nv nw">import React, { Component, Fragment } from 'react'</span><span id="403b" class="nc lv jj nb b gz nx nu l nv nw">class Counter extends Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>      count: 0<br/>    }<br/>  }</span><span id="1fab" class="nc lv jj nb b gz nx nu l nv nw">  setTitle = count =&gt; {<br/>    document.title = `You clicked ${pluralise(count, 'time')}`<br/>  }</span><span id="0312" class="nc lv jj nb b gz nx nu l nv nw">  increment = () =&gt; {<br/>    this.setState({ count: this.state.count + 1 })<br/>  }</span><span id="af34" class="nc lv jj nb b gz nx nu l nv nw">  componentDidMount() {<br/>    this.setTitle(this.state.count)<br/>  }</span><span id="f38c" class="nc lv jj nb b gz nx nu l nv nw">  componentDidUpdate() {<br/>    this.setTitle(this.state.count)<br/>  }</span><span id="9fff" class="nc lv jj nb b gz nx nu l nv nw">  render() {<br/>    const { count } = this.state<br/>    return (<br/>      &lt;Fragment&gt;<br/>        &lt;p&gt;You clicked {pluralise(count, 'time')}&lt;/p&gt;<br/>        &lt;button onClick={this.increment}&gt;Increment&lt;/button&gt;<br/>      &lt;/Fragment&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="bdd4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">但是使用钩子:</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="13c2" class="nc lv jj nb b gz nt nu l nv nw">import React, { Fragment, useState, useEffect } from 'react'</span><span id="f766" class="nc lv jj nb b gz nx nu l nv nw">const Counter = () =&gt; {<br/>  const [count, setCount] = useState(0)<br/>  <br/>  const increment = () =&gt; setCount(count + 1)<br/>  <br/>  useEffect(() =&gt; {<br/>    document.title = `You clicked ${pluralise(count, 'time')}`<br/>  })</span><span id="dad8" class="nc lv jj nb b gz nx nu l nv nw">  return (<br/>    &lt;Fragment&gt;<br/>      &lt;p&gt;You clicked {pluralise(count, 'time')}&lt;/p&gt;<br/>      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;<br/>    &lt;/Fragment&gt;<br/>  )<br/>}</span></pre><p id="3551" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">使用<code class="fe my mz na nb b">useEffect</code>钩子告诉React组件在渲染之后需要做一些事情<em class="no">。React将记住您传递给<code class="fe my mz na nb b">useEffect</code>的函数，并在执行DOM更新后调用它。</em></p><p id="b18e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">注意:传递给<code class="fe my mz na nb b">useEffect</code>的函数会在每次渲染时重新创建。这确保了<code class="fe my mz na nb b">count</code>永远不会过时。每次重新渲染组件时，都会安排不同的效果，替换之前的效果。</p><h2 id="08f8" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">如何防止效果在没有变化时触发</h2><p id="01a5" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated"><code class="fe my mz na nb b">useEffect</code>钩子接受第二个参数，用来和它的当前状态进行比较。即使<code class="fe my mz na nb b">count</code>没有改变，上面的例子也会重写<code class="fe my mz na nb b">document.title</code>。为了解决这个问题，我们调用了<code class="fe my mz na nb b">useEffect</code>，但是也传入了<code class="fe my mz na nb b">count</code>。</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="9aac" class="nc lv jj nb b gz nt nu l nv nw">useEffect(<br/>  () =&gt; {<br/>    document.title = `You clicked ${pluralise(count, 'time')}`<br/>  },<br/>  [count]<br/>)</span></pre><p id="be3e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">现在，如果<code class="fe my mz na nb b">count</code>不变，则不会调用效果功能。</p><p id="a9af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk">提示</strong>:你可以通过传入<code class="fe my mz na nb b">[]</code>作为第二个参数来强制一个效果只运行一次，从而模拟<code class="fe my mz na nb b">componentDidMount</code>的生命周期。</p><h2 id="f385" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">非阻塞效应与阻塞效应</h2><p id="18d1" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">大多数效果不需要同步发生，与<code class="fe my mz na nb b">componentDidMount</code>或<code class="fe my mz na nb b">componentDidUpdate</code>不同，使用<code class="fe my mz na nb b">useEffect</code>安排的效果不会阻止浏览器更新屏幕。在极少数情况下，您需要确保在组件完成渲染后应用效果，有一个单独的<code class="fe my mz na nb b">useLayoutEffect</code>钩子，它的API与<code class="fe my mz na nb b">useEffect</code>相同。</p><h2 id="196c" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">效果后的清理。</h2><p id="e9e8" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">提供给<code class="fe my mz na nb b">useEffect</code>的效果函数可以返回一个可选的清理函数，该函数在组件卸载时执行。React还会在下一次渲染中运行效果之前清除上一次渲染的效果。</p><h1 id="6544" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">React提供的其他标准挂钩</h1><h2 id="2a43" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">使用上下文</h2><p id="53d2" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated"><code class="fe my mz na nb b"><a class="ae mr" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a></code>钩子接受一个<code class="fe my mz na nb b">context</code>对象(从<code class="fe my mz na nb b">React.createContext</code>返回的值)并返回那个<code class="fe my mz na nb b">context</code>的当前值。当前上下文值由树中调用组件上方最近的<code class="fe my mz na nb b">&lt;MyContext.Provider&gt;</code>的<code class="fe my mz na nb b">value</code>属性决定。</p><p id="d6b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">当组件上方最近的<code class="fe my mz na nb b">&lt;MyContext.Provider&gt;</code>更新时，这个钩子将触发一次重新呈现，将最新的上下文值传递给那个<code class="fe my mz na nb b">MyContext</code>提供者。</p><h2 id="1bbf" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">用户教育</h2><p id="c654" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated"><code class="fe my mz na nb b">useState</code>的替代品。<code class="fe my mz na nb b">useReducer</code>吊钩接受一个Redux类型的减速器</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="33d5" class="nc lv jj nb b gz nt nu l nv nw">(state, action) =&gt; newState</span></pre><p id="1d43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">并用一个<code class="fe my mz na nb b">dispatch</code>方法返回当前状态。可以把它想象成一个特定于组件的迷你Redux。</p><h2 id="04b0" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">使用回调</h2><p id="5228" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">传递一个回调和一个依赖数组。<code class="fe my mz na nb b">useCallback</code>将返回一个<em class="no">内存化的</em>版本的回调，只有当其中一个依赖关系改变时才会改变。这在将回调传递给依赖引用相等的优化子组件以防止不必要的呈现时非常有用。</p><p id="f45b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">参见:<a class="ae mr" href="https://medium.com/@rossbulat/how-to-memoize-in-react-3d20cbcd2b6e" rel="noopener">如何记忆React中的组件</a>。</p><h2 id="99cf" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">使用备忘录</h2><p id="3895" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">传递一个<code class="fe my mz na nb b">create</code>函数和一个依赖数组。<code class="fe my mz na nb b">useMemo</code>仅当其中一个依赖关系改变时，才重新计算memoised值，避免每次渲染时重新计算。</p><h2 id="e9c8" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">useRef</h2><p id="d701" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">返回一个<em class="no">可变</em> <code class="fe my mz na nb b">ref</code>对象，其<code class="fe my mz na nb b">.current</code>属性被初始化为传递的参数<code class="fe my mz na nb b">(initialValue)</code>。返回的对象将在组件的整个生存期内保持不变。</p><p id="b47a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">如果您将一个<code class="fe my mz na nb b">ref</code>对象传递给React with <code class="fe my mz na nb b">&lt;div ref={myRef} /&gt;</code>，React将在DOM节点发生变化时将<code class="fe my mz na nb b">ref.current</code>属性设置为相应的DOM节点。</p><p id="1662" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">在<a class="ae mr" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">React文档</a>中阅读更多关于<code class="fe my mz na nb b">ref</code>属性的用法。</p><p id="801d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk">提示</strong>:你可以使用，<code class="fe my mz na nb b">useRef</code>作为超过<code class="fe my mz na nb b">ref</code>的属性。这有助于保留任何可变值，类似于在类中使用实例字段。</p><h2 id="47fd" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">useLayoutEffect</h2><p id="11a4" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">与<code class="fe my mz na nb b">useEffect</code>相同，但它在所有DOM突变后同步触发<em class="no"/>。使用它从DOM中读取布局并同步重新渲染。在浏览器有机会绘制之前，安排在<code class="fe my mz na nb b">useLayoutEffect</code>中的更新将被同步刷新。</p><p id="8b5b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk">提示</strong>:尽可能使用标准的<code class="fe my mz na nb b">useEffect</code>，以避免阻碍视觉更新。</p><h2 id="1c14" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">useDebugValue</h2><p id="500f" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">用于在React DevTools中显示自定义挂钩的标签。</p><h1 id="22ef" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">钩子代替Redux吗？</h1><p id="add2" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">不会。Redux仍然是管理共享或应用程序范围状态的优秀框架。React Redux <a class="ae mr" href="https://react-redux.js.org/api/hooks" rel="noopener ugc nofollow" target="_blank">从v7.1.0 </a>开始就支持钩子API，并公开诸如<code class="fe my mz na nb b">useDispatch</code>和<code class="fe my mz na nb b">useSelector</code>之类的钩子，使您能够<code class="fe my mz na nb b">subscribe</code>到Redux存储和<code class="fe my mz na nb b">dispatch</code>动作，而不必将组件包装在<code class="fe my mz na nb b">connect</code>中。</p><p id="20f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><code class="fe my mz na nb b">useSelector</code>钩子大致相当于<code class="fe my mz na nb b">connect</code>的<code class="fe my mz na nb b">mapStateToProps</code>参数。将以整个Redux存储状态作为唯一参数来调用选择器。每当组件呈现时，它都会运行。<code class="fe my mz na nb b">useSelector</code>还将订阅Redux store，并在调度动作时运行您的选择器。</p><h2 id="73a5" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">例子</h2><p id="697f" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">我们希望许多计数器组件共享相同的计数。定义一个简单的重复计数<code class="fe my mz na nb b">state</code>、<code class="fe my mz na nb b">reducer</code>和<code class="fe my mz na nb b">store</code>，如下所示:</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="69a4" class="nc lv jj nb b gz nt nu l nv nw">import { createStore, combineReducers } from 'redux'</span><span id="6f00" class="nc lv jj nb b gz nx nu l nv nw">// count starts at 0<br/>const INITIAL_COUNT = 0</span><span id="9880" class="nc lv jj nb b gz nx nu l nv nw">// the count state reducer<br/>const count = (state = INITIAL_COUNT, action = {}) =&gt; {<br/>  switch(action.type) {<br/>    case 'increment-count': return state + 1<br/>    default: return state<br/>  }<br/>}</span><span id="0b02" class="nc lv jj nb b gz nx nu l nv nw">// export the redux store<br/>export default createStore(combineReducers({ count }))</span></pre><p id="0947" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">一个<code class="fe my mz na nb b">Count</code>组件只是从使用<code class="fe my mz na nb b">useSelector</code>的状态中获取<code class="fe my mz na nb b">count</code>并显示在一个<code class="fe my mz na nb b">span</code>中:</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="a5bc" class="nc lv jj nb b gz nt nu l nv nw">import React from 'react'<br/>import { useSelector } from 'react-redux'</span><span id="c74a" class="nc lv jj nb b gz nx nu l nv nw">const Count = () =&gt; {<br/>  const count = useSelector(({ count }) =&gt; count)<br/>  return &lt;span&gt;{count}&lt;/span&gt;<br/>}</span></pre><p id="4dd8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><code class="fe my mz na nb b">useDispatch</code>钩子从Redux存储中返回对<code class="fe my mz na nb b">dispatch</code>函数的引用。您可以根据需要使用它来调度操作。</p><h2 id="0201" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">例子</h2><p id="6a39" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">从上方使用<code class="fe my mz na nb b">Count</code>组件。</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="ed3a" class="nc lv jj nb b gz nt nu l nv nw">import React, { Fragment } from 'react'<br/>import { useDispatch } from 'react-redux'<br/>import Count from './Count'</span><span id="d0bc" class="nc lv jj nb b gz nx nu l nv nw">const Counter = () =&gt; {<br/>  const dispatch = useDispatch()<br/>  const increment = () =&gt; dispatch({ type: 'increment-count' })</span><span id="e2c7" class="nc lv jj nb b gz nx nu l nv nw">  return (<br/>    &lt;Fragment&gt;<br/>      &lt;Count /&gt;<br/>      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;<br/>    &lt;/Fragment&gt;<br/>  )<br/>}</span></pre><p id="fa8a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">当使用<code class="fe my mz na nb b">dispatch</code>将回调传递给子组件时，建议使用<code class="fe my mz na nb b">useCallback</code>进行调用，否则子组件可能会由于引用的改变而出现不必要的渲染。</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="96ec" class="nc lv jj nb b gz nt nu l nv nw">import React, { Fragment, memo, useCallback } from 'react'<br/>import { useDispatch } from 'react-redux'<br/>import Count from './Count'</span><span id="b97a" class="nc lv jj nb b gz nx nu l nv nw">const Incrementer = memo(({ onClick }) =&gt; (<br/>  &lt;button onClick={onClick}&gt;Increment&lt;/button&gt;<br/>))</span><span id="f2e3" class="nc lv jj nb b gz nx nu l nv nw">const Counter = ({ count }) =&gt; {<br/>  const dispatch = useDispatch()<br/>  const increment = useCallback(<br/>    () =&gt; dispatch({ type: 'increment-count' }),<br/>    [dispatch]<br/>  )</span><span id="dd2b" class="nc lv jj nb b gz nx nu l nv nw">  return (<br/>    &lt;Fragment&gt;<br/>      &lt;Count /&gt;<br/>      &lt;Incrementer onClick={increment} /&gt;<br/>    &lt;/Fragment&gt;<br/>  )<br/>}</span></pre><h1 id="0be1" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">React路由器怎么样？</h1><p id="fe35" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">React路由器<a class="ae mr" href="https://reacttraining.com/react-router/web/api/Hooks" rel="noopener ugc nofollow" target="_blank">从v5.1开始就支持钩子API </a>。</p><h2 id="a9fe" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">使用历史</h2><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="72a7" class="nc lv jj nb b gz nt nu l nv nw">import { useHistory } from 'react-router-dom'</span><span id="3586" class="nc lv jj nb b gz nx nu l nv nw">export const HomeButton = () =&gt; {<br/>  const history = useHistory()</span><span id="8e2c" class="nc lv jj nb b gz nx nu l nv nw">  const goHome = () =&gt; history.push('/home')</span><span id="d570" class="nc lv jj nb b gz nx nu l nv nw">  return (<br/>    &lt;button type="button" onClick={goHome}&gt;Home&lt;/button&gt;<br/>  )<br/>}</span></pre><h2 id="7906" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">React路由器暴露的其他挂钩:</h2><ul class=""><li id="cd1d" class="ny nz jj la b lb mm le mn lh oa ll ob lp oc lt od oe of og bi translated"><code class="fe my mz na nb b">useLocation</code></li><li id="b167" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><code class="fe my mz na nb b">useParams</code></li><li id="2176" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><code class="fe my mz na nb b">useRouteMatch</code></li></ul><h1 id="45b8" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">测试呢？</h1><p id="8617" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">为你的定制钩子编写标准的单元测试；钩子只是函数。</p><p id="a454" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">从React的角度来看，使用钩子的组件是常规组件。您可以像往常一样测试它，如果您的钩子做了一些复杂的事情，您可以独立地测试钩子，并从组件的测试中模拟它，就像您对任何其他依赖项所做的那样。</p><p id="1947" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">更多信息见<a class="ae mr" href="https://reactjs.org/docs/testing-recipes.html" rel="noopener ugc nofollow" target="_blank">reactjs.org/docs/testing-recipes.html</a>。</p><h1 id="f448" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">“钩子的规则”</h1><p id="a4da" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">为了让钩子工作<a class="ae mr" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">，它们需要遵循三个简单的规则</a>。</p><p id="f620" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk">首先</strong>:你的钩子必须以<code class="fe my mz na nb b">use</code>这个字开头。</p><p id="19ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk">其次</strong>:只从React函数调用钩子，或者从其他钩子调用。</p><p id="60c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">不要从常规的JavaScript函数中调用钩子。</p><p id="12f8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk">注意</strong>:你不能在一个类组件中使用钩子，但是当你从旧风格<code class="fe my mz na nb b">React.Component</code>类中移植你的应用时，你<em class="no">可以在一个单独的树中用钩子混合类和函数组件。从长远来看，React团队期望带挂钩的简单函数成为人们编写React组件的主要方式。</em></p><p id="f056" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">第三个:只在你的函数的顶层调用钩子。</p><p id="e98e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">不要从内部循环、条件或嵌套函数中调用钩子，否则每次组件渲染时，钩子的调用顺序都不一样。</p><p id="a279" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">有一个名为<code class="fe my mz na nb b"><a class="ae mr" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank">eslint-plugin-react-hooks</a></code>的<code class="fe my mz na nb b">ESLint</code>插件执行这些规则。</p><p id="dfd9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><strong class="la jk">注意</strong>:如果你正在使用<code class="fe my mz na nb b">Create React App</code>，那么你会看到<code class="fe my mz na nb b"><a class="ae mr" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank">eslint-plugin-react-hook</a>s</code>已经包含在<code class="fe my mz na nb b">react-scripts</code>的最新版本中。</p><h1 id="5005" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">定制钩子——编写自己的钩子</h1><p id="f172" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">通过<a class="ae mr" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">将逻辑提取到一个钩子</a>，在两个JavaScript函数之间共享逻辑；一个名字以<code class="fe my mz na nb b">use</code>开头的JavaScript函数，可以调用其他钩子。</p><p id="8b61" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">您的自定义钩子不需要有特定的签名。您可以决定它接受什么作为参数，以及它返回什么(如果有的话)。这就像一个普通的函数。它的名字<em class="no">必须</em>以<code class="fe my mz na nb b">use</code>开头，这样你一眼就能看出挂钩的<em class="no">规则适用于它。</em></p><h2 id="c623" class="nc lv jj bd lw nd ne dn ma nf ng dp me lh nh ni mg ll nj nk mi lp nl nm mk nn bi translated">例子</h2><p id="3680" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">让我们假设任何一个自重的计数器都需要显示一个当前的<code class="fe my mz na nb b">count</code>，能够<code class="fe my mz na nb b">increment</code>那个<code class="fe my mz na nb b">count</code>，并在当前的<code class="fe my mz na nb b">count</code>改变时用当前的<code class="fe my mz na nb b">count</code>更新页面标题。(这当然假设每页只有一个<code class="fe my mz na nb b">count</code>)。我们可以这样写一个<code class="fe my mz na nb b">useCount</code>钩子:</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="38aa" class="nc lv jj nb b gz nt nu l nv nw">export const useCount = () =&gt; {<br/>  const [count, setCount] = useState(0)<br/>  const increment = () =&gt; setCount(count + 1)</span><span id="2eeb" class="nc lv jj nb b gz nx nu l nv nw">  useEffect(() =&gt; {<br/>    document.title = `You clicked ${pluralise(count, 'time')}`<br/>  }, [count])</span><span id="897d" class="nc lv jj nb b gz nx nu l nv nw">  return [count, increment]<br/>}</span></pre><p id="2a50" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">那么<code class="fe my mz na nb b">Counter</code>组件可以写成:</p><pre class="ms mt mu mv gu np nb nq nr aw ns bi"><span id="5ece" class="nc lv jj nb b gz nt nu l nv nw">const Counter = () =&gt; {<br/>  const [count, increment] = useCount()</span><span id="8887" class="nc lv jj nb b gz nx nu l nv nw">  return (<br/>    &lt;Fragment&gt;<br/>      &lt;p&gt;You clicked ${pluralise(count, 'time')}&lt;/p&gt;<br/>      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;<br/>    &lt;/Fragment&gt;<br/>  )<br/>}</span></pre><p id="7d91" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">每次你使用一个自定义钩子，它里面的所有状态和效果都被完全隔离。在这个例子中，每个使用<code class="fe my mz na nb b">useCount</code>钩子的组件都有自己的<code class="fe my mz na nb b">count</code>状态，从<code class="fe my mz na nb b">0</code>开始。如果您希望在组件之间共享状态，您可以使用Redux，或者使用许多全局状态管理钩子中的一个(例如<code class="fe my mz na nb b"><a class="ae mr" href="https://medium.com/javascript-in-plain-english/state-management-with-react-hooks-no-redux-or-context-api-8b3035ceecf8" rel="noopener">useGlobalHook</a></code>)。)</p><p id="36e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">定制钩子以以前在React组件中不可能的方式实现了逻辑的封装和共享。它们可以覆盖广泛的用例，比如<a class="ae mr" href="https://react-hook-form.com" rel="noopener ugc nofollow" target="_blank">表单处理</a>、<a class="ae mr" href="https://www.react-spring.io/docs/hooks/basics" rel="noopener ugc nofollow" target="_blank">动画</a>、<a class="ae mr" href="https://codeburst.io/how-to-fetch-data-from-an-api-with-react-hooks-9e7202b8afcd" rel="noopener" target="_blank"> API调用和订阅</a>、<a class="ae mr" href="https://github.com/amrlabib/react-timer-hook" rel="noopener ugc nofollow" target="_blank">定时器</a>等等。</p><p id="41e8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">在野外已经有数以千计有趣的React钩子可供你使用。</p><h1 id="f177" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">赢得阶级斗争</h1><p id="28f4" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">有经验的JavaScript开发人员知道使用类最多是有问题的，并把关键字<code class="fe my mz na nb b">this</code>的存在视为代码气味。JavaScript并不是真正的面向对象语言，不必要的尝试使用它可能会导致难以发现的细微错误。</p><p id="0b24" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">钩子允许你通过简化你的组件来避开这些危险，而不是强迫组件接受<code class="fe my mz na nb b">React.Component</code>(或者<code class="fe my mz na nb b">React.PureComponent</code>)的秘密，或者在由高阶组件组成的深树中纠缠不清。</p><h1 id="ac83" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">最后</h1><p id="d0d7" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">使用钩子。未来你会爱你的。</p><figure class="ms mt mu mv gu iw"><div class="bz fq l di"><div class="mw mx l"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">未来的我恨我(官方音乐视频)</figcaption></figure><h1 id="2220" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">链接</h1><p id="c8e3" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">链接按照它们在文章中出现的顺序显示。</p><ul class=""><li id="714a" class="ny nz jj la b lb lc le lf lh om ll on lp oo lt od oe of og bi translated"><a class="ae mr" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-intro.html</a></li><li id="82c9" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-state.html</a></li><li id="a602" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://www.npmjs.com/package/pluralise" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/pluralise</a></li><li id="b3fd" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-effect.html</a></li><li id="2a72" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated">【https://reactjs.org/docs/hooks-reference.html#usecontext】</li><li id="d436" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://medium.com/@rossbulat/how-to-memoize-in-react-3d20cbcd2b6e" rel="noopener">https://medium . com/@ Ross bulat/how-to-memo ize-in-react-3d 20 cbcd 2 b 6 e</a></li><li id="2481" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/refs-and-the-dom.html</a></li><li id="3661" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://react-redux.js.org/api/hooks" rel="noopener ugc nofollow" target="_blank">https://react-redux.js.org/api/hooks</a></li><li id="2456" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated">https://reacttraining.com/react-router/web/api/Hooks<a class="ae mr" href="https://reacttraining.com/react-router/web/api/Hooks" rel="noopener ugc nofollow" target="_blank"/></li><li id="20a0" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated">【https://reactjs.org/docs/testing-recipes.html T4】</li><li id="f77c" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/eslint-plugin-react-hooks</a></li><li id="e9de" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-rules.html</a></li><li id="eaa3" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-custom.html</a></li><li id="2cbb" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html</a></li><li id="532e" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://medium.com/better-programming/here-are-6-awesome-react-hooks-2ff0c0b35218" rel="noopener">https://medium . com/better-programming/here-are-6-awesome-react-hooks-2ff 0 c0b 35218</a></li><li id="29df" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://medium.com/javascript-in-plain-english/state-management-with-react-hooks-no-redux-or-context-api-8b3035ceecf8" rel="noopener">https://medium . com/JavaScript-in-plain-English/state-management-with-react-hooks-no-redux-or-context-API-8b 3035 CEE cf 8</a></li><li id="0c2c" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://react-hook-form.com" rel="noopener ugc nofollow" target="_blank">https://react-hook-form.com</a></li><li id="cdd6" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://www.react-spring.io/docs/hooks/basics" rel="noopener ugc nofollow" target="_blank">https://www.react-spring.io/docs/hooks/basics</a></li><li id="22d5" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://github.com/amrlabib/react-timer-hook" rel="noopener ugc nofollow" target="_blank">https://github.com/amrlabib/react-timer-hook</a></li><li id="8f1d" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://codeburst.io/how-to-fetch-data-from-an-api-with-react-hooks-9e7202b8afcd" rel="noopener" target="_blank">https://code burst . io/how-to-fetch-data-from-an-API-with-react-hooks-9e 7202 b 8 afcd</a></li><li id="1d19" class="ny nz jj la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated"><a class="ae mr" href="https://nikgraf.github.io/react-hooks/" rel="noopener ugc nofollow" target="_blank">https://nikgraf.github.io/react-hooks</a></li></ul><p id="dea4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi">—</p><p id="f5f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">像这样但不是订户？你可以通过<a class="ae mr" href="https://davesag.medium.com/membership" rel="noopener">davesag.medium.com</a>加入来支持作者。</p></div></div>    
</body>
</html>