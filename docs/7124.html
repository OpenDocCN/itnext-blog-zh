<html>
<head>
<title>Minimalist Guide to Testing in Flutter — Part 2 Mocking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振试验的最低限度指南——第二部分嘲弄</h1>
<blockquote>原文：<a href="https://itnext.io/minimalist-guide-to-testing-in-flutter-part-2-mocking-b0a35a0dc336?source=collection_archive---------0-----------------------#2022-06-19">https://itnext.io/minimalist-guide-to-testing-in-flutter-part-2-mocking-b0a35a0dc336?source=collection_archive---------0-----------------------#2022-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/11f393f86219f77ffefda8b8a67226f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSQd75qDswRVZ7L483wh4A.jpeg"/></div></div></figure><h2 id="56ae" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">第2部分——mock tail——测试中的嘲讽是什么？</h2><div class=""/><div class=""><h2 id="9c5e" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">在我们开始写测试之前，我认为，我们需要学习如何模拟它们，这是一个我们需要经常使用的重要话题！</h2></div><div class="is it gp gr iu lc"><a rel="noopener  ugc nofollow" target="_blank" href="/minimalist-guide-to-testing-in-flutter-e9c885c7e35c"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd jo gy z fp lh fr fs li fu fw jn bi translated">颤振试验的简明指南-第一部分什么是试验？</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">这一次，我将开始深入介绍Flutter中的测试！</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">itnext.io</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ja lc"/></div></div></a></div><h2 id="28f6" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">基本上，我们在Flutter中有两种主要的封装选择</h2><ol class=""><li id="ddb4" class="mm mn je mo b mp mq mr ms ma mt me mu mi mv mw mx my mz na bi translated">莫奇托</li><li id="5c83" class="mm mn je mo b mp nb mr nc ma nd me ne mi nf mw mx my mz na bi translated">莫克泰尔</li></ol><p id="a47b" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">这两个包都很棒，但我会选择<a class="ae nv" href="https://pub.dev/packages/mocktail" rel="noopener ugc nofollow" target="_blank"> mocktail </a></p><h2 id="dcd0" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">为什么我选择了Mocktail？</h2><p id="353e" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">别误会，<a class="ae nv" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank">莫克托</a>也很棒，是dart团队自己研发的！但是我就是喜欢莫克泰尔的方法！因为；</p><ul class=""><li id="ba0b" class="mm mn je mo b mp ni mr nk ma nz me oa mi ob mw oc my mz na bi translated">更简单的API</li><li id="09b0" class="mm mn je mo b mp nb mr nc ma nd me ne mi nf mw oc my mz na bi translated">不生成代码</li><li id="45ff" class="mm mn je mo b mp nb mr nc ma nd me ne mi nf mw oc my mz na bi translated">类型安全</li></ul><p id="2546" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">就那样！</p><h2 id="0019" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">为什么我们需要包，没有包就不能写吗？</h2><p id="5f9e" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">事实上，我们可以，但我认为这张图片会很好地向你解释这种情况。</p><h2 id="2e28" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">动机</h2><p id="b92b" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">即使在这个基本的例子中你清楚地看到了区别！</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/8c1544ada0279aa5f8fe32714bff07cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVdwDY57p5XXtdKy373tvg.jpeg"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">无包vs mocktail</figcaption></figure><p id="aba3" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">除此之外，我们还需要为所有场景编写所有这些代码！想想那个样板文件！</p><p id="e6a1" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">无论如何</p><h2 id="c073" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">什么是嘲讽，我们为什么需要它？</h2><p id="f3ff" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated"><em class="om">“单元测试背后的主要思想是隔离并关注我们正在测试的当前单元，而不是外部依赖的行为。但在大多数情况下，我们需要依赖外部依赖，如数据库、web服务器、平台API、外部设备等。</em></p><p id="a1ad" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">让我们假设我们当前的单元依赖于一个web API。当服务器运行时，测试运行缓慢但很好。但是当服务器离线时，单元测试就会失败。这使得单元测试不可预测。因为网络服务器不在我们的控制之下。当网络服务器关闭时，这不是我们的错。这就是嘲讽的由来。”</p><p id="60e1" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">(我直接从<a class="ae nv" href="https://betterprogramming.pub/flutter-unit-testing-the-beginners-guide-35105164722e" rel="noopener ugc nofollow" target="_blank">这篇牛逼的文章</a>里抄了这2段。因为我无法更好地解释它！请检查这篇文章，并给他一些掌声！)</p><p id="70f0" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">因此，我们只是创建假的服务来将我们的测试与其他依赖项隔离开来，并且我们假设所有的外部依赖项都能正常工作！</p><blockquote class="on oo op"><p id="611b" class="ng nh om mo b mp ni ko nj mr nk kr nl oq nm nn no or np nq nr os ns nt nu mw im bi translated">你可能认为基本上。用原始文件替换/伪造依赖关系</p></blockquote><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/f1923d7fa2d6d8718637c5f5b7486831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z7CrVR-xj713e7cfSUgPXQ.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">-塔达斯·佩特拉</figcaption></figure><h2 id="71a7" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">为什么我们不称他们为假装而不是嘲笑呢？</h2><p id="e61f" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">事实上，我不知道主要原因，但我想，假服务是指不同的事情。(比如在假环境下工作)但是如果我们用作伪代替嘲讽。术语会混淆！IMHO。反正那就算了也无所谓！</p><p id="b4a9" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">此外，在测试应用程序时，你会看到很多“存根”术语！</p><h2 id="9228" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">什么是存根？</h2><blockquote class="ou"><p id="a18c" class="ov ow je bd ox oy oz pa pb pc pd mw dk translated">Stub是一段代码，用来代替其他一些编程功能。存根可以模拟现有代码的行为</p></blockquote><p id="e26b" class="pw-post-body-paragraph ng nh je mo b mp pe ko nj mr pf kr nl ma pg nn no me ph nq nr mi pi nt nu mw im bi translated">基本上，我们得到这个类，然后创建一个看起来一样但功能不同的假类！</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/862419ec8b573597ff3a43c65ff3117c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*-Yo65rqrbzD3H1Fs"/></div></figure><pre class="oe of og oh gt pk pl pm pn aw po bi"><span id="6298" class="lr ls je pl b gy pp pq l pr ps">class <strong class="pl jo">Horse</strong> {}</span><span id="95a7" class="lr ls je pl b gy pt pq l pr ps">class <strong class="pl jo">Trojan</strong> extends <strong class="pl jo">Mock</strong> implements <strong class="pl jo">Horse</strong> {}</span></pre><h2 id="7667" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">够了吗？</h2><p id="d6e4" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">然后，让我们来看看我们隐藏的力量！！</p><h2 id="6248" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">逻辑很简单！</h2><p id="874e" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">“告诉你的特洛伊人在任何情况下该怎么做！让它发生！并控制它是否恰当地完成了你的工作！”</p><pre class="oe of og oh gt pk pl pm pn aw po bi"><span id="1ae2" class="lr ls je pl b gy pp pq l pr ps"><em class="om">// Stub the `sound` method.</em><br/><strong class="pl jo">when(() =&gt; trojan.sound()).thenReturn('horse sound');</strong></span><span id="622e" class="lr ls je pl b gy pt pq l pr ps"><em class="om">// Verify no interactions have occurred.</em><br/><strong class="pl jo">verifyNever(() =&gt; trojan.sound());</strong></span><span id="e39c" class="lr ls je pl b gy pt pq l pr ps"><em class="om">// Interact with the mock trojan instance.</em><br/><strong class="pl jo">trojan.sound();</strong></span><span id="6b7e" class="lr ls je pl b gy pt pq l pr ps"><em class="om">// Verify the interaction occurred.</em><br/><strong class="pl jo">verify(() =&gt; trojan.sound()).called(1);</strong></span><span id="a175" class="lr ls je pl b gy pt pq l pr ps"><em class="om">// Interact with the mock instance again.</em><br/><strong class="pl jo">trojan.sound();</strong></span><span id="07ec" class="lr ls je pl b gy pt pq l pr ps"><em class="om">// Verify the interaction occurred twice.</em><br/><strong class="pl jo">verify(() =&gt; trojan.sound()).called(2);</strong></span></pre><p id="0fa6" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">实际上，我们在测试时有3个主要步骤！</p><p id="0ded" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">(暂时忘记<code class="fe pu pv pw pl b">init</code>和<code class="fe pu pv pw pl b">dispose</code>步骤！)</p><h2 id="4090" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">1.安排—决定行为！</h2><p id="fa7f" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">我们的咒语是<code class="fe pu pv pw pl b">when</code></p><p id="21fa" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">"当那个方法运行时，就这样做！"</p><pre class="oe of og oh gt pk pl pm pn aw po bi"><span id="0d9c" class="lr ls je pl b gy pp pq l pr ps">// Sync Methods<br/><strong class="pl jo">when</strong>(() =&gt; service.<strong class="pl jo">syncMethod</strong>()).<strong class="pl jo">thenReturn</strong>('ehe');</span><span id="8764" class="lr ls je pl b gy pt pq l pr ps">// Async Methods<strong class="pl jo"><br/>when</strong>(() =&gt; service.<strong class="pl jo">asyncMethod</strong>()).<strong class="pl jo">thenAnswer</strong>((e) <strong class="pl jo">async</strong> =&gt; 'ehe');</span><span id="01ee" class="lr ls je pl b gy pt pq l pr ps">// Error Handling<br/><strong class="pl jo">when</strong>(() =&gt; service.<strong class="pl jo">brokenMethod</strong>()).<strong class="pl jo">thenThrow</strong>(<strong class="pl jo">Exception</strong>('ehe'));</span></pre><h2 id="ded9" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">2.行动——试试看！</h2><p id="d259" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">这里没有特例，我们只是运行方法！如果我们需要的话！</p><pre class="oe of og oh gt pk pl pm pn aw po bi"><span id="06eb" class="lr ls je pl b gy pp pq l pr ps">final res = service.<strong class="pl jo">syncMethod</strong>();</span><span id="381d" class="lr ls je pl b gy pt pq l pr ps">final res2 = await service.<strong class="pl jo">asyncMethod</strong>();</span><span id="d555" class="lr ls je pl b gy pt pq l pr ps">final res3 = service.<strong class="pl jo">brokenMethod</strong>();</span></pre><h2 id="eebc" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">3.断言—确认它！</h2><p id="ed83" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">最后，我们确保工作正常！所以我们定义我们的期望，并与结果进行比较！</p><pre class="oe of og oh gt pk pl pm pn aw po bi"><span id="128a" class="lr ls je pl b gy pp pq l pr ps">// We make ensure that method never runned before!<strong class="pl jo"><br/>verifyNever</strong>(() =&gt; service.<strong class="pl jo">syncMethod</strong>());</span><span id="cd46" class="lr ls je pl b gy pt pq l pr ps">// we call it once and ask the app is it called only once?<strong class="pl jo"><br/>verify</strong>(() =&gt; service.<strong class="pl jo">syncMethod</strong>()).<strong class="pl jo">called</strong>(1);</span><span id="4385" class="lr ls je pl b gy pt pq l pr ps">// we expect we run it but is it return this value?<strong class="pl jo"><br/>expect</strong>(service.<strong class="pl jo">syncMethod</strong>(), 'ehe');</span><span id="4649" class="lr ls je pl b gy pt pq l pr ps">// I know it'll throw an expection but it's really throw it?<strong class="pl jo"><br/>expect</strong>(() =&gt; service.<strong class="pl jo">brokenMethod</strong>(), <strong class="pl jo">throwsA</strong>(<strong class="pl jo">isA</strong>&lt;<strong class="pl jo">Exception</strong>&gt;()));</span></pre><h2 id="e8d4" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">您还可以随时轻松重置您的服务！</h2><p id="322d" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">轻松开始下一次测试！</p><pre class="oe of og oh gt pk pl pm pn aw po bi"><span id="8743" class="lr ls je pl b gy pp pq l pr ps"><strong class="pl jo">reset</strong>(service);</span></pre><h2 id="80a3" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">小心！</h2><p id="65cb" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">如果你想在参数匹配器中使用你的自定义类型，你需要在开始的时候注册你的类型！因为Mocktail只支持开箱即用的原语类型！但是不用担心，这很容易做到！</p><pre class="oe of og oh gt pk pl pm pn aw po bi"><span id="09fc" class="lr ls je pl b gy pp pq l pr ps"><strong class="pl jo">class</strong> <strong class="pl jo">Food</strong> {...}</span><span id="9dcb" class="lr ls je pl b gy pt pq l pr ps"><strong class="pl jo">class</strong> <strong class="pl jo">Cat</strong> {<br/>  bool likes(<strong class="pl jo">Food</strong> food) {...}<br/>}</span><span id="42d1" class="lr ls je pl b gy pt pq l pr ps">...</span><span id="df6e" class="lr ls je pl b gy pt pq l pr ps"><strong class="pl jo">class</strong> <strong class="pl jo">MockCat</strong> <strong class="pl jo">extends</strong> <strong class="pl jo">Mock</strong> <strong class="pl jo">implements</strong> <strong class="pl jo">Cat</strong> {}</span><span id="aa35" class="lr ls je pl b gy pt pq l pr ps"><strong class="pl jo">class</strong> <strong class="pl jo">FakeFood</strong> <strong class="pl jo">extends</strong> <strong class="pl jo">Fake</strong> <strong class="pl jo">implements</strong> <strong class="pl jo">Food</strong> {}</span><span id="2770" class="lr ls je pl b gy pt pq l pr ps">test('...', () {<br/>  <strong class="pl jo">registerFallbackValue</strong>(<strong class="pl jo">FakeFood</strong>());</span><span id="2b68" class="lr ls je pl b gy pt pq l pr ps">  <strong class="pl jo">final</strong> cat = <strong class="pl jo">MockCat</strong>();<br/>  when(() =&gt; cat.<strong class="pl jo">likes</strong>(<strong class="pl jo">any&lt;FakeFood&gt;</strong>()).thenReturn(<strong class="pl jo">true</strong>);<br/>  ...<br/>});</span></pre><h2 id="4055" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">为什么我不能正确地存根/验证扩展方法？</h2><p id="d20d" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">我还直接从<a class="ae nv" href="https://pub.dev/packages/mocktail#faqs" rel="noopener ugc nofollow" target="_blank">复制了文档</a>，因为它很好地解释了情况！</p><p id="8d15" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated"><em class="om">"扩展方法不能被存根化/验证，因为它们被视为静态方法。这意味着调用直接指向扩展方法，而不关心实例。因此，对扩展的stubs和verify调用总是会导致调用真正的扩展方法。</em></p><p id="a847" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated"><em class="om">与其直接存根/验证扩展方法，不如存根/验证扩展方法与之交互的实例上的公共成员</em>。"</p><pre class="oe of og oh gt pk pl pm pn aw po bi"><span id="5ea9" class="lr ls je pl b gy pp pq l pr ps">class <strong class="pl jo">MyClass</strong> {}</span><span id="2511" class="lr ls je pl b gy pt pq l pr ps"><strong class="pl jo">extension</strong> on <strong class="pl jo">MyClass</strong> {<br/>  void <strong class="pl jo">foo</strong>() {}<br/>}</span><span id="8bad" class="lr ls je pl b gy pt pq l pr ps">class <strong class="pl jo">MockMyClass</strong> extends <strong class="pl jo">Mock</strong> implements <strong class="pl jo">MyClass</strong> {}</span></pre><p id="41e2" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated"><em class="om">”在上面的场景中，在</em> <code class="fe pu pv pw pl b"><em class="om">MockMyClass</em></code> <em class="om">上调用</em> <code class="fe pu pv pw pl b"><em class="om">foo</em></code> <em class="om">将总是调用真正的</em> <code class="fe pu pv pw pl b"><em class="om">foo()</em></code> <em class="om">(不是存根)。因此，不可能存根/验证作为扩展的方法，因为它们总是会导致真正的扩展被调用。”</em></p></div><div class="ab cl px py hx pz" role="separator"><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc"/></div><div class="im in io ip iq"><p id="9830" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">这就是我想说的关于模拟测试的一切！</p><p id="c7cc" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">下周，我将开始谈论单元测试，并亲自动手！</p></div><div class="ab cl px py hx pz" role="separator"><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc"/></div><div class="im in io ip iq"><h2 id="5d0e" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">第1部分—什么是测试？</h2><div class="is it gp gr iu lc"><a rel="noopener  ugc nofollow" target="_blank" href="/minimalist-guide-to-testing-in-flutter-e9c885c7e35c"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd jo gy z fp lh fr fs li fu fw jn bi translated">颤振试验的最低限度指南</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">这一次，我将开始深入介绍Flutter中的测试！</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">itnext.io</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ja lc"/></div></div></a></div><h2 id="09be" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">第二部分——什么是嘲讽？—当前！</h2><h2 id="ffc9" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">第3部分—自动化测试</h2><div class="is it gp gr iu lc"><a rel="noopener  ugc nofollow" target="_blank" href="/minimalist-guide-to-testing-in-flutter-part-3-automated-testing-f47e857f4e88"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd jo gy z fp lh fr fs li fu fw jn bi translated">颤振试验的最低限度指南第三部分自动试验</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">单元测试、小部件测试、集成测试、测试覆盖等等，所有这些在这篇文章中都有一个可理解的…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">itnext.io</p></div></div><div class="ll l"><div class="qe l ln lo lp ll lq ja lc"/></div></div></a></div><h2 id="de4a" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">第4部分—一些有用的测试包</h2><div class="is it gp gr iu lc"><a rel="noopener  ugc nofollow" target="_blank" href="/minimalist-guide-to-testing-in-flutter-part-4-useful-packages-92e1b4eecdd8"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd jo gy z fp lh fr fs li fu fw jn bi translated">颤振试验的最低限度指南——第4部分有用的包</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">帮助你建立更快更好的测试的有用的包！</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">itnext.io</p></div></div><div class="ll l"><div class="qf l ln lo lp ll lq ja lc"/></div></div></a></div></div><div class="ab cl px py hx pz" role="separator"><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc qd"/><span class="qa bw bk qb qc"/></div><div class="im in io ip iq"><h2 id="33b1" class="lr ls je bd lt lu lv dn lw lx ly dp lz ma mb mc md me mf mg mh mi mj mk ml jk bi translated">参考</h2><div class="is it gp gr iu lc"><a href="https://betterprogramming.pub/flutter-unit-testing-the-beginners-guide-35105164722e" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd jo gy z fp lh fr fs li fu fw jn bi translated">颤振单元试验——初学者指南</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">单元测试是自动化测试过程的一部分，在这个过程中测试小的代码单元</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">better编程. pub</p></div></div><div class="ll l"><div class="qg l ln lo lp ll lq ja lc"/></div></div></a></div><figure class="oe of og oh gt iv"><div class="bz fp l di"><div class="qh qi l"/></div></figure><figure class="oe of og oh gt iv"><div class="bz fp l di"><div class="qh qi l"/></div></figure><h1 id="fe0d" class="qj ls je bd lt qk ql qm lw qn qo qp lz kt qq ku md kw qr kx mh kz qs la ml qt bi translated">感谢您的阅读！</h1><p id="db22" class="pw-post-body-paragraph ng nh je mo b mp mq ko nj mr ms kr nl ma nw nn no me nx nq nr mi ny nt nu mw im bi translated">我试图创造尽可能简单的例子。希望你喜欢。</p><p id="440b" class="pw-post-body-paragraph ng nh je mo b mp ni ko nj mr nk kr nl ma nm nn no me np nq nr mi ns nt nu mw im bi translated">如果你喜欢这篇文章，请点击👏按钮(你知道你可以升到50吗？)</p></div></div>    
</body>
</html>