<html>
<head>
<title>Podman and Skopeo on macOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">macOS上的波德曼和斯科佩奥</h1>
<blockquote>原文：<a href="https://itnext.io/podman-and-skopeo-on-macos-1b3b9cf21e60?source=collection_archive---------3-----------------------#2019-12-18">https://itnext.io/podman-and-skopeo-on-macos-1b3b9cf21e60?source=collection_archive---------3-----------------------#2019-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9dd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几年来，Docker是围绕容器做一切事情的工具:构建、管理、运行和调试映像。随着容器和<a class="ae kl" href="https://www.opencontainers.org/" rel="noopener ugc nofollow" target="_blank"> OCI </a>标准化倡议的日益流行，开源社区中出现了其他工具。主要动机是不再需要一个需要root访问的守护进程。</p><p id="6e80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://podman.io/" rel="noopener ugc nofollow" target="_blank"> Podman </a>、<a class="ae kl" href="https://github.com/containers/skopeo" rel="noopener ugc nofollow" target="_blank"> Skopeo </a>和<a class="ae kl" href="https://buildah.io/" rel="noopener ugc nofollow" target="_blank"> Buildah </a>是一套工具，可以用来管理和运行容器映像。它们与Docker镜像兼容，并且大部分遵循相同的命令行语法来实现简单的切换。快速介绍见:<a class="ae kl" href="https://servicesblog.redhat.com/2019/10/09/say-hello-to-buildah-podman-and-skopeo/" rel="noopener ugc nofollow" target="_blank">向Buildah、Podman和Skopeo问好</a>和<a class="ae kl" href="https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/" rel="noopener ugc nofollow" target="_blank"> Podman和Buildah for Docker用户</a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/584c0784cca847139d019af163b05dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*iWbQsWRfeVyiJ9bqZUJ_2Q.png"/></div></figure><p id="3e6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，这些工具是为Linux创建的。虽然通常需要Linux主机来运行容器，但Docker桌面应用程序运行虚拟机来提供macOS和Windows上的无缝体验。围绕这些新工具的工作正在进行，以便在非Linux主机上提供类似的透明解决方案，但是在撰写本文时，他们需要一些手工准备。让我们看看这到底意味着什么。</p><h1 id="546f" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">波德曼远程客户端</h1><p id="2664" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">Podman是启动和管理容器的工具。在macOS上，我们必须使用瘦<a class="ae kl" href="https://github.com/containers/libpod/blob/master/docs/tutorials/mac_client.md" rel="noopener ugc nofollow" target="_blank"> <em class="lx">远程客户端</em> </a>连接到运行在Linux主机上的真正的Podman进程——可以是一个<a class="ae kl" href="#a900" rel="noopener ugc nofollow"> Linux虚拟机，如本文后面的</a>所述。以下是配置<em class="lx">远程客户端</em>与Linux主机协同工作的主要步骤:</p><ul class=""><li id="91e9" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">从<code class="fe mh mi mj mk b">https://github.com/boot2podman/libpod/releases/</code>下载<em class="lx">远程客户端</em>二进制<em class="lx"> </em></li><li id="f652" class="ly lz iq jp b jq ml ju mm jy mn kc mo kg mp kk md me mf mg bi translated">将基于<a class="ae kl" href="https://www.ssh.com/ssh/authorized-key" rel="noopener ugc nofollow" target="_blank">密钥的ssh </a>设置为Linux主机的root我们现在假设主机名<em class="lx">Linux host</em>——因此<code class="fe mh mi mj mk b">ssh root@linuxhost</code>必须与我们的Mac上的普通用户一起工作:</li></ul><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="61ff" class="mu kv iq mk b gy mv mw l mx my">$ ssh-keygen<br/>$ cat ~/.ssh/id_rsa.pub<br/>ssh-rsa AAAAB3...</span><span id="f639" class="mu kv iq mk b gy mz mw l mx my"># Login to the Linux host somehow and append the content of your id_rsa.pub to /root/.ssh/authorized_keys.</span><span id="d564" class="mu kv iq mk b gy mz mw l mx my"># Then ssh as root should work from Mac:<br/>$ <!-- -->ssh root@linuxhost<br/>[root@<!-- -->linuxhost<!-- --> ~]#</span></pre><ul class=""><li id="42bd" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">Linux主机需要安装Podman并启动<a class="ae kl" href="https://www.projectatomic.io/blog/2018/05/podman-varlink/" rel="noopener ugc nofollow" target="_blank"><em class="lx">var link</em></a>socket<em class="lx">io . Podman . socket</em>(见下面的<a class="ae kl" href="#a900" rel="noopener ugc nofollow">)。这被<em class="lx">远程客户端</em>用来执行调用Podman的API的命令。</a></li><li id="87ec" class="ly lz iq jp b jq ml ju mm jy mn kc mo kg mp kk md me mf mg bi translated">运行<em class="lx">远程客户端</em>指向Linux主机:<br/>T0】</li><li id="61ad" class="ly lz iq jp b jq ml ju mm jy mn kc mo kg mp kk md me mf mg bi translated">可以通过创建一个<a class="ae kl" href="https://www.mankier.com/5/podman-remote.conf" rel="noopener ugc nofollow" target="_blank"><em class="lx">pod man-remote . conf</em></a>文件来跳过这些连接参数:</li></ul><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="ce6d" class="mu kv iq mk b gy mv mw l mx my">$ cat &lt;&lt;EOF &gt;$HOME/.config/containers/podman-remote.conf<br/>[connections]<br/>    [connections.host1]<br/>    destination = "linuxhost"<br/>    username = "root"<br/>    default = true<br/>EOF</span><span id="9dca" class="mu kv iq mk b gy mz mw l mx my"># With the remoting file configured we can run podman simply as:</span><span id="27c4" class="mu kv iq mk b gy mz mw l mx my">$ podman images<br/>REPOSITORY   TAG   IMAGE ID   CREATED   SIZE</span></pre><h1 id="69b1" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">让我们波德曼</h1><p id="bdb3" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">简单的信息命令如预期的那样工作。当然，图像是存储的，容器运行在Linux主机上，而不是我们的Mac上。同样，我们运行的<em class="lx"> podman </em>只是连接到运行在我们的Linux主机上的真正的podman进程的<em class="lx">远程客户端</em>。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="6687" class="mu kv iq mk b gy mv mw l mx my">$ podman version<br/>Client:<br/>Version:            1.6.1-dev<br/>RemoteAPI Version:  1<br/>Go Version:         go1.12.9<br/>OS/Arch:            darwin/amd64</span><span id="b46b" class="mu kv iq mk b gy mz mw l mx my">Service:<br/>Version:            1.6.2<br/>RemoteAPI Version:  1<br/>Go Version:         go1.13.1<br/>OS/Arch:            linux/amd64</span><span id="0370" class="mu kv iq mk b gy mz mw l mx my">$ podman images<br/>REPOSITORY                TAG      IMAGE ID      CREATED      SIZE<br/>docker.io/library/tomcat  latest   6408fdc94212  2 weeks ago  519 MB<br/>docker.io/library/nginx   latest   231d40e811cd  2 weeks ago  130 MB</span><span id="3e0d" class="mu kv iq mk b gy mz mw l mx my">$ podman ps<br/>CONTAINER ID  IMAGE                            ... <br/>3a17822f599c  docker.io/library/tomcat:latest  ...</span><span id="cff6" class="mu kv iq mk b gy mz mw l mx my">$ podman inspect docker.io/library/tomcat<br/>[ { "Id": "6408fdc9421224b1034..."<br/>...</span></pre><p id="9877" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们尝试最常见的任务:运行容器。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="94ba" class="mu kv iq mk b gy mv mw l mx my">$ podman run --name mytomcat -d docker.io/tomcat<br/>3a17822f5...</span><span id="931f" class="mu kv iq mk b gy mz mw l mx my">$ podman logs -f mytomcat<br/>11-Dec-2019 03:30:03.348 INFO [main] org.apache.catalina.startup...</span><span id="0fee" class="mu kv iq mk b gy mz mw l mx my">$ podman stop mytomcat<br/>3a17822f5...</span><span id="1ac5" class="mu kv iq mk b gy mz mw l mx my">$ podman start mytomcat<br/>3a17822f5...</span><span id="bb2b" class="mu kv iq mk b gy mz mw l mx my">$ podman attach mytomcat<br/>11-Dec-2019 03:30:03.348 INFO [main] org.apache.catalina.startup...</span></pre><p id="3588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与在Linux上使用Podman相比，一个不同之处在于，在交互模式下，按Ctrl+C不是停止容器，而是断开连接，容器继续在后台运行，因此如果我们想要停止它，我们必须在之后运行<code class="fe mh mi mj mk b">podman stop </code>。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="b782" class="mu kv iq mk b gy mv mw l mx my">$ podman run -p 8080:80 -d nginx<br/>31c5b702... </span><span id="fbfc" class="mu kv iq mk b gy mz mw l mx my">$ curl <a class="ae kl" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a><br/>curl: (7) Failed to connect to localhost port 8080</span><span id="8188" class="mu kv iq mk b gy mz mw l mx my">$ curl <a class="ae kl" href="http://linuxhost:8080/" rel="noopener ugc nofollow" target="_blank">http://linuxhost:8080/</a><br/>&lt;!DOCTYPE html&gt;...</span></pre><p id="915f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们试图将一个目录作为一个卷挂载到容器中，我们会遇到类似的问题。该目录必须存在于Linux主机上，而不是我们的Mac上。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="07cc" class="mu kv iq mk b gy mv mw l mx my"># Trying to use a local directory<br/>$ mkdir -p /Users/bszeti/tmp/html<br/>$ podman run -v /Users/bszeti/tmp/html:/usr/share/nginx/html nginx<br/>Error: error checking path "/Users/bszeti/tmp/html": stat /Users/bszeti/tmp/html: no such file or directory</span><span id="1947" class="mu kv iq mk b gy mz mw l mx my"># The directory is expected on the Linux host<br/>$ ssh root@linuxhost 'mkdir -p /var/www'<br/>$ podman run -v /var/www:/usr/share/nginx/html nginx<br/>f89ade8d33...</span></pre><h2 id="2c96" class="mu kv iq bd kw na nb dn la nc nd dp le jy ne nf li kc ng nh lm kg ni nj lq nk bi translated">证明</h2><p id="e680" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">一些图像注册需要认证。传统上，您可以通过以下三种方式之一来执行此授权:</p><ul class=""><li id="157d" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">在连接到注册表之前做一个初始的<code class="fe mh mi mj mk b">podman login</code></li><li id="7074" class="ly lz iq jp b jq ml ju mm jy mn kc mo kg mp kk md me mf mg bi translated">手动创建一个<code class="fe mh mi mj mk b"><a class="ae kl" href="https://www.projectatomic.io/blog/2016/03/docker-credentials-store/" rel="noopener ugc nofollow" target="_blank">authfile</a></code></li><li id="9980" class="ly lz iq jp b jq ml ju mm jy mn kc mo kg mp kk md me mf mg bi translated">在命令行中传递我们的凭据。</li></ul><p id="3c57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，当使用<em class="lx">远程客户端</em>时，这些选项似乎都不起作用。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="89c9" class="mu kv iq mk b gy mv mw l mx my">$ podman pull registry.redhat.io/ubi8/ubi<br/>Error... unable to retrieve auth token: invalid username/password</span><span id="d9e0" class="mu kv iq mk b gy mz mw l mx my">$ podman login registry.redhat.io<br/>Error: unrecognized command `podman login`</span><span id="76b0" class="mu kv iq mk b gy mz mw l mx my">$ podman pull --creds 'bszeti@redhat.com:mysecret' registry.redhat.io/ubi8/ubi<br/>Error... unable to retrieve auth token: invalid username/password</span><span id="462f" class="mu kv iq mk b gy mz mw l mx my">$ podman pull --authfile auth.json registry.redhat.io/ubi8/ubi<br/>Error: unknown flag: --authfile</span></pre><p id="09e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据波德曼项目，这是为<em class="lx">远程客户端</em>进行的<a class="ae kl" href="https://github.com/containers/libpod/issues/4039" rel="noopener ugc nofollow" target="_blank">工作。当前的解决方法是在从经过认证的注册表中提取之前，使用<code class="fe mh mi mj mk b">podman login</code>直接登录到Linux主机上。</a></p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="3000" class="mu kv iq mk b gy mv mw l mx my">$ ssh root@linuxhost</span><span id="3fcb" class="mu kv iq mk b gy mz mw l mx my">[root@<!-- -->linuxhost<!-- --> ~]# podman login registry.redhat.io<br/>Username: bszeti@redhat.com<br/>Password:<br/>Login Succeeded!</span><span id="ffc0" class="mu kv iq mk b gy mz mw l mx my"># Check /run/containers/0/auth.json or /run/user/0/containers/auth.json<br/>[root@localhost ~]# cat /run/user/0/containers/auth.json<br/>{<br/> "auths": {<br/>  "registry.redhat.io": {<br/>    "auth": "...&lt;username:password in base64&gt;..."<br/>  }<br/> }<br/>}</span><span id="23be" class="mu kv iq mk b gy mz mw l mx my">[root@localhost ~]# exit</span><span id="4f73" class="mu kv iq mk b gy mz mw l mx my">$ podman pull registry.redhat.io/ubi8/ubi<br/>Getting image source signatures<br/>Copying blob sha256:0e8ea26...</span></pre><p id="6d7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">对Podman v1.8.0 </em>的更新:<br/>似乎有一个新功能，当没有活动的<em class="lx"> ssh </em>会话时，它会删除默认的<code class="fe mh mi mj mk b">/run/user/0/containers/auth.json</code>文件。这增加了安全性，但是使得使用<em class="lx">远程客户端</em>更加困难，因为<a class="ae kl" href="https://github.com/containers/libpod/blob/v1.8.0/cmd/podman/pull.go#L60" rel="noopener ugc nofollow" target="_blank">不支持</a>参数<code class="fe mh mi mj mk b">--authfile</code>。一个解决方法是在默认的docker配置路径中复制<code class="fe mh mi mj mk b">podman login</code>后的<code class="fe mh mi mj mk b">auth.json</code>，这个路径似乎也被Podman使用:</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="795b" class="mu kv iq mk b gy mv mw l mx my">[root@localhost ~]# mkdir /root/.docker/<br/>[root@localhost ~]# cp /run/user/0/containers/auth.json /root/.docker/config.json</span></pre><blockquote class="nl nm nn"><p id="190e" class="jn jo lx jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated">要登录到<em class="iq"> registry.redhat.io </em>，最好创建一个<a class="ae kl" href="https://access.redhat.com/terms-based-registry/" rel="noopener ugc nofollow" target="_blank">注册表服务帐户令牌</a>，而不是使用您自己的凭证，因为密码简单地存储在base64的auth文件中。</p></blockquote><h2 id="adf3" class="mu kv iq bd kw na nb dn la nc nd dp le jy ne nf li kc ng nh lm kg ni nj lq nk bi translated">构建图像</h2><p id="ffe1" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">与波德曼匹配的构建工具是<a class="ae kl" href="https://github.com/containers/buildah" rel="noopener ugc nofollow" target="_blank"> Buildah </a>。它不能以任何形式直接在macOS上使用，但是它的功能可以通过幕后的<code class="fe mh mi mj mk b">podman build</code>命令来利用。这样我们就可以用Podman从Dockerfile文件中构建图像。</p><blockquote class="nl nm nn"><p id="b045" class="jn jo lx jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated"><em class="iq"> podman-remote.conf </em>文件似乎被<code class="fe mh mi mj mk b">podman build </code>命令忽略了，所以我们要给每个命令加上<code class="fe mh mi mj mk b">--remote-host linuxhost --username root</code>。</p></blockquote><p id="32ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用一个简单的<em class="lx"> Dockerfile </em>来构建一个服务于静态文件的映像。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="341e" class="mu kv iq mk b gy mv mw l mx my">FROM registry.redhat.io/ubi8/ubi</span><span id="ab4a" class="mu kv iq mk b gy mz mw l mx my">RUN yum update -y<br/>RUN yum install -y httpd</span><span id="8440" class="mu kv iq mk b gy mz mw l mx my">COPY index.html /var/www/html/</span><span id="2366" class="mu kv iq mk b gy mz mw l mx my">ENTRYPOINT [ "/usr/sbin/httpd" ]<br/>CMD [ "-D", "FOREGROUND" ]</span></pre><p id="2ed9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将<em class="lx"> Dockerfile </em>和<em class="lx">index.html</em>放在Mac上的一个目录中，并从那里运行<code class="fe mh mi mj mk b">podman build </code>来构建映像。新的映像将被构建并存储在Linux主机上，可以像所有提取的映像一样运行。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="bc21" class="mu kv iq mk b gy mv mw l mx my">$ podman --remote-host linuxhost --username root build --tag mytag .<br/>... build log ...</span><span id="698f" class="mu kv iq mk b gy mz mw l mx my">$ podman images<br/>REPOSITORY       TAG      IMAGE ID       CREATED             SIZE<br/>localhost/mytag  latest   56d835d0d82f   About a minute ago  557 MB</span><span id="1402" class="mu kv iq mk b gy mz mw l mx my">$ podman run -d -p 8080:80 localhost/mytag<br/>$ curl <a class="ae kl" href="http://fedora.vbox:8080/" rel="noopener ugc nofollow" target="_blank">http://linuxhost:8080/</a><br/>... index.html content ... </span></pre><p id="1c38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">对Podman v1.8.0的更新:</em><br/><code class="fe mh mi mj mk b">build</code>命令似乎不起作用，找不到从Mac发送到Linux主机的编译源代码。</p><h2 id="5380" class="mu kv iq bd kw na nb dn la nc nd dp le jy ne nf li kc ng nh lm kg ni nj lq nk bi translated">推送图像</h2><p id="bf39" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated"><em class="lx"> remote-client v.1.6.0 </em>曾经有一个关于<code class="fe mh mi mj mk b">push</code>命令的<a class="ae kl" href="https://github.com/containers/libpod/issues/4706" rel="noopener ugc nofollow" target="_blank"> bug </a>，所以我们不能将图像直接上传到远程图像注册中心。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="f3a4" class="mu kv iq mk b gy mv mw l mx my">$ podman push localhost/mytag:latest quay.io/bszeti/myimage:latest<br/>panic: runtime error: invalid memory address or nil pointer dereference</span></pre><p id="f31c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">对Podman v1.8.0的更新:</em><br/><code class="fe mh mi mj mk b">push</code>命令效果更好，但有时会丢一条<code class="fe mh mi mj mk b">Error: unexpected EOF</code>消息。添加<code class="fe mh mi mj mk b">--log-level debug</code>似乎有助于这个问题。</p><p id="56c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为解决方法，我们可以将图像保存为tar文件(在我们的Mac上)，并使用Skopeo上传到注册表中:</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="c664" class="mu kv iq mk b gy mv mw l mx my"># Save image as a docker-archive (default format)<br/>$ podman save localhost/mytag:latest -o /tmp/mytag.latest.tar</span><span id="6429" class="mu kv iq mk b gy mz mw l mx my"># Upload image into registry<br/>$ skopeo copy docker-archive:/tmp/mytag.latest.tar docker://quay.io/bszeti/mytag:latest</span></pre><blockquote class="nl nm nn"><p id="3d16" class="jn jo lx jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated">以<code class="fe mh mi mj mk b">docker-dir</code>或<code class="fe mh mi mj mk b">oci-dir</code>格式<code class="fe mh mi mj mk b">podman save</code>保存时出现意外的权限错误。</p></blockquote><h2 id="a900" class="mu kv iq bd kw na nb dn la nc nd dp le jy ne nf li kc ng nh lm kg ni nj lq nk bi translated">设置定制的Linux虚拟机</h2><p id="f90d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">下面简单介绍一下如何设置一个Linux虚拟机来尝试Podman:</p><ul class=""><li id="a183" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated"><a class="ae kl" href="https://www.virtualbox.org/wiki/Downloads" rel="noopener ugc nofollow" target="_blank">虚拟盒子</a> v6.0</li><li id="cf77" class="ly lz iq jp b jq ml ju mm jy mn kc mo kg mp kk md me mf mg bi translated"><a class="ae kl" href="https://getfedora.org/en/workstation/download/" rel="noopener ugc nofollow" target="_blank"> Fedora 31工作站</a> —使用<a class="ae kl" href="https://download.fedoraproject.org/pub/fedora/linux/releases/31/Workstation/x86_64/iso/Fedora-Workstation-Live-x86_64-31-1.9.iso" rel="noopener ugc nofollow" target="_blank"> x86_64 DVD ISO </a>安装在虚拟机中</li></ul><p id="0bfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个网络适配器:</p><ul class=""><li id="f5f4" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated"><strong class="jp ir"> NAT </strong>:虚拟机可以通过这个接口访问互联网，但是没有人可以访问虚拟机。</li><li id="1763" class="ly lz iq jp b jq ml ju mm jy mn kc mo kg mp kk md me mf mg bi translated"><strong class="jp ir">主机专用适配器</strong>:从macOS主机访问VM需要这个接口。分配的IP在虚拟机的生命周期内不会改变。在Mac的hosts文件中添加一个条目是一个好主意，这样我们就可以用主机名访问VM。<br/> <code class="fe mh mi mj mk b">sudo sh -c 'echo 192.168.99.100 linuxhost &gt;&gt;/etc/hosts'</code></li></ul><p id="1ac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过以root用户身份在虚拟机上运行以下命令，准备Linux虚拟机运行Podman:</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="6643" class="mu kv iq mk b gy mv mw l mx my"># Install SSH server <br/>yum install openssh-server<br/>systemctl start sshd.service<br/>systemctl enable sshd.service</span><span id="0369" class="mu kv iq mk b gy mz mw l mx my"># Optionally if podman was missing:<br/>yum -y install podman<br/># Optionally get the latest test version<br/>yum distro-sync --enablerepo=updates-testing podman</span><span id="8421" class="mu kv iq mk b gy mz mw l mx my"># Enable Podman socket<br/>systemctl start io.podman.socket<br/>systemctl enable io.podman.socket</span></pre><p id="70ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要为<em class="lx">远程客户端</em>设置基于密钥的ssh访问，如前面章节中的<a class="ae kl" href="#546f" rel="noopener ugc nofollow">所述。之后，只要VM启动并运行，我们就应该能够使用Podman。</a></p><h2 id="5e0f" class="mu kv iq bd kw na nb dn la nc nd dp le jy ne nf li kc ng nh lm kg ni nj lq nk bi translated">Podman-machine作为Linux虚拟机</h2><p id="3c2c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">使用<a class="ae kl" href="https://github.com/boot2podman/machine" rel="noopener ugc nofollow" target="_blank"> podman-machine </a>为Podman建立一个Linux VM有一个更简单的方法。参见相关的<a class="ae kl" href="https://developers.redhat.com/blog/2020/02/12/podman-for-macos-sort-of" rel="noopener ugc nofollow" target="_blank">博客</a>，它描述了如何安装一个拥有所需工具和配置设置的Linux VM。它也可以与<em class="lx">远程客户端</em>一起使用。</p><p id="ec84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装<em class="lx"> podman-machine </em>并创建一个虚拟机:</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="a977" class="mu kv iq mk b gy mv mw l mx my"># Download podman machine<br/>$ curl -L <a class="ae kl" href="https://github.com/boot2podman/machine/releases/download/v0.16/podman-machine.darwin-amd64" rel="noopener ugc nofollow" target="_blank">https://github.com/boot2podman/machine/releases/download/v0.16/podman-machine.darwin-amd64</a> --output /usr/local/bin/podman-machine<br/>$ chmod +x /usr/local/bin/podman-machine</span><span id="ac96" class="mu kv iq mk b gy mz mw l mx my"># Use the Fedora31 VM image from the blog. Change the shared directory location to a valid path<br/>$ podman-machine create --virtualbox-boot2podman-url <a class="ae kl" href="https://github.com/snowjet/boot2podman-fedora-iso/releases/download/d1bb19f/boot2podman-fedora.iso" rel="noopener ugc nofollow" target="_blank">https://github.com/snowjet/boot2podman-fedora-iso/releases/download/d1bb19f/boot2podman-fedora.iso</a> --virtualbox-memory="4096" --virtualbox-share-folder <strong class="mk ir">~/code</strong>:code fedbox</span><span id="002d" class="mu kv iq mk b gy mz mw l mx my"># (Optional) Upgrade Podman in VM<br/>$ podman-machine upgrade fedbox</span><span id="6b89" class="mu kv iq mk b gy mz mw l mx my"># Verify<br/>$ podman-machine ssh fedbox<br/>[tc@fedbox ~]$ podman version</span></pre><p id="4198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置<em class="lx">远程客户端</em>使用虚拟机:</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="c8ff" class="mu kv iq mk b gy mv mw l mx my"># Check IP of the VM<br/>$ podman-machine ip fedbox<br/>192.168.99.103</span><span id="62fb" class="mu kv iq mk b gy mz mw l mx my"># Check SSH key location<br/>$ podman-machine config fedbox<br/>...<br/>--identity-file=/Users/bszeti/.local/machine/machines/fedbox/id_rsa</span><span id="2012" class="mu kv iq mk b gy mz mw l mx my"># Set podman-remote.conf as below - identity_file requires v1.6.2+<br/>$ cat $HOME/.config/containers/podman-remote.conf<br/>[connections]<br/>    [connections.host1]<br/>    destination = "192.168.99.103"<br/>    username = "root"<br/>    default = true<br/>    identity_file = "/Users/bszeti/.local/machine/machines/fedbox/id_rsa"</span><span id="13f5" class="mu kv iq mk b gy mz mw l mx my"># Verify<br/>$ podman version</span></pre><blockquote class="nl nm nn"><p id="7ef0" class="jn jo lx jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated">注意:在这台机器上，<code class="fe mh mi mj mk b">auth.json</code>文件的默认路径是<code class="fe mh mi mj mk b">/run/containers/0/auth.json</code></p></blockquote><h1 id="9757" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">斯科佩奥</h1><p id="2ce6" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">Skopeo 是一个简单的命令行工具，用于与注册中心交互和管理——检查、复制和删除——集装箱图像。虽然这些任务也可以用Podman来完成，但Skopeo是一种更轻量级的“做一件事并把它做好”的工具。</p><p id="545b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mh mi mj mk b">brew install skopeo</code>可以很容易地将二进制文件安装在macOS上，我们根本不需要Linux主机——可以随意停止您的Linux VM。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="277f" class="mu kv iq mk b gy mv mw l mx my">$ skopeo -v<br/>skopeo version 0.1.40</span></pre><p id="b13a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们做任何有用的事情之前，我们需要创建一个<a class="ae kl" href="https://www.mankier.com/5/containers-policy.json" rel="noopener ugc nofollow" target="_blank"> containers-policy </a>文件，该文件包含决定我们是否接受一个提取的图像的验证规则。默认位置是<code class="fe mh mi mj mk b">/etc/containers/policy.json</code>，或者我们可以指向另一个添加了<code class="fe mh mi mj mk b">--policy &lt;policy file&gt;</code>参数的文件。或者，我们可以使用<code class="fe mh mi mj mk b">--insecure-policy</code>参数接受所有图像。注意，这些策略参数是“全局”参数，必须添加在动作命令之前(即<code class="fe mh mi mj mk b">inspect</code>、<code class="fe mh mi mj mk b">copy</code>、<code class="fe mh mi mj mk b">delete</code>等)。最简单的方法是创建一个策略文件，允许所有注册表位于默认位置:</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="5853" class="mu kv iq mk b gy mv mw l mx my">$ sudo sh -c 'cat &gt;/etc/containers/policy.json' &lt;&lt;EOF <br/>{<br/>    "default": [<br/>        {<br/>            "type": "insecureAcceptAnything"<br/>        }<br/>    ],<br/>    "transports":<br/>        {<br/>            "docker-daemon":<br/>                {<br/>                    "": [{"type":"insecureAcceptAnything"}]<br/>                }<br/>        }<br/>}<br/>EOF</span></pre><p id="3463" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了访问需要认证的注册中心，我们需要以某种方式传递凭证。我们有两个选择:</p><ul class=""><li id="596f" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated"><strong class="jp ir">用户名:密码</strong>:根据命令使用<code class="fe mh mi mj mk b">--creds</code>、<code class="fe mh mi mj mk b">--src-creds</code>、<code class="fe mh mi mj mk b">--dest-creds</code>参数</li><li id="b61b" class="ly lz iq jp b jq ml ju mm jy mn kc mo kg mp kk md me mf mg bi translated"><strong class="jp ir"> authfile </strong> : Docker auth文件，同上，用于Podman。可以通过<code class="fe mh mi mj mk b">--authfile &lt;auth file&gt;</code>添加。如果没有设置，Skopeo会查看默认位置:<code class="fe mh mi mj mk b">$HOME/.docker/config.json</code>。以下是一个示例文件:</li></ul><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="20b9" class="mu kv iq mk b gy mv mw l mx my">{<br/> "auths": {<br/>  "registry.redhat.io": {<br/>    "auth": "&lt;username:password in base64&gt;"<br/>  },<br/>  "quay.io": {<br/>    "auth": "bXl1c2VyOm15c2VjcmV0"<br/>  }<br/> }<br/>}</span></pre><p id="3ff4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">信任或忽略TLS证书可以通过基于正在使用的Skopeo命令的各种参数来实现:<code class="fe mh mi mj mk b">--cert-dir</code>、<code class="fe mh mi mj mk b">--tls-verify</code>、<code class="fe mh mi mj mk b">--src-cert-dir</code>、<code class="fe mh mi mj mk b">--src-tl-verify</code>、<code class="fe mh mi mj mk b">--dest-cert-dir</code>、<code class="fe mh mi mj mk b">--dest-tls-verify</code>。</p><h2 id="5afb" class="mu kv iq bd kw na nb dn la nc nd dp le jy ne nf li kc ng nh lm kg ni nj lq nk bi translated">检查</h2><p id="4c54" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">Skopeo可用于从注册表中读取有关图像的信息，而无需先下载图像:</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="8e54" class="mu kv iq mk b gy mv mw l mx my">$ skopeo inspect docker://quay.io/quay/busybox:latest<br/>{<br/>    "Digest": "sha256:91aa1e3e55765a568...",<br/>    "RepoTags": ...</span></pre><p id="345e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于支持映像的多个操作系统版本的注册表，需要添加全局参数<code class="fe mh mi mj mk b">--override-os linux</code>，否则默认为不存在的MacOS <code class="fe mh mi mj mk b">OS darwin</code>。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="f1a5" class="mu kv iq mk b gy mv mw l mx my">$ skopeo<strong class="mk ir"> --override-os linux</strong> inspect docker://docker.io/nginx</span><span id="868e" class="mu kv iq mk b gy mz mw l mx my">$ skopeo <strong class="mk ir">--override-os linux</strong> inspect --authfile myauth.json docker://registry.redhat.io/openshift3/jenkins-2-rhel7</span></pre><p id="defa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关详细信息(如层、入口点、cmd ),请查看注册表的原始响应:</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="bf3f" class="mu kv iq mk b gy mv mw l mx my">$ skopeo --override-os linux inspect <strong class="mk ir">--config --raw</strong> docker://docker.io/nginx | jq .</span></pre><p id="8ae3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Inspect也可用于以某种格式保存在本地磁盘上的图像(例如，如果图像是使用<code class="fe mh mi mj mk b">skopeo copy</code>下载的):</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="633e" class="mu kv iq mk b gy mv mw l mx my"># Image saved as docker-archive<br/>$ skopeo inspect docker-archive:/tmp/mytag.latest.tar</span><span id="6f10" class="mu kv iq mk b gy mz mw l mx my"># Inspecting oci-archive images tries to use /var/tmp/, needs sudo<br/>$ sudo skopeo inspect oci-archive:/tmp/mytag.latest.oci</span><span id="a5b4" class="mu kv iq mk b gy mz mw l mx my"># Image saved as directory or oci directory<br/>$ skopeo inspect dir:/tmp/mytag-latest-dir/<br/>$ skopeo inspect oci:/tmp/mytag-latest-oci/</span></pre><h2 id="d9e8" class="mu kv iq bd kw na nb dn la nc nd dp le jy ne nf li kc ng nh lm kg ni nj lq nk bi translated">复制</h2><p id="c7a6" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们用Skopeo做的最常见的任务是将图像从一个注册表复制到另一个注册表。需要几个参数，但是在理解了我们在上面的<code class="fe mh mi mj mk b">inspect</code>命令中使用的基本参数之后，它们就很明显了。在以下示例中，我们将从<code class="fe mh mi mj mk b">registry.redhat.io</code>向<code class="fe mh mi mj mk b">quay.io</code>复制一个Jenkins映像:</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="84a6" class="mu kv iq mk b gy mv mw l mx my"># Simple case - policy and auth file prepared</span><span id="9979" class="mu kv iq mk b gy mz mw l mx my">$ skopeo --override-os linux copy docker://registry.redhat.io/openshift3/jenkins-2-rhel7:v3.11 docker://quay.io/bszeti/jenkins:v3.11</span></pre><blockquote class="nl nm nn"><p id="46e7" class="jn jo lx jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated">注意:<code class="fe mh mi mj mk b">--override-os linux</code>可能需要，也可能不需要，这取决于注册表，就像<code class="fe mh mi mj mk b">skopeo inspect</code>一样</p></blockquote><p id="02cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以将之前讨论过的身份验证和TLS参数分层，例如在专用存储库之间复制映像:</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="9214" class="mu kv iq mk b gy mv mw l mx my">$ skopeo --insecure-policy copy <br/>--src-tls-verify=false --dest-tls-verify=false <br/>--src-creds 'devuser:secret' --dest-creds 'myuser:secret' docker://devregistry.host:5000/myteam/myapp:v1 docker://myregistry.host:8443/myteam/myapp:mytag</span></pre><p id="5b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以使用<code class="fe mh mi mj mk b">skopeo copy</code>来标记图像。Skopeo检查这些层是否已经存在于目标注册表中，这样就不会复制不必要的数据。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="5446" class="mu kv iq mk b gy mv mw l mx my">$ skopeo copy <br/>docker://myregistry:8443/myteam/myapp:v1 docker://myregistry:8443/myteam/myapp:qa</span></pre><p id="c0fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也可以使用<code class="fe mh mi mj mk b">copy</code>命令将图像以不同的格式保存在本地磁盘上。</p><pre class="kn ko kp kq gt mq mk mr ms aw mt bi"><span id="5fac" class="mu kv iq mk b gy mv mw l mx my">$ skopeo copy docker://docker.io/nginx docker-archive:/tmp/nginx.tar<br/>$ skopeo copy docker://docker.io/nginx oci-archive:/tmp/nginx.oci<br/>$ skopeo copy docker://docker.io/nginx dir:/tmp/nginx-dir<br/>$ skopeo copy docker://docker.io/nginx oci:/tmp/nginx-oci</span></pre><blockquote class="nl nm nn"><p id="144e" class="jn jo lx jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated">注意:在某些情况下，Skopeo在管理归档文件时会使用<code class="fe mh mi mj mk b">/var/tmp</code>下的临时目录，所以我们可能会遇到权限问题，除非它以root用户身份运行。</p></blockquote><h1 id="83be" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">摘要</h1><p id="dc39" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">当可以放心地在Linux机器上使用时，新的一套无后台、开源的容器管理工具已经达到了成熟的水平。不幸的是，它们还没有完全融入macOS。然而，通过一些手工准备和一些小的注意事项，我们现在可以开始使用这些工具了。希望这个指南已经帮助你使这个旅程变得不那么复杂，同时正在进行的工作带给我们一个更加无缝的体验。</p></div></div>    
</body>
</html>