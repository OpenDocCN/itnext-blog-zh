<html>
<head>
<title>Git Repository Transfer Keeping All History</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git存储库转移保留所有历史记录</h1>
<blockquote>原文：<a href="https://itnext.io/git-repository-transfer-keeping-all-history-670fe04cd5e4?source=collection_archive---------0-----------------------#2019-12-24">https://itnext.io/git-repository-transfer-keeping-all-history-670fe04cd5e4?source=collection_archive---------0-----------------------#2019-12-24</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/c52c1516c6d17ef8796b7e80bc27dafd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EzUbF0FNgAnmKw1b"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">照片由<a class="ae jh" href="https://unsplash.com/@giamboscaro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Giammarco Boscaro </a>在<a class="ae jh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="8089" class="pw-subtitle-paragraph kh jj jk bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">如何复制您的Git repo并保留所有以前的提交、分支和标记</h2></div><p id="768a" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Git现在是版本控制的事实标准，无论是否是分布式的。它有大量强大的功能，其中一些功能被大多数普通用户忽略了。其中一个特性是Git能够将您的本地存储库与多个远程存储库连接起来，并且可以根据您的需要删除和添加远程位置。</p><p id="976a" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这篇文章中，我们将使用添加和删除远程存储库的特性来有效地将一个存储库转移到另一个存储库，同时保持所有提交历史、分支和标签不变。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="aaf5" class="md me jk bd mf mg mh mi mj mk ml mm mn kq mo kr mp kt mq ku mr kw ms kx mt mu bi translated">Git遥控器</h1><p id="3600" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">与旧版本控制工具(如CVS和SVN)相比，所有代码都集中在一个存储库中，Git允许代码在无限数量的远程存储库中共存。</p><p id="da7f" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">事实上，Git中原始的、中心的或“起源”存储库的概念只是一个约定。当大多数用户开始同步第一个<code class="fe na nb nc nd b">git clone</code>时，它恰好<em class="lv">是他们开始同步的存储库。</em></p><p id="def5" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">随着项目的进展，存储库的位置和偏好可能会发生变化，所以在开始时曾经的<em class="lv">原点</em>可能会开始变得不相关:</p><figure class="nf ng nh ni gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj ne"><img src="../Images/a5073c8b735e2d87c3777ebd55499621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jIXuOz2ML1rr_5A7hU2Pw.png"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">Git中可以随意引入遥控器(图片由作者提供)</figcaption></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="2c0a" class="md me jk bd mf mg mh mi mj mk ml mm mn kq mo kr mp kt mq ku mr kw ms kx mt mu bi translated">转移方法</h1><p id="289a" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">到目前为止，我们已经确定，您可以拥有任意多的遥控器，它们的名称在Git的生态系统中没有任何重要作用。那么，我们如何利用Git的这个特性将文件从一个远程设备传输到另一个远程设备呢？</p><h2 id="3b83" class="nj me jk bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">丢失所有历史(开发者-上帝模式)</h2><p id="c4cd" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">快速而肮脏的方法是克隆新的、空的存储库，从源存储库中复制/粘贴文件，然后提交/推送。尽管这种方法可能会节省您几分钟的时间，并且除了您已经知道的标准Git命令之外，不需要任何其他命令，但是它有一个严重的缺点。</p><p id="5a5b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因为您是将所有文件提交到新存储库的人，所以您现在成为源存储库的每个文件的唯一作者。保存在源存储库中的任何以前的提交历史现在都将永远丢失，整个项目看起来就像是由一个人(您)创建的。</p><p id="543b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">开发商-上帝综合症得到满足；原作者气死了。</p><h2 id="9b29" class="nj me jk bd mf nk nl dn mj nm nn dp mn li no np mp lm nq nr mr lq ns nt mt nu bi translated">保存历史</h2><p id="5403" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">将资源从一个存储库复制到另一个存储库，同时保持提交历史完整无损，这不仅承认了其他人的原始工作，还可能带来有用的好处。例如，您可以搜索以前的提交消息，找到对您正在研究的问题的解释；如果你意识到一个特定的开发人员容易犯相同类型的错误，你可以很容易地过滤掉他/她的提交来重新检查它们，等等。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="f47c" class="md me jk bd mf mg mh mi mj mk ml mm mn kq mo kr mp kt mq ku mr kw ms kx mt mu bi translated">传输命令</h1><p id="403e" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">如果你搜索如何转移一个Git库，你会得到几种不同的建议，从简单的Git命令序列到纯粹的Git魔术。</p><p id="6f57" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">接下来建议的方法可能不一定是“最好的”，但是，它已经在具有数千个提交的存储库上进行了测试，并且遵循两个基本原则:1/保持完整的提交历史，包括所有分支和标签，以及2/不干扰原始存储库。</p><p id="e8f7" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以，让我们从命令开始。</p><p id="5fd6" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl"> ①从创建旧存储库的镜像克隆开始</strong></p><pre class="nf ng nh ni gu nv nd nw nx aw ny bi"><span id="88c0" class="nj me jk nd b gz nz oa l ob oc">git clone --mirror old-repo-url new-repo</span></pre><p id="f29d" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">用旧repo的Git URL替换<code class="fe na nb nc nd b">old-repo-url</code>,并给将要克隆它的文件夹<code class="fe na nb nc nd b">new-repo</code>起一个合适的名字。</p><p id="e3c0" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl"> ②删除对原始/旧存储库的远程引用</strong></p><pre class="nf ng nh ni gu nv nd nw nx aw ny bi"><span id="0cd4" class="nj me jk nd b gz nz oa l ob oc">cd new-repo<br/>git remote remove origin</span></pre><p id="bae3" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果您的原始存储库包含分支，您可能会得到一个警告，但是您可以忽略它。从技术上讲，这一步是不必要的，因为如上所述，你可以有多个遥控器，但是，它使未来的命令更容易键入，并完全脱离原来的存储库。</p><p id="336c" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl"> ③添加新存储库的远程引用</strong></p><pre class="nf ng nh ni gu nv nd nw nx aw ny bi"><span id="78b5" class="nj me jk nd b gz nz oa l ob oc">git remote add origin new-repo-url</span></pre><p id="0ecb" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">用新存储库的Git URL替换<code class="fe na nb nc nd b">new-repo-url</code>。不言而喻，您应该在您最喜欢的Git管理系统中预先创建新的回购协议。</p><p id="fe79" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl"> ④将所有内容推送到新的存储库</strong></p><pre class="nf ng nh ni gu nv nd nw nx aw ny bi"><span id="bedd" class="nj me jk nd b gz nz oa l ob oc">git push --all<br/>git push --tags</span></pre><p id="882c" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl"> ⑤克隆新的存储库</strong></p><pre class="nf ng nh ni gu nv nd nw nx aw ny bi"><span id="86e5" class="nj me jk nd b gz nz oa l ob oc">cd ..<br/>rm -rf new-repo<br/>git clone new-repo-url new-repo</span></pre><p id="939d" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">用您的新存储库替换<code class="fe na nb nc nd b">new-repo-url</code>和<code class="fe na nb nc nd b">new-repo</code>。</p><p id="4c7c" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这最后一步是必要的，因为步骤(1)中执行的克隆是镜像克隆，不能用于进一步的提交。如果你知道如何转换它，有效地绕过这个重新克隆的步骤，请在评论中告诉我。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="65c1" class="md me jk bd mf mg mh mi mj mk ml mm mn kq mo kr mp kt mq ku mr kw ms kx mt mu bi translated">结论</h1><p id="991e" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">尽管Git的分支和标记允许您有效地将一个存储库用于多种不同的目的，但有时您只想从一个新的存储库开始。在这篇文章中，我们看到了如何将一个Git存储库的内容转移到另一个新的存储库，同时也移动原始存储库的所有提交历史、分支和标记。</p></div></div>    
</body>
</html>