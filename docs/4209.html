<html>
<head>
<title>async, await, and keeping your promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步，等待，信守承诺</h1>
<blockquote>原文：<a href="https://itnext.io/async-await-and-keeping-your-promises-36cee10790cb?source=collection_archive---------1-----------------------#2020-05-16">https://itnext.io/async-await-and-keeping-your-promises-36cee10790cb?source=collection_archive---------1-----------------------#2020-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ac7549c8a097e900ddd04ac1b8600635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OJayZipwJxFeEckP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@cytonn_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cytonn摄影</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4745" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为ECMAScript 2017的一部分引入的<code class="fe lb lc ld le b">async function</code>和<code class="fe lb lc ld le b">await</code>关键字确实在承诺之上提供了非常有用的语法糖。<code class="fe lb lc ld le b">Promise</code>本身在编写异步代码时提供了回调的替代方法。承诺可以被链接，其内置的方法如<code class="fe lb lc ld le b">all</code>、<code class="fe lb lc ld le b">any</code>和<code class="fe lb lc ld le b">race</code>有助于管理多个异步任务。</p><p id="fdd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查下面的例子，这里的<code class="fe lb lc ld le b">getData</code>函数模仿异步行为。在现实世界中，你可以认为它是你的数据层，使用像<code class="fe lb lc ld le b">fetch</code>这样的函数或者第三方库，它们仍然使用回调来进行异步编程。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="b89f" class="ln lo iq le b gy lp lq l lr ls">const getData = (n: number) =&gt; {<br/>    return new Promise&lt;number&gt;((res, rej) =&gt; {<br/>        if (n === 3) {<br/>            rej('Can not use 3.');<br/>            return;<br/>        }<br/>        res(n * n);<br/>    });<br/>}</span></pre><p id="9a4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果必须的话，获取2的数据，并根据响应获取3和4的数据，那么代码将如下所示。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9a71" class="ln lo iq le b gy lp lq l lr ls">const check = () =&gt; {<br/>    getData(2)<br/>        .then(x2 =&gt; {<br/>            console.log(x2);<br/>            return getData(3);<br/>        })<br/>        .then(x3 =&gt; {<br/>            console.log(x3);<br/>            return getData(4);<br/>        })<br/>        .then(x4 =&gt; {<br/>            console.log(x4);<br/>        }).catch((ex) =&gt; { // This is catch handler<br/>            console.log('Error occurred : Check with Promise.');<br/>            console.log(ex);<br/>        });<br/>}</span></pre><p id="e5e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用async和await，相同的代码将更易读和易于理解。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="61aa" class="ln lo iq le b gy lp lq l lr ls">const check = async () =&gt; {<br/>    try {<br/>        const x2: number = await getData(2);<br/>        console.log(x2);<br/>        const x3: number = await getData(3);<br/>        console.log(x3);<br/>        const x4: number = await getData(4);<br/>        console.log(x4);<br/>    } catch (ex) { // This is catch block<br/>        console.log('error occurred : check with async and await.');<br/>        console.log(ex);<br/>    }<br/>}</span></pre><p id="1f5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">错误处理仍然是一个挑战。如果承诺被拒绝，那么要么执行catch处理程序，要么抛出一个异常。使用<code class="fe lb lc ld le b">await</code>关键字，处理拒绝承诺的唯一方法是<code class="fe lb lc ld le b">try-catch</code>阻塞。</p><p id="6eda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这在某些情况下可能行得通，但是如果在加载3和4的数据时出现错误也没关系呢？catch块没有给出处理控制流的好方法。您可能最终会为每个<code class="fe lb lc ld le b">await</code>使用单独的<code class="fe lb lc ld le b">try-catch</code>块，这将使问题恶化。</p><p id="bf07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<code class="fe lb lc ld le b">go</code>这样的语言有不同的哲学来处理错误。<code class="fe lb lc ld le b">go</code>将<code class="fe lb lc ld le b">error</code>与<code class="fe lb lc ld le b">exception</code>分离，用普通值作为返回参数传递错误。<br/>让我们看看当我们尝试这种哲学时会发生什么。</p><blockquote class="lt"><p id="b2fa" class="lu lv iq bd lw lx ly lz ma mb mc la dk translated">永远信守诺言</p></blockquote><p id="87ef" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">让我们改变getData函数，使它永远不能拒绝承诺。承诺将总是被解决，并且错误将通过返回类型被报告。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="1d1c" class="ln lo iq le b gy lp lq l lr ls">type PromiseResponse&lt;T&gt; = Promise&lt;[string] | [null, T]&gt;;<br/><br/>const getData = (n: number) : PromiseResponse&lt;number&gt; =&gt; {<br/>    return new Promise((res) =&gt; {<br/>        if (n === 3) {<br/>            // no reject here <br/>            res(['Can not use 3.']);<br/>            return;<br/>        }<br/>        res([null, n * n]);<br/>    });<br/>}</span></pre><p id="4eca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这里声明了一个类型<code class="fe lb lc ld le b">PromiseResponse</code>，这是一个承诺返回元组，将帮助TypeScript进行更好的语法检查。</p><ul class=""><li id="3357" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">第一项将是error : string或null。</li><li id="34d8" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">第二项将是T类型或未定义的实际结果。</li></ul><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="1d59" class="ln lo iq le b gy lp lq l lr ls">const check3 = async () =&gt; {<br/>    const [e2, x2] = await getDataV2(2);<br/>    // Here for TypeScript x2 is either number or undefined<br/>    if (x2 === undefined) {<br/>        console.log('Error while fetching data for 2');<br/>        return;<br/>    }<br/>    // As x2 is checked for undefined<br/>    // at this line x2 is number<br/>    console.log(x2);<br/><br/>    // now fetch data for 3 and 4<br/>    const [e3, x3] = await getDataV2(3);<br/>    if (x3 !== undefined) {<br/>        console.log(x3);<br/>    }<br/><br/>    const [e4, x4] = await getDataV2(4);<br/>    if (x4 !== undefined) {<br/>        console.log(x4);<br/>    }<br/>}</span></pre><p id="f20a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了新的方法，代码不需要使用<code class="fe lb lc ld le b">try-catch</code>块，我们可以更好地控制流程。</p><p id="961f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将这种技术用于位于UI和底层数据之间的应用层，它使生活变得更加容易。</p><p id="d0fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您的需求，您可以将类型<code class="fe lb lc ld le b">PromiseResponse</code>扩展为一个类，并使用像<code class="fe lb lc ld le b">Success</code>和<code class="fe lb lc ld le b">Error</code>这样的帮助方法来使您的代码更具可读性。</p><p id="0da2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我有一个效用函数，在propose上命名为<code class="fe lb lc ld le b">aKeptPromise</code>。有了这个函数，getData可读性更强。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="2f8d" class="ln lo iq le b gy lp lq l lr ls">function aKeptPromise&lt;T&gt;(<br/>  callback: (<br/>    success: (result: T) =&gt; void,<br/>    failure: (error: string) =&gt; void<br/>  ) =&gt; void<br/>): PromiseResponse&lt;T&gt; {<br/>  return new Promise((res) =&gt; {<br/>    callback(<br/>      (r) =&gt; res([null, r]),<br/>      (e) =&gt; res([e])<br/>    );<br/>  });<br/>}<br/><br/>const getDataV3 = (n: number) : PromiseResponse&lt;number&gt; =&gt; {<br/>    return aKeptPromise((success, failure) =&gt; {<br/>        if (n === 3) {<br/>            failure('Can not use 3.');<br/>            return;<br/>        }<br/>        success(n * n);<br/>    });<br/>}</span></pre><p id="6e9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://bit.ly/3dSOssW" rel="noopener ugc nofollow" target="_blank">打字游戏场</a></p><p id="b503" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读。如果你有意见，请告诉我。请在这里查看我的另一篇<a class="ae kc" href="https://bit.ly/3cCWdmu" rel="noopener ugc nofollow" target="_blank">打字稿</a>。</p></div></div>    
</body>
</html>