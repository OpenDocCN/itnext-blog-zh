<html>
<head>
<title>A simple guide to JavaScript Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript装饰者简单指南</h1>
<blockquote>原文：<a href="https://itnext.io/a-simple-guide-to-javascript-decorators-267b96ff3422?source=collection_archive---------0-----------------------#2021-12-07">https://itnext.io/a-simple-guide-to-javascript-decorators-267b96ff3422?source=collection_archive---------0-----------------------#2021-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3c515127d19ecc53ac9365569e34123c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5If_vx4q8Nj9pfVpAhX6w.png"/></div></div></figure><h1 id="be8e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="985d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">JavaScript decorators是JavaScript中相对较新的特性，它允许在不修改底层代码的情况下向现有函数和对象添加新行为。您可以通过在函数名或对象键前使用@符号的特殊语法来实现这一点。让我们快速看一下它们是什么以及它们是如何工作的。</p><p id="5c75" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">顺便提一下，装饰器还不是JavaScript的标准特性；他们仍然处于ECMA TC39 <a class="ae mc" href="https://github.com/tc39/proposal-decorators" rel="noopener ugc nofollow" target="_blank">规范阶段</a>。这意味着我们需要用Babel来传输我们的代码</p><p id="999f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">总的来说，decorators可以被认为是其他代码的包装器，在它上面或者代替它提供额外的功能。装饰者并不完全是新的想法；事实上，它们的功能类似于<a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function" rel="noopener ugc nofollow" target="_blank">高阶函数</a>。</p><p id="2ba7" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">你可以对<a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields" rel="noopener ugc nofollow" target="_blank">类的字段</a>、方法甚至整个类应用装饰器。<strong class="lb iu">然而，你不能在普通的JavaScript对象上使用decorators他们只处理类</strong>。</p><p id="8fa1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在让我们看看如何使用decorators来修饰类的属性和方法。</p><h1 id="cedb" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">装饰类字段</h1><p id="3a06" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">下面是在类字段上使用装饰语法的情况:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/689cd44129ea61aecd50e843d3538b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYE-y5xH_9p5FhYTAPuAgw.png"/></div></div></figure><p id="1494" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在上面的代码中，我们有一个简单的名为<code class="fe mi mj mk ml b">locked</code>的装饰函数，我们将其应用于<code class="fe mi mj mk ml b">password</code>类字段。它接受三个参数——目标、键和描述符。<code class="fe mi mj mk ml b">target</code>是正在被修饰的对象或函数，<code class="fe mi mj mk ml b">key</code>是指该目标上的属性名。描述符包含目标的所有属性，包括那些被修饰的属性。</p><p id="33a6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">类字段装饰器通过返回一个新的描述符来工作。所以我们返回一个新的描述符对象，它包含原始描述符的所有属性和值，除了设置为<code class="fe mi mj mk ml b">false</code>的<code class="fe mi mj mk ml b">writable</code>标志。这可以防止在实例化后更改<code class="fe mi mj mk ml b">password</code>字段。</p><p id="c012" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在，如果我们尝试改变我们的<code class="fe mi mj mk ml b">password</code>字段:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/f7e8d2b9615023d412b0e7523c2d8d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kx3wUsMmV1hsXingUUtWg.png"/></div></div></figure><p id="77c4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">正如我们所见，试图改变<code class="fe mi mj mk ml b">password</code>字段会导致错误，因为现在它是一个只读字段。</p><h1 id="9798" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">装饰类方法</h1><p id="b7e1" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在，让我们看一个在方法上使用decorator的例子:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/8b5a619000df642110904b82b8691d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSILo8-l302nYlI5xdC5hA.png"/></div></div></figure><p id="d3f9" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">正如我们所见，方法的decorators通过获取描述符并返回包含原始方法和任何附加逻辑的对象来工作。</p><p id="d8d4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在这种情况下，我们向我们的<code class="fe mi mj mk ml b">fetchData</code>方法添加了一些错误处理。如果我们的请求或数据解析出现任何问题，都会被捕获并记录到控制台。</p><h1 id="24c8" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">装饰班级</h1><p id="7f0c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在让我们看看如何将一个装饰器应用到整个类:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/b83ff38a2f413392e24c8e97adbc4de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDQSf4VlgYP_ndDHF1fH3A.png"/></div></div></figure><p id="e1e8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们可以看到,<code class="fe mi mj mk ml b">@saveInCache</code>装饰器被应用到我们的类中，它会自动将<code class="fe mi mj mk ml b">Person</code>的任何新实例保存在缓存映射中。</p><h1 id="7e0a" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="9737" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">JavaScript装饰器是一个强大的特性，可以节省您的时间并减少代码中的冗余。装饰者仍处于提议阶段，所以他们的语法可能会改变。在将它们添加到您的项目之前，请记住这一点。</p><p id="70fd" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">有许多不同的方式可以在代码中使用decorators在类、方法或属性上。Decorators提供了一种简单的方法，可以在不修改现有代码的情况下，以可重用的方式添加额外的行为或元数据。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="2d1b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><em class="mw">原载于2021年12月7日https://isamatov.com</em><em class="mw">的</em> <a class="ae mc" href="https://isamatov.com/javascript-decorators-tutorial/" rel="noopener ugc nofollow" target="_blank"> <em class="mw">。</em></a></p></div></div>    
</body>
</html>