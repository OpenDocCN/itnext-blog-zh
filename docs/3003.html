<html>
<head>
<title>.NET Core is Sexy — Building a Web API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。NET Core很性感——构建Web API</h1>
<blockquote>原文：<a href="https://itnext.io/net-core-is-sexy-building-a-web-api-cdb470cc8222?source=collection_archive---------2-----------------------#2019-09-14">https://itnext.io/net-core-is-sexy-building-a-web-api-cdb470cc8222?source=collection_archive---------2-----------------------#2019-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c1437007177a725175127014fe45ca61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*5fQvZr2W6ydJ1fxjLgwhcg.png"/></div></figure><p id="3224" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">任何web开发人员都知道，新的应用程序越来越面向API。正如RESTful和GraphQL的例子所示，现代模式使用后端API来提供数据，并以前端应用程序为特色(使用<strong class="jw ir"> React </strong>或<strong class="jw ir"> Angular </strong>等等)。所有时髦的技术都旨在通过尽可能直接地创建<strong class="jw ir"> Web API、</strong>和<strong class="jw ir">来改善和缓解开发人员的生活。NET Core </strong>也不例外，您将在本文中看到，它是系列<strong class="jw ir">的第三部。网芯性感(你也应该知道)</strong>。</p><blockquote class="ks kt ku"><p id="7e88" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated">本文是关于。NET Core，以及它现在如何像Node或Rails等任何其他堆栈一样简单高效地创建现代应用程序。</p><p id="4455" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/https-medium-com-buisson-jeremy-net-core-is-sexy-and-you-should-know-it-a3d0c2eeedc4">。网芯很性感你应该知道</a></p><p id="c703" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated"><a class="ae kz" href="https://medium.com/@jbuisson/net-core-is-sexy-real-world-part-1-command-line-application-953f48394c83" rel="noopener">。NET Core很性感——命令行应用</a></p><p id="ad7c" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated"><strong class="jw ir">。NET Core很性感——构建Web API </strong></p></blockquote><p id="9075" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<a class="ae kz" href="https://medium.com/@jbuisson/net-core-is-sexy-real-world-part-1-command-line-application-953f48394c83" rel="noopener">上一部分</a>中，我们创建了一个多平台控制台应用程序来处理我们的策展，通过添加主题、列出它们和删除一个完整的主题。我们已经建立了一个漂亮而简单的架构，在数据库访问(通过<a class="ae kz" href="https://docs.microsoft.com/ef/core/" rel="noopener ugc nofollow" target="_blank">实体框架</a>和<a class="ae kz" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> Sqlite </a>)和应用程序本身之间使用了一些分离。我们还花时间为数据库创建了一个简单但有用的抽象，允许我们轻松地编写测试并遵循一些<a class="ae kz" href="https://blog.cleancoder.com" rel="noopener ugc nofollow" target="_blank">干净代码</a>模式。</p><blockquote class="ks kt ku"><p id="8e01" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated"><strong class="jw ir">TL；如果你想看最终的实现，这里是完整的Web API的存储库:<a class="ae kz" href="https://gitlab.com/jbuisson/curator/tree/webapi" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/jbuisson/curator/tree/webapi</a></strong></p></blockquote><h1 id="1b1e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">让我们从头开始</h1><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="399d" class="mh lb iq md b gy mi mj l mk ml">git clone --branch console <a class="ae kz" href="mailto:git@gitlab.com" rel="noopener ugc nofollow" target="_blank">git@gitlab.com</a>:jbuisson/curator.git<br/>cd curator<br/>dotnet build</span></pre><p id="93d8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用这些命令，我们可以从上一部分停止的地方继续我们的开发。首先，我们使用名为<strong class="jw ir"> <em class="kv">控制台的git分支克隆<a class="ae kz" href="https://gitlab.com/jbuisson/curator/tree/console" rel="noopener ugc nofollow" target="_blank"> Gitlab存储库</a>。</em> </strong>然后，我们基于解决方案文件构建整个项目(。sln)在项目的根。</p><p id="715e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是文件夹树中应该有的内容:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="aefe" class="mh lb iq md b gy mi mj l mk ml">├── data<br/>├── src<br/>     ├── Curator.Console<br/>     └── Curator.Data<br/>         ├── Curator.Data.Entities<br/>         └── Curator.Data.EntityFramework<br/>             ├── Curator.Data.EntityFramework.Context<br/>             ├── Curator.Data.EntityFramework.Memory<br/>             └── Curator.Data.EntityFramework.Sqlite<br/>└── tests<br/>    ├── Curator.Console.Tests<br/>    ├── Curator.Data.Entities.Tests<br/>    └── Xunit.AssertExtensions</span></pre><p id="c37a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在将添加一个新项目，<strong class="jw ir">馆长。Api </strong>，我们将在其中创建我们的Web API。</p><h1 id="0d7f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">最低可行Api</h1><p id="cf77" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">在这里，我们将集中于手动开发严格的最低限度，以拥有一个工作的Web API，做与我们的命令行应用程序完全相同的事情。</p><p id="38ba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本系列的第一篇文章中，我们看到了<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/https-medium-com-buisson-jeremy-net-core-is-sexy-and-you-should-know-it-a3d0c2eeedc4#8f37">如何自托管web服务器</a>并处理http请求。我们现在将做同样的事情，但是使用<a class="ae kz" href="https://docs.microsoft.com/aspnet/core/mvc/overview?view=aspnetcore-2.2" rel="noopener ugc nofollow" target="_blank">ASP.NET核心MVC </a>来管理路由、控制器和所有我们不想自己做的事情。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="5db2" class="mh lb iq md b gy mi mj l mk ml">dotnet new console -o src/Curator.Api<br/>cd src/Curator.Api<br/>dotnet add package Microsoft.AspNetCore<br/>dotnet add package Microsoft.AspNetCore.Mvc</span></pre><p id="b399" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">进入<strong class="jw ir"> <em class="kv"> Program.cs </em> </strong>文件，设置我们的虚拟主机:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/jbuiss0n/2b7139aab037fd809139cf6eda332ac7" rel="noopener ugc nofollow" target="_blank">添加()然后使用()ASP.NET核心MVC使用依赖注入</a></figcaption></figure><p id="6a30" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">来自我们新成立的<strong class="jw ir">馆长。Api </strong>项目，使用命令<strong class="jw ir"> <em class="kv">运行应用</em> </strong>。默认情况下，这个命令应该启动服务器，并在http://localhost:5000 上监听任何请求。但是，我们没有配置任何控制器，所以所有请求都会抛出404 not found错误。下面是在新端子中使用<a class="ae kz" href="https://curl.haxx.se" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">卷曲</strong> </a>的例子:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="71a5" class="mh lb iq md b gy mi mj l mk ml">curl -i <a class="ae kz" href="http://localhost:5000/items" rel="noopener ugc nofollow" target="_blank">http://localhost:5000</a><br/>&gt; HTTP/1.1 404 Not Found<br/>&gt; Date: Sun, 08 Sep 2019 12:01:57 GMT<br/>&gt; Server: Kestrel<br/>&gt; Content-Length: 0</span></pre><p id="48e8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们添加第一个控制器来处理策展项目。这个控制器将使用我们的<strong class="jw ir"> CuratorContext </strong>与<strong class="jw ir"> Sqlite </strong>数据库的<strong class="jw ir">条目</strong>进行交互，因此我们需要从添加对我们已经存在的项目<strong class="jw ir">的引用开始。</strong></p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="0cef" class="mh lb iq md b gy mi mj l mk ml">dotnet add reference ../Curator.Data/Curator.Data.Entities</span><span id="1d0f" class="mh lb iq md b gy mx mj l mk ml">dotnet add reference ../Curator.Data/Curator.Data.EntityFramework/Curator.Data.EntityFramework.Context</span><span id="fccb" class="mh lb iq md b gy mx mj l mk ml">dotnet add reference ../Curator.Data/Curator.Data.EntityFramework/Curator.Data.EntityFramework.Sqlite</span></pre><p id="ec8c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，这里是控制器本身的代码，在<strong class="jw ir"> <em class="kv"> Program.cs </em> </strong>文件中:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/jbuiss0n/5d33d3fd8b6451e70dd4951aacc946ad" rel="noopener ugc nofollow" target="_blank">创建ASP.NET核心web API的严格最小代码</a></figcaption></figure><p id="9466" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里重要的代码行是类和方法的<a class="ae kz" href="https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/attributes/" rel="noopener ugc nofollow" target="_blank">属性</a>，定义了我们需要的<strong class="jw ir"> URL </strong>和请求参数。</p><p id="3a46" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">【</strong><a class="ae kz" href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.routeattribute" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">路线</strong> </a> <strong class="jw ir">【项】</strong>声明控制器的端点。这个控制器中的所有动作方法都将从这个<strong class="jw ir"> URL </strong>继承，因为它在整个控制器类中。</p><p id="3cf9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">[</strong><a class="ae kz" href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.httpgetattribute" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">HTTP GET</strong></a><strong class="jw ir">]</strong>声明下面的方法只能用于GET HTTP请求。没有定义路由路径，所以会在控制器的根路径:<strong class="jw ir"> / <em class="kv"> items </em> </strong>。</p><p id="62f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">[</strong><a class="ae kz" href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.httpgetattribute" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">HTTP POST</strong></a><strong class="jw ir">]</strong>与<strong class="jw ir">【HTTP get】</strong>做的事情一样，只是针对POST HTTP请求。</p><p id="2be0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">[</strong><a class="ae kz" href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.frombodyattribute" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">from body</strong></a><strong class="jw ir">】</strong>允许我们给<strong class="jw ir"> <em class="kv"> Post() </em> </strong>方法添加一个字符串参数，这个参数将从请求体中解析出来。ASP.NET核心将根据请求<a class="ae kz" href="https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">内容-类型</strong> </a>为我们处理格式。</p><p id="1fa9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">[</strong><a class="ae kz" href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.httpdeleteattribute" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">HTTP DELETE</strong></a><strong class="jw ir">(" { id:int } ")</strong>声明下面的方法仅可用于删除HTTP请求，它将一个命名参数添加到路径中，该参数必须是一个整数，并且将在<strong class="jw ir"> <em class="kv"> Delete() </em> </strong>方法中通过其名称可用。<br/>示例路径:<strong class="jw ir"> / <em class="kv">条目</em> / <em class="kv"> 42 </em> </strong>。</p><p id="bdcc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们需要使用一个<strong class="jw ir"> <em class="kv"> appsettings.json </em> </strong>文件为<strong class="jw ir"> Sqlite </strong>数据源添加一些配置，就像我们为命令行应用程序所做的一样。只需从<strong class="jw ir">馆长那里复制文件。控制台</strong>变成<strong class="jw ir">馆长。Api </strong>。</p><p id="ed95" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用命令<strong class="jw ir"> <em class="kv"> dotnet run </em> </strong>再次启动服务器，并在另一个终端中，使用<strong class="jw ir"> cURL </strong>在<strong class="jw ir"> <em class="kv"> items </em> </strong>端点上运行API:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="5cd6" class="mh lb iq md b gy mi mj l mk ml">curl -i <a class="ae kz" href="http://localhost:5000/items" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/items</a><br/>&gt; HTTP/1.1 200 OK<br/>&gt; Date: Sun, 08 Sep 2019 12:09:48 GMT<br/>&gt; Content-Type: application/json; charset=utf-8<br/>&gt; Server: Kestrel<br/>&gt; Transfer-Encoding: chunked</span><span id="1c5e" class="mh lb iq md b gy mx mj l mk ml">&gt; []</span></pre><p id="b930" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您没有清空控制台应用程序使用的数据库，您应该会看到在<a class="ae kz" href="https://www.json.org" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> JSON </strong> </a>中显示的项目，而不是示例中的空数组。向策展数据库添加一个新项目，如下所示:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f968" class="mh lb iq md b gy mi mj l mk ml">curl -X POST <a class="ae kz" href="http://localhost:5000/items" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/items</a> \<br/>   -H 'Content-Type: application/json' \<br/>   -d '"medium.com/@jbuisson"'</span></pre><p id="df6c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不要忘记指定<strong class="jw ir"> Content-Type </strong> HTTP头，以便ASP.NET核心知道如何解析主体数据。现在，您可以获取创建的项目。我使用<a class="ae kz" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> jq </strong> </a>来美化<strong class="jw ir"> JSON </strong>输出，但是它是完全可选的:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6b44" class="mh lb iq md b gy mi mj l mk ml">curl <a class="ae kz" href="http://localhost:5000/items" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/items</a> | jq</span><span id="3655" class="mh lb iq md b gy mx mj l mk ml">[<br/>  {<br/>    "id": 1,<br/>    "name": "medium.com/@jbuisson",<br/>    "createdAt": "2019-09-08T12:10:16.0666878"<br/>  }<br/>]</span></pre><blockquote class="ks kt ku"><p id="080a" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated">如果你不想使用<strong class="jw ir"> cURL，</strong>你可以使用像<a class="ae kz" href="https://www.getpostman.com" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> Postman </strong> </a>这样的工具来执行API上的请求。</p></blockquote><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/12b984768c7dd407845a64590205961b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUub6EsKo0a01bl1uNmFmw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">使用邮递员投递邮件</figcaption></figure><p id="55ab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">恭喜</strong>！我们已经用几行非常简单的代码构建了一个工作的web API！</p><p id="8b08" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里，我自愿手工编写所有代码，我没有使用任何助手。我想向您展示，没有任何魔法，如何创建一个Web API。网芯。但是，有一种更好、更简单的方法可以做到这一点。</p><h1 id="25d3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">简单的API设置</h1><p id="4e1a" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">与我们创建第一个应用程序的方式相同，我们可以使用<strong class="jw ir"> dotnet </strong>命令行界面(CLI)为我们搭建一个漂亮的Web API。这可能会伤你的心，但是把我们刚刚写的代码全部删掉。删除<strong class="jw ir">馆长。Api </strong>文件夹，并从头开始用新的Api项目替换它。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="259f" class="mh lb iq md b gy mi mj l mk ml">dotnet new webapi -o Curator.Api</span></pre><p id="d297" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个新项目已经有了一些新文件:</p><p id="6252" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Program.cs </strong>一如既往地是我们的应用入口点，并使用<strong class="jw ir"> <em class="kv"> Startup </em> </strong>类创建一个新的自托管web服务器。</p><p id="fb86" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Startup.cs </strong>是一个新文件。这是我们在<strong class="jw ir"> <em class="kv">启动</em> </strong>类中设置和配置api的地方。这里大部分代码都是显式的，如果您有任何疑问，带有文档链接的默认注释应该足够了。</p><p id="47cc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> appsettings。**.json </strong>是配置文件。对于<strong class="jw ir"> <em class="kv">开发</em> </strong>运行时的环境，您有一个默认配置和一个覆盖配置。环境在下一个文件中声明。</p><p id="5c00" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">Properties/launch settings . JSON</strong>包含启动配置。您可以在这里找到应用程序的已配置环境和启动属性。部分设置用于Visual Studio(不是VS代码)，可以简单地忽略(就像ISS Express配置文件)。</p><p id="5745" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">Controllers/values controller . cs</strong>是一个带有固定值的示例控制器，展示如何创建自己的值。您将发现我们创建的控制器有几个不同之处:</p><ul class=""><li id="984e" class="nd ne iq jw b jx jy kb kc kf nf kj ng kn nh kr ni nj nk nl bi translated"><strong class="jw ir">[</strong><a class="ae kz" href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.apicontrollerattribute" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">API controller</strong></a><strong class="jw ir">]</strong>属性启用特定于API的行为，例如路由要求、自动HTTP错误请求(400)响应、绑定、… <a class="ae kz" href="https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-2.2#apicontroller-attribute" rel="noopener ugc nofollow" target="_blank">更多信息请参见文档</a>。</li><li id="cc03" class="nd ne iq jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><a class="ae kz" href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.controllerbase" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">controller base</strong></a>继承为<strong class="jw ir"> ValuesController </strong>启用帮助器的方法和属性，如<strong class="jw ir"> <em class="kv"> Request、Response </em> </strong>、<strong class="jw ir"> <em class="kv"> BadRequest() </em> </strong>、<strong class="jw ir"><em class="kv">CreatedAtAction()</em></strong>、… <a class="ae kz" href="https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-2.2#controllerbase-class" rel="noopener ugc nofollow" target="_blank">更多关于文档</a>。</li></ul><p id="0da6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，您应该能够基于我们之前创建的<strong class="jw ir"><em class="kv">items controller</em></strong>和CLI为我们创建的<strong class="jw ir"><em class="kv">values controller</em></strong>创建自己的项目控制器了。</p><p id="daf0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们有两个应用程序，第一个是我们的命令行应用程序，第二个是我们新创建的Web API。所以，我们面临的问题是我们复制了逻辑，无论是在<strong class="jw ir">馆长。控制台/命令</strong>和在<strong class="jw ir">Curator.Api/Controllers</strong>中。代码重复不仅不好(维护、调试等)，而且对您的应用程序来说也是危险的。所以，你应该已经猜到了，现在是…</p><h1 id="5e43" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">是时候重构了</h1><p id="88cc" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">我们需要做的是创建一个单一的服务来处理关于获取、添加和删除项目的管理逻辑。我们开发的两个应用程序应该使用这个服务。我们也将能够为这个服务编写测试，避免重复单元测试。</p><p id="b5f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们将与<strong class="jw ir">策展人一起创建另一个独立的项目。Api </strong>和<strong class="jw ir">策展人。控制台</strong>，将被称为<strong class="jw ir">馆长。核心</strong>。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="438f" class="mh lb iq md b gy mi mj l mk ml">dotnet new classlib -o Curator.Core</span></pre><p id="d9fd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个项目中，用我们自己的服务替换生成的类:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/jbuiss0n/7f91f0f37b3b4f1363a97b6ea205ed79" rel="noopener ugc nofollow" target="_blank"> ItemsService.cs </a></figcaption></figure><p id="68f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不要忘记添加参考资料:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3fb1" class="mh lb iq md b gy mi mj l mk ml">dotnet add reference ../Curator.Data/Curator.Data.Entities</span><span id="3bf3" class="mh lb iq md b gy mx mj l mk ml">dotnet add reference ../Curator.Data/Curator.Data.EntityFramework/Curator.Data.EntityFramework.Context</span></pre><p id="0708" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我还创建了一个定制的异常来处理服务没有找到的项目。</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/jbuiss0n/aef25f335333290d3fe9563ef800e076" rel="noopener ugc nofollow" target="_blank"> NotFoundException.cs </a></figcaption></figure><p id="d733" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们花些时间考虑一下我们已经创建的所有类以及它们之间的关系。</p><ul class=""><li id="74d2" class="nd ne iq jw b jx jy kb kc kf nf kj ng kn nh kr ni nj nk nl bi translated"><strong class="jw ir"> CuratorContext </strong>是<strong class="jw ir"> EntityFramework </strong>上下文，定义我们的数据存储库。</li><li id="0bad" class="nd ne iq jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw ir">DesignTimeDbContextFactory</strong>是<strong class="jw ir"> CuratorContext </strong>提供者，为两个<strong class="jw ir">in memory</strong>dans<strong class="jw ir">Sqlite</strong>数据库配置它。</li><li id="6609" class="nd ne iq jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw ir"> ItemsService </strong>是使用<strong class="jw ir"> CuratorContext </strong>与数据库交互的服务，而不知道我们正在使用哪种提供者。</li><li id="68af" class="nd ne iq jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw ir"> ItemsController </strong>是ASP.NET核心控制器，应该使用<strong class="jw ir"> ItemsService </strong>在Web API上公开该服务的方法。</li><li id="72b5" class="nd ne iq jw b jx nm kb nn kf no kj np kn nq kr ni nj nk nl bi translated"><strong class="jw ir"> CuratorCommand </strong>是我们现有控制台应用程序的命令定义。它还应该使用<strong class="jw ir"> ItemsService </strong>，就像我们应该使用<strong class="jw ir"> ItemsController </strong>一样。</li></ul><p id="97fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了正确地配置所有这些，我们将使用<a class="ae kz" href="https://docs.microsoft.com/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">依赖注入</strong> </a>机制。网芯。</p><p id="2768" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们使用<a class="ae kz" href="https://github.com/natemcmaster/CommandLineUtils" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">command line utils</strong></a>(作者<a class="ae kz" href="https://medium.com/u/bcd6cc2f75fd" rel="noopener"> </a> <a class="nr ns ep" href="https://medium.com/u/bcd6cc2f75fd?source=post_page-----cdb470cc8222--------------------------------" rel="noopener" target="_blank"> Nate McMaster </a>)和<strong class="jw ir">依赖注入</strong>来更新我们已经存在的控制台应用程序:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/jbuiss0n/8dfdaf045e7b9956a716fca0363ee9df" rel="noopener ugc nofollow" target="_blank">更新馆长。Console/Program.cs，使用DependencyInjection </a></figcaption></figure><p id="b773" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个应用程序中，我们使用了带有<strong class="jw ir"> Sqlite CuratorContext </strong>实现的<strong class="jw ir"> ItemsService </strong>。现在由您使用<strong class="jw ir"> ItemsService </strong>而不是<strong class="jw ir"> CuratorContext </strong>来更新命令。</p><p id="d3db" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以在我们的<strong class="jw ir">管理器中做同样的事情。Api </strong>项目，使用<strong class="jw ir">启动</strong>类来配置应用程序。只需在<strong class="jw ir"> ConfigureServices(…) </strong>方法中添加以下代码行:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="329c" class="mh lb iq md b gy mi mj l mk ml">services.AddScoped&lt;CuratorContext&gt;(provider =&gt; new DesignTimeDbContextFactory(m_configuration).CreateDbContext(null));</span><span id="3e5c" class="mh lb iq md b gy mx mj l mk ml">services.AddTransient&lt;ItemsService&gt;();</span></pre><p id="cf59" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们对<strong class="jw ir"> ItemsController </strong>的最终实现应该是这样的:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/jbuiss0n/db1f743fcf9fe6f2866b97c93fa3c393" rel="noopener ugc nofollow" target="_blank"> ItemsController.cs </a></figcaption></figure><p id="4fc9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在考虑我们的应用程序“<strong class="jw ir"> <em class="kv">生产就绪</em> </strong>”之前，唯一要做的事情是拥有一个合适的数据库，让托管我们的应用程序的多个服务器(例如，在一个负载平衡器后面)可以同时访问。另外，<a class="ae kz" href="https://www.sqlite.org/whentouse.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> Sqlite </strong> </a>努力为单个应用程序或设备提供本地数据存储，并且不与客户端/服务器数据库竞争，因此我们将使用<a class="ae kz" href="https://www.mysql.com/fr/" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> MySql </strong> </a>来代替。</p><h1 id="b494" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">添加新的数据库提供程序</h1><p id="2902" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">我们已经有两个数据库提供者，一个使用<strong class="jw ir"> Sqlite </strong>，另一个使用<strong class="jw ir"> InMemory </strong>进行测试。创建一个新的应该很容易，但是要使用MySql。data . EntityFrameworkCore而不是微软的<a class="ae kz" href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Sqlite/" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">。EntityFrameworkCore . Sqlite</strong></a>。</p><p id="4a22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为此，从通常的第一步开始——创建一个新项目。它仍然很冗长，但您现在应该知道我更喜欢显式命名约定:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9c0f" class="mh lb iq md b gy mi mj l mk ml">dotnet new classlib -o src/Curator.Data/Curator.Data.EntityFramework/Curator.Data.EntityFramework.Mysql</span></pre><p id="8c5a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，在新创建的项目中，我们需要为<strong class="jw ir">配置</strong>和<strong class="jw ir"> EntityFramework </strong>添加引用和包，以最终创建<strong class="jw ir">DesignTimeDbContextFactory</strong>实现:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="bd41" class="mh lb iq md b gy mi mj l mk ml">cd src/Curator.Data/Curator.Data.EntityFramework/Curator.Data.EntityFramework.Mysql</span><span id="ec6f" class="mh lb iq md b gy mx mj l mk ml">dotnet add package Microsoft.Extensions.Configuration<br/>dotnet add package Microsoft.Extensions.Configuration.Json<br/>dotnet add package MySql.Data.EntityFrameworkCore</span></pre><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/jbuiss0n/975e9dd9a6b27c8c4f9deb6302a175b7" rel="noopener ugc nofollow" target="_blank">Mysql designtimedbcontextfactory . cs</a></figcaption></figure><p id="40c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不要忘记添加一个<strong class="jw ir"> appsettings.json </strong>文件，在这个文件中你应该把<strong class="jw ir"> ConnectionString </strong>放到你正在使用的<strong class="jw ir"> Mysql </strong>服务器上。我们在新创建的<strong class="jw ir"> Mysql </strong>项目和<strong class="jw ir"> Web API </strong>项目中都需要它。</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/jbuiss0n/4593a7ada207f9ac93cd83912683960c" rel="noopener ugc nofollow" target="_blank">不要忘记在管理器中添加<strong class="ak">连接字符串</strong>块。Api appsettings.json文件</a></figcaption></figure><p id="0329" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本系列的前一篇文章中，我鼓励您在<strong class="jw ir">实体</strong>、<strong class="jw ir">上下文</strong>实现和<strong class="jw ir"> Sqlite </strong>提供者之间创建清晰的分离。您现在应该理解这种分离的好处了，有了第三个提供者(不要忘记内存中的<strong class="jw ir">用于测试)。现在更好的是，我们在<strong class="jw ir">策展人中有一个专门和独立的服务项目<strong class="jw ir">项目服务</strong>。核心</strong>项目。我们已经将<strong class="jw ir">控制台</strong>应用程序配置为使用<strong class="jw ir"> Sqlite </strong>提供程序，将<strong class="jw ir"> Web Api </strong>应用程序配置为使用<strong class="jw ir"> Mysql </strong> one，而没有用<strong class="jw ir"> ItemsService </strong>逻辑做任何更改！</strong></p><blockquote class="nt"><p id="acb9" class="nu nv iq bd nw nx ny nz oa ob oc kr dk translated">这些是在我们的实现中使用<strong class="ak">代码抽象</strong>和<strong class="ak">代码分离</strong>的主要真正好处。</p></blockquote><p id="d2c3" class="pw-post-body-paragraph ju jv iq jw b jx od jz ka kb oe kd ke kf of kh ki kj og kl km kn oh kp kq kr ij bi translated">我们现在需要一个<strong class="jw ir"> Mysql </strong>服务器用于我们的本地环境，为此我们将使用<a class="ae kz" href="https://www.docker.com" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> Docker </strong> </a>。如果你不熟悉Docker，我真的鼓励你去读一读<a class="ae kz" href="https://www.google.com/search?q=docker+tutorial" rel="noopener ugc nofollow" target="_blank">教程</a>或者跟着<a class="ae kz" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">入门</a>信息。</p><p id="cde0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你愿意，你当然可以在你的本地计算机上使用标准的<strong class="jw ir"> Mysql </strong>安装，或者甚至可以公开访问<a class="ae kz" href="https://aws.amazon.com/fr/rds/mysql/" rel="noopener ugc nofollow" target="_blank"> AWS RDS </a>上的一个实例。</p><p id="2d8e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你还没有安装<strong class="jw ir"> Docker </strong>，这里有在<a class="ae kz" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank"> Mac </a>、<a class="ae kz" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a>和<a class="ae kz" href="https://docs.docker.com/docker-for-windows/install/" rel="noopener ugc nofollow" target="_blank"> Windows </a>上安装的链接。完成后，您应该可以使用<a class="ae kz" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> docker-compose </a>工具，我们将使用它来创建我们的<strong class="jw ir"> Mysql </strong>容器。</p><p id="f646" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在项目的根目录下创建一个名为<strong class="jw ir"> docker-compose.yml </strong>的文件，包含以下yml代码:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/jbuiss0n/935636dc301eecd32bd1b69a96e96acd" rel="noopener ugc nofollow" target="_blank"> Docker为Mysql编写</a></figcaption></figure><p id="c140" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您应该能够按如下方式启动容器:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f32a" class="mh lb iq md b gy mi mj l mk ml">docker-compose up -d</span></pre><p id="8d01" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你已经完成了，你只需要更新<strong class="jw ir"> Web API </strong>应用程序来使用<strong class="jw ir"> Mysql </strong>而不是<strong class="jw ir"> Sqlite </strong>，为此你可以简单地更新<strong class="jw ir"> <em class="kv">馆长。Api.csproj </em> </strong>文件，并将<strong class="jw ir"> ProjectReference </strong>块中的<strong class="jw ir"> Sqlite </strong>替换为<strong class="jw ir"> Mysql </strong>，不要忘记<strong class="jw ir"><em class="kv">appsettings . JSON</em></strong>文件中的<strong class="jw ir"> ConnectionString </strong>。</p><p id="e1d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">而且，暂时就这样了！我们在这方面已经取得了很大成就。我们已经将我们的控制台应用程序升级为Web API，并且我们已经做了一些重构来清理它，并使用依赖注入机制来利用我们已经实现的架构的所有好处。我们甚至用Docker建立了一个新的本地工作环境数据库。</p><div class="oi oj gp gr ok ol"><a href="https://gitlab.com/jbuisson/curator/tree/webapi" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">杰里米·比森/策展人。美国石油学会(American Petroleum Institute)</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">GitLab.com</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">跨平台。NET Core Web API</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz js ol"/></div></div></a></div><p id="7093" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下一篇文章中，我将向您展示如何打包和部署API，以及一些<strong class="jw ir">持续集成</strong>和<strong class="jw ir">持续交付</strong>。</p></div></div>    
</body>
</html>