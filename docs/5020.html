<html>
<head>
<title>Porting Dual-Pivot Sort and Timsort from Java to Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将双支点排序和Timsort从Java移植到Go</h1>
<blockquote>原文：<a href="https://itnext.io/porting-dual-pivot-sort-and-timsort-from-java-to-go-34b245e53c5?source=collection_archive---------4-----------------------#2020-11-17">https://itnext.io/porting-dual-pivot-sort-and-timsort-from-java-to-go-34b245e53c5?source=collection_archive---------4-----------------------#2020-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="0c9e" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><a class="ae kp" href="https://hubo.dev/2020-11-15-porting-dual-pivot-sort-and-timsort-from-java-to-go/" rel="noopener ugc nofollow" target="_blank"> hubo.dev </a>的镜像</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/b9d33ef735a21041ff297f329e3662de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*raYNL4Gq8XtxIV4p"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">Erik Lucatero 在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="24a9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">大多数编程语言在其内置库中提供了排序API。Java和Go使用不同的排序算法，作为练习，我用不同的方法在Go中实现了Java的算法。用两种语言理解一些设计选择是一种有趣的方式。</p><h1 id="cefc" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">TLDR</h1><ul class=""><li id="6ed0" class="mh mi iq jt b ju mj jy mk lg ml lh mm li mn ko mo mp mq mr bi translated">Go使用混合算法，对于不稳定排序，使用<strong class="jt ir">快速排序</strong>、<strong class="jt ir">堆排序、</strong>和<strong class="jt ir">外壳排序</strong>。</li><li id="f62a" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">Go使用<strong class="jt ir">插入排序</strong>和<strong class="jt ir">稳定最小存储合并</strong>进行稳定排序。</li><li id="b3e7" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">Java对原语使用<strong class="jt ir">双支点排序</strong>，这是一种不稳定的排序。</li><li id="3fec" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">Java使用<strong class="jt ir"> timsort </strong>，一种稳定的对象排序算法。</li><li id="df9e" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">我通过从Java移植算法创建了一个Go包<code class="fe mx my mz na b"><a class="ae kp" href="https://github.com/openaphid/jsort" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">jsort</strong></a></code>。可以从<a class="ae kp" href="https://github.com/openaphid/jsort" rel="noopener ugc nofollow" target="_blank">github.com/openaphid/jsort</a>进口。</li><li id="4a9c" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">用于排序切片的公共API兼容Go内置的' sort '包，如<code class="fe mx my mz na b">jsort.Sort</code>、<code class="fe mx my mz na b">jsort.Stable</code>、<code class="fe mx my mz na b">jsort.Slice</code>、<code class="fe mx my mz na b">jsort.SliceStable</code>等。它们都是使用timsort的稳定排序，在额外空间的成本上，timsort可能比<code class="fe mx my mz na b">sort.Stable</code>快2-5倍。</li><li id="d532" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">使用双支点排序提供了图元切片的专用函数，如<code class="fe mx my mz na b">jsort.Ints</code>、<code class="fe mx my mz na b">jsort.Int64s</code>等。它们可能比<code class="fe mx my mz na b">sort.Sort</code>快3倍，而且不占用额外空间。</li></ul><h1 id="6009" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">围棋的排序算法</h1><p id="a694" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated">排序API需要支持任意切片类型，其元素可以进行比较。如果一种语言支持泛型，通常很容易实现。Go目前还没有泛型，预计到2021年底会包含在<a class="ae kp" href="https://blog.golang.org/11years" rel="noopener ugc nofollow" target="_blank">v 1.18 beta版</a>中。Go中的泛型有<a class="ae kp" href="https://appliedgo.net/generics/" rel="noopener ugc nofollow" target="_blank">种替代方式</a>:代码生成、类型断言、反射和接口抽象。</p><p id="4e8c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">Go的内置<code class="fe mx my mz na b"><a class="ae kp" href="https://golang.org/src/sort/" rel="noopener ugc nofollow" target="_blank">sort</a></code>包使用接口抽象方法结合其他技术。排序算法依赖于接口<code class="fe mx my mz na b"><a class="ae kp" href="https://golang.org/src/sort/sort.go" rel="noopener ugc nofollow" target="_blank">sort.Interface</a></code>进行三种基本操作:Len、Less和Swap。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="af1a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mx my mz na b">sort.Slice</code>如果我们有时不想实现接口，函数就存在。它利用反射来派生Len和Swap操作。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ef9b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mx my mz na b">quickSort_func</code>函数可以在<a class="ae kp" href="https://golang.org/src/sort/zfuncversion.go" rel="noopener ugc nofollow" target="_blank"> zfuncversion.go </a>中找到，它是由<a class="ae kp" href="https://golang.org/src/sort/genzfunc.go" rel="noopener ugc nofollow" target="_blank"> genzfunc.go </a>从<code class="fe mx my mz na b">quicksort</code>函数的<code class="fe mx my mz na b">Interface</code>版本生成的。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e20a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">“sort.go”实现了不稳定排序和稳定排序的两种混合算法。<code class="fe mx my mz na b"><a class="ae kp" href="https://golang.org/pkg/sort/#Sort" rel="noopener ugc nofollow" target="_blank">sort.Sort</a></code>中的不稳定算法有以下特点:</p><ul class=""><li id="c5cb" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated">这是一个具有对数额外堆栈空间的递归就地算法，没有对临时空间的显式<code class="fe mx my mz na b">make</code>调用。</li><li id="2c82" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">该实现松散地遵循glibc中的<code class="fe mx my mz na b">qsort</code>。</li><li id="632a" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">递归深度由<code class="fe mx my mz na b">2*ceil(lg(n+1))</code>限定。一旦达到极限，它就切换到堆排序。</li><li id="406e" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">如果子问题的元素少于12个，它将运行一次间距为6的shell排序，然后应用插入排序。</li></ul><p id="d365" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mx my mz na b"><a class="ae kp" href="https://golang.org/pkg/sort/#Stable" rel="noopener ugc nofollow" target="_blank">sort.Stable</a></code>中的稳定算法使用了另一种方法:</p><ul class=""><li id="0ab0" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated">这也是一种具有对数附加堆栈空间的递归就地算法。</li><li id="7c6a" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">它将输入数据分成大小为20的块，然后对所有块运行插入排序。</li><li id="90ec" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">排序后的块通过<code class="fe mx my mz na b">symMerge</code>函数合并，该函数实现了<a class="ae kp" href="http://itbe.hanyang.ac.kr/ak/papers/esa2004.pdf" rel="noopener ugc nofollow" target="_blank">稳定最小存储合并</a>算法。</li></ul><h1 id="8165" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">JDK的排序算法</h1><p id="dcb0" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated">在旧的JDK版本中，Java对原始数组使用了一个<a class="ae kp" href="http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/8deef18bb749/src/share/classes/java/util/Arrays.java#l112" rel="noopener ugc nofollow" target="_blank">调优的快速排序</a>。排序<code class="fe mx my mz na b">Object[]</code>使用一个<a class="ae kp" href="http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/8deef18bb749/src/share/classes/java/util/Arrays.java#l1090" rel="noopener ugc nofollow" target="_blank">修改的合并排序</a>。从JDK 1.7开始，快速排序升级为<a class="ae kp" href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/java/util/Arrays.java#l99" rel="noopener ugc nofollow" target="_blank">双枢轴排序</a>，合并排序被<a class="ae kp" href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/java/util/Arrays.java#l468" rel="noopener ugc nofollow" target="_blank"> timsort </a>取代。</p><p id="fe15" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">2009年，Yaroslavskiy-Bloch-Bentley 首次推出双支点排序，实际上比单支点排序更快。它不会减少比较或交换操作的数量。速度更快是因为<a class="ae kp" href="https://algs4.cs.princeton.edu/lectures/keynote/23Quicksort.pdf" rel="noopener ugc nofollow" target="_blank">更少的CPU缓存未命中</a>。</p><p id="f2ab" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">Timsort是一种自适应的稳定合并排序，它利用了输入中的现有顺序。它是时间彼得斯在2002年为Python发明的。除了Java，还被<a class="ae kp" href="https://v8.dev/blog/array-sort" rel="noopener ugc nofollow" target="_blank"> V8 </a>、<a class="ae kp" href="https://github.com/apple/swift/pull/19717" rel="noopener ugc nofollow" target="_blank"> Swift </a>、<a class="ae kp" href="https://github.com/rust-lang/rust/pull/38192" rel="noopener ugc nofollow" target="_blank"> Rust </a>采用。实践证明，它的速度更快，需要O(n/2)的额外空间。这也是一个复杂的排序算法，几个实现被发现<a class="ae kp" href="http://www.envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/" rel="noopener ugc nofollow" target="_blank">破坏</a>。</p><p id="553a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mx my mz na b">jsort</code>基于OpenJDK 11中<a class="ae kp" href="https://github.com/AdoptOpenJDK/openjdk-jdk11u/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java" rel="noopener ugc nofollow" target="_blank">DualPivotQuickSort.java</a>和<a class="ae kp" href="https://github.com/AdoptOpenJDK/openjdk-jdk11u/blob/master/src/java.base/share/classes/java/util/TimSort.java" rel="noopener ugc nofollow" target="_blank">TimSort.java</a>的代码构建。</p><h1 id="1bf6" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">从Java移植到Go</h1><p id="4995" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated">除了以Go惯用的方式移植算法之外，我还尝试了一些仅用于评估的实验性解决方案，比如使用类型断言和Go2泛型。</p><h2 id="fc51" class="nj lk iq bd ll nk nl dn lp nm nn dp lt lg no np lx lh nq nr mb li ns nt mf nu bi translated">原始类型</h2><p id="99ab" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated"><a class="ae kp" href="https://github.com/AdoptOpenJDK/openjdk-jdk11u/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java" rel="noopener ugc nofollow" target="_blank">DualPivotQuicksort.java</a>为每个原语类型复制算法代码，因为<a class="ae kp" href="https://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html" rel="noopener ugc nofollow" target="_blank"> Java不支持专门化</a>。在Go中使用<code class="fe mx my mz na b">go generate</code>更容易完成。模板文件<a class="ae kp" href="https://github.com/openaphid/jsort/blob/main/sort_primitive.go" rel="noopener ugc nofollow" target="_blank"> sort_primitive.go </a>通过利用一些方便的go特性来实现该算法:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6c43" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mx my mz na b">// +build ignore</code>标志将模板排除在普通<code class="fe mx my mz na b">go build</code>之外，别名<code class="fe mx my mz na b">type primitive</code>创建了一个很容易被<a class="ae kp" href="https://github.com/openaphid/jsort/blob/main/sort_primitive_gen.go" rel="noopener ugc nofollow" target="_blank"> sort_primitive_gen.go </a>替换的占位符。生成器创建一个内部包，其中包含每个原语类型的专用代码和测试，如<a class="ae kp" href="https://github.com/openaphid/jsort/tree/main/internal/sort_int" rel="noopener ugc nofollow" target="_blank"> internal/sort_int </a>、<a class="ae kp" href="https://github.com/openaphid/jsort/tree/main/internal/sort_int64" rel="noopener ugc nofollow" target="_blank"> internal/sort_int64 </a>等。然后<a class="ae kp" href="https://github.com/openaphid/jsort/blob/main/sort_export.go" rel="noopener ugc nofollow" target="_blank"> sort_export.go </a>导出内部符号，比如<code class="fe mx my mz na b">jsort.Ints</code>和<code class="fe mx my mz na b">jsort.Int64s</code>函数。<code class="fe mx my mz na b">go generate</code>的一个漂亮的特性是，生成的代码可以在写入文件之前进行格式化。</p><h2 id="322a" class="nj lk iq bd ll nk nl dn lp nm nn dp lt lg no np lx lh nq nr mb li ns nt mf nu bi translated">通用切片类型</h2><p id="4c06" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated"><strong class="jt ir"> #1尝试:类型断言</strong></p><p id="8a3d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">为了支持排序通用切片类型，我首先在包<a class="ae kp" href="https://github.com/openaphid/jsort/tree/main/internal/sort_slice_dps_ts" rel="noopener ugc nofollow" target="_blank"> sort_slice_dps_ts </a>和<a class="ae kp" href="https://github.com/openaphid/jsort/tree/main/internal/sort_slice_tim_ts" rel="noopener ugc nofollow" target="_blank"> sort_slice_tim_ts </a>中试验了类型断言。排序函数期望数据参数是一个<code class="fe mx my mz na b">[]interface{}</code>和一个比较函数。看起来就像在Java中使用<code class="fe mx my mz na b">Object[]</code>和<code class="fe mx my mz na b">Comparator&lt;Object&gt;</code>。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="362f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在Java中，<code class="fe mx my mz na b">Object[]</code>和<code class="fe mx my mz na b">SomeClass[]</code>可以直接相互强制转换，没有开销成本。围棋不是这样，因为<code class="fe mx my mz na b">[]interface{}</code>和<code class="fe mx my mz na b">[]SomeStruct</code>是两种不同的类型。我们需要一个临时空间来帮助通过反射进行转换:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a2d1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">除了<code class="fe mx my mz na b">[]interface{}</code>的额外空间之外，它还需要在比较函数中从<code class="fe mx my mz na b">interface{}</code>到具体类型的额外强制转换操作，这是有代价的。这两个包没有被导出，因为使用类型断言在速度和内存上都不理想。</p><p id="849a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><strong class="jt ir"> #2方法:接口抽象</strong></p><p id="5945" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我首先想到的是，timsort不能建立在内置的<code class="fe mx my mz na b">sort.Interface</code>之上，因为算法依赖于更多的操作，比如索引<a class="ae kp" href="https://github.com/AdoptOpenJDK/openjdk-jdk11u/blob/master/src/java.base/share/classes/java/util/TimSort.java#L283" rel="noopener ugc nofollow" target="_blank">读</a>和<a class="ae kp" href="https://github.com/AdoptOpenJDK/openjdk-jdk11u/blob/master/src/java.base/share/classes/java/util/TimSort.java#L318" rel="noopener ugc nofollow" target="_blank">写</a>、<a class="ae kp" href="https://github.com/AdoptOpenJDK/openjdk-jdk11u/blob/master/src/java.base/share/classes/java/util/TimSort.java#L933" rel="noopener ugc nofollow" target="_blank">类型化数组创建</a>等。</p><p id="f106" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在更彻底地阅读了Go的<code class="fe mx my mz na b">sort</code>包的源代码后，我意识到接口抽象的关键是不要将数据类型泄露到排序算法中。我在包<a class="ae kp" href="https://github.com/openaphid/jsort/tree/main/internal/sort_slice_tim_interface" rel="noopener ugc nofollow" target="_blank">sort _ slice _ Tim _ interface</a>里想到了一个更好的主意，让timsort使用<code class="fe mx my mz na b">sort.Interface</code>:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4466" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">现在<code class="fe mx my mz na b">jsort.Sort</code>的函数签名和Go的<code class="fe mx my mz na b">sort.Sort</code>是一样的。我们可以用一个助手结构<code class="fe mx my mz na b"><a class="ae kp" href="https://github.com/openaphid/jsort/blob/main/internal/sort_slice_tim_interface/sort_slice_tim_interface.go#L67" rel="noopener ugc nofollow" target="_blank">lessSwap</a></code>来扩展它以支持<code class="fe mx my mz na b">sort.Slice</code>:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bd09" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">接口抽象通常是解决Go中需要泛型的任务的惯用技术。我很高兴<code class="fe mx my mz na b">jsort</code>可以使用与Go的<code class="fe mx my mz na b">sort</code>包相同的API导出timsort。需要注意的一点是<code class="fe mx my mz na b">jsort.Sort</code>和<code class="fe mx my mz na b">jsort.Stable</code>是timsort的相同函数，而<code class="fe mx my mz na b">sort.Sort</code>和<code class="fe mx my mz na b">sort.Stable</code>是不同的，这个规则也适用于<code class="fe mx my mz na b">Slice</code>和<code class="fe mx my mz na b">SliceStable</code>的函数。</p><p id="d6bd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><strong class="jt ir"> #3实验:Go2仿制药</strong></p><p id="48e1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">Go团队在2020年6月发布了一款<a class="ae kp" href="https://blog.golang.org/generics-next-step" rel="noopener ugc nofollow" target="_blank">实验工具</a><strong class="jt ir">go2go</strong>。我通过检查Go的一个dev分支在本地构建了这个工具，并用泛型语法编写了两个算法。令人印象深刻的是，我可以在不到5分钟的时间内构建一个完整的语言二进制文件。</p><p id="a2e8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">go2go工具将“<strong class="jt ir"> .go2 </strong>”代码文件翻译成“中的类型专用版本”。去吧”文件。这是一种异构的翻译，不同的专门化之间没有类型关系。翻译后的代码可以由Go 1.x构建和运行。</p><p id="6240" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">例如，我们可以用泛型为双支点排序和timsort声明排序函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c738" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">正如我通过用<code class="fe mx my mz na b">[]int</code>或<code class="fe mx my mz na b">[]Person</code>调用函数来编写测试一样，go2go生成了专门的函数:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9781" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">奥里亚文数字零<a class="ae kp" href="https://www.fileformat.info/info/unicode/char/0b66/index.htm" rel="noopener ugc nofollow" target="_blank"> ୦ (U+0B66) </a>和奥里亚文数字八<a class="ae kp" href="https://www.fileformat.info/info/unicode/char/0b6e/index.htm" rel="noopener ugc nofollow" target="_blank"> ୮ (U+0B6E) </a>被go2go用作分隔符。这两个字符在Go的标识符中使用是有效的，go2go假设没有人在自己的代码中使用它们。</p><p id="2cdf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">您可以找到“. go2”代码和翻译的“.go”包中的代码<a class="ae kp" href="https://github.com/openaphid/jsort/tree/main/internal/sort_slice_go2" rel="noopener ugc nofollow" target="_blank"> sort_slice_go2 </a>。对于这个特定的任务，用Go的新泛型语法编写感觉就像使用Java的泛型一样。</p><p id="9393" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">由于go2go关闭了<code class="fe mx my mz na b">GO111MODULE</code>，让go2文件与其他包共享代码并不容易。我只能玩包里面的代码。</p><h1 id="3730" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">错误</h1><p id="013e" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated">移植的大部分都很简单，我确实犯了一些值得注意的错误:</p><ul class=""><li id="e420" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated"><code class="fe mx my mz na b"><strong class="jt ir">++</strong></code><strong class="jt ir"/><code class="fe mx my mz na b"><strong class="jt ir">--</strong></code><strong class="jt ir">运算符</strong>。Java代码在很多地方使用了<code class="fe mx my mz na b">a++</code>和<code class="fe mx my mz na b">++a</code>。由于递增和递减运算符不是Go中的表达式，所以在Go中需要用两个语句来表示。例如，下面的Java代码在if语句中嵌入了一个增量运算符:</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a130" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">因为语义是增加<code class="fe mx my mz na b">runHi</code>并在if条件中使用旧值，所以等价的Go代码是:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="fb6b" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated"><strong class="jt ir">循环</strong>。Go只有一个循环关键字，而Java有几个可选的。当它带有增量和减量操作符时，就变得更棘手了。以下代码是Java双枢轴排序中的插入排序路径:</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4bec" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">事后的部分有一个增量操作和对两个变量的赋值，它被转换成如下:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="1356" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated"><strong class="jt ir">开关</strong>。Switch语句在Java中有隐式的失败行为，Go要求显式声明。下面这段timsort是在n较小时对数组复制的优化:</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6da3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我被它忽悠了，在Go里写错了代码。正确的版本是:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="707b" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated"><code class="fe mx my mz na b"><strong class="jt ir">&gt;&gt;&gt;</strong></code> <strong class="jt ir">操作员</strong>。对于无符号右移位操作，在Go中没有等效项。在Java代码中有两种情况。一种是得到中间点不发生整数溢出，这是历史上存在多年的<a class="ae kp" href="https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html" rel="noopener ugc nofollow" target="_blank">著名bug </a>:</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f2a1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在Go中，应该先转换成无符号int，然后再转换回来:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="516c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">Java中的另一个地方是计算2的下一个最小幂:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0e14" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我不知道如何在一行中完成，使用来自<a class="ae kp" href="https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2" rel="noopener ugc nofollow" target="_blank">bit twidling hacks</a>的想法:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="0731" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">基准</h1><p id="cae2" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated">我必须说，在Go中编写基准更加自然，因为它内置于Go的工具链中，而Java需要手动设置<a class="ae kp" href="https://openjdk.java.net/projects/code-tools/jmh/" rel="noopener ugc nofollow" target="_blank"> jmh </a>。</p><p id="4e95" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><a class="ae kp" href="https://github.com/openaphid/jsort/blob/main/sort_benchmark_test.go" rel="noopener ugc nofollow" target="_blank"> sort_benchmark_test.go </a>设置int切片和struct切片排序的基准。在每个基准测试场景中使用了两种类型的数据集。一个是随机数据，这意味着元素大多是未排序的，只有很少的重复数据。另一种使用XOR运算从索引值计算数据，这使得数据部分排序。数据集的大小范围从256到65536。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="cef5" class="nj lk iq bd ll nk nl dn lp nm nn dp lt lg no np lx lh nq nr mb li ns nt mf nu bi translated">#1基准:比较次数</h2><p id="7c6e" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated">让我们首先通过<a class="ae kp" href="https://github.com/openaphid/jsort/blob/main/sort_op_test.go" rel="noopener ugc nofollow" target="_blank"> sort_op_test.go </a>检查每个排序算法的比较次数。可以自己跑<code class="fe mx my mz na b">make operation_stats</code>看看数字。我们可以发现:</p><ul class=""><li id="ab05" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated">Timsort总是比其他人使用更少的比较。在xor数据集基准测试中，它的优势更加显著。</li><li id="07dc" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">双支点排序比其他排序需要更多的比较。</li><li id="092c" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><code class="fe mx my mz na b">sort.Sort</code>不适应数据模式。它在随机数据集和异或数据集上使用几乎相同数量的比较。</li><li id="b7f2" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><code class="fe mx my mz na b">sort.Stable</code>在异或数据集上比<code class="fe mx my mz na b">sort.Sort</code>使用更少的比较，在随机数据集上使用更多的比较。</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nv nf l"/></div></figure><p id="5161" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">从理论上讲，timsort似乎比其他人更快。但是现实世界中的性能受到许多其他指标的影响。让我们运行性能基准来研究它。</p><h2 id="259e" class="nj lk iq bd ll nk nl dn lp nm nn dp lt lg no np lx lh nq nr mb li ns nt mf nu bi translated">#2基准:排序整数</h2><p id="b14d" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated"><a class="ae kp" href="https://github.com/openaphid/jsort/blob/main/sort_benchmark_test.go#L74" rel="noopener ugc nofollow" target="_blank">第一组基准</a>用于int切片。我试图测试所有适用的API:</p><ul class=""><li id="8c39" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated"><strong class="jt ir"> Dps-SpecializedInts </strong>使用的<code class="fe mx my mz na b">jsort.Ints</code>是int的专用双枢轴排序。</li><li id="1264" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">BuiltinSort-specialized ints</strong>使用的是Go内置的不稳定排序算法的专业版，我在<a class="ae kp" href="https://github.com/openaphid/jsort/blob/main/sort_builtin_specialized_test.go" rel="noopener ugc nofollow" target="_blank">sort _ builtin _ specialized _ test . Go</a>中手工创建的。</li><li id="a208" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">内置切片</strong>使用内置<code class="fe mx my mz na b">sort.Slice</code>功能。</li><li id="0e7e" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">内置排序功能</strong>使用<code class="fe mx my mz na b">sort.Sort</code>功能。</li><li id="47ca" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">TimSort-接口</strong>调用<code class="fe mx my mz na b">jsort.Sort</code>即Tim sort。</li><li id="0361" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir"> TimSort-Slice </strong>调用<code class="fe mx my mz na b">jsort.Slice</code>函数。</li><li id="5381" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">内置切片表</strong>使用<code class="fe mx my mz na b">sort.SliceStable</code>功能。它仅用于评估，因为对基元使用稳定排序没有意义。</li><li id="8373" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">内置排序稳定</strong>使用<code class="fe mx my mz na b">sort.Stable</code>功能。</li><li id="4863" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir"> Dps-TypeAssertion </strong>和<strong class="jt ir"> TimSort-TypeAssertion </strong>使用双枢纽排序和TimSort的类型断言变体。预计它们的效率较低。</li></ul><p id="f824" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">“Dps-SpecializedInts”和“BuiltinSort-Sort”是实践中对int slice进行排序的推荐API。我在图表中突出显示了它们。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nw nf l"/></div></figure><p id="5543" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">排序随机整数的数字可以给我们一些发现:</p><ul class=""><li id="2591" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated"><code class="fe mx my mz na b">jsort.Ints</code>可以比围棋的<code class="fe mx my mz na b">sort.Ints</code>功能快3倍。两者都不占用额外的空间，因为它们都是就地排序。它很好地解释了为什么Java采用双支点排序。</li><li id="51e5" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">接口抽象对性能的影响不容忽视。“BuiltinSort-SpecializedInts”通过减少开销来加快速度，尽管它比<code class="fe mx my mz na b">jsort.Ints</code>慢10%~20%。</li><li id="93e2" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">当比较成本较低时，Timsort在随机数据上的速度并不快。</li><li id="67f0" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">使用类型断言是最慢的，而且由于类型转换，它也消耗了最多的额外空间。</li><li id="f389" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">在int slice上<code class="fe mx my mz na b">sort.Slice</code>比<code class="fe mx my mz na b">sort.Sort</code>快，而在<code class="fe mx my mz na b">jsort.Slice</code>和<code class="fe mx my mz na b">jsort.Sort</code>上结果相反。我还不知道原因。</li><li id="9e03" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><code class="fe mx my mz na b">sort.Stable</code>最慢。</li></ul><p id="d318" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">对xor数据的测试告诉我们更多的故事:</p><ul class=""><li id="2b50" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated"><code class="fe mx my mz na b">jsort.Ints</code>可以比<code class="fe mx my mz na b">sort.Ints</code>快5倍。</li><li id="2fdb" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">双支点排序和timsort的性能都要好得多。Timsort可以比内置的排序算法更快。</li></ul><h2 id="0f2b" class="nj lk iq bd ll nk nl dn lp nm nn dp lt lg no np lx lh nq nr mb li ns nt mf nu bi translated">#3基准:排序结构</h2><p id="6448" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated"><a class="ae kp" href="https://github.com/openaphid/jsort/blob/main/sort_benchmark_test.go#L319" rel="noopener ugc nofollow" target="_blank">另一组基准测试</a>是对一个结构的片进行排序，这个结构有一个int字段和一个string字段:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2280" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">基准测试测试了所有可以通过<code class="fe mx my mz na b">Name</code>字段对<code class="fe mx my mz na b">[]Person</code>进行排序的API，它的值是一个来自random int或XOR computed int的字符串。</p><ul class=""><li id="962b" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated"><strong class="jt ir">Unstable-builtin Sort-Sort</strong>使用Go的<code class="fe mx my mz na b">sort.Sort</code>，这是一种不稳定排序。</li><li id="6597" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">Stable-Tim sort-Interface</strong>使用的是<code class="fe mx my mz na b">jsort.Sort</code>，是稳定排序。</li><li id="ee1f" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">不稳定内置排序片</strong>使用<code class="fe mx my mz na b">sort.Slice</code>，也是不稳定排序。</li><li id="f1be" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">稳定时间排序片</strong>调用<code class="fe mx my mz na b">jsort.Slice</code>。</li><li id="a481" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">稳定内置排序稳定</strong>调用<code class="fe mx my mz na b">sort.Stable</code>。</li><li id="0a5a" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">Unstable-Dps-type assertion</strong>和<strong class="jt ir">Stable-TimSort-type assertion</strong>测试两种算法的类型断言版本。</li><li id="f4a8" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><strong class="jt ir">Stable-built insert-slice Stable</strong>调用<code class="fe mx my mz na b">sort.SliceStable</code>。</li></ul><p id="53d8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">实际上，稳定排序是结构的首选。它们在图表中突出显示。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nx nf l"/></div></figure><p id="5ea6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">对于随机名称数据集，我们可以收集一些见解:</p><ul class=""><li id="6d4a" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated"><code class="fe mx my mz na b">jsort.Sort</code>是所有稳定排序API中最快的。它比不稳定的<code class="fe mx my mz na b">sort.Sort</code>慢15%，比<code class="fe mx my mz na b">sort.Stable</code>快50%~100%。</li><li id="2d5d" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">Timsort需要额外的空间。</li><li id="c6e3" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated"><code class="fe mx my mz na b">sort.SliceStable</code>可以比<code class="fe mx my mz na b">sort.Stable</code>慢100%，而<code class="fe mx my mz na b">jsort.Slice</code>和<code class="fe mx my mz na b">jsort.Sort</code>可以慢20%。</li></ul><p id="06c1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在xor names数据集上，<code class="fe mx my mz na b">jsort.Sort</code>在速度上明显胜出。甚至比<code class="fe mx my mz na b">sort.Sort</code>还快。</p><h2 id="a269" class="nj lk iq bd ll nk nl dn lp nm nn dp lt lg no np lx lh nq nr mb li ns nt mf nu bi translated">#4基准:Go2泛型</h2><p id="2225" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated">实验性的Go2泛型在相同的任务上表现如何？由于<code class="fe mx my mz na b">GO111MODULE</code>被go2go关闭，我无法在go2文件中导入<code class="fe mx my mz na b">jsort</code>包。基准测试只将go2版本的dual-pivot sort和timsort与内置的排序函数进行了比较。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nv nf l"/></div></figure><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nf l"/></div></figure><ul class=""><li id="9a22" class="mh mi iq jt b ju jv jy jz lg ng lh nh li ni ko mo mp mq mr bi translated">“Dps-Go2”的翻译代码和“Dps-SpecializedInts”基本相同，对于int slice来说最快也就不足为奇了。</li><li id="2885" class="mh mi iq jt b ju ms jy mt lg mu lh mv li mw ko mo mp mq mr bi translated">“Timsort-Go2”的速度与“Stable-TimSort-Interface”不相上下，但它使用了更多的额外空间，因为它在内部分配了<code class="fe mx my mz na b">[]Person</code>而不是<code class="fe mx my mz na b">[]int</code>。如果结构<code class="fe mx my mz na b">Person</code>的大小增加，将需要更多的空间。</li></ul><h1 id="92e4" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="e6ec" class="pw-post-body-paragraph jq jr iq jt b ju mj jw jx jy mk ka kb lg nb ke kf lh nc ki kj li nd km kn ko ij bi translated">Go的排序函数可以通过使用其他算法来提高性能。如果分拣速度对您的服务至关重要，请尝试[ <a class="ae kp" href="https://github.com/openaphid/jsort" rel="noopener ugc nofollow" target="_blank"> jsort </a> ] package。</p></div></div>    
</body>
</html>