<html>
<head>
<title>How to improve the DDDness of your application.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高自己应用的DDDness？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-improve-the-dddness-of-your-application-3db2e0536ad7?source=collection_archive---------1-----------------------#2021-08-09">https://itnext.io/how-to-improve-the-dddness-of-your-application-3db2e0536ad7?source=collection_archive---------1-----------------------#2021-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="75da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者换句话说，如何通过封装构建意图揭示API，一本实用指南。</p><p id="66c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博文中的所有代码都可以在<a class="ae kl" href="https://github.com/VisualBean/Improve-DDDness" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="3c59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="#0eee" rel="noopener ugc nofollow">前言:</a> <br/> ∘ <a class="ae kl" href="#036b" rel="noopener ugc nofollow">通信和意图</a> <br/> <a class="ae kl" href="#e827" rel="noopener ugc nofollow">代码气味:公共设置程序等于没有办法强制执行一致性</a> <br/> ∘ <a class="ae kl" href="#3cd7" rel="noopener ugc nofollow">修复:使类不可变</a> <br/> <a class="ae kl" href="#233b" rel="noopener ugc nofollow">代码气味:【当我们记住时有效】模式</a> <br/> ∘ <a class="ae kl" href="#87e3" rel="noopener ugc nofollow"> IsValid vs永远有效</a> <br/> ∘ <a class="ae kl" href="#af0a" rel="noopener ugc nofollow">修复:将验证逻辑移至构造函数</a> <br/> <a class="ae kl" href="#d2d0" rel="noopener ugc nofollow">代码气味 </a> <br/> <a class="ae kl" href="#6384" rel="noopener ugc nofollow">代码气味:通过命名来沟通关系</a> <br/> ∘ <a class="ae kl" href="#585e" rel="noopener ugc nofollow">修复:将其封装在一个类(ValueObject) </a> <br/> <a class="ae kl" href="#78cb" rel="noopener ugc nofollow">代码气味:公开列表API </a> <br/> ∘ <a class="ae kl" href="#799e" rel="noopener ugc nofollow">修复:封装列表并公开一个IEnumerable </a> <br/> <a class="ae kl" href="#6e8a" rel="noopener ugc nofollow">代码气味:无丰富行为</a> <br/> ∘ <a class="ae kl" href="#b92b" rel="noopener ugc nofollow">修复:使用无处不在的语言</a> <br/> <a class="ae kl" href="#5a9f" rel="noopener ugc nofollow">封装逻辑 </a> <br/> <a class="ae kl" href="#75cb" rel="noopener ugc nofollow">提示</a></p><h1 id="0eee" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">前言:</h1><p id="1bef" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">对我来说，DDD完全是关于构建意图揭示API的(如果我们超越所有组织和领域发现的东西)。这是关于将商业概念和规则封装在对象中，也就是所谓的老式面向对象编程。</p><p id="a5d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将介绍一些可以帮助你“更好地”封装领域逻辑的代码味道和模式。我们将通过重构这些类来做到这一点；</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/a0fd019b911e232bf96446c8faec142d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*I08-KJHXjMxIIsT_D04Uag.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">恶魔阶级</figcaption></figure><p id="f69b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一类是<code class="fe mb mc md me b">Demon</code>类，这是我们大多数人大概都用过，也见过很多次的。没有封装，只有由消费代码设置的属性。</p><p id="58bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码通常由类似于</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/95ef423c0be0c8b7b62a8ae1198699a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*Q8AnhGczy5__XSrB7UyG-g.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">带有某种工厂方法的DemonService类。</figcaption></figure><p id="e29d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mb mc md me b">DemonService</code>类将有一个工厂方法，用于封装创建，最好的情况是对输入进行一些验证。</p><h2 id="036b" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">沟通和意图</h2><p id="b21f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">那么我们和这些类交流什么呢？</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/bf380aa7ba54fbced2e432599ca08af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*AyRessAuwG734SSQMIvmOg.png"/></div></div></figure><p id="8889" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从API来看，不是很多。我阅读的意图是，所有这些属性都是可选的，并且允许随时更改。</p><p id="bf94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe mb mc md me b">DemonService</code>级来说，情况非常相似。我们在这里面临的问题是，开发人员必须知道工厂方法的存在，以便获得一个“有效的”demon实例。拥有公共设置器也鼓励hacky代码修复bug“让我们快速改变它，然后继续前进”。</p><h1 id="e827" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">代码味道:公共设置器等于没有办法加强一致性</h1><p id="4a19" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果你再看一下Demon类，你会看到所有的属性都有公共的getters和setters，这意味着我们没有办法在一个实例的生命周期内保持一致性。它随时都可能被改变。</p><h2 id="3cd7" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">修复:使类不可变</h2><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/6a54bcec9c6dd10012573ea7608f3ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*sEP_PAXQ9w74XItmzjgVog.png"/></div></figure><p id="52de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，至少我们知道一个恶魔在它的一生中都是一致的，因为属性不会改变。</p><h1 id="233b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">代码气味:“记忆时有效”模式</h1><p id="b6d8" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">还记得工厂方法的<code class="fe mb mc md me b">DemonService</code>类吗？</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d2b141e4a518f8cd26af3e13988d6911.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*Y91sOi2iLeTYCIIyfxlrfg.png"/></div></figure><p id="1d56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将验证和创建逻辑从类中分离出来，可能看起来不错，这是关注点的分离..对吗？..对吗？不..<br/>这将再次留给黑客代码，其中“我们只需要一个有名字的恶魔”或类似的语义将在代码库中被抛出。问题是；这不是一个有效的<code class="fe mb mc md me b">Demon</code>。</p><h2 id="87e3" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">IsValid vs Always Valid</h2><p id="d963" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">IsValid 是指当我们的类中有一个检查有效性的方法时(当我们调用它时)。<br/> <strong class="jp ir">永远有效</strong>是一个实例应该永远是一个有效实例的想法。这样，我们知道如果我们得到一个实例，它将总是“正确的”。</p><h2 id="af0a" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">修复:将验证逻辑移到构造函数中</h2><p id="2b57" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">将验证逻辑从工厂方法移到<code class="fe mb mc md me b">Demon</code>类的构造函数中。我们现在<strong class="jp ir">永远有效</strong>。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi my"><img src="../Images/ebe252ab9aad1015bbed9914b1202771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0keMrXVg_7ZIfxvdfxWuw.png"/></div></div></figure><h1 id="d2d0" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">代码气味:原始痴迷</h1><p id="5106" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">再看一次妖类；</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/b6a75b3d745fbdf0eb32433b4216d5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*pDnqBIgO1sbrfA2k1eS57A.png"/></div></figure><p id="5e10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们是如何使用原语的吗？<code class="fe mb mc md me b">int</code>的和<code class="fe mb mc md me b">string</code>的到处都是。</p><p id="4116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原语的问题在于，它们的不变量可能比你实际接受和想要的要多得多。让我们以<code class="fe mb mc md me b">List&lt;string&gt; Underlings</code>为例。<br/>一个<code class="fe mb mc md me b">string</code>有多少个不变量？什么是“有效的”下属？尤其是当我们把一个<code class="fe mb mc md me b">List</code>作为参数的时候。我们如何验证条目？</p><h2 id="2317" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">修复:将其封装在一个类中(ValueObject)</h2><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e95d9f1eebbbe6c5f661672077f21b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*fDP6g4AIWAXAukjnKAHUmA.png"/></div></figure><p id="7d9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！现在我们可以验证一个下属是它自己的事情，我们肯定会有一个“有效”的实例，因为我们遵循的规则是<strong class="jp ir">永远有效</strong>。</p><h1 id="6384" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">代码气味:关系是通过命名来交流的</h1><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/e6b0ddf34a11abdd42ca31f8b6a68e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*tW0sXyn8aIcopnhhnesQ4g.png"/></div></figure><p id="4b63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种码味与<a class="ae kl" href="#d2d0" rel="noopener ugc nofollow">原始执念</a>密切相关。看一下<code class="fe mb mc md me b">PowerDamage</code>和<code class="fe mb mc md me b">PowerName</code>，它们似乎在它们之间传递某种形式的关系，但是没有任何东西强制执行它，当然可以通过构造器中的验证来强制执行，但是消费者呢？我们如何更好地沟通这种关系？</p><h2 id="585e" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">修复:将其封装在一个类中(ValueObject)</h2><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1bb4f9b721b1fd3b8c348599abe9630d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*RcaQjtCbxiKzOW4GQ5Ublg.png"/></div></figure><p id="8ba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在它是一个自己的对象，可以这样使用，<strong class="jp ir">永远有效</strong>和一切… <br/>并且在<code class="fe mb mc md me b">Demon</code>构造函数中</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3ef6d67ff18b55e979499d17ef817251.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*JBsW_Ajtjbf7B58JuVbc-w.png"/></div></figure><h1 id="78cb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">代码味道:公开列表API</h1><p id="e222" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果你注意到在<code class="fe mb mc md me b">Demon</code>类中，我们可能已经为<code class="fe mb mc md me b">Underlings</code>设置了私有的setter，但是因为它是一个<code class="fe mb mc md me b">List</code>类型，我们公开了<code class="fe mb mc md me b">List</code> API。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/19e3aa7c8037787798f413a7192afe4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*e0DDqxgChhE98UEOSYl_GQ.png"/></div></figure><p id="823d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时，这可能是我们想要的，但不是在这种情况下。</p><h2 id="799e" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">修复:封装列表并公开一个<code class="fe mb mc md me b">IEnumerable</code></h2><p id="f242" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">通过封装列表并只公开一个<code class="fe mb mc md me b">IEnumerable</code>，我们停止公开<code class="fe mb mc md me b">List</code> API。与此同时，我们将使用我们的恶魔领域中无处不在的语言来制作新的<code class="fe mb mc md me b">Underling</code>。因为我们将验证逻辑移到了<code class="fe mb mc md me b">Underling</code>类，所以我们可以安全地“新建”它。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ne"><img src="../Images/a4b6898579913f2adb89217926a06354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIzqHAKHb8N78dFPxag8nQ.png"/></div></div></figure><h1 id="6e8a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">代码气味:没有丰富的行为</h1><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/7d4d08ef18cc14bb3301b3173ca1592f.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*VBZYB9yBVBhr-j4Zx2vBiw.png"/></div></figure><p id="9911" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们仔细观察我们的<code class="fe mb mc md me b">Demon</code>类，我们会注意到我们实际上没有任何丰富的行为。然而，我们确实有一些关于<code class="fe mb mc md me b">Demon</code>角的领域规则。在我们的领地里，一只<code class="fe mb mc md me b">Demon</code>只能长角，不能蜕角，也不是“天生”就有的。</p><h2 id="b92b" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">修复:使用通用语言封装逻辑</h2><p id="18b4" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们简单地将这个逻辑封装在一个方法<code class="fe mb mc md me b">GrowHorns()</code>中。这样，消费代码总是可以给我们的<code class="fe mb mc md me b">Demon</code>实例添加角。域名是完整的！</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c6261c15cc483f185393fb997292c448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*xI3h9x6j0OPfwmeuET4PrA.png"/></div></figure><p id="c3ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">行为应该只对它封装的状态进行操作。这意味着Demon类内部的行为应该只改变Demon类及其封装的类的状态。—然而这可能有点棘手，将由设计者和领域专家来决定是<code class="fe mb mc md me b">Demon</code>应该直接改变<code class="fe mb mc md me b">underling</code>还是<code class="fe mb mc md me b">Underling</code>应该封装这个逻辑，而<code class="fe mb mc md me b">Demon</code>只是简单地调用那个逻辑。</p><h1 id="5a9f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">创作模式</h1><p id="8fca" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果我们看一下<code class="fe mb mc md me b">Demon</code>类，构造函数是用来创建一个新实例的。这通常没问题，但是有一些方法可以让它变得更普遍。</p><h2 id="3e58" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">私有构造函数+静态工厂方法</h2><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/1ec84388ce9fd59f121c9d875d20944f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*bt5D4O6j1xZZwdN8DdLecw.png"/></div></figure><p id="aa66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着对消费者隐藏构造函数，并拥有一个调用构造函数的静态方法。注意遍在语的使用。</p><h2 id="21eb" class="mg kn iq bd ko mh mi dn ks mj mk dp kw jy ml mm la kc mn mo le kg mp mq li mr bi translated">私有构造函数+静态实例</h2><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1bb4f9b721b1fd3b8c348599abe9630d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*RcaQjtCbxiKzOW4GQ5Ublg.png"/></div></figure><p id="48ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看<code class="fe mb mc md me b">Power</code>类，我们可能不希望消耗代码来简单地创造新的能力。我们可以强迫他们使用现有的权力。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/cc2dd3b8e0652ecbccf8e0d57d30e8d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*F1MMkkGzE6hHvZpHFertjA.png"/></div></figure><h1 id="d65a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">我们最终交流的是什么？</h1><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/268dcffcbcbd4898e5fc7bcdd9fdaa7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*LyTqhjNntX71ik3uclFBMQ.png"/></div></figure><p id="9507" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在浏览API，实例化一个<code class="fe mb mc md me b">Demon</code>的唯一方法就是调用静态工厂方法<code class="fe mb mc md me b">Summon()</code>。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/89d7290b36d8052d699ece9c356b621c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*UT0wYOzgihYcDcRn2PR73Q.png"/></div></figure><p id="51cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有两种力量。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c6529bd6f8303bf15d131c17b8657365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*K0YPXrL9RHHZbUGZ4HkVdw.png"/></div></figure><p id="49ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有效地沟通什么是被允许的，以及我们领域中无处不在的语言。</p><p id="c24f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到所有的代码<a class="ae kl" href="https://github.com/VisualBean/Improve-DDDness" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="75cb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">技巧</h1><ol class=""><li id="ff45" class="nk nl iq jp b jq lk ju ll jy nm kc nn kg no kk np nq nr ns bi translated">记住总是覆盖相等比较方法和<code class="fe mb mc md me b">GetHashCode</code>或者简单地使用新添加的<code class="fe mb mc md me b"><a class="ae kl" href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/records" rel="noopener ugc nofollow" target="_blank">record</a></code>类型。</li><li id="7a34" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">将您的领域模型放在它自己的项目中。这使得推理什么应该与什么对话，以及哪些项目应该依赖于哪些项目变得容易得多。</li><li id="0fc5" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">存储库接口和域事件应该存在于域项目中。而不是存储库实现。—参见4。</li><li id="5143" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">领域模型不关心存储。</li><li id="3575" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">不要使用<code class="fe mb mc md me b">IAggregateRoot</code>、<code class="fe mb mc md me b">IEntity</code>和<code class="fe mb mc md me b">IValueObject</code>接口。有些人喜欢这些，但我发现它们弊大于利。M <a class="ae kl" href="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/ms182128(v=vs.100)?redirectedfrom=MSDN" rel="noopener ugc nofollow" target="_blank"> arker接口</a>是非常情境化的，在DDD方面使用它们的一个副作用是你强迫自己将一个对象视为给定的类型，使你偏向那个方向。DDD的这些概念也纯粹是为了解释它们之间的等级和依赖关系。可能有理由为AggregateRoot提供一个接口，存储库将使用该接口来确保只有<code class="fe mb mc md me b">IAggregateRoot</code>对象被从数据库发送回来。你也可以维护一个<code class="fe mb mc md me b">Entity</code> <strong class="jp ir">基类</strong>(不是一个接口)，比如<a class="ae kl" href="https://enterprisecraftsmanship.com/posts/entity-base-class/" rel="noopener ugc nofollow" target="_blank"> this </a>来强制使用好的和合理的缺省值进行相等比较，并强制它拥有一个<code class="fe mb mc md me b">Id</code>。</li><li id="21cf" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">AggregateRoot“只是”顶级实体。可以说它不是一个实体。</li></ol></div></div>    
</body>
</html>