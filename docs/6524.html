<html>
<head>
<title>Modern C++ in Advent of Code: Day9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++代码的出现:第9天</h1>
<blockquote>原文：<a href="https://itnext.io/modern-c-in-advent-of-code-day9-1ad4e7890032?source=collection_archive---------3-----------------------#2021-12-09">https://itnext.io/modern-c-in-advent-of-code-day9-1ad4e7890032?source=collection_archive---------3-----------------------#2021-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="18e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是代码问世的第九天。今天，我们将分析低点和连续区域的2D矩阵。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/72c4d3a3ec890da3d0dd03ca7273aab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMzB-kdpDViXTVV2bTp8iw.png"/></div></div></figure><p id="b32d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，请先尝试解决问题，然后再看解决方案。对于这个系列的所有文章，<a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">看看这个列表</a>。</p><h1 id="3223" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第九天:第一部分</h1><p id="4bde" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们的输入是一个高度图，值0–9代表高度。我们的首要任务是找到地图上的低点。低点是指四周都被较高值包围的点。我们也把地图外的点算作高度9。</p><p id="389d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要一个函数来读取输入，然后我选择提供一个测试函数，期望主函数将在地图上迭代:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="a082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了快速测试，我们使用来自AoC的数据:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="08c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们可以实现我们的两个功能。由于每个元素都是一个数字，今天我们将逐个字符地解析输入:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3023" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，由于我们对检测新行字符感兴趣，我们必须取消设置<code class="fe md me mf mg b">std::ios_base::skipws</code>。默认情况下，阅读字符会跳过空白。我决定在这里使用launte _ back，那么我们来讨论一下与push_back的区别。这里:</p><ul class=""><li id="b41d" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">我们读取行，行向量将根据需要重新分配</li><li id="9c9e" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">使用launte _ back和move，向量会将其分配的缓冲区让给结果中新创建的向量</li><li id="d03e" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">读取下面一行将强制进行另一次分配</li></ul><p id="d62e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们改用push_back:</p><ul class=""><li id="032c" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">当读取第一行时，向量将根据需要重新分配</li><li id="22a8" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">使用push_back，内部缓冲区将复制到结果中新创建的向量</li><li id="4d33" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">我们将显式调用clear()来删除前一行中的数据，这不会改变容量</li></ul><p id="816e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，考虑到边界条件，为了检查高度图中的特定点是否是低点，我们需要检查四个邻居。</p><p id="b589" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在main函数中，我们迭代地图上的所有点，并检查它们是否是低点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h1 id="b763" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第九天:第二部分</h1><p id="308c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在第二部分中，我们必须找到三个最大的盆地，其中盆地是高度小于9的简单连通区域。因此，我们可以重新定义这个问题，把九楼当作一面墙，其他的都是“空”的区域。有了这个，我们需要做的就是一个洪水填充/广度优先搜索。此外，我们只关心盆地的大小，所以我们可以使用破坏性的方法，只需将地图上的每个访问点更改为一堵墙(九个)。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="c7fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试，我们依赖AoC的测试数据:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="e82a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于广度优先搜索的队列部分，我们使用<code class="fe md me mf mg b">std::queue</code>，但是您也可以使用<code class="fe md me mf mg b">std::deque</code>或者甚至<code class="fe md me mf mg b">std::unordered_set</code>(这将稍微简化代码，但是会对性能产生影响)。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="b1da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在方向检查之前，可以排除更新地图和增加大小的因素；然而，我们可能会访问每个坐标多达四次。</p><p id="41ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的主函数中，我们再次迭代地图，当我们遇到潜在的盆地(非墙)时调用<code class="fe md me mf mg b">flood_fill</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="7d40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了存储大小，我们有几个选项，这取决于我们是考虑内存还是性能。使用向量和排序是最直接的方法，但是它也增加了存储所有流域大小的O(n)内存开销和最后排序所有大小的O(n*logn)内存开销。</p><p id="30b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，我们可以:</p><ul class=""><li id="b1fd" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">使用三个变量和一点更新逻辑</li><li id="9bf0" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">使用<code class="fe md me mf mg b">std::priority_queue</code>并且只保留三个元素</li><li id="50e0" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">按照与<code class="fe md me mf mg b">priority_queue</code>相同的思路使用<code class="fe md me mf mg b">std::set</code></li></ul><h1 id="f4a8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="46c8" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">每日解决方案存储库位于:<a class="ae kl" href="https://github.com/HappyCerberus/moderncpp-aoc-2021" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/moderncpp-aoc-2021</a>。</p><p id="cdc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看此列表，了解关于《代码降临》其他日子的文章。</p><p id="e60f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请不要忘记亲自尝试<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">降临码</a>。</p><h1 id="10db" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="274d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="ab84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在Twitter或LinkedIn上联系我。</p></div></div>    
</body>
</html>