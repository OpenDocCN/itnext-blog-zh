# 异步重试

> 原文：<https://itnext.io/blog-md-3f9801f99454?source=collection_archive---------9----------------------->

最近想到一个好玩的问题。如果您想构建一种方法来重试某些异步调用(例如，长时间轮询最终到达的资产的 url 或重试 HTTP 调用)，该怎么办呢？我四处摸索，想出了一个我认为非常酷的解决方案。

> 我知道有些图书馆是这样做的，但是建筑很有趣，而且对我的大脑有好处！

这是我之前想到的解决方案。我使用`Promises`来处理这个问题的异步本质。

这是将 [Bluebird.js](http://bluebirdjs.com/docs/api-reference.html) 用于`reflect` API。我们使用递归来重试，直到达到预定的尝试次数。`Promises`一实例化就开始运行。通常，当使用`Promises`时，我们会启动该功能，然后我们可以根据需要传递那个`Promise`来附加东西。不幸的是，如果我们想要重试这个承诺，我们需要这个函数和`args`，这样我们就可以在需要的时候重启它。这就是为什么我们需要分别传入异步函数和`args`。

Bluebird `reflect()`函数接受一个承诺，并将其包装在一个`Promise Inspection`中。`Promise Inspection`模仿了一个已解决的`Promise`，但也揭示了一些有用的方法。即`.isFulfilled()`和`.value()`。我们可以用这些方法来检查内部`Promise`。如果内部的`Promise`满足，那么我们返回值。如果不满足，那么我们将错误推送到一个数组中，并在可用的重试次数少 1 次的情况下递归。

这就是它的作用:

过了一会儿，我正在做一个使用 [Flutures](https://github.com/fluture-js/Fluture) 的项目，需要一个类似的解决方案，所以我拼凑了这段代码:

`Futures`(由`Fluture`实现)有一些有趣的属性。与承诺不同的一个特别之处是`Futures`不执行，直到你附加了一个`.fork`调用。查看签名，该函数采用退避策略函数、多次重试和一个`Future`。

你会注意到，`retry`函数接受一个完整的`Future`，而不是一个函数和参数。这是因为`Futures`的懒惰。这意味着我们可以将函数和参数包装在一起，并在准备好的时候运行它。但是，在我们运行它之前，我们想设置这些重试。

对于我们想要做的每一次重试，我们添加一个`chainRej()`调用。因此，如果我们要重试 2 次，那么我们做一些类似于`task.chainRej(...).chainRej(...)`的事情。我们使用递归来实现这一点。我们传递给`chainRej`的函数只有在`Future`拒绝(失败)时才会被调用。当发生这种情况时，我们将错误添加到一个列表中，增加我们的重试计数器，然后我们进行决策。如果我们已经重试了最大次数，那么我们拒绝整个`Future`。如果我们没有使用所有的重试，那么我们使用退避函数和`Future.after()`将新的尝试次数传递回我们的递归函数。

其中一件很酷的事情是有一种方法可以传递回退策略。所以我们可以用不同的方式使用相同的重试功能。我们可以创建一个线性或指数回退，并将其中任何一个传递给重试函数。

它以全新的方式解决了同样的问题。这两种解决方案的唯一共同点是我们使用了递归。

下面是该函数的用法:

在这两种情况下，构建一些解决这个问题所需的工具而不是下载另一个库是很有趣的。我发现这些作为精神的形，帮助我理解我正在使用的工具。经历这些动作也帮助我更有信心解决棘手的问题。