<html>
<head>
<title>Adding features to a simple Blazor MVVM client with composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用composition为一个简单的Blazor MVVM客户端添加特性</h1>
<blockquote>原文：<a href="https://itnext.io/adding-features-to-a-simple-blazor-mvvm-client-with-composition-f31bfb01e20a?source=collection_archive---------4-----------------------#2019-04-13">https://itnext.io/adding-features-to-a-simple-blazor-mvvm-client-with-composition-f31bfb01e20a?source=collection_archive---------4-----------------------#2019-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6583" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是详细介绍在客户端Blazor中实现MVVM模式的一种方法的系列文章的第三篇。如果您想从头开始阅读本系列，第一篇文章位于此处:</p><div class="kl km gp gr kn ko"><a rel="noopener  ugc nofollow" target="_blank" href="/a-simple-mvvm-implementation-in-client-side-blazor-8c875c365435"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">客户端Blazor中一个简单的MVVM实现。</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">如前所述，我正致力于将我的生产Silverlight应用程序迁移到一个新的平台上。我的…</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">itnext.io</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ld ko"/></div></div></a></div><p id="a004" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的所有代码都可以在GitHub存储库中找到。本文的起点包含在AricleTwo分支以及4.2版本中。本文末尾的代码是ArticleThree和4.3版本。</p><div class="kl km gp gr kn ko"><a href="https://github.com/lchendricks/BlazorMVVM" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">lchendrick s/blazormvm</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">一个客户端Blazor MVVM实现。通过在…上创建帐户，为lchendricks/BlazorMVVM的开发做出贡献</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">github.com</p></div></div><div class="kx l"><div class="le l kz la lb kx lc ld ko"/></div></div></a></div><h1 id="6b46" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">应用程序的新要求</h1><p id="d464" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">上次我们添加了一些新功能，这些功能是由我们虚构的雇主发送给我们的。这一次我们也将执行当权者发给我们的一些新要求。我们将增加以下功能:</p><ul class=""><li id="14e6" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">向应用程序添加高级帐户设置</li><li id="cd98" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">将新的增强型天气服务集成到应用程序中</li><li id="adc4" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">为基本用户显示当前预测</li><li id="c7a5" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">为高级用户显示增强的每小时预测</li></ul><p id="d935" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在努力保持代码相对干净的同时完成所有这些工作。在我们看来，我们将增加组件，使其更加模块化。在ViewModel中，我们将添加ViewModel子视图，这将有助于我们保持有序。我们还将使用带有依赖注入的IEnumerable集合来帮助我们选择接口的正确实现。</p><h1 id="d263" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在视图中使用组件</h1><p id="ebbd" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我们实际上已经在使用组件了；Blazor中的任何UI，包括页面，都是一个组件。我们现在要创建的组件只是一些UI片段，我们将用标签将它们添加到页面中。对于满足我们要求的第一个新组件，我们将把视图中的表移到一个单独的组件中。</p><p id="6307" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在客户端项目中创建一个新文件夹，并将其命名为Components。在这个文件夹中添加一个新的Razor视图，并将其命名为BasicForecast.razor。从else{}块中的视图中剪切所有内容，从<table>开始到</table>结束，并将其粘贴到新组件中，替换那里的所有默认内容。为了使组件在父组件中使用时工作，我们需要在组件的顶部添加这个using语句</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a6c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组件底部的这个功能块</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="61fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该参数告诉组件，当使用它时，它将接受IFetchDataViewModel的实例，并使该实例在组件内部作为命名对象ViewModel本地可用。一旦完成，我们就可以用ViewModel替换粘贴到组件中的对fetchDataViewModel的三个引用。新组件现在看起来像这样:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2aba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用这个组件，我们返回到视图，在else{}块中输入这一行代码，我们之前在这里剪切了所有的内容。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="71f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这告诉视图在页面上的这个位置插入BasicForecast组件，并将我们的ViewModel的当前实例传入该组件。我们还需要为BlazorMVVM添加一个@using语句。Client.Components文件夹添加到视图中。添加完这些行后，更新后的视图如下所示:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a0d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在启动应用程序，我们可以看到它的工作方式与启动时完全一样。我们现在已经给视图添加了一点合成。</p><h1 id="53f9" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">重构视图模型</h1><p id="0eb3" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我们现在需要对视图模型进行修改。我们需要围绕高级帐户进行一些交互，所以我们需要添加属性和方法。我们也不应该将整个ViewModel传递给页面的子组件，组件应该只获取它需要的东西。就像我们给视图一个子视图一样，我们现在要创建一个子视图模型。</p><p id="7953" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在客户端项目的ViewModels文件夹中，添加一个名为BasicForecastViewModel.cs的新C#类。我们将把子组件所需的属性和方法迁移到这个子ViewModel，并在主ViewModel中添加对它的引用。新的子接口和类现在看起来像这样:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e8f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ViewModel将从构造函数注入中接收这个子对象的实例，因此我们需要将它添加到Startup.cs中。我们返回ConfigureServices()并添加现在将成为我们的第三个条目的内容:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c27c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了它，我们可以将它作为一个新的私有变量添加到我们的视图模型中</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a576" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过新公共属性向视图公开视图模型</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4e09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将该属性添加到视图模型接口</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a046" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并更新我们的构造函数来注入它并赋值。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4b51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的重构还需要做一些清理工作。在RetrieveForecastsAsync()中，我们为_weatherForecasts赋值，现在我们需要将它赋值给子视图模型，如下所示:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="60e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要确保当我们在ViewModel上更改温标时，我们也在子ViewModel中更改温标，如下所示:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ba9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重构完成后，我们的ViewModel接口和类现在看起来像这样</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重构视图模型后，我们现在可以更新视图，将子视图模型传递给子视图。更新if{} else{}块以进行适当的检查并传入正确的参数。这部分代码现在看起来像这样:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f4d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要更新BasicForecast视图，以便它接受BasicForecastViewModel。我们将更新子视图中的函数块，如下所示:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="291f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再一次，如果我们现在启动应用程序，我们将看到预测显示为开始时的样子。我们现在已经重构了我们的视图和视图模型，我们的应用程序仍然工作。</p><h1 id="5c6a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加高级帐户</h1><p id="88a6" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">实际的应用程序会有某种身份提供者来让它知道用户的信息。对于本文，我们将添加另一个切换按钮，让我们在基本和高级之间切换，这样我们就可以专注于MVVM模式。</p><p id="f8ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将实现这个开关，就像我们实现温度显示开关一样。在FetchDataViewModel中，我们将添加另一个私有变量</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e505" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在构造函数中将该变量设置为false</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f61c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加公共切换方法</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ff3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后将该方法放到接口上。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a951" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望切换按钮告诉我们当我们单击它时它将做什么，所以我们将添加一个属性，该属性将成为按钮的文本</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6d5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并把它放到界面上。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="deae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经添加了所有这些，我们可以返回到父视图并添加我们的新按钮</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="afc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们此时运行应用程序，我们将看到我们的按钮，单击它将切换高级状态和按钮标签。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/021abab266e060b363c7a467b38b3ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2xauPRh0a3MGj4BEO8nUFw.gif"/></div></div></figure><h1 id="6917" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">集成增强型气象服务</h1><p id="8aa4" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">对于我们的“增强型”天气服务，我们将调用国家气象局的API Web服务。该文件位于<a class="ae nj" href="https://www.weather.gov/documentation/services-web-api" rel="noopener ugc nofollow" target="_blank">https://www.weather.gov/documentation/services-web-api</a>。为了不让这篇文章太长，我们将简单地检索一个位置的预测。我们将对FetchDataModel进行更改，以从API中检索预测并存储返回的数据。我们还需要一个类来反序列化由weather.gov API返回的JSON。为了获得我们需要的类，我们可以在浏览器中调出将要调用的端点，这样我们就可以看到API返回的原始JSON。我们可以在浏览器中访问https://api.weather.gov/gridpoints/ALY/59,14/forecast的<a class="ae nj" href="https://api.weather.gov/gridpoints/ALY/59,14/forecast" rel="noopener ugc nofollow" target="_blank">来获取原始的JSON。然后，我们可以将JSON复制并粘贴到http://json2csharp.com</a><a class="ae nj" href="http://json2chasrp.com" rel="noopener ugc nofollow" target="_blank">的表单中，并单击Generate按钮。这将生成我们可以在应用程序中使用的类。界面看起来像这样:</a></p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nk"><img src="../Images/5e01ae67c0260a24d3fef51dd4d9aa4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voBHXi6LrVRRgv-hRFvkRA.png"/></div></div></figure><p id="0364" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在共享项目中创建名为WeatherDotGovForecast的新类，并将所有代码粘贴到该类中。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="daeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个类，我们就可以对模型进行必要的修改了。在FetchDataModel中添加一个私有变量来保存我们的新预测</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="affe" class="nq lg iq nm b gy nr ns l nt nu">private WeatherDotGovForecast _realWeatherForecast;</span></pre><p id="2a96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并添加一个公共属性以允许访问数据</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="fb33" class="nq lg iq nm b gy nr ns l nt nu">public WeatherDotGovForecast RealWeatherForecast { get =&gt; _realWeatherForecast; private set =&gt; _realWeatherForecast = value; }</span></pre><p id="c021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将把它放到界面上。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="705b" class="nq lg iq nm b gy nr ns l nt nu">WeatherDotGovForecast RealWeatherForecast { get; }</span></pre><p id="56c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些，我们可以向我们的模型添加一个新方法(它已经将我们选择的预测位置作为呼叫的一部分)</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="649e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们将新方法放到接口上</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="c087" class="nq lg iq nm b gy nr ns l nt nu">Task RetrieveRealForecastAsync();</span></pre><p id="bd6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以给新的天气服务打电话了。此时，我们模型的接口和类将如下所示:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="3b1e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为高级会员提供增强的预测</h1><p id="50ca" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">为了向高级会员提供增强的预测，我们将进入FetchDataViewModel并对RetrieveForecastsAsync()进行一些更新。首先，让我们抓住填充newForecasts的foreach循环，并使用Visual Studio快速操作将其提取到一个单独的方法中。我们将调用PopulateStandardForecastData()方法。我们还将把对RetrieveForecastsAsync()的调用移到新方法中，这将需要使新方法异步，并使用await关键字来调用它。</p><p id="c638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以创建一个名为PopulateEnchancedForecastData()的新私有方法，并对其进行编码，使其具有相同的行为，只是从增强的预测中提取数据。该方法将遍历来自新服务的列表<period>，并使用该数据来填充我们的IWeatherForecast[]。它还会将华氏温度转换为摄氏温度，以保持我们的用户体验一致。新方法的代码如下:</period></p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是用if-then块更新RetrieveForecastsAsync()，以调用基于高级成员资格的标准或增强预测。当所有这些更改都就绪后，更新后的方法如下所示:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2017" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以访问我们的原始预测以及我们添加到系统中的增强预测。为了用基本会员或高级会员的正确预测来更新我们的显示，我们将在每次单击按钮更改会员状态时调用RetrieveForecastsAsync()。这将要求我们将一些同步调用改为异步调用。首先，我们将TogglePremiumMembership()更改为async，并添加对的调用，以检索该方法的正确数据</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="5a99" class="nq lg iq nm b gy nr ns l nt nu">public async Task TogglePremiumMembership()<br/>{<br/>   _isPremiumMember = !_isPremiumMember;<br/>   await RetrieveForecastsAsync();<br/>}</span></pre><p id="1c0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并更改该方法的接口以返回任务。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="2bdc" class="nq lg iq nm b gy nr ns l nt nu">Task TogglePremiumMembership();</span></pre><p id="c0cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们可以转到FetchDataView并更改高级切换按钮的onclick方法，以进行异步调用。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="7b4e" class="nq lg iq nm b gy nr ns l nt nu">onclick=@(async () =&gt; await fetchDataViewModel.TogglePremiumMembership())</span></pre><p id="3318" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些变化，我们可以再次启动我们的应用程序，并看到我们增强的预测。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nv"><img src="../Images/813c73ce223ac6e2aa3f08369e214782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Srglohy8m4Qnvbyti0qMIw.gif"/></div></div></figure><p id="58f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，增强预测每天有两个条目。查看期间数据，我们可以看到每天都有一个白天预报和一个夜间预报。让我们回到视图模型，将增强的预测摘要代码更改为:</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="4987" class="nq lg iq nm b gy nr ns l nt nu">newForecast.Summary = forecast.name + " - " + forecast.shortForecast;</span></pre><p id="df99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们再次启动该应用程序，将会为我们的高级会员提供更多信息。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nw"><img src="../Images/2321968906459e82d8b89846fbb54664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnLanTzYOlAP00SR6T9Yxg.png"/></div></div></figure><h1 id="bef0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">高级用户的每小时预测</h1><p id="697d" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">国家气象局对每小时的天气预报使用与每日天气预报相同的JSON格式。这将允许FetchDataModel只需几行新代码就可以检索和存储它。我们将添加一个私有变量来保存每小时的预测</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="e374" class="nq lg iq nm b gy nr ns l nt nu">private WeatherDotGovForecast _hourlyWeatherForecast;</span></pre><p id="4404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过公共属性暴露它</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="00cc" class="nq lg iq nm b gy nr ns l nt nu">public WeatherDotGovForecast HourlyWeatherForecast { get =&gt; _hourlyWeatherForecast; private set =&gt; _hourlyWeatherForecast = value; }</span></pre><p id="ff9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及调用和存储数据的方法。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="5e80" class="nq lg iq nm b gy nr ns l nt nu">public async Task RetrieveHourlyForecastAsync()</span><span id="0706" class="nq lg iq nm b gy nx ns l nt nu">{</span><span id="9ae5" class="nq lg iq nm b gy nx ns l nt nu">_hourlyWeatherForecast = await _http.GetJsonAsync&lt;WeatherDotGovForecast&gt;("https://api.weather.gov/gridpoints/ALY/59,14/forecast/hourly");</span><span id="c771" class="nq lg iq nm b gy nx ns l nt nu">}</span></pre><p id="da62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们需要将这两个成员都拉到接口上。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="3c90" class="nq lg iq nm b gy nr ns l nt nu">Task RetrieveHourlyForecastAsync();<br/>WeatherDotGovForecast HourlyWeatherForecast { get; }</span></pre><p id="851a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些更改，ViewModel现在可以通过模型完全访问每小时的预测。接口和类现在看起来像这样:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="16fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在不太长时间的情况下总结这一功能，我们将更新增强的预测，以便如果高级会员单击预测，我们将显示当天的每小时预测。如果该成员再次点击预测，它将切换回每日预测。</p><p id="a660" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了帮助用户选择每日预测，我们将在预测表中启用悬停突出显示。为此，我们只需更新BasicForecast视图的表定义。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="2e31" class="nq lg iq nm b gy nr ns l nt nu">&lt;table class="table table-hover"&gt;</span></pre><h1 id="b94c" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">让子视图模型负责代理</h1><p id="a716" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">接下来，我们将连接BasicForecast视图和BasicForecastViewModel，以便在用户单击预测表中的某一行时向父视图模型发出警报。我们将通过在BasicForecastViewModel中创建一个委托并让父视图模型为该委托分配一个方法来实现这一点。如果你不熟悉使用委托，它们基本上是一个变量，包含一个指向方法的指针。当您调用委托时，您调用的是已经分配给它的方法。这是一种让子对象向父对象传递数据并在父对象中启动操作的有用方法。我们需要做的第一件事是定义我们的代表。在接口和类之外，我们将在命名空间中声明下面的委托。请注意，该委托返回了一个任务，因为我们将再次进行异步调用。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="240b" class="nq lg iq nm b gy nr ns l nt nu">public delegate Task ToggleDelegate(DateTime selectedDay);</span></pre><p id="cbbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个定义，我们将把这个委托实现为BasicForecastViewModel类的公共属性</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="42d3" class="nq lg iq nm b gy nr ns l nt nu">public ToggleDelegate ToggleForecastDelegate { get; set; }</span></pre><p id="deb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们会将该属性拖到接口上。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="1815" class="nq lg iq nm b gy nr ns l nt nu">ToggleDelegate ToggleForecastDelegate { get; set; }</span></pre><p id="11e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将在类中声明一个调用这个委托的方法</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="aed3" class="nq lg iq nm b gy nr ns l nt nu">public async Task ToggleForecast(DateTime selectedDate)<br/>{<br/>   await ToggleForecastDelegate(selectedDate);<br/>}</span></pre><p id="4a67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将该方法放到接口上。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="30e1" class="nq lg iq nm b gy nr ns l nt nu">Task ToggleForecast(DateTime selectedDate);</span></pre><p id="9d83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的方法中，我们不检查委托是否为空，因为一旦在父ViewModel的构造函数中创建了委托，我们就会给它分配一个方法。有了这些变化，我们的委托、接口和类看起来像这样</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="21ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了调用我们的新委托，我们将为子视图中的数据表中的行添加一个onclick事件。该事件将从选定的行传回日期时间。对行定义的这一更改将对我们新的ViewModel方法进行异步调用。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="00a9" class="nq lg iq nm b gy nr ns l nt nu">&lt;tr onclick="@(async () =&gt; await ViewModel.ToggleForecast(forecast.Date))"&gt;</span></pre><p id="0ae3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了要调用的委托集，并向它传递了所需的数据。最后一步是给委托分配一个方法。我们将进入FetchDataViewModel并创建一个带有匹配签名的异步方法。为了测试一切是否按预期运行，我们将从一个控制台开始。WriteLine()来看看事情是否正常。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="dbc0" class="nq lg iq nm b gy nr ns l nt nu">private async Task ToggleForecast(DateTime selectedDate)<br/>{<br/>   if (_isPremiumMember)<br/>   {<br/>      Console.WriteLine(selectedDate.ToLongDateString());<br/>   }<br/>}</span></pre><p id="82ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们准备好了，我们就可以进入构造函数并添加一行代码来将新方法分配给子视图模型中的委托。</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="987d" class="nq lg iq nm b gy nr ns l nt nu">basicForecastViewModel.ToggleForecastDelegate = ToggleForecast;</span></pre><p id="de20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在此时运行应用程序，并按F12打开调试控制台，我们将看到，当我们将鼠标悬停在forecase datatable行上时，这些行会突出显示，当我们单击premium版本的forecast(仅premium版本)时，所选的日期时间会打印到控制台。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ny"><img src="../Images/724a2be46e6a798019a7c1b40a608dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zm9XT918STJrPerFw14ZNg.png"/></div></div></figure><h1 id="f465" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">总结每小时的预报</h1><p id="37f0" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我们现在需要更新我们的ParentViewModel，以采取适当的措施在premium成员的每日和每小时预测之间切换。我们将再次需要跟踪我们所处的状态，所以我们将向我们的视图模型添加另一个私有bool</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="1e40" class="nq lg iq nm b gy nr ns l nt nu">private bool _isDailyForecast;</span></pre><p id="c1b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并在构造函数中将其设置为true</p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="9e76" class="nq lg iq nm b gy nr ns l nt nu">_isDailyForecast = true;</span></pre><p id="34f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要PopulateEnhancedForecastData()方法来获取每日或每小时的预测，因此我们将对该方法进行一些修改。首先，我们必须放入一个条件块，以便我们调用API上的正确端点来获得我们想要的预测。接下来，我们必须有条件地填充我们的摘要字段，因为在数据的每小时预测中，forecast.name为空。这是我们重新设计的方法:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f975" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以通过在ToggleForecast()中完成所需的更改来完成我们的视图模型更新。我们将更换控制台。WriteLine()语句，其中几行代码切换_isDailyForecast的值，创建列表<iweatherforecast>，并使用来自API的正确预测填充它。最后，如果预测是每小时一次，我们将过滤列表中与我们选择的日期匹配的条目，否则获取所有预测。过滤需要引用系统。因此还需要添加一个using语句。这是我们完成所有工作所需的代码:</iweatherforecast></p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ea09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们今天最后的细节是让子视图模型格式化日期，以一种对我们的高级用户有意义的方式显示日期和时间。我们将最后一次进入BasicForecast，并将显示日期的<td>元素更改为现在使用的格式字符串:</td></p><pre class="mw mx my mz gt nl nm nn no aw np bi"><span id="f0d7" class="nq lg iq nm b gy nr ns l nt nu">&lt;td&gt;@forecast.Date.ToString("MM/dd/yyyy h:mm tt")&lt;/td&gt;</span></pre><p id="a5bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个最终的变化，我们可以启动我们的应用程序，并作为高级会员从每天预测改为每小时预测。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nz"><img src="../Images/0207cc752c06929c9d87a976acd04251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BU0i9y_Ot5QVU0NthyzEcQ.gif"/></div></div></figure><h1 id="ad61" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">包扎</h1><p id="91c3" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">今天，我们在示例项目中添加了更多的功能，并扩展了我们在前两篇文章中构建的MVVM架构。预测页面中的对象关系现在如下所示:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oa"><img src="../Images/8298a83f36ae08d214171b17b1a70317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O53pzUE1c8OCoi0kmVHsOA.png"/></div></div></figure><p id="4494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Out View和ViewModel都有子对象，但是我们仍然保持系统的清晰分离。除了视图模型之外，没有对象知道我们的模型和它调用的服务，我们的子视图甚至不知道它从哪个子视图模型接收数据。由于父视图模型负责协调页面上的一切，它可以通过视图中的参数传递其子视图模型。我们还能够让子视图中的用户操作使用委托调用ViewModel中的方法，同时再次保持子视图不知道ViewModel。</p><p id="454d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以做更多的事情来改进我们的应用程序。在国家气象局的API中，有更多我们没有展示给用户的数据。我们可以定制用户体验，并通过一些额外的重构使我们的应用程序架构更好。本系列的第四篇文章可以通过下面的链接阅读:</p><div class="kl km gp gr kn ko"><a rel="noopener  ugc nofollow" target="_blank" href="/refactoring-the-simple-blazor-mvvm-client-adventures-in-dependency-injection-e9866d194ee9"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">重构简单的Blazor MVVM客户端:依赖注入的冒险</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">本文是关于在ASP.Net客户端实现模型视图视图模型的系列文章的第四篇…</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">itnext.io</p></div></div><div class="kx l"><div class="ob l kz la lb kx lc ld ko"/></div></div></a></div></div></div>    
</body>
</html>