<html>
<head>
<title>Indexing encrypted database field for searching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">索引加密的数据库字段以进行搜索</h1>
<blockquote>原文：<a href="https://itnext.io/indexing-encrypted-database-field-for-searching-e50e7bcfbd80?source=collection_archive---------2-----------------------#2020-02-08">https://itnext.io/indexing-encrypted-database-field-for-searching-e50e7bcfbd80?source=collection_archive---------2-----------------------#2020-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f7ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如今，个人数据安全也是一个重要问题。每年都有十几家大大小小的公司公开用户数据。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/c9d3455fcc30429e1c5778b9cae269f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ho6CjGVBYI2qDzeWwZjkCw.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:percona.com</figcaption></figure><p id="0790" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对数据库中的数据进行加密可以最大限度地降低数据被盗时信息泄露的风险，但却失去了数据库的重要特性——搜索和组织。这里有一个容易理解的例子，我用同样的<em class="lr">秘密</em>用AES加密同样的文本AAAA 10次。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6d0b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">加密10次，我们会得到10个不同的结果。你可以往回跑几十次，看结果还是不一样。如果要搜索，不可能找到与加密字符串相似的字符串进行搜索。因此，让我们来看看如何在一堆加密数据中进行索引和搜索。</p><h1 id="6a5f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">一些你应该提前注意的事情</h1><p id="30d9" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated"><strong class="kx iu">首先保护你的应用/服务器<br/> </strong>加密的数据库会保护你的数据，这是事实。但前提是有人拥有你的数据库并且无法解密。如果攻击者控制了你的web/API服务器，那么一切都完了。因此，加密数据库并不意味着你可以忽略应用程序的安全性。记住不要将加密密钥留在数据库中。将数据库和web / api应用程序放在两个不同的地方，以最小化风险。</p><p id="fb45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">信息泄露<br/> </strong>如果要搜索，需要对数据进行索引。但是索引将揭示关于数据的信息，不是真正的数据本身，而是通常的元数据。例如，允许对数据进行排序的索引可以揭示数据的顺序。用于搜索的索引将揭示关于可能相关或相似的文本的信息。这是一个不可避免的副作用，问题是它是哪个级别或者它取决于你的数据是如何分布的或者有多重要。</p><p id="152e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">根据安全级别的不同，你也可以用数据库将它索引到其他地方，甚至可以保存在内存中，只在开始运行应用程序时构建。</p><h1 id="1be4" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">确定性加密</h1><p id="d789" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">每个人可能会想到的第一个方法是如何获得每次加密的相同结果。又称<a class="ae ki" href="https://en.wikipedia.org/wiki/Deterministic_encryption" rel="noopener ugc nofollow" target="_blank">确定性加密</a>。这样，你可以很容易地创建一个加密的字符串在DB中搜索，当然，只搜索精确的结果，而不是像类型的<strong class="kx iu">。以下是使用AES实现这一点的两种方法的示例。</strong></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="512a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们常用的算法(DES，AES，Blowfish)都是cypher块。这意味着要加密的文本将被分成块并逐个加密。例如，AES的块大小为128位。这意味着AAAAAAAAAAAAAAAAAABBBBaaaabbbb段将被分成2个块aaaaaaaaaaaaaaaaaaaaaaaa和BBBB进行加密。这就是该算法如何使用与上述示例中相同的文本获得相同的结果。</p><p id="9d1d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">AES有不同的工作模式。最后一种模式称为ECB(电子码本)模式。为了用与第一个例子相同的文本得到不同的结果，AES使用前一个块的结果与后一个块(XOR)组合，然后对其进行加密，等等。</p><p id="10ca" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于第一个块，由于没有前一个块，我们选择一个名为IV(初始化向量)的随机密钥。每次加密，我们选择另一个IV，所以结果是随机的。这种模式称为CBC(密码块链接)模式。就像上面的例子，我使用的两种方法是使用ECB模式和选择固定的IV，而不是改变每个加密。</p><p id="bcae" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如上所述，您可以看到，使用这种类型的加密，每个块总是被加密成相同的结果。这里有一个例子:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6b13" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你可能意识到了，ECB模式下，AAAAAAAAAAAAAAAAAA总是加密到cXraKOjg / jsIVEuHTNcaz，BBBBBBBBBBBBBBBB总是加密到hYSoRAWWIqJHFkMsvlpVg。静态IV的CBC模式更好，因为后续模块的结果取决于前一模块，但第一模块将保持不变。</p><p id="1806" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果加密信息是用户可以输入的信息(通过网络/移动应用程序，API)，那么任何人都可以很容易地建立一个密码本来解码你所有的加密数据。而不需要加密密钥。这种类型的攻击被称为<a class="ae ki" href="https://en.wikipedia.org/wiki/Chosen-plaintext_attack" rel="noopener ugc nofollow" target="_blank">选择明文攻击</a>，上面的加密算法不能保护你的数据。所以这不一定是一个好的使用方式。</p><h1 id="e6c2" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">使用盲索引</h1><p id="5de3" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">当涉及到创建一个值，该值对应于每次都产生相同结果的一段数据时，您首先应该想到的不是确定性加密而是哈希。我们将创建一个索引，通过散列数据并将其保存在其他地方(另一列)来进行搜索。这叫做<a class="ae ki" href="https://www.sitepoint.com/how-to-search-on-securely-encrypted-database-fields/#implementingliteralsearchofencrypteddata" rel="noopener ugc nofollow" target="_blank">盲标引</a>。</p><p id="bf08" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当然，不可能使用MD5或SHA-1，因为任何人都可以很容易地创建一个查找表来获取原始数据。在一个简单的例子中，添加HMAC就足够了，所以您需要密钥来生成正确的哈希以进行搜索。这是HMAC-SHA-256法案的一个例子。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2db0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们仍然有带有随机结果的加密数据，并且仍然有一个要搜索的索引。如果数据更重要，可以使用更难(但更慢)的哈希算法，比如PBKDF2、bcrypt或Argon2。不要将加密密钥保存在数据库中，而必须保存在其他地方。</p><p id="d03f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">很容易看出，这种方式也会泄露信息，因为同样的数据，索引也会完全相同。尤其是如果你的数据只有几个值(布尔值或枚举类型)，那么这是相当严重的。</p><p id="20f8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">具有小输入域的字段</p><p id="e9ba" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这种布尔或枚举数据类型的索引不是很安全，但是如果数据很重要，我们仍然必须加密。</p><p id="0db6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一般来说，数据的价值太小，那么你可以以某种方式增加数字，使它看起来更随机。最简单的方法是在哈希之前将每个值转换为不同的值。例如，一个布尔数据类型有两个值<code class="fe mr ms mt mu b">true</code>和<code class="fe mr ms mt mu b">false</code>，它可以将<code class="fe mr ms mt mu b">true</code>转换为字符串<code class="fe mr ms mt mu b">ture</code>、<code class="fe mr ms mt mu b">ture</code>、<code class="fe mr ms mt mu b">ture</code>中的一个……在搜索时，做同样的事情，查询所有可能的散列结果。</p><p id="f114" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">创建更多值的另一种方法是将该字段与另一个包含更多随机数据值的字段相结合。这被称为<a class="ae ki" href="https://paragonie.com/blog/2019/01/ciphersweet-searchable-encryption-doesn-t-have-be-bitter#compound-blind-indexes" rel="noopener ugc nofollow" target="_blank">复合盲指数</a>。当然，可搜索性会大大降低，因为你现在只能用1个其他字段进行搜索。所以最好是结合我们要搜索的相关领域。</p><p id="e5a2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，我有t_virus_infected列类型enum，有两个值yes和no。例如，我将把它与country列结合起来。然后我可以搜索某个国家感染过t病毒的人。但当然，并不总是能结合这样的便利。</p><h1 id="a841" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">引入一些噪声</h1><p id="f9f0" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">在价值不大的情况下，可以按照上面的方法。如果您有更多的值，但仍然有许多重复项，那么您可以通过在保存之前转换索引(就像转换数据一样)来添加一点噪声，从而降低一点危险级别。开)。不是将整个散列保存为一个索引，而是只保存一部分，可能是前几十个字符，或者将每个部分的几个字符放在不同的位置，然后连接在一起。例如，有两个不同的字符串被散列成:</p><pre class="kk kl km kn gt mv mu mw mx aw my bi"><span id="8602" class="mz lv it mu b gy na nb l nc nd">bb4367f35e06e4da1684f089442ecc93e80a66160894d4149f60aee1b8606870<br/>bb4367f35e06e4da1684f089442ecc931f6d20f1bb3650293402f4926b536741</span></pre><p id="aa71" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">不是将整个散列保存为索引，而是获得前32个字符。那么这两个字符串将具有相同的索引bb 4367 f 35 e 06 E4 da 1684 f 089442 ECC 93，即使它们彼此不相关。当然这样做会有假阳性的情况，所以你可以从查询结果中过滤。但是如果假阳性太多，这个指标就没有太大意义了。所以你得计算让这个指数合适。选择越短的索引字符串，重叠的百分比越高，但太长是没有用的，因为几乎没有人有相同的。这里的可以参考合适的计算<a class="ae ki" href="https://ciphersweet.paragonie.com/security#blind-index-information-leaks" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4e90" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过上面的计算，索引中的每个值对于每个字符串都不再是唯一的，因此不可能从相同的索引值得出数据相同的结论。如果你想了解更多，这种类型的数据结构被称为<a class="ae ki" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank">布鲁姆过滤器</a>。</p><h1 id="3a53" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">模糊搜索</h1><p id="d6fe" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">有了前面的方式，你也发现我只搜索了精确结果，LIKE类型搜索完全没有。然而，在创建索引之前，我们仍然可以通过将数据转换成另一种模糊可搜索的形式来进行模糊搜索。搜索时，将其转换为与要搜索的索引相同的格式。</p><p id="609e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你真的想搜索类似的查询，你可以尝试用<a class="ae ki" href="https://scoutapm.com/blog/how-to-make-text-searches-in-postgresql-faster-with-trigram-similarity" rel="noopener ugc nofollow" target="_blank"> n-grams </a>创建一个巨型索引。从实现和存储的角度来看，这将是相当复杂的。当然，也要考虑指数会透露的信息。</p><p id="7a08" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您想以上述方式加密和索引数据库，有几个库可供您使用。</p><ul class=""><li id="cfae" class="ne nf it kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated">PHP:<a class="ae ki" href="https://packagist.org/packages/paragonie/ciphersweet" rel="noopener ugc nofollow" target="_blank">paragonie/cipher sweet</a></li><li id="23bd" class="ne nf it kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">拉勒维尔:<a class="ae ki" href="https://packagist.org/packages/paragonie/eloquent-ciphersweet" rel="noopener ugc nofollow" target="_blank">典范/雄辩的密码甜</a></li><li id="bfc7" class="ne nf it kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">NodeJS: <a class="ae ki" href="https://npm.im/ciphersweet-js" rel="noopener ugc nofollow" target="_blank"> ciphersweet-js </a></li><li id="2442" class="ne nf it kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">rails:<a class="ae ki" href="https://github.com/attr-encrypted/attr_encrypted" rel="noopener ugc nofollow" target="_blank">attr _ encrypted</a>+<a class="ae ki" href="https://github.com/ankane/blind_index" rel="noopener ugc nofollow" target="_blank">blind _ index</a></li></ul></div></div>    
</body>
</html>