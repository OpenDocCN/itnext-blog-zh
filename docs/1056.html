<html>
<head>
<title>Scaling Selenium test execution with Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes扩展Selenium测试执行</h1>
<blockquote>原文：<a href="https://itnext.io/scaling-selenium-test-execution-with-kubernetes-c79bc53979f5?source=collection_archive---------1-----------------------#2018-07-13">https://itnext.io/scaling-selenium-test-execution-with-kubernetes-c79bc53979f5?source=collection_archive---------1-----------------------#2018-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6f07dba0c641002dbc1161c97231944e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qM0zg4epgkiUQViN0635A.jpeg"/></div></div></figure><p id="f260" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个系列中，我们将探索使用Docker容器和Kubernetes为Selenium构建一个可伸缩的执行框架。</p><h2 id="e788" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">超大规模测试执行</h2><p id="af1e" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Docker和Kubernetes编排平台的容器化已经席卷了计算基础设施世界，并对我们今天设计和构建软件的方式产生了深远的影响。Selenium测试是一种候选工作负载，可以受益于现代超大规模基础架构提供的大规模并行性。</p><p id="f627" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将使用我们在用MSTest V2 系列的<a class="ae lu" href="https://medium.com/@joegroner/selenium-ui-testing-with-mstest-v2-1db414bbba28" rel="noopener"> Selenium UI测试中构建的框架，在Docker容器中执行Selenium测试。而用于测试的示例代码是基于C#构建的。NET Core，这种方法可以用于任何可以利用RemoteWebDriver的Selenium测试套件。</a></p><h2 id="6a6f" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">在Linux中用。网络核心</h2><p id="d53d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">首先，让我们从Github上的<a class="ae lu" href="https://github.com/joegroner/jg-testframework" rel="noopener ugc nofollow" target="_blank"> jg-testframework repo </a>中克隆框架和样本。在Linux环境中，确保您可以在本地构建和运行测试，并获得通过的结果。你要确保你有<a class="ae lu" href="https://www.microsoft.com/net/download/dotnet-core/" rel="noopener ugc nofollow" target="_blank">。NET Core 2.1 SDK </a>安装运行(我的测试一直针对2.1.301)。</p><p id="a376" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在测试中/JG。Demo.CoreTests子文件夹，打开default.runsettings文件，确保WebDriver参数设置为“chrome”:</p><p id="338f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lv lw lx ly b">&lt;Parameter name=”WebDriver” value=”chrome” /&gt;</code></p><p id="5b4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您可以运行测试，看看您是否获得了通过测试的结果:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="a389" class="kw kx iq ly b gy mh mi l mj mk">cd test/JG.Demo.CoreTests<br/>dotnet build<br/>dotnet test --no-build --settings default.runsettings</span></pre><p id="8eeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们也使用RemoteWebDriver和手动启动的chromedriver进行一次健全性检查。确保在default.runsettings中设置了以下值:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="eafd" class="kw kx iq ly b gy mh mi l mj mk">&lt;Parameter name=”WebDriver” value=”remotechrome” /&gt;<br/>&lt;Parameter name="SeleniumHost" value="<a class="ae lu" href="http://localhost:4444/" rel="noopener ugc nofollow" target="_blank">http://localhost:4444/</a>" /&gt;</span></pre><p id="8627" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在后台启动chromedriver的一个实例，并重复测试执行:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="06bc" class="kw kx iq ly b gy mh mi l mj mk">./bin/Debug/netcoreapp2.1/chromedriver --port=4444 &gt;/dev/null 2&gt;&amp;1 &amp;<br/>dotnet test --no-build --settings default.runsettings</span></pre><p id="a9b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ml">旁白:如果你打算继续下去，如果你想重用端口4444，你可能想终止后台进程。</em></p><h2 id="e6fc" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">Docker入门</h2><p id="cef7" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Selenium项目维护<a class="ae lu" href="https://hub.docker.com/r/selenium/" rel="noopener ugc nofollow" target="_blank">一组Docker图像</a>，我们将使用它们在Docker中执行测试。</p><p id="be7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们使用独立的Chrome镜像进行一个简单的测试。首先，我们需要修改SeleniumHost参数以包含一个路径(我们稍后将讨论原因):</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="6627" class="kw kx iq ly b gy mh mi l mj mk">&lt;Parameter name="SeleniumHost" value="<a class="ae lu" href="http://localhost:4444/wd/hub" rel="noopener ugc nofollow" target="_blank">http://localhost:4444/wd/hub</a>" /&gt;</span></pre><p id="aee8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将旋转绑定到端口4444的容器，并再次运行我们的测试:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="8d9c" class="kw kx iq ly b gy mh mi l mj mk">docker run -d -p 4444:4444 -v /dev/shm:/dev/shm selenium/standalone-chrome<br/>dotnet test --no-build --settings default.runsettings</span></pre><p id="def3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在<a class="ae lu" href="https://github.com/SeleniumHQ/docker-selenium" rel="noopener ugc nofollow" target="_blank"> docker-selenium repo </a>上找到关于Selenium映像的其他信息，包括对/dev/shm和内存的简要讨论。</p><p id="4c17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ml">旁白:如果您打算继续，如果您想重用端口4444，您可能需要停止容器。</em></p><h2 id="5f3b" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">使用Selenium网格进行缩放</h2><p id="874c" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Selenium项目创建了网格来帮助解决可伸缩性问题。网格抽象了对(潜在的)异构驱动程序/浏览器组合的访问，集中了基础设施，并为消费者提供了测试云。</p><p id="e972" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个网格由<a class="ae lu" href="https://www.seleniumhq.org/docs/07_selenium_grid.jsp#how-selenium-grid-works-with-a-hub-and-nodes" rel="noopener ugc nofollow" target="_blank">集线器和节点元素</a>组成。节点是驱动程序/浏览器对的抽象，例如Chrome节点或Firefox节点，集线器充当集中器。节点在启动时向集线器注册。然后，客户端提交启动会话的请求，并将所需的能力传递给集线器，集线器检查该请求，并将测试会话路由到适当的节点以供执行。随后的通信都继续流经集线器，从而简化了客户端配置。</p><p id="3eb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了通过网格执行测试，我们将/wd/hub路径添加到Selenium主机URL中。因此，我们可以推断，我们在前面的例子中使用的Docker映像既充当了hub又充当了node，实际上它是一个独立的单节点网格。</p><p id="3250" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ml">先不说:为什么要多走一条路？hub还提供了其他端点，包括一个位于/grid/console的控制台，它对于管理网格非常有用。</em></p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/eb56230f56401fd6455b03125167049c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9ozGG2pdYmU5MXTTGKMYA.png"/></div></div></figure><h2 id="e468" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">在Docker中建立Selenium网格</h2><p id="09b5" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">让我们看看Docker Hub上提供的其他一些图片，这些图片展示了Selenium网格Hub和node角色，特别是selenium/hub和selenium/node-chrome。我们将借用docker-selenium文档来使用Docker Compose来简化网格:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b845" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，通过简单地从创建docker-compose.yaml的目录执行<code class="fe lv lw lx ly b">docker-compose up -d</code>,我们已经启动了两个容器:一个hub和一个带有Chrome的节点。我们可以重复我们的测试，它们应该会再次成功运行。</p><h2 id="db1f" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">水平缩放Selenium网格节点</h2><p id="8f7d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Docker使扩展变得微不足道(假设您有足够的计算资源)，所以让我们看看如果我们用第二个Chrome节点扩展并再次运行测试会发生什么。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="b090" class="kw kx iq ly b gy mh mi l mj mk">docker-compose up -d --scale chrome=2</span></pre><p id="aef4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我加了一些线。Sleep()调用我们的演示测试方法来使扩展的效果更加明显，但是当我们添加额外的测试并继续向外扩展时，回报自然会变得更加明显。</p><h2 id="6e4c" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">下一个</h2><p id="8eb4" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在我们的下一期文章中，我们将与VSTS一起处理构建和发布，以展示我们如何将Docker中的Selenium Grid集成到典型的CI/CD流程中，然后我们将把执行推送到云中的Kubernetes。</p><p id="01d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从<a class="ae lu" href="https://github.com/joegroner/jg-testframework/tree/docker-part1" rel="noopener ugc nofollow" target="_blank"> Github repo </a>下载代码。</p></div></div>    
</body>
</html>