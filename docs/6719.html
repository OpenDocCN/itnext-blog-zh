<html>
<head>
<title>Increase Kubernetes Network Security with Cilium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用纤毛增加Kubernetes网络安全性</h1>
<blockquote>原文：<a href="https://itnext.io/increase-kubernetes-network-security-with-cilium-ba6af15c8f5f?source=collection_archive---------1-----------------------#2022-02-07">https://itnext.io/increase-kubernetes-network-security-with-cilium-ba6af15c8f5f?source=collection_archive---------1-----------------------#2022-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a425b2e67733aee7983e46a41cdc2524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Su_F3nvXFYHwFov"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jd" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="dbaf" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">微服务的承诺</h2></div><p id="4ee0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用微服务架构有两个主要好处。</p><ol class=""><li id="756c" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">使分布式团队能够在分布式系统的各个部分独立工作，从而使<a class="ae jd" href="https://en.wikipedia.org/wiki/Conway%27s_law" rel="noopener ugc nofollow" target="_blank">康威定律</a>对我们有利。</li><li id="9ae1" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">通过<strong class="kx jh">将越来越多的横切关注点从应用程序代码转移到底层基础设施，降低分布式系统的复杂性。</strong></li></ol><p id="3aca" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在一个面向服务器端工作负载的微服务架构成为主流模式、越来越多的计算在Kubernetes上运行的世界里，我们有机会真正实现微服务的技术和组织承诺。</p><p id="e416" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文将展示如何使用Cilium解决授权问题，并将其从应用程序代码推向底层平台。</p><p id="633d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您是使用Kubernetes的开发人员、Kubernetes管理员或者只是想了解现代的云原生模式，您会发现这篇文章很有帮助。</p><h2 id="6376" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">纤毛是什么</h2><p id="94b0" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">Cilium是一款开源软件，用于提供、保护和观察容器工作负载之间的网络连接——云原生，由革命性的内核技术eBPF提供支持。</p><p id="7b92" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">来源:<a class="ae jd" href="https://cilium.io/" rel="noopener ugc nofollow" target="_blank">https://cilium.io/</a></p><blockquote class="nd ne nf"><p id="e30d" class="kv kw ng kx b ky kz kh la lb lc kk ld nh lf lg lh ni lj lk ll nj ln lo lp lq ij bi translated"><em class="jg">如果你想自己尝试一下Cilium，可以去看看他们的优秀</em> <a class="ae jd" href="https://play.instruqt.com/isovalent/tracks/cilium-getting-started" rel="noopener ugc nofollow" target="_blank"> <em class="jg">互动教程</em> </a></p></blockquote><h2 id="25c9" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">什么是eBPF</h2><blockquote class="nd ne nf"><p id="1b29" class="kv kw ng kx b ky kz kh la lb lc kk ld nh lf lg lh ni lj lk ll nj ln lo lp lq ij bi translated"><em class="jg"> eBPF是一项革命性的技术，起源于Linux内核，可以在操作系统内核中运行沙盒程序。它用于安全有效地扩展内核的功能，而无需更改内核源代码或加载内核模块。要了解更多关于eBPF的信息，请访问</em><a class="ae jd" href="https://ebpf.io/what-is-ebpf/" rel="noopener ugc nofollow" target="_blank"><em class="jg">eBPF简介</em> </a></p></blockquote><p id="27e4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个<a class="ae jd" href="https://www.youtube.com/watch?v=5t7-HM2jlTM&amp;ab_channel=ContainerSolutions" rel="noopener ugc nofollow" target="_blank">很棒的视频</a>，Liz Rice详细解释了eBPF。</p><p id="f1db" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下图显示了eBPF是如何在高层次上工作的</p><figure class="nl nm nn no gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/3e0c02ddf18be38eac5886d48c2584e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRxV97vUopsbJyImdRTjNw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">来源:<a class="ae jd" href="https://ebpf.io/what-is-ebpf/" rel="noopener ugc nofollow" target="_blank">https://ebpf.io/what-is-ebpf/</a></figcaption></figure><h2 id="d8e6" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">用例:粒度授权控制</h2><p id="1c8f" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">让我们设想一个场景，其中您的REST API由多个端点组成，公开与机票预订相关的资源。这个REST API被部署到一个托管的K8s集群，比如说GKE (Google Kubernetes引擎)，并且经常被集群中运行的其他微服务以及一些外部服务访问。</p><p id="59fb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从安全的角度来看，你需要遵循零信任安全和最小特权的T2原则，为了实现这一点，你需要严格控制和验证对你的API的访问，只暴露那些调用服务所必需的端点。</p><p id="3d66" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Kubernetes网络政策可以带我们走到一半。</p><h1 id="aa38" class="np mg jg bd mh nq nr ns mk nt nu nv mn km nw kn mq kp nx kq mt ks ny kt mw nz bi translated">网络策略</h1><p id="3a60" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">Kubernetes <a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank">网络策略</a>为集群中运行的pod定义网络流量规则。</p><blockquote class="nd ne nf"><p id="a323" class="kv kw ng kx b ky kz kh la lb lc kk ld nh lf lg lh ni lj lk ll nj ln lo lp lq ij bi translated"><em class="jg">我们将重点关注</em> <a class="ae jd" href="https://cilium.io/" rel="noopener ugc nofollow" target="_blank"> <em class="jg">纤毛</em> </a> <em class="jg">并展示它如何提供增强的和更强大的策略</em></p></blockquote><p id="a093" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下图显示了有关网络策略的更多信息。</p><figure class="nl nm nn no gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/6b7bc7d1744a4abc2d8511a342a53ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ve6h2uS57QnwIva-5-IFTQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">来源:作者</figcaption></figure><p id="cc02" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，有一个问题。我们的航班预订服务公开了多个REST端点，而Kubernetes网络策略仅适用于IP:PORT组合。这意味着集群中运行的每个服务都可以访问所有端点，即使它不需要。<strong class="kx jh">这显然违反了最小特权原则。</strong></p><h2 id="122f" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">网络策略得到改善</h2><p id="eb0a" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">Cilium通过引入<a class="ae jd" href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" rel="noopener ugc nofollow" target="_blank">CRD</a><em class="ng">CiliumNetworkPolicy</em>解决了这个问题，它增加了缺失的功能，使我们能够有装饰性地创建规则来管理对我们的API的各个端点的访问。</p><blockquote class="nd ne nf"><p id="09c8" class="kv kw ng kx b ky kz kh la lb lc kk ld nh lf lg lh ni lj lk ll nj ln lo lp lq ij bi translated"><em class="jg">顺便提一下，从架构的角度来看，同样的功能也可以通过API管理网关来实现，比如</em> <a class="ae jd" href="https://konghq.com/kong/" rel="noopener ugc nofollow" target="_blank"> <em class="jg">孔</em> </a> <em class="jg">，但是这是一种不同的方法，只适用于HTTP服务，而Cilium是一种较低级别的解决方案，支持Kafka、数据库等等。</em></p></blockquote><p id="ec8d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是一个示例CiliumNetworkPolicy YAML文件，该文件严格地只允许来自具有选定标签的pod的流量使用/flights资源上的GET动词。</p><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="64a8" class="mf mg jg oc b gy og oh l oi oj">apiVersion: "cilium.io/v2"<br/>kind: CiliumNetworkPolicy<br/>metadata:<br/>  name: "readflights"<br/>spec:<br/>  description: "Allow HTTP GET /flights from env=prod, app=flights_board to app=flights_service"<br/>  endpointSelector:<br/>    matchLabels:<br/>      app: flights_service<br/>  ingress:<br/>  - fromEndpoints:<br/>    - matchLabels:<br/>        env: prod<br/>        app: flights_board<br/>    toPorts:<br/>    - ports:<br/>      - port: "80"<br/>        protocol: TCP<br/>      rules:<br/>        http:<br/>        - method: "GET"<br/>          path: "/flights"</span></pre><p id="a60b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Cilium还支持<a class="ae jd" href="https://docs.cilium.io/en/stable/policy/language/#dns-policy-and-ip-discovery" rel="noopener ugc nofollow" target="_blank"> DNS策略</a>，例如，我们可以只允许来自负载平衡器地址或模式与外部托管的服务名称相匹配的外来流量。</p><h2 id="6d79" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">有什么好处？</h2><p id="a919" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在HTTP层(第7层)设置规则可以将API的授权问题转移到Kubernetes，而不是在应用程序本身中编码规则。这种方法的好处是:</p><ul class=""><li id="83e9" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq ok lx ly lz bi translated">独立于应用程序代码库开发更改授权规则的能力</li><li id="392f" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq ok lx ly lz bi translated">将应用程序代码管道从规则管道中分离出来的可能性，使团队能够协作</li><li id="3ba2" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq ok lx ly lz bi translated">能够在容器映像中部署同一API的另一个实例，但是具有不同的标签和规则，这可能取决于名称空间或不同的条件</li><li id="920d" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq ok lx ly lz bi translated">标准化和集中控制的安全方面</li></ul><h1 id="af32" class="np mg jg bd mh nq nr ns mk nt nu nv mn km nw kn mq kp nx kq mt ks ny kt mw nz bi translated">演示场景</h1><p id="7fea" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">您可以在本地机器上不安装任何东西的情况下继续操作。该演示将展示如何使用CiliumNetworkPolicy来保护对我们的示例航班预订服务的访问。</p><h2 id="8803" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">先决条件</h2><p id="5c04" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们将在Katacoda上使用一个干净的Ubuntu 20.04实例，所以不需要在本地安装任何东西。</p><h2 id="5622" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">#1加速Katacoda环境</h2><p id="e5e7" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在Katacoda上激活<a class="ae jd" href="https://www.katacoda.com/scenario-examples/courses/environment-usages/ubuntu-2004" rel="noopener ugc nofollow" target="_blank"> Ubuntu 20.04游乐场</a>并遵循以下步骤。</p><h2 id="6122" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">#2在Ubuntu实例上安装k3s</h2><p id="5b4f" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们将使用Rancher提供的名为<a class="ae jd" href="https://k3s.io/" rel="noopener ugc nofollow" target="_blank"> k3s </a>的小型快速Kubernetes发行版。这将使我们能够快速构建新的Kubernetes集群，并继续下一步工作。</p><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="b50c" class="mf mg jg oc b gy og oh l oi oj">curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC='--flannel-backend=none --disable-network-policy' sh -</span></pre><p id="55c9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将KUBECONFIG环境变量设置为指向k3s配置文件，这样我们就可以通过已经预安装在Katacoda环境中的<code class="fe ol om on oc b">kubectl</code>与集群对话。</p><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="d299" class="mf mg jg oc b gy og oh l oi oj">export KUBECONFIG=/etc/rancher/k3s/k3s.yaml</span></pre><h2 id="bcdb" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">#3安装纤毛CLI</h2><blockquote class="nd ne nf"><p id="0a1d" class="kv kw ng kx b ky kz kh la lb lc kk ld nh lf lg lh ni lj lk ll nj ln lo lp lq ij bi translated"><em class="jg">如果你需要帮助安装纤毛，请参考他们的</em> <a class="ae jd" href="https://docs.cilium.io/en/stable/gettingstarted/k3s/" rel="noopener ugc nofollow" target="_blank"> <em class="jg">优秀文档</em> </a> <em class="jg">。</em></p></blockquote><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="bec4" class="mf mg jg oc b gy og oh l oi oj">curl -L --remote-name-all https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz{,.sha256sum}<br/>sha256sum --check cilium-linux-amd64.tar.gz.sha256sum<br/>sudo tar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin<br/>rm cilium-linux-amd64.tar.gz{,.sha256sum}</span></pre><h2 id="e146" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">#4在集群上安装纤毛</h2><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="35ff" class="mf mg jg oc b gy og oh l oi oj">cilium install</span></pre><p id="2f58" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Cilium可能需要一段时间来激活，因此我们将使用此命令来等待Cilium完全启动。</p><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="7bb0" class="mf mg jg oc b gy og oh l oi oj">cilium status --wait</span></pre><h2 id="bb3b" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">#5部署样例go API</h2><p id="136b" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">让我们部署一个极简的Go REST API，在这里我们可以轻松地测试CiliumNetworkPolicy的运行情况。</p><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="8ad2" class="mf mg jg oc b gy og oh l oi oj">kubectl apply -f <a class="ae jd" href="https://raw.githubusercontent.com/Piotr1215/go-sample-api/master/k8s/deployment.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/Piotr1215/go-sample-api/master/k8s/deployment.yaml</a></span></pre><p id="89d6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查看Katacoda终端的API开放端口<strong class="kx jh"> 31234 </strong></p><p id="bab1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该API有3个简单的GET端点</p><ul class=""><li id="93b1" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq ok lx ly lz bi translated">/ returns "主页"</li><li id="3e09" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq ok lx ly lz bi translated">/version返回“版本页”</li><li id="33a8" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq ok lx ly lz bi translated">/about返回“关于页面”</li></ul><h2 id="ff42" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">#6检查服务连接</h2><p id="2433" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">创建一个测试<a class="ae jd" href="https://www.busybox.net/" rel="noopener ugc nofollow" target="_blank"> BusyBox </a> pod并检查go-api服务的连通性</p><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="1d6d" class="mf mg jg oc b gy og oh l oi oj">kubectl run -it --rm debug \<br/>        --image=radial/busyboxplus:curl \<br/>        --restart=Never \<br/>        -- curl -w "\n" <a class="ae jd" href="http://go-api-svc" rel="noopener ugc nofollow" target="_blank">http://go-api-svc</a></span></pre><p id="4036" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来分解这个命令:</p><ul class=""><li id="9daf" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq ok lx ly lz bi translated"><code class="fe ol om on oc b">kubectl run</code> -开始一个新的pod</li><li id="935d" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq ok lx ly lz bi translated"><code class="fe ol om on oc b">-it</code>标志确保我们可以与pod交互，并向内部运行的容器发送命令</li><li id="32b7" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq ok lx ly lz bi translated"><code class="fe ol om on oc b">--rm</code>指示库伯内特公司在豆荚退出后立即将其移除</li><li id="01ca" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq ok lx ly lz bi translated"><code class="fe ol om on oc b">curl -w "\n" http://go-api-svc</code>利用Kubernetes DNS和服务发现机制调用go-api服务</li></ul><p id="8d0d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行这个命令后，你应该看到<code class="fe ol om on oc b">HOME Page</code>返回到终端。</p><h2 id="855c" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">#7应用网络策略</h2><p id="d771" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">让我们应用只允许来自标签为app:version_ready的pod的流量到达go-api pod的端点的策略。</p><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="4506" class="mf mg jg oc b gy og oh l oi oj">apiVersion: "cilium.io/v2"<br/>kind: CiliumNetworkPolicy<br/>metadata:<br/>  name: "readflights"<br/>spec:<br/>  description: "Allow HTTP GET /version from app=version_reader to type=service"<br/>  endpointSelector:<br/>    matchLabels:<br/>      type: service <br/>  ingress:<br/>  - fromEndpoints:<br/>    - matchLabels:<br/>        app: version_reader<br/>    toPorts:<br/>    - ports:<br/>      - port: "8080"<br/>        protocol: TCP<br/>      rules:<br/>        http:<br/>        - method: "GET"<br/>          path: "/version"</span><span id="86df" class="mf mg jg oc b gy oo oh l oi oj">kubectl apply -f <a class="ae jd" href="https://raw.githubusercontent.com/Piotr1215/go-sample-api/master/k8s/cilium-policy.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/Piotr1215/go-sample-api/master/k8s/cilium-policy.yaml</a></span></pre><h2 id="128b" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">#8检查连接是否正常</h2><p id="f83c" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">如果我们的策略运行正常，我们应该不能再访问该服务了。</p><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="e6ae" class="mf mg jg oc b gy og oh l oi oj">kubectl run -it --rm debug \<br/>        --image=radial/busyboxplus:curl \<br/>        --restart=Never \<br/>        --timeout=15s \<br/>        -- curl -w "\n" <a class="ae jd" href="http://go-api-svc" rel="noopener ugc nofollow" target="_blank">http://go-api-svc</a></span></pre><p id="cf1c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述命令将导致超时。</p><blockquote class="nd ne nf"><p id="3fd8" class="kv kw ng kx b ky kz kh la lb lc kk ld nh lf lg lh ni lj lk ll nj ln lo lp lq ij bi translated"><em class="jg">如果您不想等待超时，您可以使用顶部的</em> <code class="fe ol om on oc b"><em class="jg">+</em></code> <em class="jg">图标创建一个新的终端会话。</em></p></blockquote><h2 id="a7e6" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">#9身份识别政策</h2><p id="2f26" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">为了向<code class="fe ol om on oc b">/version</code>端点授予对pod的访问权，我们必须用<code class="fe ol om on oc b">app=version_reader</code>对其进行适当的标记。这将启用身份识别策略，我们也可以使用K8s标签，而不是通过它们的IP:PORT组合来定位pod。利用标签而不是IP可以很好地适应Kubernetes基础设施的短暂性。</p><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="aa5c" class="mf mg jg oc b gy og oh l oi oj">kubectl run -it --rm debug2 \<br/>        --image=radial/busyboxplus:curl \<br/>        --labels app=version_reader \<br/>        --restart=Never \<br/>        -- curl -w "\n" <a class="ae jd" href="http://go-api-svc/version" rel="noopener ugc nofollow" target="_blank">http://go-api-svc/version</a></span></pre><p id="3f3b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这应该会打印出<code class="fe ol om on oc b">VERSION Page</code>。让我们尝试从同一个pod访问<code class="fe ol om on oc b">/about</code>端点。行得通吗？</p><pre class="nl nm nn no gt ob oc od oe aw of bi"><span id="2281" class="mf mg jg oc b gy og oh l oi oj">kubectl run -it --rm debug2 \<br/>        --image=radial/busyboxplus:curl \<br/>        --labels app=version_reader \<br/>        --timeout=15s \<br/>        --restart=Never \<br/>        -- curl -w "\n" <a class="ae jd" href="http://go-api-svc/about" rel="noopener ugc nofollow" target="_blank">http://go-api-svc/about</a></span></pre><h1 id="f3ec" class="np mg jg bd mh nq nr ns mk nt nu nv mn km nw kn mq kp nx kq mt ks ny kt mw nz bi translated">结论</h1><p id="608a" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们只是触及了纤毛功能的表面，但我相信专注于实际使用案例有助于我们学习使用纤毛的实际技能，而不是学习关于纤毛的知识。</p><p id="6b00" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">云原生生态系统的当前趋势是在越来越多的场景中采用eBPF。这项技术目前被谷歌、脸书、SUSE、AWS和许多其他公司用作强大而灵活的底层解决方案，可以更好地解决现有的一系列挑战。</p><p id="bf5a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Cilium弥合了低级eBFP原语和最终用户之间的抽象鸿沟，IMO是最有前途的云原生项目之一。</p></div></div>    
</body>
</html>