<html>
<head>
<title>A wild way to check if a number is prime using a regular expression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用正则表达式检查一个数是否是质数的一种简单方法</h1>
<blockquote>原文：<a href="https://itnext.io/a-wild-way-to-check-if-a-number-is-prime-using-a-regular-expression-4edfb725f895?source=collection_archive---------0-----------------------#2018-10-13">https://itnext.io/a-wild-way-to-check-if-a-number-is-prime-using-a-regular-expression-4edfb725f895?source=collection_archive---------0-----------------------#2018-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ab3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在你过去搜索素数算法的某个地方，你可能会遇到这样的情况:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/17b01fbd305cfa8f7ba405416b6503b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6ZGg8TUN6fIgFMktRnFmA.png"/></div></div></figure><p id="b39d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是什么？这是一种检查一个数是否是质数的方法！而且你连for循环都不用写！</p><p id="9794" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很狂野，对吧？</p><p id="303b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我也这么认为。所以我想如果有人好奇的话，把这个正则表达式分解并一步一步地解释可能会很有趣。</p><p id="5b47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="la">注意:我知道正则表达式(在/'之间的东西)可能看起来很神奇，但是坚持我的观点，我保证它是有意义的。</em></p><h2 id="874f" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">好吧，发生了什么事？</h2><p id="e3c4" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">因此，这个功能基本上遵循三个步骤:</p><ol class=""><li id="d89c" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated">把这个数变成一元形式</li><li id="48a9" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">查看它是0还是1</li><li id="8291" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">检查它是否是任何大于1的数的倍数</li></ol><h2 id="a775" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">第一步</h2><p id="d306" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">所以首先我们要把我们要检查的数字转换成一元形式。“一元”基本上是计数标记的一种花哨说法(即3变成“111”，4变成“1111”，等等。).</p><p id="08a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是通过这段代码实现的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/7188b84107e320c6284089f8440d6c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*OYxIxoNs7o_2pG1LrwrlMA.png"/></div></figure><p id="6143" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这基本上就是说，“创建一个有n + 1个空槽的数组，并用1连接所有这些空值。”</p><p id="cf0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我更喜欢使用ES6中的String.prototype.repeat()方法，如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/d9ae83a41f34088449b983c1863e1701.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*F_em0PRUNJcf9tkq_vAGJg.png"/></div></figure><p id="1a34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做可以让您不必首先创建一个数组，然后将数组的所有元素连接成一个字符串。它读起来也更直观，但更老的方法是在互联网上到处都是，所以我想我会展示这两者。</p><p id="43ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！继续前进。</p><h2 id="6315" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">第二步</h2><p id="fbba" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">所以现在我们要开始看看这个一元版本的数是否匹配正则表达式。正则表达式可以分为两部分，在<code class="fe mp mq mr ms b">|</code>(它的工作方式类似于OR操作符)左边的部分和右边的部分。</p><p id="084b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">左边是:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/dac75f751cb4c1bf68e8426c44b69b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*yx_dwCxbfdWj4OCIL_AAxQ.png"/></div></figure><p id="9d70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以让我们一个字一个字的来。</p><p id="49c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先是<code class="fe mp mq mr ms b">^</code>。</p><p id="16ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这告诉正则表达式它需要匹配字符串的开头，所以它不能找到从中间、结尾或除了开头以外的任何地方开始的模式。这个家伙是<code class="fe mp mq mr ms b">$</code>的对等物，它告诉我们的正则表达式字符串的结尾必须在哪里。基本上，这意味着整个字符串必须匹配正则表达式，不能有任何余数。</p><p id="d510" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来我们有<code class="fe mp mq mr ms b">1</code>。</p><p id="15ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的1只是说在字符串中查找字符“1”。我们可以制作一个全是2的一元字符串(例如，3变成了“222”等等。)并且这个字符需要是2。它只需要和你用来创建字符串的字符一样。</p><p id="6677" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是<code class="fe mp mq mr ms b">?</code>。</p><p id="186f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着它前面的字符是可选的，因此正则表达式将匹配零个“1”或一个“1”(即“或“1”)。</p><p id="1b01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一个字符是<code class="fe mp mq mr ms b">$</code>。</p><p id="fd3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像我说的，它是<code class="fe mp mq mr ms b">^</code>的对应。这就是我们如何知道最后没有余数！</p><p id="e1af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，正则表达式的这一部分完成了步骤2，检查传入的数字是0还是1。</p><p id="f839" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！下一个！</p><h2 id="d164" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">第三步</h2><p id="586d" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">这就是乐趣的开始。现在我们需要看看这个数是否是大于1的倍数。如果是，那就不是质数！所以让我们看看正则表达式的右边:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/45410bd10d4a843f59dc66ed592d05a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*txiDHk5Y9XMAr4CGRnvfwg.png"/></div></figure><p id="707d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们有和以前一样的<code class="fe mp mq mr ms b">^...$</code>模式，说字符串必须在这些地方开始和结束，匹配才能工作。所以首先让我们看看括号在做什么。</p><p id="c794" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mp mq mr ms b">(11+?)</code></p><p id="1bd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的括号创建了一个分组，这很重要，因为我们要检查倍数。如果我们想看到我们的数字不是2的倍数，我们需要把所有的“1”分组为“11 ”,并找出是否有余数。</p><p id="d4e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">括号内的前两个<code class="fe mp mq mr ms b">1</code>与之前的<code class="fe mp mq mr ms b">1</code>相同。它们只是匹配数字的一元字符串版本中的“1”。</p><p id="f73b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mp mq mr ms b">+</code>表示匹配它前面的一个或多个字符。因此，至少需要两个“1”才匹配，但是任何大于这个数的“1”也匹配。</p><p id="3faf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mp mq mr ms b">+</code>后面的<code class="fe mp mq mr ms b">?</code>超级重要。它让<code class="fe mp mq mr ms b">+</code>变得“不贪婪”这意味着它将首先匹配字符串中可能的最小部分。它将从只匹配两个“1”开始，然后是三个“1”，然后是四个，依此类推。如果<code class="fe mp mq mr ms b">?</code>丢失，那么<code class="fe mp mq mr ms b">+</code>将会贪婪地匹配尽可能多的字符串，对我们来说是整个字符串，因为我们的字符串只包含一个字符。</p><p id="25ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了两个或更多“1”的分组，我们需要检查分组的倍数是否匹配字符串的其余部分，没有余数(即，直到字符串的最末尾)。这就是它的由来:</p><p id="44c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mp mq mr ms b">\1+?</code></p><p id="70f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一位是<code class="fe mp mq mr ms b">\1</code>，称为反向参考。它将引用正则表达式中的第一个分组。把它想象成一个正则表达式变量。它指的是那些括号之间的东西。</p><p id="4a99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">后面的<code class="fe mp mq mr ms b">+?</code>应该看着眼熟。这是非贪婪地检查我们的反向引用可能有一次或多次迭代。</p><p id="d03f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以如果<code class="fe mp mq mr ms b">(11+?)</code>匹配字符串“11 ”,我们的反向引用也将匹配“11 ”,所以我们的正则表达式正在寻找任何是“11”的倍数的东西，从“1111”开始，然后是“111111 ”,等等。如果失败了(如果我们的数字是奇数)，那么它将返回并向括号内的位添加另一个“1”，并尝试匹配任何是“111”倍数的值。</p><p id="b0d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们的正则表达式在匹配时返回true，这意味着我们的数字是1)0或1，或者2)大于1的倍数。那说明它不是(即<code class="fe mp mq mr ms b">!</code>)素数！很酷，对吧？</p><p id="4b78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再看一遍代码，看看你是否理解了全部内容:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/17b01fbd305cfa8f7ba405416b6503b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6ZGg8TUN6fIgFMktRnFmA.png"/></div></div></figure><p id="b1bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，您可以看到一个具有一些不错的ES6语法的版本，它消除了创建不必要的阵列的需要:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/367a47f3a94c53d0a47387a401a39ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_y3aI4bgyzgANxefGLf6Q.png"/></div></div></figure><p id="a75a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我目前只有这些了。感谢阅读！希望你喜欢自己，并准备好做一些自己的正则表达式魔术。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="7420" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="la">编辑:</em></p><p id="2deb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="la">一些人问我用这种方法检查质数的效率。我应该从一开始就提到并为not道歉，这是一种非常低效的检查一个数是否是质数的方法。</em></p><p id="5705" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确定一个数是否是质数的典型方法是只检查数的平方根以内的约数，但在这里我们检查数的一半。</p><p id="7c10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="la">正则表达式本身也只是问题的一部分。String.prototype.repeat()是一个将重复n次的迭代，对于非常大的数字，仅这一项就要花费很多时间。</em></p><p id="3728" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数浏览器中字符串的最大长度大约是2.68亿，所以你不能检查大于这个长度的素数(比如我最喜欢的素数，1000000000000066000000001)。</p><p id="7448" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="la">总而言之，从实用的角度来看，正则表达式的做法非常糟糕。我只是觉得把它作为学术练习会很有趣。感谢所有提问的人！</em></p></div></div>    
</body>
</html>