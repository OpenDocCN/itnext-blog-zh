<html>
<head>
<title>Back to the Browser: React Form Validation with the DOM API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回到浏览器:用DOM API进行表单验证</h1>
<blockquote>原文：<a href="https://itnext.io/back-to-the-browser-form-validation-d32dd01802c0?source=collection_archive---------5-----------------------#2019-02-18">https://itnext.io/back-to-the-browser-form-validation-d32dd01802c0?source=collection_archive---------5-----------------------#2019-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6a1eed34ed3e4d38cd4d0a9b4085d082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lOBid_kZry-I0rkPpu7Slg.png"/></div></div></figure><div class=""/><p id="80b7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上周，我写了一篇关于如何用React钩子构建表单验证钩子的文章(这里有更多关于它的内容)</p><p id="9cfd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是就在完成这篇文章之后，我开始想“好吧，但是我们知道这个例子中几乎所有的验证都可以使用DOM API来完成”，这就是这篇文章是如何诞生的故事。</p><p id="535b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们现在拥有的所有花哨和令人敬畏的技术，我们忘记了检查浏览器的最新版本中实现了什么(我指的是我自己)。</p><p id="dfe2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有像web组件这样的功能，但我们没有利用这些功能，因为我们喜欢这些框架/库(Vue.js、React、Angular、Polymer等)。我这里有一些关于web组件<a class="ae kz" href="http://slides.com/highercomve/web-components#/" rel="noopener ugc nofollow" target="_blank">的幻灯片</a>，但是这篇文章不是关于那个的，是关于浏览器今天能为我们做什么关于表单验证。</p><p id="0289" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">浏览器现在支持表单验证，也许你以前用过。大约</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi la"><img src="../Images/dfa1fcddb857b286e6b099de033d4f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*DUAmNywXLnN51HrKKrTZyg.png"/></div></figure><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="600b" class="lk ll je lg b gy lm ln l lo lp">&lt;input type='text'<br/>       name='firstName'<br/>       id='firstName'<br/>       minlength='2'<br/>       pattern='[a-zA-Z]*'<br/>       required <br/>/&gt;</span></pre><p id="858a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常简单的验证，其中验证字符串的最小长度、输入值的存在性，并根据正则表达式模式搜索从“a”到“z”的小写或大写字符进行验证。</p><p id="b6dc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很好，但我们如何将这与…我不知道…反应？好吧，我们开始吧！</p><h2 id="e99d" class="lk ll je bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">首先，让我们删除这些错误的浏览器界面</h2><p id="b0ce" class="pw-post-body-paragraph kb kc je kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">因为它们有点丑。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e189" class="lk ll je lg b gy lm ln l lo lp">&lt;form id="my-super-form" novalidate&gt;<br/>  &lt;input type='text'<br/>       name='firstName'<br/>       id='firstName'<br/>       minlength='2'<br/>       pattern='[a-zA-Z]*'<br/>       required <br/>  /&gt;<br/>&lt;/form&gt;</span></pre><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/b1ce8f07df09288b32247ea7fc11f7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/1*ljTFIMmjzU5_IxkLssllAA.gif"/></div></figure><p id="7f21" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">重要吗</strong>提到把"<strong class="kd jf"> novalidate" </strong>属性放到<strong class="kd jf"> form </strong>标签并不意味着你可以使用浏览器验证，只意味着你需要为它编写一小段代码。</p><h1 id="0fed" class="mn ll je bd lq mo mp mq lt mr ms mt lw mu mv mw lz mx my mz mc na nb nc mf nd bi translated">检查有效性方法和报告有效性</h1><p id="aba4" class="pw-post-body-paragraph kb kc je kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">如果我们采用这种形式并运行方法<strong class="kd jf"> checkValidity </strong>我们实际上是在运行浏览器的验证。该方法适用于所有与表单相关的标签:表单、输入、选择、文本区域等。</p><p id="ffca" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf"> reportValidity </strong>方法是相同的，可用于相同的标记。它们之间唯一的区别是副作用。当我们使用<strong class="kd jf"> checkValidity </strong>方法时，它将返回一个<strong class="kd jf">布尔值</strong>(如果有效则为真，如果无效则为假)<strong class="kd jf"> </strong>而没有任何副作用，但是当我们使用<strong class="kd jf"> reportValidity </strong>时，我们得到相同的<strong class="kd jf">布尔值</strong>，但是同时浏览器使用本机浏览器方式显示错误(在我们放置<strong class="kd jf"> novalidate </strong>属性之前也是如此)。</p><h1 id="2979" class="mn ll je bd lq mo mp mq lt mr ms mt lw mu mv mw lz mx my mz mc na nb nc mf nd bi translated">我们如何使用它？</h1><p id="d844" class="pw-post-body-paragraph kb kc je kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">拥有这个HTML</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e113" class="lk ll je lg b gy lm ln l lo lp">&lt;form id="my-super-form" novalidate&gt;<br/>  &lt;input type='text'<br/>       name='firstName'<br/>       id='firstName'<br/>       minlength='2'<br/>       pattern='[a-zA-Z]*'<br/>       required <br/>  /&gt;<br/>  &lt;button type="submit"&gt;Submit this form&lt;/button&gt;</span><span id="071a" class="lk ll je lg b gy ne ln l lo lp">&lt;/form&gt;</span></pre><p id="04f1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以写这段Javascript代码</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8df1" class="lk ll je lg b gy lm ln l lo lp">var form = document.querySelector("#my-super-form")<br/>form.addEventListener("submit", (event) =&gt; {<br/>    event.preventDefault()<br/>    const isValid = form.checkValidity()<br/>    if (!isValid) {<br/>      return alert("the form is not valid")</span><span id="6ab9" class="lk ll je lg b gy ne ln l lo lp">    }<br/>    const formData = new FormData(form)<br/>    // Do something with the formData, example send it via a ajax</span><span id="dcce" class="lk ll je lg b gy ne ln l lo lp">})</span></pre><p id="b640" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将以糟糕的用户体验告终，因为用户永远不知道什么是失败，什么是错误。</p><p id="694f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但好的一面是，我们可以读取浏览器通常放在界面中的错误，并利用这些错误，这可以通过使用属性<strong class="kd jf"> validationMessage </strong>来实现。该方法可用于表单的输入，而不是表单本身。我们有另一个属性可以用来查看输入的验证状态，这个属性叫做<strong class="kd jf">有效性</strong>，它返回这样一个对象:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7b53" class="lk ll je lg b gy lm ln l lo lp">{<br/>  badInput: false<br/>  customError: false<br/>  patternMismatch: false<br/>  rangeOverflow: false<br/>  rangeUnderflow: false<br/>  stepMismatch: false<br/>  tooLong: false<br/>  tooShort: false<br/>  typeMismatch: false<br/>  valid: true<br/>  valueMissing: false<br/>}</span></pre><p id="b2aa" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">描述是否存在任何类型的错误，以便在需要时对错误进行分类。</p><p id="0646" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以访问那些获取表单元素并读取这些属性的方法，比如:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b8c0" class="lk ll je lg b gy lm ln l lo lp">const submit = (event) =&gt; {<br/>    event.preventDefault()<br/>    const form = event.target<br/>    const isValid = form.checkValidity() // returns true or false<br/>    const formData = new FormData(form)<br/>    const validationMessages = Array<br/>      .from(formData.keys())<br/>      .reduce((acc, key) =&gt; {<br/>        acc[key] = form.elements[key].validationMessage<br/>        return acc<br/>      }, {})<br/>    console.log(validationMessages)<br/>}</span></pre><p id="be66" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将安慰类似于:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7a6f" class="lk ll je lg b gy lm ln l lo lp">{<br/>  "firstName": "Please fill out this field.",<br/>  "lastName": "Please fill out this field.",<br/>  "age": "Please fill out this field.",<br/>  "email": "Please fill out this field."<br/>}</span></pre><p id="5bb3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们对原生表单验证的工作原理有了更多的了解。让我们试着让内心有所反应</p><figure class="lb lc ld le gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="286c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个活生生的例子</p><figure class="lb lc ld le gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/507e81ebf51e900f50d48aea49c4e949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/1*DmYQKsZvABatEMSia4Movg.gif"/></div></figure><div class="is it gp gr iu ni"><a href="https://frontarm.com/demoboard/?id=f18f6c0a-bb26-4962-93e6-5c32a5dc3187" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jf gy z fp nn fr fs no fu fw jd bi translated">演示板</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">快速创建Javascript和Markdown演示。导入npm上的任何包。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">frontarm.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ja ni"/></div></div></a></div><p id="3469" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我没有在React代码中挖掘太多，因为它几乎与上一篇文章相同。但是我使用了一些钩子来保存验证，以便打印验证错误。</p><p id="4477" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这些信息对你有用！</p><p id="d487" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想了解我们如何使用相同的API创建自定义消息或其他内容，我创建了另一个示例:)</p><div class="is it gp gr iu ni"><a href="https://frontarm.com/demoboard/?id=4c92231f-f327-4ed1-8fe4-d8a6e8563779" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jf gy z fp nn fr fs no fu fw jd bi translated">演示板</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">快速创建Javascript和Markdown演示。导入npm上的任何包。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">frontarm.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw ja ni"/></div></div></a></div><p id="2f96" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在返回代码编辑器:)</p></div></div>    
</body>
</html>