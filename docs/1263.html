<html>
<head>
<title>JavaScript Promises with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺使用Node.js</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-promises-with-node-js-e8ca827e0ea3?source=collection_archive---------0-----------------------#2018-08-24">https://itnext.io/javascript-promises-with-node-js-e8ca827e0ea3?source=collection_archive---------0-----------------------#2018-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="59ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将通过简短的Node.js示例程序来解释如何使用JavaScript promises。</p><p id="556d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还将解释什么是异步任务，以及它们如何在JavaScript中用承诺和回调来实现。</p><p id="cb5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我使用Node.js程序作为例子，所以我也将简要解释Node.js是什么以及它是如何工作的。</p><p id="64f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，在整篇文章中，我将承诺的使用与回调在JavaScript中实现异步任务的更传统的使用进行了比较。</p><h1 id="e99e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">内容</h1><ul class=""><li id="8a38" class="lm ln it js b jt lo jx lp kb lq kf lr kj ls kn lt lu lv lw bi translated"><a class="ae lx" href="#4029" rel="noopener ugc nofollow"> <strong class="js iu">什么是承诺？什么是异步任务？</strong>T3】</a></li><li id="021c" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn lt lu lv lw bi translated"><a class="ae lx" href="#199b" rel="noopener ugc nofollow"> <strong class="js iu">什么是Node.js？</strong> </a></li><li id="2159" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn lt lu lv lw bi translated"><a class="ae lx" href="#b7e6" rel="noopener ugc nofollow"> <strong class="js iu">带有承诺的简单异步任务</strong> </a></li><li id="ec80" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn lt lu lv lw bi translated"><a class="ae lx" href="#9482" rel="noopener ugc nofollow"> <strong class="js iu">带承诺的链式异步任务</strong> </a></li><li id="a51f" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn lt lu lv lw bi translated"><a class="ae lx" href="#cc7d" rel="noopener ugc nofollow"> <strong class="js iu">创造承诺</strong> </a></li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/4e9c7a7b2e72e034af140eb3db75df60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xCdQ5SF6bQFOvXTo9h7vA.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">曼努埃尔·萨多在<a class="ae lx" href="https://unsplash.com/search/photos/node?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="4029" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">什么是承诺？什么是异步任务？</h1><p id="b58e" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">承诺和回调是JavaScript中实现<strong class="js iu">异步任务</strong>的两种机制。如果调用者只是“开始”任务，然后在任务运行时继续做其他工作，那么任务就是异步的。当任务完成时，调用者会得到通知，这样它就可以中断当前的执行，并对任务的结果做任何事情。</p><p id="d7c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这与<strong class="js iu">同步任务</strong>形成对比，在这种情况下，调用者只需等待任务完成，然后才继续执行。</p><p id="475c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，程序包含同步和异步任务。自然，持久的“慢”任务很适合异步任务(非常快的任务可以同步实现)。最慢的任务通常是输入输出(I/O)任务。I/O任务是访问外部设备的任务，如硬盘或网络。在JavaScript中，I/O任务通常是异步实现的。</p><p id="5808" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您在程序中启动一个异步任务时，您必须以某种方式定义当这个任务完成时要做什么。传统上，这是通过一个<strong class="js iu">回调函数</strong>来完成的，您可以将它作为一个参数传递给启动异步任务的函数。该功能将在任务完成时执行。</p><p id="9ba5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近，有另一种方法来定义异步任务完成后要采取的动作:<strong class="js iu">承诺</strong>。在已经于2015年6月出版的<a class="ae lx" href="http://www.ecma-international.org/ecma-262/6.0/" rel="noopener ugc nofollow" target="_blank"> ECMA-262标准第六版</a> (ES6)中已经引入了承诺。</p><p id="6323" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章的目的是通过例子来解释承诺的用法。注意，承诺可以作为回调函数的替代，用承诺可以做的事情也可以用回调函数来做。但是承诺更加专业，允许更干净的代码。在本文中，当我们比较承诺的使用和回调的使用时，这一点也会变得很明显。</p><p id="9012" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">异步是JavaScript的核心。JavaScript <strong class="js iu">运行时环境</strong>专门用于异步任务的执行。它们具有处理异步任务的特殊功能。这也适用于特定的JavaScript运行时环境<strong class="js iu"> Node.js </strong>。但是Node.js到底是什么？</p><h1 id="199b" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">Node.js是什么？</h1><p id="a97a" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">简单来说，Node.js是一个针对JavaScript的<em class="mw">独立</em> <strong class="js iu">运行时环境</strong>。这意味着，Node.js可以在您的计算机上作为独立的进程执行JavaScript代码。我们可以说Node.js之于JavaScript就像JVM之于Java字节码，或者说Python解释器之于Python。</p><p id="df44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个的特别之处在于<em class="mw">独立</em>部分。因为，传统上JavaScript引擎是专门嵌入到网络浏览器中的。这意味着，您只能在web浏览器中显示的网站的上下文中执行JavaScript代码。Node.js是第一批独立于web浏览器并在自己的进程中运行的JavaScript引擎之一。</p><p id="4a33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Node.js使JavaScript用于通用应用成为可能。今天，用Node.js构建的最常见的应用程序类型是web服务器。但是原则上Node.js可以用来构建任何类型的应用程序。</p><h2 id="95d0" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">它是如何工作的？</h2><p id="d7bd" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">Node.js有以下三个主要成分:</p><ul class=""><li id="9eb9" class="lm ln it js b jt ju jx jy kb nj kf nk kj nl kn lt lu lv lw bi translated"><strong class="js iu"> JavaScript引擎</strong></li><li id="71f1" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn lt lu lv lw bi translated"><strong class="js iu">异步输入输出库</strong></li><li id="28cb" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn lt lu lv lw bi translated"><strong class="js iu">事件循环</strong></li></ul><p id="8064" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面，我将解释每一个概念。下面是内部Node.js架构的概述:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nm"><img src="../Images/29258081e44d53c4a2c82737b0544c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlLLjnf97Kt8hd4W1cq85w.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Node.js的内部工作方式</figcaption></figure><p id="8b1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> JavaScript引擎:</strong></p><p id="9ea0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JavaScript引擎是一种读取JavaScript代码并使其在机器上执行的软件。</p><p id="d3b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天大多数JavaScript引擎执行<strong class="js iu">实时(JIT)编译</strong>，也就是说，在程序执行的同时，JavaScript语句被编译成机器代码。这使得它们介于经典超前(AOT)编译器(如C语言的<code class="fe nn no np nq b">gcc</code>)和经典解释器(如Ruby或Python的解释器)之间。这里有一个<a class="ae lx" href="https://www.youtube.com/watch?v=p-iiEDtpy6I" rel="noopener ugc nofollow" target="_blank">视频</a>解释了JavaScript引擎是如何工作的。</p><p id="0bd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重要的是要记住，JavaScript引擎的工作是获取JavaScript的一个语句或函数，并让它在机器上执行。</p><p id="6980" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Web浏览器包含一个JavaScript引擎，Node.js也是，Node.js使用的JavaScript引擎是Google开发的<strong class="js iu"/><a class="ae lx" href="https://developers.google.com/v8/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Chrome V8</strong></a>(或简称V8)。</p><p id="c028" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">异步输入输出库:</strong></p><p id="d17c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个JavaScript引擎对于一个完整的运行时环境是不够的。异步实现的慢速操作，如磁盘访问或网络请求，不是由JavaScript引擎本身执行，而是交给专门的异步I/O库执行。Node.js使用的库叫做<a class="ae lx" href="https://libuv.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> libuv </strong> </a>。</p><p id="6c8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">libuv维护一个工作线程池<strong class="js iu">,从JavaScript引擎接收的I/O任务在这个池中执行。线程池的默认大小是4，最大大小是128，可以在Node.js启动时通过设置<code class="fe nn no np nq b">UV_THREADPOOL_SIZE</code>环境变量来改变(参见<a class="ae lx" href="http://docs.libuv.org/en/v1.x/threadpool.html" rel="noopener ugc nofollow" target="_blank"> docs </a>)。</strong></p><p id="0353" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，线程池<em class="mw">中的线程可能</em>阻塞(例如，等待磁盘访问)，但这不会阻塞运行在自己线程中的JavaScript引擎。如果线程池中的所有线程都很忙，并且有来自JavaScript引擎的新任务到达，那么这些新任务只是由libuv进行排队，一旦一个工作线程空闲，它们就会被处理。</p><p id="ffe6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当JavaScript引擎将一个I/O任务传递给libuv时，它还向运行时注册与该任务相关联的<strong class="js iu">回调</strong>。这个回调将在任务完成时执行(我们稍后将详细了解这是如何发生的)。这意味着，传递给libuv的每个任务都必须有一个与之相关联的回调。这个回调函数是作为参数传递给异步函数的回调函数。</p><p id="291b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们看看当libuv完成一个任务时，这个回调会发生什么。</p><p id="43ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">事件循环:</strong></p><p id="e544" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事件循环与<strong class="js iu">事件队列</strong>协同工作。事件队列只是JavaScript函数的队列。为了清楚起见，让我们调用事件队列中的函数<em class="mw">事件</em>。当libuv完成一项任务时，运行时会将相关的回调放入事件队列中。</p><p id="9f11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，事件队列常用的替代名称是<em class="mw">任务队列</em>或<em class="mw">消息队列</em>。但它们都是一样的东西。</p><p id="4fe1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在到<strong class="js iu">事件循环</strong>:事件循环位于事件队列和JavaScript引擎之间。简单地说，事件循环的工作就是将事件从事件队列“铲”到JavaScript引擎中执行。</p><p id="3fb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是事件循环不是盲目地这样做，而是根据以下规则:</p><ul class=""><li id="e6d4" class="lm ln it js b jt ju jx jy kb nj kf nk kj nl kn lt lu lv lw bi translated">如果JavaScript引擎当前已经在执行一个事件，那么事件循环将等待，直到JavaScript引擎完成该事件的执行。</li><li id="55f6" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn lt lu lv lw bi translated">JavaScript引擎一空闲，事件循环就将事件队列头部的事件传递给JavaScript引擎。如果事件队列当前为空，但仍有未完成的异步任务，那么事件循环将一直等待，直到新事件被放入事件队列。</li></ul><p id="7d9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一点通常用<strong class="js iu">调用栈</strong>来解释。与大多数运行时一样，Node.js也维护一个调用栈，以便于函数的执行。当一个函数被调用时，一个由函数的返回地址和局部变量组成的“堆栈帧”被推到堆栈上，当函数返回时，堆栈帧被从堆栈中移除。</p><p id="d8c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只要调用堆栈不为空，就意味着JavaScript引擎仍在执行一个事件。当调用堆栈为空时，这意味着JavaScript引擎已经执行完它的最后一个事件(之前由事件循环传递给它)，这意味着JavaScript引擎已经准备好从事件循环接收下一个事件。</p><p id="6022" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从这个事实出发，Node.js总是在处理新事件之前“清空堆栈”，并且在执行任何其他事件之前，所有事件<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Run-to-completion" rel="noopener ugc nofollow" target="_blank">“运行完成”</a>。</p><p id="6689" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个很好的<a class="ae lx" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">视频</strong> </a>解释了事件循环是如何工作的。</p><p id="9a79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，上面的视频不是专门关于Node.js的，而是关于web浏览器中的JavaScript运行时。然而，Node.js实际上非常类似于web浏览器的JavaScript运行时。最大的区别可能是Node.js使用libuv，而web浏览器运行时使用浏览器提供的API来执行异步I/O任务。事件循环在Node.js和web浏览器JavaScript运行时中的工作方式非常相似。</p><h2 id="b58b" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">主程序是如何执行的？</h2><p id="7607" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">到目前为止，我们已经讨论了作为回调的“事件”,当相应的异步任务完成时，这些事件被放入事件队列。但是一个程序的“主代码”呢？或者一个完全不使用异步任务和回调的程序？</p><p id="af81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，下面的程序:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="e8b6" class="mx kp it nq b gy nv nw l nx ny">var n = 1 + 1;<br/>console.log("The answer is " + n);</span></pre><p id="c664" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是如何执行的？嗯，一个程序的主代码可以看作是一个特殊函数<code class="fe nn no np nq b">main()</code>的主体，当程序启动时，这个函数作为第一个事件放入事件队列。因此，事件循环会立即将其传递给JavaScript引擎，JavaScript引擎会将其作为第一个事件执行。</p><p id="2cdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也解释了JavaScript经常出现的一个重要现象。考虑以下程序:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="8411" class="mx kp it nq b gy nv nw l nx ny">myLog("Start of main");</span><span id="ed58" class="mx kp it nq b gy nz nw l nx ny">setTimeout(() =&gt; myLog("I'm the setTimeout callback"), 0);</span><span id="538c" class="mx kp it nq b gy nz nw l nx ny">for (i = 0; i &lt; 1000000000; i++) {}</span><span id="c50a" class="mx kp it nq b gy nz nw l nx ny">myLog("End of main");</span></pre><p id="9e8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它的输出:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="d7db" class="mx kp it nq b gy nv nw l nx ny">$ node app.js<br/>12:26:35.423 Start of main<br/>12:26:38.662 End of main<br/>12:26:38.665 I'm the setTimeout callback</span></pre><p id="c3ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以看到，尽管我们为<code class="fe nn no np nq b">setTimeout</code>回调设置了0毫秒的延迟，但这个回调仅在3秒钟后执行，在主程序中的所有其他语句都已执行之后。</p><p id="b29e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原因是在JavaScript引擎已经开始执行<code class="fe nn no np nq b">main</code>事件之后，<code class="fe nn no np nq b">setTimeout</code>回调导致一个新事件被放入事件队列(注意，<code class="fe nn no np nq b">setTimeout</code>为libuv创建一个异步任务，该任务将在设置的延迟到期时完成，从而创建一个新事件，由回调函数组成，并被放入事件队列)。</p><p id="9bd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回调事件几乎会在主程序调用<code class="fe nn no np nq b">setTimeout</code>后立即进入事件队列(延迟设置为0毫秒)。它将位于事件队列的最前面，等待被执行。但是事件循环对此无能为力。JavaScript引擎仍在执行<code class="fe nn no np nq b">main</code>事件，事件循环别无选择，只能等到JavaScript引擎完成<code class="fe nn no np nq b">main</code>事件(及其冗长的<code class="fe nn no np nq b">for</code>循环)的执行后，才能将<code class="fe nn no np nq b">setTimeout</code>回调事件传递给JavaScript引擎。</p><p id="c02e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是<code class="fe nn no np nq b">setTimeout</code>不是<em class="mw">保证延迟</em>而是<em class="mw">最小延迟</em>的原因。这个也在<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Adding_messages" rel="noopener ugc nofollow" target="_blank">这里</a>解释。</p><p id="69bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在对Node.js和事件循环如何工作进行了冗长的讨论之后，让我们回到文章的主题:<strong class="js iu">承诺</strong>。</p><h1 id="6f63" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">简单的异步任务和承诺</h1><p id="dcc6" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">异步函数返回承诺。然后，通过向该承诺提供回调函数来定义任务完成时要做什么。这与回调的传统用法形成对比，在传统用法中，回调函数直接传递给异步函数。</p><p id="de37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将用一个例子来说明<code class="fe nn no np nq b">amqplib</code>模块的异步API函数。<code class="fe nn no np nq b">amqplib</code>是AMQP消息队列服务器的客户端库，例如<a class="ae lx" href="http://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>。</p><p id="0efa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个库有一个很好的特性，所有的API函数都有基于承诺的版本和基于回调的版本。因此，我们可以方便地比较承诺的使用和回调的使用。</p><p id="44bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面列出的第一个程序只是尝试与本地机器上的AMQP服务器建立连接:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="8957" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib');</span><span id="ed85" class="mx kp it nq b gy nz nw l nx ny">amqp.connect("amqp://localhost").then(onSuccess).catch(onFailure);</span><span id="21a7" class="mx kp it nq b gy nz nw l nx ny">function onSuccess(result) {<br/>  myLog(result.toString());<br/>}</span><span id="2f27" class="mx kp it nq b gy nz nw l nx ny">function onFailure(err) {<br/>  myLog(err.toString());<br/>}</span><span id="1fa7" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="fbeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，上面的清单中省略了<code class="fe nn no np nq b">myLog</code>函数的定义，但是可以在文章末尾的<a class="ae lx" href="#df35" rel="noopener ugc nofollow">附录</a>中找到。</p><p id="760e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nn no np nq b">amqp.connect</code>函数返回一个承诺。然后我们对这个承诺调用<code class="fe nn no np nq b">then</code>，在连接建立成功的情况下向它传递回调函数，然后我们调用<code class="fe nn no np nq b">catch</code>函数，在连接建立失败的情况下向它传递另一个回调函数。稍后我会更详细地解释<code class="fe nn no np nq b">then</code>和<code class="fe nn no np nq b">catch</code>的用法。</p><p id="66ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便说一下，一份承诺文件可以在这里找到。</p><p id="2bec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在没有运行AMQP服务器的情况下，让我们执行这个程序:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="4af0" class="mx kp it nq b gy nv nw l nx ny">$ node app.js<br/>12:11:13.580 I'm here<br/>12:11:13.595 Error: connect ECONNREFUSED 127.0.0.1:5672</span></pre><p id="1473" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以在输出中看到两件事。首先，无法建立连接(调用了<code class="fe nn no np nq b">onFailure</code>函数，而不是<code class="fe nn no np nq b">onSuccess</code>函数)。这仅仅是因为我们的本地机器上没有运行AMQP服务器。稍后，我们将启动一个RabbitMQ服务器，然后再次运行该程序。</p><p id="2c55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，我们可以看到，<code class="fe nn no np nq b">myLog("I'm here")</code>语句在构成<code class="fe nn no np nq b">onFailure</code>函数体的<code class="fe nn no np nq b">myLog(err.toString()) </code>语句之前15毫秒被执行。让我们来看看为什么这一系列事件是这样的。</p><h2 id="663c" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">这是怎么回事？</h2><p id="922a" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">Node.js使用一个运行JavaScript引擎的主线程。如上所述，同步任务由主线程直接执行。另一方面，异步任务由主线程传递给异步I/O库libuv。之后，主线程继续执行程序中的下一条语句。</p><p id="ac9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同时，工作线程执行提交给libuv的任务。任务一完成，相关的回调就作为一个新事件被放入事件队列，最终由事件循环传递给主线程中的JavaScript引擎。</p><p id="90f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个承诺基本上是向libuv发布一个异步任务，一个承诺的<code class="fe nn no np nq b">then</code>函数向与这个承诺关联的异步任务注册一个回调。</p><p id="1ab8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，当我们执行上述程序时，会出现以下步骤序列:</p><ol class=""><li id="8233" class="lm ln it js b jt ju jx jy kb nj kf nk kj nl kn oa lu lv lw bi translated">主线程执行<code class="fe nn no np nq b">amqp.connect</code>。这导致一个适当的<em class="mw"> connect </em>任务被传递给libuv进行异步执行。此后，<code class="fe nn no np nq b">amqp.connect</code>完成并返回一个承诺。</li><li id="2944" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn oa lu lv lw bi translated">来自libuv线程池的工作线程现在可以开始执行连接任务。 </li><li id="c514" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn oa lu lv lw bi translated">主线程执行<code class="fe nn no np nq b">amqp.connect</code>返回的承诺的<code class="fe nn no np nq b">then</code>函数，并将提供的<code class="fe nn no np nq b">onSuccess</code>函数注册为<em class="mw"> connect </em>任务的回调(针对任务<em class="mw">成功</em>的情况)。<code class="fe nn no np nq b">then</code>函数返回另一个承诺。</li><li id="fdbb" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn oa lu lv lw bi translated">主线程执行<code class="fe nn no np nq b">then</code>返回的承诺的<code class="fe nn no np nq b">catch</code>函数，并将提供的<code class="fe nn no np nq b">onFailure</code>函数注册为<em class="mw"> connect </em>任务的另一个回调(针对任务<em class="mw">失败</em>的情况)。<code class="fe nn no np nq b">catch</code>函数返回另一个承诺(但是在我们的例子中没有进一步使用)。</li><li id="c3b8" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn oa lu lv lw bi translated">主线程执行<code class="fe nn no np nq b">myLog("I'm here")</code>(打印<code class="fe nn no np nq b">I'm here</code>到控制台)。</li><li id="bb9a" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn oa lu lv lw bi translated"><strong class="js iu"> <em class="mw">大约15毫秒，主线程空闲，事件队列为空，所以什么也没发生。</em> </strong></li><li id="c1e4" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn oa lu lv lw bi translated">一个工作线程完成了<em class="mw">连接</em>任务(它失败了)，这导致运行时将<code class="fe nn no np nq b">onFailure</code>函数放入事件队列。</li><li id="387c" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn oa lu lv lw bi translated">主线程执行<code class="fe nn no np nq b">onFailure</code>功能(将<code class="fe nn no np nq b">Error connect ECONNREFUSED ...</code>打印到控制台)。</li><li id="815a" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn oa lu lv lw bi translated">Node.js进程终止。</li></ol><h2 id="dca6" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">关于“<code class="fe nn no np nq b">catch" and "then"</code>的一个注记</h2><p id="0f0c" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated"><code class="fe nn no np nq b">catch(onFailure)</code>函数只是<code class="fe nn no np nq b">then(undefined, onFailure)</code>的语法糖。也就是说，<code class="fe nn no np nq b">catch</code>只是另一个第一个参数设置为<code class="fe nn no np nq b">undefined</code>的<code class="fe nn no np nq b">then</code>函数(参见<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" rel="noopener ugc nofollow" target="_blank">文档</a>)。</p><p id="90cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">撇开<code class="fe nn no np nq b">catch</code>不谈，我们可以谈谈<code class="fe nn no np nq b">then</code>以及调用它的方式。</p><p id="b654" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nn no np nq b">then</code>函数有两个参数，其中第二个参数是可选的。第一个参数是当<code class="fe nn no np nq b">then</code>被调用的承诺为<strong class="js iu">【履行】</strong>时要调用的回调函数，第二个(可选)参数是当承诺为<strong class="js iu">【拒绝】</strong>时要调用的回调函数(参见<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank">文档</a>)。</p><p id="3b44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，这两个函数参数都是单参数函数，就像我们上面定义的<code class="fe nn no np nq b">onSuccess</code>和<code class="fe nn no np nq b">onFailure</code>一样。</p><p id="9765" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，<code class="fe nn no np nq b">then</code>的典型调用如下所示:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="8fa9" class="mx kp it nq b gy nv nw l nx ny">then(onSuccess, onFailure)</span></pre><p id="4976" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但也可以这样称呼:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="db87" class="mx kp it nq b gy nv nw l nx ny">then(onSuccess)</span></pre><p id="405a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者像这样:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="ad5e" class="mx kp it nq b gy nv nw l nx ny">then(undefined, onFailure)</span></pre><p id="65ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们已经看到的，最后一次调用相当于:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="16cf" class="mx kp it nq b gy nv nw l nx ny">catch(onFailure)</span></pre><p id="3272" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一种情况，<code class="fe nn no np nq b">then(onSuccess, onFailure)</code>非常清楚:如果承诺<em class="mw">中的任务成功</em>(即承诺“完成”)，则调用<code class="fe nn no np nq b">onSuccess</code>，如果任务<em class="mw">失败</em>(即承诺“拒绝”)，则调用<code class="fe nn no np nq b">onFailure</code>。</p><p id="348a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，在第二种情况下，<code class="fe nn no np nq b">then(onSuccess)</code>，如果承诺兑现，则调用<code class="fe nn no np nq b">onSuccess</code>。但是如果承诺被拒绝了呢？那么实际上没有回调代码被执行(承诺拒绝没有被处理)。正如我们将在后面看到的，如果<code class="fe nn no np nq b">then</code>函数被<em class="mw">链接</em>，这实际上可能是一个期望的行为。</p><p id="c168" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三种情况，<code class="fe nn no np nq b">then(undefined, onFailure)</code>，相当于<code class="fe nn no np nq b">catch(onFailure)</code>，如果拒绝承诺，则调用<code class="fe nn no np nq b">onFailure</code>。但是如果承诺兑现了呢？同样，不执行回调代码(不处理承诺履行)。同样，如果<code class="fe nn no np nq b">then</code>函数是链式的，这可能是有用的。</p><p id="83c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的清单中，我们有下面一行:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="747b" class="mx kp it nq b gy nv nw l nx ny">amqp.connect("amqp://localhost").then(onSuccess).catch(onFailure);</span></pre><p id="2f33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个新知识，我们看到下面这条线是等价的:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="3ff3" class="mx kp it nq b gy nv nw l nx ny">amqp.connect("amqp://localhost").then(onSuccess).then(undefined, onFailure);</span></pre><p id="c45e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以像这样通过一次调用<code class="fe nn no np nq b">then</code>来实现相同的行为:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="b47c" class="mx kp it nq b gy nv nw l nx ny">amqp.connect("amqp://localhost").then(onSuccess, onFailure);</span></pre><p id="c8bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#Chaining" rel="noopener ugc nofollow" target="_blank">文件</a>推荐使用<code class="fe nn no np nq b">then(onSuccess)</code>和<code class="fe nn no np nq b">catch(onFailure)</code>而不是<code class="fe nn no np nq b">then(onSuccess, onFailure)</code>。</p><h2 id="6d8d" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">允许履行承诺</h2><p id="3a52" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">用<code class="fe nn no np nq b">rabbitmq-server</code>在本地机器上启动RabbitMQ服务器，然后再次运行程序:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="ee4b" class="mx kp it nq b gy nv nw l nx ny">$ node app.js<br/>12:14:59.448 I'm here<br/>12:14:59.505 [object Object]</span></pre><p id="8a04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在连接成功了。与之前相反，现在调用了<code class="fe nn no np nq b">onSuccess</code>，而不是<code class="fe nn no np nq b">onFailure</code>，在通过调用<code class="fe nn no np nq b">amqp.connect</code>启动连接建立之后至少57毫秒。</p><p id="90f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您现在导航到<code class="fe nn no np nq b"><a class="ae lx" href="http://localhost:15672/#/connections," rel="noopener ugc nofollow" target="_blank">http://localhost:15672/#/connections</a></code>上的RabbitMQ管理UI，您应该在那里看到打开的连接。</p><p id="e406" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">日志输出中打印的<code class="fe nn no np nq b">[object Object]</code>实际上是一个<code class="fe nn no np nq b">amqplib</code>对象，它表示一个到AMQP服务器的开放连接，它可以用于<code class="fe nn no np nq b">amqplib</code>的进一步API函数，例如，用于创建一个<a class="ae lx" href="http://www.squaremobius.net/amqp.node/channel_api.html#model_createChannel" rel="noopener ugc nofollow" target="_blank">通道</a>。</p><h2 id="740b" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">使用匿名函数</h2><p id="fae8" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">在上面的例子中，我们使用明确命名的函数<code class="fe nn no np nq b">onSuccess</code>和<code class="fe nn no np nq b">onFailure</code>作为<code class="fe nn no np nq b">then</code>和<code class="fe nn no np nq b">catch</code>函数的参数。</p><p id="c820" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这些情况下，更常见的是使用匿名函数(尽管通常可读性较差)。在这种情况下，程序应该是这样的:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="07c5" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib');</span><span id="0ec8" class="mx kp it nq b gy nz nw l nx ny">amqp.connect("amqp://localhost")<br/>  .then(result =&gt; myLog(result.toString()))<br/>  .catch(err =&gt; myLog(err.toString()));</span><span id="ea17" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="9826" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这完全等同于上面带有命名回调函数的版本。</p><h2 id="2f0e" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">承诺与回访</h2><p id="0a8b" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated"><code class="fe nn no np nq b">amqplib</code>模块对API中的每个函数都有一个基于承诺和基于回调的版本。要导入基于回调的函数，我们只需要<code class="fe nn no np nq b">amqplib/callback_api</code>而不是<code class="fe nn no np nq b">amqplib</code>。</p><p id="da30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在基于回调的版本中，<code class="fe nn no np nq b">connect</code>函数有两个参数:一个AMQP URI和一个<a class="ae lx" href="http://fredkschott.com/post/2014/03/understanding-error-first-callbacks-in-node-js/" rel="noopener ugc nofollow" target="_blank">错误优先回调</a>函数。让我们用基于回调的API函数重写上面的程序:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="9718" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib/callback_api');</span><span id="1235" class="mx kp it nq b gy nz nw l nx ny">amqp.connect("amqp://localhost", callback);</span><span id="caf9" class="mx kp it nq b gy nz nw l nx ny">function callback(err, result) {<br/>  if (err)<br/>    myLog(err.toString());<br/>  else<br/>    myLog(result.toString());<br/>}</span><span id="eb99" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="b846" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论有没有运行RabbitMQ服务器，您都可以运行这个程序:其行为与最初基于Promise的版本完全相同。</p><p id="3b57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，为了完整起见，让我们用匿名函数而不是命名函数重写基于回调的版本:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="a689" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib/callback_api');</span><span id="9299" class="mx kp it nq b gy nz nw l nx ny">amqp.connect("amqp://localhost", (err, result) =&gt; {<br/>  if (err)<br/>    myLog(err.toString());<br/>  else<br/>    myLog(result.toString());<br/>});</span><span id="16e1" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="7fa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这里已经可以看到，基于回调的版本比基于承诺的版本稍微不那么简洁。但是对于更复杂的任务，这种差异会更明显，我们将在下一节中看到。</p><h1 id="9482" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">带承诺的链式异步任务</h1><p id="51ed" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">如果我们必须执行一系列异步任务，并且限制一个任务只能在前一个任务完成时开始，那么承诺，尤其是承诺链，就变得非常有用。这导致了嵌套的回调，因为我们在其他回调中有回调的定义。</p><p id="b2fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，为了完整地设置一个RabbitMQ服务器，我们可能需要执行以下任务。</p><ol class=""><li id="3455" class="lm ln it js b jt ju jx jy kb nj kf nk kj nl kn oa lu lv lw bi translated">建立到RabbitMQ服务器的<em class="mw">连接</em></li><li id="61b7" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn oa lu lv lw bi translated">(1)完成后，在此连接上创建一个<em class="mw">通道</em></li><li id="adb3" class="lm ln it js b jt ly jx lz kb ma kf mb kj mc kn oa lu lv lw bi translated">当(2)完成时，在该通道上创建一个<em class="mw">队列</em></li></ol><p id="3af3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是我们如何通过连锁承诺来实现这一点:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="960a" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib');</span><span id="def5" class="mx kp it nq b gy nz nw l nx ny">amqp.connect("amqp://localhost")<br/>  .then(onConnSuccess)<br/>  .then(onChannelSuccess)<br/>  .then(onQueueSuccess)<br/>  .catch(onFailure);</span><span id="0524" class="mx kp it nq b gy nz nw l nx ny">function onConnSuccess(connection) {<br/>  myLog("Connection: " + connection.toString());<br/>  return connection.createChannel()<br/>}</span><span id="b34c" class="mx kp it nq b gy nz nw l nx ny">function onChannelSuccess(channel) {<br/>  myLog("Channel: " + channel.toString());<br/>  return channel.assertQueue("my_queue");<br/>}</span><span id="a781" class="mx kp it nq b gy nz nw l nx ny">function onQueueSuccess(queue) {<br/>  myLog("Queue: " + queue.toString());<br/>}</span><span id="b44d" class="mx kp it nq b gy nz nw l nx ny">function onFailure(err) {<br/>  myLog(err.toString());<br/>}</span><span id="1e39" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="2d82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，每个任务都有一个成功回调函数，其中前两个函数启动一个新的异步任务，并将结果承诺返回到承诺链中。</p><p id="957d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nn no np nq b">then</code>是内部设置的，允许回调函数返回一个承诺，该承诺应用于链中的后续<code class="fe nn no np nq b">then</code>，依此类推。如果回调函数返回一个非承诺值，那么当前的承诺就用这个值“解决”了，也就是履行了。关于<code class="fe nn no np nq b">then</code>返回值的详细信息可以在<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#Return_value" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">文档</strong> </a>中找到。总而言之，这种复杂的设计允许如上所示的承诺链。</p><p id="dc16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在链的末端有一个单独的<code class="fe nn no np nq b">catch(onFailure)</code>函数(你知道它与<code class="fe nn no np nq b">then(undefined, onFailure)</code>相同)。一旦链中的任何先前承诺被拒绝，就调用该函数。这意味着，如果链中较早的承诺被拒绝，那么后续的<code class="fe nn no np nq b">then</code>功能不会被执行，而是直接跳到<code class="fe nn no np nq b">catch</code>。这就是为什么，如前所述，如果一些<code class="fe nn no np nq b">then</code>只处理完成，而不处理拒绝，而另一些<code class="fe nn no np nq b">catch</code>只处理拒绝，而不处理完成，那么链接是有用的。</p><p id="3793" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看这在实践中是如何工作的。如果我们没有运行RabbitMQ服务器并运行上述程序，我们会得到以下结果:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="ad0b" class="mx kp it nq b gy nv nw l nx ny">$ node app.js<br/>18:26:28.509 I'm here<br/>18:26:28.548 Error: connect ECONNREFUSED 127.0.0.1:5672</span></pre><p id="4d40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里执行的惟一一个回调是<code class="fe nn no np nq b">onFailure</code>，带有连接承诺的错误对象。正如所料，没有一个<code class="fe nn no np nq b">then</code>回调被执行。</p><p id="25d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们用<code class="fe nn no np nq b">rabbitmq-server</code>启动一个RabbitMQ服务器，并再次运行程序:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="3a1c" class="mx kp it nq b gy nv nw l nx ny">$ node app.js<br/>18:35:35.337 I'm here<br/>18:35:35.362 Connection: [object Object]<br/>18:35:35.368 Channel: [object Object]<br/>18:35:35.371 Queue: [object Object]</span></pre><p id="680e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所看到的，现在所有<code class="fe nn no np nq b">then</code>的回调函数都按顺序执行，创建一个连接，然后是一个通道，然后是一个队列。另一方面，不执行<code class="fe nn no np nq b">catch</code>，因为没有任务失败。</p><p id="1f3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe nn no np nq b"><a class="ae lx" href="http://localhost:15672/" rel="noopener ugc nofollow" target="_blank">http://localhost:1567</a></code>上检查您的RabbitMQ服务器，您应该看到已经创建了一个连接、一个通道以及一个队列。</p><h2 id="b8fd" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">承诺与回访</h2><p id="d294" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">凡是用承诺可以做到的，也可以用回电来做到。因此，让我们看看如何用回调(使用<code class="fe nn no np nq b">amqplib</code> API的“回调版本”)编写上述程序:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="82b3" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib/callback_api');</span><span id="aa93" class="mx kp it nq b gy nz nw l nx ny">amqp.connect("amqp://localhost", connCallback);</span><span id="b39a" class="mx kp it nq b gy nz nw l nx ny">function connCallback(err, connection) {<br/>  if (err)<br/>    myLog(err.toString());<br/>  else {<br/>    myLog("Connection: " + connection.toString());<br/>    connection.createChannel(channelCallback);<br/>  }<br/>}</span><span id="b40f" class="mx kp it nq b gy nz nw l nx ny">function channelCallback(err, channel) {<br/>  if (err)<br/>    myLog(err.toString());<br/>  else {<br/>    myLog("Channel: " + channel.toString());<br/>    channel.assertQueue("my_queue", null, queueCallback);<br/>  }<br/>}</span><span id="7406" class="mx kp it nq b gy nz nw l nx ny">function queueCallback(err, queue) {<br/>  if (err)<br/>    myLog(err.toString());<br/>  else {<br/>    myLog("Queue: " + queue.toString());<br/>  }<br/>}</span><span id="1399" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="f039" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于承诺的版本比基于回调的版本更简洁，我认为可以说它也更具可读性。</p><h2 id="ffcb" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">使用匿名函数</h2><p id="681a" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">让我们看看当我们使用匿名函数时，基于承诺的版本和基于回调的版本是什么样子的。</p><p id="3f9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">无极版本:</strong></p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="68e3" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib');</span><span id="756f" class="mx kp it nq b gy nz nw l nx ny">amqp.connect("amqp://localhost")<br/>  .then(connection =&gt; {<br/>    myLog("Connection: " + connection.toString());<br/>    return connection.createChannel()<br/>  })<br/>  .then(channel =&gt; {<br/>    myLog("Channel: " + channel.toString());<br/>    return channel.assertQueue("my_queue");<br/>  })<br/>  .then(queue =&gt; {<br/>    myLog("Queue: " + queue.toString());<br/>  })<br/>  .catch(err =&gt; {<br/>    myLog(err.toString());<br/>  });</span><span id="672c" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="b6d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">回调版本:</strong></p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="4c0b" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib/callback_api');</span><span id="590c" class="mx kp it nq b gy nz nw l nx ny">amqp.connect("amqp://localhost", (err, connection) =&gt; {<br/>  if (err)<br/>    myLog(err.toString());<br/>  else {<br/>    myLog("Connection: " + connection.toString());<br/>    connection.createChannel((err, channel) =&gt; {<br/>      if (err)<br/>        myLog(err.toString());<br/>      else {<br/>        myLog("Channel: " + channel.toString());<br/>        channel.assertQueue("my_queue", null, (err, queue) =&gt; {<br/>          if (err)<br/>            myLog(err.toString());<br/>          else {<br/>            myLog("Queue: " + queue.toString());<br/>          }<br/>        });<br/>      }<br/>    });<br/>  }<br/>});</span><span id="652e" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="e08d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，承诺相对于回调函数的优势变得非常明显。</p><p id="f829" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于回调，我们必须定义嵌套的匿名回调定义，我们最终会陷入“回调地狱”。此外，我们必须检查<code class="fe nn no np nq b">if/else</code>语句中的错误，这些错误会进一步增加可读性。</p><p id="dee6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，对于promises，我们对所有匿名函数都有一个固定的嵌套深度，错误作为链的元素来处理(通过<code class="fe nn no np nq b">catch</code>函数)。</p><p id="b53b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种增加的可读性和减少的错误倾向是承诺相对于回调的主要优势。</p><h1 id="cc7d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">创造承诺</h1><p id="21ed" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">以上所有讨论都是关于<em class="mw">使用</em>承诺。在每种情况下，承诺都是由API函数创建的，我们只是使用它。</p><p id="3cc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，如果您必须为自己创建一个具有承诺能力的异步函数，那么您必须知道如何创建承诺。</p><p id="e7f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，假设我们想要创建一个基于承诺的<code class="fe nn no np nq b">setup</code>函数，它结合了上面的<em class="mw">连接</em>、<em class="mw">通道</em>和<em class="mw">队列</em>任务。该函数应该返回一个承诺，调用者应该能够这样做:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="1c32" class="mx kp it nq b gy nv nw l nx ny">setup().then(onSetupSuccess).catch(onSetupFailed);</span></pre><p id="818f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，<code class="fe nn no np nq b">onSetupSuccess</code>是一个调用方定义的回调函数，用于整个设置(即连接<em class="mw">和</em>通道<em class="mw">和</em>队列的创建)成功的情况，而<code class="fe nn no np nq b">onSetupFailed</code>是一个调用方定义的回调函数，用于任何这些任务失败的情况。</p><p id="1cb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以通过以下方式创建承诺，如文档中的<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#Creating_a_Promise" rel="noopener ugc nofollow" target="_blank">这里的</a>所述:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="3ee5" class="mx kp it nq b gy nv nw l nx ny">new Promise(executor);</span></pre><p id="c52f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，<code class="fe nn no np nq b">executor</code>是对所谓的<strong class="js iu">执行器函数</strong> <em class="mw">的引用。当你创建一个承诺时，你必须定义这个执行者函数。</em></p><p id="21ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">executor函数必须具有以下签名:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="ab85" class="mx kp it nq b gy nv nw l nx ny">function executor(resolve, reject)</span></pre><p id="9afd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也就是说，它必须有两个参数，并且这两个参数都是函数引用。别担心，你不需要定义这些函数。但是你必须在executor函数的主体中调用这些函数。</p><p id="54f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特别是，当您想要“履行”承诺时，也就是当异步任务成功时，您必须调用<code class="fe nn no np nq b">resolve</code>函数。而你要“拒绝”承诺的时候，也就是异步任务失败的时候，就得调用<code class="fe nn no np nq b">reject</code>函数。</p><p id="c93e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，要创建启用承诺的异步函数，该函数必须简单地返回一个适当设置的承诺。</p><p id="fd5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看这在实践中是怎样的。下面是一个定义和使用如上所述的<code class="fe nn no np nq b">setup</code>函数的程序:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="09c2" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib');</span><span id="1038" class="mx kp it nq b gy nz nw l nx ny">setup()<br/>  .then(() =&gt; myLog("Setup succeeded"))<br/>  .catch(err =&gt; myLog("Setup failed: " + err));</span><span id="d69a" class="mx kp it nq b gy nz nw l nx ny">function setup() {<br/>  return new Promise(setupExecutor);<br/>}</span><span id="5054" class="mx kp it nq b gy nz nw l nx ny">function setupExecutor(resolve, reject) {<br/>  amqp.connect("amqp://localhost")<br/>    .then(connection =&gt; {<br/>      return connection.createChannel()<br/>    })<br/>    .then(channel =&gt; {<br/>      return channel.assertQueue("my_queue");<br/>    })<br/>    .then(queue =&gt; {<br/>      resolve();<br/>    })<br/>    .catch(err =&gt; {<br/>      reject(err);<br/>    });<br/>}</span><span id="edfe" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="e1f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们在没有运行RabbitMQ服务器的情况下执行这个程序，我们会得到以下输出:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="d751" class="mx kp it nq b gy nv nw l nx ny">$ node app.js<br/>16:50:10.447 I'm here<br/>16:50:10.463 Setup failed: Error: connect ECONNREFUSED 127.0.0.1:5672</span></pre><p id="63e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在运行RabbitMQ服务器的情况下:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="094e" class="mx kp it nq b gy nv nw l nx ny">$ node app.js<br/>16:51:25.815 I'm here<br/>16:51:25.890 Setup succeeded</span></pre><p id="f824" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以再查一下<a class="ae lx" href="http://localhost:15672/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">http://localhost:15672/</strong></a><strong class="js iu"/>，连接、通道、队列应该都在。只需调用启用承诺的<code class="fe nn no np nq b">setup</code>函数就可以完成所有事情。我们已经成功地创建了一个新基于承诺的异步函数，该函数又包含三个相互依赖的异步任务。</p><p id="4b53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和往常一样，将函数引用参数定义为<strong class="js iu">匿名函数</strong>比命名函数更常见。在这种情况下，程序应该是这样的(只有<code class="fe nn no np nq b">setup</code>函数发生了变化):</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="ac66" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib');</span><span id="6560" class="mx kp it nq b gy nz nw l nx ny">setup()<br/>  .then(() =&gt; myLog("Setup succeeded"))<br/>  .catch(err =&gt; myLog("Setup failed: " + err));</span><span id="89ce" class="mx kp it nq b gy nz nw l nx ny">function setup() {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    amqp.connect("amqp://localhost")<br/>      .then(connection =&gt; {<br/>        return connection.createChannel()<br/>      })<br/>      .then(channel =&gt; {<br/>        return channel.assertQueue("my_queue");<br/>      })<br/>      .then(queue =&gt; {<br/>        resolve();<br/>      })<br/>      .catch(err =&gt; {<br/>        reject(err);<br/>      });<br/>  });<br/>}</span><span id="03ad" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="5525" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，这里我们的promise的executor函数的实现使用了异步的基于promise的函数本身(<code class="fe nn no np nq b">amqplib</code> API函数)。</p><p id="50c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，没有什么能阻止我们使用基于回调的异步函数来实现promise executor函数。仅仅因为我们定义了一个承诺，并不意味着我们也必须用承诺实现承诺中的所有异步操作。</p><p id="cbaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们愿意，我们可以使用<code class="fe nn no np nq b">amqplib</code>的基于<strong class="js iu">回调的API </strong>函数来实现我们的承诺执行器函数。在这种情况下，程序应该是这样的:</p><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="e928" class="mx kp it nq b gy nv nw l nx ny">var amqp = require('amqplib/callback_api');</span><span id="be80" class="mx kp it nq b gy nz nw l nx ny">setup()<br/>  .then(() =&gt; myLog("Setup succeeded"))<br/>  .catch(err =&gt; myLog("Setup failed: " + err));</span><span id="8073" class="mx kp it nq b gy nz nw l nx ny">function setup() {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    amqp.connect("amqp://localhost", (err, connection) =&gt; {<br/>      if (err)<br/>        reject(err);<br/>      else {<br/>        connection.createChannel((err, channel) =&gt; {<br/>          if (err)<br/>            reject(err);<br/>          else {<br/>            channel.assertQueue("my_queue", null, (err, queue) =&gt; {<br/>              if (err)<br/>                reject(err);<br/>              else {<br/>                resolve();<br/>              }<br/>            });<br/>          }<br/>        });<br/>      }<br/>    });<br/>  });<br/>}</span><span id="bdfb" class="mx kp it nq b gy nz nw l nx ny">myLog("I'm here");</span></pre><p id="4b4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，如上所述，我认为基于承诺的版本比基于回调的版本更具可读性是不言而喻的。</p><h1 id="df35" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">附录:myLog函数</h1><pre class="me mf mg mh gt nr nq ns nt aw nu bi"><span id="8958" class="mx kp it nq b gy nv nw l nx ny">function myLog(msg) {<br/>  console.log(getTime() + " " + msg);<br/>}</span><span id="74bb" class="mx kp it nq b gy nz nw l nx ny">function getTime() {<br/>  var d = new Date();<br/>  return d.toLocaleTimeString('en-GB') + "." + d.getMilliseconds();<br/>}</span></pre></div></div>    
</body>
</html>