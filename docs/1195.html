<html>
<head>
<title>Reduce unit tests boilerplate with Jest’s .each syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest的减少单元测试样板。每种语法</h1>
<blockquote>原文：<a href="https://itnext.io/reduce-unit-tests-boilerplate-with-jests-each-syntax-f5e48828437f?source=collection_archive---------2-----------------------#2018-08-09">https://itnext.io/reduce-unit-tests-boilerplate-with-jests-each-syntax-f5e48828437f?source=collection_archive---------2-----------------------#2018-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4f2dfdb33329377fe1c01c4c7de3f7b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KYfVVVCGKS0j7MNjQRrGvw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/photos/9HI8UJMSdZA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布拉登·科拉姆</a>在<a class="ae kc" href="https://unsplash.com/search/photos/run?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="63ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了最终得到可维护的、结构良好的代码库，单元测试在web开发中至关重要。如你所知，这篇文章不会试图说服你考试的重要性。这是理所当然的。</p><p id="4c28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，有一个问题，我们在编写单元测试时面临的问题是，我们必须重复很多次，以便用describe / it格式添加所有这些断言。是的，这是真的。编写测试需要时间。</p><p id="c5b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那我们该怎么办？为了更快地编写测试，我们必须找到尽可能自动化整个过程的方法。对于那些想知道的人来说，编写更少的测试不是一个选项。</p><h2 id="bb6d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">。每个人都是为了胜利</h2><p id="11e2" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有一个很酷的功能叫做<a class="ae kc" href="https://jestjs.io/docs/en/api#describeeachtable-name-fn" rel="noopener ugc nofollow" target="_blank">。Jest 23中包含的每个</a>。这个图书馆的灵感来自摩卡咖啡。它最初是一个名为<a class="ae kc" href="https://www.npmjs.com/package/jest-each" rel="noopener ugc nofollow" target="_blank"> jest-each </a>的第三方包，在第23版中jest自己提供了这个包。如果你仍然使用旧版本的Jest，你可以单独安装jest-each包。</p><h2 id="1c53" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">它是如何工作的？</h2><p id="beda" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">因为。每一个我们都可以用几行写几十个断言，这样我们就可以避免重复。我们唯一要做的就是以动态的方式声明我们的变量，然后使用这些变量做一次断言。这些甚至用在断言的描述中。</p><p id="e28a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">听起来很有趣？那么让我们深入研究代码。我们有下面的纯函数，我们想对它进行单元测试:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d181" class="lb lc iq me b gy mi mj l mk ml">function add(x, y) {<br/>  return x + y;<br/>}</span></pre><p id="ddde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以选择随机的数字对，并提供一些断言，以验证我们总是得到预期的结果:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d9dd" class="lb lc iq me b gy mi mj l mk ml">describe('test add method', () =&gt; {<br/>  it ('should return 5 when 2 and 3 are used', () =&gt; {<br/>    expect(add(2, 3)).toEqual(5);  <br/>  });</span><span id="5d78" class="lb lc iq me b gy mm mj l mk ml">  it ('should return 50 when 20 and 30 are used', () =&gt; {<br/>    expect(add(20, 30)).toEqual(50);  <br/>  });</span><span id="75a9" class="lb lc iq me b gy mm mj l mk ml">  it ('should return -5 when -2 and -3 are used', () =&gt; {<br/>    expect(add(-2, -3)).toEqual(-5);  <br/>  });<br/>});</span></pre><p id="d954" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了。我们写下了我们的断言，但是很明显，我们必须按照<code class="fe mn mo mp me b">it</code>语句重复一点，对吗？如果我们仔细观察，我们会注意到每个断言唯一的变化是新的参数和预期的结果。</p><p id="b7fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如何解决这个问题？如果我们可以在一个地方只声明参数和预期的结果，然后以动态的方式调用每个组合的断言，那就太好了。</p><p id="2e3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用<code class="fe mn mo mp me b">it.each</code>来重构我们的测试:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="a416" class="lb lc iq me b gy mi mj l mk ml">describe('test add method', () =&gt; {<br/>  it.each`<br/>    a     | b     | result<br/>    ${2}  | ${3}  | ${5}<br/>    ${20} | ${30} | ${50}<br/>    ${-2} | ${-3} | ${-5}<br/>  `('should return $result when $a and $b are used', ({a, b, result}) =&gt; {<br/>    expect(add(a, b)).toEqual(result);<br/>  });<br/>});</span></pre><p id="05cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不错！！更少的样板文件，可读性更好，对吗？我们可以在眨眼之间检查预期的结果。</p><p id="3229" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将在控制台中返回以下结果:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/1a84bd0c46f1f6de6c92e7fdc2415394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YZt87ONVGZuDrxJ6_IP-A.png"/></div></div></figure><h2 id="7e8c" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">如何在ReactJS组件中使用它？</h2><p id="32a3" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">假设我们有以下<code class="fe mn mo mp me b">Button</code>组件:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c1c1" class="lb lc iq me b gy mi mj l mk ml">import React from 'react';<br/>import cn from 'classnames';<br/>import PropTypes from 'prop-types';</span><span id="853f" class="lb lc iq me b gy mm mj l mk ml">const Button = ({ isPrimary, isDanger, isSuccess }) =&gt; (<br/>  &lt;button<br/>    className={cn('button', {<br/>      'is-primary': isPrimary,<br/>      'is-danger': isDanger,<br/>      'is-success': isSuccess,<br/>    })}<br/>  /&gt;<br/>);</span><span id="1d23" class="lb lc iq me b gy mm mj l mk ml">Button.propTypes = {<br/>  isPrimary: PropTypes.bool,<br/>  isDanger: PropTypes.bool,<br/>  isSuccess: PropTypes.bool,<br/>};</span><span id="aa8d" class="lb lc iq me b gy mm mj l mk ml">Button.defaultProps = {<br/>  isPrimary: false,<br/>  isDanger: false,<br/>  isSuccess: false,<br/>};</span><span id="0091" class="lb lc iq me b gy mm mj l mk ml">export default Button;</span></pre><p id="c43b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以很容易地使用笑话，酶和。每个模式对所有这些类进行单元测试:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f437" class="lb lc iq me b gy mi mj l mk ml">import React from 'react';<br/>import { shallow } from 'enzyme';<br/>import Button from './Button';</span><span id="5f2f" class="lb lc iq me b gy mm mj l mk ml">let props;</span><span id="6764" class="lb lc iq me b gy mm mj l mk ml">beforeEach(() =&gt; {<br/>  props = {<br/>    isPrimary: false,<br/>    isDanger: false,<br/>    isSuccess: false,<br/>  };<br/>});</span><span id="883f" class="lb lc iq me b gy mm mj l mk ml">describe('test Button component', () =&gt; {<br/>  it.each`<br/>    propName       | propValue | className       | result<br/>    ${'isPrimary'} | ${true}   | ${'is-primary'} | ${true}<br/>    ${'isDanger'}  | ${true}   | ${'is-danger'}  | ${true}<br/>    ${'isSuccess'} | ${true}   | ${'is-success'} | ${true}<br/>  `('should have class $className when prop $propName is equal to $propValue', ({propName, propValue, className, result}) =&gt; {<br/>    props = { ...props, [propName]: propValue };<br/>    <em class="mr">const </em>enzymeWrapper = shallow(&lt;Button {...props} /&gt;);</span><span id="9b7a" class="lb lc iq me b gy mm mj l mk ml">    expect(enzymeWrapper.hasClass(className)).toEqual(result);<br/>  });<br/>});</span></pre><p id="07bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我很确定你已经知道这有多快和可伸缩了。让我们添加一些额外的断言来证明这一点:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9c80" class="lb lc iq me b gy mi mj l mk ml">it.each`<br/>  propName       | propValue | className       | result<br/>  ${'isPrimary'} | ${false}  | ${'is-primary'} | ${false}<br/>  ${'isDanger'}  | ${false}  | ${'is-danger'}  | ${false}<br/>  ${'isSuccess'} | ${false}  | ${'is-success'} | ${false}<br/>`('should have not class $className when prop $propName is equal to $propValue', ({propName, propValue, className, result}) =&gt; {<br/>  props = { ...props, [propName]: propValue };<br/>  <em class="mr">const </em>enzymeWrapper = shallow(&lt;Button {...props} /&gt;);</span><span id="70ca" class="lb lc iq me b gy mm mj l mk ml">  expect(enzymeWrapper.hasClass(className)).toEqual(result);<br/>});</span></pre><p id="9dce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">老实说，这些测试在现实生活中并不那么有用，因为它们检查的是<code class="fe mn mo mp me b">classnames</code>包是否完成了它的工作，这有点过度工程化😃</p><h2 id="7977" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="7599" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我很有信心，现在你知道如何利用。减少你在单元测试中必须一遍又一遍重复的无聊的样板代码。干杯！！</p></div></div>    
</body>
</html>