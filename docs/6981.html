<html>
<head>
<title>RISC vs CISC Microprocessor Philosophy in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2022年RISC vs CISC微处理器理念</h1>
<blockquote>原文：<a href="https://itnext.io/risc-vs-cisc-microprocessor-philosophy-in-2022-fa871861bc94?source=collection_archive---------0-----------------------#2022-05-04">https://itnext.io/risc-vs-cisc-microprocessor-philosophy-in-2022-fa871861bc94?source=collection_archive---------0-----------------------#2022-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2fc9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过将RISC与CISC的争论框定为如何花费有限的晶体管预算来实现性能的争论，来重新审视这场争论。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3bef6983cd610b8340f08cc80986c6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7H8qyo6GsZm36FVCGHk8pQ.png"/></div></div></figure><p id="a536" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">人们喜欢把RISC和CISC处理器之间的区别看作是一些特定的功能，或者是对指令或晶体管数量的某种神奇限制。</p><h1 id="9de8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">指令少不代表RISC</h1><p id="ceb5" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">让我们消除一些非常明显的误解。因为RISC代表<em class="mw">精简指令集计算机</em>，有很多人认为RISC处理器仅仅是一个指令很少的CPU。如果是这样的话，那么<a class="ae mx" href="https://en.wikipedia.org/wiki/MOS_Technology_6502" rel="noopener ugc nofollow" target="_blank"> 6502处理器</a>将会是有史以来最精简的处理器之一，只有56条指令。甚至英特尔8086也可以算作RISC处理器，因为它只有81条指令<a class="ae mx" href="https://en.wikipedia.org/wiki/X86_instruction_listings" rel="noopener ugc nofollow" target="_blank"/>。即使是后来的Intel 80286也只有100条左右的指令。</p><p id="6237" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像AVR这样的简单8位RISC处理器有<a class="ae mx" href="http://www.avr-asm-tutorial.net/avr_en/overview/overview.html" rel="noopener ugc nofollow" target="_blank"> 78条指令</a>。如果你看看第一个32位RISC处理器，比如PowerPC 601(1993年发布)，它有<a class="ae mx" href="https://www.ibm.com/docs/en/aix/7.1?topic=reference-appendix-g-powerpc-601-risc-microprocessor-instructions" rel="noopener ugc nofollow" target="_blank"> 273条指令</a>。</p><p id="b80d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从Berkley最初的RISC处理器衍生而来的MIPS32指令集也有200多条指令。</p><p id="6c8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以将其与CISC的32位处理器如80386进行比较，后者只有170多条指令。尽管在类似的时间(1986年)发布的MIPS R2000处理器有大约92条指令。</p><p id="890e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于古董:</p><ul class=""><li id="20e4" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated"><a class="ae mx" href="https://en.wikipedia.org/wiki/X86_instruction_listings" rel="noopener ugc nofollow" target="_blank"> x86指令列表</a></li><li id="f672" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae mx" href="https://eun.github.io/Intel-Pentium-Instruction-Set-Reference/data/index.html" rel="noopener ugc nofollow" target="_blank">奔腾指令集</a></li><li id="90c7" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae mx" href="https://www.masswerk.at/6502/6502_instruction_set.html" rel="noopener ugc nofollow" target="_blank"> 6502指令集</a></li><li id="4863" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae mx" href="http://ti.ira.uka.de/TI-2/Mips/Befehlssatz.pdf" rel="noopener ugc nofollow" target="_blank"> MIPS R2000指令集</a></li></ul><h1 id="1db3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">晶体管少不代表RISC</h1><p id="2d8f" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">这里有一个有趣的练习，去这篇维基百科文章:<a class="ae mx" href="https://en.wikipedia.org/wiki/Transistor_count" rel="noopener ugc nofollow" target="_blank">晶体管计数</a>。</p><p id="f468" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CISC处理器和RISC处理器之间晶体管数量的分界点是什么？哦，你找不到吗？那是因为没有。6502有4，528个晶体管。而第一个ARM处理器有25000个晶体管。</p><p id="231f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者这个有趣的小事实。摩托罗拉68060被认为是那个时代最精确的处理器之一，重250万个晶体管，少于1994年发布的IBM PowerPC 601的280万个晶体管。</p><p id="e66d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你看看几乎同时发布的RISC和CISC处理器，没有明显的趋势表明RISC处理器比CISC处理器有更少的晶体管和更少的指令。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nm"><img src="../Images/300d622f6af13134b4333707e89dd7c1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*e0g4QzicyzS_7f9gKwxAeA.png"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">20世纪90年代早期流行的RISC和CISC处理器的晶体管和指令数的比较</figcaption></figure><p id="fe3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，让我们得出这样的结论:不存在神奇数量的晶体管或指令能让你的芯片神奇地变成RISC或CISC芯片。但是问题依然存在，到底是什么造就了微处理器RISC或CISC？</p><h1 id="bc3b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">RISC和CISC是不同的晶体管预算哲学</h1><p id="4870" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">当你的老板告诉你“这里，有一百万个晶体管，让我成为一个快速处理器！”那么你有很多方法来实现这个目标。对于相同数量的晶体管，RISC和CISC设计者将做出不同的选择。</p><p id="4b19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">伯克利的大卫·a·帕特森最出名的可能是他在1980年发表的论文《精简指令集计算机的案例》中推广了RISC处理器的思想。</p><p id="b1d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">帕特森在这篇论文中概述的并不是芯片应该如何制造的详细蓝图，而更像是哲学指导方针。</p><ul class=""><li id="f2ed" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">在真实世界的程序中添加这条指令会带来多少性能提升？</li><li id="2415" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">有什么硬件含义？我们需要存储大量的复杂状态吗？由于需要存储大量的状态，这使得上下文切换和无序执行更加复杂。</li><li id="656b" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">一个设计良好的简单指令组合可以完成同样的工作，并且性能相当吗？</li><li id="c45b" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">我们是否可以利用现有的算术逻辑单元(alu)和CPU上的其他资源来添加这条指令，或者我们是否需要添加许多新的东西？</li><li id="0c54" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">如果不添加这条指令，这些晶体管的其他用途是什么？更多缓存？更好的分支预测器？</li></ul><p id="ccf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解这些规则适用于给定的晶体管预算是很重要的。如果你有更多的晶体管，你可以添加更多的指令，甚至是复杂的指令。</p><p id="9e29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，RISC哲学优先考虑保持ISA简单。这意味着RISC设计者将首先尝试通过<em class="mw">而不是添加指令来提高性能，例如:</em></p><ul class=""><li id="e056" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">使用晶体管增加更多高速缓存</li><li id="b157" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">更多CPU寄存器</li><li id="9807" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">更好的渠道</li><li id="40ce" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">更好的分支预测器</li><li id="6258" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">超标量体系结构</li><li id="f927" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">添加更多指令解码器</li><li id="604f" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">无序执行</li><li id="a287" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">宏观操作融合</li><li id="0e71" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">压缩指令</li></ul><p id="1697" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，当设计一个好的RISC指令集(ISA)时，一个关键的目标是使设计不妨碍未来的微体系结构优化。</p><p id="80b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与CISC设计师设计CPU的方式不同。CISC的设计者将添加复杂的指令，引入更多的状态来跟踪，如状态寄存器，如果这样能提供更好的性能。</p><h2 id="4eb5" class="nr ma it bd mb ns nt dn mf nu nv dp mj ld nw nx ml lh ny nz mn ll oa ob mp oc bi translated">CISC设计哲学的问题</h2><p id="2e66" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">问题是CISC的设计师没有超前思考。将来你的晶体管预算可能会增加。突然间，你得到了所有这些可以用来创建无序(OoO)超标量处理器逻辑的晶体管。这意味着您在每个时钟周期解码多条指令，并将它们放入指令队列。然后OoO逻辑计算出哪些指令不相互依赖，这样它们就可以并行运行。</p><p id="e415" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你是一名软件开发人员，你可以考虑一下函数式编程和命令式编程的区别。为了短期的性能收益而改变全局数据是很有诱惑力的。然而，一旦你并行运行，全局状态被多个函数改变，这些函数可以在多个线程中并行运行，这绝对是一场噩梦。</p><p id="7fb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数式编程更喜欢只依赖输入而不依赖全局数据的纯函数。这些功能可以很容易地并行运行。同样的机制也适用于CPU。不依赖于全局状态(如状态寄存器)的汇编代码指令可以更容易地并行或在流水线中运行。</p><p id="8cf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RISC-V是这种思想的一个很好的例子。RISC-V没有状态寄存器。比较和跳转指令合二为一。除非通过运行额外计算来确定是否发生了溢出，否则无法用状态寄存器捕获整数溢出。</p><p id="44df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这应该给你一些关于RISC和CISC之间区别的线索。</p><h2 id="8792" class="nr ma it bd mb ns nt dn mf nu nv dp mj ld nw nx ml lh ny nz mn ll oa ob mp oc bi translated">RISC处理器设计者的优先事项</h2><p id="aa6d" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">一个RISC设计者在增加10条新指令时不一定会有问题，如果这些指令对微体系结构没有显著影响的话。如果一条指令要求在CPU中表示更多的全局状态，RISC设计者将更不愿意添加该指令。</p><p id="9354" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种理念的最终结果是，在历史上，向RISC处理器添加诸如流水线和超标量架构之类的东西比CISC处理器更容易，因为人们避免了添加引入状态管理或控制逻辑的指令，这使得很难添加这些种类的微架构创新。</p><p id="53a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么RISC-V团队更喜欢进行宏操作融合，而不是添加支持复杂寻址模式或整数溢出检测的指令。如果你不知道什么是微操作融合，看看这些文章:</p><ul class=""><li id="f0c4" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated"><a class="ae mx" href="https://erik-engheim.medium.com/what-the-heck-is-a-micro-operation-e991f76209e" rel="noopener">微操作到底是个什么鬼？</a></li><li id="1968" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae mx" href="https://erik-engheim.medium.com/the-genius-of-risc-v-microprocessors-b19d735abaa6" rel="noopener">RISC-V微处理器的天才</a> —涵盖了宏操作融合在RISC-V中的使用</li></ul><p id="57e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，RISC理念导致了不断出现的特定设计选择，这使我们能够谈论一些更具体的差异，您将在比较RISC和CISC处理器时观察到这些差异。让我们看看这些。</p><h1 id="7b8d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">现代RISC和CISC处理器的特点</h1><p id="37a3" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">某些设计选择不断出现在许多不同的RISC处理器上。一个常见的模式是，RISC处理器往往有固定长度的32位指令。有一些例外，如AVR使用固定长度的16位指令。相比之下，英特尔x86处理器的指令长度为1至15字节。摩托罗拉68k处理器，另一个著名的CISC设计，有2到10字节长(16位到80位)的指令。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nm"><img src="../Images/0c98279b225449bdcf6a10febbf6ce86.png" data-original-src="https://miro.medium.com/v2/format:webp/1*S5p5zD2lJu9KpfNRmp1Zhw.png"/></div></figure><p id="cdc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">变长指令实际上对汇编程序员来说很方便。我的第一台电脑是Amiga 1000，它配有摩托罗拉68k处理器，所以它向我介绍了68k组件，坦白说，它非常简洁。它有将数据从一个存储位置移动到下一个存储位置的指令，或者你可以将数据从一个寄存器<code class="fe od oe of og b">A1</code>给定的地址移动到另一个寄存器<code class="fe od oe of og b">A2</code>给定的存储位置。</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="1220" class="nr ma it og b gy ol om l on oo">; 68k Assembly code<br/><br/>MOVE.B 4, 12      ; mem[4] → mem[12] <br/>MOVE.B (A1), (A2)   ; mem[A1] → mem[A2]</span></pre><p id="6d36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种指令使CPU易于编程，但这意味着没有办法将每个支持的指令都放在32位内，因为表达完整的源地址和目的地址将单独消耗64位。因此，通过使用可变长度指令，我们可以轻松地在任何指令中包含完整的32位内存地址。</p><p id="4566" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这种便利是有代价的。可变长度指令更难流水线化，如果你想让超标量处理器并行解码两条或更多条指令，你不容易做到，因为你不知道每条指令在哪里开始和结束，直到你解码它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/65553145d1bcfd5c1c423da067953762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hkmuCvILENN5eQnu4WJYA.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">对于超标量处理器，你有多个并行工作的指令解码器。</figcaption></figure><p id="8250" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果流水线和超标量听起来像天书，那么读读这些故事:</p><ul class=""><li id="3bd2" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated"><a class="ae mx" href="https://erik-engheim.medium.com/microprocessor-pipelining-f63df4ee60cf" rel="noopener">为什么要流水线化一个微处理器？</a> —什么是指令流水线及其优势。</li><li id="4ed6" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae mx" href="https://erik-engheim.medium.com/very-long-instruction-word-microprocessors-17262def3037" rel="noopener">超长指令字微处理器</a> —更深入地解释超标量微处理器。</li></ul><p id="1a01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RISC处理器倾向于避免可变长度指令，因为它们打破了不添加指令的RISC哲学，这使得添加更高级的微架构优化更加困难。</p><p id="575c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">固定长度的指令造成不便。您不能将内存地址放入任何操作中，只能放入特定的操作中，如加载和存储指令。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nm"><img src="../Images/f26c8df3d42254ed895d0aa245eea251.png" data-original-src="https://miro.medium.com/v2/format:webp/1*AKhZB0haTnPfVmA8pXEAew.png"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">RISC处理器中的算术逻辑单元(ALU)只能从寄存器中获取输入，而不能从内存中获取</figcaption></figure><h2 id="75a9" class="nr ma it bd mb ns nt dn mf nu nv dp mj ld nw nx ml lh ny nz mn ll oa ob mp oc bi translated">加载/存储架构</h2><p id="325a" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">机器代码指令必须对关于正在执行什么信息的信息进行编码，例如它是否正在执行<code class="fe od oe of og b">ADD</code>、<code class="fe od oe of og b">SUB</code>或<code class="fe od oe of og b">MUL</code>。它还必须对其输入信息进行编码。什么是输入寄存器和输出寄存器。一些指令需要对我们试图从哪个地址加载数据进行编码。在RISC-V中，指令是这样编码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/4ab95361345fe172274b53e8dd5facc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lnodjYuUXHKz6kGh5DVODQ.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">展示了如何使用32位字中的每一位对RISC-V指令集的指令进行编码</figcaption></figure><p id="d810" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们执行的特定指令称为操作码(黄色)，它消耗7位。我们指定的每个寄存器输入或输出都需要5位。由此应该很清楚，挤进一个32位的地址是不可能的。甚至更短的地址也很难，因为你需要位来指定操作中使用的寄存器。有了CISC处理器，这就不成问题了，因为你可以自由地执行超过32位的指令。</p><p id="87ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种紧凑的空间要求导致RISC处理器具有我们所说的加载/存储结构。只有RISC-V上的<code class="fe od oe of og b">LW</code>和<code class="fe od oe of og b">SW</code>等专用加载和存储指令才能用于访问内存。</p><p id="37b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用CISC处理器，如68k，几乎任何操作，如<code class="fe od oe of og b">ADD</code>、<code class="fe od oe of og b">SUB</code>、<code class="fe od oe of og b">AND</code>和<code class="fe od oe of og b">OR</code>，都可以使用内存地址作为操作数(参数)。在下面的例子中，<code class="fe od oe of og b">4(A2)</code>计算一个内存地址，我们用它来读取<code class="fe od oe of og b">ADD</code>指令的一个操作数(参数)。最终结果也存储在那里(在68k destination上是右参数)。</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="e1c3" class="nr ma it og b gy ol om l on oo">; 68k assembly<br/>ADD.L D3, 4(A2)  ; D3 + mem[4 + A2] → mem[4 + A2]</span></pre><p id="5700" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">典型的RISC处理器，如基于RISC-V指令集的处理器，需要将加载(<code class="fe od oe of og b">LW</code>)和存储(<code class="fe od oe of og b">SW</code>)作为单独的指令存储到存储器中。</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="1c88" class="nr ma it og b gy ol om l on oo"># RISC-V assembly<br/>LW  x4, 4(x2)      # x4 ← mem[x2+4] <br/>ADD x3, x4, x3     # x3 ← x4 + x3 <br/>SW  x3, 4(x2)      # x3 → mem[x2+4]</span></pre><p id="449d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不需要结合地址寄存器(<code class="fe od oe of og b">A0</code>到<code class="fe od oe of og b">A7</code>)来计算地址。你可以直接指定一个内存地址，比如400:</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="9e33" class="nr ma it og b gy ol om l on oo">; 68k assembly<br/>ADD.L 400, D4     ; mem[400] + D4 → D4</span></pre><p id="886b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是即使像这样看似简单的操作也需要多条RISC指令。</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="ea4f" class="nr ma it og b gy ol om l on oo"># RISC-V assembly<br/>LW  x2, 400(x0)    # x3 ← mem[x0 + 400] <br/>ADD x4, x4, x3     # x4 ← x4 + x3</span></pre><p id="4c3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在许多RISC设计中,<code class="fe od oe of og b">x0</code>寄存器总是为零，这意味着即使你只对绝对内存地址感兴趣，你也可以使用偏移加基址寄存器的形式。虽然这些偏移量看起来非常类似于您在68k上所做的，但它们要有限得多，因为您总是需要适应32位字。有了68k你可以给<code class="fe od oe of og b">ADD.L</code>一个完整的32位地址。你不能用RISC-V <code class="fe od oe of og b">LW</code>和<code class="fe od oe of og b">SW</code>。获取完整的32位地址相当麻烦。比方说你想从32位地址<code class="fe od oe of og b">0x00042012</code>加载数据，你必须分别加载高20位和低12位来形成一个32位地址。</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="3067" class="nr ma it og b gy ol om l on oo"># RISC-V assembly<br/>LUI  x3, 0x42        # x3[31:12] ← 0x42  put in upper 20-bits<br/>ADDI x3, x3, 0x12    # x3 ← x3 + x3 + 0x12 <br/><br/>LW x4, 0(x3)         # x4 ← mem[x3+0]</span></pre><p id="b86f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上这可以简化为:<code class="fe od oe of og b"> LUI x3, 0x42 LW x4, 0x12(x3)</code></p><p id="1cdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我记得当我从68k汇编过渡到PowerPC(苹果以前使用的RISC处理器)时，这让我很恼火。当时我认为RISC意味着一切都将变得容易得多。我发现x86很混乱，很难处理。然而，对于汇编代码来说，RISC不如68k这样好的CISC指令集使用起来方便。幸运的是，在RISC处理器上有一些简单的技巧可以使这变得更容易。RISC-V定义了许多伪指令，使汇编代码编写更容易。使用<code class="fe od oe of og b">LA</code>(加载地址)伪指令，我们可以像这样编写前面的代码:</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="28d1" class="nr ma it og b gy ol om l on oo"># RISC-V assembly with pseudo instructions<br/>LI x3, 0x00042012   # Expands to a LUI and ADDI<br/>LW x4, 0(x3)</span></pre><p id="36cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总结:虽然加载/存储架构使得编写汇编代码更加麻烦，但是它允许我们保持每条指令32位长。这意味着创建一个超标量微体系结构，可以并行解码多条指令，实现成本更少的晶体管。流水线处理每条指令变得更加容易，因为它们中的大部分可以适合经典的5步RISC流水线。</p><h2 id="3290" class="nr ma it bd mb ns nt dn mf nu nv dp mj ld nw nx ml lh ny nz mn ll oa ob mp oc bi translated">RISC处理器有很多寄存器</h2><p id="4546" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">有了像68k这样的CISC处理器，你可以用一条指令做很多事情。假设您想将数字从一个数组复制到另一个数组。下面是一个用C语言设计的使用指针的例子:</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="b6ba" class="nr ma it og b gy ol om l on oo">// C code<br/>int data[4] = {4, 8, 1, 2, -1};<br/>int *src = data;<br/><br/>while (*xs &gt; 0)<br/>    *dst++ = *src++;</span></pre><p id="3a89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您将指针<code class="fe od oe of og b">src</code>存储在68k处理器的地址寄存器<code class="fe od oe of og b">A0</code>中，并将<code class="fe od oe of og b">dst</code>存储在地址寄存器<code class="fe od oe of og b">A1</code>中，您可以在一条指令中复制并推进每个指针4个字节:</p><pre class="kj kk kl km gt oh og oi oj aw ok bi"><span id="9cea" class="nr ma it og b gy ol om l on oo">; 68k assembly<br/><br/>MOVE.L  (A0)+,(A1)+   ; mem[A1++] → mem[A2++]</span></pre><p id="a9e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这只是一个例子，但一般来说，你可以做更多的CISC指令。这意味着您需要更少的代码。RISC设计者因此意识到他们的代码会变得臃肿。因此，RISC设计者分析真实代码，提出不使用复杂指令就能减少代码大小的方案。他们发现大量代码只是简单地从内存中加载和存储数据。通过增加许多寄存器，可以将临时结果保存在寄存器中，而不用将它们写到存储器中。这将减少需要执行的加载和存储指令的数量，从而减少代码RISC代码的大小。</p><p id="a332" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，MIPS、SPARC、Arm (64位)和RISC-V处理器都有32个通用寄存器。我们可以将其与只有8个通用寄存器的原始x86进行对比。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nm"><img src="../Images/791dc9f483789b9bafc4d81af9365181.png" data-original-src="https://miro.medium.com/v2/format:webp/1*kHYxK_WgivrAI3bIiWhZcQ.png"/></div></figure><h1 id="c2ff" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">从RISC/CISC的角度看复杂性</h1><p id="aff2" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在这个故事中，我想表达的是，RISC处理器并不比CISC处理器更先进。区别在于RISC和CISC设计者选择增加复杂性的地方。</p><p id="997d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CISC设计师将复杂性放在指令集架构(ISA)中，而RISC设计师宁愿将复杂性添加到他们的微架构中，但正如我一直强调的那样，他们不希望ISA将复杂性强加到微架构中。</p><p id="5051" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我在MIPS R4000、摩托罗拉68040和英特尔486之间做一个比较，以强调这种理念上的差异。他们每个人都有大约120万个晶体管，并在同一时间(1989年至1991年)发布。</p><ul class=""><li id="fd59" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated">RISC处理器(R4000)是64位的，其他的是32位的。</li><li id="4099" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">R4000具有8级流水线，比6级流水线的68040和5级流水线的486允许更高的时钟频率。</li><li id="4ee1" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated">更长的管道使R4000从100-200 Mhz远远超过68040的40Mhz，486DX2达到66Mhz(在更晚的型号中为100Mhz)。</li></ul><p id="481b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最终，在1993/1994年，人们得到了更快的CISC处理器，如68060和奔腾。但同时出现了MIPS R8000，它是一种超标量体系结构，可以并行解码4条指令。奔腾处理器每个时钟周期只能解码2条指令。</p><p id="4cc0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们可以看到RISC设计者是如何偏爱花哨的微体系结构而不是花哨的指令的。</p><h1 id="7552" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">"但是现代CISC处理器有复杂的微结构！"</h1><p id="01ea" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">你可能会抗议说，今天的CISC处理器有复杂的微体系结构。的确如此。现代英特尔或AMD处理器具有多个解码器、微操作高速缓存、高级分支预测器、无序(OoO)执行引擎。然而，这并不奇怪。记住我关于晶体管预算哲学的关键点:今天每个人都有很多晶体管可以使用，所以所有高端芯片都将有很多先进的微架构功能。他们可以用给他们的预算负担得起。</p><p id="bd83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有个问题:许多复杂的微架构特性是由复杂的CISC指令集强加的。让我举几个例子。为了使流水线工作，x86处理器把它们复杂的长指令分解成微操作。微操作很简单，行为更像RISC操作，因此更容易流水线化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/1574cb2b58efd8227e7541f8a9c65852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*titoeiXLVZ-jBgaktnxJ2w.png"/></div></div></figure><p id="fcc6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">问题是将CISC指令分解成更简单的微操作并不容易。因此，许多现代超标量x86处理器具有3个用于简单指令的指令解码器和1个用于复杂指令的解码器。由于你不知道每条指令的开始和结束，CISC处理器不得不参与一个复杂的涉及许多晶体管的猜谜游戏。</p><p id="3d10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RISC处理器避免了这种复杂性，可以将所有浪费的晶体管用于添加更多解码器或进行其他优化，如使用压缩指令或宏操作融合(将非常简单的指令组合成更复杂的指令)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/69b96114aec5b731e7aaba75016d0e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YIVBiaVURbXxbYYh5xDCcA.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">在不同的CPU设计中，指令组合或分解的不同方式。</figcaption></figure><p id="347e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你将苹果公司的M1处理器与AMD和Intel处理器进行比较，你会发现它有更多的指令解码器。CISC的设计者试图通过添加微操作缓存来缓解这个问题。有了微操作高速缓存，CISC处理器就不必一次又一次地通过障碍或解码相同的复杂指令。然而，增加这一功能显然会增加晶体管成本。它不是免费的。因此，你在微结构复杂性上浪费了晶体管预算，这是因为你的ISA的复杂性才需要的。</p><h1 id="c373" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Arm与RISC-V设计理念</h1><p id="6da8" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">比较现代RISC和CISC处理器的一个问题是，RISC基本上赢了。没有人再从头开始设计CISC处理器了。Intel和AMD的x86处理器今天之所以受欢迎，主要是因为向后兼容。</p><blockquote class="ot"><p id="460f" class="ou ov it bd ow ox oy oz pa pb pc lp dk translated">如果你今天让一个设计团队坐下来，告诉他们从头开始设计一款高性能处理器，那么你不会得到传统的CISC设计。</p></blockquote><p id="1933" class="pw-post-body-paragraph ku kv it kw b kx pd ju kz la pe jx lc ld pf lf lg lh pg lj lk ll ph ln lo lp im bi translated">然而，这并不意味着RISC社区在设计者倾向于CISC还是RISC方向上没有差异。现代Arm处理器和基于RISC-V的处理器是这种对比的有趣例子。</p><p id="7a1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Arm设计人员更愿意添加复杂的指令来获得性能。请记住，不启动不是RISC设计。随着晶体管预算的增长，增加更复杂的指令是公平的。</p><p id="371c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RISC-V设计人员更热衷于将ISA的复杂性保持在最低水平，而不是通过使用压缩指令和宏操作融合等技巧来增加微体系结构的复杂性以获得性能。我在这里讨论这些设计选择:<a class="ae mx" href="https://erik-engheim.medium.com/the-genius-of-risc-v-microprocessors-b19d735abaa6" rel="noopener">RISC-V微处理器的天才。</a></p><p id="4d1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Arm和RISC-V的不同选择不是随意的，而是受到非常不同的目标和市场的严重影响。Arm越来越多地涉足高端市场。请记住，苹果的Arm芯片正在与x86芯片进行正面竞争，不久Nvidia也会这样做。</p><p id="89cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RISC-V的目标是成为一个更广泛的架构，用于从键盘到人工智能加速器，从GPU到专门的超级计算机的任何东西。这意味着RISC-V意味着灵活性，你添加的指令越复杂，你强加的复杂性就越小，从而减少了为特定用例定制芯片的自由。</p><h1 id="309b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">资源和相关文章</h1><p id="7456" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">参考资料和我写的关于这个主题的相关文章。</p><p id="11e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2020年的RISC和CISC意味着什么？——我思考这个话题的最初尝试之一。</p><p id="be72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mx" href="https://erik-engheim.medium.com/demystifying-risc-microprocessors-philosophy-f6303f6c0f7f" rel="noopener">RISC哲学</a>——我第一次想到RISC是一种设计哲学，而不是一系列功能的复选框。</p><p id="97dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mx" href="https://medium.com/itnext/advantages-of-risc-v-vector-processing-over-x86-simd-c1b72f3a3e82" rel="noopener">RISC-V矢量处理相对于x86风格SIMD的优势</a> —用矢量处理代替SIMD指令进行数据并行的优势。</p><p id="2da8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">IBM 801——被认为是第一个RISC处理器</p></div></div>    
</body>
</html>