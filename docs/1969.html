<html>
<head>
<title>How to automate your releases, versioning &amp; release notes like a boss</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何像老板一样自动化你的发布、版本控制和发布说明</h1>
<blockquote>原文：<a href="https://itnext.io/automate-your-releases-versioning-and-release-notes-with-semantic-release-d5575b73d986?source=collection_archive---------0-----------------------#2019-03-05">https://itnext.io/automate-your-releases-versioning-and-release-notes-with-semantic-release-d5575b73d986?source=collection_archive---------0-----------------------#2019-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bc18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将探索如何通过<a class="ae kl" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>来自动化发布、变更日志、发布说明生成和语义版本化</p><p id="a073" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我告诉你，只需一个命令，你就可以:</p><ol class=""><li id="b3b8" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">将package.json版本升级到正确的版本</li><li id="dc73" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">创建一个github版本</li><li id="3c0e" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">创建git标签</li><li id="1dd9" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">生成包含发行说明的变更日志</li><li id="992c" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">将更改推送到您的git存储库</li><li id="3d21" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">将您的包发布到npm</li></ol><h2 id="a876" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">动机</h2><p id="416a" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">无论您是有一个开源项目，还是在一家私人公司从事一个其他人在他们的项目中使用的项目，您可能都需要传达您对项目所做的更改，以便其他人可以了解什么发生了更改，并知道是否有任何重大更改。您可能希望自动化您的发布的一些原因是:</p><ol class=""><li id="4c2a" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">遵循语义版本控制，以便向消费者反映项目变更，并区分功能发布、错误修复和重大变更。</li><li id="d5aa" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">生成发行说明/变更日志，以便使用您的库的其他开发人员能够理解每个版本中包含的确切变更及其含义。</li><li id="4045" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">向客户和/或项目经理传达变更。</li><li id="4a2d" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">使发布成为您持续集成系统的一部分。</li><li id="1a3f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">手动生成发行版、修改版本和创建发行说明的过程可能会很痛苦、容易出错且情绪化。</li><li id="1721" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">自动创建一个git标签，并在npm上发布新版本的库。</li></ol><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/11a6a89f8769ec8fd27b7f3d9ff9e20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_PIl6U0oY2qsulaMU6Vmg.jpeg"/></div></figure><p id="fefa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对你的发布分支所做的每一个拉取请求或者提交都会自动地为你生成一个变更日志，计算出需要的版本变动，为你变动版本并且自动地发布你的库，会怎么样？</p><p id="694f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遇见<a class="ae kl" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>。在我们设置之前，使用语义发布有两个要求:“语义版本控制”和“常规提交”。</p><h2 id="ce88" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">语义版本控制</h2><p id="f4c3" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">语义版本化提供了一种获得代表项目开发的有意义的版本号的方法。</p><blockquote class="mg mh mi"><p id="f07a" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">给定主要版本号。小调。补丁，增加:</p><p id="8b2d" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">主要版本当您进行不兼容的API更改时，</p><p id="75c1" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">当您以向后兼容的方式添加功能时，次要版本</p><p id="9975" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">补丁版本当你做向后兼容的bug修复。</p><p id="6ea2" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">预发布和构建元数据的附加标签可作为主标签的扩展。小调。补丁格式。</p></blockquote><h2 id="6132" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">常规提交</h2><blockquote class="mg mh mi"><p id="7ba4" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">常规提交是一种规范，用于向提交消息添加人类和机器可读的含义</p></blockquote><p id="0e00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉传统提交，看看<a class="ae kl" href="https://www.conventionalcommits.org/en/v1.0.0-beta.2/" rel="noopener ugc nofollow" target="_blank">传统提交</a>或<a class="ae kl" href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#commits" rel="noopener ugc nofollow" target="_blank">角度提交风格</a>。基本上，您的提交消息应该以下列之一开始。</p><ul class=""><li id="b225" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk mn ks kt ku bi translated"><em class="mj">专长:新功能</em></li><li id="ec29" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk mn ks kt ku bi translated"><em class="mj">修复:一个错误修复</em></li><li id="27dc" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk mn ks kt ku bi translated"><em class="mj">文档:仅文档变更</em></li><li id="8c51" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk mn ks kt ku bi translated"><em class="mj">样式:不影响代码含义的更改(空白、格式、缺少分号等)</em></li><li id="5565" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk mn ks kt ku bi translated"><em class="mj">重构:既不修复bug也不增加特性的代码变化</em></li><li id="86fd" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk mn ks kt ku bi translated"><em class="mj"> perf:改进性能的代码更改</em></li><li id="227f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk mn ks kt ku bi translated"><em class="mj">测试:添加缺失或修正现有测试</em></li><li id="5b39" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk mn ks kt ku bi translated"><em class="mj">苦差事:变更构建过程或辅助工具和库，如文档生成</em></li></ul><h1 id="c8f9" class="mo lb iq bd lc mp mq mr lf ms mt mu li mv mw mx ll my mz na lo nb nc nd lr ne bi translated">语义发布配置</h1><p id="0bf4" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">现在来看实际设置:</p><p id="7c7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.首先你需要安装semantic-release和基于你的配置你想要使用的插件，你可以在这里看到所有可用插件的列表<a class="ae kl" href="https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/plugins.md" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="lz ma mb mc gt nf ng nh ni aw nj bi"><span id="b5c4" class="la lb iq ng b gy nk nl l nm nn">npm i -D semantic-release @semantic-release/{git,commit-analyzer,release-notes-generator,npm,changelog}<!-- --> </span></pre><p id="f3cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.接下来，按照文档<a class="ae kl" href="https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/configuration.md#configuration" rel="noopener ugc nofollow" target="_blank">这里</a>根据自己的需求配置语义发布。我的个人配置如下:</p><pre class="lz ma mb mc gt nf ng nh ni aw nj bi"><span id="6b7a" class="la lb iq ng b gy nk nl l nm nn">// package.json<br/>"release": {<br/>     "plugins": [<br/>      "@semantic-release/commit-analyzer",<br/>      "@semantic-release/release-notes-generator",<br/>// if you dont want to publish on npm registry, you can set npmPublish to false </span><span id="b853" class="la lb iq ng b gy no nl l nm nn">      ["@semantic-release/npm",{"<!-- -->npmPublish"<!-- -->:false}],<br/>      "@semantic-release/changelog",<br/>      "@semantic-release/git"<br/>    ],<br/>    "branch": "master"<br/>  }</span></pre><p id="2730" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.现在，您应该能够通过从您的持续集成系统运行<code class="fe np nq nr ng b">npx semantic-release</code>来自动创建一个发布，或者甚至使用<code class="fe np nq nr ng b">--no-ci</code>标志手动创建。</p><h1 id="4d14" class="mo lb iq bd lc mp mq mr lf ms mt mu li mv mw mx ll my mz na lo nb nc nd lr ne bi translated">持续集成设置</h1><h2 id="8ce2" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">使用Github手动释放</h2><p id="17c6" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">你所需要的只是设置一个<code class="fe np nq nr ng b">GH_TOKEN</code>环境变量，然后你就可以开始了。</p><h2 id="d2ef" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">使用位桶管道</h2><p id="fac7" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">您可以使用以下<a class="ae kl" href="https://github.com/semantic-release/semantic-release/blob/master/docs/recipes/README.md" rel="noopener ugc nofollow" target="_blank"> CI方法</a>之一，在我的例子中，我使用了一个私有的bitbucket存储库和管道作为CI，以及一个私有的npm注册表，我想将我的库发布到其中，所以我们需要做一些额外的工作。</p><ol class=""><li id="92a2" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">您可以按照npm提供的步骤<a class="ae kl" href="https://npme.npmjs.com/docs/tutorials/pipelines.html" rel="noopener ugc nofollow" target="_blank">使用您的私有注册表和npm令牌来配置管道。</a></li><li id="278a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">首先，我们需要访问我们的CI，以便在npm上发布我们的库，并设置我们正在使用的npm注册中心，以防我们发布到私有注册中心。我们可以通过在存储库的管道设置中设置<code class="fe np nq nr ng b">NPM_REGISTRY_URL</code> &amp; <code class="fe np nq nr ng b">NPM_TOKEN</code>环境变量来做到这一点。</li><li id="80c6" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">从存储库的pipelines settings on bit bucket向您的pipelines设置添加一个SSH密钥，以便它可以访问私有存储库并可以推送release标记。</li><li id="9254" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">在存储库的根目录下创建一个<code class="fe np nq nr ng b">bitbucket-pipelines.yml</code>,它将配置构建管道并通过npx触发语义发布。</li></ol><pre class="lz ma mb mc gt nf ng nh ni aw nj bi"><span id="d11b" class="la lb iq ng b gy nk nl l nm nn"># This is a sample build configuration for JavaScript.<br/># Check our guides at https://confluence.atlassian.com/x/14UWN for more examples.<br/># Only use spaces to indent your .yml configuration.<br/># -----<br/># You can specify a custom docker image from Docker Hub as your build environment.<br/>image: node:latest</span><span id="3786" class="la lb iq ng b gy no nl l nm nn">pipelines:<br/>  default:<br/>    - step:<br/>        caches:<br/>          - node<br/>        script: # Modify the commands below to build your repository.<br/>          # Generates a .npmrc file configured for installing private modules:<br/>          #<br/>          # NPM_REGISTRY_URL: the full URL of your private registry<br/>          #                   defaults to registry.npmjs.org.<br/>          # NPM_TOKEN: secret token for installing private modules. This<br/>          #            this token can be found in your .npmrc, after logging in.<br/>          - printf "//`node -p \"require('url').parse(process.env.NPM_REGISTRY_URL || 'https://registry.npmjs.org').host\"`/:_authToken=${NPM_TOKEN}\nregistry=${NPM_REGISTRY_URL:-https://registry.npmjs.org}\n" &gt;&gt; ~/.npmrc<br/>          - npm install<br/>          - npm test<br/>          - npx semantic-release</span></pre><p id="a304" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你设置正确，现在每个提交都会在主分支触发一个释放并执行配置好的插件。当合并特性拉请求时，您可以使用挤压合并策略，该策略将多个提交的整个拉请求挤压成单个提交，您甚至可以将提交消息更改为传统的提交样式。</p><p id="4f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">制作一个传统提交风格的提交消息，将其合并到主分支，然后观察奇迹的发生。</p><p id="56e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个新的管道被触发并被标记为绿色，语义释放推送一个新的提交，基于以前的提交生成CHANGELOG.md文件，一个新的git标记用语义正确的版本创建，并且该包被发布到我的私有npm注册表。很棒，不是吗？</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/ebfbfe71d1bfbac1c30cfb3d291ab40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVABA0PRhm0SBoCvl_iKpA.png"/></div></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nx"><img src="../Images/8d8330e33de9ce7328f3e905c0e577f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pxh5zuzSCSyfArEZI5l6ew.png"/></div></div></figure></div></div>    
</body>
</html>