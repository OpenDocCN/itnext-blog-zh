# 打字稿中的延续

> 原文：<https://itnext.io/continuations-in-typescript-db18402010bc?source=collection_archive---------0----------------------->

## 提取打字稿中的常见模式

![](img/59e08aa07f329907fa78eaf311c11f7a.png)

由[布鲁诺·菲格雷多](https://unsplash.com/@bfigas?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/waiting-train-station?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

开发用户界面的一个主要挑战是处理由用户交互触发的事件。不仅在任何给定的时间可能发生许多可能的事件，事件被触发的顺序也是可变的(或者它们可以同时发生)。在这些事件之外，JavaScript 应用程序必须处理其他异步代码，比如处理 API 调用。

在 JavaScript 发展到今天的几十年中，有许多方法可以编写异步代码。从 html 中的事件侦听器、JQuery 的 callback-hell 和 React 组件的 onChange 属性，仅举几个大多数人都知道的例子。在这个疯狂的旅程中，出现了一些有问题的模式和特别的解决方案，结果并不像希望的那样理想。

在这篇文章中，我想寻找一种方法来处理“代码在其他事情发生时发生”的想法，这种想法有一个更正式和数学的背景，希望能帮助你对所有这些模式的共同基础有一个直觉。这绝不是对它们的替代，而是对所有这一切进行逻辑推理的一种方式的阐述。

# 什么是延续？

所有处理事件的方式都有一些概念上的相似之处:我们有一些在其他事情发生后运行的代码。在引言的所有例子中，你可以看到，无论我们用哪种方式处理事件，我们都有两样东西:我们等待发生的事情和我们事后做的事情。就命令式代码而言，我们可以说我们一直等到继续执行我们的代码。这就是延续的名字来源:我们在某事发生后继续。那么延续是什么样子的呢？事实上很简单。它们只不过是一个将回调作为参数的函数:

请注意，长名称“continuation”通常简称为“cont”

虽然这是延续的正确定义，但我想使用一个稍微不同的定义，将上面的类型包装在一个接口中。这样做的好处是，我们可以为后续定义的操作使用流畅的 api:

可以看到，`run`属性的定义和之前的定义完全一样。在这个类型中，我们可以向`Cont`类型添加更多的方法来定义我们所有的操作。但是到底什么是延续呢？

对于老式的 JavaScript 回调，我们真正关注的是回调:整个模式的中心是为异步函数提供回调，当这些函数完成时，这些函数就会被调用。对于延续，我们喜欢反过来推理:我们有在特定时间输出值的东西。这里的焦点是输出的东西，而不是之后发生的逻辑。对于延续，我们将围绕这个还没有值的对象进行推理和编程，但最终会有一个值。对于 JavaScript 来说，这有一个额外的好处，那就是不必真正关心我们如何注册事件侦听器(这是一直在变化的)，而是将它隐藏在那些最终将包含值的对象的库后面。我们将提供的回调现在只不过是延续世界和其余代码之间的连接器。

# 定义延续

熟悉函数式编程的读者会注意到上一段中的一个常见模式。在函数式编程中，许多令人兴奋的事情发生在抽象概念周围，这些抽象概念就像一个内部有值的魔盒。事实证明，回调的模式确实是单子。如果你还没有得到单子，不要担心，我将尝试保持一切实用，并用例子说明。

延续的第一个特性是我们可以将其输出从一种类型转换为另一种类型。图片你有[一个](https://gist.github.com/WimJongeneel/bcf2c0eebb9c44360f39f064550fb3b8) `[keyboard](https://gist.github.com/WimJongeneel/bcf2c0eebb9c44360f39f064550fb3b8)` [延续](https://gist.github.com/WimJongeneel/bcf2c0eebb9c44360f39f064550fb3b8)当一个按钮被按下时输出一个 JavaScript `Event`，你有一个函数`displayKeycode`打印一个字符串。使用`map`函数，您可以将键盘延续转换为字符串延续，并提供对结果的回调。下面显示了一个示例:

`map`是一个方法，它将一个函数从你的延续类型(`a`)转换成你想要的延续类型(通常称为`b`)。使用`map`,我们可以将不兼容类型的延续和回调结合在一起。我们的`Cont`类型的新定义如下:

另一种将延续转换成单子的方法是`bind`方法。然而，在 TypeScript 中名字`bind`已经被用来绑定函数的范围，所以我将使用`then`来代替。`then`是一个方法，它基于我们已经拥有的延续的值创建一个新的延续。这样，我们可以将多个延续链接到一个更大的异步流程中。让我们回到之前的例子，键盘延续和图像，我们希望在按钮被按下和代码被显示之间增加一些延迟。为此我们可以使用一个延续`wait`，在一定时间后输出你给它的值([实际上是](https://gist.github.com/WimJongeneel/d41727471d3071f25626118c7a0f3a38) `[setTimeout](https://gist.github.com/WimJongeneel/d41727471d3071f25626118c7a0f3a38)` [作为延续)](https://gist.github.com/WimJongeneel/d41727471d3071f25626118c7a0f3a38)。我们用它编写的代码如下所示:

如果我们将`then`添加到`Cont`的定义中，那么我们将得到如下所示的完整定义。对于那些感兴趣的人来说，从调用回调的函数构造一个`Cont`的代码可以在[这个片段](https://gist.github.com/WimJongeneel/f2951c238604c860f63fae639f8a074a)中找到。

# 延续和承诺

承诺是 JavaScript 中一个非常受欢迎的结束回调的附加功能——大多数使用过 JQuery 的人都会记得。碰巧的是，承诺和延续是基于非常相似的想法。然而，有一些主要的差异。其中之一是承诺有一个自动连接机制，将承诺中的每一个承诺直接变成承诺。其结果是承诺上的`map`和`then`是相同的(因此没有承诺上的 map 方法)。另一个主要区别是，只承诺输出一次，而不是可能输出多次。最后，promise 有一个用于错误处理的`then`和`catch`处理程序，而不是只有一个处理程序(参见[我关于铁路编程的文章](/railroad-programming-in-typescript-21d69f486f6e)了解一种适用于延续的错误处理函数方法)。

但是说到底，承诺和延续都处理异步代码，所以将承诺转换成延续是可能的(注意，这将总是输出一次):

承诺的一个重要属性是它们是热切的，这意味着当你对某个过程做出承诺时，那个过程总是在运行。对于我们的库来说，这可能有点奇怪，因为只有当我们调用`run`时，延续才会开始输出东西。对于上面显示的 promise 适配器，在我们向它添加回调之前，当 promise 设置时，我们可能会“错过”值。为此，更实际的做法是使用懒惰的承诺。惰性承诺是一个从零个参数返回承诺的函数。因为 promise 只是在我们调用这个函数之后构造的，所以我们可以控制异步流程何时开始运行，并将其与我们的 continuations 很好地集成在一起。

# 连续组合子

现在我们已经定义了我们的抽象并看到了一些例子，是时候看看一些更高级的概念了。延续的一个非常强大的特性是它们支持大量的组合子。组合子是一个函数，它接受多个延拓，并把它们变成一个单独的延拓。

有各种通用的可重用的组合子，但是你也可以创建非常特殊的组合子来满足你自己的需要。我首先想看的最常见的泛型组合子是`any`。`any`接受一个延续数组，并返回一个延续，只要其中一个延续输出一个值，该延续就输出一个值。

这是最常用的组合子，因为它是将输出的事物组合成单一输出的事物的最自然的方式。请注意，这个组合子不可能为承诺定义，因为您返回的承诺只能输出一次。另一个常见的组合子是`race`。`race`也适用于承诺，对应急也有同样的作用:

关于`race`的实现，值得注意的一个有趣事实是，我们重用了`any`，但将其限制为仅输出一次。且听下回分解，`once`如何实行。(实际上，尝试实现承诺的`any`可能会导致`race`)在这两个函数之外，我们还可以创建一个等待所有延续输出的`all`，一个在两个延续输出时给出结果对的`zip`，等等。

# 延续装饰者

高阶延拓是由另一个延拓构造的延拓。这种模式在 OOP 中也称为装饰模式。`once`就是这样一个装饰器，它将一个延续限制为只有一个输出，本质上是将它变成一个承诺。

另一个非常有用的装饰器是`filter`。`filter`用谓词过滤延续的输出。这个函数也可以添加到我们为 continuation 创建的 fluent api 中，以便能够以类似于我们在数组上使用 filter 的方式调用 filter。

这里要做的一个有趣的观察是，延拓的工作方式类似于值的集合。当我们将承诺转换为延续时，我们已经注意到延续可以输出多个值，但现在我们看到它们可以被视为真正的集合。它们只在一段时间内输出它们的值，而不能立即输出所有的值(有些人可能也知道这是异步流)。这意味着为集合而存在的所有方法也可以为延续而实现。例如，`skip`和`take`可以为延续实现:

# 结论

你们中的一些人可能已经认识到我在 [RxJS](https://github.com/ReactiveX/rxjs) 中描述的许多概念。事实上，RxJs 是一个基于相同概念的库，但它更多地关注现实生活中的问题解决，而不是数学上的完美(对于您打算实际使用的库来说，这完全是正确的做法)。

如果你真的很喜欢阅读这些概念，并且想知道如何将它们应用到更广泛的概念中，你可以阅读下面链接的关于单子反应的文章。这是一个库，在延续部分使用可渲染的变体来包装反应组件。通过这样做，有可能映射、绑定、组合和装饰反应组件，就像我们对延续所做的一样。

[](https://medium.com/@giuseppemaggiore/a-react-journey-from-vanilla-to-type-safe-to-monadic-41beaa386910) [## 反应之旅:从香草，到类型安全，到单子

### 介绍

medium.com](https://medium.com/@giuseppemaggiore/a-react-journey-from-vanilla-to-type-safe-to-monadic-41beaa386910)