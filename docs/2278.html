<html>
<head>
<title>Laravel: The Power of Authentication [Part 1]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel:认证的力量(第1部分)</h1>
<blockquote>原文：<a href="https://itnext.io/laravel-the-power-of-authentication-part-1-4510f721d8ff?source=collection_archive---------2-----------------------#2019-04-29">https://itnext.io/laravel-the-power-of-authentication-part-1-4510f721d8ff?source=collection_archive---------2-----------------------#2019-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4a4b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">忘记在你的控制器中使用讨厌的逻辑。学真道！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d639e6bfe3413c617fcdcf5382a55e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SpF8AhroiDWsRejc"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@fancycrave?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fancycrave </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="400f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为我的文章<a class="ae kv" href="https://medium.com/@DarkGhostHunter/laravel-making-your-own-passwordless-auth-guard-b7740c89adf8" rel="noopener">关于认证如何在Laravel </a>中工作的<em class="ls">的后续</em>，这里我将写一下认证机制的活动部分，比如认证中间件、防护、驱动程序、用户提供者和可认证者。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="489c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，身份验证系统基本上是一个中间件，它查看请求的任何资源(cookie、请求头、会话等)以获取访问凭证(用户ID和密码、令牌等)。如果找到它们，它将从应用程序(数据库、外部api等)中提取具有这些凭证的用户，并在请求生命周期或后续请求中保持其可用性。</p><blockquote class="ma mb mc"><p id="d45b" class="kw kx ls ky b kz la jr lb lc ld ju le md lg lh li me lk ll lm mf lo lp lq lr ij bi translated">我谦恭地建议您至少了解一下<a class="ae kv" href="https://laravel.com/docs/session" rel="noopener ugc nofollow" target="_blank">会话</a>和<a class="ae kv" href="https://laravel.com/docs/requests" rel="noopener ugc nofollow" target="_blank">请求</a>是如何工作的，以及<a class="ae kv" href="https://laravel.com/docs/5.8/lifecycle" rel="noopener ugc nofollow" target="_blank">应用程序生命周期</a>。最后一段只是冰山一角。</p></blockquote><p id="1dbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是认证系统不仅仅是一个中间件。一旦过了那一关，事情就变得非常非常复杂了。幸运的是，这只是乍一看令人望而生畏，在下一系列文章中，我将揭示身份验证系统是如何工作的，而不会用复杂的概念来轰炸。</p><p id="a3b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，想象一下这个:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/63736faff5c3009965ccb513568f76a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4J74Tk7u0dEVDO2Qxt0fiw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">对于门外汉来说，认证系统是什么的崇高表现。是的，冰山一角。</figcaption></figure><h1 id="fcdf" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">认证中间件</h1><p id="5a90" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">实际上，有两个中间件用于身份验证。第一个是<code class="fe ne nf ng nh b">Authenticate</code>，它代表认证机制中的主要齿轮，还有<code class="fe ne nf ng nh b">AuthenticatedSession</code>中间件，它有点像<em class="ls">利基— </em>我们稍后会谈到它。</p><p id="0e6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在您的<code class="fe ne nf ng nh b">app\Http\Kernel.php</code>中看到中间件优先级，您会看到<code class="fe ne nf ng nh b">Authenticate</code>就在<code class="fe ne nf ng nh b">AuthenticatedSession</code>之前。如果不是，那么检查一下它扩展的内核。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/69e109b00d9bcea39be30a1b69cad73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78ZCddcfjrprqgqZbdBIIg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">app\Http\Kernel.php</figcaption></figure><p id="c540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个数组定义了中间件在另一个之前的顺序。这避免了当一个中间件需要其他中间件提供的东西时的冲突。我个人认为Laravel可以有一个中间件属性来要求其他的，但是对于当前版本来说这已经足够了——大量的中间件意味着你可能做得有些过头了。</p><h1 id="f27a" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">它从认证开始</h1><p id="eb17" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">当您在路由或控制器中设置<code class="fe ne nf ng nh b">auth</code>中间件时，传入的请求将由<code class="fe ne nf ng nh b">Authenticate</code>类处理。当应用程序实例化它时，它接收<code class="fe ne nf ng nh b">AuthManager</code>服务，并且这个服务返回一个以它的名字命名的守卫。</p><p id="b03c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该中间件将尝试检查在您的配置文件中设置的默认身份验证机制，否则它将循环您在中间件参数中设置的每个身份验证，如下例所示:</p><pre class="kg kh ki kj gt nj nh nk nl aw nm bi"><span id="11d1" class="nn mi iq nh b gy no np l nq nr">Route::get('private')<br/>    -&gt;uses('PrivateController@show')<br/>    -&gt;middleware('auth:token,session,telepathy,hunch,whatever');</span></pre><p id="5b75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当它按顺序循环通过每个认证守卫时，它基本上调用<code class="fe ne nf ng nh b">AuthManager</code>内每个守卫的<code class="fe ne nf ng nh b">check()</code>方法，返回一个boolean应用程序将使用返回<code class="fe ne nf ng nh b">true</code>的第一个身份验证，如果没有人说有一个用户已经过身份验证，它将返回一个<code class="fe ne nf ng nh b">AuthenticationException</code>，因为没有身份验证能够判断谁正在访问该路由。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/b9789b7b1c03c6682b95f733b124f847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Hx0KofK2ul_PvwKCOawpA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照明/认证/中间件/认证</figcaption></figure><p id="5f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用户没有通过<code class="fe ne nf ng nh b">redirectTo()</code>方法进行身份验证，该异常将接收您希望重定向到的URL，该方法接收请求作为参数。例如，您可以根据请求的位置将用户重定向到不同的URL。</p><h2 id="d0cb" class="nn mi iq bd mj nt nu dn mn nv nw dp mr lf nx ny mt lj nz oa mv ln ob oc mx od bi translated">那么，身份验证会话是做什么的呢？</h2><p id="264c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/laravel/laravel/blob/master/app/Http/Kernel.php#L34" rel="noopener ugc nofollow" target="_blank">该中间件默认情况下是禁用的</a>，但启用它将允许用户在密码更改时从所有其他设备注销。</p><p id="3b8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快速浏览一下<code class="fe ne nf ng nh b">handle()</code>方法告诉我们，这个<code class="fe ne nf ng nh b">AuthenticateSession</code>试图通过比较用户先前存储在会话中的密码散列来验证用户身份——您将需要使用<code class="fe ne nf ng nh b">SessionGuard</code>或类似的使用会话。因此，如果用户更改数据库中的密码哈希，所有其他会话都将自动失效，因为这些会话使用的是旧的密码哈希。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/3809453ff6f5809c5e22c3a2addb1fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qraBdRAxkJdVGZNzUjalFg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照明/会话/中间件/认证会话</figcaption></figure><p id="dec7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不知道，Laravel不会强制用户只能在一个设备上进行身份验证。这意味着，一个用户可以在世界的不同地方打开多个会话，即使该用户更改了他的密码。</p><p id="12db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，Laravel允许这个中间件与<code class="fe ne nf ng nh b"><a class="ae kv" href="https://github.com/laravel/framework/blob/5e87f2df072ec4a243b6a3a983a753e8ffa5e6bf/src/Illuminate/Auth/SessionGuard.php#L543" rel="noopener ugc nofollow" target="_blank">logoutOtherDevices()</a></code> <a class="ae kv" href="https://github.com/laravel/framework/blob/5e87f2df072ec4a243b6a3a983a753e8ffa5e6bf/src/Illuminate/Auth/SessionGuard.php#L543" rel="noopener ugc nofollow" target="_blank">方法</a>结合使用，当用户登录时，<a class="ae kv" href="https://laravel.com/docs/5.8/authentication#invalidating-sessions-on-other-devices" rel="noopener ugc nofollow" target="_blank">将使其他设备中的会话无效。这个可以放在你的<code class="fe ne nf ng nh b">LoginController</code>上。</a></p><p id="55e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Laracast 中有一个很好的视频，讲述了这一点以及如何注销所有其他设备，所以请查看它以了解更多细节。如果你不想，这里是要点:当它收到密码，它重新散列并保存到数据库，从而使其他会话无效，因为散列不相等。</p><p id="2ebc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，中间件已经介绍完了，下一步是理解警卫驱动和用户提供者。</p></div></div>    
</body>
</html>