<html>
<head>
<title>🐍 Build a Snake Game in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">🐍用TypeScript构建一个贪吃蛇游戏</h1>
<blockquote>原文：<a href="https://itnext.io/build-a-snake-game-in-typescript-8bee5b9f1ec6?source=collection_archive---------1-----------------------#2019-05-19">https://itnext.io/build-a-snake-game-in-typescript-8bee5b9f1ec6?source=collection_archive---------1-----------------------#2019-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b2f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用HTML5和TypeScript构建一个复古的贪吃蛇游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe01d3ca92da1732f47681af46741966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2-QbTqbFi_tOkoIj0_zhZg.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用HTML5 Canvas和TypeScript制作的复古贪吃蛇游戏的屏幕截图</figcaption></figure><h2 id="0c52" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="1143" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi mo translated"><span class="l mp mq mr bm ms mt mu mv mw di">如果说在我的成长过程中有一件事给我留下了深刻的印象，那就是80年代和90年代的酷游戏，它们非常简单，但玩起来也非常有趣。我也在这段时间学习了《T4》的基本编程，所以很自然，没过多久我就开始创作自己的简单游戏了。</span></p><p id="bf95" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">早在2015年，我在TypeScript中创建了这个<a class="ae ky" href="https://bytegames.github.io/bytes" rel="noopener ugc nofollow" target="_blank">老派的贪吃蛇游戏</a>，以测试HTML5中<strong class="lx iu"> canvas </strong>对象的图形功能，并感受如何使用它从头开始重新创建经典的2D游戏。</p><p id="77ae" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">我选择了<a class="ae ky" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>,因为那时我已经用它构建了几个UI和UI框架，其中许多都是根据我使用C#和WPF的经验来模仿的。这使得它成为从零开始快速构建定制游戏引擎原型的绝佳选择，我想要完美的性能和几乎没有错误的行为(我们总是想要没有错误的软件，但在这种情况下，我使用我选择的工具从零开始构建整个游戏，所以我实际上得到了它)。</p><p id="a8a7" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">整个项目都是开源的，在这里可以找到<a class="ae ky" href="https://github.com/bytegames/bytes" rel="noopener ugc nofollow" target="_blank"/>，所以如果你喜欢，就去拿一份副本，体验一下吧，看看你能得到什么。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="89c6" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">项目结构</h2><p id="f5d2" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这个项目非常简单，除了TypeScript编译器之外没有任何外部依赖。这使得它成为从头开发简单游戏引擎的理想环境。下面是<strong class="lx iu"> package.json </strong>和<strong class="lx iu"> tsconfig.json </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="72f9" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这个项目中的<strong class="lx iu"> package.json </strong>文件或多或少是作为参考，因为实际上不存在依赖关系或其他任何东西。在<strong class="lx iu"> tsconfig.json </strong>中，有指令让编译器将文件输出为ES6模块，并将它们放在<strong class="lx iu"> build </strong>目录中，以便在浏览器中加载。</p><p id="ce7b" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在项目根目录下还有一个<strong class="lx iu">index.html</strong>文件，用于将游戏作为一个静态应用程序(这里已经完成了<a class="ae ky" href="https://bytegames.github.io/bytes" rel="noopener ugc nofollow" target="_blank"/>)和一个用于CSS3风格的<strong class="lx iu"> css </strong>文件夹。</p><p id="ded7" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><strong class="lx iu"> src </strong>的内容是主入口文件<strong class="lx iu"> game.ts </strong>以及三个文件夹<strong class="lx iu">对象</strong>、<strong class="lx iu">类型</strong>和<strong class="lx iu"> ux、</strong>对应这些关键概念:</p><ul class=""><li id="b52f" class="nl nm it lx b ly mx mb my li nn lm no lq np mn nq nr ns nt bi translated"><strong class="lx iu">物体</strong>:游戏中使用的物体，如<strong class="lx iu">蛇</strong>或<strong class="lx iu">硬币</strong></li><li id="cb05" class="nl nm it lx b ly nu mb nv li nw lm nx lq ny mn nq nr ns nt bi translated"><strong class="lx iu">类型</strong>:基本数据类型，如<strong class="lx iu">位置</strong>、<strong class="lx iu">速度</strong>、<strong class="lx iu">方向</strong>、<strong class="lx iu">游戏键</strong></li><li id="7d54" class="nl nm it lx b ly nu mb nv li nw lm nx lq ny mn nq nr ns nt bi translated"><strong class="lx iu"> ux </strong>:处理游戏性和渲染的组件，比如<strong class="lx iu"> Canvas </strong></li></ul><p id="fe8c" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">每个文件夹中都有一个<strong class="lx iu"> index.ts </strong>文件，它只是将其他文件的内容分组并导出到每个文件的一个模块中。这包括了文件夹结构和项目配置文件，所以接下来我们将看看HTML5和CSS3中定义的游戏的表现和风格。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="4d98" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak"> HTML和CSS定义</strong></h2><p id="c41c" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这个游戏依赖于<strong class="lx iu">画布</strong>来完成大部分真实的屏幕工作，所以游戏的其余部分UX主要是在那里支持它。下面来看看<strong class="lx iu">index.html</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bd6d" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在这里我们可以看到这个HTML文件没有太多内容:一些基本的社交图元数据，一个带有几个简单的<strong class="lx iu">按钮</strong>和<strong class="lx iu"> div </strong>读数的<strong class="lx iu">头</strong>，以及将在其中绘制游戏动作的<strong class="lx iu">画布</strong>本身。</p><p id="4916" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">接下来是CSS文件，<strong class="lx iu"> css/style.css: </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1820" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在上面的代码片段中，<strong class="lx iu"> css/style.css </strong>在两个选项卡中都是打开的，在第一个选项卡中显示前半部分，在右侧显示后半部分。没有太多的东西，只有一些颜色定义，居中内容的基本页面结构，以及一些按钮、链接和其他东西的样式。大部分工作都发生在<strong class="lx iu">画布</strong>中，所以这几个样式就足够设置一个基本的游戏了。结构和风格都不在话下，我们来看看游戏逻辑实现。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="a58e" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">核心类型定义</h2><p id="6528" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">文件夹<strong class="lx iu">。/types </strong>包含几个类、枚举和接口，它们构成了游戏中使用的基本类型。这里是<strong class="lx iu"> gameobjects.ts </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e9c2" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这个文件定义了游戏对象和棋盘在屏幕上绘制对象所使用的接口。</p><p id="0c08" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">接下来是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/45fe62340135dd2bc22ad3f307cf62f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06Vd1TDGfBsP99EqC_lGSw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb">用<strong class="bd lb"> gameobjects.ts </strong>、<strong class="bd lb"> position.ts </strong>和<strong class="bd lb"> enums.ts </strong>键入</strong>文件夹</figcaption></figure><p id="989a" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在上面的截图中，<strong class="lx iu">类型</strong>中的四个模块文件中有三个是打开的。文件<strong class="lx iu"> enums.ts </strong>包含四种符合这些要求的枚举类型:</p><ul class=""><li id="9220" class="nl nm it lx b ly mx mb my li nn lm no lq np mn nq nr ns nt bi translated"><strong class="lx iu">游戏键</strong>:向上<em class="oa">、<em class="oa">向下</em>、<em class="oa">向左</em>和<em class="oa">向右</em>箭头键的键值</em></li><li id="7a11" class="nl nm it lx b ly nu mb nv li nw lm nx lq ny mn nq nr ns nt bi translated"><strong class="lx iu">屏幕边缘</strong>:用于判断蛇是否与屏幕边缘发生碰撞</li><li id="deef" class="nl nm it lx b ly nu mb nv li nw lm nx lq ny mn nq nr ns nt bi translated"><strong class="lx iu">方向</strong>:玩家当前移动的方向(如果有)</li><li id="fc7a" class="nl nm it lx b ly nu mb nv li nw lm nx lq ny mn nq nr ns nt bi translated"><strong class="lx iu">速度:</strong>玩家当前在游戏板上移动的速度</li></ul><p id="933d" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">此外，我们还有一个用于<strong class="lx iu"> Drawable </strong>的接口以及两个扩展它的接口，一个用于玩家，一个用于玩家可能会碰到的游戏物体。这些中的每一个都有一个<strong class="lx iu">位置</strong>，它被定义为具有一个<strong class="lx iu"> X </strong>和<strong class="lx iu"> Y </strong>值以及一个复制位置的方便方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/768bb91bce8ea5e5c2a946858290ff1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r85O8UNrArRJ2FNoiIk5Zw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行游戏时钟的<strong class="bd lb"> src/timer.ts </strong>中的<strong class="bd lb"> Timer </strong>类</figcaption></figure><p id="6b8b" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><strong class="lx iu">类型</strong>下的最后一项是<strong class="lx iu">定时器</strong>类，作为游戏的主时钟。根据需要可以<em class="oa">启动</em>、<em class="oa">停止</em>、<em class="oa">复位</em>。有两个本地定义的枚举:<strong class="lx iu">时钟类型</strong>，它表示计时器是否有持续时间或永远运行，以及<strong class="lx iu">时钟指针</strong>，它提供一个主时钟“脉冲”，游戏的其他部分使用它，例如，根据需要以正常速度的一半(或两倍)移动玩家对象。</p><p id="2b95" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这涵盖了游戏中使用的主要类型。这些将在许多地方被引用，并根据需要用于创建其他更复杂的对象。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="05cf" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">游戏对象类别</h2><p id="ec2a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们要检查的下一组模块是游戏<strong class="lx iu">对象:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/f2a69bc3c12212257e70671f8af9bfa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xeCV4S6EecE0FZlZoSWDw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb">硬币</strong>类代表一枚硬币，可以捡起来获得点数</figcaption></figure><p id="c920" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这组中的第一个是<strong class="lx iu"> Coin </strong>类，它实现了<strong class="lx iu"> IGameObject </strong>接口，这意味着它至少必须有<strong class="lx iu"> handle_collision( ) </strong>和<strong class="lx iu"> draw() </strong>方法，否则编译器会抛出一个错误。这在构建某个东西的过程中很有用，因为您不会希望在一百个左右的游戏对象中的一个上意外地遗漏这些方法中的一个，导致它要么不响应玩家，不在屏幕上绘制，要么最终在棋盘上出现一个不可见的项目，该项目没有出现，但仍会响应玩家的碰撞。</p><p id="920d" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><strong class="lx iu"> Coin </strong>类有一些静态属性，包括默认值和当前内存中存在的Coin的所有实例的静态引用。这种方法使得从项目本身的概念定义中操纵项目组变得非常容易:例如，制作另一个项目是很容易的，当收集到该项目时，会导致屏幕上的所有硬币消失，或导致更多的硬币落下，或任何其他效果。</p><p id="df03" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">当<strong class="lx iu">手柄_碰撞</strong>被触发时，撞上它的蛇得到硬币的总价值并加到它的玩家分数上，然后蛇的<em class="oa">最大长度</em>增加<em class="oa"> 8 </em>，这允许蛇在接下来的八个时钟周期内增长八步。然后调用<strong class="lx iu"> destroy() </strong>方法，该方法将硬币从棋盘上移除，并清除任何剩余的痕迹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/5e5dca04988caa666bd608f43859095e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OTE011i8OKa4H5v9x6VcPw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">展示了<strong class="bd lb"> draw() </strong>和<strong class="bd lb"> destroy() </strong>方法的<strong class="bd lb"> Coin </strong>类</figcaption></figure><p id="3fe8" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">每个对象都有自己的这些方法的实现，这允许有很大的灵活性，同时保持一个简单有效的体系结构，使整个游戏设计处于可控状态。例如，可以在<strong class="lx iu"> handle_collision() </strong>或<strong class="lx iu"> destroy() </strong>方法中加入一些特殊效果，而对系统中的其他部分几乎没有影响。这是如何利用TypeScript的一些强大的<a class="ae ky" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> OOP </a>特性的一个例子。</p><p id="1e95" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">接下来是<strong class="lx iu"> FastPlayer </strong>和<strong class="lx iu"> SlowPlayer </strong>对象，分别加速和减速玩家。由于这实际上是同一事物的两种变体，我将展示其中的一种，<strong class="lx iu"> FastPlayer，</strong>作为示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/fc9ac3fa3276f16e7ec2c2b9918978e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggyYdOjgoB_Egn8T0Pz7QQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">快速玩家职业，当被收集时会使玩家快速移动</figcaption></figure><p id="d51a" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><strong class="lx iu"> FastPlayer </strong>类看起来非常类似于之前的<strong class="lx iu"> Coin </strong>示例。这里的主要区别是<strong class="lx iu"> handle_collision() </strong>改变蛇移动的速度，而<strong class="lx iu"> draw() </strong>产生不同的图形。接下来是组成蛇的类，<strong class="lx iu">蛇段</strong>和<strong class="lx iu">蛇:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c80ea2c16fedb7a1c977015f247d2f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4nFforuCLkahA8lV9An8Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将蛇块绘制到屏幕上的<strong class="bd lb">蛇段</strong>类</figcaption></figure><p id="7cd5" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><strong class="lx iu"> SnakeSegment </strong>类定义了要在屏幕上绘制的一段蛇。屏幕上的每条蛇都由一组这样的蛇组成，每条蛇都有一个<em class="oa">位置</em>用于定位并将其绘制到板上，还有一个<em class="oa">颜色</em>，它通过<strong class="lx iu">颜色</strong>变量中定义的八个值自动旋转。一天晚上，我给女儿看这个游戏，她觉得这个游戏有彩虹效果会更酷，就像一个众所周知的迷因，事实就是如此。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/29edc05ca6225afcfad7d49d15c85e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*see2A35JYUheO_JfqMK3mg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有玩家控制器对象各种属性的<strong class="bd lb"> Snake </strong>类</figcaption></figure><p id="7f06" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><strong class="lx iu"> objects </strong>文件夹中的最后一个模块是<strong class="lx iu"> snake.ts </strong>中的<strong class="lx iu"> Snake </strong>类，它控制着播放器的寿命和Snake对象本身的实际渲染。在上面的截图中是一个静态的<em class="oa"> default_length </em>，它决定了在玩家没有收集到任何硬币的情况下，默认情况下蛇会得到多长时间。<em class="oa"> jump_distance </em>属性决定了当<em class="oa"> jump </em>键被按下时，蛇会跳多远，这使得蛇跳过那些被跳过的空间中的障碍物或物品。</p><p id="119d" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">还有用于<em class="oa"> skip_next_turn </em>、<em class="oa"> hit_detected </em>和<em class="oa"> is_alive </em>的<em class="oa">布尔</em>属性，它们控制游戏功能并允许健全性检查，如在绘制之前确保玩家仍然活着等等。还有<em class="oa">速度</em>、<em class="oa">方向</em>和<em class="oa">位置</em>的属性，这些属性在这里不言自明。默认的速度和方向分别是<em class="oa">正常</em>和<em class="oa">无</em>，而<em class="oa">位置</em>最初是未定义的，当蛇被放置在游戏板上时被设置。</p><p id="525e" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">除了<em class="oa"> hi_score </em>、<em class="oa"> points </em>和<em class="oa">lifes</em>的标准费用属性之外，还有一个名为<em class="oa"> segment </em>的<strong class="lx iu"> SnakeSegment </strong>对象数组，用于保存棋盘上跟随其后的各个蛇块。还可以看到<strong class="lx iu">构造函数</strong>和<strong class="lx iu"> jump() </strong>方法的一部分，该方法计算出玩家行进的方向，并将蛇头向前移动<em class="oa"> jump_distance </em>的值，从而导致其余的段也跟着移动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/66e01e97198ba80de75f513e9f90da30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5GocG8ufx44QQoY8UicYeQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">更多的<strong class="bd lb">蛇</strong>类拥有各种游戏方式</figcaption></figure><p id="c352" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">Snake类中还有一些处理实际游戏的方法。在上面的截图中，<strong class="lx iu"> on_hit_screen_edge() </strong>没有被使用，因为它曾经被设置为当蛇与墙壁相撞时杀死玩家，但我想让蛇跳到另一边，所以我删除了这段代码，留下了一个带有<em class="oa"> TODO </em>和空<em class="oa"> switch </em>语句的<a class="ae ky" href="https://en.wikipedia.org/wiki/Method_stub" rel="noopener ugc nofollow" target="_blank">方法存根</a>。</p><p id="d6c1" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">我们还发现了<strong class="lx iu"> die() </strong>方法，该方法将<em class="oa"> hit_detected </em>设置为<em class="oa"> true，</em>设置并重置高分，在失去生命时重置游戏，并且还重置蛇的位置和方向以在下一轮重新开始。还有一个方法<strong class="lx iu"> set_speed() </strong>，它接受一个<strong class="lx iu"> Speed </strong>对象并从中更新蛇的速度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/ca062397d05a8fe8e182c5ffb457aa07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Brk9-LAL1BZCOn-YW8p-_A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">更多的<strong class="bd lb">蛇</strong>类带有<strong class="bd lb"> process_turn() </strong>方法</figcaption></figure><p id="d64f" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">Snake类还有一个<strong class="lx iu"> process_turn() </strong>方法，该方法根据蛇的当前速度、位置和方向以及它试图占据的空间中发生的任何事情来确定接下来将要发生的事情。首先，如果蛇已经死了，什么都不要做。如果蛇移动很快，跳过每隔一个时钟周期的处理(让它每转移动两格)，同样，如果玩家移动很慢，通过跳过每隔一个回合让它拖出来。接下来，执行一些检查和更新，以更新蛇<em class="oa">的位置</em>并确定它是否在移动，然后处理诸如屏幕环绕和与占据要进入的空间的物体碰撞的事件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c6224bac6b1fb76ba40799d104eccae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3gSqn25PU33OHTNPiTWZg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">甚至更多的<strong class="bd lb">蛇</strong>类的游戏性和定位逻辑</figcaption></figure><p id="0cff" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">如果玩家还活着，并且在棋盘上走来走去，就会调用update_board()方法，该方法会将每个单独的蛇段重新绘制到棋盘上，使每个蛇段都跟随前面的蛇段，无论蛇段在哪里。</p><p id="2e4a" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">这就完成了对<strong class="lx iu"> Snake </strong>类的处理，该类包含了处理屏幕内外的蛇的大部分游戏逻辑。这就是<a class="ae ky" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> OOP </a>的概念真正派上用场的地方，因为我们可以将所有的snake逻辑保存在一个名为<strong class="lx iu"> snake.ts </strong>的文件中，而不是分散在随机的文件中。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="b10f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">控制和游戏性</h2><p id="afe3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在<strong class="lx iu"> ux </strong>文件夹中是接受输入控制和渲染游戏图形输出的类。我们首先要看的是<strong class="lx iu"> src/ux/board.ts </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/122a0eaee8ec402ef3153b36f53e5ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1IrgrTkxJAVPb17bZEIWIg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb"> Board </strong>类，有各种处理游戏中物体的方法</figcaption></figure><p id="5c7b" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><strong class="lx iu">棋盘</strong>类包含处理游戏棋盘的各种静态方法和属性，这是一个网格，具有<em class="oa">高度</em>和<em class="oa">宽度</em>以及<em class="oa">块大小</em>，定义了每个游戏棋盘方块的高度和宽度(以像素为单位)。实际的棋盘本身由<em class="oa">网格</em>属性表示，这是一个<strong class="lx iu"> IDrawable、</strong>的数组，它允许控制器很容易地跟踪在任何给定时间正在玩的项目，并随着游戏的进行更新它们。</p><p id="a68d" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">有各种方法如<strong class="lx iu"> place_object() </strong>和<strong class="lx iu"> remove_object_at() </strong>这些方法大多是自解释的，一次只处理一两件事情。这是有意的，因为架构非常明显，可以很容易地更新和修改，而不太可能破坏其他东西，因为就每个单独的部分而言，其他所有东西仍然按预期工作。游戏开发通常以这种方式很好地适应面向对象编程，因为程序有效地处理相互交互的虚拟对象，以及像游戏棋盘这样的东西，而游戏棋盘又是另一个游戏对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/2935032b7c812dbb475fc393fd37ff13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*biZrpx6fRXCGJM8uw7xAHA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有<strong class="bd lb">generate _ random _ position()</strong>、<strong class="bd lb"> init() </strong>和<strong class="bd lb"> draw() </strong>方法的<strong class="bd lb">板</strong>类</figcaption></figure><p id="d828" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">我们还在Board类中找到了<strong class="lx iu">generate _ random _ Position()</strong>方法，它使用一些标准的<em class="oa"> Math.floor </em>和<em class="oa"> Math.random </em> JavaScript函数来得出一个随机的板位置，然后将其作为<strong class="lx iu"> Position </strong>对象返回。init()方法通过将<strong class="lx iu">画布</strong>的高度和宽度除以棋盘的<em class="oa"> block_size，</em>来计算棋盘的<em class="oa">高度</em>和<em class="oa">宽度</em>，然后用空数组初始化网格本身。<strong class="lx iu"> draw() </strong>方法充分利用了可互换的对象接口，它遍历棋盘，并在实现<strong class="lx iu"> IDrawable、</strong>的对象的每个实例上调用<strong class="lx iu"> draw() </strong>，而不管该对象是蛇、硬币还是其他屏幕上的项目。</p><p id="f6c2" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">接下来是<strong class="lx iu"> src/ux/canvas.ts </strong>中的<strong class="lx iu"> Canvas </strong>类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/4aa0ca5f888a344c6d3e56683582696f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpdik-QUniu0LG5YoRG1LA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用于绘制游戏内容的精简的<strong class="bd lb">画布</strong>类</figcaption></figure><p id="231c" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">canvas是一个非常简单的抽象类，它有一个<em class="oa">宽度</em>和<em class="oa">高度</em>，它们已经被初始化为怀旧的分辨率<em class="oa"> 640x400 </em>，还有一个<em class="oa">上下文</em>属性，用于保存对HTML5屏幕上Canvas上下文的引用，该上下文用于在屏幕上实际绘制图形。有一个<strong class="lx iu"> init() </strong>方法以及一些绘制基本形状的方便方法，差不多就是这些了。接下来我们将看看<strong class="lx iu"> src/ux/console.ts </strong>中的控制台:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/01d8ec8cfa15b41851c44cb1452bedae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMHI9EJtIG6geHmH4t-tmg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有几个标准控制台按钮的<strong class="bd lb">控制台</strong>类</figcaption></figure><p id="3476" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><strong class="lx iu">控制台</strong>类非常简单，引用了控制游戏状态(开始、暂停和重置)的三个按钮，并带有<em class="oa"> onclick </em>事件的处理程序，这些事件调用<strong class="lx iu">游戏</strong>对象上的各个游戏函数。</p><p id="af5a" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">接下来是<strong class="lx iu"> src/ux/controls.ts </strong>中的<strong class="lx iu">控件</strong>类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/811f23f847e056c37b8f48fefaef5d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gYxhwhYBFc5D-8KIPfwiw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb">控制</strong>类，该类处理游戏的控制器输入</figcaption></figure><p id="fe97" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><strong class="lx iu">控件</strong>类专门用于处理用户输入。有一个用于<em class="oa"> on_key_up </em>的处理程序(它由<strong class="lx iu">游戏</strong>类连接，我们将在后面看到),它只是获取当前事件的关键代码并将其存储在本地。这样，玩家可以在一个时钟周期内按下多个控制键，而控制器将只使用最后一个按下的键。这在游戏中非常有用，可以瞬间改变蛇的移动方向。</p><p id="65a5" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">每次调用<strong class="lx iu"> process_input() </strong>时，即每个游戏时钟脉冲一次，以更新每回合的游戏状态，都会执行一系列检查来确定下一步要做什么。如果没有提供任何输入，就让一切保持原样。这将导致，例如，如果我们不去管它，蛇会一直在屏幕上移动。蛇可以向除了它来的方向以外的任何方向移动，因为它不能穿过自己。如果最后按下的键是空格键，则在蛇上调用<strong class="lx iu"> jump() </strong>方法。一旦<em class="oa"> last_key </em>已经被Controls类使用，它就被丢弃并被设置回<em class="oa"> null </em>，因为这个类与游戏逻辑的其余部分无关，它只是耐心地等待捕获(也许处理)控制器输入。</p><p id="89ce" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">接下来是<strong class="lx iu"> srx/ux/gui.ts </strong>中的<strong class="lx iu"> GUI </strong>类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/25f9279aeefe03bb8d0b8eefe8adb2f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utivCXV3BNfPo2MwOsx21Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">呈现游戏指标和文本的<strong class="bd lb"> GUI </strong>类</figcaption></figure><p id="bcb8" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">GUI 类也非常简单，仅用于绘制分数和剩余生命数。它包含一些DOM元素，并根据游戏状态的各种属性更新它们的文本。</p><p id="30fc" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">所有支持的类和类型定义都已完成，让我们来看看最后一个。本项目中ts文件，<strong class="lx iu"> game.ts </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/f32b26610e4abb89537ac829d9cd1cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCaAkTknvznpMosg0Um_cw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">游戏的主入口，<strong class="bd lb">游戏</strong>类</figcaption></figure><p id="c897" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">游戏类作为游戏的主要入口点和控制器。驱动游戏动作核心的<em class="oa"> clock </em>和<em class="oa"> player_one </em>有静态属性，还有从<em class="oa"> 0开始的当前<em class="oa"> hi_score </em>、</em>和<em class="oa"> is_running </em>用于设置(并检查)游戏是否正在运行。</p><p id="b57b" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated"><strong class="lx iu"> init() </strong>方法只在游戏网站加载时调用一次，初始化<strong class="lx iu"> canvas </strong>对象，并开始将<em class="oa"> onkeyup </em>事件转发给游戏控制器进行进一步处理。当这些任务完成并且每当游戏被重置时，调用<strong class="lx iu"> ready() </strong>方法，这又重新初始化各种其他游戏组件，包括<strong class="lx iu">棋盘</strong>、<strong class="lx iu">时钟</strong>和<strong class="lx iu">蛇</strong>。</p><p id="a63b" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">当<strong class="lx iu"> start() </strong>方法启动游戏时，首先进行检查以确保游戏尚未运行或处于暂停状态，此时游戏将根据时钟上<em class="oa"> is_paused </em>的当前状态继续或暂停/取消暂停。一旦这些检查通过，就开始计时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/e5a3ed76838d61cad0e88ef4026aa523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SnuaHHTnrf0rnJHH4VEeg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb">游戏的</strong>类有<strong class="bd lb">暂停()</strong>、<strong class="bd lb">复位()</strong>和<strong class="bd lb"> on_clock_tick() </strong>方法</figcaption></figure><p id="49e5" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">除了启动游戏，我们还需要能够暂停和重置它。<strong class="lx iu"> pause() </strong>方法检查游戏时钟上<em class="oa"> is_paused </em>的当前状态，然后根据需要暂停或恢复游戏。<strong class="lx iu"> reset() </strong>方法会停止游戏时钟(如果存在)，将<em class="oa"> is_running </em>设置为false，然后调用<strong class="lx iu"> ready() </strong>将游戏细节重新初始化回默认值。</p><p id="6e21" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">目前还在开发中的<strong class="lx iu"> on_clock_tick() </strong>的内容有些混乱，但是基本思想在这里。控制器通过<strong class="lx iu"> process_input() </strong>接收每个时钟脉冲输入。接下来，通过在玩家的游戏棋子(蛇)上调用<strong class="lx iu"> process_turn() </strong>来决定玩家的命运。</p><p id="d870" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">在偶数时钟脉冲上，通过在整个棋盘上分散一些硬币和电源，一些临时的项目随机化逻辑被执行以使游戏更有趣。这个的代码可能会在以后改变，以适应更复杂的游戏逻辑来产生和分配随机物品。</p><p id="425b" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">截图中没有的是<strong class="lx iu"> on_clock_tick()最后的<strong class="lx iu"> <em class="oa"> Board.draw() </em> </strong>和<strong class="lx iu"> <em class="oa"> GUI.draw() </em> </strong>方法调用。这些只是调用每个对象的绘制方法，用更新的内容绘制屏幕。</strong></p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="7ca9" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="349f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我希望你喜欢这篇关于用TypeScript构建简单的经典2D游戏的文章。这个基本的游戏“引擎”可以以无数种方式进行修改或升级，用于从在线象棋到基于网络的RPG游戏或任何其他游戏，只受开发者想象力的限制。</p><p id="4a9a" class="pw-post-body-paragraph lv lw it lx b ly mx ju ma mb my jx md li mz mf mg lm na mi mj lq nb ml mm mn im bi translated">感谢阅读！</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><blockquote class="ob"><p id="76ec" class="oc od it bd oe of og oh oi oj ok mn dk translated">肯尼斯·雷利(<a class="ae ky" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a>)是<a class="ae ky" href="https://lvl-up.tech/" rel="noopener ugc nofollow" target="_blank"> LevelUP </a>的CTO</p></blockquote></div></div>    
</body>
</html>