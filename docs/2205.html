<html>
<head>
<title>OnPush change detection for faster Angular apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OnPush变化检测用于更快的角度应用</h1>
<blockquote>原文：<a href="https://itnext.io/onpush-change-detection-for-faster-angular-apps-f5d6dccea589?source=collection_archive---------3-----------------------#2019-04-16">https://itnext.io/onpush-change-detection-for-faster-angular-apps-f5d6dccea589?source=collection_archive---------3-----------------------#2019-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/f15f14f792b167b435d2edb20754d29b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*VKY-Ldkt-iHobItql7G_5w.png"/></div></figure><p id="bd62" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然不是最快的，但默认情况下Angular是性能最好的框架之一。</p><p id="18bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">即使大多数应用程序不需要进行任何高级优化就能正常运行，在旧的浏览器和较慢的设备上运行复杂的应用程序仍然是一项艰巨的任务。</p><h1 id="8da0" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">变更检测策略🔥</h1><p id="3c32" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们可以做的第一个也可能是最重要的调整是改变Angular默认使用的检测策略，以最大限度地减少变化检测的运行次数，这将使你的应用程序运行得更流畅、更快。</p><p id="35ae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认情况下，你猜对了，Angular使用策略<code class="fe lv lw lx ly b">ChangeDetectionStrategy.Default</code>。这意味着组件将始终被检查。效率不高吧？</p><p id="f195" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果大多数组件不需要更新，为什么要这样做呢？输入<code class="fe lv lw lx ly b">ChangeDetectionStrategy.OnPush</code>，它将指示变化检测跳过一个组件，除非发生以下任何情况:</p><ul class=""><li id="c3a3" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr me mf mg mh bi translated">元件的输入参考发生变化</li><li id="ff09" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">组件中的DOM事件已被调度(例如点击)</li><li id="3b03" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">通过异步管道订阅的可观察事件的发射</li><li id="91c0" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">手动运行更改检测</li></ul><p id="5c13" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种实践对于大型复杂的应用程序更为重要，因为变更检测会跳过大量的组件。一个简单的方法可以看出这两种方法的区别，那就是使用Chrome的渲染开发工具。检查“油漆闪烁”选项，自己看看有多少次你的组件是不必要的重新渲染。</p><p id="fefb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下面的例子中，我们的组件将<em class="mn">而不是</em>更新视图:</p><pre class="mo mp mq mr gt ms ly mt mu aw mv bi"><span id="e7f6" class="mw kt iq ly b gy mx my l mz na">@Component({<br/>  ...,<br/>  template: '{{ count }}',<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ChangeDetectionComponent implements OnInit {<br/>  count = 0;</span><span id="2d3f" class="mw kt iq ly b gy nb my l mz na">  ngOnInit() {<br/>    setInterval(() =&gt; ++this.count, 1000);<br/>  }<br/>}</span></pre><h1 id="45d6" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">RxJS来救援了</h1><p id="1e4a" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">来自Angular 1.x的开发人员可能会发现这令人困惑并且难以使用:不可否认，在没有RxJS的情况下使用OnPush并不总是容易的。</p><p id="621c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">也就是说，我认为使用OnPush提供了一种更好的编码实践方式。例如，通过推广RxJS和<code class="fe lv lw lx ly b">async</code>管道的使用，我们得到了一个可预测的、声明性的代码库，它碰巧也是高性能的。</p><p id="6a60" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是使用<code class="fe lv lw lx ly b">async</code>管道的一些优点:</p><ul class=""><li id="bf42" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr me mf mg mh bi translated">自动订阅观察</li><li id="8bec" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">当组件被破坏时自动退订</li><li id="4e6e" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">轻松与变革战略战略合作。OnPush</li><li id="c346" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">减少我们组件的锁定</li></ul><p id="327a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简而言之，RxJS + OnPush =双赢。</p><p id="c781" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们用一个<code class="fe lv lw lx ly b">Observable</code>来重构前面的例子:</p><pre class="mo mp mq mr gt ms ly mt mu aw mv bi"><span id="5e05" class="mw kt iq ly b gy mx my l mz na">@Component({<br/>  ...,<br/>  template: '{{ count$ | async }}',<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ChangeDetectionComponent implements OnInit {<br/>  count$: Observable&lt;number&gt;;</span><span id="a081" class="mw kt iq ly b gy nb my l mz na">  ngOnInit() {<br/>    this.count$ = interval(1000)<br/>        .pipe(<br/>            map((count: number) =&gt; ++count)<br/>        );<br/>  }<br/>}</span></pre><p id="0ee4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在有了一个优雅的、声明性的和执行性的解决方案！</p><h1 id="6c1c" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">NGRX</h1><p id="aba9" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">当处理大型应用程序时，我建议使用状态管理库。不仅因为它有助于管理状态，还因为Angular状态管理库将可观察对象视为一等公民，就像框架一样。虽然有很多很棒的库，但我强烈推荐NGRX。</p><p id="a50e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">NGRX通过使用RxJS从存储中提取数据，轻松地处理纯角度组件，这意味着组件中保存的所有数据都是可观察的。</p><p id="2de2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你还不知道NGRX，那么你应该读一读。</p><p id="65d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了阅读下面的例子，你只需要知道我们从商店(把它想象成我们的数据库)中检索数据作为一个可观察对象，并且我们通过<code class="fe lv lw lx ly b">async</code>管道订阅在模板中显示它。</p><pre class="mo mp mq mr gt ms ly mt mu aw mv bi"><span id="83e3" class="mw kt iq ly b gy mx my l mz na">@Component({<br/>    ...,<br/>    changeDetection: ChangeDetectionStrategy.OnPush,<br/>    template: `<br/>        &lt;div *ngFor="let todo of (todos$ | async)"&gt;<br/>            {{ todo.name }}<br/>        &lt;/div&gt;<br/>    `<br/>})<br/>export class TodosComponent {<br/>    constructor(private store: Store&lt;AppState&gt;) {}</span><span id="08c7" class="mw kt iq ly b gy nb my l mz na">    ngOnInit() {<br/>        this.todos$ = this.store.select((state) =&gt; state.todos);<br/>    }<br/>}</span></pre><p id="b84e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每当<code class="fe lv lw lx ly b">todos$</code>发出一个新值时，框架就会呈现模板。</p><h1 id="d145" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">什么时候使用OnPush没有意义？</h1><p id="ffb0" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">绝不！OnPush是一种让你的应用程序更快的简单方法，个人认为没有理由不每次都使用它。</p><h1 id="6a49" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">重构代码库以提高性能🚀</h1><p id="2bcf" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我使用的大多数遗留角度代码库都使用默认的变化检测，应用程序的性能受此影响很大。大多数开发人员也不热衷于使用它，只是因为它看起来令人生畏。但是，其实也不一定。</p><p id="aff1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您计划通过使用OnPush变更检测来重构代码库，首先要知道的是，您永远不要从父组件开始。原因是，当changeDetection添加到父组件时，其所有组件树都会受到影响。</p><p id="6706" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我的建议是从叶子开始，一路向上到父组件。哑组件，如果写得好，通常不应该受到影响，因为它们只是接收输入并呈现它，所以它们是你应该重构的第一个对象。一旦容器的所有树都被重构，就该是容器的时候了。</p><p id="6854" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">集装箱负责什么？</p><ul class=""><li id="7d8c" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr me mf mg mh bi translated">检索数据并将其传递给其他组件</li><li id="3ba0" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">将一个或多个组件的布局放在一起</li></ul><p id="bcb7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">管理数据可以说是前端开发人员今天面临的最困难的任务，这就是为什么设计良好的容器是项目整体架构的关键。</p><p id="3513" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我推荐两种选择:</p><ul class=""><li id="7cd2" class="lz ma iq jw b jx jy kb kc kf mb kj mc kn md kr me mf mg mh bi translated">如果您不想使用第三方，可以使用自己的RxJS状态管理，方法是在服务中使用主题，并通过Observables公开数据</li><li id="87ae" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">用NGRX，NGXS，Akita等。？</li></ul><h1 id="a81e" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">外卖食品</h1><ul class=""><li id="14d0" class="lz ma iq jw b jx lq kb lr kf nc kj nd kn ne kr me mf mg mh bi translated">使用<code class="fe lv lw lx ly b">OnPush</code>变化检测策略，你的应用会更快</li><li id="fb09" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">使用<code class="fe lv lw lx ly b">async</code>管，这将使<code class="fe lv lw lx ly b">OnPush</code>更容易工作</li><li id="a788" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">使用状态管理库，或者在服务中利用RxJS</li><li id="b8ad" class="lz ma iq jw b jx mi kb mj kf mk kj ml kn mm kr me mf mg mh bi translated">重构很难:从你的叶子组件开始，一路向上，直到所有组件都使用<code class="fe lv lw lx ly b">OnPush</code></li></ul><p id="7c0e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文最初写于<a class="ae nf" href="https://frontend.consulting/on-push-change-detection-for-faster-angular-apps" rel="noopener ugc nofollow" target="_blank">https://frontend . consulting/on-push-change-detection-for-faster-angular-apps</a></p></div></div>    
</body>
</html>