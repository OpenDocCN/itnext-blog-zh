<html>
<head>
<title>Automating AWS Resource Creation with Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform自动创建AWS资源</h1>
<blockquote>原文：<a href="https://itnext.io/automating-aws-resource-creation-with-terraform-c942c7e304dc?source=collection_archive---------6-----------------------#2021-11-21">https://itnext.io/automating-aws-resource-creation-with-terraform-c942c7e304dc?source=collection_archive---------6-----------------------#2021-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/48d605650b30ca6420fca01183bb5c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hZ1AzA0R_RzdXL5kwfxQg.jpeg"/></div></div></figure><p id="afa4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在学习AWS的时候，我被分配到一个有时间限制的沙盒中，来玩AWS资源。我最初使用AWS控制台创建所需的资源。当这些资源的数量和它们之间的交互增加时，我开始思考我们是否可以自动创建资源。</p><p id="2650" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个已经解决的问题。答案是使用Infra作为代码工具— <a class="ae kw" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>。</p><h2 id="0891" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">目标AWS VPC环境</h2><p id="ee43" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我将创建一个AWS VPC环境，用于在不同的子网中运行Web服务器和DB服务器，如下图所示。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/e91010d76ddb9f4cf2f945e9c87d8d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*7E4HDLn4oQ6Uiu8Ddd0Phw.png"/></div></figure><h2 id="4e92" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">工具设置</h2><p id="6c0d" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在装有brew的Mac上安装terraform和aws命令行工具，</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b314" class="kx ky iq mb b gy mf mg l mh mi">brew install terraform<br/>brew install awscli</span></pre><h2 id="1cc6" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">地形文件结构</h2><p id="5a7b" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">Terraform将基于多个*的描述性内容运行。tf文件。运行时，Terraform将读取所有的<code class="fe mj mk ml mb b">*tf</code>文件，并按正确的顺序组装它们。</p><p id="c617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从两个文件开始，<code class="fe mj mk ml mb b">main.tf </code>和<code class="fe mj mk ml mb b">variables.tf.</code><code class="fe mj mk ml mb b">main.tf</code>如下所示:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a7c2" class="kx ky iq mb b gy mf mg l mh mi">terraform {<br/>  required_providers {<br/>    aws = {<br/>      source  = "hashicorp/aws"<br/>      version = "3.65"<br/>    }<br/>  }<br/>}</span><span id="9500" class="kx ky iq mb b gy mm mg l mh mi">provider "aws" {<br/>  access_key = var.access_key<br/>  secret_key = var.secret_key<br/>  region     = var.region<br/>}</span></pre><p id="1173" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Terraform的功能是由插件带来的。Terraform的最新版本允许您在tf文件中指定您的提供者。这里我们定义了所需的AWS提供者及其版本，然后用凭证设置AWS提供者。<code class="fe mj mk ml mb b">var</code>表示将从变量中读取值，变量在<code class="fe mj mk ml mb b">variables.tf</code>文件中定义，内容如下。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6a35" class="kx ky iq mb b gy mf mg l mh mi">variable "access_key" {<br/>  description = "AWS Access key"<br/>  default     = "A...."<br/>}</span><span id="86b7" class="kx ky iq mb b gy mm mg l mh mi">variable "secret_key" {<br/>  description = "AWS Secret Key"<br/>  default     = "j...."<br/>}</span><span id="5e59" class="kx ky iq mb b gy mm mg l mh mi">variable "region" {<br/>  description = "AWS region for hosting our your network"<br/>  default     = "us-east-1"<br/>}</span><span id="31a2" class="kx ky iq mb b gy mm mg l mh mi">variable "aws_ami" {<br/>  description = "Amazone linux"<br/>  default     = "ami-04ad2567c9e3d7893" //x86_64<br/>}</span><span id="e06a" class="kx ky iq mb b gy mm mg l mh mi">variable "ssh_key_name" {<br/>  description = "ssh key"<br/>  default     = "mykey"<br/>}</span></pre><p id="0c9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以运行<code class="fe mj mk ml mb b">terraform init</code>，它将相应地下载定义的提供者，</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ec5e" class="kx ky iq mb b gy mf mg l mh mi">terraform init</span><span id="c30f" class="kx ky iq mb b gy mm mg l mh mi">Initializing the backend...</span><span id="4e23" class="kx ky iq mb b gy mm mg l mh mi">Initializing provider plugins...<br/>- Reusing previous version of hashicorp/aws from the dependency lock file<br/>- Using previously-installed hashicorp/aws v3.65.0</span><span id="3b87" class="kx ky iq mb b gy mm mg l mh mi">Terraform has been successfully initialized!<br/>....</span></pre><p id="63bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于不同的功能，我们将AWS资源分成不同的tf文件。资源定义的格式很简单。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4184" class="kx ky iq mb b gy mf mg l mh mi">resource type_of_resource "resource name" {<br/>  attribute = "attribue value"<br/>  ...<br/>}</span></pre><h2 id="07a4" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">VPC: vpc.tf</h2><p id="0cdc" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在vpc.tf文件中，我们首先开始创建vpc，将CIDR设置为“192.168.0.0/16”</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3665" class="kx ky iq mb b gy mf mg l mh mi">resource "aws_vpc" "my-vpc" {<br/>  cidr_block = "192.168.0.0/16"<br/>  instance_tenancy = "default"<br/>  enable_dns_hostnames = true</span><span id="72f6" class="kx ky iq mb b gy mm mg l mh mi">  tags = {<br/>    Name = "my-vpc"<br/>  }<br/>}</span></pre><p id="faac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后分别为web区域(192.168.20.0/16)和DB区域(192.168.20.0/24)创建两个子网，</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="287b" class="kx ky iq mb b gy mf mg l mh mi">resource "aws_subnet" "web-subnet" {<br/>  cidr_block = "192.168.10.0/24"<br/>  vpc_id = "${aws_vpc.my-vpc.id}"<br/>  #availability_zone = "us-east-1a"<br/>  map_public_ip_on_launch = true</span><span id="8acc" class="kx ky iq mb b gy mm mg l mh mi">  tags = {<br/>    Name = "192.168.10.0"<br/>  }<br/>}</span><span id="48a6" class="kx ky iq mb b gy mm mg l mh mi">resource "aws_subnet" "db-subnet" {<br/>  cidr_block = "192.168.20.0/24"<br/>  vpc_id = "${aws_vpc.my-vpc.id}"<br/>  #availability_zone = "us-east-1a"<br/>  map_public_ip_on_launch = false</span><span id="6279" class="kx ky iq mb b gy mm mg l mh mi">  tags = {<br/>    Name = "192.168.20.0"<br/>  }<br/>}</span></pre><p id="618d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意vpc_id，它的值被定义为<code class="fe mj mk ml mb b">“${aws_vpc.my-vpc.id}”</code>,这是为了使用名称为“my_vpc”的aws_vpc资源，正如我们刚刚在上面定义的那样，获取<code class="fe mj mk ml mb b">id</code>字段，将其分配给vpc_id。我们不需要复制VPC id值或硬编码它的id值。</p><p id="1bc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于web-subnet中的实例，我们将通过将字段<code class="fe mj mk ml mb b">map_public_ip_on_launch</code>设置为true来分配一个公共IP。而对于DB子网，不分配公共IP。</p><p id="4aaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">分别创建互联网网关和NAT网关，</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ca0d" class="kx ky iq mb b gy mf mg l mh mi"># Defining the VPC Internet Gateway<br/>resource "aws_internet_gateway" "my-internet-gw" {<br/>  vpc_id = "${aws_vpc.my-vpc.id}"</span><span id="9fa9" class="kx ky iq mb b gy mm mg l mh mi">  tags = {<br/>    Name = "my-internet-gw"<br/>  }<br/>}</span><span id="d771" class="kx ky iq mb b gy mm mg l mh mi"># Defining the Elastic IP Address for NAT<br/>resource "aws_eip" "nat" {<br/>  vpc = true<br/>}</span><span id="dd50" class="kx ky iq mb b gy mm mg l mh mi"># Defining the VPC NAT Gateway<br/>resource "aws_nat_gateway" "my-nat-gw" {<br/>  allocation_id = "${aws_eip.nat.id}"<br/>  subnet_id     = "${aws_subnet.web-subnet.id}"<br/>  depends_on = [aws_internet_gateway.my-internet-gw]<br/>  tags = {<br/>    Name = "my nat gateway"<br/>  }<br/>}</span></pre><p id="ebe3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">NAT网关将使用web子网，以便它可以通过internet网关与internet对话。</p><p id="4d0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们创建路由表。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1ed3" class="kx ky iq mb b gy mf mg l mh mi"># Defining the route table for web subnet<br/>resource "aws_route_table" "webzone-rt" {<br/>  vpc_id = "${aws_vpc.my-vpc.id}"</span><span id="6118" class="kx ky iq mb b gy mm mg l mh mi">  route {<br/>    cidr_block = "0.0.0.0/0"<br/>    gateway_id = "${aws_internet_gateway.my-internet-gw.id}"<br/>  }</span><span id="ee3f" class="kx ky iq mb b gy mm mg l mh mi">  tags = {<br/>    Name = "webzone route"<br/>  }<br/>}</span><span id="e690" class="kx ky iq mb b gy mm mg l mh mi"># Associating the web subnet<br/>resource "aws_route_table_association" "web-rt-association" {<br/>  route_table_id = "${aws_route_table.webzone-rt.id}"<br/>  subnet_id = "${aws_subnet.web-subnet.id}"<br/>}</span><span id="6197" class="kx ky iq mb b gy mm mg l mh mi"># Defining the route table for private subnet<br/>resource "aws_route_table" "dbzone-rt" {<br/>  vpc_id = "${aws_vpc.my-vpc.id}"</span><span id="87d5" class="kx ky iq mb b gy mm mg l mh mi">  route {<br/>    cidr_block = "0.0.0.0/0"<br/>    gateway_id = "${aws_nat_gateway.my-nat-gw.id}"<br/>  }</span><span id="0188" class="kx ky iq mb b gy mm mg l mh mi">  tags = {<br/>    Name = "DB zone route"<br/>  }<br/>}</span><span id="3cf8" class="kx ky iq mb b gy mm mg l mh mi"># Associating the DB subnet to the NAT exposed route table<br/>resource "aws_route_table_association" "db-rt-association" {<br/>  route_table_id = "${aws_route_table.dbzone-rt.id}"<br/>  subnet_id = "${aws_subnet.db-subnet.id}"<br/>}</span></pre><p id="a0c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在web区域中，对于通向外部(0.0.0.0/0)的流量，我们将其路由到互联网网关。在DB区域中，流量将通过NAT网关路由，以便该区域中的EC2实例仍然可以通过NAT访问互联网。</p><p id="e164" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过创建<code class="fe mj mk ml mb b">aws_route_table_association</code>的资源来显式地将子网与其路由表相关联</p><p id="f739" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们为EC2实例创建安全组。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2522" class="kx ky iq mb b gy mf mg l mh mi"># Security Group for web subnet<br/>resource "aws_security_group" "web-sg" {<br/>  name = "web-sg"<br/>  description = "Allow HTTP/SSH Access"<br/>  vpc_id = "${aws_vpc.my-vpc.id}"</span><span id="bcb7" class="kx ky iq mb b gy mm mg l mh mi">  tags = {<br/>    Name = "web sg"<br/>  }</span><span id="3f26" class="kx ky iq mb b gy mm mg l mh mi">  ingress {<br/>    from_port = 80<br/>    to_port = 80<br/>    protocol = "tcp"<br/>    cidr_blocks = ["0.0.0.0/0"]<br/>  }</span><span id="ace0" class="kx ky iq mb b gy mm mg l mh mi">  ingress {<br/>    from_port = 22<br/>    to_port = 22<br/>    protocol = "tcp"<br/>    cidr_blocks = ["0.0.0.0/0"]<br/>  }</span><span id="5009" class="kx ky iq mb b gy mm mg l mh mi">  egress {<br/>    from_port       = 0<br/>    to_port         = 0<br/>    protocol        = "-1"<br/>    cidr_blocks     = ["0.0.0.0/0"]<br/>  }<br/>}</span><span id="453b" class="kx ky iq mb b gy mm mg l mh mi">resource "aws_security_group" "db-sg" {<br/>  name = "db-sg"<br/>  description = "DB zone Access"<br/>  vpc_id = "${aws_vpc.my-vpc.id}"</span><span id="0a39" class="kx ky iq mb b gy mm mg l mh mi">  tags = {<br/>    Name = "db sg"<br/>  }</span><span id="0e88" class="kx ky iq mb b gy mm mg l mh mi">  ingress {<br/>    from_port = 22<br/>    to_port = 22<br/>    protocol = "tcp"<br/>    cidr_blocks = [aws_subnet.web-subnet.cidr_block]<br/>  }<br/>  <br/>  ingress {<br/>    from_port = 3306<br/>    to_port = 3306<br/>    protocol = "tcp"<br/>    cidr_blocks = [aws_subnet.web-subnet.cidr_block]<br/>  }</span><span id="3895" class="kx ky iq mb b gy mm mg l mh mi">  egress {<br/>    from_port = 0<br/>    to_port = 0<br/>    protocol = "-1"<br/>    cidr_blocks = ["0.0.0.0/0"]<br/>  }<br/>}</span></pre><p id="1eb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于web zone EC2实例，除了SSH之外，我们还允许HTTP访问。在DB区域中，只允许来自web区域的SSH/MySQL(3306)。允许任何传出流量。</p><p id="8e6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">VPC设置完成。网络ACL是随着VPC的创建而创建的默认ACL。</p><p id="4bc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经准备好创建我们的EC2实例。但在此之前，让我们创建SSK密钥对。</p><h2 id="21c5" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">SSH密钥对:ssh-key.tf</h2><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="35be" class="kx ky iq mb b gy mf mg l mh mi">resource "aws_key_pair" "mykey" {<br/>  key_name   = "mykey"<br/>  public_key = file(pathexpand("~/.ssh/id_rsa.pub"))<br/>}</span></pre><p id="dd42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们调用Terraform函数文件来读取我的本地公共SSH密钥的内容，在AWS中创建资源并将其命名为<code class="fe mj mk ml mb b">mykey</code>。</p><h2 id="9f9f" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">EC2实例:ec2.tf</h2><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a94c" class="kx ky iq mb b gy mf mg l mh mi">resource "aws_instance" "web-server" {<br/>  ami = "${var.aws_ami}"<br/>  subnet_id = "${aws_subnet.web-subnet.id}"<br/>  instance_type = "t2.micro"<br/>  key_name = "${var.ssh_key_name}"<br/>  #user_data = "${file("httpd.sh")}"<br/>  vpc_security_group_ids = ["${aws_security_group.web-sg.id}"]<br/>  <br/>  tags = {<br/>    Name = "web-server"<br/>  }<br/>}</span><span id="2c0a" class="kx ky iq mb b gy mm mg l mh mi">resource "aws_instance" "db-server" {<br/>  ami = "${var.aws_ami}"<br/>  subnet_id = "${aws_subnet.db-subnet.id}"<br/>  instance_type = "t2.micro"<br/>  associate_public_ip_address = false<br/>  <br/>  key_name = "${var.ssh_key_name}"<br/>  vpc_security_group_ids = ["${aws_security_group.db-sg.id}"]<br/>  <br/>  tags = {<br/>    Name = "db-server"<br/>  }<br/>}</span></pre><p id="e683" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用来自变量aws_ami的AMI创建EC2实例。对于数据库服务器，我们将<code class="fe mj mk ml mb b">associate_public_ip_address</code>设置为false，因此没有为它分配公共IP。</p><h2 id="9b06" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">创造资源</h2><p id="6cc5" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">一旦所有的tf文件都准备好了，我们就可以创建资源了，</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f70e" class="kx ky iq mb b gy mf mg l mh mi">terraform plan<br/>terraform apply -auto-approve</span></pre><p id="5b75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个计划就像一次演习。应用程序将创建资源。</p><p id="b7f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以运行<code class="fe mj mk ml mb b">terraform destroy</code>来删除所有创建的资源。</p></div></div>    
</body>
</html>