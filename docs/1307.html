<html>
<head>
<title>GraphQL Mutation Arguments Validation with Yup using graphql-middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL中间件使用Yup进行graphql变异参数验证</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-mutation-arguments-validation-with-yup-using-graphql-middleware-645822fb748?source=collection_archive---------1-----------------------#2018-09-06">https://itnext.io/graphql-mutation-arguments-validation-with-yup-using-graphql-middleware-645822fb748?source=collection_archive---------1-----------------------#2018-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/fa73843a5e0f584d2a99322b778dbcad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gREOEEM39RWzrvbkwsq2AQ.png"/></div></div></figure><div class=""/><blockquote class="jy jz ka"><p id="a269" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个故事被移到:<a class="ae la" href="https://jonathancardoso.com/en/blog/graphql-mutation-arguments-validation-with-yup-using-graphql-middleware/" rel="noopener ugc nofollow" target="_blank">https://jonathancardoso . com/en/blog/graph QL-mutation-arguments-validation-with-yup-using-graph QL-middleware/</a></p></blockquote><p id="a44c" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最近我发现了Prisma开发的名为<code class="fe le lf lg lh b"><a class="ae la" href="https://github.com/prisma/graphql-middleware" rel="noopener ugc nofollow" target="_blank">graphql-middleware</a></code>的令人敬畏的库，它允许在调用GraphQL解析器之前/之后运行任意代码。</p><p id="c10a" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这篇文章中，我将展示如何使用<a class="ae la" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank">yes</a>创建一个中间件来验证任何GraphQL变体的输入参数。</p><h2 id="a738" class="li lj jb bd lk ll lm dn ln lo lp dp lq lb lr ls lt lc lu lv lw ld lx ly lz ma bi translated">初始代码</h2><p id="1ef3" class="pw-post-body-paragraph kb kc jb ke b kf mb kh ki kj mc kl km lb md kp kq lc me kt ku ld mf kx ky kz ij bi translated">对于这个例子，我们将创建一个简单的<code class="fe le lf lg lh b">graphql-yoga</code>服务器，初始代码如下:</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h2 id="b606" class="li lj jb bd lk ll lm dn ln lo lp dp lq lb lr ls lt lc lu lv lw ld lx ly lz ma bi translated">步骤1:添加中间件</h2><p id="375e" class="pw-post-body-paragraph kb kc jb ke b kf mb kh ki kj mc kl km lb md kp kq lc me kt ku ld mf kx ky kz ij bi translated">让我们把我们的中间件命名为<code class="fe le lf lg lh b">yupValidation</code>:</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="45f7" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">根据文档，中间件可以是一个对象，其键与它们应该执行的类型/字段相匹配。在我们的例子中，我们说我们想要在每一个突变上运行我们的中间件。</p><p id="4d9d" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">将其添加到<code class="fe le lf lg lh b">GraphQLServer</code>实例中:</p><pre class="mg mh mi mj gt mm lh mn mo aw mp bi"><span id="06e2" class="li lj jb lh b gy mq mr l ms mt">const server = new GraphQLServer({<br/>  typeDefs,<br/>  resolvers,<br/>  middlewares: [yupMutationMiddleware()],<br/>});</span></pre><p id="7590" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">它目前没有做任何有趣的事情，我们只是调用变异解析器并返回它。但是看到那些<code class="fe le lf lg lh b">console.log</code>了吗？他们可以向我们展示一些有趣的东西，如果我们现在向这个端点提交一个突变，让我们这样做，将这个突变发送到端点(您可以使用在与服务器相同的端口自动运行的playground):</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="efc3" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">控制台中将记录以下内容:</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/110035f6256ca2fe5b6e9c2c6f4f7317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFGmzEtduHTfLIKvZoUz1w.png"/></div></div></figure><p id="91ea" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这里的顺序很重要，您的中间件在调用字段<code class="fe le lf lg lh b">resolve</code>的之前执行<strong class="ke jc">，您可以在您的中间件函数中随时调用<code class="fe le lf lg lh b">resolve</code>函数。</strong></p><h2 id="6739" class="li lj jb bd lk ll lm dn ln lo lp dp lq lb lr ls lt lc lu lv lw ld lx ly lz ma bi translated">步骤2:添加验证模式</h2><p id="0b50" class="pw-post-body-paragraph kb kc jb ke b kf mb kh ki kj mc kl km lb md kp kq lc me kt ku ld mf kx ky kz ij bi translated">让我们改变定义<code class="fe le lf lg lh b">AddUser</code>变异的方式，而不是直接放置resolve，让我们使用一个对象。在该对象中，我们还要声明一个<code class="fe le lf lg lh b">validationSchema</code>属性，它将告诉我们如何验证变异的参数，这将是一个Yup模式:</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">不要忘记从文件顶部的“是”开始导入*</figcaption></figure><h2 id="0cfc" class="li lj jb bd lk ll lm dn ln lo lp dp lq lb lr ls lt lc lu lv lw ld lx ly lz ma bi translated">第三步。实现中间件</h2><p id="7e64" class="pw-post-body-paragraph kb kc jb ke b kf mb kh ki kj mc kl km lb md kp kq lc me kt ku ld mf kx ky kz ij bi translated">太好了！我们已经做好了一切准备，现在我们需要让它真正发挥作用。😅</p><p id="801c" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">基本思想是确定被调用的变异是否是用一个<code class="fe le lf lg lh b">validationSchema</code>属性定义的，如果是，用它来验证<code class="fe le lf lg lh b">args</code>，如果发现任何错误，就返回错误。</p><blockquote class="jy jz ka"><p id="ac9b" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，等等，我该如何在中间件中获得这个<code class="fe le lf lg lh b">validationSchema</code>属性呢？！？</p></blockquote><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mz ml l"/></div></figure><p id="d97a" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们将使用明显被遗忘但仍然重要的<code class="fe le lf lg lh b">info</code>属性。如果你从未使用过它或者不知道它是什么，Prisma有一个很棒的帖子<a class="ae la" href="https://www.prisma.io/blog/graphql-server-basics-demystifying-the-info-argument-in-graphql-resolvers-6f26249f613a/" rel="noopener ugc nofollow" target="_blank">揭开了info参数</a>的神秘面纱。</p><p id="5b12" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">总体思路是使用graphql-js的一个隐藏特性，即如果您在graphql模式的类型定义上传递额外的属性，它们将在解析器的<code class="fe le lf lg lh b">info</code>参数上可用。</p><blockquote class="jy jz ka"><p id="c8da" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jc">我个人认为，这是非常安全的使用。</strong></p></blockquote><p id="a1fd" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">下面的代码将像定义并传递给graphql-js一样检索突变字段:</p><pre class="mg mh mi mj gt mm lh mn mo aw mp bi"><span id="de88" class="li lj jb lh b gy mq mr l ms mt">const mutationField = info.schema.getMutationType().getFields()[info.fieldName];</span></pre><p id="de50" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><code class="fe le lf lg lh b">info.schema.getMutationType()</code>是不言自明的，它返回根类型<code class="fe le lf lg lh b">Mutation</code>，然后我们用他们的<code class="fe le lf lg lh b">getFields()</code>方法来检索他们所有的字段，基本上就是一个散列，里面有所有定义的突变，每个突变名称都是关键字。</p><p id="db80" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><code class="fe le lf lg lh b">info.fieldName</code>具有当前字段解析器的名称，因为我们的中间件将只针对突变运行，所以我们可以100%确定之前调用的<code class="fe le lf lg lh b">getFields()</code>将具有带有那个<code class="fe le lf lg lh b">fieldName</code>的键。</p><p id="de9c" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在一切都很简单了，我们只需要验证是否有一个<code class="fe le lf lg lh b">validationSchema</code>，如果有，根据它验证<code class="fe le lf lg lh b">args</code>。如果发现任何错误，我们将返回yup的验证消息作为变异调用结果中的错误字段，而不是调用变异<code class="fe le lf lg lh b">resolve</code>。</p><blockquote class="jy jz ka"><p id="267a" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">说多了，给我看看代码。</p></blockquote><p id="af64" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这是这样的:</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="1786" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">简单吧？现在，如果你用一个不符合你声明的有效性的<code class="fe le lf lg lh b">firstName</code>来调用突变:</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/df5a66b2550840612b6368adb3c2097a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*8-PTuudBtvg71L-OqX9d6Q.png"/></div></figure><p id="2748" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">万一您想要开箱即用的东西，我已经用这个中间件创建了一个包，但是经过一些改进和测试，请检查一下:</p><div class="ip iq gp gr ir nb"><a href="https://github.com/JCMais/graphql-yup-middleware" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd jc gy z fp ng fr fs nh fu fw ja bi translated">jcm ais/graph QL-yup-中间件</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">使用yup为您的突变参数添加验证！-jcm ais/graph QL-是的-中间件</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ix nb"/></div></div></a></div></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="e31e" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">GraphQL本身就非常强大，添加中间件会让它更加强大。您可以创建简单的验证中间件，比如上面的那个，也可以创建最复杂的验证中间件，比如授权/认证检查，并让您的变体接收已经从数据库中获取的对象作为参数，而不仅仅是ID！</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="3ee9" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">让我知道你要用这个创造什么！</p><p id="33e9" class="pw-post-body-paragraph kb kc jb ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">你也可以在推特上找到我:@_jonathancardos</p><div class="ip iq gp gr ir nb"><a href="https://twitter.com/_jonathancardos" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd jc gy z fp ng fr fs nh fu fw ja bi translated">乔纳森·卡多佐(@_jonathancardos) |推特</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">乔纳森·卡多佐的最新推文(@_jonathancardos)。全栈开发人员，大部分时间使用…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">twitter.com</p></div></div><div class="nk l"><div class="nx l nm nn no nk np ix nb"/></div></div></a></div><h2 id="bbbe" class="li lj jb bd lk ll lm dn ln lo lp dp lq lb lr ls lt lc lu lv lw ld lx ly lz ma bi translated">参考</h2><div class="ip iq gp gr ir nb"><a href="https://www.prisma.io/blog/graphql-middleware-zie3iphithxy/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd jc gy z fp ng fr fs nh fu fw ja bi translated">开源GraphQL中间件-简化解析器的库| Prisma</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">一个组织良好的代码库是维护和轻松引入应用程序变化的关键。弄清楚…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">www.prisma.io</p></div></div><div class="nk l"><div class="ny l nm nn no nk np ix nb"/></div></div></a></div></div></div>    
</body>
</html>