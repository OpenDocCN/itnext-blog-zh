<html>
<head>
<title>Performance Programming in Flutter — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振的性能规划第二部分</h1>
<blockquote>原文：<a href="https://itnext.io/performance-programming-in-flutter-part-2-aea22e5a9c32?source=collection_archive---------8-----------------------#2020-10-07">https://itnext.io/performance-programming-in-flutter-part-2-aea22e5a9c32?source=collection_archive---------8-----------------------#2020-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f160" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">在Flutter中使用低级分离API</em></strong></p><p id="5902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我之前的<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/performance-programming-in-flutter-using-isolates-part-1-997a29011e88">文章</a>中，我解释了如何在高层次上使用隔离。但是使用高级API有一些缺点。</p><p id="245d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过在高级计算功能上使用低级API，您可以获得对隔离的更多控制。您可以在任何时间点<em class="kl">暂停、恢复和停止</em>隔离，这是使用“<em class="kl">计算</em>功能无法实现的。</p><p id="25d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">让我们看看如何实现这些目标。</strong></p><h1 id="163a" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">观看视频</strong></h1><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">颤振分离物</figcaption></figure><p id="c380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我创建了一个自定义类来发送数据给<strong class="jp ir">隔离</strong>。我称之为线程参数。</p><pre class="ll lm ln lo gt lw lx ly lz aw ma bi"><span id="0a78" class="mb ko iq lx b gy mc md l me mf">class ThreadParams {<br/>  ThreadParams(this.val, this.sendPort);<br/>  int val;<br/>  SendPort sendPort;<br/>}</span></pre><p id="90f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，您可以看到其中一个参数是发送端口。这是隔离与呼叫隔离通信<br/>的端口。</p><p id="127e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有另一个名为ReceivePort的类，调用的Isolate类通过它取回数据。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="f71f" class="kn ko iq bd kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg mr li lj lk bi translated"><strong class="ak">开始隔离线程</strong></h1><p id="1a17" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">这就是start方法的样子。</p><pre class="ll lm ln lo gt lw lx ly lz aw ma bi"><span id="fae4" class="mb ko iq lx b gy mc md l me mf">Isolate _isolate;<br/> bool _running = false;<br/> ReceivePort _receivePort;<br/> Capability _capability;<br/> <br/> void _start() async {<br/>    if (_running) {<br/>      return;<br/>    }<br/>    setState(() {<br/>      _running = true;<br/>    });<br/>    _receivePort = ReceivePort();<br/>    ThreadParams threadParams = ThreadParams(2000,     _receivePort.sendPort);<br/>    _isolate = await Isolate.spawn(<br/>      _isolateHandler,<br/>      threadParams,<br/>    );<br/>    _receivePort.listen(_handleMessage, onDone: () {<br/>      setState(() {<br/>        _threadStatus = 'Stopped';<br/>      });<br/>    });<br/>}</span></pre><p id="ee88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将会创建一个新的隔离线程。调用方法通过<em class="kl"> _receivePort.listen </em>监听来自<em class="kl"> _isolate </em>的消息，receivePort.listen 具有接收消息的功能。</p><p id="bc25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> _handleMessage </em>可以是这样一个简单的函数。</p><pre class="ll lm ln lo gt lw lx ly lz aw ma bi"><span id="e46c" class="mb ko iq lx b gy mc md l me mf">void _handleMessage(dynamic data) {<br/>    print(data.toString());<br/>}</span></pre><p id="2d91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> _isolateHandler </em>方法是_isolate的入口方法，它应该是静态方法或者不应该是类中的方法。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="d1e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是<em class="kl"> _isolateHandler </em>，它包含了我们将要在<em class="kl"> _isolate </em>线程内部执行的大量操作方法。</p><pre class="ll lm ln lo gt lw lx ly lz aw ma bi"><span id="5da9" class="mb ko iq lx b gy mc md l me mf">static void _isolateHandler(ThreadParams threadParams) async {<br/>    heavyOperation(threadParams);<br/>  }<br/> <br/>  static void heavyOperation(ThreadParams threadParams) async {<br/>    int count = 10000;<br/>    while (true) {<br/>      int sum = 0;<br/>      for (int i = 0; i &lt; count; i++) {<br/>        sum += await computeSum(1000);<br/>      }<br/>      count += threadParams.val;<br/>      threadParams.sendPort.send(sum.toString());<br/>    }<br/>  }<br/> <br/>  static Future&lt;int&gt; computeSum(int num) {<br/>    Random random = Random();<br/>    return Future(() {<br/>      int sum = 0;<br/>      for (int i = 0; i &lt; num; i++) {<br/>        sum += random.nextInt(100);<br/>      }<br/>      return sum;<br/>    });<br/>  }</span></pre><h1 id="8f50" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">暂停、恢复和停止隔离</strong></h1><pre class="ll lm ln lo gt lw lx ly lz aw ma bi"><span id="5ffa" class="mb ko iq lx b gy mc md l me mf">void _pause() {<br/>  if (null != _isolate) {<br/>    _paused ? _isolate.resume(_capability) : _capability = _isolate.pause();<br/>    setState(() {<br/>      _paused = !_paused;<br/>      _threadStatus = _paused ? 'Paused' : 'Resumed';<br/>    });<br/>  }<br/>}<br/> <br/>void _stop() {<br/>  if (null != _isolate) {<br/>    setState(() {<br/>      _running = false;<br/>    });<br/>    _receivePort.close();<br/>    _isolate.kill(priority: Isolate.immediate);<br/>    _isolate = null;<br/>  }<br/>}</span></pre><p id="83da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里要理解的主要事情是暂停隔离是为了恢复隔离，我们需要一个在暂停隔离时可以得到的能力对象。隔离暂停将返回可用于恢复隔离能力。</p><h1 id="665b" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">发送消息</strong></h1><p id="038d" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated"><code class="fe mx my mz lx b">threadParams.sendPort.send(sum.toString());</code></p><p id="92ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> SendPort.send </em>用于将消息发送回调用隔离。我这里所说的隔离是指运行Flutter应用程序的主隔离。</p><p id="c38f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是最基本的。</p><h1 id="b26d" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">完整示例</h1><p id="f205" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">这是一个完整的例子。</p><pre class="ll lm ln lo gt lw lx ly lz aw ma bi"><span id="5ac9" class="mb ko iq lx b gy mc md l me mf">import 'package:flutter/material.dart';<br/>import 'dart:isolate';<br/>import 'dart:math';<br/>import 'dart:async';<br/> <br/>class PerformancePage extends StatefulWidget {<br/>  final String title = "Isolates Demo";<br/> <br/>  <a class="ae km" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  _PerformancePageState createState() =&gt; _PerformancePageState();<br/>}<br/> <br/>class _PerformancePageState extends State&lt;PerformancePage&gt; {<br/>  //<br/>  Isolate _isolate;<br/>  bool _running = false;<br/>  bool _paused = false;<br/>  String _message = '';<br/>  String _threadStatus = '';<br/>  ReceivePort _receivePort;<br/>  Capability _capability;<br/> <br/>  void _start() async {<br/>    if (_running) {<br/>      return;<br/>    }<br/>    setState(() {<br/>      _running = true;<br/>      _message = 'Starting...';<br/>      _threadStatus = 'Running...';<br/>    });<br/>    _receivePort = ReceivePort();<br/>    ThreadParams threadParams = ThreadParams(2000, _receivePort.sendPort);<br/>    _isolate = await Isolate.spawn(<br/>      _isolateHandler,<br/>      threadParams,<br/>    );<br/>    _receivePort.listen(_handleMessage, onDone: () {<br/>      setState(() {<br/>        _threadStatus = 'Stopped';<br/>      });<br/>    });<br/>  }<br/> <br/>  void _pause() {<br/>    if (null != _isolate) {<br/>      _paused ? _isolate.resume(_capability) : _capability = _isolate.pause();<br/>      setState(() {<br/>        _paused = !_paused;<br/>        _threadStatus = _paused ? 'Paused' : 'Resumed';<br/>      });<br/>    }<br/>  }<br/> <br/>  void _stop() {<br/>    if (null != _isolate) {<br/>      setState(() {<br/>        _running = false;<br/>      });<br/>      _receivePort.close();<br/>      _isolate.kill(priority: Isolate.immediate);<br/>      _isolate = null;<br/>    }<br/>  }<br/> <br/>  void _handleMessage(dynamic data) {<br/>    setState(() {<br/>      _message = data;<br/>    });<br/>  }<br/> <br/>  static void _isolateHandler(ThreadParams threadParams) async {<br/>    heavyOperation(threadParams);<br/>  }<br/> <br/>  static void heavyOperation(ThreadParams threadParams) async {<br/>    int count = 10000;<br/>    while (true) {<br/>      int sum = 0;<br/>      for (int i = 0; i &lt; count; i++) {<br/>        sum += await computeSum(1000);<br/>      }<br/>      count += threadParams.val;<br/>      threadParams.sendPort.send(sum.toString());<br/>    }<br/>  }<br/> <br/>  static Future&lt;int&gt; computeSum(int num) {<br/>    Random random = Random();<br/>    return Future(() {<br/>      int sum = 0;<br/>      for (int i = 0; i &lt; num; i++) {<br/>        sum += random.nextInt(100);<br/>      }<br/>      return sum;<br/>    });<br/>  }<br/> <br/>  <a class="ae km" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(BuildContext context) {<br/>    return new Scaffold(<br/>      appBar: new AppBar(<br/>        title: new Text(widget.title),<br/>      ),<br/>      body: new Container(<br/>        padding: EdgeInsets.all(20.0),<br/>        alignment: Alignment.center,<br/>        child: new Column(<br/>          children: &lt;Widget&gt;[<br/>            !_running<br/>                ? OutlineButton(<br/>                    child: Text('Start Isolate'),<br/>                    onPressed: () {<br/>                      _start();<br/>                    },<br/>                  )<br/>                : SizedBox(),<br/>            _running<br/>                ? OutlineButton(<br/>                    child: Text(_paused ? 'Resume Isolate' : 'Pause Isolate'),<br/>                    onPressed: () {<br/>                      _pause();<br/>                    },<br/>                  )<br/>                : SizedBox(),<br/>            _running<br/>                ? OutlineButton(<br/>                    child: Text('Stop Isolate'),<br/>                    onPressed: () {<br/>                      _stop();<br/>                    },<br/>                  )<br/>                : SizedBox(),<br/>            SizedBox(<br/>              height: 20.0,<br/>            ),<br/>            Text(<br/>              _threadStatus,<br/>              style: TextStyle(<br/>                fontSize: 20.0,<br/>              ),<br/>            ),<br/>            SizedBox(<br/>              height: 20.0,<br/>            ),<br/>            Text(<br/>              _message,<br/>              style: TextStyle(<br/>                fontSize: 20.0,<br/>                color: Colors.green,<br/>              ),<br/>            ),<br/>          ],<br/>        ),<br/>      ),<br/>    );<br/>  }<br/>}<br/> <br/>class ThreadParams {<br/>  ThreadParams(this.val, this.sendPort);<br/>  int val;<br/>  SendPort sendPort;<br/>}</span></pre><p id="e069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。</p><p id="6bd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你觉得这篇文章有用，请鼓掌。</p><p id="8a5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">感谢阅读，如果你觉得我的帖子有用，请在下面留下你的宝贵意见，订阅我的</em> <a class="ae km" href="https://www.youtube.com/channel/UC5lbdURzjB0irr-FTbjWN1A" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> youtube频道</em> </a> <em class="kl">获取更多视频。</em></p></div></div>    
</body>
</html>