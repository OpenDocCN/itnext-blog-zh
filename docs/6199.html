<html>
<head>
<title>Micro Frontends don’t exist.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端不存在。</h1>
<blockquote>原文：<a href="https://itnext.io/micro-frontends-dont-exist-93228c6d2a73?source=collection_archive---------1-----------------------#2021-09-17">https://itnext.io/micro-frontends-dont-exist-93228c6d2a73?source=collection_archive---------1-----------------------#2021-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3dae55c28736bad48f147005191a88b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7efOdo8lRTjHsNJ1UgOsiw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">伊万·阿列克西奇在<a class="ae kc" href="https://unsplash.com/s/photos/crossroads?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="bf87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">更新(10月17日):关于联邦架构策略的一系列文章和一本书即将出版。这个故事可能包含过时的信息和一些天真的断言。请谨慎阅读。</em></p><h1 id="70b1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">还给凯撒…</h1><p id="4059" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">你最近一定看了很多关于“微前端”的东西。但是你对它了解多少呢？根据自己的定义，一个<em class="lb">微前端</em>到底会是什么样子？定义通常所说的<em class="lb">微前端</em>的正确术语是什么？实际上，这个名字背后的故事和它后来的用法是相当尴尬的。</p><p id="d0d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">微前端</em>这个词终于在2016年出现。它被描述为“前端的微服务”。在如何设计微前端的背后有一个非常宽泛的想法…但是这个术语本身很快成为主流。</p><p id="c19c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天，我们已经弄清楚了如何使用Webpack模块联盟正确地解耦前端<em class="lb">，但是这是否会使前端<em class="lb">微前端</em>？不完全是。</em></p><h1 id="476c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">前端微服务？</h1><p id="0011" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">什么是微服务？它是软件架构策略的一部分，其中来自整体架构的服务被分割成更小的部分并独立开发。每个服务都独立存在。它可以通过API网关访问，并且执行的操作数量非常少。它们通常按域划分，用于执行CRUD操作(！).</p><p id="4ee2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">后来影响前端的误解和耻辱从这里开始。</p><blockquote class="mf mg mh"><p id="ca90" class="kd ke lb kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">微前端被误称为微前端。有点像智商:它实际上不评价智力，而是评价推理能力。</p></blockquote><p id="8fd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从技术上讲，<em class="lb">微前端</em>必须:</p><ol class=""><li id="6780" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">执行单个前端操作。</li><li id="9ff7" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">不了解其他前端。</li><li id="0f71" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">成为更大整体的一部分。</li></ol><p id="7727" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于这三点，任何前端开发者都可以很容易地发现使用术语<em class="lb">微前端</em>的误解。前端不是服务，因此<em class="lb">微前端</em>不是“微服务”。设计本质上是不同的，不应该进行比较。微服务通常执行CRUD操作。今天提出的微前端的方式一点也不“微”。因此，<em class="lb">微前端</em>和“微服务”的唯一共同点是两者都是独立开发的。</p><blockquote class="mf mg mh"><p id="8886" class="kd ke lb kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">微前端可能存在，但它不是一个体系结构，它不以出售给你的方式存在:它是一个独立的组件。</p></blockquote></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="bb83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们再来看看微前端应该遵循的3个技术规则。</p><ol class=""><li id="2869" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">执行单个前端操作。</li></ol><p id="a8f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是所谓的组件。如果你用的是<a class="ae kc" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>，一个<em class="lb">微前端</em>可能是一个<a class="ae kc" href="https://medium.com/@LayZeeDK/scam-single-component-angular-module-97a891916216" rel="noopener">骗局</a>组件。</p><p id="1e16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.不了解其他前端。</p><p id="f901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以争论这个。如果完全隔离，如何接触到<em class="lb">微前端</em>？宿主应用程序。从技术上讲，您可以让独立的前端独立工作，但这没有意义。主机应用程序是系统的关键部分，它必须了解所有托管的前端。</p><p id="2c00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.成为更大整体的一部分。</p><p id="408c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用<em class="lb">微前端</em>这个词，我们给一个技术上不可行的解决方案打上了烙印，也不符合“微前端服务”的定义。此术语只有在前端完全隔离(无主机)的情况下才有效。相比之下，微服务可以在完全隔离的情况下运行，并且仍然会执行它们被创建的目的。</p><p id="9fa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就架构而言，没有<em class="lb">微前端架构</em>，但有<strong class="kf ir">联合架构策略</strong> (FAS)，其中一个或多个<strong class="kf ir">联合者、</strong>主机知道它必须加载的<strong class="kf ir">联合</strong>应用以确保系统的有效性。</p><p id="e028" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有很多例子表明<em class="lb">微前端</em>本身就是pwn，但这三个例子是显而易见的。你练习联合架构(在我们的例子中是联合前端)越多，你就越能理解今天描述的术语<em class="lb">微前端</em>背后的误解。</p><h1 id="b81b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">联合架构战略(FAS)</h1><p id="4cbe" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们今天谈论<em class="lb">微前端</em>不能不提到<a class="ae kc" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank"> Webpack模块联盟</a>由<a class="ng nh ep" href="https://medium.com/u/9ef1379caffc?source=post_page-----93228c6d2a73--------------------------------" rel="noopener" target="_blank"> Zack Jackson </a>创建，并受到<a class="ae kc" href="https://www.apollographql.com/docs/federation/" rel="noopener ugc nofollow" target="_blank"> Apollo联盟</a>的启发。为什么？因为<em class="lb">微前端</em>事实上是<em class="lb">事实上是</em>——不是<em class="lb">微前端</em>而是联邦前端(FF)。谈论不存在的、以不同技术命名的东西，不是把属于凯撒的东西给凯撒。</p><p id="cfba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要前端为前端服务，就只有前端。不是“微前端”。我们所说的由主机应用程序单独开发和持有前端并不是“微前端架构”，而是联合架构。</p><blockquote class="mf mg mh"><p id="139b" class="kd ke lb kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">我们所说的“微前端”是遵循联合架构策略的前端。</p></blockquote><h1 id="a3c7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">选择加入的决定性因素是什么？</h1><p id="51ec" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我个人使用联邦前端已经有一段时间了。我一直在研究、试用和做许多关于通常所说的“微前端架构”的演示。这让我意识到他们并不存在。这种类型的架构风格只针对大项目和大团队的污名是很有争议的。就架构而言，没有唯一的解决方案，因此联邦架构可以根据其特性适合任何项目，而不管其规模或团队规模如何。</p><p id="a3c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们假设我们正在创建一个应用程序。我们已经知道这个应用程序的各个部分在下一年不会改变。为什么每次我们想在其他应用程序上部署变更时，都要重新编译这些部分呢？在这种情况下，使用FA可以利用webpack模块联合。如果您在monorepo环境中工作，您还可以利用增量构建，只构建已经更改的应用程序。这将使你的CD/CI渠道飞速发展。</p><h1 id="2091" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">自己试试！</h1><p id="7fc3" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">使用应用程序联合是一个非常酷的实验，可以减轻桌面和移动应用程序的负担。什么是好的移动应用？可能是它能够为最终用户提供应用程序中最少的功能。使用FA时，可以在运行时选择加载哪个前端，不加载哪个前端。是不是很棒？你不需要在每台设备上捆绑或在DDD上运行来确保你的用户得到他想要的。您不必为了显示或不显示某个组件而在代码中添加条件语句。您只需配置主机应用程序(federator)来服务您的应用程序(federated)的模块。由于移动设备的伸缩性至关重要，联合架构可能会有很大帮助。</p><p id="fb1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">联邦应用程序的使用正在改变我们开发应用程序的方式。它将任何类型的依赖关系移动到松散依赖关系。应用程序在运行时被解析，可以很容易地被替换或替代。再说一次，我们谈论的是应用而不是微前端，因为有些应用可能没有微…</p><h1 id="7e30" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="6f90" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这篇文章不是为了解决围绕<em class="lb">微前端</em>的现有炒作，但我认为把东西放回它们该在的地方是很有趣的。</p><p id="cfc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您对联合架构感兴趣，我将非常乐意与您分享选择这种架构时的好、坏以及——有时——丑陋之处。你可以通过推特联系我，或者在下面留言，我会尽快回复你。</p><p id="048f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的关注。我真的希望你喜欢这本书，它充满了爱。</p><p id="a551" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">学分:</p><div class="ni nj gp gr nk nl"><a href="https://medium.com/swlh/webpack-5-module-federation-a-game-changer-to-javascript-architecture-bcdd30e02669" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">Webpack 5联盟:JavaScript架构的游戏改变者</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">多个Webpack构建一起工作，就像一个整体。运行时轻松、可扩展的编排，在两个客户端上…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz jw nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://webpack.js.org/concepts/module-federation/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">模块联盟|网络包</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">多个独立的构建应该形成一个应用程序。这些独立的版本之间不应该有依赖关系…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">webpack.js.org</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz jw nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://microservices.io/patterns/microservices.html" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">微服务模式:微服务架构模式</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">您正在开发一个服务器端企业应用程序。它必须支持各种不同的客户端，包括…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">微服务. io</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz jw nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://www.apollographql.com/docs/federation/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">阿波罗联盟简介</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">为了充分利用GraphQL，您的组织应该公开一个提供统一接口的单一数据图…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">www.apollographql.com</p></div></div><div class="nu l"><div class="oc l nw nx ny nu nz jw nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">微前端</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">Cam Jackson Cam Jackson是Thoughtworks的一名全栈web开发人员和顾问，他对如何…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">martinfowler.com</p></div></div><div class="nu l"><div class="od l nw nx ny nu nz jw nl"/></div></div></a></div></div></div>    
</body>
</html>