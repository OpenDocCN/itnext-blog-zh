<html>
<head>
<title>Kotlin: sequences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林:序列</h1>
<blockquote>原文：<a href="https://itnext.io/kotlin-sequences-c5a3f6228eca?source=collection_archive---------3-----------------------#2018-06-21">https://itnext.io/kotlin-sequences-c5a3f6228eca?source=collection_archive---------3-----------------------#2018-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/779ee1238466713f1edb0ed29bacaf3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s2Ymw7pYFDY_YTGa"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Johannes Hofmann 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="71cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当使用集合和Kotlin的<a class="ae kc" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-collection/index.html" rel="noopener ugc nofollow" target="_blank">大量的<em class="lb">集合函数</em> </a>时，我们倾向于忘记性能，假设Kotlin的<em class="lb">集合函数</em>设计得很好并且执行得非常好。尽管这是完全正确的，但是当我们链接这些函数时，性能会受到影响。</p><h2 id="26ed" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">急切地创造中间系列</h2><p id="6001" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">这些是Kotlin创建的集合，用于评估一系列的<em class="lb">集合函数</em>调用。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="a986" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">科特林在这个调用链上创建了两个列表。一个用于<em class="lb">贴图</em>的结果，另一个用于<em class="lb">过滤器</em>的结果。这对于少量的元素是可以的，但是对于大的列表就不行了。</p><h1 id="b57f" class="mg ld iq bd le mh mi mj lh mk ml mm lk mn mo mp ln mq mr ms lq mt mu mv lt mw bi translated">顺序</h1><p id="3908" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在Kotlin中，你可以使用<em class="lb">序列</em>来避免创建中间集合。语法非常简单。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="bd2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们得到了相同的结果，但性能更好。我们可以用<em class="lb"> asSequence() </em>将任何集合转换成序列，然后用<em class="lb"> toList()将其反向转换。</em></p><p id="87ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列表中的每个元素首先被映射，然后被过滤，相反如果我们不使用<em class="lb">序列，</em>将首先映射所有列表，然后过滤那个<em class="lb">映射的结果</em>。</p><blockquote class="mx my mz"><p id="d6d7" class="kd ke lb kf b kg kh ki kj kk kl km kn na kp kq kr nb kt ku kv nc kx ky kz la ij bi translated">序列类似于Java的8 s流，但是没有在多个CPU上并行运行流操作的选项。</p></blockquote><h2 id="2206" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">懒惰操作</h2><p id="4427" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">执行<em class="lb">序列时有两种操作。</em></p><ul class=""><li id="d85a" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated"><strong class="kf ir"> <em class="lb">中间运算:</em> </strong>返回另一个序列:<em class="lb"> map()、filter()… </em></li><li id="0d02" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated"><strong class="kf ir"> <em class="lb">终端操作:</em> </strong> <em class="lb"> </em>返回一个元素。一个集合，一个数字，一个对象等:<em class="lb"> toList()，find()，count()… </em></li></ul><p id="04a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有当<em class="lb">终端操作</em>被调用<em class="lb">时，中间操作</em>才被执行。</p><h2 id="95e4" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">创建一个序列</h2><p id="73bd" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">直接从lambda中创建一个序列非常有用，而且非常容易做到。我们使用带有“种子”值的<em class="lb">生成序列</em>，在本例中为0，在本例中为λ<em class="lb">{ it+1 }</em>。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="9ce3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，直到调用此链的<em class="lb"> sum、</em>和<em class="lb">终端操作</em>时，才会执行前2行。</p><h2 id="21fa" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">改进序列</h2><p id="4d63" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们可以将<em class="lb">集合函数</em>分为两组。</p><ul class=""><li id="5f9f" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated">总是在整个集合数据上运行的:<em class="lb"> map()，filter()… </em></li><li id="38ce" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">不需要在所有数据上运行的:<em class="lb"> find()、any()……</em></li></ul><p id="d995" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这两个类别，并且如前所述，在一个<em class="lb">序列e </em>中，列表中的每个元素在传递到下一个元素之前执行所有的链操作，我们可以假设使用<em class="lb">序列</em>可以进一步提高性能。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="d7f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们可以在第一个链中看到map是在整个列表中执行的。</p><p id="1248" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二个例子中，因为它是在一个<em class="lb">序列上执行的，</em>映射<em class="lb">在第一个元素上执行，然后传递给<em class="lb">查找</em>函数并终止。<em class="lb"> find </em>函数在找到lambda的第一个出现时返回，而它恰好是我们数组中的第一个。</em></p><blockquote class="nr"><p id="56fa" class="ns nt iq bd nu nv nw nx ny nz oa la dk translated">作为一个Kotlin规则，每当你对一个大集合进行链式操作时，就使用序列。在常规收集中，急切的操作会高效地执行。</p></blockquote><h1 id="6649" class="mg ld iq bd le mh mi mj lh mk ml mm lk mn oc mp ln mq od ms lq mt oe mv lt mw bi translated">结论</h1><p id="174f" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">当使用<em class="lb">集合函数链时，</em>我们可以更快地编码，使用标准库函数并获得可读代码。关注我们的集合有多大，当它们很大时使用<em class="lb">序列</em>，将避免未来的性能问题。</p></div></div>    
</body>
</html>