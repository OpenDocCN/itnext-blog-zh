<html>
<head>
<title>Managing AWS Infrastructure as Code using Ansible, CloudFormation, and CodeBuild</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Ansible、CloudFormation和CodeBuild将AWS基础设施作为代码进行管理</h1>
<blockquote>原文：<a href="https://itnext.io/managing-aws-infrastructure-as-code-using-ansible-cloudformation-and-codebuild-7edb2e515dff?source=collection_archive---------2-----------------------#2019-07-30">https://itnext.io/managing-aws-infrastructure-as-code-using-ansible-cloudformation-and-codebuild-7edb2e515dff?source=collection_archive---------2-----------------------#2019-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/891ae1cb4d3bd0753f1ed2f3aaed6caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCDPa_mdlBL_JQUj_27-0g.png"/></div></div></figure><p id="2ee5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当谈到在AWS云平台上供应和配置资源时，有各种各样的服务、工具和工作流可供选择。您可以决定专门使用AWS提供的基于云的服务，如CodeBuild、CodePipeline、CodeStar和OpsWorks。或者，您可以选择开源软件(OSS)来提供和配置AWS资源，例如社区版的Jenkins、HashiCorp Terraform、Pulumi、Chef和Puppet。您也可以选择使用许可产品，例如Octopus Deploy、TeamCity、CloudBees Core、Travis CI Enterprise和XebiaLabs XL Release。您甚至可能决定用Python、Go、JavaScript、Bash或其他常见语言编写自己的定制工具或脚本。</p><p id="2e25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实上，在我接触过的大多数企业中，团队将AWS服务、开源软件、定制脚本和偶尔获得许可的产品相结合，构建完整的端到端基础架构，作为基于代码的工作流，用于供应和配置AWS资源。选择通常基于团队经验、供应商关系和企业的特定业务用例。</p><p id="1b8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在接下来的文章中，我们将探索这样一组易于集成的工具，用于供应和配置AWS资源。该工具堆栈由Red Hat Ansible、AWS CloudFormation和AWS CodeBuild以及几项补充性的AWS技术组成。使用这些工具，我们将提供一个相对简单的AWS环境，然后部署、配置和测试一组高度可用的Apache HTTP服务器。该演示类似于上一篇文章<a class="ae kz" href="https://programmaticponderings.com/2019/01/30/getting-started-with-red-hat-ansible-for-google-cloud-platform/" rel="noopener ugc nofollow" target="_blank">中介绍的Google云平台红帽Ansible入门</a>中的演示。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/7753fddb415ee872c701ddfdc6779a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LpN-AjOUJBhKp0_oEBI5cA.png"/></div></div></figure><h1 id="c2bb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么是Ansible？</h1><p id="fce9" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">自2012年以来，Ansible凭借其简单易用、与大多数主流云、数据库、网络、存储和身份提供商以及其他<a class="ae kz" href="https://docs.ansible.com/ansible/latest/modules/modules_by_category.html" rel="noopener ugc nofollow" target="_blank">类别</a>的广泛兼容性，成为工程团队配置管理的热门选择。鉴于现代企业中使用的多种语言技术，以及多云和混合云架构的优势日益增长，Ansible提供了一个通用平台，用于支持成熟的开发运维及基础设施作为代码实践。Ansible很容易与更高级别的编排系统集成，如AWS CodeBuild、Jenkins或<a class="ae kz" href="https://www.redhat.com/en/resources/awx-and-ansible-tower-datasheet" rel="noopener ugc nofollow" target="_blank">红帽AWX和Tower </a>。</p><h1 id="5cf4" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">技术</h1><p id="d562" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">本文中使用的主要技术包括。</p><h1 id="6991" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">红帽Ansible</h1><p id="79c0" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">Ansible，<a class="ae kz" href="https://www.redhat.com/en/about/press-releases/red-hat-acquire-it-automation-and-devops-leader-ansible" rel="noopener ugc nofollow" target="_blank">于2015年10月被Red Hat收购</a>，它在单一平台中无缝地提供了配置管理、供应和应用部署的工作流编排。与类似工具不同，Ansible的工作流自动化是无代理的，依赖于<a class="ae kz" href="https://en.wikipedia.org/wiki/Secure_Shell" rel="noopener ugc nofollow" target="_blank">安全外壳</a> (SSH)和<a class="ae kz" href="https://docs.microsoft.com/en-us/windows/desktop/winrm/about-windows-remote-management" rel="noopener ugc nofollow" target="_blank"> Windows远程管理</a> (WinRM)。如果您有兴趣了解Ansible的更多优势，他们已经发布了一份关于<a class="ae kz" href="https://www.ansible.com/hubfs/pdfs/Benefits-of-Agentless-WhitePaper.pdf" rel="noopener ugc nofollow" target="_blank">无代理架构的优势</a>的白皮书。</p><p id="528c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据<a class="ae kz" href="https://www.g2crowd.com/products/ansible/reviews" rel="noopener ugc nofollow" target="_blank"> G2人群</a>的调查，Ansible在<a class="ae kz" href="https://www.g2crowd.com/categories/configuration-management?segment=all" rel="noopener ugc nofollow" target="_blank">配置管理软件</a>类别中是一个明显的领导者，排在<a class="ae kz" href="https://about.gitlab.com/" rel="noopener ugc nofollow" target="_blank"> GitLab </a>之后。该类别的竞争者包括GitLab、AWS Config、<a class="ae kz" href="https://puppet.com/" rel="noopener ugc nofollow" target="_blank"> Puppet </a>、<a class="ae kz" href="https://www.chef.io/chef/" rel="noopener ugc nofollow" target="_blank"> Chef </a>、Codenvy、HashiCorp <a class="ae kz" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>、<a class="ae kz" href="https://octopus.com/" rel="noopener ugc nofollow" target="_blank"> Octopus Deploy </a>和JetBrains <a class="ae kz" href="https://www.jetbrains.com/teamcity/" rel="noopener ugc nofollow" target="_blank"> TeamCity </a>。</p><h1 id="25d7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">自动气象站云形成</h1><p id="e174" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">根据AWS的说法，<a class="ae kz" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> CloudFormation </a>提供了一种通用语言来描述和提供基于AWS的云环境中的所有基础设施资源。CloudFormation允许您使用基于JSON或YAML的模板，以自动化和安全的方式，在所有AWS区域和客户中建模和提供应用程序所需的所有资源。</p><p id="7e16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对基础设施进行编码，通常被称为“基础设施即代码”，允许您将基础设施视为代码。您可以使用任何IDE创作它，将其签入版本控制系统，并在部署它之前与团队成员一起检查文件。</p><h1 id="e8e3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">AWS代码构建</h1><p id="aa6b" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">根据AWS的说法，<a class="ae kz" href="https://aws.amazon.com/codebuild/" rel="noopener ugc nofollow" target="_blank"> CodeBuild </a>是一个完全托管的持续集成服务，它编译您的源代码，运行测试，并生成可以随时部署的软件包。使用CodeBuild，您不需要供应、管理和扩展您自己的构建服务器。CodeBuild不断扩展并同时处理多个构建，因此您的构建不会在队列中等待。</p><p id="cb68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CloudBuild与其他AWS开发人员工具无缝集成，包括CodeStar、CodeCommit、CodeDeploy和CodePipeline。</p><p id="3b44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">据<a class="ae kz" href="https://www.g2.com/products/aws-codebuild/competitors/alternatives" rel="noopener ugc nofollow" target="_blank"> G2人群</a>介绍，在构建自动化软件类别中，AWS CodeBuild的主要竞争对手包括<a class="ae kz" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>、<a class="ae kz" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>、<a class="ae kz" href="https://www.cloudbees.com/" rel="noopener ugc nofollow" target="_blank">cloud bees</a>Core and code ship、<a class="ae kz" href="https://travis-ci.org/" rel="noopener ugc nofollow" target="_blank"> Travis CI </a>、JetBrains <a class="ae kz" href="https://www.jetbrains.com/teamcity/" rel="noopener ugc nofollow" target="_blank"> TeamCity </a>和Atlassian <a class="ae kz" href="https://www.atlassian.com/software/bamboo" rel="noopener ugc nofollow" target="_blank"> Bamboo </a>。</p><h1 id="c293" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">其他技术</h1><p id="31d8" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">除了上面提到的主要技术之外，在演示中，我们还将在较小的程度上利用以下服务和工具:</p><ul class=""><li id="7430" class="mi mj it kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated">AWS代码提交</li><li id="c069" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">AWS代码管道</li><li id="320e" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">AWS系统管理器参数存储</li><li id="0f95" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">亚马逊简单存储服务(S3)</li><li id="8ce3" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">AWS身份和访问管理(IAM)</li><li id="4d59" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">AWS命令行界面(CLI)</li><li id="35e4" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">云形成棉绒</li><li id="55ef" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">Apache HTTP服务器</li></ul><h1 id="faa7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">源代码</h1><p id="9143" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">这篇文章的所有源代码都包含在两个GitHub存储库中。CloudFormation模板和相关文件位于<a class="ae kz" href="https://github.com/garystafford/ansible-aws-cfn" rel="noopener ugc nofollow" target="_blank"> ansible-aws-cfn </a> GitHub存储库中。Ansible角色和相关文件位于<a class="ae kz" href="https://github.com/garystafford/ansible-aws-roles" rel="noopener ugc nofollow" target="_blank">ansi ble-AWS-Roles</a>GitHub存储库中。可以使用以下命令克隆这两个存储库。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="a6b8" class="nb lg it mx b gy nc nd l ne nf">git clone --branch master --single-branch --depth 1 --no-tags \ <br/>  https://github.com/garystafford/ansible-aws-cfn.git<br/><br/>git clone --branch master --single-branch --depth 1 --no-tags \<br/>  https://github.com/garystafford/ansible-aws-roles.git</span></pre><h1 id="c10c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">显色法</h1><p id="6be9" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">在本演示中，我们将遵循资源调配和配置的一般流程如下:</p><ul class=""><li id="c9e5" class="mi mj it kd b ke kf ki kj km mk kq ml ku mm ky mn mo mp mq bi translated">创建一个S3桶来存储经验证的云形成模板</li><li id="2b84" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">为Ansible创建一个Amazon EC2密钥对</li><li id="edd4" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">创建两个AWS CodeCommit存储库来存储项目的源代码</li><li id="bce0" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">将参数放入参数存储中</li><li id="8b4b" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">编写并测试云形成模板</li><li id="8c80" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">配置Ansible和AWS动态清单脚本</li><li id="e477" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">编写并测试可承担的角色和剧本</li><li id="9912" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">编写CodeBuild构建规范文件</li><li id="1772" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">为代码构建和代码管道创建IAM角色</li><li id="986f" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">创建和测试代码构建项目和代码管道</li><li id="f5a8" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">为AWS提供、部署和配置完整的web平台</li><li id="fb45" class="mi mj it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">测试最终的web平台</li></ul><h1 id="d7ab" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">先决条件</h1><p id="2927" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">对于这个演示，我将假设您已经有了一个AWS帐户，本地安装了AWS CLI、Python和<a class="ae kz" href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html" rel="noopener ugc nofollow" target="_blank"> Ansible </a>，一个用于存储最终CloudFormation模板的S3桶和一个用于SSH的<a class="ae kz" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html" rel="noopener ugc nofollow" target="_blank"> Amazon EC2密钥对</a>。</p><h1 id="157a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">持续集成和交付概述</h1><p id="a485" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">在本演示中，我们将使用几个AWS服务构建多个CI/CD管道，用于向AWS调配和配置资源。这些服务包括代码提交、代码构建、代码管道、系统管理器参数存储和亚马逊简单存储服务(S3)。下图显示了我们将使用这些AWS服务以及Ansible构建的完整CI/CD工作流。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/25de9f101d6d2f63d11376cae9b789b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-328Tphb153yeKtAStkDg.png"/></div></div></figure><h1 id="3d15" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">AWS代码提交</h1><p id="a06b" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">据亚马逊称，<a class="ae kz" href="https://aws.amazon.com/codecommit/" rel="noopener ugc nofollow" target="_blank"> AWS CodeCommit </a>是一个完全托管的源代码控制服务，可以轻松托管安全且高度可扩展的私有Git库。CodeCommit消除了操作您自己的源代码控制系统的需要，或者担心扩展它的基础设施。</p><p id="f7dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先创建两个AWS CodeCommit存储库来保存之前克隆的两个GitHub项目。将两个项目提交到您自己的AWS CodeCommit存储库中。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/83914c43e8c2fae314120e1035f3521b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Od0u1Iog-vsmCS2j"/></div></div></figure><h1 id="0c03" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结构管理</h1><p id="9ff6" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">我们有几个选项来存储在AWS上供应和配置资源所必需的配置值。我们可以直接在CodeBuild中将配置值设置为环境变量。我们可以在我们的职责范围内设置配置值。我们可以使用AWS系统管理器参数存储来存储配置值。在本演示中，我们将使用所有三个选项的组合。</p><h1 id="3e14" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">AWS系统管理器参数存储</h1><p id="da90" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">据Amazon称，<a class="ae kz" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html" rel="noopener ugc nofollow" target="_blank"> AWS Systems Manager参数存储库</a>为配置数据管理和机密管理提供了安全的分层存储。您可以将密码、数据库字符串和许可证代码等数据存储为参数值，以纯文本或加密的形式存储。</p><p id="d8b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个演示使用了两个CloudFormation模板。这两个模板有几个参数。这些参数值中的大部分将存储在参数存储中，由CloudBuild检索，并在配置期间注入到CloudFormation模板中。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/81c9cc29aae255f4f7f1f87928eff1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*fWi0lwoDSkmH7FSC"/></div></div></figure><p id="1e24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Ansible GitHub项目包含一个shell脚本<code class="fe ni nj nk mx b">parameter_store_values.sh</code>，用于将必要的参数放入参数存储中。该脚本要求本地安装<a class="ae kz" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank"> AWS命令行接口</a> (CLI)。您需要更改脚本中的<code class="fe ni nj nk mx b">KEY_PATH</code>键值(显示在下面的<em class="nl">片段)来匹配您的私有密钥的位置，私有密钥是您之前创建的供Ansible使用的Amazon EC2密钥对的一部分。</em></p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="56a1" class="nb lg it mx b gy nc nd l ne nf"><strong class="mx iu">KEY_PATH="/path/to/private/key"<br/></strong><br/># put encrypted parameter to Parameter Store<br/>aws ssm put-parameter \<br/>  --name $PARAMETER_PATH/ansible_private_key \<br/>  --type SecureString \<br/>  --value "file://${KEY_PATH}" \<br/>  --description "Ansible private key for EC2 instances" \<br/>  --overwrite</span></pre><h1 id="49e6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">安全措施</h1><p id="4c57" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">所有其他参数都以字符串数据类型存储在参数存储中，而私钥则以<a class="ae kz" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-securestring.html" rel="noopener ugc nofollow" target="_blank"> SecureString </a>数据类型存储。参数存储使用一个<a class="ae kz" href="https://aws.amazon.com/kms/" rel="noopener ugc nofollow" target="_blank"> AWS密钥管理服务</a> (KMS)客户主密钥(CMK)来加密安全参数值。CodeBuild(稍后讨论)使用的IAM角色将拥有正确的权限，可以使用KMS密钥来检索和解密私钥安全参数值。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/3f41dc9364591780b8d41522b052c8a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*DVZbc1g_tGx391n1"/></div></div></figure><h1 id="39ad" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">云的形成</h1><p id="f289" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">这个演示使用了两个CloudFormation模板。第一个模板<code class="fe ni nj nk mx b">network-stack.template</code>，包含AWS网络栈资源。该模板包括一个VPC、一个互联网网关、两个NAT网关、四个子网、两个弹性IP地址以及相关的路由表和安全组。第二个模板<code class="fe ni nj nk mx b">compute-stack.template</code>包含web服务器计算堆栈资源。该模板包括自动扩展组、启动配置、应用程序负载平衡器(ALB)、ALB侦听器、ALB目标组和实例安全组。这两个模板都源自AWS CloudFormation <a class="ae kz" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/sample-templates-services-us-west-2.html" rel="noopener ugc nofollow" target="_blank">模板样本库</a>，并针对本次演示进行了修改。</p><p id="8b9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个模板位于CloudFormation项目的<code class="fe ni nj nk mx b">cfn_templates</code>目录中，如下面的树形视图所示。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="9d5c" class="nb lg it mx b gy nc nd l ne nf">.<br/>├── LICENSE.md<br/>├── README.md<br/>├── buildspec_files<br/>│   ├── build.sh<br/>│   └── buildspec.yml<br/><strong class="mx iu">├── cfn_templates</strong><br/><strong class="mx iu">│   ├── compute-stack.template</strong><br/><strong class="mx iu">│   └── network-stack.template</strong><br/>├── codebuild_projects<br/>│   ├── build.sh<br/>│   └── cfn-validate-s3.json<br/>├── codepipeline_pipelines<br/>│   ├── build.sh<br/>│   └── cfn-validate-s3.json<br/>└── requirements.txt</span></pre><p id="faac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">演示时不需要修改模板。所有参数都在参数存储中或由Ansible角色设置，并由Ansible剧本通过CodeBuild使用。</p><h1 id="e71e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Ansible</h1><p id="7a2b" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">我们将使用Red Hat Ansible通过直接与CloudFormation交互来提供网络和计算资源，部署和配置Apache HTTP Server，最后执行系统的最终集成测试。在我看来，AWS平台上最接近Ansible的等价物是<a class="ae kz" href="https://aws.amazon.com/opsworks/" rel="noopener ugc nofollow" target="_blank"> AWS OpsWorks </a>。OpsWorks允许您使用Chef和Puppet(ansi ble的直接竞争对手)来自动化如何在Amazon EC2实例或内部计算环境中配置、部署和管理服务器。</p><h1 id="93de" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">可变配置</h1><p id="b7a2" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">要将Ansible与AWS和CloudFormation一起使用，首先需要定制项目的<code class="fe ni nj nk mx b">ansible.cfg</code>文件，以启用<code class="fe ni nj nk mx b">aws_ec2</code>库存插件。下面是我的部分配置文件，作为参考。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="f4b1" class="nb lg it mx b gy nc nd l ne nf">[defaults]<br/>gathering = smart<br/>fact_caching = jsonfile<br/>fact_caching_connection = /tmp<br/>fact_caching_timeout = 300<br/><br/>host_key_checking = False<br/>roles_path = roles<br/>inventory = inventories/hosts<br/>remote_user = ec2-user<br/>private_key_file = ~/.ssh/ansible<br/><br/><strong class="mx iu">[inventory]<br/></strong>enable_plugins = host_list, script, yaml, ini, auto, <strong class="mx iu">aws_ec2</strong></span></pre><h1 id="2221" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">可变角色</h1><p id="b038" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">根据Ansible的说法，<a class="ae kz" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#roles" rel="noopener ugc nofollow" target="_blank">角色</a>是基于已知的文件结构自动加载某些变量文件、任务和处理程序的方式。按角色对内容进行分组还允许与其他用户轻松共享角色。为了演示，我编写了四个角色，位于<code class="fe ni nj nk mx b">roles</code>目录中，如下面的项目树视图所示。默认情况下，本演示中不使用<code class="fe ni nj nk mx b">common</code>角色。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="6f0e" class="nb lg it mx b gy nc nd l ne nf">.<br/>├── LICENSE.md<br/>├── README.md<br/>├── ansible.cfg<br/>├── buildspec_files<br/>│   ├── buildspec_compute.yml<br/>│   ├── buildspec_integration_tests.yml<br/>│   ├── buildspec_network.yml<br/>│   └── buildspec_web_config.yml<br/>├── codebuild_projects<br/>│   ├── ansible-test.json<br/>│   ├── ansible-web-config.json<br/>│   ├── build.sh<br/>│   ├── cfn-compute.json<br/>│   ├── cfn-network.json<br/>│   └── notes.md<br/>├── filter_plugins<br/>├── group_vars<br/>├── host_vars<br/>├── inventories<br/>│   ├── aws_ec2.yml<br/>│   ├── ec2.ini<br/>│   ├── ec2.py<br/>│   └── hosts<br/>├── library<br/>├── module_utils<br/>├── notes.md<br/>├── parameter_store_values.sh<br/>├── playbooks<br/>│   ├── 10_cfn_network.yml<br/>│   ├── 20_cfn_compute.yml<br/>│   ├── 30_web_config.yml<br/>│   └── 40_integration_tests.yml<br/>├── production<br/>├── requirements.txt<br/><strong class="mx iu">├── roles</strong><br/><strong class="mx iu">│   ├── cfn_compute</strong><br/><strong class="mx iu">│   ├── cfn_network</strong><br/>│   ├── common<br/><strong class="mx iu">│   ├── httpd</strong><br/><strong class="mx iu">│   └── integration_tests</strong><br/>├── site.yml<br/>└── staging</span></pre><p id="8abd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这四个角色包括一个提供网络的角色，即<code class="fe ni nj nk mx b">cfn_network</code>角色。用于配置计算资源的角色，即<code class="fe ni nj nk mx b">cfn_compute</code>角色。部署和配置Apache服务器的角色,<code class="fe ni nj nk mx b">httpd</code>角色。最后，执行平台最终集成测试的角色是<code class="fe ni nj nk mx b">integration_tests</code>角色。各个角色有助于将项目的主要部分(网络、计算和中间件)分成逻辑代码文件。每个角色最初都是用<a class="ae kz" href="https://galaxy.ansible.com/docs/contributing/creating_role.html" rel="noopener ugc nofollow" target="_blank"> Ansible Galaxy </a> ( <code class="fe ni nj nk mx b">ansible-galaxy init</code>)构建的。它们遵循Galaxy的标准文件结构，如下面的树视图所示，属于<code class="fe ni nj nk mx b">cfn_network</code>角色。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="e9d7" class="nb lg it mx b gy nc nd l ne nf">.<br/>├── README.md<br/>├── defaults<br/><strong class="mx iu">│   └── main.yml<br/></strong>├── files<br/>├── handlers<br/>│   └── main.yml<br/>├── meta<br/>│   └── main.yml<br/>├── tasks<br/><strong class="mx iu">│   ├── create.yml<br/>│   ├── delete.yml<br/>│   └── main.yml<br/></strong>├── templates<br/>├── tests<br/><strong class="mx iu">│   ├── inventory<br/>│   └── test.yml<br/></strong>└── vars<br/>    └── main.yml</span></pre><h1 id="3d65" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">测试可行角色</h1><p id="435a" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">除了在开发过程中检查每个角色以及使用<a class="ae kz" href="https://github.com/ansible/ansible-lint" rel="noopener ugc nofollow" target="_blank"> Ansible Lint </a>提交每个代码之外，每个角色还包含一组单元测试，位于<code class="fe ni nj nk mx b">tests</code>目录中，以确认角色任务的成功或失败。下面我们看到一组针对<code class="fe ni nj nk mx b">cfn_compute</code>角色的基本测试。首先，我们收集关于已部署EC2实例的<a class="ae kz" href="https://docs.ansible.com/ansible/2.5/user_guide/playbooks_variables.html#information-discovered-from-systems-facts" rel="noopener ugc nofollow" target="_blank">事实</a>。Ansible可以自动从您的远程系统中获取事实信息。我们检查正在运行的EC2实例的预期属性，包括时区、操作系统、主要OS版本和用户ID。注意<code class="fe ni nj nk mx b">failed_when</code>条件句的使用。这个可行的剧本<a class="ae kz" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html" rel="noopener ugc nofollow" target="_blank">错误处理</a>条件用于确认任务的成功或失败。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="8964" class="nb lg it mx b gy nc nd l ne nf">---<br/>- name: Test cfn_compute Ansible role<br/>  gather_facts: True<br/>  hosts: tag_Group_webservers<br/><br/>  pre_tasks:<br/>  - name: List all ansible facts<br/>    debug:<br/>      msg: "{{ ansible_facts }}"<br/><br/>  tasks:<br/>  - name: Check if EC2 instance's timezone is set to 'UTC'<br/>    debug:<br/>      msg: Timezone is UTC<br/>    failed_when: ansible_facts['date_time']['tz'] != 'UTC'<br/><br/>  - name: Check if EC2 instance's OS is 'Amazon'<br/>    debug:<br/>      msg: OS is Amazon<br/>    failed_when: ansible_facts['distribution_file_variety'] != 'Amazon'<br/><br/>  - name: Check if EC2 instance's OS major version is '2018'<br/>    debug:<br/>      msg: OS major version is 2018<br/>    failed_when: ansible_facts['distribution_major_version'] != '2018'<br/><br/>  - name: Check if EC2 instance's UserID is 'ec2-user'<br/>    debug:<br/>      msg: UserID is ec2-user<br/>    failed_when: ansible_facts['user_id'] != 'ec2-user'</span></pre><p id="adae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们在两台正确配置的EC2 web服务器上运行测试，我们会看到类似下面的结果。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d68e9baca24874e396a97a0baeb7a3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*DPq8BAaP39SkFAGr"/></div></figure><p id="5f84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下面的<code class="fe ni nj nk mx b">cfn_network</code>角色单元测试中，注意ansi ble<a class="ae kz" href="https://docs.ansible.com/ansible/latest/modules/cloudformation_facts_module.html" rel="noopener ugc nofollow" target="_blank">cloud formation _ facts模块</a>的使用。该模块允许我们获得关于成功完成的AWS CloudFormation堆栈的事实。然后，我们可以使用这些事实来推动额外的配置和配置，或测试。在下面的任务中，我们获得了网络CloudFormation堆栈的输出。这些值与我们在AWS CloudFormation管理控制台的堆栈输出选项卡中看到的值完全相同。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="ef83" class="nb lg it mx b gy nc nd l ne nf">---<br/>- name: Test cfn_network Ansible role<br/>  gather_facts: False<br/>  hosts: localhost<br/><br/>  pre_tasks:<br/>    - name: Get facts about the newly created cfn network stack<br/>      <strong class="mx iu">cloudformation_facts</strong>:<br/>        stack_name: "ansible-cfn-demo-network"<br/>      register: cfn_network_stack_facts<br/><br/>    - name: List 'stack_outputs' from cached facts<br/>      debug:<br/>        msg: "{{ cloudformation['ansible-cfn-demo-network'].stack_outputs }}"<br/><br/>  tasks:<br/>  - name: Check if the AWS Region of the VPC is {{ lookup('env','AWS_REGION') }}<br/>    debug:<br/>      msg: "AWS Region of the VPC is {{ lookup('env','AWS_REGION') }}"<br/>    failed_when: cloudformation['ansible-cfn-demo-network'].stack_outputs['VpcRegion'] != lookup('env','AWS_REGION')</span></pre><p id="02a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与CloudFormation模板类似，Ansible角色不需要修改。项目的大多数参数与代码分离，并存储在参数存储或CodeBuild buildspec文件中(接下来的将讨论<em class="nl">)。在<code class="fe ni nj nk mx b">defaults/main.yml</code>文件的角色中找到的几个参数既不是特定于帐户的，也不是特定于环境的。</em></p><h1 id="c8d5" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">翻译剧本</h1><p id="2fbe" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">这些角色将由我们的翻译剧本来命名。对于<code class="fe ni nj nk mx b">cfn_network</code>和<code class="fe ni nj nk mx b">cfn_compute</code>角色，有一组<code class="fe ni nj nk mx b">create</code>和一组<code class="fe ni nj nk mx b">delete</code>任务。无论是<code class="fe ni nj nk mx b">create</code>还是<code class="fe ni nj nk mx b">delete</code>任务都可以通过角色访问，使用<code class="fe ni nj nk mx b">main.yml</code>文件并引用<code class="fe ni nj nk mx b">create</code>或<code class="fe ni nj nk mx b">delete</code>或<a class="ae kz" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html" rel="noopener ugc nofollow" target="_blank">可变标签</a>。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="4d68" class="nb lg it mx b gy nc nd l ne nf">---<br/>- import_tasks: create.yml<br/>  tags:<br/>    - create<br/><br/>- import_tasks: delete.yml<br/>  tags:<br/>    - delete</span></pre><p id="78dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面，我们看到<code class="fe ni nj nk mx b">cfn_network</code>角色<code class="fe ni nj nk mx b">create.yml</code>的<code class="fe ni nj nk mx b">create</code>任务，在上面由<code class="fe ni nj nk mx b">main.yml</code>引用。在第一个任务中使用<a class="ae kz" href="https://docs.ansible.com/ansible/latest/modules/cloudformation_module.html" rel="noopener ugc nofollow" target="_blank"> cloudcormation模块</a>允许我们创建或删除AWS CloudFormation堆栈，并展示了Ansible的真正力量——通过模块扩展其核心功能来执行复杂的AWS资源供应的能力。通过切换<a class="ae kz" href="https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#alicloud" rel="noopener ugc nofollow" target="_blank">云模块</a>，我们可以轻松地在Google Cloud、Azure、AliCloud、OpenStack或VMWare等平台上配置资源。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="9bc4" class="nb lg it mx b gy nc nd l ne nf">---<br/>- name: create a stack, pass in the template via an S3 URL<br/>  <strong class="mx iu">cloudformation</strong>:<br/>    stack_name: "{{ stack_name }}"<br/>    state: present<br/>    region: "{{ lookup('env','AWS_REGION') }}"<br/>    disable_rollback: false<br/>    template_url: "{{ lookup('env','TEMPLATE_URL') }}"<br/>    template_parameters:<br/>      VpcCIDR: "{{ lookup('env','VPC_CIDR') }}"<br/>      PublicSubnet1CIDR: "{{ lookup('env','PUBLIC_SUBNET_1_CIDR') }}"<br/>      PublicSubnet2CIDR: "{{ lookup('env','PUBLIC_SUBNET_2_CIDR') }}"<br/>      PrivateSubnet1CIDR: "{{ lookup('env','PRIVATE_SUBNET_1_CIDR') }}"<br/>      PrivateSubnet2CIDR: "{{ lookup('env','PRIVATE_SUBNET_2_CIDR') }}"<br/>      TagEnv: "{{ lookup('env','TAG_ENVIRONMENT') }}"<br/>    tags:<br/>      Stack: "{{ stack_name }}"</span></pre><p id="afce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述任务中的CloudFormation参数主要来自环境变量，其值由CodeBuild从参数存储中检索并在环境中设置。我们使用Ansible的<a class="ae kz" href="https://docs.ansible.com/ansible/2.8/plugins/lookup.html" rel="noopener ugc nofollow" target="_blank">查找插件</a>获得这些外部值。<code class="fe ni nj nk mx b">stack_name</code>变量的值来自角色的<code class="fe ni nj nk mx b">defaults/main.yml</code>文件。任务<a class="ae kz" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html" rel="noopener ugc nofollow" target="_blank">变量</a>使用Python <a class="ae kz" href="http://jinja.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Jinja2模板系统</a>风格的编码。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/22fdfb3c3b18e70cdadd242af5b22b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*kSQJkSfSdxed8Jve"/></div></figure><p id="b184" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">调用任务的相关Ansible剧本位于<code class="fe ni nj nk mx b">playbooks</code>目录中，如之前在树形视图中所示。行动手册定义了一些必需的参数，比如主机列表将从哪里导出，以及调用适当的角色。在我们的简单演示中，每个剧本只调用一个角色。通常，在一个较大的项目中，您会从一个剧本中调用多个角色。下面，我们看到网络剧本，<code class="fe ni nj nk mx b">playbooks/10_cfn_network.yml</code>，它调用了<code class="fe ni nj nk mx b">cfn_network</code>角色。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="2b70" class="nb lg it mx b gy nc nd l ne nf">---<br/>- name: Provision VPC and Subnets<br/>  hosts: localhost<br/>  connection: local<br/>  gather_facts: False<br/><br/><strong class="mx iu">  roles:<br/>    - role: cfn_network</strong></span></pre><h1 id="9313" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">动态库存</h1><p id="3888" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">Ansible的另一个主要特性在Web服务器配置手册<code class="fe ni nj nk mx b">playbooks/30_web_config.yml</code>中演示，如下所示。注意，我们希望部署和配置Apache HTTP Server的主机是基于AWS标记值的，由对<code class="fe ni nj nk mx b">tag_Group_webservers</code>的引用来指示。这间接引用了一个名为Group的AWS标记，其值为<code class="fe ni nj nk mx b">webservers</code>，由CloudFormation应用于我们的EC2主机。使用动态外部库存系统生成<a class="ae kz" href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html" rel="noopener ugc nofollow" target="_blank">动态库存</a>的能力是Ansible的一个关键特性。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="578d" class="nb lg it mx b gy nc nd l ne nf">---<br/>- name: Configure Apache Web Servers<br/><strong class="mx iu">  hosts: tag_Group_webservers<br/></strong>  gather_facts: False<br/>  become: yes<br/>  become_method: sudo<br/><br/>  roles:<br/>    - role: httpd</span></pre><p id="f3ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了生成EC2主机的动态清单，我们使用Ansible <a class="ae kz" href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html#inventory-script-example-aws-ec2" rel="noopener ugc nofollow" target="_blank"> AWS EC2动态清单</a>脚本、<code class="fe ni nj nk mx b">inventories/ec2.py</code>和<code class="fe ni nj nk mx b">inventories/ec2.ini</code>文件。该脚本动态地向AWS查询所有包含特定AWS标记的EC2主机，这些主机属于特定的安全组、区域、可用性区域等等。</p><p id="1431" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经在<code class="fe ni nj nk mx b">inventories/aws_ec2.yml</code>文件中定制了AWS EC2动态清单脚本的配置。在其他配置项中，该文件定义了<code class="fe ni nj nk mx b">keyed_groups</code>。这指示脚本根据EC2主机的唯一AWS标记和标记值来清点EC2主机。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="bae3" class="nb lg it mx b gy nc nd l ne nf">plugin: aws_ec2<br/>remote_user: ec2-user<br/>private_key_file: ~/.ssh/ansible<br/>regions:<br/>  - us-east-1<br/><strong class="mx iu">keyed_groups:</strong><br/><strong class="mx iu">  - key: tags.Name</strong><br/><strong class="mx iu">    prefix: tag_Name_</strong><br/><strong class="mx iu">    separator: ''</strong><br/><strong class="mx iu">  - key: tags.Group</strong><br/><strong class="mx iu">    prefix: tag_Group_</strong><br/><strong class="mx iu">    separator: ''</strong><br/>hostnames:<br/>  - dns-name<br/>  - ip-address<br/>  - private-dns-name<br/>  - private-ip-address<br/>compose:<br/>  ansible_host: ip_address</span></pre><p id="e961" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在前面的演示部分中构建了CloudFormation计算堆栈后，要构建主机的动态EC2清单，可以使用以下命令。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="eaa9" class="nb lg it mx b gy nc nd l ne nf">ansible-inventory -i inventories/aws_ec2.yml --graph</span></pre><p id="d098" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您将看到所有EC2主机的清单，如下所示。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="3638" class="nb lg it mx b gy nc nd l ne nf">@all:<br/>  |--@aws_ec2:<br/>  |  |--ec2-18-234-137-73.compute-1.amazonaws.com<br/>  |  |--ec2-3-95-215-112.compute-1.amazonaws.com<br/><strong class="mx iu">  |--@tag_Group_webservers:</strong><br/><strong class="mx iu">  |  |--ec2-18-234-137-73.compute-1.amazonaws.com</strong><br/><strong class="mx iu">  |  |--ec2-3-95-215-112.compute-1.amazonaws.com</strong><br/>  |--@tag_Name_Apache_Web_Server:<br/>  |  |--ec2-18-234-137-73.compute-1.amazonaws.com<br/>  |  |--ec2-3-95-215-112.compute-1.amazonaws.com<br/>  |--@ungrouped:</span></pre><p id="5f69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意两个EC2 web服务器实例，列在<code class="fe ni nj nk mx b">tag_Group_webservers</code>下面。它们代表我们将在其上安装Apache HTTP Server的目标库存。我们也可以使用带有值<code class="fe ni nj nk mx b">tag_Name_Apache_Web_Server</code>的标签Name。</p><h1 id="a347" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">AWS代码构建</h1><p id="e9f5" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">回想我们的图表，你会注意到CodeBuild的使用是我们五个DevOps工作流程中每一个的重要部分。CodeBuild用于1)验证云信息模板，2)调配网络资源，3)调配计算资源，4)安装和配置web服务器，以及5)运行集成测试。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/961237c07a28a2e4e0bb97d8e8a570dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*SAe89eFhh9Dm45L3"/></div></figure><p id="bf34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将这些流程分成单独的工作流，我们可以在不影响计算资源的情况下重新部署web服务器，或者在不影响网络资源的情况下重新部署计算资源。通常，大型企业中的不同团队负责这些资源类别中的每一个——架构、安全性(IAM)、网络、计算、web服务器和代码部署。分离关注点使得共享所有权模型更容易管理。</p><h1 id="2331" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">构建规范</h1><p id="9d0f" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">CodeBuild项目依赖于构建规范或buildspec文件进行配置，如下所示。CodeBuild的buildspec文件与Jenkins的<a class="ae kz" href="https://jenkins.io/doc/book/pipeline/jenkinsfile/" rel="noopener ugc nofollow" target="_blank"> Jenkinsfile </a>同义。我们的五个工作流程都将使用CodeBuild。每个CodeBuild项目引用一个单独的buildspec文件，包含在两个GitHub项目中，到目前为止，您已经将该文件推送到两个CodeCommit存储库中。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/4e8e8c98d83402007cff8e9982ce261c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*_n3or7fdxjoM1Wgd"/></div></div></figure><p id="aa21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面我们看到一个CodeBuild项目的buildspec文件的例子，它部署了我们的AWS网络资源，<code class="fe ni nj nk mx b">buildspec_files/buildspec_network.yml</code>。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="d80a" class="nb lg it mx b gy nc nd l ne nf">version: 0.2<br/><br/><strong class="mx iu">env:<br/></strong>  variables:<br/>    TEMPLATE_URL: "https://s3.amazonaws.com/garystafford_cloud_formation/cf_demo/network-stack.template"<br/>    AWS_REGION: "us-east-1"<br/>    TAG_ENVIRONMENT: "ansible-cfn-demo"<br/>  parameter-store:<br/>    VPC_CIDR: "/ansible_demo/vpc_cidr"<br/>    PUBLIC_SUBNET_1_CIDR: "/ansible_demo/public_subnet_1_cidr"<br/>    PUBLIC_SUBNET_2_CIDR: "/ansible_demo/public_subnet_2_cidr"<br/>    PRIVATE_SUBNET_1_CIDR: "/ansible_demo/private_subnet_1_cidr"<br/>    PRIVATE_SUBNET_2_CIDR: "/ansible_demo/private_subnet_2_cidr"<br/><br/><strong class="mx iu">phases:<br/></strong>  install:<br/>    runtime-versions:<br/>      python: 3.7<br/>    commands:<br/>      - pip install -r requirements.txt -q<br/>  build:<br/>    commands:<br/>      - ansible-playbook -i inventories/aws_ec2.yml playbooks/10_cfn_network.yml --tags create  -v<br/>  post_build:<br/>    commands:<br/>      - ansible-playbook -i inventories/aws_ec2.yml roles/cfn_network/tests/test.yml</span></pre><p id="ad7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">buildspec文件有几个不同的部分。首先，在<code class="fe ni nj nk mx b">variables</code>部分，我们定义变量。它们是从参数存储中检索的三个静态变量值和五个变量值的组合。在构建时，可以使用AWS CLI、SDK或从CodeBuild管理控制台覆盖其中的任何内容。您将需要更新一些变量来匹配您的特定环境，例如<code class="fe ni nj nk mx b">TEMPLATE_URL</code>来匹配您的S3存储桶路径。</p><p id="3b76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们建造的<code class="fe ni nj nk mx b">phases</code>。同样，如果您熟悉Jenkins，请将这些视为包含多个步骤的阶段。第一阶段，<code class="fe ni nj nk mx b">install</code>，构建一个Docker容器，在其中执行构建过程。这里我们用的是Python 3.7。我们还运行一个pip命令，从我们的<code class="fe ni nj nk mx b">requirements.txt</code>文件中安装所需的Python包。接下来，我们通过执行一个Ansible命令来执行我们的<code class="fe ni nj nk mx b">build</code>阶段。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="befc" class="nb lg it mx b gy nc nd l ne nf">ansible-playbook \<br/>  -i inventories/aws_ec2.yml \<br/>  playbooks/10_cfn_network.yml --tags create -v</span></pre><p id="3d20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">指挥部调用我们的战术手册，<code class="fe ni nj nk mx b">playbooks/10_cfn_network.yml</code>。该命令引用了<code class="fe ni nj nk mx b">create</code>标签。这导致剧本运行到<code class="fe ni nj nk mx b">cfn_network</code>角色的创建任务(<code class="fe ni nj nk mx b">roles/cfn_network/tasks/create.yml</code>)，如<code class="fe ni nj nk mx b">main.yml</code>文件(<code class="fe ni nj nk mx b">roles/cfn_network/tasks/main.yml</code>)中所定义的。最后，在我们的<code class="fe ni nj nk mx b">post_build</code>阶段，我们使用第二个Ansible命令执行我们角色的单元测试(<code class="fe ni nj nk mx b">roles/cfn_network/tests/test.yml</code>)。</p><h1 id="45c6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">代码构建项目</h1><p id="c17b" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">接下来，我们需要创建代码构建项目。您可以使用AWS CLI或从CodeBuild管理控制台(显示在下面的<em class="nl">)完成此操作。我在每个项目中的<code class="fe ni nj nk mx b">codebuild_projects</code>目录中包含了单独的模板和一个创建脚本，您可以使用AWS CLI使用它们来构建项目。您必须修改JSON模板，用您自己的模板替换对我的特定的、唯一的AWS资源的所有引用。为了进行演示，我建议使用提供的CodeBuild项目模板作为指南，在CodeBuild管理控制台中手动创建五个项目。</em></p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/fef49a967bc5c2089aa1615c20cf5c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*fktibbOQFFBTkVk-"/></div></div></figure><h1 id="9fd4" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">代码构建IAM角色</h1><p id="8a95" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">要执行我们的CodeBuild项目，我们需要一个IAM角色或多个角色CodeBuild，并对CodeCommit、S3和CloudWatch等资源拥有权限。在本演示中，我选择为所有工作流创建一个IAM角色。然后，我允许CodeBuild根据需要将所需的策略分配给角色，这是CodeBuild的一个特性。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/77cf1b3ae3be48bac838fc4841263760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*P4baDaqqtHJT2dvX"/></div></div></figure><h1 id="ff12" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">代码管道</h1><p id="f36f" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">除了CodeBuild，我们还将CodePipeline用于五个工作流中的第一个。CodePipeline验证CloudFormation模板，并将它们推送到我们的S3桶中。管道调用相应的CodeBuild项目来验证每个模板，然后将有效的CloudFormation模板部署到S3。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/7c5e0f33baca61413cb2b7193a900396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*tTxaMXZAVempTGba"/></div></figure><p id="b296" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在真正的CI/CD方式中，每次CloudFormation项目的源代码提交到CodeCommit存储库时，都会自动执行管道。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/25608a1b4ac463e5050dc358cdbf0d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*LQxM0pwDuRMzeeTO"/></div></div></figure><p id="113c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CodePipeline调用CodeBuild，code build根据其buildspec文件执行构建。这个特殊的CodeBuild buildspec文件还演示了CodeBuild的另一个功能，即执行外部脚本。当我们有一个复杂的构建阶段时，我们可以选择调用外部脚本，比如Bash或Python脚本，而不是将命令嵌入到构建规范中。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="49c1" class="nb lg it mx b gy nc nd l ne nf">version: 0.2<br/><br/>phases:<br/>  install:<br/>    runtime-versions:<br/>      python: 3.7<br/>  pre_build:<br/>    commands:<br/>      - pip install -r requirements.txt -q<br/>      - cfn-lint -v<br/>  build:<br/>    commands:<br/><strong class="mx iu">      - sh buildspec_files/build.sh<br/></strong><br/>artifacts:<br/>  files:<br/>    - '**/*'<br/>  base-directory: 'cfn_templates'<br/>  discard-paths: yes</span></pre><p id="9289" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面，我们看到的脚本叫做。这里，我们使用CloudFormation Linter、<code class="fe ni nj nk mx b">cfn-lint</code>和<code class="fe ni nj nk mx b">cloudformation validate-template</code>命令来验证我们的模板，以便进行比较。这两个工具给出了略有不同但相关的林挺结果。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="e142" class="nb lg it mx b gy nc nd l ne nf">#!/usr/bin/env bash<br/><br/>set -e<br/><br/>for filename in cfn_templates/*.*; do<br/>    cfn-lint -t ${filename}<br/>    aws cloudformation validate-template \<br/>      --template-body file://${filename}<br/>done</span></pre><p id="833e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与CodeBuild项目模板类似，我在<code class="fe ni nj nk mx b">codepipeline_pipelines</code>目录中包含了一个CodePipeline模板，您可以使用AWS CLI修改和创建它。或者，我建议使用CodePipeline管理控制台为演示创建管道，使用提供的CodePipeline模板作为指南。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/5fe69c12459253ba33e7e5ca6b9c1b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*qLnVi0ANiUG5UKCD"/></div></div></figure><p id="309f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是最终CodePipleine管道的阶段视图。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/f998b966812f367ec87bb51d947784ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*LN7rmVlaNm9wj3T0"/></div></div></figure><h1 id="97dd" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">搭建平台</h1><p id="4b1a" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">有了所有的资源、代码和DevOps工作流，我们应该准备好在AWS上构建我们的平台。首先是CodePipeline项目，以验证CloudFormation模板并将其放入您的S3桶中。因为您可能没有向CloudFormation文件CodeCommit存储库提交新代码，这将触发管道，所以您可以使用AWS CLI(下面显示的<em class="nl">)或通过管理控制台启动管道。</em></p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="921e" class="nb lg it mx b gy nc nd l ne nf"># list names of pipelines<br/>aws codepipeline list-pipelines<br/><br/># execute the validation pipeline<br/>aws codepipeline start-pipeline-execution --name cfn-validate-s3</span></pre><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/388716448d7c1b99259fe8789181b331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*wMom5-KBH5h5ktyF"/></div></figure><p id="b23f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">管道应该在几秒钟内完成。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/2ca18fa4073d3ddd99a131b0532f4cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*DfIZ5S5S63TtBugS"/></div></div></figure><p id="b814" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，按以下顺序执行四个CodeBuild项目中的每一个。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="da97" class="nb lg it mx b gy nc nd l ne nf"># list the names of the projects<br/>aws codebuild list-projects<br/><br/># execute the builds in order<br/>aws codebuild start-build --project-name cfn-network<br/>aws codebuild start-build --project-name cfn-compute<br/><br/># ensure EC2 instance checks are complete before starting<br/># the ansible-web-config build!<br/>aws codebuild start-build --project-name ansible-web-config<br/>aws codebuild start-build --project-name ansible-test</span></pre><p id="8297" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如上面的代码注释所述，在确认EC2实例状态检查已经完成并通过之前，请注意不要启动ansible-web-config构建，如下所示。当CloudFormation完成构建新的计算堆栈时，之前的<code class="fe ni nj nk mx b">cfn-compute</code>构建也将完成。然而，CloudFormation完成的事实并不意味着EC2实例已经完全启动并运行。等待失败将导致安装和配置Apache HTTP服务器的<code class="fe ni nj nk mx b">ansible-web-config</code> CodeBuild项目构建失败。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/c37cb273f9236b443744eba58d3919ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*qy7rTD4z4mLXjvF4"/></div></div></figure><p id="89ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面，我们看到<code class="fe ni nj nk mx b">cfn_network</code> CodeBuild项目首先构建了一个基于Python的Docker容器，在其中执行构建。每个构建都是在一个全新的、独立的<a class="ae kz" href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html" rel="noopener ugc nofollow" target="_blank"> Docker容器</a>中执行的，如果您希望在多个构建中持久保存之前缓存的可回答的事实或之前定义的环境变量，这可能会让您出错。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/1c9f4fd1040fac5b276dd15626e704d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Cm6bQ33DjNvO0dR3"/></div></div></figure><p id="eff3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面，我们看到了两个完整的CloudFormation堆栈，这是我们的CodeBuild项目和Ansible的结果。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/6f360c0b089ab2ab8df1ad5124b3fa72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*e2oWGSpDn9w7W0oa"/></div></div></figure><p id="e38e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第五个也是最后一个代码构建通过使用应用程序负载平衡器的公共DNS名称尝试访问Apache HTTP服务器的默认主页来测试我们的平台。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/da47c4bbc6f7d86e54cd75a915f2b192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*SQqOgNnTI2s7R3VO"/></div></div></figure><p id="61b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面，我们看一个构建失败时会发生什么的例子。在这种情况下，最终的集成测试之一未能从ALB端点返回预期的结果。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/f8ca86f4242524182c37982be8e43769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*YyOPMBZuQmdzk6lG"/></div></div></figure><p id="bf14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面，在错误被修复后，我们重新运行构建，成功地重新执行了测试。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/920f735b6a3cc21cb032e11a3ff27a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*gWFBwmtqbLjE8E4P"/></div></div></figure><p id="9fb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过点击与我们在浏览器中的测试相同的ALB公共DNS名称来手动确认平台正在工作。该请求应该将我们的请求负载平衡到两个正在运行的web服务器的默认主页之一。通常，在这一点上，您会使用软件持续部署工具将您的应用程序部署到Apache，例如Jenkins、CodeDeploy、Travis CI、TeamCity或Bamboo。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/aec3ed47d6575551cfc0ca573da08da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*pgQo61tjJiOZPmHY"/></div></div></figure><h1 id="c560" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">清理</h1><p id="3bbe" class="pw-post-body-paragraph kb kc it kd b ke md kg kh ki me kk kl km mf ko kp kq mg ks kt ku mh kw kx ky im bi translated">要从演示中清理正在运行的AWS资源，首先删除CloudFormation计算堆栈，然后删除网络堆栈。为此，请执行以下命令，一次一个。这些命令调用与我们创建堆栈时调用的相同的行动手册，只是这次我们使用了<code class="fe ni nj nk mx b">delete</code>标签，而不是<code class="fe ni nj nk mx b">create</code>标签。</p><pre class="lb lc ld le gt mw mx my mz aw na bi"><span id="9342" class="nb lg it mx b gy nc nd l ne nf"># first delete cfn compute stack<br/>ansible-playbook \ <br/>  -i inventories/aws_ec2.yml \ <br/>  playbooks/20_cfn_compute.yml -t delete -v<br/><br/># then delete cfn network stack<br/>ansible-playbook \ <br/>  -i inventories/aws_ec2.yml \ <br/>  playbooks/10_cfn_network.yml -t delete -v</span></pre><p id="58f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您应该观察到以下输出，表明两个CloudFormation堆栈都已被删除。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/31b6acd726d0febd5dd73a5fd3a018b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*WYIn64F64kMyxAqQ"/></div></figure><p id="84e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">确认堆栈已从CloudFormation管理控制台或AWS CLI中删除。</p><p id="5dab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nl">本文表达的所有观点都是我个人的，不一定代表我现在或过去的雇主或他们的客户的观点。</em></p></div></div>    
</body>
</html>