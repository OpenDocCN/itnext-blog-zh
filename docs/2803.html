<html>
<head>
<title>Arrow Functions: JavaScript ES6 Feature Series (Pt 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">箭头函数:JavaScript ES6特性系列(第2部分)</h1>
<blockquote>原文：<a href="https://itnext.io/arrow-functions-javascript-es6-feature-series-pt-2-e8c31c823392?source=collection_archive---------1-----------------------#2019-08-06">https://itnext.io/arrow-functions-javascript-es6-feature-series-pt-2-e8c31c823392?source=collection_archive---------1-----------------------#2019-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="55bf" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么时候函数不是函数？当它是箭头时</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ce7dc680182913ecca27dbf595fcc79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYUC3cHTrwm-ajRETWCpJA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@roman_lazygeek?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">罗马法师</a>在<a class="ae le" href="https://unsplash.com/search/photos/teaching?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="7a24" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="a05a" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi md translated">这一系列帖子背后的灵感很简单:仍然有很多开发人员认为JavaScript有时毫无意义——或者至少，与其他编程语言相比，JavaScript的行为看起来很奇怪。</p><p id="38bb" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">因为它是如此流行和广泛使用的语言，所以我想提供一些关于我经常使用的JavaScript ES6特性的帖子，供开发人员参考。</p><p id="b599" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">我们的目标是让这些文章简短，但仍能深入解释对该语言的各种改进，我希望这些文章能启发您使用JS编写一些真正酷的东西。谁知道呢，在这个过程中你可能会学到一些新东西。😄</p><blockquote class="mr"><p id="7cfe" class="ms mt it bd mu mv mw mx my mz na mc dk translated">在我的第二篇文章中，我想深入探讨箭头函数，以及它们与传统的函数声明和函数表达式有何不同。</p></blockquote><h1 id="e655" class="jq jr it bd js jt ju jv jw jx jy jz ka kb nb kd ke kf nc kh ki kj nd kl km kn bi translated">函数声明</h1><p id="c54e" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您可能以前听说过这一点，但它值得重复:在JavaScript中，函数是一级对象，因为它们可以像任何其他对象一样拥有属性和方法。它们与其他对象的区别在于函数可以被调用。简而言之，它们是<code class="fe ne nf ng nh b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function" rel="noopener ugc nofollow" target="_blank">Function</a></code>物体。</p><p id="6b3f" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">从现在开始，我假设您熟悉JavaScript中函数的一般概念，但是在我讨论箭头函数之前，有必要先讨论一下<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function" rel="noopener ugc nofollow" target="_blank">函数声明</a>(也称为函数语句)和<a class="ae le" href="https://developer.mozilla.org/en-US/docs/web/JavaScript/Reference/Operators/function" rel="noopener ugc nofollow" target="_blank">函数表达式</a>。</p><p id="3a2d" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">函数声明是JavaScript中最基本的函数语句。它定义了一个函数以及它需要运行的指定参数。这里有一个例子:</p><h2 id="3c77" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated"><strong class="ak">解析一个函数声明</strong></h2><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="a79d" class="ni jr it nh b gy ny nz l oa ob">function multiply(number1, number2){<br/>  return number1 * number2;<br/>}</span><span id="e376" class="ni jr it nh b gy oc nz l oa ob">console.log(multiply(4, 9));  // prints: 36 to the console</span></pre><p id="d73d" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">如果你在看上面的函数声明例子，下面是组成函数的内容。<code class="fe ne nf ng nh b">multiply</code>是函数名，<code class="fe ne nf ng nh b">number1</code>和<code class="fe ne nf ng nh b">number2</code>是函数接受的两个参数，函数体<code class="fe ne nf ng nh b">return number1 * number2;</code>是语句。</p><h2 id="d1cd" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated">函数声明特征</h2><p id="32a2" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">开发人员在编写代码时需要记住函数声明的某些特性，因为它们总有一天会让你犯错——它们会让我们所有人犯错(包括我自己)。🙋</p><h2 id="16ff" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated"><strong class="ak">函数返回未定义，除非另有说明</strong></h2><p id="e1a5" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">默认情况下，函数返回<code class="fe ne nf ng nh b">undefined</code>。通过在正文中包含<code class="fe ne nf ng nh b">return</code>关键字，您可以指定它返回的值。</p><p id="4532" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">未定义的函数声明与返回值</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="85a9" class="ni jr it nh b gy ny nz l oa ob">function returnsNothing(item1, item2) {<br/>  item1 + item2;<br/>}</span><span id="c2dc" class="ni jr it nh b gy oc nz l oa ob">console.log(returnsNothing(1, 9)); // prints: undefined</span><span id="ff3e" class="ni jr it nh b gy oc nz l oa ob">function returnsSomething(item1, item2) {<br/>  return item1 + item2;<br/>}</span><span id="26a2" class="ni jr it nh b gy oc nz l oa ob">console.log(returnsSomething(1, 9)); // prints: 10</span></pre><p id="c085" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">对于我上面的例子，<code class="fe ne nf ng nh b">item1</code>和<code class="fe ne nf ng nh b">item2</code>的和是从<code class="fe ne nf ng nh b">returnsSomething </code>函数返回的，而<code class="fe ne nf ng nh b">returnsNothing</code>函数虽然做完全相同的加法，但当用<code class="fe ne nf ng nh b">console.log()</code>调用该值时，它仅仅返回undefined。</p><h2 id="60f2" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated"><strong class="ak">函数声明被挂起</strong></h2><p id="b37a" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">类似于我在上一篇<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/var-let-const-javascript-es6-feature-series-pt-1-fa603567809e">博文</a>中讨论的变量提升，JavaScript中的函数声明被提升到封闭函数或全局范围的顶部。这意味着，你可以在一个函数被代码声明之前使用它。</p><p id="461a" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">函数声明提升与函数表达式不提升</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="56bf" class="ni jr it nh b gy ny nz l oa ob">console.log(hoistedFunction()); // prints: Hello, I work even though I am called before being declared</span><span id="78e4" class="ni jr it nh b gy oc nz l oa ob">function hoistedFunction() {<br/>  return 'Hello, I work even though I am called before being declared';<br/>}</span><span id="dc40" class="ni jr it nh b gy oc nz l oa ob">console.log(notHoisted()); // prints: TypeError: notHoisted is not a function</span><span id="14ce" class="ni jr it nh b gy oc nz l oa ob">var notHoisted = function() {<br/>  return 'I am not hoisted, so I will not be found if called before my declaration';<br/>}</span><span id="aec3" class="ni jr it nh b gy oc nz l oa ob">console.log(notHoisted()); // prints: I am not hoisted, so I will not be found if called before my declaration</span></pre><p id="a027" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">在上面的例子中，函数<code class="fe ne nf ng nh b">hoistedFunction()</code>返回它的值，不管它何时在代码中被调用，因为它是一个函数声明。</p><p id="edc8" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">另一方面，赋给变量<code class="fe ne nf ng nh b">notHoisted()</code>的第二个函数(它是一个函数表达式)没有被提升到作用域的顶部，因此如果它在函数被解析之前被调用，它会在代码中抛出一个<code class="fe ne nf ng nh b">TypeError</code>，表明它不是一个函数(主要是因为编译器还不知道它)。</p><p id="77ac" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">当考虑函数声明时，这些是你需要知道的主要事情。让我们继续讨论函数表达式。</p><h1 id="8a3f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">函数表达式</h1><p id="44bb" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/web/JavaScript/Reference/Operators/function" rel="noopener ugc nofollow" target="_blank">函数表达式</a>类似于函数声明。它们仍然有名称(这次是可选的)、参数和基于主体的语句。</p><h2 id="c88c" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated">函数表达式的剖析</h2><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="6a38" class="ni jr it nh b gy ny nz l oa ob">const divide = function(number1, number2){<br/>  return number1 / number2;<br/>}</span><span id="6755" class="ni jr it nh b gy oc nz l oa ob">console.log(divide(15, 5)); // prints: 3</span></pre><p id="8890" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">对于这个例子，变量<code class="fe ne nf ng nh b">divide()</code>被分配给匿名函数，该函数接受参数<code class="fe ne nf ng nh b">number1</code>和<code class="fe ne nf ng nh b">number2</code>，并根据主体语句<code class="fe ne nf ng nh b">return number1 / number2;</code>返回商。</p><h2 id="1c01" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated">功能表达特征</h2><p id="4cf8" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">就像函数声明一样，函数表达式也有自己独特的定义。以下是你需要知道的关于他们的事情。</p><h2 id="b852" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated">函数表达式可以是匿名的(也可以不是)</h2><p id="9fc7" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如我上面简单提到的，函数表达式，因为它们被赋给了变量，所以可以省略名字，成为所谓的“匿名函数”。这是可能的，因为变量名将被<em class="od">隐式地</em>分配给函数。</p><p id="f748" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">匿名函数表达式(隐式命名在起作用)</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="dcc3" class="ni jr it nh b gy ny nz l oa ob">const anonymous = function() {<br/>  return 'I do not need my own name, as I am assigned to the variable anonymous';<br/>}</span><span id="48d1" class="ni jr it nh b gy oc nz l oa ob">console.log(anonymous()); // prints: I do not need my own name, as I am assigned to the variable anonymous</span></pre><p id="9dcc" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">正如变量名所暗示的，因为它引用的函数没有名字，所以它隐式地将<code class="fe ne nf ng nh b">anonymous()</code>赋给该函数。</p><p id="7601" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">然而，如果你想在函数体内引用当前函数，你需要创建一个<em class="od">显式</em>命名的函数(它的名字只在函数体内是局部的)。</p><p id="19fc" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">命名函数表达式(工作时显式命名)</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="8a5c" class="ni jr it nh b gy ny nz l oa ob">var math = {<br/>  'factit': function factorial(n) {<br/>    console.log(n)<br/>    if (n &lt;= 1) {<br/>      return 1;<br/>    }<br/>    return n * factorial(n - 1);<br/>  }<br/>};<br/><br/>console.log(math.factit(3)); //prints: 3; 2; 1;</span></pre><p id="e939" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">对于这个变量<code class="fe ne nf ng nh b">math</code>，您可以通过在对象外部调用<code class="fe ne nf ng nh b">math.factit();</code>来调用<code class="fe ne nf ng nh b">factorial()</code>函数，并传入所需的参数。在我的日常开发中，我并没有发现对这种类型的命名函数表达式有太多的需求，但是如果需要的话，知道它是可用的就好了。</p><p id="13d0" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">底线:</strong>如果函数表达式的名字被省略，那么它将被赋予变量名(隐式名)。如果函数表达式的名称存在，它将是分配的函数名称(显式名称)。</p><h2 id="0da0" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated">函数表达式可以是生命</h2><p id="b0b0" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">函数表达式可以作为一个生命来使用:一个<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">立即调用函数表达式</a>，函数表达式一旦被定义就运行。</p><p id="704e" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">JavaScript引擎的这种立即执行是由匿名函数末尾的<code class="fe ne nf ng nh b">()</code>触发的。</p><p id="fde7" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">我在这里不会讲太多细节，但是对于在生命中创建的任何变量，要让外部或全局范围可以访问，匿名函数必须像函数表达式一样被赋予一个变量。</p><p id="dae0" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">如果不是这样，并且匿名函数只是在运行时被调用，那么在函数作用域内创建的任何变量对外界都是不可见的。</p><p id="f01a" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">可访问的生活变量与不可访问的生活变量</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="3906" class="ni jr it nh b gy ny nz l oa ob">const cogitoErgoSum = (function () {<br/>  const quote = "I think therefore I am";<br/>  return quote;<br/>})();</span><span id="5542" class="ni jr it nh b gy oc nz l oa ob">// immediately creates the output<br/>cogitoErgoSum; // prints: I think therefore I am</span><span id="427c" class="ni jr it nh b gy oc nz l oa ob">(function (){<br/>  const quote2 = "I am not outside this IIFE";<br/>})();</span><span id="db5f" class="ni jr it nh b gy oc nz l oa ob">quote2; // prints: ReferenceError: quote2 is not defined</span></pre><h2 id="fafc" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated"><strong class="ak">函数表达式不提升</strong></h2><p id="4d83" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">函数表达式(和箭头函数)跟在新的<code class="fe ne nf ng nh b">let</code>和<code class="fe ne nf ng nh b">const</code>变量关键字之后，因为它们在运行时不会被提升。</p><p id="ff06" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">正如我在上面关于提升的函数声明一节中所演示的，函数表达式<em class="od">不</em>提升，当执行到达函数表达式时，函数表达式被创建，并且从那时起它是可用的。</p><p id="b3dc" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">函数声明提升与函数表达式不提升</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="a099" class="ni jr it nh b gy ny nz l oa ob">console.log(hoistedFunction()); // prints: I am a function declaration so I am hoisted to the top of the scope at run time</span><span id="ad1a" class="ni jr it nh b gy oc nz l oa ob">function hoistedFunction() {<br/>  return 'I am a function declaration so I am hoisted to the top of the scope at run time';<br/>}</span><span id="6392" class="ni jr it nh b gy oc nz l oa ob">console.log(stillNotHoisted()); // prints: TypeError: stillNotHoisted is not a function</span><span id="87e5" class="ni jr it nh b gy oc nz l oa ob">const stillNotHoisted = function() {<br/>  return 'I am a function expression and therefore, hoisting does not apply to me';<br/>}</span><span id="084a" class="ni jr it nh b gy oc nz l oa ob">console.log(stillNotHoisted()); // prints: I am a function expression and therefore, hoisting does not apply to me</span></pre><p id="0149" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">结果和我在函数声明中描述的一样，如果函数表达式在运行时解析之前被调用，就会抛出<code class="fe ne nf ng nh b">TypeErrors</code>。就是不做。</p><p id="dc06" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">好了，现在是时候讨论箭头功能了:ES6最新最大的功能改进。</p><h1 id="8a5d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">箭头函数表达式➡️</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/757128f99426ada0e576bb7ac5416484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*nRnzjLROZcgLd8A7cHyoXQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">最基本的箭头函数语法。</figcaption></figure><p id="e6c6" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头函数表达式</a>是正则函数表达式的语法紧凑替代。</p><h2 id="2b55" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated">剖析两种基本箭函数表达式</h2><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="acf2" class="ni jr it nh b gy ny nz l oa ob">const basicArrow = () =&gt; {<br/>  return 'The most basic of basic arrow functions';<br/>}</span><span id="315b" class="ni jr it nh b gy oc nz l oa ob">basicArrow(); // prints: The most basic of basic arrow functions</span><span id="f3d7" class="ni jr it nh b gy oc nz l oa ob">const basicArrow2 = oneParam =&gt; 'Single line with ${oneParam } is also valid';</span><span id="5b76" class="ni jr it nh b gy oc nz l oa ob">basicArrow2('only one param'); // prints: Single line with only on param is also valid </span></pre><p id="7cb3" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">上面的两个例子<code class="fe ne nf ng nh b">basicArrow()</code>和<code class="fe ne nf ng nh b">basicArrow2()</code>都是箭头函数的有效例子。与所有的函数表达式一样，这两个匿名函数都是由分配给它们的变量隐式命名的。</p><p id="0228" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">但不同的是，关键字<code class="fe ne nf ng nh b">function</code>是不必要的，相反，如果没有必需的参数，它被一组括号<code class="fe ne nf ng nh b">()</code>代替，即<code class="fe ne nf ng nh b">basicArrow2()</code>所需的单个参数的名称，即<code class="fe ne nf ng nh b">oneParam</code>(在这种情况下不需要括号)，或者，对于任何其他数量的参数，您可以使用<code class="fe ne nf ng nh b">(paramOne, paramTwo, paramThree, ...)</code>。</p><p id="2a2d" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">类似地，第一个函数在函数体内有一个普通的<code class="fe ne nf ng nh b">return</code>语句，用花括号<code class="fe ne nf ng nh b">{}</code>括起来，但是，如果这个语句非常简单，并且您可以将返回结果放在一行中，那么实际的<code class="fe ne nf ng nh b">return</code>和花括号也可以省略，就像在<code class="fe ne nf ng nh b">basicArrow2()</code>中一样。这是带有隐含return语句的简洁主体语法。</p><h2 id="1c1e" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated">箭头功能特征</h2><p id="e901" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">虽然箭头函数乍一看很容易识别，但它们实际上有一些奇怪的、特定的特征，开发人员需要记住这些特征。</p><p id="15f6" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">除了简洁的语法，arrow函数缺少<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank"> this </a>、<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank"> arguments </a>、<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super" rel="noopener ugc nofollow" target="_blank"> super </a>或<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target" rel="noopener ugc nofollow" target="_blank"> new.target </a>关键字。这些事实也导致了arrow函数的一个最大缺点:它们不适合作为方法，也不能用作构造函数。我将很快更详细地讨论这个问题。</p><h2 id="afa3" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated">较短的函数语法</h2><p id="1153" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我看来，正则函数表达式的第一个也是最大的改进是arrow函数提供的更短、更简洁的语法。</p><p id="83bc" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">这是一个与传统函数表达式完全相同的函数，然后再写成一个箭头函数表达式。</p><p id="fd52" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">传统函数表达式:</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="d2f0" class="ni jr it nh b gy ny nz l oa ob">var elements = [‘Hydrogen’, ‘Helium’, ‘Lithium’, ‘Beryllium’];</span><span id="3da6" class="ni jr it nh b gy oc nz l oa ob">elements.map(function(element) {<br/>  return element.length;<br/>});</span><span id="ddca" class="ni jr it nh b gy oc nz l oa ob">// this statement returns the array: [8, 6, 7, 9]</span></pre><p id="cc69" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">新箭头函数表达式:</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="a5e8" class="ni jr it nh b gy ny nz l oa ob">var elements = [‘Hydrogen’, ‘Helium’, ‘Lithium’, ‘Beryllium’];</span><span id="248b" class="ni jr it nh b gy oc nz l oa ob">elements.map((element) =&gt; element.length);</span><span id="773b" class="ni jr it nh b gy oc nz l oa ob">// this statement still returns the same array: [8, 6, 7, 9]</span></pre><p id="9b0b" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">看看这些，告诉我第二个是不是更容易阅读，并遵循代码在做什么。这本身就是我想尽可能使用箭头函数的最大原因。只是干净和清晰多了。</p><h2 id="6e48" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated">吊装仍然不适用</h2><p id="e24d" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">就像传统的函数表达式一样，提升仍然不适用于箭头函数。</p><p id="ec57" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">没有吊装，只有</strong>T4】</p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="7be3" class="ni jr it nh b gy ny nz l oa ob">console.log(fish()); // prints: TypeError: fish is not a function</span><span id="c479" class="ni jr it nh b gy oc nz l oa ob">const fish = () =&gt; ['perch', 'salmon', 'trout', 'bass'];</span><span id="01e8" class="ni jr it nh b gy oc nz l oa ob">console.log(fish()); // prints: [ 'perch', 'salmon', 'trout', 'bass' ]</span></pre><p id="43ad" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">如果你试图在代码中声明之前调用<code class="fe ne nf ng nh b">fish()</code>变量，就会抛出<code class="fe ne nf ng nh b">TypeError</code>。和以前一样，解决方案是要么将函数声明为函数声明，这样它就被提升到作用域的顶部，要么等到函数表达式之后再调用代码。</p><h2 id="7b95" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated"><strong class="ak">没有单独的“这个”</strong></h2><p id="1874" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在arrow函数之前，每个新函数都根据函数的调用方式定义了自己的<code class="fe ne nf ng nh b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">this</a></code>值:</p><ul class=""><li id="eb6e" class="of og it lh b li mm lm mn lq oh lu oi ly oj mc ok ol om on bi translated">在构造函数的情况下是一个新对象，</li><li id="9936" class="of og it lh b li oo lm op lq oq lu or ly os mc ok ol om on bi translated"><code class="fe ne nf ng nh b">undefined</code>在严格模式函数调用中，</li><li id="c1cf" class="of og it lh b li oo lm op lq oq lu or ly os mc ok ol om on bi translated">如果函数作为“对象方法”被调用，</li></ul><p id="c375" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">另一方面，箭头函数没有自己的<code class="fe ne nf ng nh b">this</code>。使用封闭词法范围的<code class="fe ne nf ng nh b">this</code>值；箭头函数遵循普通的变量查找规则，从当前作用域级别开始，一直搜索到最高级别来查找变量。因此，在搜索当前范围内不存在的<code class="fe ne nf ng nh b">this</code>时，一个箭头函数最终从其封闭范围内找到了<code class="fe ne nf ng nh b">this</code>对象。参见下面的例子，了解不同之处。</p><p id="994e" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><code class="fe ne nf ng nh b"><strong class="lh iu">This</strong></code> <strong class="lh iu">作用域，显示函数声明</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="2d34" class="ni jr it nh b gy ny nz l oa ob">function Person() {<br/>  // The Person() constructor defines `this` as an instance of itself.<br/>  this.age = 0;<br/><br/>  setInterval(function growUp() {<br/>    // In non-strict mode, the growUp() function defines `this`<br/>    // as the global object (because it's where growUp() is executed.), <br/>    // which is different from the `this`<br/>    // defined by the Person() constructor.<br/>    this.age++;<br/>  }, 1000);<br/>}<br/><br/>var p = new Person();</span></pre><p id="11b8" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><code class="fe ne nf ng nh b"><strong class="lh iu">This</strong></code> <strong class="lh iu">范围，显示箭头功能</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="d9af" class="ni jr it nh b gy ny nz l oa ob">function Person(){<br/>  this.age = 0;<br/><br/>  setInterval(() =&gt; {<br/>    this.age++; // |this| properly refers to the Person object<br/>  }, 1000);<br/>}<br/><br/>var p = new Person();</span></pre><h2 id="fb04" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated"><strong class="ak">参数没有绑定</strong></h2><p id="71f6" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">除了不能访问<code class="fe ne nf ng nh b">this</code>之外，arrow函数没有自己的<code class="fe ne nf ng nh b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">arguments</a></code> <a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">对象</a>。</p><p id="1563" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">因为您可能没有听说过它们，<code class="fe ne nf ng nh b">arguments</code>是一个函数中类似于<code class="fe ne nf ng nh b">Array</code>的对象，包含传递给该函数的值。我说<code class="fe ne nf ng nh b">Array</code> -like是因为这个<code class="fe ne nf ng nh b">arguments</code>有一个长度属性和索引，但是它缺少Array的内置方法，比如<code class="fe ne nf ng nh b">.forEach()</code>和<code class="fe ne nf ng nh b">.map()</code>。</p><p id="d96a" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">因此，在这个例子中，<code class="fe ne nf ng nh b">arguments</code>只是对封闭范围的参数的引用。</p><p id="4d49" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><code class="fe ne nf ng nh b"><strong class="lh iu">arguments</strong></code> <strong class="lh iu">带箭头功能</strong></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="7c46" class="ni jr it nh b gy ny nz l oa ob">var arguments = [1, 2, 3];<br/>var arr = () =&gt; arguments[0];<br/><br/>arr(); // prints: 1<br/><br/>function foo(n) {<br/>  var f = () =&gt; arguments[0] + n; // foo's implicit arguments binding. arguments[0] is n<br/>  return f();<br/>}<br/><br/>foo(3); // prints: 6</span></pre><p id="a073" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">在大多数情况下，使用rest参数是使用<code class="fe ne nf ng nh b">arguments</code>对象的一个很好的替代方法。</p><p id="88f5" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">休息参数用箭头功能</strong>代替 <code class="fe ne nf ng nh b"><strong class="lh iu">arguments</strong></code> <strong class="lh iu"/></p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="21b4" class="ni jr it nh b gy ny nz l oa ob">function foo(n) { <br/>  var f = (...args) =&gt; args[0] + n;<br/>  return f(10); <br/>}<br/><br/>foo(1); // prints: 11</span></pre><p id="69b1" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">rest参数，我将在本系列的另一篇博文中讨论，是ES6推荐的访问和操作arrow函数内部的<code class="fe ne nf ng nh b">arguments</code>的方法。</p><h2 id="632b" class="ni jr it bd js nj nk dn jw nl nm dp ka lq nn no ke lu np nq ki ly nr ns km nt bi translated">不使用“New”作为构造函数</h2><p id="3a1c" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好了，最后要知道的箭头函数特性:箭头函数不能作为构造函数使用，当和<code class="fe ne nf ng nh b">new</code>关键字一起使用时会抛出一个<code class="fe ne nf ng nh b">TypeError</code>。</p><pre class="kp kq kr ks gt nu nh nv nw aw nx bi"><span id="684e" class="ni jr it nh b gy ny nz l oa ob">var Foo = () =&gt; {};<br/>var foo = new Foo(); // prints: TypeError: Foo is not a constructor</span></pre><p id="4192" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">仅此而已。这就是关于箭头函数你需要知道的。简单！😅</p><h1 id="2cdd" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="ad2f" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">JavaScript是一种非常强大的编程语言，它的受欢迎程度只会继续增加(如果年度开发者调查可信的话)。尽管有如此多的开发人员使用它，但肯定会有一些误解和知识差距，特别是随着ES6越来越广泛地被日常使用。</p><p id="d613" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">我的目标是阐明您日常使用的一些JavaScript和ES6语法，但可能从未完全理解其工作方式的细微差别。</p><p id="039a" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">各种类型的函数都是JavaScript的主食，无论是传统的函数声明或函数表达式，还是更新、更简洁的ES6 arrow函数。知道何时(以及如何)有效地利用每种类型函数的好处，肯定会使编写JS变得更容易。</p><p id="d152" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">过几周再来看看，我会写更多关于JavaScript和ES6或其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="6f97" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">感谢您的阅读，我希望您能够更好地将箭头函数整合到您的JavaScript应用程序中。如果你觉得有帮助，请与你的朋友分享！</p><p id="7e69" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他一些博客</p><ul class=""><li id="86ad" class="of og it lh b li mm lm mn lq oh lu oi ly oj mc ok ol om on bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/var-let-const-javascript-es6-feature-series-pt-1-fa603567809e"> Var，Let &amp; Const: JavaScript ES6特性系列(Pt 1) </a></li><li id="a02f" class="of og it lh b li oo lm op lq oq lu or ly os mc ok ol om on bi translated"><a class="ae le" href="http://Take Your VS Code Configuration Anywhere Easily with Settings Sync" rel="noopener ugc nofollow" target="_blank">通过设置同步</a>,将您的VS代码配置轻松带到任何地方</li><li id="bcdf" class="of og it lh b li oo lm op lq oq lu or ly os mc ok ol om on bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-international-methods-b70a2de09d92"> JavaScript国际方法</a></li></ul></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="1a82" class="pw-post-body-paragraph lf lg it lh b li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly mq ma mb mc im bi translated"><strong class="lh iu">参考资料和更多资源:</strong></p><ul class=""><li id="afe2" class="of og it lh b li mm lm mn lq oh lu oi ly oj mc ok ol om on bi translated">函数声明，MDN Docs:<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Statements/function</a></li><li id="4c82" class="of og it lh b li oo lm op lq oq lu or ly os mc ok ol om on bi translated">函数表达式，MDN Docs:<a class="ae le" href="https://developer.mozilla.org/en-US/docs/web/JavaScript/Reference/Operators/function" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/web/JavaScript/Reference/Operators/function</a></li><li id="7039" class="of og it lh b li oo lm op lq oq lu or ly os mc ok ol om on bi translated">Arrow Functions，MDN Docs:<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Functions/Arrow _ Functions</a></li></ul></div></div>    
</body>
</html>