<html>
<head>
<title>Next-Gen Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一代Javascript</h1>
<blockquote>原文：<a href="https://itnext.io/next-gen-javascript-2697ab934ffd?source=collection_archive---------0-----------------------#2017-12-28">https://itnext.io/next-gen-javascript-2697ab934ffd?source=collection_archive---------0-----------------------#2017-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bafa35144a29dfe88fb1175b99011927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IC0WTFi9hrUW2XL-LxHO1w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ECMAScript是定义JS特性的标准</figcaption></figure></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><h1 id="1dd0" class="kj kk iq bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">让和const超过var</h1><p id="3eac" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">let关键字允许您考虑块范围来定义变量。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="dd8d" class="mo kk iq mk b gy mp mq l mr ms"><strong class="mk ir">const </strong>letFunc = () =&gt; {<br/>    <strong class="mk ir">let </strong>myLet = 1<br/>    <strong class="mk ir">if</strong>(<strong class="mk ir">true</strong>) {<br/>        <strong class="mk ir">let  </strong>myLet = 2<br/>        console.log(myLet)<br/>    }<br/>    console.log(myLet)<br/>}</span><span id="cd13" class="mo kk iq mk b gy mt mq l mr ms">letFunc()</span><span id="66a7" class="mo kk iq mk b gy mt mq l mr ms">// 2<br/>// 1</span></pre><p id="8518" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">const关键字的作用类似于java中的final关键字。它告诉你被定义为const的变量在整个代码中不会再被改变。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ee41" class="mo kk iq mk b gy mp mq l mr ms">const myConst = 'I\'m not gonna change'</span></pre><p id="712e" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">另一方面，var关键字考虑的是函数范围，而不关心块范围。这意味着您可以使用var关键字来定义全局变量。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c744" class="mo kk iq mk b gy mp mq l mr ms"><strong class="mk ir">const </strong>varFunc = () =&gt; {<br/>    <strong class="mk ir">var </strong>myVar = 1<br/>    <strong class="mk ir">if</strong>(<strong class="mk ir">true</strong>) {<br/>        <strong class="mk ir">var  </strong>myVar = 2<br/>        console.log(myVar)<br/>    }<br/>    console.log(myVar)<br/>}<br/><br/>varFunc()</span><span id="6842" class="mo kk iq mk b gy mt mq l mr ms">// 2<br/>// 2</span></pre><h1 id="774c" class="kj kk iq bd kl km mz ko kp kq na ks kt ku nb kw kx ky nc la lb lc nd le lf lg bi translated">箭头功能</h1><p id="043d" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Arrow函数没有取代js中的函数有几个原因</p><blockquote class="ne"><p id="a84b" class="nf ng iq bd nh ni nj nk nl nm nn me dk translated">箭头功能没有自己的<code class="fe no np nq mk b">this</code></p></blockquote><ol class=""><li id="caa1" class="nr ns iq lj b lk nt lo nu ls nv lw nw ma nx me ny nz oa ob bi translated">这个关键字总是指在定义arrow函数的环境中定义的东西</li><li id="926c" class="nr ns iq lj b lk oc lo od ls oe lw of ma og me ny nz oa ob bi translated">不能与new关键字一起使用</li></ol><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="782e" class="mo kk iq mk b gy mp mq l mr ms"><strong class="mk ir">function </strong>testScopeFunc() {<br/>    console.log(<strong class="mk ir">this</strong>.amt)<br/>    <strong class="mk ir">return </strong>{<br/>        amt: 10,<br/>        getAmt: () =&gt; console.log(<strong class="mk ir">this</strong>.amt)<br/>    }<br/>}<br/><br/>testScopeFunc.call({ amt: 2 }).getAmt()</span><span id="5118" class="mo kk iq mk b gy mt mq l mr ms">// 2<br/>// 2</span></pre><p id="3f13" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">但是当我们使用一个普通的函数时</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5314" class="mo kk iq mk b gy mp mq l mr ms"><strong class="mk ir">function </strong>testScopeFuncNormal() {<br/>    console.log(<strong class="mk ir">this</strong>.amt)<br/>    <strong class="mk ir">return </strong>{<br/>        amt: 10,<br/>        getAmt: <strong class="mk ir">function</strong>() {<br/>            "use strict";<br/>            console.log(<strong class="mk ir">this</strong>.amt)<br/>        }<br/>    }<br/>}<br/><br/>testScopeFuncNormal.call({amt: 2}).getAmt()</span><span id="a257" class="mo kk iq mk b gy mt mq l mr ms">// 2<br/>// 10</span></pre><p id="7d3b" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">如你所见，arrow函数总是指向一个固定的范围。就像我们在java中使用“this”一样。</p><h2 id="7fbe" class="mo kk iq bd kl oh oi dn kp oj ok dp kt ls ol om kx lw on oo lb ma op oq lf or bi translated">如何使用箭头函数</h2><ol class=""><li id="92c9" class="nr ns iq lj b lk ll lo lp ls os lw ot ma ou me ny nz oa ob bi translated">单线线路</li></ol><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="958b" class="mo kk iq mk b gy mp mq l mr ms">const myFunc = () =&gt; console.log('My Function')</span></pre><p id="c52e" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">这里不需要return关键字</p><p id="0dd6" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">2.多线</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9a24" class="mo kk iq mk b gy mp mq l mr ms">const myFunc = () =&gt; { //Your Function body }</span></pre><p id="85d9" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">3.单变量</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c551" class="mo kk iq mk b gy mp mq l mr ms">const myFunc = arg =&gt; { // your func body}</span></pre><p id="ad78" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">如果有多个参数或者根本没有参数，则必须使用括号()=&gt; {}语法</p><h1 id="22d1" class="kj kk iq bd kl km mz ko kp kq na ks kt ku nb kw kx ky nc la lb lc nd le lf lg bi translated">出口和进口</h1><p id="0510" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当您在多个文件中编写代码时，您必须将一个文件中编写的函数导入到另一个文件中。这就是你需要这个的地方。</p><h2 id="ecbb" class="mo kk iq bd kl oh oi dn kp oj ok dp kt ls ol om kx lw on oo lb ma op oq lf or bi translated">出口</h2><p id="2e99" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果你想从你的文件中公开一个函数，你可以使用如下的默认导出</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="08e5" class="mo kk iq mk b gy mp mq l mr ms">export default myfunc</span></pre><p id="5474" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">但是当你有多个函数时，你可以使用下面的语法。我们称之为命名导出</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6ffe" class="mo kk iq mk b gy mp mq l mr ms">export const func1<br/>export const func2</span></pre><h2 id="a1ab" class="mo kk iq bd kl oh oi dn kp oj ok dp kt ls ol om kx lw on oo lb ma op oq lf or bi translated">导入</h2><p id="d400" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果您使用上面给出的默认导出，您可以使用下面的语法</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="51a2" class="mo kk iq mk b gy mp mq l mr ms">import myfunc from './somefile'<br/>import person from './somefile'</span></pre><p id="f821" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">如果要导入多个函数，可以使用以下语法</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="62fe" class="mo kk iq mk b gy mp mq l mr ms">import { func1 } from './somefile'<br/>import { func1, func2 } from './somefile'<br/>import { func1 as f1, func2 as f2 } from './somefile'</span></pre><p id="a090" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">或者你可以一次全部导入并如下使用它们</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9c54" class="mo kk iq mk b gy mp mq l mr ms">import * as myFunctionPool from './somefile'</span><span id="a644" class="mo kk iq mk b gy mt mq l mr ms">// call seperate functions as <br/>myFunctionPool.func1()<br/>myFunctionPool.func2()</span></pre><h1 id="4121" class="kj kk iq bd kl km mz ko kp kq na ks kt ku nb kw kx ky nc la lb lc nd le lf lg bi translated">班级</h1><p id="08d4" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">类是对象的蓝图。它们可以同时具有属性和方法。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="080e" class="mo kk iq mk b gy mp mq l mr ms"><strong class="mk ir">class </strong>Planet {<br/>    constructor(){<br/>        <strong class="mk ir">this</strong>.name = 'Earth'<br/>        <strong class="mk ir">this</strong>.age = 2300<br/>    }<br/>    getName() { console.log(<strong class="mk ir">this</strong>.name) }<br/>}<br/><strong class="mk ir">const </strong>earth = <strong class="mk ir">new </strong>Planet()<br/>earth.getName()Spread and Rest Operators</span></pre><p id="8cf4" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">类支持继承</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="56b8" class="mo kk iq mk b gy mp mq l mr ms"><strong class="mk ir">class </strong>SolarSystem {<br/>    constructor(){<br/>        <strong class="mk ir">this</strong>.galaxy = 'Milky way'<br/>    }<br/>    getGalaxy() { console.log(<strong class="mk ir">this</strong>.galaxy)}<br/>}<br/><br/><strong class="mk ir">class </strong>Planet <strong class="mk ir">extends </strong>SolarSystem{<br/>    constructor(){<br/>        <strong class="mk ir">super</strong>() // Have to call the super class in derived class    which executes the parent constructor<br/>        <strong class="mk ir">this</strong>.name = 'Earth'<br/>        <strong class="mk ir">this</strong>.age = 2300<br/>    }<br/>    getName() { console.log(<strong class="mk ir">this</strong>.name) }<br/><br/>}<br/><br/><strong class="mk ir">const </strong>earth = <strong class="mk ir">new </strong>Planet()<br/>earth.getName()<br/>earth.getGalaxy()</span></pre><p id="c555" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">在<strong class="lj ir"> ES7 </strong>中，你可以跳过构造函数调用，直接在类中开发属性。你也不必使用<strong class="lj ir"> super() </strong>调用超类的构造函数。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ffba" class="mo kk iq mk b gy mp mq l mr ms"><strong class="mk ir">class </strong>Water {<br/>    ph = 6.97<br/>    o2 = 22<br/>}</span></pre><h1 id="3c21" class="kj kk iq bd kl km mz ko kp kq na ks kt ku nb kw kx ky nc la lb lc nd le lf lg bi translated">休息和传播运算符</h1><p id="e89f" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">仅使用3个连续的点(…)来表示静止和展开</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="bd26" class="mo kk iq mk b gy mp mq l mr ms">... // This is basically the spread and rest operator</span></pre><ul class=""><li id="e481" class="nr ns iq lj b lk mu lo mv ls ov lw ow ma ox me oy nz oa ob bi translated">Spread用于拆分数组或对象属性，以创建新的数组或对象</li><li id="bb0f" class="nr ns iq lj b lk oc lo od ls oe lw of ma og me oy nz oa ob bi translated">Rest —用于将函数的多个参数聚合到一个数组中</li></ul><h2 id="77e1" class="mo kk iq bd kl oh oi dn kp oj ok dp kt ls ol om kx lw on oo lb ma op oq lf or bi translated">扩展运算符用途</h2><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="059c" class="mo kk iq mk b gy mp mq l mr ms"><strong class="mk ir">let </strong>myArr = [1,2,3]<br/><strong class="mk ir">let </strong>myNewArray = [...myArr, 4, 5]<br/>console.log(myNewArray) // [ 1, 2, 3, 4, 5 ]</span></pre><p id="01e3" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">扩展操作符也可以用于对象</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f574" class="mo kk iq mk b gy mp mq l mr ms"><strong class="mk ir">const </strong>leaf = {<br/>    color:'green',<br/>}<br/><br/><strong class="mk ir">const </strong>tree = {<br/>    ...leaf,<br/>    leaves: 23,<br/>}</span><span id="bea0" class="mo kk iq mk b gy mt mq l mr ms">console.log(tree)</span></pre><p id="f416" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">Rest运算符使用</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8d4f" class="mo kk iq mk b gy mp mq l mr ms"><strong class="mk ir">function </strong>arguments(...args) {<br/>    <strong class="mk ir">for</strong>(<strong class="mk ir">let </strong>arg <strong class="mk ir">of </strong>args){<br/>        console.log(arg)<br/>    }<br/>}<br/><br/>arguments(1,2,3,4,5,6)</span></pre><p id="59e3" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">这里，我们传递给函数的参数将被推送到一个数组中，这个数组可以使用索引来访问</p><h1 id="d314" class="kj kk iq bd kl km mz ko kp kq na ks kt ku nb kw kx ky nc la lb lc nd le lf lg bi translated">解构</h1><p id="3b1a" class="pw-post-body-paragraph lh li iq lj b lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">用于分别从对象和数组中提取属性或元素。</p><p id="bc8b" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">在数组中，元素的顺序定义了我们提取的对象，而在对象中，属性名定义了我们提取的内容</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0e7c" class="mo kk iq mk b gy mp mq l mr ms">{ name, age } = { name: 'me', age:22 }<br/>console.log(name) // me</span></pre><p id="18e3" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">对于数组</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="eb5d" class="mo kk iq mk b gy mp mq l mr ms">[x,,z] = [1, 2, 3]<br/>console.log(x) // 1<br/>console.log(z) //3</span></pre><p id="2042" class="pw-post-body-paragraph lh li iq lj b lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">这些是js最新版本中新引入的一些东西。但是还有其他一些重要的特性，比如循环的<strong class="lj ir">—</strong>、<strong class="lj ir">生成器函数</strong>，当yeild(暂停)<strong class="lj ir">、async await </strong>取代了承诺和回调等的使用时，它会在函数中存储一个状态。最后如果喜欢这篇文章就鼓掌。</p></div></div>    
</body>
</html>