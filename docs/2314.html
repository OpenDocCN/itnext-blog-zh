<html>
<head>
<title>Architecting the Store in NGRX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在NGRX中构建商店</h1>
<blockquote>原文：<a href="https://itnext.io/architecting-the-store-in-ngrx-e4955641d746?source=collection_archive---------7-----------------------#2019-05-05">https://itnext.io/architecting-the-store-in-ngrx-e4955641d746?source=collection_archive---------7-----------------------#2019-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6753" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在NGRX中构建和设计商店的分步指南</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/6a24ee7600c4fac5b2a7982d4857f276.png" data-original-src="https://miro.medium.com/v2/format:webp/1*CYmnppaZkh7OcF1IRH15jQ.png"/></div></figure><p id="9b04" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是系列文章的第二篇，旨在详细解释用NGRX构建Angular应用程序的一步一步的方法。</p><p id="f57c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本系列的第一篇文章<a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/state-management-with-ngrx-introduction-1aae0803e988">中，我写了一篇关于NGRX平台所有概念的概述。</a></p><p id="58e7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您从未使用过NGRX，或者从未深入研究过，我真的建议您阅读它。</p><h2 id="3bc2" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">NGRX 8</h2><p id="5304" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">在前一篇文章中，使用当前的NGRX版本解释了这些概念。为了让文章保持最新，从现在开始，我将使用NGRX version 8中发布的最新特性来介绍和解释相同的概念。外面有些很酷的东西！</p><p id="94d8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">特别是，我们将了解如何创建:</p><ul class=""><li id="aa8e" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated">使用<code class="fe mr ms mt mu b">createAction</code>的动作</li><li id="8b66" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">带<code class="fe mr ms mt mu b">createReducer</code>的减速器</li><li id="aee4" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">与<code class="fe mr ms mt mu b">createEffect</code>的效果(在下一篇文章中)</li></ul><h2 id="b21b" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">这篇文章是关于什么的？</h2><p id="1e2a" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">相反，在本文中，我们将探索构建构成我们的存储的实体的过程，并将为每个实体设置实体适配器、动作和reducers。</p><p id="d438" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">作为我之前关于<a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/building-an-enterprise-grade-angular-project-structure-f5be32533ba3">创建可伸缩文件夹结构</a>的一篇文章的后续，我们将看到一个创建存储模块作为由我们的域模块导入的服务模块的例子。</p><p id="06bc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将开始构建一个应用程序，从<a class="ae lj" href="https://coincap.io" rel="noopener ugc nofollow" target="_blank"> Coincap </a> **中检索实时加密价格，并在一个可定制的仪表板中显示它们。</p><p id="5b32" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="na"> **我浏览了各种获取实时价格的网站，Coincap是迄今为止最简单、最清晰的提供商。向团队致敬！</em></p><h1 id="d927" class="nb ll iq bd lm nc nd ne lp nf ng nh ls jw ni jx lv jz nj ka ly kc nk kd mb nl bi translated">设置角度和NGRX</h1><p id="369f" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">让我们看看如何设置Angular应用程序和NGRX。</p><h2 id="a1e5" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">Angular CLI工作空间</h2><p id="0f42" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">您可能要做的第一件事是用Angular CLI创建一个新的应用程序，并添加路由和样式参数。</p><p id="0931" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe mr ms mt mu b">ng new &lt;app&gt; --routing --style=scss</code></p><h2 id="f5c0" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">NGRX</h2><p id="26da" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">让我们安装使用NGRX所需的所有库:</p><p id="20b8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe mr ms mt mu b">npm i @ngrx/store @ngrx/effects @ngrx/entity</code></p><p id="2954" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你差不多都准备好了！</p><p id="bcd5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本系列的最后，我将在Github上发布整个应用程序，这样您就可以使用自己的项目运行或复制粘贴代码。</p><h1 id="569b" class="nb ll iq bd lm nc nd ne lp nf ng nh ls jw ni jx lv jz nj ka ly kc nk kd mb nl bi translated">项目的文件夹结构</h1><p id="1594" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">让我们简单看一下我选择的项目结构:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/782fcb24190810b3623a6a27eedfd497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTWoVjCnGCJMMNUzxcdcUw.png"/></div></div></figure><ul class=""><li id="5792" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated"><strong class="kp ir"/><code class="fe mr ms mt mu b"><strong class="kp ir">store</strong></code>里有什么？<br/>在<code class="fe mr ms mt mu b">store</code>中的每个文件夹都是一个Angular服务模块，它只是为仪表板模块设置NGRX存储和效果，仪表板模块是一个域模块，我们的应用程序的智能组件就放在这个域模块中。</li></ul><p id="4705" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们来看看<code class="fe mr ms mt mu b">DashboardStoreModule</code>这个还是很简单的:</p><pre class="kf kg kh ki gt nr mu ns nt aw nu bi"><span id="bff0" class="lk ll iq mu b gy nv nw l nx ny">@NgModule({<br/>    imports: [<br/>        StoreModule.forFeature('dashboard', dashboardReducer),<br/>        // will import effects<br/>    ],<br/>    providers: [<br/>       // will import providers<br/>    ]<br/>})<br/><em class="na">export class </em>DashboardStoreModule {}</span></pre><p id="485e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后<code class="fe mr ms mt mu b">DashboardModule</code>将导入<code class="fe mr ms mt mu b">DashboardStoreModule</code>和其他商店模块:</p><pre class="kf kg kh ki gt nr mu ns nt aw nu bi"><span id="0af2" class="lk ll iq mu b gy nv nw l nx ny">@NgModule({<br/>    declarations: [<br/>       // components<br/>    ],<br/>    imports: [<br/>        <em class="na">// store service modules<br/>        </em>DashboardStoreModule,<br/>        PricesStoreModule,<br/>        AssetsStoreModule,</span><span id="6d4f" class="lk ll iq mu b gy nz nw l nx ny"><em class="na">// other modules</em></span><span id="df3b" class="lk ll iq mu b gy nz nw l nx ny">],<br/>    exports: [RouterModule]<br/>})<br/><em class="na">export class </em>DashboardModule {}</span></pre><ul class=""><li id="2eb1" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated"><strong class="kp ir"/><code class="fe mr ms mt mu b"><strong class="kp ir">DashboardModule</strong></code><strong class="kp ir">哪里导入的？<br/></strong><code class="fe mr ms mt mu b">DashboardModule</code>是一个延迟加载的模块，所以我们不从应用程序的任何地方导入它，而是在路由模块配置中引用它。</li></ul><p id="75a0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了让延迟加载的特性模块与NGRX一起工作，我们需要为<code class="fe mr ms mt mu b">StoreModule</code>和<code class="fe mr ms mt mu b">EffectsModule</code>调用forRoot方法，尽管使用空值。</p><pre class="kf kg kh ki gt nr mu ns nt aw nu bi"><span id="7405" class="lk ll iq mu b gy nv nw l nx ny">@NgModule({<br/>    declarations: [AppComponent],<br/>    imports: [<br/>        // other modules,<br/>        StoreModule.forRoot({}, { metaReducers }),<br/>        EffectsModule.forRoot([]),<br/>    ],<br/>    bootstrap: [AppComponent]<br/>})<br/><em class="na">export class </em>AppModule {}</span></pre><h1 id="7400" class="nb ll iq bd lm nc nd ne lp nf ng nh ls jw ni jx lv jz nj ka ly kc nk kd mb nl bi translated">商店实体</h1><p id="a7dd" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">为了构建商店，我们需要首先分析我们的数据结构。</p><p id="68ad" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如我上面提到的，该应用程序将以一个带有<strong class="kp ir">磁贴</strong>的<strong class="kp ir">仪表盘</strong>为特色，每个小部件都将包含加密货币价格标签。为了检索显示<strong class="kp ir">价格</strong>，我们首先需要加载<strong class="kp ir">资产(加密货币)</strong>。</p><p id="e316" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后，我们将使用4个不同的实体来构建我们相当简单的商店:</p><ul class=""><li id="ab25" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated">包含磁贴(或小部件)的仪表板</li><li id="aca3" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">资产列表(加密货币)</li><li id="4692" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">(认购的每项资产的)价格</li></ul><h2 id="d3e3" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">平面存储与嵌套存储</h2><p id="1638" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">我们有两种建店方式:</p><ul class=""><li id="fa36" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated">嵌套结构，直接将价格添加到资产存储中</li><li id="da92" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">一种平面结构，其中资产和价格被分成两个独立的对象，并且仅基于资产ID相关</li></ul><p id="b124" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我个人比较喜欢扁平化的结构。</p><p id="8e8e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">为什么？过去，我错误地选择了嵌套结构，我发现了以下问题:</strong></p><ul class=""><li id="b0c5" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated">通过直接给资产添加价格，我们将改变实体的原始接口</li><li id="eb6e" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">更深的嵌套结构更难查询</li></ul><p id="77e8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个简单的例子中，它并没有真正影响性能或复杂性。但是，如果您计划构建一个具有复杂状态的大型应用程序，您将很快发现嵌套结构是如何导致选择器和存储复杂性增加的。</p><p id="9cde" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我的建议是将存储保持为对象的平面结构，并使用唯一值来保持它们之间的关系。</p><h1 id="0fad" class="nb ll iq bd lm nc nd ne lp nf ng nh ls jw ni jx lv jz nj ka ly kc nk kd mb nl bi translated">仪表盘</h1><p id="3643" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">为了简单起见，我们将保持仪表板的最小化。我们只需要小部件中的两件东西:</p><ul class=""><li id="46fe" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated">磁贴ID</li><li id="a203" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">资产ID</li></ul><p id="466f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了构建商店的这一部分，我们将使用<code class="fe mr ms mt mu b">@ngrx/entity</code>。</p><h2 id="eb0e" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">瓷砖</h2><p id="8ff1" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">让我们首先创建一个名为<code class="fe mr ms mt mu b">Tile</code>的类，它代表我们状态的模型:</p><pre class="kf kg kh ki gt nr mu ns nt aw nu bi"><span id="80ba" class="lk ll iq mu b gy nv nw l nx ny"><em class="na">export class </em>Tile {<br/>    <em class="na">public readonly </em>id = uuid();</span><span id="3c97" class="lk ll iq mu b gy nz nw l nx ny"><em class="na">    constructor</em>(<em class="na">public </em>assetId?: <em class="na">string</em>) {}<br/>}</span></pre><p id="ef6a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当然，除非一个磁贴预先加载了一个资产ID，否则在用户决定显示哪个资产之前，资产ID不会被定义，这就是为什么我们标记为可能的<code class="fe mr ms mt mu b">undefined</code>。</p><h2 id="646b" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">仪表板适配器</h2><p id="6c7f" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">我们继续为我们的状态创建适配器。我们的状态将只是一个实体状态，包含一组图块:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="e799" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">仪表板操作</h2><p id="e6b4" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">为了创建我们的动作，我们将使用NGRX 8提供的名为<code class="fe mr ms mt mu b">createAction</code>的新工厂。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="10d4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">总结代码，我们创建了3个动作:</p><ul class=""><li id="1605" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated"><code class="fe mr ms mt mu b">addTile</code>谁的有效载荷是一个<code class="fe mr ms mt mu b">Tile</code>级</li><li id="94b8" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated"><code class="fe mr ms mt mu b">removeTile</code>它只接收一个字符串作为有效载荷，也就是ID</li><li id="f63e" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated"><code class="fe mr ms mt mu b">updateTile</code>它也接收一个<code class="fe mr ms mt mu b">Tile</code>类</li></ul><p id="cd53" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">注意<code class="fe mr ms mt mu b">props</code>是一个从<code class="fe mr ms mt mu b">@ngrx/store</code>导入的函数，作为第二个参数被调用。</p><h2 id="75c8" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">仪表板减速器</h2><p id="a08c" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">为了构建仪表板缩减器，我们将使用名为<code class="fe mr ms mt mu b">createReducer</code>的新工厂方法，该方法采用以下参数:</p><ul class=""><li id="3cd4" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated">第一个参数是初始状态，这是我们使用实体适配器创建的</li><li id="4a81" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">以下所有参数都是每个动作的缩减器函数，我们使用从<code class="fe mr ms mt mu b">@ngrx/store</code>导入的函数<code class="fe mr ms mt mu b">on</code>来定义</li><li id="314e" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">我们使用实体适配器方法来添加、删除和更新仪表板的图块</li></ul><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="417a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们在<code class="fe mr ms mt mu b">DashboardStoreModule</code>中导入了减速器:</p><pre class="kf kg kh ki gt nr mu ns nt aw nu bi"><span id="e3e4" class="lk ll iq mu b gy nv nw l nx ny">@NgModule({<br/>    imports: [<br/>         StoreModule.forFeature('dashboard', dashboardReducer),<br/>    ]<br/>// more</span></pre><h1 id="865f" class="nb ll iq bd lm nc nd ne lp nf ng nh ls jw ni jx lv jz nj ka ly kc nk kd mb nl bi translated">资产</h1><p id="e8a4" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">因为我们将使用Coincap的API接收资产列表，所以我们将复制它们的接口:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="f3a6" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">资产操作</h2><p id="ab91" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">为了获取资产，我们需要对Coincap的API执行一个HTTP请求。HTTP动作将通过我们将在下一篇文章中定义的效果方法。</p><p id="d047" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里需要注意的是我分解资产<em class="na">动作</em>的方式:</p><ul class=""><li id="c8b6" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated"><strong class="kp ir">getAssetsRequestStarted:</strong><br/>请求开始时调度的操作</li><li id="6352" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated"><strong class="kp ir">getAssetsRequestSuccess:</strong><br/>当请求成功时被调度的动作(为了简单起见，这里没有错误动作，但是你应该总是创建它们)</li><li id="2faf" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated"><strong class="kp ir"> addAssets: </strong> <br/>仅由reducer使用的动作，这是一个向商店添加资产的命令</li></ul><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="b5a0" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">资产缩减器和适配器</h2><p id="1a72" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">唯一对<em class="na"> addAssets </em>动作做出反应的reducer函数将简单地在获取所有资产后将其添加到存储中。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="bcde" class="nb ll iq bd lm nc nd ne lp nf ng nh ls jw ni jx lv jz nj ka ly kc nk kd mb nl bi translated">价格</h1><p id="c49a" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">Coincap的API返回的价格非常简单，只是带有资产键及其相对价格的对象。因此，我们有一个非常简单的价格商店。</p><h2 id="a70f" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">价格行动</h2><p id="93fd" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">我们将创建3个行动:</p><ul class=""><li id="4096" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated"><strong class="kp ir"> addPrice: <br/> </strong>收到价格后更新商店的动作</li><li id="ea2e" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated"><strong class="kp ir">createPriceSubscription</strong>:<br/>创建订阅的动作</li><li id="ff37" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated"><strong class="kp ir">关闭价格订阅</strong> : <br/>关闭订阅的动作</li></ul><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="ef4a" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">降价</h2><p id="96b8" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">由于Coincap的实时API返回的价格只是资产及其价格的一个键，所以我们真的不需要对实体框架做太多工作。</p><p id="0fbe" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">实际上，对于收到的每一个价格，我们只需通过用新的有效负载传播价格对象，用存储中的资产ID及其价格来设置键。</p><p id="13ca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果它不存在，就会被创建，否则，就会被它的最新值覆盖。</p><p id="dac2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">想象我们的状态是:</p><pre class="kf kg kh ki gt nr mu ns nt aw nu bi"><span id="05a9" class="lk ll iq mu b gy nv nw l nx ny">{ "bitcoin": "some price" };</span></pre><p id="8a06" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们来自WebSocket流的有效负载是:</p><pre class="kf kg kh ki gt nr mu ns nt aw nu bi"><span id="2a65" class="lk ll iq mu b gy nv nw l nx ny">{ "ethereum": "another price" }</span></pre><p id="730e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这只会变成:</p><pre class="kf kg kh ki gt nr mu ns nt aw nu bi"><span id="575f" class="lk ll iq mu b gy nv nw l nx ny">{ <br/>    "bitcoin": "some price",<br/>    "ethereum": "another price"<br/>};</span></pre><p id="bae8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是一个简单操作的代码:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="3ccc" class="nb ll iq bd lm nc nd ne lp nf ng nh ls jw ni jx lv jz nj ka ly kc nk kd mb nl bi translated">商店的概况</h1><p id="6507" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">让我们用一些数据来看看这家店:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi oc"><img src="../Images/fb78651ed1e47d80728f54c331c149ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3U_DkFj1rvw_cCxWyAph4g.png"/></div></div></figure><ul class=""><li id="de97" class="mi mj iq kp b kq kr kt ku kw mk la ml le mm li mn mo mp mq bi translated">我们已经获取了5项资产</li><li id="3a41" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">我们有一个，空瓷砖</li><li id="80e2" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">我们没有价格，因为图块尚未订阅资产</li></ul><h1 id="c483" class="nb ll iq bd lm nc nd ne lp nf ng nh ls jw ni jx lv jz nj ka ly kc nk kd mb nl bi translated">外卖食品</h1><ul class=""><li id="fdfc" class="mi mj iq kp b kq md kt me kw od la oe le of li mn mo mp mq bi translated">布置您的应用程序实体，并分析它们之间的关系，以便清楚地了解商店的结构可能是什么样子</li><li id="f137" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">使用NGRX实体！这是一个伟大的工具来减少你的减速器样板</li><li id="b0e9" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">使用商店服务模块将用户界面模块从商店中分离出来</li><li id="442f" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">比起嵌套结构，更喜欢扁平结构</li><li id="bee8" class="mi mj iq kp b kq mv kt mw kw mx la my le mz li mn mo mp mq bi translated">保持动作的清晰和粒度，区分命令和事件</li></ul><p id="dd4d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在下一篇文章中，我们将着眼于创建从API获取数据的效果，以及从<em class="na"> Coincap </em>接收实时价格的流。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="adbf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">希望你喜欢这篇文章，如果你同意，不同意，或者如果你想做任何不同的事情，请留言！</p><p id="7ed6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="na">如果你喜欢这篇文章，请关注我的</em><a class="ae lj" href="https://medium.com/@.gc" rel="noopener"><em class="na">Medium</em></a><em class="na">或</em><a class="ae lj" href="https://twitter.com/home" rel="noopener ugc nofollow" target="_blank"><em class="na">Twitter</em></a><em class="na">以获取更多关于Angular、RxJS、Typescript等的文章！</em></p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="efc6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="na">原发布于</em><a class="ae lj" href="https://frontend.consulting/architecting-the-store-in-ngrx" rel="noopener ugc nofollow" target="_blank"><em class="na">https://frontend . consulting</em></a><em class="na">。</em></p></div></div>    
</body>
</html>