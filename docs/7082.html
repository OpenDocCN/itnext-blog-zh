<html>
<head>
<title>Go’s new sorting algorithm: pdqsort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go的新排序算法:pdqsort</h1>
<blockquote>原文：<a href="https://itnext.io/gos-new-sorting-algorithm-pdqsort-822053d7801b?source=collection_archive---------0-----------------------#2022-06-07">https://itnext.io/gos-new-sorting-algorithm-pdqsort-822053d7801b?source=collection_archive---------0-----------------------#2022-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/04a1f94ee9392ec06db5d1119508e01d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*kpB-GqHZzrcjnJjkOUDqWQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><em class="jy">照片由</em> <a class="ae jz" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="jy">马库斯·斯皮斯克</em> </a> <em class="jy">上</em> <a class="ae jz" href="https://unsplash.com/s/photos/different-sizes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="jy">下</em> </a></figcaption></figure><p id="8700" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">我一直觉得Go的标准库非常容易阅读。标准库的一部分包括自包含的概念，不需要太多的背景知识就可以深入了解。当我读到Go的排序算法已经从<a class="ae jz" href="https://github.com/golang/go/commit/72e77a7f41bbf45d466119444307fd3ae996e257" rel="noopener ugc nofollow" target="_blank">变成了</a>一种叫做“pdqsort”的东西时，我想去看看并了解一下它会很好。</p><p id="25f8" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">在这篇文章中，我们将通过研究以前的排序算法和新的排序算法来做到这一点。</p><p id="666b" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">到目前为止，Go依靠其标准库中的<a class="ae jz" href="https://en.wikipedia.org/wiki/Quicksort" rel="noopener ugc nofollow" target="_blank"> Quicksort </a>。你已经可以在这里继续检查它的实现<a class="ae jz" href="https://github.com/golang/go/blob/release-branch.go1.18/src/sort/sort.go#L231" rel="noopener ugc nofollow" target="_blank">了</a>但是我还会提供相关的链接。</p><p id="1d53" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">快速排序算法的核心工作原理如下:</p><ol class=""><li id="aa90" class="ky kz iq kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">选择一个枢轴</li><li id="11b4" class="ky kz iq kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">将小于轴心的项目排列在轴心的“左侧”,将大于轴心的项目排列在“右侧”</li><li id="ccab" class="ky kz iq kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">对于透视的两侧，从#1开始递归地应用相同的逻辑</li></ol><p id="ef82" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">完成这些步骤后，我们应该最终得到一个经过排序的集合。这在许多数据集上运行良好，我们得到了一个很好的排序算法，平均复杂度为o(n logn)<em class="lm">⁴</em>。然而，在某些情况下，它不能很好地执行，并且最终具有二次复杂度。这意味着它的最坏情况性能为O(n ^ 2)⁵ )。Quicksort表现不佳的这些情况大多与已排序或几乎sorted⁶的数据集有关。</p><p id="a5a0" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">虽然我提到Go最初使用了Quicksort，但Go标准库使用了一些技巧来避免陷入Quicksort会产生最差性能或相当性能的情况。</p><p id="7300" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">阅读源代码，其中一些如下:</p><ul class=""><li id="a79c" class="ky kz iq kc b kd ke kh ki kl la kp lb kt lc kx ln le lf lg bi translated">如果集合大小为“use⁸小enough"⁷<a class="ae jz" href="https://en.wikipedia.org/wiki/Shellsort" rel="noopener ugc nofollow" target="_blank">shellsort</a></li><li id="1a9e" class="ky kz iq kc b kd lh kh li kl lj kp lk kt ll kx ln le lf lg bi translated">如果递归深度太大，切换to⁹ <a class="ae jz" href="https://en.wikipedia.org/wiki/Heapsort" rel="noopener ugc nofollow" target="_blank">堆排序</a></li><li id="8da4" class="ky kz iq kc b kd lh kh li kl lj kp lk kt ll kx ln le lf lg bi translated">试着选择一个好支点⁰</li></ul><p id="af8e" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">正如你可能已经注意到的，Go的快速排序实现并不是算法的简单形式，而是一种叫做<a class="ae jz" href="https://en.wikipedia.org/wiki/Introsort" rel="noopener ugc nofollow" target="_blank"> Introsort </a>的混合形式。</p><p id="1f7b" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">现在，我们来谈谈新的排序算法“pdq sort”——模式战胜快速排序。看名字，听起来还是Quicksort。对更改的描述概括了在某些最坏的情况下，它在哪些方面比以前的版本产生了更好的性能。</p><p id="2d3f" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">让我们从这里的<a class="ae jz" href="https://github.com/golang/go/blob/72e77a7f41bbf45d466119444307fd3ae996e257/src/sort/sort.go#L48" rel="noopener ugc nofollow" target="_blank">开始</a>，看看有什么变化&amp;留了下来。</p><p id="c288" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">当集合大小很小时，我们仍然使用到<a class="ae jz" href="https://en.wikipedia.org/wiki/Insertion_sort" rel="noopener ugc nofollow" target="_blank">插入排序</a>，在某些情况下<a class="ae jz" href="https://github.com/golang/go/blob/72e77a7f41bbf45d466119444307fd3ae996e257/src/sort/zsortinterface.go#L77-L81" rel="noopener ugc nofollow" target="_blank">退回到</a>堆排序。用于<a class="ae jz" href="https://github.com/golang/go/blob/72e77a7f41bbf45d466119444307fd3ae996e257/src/sort/zsortinterface.go#L256-L261" rel="noopener ugc nofollow" target="_blank">选择枢轴</a>的方法也类似于前面的实现。</p><p id="c73f" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">与前面的实现不同，pdqsort在遇到不同的模式时，试图通过移动事物来避免最坏的情况:</p><ul class=""><li id="b236" class="ky kz iq kc b kd ke kh ki kl la kp lb kt lc kx ln le lf lg bi translated">如果我们正在处理一个不能以平衡方式分区的分区⁴，我们将<a class="ae jz" href="https://github.com/golang/go/blob/72e77a7f41bbf45d466119444307fd3ae996e257/src/sort/zsortinterface.go#L238" rel="noopener ugc nofollow" target="_blank">移动</a>以避免将来出现这种不平衡的分区。此外，不是退回到纯粹基于递归深度的堆排序，而是使用不平衡分区的数量来切换到回退。</li><li id="d082" class="ky kz iq kc b kd lh kh li kl lj kp lk kt ll kx ln le lf lg bi translated"><a class="ae jz" href="https://github.com/golang/go/blob/72e77a7f41bbf45d466119444307fd3ae996e257/src/sort/zsortinterface.go#L99-L104" rel="noopener ugc nofollow" target="_blank">处理</a>集合中可能已经排序或反向排序的部分</li><li id="6c51" class="ky kz iq kc b kd lh kh li kl lj kp lk kt ll kx ln le lf lg bi translated"><a class="ae jz" href="https://github.com/golang/go/blob/72e77a7f41bbf45d466119444307fd3ae996e257/src/sort/zsortinterface.go#L108-L112" rel="noopener ugc nofollow" target="_blank">处理等于支点的</a>元素，以避免将来不必要的交换</li></ul><p id="7ea5" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">在介绍pdqsort算法的<a class="ae jz" href="https://arxiv.org/pdf/2106.05123.pdf" rel="noopener ugc nofollow" target="_blank">文章</a>中有更多的内容。这些是我通过阅读源代码和文章可以发现的主要区别。新算法的实现似乎有更多的活动部分，尽管代码是以一种易于理解的方式组织的。</p><p id="f891" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">这有助于我理解发生了什么变化。我希望这能很好地概述这一变化以及它试图解决的问题。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="c41d" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><em class="lm"> 1。截至Go 1.18，这仍未发布，预计将在未来版本中登陆</em></p><p id="e59d" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><em class="lm"> 2。Pivot是在给定集合中排列其他项目时要保留在原位的项目</em></p><p id="9b75" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><em class="lm"> 3。排序的概念可能因被排序的项目而异。这些可能是整数或更复杂的数据结构。</em></p><p id="1e68" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><em class="lm"> 4。时间复杂度</em>的解释见 <a class="ae jz" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank"> <em class="lm">本</em> </a> <em class="lm"/></p><p id="f74b" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><em class="lm"> 5。n平方的阶。</em></p><p id="601b" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">6。那可能包含许多重复的元素——参见“ <a class="ae jz" href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem" rel="noopener ugc nofollow" target="_blank"> <em class="lm">荷兰国旗问题</em></a><em class="lm"/></p><p id="5bd9" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">7。不到13 </p><p id="adc5" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><em class="lm"> 8。参见</em> <a class="ae jz" href="https://github.com/golang/go/blob/release-branch.go1.18/src/sort/sort.go#L215-L222" rel="noopener ugc nofollow" target="_blank"> <em class="lm">此处</em> </a>的相关代码</p><p id="1173" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><em class="lm"> 9。参见</em> <a class="ae jz" href="https://github.com/golang/go/blob/release-branch.go1.18/src/sort/sort.go#L234-L242" rel="noopener ugc nofollow" target="_blank"> <em class="lm">此处</em> </a> <em class="lm">中递归切换到Heapsort的深度是如何计算的</em></p><p id="ac79" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">10。见 <a class="ae jz" href="https://en.wikipedia.org/wiki/Quicksort#Choice_of_pivot" rel="noopener ugc nofollow" target="_blank"> <em class="lm">本</em> </a> <em class="lm">解释选择一个好支点的困难和不同的方法。这些大多也可以在Go的源代码中找到:</em> <a class="ae jz" href="https://github.com/golang/go/blob/release-branch.go1.18/src/sort/sort.go#L110" rel="noopener ugc nofollow" target="_blank"> <em class="lm">避免</em> </a> <em class="lm">整数溢出，</em> <a class="ae jz" href="https://github.com/golang/go/blob/release-branch.go1.18/src/sort/sort.go#L111-L118" rel="noopener ugc nofollow" target="_blank"> <em class="lm">挑选</em></a><em class="lm"/><a class="ae jz" href="https://en.wikipedia.org/wiki/Median#Ninther" rel="noopener ugc nofollow" target="_blank"><em class="lm">第九</em> </a> <em class="lm">"作为支点</em></p><p id="68be" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">11。参见相关文章 <a class="ae jz" href="https://arxiv.org/pdf/2106.05123.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="lm">此处</em> </a> <em class="lm">对算法更透彻的解释。</em></p><p id="d1ca" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><em class="lm"> 12。变化的作者</em> <a class="ae jz" href="https://github.com/golang/go/commit/72e77a7f41bbf45d466119444307fd3ae996e257" rel="noopener ugc nofollow" target="_blank"> <em class="lm">包括</em> </a> <em class="lm">一个比较，表明它比以前的排序切片算法快大约10倍，并且从来没有比以前的版本慢很多。</em></p><p id="f205" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><em class="lm"> 13。虽然之前的算法用的是</em><a class="ae jz" href="https://en.wikipedia.org/wiki/Shellsort" rel="noopener ugc nofollow" target="_blank"><em class="lm">Shellsort</em></a><em class="lm">，但都是非常相似的算法。</em></p><p id="8d0f" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><em class="lm"> 14。这是通过检查枢轴的任一侧(参见</em><a class="ae jz" href="https://github.com/golang/go/blob/72e77a7f41bbf45d466119444307fd3ae996e257/src/sort/zsortinterface.go#L120" rel="noopener ugc nofollow" target="_blank"><em class="lm">1</em></a>&amp;<a class="ae jz" href="https://github.com/golang/go/blob/72e77a7f41bbf45d466119444307fd3ae996e257/src/sort/zsortinterface.go#L124" rel="noopener ugc nofollow" target="_blank"><em class="lm">2</em></a><em class="lm">)来完成的，以查看我们最终是否有两个分区，其中一个是</em> <a class="ae jz" href="https://github.com/golang/go/blob/72e77a7f41bbf45d466119444307fd3ae996e257/src/sort/zsortinterface.go#L118" rel="noopener ugc nofollow" target="_blank"> <em class="lm">比另一个</em>小得多的 </a> <em class="lm"/></p></div></div>    
</body>
</html>