<html>
<head>
<title>JavaScript traits: the clean way to modify global prototypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript特征:修改全局原型的干净方法</h1>
<blockquote>原文：<a href="https://itnext.io/straits-9ef2b9a563cd?source=collection_archive---------1-----------------------#2018-12-17">https://itnext.io/straits-9ef2b9a563cd?source=collection_archive---------1-----------------------#2018-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/287cb891aa338477650cab9d251719b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHIXiHxBf_6xVpwcoiJIhQ.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="52ff" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">有了ES6，终于可以以一种干净的方式向Object.prototype、Array.prototype和所有其他对象添加方法了</h2></div><p id="de62" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">特征是大多数现代语言用来实现多态性而不依赖于继承的特性。</p><p id="998c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们将介绍它们，展示它们可以用JavaScript解决哪些问题，并建议一种实现它们的方法。希望你觉得有趣！</p><h1 id="ac9e" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">关于JavaScript和现代语言的几句话</h1><p id="cd8a" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">在过去的5年里，JavaScript一直是我的首选语言，尽管它有着臭名昭著的怪癖。</p><p id="840f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它写起来很快，运行起来很高效，但最重要的是，它是<em class="mk">现代</em>。这种语言本身以及它的生态系统使用了很棒的特性和解决方案，是我们所知道的最好的。</p><p id="4e01" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">JavaScript支持面向对象的编程，并使用鸭类型来实现多态性。这种方法比继承更加强大和灵活，但是它仍然有一些重大缺陷。</p><p id="c1e6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">实现OOP的一个更好、更现代的方法是使用traits。通过duck typing和原型继承在JavaScript中实现体面的特征曾经存在问题，但是自从该语言的最新版本(ECMAScript 6)添加了新的原始数据类型(<code class="fe ml mm mn mo b">symbol</code>)以来，情况有所改善。</p><p id="a4e5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是很少有人使用这种令人兴奋的语言特性，这也是这篇文章的动机所在。</p><h1 id="d41d" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">什么是特质？</h1><p id="3c09" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated"><a class="ae mj" href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29" rel="noopener ugc nofollow" target="_blank"> Traits </a>是一种向现有类型添加语义的方式，不会有无意干扰现有代码的风险。</p><p id="d28d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">特征是继承的替代方法，作为实现多态性的方法，所有现代语言都有特征:想想go、haskell和rust，仅举几个例子。</p><p id="fbfd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">JavaScript是一种<a class="ae mj" href="https://en.wikipedia.org/wiki/Prototype-based_programming" rel="noopener ugc nofollow" target="_blank">原型</a>、<a class="ae mj" href="https://en.wikipedia.org/wiki/Duck_typing" rel="noopener ugc nofollow" target="_blank">鸭型</a>语言，这使得程序员可以通过向现有原型添加新属性来做一些非常类似的事情。但是这种简单添加有很大的问题，应该避免。事实上<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#Bad_practice_Extension_of_native_prototypes" rel="noopener ugc nofollow" target="_blank">你永远不应该修改你不拥有的类型的原型</a>，这就是为什么大多数库在没有实际修改那些类型的情况下，尽力为现有类型提供新的功能。</p><p id="852d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">JavaScript的最新版本(即ECMAScript 6)增加了一种新的原语数据类型<code class="fe ml mm mn mo b"><a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Glossary/symbol" rel="noopener ugc nofollow" target="_blank">symbol</a></code>，可以用来有效地实现traits。一个<code class="fe ml mm mn mo b">symbol</code>基本上是一个惟一的标识符，可以作为一个属性使用，并且永远不会与其他任何东西冲突。在ECMAScript 6中，他们需要一种方法来扩展标准类型，而不破坏与现有代码的兼容性。这就是他们引入<code class="fe ml mm mn mo b">symbol</code>的原因，他们确实用它来实现特征。然而，他们没有宣传这一新功能，也没有让traits成为一等公民，而是让<code class="fe ml mm mn mo b">symbol</code>留在暗处。标准将这个特性称为<em class="mk">协议</em>，而不是<em class="mk">特征</em>，其中一个例子是<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank">迭代协议</a>。</p><p id="97b8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">除了缺乏指导方针和好的例子，另一个问题使得很难使用<code class="fe ml mm mn mo b">symbol</code> s作为特征:缺乏好的语法来这样做。</p><p id="a76c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是说够了！让我们看一个例子。</p><h1 id="c284" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">为什么我们需要特质？一个例子</h1><p id="be63" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">假设您需要一个序列化程序来将数据转换成可以存储在某个地方的字符串。</p><p id="b175" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe ml mm mn mo b">JSON.stringify()</code>不够好，因为它不支持“复杂”的对象(尝试字符串化一个圆形对象、<code class="fe ml mm mn mo b">RegExp</code>、<code class="fe ml mm mn mo b">Map</code>等，你会看到)。</p><p id="3f58" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">那么，让我们写自己的序列化函数吧。我们希望支持<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">原始数据类型</a> ( <code class="fe ml mm mn mo b">boolean</code>、<code class="fe ml mm mn mo b">number</code>、<code class="fe ml mm mn mo b">string</code>等)、<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" rel="noopener ugc nofollow" target="_blank">内置类型</a> ( <code class="fe ml mm mn mo b">Array</code>、<code class="fe ml mm mn mo b">Map</code>、<code class="fe ml mm mn mo b">RegExp</code>等)，以及我们或其他人定义的类。有些东西可能无法序列化，比如<code class="fe ml mm mn mo b">Function</code> s或<code class="fe ml mm mn mo b">Promise</code> s，这没关系:如果我们要序列化其中一个，我们会抛出一个错误。</p><p id="24a7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们试图做的是，给大多数类型添加一个新的序列化逻辑，不管它们是由我们定义的，由其他人定义的，还是内置在语言中的。这种逻辑需要为每种类型定制。</p><p id="c683" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以通过给每样东西添加一个新的<code class="fe ml mm mn mo b">serialize</code>方法来实现这一点。这样<code class="fe ml mm mn mo b">var.serialize()</code>将为任何变量<code class="fe ml mm mn mo b">var</code>返回一个可序列化的表示。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9e5d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们试一试…</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="74fa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它打印出<code class="fe ml mm mn mo b">Person("peoro", 32){objects:[{"a": true,"re": /^...$/g}]}</code>，这正是我们想要的。</p><p id="8702" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">太神奇了！不是吗？</p><p id="166d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不完全是。</p><p id="5b35" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们修改了我们没有所有权的现有类型。那叫<a class="ae mj" href="https://en.wikipedia.org/wiki/Monkey_patch" rel="noopener ugc nofollow" target="_blank">猴子打补丁</a>。它似乎可以工作，但是一旦有人试图在实际应用程序中使用我们的序列化程序，就会产生许多严重的问题。让我们来看几个:</p><ul class=""><li id="f38c" class="mv mw jb ks b kt ku kw kx kz mx ld my lh mz ll na nb nc nd bi translated">尝试序列化对象<code class="fe ml mm mn mo b">{serialize:true}</code>:您会得到一个错误，因为这样的对象的<code class="fe ml mm mn mo b">serialize</code>属性覆盖了<code class="fe ml mm mn mo b">Object.prototype.serialize</code>。</li><li id="735b" class="mv mw jb ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">其他人可能会定义不同的<code class="fe ml mm mn mo b">serialize</code>方法来序列化不同格式的对象。我们的序列化程序和他们的不兼容；如果两者都被加载到同一个项目中(即使是作为一个间接依赖)，事情会以意想不到的方式发生。</li><li id="d033" class="mv mw jb ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">尝试在普通对象上使用<code class="fe ml mm mn mo b">for...in</code>进行迭代:您也将迭代<code class="fe ml mm mn mo b">Object.prototype</code>的<code class="fe ml mm mn mo b">serialize</code>属性。这将打破现有的大部分代码。</li></ul><p id="e282" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">monkey patching的问题是我们正在修改全局数据:任何不是我们编写的函数都可能依赖于对我们可能已经破坏的现有对象的假设，</p><p id="16f6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是为什么库(包括可能强加自己标准的大型库——比如jQuery或lodash)不会修改内置类型的原因。他们宁愿公开自由函数(比如lodash)，或者封装现有对象的包装器，并且只向它们的包装器添加新方法(比如jQuery)。</p><p id="97a4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">值得注意的是，这些库选择的解决方案非常有限:很难对包装器和自由函数的行为进行专门化。当你写它们的时候，你可能会硬编码一个<code class="fe ml mm mn mo b">if</code>的瀑布来支持一堆类型，但是以后它就不能被扩展了。您将无法使它们的函数与您的自定义类型一起工作。</p><p id="9d25" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">作为一个练习，尝试定义一个<code class="fe ml mm mn mo b">serialize</code>函数，它能够在不修改现有对象及其原型的情况下序列化几种类型。然后尝试让库的用户能够添加对他们自己类型的支持，或者添加到现有的第三方对象。你可能考虑的大多数解决方案(例如使用<code class="fe ml mm mn mo b">Type → serializationFunction</code>地图)可能会导致进一步的意想不到的问题。</p><p id="d708" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是我们需要帮助的地方。欢迎来到特质的世界。</p><h1 id="5fbd" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">如何在JavaScript中实现特征</h1><p id="bd55" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">一个<code class="fe ml mm mn mo b">symbol</code>是ES6中引入的原始类型，可以用作对象的键，它保证永远不会与其他任何东西冲突:如果<code class="fe ml mm mn mo b">sym</code>是一个<code class="fe ml mm mn mo b">symbol</code>，访问<code class="fe ml mm mn mo b">object[sym]</code>的唯一方法就是使用<code class="fe ml mm mn mo b">sym</code>本身。另外，<code class="fe ml mm mn mo b">for...in</code>循环不会迭代<code class="fe ml mm mn mo b">symbol</code> s。</p><p id="cd29" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以这种方式工作并不是巧合:它们被添加到标准中的原因和我们需要它们的原因完全一样。ECMAScript 6想要给现有类型添加新的功能，但是，正如我们所看到的，如果不冒破坏现有代码的风险，这是不可能的。</p><p id="f50f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">关于标准如何使用它们的例子，请看<a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank">可迭代协议</a>。引入了一个新符号<code class="fe ml mm mn mo b">Symbol.iterator</code>。实现它的类型可以使用<code class="fe ml mm mn mo b"><a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noopener ugc nofollow" target="_blank">for...of</a></code> <a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noopener ugc nofollow" target="_blank">语法</a>进行迭代。此类符号在<code class="fe ml mm mn mo b">Array</code>、<code class="fe ml mm mn mo b">TypedArray</code>、<code class="fe ml mm mn mo b">String</code>、<code class="fe ml mm mn mo b">Map</code>、<code class="fe ml mm mn mo b">Set</code>上实现，您也可以在自己的类型上实现。</p><p id="eda1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们的序列化程序应该实例化一个<code class="fe ml mm mn mo b">serialize</code>符号，使用它，并公开给每个人使用:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="be8d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们的用户可以在他们的类型上实现相同的<code class="fe ml mm mn mo b">serialize</code>符号并使用它。其他现有的代码都不会受到影响。</p><p id="bffd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然而，这并不是最终答案...它们非常强大，被标准用来实现特征，但是涉及它们的文档数量很少。几乎没有指南，很少有教程或文章解释它们是什么以及如何使用它们。结果是很少有模块在使用它们。</p><p id="92b0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">另一个问题与它们的语法有关:没有特殊的语法来使用它们，在某些情况下，这成为一种痛苦。</p><p id="f914" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">想象一个<a class="ae mj" href="https://www.npmjs.com/package/lodash-traits" rel="noopener ugc nofollow" target="_blank"> lodash-traits </a>库，它为每个lodash函数提供并实现了一个<code class="fe ml mm mn mo b">symbol</code>。</p><p id="3e4d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你不能只做:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ef49" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你必须做…</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e307" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这很快就会变得不舒服。</p><p id="1889" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是为什么，除了特征，我们提出了一个新的语法，旨在帮助特征的发展。</p><h1 id="6c84" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">特征的更好语法</h1><p id="be6e" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">我们提出了一个语言扩展，海峡语法，能够以如下方式编写前面的代码片段:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="be1c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是什么意思？</p><p id="d7a3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe ml mm mn mo b">use traits * from traitSet;</code>意味着我们将寻找物体内部的符号<code class="fe ml mm mn mo b">traitSet</code>。我们称<code class="fe ml mm mn mo b">traitSet</code>为<em class="mk">特征集</em>。<code class="fe ml mm mn mo b">object.*key</code>意味着我们正在使用特征集中的符号<code class="fe ml mm mn mo b">key</code>访问<code class="fe ml mm mn mo b">object</code>。</p><p id="d06d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">实际上:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="232e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">大致相当于:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="596f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们将按照以下方式编写模块的序列化部分:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9b40" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这种语法与ECMAScript 6:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0e82" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">可以同时使用多个特征集中的特征，如果某个特征被复制或丢失，我们会收到一个错误。</p><p id="2829" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该语法旨在…</p><ul class=""><li id="8cf2" class="mv mw jb ks b kt ku kw kx kz mx ld my lh mz ll na nb nc nd bi translated">将<code class="fe ml mm mn mo b">symbol</code>变成JavaScript的一等公民。</li><li id="d4fc" class="mv mw jb ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">使特征更容易声明和使用。</li><li id="e05e" class="mv mw jb ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated">避免范围和特征变量之间的冲突和错误。</li></ul><p id="b4f8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">目前可以使用这种语法开发代码，并使用一个babel插件将其转换成标准的JavaScript:<a class="ae mj" href="https://www.npmjs.com/package/@straits/babel" rel="noopener ugc nofollow" target="_blank">@ straits/babel</a>。</p><h1 id="4801" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">文章结论和海峡介绍</h1><p id="d0a5" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">希望现在清楚了为什么需要特征，如何使用<code class="fe ml mm mn mo b">symbol</code> s、原型遗传和鸭子分型来创建它们，以及如何舒适地使用它们。</p><p id="570f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">straits项目提供了许多公共函数来帮助声明和使用特征、特性和特性集。</p><p id="1865" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您想尝试一下，只需在一个空目录中运行<code class="fe ml mm mn mo b">npm init @straits</code>:它将建立一个准备使用新语法的项目。然后运行<code class="fe ml mm mn mo b">npm install</code>，一切都准备好了:<code class="fe ml mm mn mo b">npm start</code>将运行<code class="fe ml mm mn mo b">src/index.js</code>，一个可以玩的hello-world。</p><p id="db34" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你喜欢特征，你应该在你的项目中使用<a class="ae mj" href="https://straits.github.io/syntax/" rel="noopener ugc nofollow" target="_blank">海峡语法</a>。这对你的用户来说是完全透明的，因为你将在npm上发布的代码是透明的:标准的、常规的JavaScript。你的模块的用户可以自由选择是否也使用这个语法，或者手动使用<code class="fe ml mm mn mo b">symbol</code> s，甚至通过自由函数。查看一下<a class="ae mj" href="https://github.com/peoro/lodash-traits/blob/master/test/index.js" rel="noopener ugc nofollow" target="_blank"> lodash-traits' </a> <code class="fe ml mm mn mo b"><a class="ae mj" href="https://github.com/peoro/lodash-traits/blob/master/test/index.js" rel="noopener ugc nofollow" target="_blank">test/index.js</a></code>，看看使用traits的模块如何在使用或不使用straits语法的情况下使用。</p><p id="d225" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您想了解一些依赖于traits的项目，请查看:</p><ul class=""><li id="282c" class="mv mw jb ks b kt ku kw kx kz mx ld my lh mz ll na nb nc nd bi translated"><a class="ae mj" href="https://www.npmjs.com/package/lodash-traits" rel="noopener ugc nofollow" target="_blank"> lodash-traits </a>:包装<a class="ae mj" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>功能的特性集。</li><li id="7940" class="mv mw jb ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated"><a class="ae mj" href="https://www.npmjs.com/package/chalk-traits" rel="noopener ugc nofollow" target="_blank">粉笔-特性</a>:特性集包装<a class="ae mj" href="https://www.npmjs.com/package/chalk" rel="noopener ugc nofollow" target="_blank">粉笔</a>功能。</li><li id="f91a" class="mv mw jb ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated"><a class="ae mj" href="https://www.npmjs.com/package/scontainers" rel="noopener ugc nofollow" target="_blank">容器</a>:一个强大的、高性能的库(尽管仍在alpha中),用于处理数据集合。</li><li id="b46b" class="mv mw jb ks b kt ne kw nf kz ng ld nh lh ni ll na nb nc nd bi translated"><a class="ae mj" href="https://www.npmjs.com/package/esast" rel="noopener ugc nofollow" target="_blank"> ESAST </a>:一个以舒适的方式操作JavaScript AST的库(即没有包装对象)。</li></ul></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="ddea" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="mk">原载于</em><a class="ae mj" href="https://straits.github.io/" rel="noopener ugc nofollow" target="_blank"><em class="mk">straits . github . io</em></a><em class="mk">。</em></p></div></div>    
</body>
</html>