<html>
<head>
<title>A better way to organize redux state</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组织redux状态的更好方法</h1>
<blockquote>原文：<a href="https://itnext.io/a-better-way-to-organize-redux-state-6a62dd79b2df?source=collection_archive---------1-----------------------#2019-09-03">https://itnext.io/a-better-way-to-organize-redux-state-6a62dd79b2df?source=collection_archive---------1-----------------------#2019-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e0ef7242f4e43d4bc7d4be7ee5fd5975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUoKZUR4_m-YsztGcm-q0Q.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@parktroopers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">公园巡警</a>在<a class="ae kf" href="https://unsplash.com/search/photos/future-structure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="a661" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为Holloway<a class="ae kf" href="https://www.holloway.com" rel="noopener ugc nofollow" target="_blank">的一名技术主管，我从理论的角度思考了很多关于软件的问题，有时它可能是纯粹的哲学或核心代数。在软件工程面试中，数学问题经常被用来测试分析能力。但不仅仅是在面试中，你需要进行数学思考。我发现在写一行代码之前花几天时间思考和分析一个问题是更明智的做法。</a></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="60b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几年前，在Stripe的一次工程职位面试中，我收到了一个关于构建一个在超时后删除值(或使它们不可访问)的数据存储的问题。这是一个美丽的谜题，因为它可以通过许多方法来解决，大多数方法都可行，但只有少数方法是好的。</p><p id="3cc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个难题在我的记忆中找到了一个位置，在我不时回来反思的事情之间。</p><p id="2895" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">突然，我意识到能够为键值存储中的记录设置生存期(或者根本不删除它们)，改变了我们组织和处理redux store state之类的东西的方式。例如，我们可以忘记在存储状态下覆盖记录。</p><p id="d3a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从事数据库工作的人可能不会理解我的兴奋。DB里没有<code class="fe ll lm ln lo b">overwrite</code>这种东西。你可以<code class="fe ll lm ln lo b">write</code>、<code class="fe ll lm ln lo b">update</code>或<code class="fe ll lm ln lo b">delete</code>一次记录。但是redux状态有点不同。</p><p id="9e6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先是客户端，客户端的app都是有状态的，所以你需要有一个状态来描述要渲染哪些数据和实际要渲染的数据。当你需要为你的应用程序保存这样的数据时，Redux非常方便。</p><p id="7856" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些随机的todo应用程序可能有这样的存储状态:</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="48d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很明显，我们需要把所有的东西都放进一个商店里，来描述app目前可以渲染什么。并在需要时获取新数据，例如解析路由状态，或者加载数据以在弹出窗口中显示任务细节。</p><p id="d119" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果需要在用户单击链接之前加载数据，或者如果我们需要缓存一段时间的数据，并减少在数据刚刚加载时的重新获取，该怎么办呢？</p><p id="2c53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一个使用示例中状态的应用程序需要在后台获取额外的任务，它将导致立即呈现这些任务。这可能不是我们想要的行为。</p><h2 id="a48c" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">分离数据和状态</h2><p id="5adf" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我发现的关于redux状态的困惑是，它经常被用来在同一个地方同时存储数据记录和app的状态。如果我们想在redux中添加一条未来需求的记录，这意味着我们也要更新应用程序的状态。</p><p id="b160" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得缓存或预取在没有黑客攻击的情况下几乎不可能。</p><p id="3da2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最理想的解决方案可能是将数据和状态完全分离，并将数据记录存储在indexedDB中的某个地方，并实现类似于<code class="fe ll lm ln lo b">indexedDBConnect</code>的东西来向React组件提供数据。或者发明其他方法。但这是一个更深入的话题<em class="mt">(顺便说一下，这里有一篇关于indexedDB的好文章:</em> <a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/indexeddb-your-second-step-towards-progressive-web-apps-pwa-dcbcd6cc2076"> <em class="mt">如何使用IndexedDB构建渐进式Web应用</em> </a> <em class="mt"> ) </em>，在这篇文章中，我想谈谈如何组织<code class="fe ll lm ln lo b">redux</code> store以更好的方式存储状态和数据。</p><p id="ede7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要将数据记录与应用程序的状态分开。虽然听起来很简单，但需要一些时间来吸收。我试着用一个例子来解释。</p><p id="a410" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看todo应用程序的状态，看看什么是状态，什么是记录。</p><ol class=""><li id="0cd5" class="mu mv it ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated"><em class="mt">路线状态:</em></li></ol><pre class="lp lq lr ls gt nd lo ne nf aw ng bi"><span id="aede" class="lv lw it lo b gy nh ni l nj nk">route: { url: '/' }</span></pre><p id="b5cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ll lm ln lo b">route</code>是一个州，没有记载。它说明了当前的URL是什么，仅此而已。</p><p id="8702" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.<em class="mt">用户状态:</em></p><pre class="lp lq lr ls gt nd lo ne nf aw ng bi"><span id="0fff" class="lv lw it lo b gy nh ni l nj nk">user: { id: "user-1", name: "Peter", },</span></pre><p id="e757" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ll lm ln lo b">user</code>更有趣一点。它声明谁是当前用户以及用户模型有哪些字段。所以这里的状态是<code class="fe ll lm ln lo b">currentUser</code>，记录是<code class="fe ll lm ln lo b">user</code>对象。</p><p id="238c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分离的状态和记录如下所示:</p><pre class="lp lq lr ls gt nd lo ne nf aw ng bi"><span id="9140" class="lv lw it lo b gy nh ni l nj nk">users: { <br/>  current: "user-1", <br/>  "user-1": { id: "user-1", name: "Peter" },<br/>}</span></pre><p id="3697" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.<em class="mt">任务</em>:</p><pre class="lp lq lr ls gt nd lo ne nf aw ng bi"><span id="6f4f" class="lv lw it lo b gy nh ni l nj nk">tasks: {    <br/>  list: [      <br/>    {        <br/>      id: "task-1", <br/>      title: "finish to-do app with a new framework",        <br/>      state: "in-progress",      <br/>     }, {        <br/>      id: "task-2",        <br/>      title: "write on medium about it",        <br/>      state: "not-started",      <br/>     },    <br/>   ],  <br/>}</span></pre><p id="b14c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的状态是任务id和任务顺序:</p><pre class="lp lq lr ls gt nd lo ne nf aw ng bi"><span id="b39b" class="lv lw it lo b gy nh ni l nj nk">tasks: { <br/>  currentTasks: [<br/>    "task-1",<br/>    "task-2"<br/>  ],<br/>  <br/>  "task-1": {        <br/>    id: "task-1", <br/>    title: "finish to-do app with a new framework",        <br/>    state: "in-progress",      <br/>  }, <br/>  "task-2": {        <br/>    id: "task-2",        <br/>    title: "write on medium about it",        <br/>    state: "not-started",      <br/>  },<br/>}</span></pre><p id="cbff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以及重组后的整个redux状态:</p><pre class="lp lq lr ls gt nd lo ne nf aw ng bi"><span id="63cc" class="lv lw it lo b gy nh ni l nj nk">{<br/>  route: { url: '/' },</span><span id="4739" class="lv lw it lo b gy nl ni l nj nk">  users: { <br/>    current: "user-1", <br/>    "user-1": { id: "user-1", name: "Peter" },<br/>  },</span><span id="6c17" class="lv lw it lo b gy nl ni l nj nk">  tasks: { <br/>    currentTasks: [<br/>      "task-1",<br/>      "task-2"<br/>    ],<br/>  <br/>    "task-1": {        <br/>      id: "task-1", <br/>      title: "finish to-do app with a new framework",        <br/>      state: "in-progress",      <br/>    }, <br/>    "task-2": {        <br/>      id: "task-2",        <br/>      title: "write on medium about it",        <br/>      state: "not-started",      <br/>    },<br/>  },<br/>}</span></pre><p id="465e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">状态和数据记录是分开的。我们可以根据需要预取尽可能多的任务记录，或者在不删除任务记录的情况下呈现任务的子集。我们不必担心redux中的数据过多，我们可以在超时之后删除值。取决于你从故事开始就解决谜题的方式。</p><h2 id="5116" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">结论</h2><p id="d600" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这在理论上看起来不错，实际上，在实践中也是如此。霍洛韦阅读器应用程序的redux store就是这样组织的。它允许为popovers特性同时渲染多条路线，或者在渲染指南之前预取大量JSON对象，而不用担心混乱的存储状态和许多其他事情，包括性能优化，但这是未来故事的主题。</p></div></div>    
</body>
</html>