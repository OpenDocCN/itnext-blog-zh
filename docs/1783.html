<html>
<head>
<title>Delegating Work Using NodeJS and AMQP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NodeJS和AMQP委派工作</h1>
<blockquote>原文：<a href="https://itnext.io/delegating-work-using-nodejs-and-amqp-4d3cc1f62824?source=collection_archive---------3-----------------------#2019-01-28">https://itnext.io/delegating-work-using-nodejs-and-amqp-4d3cc1f62824?source=collection_archive---------3-----------------------#2019-01-28</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><figure class="iq ir gq gs is it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj ip"><img src="../Images/2219592b8ce13dfdb1f1b78ff008bb9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUmEqPV9tnNo-hKwzwG3Yg.jpeg"/></div></div><figcaption class="ja jb gk gi gj jc jd bd b be z dk translated">“海洋是最初的互联网；它连接万物。”— <em class="je">伦佐·皮亚诺</em></figcaption></figure><div class=""/><p id="b158" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">过去的这个周末，我去果阿放松一下，把我的注意力从工作上移开，吃点美食，呼吸新鲜空气，在海滩边放松一下。当我开始考虑消息队列和简单的任务委托时，我还不到一天，所以我决定写一个小的库，我称之为<code class="fe lc ld le lf b">amp-delegate</code>，它简化了<code class="fe lc ld le lf b">AMQP</code>远程工作者的创建和使用。</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="d692" class="lo lp jh lf b gz lq lr l ls lt">npm install amqp-delegate</span></pre><h2 id="136d" class="lo lp jh bd lu lv lw dn lx ly lz dp ma kp mb mc md kt me mf mg kx mh mi mj mk bi translated">一个例子:</h2><p id="2118" class="pw-post-body-paragraph ke kf jh kg b kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb ik bi translated"><code class="fe lc ld le lf b">worker.js</code></p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="40d8" class="lo lp jh lf b gz lq lr l ls lt">const { makeWorker } = require('amqp-delegate')</span><span id="30dc" class="lo lp jh lf b gz mq lr l ls lt">// waits for 10ms then adds two numbers.<br/>const task = (a, b) =&gt;<br/>  new Promise(resolve =&gt;<br/>    setTimeout(() =&gt;<br/>      resolve(a + b), 10))</span><span id="6e9d" class="lo lp jh lf b gz mq lr l ls lt">const worker = makeWorker({<br/>  name: 'adder',<br/>  task<br/>})</span><span id="3714" class="lo lp jh lf b gz mq lr l ls lt">worker.start()</span></pre><p id="9f67" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe lc ld le lf b">delegate.js</code></p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="9828" class="lo lp jh lf b gz lq lr l ls lt">const { makeDelegate } = require('amqp-delegate')</span><span id="c680" class="lo lp jh lf b gz mq lr l ls lt">const delegator = makeDelegator()</span><span id="8e9a" class="lo lp jh lf b gz mq lr l ls lt">delegator<br/>  .start()<br/>  .then(() =&gt; delegator.invoke('adder', 10, 15))<br/>  .then(result =&gt; {<br/>    console.log('result', result)<br/>  })<br/>  .catch(err =&gt; {<br/>    console.error('caught', err)<br/>  })</span></pre><figure class="lg lh li lj gu it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj mr"><img src="../Images/f4c84a99f12b7915c8b9a375a64434d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzWOM3VCAlypH0KtZ2JPEQ.png"/></div></div></figure><p id="b855" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">您可以运行任意多的workers，因为它们都是异步的，所以它们可以做抓取网页、与数据库交互或任何您喜欢的事情。第一个被点名的工人将接手这项工作。</p><h1 id="6f0e" class="ms lp jh bd lu mt mu mv lx mw mx my ma mz na nb md nc nd ne mg nf ng nh mj ni bi translated">它是如何工作的？</h1><p id="49a0" class="pw-post-body-paragraph ke kf jh kg b kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb ik bi translated">这只是标准远程过程调用模式的一个简单实现，但是消息队列交互的细节被包装在一个简单的高级接口中，因此您不必看到或理解它们。</p><h2 id="3b0d" class="lo lp jh bd lu lv lw dn lx ly lz dp ma kp mb mc md kt me mf mg kx mh mi mj mk bi translated">工人</h2><p id="d561" class="pw-post-body-paragraph ke kf jh kg b kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb ik bi translated">当你第一次制造一个工人时，你给它一个<code class="fe lc ld le lf b">name</code>和一个<code class="fe lc ld le lf b">task</code>来执行。<code class="fe lc ld le lf b">name</code>可以是任何字符串，<code class="fe lc ld le lf b">task</code>可以是任何接受简单参数并返回简单结果的纯异步函数。简单的意思是可以被整理成一个<code class="fe lc ld le lf b">JSON</code>字符串并转换成一个缓冲区的参数，缓冲区是<code class="fe lc ld le lf b">AMQP</code>的首选消息内容格式。</p><p id="49a7" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">当您启动一个worker时，它连接到您的<code class="fe lc ld le lf b">AMQP</code>服务器，然后开始监听与worker具有相同<code class="fe lc ld le lf b">name</code>的队列。当它听到该队列上的消息时，它获取该消息，与其他具有相同<code class="fe lc ld le lf b">name</code>的工作线程竞争，将消息内容解码为一个参数数组，并将这些参数传递给工作线程的<code class="fe lc ld le lf b">task</code>。</p><p id="8d65" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">当<code class="fe lc ld le lf b">task</code>完成时，它将结果编组到<code class="fe lc ld le lf b">JSON</code>，将其转换为缓冲区，并使用传入请求的<code class="fe lc ld le lf b">replyTo</code>队列将其发送回调用者，并提供传入请求的<code class="fe lc ld le lf b">correlationId</code>。这样，委托者就知道这个消息是对其请求的回复，而不是同一队列中的其他随机消息。</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="b7bf" class="lo lp jh lf b gz lq lr l ls lt">* makeWorker({ url, name, task, onError, onClose }) // =&gt; worker<br/>* async worker.start()<br/>* async worker.stop()</span></pre><h2 id="a402" class="lo lp jh bd lu lv lw dn lx ly lz dp ma kp mb mc md kt me mf mg kx mh mi mj mk bi translated">委托人</h2><p id="f68f" class="pw-post-body-paragraph ke kf jh kg b kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb ik bi translated">当你开始委托时，你不需要告诉它任何事情。它只是连接到<code class="fe lc ld le lf b">AMQP</code>服务器，等待您通过名称调用远程工作人员。当您调用<code class="fe lc ld le lf b">delegator.invoke</code>时，您给它您想要调用的工人的<code class="fe lc ld le lf b">name</code>，以及您想要工人在执行其<code class="fe lc ld le lf b">task</code>时使用的<code class="fe lc ld le lf b">params</code>。然后你就<code class="fe lc ld le lf b">await</code>结果。</p><p id="774d" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">委托者将参数编组到<code class="fe lc ld le lf b">JSON</code>中，然后编组到一个缓冲区中，创建一个惟一的<code class="fe lc ld le lf b">correlationId</code>，并开始监听队列的<code class="fe lc ld le lf b">replyTo</code>队列中带有右<code class="fe lc ld le lf b">correlationId</code>的消息。</p><pre class="lg lh li lj gu lk lf ll lm aw ln bi"><span id="3f71" class="lo lp jh lf b gz lq lr l ls lt">* makeDelegator({ url, onError, onClose }) // =&gt; delegator<br/>* async delegator.start()<br/>* async delegator.invoke(name, ...params) // =&gt; result<br/>* async delegator.stop()</span></pre><h2 id="156d" class="lo lp jh bd lu lv lw dn lx ly lz dp ma kp mb mc md kt me mf mg kx mh mi mj mk bi translated">错误处理</h2><p id="876d" class="pw-post-body-paragraph ke kf jh kg b kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb ik bi translated">工作者和委托者都可以被提供<code class="fe lc ld le lf b">onClose</code>和<code class="fe lc ld le lf b">onError</code>钩子，您的代码可以使用它们来优雅地处理错误情况。除此之外，你可以在你的<code class="fe lc ld le lf b">awaits</code>周围使用标准的<code class="fe lc ld le lf b">try</code> / <code class="fe lc ld le lf b">catch</code>包装器，或者，如果你正在使用<code class="fe lc ld le lf b">promises</code>，使用标准的<code class="fe lc ld le lf b">catch</code>处理程序。</p><h1 id="a91c" class="ms lp jh bd lu mt mu mv lx mw mx my ma mz na nb md nc nd ne mg nf ng nh mj ni bi translated">链接</h1><ul class=""><li id="da5c" class="nj nk jh kg b kh ml kl mm kp nl kt nm kx nn lb no np nq nr bi translated">参见<code class="fe lc ld le lf b"><a class="ae ns" href="https://github.com/davesag/amqp-delegate" rel="noopener ugc nofollow" target="_blank">github.com/davesag/amqp-delegate</a></code>处的回购。</li><li id="2a0b" class="nj nk jh kg b kh nt kl nu kp nv kt nw kx nx lb no np nq nr bi translated">官方<a class="ae ns" href="https://www.rabbitmq.com/tutorials/tutorial-six-javascript.html" rel="noopener ugc nofollow" target="_blank"> RabbitMQ RPC教程</a>。</li></ul><p id="82f5" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi">—</p><p id="f5f2" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">像这样但不是订户？你可以通过<a class="ae ns" href="https://davesag.medium.com/membership" rel="noopener">davesag.medium.com</a>加入来支持作者。</p></div></div>    
</body>
</html>