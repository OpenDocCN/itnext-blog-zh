<html>
<head>
<title>Great import schism: Typescript confusion around imports explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大进口分裂:解释围绕进口的打字稿混乱</h1>
<blockquote>原文：<a href="https://itnext.io/great-import-schism-typescript-confusion-around-imports-explained-d512fc6769c2?source=collection_archive---------0-----------------------#2018-11-13">https://itnext.io/great-import-schism-typescript-confusion-around-imports-explained-d512fc6769c2?source=collection_archive---------0-----------------------#2018-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/201b9610d7ba7384e40feac2b3f5bdc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x142AxXjq1mO_PzHBgvhzg.png"/></div></div></figure><p id="a787" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用typescript已经有一段时间了，在理解它的模块和相应的设置方面有相当多的问题，我不得不说围绕它有很多困惑。命名空间，<code class="fe kw kx ky kz b">import * as React from 'react'</code>，<code class="fe kw kx ky kz b">esModuleInterop</code>等等。所以让我试着解释一下这到底是怎么回事。</p><p id="da69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不会把名称空间作为typescript中的一个模块系统来讨论，因为这个想法并不太好(至少考虑到当前的发展方向)，而且目前没有人使用它们。<br/> <br/>那么，在 <code class="fe kw kx ky kz b">esModuleInterop</code>之前我们有什么<em class="la">选项呢？我们有几乎与babel或browsers相同的模块，特别是考虑到命名的导入/导出。但是关于默认的导出和导入，typescript有它自己的处理方式，我们不得不写<code class="fe kw kx ky kz b">import * as React from 'react'</code>(而不是<code class="fe kw kx ky kz b">import React from 'react'</code>)，当然，我不只是在说react，而是关于所有来自commonjs库的默认导入，为什么呢？</em></p><p id="bcf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，让我们看看commonjs和es6模块中的一些模式之间的互操作性是如何工作的。例如，我们有一个模块将<code class="fe kw kx ky kz b">foo</code>和<code class="fe kw kx ky kz b">bar</code>导出为键控对象:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="700c" class="lj lk iq kz b gy ll lm l ln lo">module.exports = { foo, bar }</span></pre><p id="cabb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用require和destructuring来导入它:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="66fb" class="lj lk iq kz b gy ll lm l ln lo">const { foo, bar } = require('my-module')</span></pre><p id="e83c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并使用命名导入应用相同的原则(尽管公平地说它不是析构的):</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="18d6" class="lj lk iq kz b gy ll lm l ln lo">import { foo, bar } from 'my-module'</span></pre><p id="fae9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在commonjs代码中更常见的模式是<code class="fe kw kx ky kz b">const myModule = require('my-module')</code>(因为我们还没有析构)那么在es6中我们如何做呢？</p><p id="502b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当开发es6导入的规范时，一个重要的问题是与commonjs的互操作性，因为commonjs中已经有很多代码了。这就是违约进出口的由来。是的。他们唯一的目的是用commonjs提供一个互操作，所以我们可以写<code class="fe kw kx ky kz b">import myModule from 'my-module'</code>并得到同样的东西。但是从规范中并不清楚，另外，互操作的实现是transpiler开发者的特权。于是这里发生了大分裂:<code class="fe kw kx ky kz b">import React from 'react'</code> vs <code class="fe kw kx ky kz b">import * as React from 'react'</code>。<br/><br/>typescript为什么挑了后者？想象自己是一名transpiler开发人员，问自己，<em class="la">将es6导入文件转换到commonjs的最简单方法是什么？</em>。假设我们有以下一组导出和导入:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="92f9" class="lj lk iq kz b gy ll lm l ln lo">export const foo = 1<br/>export const bar = 2<br/>export default () =&gt; {}</span><span id="14f2" class="lj lk iq kz b gy lp lm l ln lo">import { foo } from 'module'<br/>import func from 'module'`</span></pre><p id="e080" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们使用带有<code class="fe kw kx ky kz b">default</code>键的js对象进行默认导出！</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="3cb1" class="lj lk iq kz b gy ll lm l ln lo">module.exports = {<br/>  foo: 1,<br/>  bar: 2,<br/>  default: () =&gt; {}<br/>}</span><span id="9fc0" class="lj lk iq kz b gy lp lm l ln lo">const module = require('module')<br/>const foo = module.foo<br/>const func = module.default</span></pre><p id="d31e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，酷，但是互操作呢？如果默认导入意味着接受名为<code class="fe kw kx ky kz b">default</code>的字段，那么当我们写<code class="fe kw kx ky kz b">import React from 'react'</code>时，它的意思是<code class="fe kw kx ky kz b">const { default: React } = require('react')</code>，但这是行不通的！让我们使用<em class="la"> star imports </em>来代替，这样用户将不得不编写<code class="fe kw kx ky kz b">import * as React from 'react'</code>来获取<code class="fe kw kx ky kz b">module.exports</code>中的内容。</p><p id="48db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这里有一个语义上的区别。Commonjs就像普通的javascript，仅此而已。只有函数和对象，js规范中没有<code class="fe kw kx ky kz b">require</code>。另一方面，ES6 import现在是规范的一部分，所以在这种情况下,<code class="fe kw kx ky kz b">myModule</code>不仅仅是一个普通的javascript对象，而是一个名为名称空间(而不是typescript名称空间)的东西，因此具有特定的属性。其中之一是名称空间是不可调用的。有人可能会问，这算什么问题？<br/> <br/>让我们尝试另一个commonjs模式，用一个函数作为导出:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="f581" class="lj lk iq kz b gy ll lm l ln lo">module.exports = function() { // do something }</span></pre><p id="04b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以要求并执行它:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="1d2c" class="lj lk iq kz b gy ll lm l ln lo">const foo = require('my-module')<br/>foo()</span></pre><p id="2398" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如果在符合规范的环境中使用ES6模块尝试这样做，您会得到错误消息:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="7a71" class="lj lk iq kz b gy ll lm l ln lo">import * as foo from 'my-module'<br/>foo() // Error</span></pre><p id="38e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为名称空间不仅仅是javascript对象，而是包含每个es6导出的特定内容。</p><p id="f847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是Babel做对了，并且提出了某种互操作，所以我们可以写<code class="fe kw kx ky kz b">import React from 'react'</code>并且它会工作。它所做的是在传输时，在<code class="fe kw kx ky kz b">module.exports</code>中用一个特殊的标志来标记每个es6模块，这样我们就可以看到这个标志是真的并返回<code class="fe kw kx ky kz b">module.exports</code>还是假的(很明显，如果库是commonjs并且没有被传输)，然后我们将在<code class="fe kw kx ky kz b">{ default: export }</code>中包装当前的导出，这样我们每次都可以使用<code class="fe kw kx ky kz b">default</code>(<a class="ae lq" href="https://babeljs.io/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wChTl0YA6NIlGJAUQBskQkA7GACgEogA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=false&amp;targets=&amp;version=6.26.0&amp;envVersion=" rel="noopener ugc nofollow" target="_blank">见这个</a>)。</p><p id="33bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Typescript与star imports进行了斗争，但最终放弃并引入了<code class="fe kw kx ky kz b">esModuleInterop</code>编译器选项。这个选项基本上和babel做同样的事情，如果你启用它，你可以写普通的<code class="fe kw kx ky kz b">import React from 'react'</code>，typescript会做这个工作。<br/> <br/>问题是，尽管它默认为新项目启用(当你运行<code class="fe kw kx ky kz b">tsc --init</code>时)，但它不适用于现有项目(即使你更新到TS 3)，因为它不是向后兼容的，所以你必须重写不需要的star导入以支持默认导入。React很好，因为它有一堆命名的导出，但是带有可调用名称空间的例子就不行了。但是不要担心，如果关于导出的类型是正确的(而且它们大部分是正确的，因为它们自动地修复了很多导出类型。)<br/> <br/>所以我真的提倡使用<code class="fe kw kx ky kz b">esModuleInterop</code>选项，因为它不仅允许您编写更少的代码，更容易阅读和规范兼容的代码(而且它不仅仅是咆哮，例如rollup不允许您以这种方式使用star imports)，而且还减轻了typescript和babel社区之间的一些摩擦。<br/>需要注意的是，只有当target是&lt; = ES5时，<code class="fe kw kx ky kz b">esModuleInterop</code>才会自动启用合成默认导入。所以如果你启用了这个选项，但是编译器仍然会抱怨<code class="fe kw kx ky kz b">import React</code>，检查你的目标，也许会启用合成默认导入(或者重启你的vs代码/webstorm，你永远不知道:)。</p><p id="679a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这个解释对你来说已经很清楚了，但是如果你有任何问题，请在评论或者推特上提问！</p></div></div>    
</body>
</html>