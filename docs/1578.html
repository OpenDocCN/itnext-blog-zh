<html>
<head>
<title>React Hooks Tutorial on Developing a Custom Hook for Data Fetching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks开发数据获取定制钩子教程</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-tutorial-on-developing-a-custom-hook-for-data-fetching-8ad5840db7ae?source=collection_archive---------0-----------------------#2018-11-29">https://itnext.io/react-hooks-tutorial-on-developing-a-custom-hook-for-data-fetching-8ad5840db7ae?source=collection_archive---------0-----------------------#2018-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b7af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">钩子进入反应16.7。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/41d2e600d9c3ef40fbfcc7a87812479c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjOU7l3free9vRK7XM76Fw.png"/></div></div></figure><h2 id="bb23" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">介绍</h2><p id="e25b" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">React钩子是React 16.7中的一个新特性。它允许我们编写有状态的功能组件，这在没有类组件的情况下是不可能的。官方文件是必读的，所以如果你还没有看的话就去看看吧。</p><div class="ly lz gp gr ma mb"><a href="https://reactjs.org/docs/hooks-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">介绍钩子-反应</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">钩子是一个新的特性提议，它让你不用写类就可以使用状态和其他React特性。他们是…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">reactjs.org</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ky mb"/></div></div></a></div><p id="e191" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了有状态功能组件之外，这个新特性允许我们构建一个定制的钩子来共享组件之间的逻辑。这对于高阶组件(hoc)来说是可能的，尽管从技术上来说钩子能达到的效果没有区别，但是钩子简化了很多，减少了所谓的“包装地狱”。这种简单性鼓励构建定制挂钩，这种趋势让我想起了npm的早期。</p><p id="188b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文解释了如何编写一个定制的钩子，并展示了它如何共享逻辑，即使只有几行代码。我们以一个简单的数据获取(Fetch API)为例。</p><h2 id="2479" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">目标</h2><p id="05b2" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">假设读者已经学习了React钩子的基础，我们将从我们开发的定制钩子如何使用的目标例子开始。</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="1730" class="la lb it mr b gy mv mw l mx my">const MyComponent = () =&gt; {<br/>  const { error, loading, data } = useFetch('http://...');<br/>  if (error) return &lt;Err error={error} /&gt;;<br/>  if (loading) return &lt;Loading /&gt;;<br/>  return (<br/>    &lt;DataView data={data} /&gt;<br/>  );<br/>};</span></pre><p id="ccfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，<code class="fe mz na nb mr b">useFetch</code>是自定义挂钩。不是很直观吗？<code class="fe mz na nb mr b">MyComponent</code>是一个“有状态”的功能组件，而<code class="fe mz na nb mr b">DataView</code>可以是一个无状态的功能组件，应该更具可重用性。</p><h2 id="f1fc" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">编写自定义挂钩</h2><p id="80a7" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">让我们看看如何编写一个自定义钩子来实现上述目标。自定义钩子只是一个使用其他钩子的函数。我们首先定义一个函数。</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="bfcb" class="la lb it mr b gy mv mw l mx my">const useFetch = (url) =&gt; {<br/>  // ...<br/>};</span></pre><p id="0e48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个钩子返回三个值，所以我们定义了三个状态值。请注意，我们不需要将它们组合在一个状态对象中。</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="c7a4" class="la lb it mr b gy mv mw l mx my">const useFetch = (url) =&gt; {<br/>  <strong class="mr iu">const [error, setError] = useState(null);<br/>  const [loading, setLoading] = useState(true);<br/>  const [data, setData] = useState(null);</strong><br/>  // ...<br/>  <strong class="mr iu">return { error, loading, data };</strong><br/>};</span></pre><p id="ba63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，主要部分被定义在一个<code class="fe mz na nb mr b">useEffect</code>钩子中。注意，我们在输入数组中传递了<code class="fe mz na nb mr b">url</code>。</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="999e" class="la lb it mr b gy mv mw l mx my">const useFetch = (url) =&gt; {<br/>  const [error, setError] = useState(null);<br/>  const [loading, setLoading] = useState(true);<br/>  const [data, setData] = useState(null);<br/>  <strong class="mr iu">useEffect(() =&gt; {<br/>    (async () =&gt; {<br/>      setLoading(true);<br/>      const response = await fetch(url);<br/>      const data = await response.json();<br/>      setData(data);<br/>      setLoading(false);<br/>    })();<br/>  }, [url]);</strong><br/>  return { error, loading, data };<br/>};</span></pre><p id="5137" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还没有实现错误处理。补充一下吧。</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="8820" class="la lb it mr b gy mv mw l mx my">const useFetch = (url) =&gt; {<br/>  const [error, setError] = useState(null);<br/>  const [loading, setLoading] = useState(true);<br/>  const [data, setData] = useState(null);<br/>  useEffect(() =&gt; {<br/>    (async () =&gt; {<br/>      setLoading(true);<br/>      <strong class="mr iu">try {</strong><br/>        const response = await fetch(url);<br/>        <strong class="mr iu">if (response.ok) {</strong><br/>          const data = await response.json();<br/>          setData(data);<br/>        <strong class="mr iu">} else {<br/>          setError(new Error(response.statusText));<br/>        }<br/>      } catch (e) {<br/>        setError(e);<br/>      }</strong><br/>      setLoading(false);<br/>    })();<br/>  }, [url]);<br/>  return { error, loading, data };<br/>};</span></pre><p id="15fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是实现我们目标的基本定制钩子。它可以在几个组件中重用。您可以查看这个codesandbox中的工作示例。</p><p id="1df8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae nc" href="https://codesandbox.io/s/github/dai-shi/react-hooks-fetch/tree/master/examples/01_minimal" rel="noopener ugc nofollow" target="_blank">https://code sandbox . io/s/github/Dai-Shi/react-hooks-fetch/tree/master/examples/01 _ minimal</a></p><h2 id="928c" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">扩展自定义挂钩</h2><p id="6a66" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">我们的钩子仍然是基本的，我们可能希望支持POST方法或非JSON数据。可以有各种方式来延长这个钩子。让我们尝试一个简单的方法，尽可能地保持获取API。</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="fbc9" class="la lb it mr b gy mv mw l mx my">const defaultOpts = {};<br/>const useFetch = (input, <strong class="mr iu">opts = defaultOpts</strong>) =&gt; {<br/>  const [error, setError] = useState(null);<br/>  const [loading, setLoading] = useState(true);<br/>  const [data, setData] = useState(null);<br/>  <strong class="mr iu">const {<br/>    readBody = body =&gt; body.json(),<br/>    ...init<br/>  } = opts;</strong><br/>  useEffect(() =&gt; {<br/>    (async () =&gt; {<br/>      setLoading(true);<br/>      try {<br/>        const response = await fetch(input, <strong class="mr iu">init</strong>);<br/>        if (response.ok) {<br/>          const body = await <strong class="mr iu">readBody</strong>(response);<br/>          setData(body);<br/>        } else {<br/>          setError(new Error(response.statusText));<br/>        }<br/>      } catch (e) {<br/>        setError(e);<br/>      }<br/>      setLoading(false);<br/>    })();<br/>  }, [input, <strong class="mr iu">opts</strong>]);<br/>  return { error, loading, data };<br/>};</span></pre><p id="54a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个扩展的自定义钩子的难点之一是在<code class="fe mz na nb mr b">useEffect</code>的输入数组中传递<code class="fe mz na nb mr b">opts</code>。除非用户仔细了解它的工作原理，否则可能会导致无限调用<code class="fe mz na nb mr b">fetch</code> es。</p><p id="2d82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个如何使用这个定制钩子的例子。</p><pre class="kp kq kr ks gt mq mr ms mt aw mu bi"><span id="c437" class="la lb it mr b gy mv mw l mx my">const PostRemoteData = () =&gt; {<br/>  const opts = useMemo(() =&gt; ({<br/>    method: 'POST',<br/>    body: JSON.stringify({<br/>      title: 'foo',<br/>      body: 'bar',<br/>      userId: 1,<br/>    }),<br/>    readBody: body =&gt; body.text(),<br/>  }), []);<br/>  const { error, loading, data } = useFetch('http://...', opts);<br/>  if (error) return &lt;Err error={error} /&gt;;<br/>  if (loading) return &lt;Loading /&gt;;<br/>  return (<br/>    &lt;span&gt;Result: {data}&lt;/span&gt;<br/>  );<br/>};</span></pre><h2 id="fa28" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">图书馆</h2><p id="2d7d" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">虽然这只是一个很小的定制钩子，但是我把它作为一个库并在npmjs.com发布了它。</p><div class="ly lz gp gr ma mb"><a href="https://github.com/dai-shi/react-hooks-fetch" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">戴式/反应钩取</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">用于获取API的React自定义挂钩。通过在…上创建一个帐户，为dai-shi/react-hooks-fetch开发做出贡献</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">github.com</p></div></div><div class="mk l"><div class="nd l mm mn mo mk mp ky mb"/></div></div></a></div><h2 id="275e" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">最终注释</h2><p id="593b" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">实际上，我不太确定Fetch API是否是解释构建自定义钩子的合适主题。人们可能更喜欢与视图层分离的数据提取层。然而，我希望这篇文章解释了如何开发一个定制的钩子，并有助于注意到它的可重用性。</p></div></div>    
</body>
</html>