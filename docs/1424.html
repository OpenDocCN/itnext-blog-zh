<html>
<head>
<title>Using Node.js to Read Really, Really Large Datasets &amp; Files (Pt 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js读取非常非常大的数据集和文件(第1部分)</h1>
<blockquote>原文：<a href="https://itnext.io/using-node-js-to-read-really-really-large-files-pt-1-d2057fe76b33?source=collection_archive---------0-----------------------#2018-10-11">https://itnext.io/using-node-js-to-read-really-really-large-files-pt-1-d2057fe76b33?source=collection_archive---------0-----------------------#2018-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ju"><img src="../Images/2649506b389b7738201d2eca1ca54efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Nq1fQSPq9aeoWxn4WFbhg.png"/></div></div></figure><p id="0960" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi le translated"><span class="l lf lg lh bm li lj lk ll lm di"> T </span>他的博文有一个有趣的灵感点。上周，有人在我的一个Slack频道上发布了一个他收到的关于一家保险技术公司开发人员职位的编码挑战。</p><p id="47e2" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">它激起了我的兴趣，因为挑战包括阅读来自联邦选举委员会的非常大的数据文件，并显示这些文件中的特定数据。由于我没有太多处理原始数据的经验，并且我总是准备迎接新的挑战，我决定用Node.js来解决这个问题，看看我是否能自己完成这个挑战，这只是为了好玩。</p><p id="8bd3" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">这里有4个问题，以及一个到程序要解析的数据集的链接。</p><ul class=""><li id="c74b" class="ln lo iq ki b kj kk kn ko kr lp kv lq kz lr ld ls lt lu lv bi translated">写一个程序，打印出文件中的总行数。</li><li id="5b83" class="ln lo iq ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated">请注意，第8列包含一个人的姓名。编写一个程序，加载这些数据并创建一个包含所有名称字符串的数组。打印出第432号和第43243号姓名。</li><li id="720b" class="ln lo iq ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated">请注意，第5列包含一种日期形式。计算每个月有多少捐赠，并打印出结果。</li><li id="8417" class="ln lo iq ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated">请注意，第8列包含一个人的姓名。用每个名字创建一个数组。确定数据中最常见的名字及其出现的次数。</li></ul><p id="9b79" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">数据链接:<a class="ae mb" href="https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip" rel="noopener ugc nofollow" target="_blank">https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip</a></p><p id="4925" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">当您解压缩该文件夹时，您应该会看到一个2.55GB的主<code class="fe mc md me mf b">.txt</code>文件和一个包含该主文件较小部分的文件夹(这是我在转移到主文件之前测试我的解决方案时使用的)。</p><p id="744a" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">不算太可怕吧？似乎可行。让我们来谈谈我是如何做到这一点的。</p><h2 id="ea49" class="mg mh iq bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">我想到的两个原始Node.js解决方案</h2><p id="477a" class="pw-post-body-paragraph kg kh iq ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld ij bi translated">处理大文件对JavaScript来说并不是什么新鲜事，事实上，在Node.js的核心功能中，有许多读写文件的标准解决方案。</p><p id="48a9" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">最直接的方法是<code class="fe mc md me mf b"><a class="ae mb" href="https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback" rel="noopener ugc nofollow" target="_blank">fs.readFile()</a></code>，将整个文件读入内存，然后在Node读取后对其进行操作，第二种方法是<code class="fe mc md me mf b"><a class="ae mb" href="https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options" rel="noopener ugc nofollow" target="_blank">fs.createReadStream()</a></code>，它以类似于Python和Java等其他语言的方式流入(流出)数据。</p><h2 id="384f" class="mg mh iq bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">我选择运行的解决方案&amp;为什么</h2><p id="fd8c" class="pw-post-body-paragraph kg kh iq ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld ij bi translated">由于我的解决方案需要包括计算总行数和解析每行以获得捐赠名称和日期，所以我选择使用第二种方法:<code class="fe mc md me mf b">fs.createReadStream()</code>。然后，当我流过文档时，我可以使用<code class="fe mc md me mf b"><a class="ae mb" href="https://nodejs.org/api/readline.html#readline_event_line" rel="noopener ugc nofollow" target="_blank">rl.on(‘line’,...)</a></code>函数从每行代码中获取必要的数据。</p><p id="bec5" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">对我来说，这似乎比读入文件后将整个文件分割开来并逐行运行要容易得多。</p><h2 id="5891" class="mg mh iq bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">node . js create readstream()&amp; ReadFile()代码实现</h2><p id="b220" class="pw-post-body-paragraph kg kh iq ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld ij bi translated">下面是我用Node.js的<code class="fe mc md me mf b">fs.createReadStream()</code>函数想出来的代码。下面我来分解一下。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ne"><img src="../Images/55e8f1e579fce82144b499ffd02e2bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szFus-f7Xllx17AuSc_TQw.png"/></div></div></figure><p id="341d" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我必须做的第一件事就是从Node.js导入所需的函数:<code class="fe mc md me mf b">fs</code>(文件系统)、<code class="fe mc md me mf b">readline</code>和<code class="fe mc md me mf b">stream</code>。这些导入允许我创建一个<code class="fe mc md me mf b">instream</code>和<code class="fe mc md me mf b">outstream</code>，然后是<code class="fe mc md me mf b">readLine.createInterface()</code>，这将允许我逐行读取流并从中打印出数据。</p><p id="11be" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我还添加了一些变量(和注释)来保存各种数据位:一个<code class="fe mc md me mf b">lineCount</code>、<code class="fe mc md me mf b">names</code>数组、<code class="fe mc md me mf b">donation</code>数组和对象，以及<code class="fe mc md me mf b">firstNames</code>数组和<code class="fe mc md me mf b">dupeNames</code>对象。稍后您将看到这些在哪里发挥作用。</p><p id="7f56" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在<code class="fe mc md me mf b">rl.on('line',...)</code>函数内部，我能够进行所有的逐行数据解析。在这里，我为流过的每一行增加了<code class="fe mc md me mf b">lineCount</code>变量。我使用JavaScript <code class="fe mc md me mf b">split()</code>方法解析出每个名字，并将其添加到我的<code class="fe mc md me mf b">names</code>数组中。我进一步将每个名字简化为名字，同时考虑中间的首字母、多个名字等。在JavaScript <code class="fe mc md me mf b">trim()</code>、<code class="fe mc md me mf b">includes()</code>和<code class="fe mc md me mf b">split()</code>方法的帮助下显示名字。我将过时的年份和日期列切片，重新格式化为可读性更好的<code class="fe mc md me mf b">YYYY-MM</code>格式，并将它们添加到<code class="fe mc md me mf b">dateDonationCount</code>数组中。</p><p id="5d7d" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在<code class="fe mc md me mf b">rl.on('close',...)</code>函数中，我对收集到的数据进行了所有的转换，然后<code class="fe mc md me mf b">console.log</code>将我的所有数据输出给用户查看。</p><p id="d803" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">位于第432和43243位的<code class="fe mc md me mf b">lineCount</code>和<code class="fe mc md me mf b">names</code>无需进一步操作。找到最常见的名字和每个月的捐款数量有点难。</p><p id="4997" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">对于最常见的名字，我首先必须为每个名字(键)和它出现的次数(值)创建一个键值对对象，然后我使用ES6函数<code class="fe mc md me mf b">Object.entries()</code>将它转换成一个数组的数组。从那里开始，按照名称的值对名称进行排序并打印出最大值是一项简单的任务。</p><p id="95e6" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">捐款还要求我制作一个类似的键值对对象，创建一个<code class="fe mc md me mf b">logDateElements()</code>函数，我可以很好地使用ES6的字符串插值来显示每个捐款月的键和值。然后创建一个<code class="fe mc md me mf b">new Map()</code>，将<code class="fe mc md me mf b">dateDonations</code>对象转换成一个数组的数组，并通过调用每个数组上的<code class="fe mc md me mf b">logDateElements()</code>函数对其进行循环。咻！不像我最初想的那么简单。</p><p id="3e33" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">但是成功了。至少对于我用于测试的较小的400MB文件…</p><p id="d1ee" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在我用<code class="fe mc md me mf b">fs.createReadStream()</code>完成之后，我又用<code class="fe mc md me mf b">fs.readFile()</code>实现了我的解决方案，看看有什么不同。这是相关的代码，但我不会在这里详述所有细节——它与第一个代码片段非常相似，只是看起来更同步(不过，除非您使用<code class="fe mc md me mf b">fs.readFileSync()</code>函数，否则JavaScript会像其他所有代码一样异步运行这段代码，不用担心。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ne"><img src="../Images/483c09995da618b8bf9668e02ffa4bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLYx43qMKJBpbZ8TUp_qrA.png"/></div></div></figure><p id="637f" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">如果你想看我的全部代码，你可以在这里看到。</p><h2 id="4cf3" class="mg mh iq bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">Node.js的初步结果</h2><p id="f135" class="pw-post-body-paragraph kg kh iq ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld ij bi translated">使用我的工作解决方案，我将文件路径添加到2.55GB的monster文件的<code class="fe mc md me mf b">readFileStream.js</code>文件中，并看到我的节点服务器崩溃并出现<code class="fe mc md me mf b">JavaScript heap out of memory</code>错误。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi nf"><img src="../Images/65b629bdda634eb3fa22aa9e72ca8128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S26hQHQCuzlPDHMnDR_s3g.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">失败。咚咚咚……</figcaption></figure><p id="a523" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">事实证明，尽管Node.js正在流式传输文件输入和输出，但在这两者之间，它仍然试图将整个文件内容保存在内存中，这对于这样大小的文件是做不到的。节点一次最多可以容纳1.5GB的内存，但不能再多了。</p><p id="141f" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">因此，我目前的解决方案都不能完全应对挑战。</p><p id="0a77" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我需要一个新的解决方案。通过节点运行的更大数据集的解决方案。</p><h2 id="3f45" class="mg mh iq bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">新的数据流解决方案</h2><p id="5810" class="pw-post-body-paragraph kg kh iq ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld ij bi translated">我以<code class="fe mc md me mf b"><a class="ae mb" href="https://www.npmjs.com/package/event-stream" rel="noopener ugc nofollow" target="_blank">EventStream</a></code>的形式找到了我的解决方案，这是一个受欢迎的NPM模块，每周下载超过200万次，并承诺“让创建和使用流变得容易”。</p><p id="b999" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">在EventStream文档的一点帮助下，我能够再次找出如何逐行读取代码并做需要做的事情，希望是以一种对Node更友好的方式。</p><h2 id="54b1" class="mg mh iq bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">事件流代码实现</h2><p id="6f21" class="pw-post-body-paragraph kg kh iq ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld ij bi translated">这是我的代码使用NPM模块EventStream的新代码。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ne"><img src="../Images/376ef29e93a1c64d31e4e1f30a6e0ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZFzB0v46FoAaMTR0ANrCQ.png"/></div></div></figure><p id="4198" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">最大的变化是文件开头的管道命令——所有这些语法都是EventStream的文档建议您将流分成由<code class="fe mc md me mf b">.txt</code>文件每行末尾的<code class="fe mc md me mf b">\n</code>字符分隔的块的方式。</p><p id="71ef" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我唯一需要修改的是<code class="fe mc md me mf b">names</code>答案。我不得不稍加修改，因为如果我试图将所有13毫米的名字添加到一个数组中，我又会遇到内存不足的问题。我通过收集第432和第43，243个名字并将它们添加到它们自己的数组中来解决这个问题。不完全是被要求的，但是，嘿，我得有点创意。</p><h2 id="3833" class="mg mh iq bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">Node.js和EventStream的结果:第2轮</h2><p id="7e06" class="pw-post-body-paragraph kg kh iq ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld ij bi translated">好了，随着新解决方案的实现，我再次用我的2.55GB文件启动Node.js，我的手指交叉这将工作。看看结果。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi nk"><img src="../Images/7f6925ae8c6aa3287225f24cff8daf5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJBlTYxNUCPXCDeKI9RTMg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">吼吼！</figcaption></figure><p id="de54" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">成功！</p><h2 id="42c9" class="mg mh iq bd mi mj mk dn ml mm mn dp mo kr mp mq mr kv ms mt mu kz mv mw mx my bi translated">结论</h2><p id="2b06" class="pw-post-body-paragraph kg kh iq ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld ij bi translated">最终，Node.js的纯文件和大数据处理功能没有达到我的要求，但只需要一个额外的NPM包EventStream，我就能够解析一个大规模数据集，而不会使节点服务器崩溃。</p><p id="5c69" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">请继续关注本系列的<a class="ae mb" href="https://bit.ly/2JdcO2g" rel="noopener ugc nofollow" target="_blank">第二部分</a>，我将Node.js中读取数据的三种不同方式与性能测试进行了比较，看看哪种方式真正优于其他方式。结果令人大开眼界，尤其是当数据变大时…</p><p id="09f4" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">感谢您的阅读，我希望这能让您了解如何使用Node.js处理大量数据。非常感谢鼓掌和分享！</p><p id="043f" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他博客:</p><ul class=""><li id="d6b9" class="ln lo iq ki b kj kk kn ko kr lp kv lq kz lr ld ls lt lu lv bi translated"><a class="ae mb" href="https://medium.com/@paigen11/postman-vs-insomnia-comparing-the-api-testing-tools-4f12099275c1" rel="noopener">邮递员vs .失眠:比较API测试工具</a></li><li id="0216" class="ln lo iq ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated"><a class="ae mb" href="https://medium.com/@paigen11/how-to-use-netflixs-eureka-and-spring-cloud-for-service-registry-8b43c8acdf4e" rel="noopener">如何使用网飞的Eureka和Spring Cloud进行服务注册</a></li><li id="1b5a" class="ln lo iq ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated"><a class="ae mb" href="https://medium.com/@paigen11/jib-getting-expert-docker-results-without-any-knowledge-of-docker-ef5cba294e05" rel="noopener"> Jib:在没有任何Docker知识的情况下获得专家Docker结果</a></li></ul></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="8702" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><strong class="ki ir">参考资料和更多资源:</strong></p><ul class=""><li id="42db" class="ln lo iq ki b kj kk kn ko kr lp kv lq kz lr ld ls lt lu lv bi translated">Node.js文档，文件系统:【https://nodejs.org/api/fs.html T2】</li><li id="ce08" class="ln lo iq ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated">Node.js文档，Readline:【https://nodejs.org/api/readline.html#readline_event_line T4】</li><li id="9666" class="ln lo iq ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated">Github，读取文件回购:<a class="ae mb" href="https://github.com/paigen11/file-read-challenge" rel="noopener ugc nofollow" target="_blank">https://github.com/paigen11/file-read-challenge</a></li><li id="de50" class="ln lo iq ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated">https://www.npmjs.com/package/event-stream，NPM，事件之梦</li></ul></div></div>    
</body>
</html>