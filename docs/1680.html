<html>
<head>
<title>Load Testing Using Apache JMeter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Apache JMeter进行负载测试</h1>
<blockquote>原文：<a href="https://itnext.io/load-testing-using-apache-jmeter-af189dd6f805?source=collection_archive---------1-----------------------#2019-01-01">https://itnext.io/load-testing-using-apache-jmeter-af189dd6f805?source=collection_archive---------1-----------------------#2019-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/384f4c752bda4603131e39e0eb6b385c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-PTSr04R-vTXuy2K"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kc" href="https://unsplash.com/@vanveenjf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> VanveenJF </a>拍摄的照片</figcaption></figure><p id="1dd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">负载测试是对任何软件系统进行负载(HTTP、HTTPS、WebSocket等)调用，以确定其在正常和高负载条件下的行为的过程。负载测试有助于确定软件系统可以处理的最大请求。它有助于确定导致应用程序性能下降的瓶颈点。当我们模拟真实的用户场景时，负载测试是有效的。我们需要知道用户在我们的应用程序上的行为。尝试使用不同的API调用复制它们的行为，并在我们的应用程序中长时间通过许多并发请求生成负载，以了解应用程序行为的变化。</p><p id="ba7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在系统上生成超出正常使用的负载(高负载)来理解应用程序/系统行为时，我们称之为压力测试。进行压力测试是为了了解整个系统的极限，理解在这样的负载期间抛出的错误种类，以及最终用户是如何受到影响的。这有助于在通过配置更多基础架构或优化应用程序来应对更高负载时的事件规划。</p><p id="14c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<a class="ae kc" href="http://jmeter.apache.org" rel="noopener ugc nofollow" target="_blank"> Apache JMeter </a>对静态和动态资源进行负载测试，这些资源可以生成并发用户来模拟真实的用户场景。它还提供测试报告的图形分析。它是用java编写的，所以我们需要安装Java运行时来运行Jmeter。根据<a class="ae kc" href="http://jmeter.apache.org/index.html" rel="noopener ugc nofollow" target="_blank"> JMeter网站</a>，其定义如下:</p><blockquote class="lb lc ld"><p id="5e95" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">Apache JMeter应用程序是开源软件，是一个100%纯Java应用程序，旨在加载测试功能行为和测量性能。它最初是为测试Web应用程序而设计的，但后来扩展到了其他测试功能。</p></blockquote><p id="d11f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您想要运行测试的系统上安装<a class="ae kc" href="https://jmeter.apache.org/download_jmeter.cgi" rel="noopener ugc nofollow" target="_blank"> JMeter </a>。我用Mac OS运行JMeter，用brew安装Jmeter。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="a9de" class="lr ls iq ln b gy lt lu l lv lw">brew install jmeter</span></pre><p id="c581" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先需要使用下面的命令检查我们可以在系统上打开的文件描述符。每个操作系统对活动文件描述符都有限制。每个TCP连接都需要一个文件描述符，所以我们需要确保有足够的文件描述符(可以在1-65535之间设置)来运行并发请求。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="c4ad" class="lr ls iq ln b gy lt lu l lv lw">ulimit -n</span></pre><p id="7160" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了开始我们的负载测试，我们需要从线程组开始。它们是任何测试计划的起点。我们可以指定想要同时模拟的用户数量(=线程数量)。设置加速时间，该时间指定启动所有线程所需的时间。我们需要为组中的每个用户(线程)定义一些迭代。每个线程独立于其他线程执行计划。单线程中的所有元素将按顺序执行。</p><p id="ea08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在一个线程组中添加采样器和逻辑控制器。采样器帮助向服务器发送请求并等待响应，即HTTP请求采样器发送HTTP请求并获得响应。逻辑控制器帮助定制逻辑以决定何时发送请求、修改请求等。</p><p id="66ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">侦听器是另一种类型的元素，我们可以将它添加到线程组中。它们提供了对我们的负载测试信息的访问。图形结果监听器帮助我们绘制测试结果。查看结果树监听器显示请求和响应的详细信息。我们可以为采样器请求添加预处理程序和后处理程序。前处理器在样本请求前执行定义的动作，后处理器在样本请求后执行定义的动作。预处理器可用于为每个请求生成不同的动态参数，后处理器可用于获取其他请求要使用的响应参数。配置元素用于配置采样器的默认值。</p><p id="3fb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们举一个真实的例子，我们将使用一个线程组创建一个JMeter测试计划，该线程组可以在给定服务器上的用户资源上运行CRUD操作。每个“创建用户”操作需要在发送请求之前随机生成不同的电子邮件地址。获取身份验证令牌和用户id为创建用户请求提供了响应。身份验证令牌在所有后续请求中用作标头，并根据需要在URL和主体参数中用作用户id。最后，有一个视图结果树监听器，在那里我们可以看到所有的请求及其响应。</p><p id="23fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步骤1:向我们的测试计划添加一个线程组</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lx"><img src="../Images/0893b28782ae61f8cea274a8d3afcd31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ali2AZZk3cIf76Sa6SmJLg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建线程组</figcaption></figure><p id="bee1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步骤2:添加HTTP请求默认值，使用config元素定义所有请求所需的默认参数，如主机名和服务器端口。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/ab7fdf98b976cb729a387d4d583f1fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOzVlqHSYs-__DbDcnbWMA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建HTTP请求默认值</figcaption></figure><p id="ecd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步骤3:添加一个HTTP请求采样器来发送创建用户请求。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/c8e6d9701b4fd78458cce92fc09d5639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5u3H4cgJJk-5ORKQ8Dhn2g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建HTTP请求采样器</figcaption></figure><p id="f9b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加主体以创建带有动态电子邮件参数的HTTP请求，该参数由预处理器生成。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/e26c3501892acd6332fbbca9a9818af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*zqpwqZU9eN3pU_Pv7Ta9Jw.png"/></div></figure><p id="ebbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第4步:添加一个BeanShell预处理器，为创建用户请求生成一个随机的电子邮件地址。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/4d045814ed739ee36356321f38ca231e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xyw4nV1tgBD-ffaruAK9PQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">为预处理用户HTTP请求创建BeanShell处理器</figcaption></figure><p id="03a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用java代码生成一个随机数，用于为每个请求生成新的电子邮件。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mc"><img src="../Images/df41f7f4920a873456befa07f09f534f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8j-RmgKT35iLYM7sjoKNAA.png"/></div></div></figure><p id="e736" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步骤5:添加一个JSON提取器后处理器，从创建用户请求的响应中获取身份验证令牌和userId。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/8aa1b45994ae5ccb06cd29a20f8c9646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SSPXn7A-qSNfFgmXzmdgw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">为后处理HTTP请求创建JSON提取器</figcaption></figure><p id="ea61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用JSON提取器从JSON响应中读取令牌。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/08ed8fb83216f4e402a6d1fe4f81a845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ekvl6aN9Dj_bb1Bx6AdGKg.png"/></div></div></figure><p id="231c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步骤6:添加一个HTTP头管理器，将身份验证令牌作为头添加到所有后续请求中。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/7ec598acf969c24f5c01fba367588411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQ_ZLtN3V1ttSmSwxaWpNw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建HTTP头管理器，用于向所有请求发送验证头</figcaption></figure><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/f016d7164b1870ecd4def64b69cf9613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRdmymzOIg6hCBgISK7hNQ.png"/></div></div></figure><p id="0d8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第七步:添加更新用户，获取用户，删除用户HTTP请求采样器用于后续的请求，方式与创建用户HTTP请求采样器相同，userId为动态变量，从创建用户后处理器中取出。</p><p id="d311" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">步骤8:添加查看结果树以获得对所有请求的响应。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/1736e3d1d5470cde6bb0132cd8b2e74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqEDaAkcPIkepGlE3ejVwA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建视图结果树监听程序</figcaption></figure><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/006767aa798b0ac2f526cb2ec72e85f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9jdHt2i13OyhFiqRJtkgw.png"/></div></div></figure><p id="9333" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们准备好了用户CRUD负载测试，可以通过增加用户数量来生成负载。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/b474ec309ebd7e52168f7cfb11c0acdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V96gly_QZv9VNEoCfRODUw.png"/></div></div></figure><p id="1305" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以生成不同的负载测试计划，以了解我们的应用程序的限制。</p><p id="f242" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的代码可以在这个git资源库中找到:<a class="ae kc" href="https://github.com/MiteshSharma/JMeterUserLoadTest" rel="noopener ugc nofollow" target="_blank">https://github.com/MiteshSharma/JMeterUserLoadTest</a></p><p id="af6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="le"> PS:如果你喜欢这篇文章，请鼓掌支持</em> </strong>👏<strong class="kf ir"> <em class="le">。欢呼</em> </strong></p></div></div>    
</body>
</html>