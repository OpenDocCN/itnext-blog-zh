<html>
<head>
<title>10 Features of Go that Set it Apart From Other Languages.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go区别于其他语言的10个特征。</h1>
<blockquote>原文：<a href="https://itnext.io/10-features-of-go-that-set-it-apart-from-other-languages-89337e5ee551?source=collection_archive---------0-----------------------#2021-09-21">https://itnext.io/10-features-of-go-that-set-it-apart-from-other-languages-89337e5ee551?source=collection_archive---------0-----------------------#2021-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1256041fbb00119ae9a9b560cf799d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNAfe8HdCISV0MFnK5cnag.jpeg"/></div></div></figure><p id="c510" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为编程语言，go还相当年轻。它于2009年11月10日首次发布。它的创造者<a class="ae kw" href="https://en.wikipedia.org/wiki/Robert_Griesemer" rel="noopener ugc nofollow" target="_blank">罗伯特·格里斯默</a> <br/> <a class="ae kw" href="https://en.wikipedia.org/wiki/Rob_Pike" rel="noopener ugc nofollow" target="_blank">罗布·派克</a>和<a class="ae kw" href="https://en.wikipedia.org/wiki/Ken_Thompson" rel="noopener ugc nofollow" target="_blank">肯·汤普森</a>在谷歌工作，大规模扩展的挑战激发他们将Go设计为一个快速高效的编程解决方案，用于大型代码库的项目，由多个开发人员管理，具有严格的性能要求，并跨越多个网络&amp;处理核心。</p><p id="69bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go的创始人在创造他们的新语言时，也抓住机会学习其他编程语言的优点、缺点和疏忽。结果是一种干净、清晰、实用的语言，只有相对较少的命令和功能。</p><p id="c275" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将解析Go区别于其他语言的10个特性(根据我个人的观察)。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="ee1f" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">1.Go总是在构建中包含二进制文件</h1><p id="e3ab" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">Go运行时提供诸如内存分配、垃圾收集、并发支持和联网等服务。它被编译成每个Go二进制文件。这与许多其他语言不同，其中许多语言使用虚拟机，需要与程序一起安装才能正常工作。</p><p id="a532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将运行时直接包含在二进制文件中使得发布和运行Go程序变得非常容易，并且避免了运行时和程序之间的不兼容问题。Python、Ruby和JavaScript等语言的虚拟机也没有针对垃圾收集和内存分配进行优化，这解释了Go相对于其他类似语言的优越速度。举个例子，Go在<a class="ae kw" href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" rel="noopener ugc nofollow" target="_blank">栈</a>上存储尽可能多的数据，在那里数据按顺序排列，访问速度比<a class="ae kw" href="https://www.educba.com/what-is-heap-memory/" rel="noopener ugc nofollow" target="_blank">堆</a>快得多。稍后将详细介绍。</p><p id="8393" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于Go的静态二进制文件的最后一点是，因为没有运行所需的外部依赖，<strong class="ka ir">它们启动起来非常快</strong>。如果你使用像<a class="ae kw" href="https://cloud.google.com/appengine" rel="noopener ugc nofollow" target="_blank">谷歌应用引擎</a>这样的服务，这是很有用的，这是一个运行在谷歌云上的平台即服务，它可以将你的应用程序缩减到零个实例，以节省云成本。当一个新的请求进来时，App Engine可以在一眨眼的时间内启动你的Go程序的一个实例。Python或Node中的相同体验通常会导致3-5秒(或更长时间)的等待，因为所需的虚拟环境也会随着新实例一起启动。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="9ed3" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">2.Go没有针对程序依赖性的集中托管服务</h1><p id="0da7" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">为了访问已发布的围棋程序，开发者不依赖于集中托管的服务，比如Java的<a class="ae kw" href="https://search.maven.org/" rel="noopener ugc nofollow" target="_blank"> Maven Central </a>或JavaScript的<a class="ae kw" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a> registry。相反，项目通过它们的源代码库(最常见的是Github)共享。<code class="fe mh mi mj mk b">go install</code>命令行允许以这种方式下载存储库。</p><p id="e203" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我为什么喜欢这个功能？我一直认为像Maven Central、PIP和NPM这样的集中托管的依赖服务是有些令人生畏的黑匣子，可能会抽象出下载和安装依赖项(以及依赖项的依赖项)的麻烦，但不可避免地会在出现依赖项错误时导致令人害怕的心脏停止跳动(我经历过太多了，无法计数)。</p><p id="c592" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我常常感到沮丧，因为我从来没有完全理解他们是如何在幕后工作的。通过去掉一个中心服务，安装、版本控制和管理你的Go项目的依赖项的过程变得非常清晰，从而更加干净。</p><p id="fd29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，让你的模块对其他人可用就像把它放在版本控制系统中一样简单，这是一种非常简单的分发程序的方式。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="a63e" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">3.Go是按值调用</h1><p id="efac" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在Go中，当你提供一个原语(数字、布尔或字符串)或一个结构(类对象的粗略等价物)作为函数的参数时，Go总是会制作一个变量的值的<strong class="ka ir">副本。</strong></p><p id="5e69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Java、Python和JavaScript等许多其他语言中，原语是通过值传递的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/the-power-of-functional-programming-in-javascript-cc9797a42b60">，但是对象(类实例)是通过<strong class="ka ir">引用</strong>传递的，这意味着接收函数实际上接收的是一个指向原始对象的<strong class="ka ir">指针</strong>，<em class="ml">而不是其副本</em>。</a></p><p id="ecf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着在接收函数<strong class="ka ir">中对对象所做的任何改变都会反映在原始对象</strong>中。</p><p id="345d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Go中，默认情况下，通过使用<em class="ml">星号</em>操作符，通过值传递结构和原语，并且可以选择传递一个<a class="ae kw" href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html" rel="noopener ugc nofollow" target="_blank">指针</a>:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="de97" class="mu lf iq mk b gy mv mw l mx my"><em class="ml">// pass by value</em><br/>func MakeNewFoo(f <strong class="mk ir">Foo</strong>) (Foo, error) {<br/>   f.Field1 = "New val"<br/>   f.Field2 = f.Field2 + 1<br/>   return f, nil<br/>}</span></pre><p id="40b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的函数接收Foo的一个副本，而<strong class="ka ir">返回一个新的Foo对象</strong>。</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="e65e" class="mu lf iq mk b gy mv mw l mx my"><em class="ml">// pass by reference</em><br/>func MutateFoo(f <strong class="mk ir">*Foo</strong>) error {<br/>   f.Field1 = "New val"<br/>   f.Field2 = 2<br/>   return nil<br/>}</span></pre><p id="a279" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的函数接收一个指向Foo的指针，然后<strong class="ka ir">改变原始对象</strong>。</p><p id="2cfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种按值调用和按引用调用的明显区别使您的意图显而易见，并减少了调用函数无意中改变传入对象的可能性(这是许多初级开发人员难以掌握的)。</p><p id="8c18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如麻省理工学院<a class="ae kw" href="http://web.mit.edu/6.031/www/fa20/classes/08-immutability/" rel="noopener ugc nofollow" target="_blank">总结</a> : <em class="ml">“可变性使得理解你的程序正在做什么变得更加困难，并且更难执行契约”</em></p><p id="4518" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，按值调用大大减少了垃圾收集器的工作，这意味着应用程序速度更快，内存效率更高。<a class="ae kw" href="https://www.forrestthewoods.com/blog/memory-bandwidth-napkin-math/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>的结论是，指针追踪(从堆中检索指针值)比从连续堆栈中检索值要慢10到20倍。要记住的一个好的经验法则是:<em class="ml">从内存中读取的最快方法是顺序读取，这意味着将随机存储在RAM中的指针数量减少到最小</em>。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="25e2" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">4.“延期”关键字</h1><p id="8ec5" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在NodeJS中，在我开始使用<a class="ae kw" href="https://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> knex.js </a>之前，我会在我的代码中手动管理数据库连接，方法是创建一个DB池，然后在每个函数中从池中打开一个新的连接，一旦所需的数据库CRUD功能完成，就在函数末尾释放连接。</p><p id="51d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这有点像维护的噩梦，因为如果我不在每个函数结束时释放连接，未释放的数据库连接的数量将会慢慢增加，直到连接池中不再有空闲连接，然后应用程序就会中断。</p><p id="29b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现实是，程序经常需要释放、清理和拆除资源、文件、连接等。所以Go引入了<strong class="ka ir"> defer </strong>关键字作为管理这种情况的有效方法。</p><p id="ea3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何以<strong class="ka ir"> defer </strong>开头的语句都会延迟其调用，直到周围的函数退出。这意味着你可以把你的清理/删除代码放在一个函数的顶部(很明显的地方)，知道一旦函数完成，它就会完成它的工作。</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="9099" class="mu lf iq mk b gy mv mw l mx my">func main() {                        <br/>    if len(os.Args) &lt; 2 {   <br/>        log.Fatal("no file specified")<br/>    }  <br/>    f, err := os.Open(os.Args[1])                        <br/>    if err != nil {                         <br/>        log.Fatal(err)                        <br/>    }                        <br/>    <strong class="mk ir">defer f.Close()</strong>                        <br/>    data := make([]byte, 2048)                        <br/>    for {                         <br/>        count, err := f.Read(data)                                               <br/>        os.Stdout.Write(data[:count])                        <br/>        if err != nil {                          <br/>            if err != io.EOF {                           <br/>                log.Fatal(err)                          <br/>            }                          <br/>            break                         <br/>        }                        <br/>    }                       <br/>}</span></pre><p id="42b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，文件关闭方法被延迟。我喜欢这种模式:在函数的顶部声明你的管家意图，然后忘记它，知道一旦函数退出，它就会完成它的工作。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="8db1" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">5.Go采用了函数式编程的最佳特性</h1><p id="c648" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">函数式编程是一种高效和创造性的范式，谢天谢地，Go采用了函数式编程的最佳特性。在Go中:</p><p id="17aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—函数是值，这意味着它们可以作为值添加到映射中，作为参数传递到其他函数中，设置为变量，并从函数中返回(称为“高阶函数”&amp;经常在Go中使用decorator模式创建中间件)。</p><p id="a228" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—可以创建和自动调用匿名函数。</p><p id="c458" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—在其他函数内部声明的函数允许闭包(其中在函数内部声明的函数能够访问和修改在外部函数中声明的变量)。在惯用的Go中，闭包被广泛用于限制函数的作用域，并设置函数在逻辑中使用的状态。</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="e0d4" class="mu lf iq mk b gy mv mw l mx my">func StartTimer (name string) func(){<br/>    t := time.Now()<br/>    log.Println(name, "started")<br/>    return func() {<br/>        d := time.Now().Sub(t)<br/>        log.Println(name, "took", d)<br/>    }<br/>}</span><span id="e3f5" class="mu lf iq mk b gy mz mw l mx my">func RunTimer() {<br/>    stop := StartTimer("My timer")<br/>    defer stop()<br/>    time.Sleep(1 * time.Second)<br/>}</span></pre><p id="02bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上是一个关闭的例子。“StartTimer”函数<strong class="ka ir">返回一个新函数</strong>，该函数通过<strong class="ka ir">闭包</strong>访问“t”值，该值在其出生范围内设置。然后，该函数可以将当前时间与“t”的值进行比较，从而创建一个有用的计时器。感谢<a class="ae kw" href="https://twitter.com/matryer" rel="noopener ugc nofollow" target="_blank"> Mat Ryer </a>的这个例子。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="0a02" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">6.Go有隐式接口</h1><p id="1b38" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">任何读过关于<a class="ae kw" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">可靠</a>编码和<a class="ae kw" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">设计模式</a>的文献的人可能都听过这样一句口头禅<em class="ml">‘偏好组合胜过继承’。</em>简而言之，这表明你应该将你的业务逻辑分解到不同的接口中，而不是依赖于从父类继承的属性和逻辑。</p><p id="e134" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个流行的是<em class="ml">“编程到一个接口，而不是实现”:</em>一个API应该只发布其预期行为(其方法签名)的契约，而不是关于该行为如何实现的细节。</p><p id="c54c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两者都指出了<strong class="ka ir">接口</strong>在现代编程中的至关重要性。</p><p id="ddd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，毫不奇怪，Go支持接口。事实上，接口是Go中唯一的抽象类型。</p><p id="67b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，与其他语言不同的是，Go中的接口不是显式地实现的，而是隐式地实现的。具体类型不声明它实现接口。相反，如果该具体类型的方法集包含底层接口的所有方法集，<strong class="ka ir"> Go认为该对象实现了接口</strong>。</p><p id="320c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种<strong class="ka ir">隐式</strong>接口实现(正式名称为结构化类型化)允许Go加强类型安全和解耦，保留了动态语言中展现的灵活性。</p><p id="c271" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相比之下，显式接口将客户端和实现绑定在一起，使得在Java中替换依赖关系比在Go中要困难得多。</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="3f59" class="mu lf iq mk b gy mv mw l mx my"><em class="ml">// this is an interface declaration (called Logic)</em><br/>type Logic interface {<br/>    <strong class="mk ir">Process</strong>(data string) string<br/>}</span><span id="8fd3" class="mu lf iq mk b gy mz mw l mx my"><br/>type LogicProvider struct {}</span><span id="8846" class="mu lf iq mk b gy mz mw l mx my"><em class="ml">// this is a method called 'Process' on the LogicProvider struct</em><br/>func (lp LogicProvider) <strong class="mk ir">Process</strong>(data string) string {<br/>    // business logic<br/>}</span><span id="26d6" class="mu lf iq mk b gy mz mw l mx my"><em class="ml">// this is the client struct with the Logic interface as a property</em><br/>type Client struct {<br/>    L Logic<br/>}</span><span id="1f8a" class="mu lf iq mk b gy mz mw l mx my">func(c Client) Program() {<br/>    // get data from somewhere<br/>    c.L.Process(data)<br/>}</span><span id="de23" class="mu lf iq mk b gy mz mw l mx my">func main() {<br/>    c := Client {<br/>        <strong class="mk ir">L: LogicProvider{},  <br/>    </strong>}<br/>    c.Program()<br/>}</span></pre><p id="0fde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="ml"> LogicProvider </em>中没有声明任何东西来表明它符合<em class="ml">逻辑</em>接口。这意味着客户端在将来可以很容易地替换它的逻辑提供者，只要该逻辑提供者包含底层接口的所有方法集(<em class="ml">逻辑</em>)。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="f1f5" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">7.错误处理</h1><p id="be3a" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">Go中错误的处理方式与其他语言有很大不同。简而言之，Go通过<strong class="ka ir">返回一个error类型的值作为函数</strong>的最后一个返回值来处理错误。</p><p id="4d04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当函数按预期执行时，为错误参数返回<strong class="ka ir"> nil </strong>，否则返回<strong class="ka ir">错误值</strong>。然后，调用函数检查错误返回值，并处理错误，或者抛出自己的错误。</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="d2b4" class="mu lf iq mk b gy mv mw l mx my"><em class="ml">// the function returns an int and an error</em><br/>func calculateRemainder(numerator int, denominator int) (<strong class="mk ir">int, error</strong>) {<br/>   <em class="ml">// Error returned</em><br/>   if denominator == 0 {<br/>      return 9, <strong class="mk ir">errors.New("denominator is 0")<br/>   </strong>}</span><span id="3f00" class="mu lf iq mk b gy mz mw l mx my">   <em class="ml">// No error returned</em><br/>   return numerator / denominator, <strong class="mk ir">nil<br/></strong>}</span></pre><p id="0528" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go以这种方式运行是有原因的:它迫使编码人员考虑异常并正确处理它们。传统的try-catch异常还会在代码中添加至少一个新的代码路径，并以难以理解的方式缩进代码。Go更喜欢将“快乐路径”视为非缩进代码，任何错误都会在“快乐路径”完成之前被识别并返回。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="33c4" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">8.并发</h1><p id="d269" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">可以说，并发性是Go最著名的特性，它允许在机器或服务器上的多个可用内核上并行运行处理。当独立的进程<strong class="ka ir">不相互依赖</strong>(不需要按顺序运行)并且时间性能至关重要时，并发最有意义。I/O需求经常是这种情况，在这种情况下，对磁盘或网络的读写比除了最复杂的内存中进程之外的所有进程都要慢几个数量级。</p><p id="5c75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数调用前的'<em class="ml"> go </em>'关键字将同时运行该函数。</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="95c5" class="mu lf iq mk b gy mv mw l mx my">func process(val int) int {<br/>   <em class="ml">// do something with val</em><br/>}</span><span id="ebbf" class="mu lf iq mk b gy mz mw l mx my"><em class="ml">// for each value in 'in', run the process function concurrently, <br/>// and read the result of process to 'out'</em><br/>func runConcurrently(in &lt;-chan int, out chan&lt;- int){<br/>   <strong class="mk ir">go</strong> func() {<br/>       for val := range in {<br/>            result := process(val)<br/>            out &lt;- result  <br/>       }<br/>   }<br/>}</span></pre><p id="eae3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go中的并发性是一个深入且相当高级的特性，但是在它有意义的地方，它提供了一个有效的方法来确保程序的最佳性能。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="c07e" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">9.Go标准库</h1><p id="ffc8" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">Go有一个“包含电池”的哲学，现代编程语言的许多要求都被放入标准库中，这使得程序员的生活简单多了。</p><p id="2fba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，Go是一种相对年轻的语言，这意味着现代应用程序的许多问题/需求都在标准库中得到了解决。</p><p id="58ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，Go为网络(特别是HTTP/2)和文件管理提供了世界级的支持。它还提供本机JSON编码和解码。因此，设置一个服务器来处理HTTP请求和返回响应(JSON或其他)是非常简单的，这解释了Go在基于REST的HTTP web服务开发中的受欢迎程度。</p><p id="2c83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如Mat Ryer所指出的，标准库是开源的，是学习围棋最佳实践的好方法。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="d881" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">10.调试:Go游乐场</h1><p id="e34d" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在任何语言中进行调试都是一项关键要求。大多数语言依赖第三方在线工具或智能ide来提供调试工具，允许开发人员快速检查他们的代码。Go已经提供了一个免费的在线工具—【https://play.golang.org】<a class="ae kw" href="https://play.golang.org" rel="noopener ugc nofollow" target="_blank">Go Playground，在这里你可以尝试和分享小程序。这是一个非常有用的工具，它使调试变得非常简单。</a></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="97f0" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考</h1><div class="na nb gp gr nc nd"><a href="https://golang.org/doc/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">证明文件</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">Go编程语言是一个开源项目，旨在提高程序员的工作效率。围棋富有表现力，简洁…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">golang.org</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jw nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://github.com/learning-go-book" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">学习围棋</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">学习围棋的GitHub repo。Learning Go有17个可用的存储库。在GitHub上关注他们的代码。</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="ns l no np nq nm nr jw nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://www.oreilly.com/library/view/learning-go/9781492077206/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">学习围棋</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">Go正迅速成为构建web服务的首选语言。虽然有大量的教程可用…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">www.oreilly.com</p></div></div><div class="nm l"><div class="nt l no np nq nm nr jw nd"/></div></div></a></div><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div></div>    
</body>
</html>