<html>
<head>
<title>Testing Bun’s compatibility, and speed, with Node.js and a complex application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试Bun与Node.js和一个复杂应用程序的兼容性和速度</h1>
<blockquote>原文：<a href="https://itnext.io/testing-buns-compatibility-and-speed-with-a-complex-application-bee823a1a1b3?source=collection_archive---------0-----------------------#2022-07-10">https://itnext.io/testing-buns-compatibility-and-speed-with-a-complex-application-bee823a1a1b3?source=collection_archive---------0-----------------------#2022-07-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="5274" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">一个新的服务器端JavaScript平台宣称Node.js的兼容性和巨大的性能提升，但是它符合标准吗？</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/fe5a8cd786e95ea777669d84770a5311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7bq5eOIFYFb-vNYZ.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</figcaption></figure><p id="eb21" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">最近，一个新的JavaScript服务器端运行时Bun宣布推出，承诺将大幅提高Node.js的速度。与其用一个小应用程序进行测试，不如让我们用一个复杂的应用程序来看看真实世界的性能。</strong></p><p id="e4b5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Bun网站(<a class="ae lv" href="https://bun.sh/" rel="noopener ugc nofollow" target="_blank">https://bun.sh/</a>)让它看起来像是Node.js开发的一个非常有趣的选择。它与Node.js的想法相同，但承诺有更好的性能。像Node.js一样，Bun从web浏览器打包了一个JavaScript引擎作为服务器端JavaScript平台，并承诺实现Node.js API以实现完全兼容性。</p><p id="9302" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">它没有使用Chrome的V8引擎，而是使用了苹果Safari浏览器的JavaScriptCore引擎。这款发动机备受推崇，被认为比V8更快，是第一个宣称的优势。另一个声称的优势是Bun系统是用一种新语言Zig编写的，而不是用C++或Rust。由于一些技术细节，Zig应该更快。</p><p id="a21c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我发现的另一件有趣的事情是，TypeScript和JSX transpilers都内置于Bun中，这应该使运行TypeScript代码变得非常容易。</p><p id="51cc" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该团队声称与Node.js包有90%的兼容性，包括使用N-API来支持执行本机代码Node.js包。它还使用Node.js的相同的<code class="fe lw lx ly lz b">node_modules</code>基础设施和包查找算法，这意味着它可以立即与现有的Node.js生态系统兼容。</p><p id="c00d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">相比之下，Deno(另一个Node.js替代方案)与Node.js包生态系统不兼容，这给了它很大的劣势。</p><p id="872a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Node.js开发人员将如何处理与现有生态系统兼容但速度更快的替代方案？</p><p id="a7bd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">更新2:正如我下面提到的，这篇文章错误地没有在Bun上测试我的应用程序。相反，它意外地在Node.js上运行了测试。</p><p id="10a6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我写了一篇更新的文章:</p><div class="ma mb gq gs mc md"><a rel="noopener  ugc nofollow" target="_blank" href="/deeper-testing-of-buns-performance-and-compatibility-against-node-js-9115763965ed"><div class="me ab fp"><div class="mf ab mg cl cj mh"><h2 class="bd iv gz z fq mi fs ft mj fv fx it bi translated">对Bun的性能和与Node.js的兼容性进行更深入的测试</h2><div class="mk l"><h3 class="bd b gz z fq mi fs ft mj fv fx dk translated">Bun最终可能会使Node.js和/或Deno变得无关紧要，但现在说它们都是死项目还为时过早</h3></div><div class="ml l"><p class="bd b dl z fq mi fs ft mj fv fx dk translated">itnext.io</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr kt md"/></div></div></a></div><p id="44e7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">更新:看起来我下面的测试是不正确的。在测试中使用的Bun版本中，我使用<code class="fe lw lx ly lz b">cli.js</code>运行我的应用程序，它在文件的前面有一个“shebang ”,也称为<code class="fe lw lx ly lz b">#!/usr/bin/env node. According to a comment below by Jarred Sumner, Bun respected the shebang, and therefore my code was executed by Node.js rather than by Bun.</code></p><p id="dd53" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在Bun 0.1.4中，情况似乎略有变化。这个源文件让我测试shebang特性:</p><pre class="kk kl km kn gu ms lz mt mu aw mv bi"><span id="60a4" class="mw mx iu lz b gz my mz l na nb">#!/usr/bin/env node</span><span id="14ae" class="mw mx iu lz b gz nc mz l na nb">console.log(process.isBun);</span></pre><p id="c4d2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe lw lx ly lz b">process.isBun</code>变量可用于测试Bun是否运行。根据Jarred下面的评论，如果使用Bun运行，这将使用Node.js执行。但是对于Bun 0.1.4，它是由Bun执行的:</p><pre class="kk kl km kn gu ms lz mt mu aw mv bi"><span id="4bac" class="mw mx iu lz b gz my mz l na nb">david@nuc2:~/ws/techsparx.com$ bun -v<br/>0.1.4<br/>david@nuc2:~/ws/techsparx.com$ node ./shebang.js <br/>undefined<br/>david@nuc2:~/ws/techsparx.com$ bun ./shebang.js <br/>1</span></pre><p id="d4a1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这意味着当给Bun一个带有shebang的文件时，它将继续执行这个文件，而不是把它交给Node.js。</p><p id="b318" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">shebang特性从Berkeley Unix 4.2BSD开始就存在于Unix/Linux生态系统中。当时，我阅读了4.2BSD源代码(在20世纪80年代中期)，并了解到shebang是由内核直接处理的。它相当于一个<code class="fe lw lx ly lz b">exec</code>调用来调用shebang中命名的解释器，脚本作为标准输入。解释器应该检测并忽略第一行，并执行它在stdin中找到的任何代码。</p><p id="4fe4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Bun关注shebang然后执行Node.js是不正确的。谢天谢地，这不是它所做的。</p><p id="8539" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">顺便说一句，这里有一个你可以用shebangs做的有趣且有益的小把戏:</p><pre class="kk kl km kn gu ms lz mt mu aw mv bi"><span id="6c86" class="mw mx iu lz b gz my mz l na nb">david@nuc2:~/ws/techsparx.com$ vi shebang.sed<br/>david@nuc2:~/ws/techsparx.com$ chmod +x shebang.sed <br/>david@nuc2:~/ws/techsparx.com$ ./shebang.sed <br/>Hello World<br/>david@nuc2:~/ws/techsparx.com$ cat shebang.sed <br/>#!/usr/bin/sed 1d<br/>Hello World</span></pre><p id="8c51" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">sed程序从20世纪80年代或更早就存在了，是一种在文本流上执行文本操作的方法。本例中的shebang命令运行<code class="fe lw lx ly lz b">sed</code>,删除第一行文本。这是因为<code class="fe lw lx ly lz b">sed</code>将在<code class="fe lw lx ly lz b">stdin</code>上接收脚本，通过删除第一行，输出将不包含shebang。您可以使用这个技巧来创建一个简单的命令，只打印一些文本，比如本地比萨饼店的列表。</p><p id="c8aa" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所以…在Bun 0.1.4中，shebang不会让Node.js运行测试。为了让Jarred正确，Bun 0.1.3和更早的版本必须做到这一点。</p><p id="415c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我尝试使用Bun 0.1.4执行我的代码，遇到了大量的兼容性问题。看起来Bun此时无法执行AkashaCMS。在列出短期任务的Bun问题队列中有一个问题，这也是对Bun与Node.js不兼容的领域的承认。一个特殊的问题是返回Promise对象的<code class="fe lw lx ly lz b">fs</code>包中的函数，这在AkashaRender中广泛使用。</p><p id="d893" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这意味着当我运行下面的测试时，它是由Node.js运行的，这就是为什么结果数据显示类似的处理时间。</p><h1 id="f9a1" class="nd mx iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">简单性能测试的陷阱</h1><p id="b10f" class="pw-post-body-paragraph kz la iu lb b lc nu jv le lf nv jy lh li nw lk ll lm nx lo lp lq ny ls lt lu in bi translated">YouTube上已经有几个视频让Bun第一次尝试。我看过的每个视频都显示他们运行一些简单的命令，并说天哪，哇，这真快。</p><p id="20ee" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有一个众所周知的过分简单的性能测试的谬误。用Bun运行一个简单的脚本是否意味着它在实际应用中比Node.js快得多？这就是谬误。要验证Bun确实更快，需要比几个简单的例子更深入的测试。</p><p id="2b2d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我的想法是用一个复杂的案例来尝试Bun，测试兼容性和性能。</p><h1 id="efb6" class="nd mx iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">我对Bun的复杂测试用例</h1><p id="71c3" class="pw-post-body-paragraph kz la iu lb b lc nu jv le lf nv jy lh li nw lk ll lm nx lo lp lq ny ls lt lu in bi translated">我开发了一个静态网站生成器(AkashaCMS ),用它我建立了几个网站。其中一些相当大。例如，<code class="fe lw lx ly lz b">techsparx.com</code>有超过1600个网页——换句话说就是博客帖子。AkashaCMS支持多种模板引擎，它做服务器端的类似jQuery的DOM操作和其他一些事情。</p><p id="0ced" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在我的笔记本电脑(一台Dell Latitude E7250 w/ Core i7和16GB内存)上使用Node.js，将网站渲染为HTML并准备好部署需要大约30分钟。如果Bun实现了它的声明，那么这个时间应该会减少到10分钟？</p><p id="b2a7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有两个重要的场景:</p><ol class=""><li id="e208" class="nz oa iu lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">Bun到底能不能执行AkashaCMS？它能渲染<code class="fe lw lx ly lz b">techsparx.com</code>网站里的一切吗？</li><li id="5630" class="nz oa iu lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">Bun渲染我的网站能比用Node.js快一点吗？</li></ol><h1 id="7b95" class="nd mx iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">第一次观察</h1><p id="0216" class="pw-post-body-paragraph kz la iu lb b lc nu jv le lf nv jy lh li nw lk ll lm nx lo lp lq ny ls lt lu in bi translated">我的第一个测试不是运行AkashaCMS本身，而是执行一个与Node.js包相关的测试套件。我使用Mocha构建测试套件，不幸的是，(目前)有一些代码与Bun不兼容。一些包在寻找<code class="fe lw lx ly lz b">process</code>对象中的值来确定兼容性。Bun没有提供预期的值，Mocha使用的一些包在各种兼容性测试中崩溃。我在他们的问题队列中报告了这些问题，似乎解决方案已经在进行中。</p><p id="69e7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一个问题是Bun不支持对Github上的包的<code class="fe lw lx ly lz b">package.json</code>依赖。我把Github依赖项用于我认为不值得发布到npm的包。Bun问题队列已经注意到了这个问题。如果你和我一样，有一些没有发布到npm资源库的包，但是你直接从Github加载，那么你现在就不走运了。</p><p id="2408" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我确实发现使用npm来安装包，然后使用Bun来执行代码，工作得非常完美。Bun是"<em class="on"> beta </em>"软件… FWIW。</p><h1 id="9dae" class="nd mx iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">使用Bun渲染AkashaCMS网站</h1><p id="720f" class="pw-post-body-paragraph kz la iu lb b lc nu jv le lf nv jy lh li nw lk ll lm nx lo lp lq ny ls lt lu in bi translated">第一个测试场景Bun可以完美地呈现<code class="fe lw lx ly lz b">techsparx.com</code>网站——几乎没有任何问题。</p><p id="a15b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这个网站确实使用了几个Github依赖项。这意味着使用<code class="fe lw lx ly lz b">npm install</code>来下载依赖项。</p><p id="eda2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">通常，我使用<code class="fe lw lx ly lz b">package.json</code>中的<code class="fe lw lx ly lz b">scripts</code>条目来驱动构建过程。这是记录此类过程的一种便捷方式，我在之前的文章中讨论过:<a class="ae lv" href="https://techsparx.com/nodejs/tools/npm-build-scripts.html" rel="noopener ugc nofollow" target="_blank">如何使用npm/yarn/Node.js package.json脚本作为您的构建工具</a></p><p id="74ae" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">虽然Bun可以直接执行<code class="fe lw lx ly lz b">package.json</code>构建脚本，但是这些脚本运行<code class="fe lw lx ly lz b">akasharender</code>命令，而后者又是一个使用<code class="fe lw lx ly lz b">node</code>命令执行的脚本。相反，我手动运行这些命令:</p><pre class="kk kl km kn gu ms lz mt mu aw mv bi"><span id="beeb" class="mw mx iu lz b gz my mz l na nb">$ bun run node_modules/akasharender/cli.js -- copy-assets config.js<br/>$ bun run node_modules/akasharender/cli.js -- render config.js</span></pre><p id="c4dd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这直接执行<code class="fe lw lx ly lz b">cli.js</code>。<code class="fe lw lx ly lz b">--</code>部分是为了确保命令行参数被传递给<code class="fe lw lx ly lz b">akasharender</code>，而不是被Bun插入。第一个命令将资源文件复制到呈现的输出目录，第二个命令将网页和其他文件呈现到该目录中。</p><p id="38b0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">更新——以上不再起作用，取而代之的是从命令行中去掉<code class="fe lw lx ly lz b">run</code>。此外，Bun在v0.1.4中不能执行AkashaRender。参见上面更长的讨论。</p><p id="7111" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在Node.js中，命令行上不需要<code class="fe lw lx ly lz b">run</code>动词，也不需要<code class="fe lw lx ly lz b">--</code>标记。否则，就是同一个命令行。</p><p id="126a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">初审成功通过了。它正确地运行了AkashaCMS并渲染了<code class="fe lw lx ly lz b">techsparx.com</code>网站。</p><h1 id="3501" class="nd mx iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">首次Bun性能测试—复制资产文件</h1><p id="6b90" class="pw-post-body-paragraph kz la iu lb b lc nu jv le lf nv jy lh li nw lk ll lm nx lo lp lq ny ls lt lu in bi translated">为了理解我将给出的性能数字，对AkashaCMS有一点了解可能会有所帮助。</p><p id="7543" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">一个AkashaCMS项目有四种输入目录，<em class="on">资产</em>，<em class="on">文档</em>和两种模板目录。资产目录中的文件被简单地复制到渲染输出目录，而文档目录中的文件通过渲染过程运行。产生的输出目录包含网站作者想要的HTML/CSS/JS/Image文件的任意组合。</p><p id="cd2b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因此<code class="fe lw lx ly lz b">copy-assets</code>本质上就是这些步骤:</p><ol class=""><li id="a61c" class="nz oa iu lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">在资产目录中查找文件</li><li id="6480" class="nz oa iu lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">使用有效的文件复制操作(来自<code class="fe lw lx ly lz b">fs-extra</code>包的<code class="fe lw lx ly lz b">fs.copy</code>)</li></ol><p id="4f21" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">文件复制循环使用<code class="fe lw lx ly lz b">fastq</code>包运行多达10个同步复制操作。不尝试跳过复制已经在输出目录中的文件。</p><p id="35af" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">相比之下，<code class="fe lw lx ly lz b">render</code>命令运行渲染代码、模板引擎和一堆其他东西。</p><p id="ed13" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">测试系统是一台英特尔NUC，采用第五代酷睿i5，16GB内存，文件存储在硬盘上。</p><p id="84f5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用<code class="fe lw lx ly lz b">time</code>命令进行测量。下面的列是<em class="on"> real </em>，表示经过的时间，<em class="on"> user </em>，表示用户态代码的CPU消耗，<em class="on"> sys </em>，表示内核代码的CPU消耗。</p><p id="55b2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这些是使用Bun v0.1.2运行六次<code class="fe lw lx ly lz b">copy-assets</code>的时间。</p><pre class="kk kl km kn gu ms lz mt mu aw mv bi"><span id="cc9a" class="mw mx iu lz b gz my mz l na nb">real  0m7.326s  user  0m5.241s  sys  0m1.319s <br/>real  0m4.445s  user  0m5.277s  sys  0m1.101s <br/>real  0m4.847s  user  0m5.346s  sys  0m1.137s <br/>real  0m4.874s  user  0m5.345s  sys  0m1.217s<br/>real  0m4.847s  user  0m5.420s  sys  0m1.128s <br/>real  0m4.867s  user  0m5.472s  sys  0m1.167s</span></pre><p id="0b29" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这些是使用Node.js v18.5.0运行六次<code class="fe lw lx ly lz b">copy-assets</code>的时间</p><pre class="kk kl km kn gu ms lz mt mu aw mv bi"><span id="6688" class="mw mx iu lz b gz my mz l na nb">real  0m4.686s  user  0m5.105s  sys  0m1.279s<br/>real  0m4.549s  user  0m5.160s  sys  0m1.224s<br/>real  0m4.659s  user  0m5.246s  sys  0m1.309s<br/>real  0m4.884s  user  0m5.127s  sys  0m1.285s<br/>real  0m4.658s  user  0m5.316s  sys  0m1.148s<br/>real  0m4.968s  user  0m5.174s  sys  0m1.292s</span></pre><p id="d17a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">换句话说，结果大致相同。</p><p id="a9e2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于<code class="fe lw lx ly lz b">techsparx.com</code>，有2000多份文件要拷贝。</p><h1 id="18a2" class="nd mx iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">第二个Bun性能测试——渲染一个充满HTML文件的网站</h1><p id="ad37" class="pw-post-body-paragraph kz la iu lb b lc nu jv le lf nv jy lh li nw lk ll lm nx lo lp lq ny ls lt lu in bi translated">我们刚刚在一个大量复制文件的测试中证明了Bun并没有改进Node.js。下一步是看它如何执行更复杂的任务，将Markdown文件呈现为HTML，然后在HTML中处理模板。</p><p id="6605" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这种情况下使用的主要软件包是:</p><ul class=""><li id="ecc8" class="nz oa iu lb b lc ld lf lg li ob lm oc lq od lu oo of og oh bi translated">使用<code class="fe lw lx ly lz b">markdown-it</code> v12.x进行降价渲染</li><li id="2b4e" class="nz oa iu lb b lc oi lf oj li ok lm ol lq om lu oo of og oh bi translated">使用Cheerio v1.0.0-rc.10的服务器端DOM处理</li><li id="7422" class="nz oa iu lb b lc oi lf oj li ok lm ol lq om lu oo of og oh bi translated">混合使用EJS (v3.1.x)和Nunjucks (v3.2.x)的模板处理</li></ul><p id="24f0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">像使用<code class="fe lw lx ly lz b">copy-assets</code>命令一样，<code class="fe lw lx ly lz b">fastq</code>用于一次并行执行几个渲染。</p><p id="5a38" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用Bun v0.1.2渲染<code class="fe lw lx ly lz b">techsparx.com</code>的时间</p><pre class="kk kl km kn gu ms lz mt mu aw mv bi"><span id="2edc" class="mw mx iu lz b gz my mz l na nb">real  26m1.263s   user  25m20.973s  sys  0m27.235s<br/>real  25m50.435s  user  25m40.301s  sys  0m24.955s<br/>real  25m53.489s  user  25m58.259s  sys  0m25.791s</span></pre><p id="8405" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用Node.js v18.5.0渲染<code class="fe lw lx ly lz b">techsparx.com</code>的时间</p><pre class="kk kl km kn gu ms lz mt mu aw mv bi"><span id="ec79" class="mw mx iu lz b gz my mz l na nb">real  25m46.665s  user  25m42.305s  sys	0m26.839s<br/>real  26m6.209s   user  27m38.675s  sys	0m25.880s<br/>real  25m42.731s  user  27m29.677s  sys	0m25.977s</span></pre><p id="70d5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">至于<code class="fe lw lx ly lz b">copy-assets</code>的情况，两个平台的时间大致相同。</p><h1 id="be37" class="nd mx iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">摘要</h1><p id="102a" class="pw-post-body-paragraph kz la iu lb b lc nu jv le lf nv jy lh li nw lk ll lm nx lo lp lq ny ls lt lu in bi translated">对于这种工作负载，Bun的性能与Node.js大致相同。</p><p id="5e20" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">由于Bun团队对性能提出了很高的要求，我们必须考虑发生了什么。超越，就是认识到Bun是Beta版，可能有一两个bug。</p><p id="7357" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">显然，这不是最好的性能测试。大约20年前，我在Sun Microsystems的Java SE团队工作，并参与了一个致力于性能增强的小组。他们有一长串针对特定工作负载的测试，其中每个测试侧重于一个特定的性能测量。这样，团队可以说N版通过<code class="fe lw lx ly lz b">n%</code>提高了字符串性能。</p><p id="cb05" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">虽然运行像AkashaCMS这样的应用程序需要使用平台的很大一部分，但这并不是一个清晰的测试场景。正如今天在YouTube上发现的过于简单的Bun演示不能帮助我们理解Bun的表现一样，这个测试也不能。我看到Node.js团队中有一个基准测试团队，但是他们的工作空间已经闲置多年了。然而，我猜想他们为此开发了一套正确的测试。</p><p id="97fa" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我注意到一个包——<a class="ae lv" href="https://github.com/majimboo/node-benchmarks" rel="noopener ugc nofollow" target="_blank">https://github.com/majimboo/node-benchmarks</a>——似乎有一套在Node.js上执行的基准测试。但是，试图使用Node.js v18.5.0安装它却无法安装<code class="fe lw lx ly lz b">microtime</code>包。修补其<code class="fe lw lx ly lz b">package.json</code>以使用<code class="fe lw lx ly lz b">microtime</code> v3.1.x让测试运行，但我不知道如何解释结果。无论如何，该套件中的测试对于这个目的来说是正确的。</p><p id="c2d4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">要了解Bun是否真的比Node.js快，以及在哪些功能领域比node . js快或慢，需要适当的比较基准测试。因为两个平台的目标是执行完全相同的代码，所以可以在每个平台上运行相同的基准/性能测试来测量相对性能。</p><p id="2304" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当Ryan Dahl在2009年首次推出Node.js时，他通过展示与其他平台进行比较的性能基准，向全世界推销了它。IIRC:他的测试集中在一个有用的指标上，内存占用和每秒HTTP操作的数量。</p><p id="917d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最后，我对Bun印象深刻。这是一个新宣布的项目，旨在复制Node.js，它已经能够处理有点复杂的应用程序。</p><h1 id="fed5" class="nd mx iu bd ne nf ng nh ni nj nk nl nm ka nn kb no kd np ke nq kg nr kh ns nt bi translated">关于作者</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj op"><img src="../Images/29c63e0d83fb73abcdbba08b04567a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*cIuBBVW7NqQggPML.jpg"/></div></figure><p id="a01d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><a class="ae lv" href="https://davidherron.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iv">大卫·赫伦</strong> </a> <strong class="lb iv"> </strong>:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</p></div><div class="ab cl oq or hy os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="in io ip iq ir"><p id="490b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="on">原载于</em><a class="ae lv" href="https://techsparx.com/nodejs/bun/1st-trial.html" rel="noopener ugc nofollow" target="_blank"><em class="on">https://techsparx.com</em></a><em class="on">。</em></p></div></div>    
</body>
</html>