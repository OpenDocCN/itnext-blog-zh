<html>
<head>
<title>Managing And Refreshing Auth0 Tokens In a Vuejs Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Vuejs应用程序中管理和刷新Auth0令牌</h1>
<blockquote>原文：<a href="https://itnext.io/managing-and-refreshing-auth0-tokens-in-a-vuejs-application-65eb29c309bc?source=collection_archive---------1-----------------------#2018-03-18">https://itnext.io/managing-and-refreshing-auth0-tokens-in-a-vuejs-application-65eb29c309bc?source=collection_archive---------1-----------------------#2018-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c6fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fmanaging-and-refreshing-auth0-tokens-in-a-vuejs-application-65eb29c309bc" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn </a>上分享这篇文章</p><p id="16f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">这里讨论的原理的演示可以在【http://vue-auth0-demo.s3-website.eu-central-1.amazonaws.com】的</em>T5T7】中找到。此外，为了清楚起见，本文省略了一些细节。更完整的例子的源代码(上面的演示)，可以在<a class="ae kl" href="https://github.com/sellomkantjwa/vue-auth0-demo" rel="noopener ugc nofollow" target="_blank">【https://github.com/sellomkantjwa/vue-auth0-demo</a><em class="km">找到。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><a href="http://vue-auth0-demo.s3-website.eu-central-1.amazonaws.com/"><div class="gh gi kn"><img src="../Images/c477117525558b93030ac4b52a936da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WL6orHnMtH8KKDtUaSOA8A.png"/></div></a><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">演示</figcaption></figure><p id="6990" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用Auth0来管理您的单页面应用程序的用户，您将很快了解到在浏览器中存储<em class="km">刷新令牌</em>作为您的状态的一部分是一种糟糕的做法。这是因为刷新令牌永远不会过期，如果其中一个令牌遭到破坏，那么攻击者可以使用该单个刷新令牌无限期地刷新受害者的访问令牌，这很糟糕。</p><p id="26db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在您的应用程序中，用户不太可能连续在线超过2个小时(auth0访问令牌的默认TTL)，那么您可能会决定让令牌过期，并要求用户再次登录，以便在TTL之后继续他们的会话。我个人不赞成这种方法——想象一个场景，用户登录你的应用，使用10分钟，切换到一个新标签，过一会儿返回你的应用，开始四处点击。突然，就在会话进行到一半时，令牌过期了，出现在他们面前的是一个登录屏幕，这可不酷。让我们看看如何确保这种情况永远不会发生。</p><p id="b4df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在浏览器中使用Auth0最简单的方法是下载他们的SDK。</p><p id="c843" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用npm:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="1c4d" class="le lf iq la b gy lg lh l li lj">npm i auth0-js -SE </span></pre><p id="fa98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者在您的页面上包含脚本:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="2a8f" class="le lf iq la b gy lg lh l li lj">&lt;script src=”https://cdn.auth0.com/js/auth0/9.3.1/auth0.min.js"&gt;&lt;/script&gt;</span></pre><p id="6875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用户会话的管理并不过分复杂，可以总结如下:</p><ol class=""><li id="ecd3" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">当用户第一次登录我们的应用程序时，我们捕获并存储:<br/> * access_token(为了正确使用Auth0和Oauth，我们需要用它在我们的API/服务器上验证我们自己)<br/> * expires_in(它告诉我们离令牌过期还有多长时间)</li><li id="f023" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">我们在令牌过期前几分钟安排一个<code class="fe ly lz ma la b">setTimeout</code>来刷新令牌。</li><li id="5171" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">当用户下一次登陆我们的应用时，我们会检查他们之前是否登录过；如果他们已经过期，我们检查他们的令牌是否已经过期或即将过期，如果是这样，就将他们发送到登录页面。如果令牌尚未到期<code class="fe ly lz ma la b">&amp;&amp;</code>也未接近到期，我们就让他们进来，并计划在令牌接近到期时进行刷新。</li></ol><p id="7cbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从创建一个助手模块开始，我们将使用它来管理用户的会话。在其中，我们将实例化并导出一个新的auth0实例，我们可以在整个过程中重用它。</p><p id="2d17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km"> //session-manager.js </em></p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="9044" class="le lf iq la b gy lg lh l li lj"><em class="km">//Irrelevant code omitted for clarity</em></span><span id="a437" class="le lf iq la b gy mb lh l li lj"><strong class="la ir"> <br/>import </strong>{WebAuth} <strong class="la ir">from </strong>"auth0-js";<br/><br/><strong class="la ir">const </strong>auth0 = <strong class="la ir">new </strong>WebAuth({<br/>    responseType: "token id_token",<br/>    domain: process.env.DEMO_AUTH0_DOMAIN,<br/>    clientID: process.env.DEMO_AUTH0_CLIENT_ID,<br/>    redirectUri: "http://localhost:8080/login-callback"<br/>});</span><span id="79c8" class="le lf iq la b gy mb lh l li lj">export{auth0}</span><span id="66c4" class="le lf iq la b gy mb lh l li lj"><em class="km">//irrelevant code omitted</em></span></pre><p id="e4cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们将我们的域和clientID存储为可配置变量。如果你愿意，你可以硬编码这些。</p><p id="9ae9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是登录组件。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">登录组件</figcaption></figure><p id="baaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将看到我们在这里所做的只是调用<code class="fe ly lz ma la b">auth0.authorize()</code>，它将用户重定向到我们的Auth0托管页面，用户可以在那里登录。该页面看起来有点像这样:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi me"><img src="../Images/5355219db1ed406444ecde1ef2d93de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*HiXSFc9aENqGGyn1cC44RA.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">我们的登录页面</figcaption></figure><p id="ee9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦用户登录，他们将被重定向到我们指定的url，我们可以在那里提取和存储令牌。在上面的设置(<em class="km"> session-manager.js </em>)中，我们已经指定了URI<a class="ae kl" href="http://localhost:8080/login-callback" rel="noopener ugc nofollow" target="_blank"><em class="km">http://localhost:8080/log in-callback</em></a><em class="km"/>)(确保该url在Auth0中允许的回调URL列表中，否则整个事情都会搞砸。)</p><p id="b0d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们收集用户的令牌并将其存储在指定的重定向uri中。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">login-callback.vue</figcaption></figure><p id="ee8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们被重定向到<a class="ae kl" href="http://localhost:8080/login-callback" rel="noopener ugc nofollow" target="_blank"><em class="km">http://localhost:8080/log in-callback</em></a><em class="km">，</em>时，上面的组件被加载。它的唯一目的是收集、解析和存储返回的令牌。当auth0返回到回调url时，它将必要的令牌和有效期附加到url中的<em class="km">散列</em>中。整个url如下所示:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="ddd3" class="le lf iq la b gy lg lh l li lj"><a class="ae kl" href="http://localhost:8080/login-callback#access_token=xxxxxxxxxxxxxxxxxxxxxxxxx&amp;expires_in=7200&amp;token_type=Bearer&amp;state=lpT0Q4vX2wCKd9HlJjFSivZATph9O2eF&amp;id_token=xxxxxxxxxxxxxxxxxxxxxxxx" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/login-callback#access_token=xxxxxxxxxxxxxxxxxxxxxxxxx&amp;expires_in=7200&amp;token_type=Bearer&amp;state=xxxxxxxxxxxxxxxxx&amp;id_token=xxxxxxxxxxxxxxxxxxxxxxxx</a></span></pre><p id="f383" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<a class="ae kl" href="https://www.npmjs.com/package/query-string" rel="noopener ugc nofollow" target="_blank"> querystring </a>模块将令牌数据解析成JSON以便于处理，然后将它传递给Vuex变量，以便存储在我们的中央状态中。解析后的令牌数据如下所示:</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="d88d" class="le lf iq la b gy lg lh l li lj">{<br/>  "access_token":"xxxxxxxxxxxxxxxxx",<br/>  "expires_in":"7200",<br/>  "token_type":"Bearer",<br/>  "state":"xxxxxxxxxxxxxxxxx",<br/>  "id_token":"xxxxxxxxxxxxxx"<br/>}</span></pre><p id="41ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的Vuex商店中，我们可以将代币保存到我们的中央州和<code class="fe ly lz ma la b">localstorage</code>。我们需要将令牌保存到<code class="fe ly lz ma la b">localstorage</code>中，这样我们就可以在令牌过期之前，在页面重新加载或连续访问站点时保存它。这样，我们可以重用令牌，而不是每次点击应用程序时都要求用户登录。下面是我们的存储片段，其中我们定义了负责持久化令牌的突变。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">将令牌保存到我们的状态和本地存储</figcaption></figure><p id="f0a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，我们现在已经存储了我们的凭证，并且可以设置<em class="km"> getters </em>，这样我们就可以在需要的时候检索它们。以下是完整的商店:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="419d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们希望设置令牌刷新，以便用户不会注销活动会话，我们还希望在用户登录应用程序时正确初始化会话。让我们把所有这些逻辑扔进<em class="km"> session-manager.js. </em></p><p id="0ebd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">//session-manager.js</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="7b71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ly lz ma la b">initSession</code>功能执行以下操作:</p><ol class=""><li id="e429" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">检查我们是否有令牌到期日期，如果没有，这意味着用户从未登录。我们将用户重定向到登录页面。</li><li id="89d0" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">如果有令牌过期日期，我们会检查它是否已过期或将在接下来的10分钟内过期。如果上述任何条件为真，那么我们重定向用户登录。这10分钟只是一个缓冲，让我们自己刷新令牌。实际上，这可能是令牌到期之前的任何时间。</li><li id="3eb1" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">如果1和2不成立，那么我们知道令牌仍然有效，我们还可以使用它一段时间。此时，我们设置了一个<em class="km"> setTimeout </em>来在令牌实际到期前10分钟刷新它。</li></ol><p id="7c4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不出所料,<code class="fe ly lz ma la b">refreshToken</code>函数实际上刷新了令牌。在auth0 sdk中实现这一点的方法被称为<code class="fe ly lz ma la b">checkSession</code>，auth0如何在没有重定向的情况下实现这一点的机制可以在这里找到<a class="ae kl" href="https://auth0.com/docs/api-auth/tutorials/silent-authentication" rel="noopener ugc nofollow" target="_blank"/>—有趣的方法。刷新令牌后，我们设置了另一个超时，在它过期前10分钟再次刷新按钮。</p><p id="08d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要在应用程序加载时调用<code class="fe ly lz ma la b">initSession</code>来设置会话。最好的地方是在我们的根Vue组件App.vue中:</p><p id="930c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">//App.vue</p><pre class="ko kp kq kr gt kz la lb lc aw ld bi"><span id="8494" class="le lf iq la b gy lg lh l li lj">//<em class="km">irrelevant code omitted</em></span><span id="ce40" class="le lf iq la b gy mb lh l li lj">&lt;script&gt;<br/><br/>    <strong class="la ir">import </strong>Router <strong class="la ir">from </strong>"./router";<br/>    <strong class="la ir">import </strong>Store <strong class="la ir">from </strong>"./store";<br/>    <strong class="la ir">import </strong>{initSession} <strong class="la ir">from </strong>"./session-manager";<br/><br/>    <strong class="la ir">export default </strong>{<br/>        name: 'app',<br/>        data() {<br/>            <strong class="la ir">return </strong>{};<br/>        },<br/>        mounted() {<br/>            initSession();  //Initialize our session<br/>        },<br/>        router: Router,<br/>        store: Store<br/>    };<br/><br/><br/>&lt;/script&gt;</span><span id="e48f" class="le lf iq la b gy mb lh l li lj">//<em class="km">irrelevant code omitted</em></span></pre><p id="fd31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将让用户退出应用程序。(提示:调用Auth0 sdk的logout方法，清除令牌localstorage，并清除刷新令牌超时)</p><p id="8715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。我们现在可以确信，我们的用户会话不会被不必要的中断，并且我们不需要存储任何刷新令牌来实现这一点。</p></div></div>    
</body>
</html>