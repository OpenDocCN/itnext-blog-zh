<html>
<head>
<title>Making TensorflowJS work faster with WebWorkers.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让TensorflowJS与WebWorkers一起更快地工作。</h1>
<blockquote>原文：<a href="https://itnext.io/making-tensorflowjs-work-faster-with-webworkers-c356157a9d42?source=collection_archive---------9-----------------------#2020-02-17">https://itnext.io/making-tensorflowjs-work-faster-with-webworkers-c356157a9d42?source=collection_archive---------9-----------------------#2020-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/4b50770d8eb87d22c429e7ef3f478336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qO1GziHAonx-pW35xw-mlA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="e37b" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">提高在web应用程序中运行张量流模型的性能。</h2></div><h1 id="54ea" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">问题</h1><p id="f7dd" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">如果您曾经使用过TensorflowJS，您可能知道通过模型运行数据(尤其是图像处理)需要很长时间。因为JavaScript是单线程的，这给站点响应带来了巨大的问题。每当sth阻塞主线程，用户就无法与你的网站进行交互。你能做些什么来解决这个问题呢？答案很简单，使用WebWorker运行您的模型。</p><h1 id="f1e3" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">事件循环</h1><p id="acb5" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated"><a class="ae me" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" rel="noopener ugc nofollow" target="_blank">事件循环</a>负责执行代码，收集处理事件，执行排队的子任务。至少<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank"> MDM是这么说的</a> …</p><blockquote class="mf"><p id="2079" class="mg mh jb bd mi mj mk ml mm mn mo md dk translated">我不会花太多时间来描述它是如何工作的，但是如果你感兴趣，可以看看<a class="ae me" href="https://www.youtube.com/watch?v=cCOL7MC4Pl0" rel="noopener ugc nofollow" target="_blank"> Jake Archibald在JSConf上的演讲。亚洲</a></p></blockquote><p id="7642" class="pw-post-body-paragraph li lj jb lk b ll mp kc ln lo mq kf lq lr mr lt lu lv ms lx ly lz mt mb mc md ij bi translated">基本上每次你在JS中运行某个东西，它都阻塞了主线程。你的目标是达到60FPS(或每帧16毫秒)。这意味着如果主线程执行时间超过16ms(由于样式和布局的重新计算和打印，准确的时间会稍短)，用户会注意到“延迟”。通常，浏览器会这样做:</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/9e29302991321ccf3ab57c543ed1aa02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AW0PRqHMd6JcwyfX.png"/></div></div></figure><p id="c94d" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">还有ofc。执行代码的更好方式。你可以把它批处理成<strong class="lk jc"> requestAnimationFrame </strong>。这种方式保证了你的代码在render之前执行(Safari除外:(因为Safari很怪异)。如果你看第二帧，你会注意到有时在<strong class="lk jc"> requestAnimationFrame </strong>之外执行了一个“事件”。那次事件可能只是类似事件的一次点击，并不会真正影响到UX。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/2d37b1bc9f01042351f1dd80dd360b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w3tHQAMXYDoKZpR0.png"/></div></div></figure><h1 id="f67d" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">为什么事件循环不能处理TF模型的执行？</h1><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/bfa3076d6ecb4065c09ce461b23cb914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q5r-7F6oeyJx0MhQ.png"/></div></div></figure><p id="0762" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">通过我们的模型传递数据需要时间，很多时间。在16毫秒内完成是非常不可能的。在这种情况下，即使将其放入requestAnimationFrame也无济于事:</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/f131ac1c23ed9cd9c356da5c5be701b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_Zj4YeLMDBEYqpRV.png"/></div></div></figure><p id="0f7f" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">如果你看到这些图片，你可能会想“嗯，只是少了两帧。没什么大不了的，我们可以接受。”。如果你用小模型工作，那是真的。通常(例如图像处理)看起来像:</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/3415c9215eb1c0a7bb19be712511d8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aFc4E6sop64ov4PA.png"/></div></div></figure><p id="7743" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">如果您考虑像实时对象检测这样的应用，处理一帧至少需要65毫秒(tiny YOLOv3)。如果你用的是更精确的型号，那就更多了(标准YOLOv3是0.25秒)。你必须记住，这些数字是在你的用户可能没有的高端计算机上获得的(作为软件开发人员，很容易忘记这一点)。</p><h1 id="5b48" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">如何使用WebWorker/s修复此问题？</h1><p id="371f" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">如果我们坚持主线程仅用于执行关键工作(用户交互、应用程序逻辑等)的规则。)我们可以将一些工作(TF处理)卸载给<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener ugc nofollow" target="_blank"> WebWorker </a>。如果您不熟悉workers的概念，您可以将它们视为单独的线程(不是多线程),您可以与它们交换数据。</p><p id="5b80" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">每个工人(可能有很多人)在单独的进程中运行，所以即使你想运行需要0.25秒才能完成的函数，你也不会在这段时间阻塞主应用程序。</p><h1 id="f6cc" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">工人解决方案</h1><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/eef63564c29b34ea1ad9a7032b24f648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_wkPO_9FAXy8R6QDt_1Xkw.gif"/></div></div></figure><p id="06a9" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">让我为你剖析一下那个动画。首先，我们必须初始化web worker，但这是在制作动画之前完成的。一旦我们有了WW，我们需要为我们的模型创建输入数据。这是在第一帧的RAF(requestAnimationFrame)内部完成的。它可以是照相机图像提取等。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/8d7689fd33f6deab135b23ddd839b5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1zsEXVpNW9AqHJNsiCZIA.png"/></div></div></figure><p id="3d81" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">在WW内部，我们不关心框架。处理我们刚刚发送的数据可能需要一段时间，但没关系。那时，用户仍然可以使用网站，因为没有任何东西阻塞主线程。每次一个新的帧通过，我们都在重新打印应用程序的变化，仍然在监听来自WW的消息。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/1997f830a00a671de903bbf3217ec03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9zHghrFR8QbKH3CJ6blTw.png"/></div></div></figure><p id="3464" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">大约50毫秒后，我们的模型完成了，我们收到了来自WW的消息。英国皇家空军没有收到这条消息。我们在当前帧中处理它并更新状态，这样结果可以被下一个RAF获得。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/21bfc146029af0e1fc9970360aa15cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X44MuZ9XwdFCduYfRaOXWA.png"/></div></div></figure><p id="d54c" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">接下来，英国皇家空军认识到有来自WW的新数据，因此发送新图像以供我们的模型处理将是非常棒的。“样式”、“布局”和“打印”正在更新用户应该在屏幕上看到的内容，没有延迟。</p><p id="0ff2" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">你可能会注意到我们每64毫秒更新一次预测。这给了我们大约15FPS(这是远离流体运动)。用户可以在屏幕上看到，因为相机图像每帧更新一次，我们的预测每4帧更新一次。在等待TF处理我们的图像的这段时间里，这仍然比一个冻结的相机要好。</p><h1 id="acff" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">实施细节</h1><blockquote class="nh ni nj"><p id="2fcd" class="li lj nk lk b ll mz kc ln lo na kf lq nl nb lt lu nm nc lx ly nn nd mb mc md ij bi translated"><em class="jb">我们将使用</em><a class="ae me" href="https://github.com/developit/workerize-loader" rel="noopener ugc nofollow" target="_blank"><em class="jb">workerize-loader</em></a><em class="jb">，它可用于webpack，使它更容易与我们的WW通信。主要的区别在于，在workerize中，我们不必处理WW消息。</em></p></blockquote><p id="ad13" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">你甚至不必在主线程中加载TF，我们在那里不需要它。因为我们使用的是<strong class="lk jc"> workerize-loader </strong>，所以我们可以导出我们的async <strong class="lk jc"> getPrediction </strong>函数，并在主线程中使用它。</p><pre class="mv mw mx my gt no np nq nr aw ns bi"><span id="e21c" class="nt kr jb np b gy nu nv l nw nx">// get-predictions.worker.js</span><span id="5dd1" class="nt kr jb np b gy ny nv l nw nx">// Import TF and Model<br/>import '@tensorflow/tfjs';<br/>import * as ssd from '@tensorflow-models/coco-ssd';</span><span id="8e21" class="nt kr jb np b gy ny nv l nw nx">let net;</span><span id="48d7" class="nt kr jb np b gy ny nv l nw nx">// Load our model from the web<br/>ssd<br/>  .load({<br/>    base: 'lite_mobilenet_v2',<br/>  })<br/>  .then(model =&gt; {<br/>    net = model;<br/>  });</span><span id="49c7" class="nt kr jb np b gy ny nv l nw nx">// export function you want to call to get predictions<br/>export async function getPrediction(image) {<br/>  // check if model is loaded<br/>  // sometime you might want to handle if function returns null<br/>  if (!net) {<br/>    return null;<br/>  }</span><span id="330e" class="nt kr jb np b gy ny nv l nw nx">// run object detection<br/>  const result = await net.detect(image);<br/>  const boxes = result.map(boxInfo =&gt; [<br/>    boxInfo.bbox[0],<br/>    boxInfo.bbox[1],<br/>    boxInfo.bbox[0] + boxInfo.bbox[2],<br/>    boxInfo.bbox[1] + boxInfo.bbox[3],<br/>  ]);<br/>  const scores = result.map(boxInfo =&gt; boxInfo.score);<br/>  const classes = result.map(boxInfo =&gt; boxInfo.class);</span><span id="08e2" class="nt kr jb np b gy ny nv l nw nx">// return data we need to print our boxes<br/>  return { result, boxes, classes, scores };<br/>}</span></pre><p id="6d5d" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">在WW代码中，我们唯一要做的事情就是在worker初始化时加载一个合适的模型。getPrediction非常简单，但是我们仍然需要检查模型是否被加载，如果没有，我们可以返回null，这样主线程就知道还没有模型。</p><p id="9bf1" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">在第27行，我们用我们的图像作为输入来调用TF模型。</p><pre class="mv mw mx my gt no np nq nr aw ns bi"><span id="c3c5" class="nt kr jb np b gy nu nv l nw nx">const result = await net.detect(image);</span></pre><p id="b346" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">之后，结果被处理并以新对象的形式返回。</p><p id="bd3a" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">负责向WW发送图像的代码使用<strong class="lk jc"> navigator.mediaDevices </strong>来访问相机，然后从中获取当前帧。</p><pre class="mv mw mx my gt no np nq nr aw ns bi"><span id="7870" class="nt kr jb np b gy nu nv l nw nx">navigator.mediaDevices<br/>  .getUserMedia({<br/>    audio: false,<br/>    video: videoConstraints,<br/>  })<br/>  .then(stream =&gt; {<br/>    window.stream = stream;<br/>    webcamRef.current.srcObject = stream;<br/>    return new Promise(resolve =&gt; {<br/>      webcamRef.current.onloadedmetadata = () =&gt; {<br/>        resolve();<br/>      };<br/>    });<br/>  });</span></pre><p id="133e" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">之后，我们只需将图像发送到WW并处理响应。</p><pre class="mv mw mx my gt no np nq nr aw ns bi"><span id="e0f7" class="nt kr jb np b gy nu nv l nw nx">const predictionResults = await predict(stopDetection);</span><span id="8f4e" class="nt kr jb np b gy ny nv l nw nx">const ctx = canvasRef.current.getContext('2d');<br/>predictionResults.result.forEach(box =&gt; {<br/>  drawBoxWithLabel(box, ctx);<br/>});</span></pre><p id="444e" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">你可以在这里查看全部代码(它有很多额外的功能，但核心保持不变):<a class="ae me" href="https://github.com/burnpiro/erdem.pl/blob/master/src/components/Detector/Detector.js" rel="noopener ugc nofollow" target="_blank">https://github . com/burn piro/erdem . pl/blob/master/src/components/Detector/Detector . js</a></p><blockquote class="nh ni nj"><p id="256c" class="li lj nk lk b ll mz kc ln lo na kf lq nl nb lt lu nm nc lx ly nn nd mb mc md ij bi translated">请原谅我把所有的东西都放在一个文件里，但是我认为给一个文件的链接比在GitHub上导航更容易。</p></blockquote><p id="61fc" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated">这里还有物体检测的例子:<a class="ae me" href="https://erdem.pl/object-detection/" rel="noopener ugc nofollow" target="_blank">https://erdem.pl/object-detection/</a></p><h1 id="e4a1" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">摘要</h1><p id="02fc" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">如果你在网上处理TF，把它卸载到一个新的线程中几乎总是一个好主意。它迫使我们处理主应用程序和WW之间的通信，但在像<strong class="lk jc"> workerize、</strong>这样的加载器的帮助下，我们几乎可以像使用一个纯粹的函数一样使用它。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="cadf" class="pw-post-body-paragraph li lj jb lk b ll mz kc ln lo na kf lq lr nb lt lu lv nc lx ly lz nd mb mc md ij bi translated"><em class="nk">最初发布于</em><a class="ae me" href="https://erdem.pl/2020/02/making-tensorflow-js-work-faster-with-web-workers" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://erdem . pl</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>