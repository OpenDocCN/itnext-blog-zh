<html>
<head>
<title>RxJS: Cache and AJAX Race Conditions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS:缓存和AJAX竞争条件</h1>
<blockquote>原文：<a href="https://itnext.io/handling-cache-and-ajax-race-conditions-4cb152db8764?source=collection_archive---------3-----------------------#2018-12-12">https://itnext.io/handling-cache-and-ajax-race-conditions-4cb152db8764?source=collection_archive---------3-----------------------#2018-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c86d09e5365b863733b8086d446832d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SOUetFCSqenK-rMw"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@victoire_jonch?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Victoire Joncheray </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><div class=""><h2 id="a787" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">RxJS的“startWith”有一个秘密用例</h2></div><p id="8c9f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">我创建了一个非常酷的方法来同时使用缓存和AJAX版本的数据。</em></p><h1 id="023e" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">问题是</h1><p id="1eaf" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">当处理存储在缓存中的数据时，您希望确保数据是最新的。有很多方法可以解决这个难题，但是我提出的方法是<strong class="kx jh">首先检索缓存版本，然后检索最新版本</strong>。这样，您的应用程序可以快速地从缓存中读取数据，但是真实的数据仍然可以在后台加载。</p><p id="43fe" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了防止任何奇怪的UI问题，另一个重要的部分是只传递更新的AJAX数据。不管实现如何，这意味着您需要将缓存的版本存储在state中的某个地方，以便随时可以与返回的AJAX数据进行比较。</p><h1 id="a72e" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">承诺的方式</h1><p id="ebcb" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我第一次尝试这样的事情是在3年前，为了一个24小时的工作编码挑战。感谢一位天才建筑师帮助我思考这个问题，我能够在6个小时内完成一个工作原型。尽管如此，这仍然是一个很难解决的问题。</p><p id="e962" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当时，我只知道回调和承诺。您可能知道，承诺只发出一次值，所以我用自己的承诺处理程序逻辑包装了jQuery承诺实现，并创建了一个发出两个值的自定义承诺。然而，这对于任何人来说都是不可见的。你只需要创建一个<code class="fe mp mq mr ms b">CachedDataFetcher</code>对象，然后从那里开始。</p><p id="4e7c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我没有确切的代码，也不想泄露公司机密，所以我打算根据记忆重写API。</p><p id="72ea" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它看起来像这样:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="fde0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr"> jQuery的promise实现与官方的ECMAScript标准不同，这就是为什么这个API有一个</em> <code class="fe mp mq mr ms b"><em class="lr">done</em></code> <em class="lr">和</em> <code class="fe mp mq mr ms b"><em class="lr">error</em></code> <em class="lr">方法。</em></p><p id="3043" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mp mq mr ms b">create</code>函数是工厂模式的一部分，它返回<code class="fe mp mq mr ms b">new CachedDataFetcher()</code>你传入的任何选项。除了<code class="fe mp mq mr ms b">done</code>方法触发获取数据的承诺，而不是在<code class="fe mp mq mr ms b">fetch</code>被调用时，其他一切都与您所期望的相似。</p><p id="778e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天改写一下，以下是我对该实现的简化看法:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="28c6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">我故意没有添加错误处理逻辑，这样更容易理解。真正的实现要复杂得多。</em></p><p id="d83e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">API一般，示例和实际实现相当糟糕，但我希望你能明白我的想法。</p><p id="390e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只要您返回的东西是与普通承诺API兼容的，您就可以用<code class="fe mp mq mr ms b">CachedDataFetcher</code>轻松地切换出代码库中现有的数据调用，并且只需要最小的改动。从其他人的角度来看，这是一个正常的承诺；但它的好处是能够发出两种价值。</p><p id="7063" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我已经在observable上工作了几年，那么使用observable来输出缓存和AJAX版本的数据就更有意义了，但是当时，我是在用我所知道的东西工作。尽管这有点像谎言。我也在Knockout中使用了observables，但是由于它们与DOM绑定在一起，所以我从未想过尝试将它们用于这个特定的目的。</p><h1 id="3f68" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">随着时间的推移可观察到的</h1><p id="bd89" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在，我会在Redux-Observable epic中运行这个逻辑，并触发Redux操作。相反，我将向您展示昨晚我是如何使用带有主题的直接RxJS和令人惊奇的<code class="fe mp mq mr ms b">startWith</code>操作符解决这个问题的。谈谈隐藏的潜力！</p><p id="040d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们不能使用<code class="fe mp mq mr ms b">race</code>,因为我想要两个值。唯一的另一种方法是使用<code class="fe mp mq mr ms b">merge</code>，但是这样做的话，AJAX响应可能会在缓存响应之前先返回。你不想用坏数据覆盖好数据。</p><p id="0aee" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我如何利用<code class="fe mp mq mr ms b">startWith</code>来模仿缓存和AJAX行为的:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="de3b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，这比偷工减料的许诺少了许多行，也更容易推理，但是它是如何工作的呢？</p><p id="3711" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们从缓存中获得了我们想要的值，我们就开始我们的<code class="fe mp mq mr ms b">ajax</code> observable。当我们的<code class="fe mp mq mr ms b">switchMap</code>发生时，AJAX调用立即发生，而<code class="fe mp mq mr ms b">startWith</code>在任何东西通过管道之前首先运行。这给了我们时间来准备<code class="fe mp mq mr ms b">distinctUntilChanged</code>中的本地状态，并将缓存的值传递给我们的订户(如果它存在的话),同时保持我们的AJAX逻辑简单。</p><p id="eb53" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不会让值通过，除非它们与之前通过的值不同。这满足了我们“如果与缓存相同，就不要从AJAX更新”的要求。</p><p id="b963" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，我们的订户是一个主题。我们不是私下里做<code class="fe mp mq mr ms b">store.dispatch</code>，而是通过将主题<code class="fe mp mq mr ms b">itemList$</code>传入<code class="fe mp mq mr ms b">subscribe</code>方法来调用<code class="fe mp mq mr ms b">subject.next</code>。</p><p id="d002" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以用这种方式模仿Redux-Observable的相同功能，但是如果已经有一个实现可以为您完成所有这些工作，为什么还要编写自己的实现呢？我有一个不是很大的快速项目，所以我自己完成了它，但一般来说，我会使用一个有良好文档的已建立的库，以便未来的开发人员(包括我)可以维护它。</p><h2 id="8d20" class="mz lt jg bd lu na nb dn ly nc nd dp mc le ne nf me li ng nh mg lm ni nj mi nk bi translated">缓存和AJAX随着时间的推移</h2><p id="edd6" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">虽然这解决了3年前的原始问题，但这只是昨晚问题的一部分。我需要它来随着时间的推移更新项目列表值。这意味着我的AJAX调用需要每隔一段时间发生一次，而我的缓存值只发生一次。</p><p id="f1f7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用与前面相同的代码，解决方案很简单，只需添加<code class="fe mp mq mr ms b">interval</code>:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2cfd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mp mq mr ms b">startWith</code>的位置很重要，我们已经在同一个管道中使用了两次。这就是诀窍。</p><p id="f746" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如你可能知道的，<code class="fe mp mq mr ms b">interval</code>就像<code class="fe mp mq mr ms b">timer</code>一样，只有在计时器超时后才会触发。在这种情况下，它会在发出AJAX调用之前等待1个小时。使用<code class="fe mp mq mr ms b">startWith</code>，我们可以在订阅时立即启动AJAX调用，同时通过管道传递缓存的值！</p><p id="8f91" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我认为<code class="fe mp mq mr ms b">startWith</code>非常棒。还有<code class="fe mp mq mr ms b">endWith</code>，当一个观察完成时，它提供类似的功能。这是一个非常巧妙的技巧，以直观的方式简化了这个解决方案。</p><h1 id="570a" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果您对更多与RxJS和Redux-Observable相关的主题感兴趣，您应该看看我的其他文章:</p><ul class=""><li id="1105" class="nl nm jg kx b ky kz lb lc le nn li no lm np lq nq nr ns nt bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="c569" class="nl nm jg kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae jd" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li><li id="b18e" class="nl nm jg kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e" rel="noopener">你不应该需要从React-Redux中“连接”</a></li><li id="21e8" class="nl nm jg kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a" rel="noopener">使用Redux的秘密:createNamespaceReducer </a></li><li id="c67f" class="nl nm jg kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li></ul></div></div>    
</body>
</html>