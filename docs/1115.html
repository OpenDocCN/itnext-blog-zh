<html>
<head>
<title>DevOps Use Case: Performing Redis maintenance in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DevOps用例:在Kubernetes中执行Redis维护</h1>
<blockquote>原文：<a href="https://itnext.io/devops-use-case-performing-redis-maintenance-in-kubernetes-599910e7f649?source=collection_archive---------10-----------------------#2018-07-23">https://itnext.io/devops-use-case-performing-redis-maintenance-in-kubernetes-599910e7f649?source=collection_archive---------10-----------------------#2018-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如今，在Kubernetes集群中运行几乎任何东西都很容易。但是调试这些服务呢？如果您需要快速访问一个通常不向internet或intranet公开并且只能从集群内部访问的服务，该怎么办？你的服务就像:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/4e7e97dd539b10a1aa8b444f65d62319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*SMG-QFDIuwGsNz0P.jpg"/></div></figure><p id="05ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇短文中，我将演示如何用一个优秀而强大的<a class="ae kt" href="https://github.com/joeferner/redis-commander" rel="noopener ugc nofollow" target="_blank"> Redis Commander </a> GUI连接到一个正在运行的Redis实例。</p><h1 id="b305" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="cb2a" class="ls lt iq jp b jq lu ju lv jy lw kc lx kg ly kk lz ma mb mc bi translated">部署<a class="ae kt" href="https://webhookrelay.com/v1/examples/relay-ingress.html" rel="noopener ugc nofollow" target="_blank"> Webhook中继入口控制器</a></li><li id="d5be" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">部署<a class="ae kt" href="https://github.com/webhookrelay/k8s-redis-commander/blob/master/redis-commander.yaml" rel="noopener ugc nofollow" target="_blank"> Redis指挥官</a></li><li id="dcac" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">通过Webhook中继隧道访问Redis Commander并调试您的Redis节点</li></ul><h1 id="c797" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">先决条件</h1><p id="5923" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">您首先需要设置一些东西:</p><ul class=""><li id="e4d8" class="ls lt iq jp b jq jr ju jv jy ml kc mm kg mn kk lz ma mb mc bi translated">Kubernetes，您可以使用现有的集群，也可以使用Minikube或Docker for Mac。</li><li id="ced9" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">Webhook中继账号，在这里注册<a class="ae kt" href="https://my.webhookrelay.com/register" rel="noopener ugc nofollow" target="_blank"/></li><li id="7ccf" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated"><a class="ae kt" href="https://webhookrelay.com/v1/guide/index.html#Getting-Started" rel="noopener ugc nofollow" target="_blank"> Webhook中继CLI </a></li></ul><h1 id="6036" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">开拍！</h1><p id="db7d" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">让我们部署Redis(如果已经运行，跳过)，从<a class="ae kt" href="https://github.com/webhookrelay/k8s-redis-commander" rel="noopener ugc nofollow" target="_blank">克隆的存储库</a>部署它:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="d9fd" class="mt kv iq mp b gy mu mv l mw mx">kubectl apply -f redis.yaml</span></pre><p id="5145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将创建:</p><ul class=""><li id="26ac" class="ls lt iq jp b jq jr ju jv jy ml kc mm kg mn kk lz ma mb mc bi translated">Redis部署</li><li id="09e9" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">使Redis在集群内可访问的服务</li></ul><p id="a4bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，将我们基于隧道的入口控制器安装到您的集群中:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="025a" class="mt kv iq mp b gy mu mv l mw mx">relay ingress init</span></pre><p id="68a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该命令:</p><ul class=""><li id="7a6d" class="ls lt iq jp b jq jr ju jv jy ml kc mm kg mn kk lz ma mb mc bi translated">创建命名空间</li><li id="ba5a" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">为入口控制器创建一个认证密码以使用您的帐户</li><li id="c9e8" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">部署实际的入口控制器</li></ul><p id="9055" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过以下方式检查它是否正在运行:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="a67f" class="mt kv iq mp b gy mu mv l mw mx">$ kubectl get pods -n webrelay-ingress<br/>NAME READY STATUS RESTARTS AGE</span><span id="c35d" class="mt kv iq mp b gy my mv l mw mx">webrelay-69996f8d7c-522z8 1/1 Running 0 10s</span></pre><h1 id="58ac" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">配置Redis命令程序</h1><p id="2b6e" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">现在，在你喜欢的代码编辑器中打开<code class="fe mz na nb mp b">redis-commander.yaml</code>(我的是VSCode:)，编辑几个细节。</p><p id="6cbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你在一个自由层，不幸的是，你不能为你的隧道选择一个子域，所以你需要先创建一个。此外，如果您为Redis服务选择了不同的名称，那么更新<code class="fe mz na nb mp b">REDIS_HOSTS</code>环境变量。</p><p id="d5f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要创建隧道，请运行:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="58d1" class="mt kv iq mp b gy mu mv l mw mx">$ relay tunnel create — group webrelay-ingress hello-ingress<br/>2p4ptkh9vutgm8tqavigja.webrelay.io← →http://127.0.0.1</span></pre><p id="5d63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，将<code class="fe mz na nb mp b">2p4ptkh9vutgm8tqavigja.webrelay.io</code>复制到最后一个入口部分，并替换<code class="fe mz na nb mp b">[REPLACE THIS WITH YOUR TUNNEL NAME]</code></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="76f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成编辑后，创建它:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="01ec" class="mt kv iq mp b gy mu mv l mw mx">kubectl apply -f redis-commander.yaml</span></pre><p id="f41c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在应该可以从您的浏览器访问它了:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/7dffa34ff2203d93ed62461d75841165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fgP9befjEhRj-IJ2.png"/></div></div></figure><blockquote class="nj"><p id="c13f" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">很酷，是吗？祝你的其他实验好运！</p></blockquote><figure class="nv nw nx ny nz kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/e6a6c38f6fd98ea0c5f5b7f36720b23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*ERlztbuwEOVuvjXJ.gif"/></div></figure><h1 id="1221" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">。/wrap_up</h1><p id="a827" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">总而言之，同样的策略也可以应用于其他服务，比如Prometheus或Grafana。您可以仅在需要时创建隧道，例如，虽然Grafana始终可以连接，但当您不确定服务发现是否遗漏了什么或想要使用原始查询时，您可能只想看一眼Prometheus。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="7c28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="oh">原载于2018年7月23日</em><a class="ae kt" href="https://webhookrelay.com/blog/2018/07/23/kubernetes-redis-commander/" rel="noopener ugc nofollow" target="_blank"><em class="oh">【webhookrelay.com</em></a><em class="oh">。</em></p></div></div>    
</body>
</html>