<html>
<head>
<title>What I miss in Java, the perspective of a Kotlin developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从一个Kotlin开发者的角度来看，我在Java中错过了什么</h1>
<blockquote>原文：<a href="https://itnext.io/miss-java-kotlin-developer-2bc6a8e3539a?source=collection_archive---------0-----------------------#2022-06-13">https://itnext.io/miss-java-kotlin-developer-2bc6a8e3539a?source=collection_archive---------0-----------------------#2022-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d3a0d122d0eae62893085d0d83aecad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pFujHmq0ByhkrcPqKeFZQ.jpeg"/></div></div></figure><p id="da8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">近20年来，Java一直是我的谋生手段。几年前，我开始学习科特林语；我从未后悔过。</p><p id="1d07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然Kotlin编译成JVM字节码，但我有时不得不重新编写Java。每当我这样做的时候，我都无法停止思考为什么我的代码看起来没有Kotlin中的好。我错过了一些可以提高代码可读性、表现力和可维护性的特性。</p><p id="2e24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章并不是要抨击Java，而是列出一些我想在Java中找到的特性。</p><h1 id="4f01" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">不可变引用</h1><p id="2754" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Java从一开始就有不可变的引用:</p><ul class=""><li id="bccd" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">对于类中的属性</li><li id="2ad5" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">对于方法中的参数</li><li id="8f2c" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">对于局部变量</li></ul><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d571" class="mw kx iq ms b gy mx my l mz na">class Foo {</span><span id="4fa0" class="mw kx iq ms b gy nb my l mz na">    final Object bar = new Object();      // 1</span><span id="d084" class="mw kx iq ms b gy nb my l mz na">    void baz(final Object qux) {          // 2<br/>        final var corge = new Object();   // 3<br/>    }<br/>}</span></pre><ol class=""><li id="6f6c" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nc mf mg mh bi translated">无法重新分配<code class="fe nd ne nf ms b">bar</code></li><li id="cdd8" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv nc mf mg mh bi translated">无法重新分配<code class="fe nd ne nf ms b">qux</code></li><li id="e866" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv nc mf mg mh bi translated">无法重新分配<code class="fe nd ne nf ms b">corge</code></li></ol><p id="b068" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不可变引用对于避免讨厌的错误有很大的帮助。有趣的是，使用<code class="fe nd ne nf ms b">final</code>关键字并不普遍，即使是在广泛使用的项目中。比如Spring的<code class="fe nd ne nf ms b"><a class="ae ng" href="https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/web/filter/GenericFilterBean.java" rel="noopener ugc nofollow" target="_blank">GenericBean</a></code>使用不可变属性，但既不是不可变的方法参数，也不是局部变量；slf4j的<code class="fe nd ne nf ms b"><a class="ae ng" href="https://github.com/qos-ch/slf4j/blob/master/slf4j-api/src/main/java/org/slf4j/spi/DefaultLoggingEventBuilder.java" rel="noopener ugc nofollow" target="_blank">DefaultLoggingEventBuilder</a></code>三个都不用。</p><p id="1e0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然Java允许定义不可变的引用，但这不是强制性的。默认情况下，引用是可变的。大多数Java代码没有利用不可变引用。</p><p id="eca4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kotlin没有给你留下选择的余地:每个属性和局部变量都需要定义为<code class="fe nd ne nf ms b">val</code>或<code class="fe nd ne nf ms b">var</code>。另外，不能重新分配方法参数。</p><p id="5139" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Java关键字<code class="fe nd ne nf ms b">var</code>则完全不同。首先，它只适用于局部变量。更重要的是，它没有提供其不可变的对应物<code class="fe nd ne nf ms b">val</code>。您仍然需要添加几乎没人使用的关键字<code class="fe nd ne nf ms b">static</code>。</p><h1 id="98c4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">零安全</h1><p id="c23b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在Java中，没有办法知道一个变量是否是<code class="fe nd ne nf ms b">null</code>。明确地说，Java 8引入了<code class="fe nd ne nf ms b"><a class="ae ng" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">Optional</a></code>类型。从Java 8开始，返回一个<code class="fe nd ne nf ms b">Optional</code>意味着底层值可以是<code class="fe nd ne nf ms b">null</code>；返回另一种类型意味着它不能。</p><p id="2683" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，<code class="fe nd ne nf ms b">Optional</code>的开发者设计它只是为了返回值。对于方法参数和返回值，语言语法中没有任何内容。为了解决这个问题，一些库提供了编译时注释:</p><ul class=""><li id="888b" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><a class="ae ng" href="https://github.com/amaembo/jsr-305/tree/master/ri/src/main/java/javax/annotation" rel="noopener ugc nofollow" target="_blank"> JSR 305 </a>带注释<code class="fe nd ne nf ms b">@Nonnull</code>和<code class="fe nd ne nf ms b">@Nullable</code></li><li id="3960" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae ng" href="https://github.com/spring-projects/spring-framework/tree/main/spring-core/src/main/java/org/springframework/lang" rel="noopener ugc nofollow" target="_blank">弹簧</a>、<code class="fe nd ne nf ms b">@NonNull</code>和<code class="fe nd ne nf ms b">@Nullable</code></li><li id="06a1" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae ng" href="https://github.com/JetBrains/java-annotations/tree/master/common/src/main/java/org/jetbrains/annotations" rel="noopener ugc nofollow" target="_blank">喷射脑</a>、<code class="fe nd ne nf ms b">@NotNull</code>和<code class="fe nd ne nf ms b">@Nullable</code></li><li id="aeeb" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae ng" href="https://github.com/stephenc/findbugs-annotations/tree/master/src/main/java/edu/umd/cs/findbugs/annotations" rel="noopener ugc nofollow" target="_blank"> Findbugs </a>、<code class="fe nd ne nf ms b">@NonNull</code>和<code class="fe nd ne nf ms b">@Nullable</code></li><li id="174b" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae ng" href="https://github.com/eclipse/aspectj.eclipse.jdt.core/tree/main/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation" rel="noopener ugc nofollow" target="_blank">日食</a>、<code class="fe nd ne nf ms b">@NonNull</code>和<code class="fe nd ne nf ms b">@Nullable</code></li><li id="35ce" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">以及<a class="ae ng" href="https://github.com/typetools/checker-framework/tree/master/checker-qual/src/main/java/org/checkerframework/checker/nullness/qual" rel="noopener ugc nofollow" target="_blank">检查器框架</a>、<code class="fe nd ne nf ms b">@NonNull</code>和<code class="fe nd ne nf ms b">@Nullable</code></li></ul><p id="a19e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，一些库专注于特定的ide。此外，库之间很难兼容。有这么多可用的库，以至于StackOverflow上有人问用哪一个。由此产生的活动很能说明问题。</p><p id="f469" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，使用可空性库是可以选择的。另一方面，Kotlin要求每个类型要么可以为空，要么不可以为空。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="7918" class="mw kx iq ms b gy mx my l mz na">val nonNullable: String = computeNonNullableString()<br/>val nullable: String? = computeNullableString()</span></pre><h1 id="8e45" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">扩展功能</h1><p id="2e05" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在Java中，通过子类化来扩展一个类:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="cf81" class="mw kx iq ms b gy mx my l mz na">class Foo {}<br/>class Bar extends Bar {}</span></pre><p id="a176" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">子类化有两个主要问题。第一个问题是一些类不允许这样做:它们用关键字<code class="fe nd ne nf ms b">final</code>标记。几个广泛使用的JDK类是<code class="fe nd ne nf ms b">final</code>、<em class="nh">，例如</em>、<code class="fe nd ne nf ms b">String</code>。第二个问题是，如果一个方法在我们的控制之外返回一个类型，我们就会被这个类型所束缚，不管它是否包含我们想要的行为。</p><p id="1fe2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决上述问题，Java开发人员发明了实用程序类的概念，通常将类型<code class="fe nd ne nf ms b">XYZ</code>命名为<code class="fe nd ne nf ms b">XYZUtils</code>。实用程序类是一组带有<code class="fe nd ne nf ms b">private</code>构造函数的<code class="fe nd ne nf ms b">static</code>方法，因此它不能被实例化。这是一个美化了的名称空间，因为Java不允许类之外的方法。</p><p id="4674" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，如果某个方法在某个类型中不存在，实用程序类可以提供一个方法，该方法将该类型作为参数并执行所需的行为。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="53ef" class="mw kx iq ms b gy mx my l mz na">class StringUtils {                                          // 1</span><span id="4865" class="mw kx iq ms b gy nb my l mz na">    private StringUtils() {}                                 // 2</span><span id="c162" class="mw kx iq ms b gy nb my l mz na">    static String capitalize(String string) {                // 3<br/>        return string.substring(0, 1).toUpperCase()<br/>            + string.substring(1);                           // 4<br/>    }<br/>}</span><span id="acdb" class="mw kx iq ms b gy nb my l mz na">String string = randomString();                              // 5<br/>String capitalizedString = StringUtils.capitalize(string);   // 6</span></pre><ol class=""><li id="0221" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nc mf mg mh bi translated">实用程序类</li><li id="a6ff" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv nc mf mg mh bi translated">防止此类型的新对象的实例化</li><li id="2bc2" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv nc mf mg mh bi translated"><code class="fe nd ne nf ms b">static</code>方法</li><li id="58ad" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv nc mf mg mh bi translated">不考虑边角情况的简单大写</li><li id="e20a" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv nc mf mg mh bi translated"><code class="fe nd ne nf ms b">String</code>类型不提供大写功能</li><li id="fb3b" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv nc mf mg mh bi translated">使用一个实用程序类来考虑这种行为</li></ol><p id="3e09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，在早期，开发人员在项目内部创建了这样的类。如今，这个生态系统提供开源库，比如Apache Commons Lang或Guava。不要多此一举！</p><p id="0fb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kotlin提供了<a class="ae ng" href="https://kotlinlang.org/docs/extensions.html#extension-functions" rel="noopener ugc nofollow" target="_blank">扩展函数</a>来解决同样的问题。</p><blockquote class="ni nj nk"><p id="c88d" class="jy jz nh ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq"> Kotlin提供了用新功能扩展类或接口的能力，而不必继承类或使用设计模式，如</em> Decorator <em class="iq">。我们可以通过称为</em>扩展<em class="iq">的特殊声明来实现它。</em></p><p id="849a" class="jy jz nh ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated">例如，你可以从第三方库中为一个类或一个接口编写新的函数，但你不能修改它。这样的函数可以像它们是原始类的方法一样以通常的方式被调用。这种机制称为扩展功能<em class="iq">。</em></p><p id="f04e" class="jy jz nh ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq">要声明一个扩展函数，在它的名字前面加上一个</em>接收方<em class="iq">类型，它指的是被扩展的类型。</em></p></blockquote><p id="4df0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用扩展函数，可以将上面的代码重写为:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="edb2" class="mw kx iq ms b gy mx my l mz na">fun String.capitalize2(): String {                           // 1-2<br/>    return substring(0, 1).uppercase() + substring(1);<br/>}</span><span id="120e" class="mw kx iq ms b gy nb my l mz na">val string = randomString()<br/>val capitalizedString = string.capitalize2()                 // 3</span></pre><ol class=""><li id="9d88" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nc mf mg mh bi translated">自由浮动函数，不需要类包装</li><li id="85b4" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv nc mf mg mh bi translated"><code class="fe nd ne nf ms b">capitalize()</code>已经存在于科特林的stdlib中</li><li id="d16b" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv nc mf mg mh bi translated">调用扩展函数，好像它属于<code class="fe nd ne nf ms b">String</code>类型</li></ol><p id="e9c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意扩展函数是“静态”解析的。它们并没有真正将新的行为附加到现有的类型上；他们假装这样做。生成的字节码非常类似于(如果不是相同的话)一个Java静态方法。然而，语法要清晰得多，并且允许函数链接，这在Java的方法中是不可能的。</p><h1 id="9311" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">具体化的泛型</h1><p id="0c60" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Java的第5版带来了泛型。然而，语言设计者热衷于保持向后兼容性:Java 5 <em class="nh">字节码</em>需要与Java 5 <em class="nh">之前的字节码</em>完美地交互。这就是为什么泛型类型没有被写入生成的<em class="nh">字节码</em>中:它被称为<em class="nh">类型擦除</em>。相反的是具体化的泛型，泛型类型将被写在字节码<em class="nh">中。</em></p><p id="820a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">泛型类型仅仅是编译时的问题，会产生一些问题。例如，以下方法签名产生相同的<em class="nh">字节码</em>，因此，代码无效:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6744" class="mw kx iq ms b gy mx my l mz na">class Bag {<br/>    int compute(List&lt;Foo&gt; persons) {}<br/>    int compute(List&lt;Bar&gt; persons) {}<br/>}</span></pre><p id="0904" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个问题是如何从值容器中获取类型化的值。这里有一个春天的例子:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="873b" class="mw kx iq ms b gy mx my l mz na">public interface BeanFactory {<br/>    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType);<br/>}</span></pre><p id="2a16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开发人员添加了一个<code class="fe nd ne nf ms b">Class&lt;T&gt;</code>参数，以便能够知道方法体中的类型。如果Java已经具体化了泛型，那就没有必要了:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="baad" class="mw kx iq ms b gy mx my l mz na">public interface BeanFactory {<br/>    &lt;T&gt; T getBean();<br/>}</span></pre><p id="2dae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象一下如果科特林具体化了泛型。我们可以改变上面的设计:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="76e1" class="mw kx iq ms b gy mx my l mz na">interface BeanFactory {<br/>    fun &lt;T&gt; getBean(): T<br/>}</span></pre><p id="923b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并调用该函数:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="597c" class="mw kx iq ms b gy mx my l mz na">val factory = getBeanFactory()<br/>val anyBean = getBean&lt;Any&gt;()               // 1</span></pre><ol class=""><li id="0e78" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nc mf mg mh bi translated">具体化的泛型！</li></ol><p id="6f0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kotlin仍然需要遵守JVM规范，并与Java编译器生成的<em class="nh">字节码</em>兼容。它可以通过一个叫做内联的技巧来工作:编译器用函数体替换内联的方法调用。</p><p id="65fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是让它工作的科特林代码:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="2c2c" class="mw kx iq ms b gy mx my l mz na">inline fun &lt;reified T : Any&gt; BeanFactory.getBean(): T = getBean(T::class.java)</span></pre><h1 id="3984" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="0a8a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这篇文章中，我描述了我在Java中错过的四个Kotlin特性:不可变引用、空安全、扩展函数和具体化泛型。虽然Kotlin提供了其他很棒的特性，但这四个特性足以对Java进行大部分改进。</p><p id="d4c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，有了扩展函数和具体化的泛型，再加上一点语法上的好处，就可以很容易地设计DSL，比如Kotlin Routes和Beans DSL:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="bf27" class="mw kx iq ms b gy mx my l mz na">beans {<br/>  bean {<br/>    router {<br/>      GET("/hello") { ServerResponse.ok().body("Hello world!") }<br/>    }<br/>  }<br/>}</span></pre><p id="892d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">毫无疑问:我知道Java作为一门语言有更多的惰性需要改进，而Kotlin天生更灵活。但是，竞争是好的，两者可以互相学习。</p><p id="2f1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同时，我只在必要时才写Java，因为Kotlin已经成为我在JVM上选择的语言。</p><p id="30d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="67c1" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><a class="ae ng" href="https://kotlinlang.org/docs/basic-syntax.html#variables" rel="noopener ugc nofollow" target="_blank">变量</a></li><li id="8664" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae ng" href="https://kotlinlang.org/docs/null-safety.html" rel="noopener ugc nofollow" target="_blank">无效安全</a></li><li id="e3c7" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae ng" href="https://kotlinlang.org/docs/extensions.html#extension-functions" rel="noopener ugc nofollow" target="_blank">扩展功能</a></li><li id="7283" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae ng" href="https://kotlinlang.org/docs/inline-functions.html#reified-type-parameters" rel="noopener ugc nofollow" target="_blank">具体化类型参数</a></li></ul></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="b3a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nh">原载于</em> <a class="ae ng" href="https://blog.frankel.ch/miss-in-java-kotlin-developer/" rel="noopener ugc nofollow" target="_blank"> <em class="nh">一个Java怪胎</em></a><em class="nh">2022年6月12日</em></p></div></div>    
</body>
</html>