<html>
<head>
<title>Synchronous processing in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的同步处理</h1>
<blockquote>原文：<a href="https://itnext.io/synchronous-processing-in-swift-e6923e56a232?source=collection_archive---------1-----------------------#2019-06-27">https://itnext.io/synchronous-processing-in-swift-e6923e56a232?source=collection_archive---------1-----------------------#2019-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b327" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我最近在使用JavaScript时体验了async/await。如果我们在Swift中也能做到这一点，那该多好啊！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3c83d3668e0638167a7227fa0e6c9f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtHVaA8jNq3q0bGThsB1Ng.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">这是我们今天要实现的，实际上我不会像这样使用三元运算符…我只是想让这个片段很好地适合媒体封面图像😅</figcaption></figure><p id="481f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">提供一个异步接口，一旦抽象的网络调用完成，闭包就会被调用。我们对此都很熟悉，它鼓励我们以类似的方式编写自己的网络层。典型的网络呼叫可以定义为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">对于那些滚动条不会自动隐藏的人，我在最后留了一个空行</figcaption></figure><p id="d426" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑一个场景，您需要一个接一个地进行多个API调用，如下所示:</p><blockquote class="lx"><p id="327d" class="ly lz iq bd ma mb mc md me mf mg lq dk translated">登录后，请求最新的条款和条件。如果用户尚未接受，则显示条款和条件屏幕。否则，请转到仪表板。</p></blockquote><p id="d8ae" class="pw-post-body-paragraph kv kw iq kx b ky mh jr la lb mi ju ld le mj lg lh li mk lk ll lm ml lo lp lq ij bi translated">为了实现这一点，您将在登录API的完成闭包内调用条款和条件API。您还需要在屏幕上显示加载指示器，并处理可能出现的任何错误。最后，生成的代码可能会很长:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0763" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了冗长，我觉得还有几件事可以用更好的方式来完成:</p><ul class=""><li id="7b57" class="mm mn iq kx b ky kz lb lc le mo li mp lm mq lq mr ms mt mu bi translated"><code class="fe lr ls lt lu b">[weak self]</code>每次必须手动处理</li><li id="8388" class="mm mn iq kx b ky mv lb mw le mx li my lm mz lq mr ms mt mu bi translated">总是需要一个<code class="fe lr ls lt lu b">switch</code>来检查API调用是否成功</li><li id="f789" class="mm mn iq kx b ky mv lb mw le mx li my lm mz lq mr ms mt mu bi translated"><code class="fe lr ls lt lu b">isLoading</code>必须手动处理。当登录调用过早完成时，我们将其设置为<code class="fe lr ls lt lu b">false</code>:在某些情况下，这可能会导致加载动画在条款和条件调用开始之前重置</li><li id="7f71" class="mm mn iq kx b ky mv lb mw le mx li my lm mz lq mr ms mt mu bi translated">代码不是从上到下读的。你不能只看<code class="fe lr ls lt lu b">login(with:)</code>就说如果通话成功就会出现一个场景</li></ul><p id="e504" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">如果我们能够一个接一个地同步调用这两个API，会怎么样？</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">(假设你是用Combine或者similar来订阅isLoading。稍后将详细介绍)</figcaption></figure><p id="a35b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了上面的:</p><ul class=""><li id="6907" class="mm mn iq kx b ky kz lb lc le mo li mp lm mq lq mr ms mt mu bi translated">没有必要总是引用自己的名字</li><li id="db29" class="mm mn iq kx b ky mv lb mw le mx li my lm mz lq mr ms mt mu bi translated">所有的错误都在catch中处理——没有必要在<code class="fe lr ls lt lu b">Result&lt;Response, Error&gt;</code>上<code class="fe lr ls lt lu b">switch</code></li><li id="f0ae" class="mm mn iq kx b ky mv lb mw le mx li my lm mz lq mr ms mt mu bi translated">设置<code class="fe lr ls lt lu b">isLoading</code>标志不符合我们的重要逻辑。本质上，我们只是简单地说“当这个函数运行时显示一个负载指示器”</li><li id="0dfc" class="mm mn iq kx b ky mv lb mw le mx li my lm mz lq mr ms mt mu bi translated">代码简洁，从上到下阅读</li></ul><h1 id="8f7b" class="na nb iq bd nc nd ne nf ng nh ni nj nk jw nl jx nm jz nn ka no kc np kd nq nr bi translated">我们如何才能使这成为现实？</h1><p id="b2cb" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">我们需要做的第一件事是将<code class="fe lr ls lt lu b">URLSession.dataTask(with:completionHandler:)</code>转换成一个同步函数。如果您一直在使用Swift进行脚本编写，那么您可能之前已经这样做过了。我决定使用一个<code class="fe lr ls lt lu b">Semaphore</code>来冻结调用线程，直到任务返回值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="4ff9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您的网络代码的其余部分可以保持与平常几乎一样——额外的好处是不需要传递完成闭包！只需从函数中返回解析后的模型，并<code class="fe lr ls lt lu b">throw</code>任何出现的错误。</p><p id="c735" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，我们绝对不希望在网络操作发生时冻结主线程。我一直假设我所有的主要逻辑都将在后台运行。当按下按钮调用我的控制器*上的一个函数时，我会立即使用<a class="ae nx" href="https://gist.github.com/maxchuquimia/12fbe51a7402bf9fff4b0c87c8750755" rel="noopener ugc nofollow" target="_blank">一个我编写的简单函数</a>转移到一个新线程。<code class="fe lr ls lt lu b">async(_:)</code>存在于协议中，因此它可以将对<code class="fe lr ls lt lu b">Self</code>的弱化引用传递到闭包中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1cd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过这种方式，我知道前缀为<code class="fe lr ls lt lu b">async</code>的函数内部的所有东西都安全地运行在后台线程上。当然，将一个函数注释为<code class="fe lr ls lt lu b">@async</code>会比用相同的签名维护两个函数更好……但是我们可能需要等待另一个Swift版本来工作。</p><p id="2367" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ny">*控制器是我称之为ViewModel的对象。我觉得“视图模型”这个术语有误导性，因为“模型”通常是静态存储… </em></p><h2 id="665f" class="nz nb iq bd nc oa ob dn ng oc od dp nk le oe of nm li og oh no lm oi oj nq ok bi translated">回调主线程</h2><p id="3778" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">当然，我们不能从后台更新UI。然而，当我们切换回主线程时，有许多方法可以很好地避免代码不可读。在WWDC19之前，我实际上使用了这种模式，使用我自己的observable类型，但是现在有了<code class="fe lr ls lt lu b">Combine</code>，确保发布者的所有订阅者都通过<code class="fe lr ls lt lu b">receive(on:)</code>在主线程上得到通知变得非常简单。下一节中的示例:</p><h1 id="ec4d" class="na nb iq bd nc nd ne nf ng nh ni nj nk jw nl jx nm jz nn ka no kc np kd nq nr bi translated">把所有的放在一起</h1><p id="65b9" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">假设我们有一个超级简单的应用程序，用户按下按钮，下载并显示他们的最新消息。首先我们需要一个代表屏幕上所有内容的<code class="fe lr ls lt lu b">ViewModel</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="727f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们需要一个<code class="fe lr ls lt lu b">Controller</code>来负责下载最新的消息并显示最新的消息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们甚至可以做一些聪明的事情，当线程产生时，控制器中的async函数自动将isLoading属性设置为true，当线程终止时，将它设置回false😉</figcaption></figure><p id="febe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，<code class="fe lr ls lt lu b">ContentView</code>将自身绑定到<code class="fe lr ls lt lu b">Controller.viewModel</code>并转发按钮按下动作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="c883" class="na nb iq bd nc nd ne nf ng nh ni nj nk jw nl jx nm jz nn ka no kc np kd nq nr bi translated">真的更好吗？</h1><p id="e085" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">是的。也许吧？也许不是。当然，有一些事情需要考虑。我已经用强类型的方式解决了同时进行两个网络调用的问题<a class="ae nx" href="https://gist.github.com/maxchuquimia/12fbe51a7402bf9fff4b0c87c8750755" rel="noopener ugc nofollow" target="_blank">这里</a>，但是我确定还有其他情况我还没有遇到。值得注意的是，克里斯·拉特纳等人正在讨论异步/等待风格的操作<a class="ae nx" href="https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619" rel="noopener ugc nofollow" target="_blank"/>，所以这种语法可能很快会成为标准。</p></div></div>    
</body>
</html>