<html>
<head>
<title>Automation-friendly Software Systems and How to Build Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动化友好的软件系统以及如何构建它们</h1>
<blockquote>原文：<a href="https://itnext.io/automation-friendly-software-systems-and-how-to-build-them-7a7c5e3c1a15?source=collection_archive---------5-----------------------#2019-10-04">https://itnext.io/automation-friendly-software-systems-and-how-to-build-them-7a7c5e3c1a15?source=collection_archive---------5-----------------------#2019-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/50ad79b41a4940c7e5498a004422eae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8XsNOs5VLYO5DyEweGe5lA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="32f8" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">向更好的自动化方向设计软件系统的技巧</h2></div><figure class="kr ks kt ku gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kq"><img src="../Images/61b131af865bb6a97f3ae2a35771ebe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVRKdoTkmy3dUUPCNX7FpA.png"/></div></div></figure><h1 id="2c47" class="kv kw jb bd kx ky kz la lb lc ld le lf kh lg ki lh kk li kl lj kn lk ko ll lm bi translated">我为什么要在乎？</h1><p id="7e38" class="pw-post-body-paragraph ln lo jb lp b lq lr kc ls lt lu kf lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">一提到“自动化”，我们就会想到DevOps。在建立了一个app或服务之后，我们必须管理它的生命周期。环境设置、供应、维护、升级和退役自然会发挥作用。设计您的应用程序以更好地支持该生命周期的自动化，可以让开发运维以及您的生活变得更加轻松。</p><p id="e84b" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然而，当谈到自动化友好时，有一个更重要的角度需要考虑:让您的客户满意。在SaaS或PaaS的环境中，您的产品将是客户自己的大型系统不可或缺的组成部分。因此，上述客户需要管理你的产品的生命周期，最好是以自动化的方式。即使你认为没有自动化你也可以脱身，但对你的客户来说，情况就不同了。</p><p id="1cf9" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">本文提供了设计软件系统的指导方针，您和您的客户可以在此基础上构建良好的自动化。</p><h1 id="18c3" class="kv kw jb bd kx ky kz la lb lc ld le lf kh lg ki lh kk li kl lj kn lk ko ll lm bi translated"><strong class="ak">定义良好的自动化？</strong></h1><p id="b683" class="pw-post-body-paragraph ln lo jb lp b lq lr kc ls lt lu kf lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">并非所有的自动化都是平等的。最好的自动化，在其核心，必须是<strong class="lp jc">容易理解</strong>和<strong class="lp jc">容易修复</strong>。从自动化用户的角度来看，这可能是调整配置、修改标准CI/CD系统(例如Travis或Jenkins)中的代码片段，或者使用内部管理应用程序/仪表板的简单事情。通过拥有更多的代码(朝着图灵完整性)，你以自动化变得更加复杂为代价获得了灵活性。</p><p id="dfca" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您的自动化应该支持配置端，因为在您度假时代替您的sre、支持工程师或新开发人员更有可能是用户，而不是最初的开发人员本身。代码越多，学习曲线就越陡，从而增加了出错的可能性。</p><figure class="kr ks kt ku gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mo"><img src="../Images/fca4a8a8e31cdeab7f4e46f90719269c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kS4QTrdaFqD3BRInjo_R_w.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">复杂性和灵活性之间的权衡</figcaption></figure><p id="bffc" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">故障是不可避免的，会因为网络中断、凭证错误或仅仅是想法改变而中断您的自动化。在理想的情况下，您的自动化应该能够轻松地修复这些不受欢迎的挫折。当好的自动化失败时，修复应该像“重新运行直到成功”一样简单另一方面，糟糕的自动化会产生一堆临时状态，在重试之前必须手动清除这些状态。</p><p id="dbf9" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在我们有了一个可行的自动化度量标准，我们可以继续讨论设计的话题了。</p><h1 id="cbd0" class="kv kw jb bd kx ky kz la lb lc ld le lf kh lg ki lh kk li kl lj kn lk ko ll lm bi translated"><strong class="ak">让API存在</strong></h1><p id="82d6" class="pw-post-body-paragraph ln lo jb lp b lq lr kc ls lt lu kf lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">任何自动化友好的系统都应该有API——也就是以编程方式操作应用程序状态的方法。黄金法则:人类可以执行的任何动作都应该映射到API上。</p><h1 id="ae2b" class="kv kw jb bd kx ky kz la lb lc ld le lf kh lg ki lh kk li kl lj kn lk ko ll lm bi translated"><strong class="ak">具有协调功能的声明性API</strong></h1><p id="9262" class="pw-post-body-paragraph ln lo jb lp b lq lr kc ls lt lu kf lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">尽管拥有API是自动化的最低要求，但它们并不一定会使自动化变得更容易。然而，带有协调功能的声明式API将您的自动化带到了一个新的高度。</p><p id="e2c9" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">简而言之，声明式API关注的是“什么”(期望的状态)，而不是“如何”(状态之间的变化)。使用声明式API，用户是独裁者，他们只告诉你的系统应该处于什么状态，而命令式API则相反，用户通过命令式API充当你的系统的指挥者。虽然两者可能实现相同的结果，但它们的侧重点不同会影响用户的自动化体验。</p><p id="fabb" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">比方说，您的系统提供备份功能。声明式API将允许用户指定所需的备份状态，例如，每隔N天就有一个备份文件。您的系统会注意到这一点，并不断确保其发生(协调)。命令式API将允许用户创建一个备份作业，并让它每N天运行一次。实际上，像Puppet和Kubernetes这样的系统是声明式设计范例的典范。</p><p id="5415" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">声明式API更可取，因为它们有助于简化自动化，并自然地转换成所需状态的配置。这减少了您需要编写的代码量，并将自动化问题转化为更直接的“配置文件管理”问题。这方面有很多有效的解决方案，比如Git和GitOps。此外，声明式API通过将错误归入系统的协调逻辑来减轻失败，系统的协调逻辑能够更好地处理这些错误。自动化必须确保您的系统接收到所需的状态，并观察它如何转换到这些状态。最后，声明式API生来就是等幂的，并且可以安全地重新运行。使用命令式API，您可能会担心重新运行某些自动化任务，比如请求新的资源和生成副本，而声明式API为您的系统提供了所需资源的列表。您可以继续发送相同的列表，系统将确保该列表上的所有内容都得到满足，而不是创建重复的列表。</p><h1 id="d62d" class="kv kw jb bd kx ky kz la lb lc ld le lf kh lg ki lh kk li kl lj kn lk ko ll lm bi translated"><strong class="ak">订单减少</strong></h1><p id="8109" class="pw-post-body-paragraph ln lo jb lp b lq lr kc ls lt lu kf lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">虽然声明式API让您的系统为自动化做好了充分的准备，但是您还可以做更多的事情。</p><p id="557b" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">大多数回避声明式API的人表示，他们无法处理复杂的工作流，这些工作流需要按照一定的顺序执行一系列步骤。</p><p id="9615" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们使用一个资源创建场景作为例子。假设我们有两个API，一个用于调配存储，另一个用于创建凭据。用户必须首先调用存储API，等待API与底层基础设施进行交互，然后获取ID。然后，用户需要将该ID传递给凭据API，以便为新存储创建凭据。很难用声明式API和配置来表达这样的操作逻辑，因为它们缺乏命令式的顺序和步骤。您可以通过让人们手动配置他们想要的步骤来“欺骗”,但这只是让您的API变得必不可少。这类似于发明你自己的迷你语言，让人们用它编写代码片段。由此产生的解决方案将与任何其他必要的系统具有相同的优点和缺点。</p><figure class="kr ks kt ku gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mo"><img src="../Images/cb91b55f9c08ed7fd570bc8dfd422de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iu6CraFjMn2kSBlkMzRuXQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">资源创建示例</figcaption></figure><p id="3424" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">命令是声明式API的致命弱点。作为开发人员，您可以通过消除对订单的需求来提供帮助。以下是你可以尝试的两个技巧:</p><p id="7d81" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp jc">将订单移入您的系统</strong></p><p id="765a" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这可以通过包装命令式逻辑并将一系列API调用合并到一个更高级别的“覆盖所有”API中来实现。在我们的示例中，您的用户希望创建存储和该存储的凭据。通过将所有内容打包到一个“给我一个存储凭证”API中，您的用户只需要调用它一次，并让您的系统处理返回最终结果所需的特定步骤。</p><figure class="kr ks kt ku gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mo"><img src="../Images/010b2f1cb09c7e482a7548bcd7e6139e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFeFYNUOWoiIxha_srubSw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">使用“覆盖所有”API删除订单</figcaption></figure><p id="9cc1" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp jc">删除步骤间的依赖关系</strong></p><p id="c8e0" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">当两个步骤不再相互依赖时，命令就变得没有必要了。实现这一点的一个方法是使API更具确定性。步骤相互依赖，因为它们缺少来自其他步骤的某些信息来继续进行。回顾我们之前的示例，凭据创建必须等待资源调配，这是因为需要存储ID，而不是因为新存储准备就绪。如果我们有一个seer告诉凭证API未来的存储ID，它可以立即创建一个凭证条目(ID、用户名、密码),或者在存储准备就绪后启动一个协调循环来创建它。的确，在存储准备就绪之前，用户将无法使用凭据，但这实际上与强制解决方案的结果相同。唯一的区别是，在这种情况下，用户先进行配置，获取凭据，然后等待，而在命令式解决方案中，用户在获取凭据之前先进行配置和等待。</p><p id="b3fc" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">那你去哪里找先知呢？如果您的API结果是确定性的，那么您不需要这样做。我们通常需要一个seer来判断未来的存储ID，因为它是我们的系统在配置时生成的随机值。不需要这样，因为您可以让您的用户传入一个ID供您的系统使用。您不需要太担心用户生成的id不够唯一，因为有很多方法可以帮助实现唯一性，比如命名空间(例如，将ID设置为{username}/{user-gen-id})或者只是检查和拒绝重复的ID(例如，twitter用户名)。</p><figure class="kr ks kt ku gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mo"><img src="../Images/b0b8d7b1fbe004a0c1dccfc781e82b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sE1XtG9Vm7pqDTyzXvyEoA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">使用确定性API和对帐删除订单</figcaption></figure><p id="f38a" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">总之，确定性API将运行一系列命令性步骤转化为在等待所有部分在协调循环的帮助下收敛到期望状态之前发送一次声明性配置。</p><h1 id="09c7" class="kv kw jb bd kx ky kz la lb lc ld le lf kh lg ki lh kk li kl lj kn lk ko ll lm bi translated"><strong class="ak">奖励:创建一个CLI </strong></h1><p id="1ff9" class="pw-post-body-paragraph ln lo jb lp b lq lr kc ls lt lu kf lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">不管是不是声明性的，CLI(命令行界面)都是自动化的催化剂。它允许人们用几行脚本来自动化您的系统，而不是创建一个完整的编码项目——至少在开始时是这样。如今这是一种常见的做法，所有主要的IaaS、PaaS和SaaS服务(如AWS、Azure和IBM Cloud)都使用这种方法。感兴趣的人可以看看https://github.com/urfave/cli的<a class="ae mt" href="https://github.com/urfave/cli" rel="noopener ugc nofollow" target="_blank"/>和https://github.com/pallets/click的<a class="ae mt" href="https://github.com/pallets/click" rel="noopener ugc nofollow" target="_blank"/>这样的框架，让你在构建漂亮而专业的CLI时省去很多麻烦。</p><p id="47fa" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><em class="mu">表头图片来源:</em> <a class="ae mt" href="https://pixabay.com/users/Pexels-2286921/" rel="noopener ugc nofollow" target="_blank"> <em class="mu">像素</em></a><em class="mu">/像素</em></p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="a432" class="pw-post-body-paragraph ln lo jb lp b lq mj kc ls lt mk kf lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你喜欢这篇文章，<a class="ae mt" href="https://medium.com/@nealhu" rel="noopener">在Medium上关注我</a>！我撰写关于分布式系统和软件架构的文章，例如:</p><ul class=""><li id="8fd4" class="nc nd jb lp b lq mj lt mk lw ne ma nf me ng mi nh ni nj nk bi translated"><a class="ae mt" rel="noopener ugc nofollow" target="_blank" href="/minimalist-software-architecture-426888684e60">极简软件架构</a>。构建大规模多区域分布式系统的经验教训</li><li id="81f2" class="nc nd jb lp b lq nl lt nm lw nn ma no me np mi nh ni nj nk bi translated"><a class="ae mt" rel="noopener ugc nofollow" target="_blank" href="/before-you-use-kustomize-eaa9529cdd19">使用Kustomize之前</a>。流行的Kubernetes配置管理工具Kustomize的优缺点</li></ul></div></div>    
</body>
</html>