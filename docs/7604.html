<html>
<head>
<title>Create Upsert Yourself for Amazon Redshift Databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自己的亚马逊红移数据库</h1>
<blockquote>原文：<a href="https://itnext.io/create-upsert-yourself-for-amazon-redshift-databases-a46ad8cce120?source=collection_archive---------3-----------------------#2022-11-20">https://itnext.io/create-upsert-yourself-for-amazon-redshift-databases-a46ad8cce120?source=collection_archive---------3-----------------------#2022-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e3cf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有了单独的临时表，在PostgreSQL中插入和更新数据就变得简单了。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/45f82fcdb526e199754bceed707523aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*DHmcRZIHLYf2Wg0t.jpg"/></div></figure><h1 id="6de1" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">介绍</h1><p id="7a13" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我喜欢在创业公司工作的一个原因是，我可以和公司里各种各样的人一起工作，还可以解决有趣的问题。几个月前，营销团队致力于改进我们的分析报告，并希望将数据存储在我们的Amazon Redshift数据库中，以便用于构建更详细的报告。</p><p id="a2e3" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">虽然如果所有数据都是全新的，这通常是一个相对简单的SQL请求，但有一点让它变得有点棘手，那就是我需要更新数据表中的某些行并插入新行。通常，我会使用一条<code class="fe mg mh mi mj b">UPSERT</code> SQL语句来同时做这两件事，但是Redshift不支持<code class="fe mg mh mi mj b">UPSERT</code>语句，所以我不得不更有创造性地手动实现这一点。通过一些研究和大量测试，我了解到通过使用一个临时数据表和几个SQL语句串在一起是可能的，并且没有我想象的那么复杂。</p><p id="7710" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">让我们看看如何在基于PostgreSQL的Amazon Redshift数据库中创建我们自己版本的</strong> <code class="fe mg mh mi mj b"><strong class="lh ir">UPSERT</strong></code> <strong class="lh ir"> SQL语句，更新已经存在的数据并添加新数据。</strong></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="aaf7" class="kn ko iq bd kp kq mr ks kt ku ms kw kx jw mt jx kz jz mu ka lb kc mv kd ld le bi translated">亚马逊红移</h1><p id="2428" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae mw" href="https://docs.aws.amazon.com/redshift/latest/dg/c_redshift-sql.html" rel="noopener ugc nofollow" target="_blank"> Redshift </a>是亚马逊网络服务基于PostgreSQL的云数据仓库，增加了管理超大型数据集和支持这些数据的高性能分析和报告的功能。</p><blockquote class="mx my mz"><p id="a834" class="lf lg na lh b li mb jr lk ll mc ju ln nb md lq lr nc me lu lv nd mf ly lz ma ij bi translated"><em class="iq">它类似于谷歌的BigQuery或微软的Azure云数据仓库，如果你过去使用过其中任何一个的话。</em></p></blockquote><p id="7601" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">尽管Redshift是基于PostgreSQL的，但它也有一些不同之处，其中之一就是缺少T4功能。</p><h2 id="bde0" class="ne ko iq bd kp nf ng dn kt nh ni dp kx lo nj nk kz ls nl nm lb lw nn no ld np bi translated">没有内置的升级功能</h2><p id="c7e8" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">亚马逊很乐意承认这个缺点，并建议使用一个<a class="ae mw" href="https://docs.aws.amazon.com/redshift/latest/dg/c_best-practices-upsert.html" rel="noopener ugc nofollow" target="_blank">暂存表来执行合并</a>。这听起来很有道理，但是关于如何做到这一点的AWS文档有点少。</p><p id="daec" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">所以在我弄明白之后，我想分享一下，每一步都有代码示例。我们开始吧。</p><h1 id="a1e2" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">创建您自己的UPSERT</h1><blockquote class="mx my mz"><p id="95da" class="lf lg na lh b li mb jr lk ll mc ju ln nb md lq lr nc me lu lv nd mf ly lz ma ij bi translated"><strong class="lh ir"> <em class="iq">注意:</em> </strong> <em class="iq">本教程假设您熟悉基本的SQL语法。如果您希望参考本文中的任何命令，我建议您查看</em> <a class="ae mw" href="https://docs.aws.amazon.com/redshift/latest/dg/c_SQL_commands.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">红移SQL命令文档</em> </a> <em class="iq">。</em></p></blockquote><p id="8227" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">如果没有本地的，我们就自己做。有多种方法可以重新创建<code class="fe mg mh mi mj b">UPSERT</code>,但是我选择的方法实际上是删除生产表中与临时表中的行匹配的所有现有行，然后将临时表中的所有数据插入生产表中。</p><p id="ca10" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这听起来很复杂(因为它有点复杂)，但是一旦过程中的每一步都被分解了，就没那么糟糕了。</p><p id="9235" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">对于本文，我将建立一个表(USER_UPDATES ),它是一个虚构的USERS表的副本。在USER_UPDATES中，我将修改表中的一些现有数据(更新)，并在表中创建一些新数据(插入)，然后我们将把新修改的数据更新到USERS表中。</p><p id="cbc9" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">前提数据修改设置</strong></p><pre class="kg kh ki kj gt nq mj nr bn ns nt bi"><span id="fee0" class="nu ko iq mj b be nv nw l nx ny">-- Create a sample table as a copy of the fake USERS table <br/><br/>CREATE TABLE user_updates AS<br/>SELECT * FROM users;<br/><br/>-- Change every third row so we have updated users<br/><br/>UPDATE user_updates<br/>SET <br/>    firstname = upper(firstname),<br/>    lastname = upper(lastname),<br/>    lastseen = '2022-11-13'<br/>AND mod(userid, 3) = 0;;<br/><br/>-- Add some new rows of users so we have insert examples <br/>-- This example creates a duplicate of every fifth row of user data<br/><br/>INSERT INTO user_updates<br/>SELECT <br/>      (userid + 127) AS userid, <br/>      firstname, <br/>      lastname, <br/>      getdate() AS lastseen,<br/>FROM user_updates<br/>AND mod(userid, 5) = 0;</span></pre><p id="9a0d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">现在已经有了一些更新的用户数据，是时候将它添加回USERS表中了，同时确保已经在表中的用户数据被覆盖和更新，并添加新的用户数据。</p><p id="7038" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir"> 1。制作暂存表</strong></p><p id="1b0c" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们需要做的第一件事是编写一个SQL命令来创建一个临时表，它是数据最终将被写入的生产表的精确副本。</p><pre class="kg kh ki kj gt nq mj nr bn ns nt bi"><span id="4707" class="nu ko iq mj b be nv nw l nx ny">-- Create temporary table that's a duplicate of the production users table<br/><br/>CREATE TEMP TABLE temp_users (LIKE users);</span></pre><p id="fdd6" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">创建一个临时表与在SQL中创建一个常规表几乎是一样的(只需添加<code class="fe mg mh mi mj b">TEMP</code>)，我们不必详细列出每一列，只需使用<code class="fe mg mh mi mj b">LIKE &lt;table_name&gt;</code>告诉SQL将这个表的列作为它最终要添加数据的表的副本。</p><p id="09fb" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir"> 2。将新数据插入临时表</strong></p><p id="f79c" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">现在已经创建了临时表，可以将先决条件设置步骤中修改过的数据插入到临时表中了。在这个INSERT语句中，我们将从USER_UPDATES表中获取所有数据，并将其插入临时的TEMP_USERS表中。</p><pre class="kg kh ki kj gt nq mj nr bn ns nt bi"><span id="f1eb" class="nu ko iq mj b be nv nw l nx ny">-- Take all the data from the user_updates table and insert it into the temporary table<br/><br/>INSERT INTO temp_users<br/>SELECT<br/>       userid,<br/>       firstname,<br/>       lastname,<br/>       lastseen,<br/>FROM user_updates;</span></pre><p id="bfdd" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">这里，来自USER_UPDATES的所有数据暂时放在TEMP_USERS表中。</p><p id="2aa0" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir"> 3。开始交易</strong></p><p id="d718" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">一个<strong class="lh ir">事务</strong>是在数据库中完成的一个工作单元——工作可以是从创建表到删除表的任何事情。这里发生的事务将从生产表用户中删除特定的用户数据行(这些用户是在临时表中更新了数据的现有用户)，然后将他们的新数据添加到表中。</p><pre class="kg kh ki kj gt nq mj nr bn ns nt bi"><span id="a173" class="nu ko iq mj b be nv nw l nx ny">-- Start the work of deleting existing user data from the table and adding the new data instead<br/><br/>BEGIN TRANSACTION;</span></pre><p id="1049" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">关于PostgreSQL中的事务，只要执行成功，就会在语句结束时隐式执行提交。如果执行失败，则执行回滚。这变得特别方便，因为如果新用户数据未能添加到USERS表中，它将回滚并自动将旧用户数据替换回表中。</p><p id="d14c" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir"> 4。删除永久表中需要用新数据替换的行</strong></p><p id="2ca2" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">一旦事务开始，要做的第一件事就是从永久表(USERS)中删除所有用户ID与TEMP_USERS表中的用户ID相匹配的行。</p><pre class="kg kh ki kj gt nq mj nr bn ns nt bi"><span id="e07d" class="nu ko iq mj b be nv nw l nx ny">-- Delete the users from the database whose data needs to be updated<br/><br/>DELETE FROM users <br/>USING <br/>    temp_users <br/>WHERE users.userid = temp_users.userid;</span></pre><p id="58ab" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">首先，通过这样做<code class="fe mg mh mi mj b">DELETE</code>,我们确保当新数据被添加到USERS表中时，不会有重复的用户数据。</p><p id="69d8" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir"> 5。将临时表中的所有数据插入永久表</strong></p><p id="95ad" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">现在可以安全地将TEMP_USERS表中的所有内容插入到USERS表中，而不用担心复制现有的用户数据。</p><pre class="kg kh ki kj gt nq mj nr bn ns nt bi"><span id="7905" class="nu ko iq mj b be nv nw l nx ny">-- Add all the user data from the temp table to the prod table <br/><br/>INSERT INTO users<br/>SELECT * FROM temp_users;</span></pre><p id="e582" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir"> 6。结束交易</strong></p><p id="fe6b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">一旦事务的所有部分都成功完成，它就可以像开始一样结束。</p><pre class="kg kh ki kj gt nq mj nr bn ns nt bi"><span id="85c6" class="nu ko iq mj b be nv nw l nx ny">-- End the work<br/><br/>END TRANSACTION;</span></pre><p id="612b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">现在还有最后一件事要做:稍微清理一下。</p><p id="da97" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir"> 7。删除临时表</strong></p><p id="6f63" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">最后，因为TEMP_USERS表已经完成了它的工作，不再需要它，所以它被丢弃(删除)。</p><pre class="kg kh ki kj gt nq mj nr bn ns nt bi"><span id="2760" class="nu ko iq mj b be nv nw l nx ny">-- Delete the temporary table now that its job is done<br/><br/>DROP TABLE temp_users;</span></pre><p id="5bf9" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">一旦每个步骤都被分解并解释清楚，创造我们自己的<code class="fe mg mh mi mj b">UPSERT</code>也不是那么糟糕。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="88c3" class="kn ko iq bd kp kq mr ks kt ku ms kw kx jw mt jx kz jz mu ka lb kc mv kd ld le bi translated">结论</h1><p id="eb0e" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Amazon Redshift是一个流行、强大的数据仓库，但即使它基于PostgreSQL，它也缺少一些更好的功能，如<code class="fe mg mh mi mj b">UPSERT</code>，这正是我需要帮助一个团队工作的功能。</p><p id="c680" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">因为我需要用新信息更新数据表，并更新该表中的现有数据，所以我需要比简单的SQL <code class="fe mg mh mi mj b">INSERT</code>更多的东西。幸运的是，借助一个临时表和几个有针对性的<code class="fe mg mh mi mj b">DELETE</code>和<code class="fe mg mh mi mj b">INSERT</code>查询，创建<code class="fe mg mh mi mj b">UPSERT</code>功能并没有我想象的那么困难。不算太寒酸。</p><p id="dd2f" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">过几周再来看看——我会写更多关于JavaScript、React、IoT或其他与web开发相关的东西。</p><p id="7ac9" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">如果你想确保你不会错过我写的一篇文章，在这里注册我的时事通讯:<a class="ae mw" href="https://paigeniedringhaus.substack.com/" rel="noopener ugc nofollow" target="_blank">https://paigeniedringhaus.substack.com</a></p><p id="560a" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">感谢阅读。我希望看到如何创建自己的SQL <code class="fe mg mh mi mj b">UPSERT</code>函数对您有所帮助。这可能不是第一次也不是最后一次需要向表中插入和更新数据，最好有一些如何最好地完成它的选项。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d3a5" class="kn ko iq bd kp kq mr ks kt ku ms kw kx jw mt jx kz jz mu ka lb kc mv kd ld le bi translated">参考资料和更多资源</h1><ul class=""><li id="a1b1" class="nz oa iq lh b li lj ll lm lo ob ls oc lw od ma oe of og oh bi translated"><a class="ae mw" href="https://docs.aws.amazon.com/redshift/latest/dg/t_updating-inserting-using-staging-tables-.html" rel="noopener ugc nofollow" target="_blank"> AWS红移文档，更新并插入新数据</a></li><li id="32be" class="nz oa iq lh b li oi ll oj lo ok ls ol lw om ma oe of og oh bi translated"><a class="ae mw" href="https://docs.aws.amazon.com/redshift/latest/dg/c_redshift-and-postgres-sql.html" rel="noopener ugc nofollow" target="_blank"> AWS红移文档、亚马逊红移和PostgreSQL </a></li><li id="1fb8" class="nz oa iq lh b li oi ll oj lo ok ls ol lw om ma oe of og oh bi translated"><a class="ae mw" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a></li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="d172" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><em class="na">原载于</em><a class="ae mw" href="https://www.paigeniedringhaus.com/blog/create-upsert-yourself-for-amazon-redshift-databases" rel="noopener ugc nofollow" target="_blank"><em class="na">https://www.paigeniedringhaus.com</em></a><em class="na">。</em></p></div></div>    
</body>
</html>