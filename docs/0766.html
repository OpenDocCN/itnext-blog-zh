<html>
<head>
<title>Building RESTful Web APIs with Dart, Aqueduct, and PostgreSQL — Part 3: Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Dart、Aqueduct和PostgreSQL构建RESTful Web APIs第3部分:Postgres</h1>
<blockquote>原文：<a href="https://itnext.io/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-3-postgres-90ff70742675?source=collection_archive---------4-----------------------#2018-05-23">https://itnext.io/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-3-postgres-90ff70742675?source=collection_archive---------4-----------------------#2018-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/06e8bbde0c96f1f6bf784142ca15afc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZOMxFZ3wwPS9yd0OYUPHg.jpeg"/></div></div></figure><div class=""/></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="ceb4" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh jc"> <em class="ld">请注意:从Dart 2开始，导水管的API发生了变化，导致了突破性的变化。本文基于Dart v1的Aqueduct 2.5.0。</em> </strong></p><p id="004e" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh jc"> <em class="ld">我已经更新了这个作为新的视频系列:</em></strong><a class="ae le" href="http://bit.ly/aqueduct-tutorial" rel="noopener ugc nofollow" target="_blank"><strong class="kh jc"><em class="ld">http://bit.ly/aqueduct-tutorial</em></strong></a></p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="cc02" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在第2部分中，我们实现了一个具有CRUD功能的“/books”路径，作为我们的<em class="ld">favoreads</em>阅读列表应用程序的一部分，已经查看了Aqueduct的<em class="ld">路由器</em>和<em class="ld">http controller</em>。最终的解决方案留给我们完整的路由(*\0/*)和一个充当我们的数据存储的<code class="fe lf lg lh li b">List</code>类型。</p><p id="1584" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">本文是系列文章的一部分，涵盖:</p><ul class=""><li id="7fd4" class="lj lk jb kh b ki kj km kn kq ll ku lm ky ln lc lo lp lq lr bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-3cc9b931f777"> <strong class="kh jc">第1部分:设置并运行示例</strong> </a></li><li id="0e57" class="lj lk jb kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-2-routing-with-crud-operations-629fe58114fa"> <strong class="kh jc">第二部分:用CRUD操作实现路由</strong> </a></li><li id="1742" class="lj lk jb kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated"><strong class="kh jc">第3部分:将Web APIs连接到PostgreSQL数据库</strong> ( <em class="ld">我们到了)</em></li><li id="c038" class="lj lk jb kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-4-testing-de3618515639"> <strong class="kh jc">第4部分:编写自动化测试</strong> </a></li><li id="a653" class="lj lk jb kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-bonus-content-2fc086b7259a"><strong class="kh jc">*奖金内容* </strong> <em class="ld"> </em> DB迁移和模型关系</a></li></ul><p id="cd56" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在这一部分中，我们将使用PostgreSQL数据库替换列表，从而允许我们持久保存发送给API的信息。我们将使用内置的ORM来帮助解决这个问题。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="833a" class="lx ly jb bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">1.设置PostgreSQL服务器</h1><p id="3a60" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">我推荐在Mac上安装<a class="ae le" href="https://postgresapp.com" rel="noopener ugc nofollow" target="_blank"> Postgres.app </a>，因为这是最简单的方法，或者使用<a class="ae le" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank">官方下载页面</a>获得其他选项/平台。</p><p id="484a" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">一旦服务器运行，使用它的命令行工具(<code class="fe lf lg lh li b">psql</code>)创建您的数据库和一个可以使用下面的SQL命令访问它的用户:</p><pre class="na nb nc nd gt ne li nf ng aw nh bi"><span id="d469" class="ni ly jb li b gy nj nk l nl nm">CREATE DATABASE <strong class="li jc">fave_reads</strong>;<br/>CREATE USER <strong class="li jc">dartuser</strong>;<br/>ALTER USER dartuser WITH password '<strong class="li jc">dbpass123</strong>';<br/>GRANT all ON database fave_reads TO dartuser;</span></pre><p id="5c8e" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><em class="ld">如果您正在使用Postgresapp，您可以通过单击窗口中显示的任何数据库图标来打开此命令行工具。</em></p><h1 id="8af3" class="lx ly jb bd lz ma nn mc md me no mg mh mi np mk ml mm nq mo mp mq nr ms mt mu bi translated">2.重构Book类</h1><p id="6639" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">为了给我们的数据库提供正确的模型，我们需要扩展<code class="fe lf lg lh li b">ManagedObject&lt;T&gt;</code>类。托管对象处理数据库行到应用程序对象的转换，反之亦然。</p><p id="fa14" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">将<code class="fe lf lg lh li b">lib/model/book.dart</code>中的<code class="fe lf lg lh li b">Book</code>型号修改如下:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7e7f" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们的数据库列将基于在<code class="fe lf lg lh li b">_Book</code>中定义的属性。<code class="fe lf lg lh li b">id</code>属性被标记为每一列的主键，用<code class="fe lf lg lh li b">@managedPrimaryKey</code>表示。我们每增加一本新书，它就会自动增加。</p><p id="dc20" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae le" href="https://aqueduct.io/docs/db/modeling_data/" rel="noopener ugc nofollow" target="_blank"> <em class="ld">了解有关数据建模的更多信息</em> </a></p><h1 id="4d7c" class="lx ly jb bd lz ma nn mc md me no mg mh mi np mk ml mm nq mo mp mq nr ms mt mu bi translated">3.创建ManagedContext</h1><p id="6b8d" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">为了将我们的应用程序绑定到数据库，它需要:</p><ul class=""><li id="518c" class="lj lk jb kh b ki kj km kn kq ll ku lm ky ln lc lo lp lq lr bi translated">维护数据库连接</li><li id="7bf5" class="lj lk jb kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated">执行数据库查询，以及</li><li id="41cf" class="lj lk jb kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated">将数据库行的结果转换为应用程序对象</li></ul><p id="f560" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这就是<code class="fe lf lg lh li b">ManagedContext</code>的用武之地！正是如此。</p><p id="2ad9" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">修改<code class="fe lf lg lh li b">FaveReadsSink</code>构造函数，如下所示:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e044" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们加载我们的模型，配置我们的数据库连接，并将它们作为依赖项传递，从而创建我们的托管上下文。这个托管上下文是在静态属性<code class="fe lf lg lh li b">defaultContext</code>下设置的，在与我们的数据库交互期间<code class="fe lf lg lh li b">Query&lt;T&gt;</code>对象将需要这个属性(稍后将详细介绍)。</p><h1 id="9c39" class="lx ly jb bd lz ma nn mc md me no mg mh mi np mk ml mm nq mo mp mq nr ms mt mu bi translated">4.构建我们的数据库模式</h1><p id="d05c" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">为此，我们将使用一个模式构建器。它将采用我们的数据模型和Postgres连接，并从中创建我们的数据库表。为了使用它，让我们在我们的<code class="fe lf lg lh li b">FaveReadsSink</code>类中定义一个名为<code class="fe lf lg lh li b">createDatabaseSchema</code>的方法:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5ad0" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">生成了许多SQL命令，这些命令在<code class="fe lf lg lh li b">for</code>循环中执行。在<code class="fe lf lg lh li b">willOpen</code>方法中，让我们触发这个操作:</p><pre class="na nb nc nd gt ne li nf ng aw nh bi"><span id="f175" class="ni ly jb li b gy nj nk l nl nm">@override<br/>Future willOpen() async {<br/>  try {<br/>    <strong class="li jc">await createDatabaseSchema(</strong>ManagedContext.defaultContext<strong class="li jc">)</strong>;<br/>  } catch (e) {}<br/>}</span></pre><p id="d3b8" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在应用程序准备好接收请求之前，将创建模式。try/catch块用于防止由于模式已经存在而第二次引发异常，从而退出进程。<em class="ld">可能有更好的方法来做这件事，所以我让你自己来玩这个</em>😉</p><p id="800e" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们现在应该能够重新启动我们的应用程序，并且应该仍然运行。只需确保您的PostgreSQL服务器处于活动状态。</p><p id="2bfb" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">最后，让我们重构我们的<code class="fe lf lg lh li b">BooksController</code>来与这个数据库通信。</p><h1 id="2dc9" class="lx ly jb bd lz ma nn mc md me no mg mh mi np mk ml mm nq mo mp mq nr ms mt mu bi translated">5.重构我们的BooksController类</h1><p id="d968" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">与数据库对话包括创建查询对象和调用方法来创建、读取、更新和删除数据。这些查询对象来自于<code class="fe lf lg lh li b">Query&lt;T&gt;</code>类的实例，其中<code class="fe lf lg lh li b">T</code>代表我们的模型:</p><pre class="na nb nc nd gt ne li nf ng aw nh bi"><span id="390c" class="ni ly jb li b gy nj nk l nl nm">// Example:<br/>// Build your query<br/>var query = <strong class="li jc">new Query&lt;Book&gt;</strong>()<br/>  ..<strong class="li jc">values</strong>.name = ‘Book name’<br/>  ..<strong class="li jc">values</strong>.author = ‘John Smith’<br/>  ..<strong class="li jc">values</strong>.year = 2016;</span><span id="dd94" class="ni ly jb li b gy nu nk l nl nm">// Execute query<br/>var result = await query<strong class="li jc">.insert();</strong></span></pre><p id="14f2" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe lf lg lh li b">Query&lt;Book&gt;</code>对象的<code class="fe lf lg lh li b">values</code>属性被设置为一个托管对象的实例，在本例中是<code class="fe lf lg lh li b">Book</code>。可用的CRUD方法包括<code class="fe lf lg lh li b">insert</code>(创建)<code class="fe lf lg lh li b">fetch</code>(读取)<code class="fe lf lg lh li b">update</code>和<code class="fe lf lg lh li b">delete</code>。</p><p id="8034" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">让我们修改<code class="fe lf lg lh li b">getAllBooks</code> responder方法，从我们的数据库中读取:</p><pre class="na nb nc nd gt ne li nf ng aw nh bi"><span id="7263" class="ni ly jb li b gy nj nk l nl nm">@httpGet<br/>Future&lt;Response&gt; getAllBooks() async {<br/>  var query = <strong class="li jc">new Query&lt;Book&gt;</strong>();<br/>  return new Response.ok(<strong class="li jc">await query.fetch()</strong>);<br/>}</span></pre><p id="3469" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">并将<code class="fe lf lg lh li b">getBook</code> responder方法修改如下:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b74e" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">查询对象使用<code class="fe lf lg lh li b">where</code>属性，它也是<code class="fe lf lg lh li b">Book</code>的一个实例。这允许我们对数据进行过滤。同一行的<code class="fe lf lg lh li b">whereEqualTo</code>功能是渡槽自带的匹配器功能之一。上面将执行以下SQL查询:</p><pre class="na nb nc nd gt ne li nf ng aw nh bi"><span id="13e0" class="ni ly jb li b gy nj nk l nl nm"><strong class="li jc">SELECT</strong> (id, name, author, year) <strong class="li jc">FROM</strong> _book <strong class="li jc">WHERE</strong> id = "&lt;idx&gt;"</span></pre><p id="ea9d" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这里是完全更新的<code class="fe lf lg lh li b">BooksController</code>和各种查询方法:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="41c5" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">重启应用程序并用<a class="ae le" href="https://www.getpostman.com/apps" rel="noopener ugc nofollow" target="_blank"> Postman </a>进行测试。</p><h1 id="391b" class="lx ly jb bd lz ma nn mc md me no mg mh mi np mk ml mm nq mo mp mq nr ms mt mu bi translated">结论</h1><p id="8ac0" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">就后端而言，我们现在有了一个完全工作的API。在第4部分中，我们将编写一些测试。</p><p id="e970" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我鼓励你浏览下面的进一步阅读材料，以完全掌握我们所涉及的一些概念。一如既往，<strong class="kh jc">我喜欢反馈</strong>。让我知道你喜欢什么，不喜欢什么，以及你接下来想看什么。我真的很感激。</p><p id="244a" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">本系列的第3部分到此结束。源代码<a class="ae le" href="https://github.com/graphicbeacon/favereads" rel="noopener ugc nofollow" target="_blank">在github </a>上可用<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-4-testing-de3618515639"> Part 4 </a>现在也可用。如果您喜欢这篇文章，请喜欢并关注我。</p><h1 id="bc67" class="lx ly jb bd lz ma nn mc md me no mg mh mi np mk ml mm nq mo mp mq nr ms mt mu bi translated">进一步阅读</h1><ol class=""><li id="bc62" class="lj lk jb kh b ki mv km mw kq nv ku nw ky nx lc ny lp lq lr bi translated"><a class="ae le" href="https://aqueduct.io/docs/db/overview/" rel="noopener ugc nofollow" target="_blank">渡槽数据库概述</a></li><li id="aa95" class="lj lk jb kh b ki ls km lt kq lu ku lv ky lw lc ny lp lq lr bi translated"><a class="ae le" href="https://aqueduct.io/docs/snippets/orm/" rel="noopener ugc nofollow" target="_blank">渡槽槽身片段</a></li><li id="4d9f" class="lj lk jb kh b ki ls km lt kq lu ku lv ky lw lc ny lp lq lr bi translated">被管理对象&lt; T &gt;类文档</li><li id="b539" class="lj lk jb kh b ki ls km lt kq lu ku lv ky lw lc ny lp lq lr bi translated"><a class="ae le" href="https://www.dartdocs.org/documentation/aqueduct/latest/aqueduct/ManagedContext-class.html" rel="noopener ugc nofollow" target="_blank"> ManagedContext类文档</a></li></ol></div></div>    
</body>
</html>