<html>
<head>
<title>Parallel Mandelbrot Set Using Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Golang的并行Mandelbrot集</h1>
<blockquote>原文：<a href="https://itnext.io/parallel-mandelbrot-set-using-golang-6d59b593829a?source=collection_archive---------1-----------------------#2021-06-18">https://itnext.io/parallel-mandelbrot-set-using-golang-6d59b593829a?source=collection_archive---------1-----------------------#2021-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cb1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章解释了如何使用Golang <em class="kl"> goroutines </em>并行生成Mandelbrot集合。</p><p id="2df8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的源代码:<a class="ae km" href="https://github.com/GiselaMD/parallel-mandelbrot-go" rel="noopener ugc nofollow" target="_blank">https://github.com/GiselaMD/parallel-mandelbrot-go</a></p><h1 id="fd36" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">曼德尔布罗集合</h1><p id="230e" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">对于那些对什么是曼德尔布罗特集感兴趣的人来说，去看看https://en.wikipedia.org/wiki/Mandelbrot_set</p><p id="6f59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设定公式基于<strong class="jp ir"> x </strong>和<strong class="jp ir"> y </strong>坐标的位置:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="82c0" class="lz ko iq lv b gy ma mb l mc md">x = x*x — y*y + a<br/>y = 2*x*y + b</span></pre><p id="539f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还检查<code class="fe me mf mg lv b">x*x + y*y &gt; 4</code>是否设置了颜色。</p><p id="47ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我不想讨论数学细节，我想解释一下我们如何使用<em class="kl"> goroutines </em>在屏幕上呈现Mandelbrot集合。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="2d0c" class="kn ko iq bd kp kq mo ks kt ku mp kw kx ky mq la lb lc mr le lf lg ms li lj lk bi translated">进入代码</h1><p id="8009" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">该程序基于将影响Mandelbrot集合的性能和分辨率的4个主要值。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="f737" class="lz ko iq lv b gy ma mb l mc md">maxIter = 1000<br/>samples = 200</span><span id="d578" class="lz ko iq lv b gy mt mb l mc md">numBlocks = 64<br/>numThreads = 16</span></pre><ul class=""><li id="beef" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated"><code class="fe me mf mg lv b">maxIter</code>定义Mandelbrot公式将被计算多少次，产生<code class="fe me mf mg lv b">x</code>和<code class="fe me mf mg lv b">y</code>值。</li><li id="d8f4" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated"><code class="fe me mf mg lv b">samples</code>是生成RGB颜色值的交互次数。</li><li id="0fab" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated"><code class="fe me mf mg lv b">numBlock</code>是将图像分成多少块。</li><li id="17a8" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated"><code class="fe me mf mg lv b">numThreads</code>是将要创建的<em class="kl"> goroutines </em>的数量。</li></ul><p id="d2cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在屏幕上渲染结果，我使用了像素库(<a class="ae km" href="https://github.com/faiface/pixel" rel="noopener ugc nofollow" target="_blank">github.com/faiface/pixel</a>)。在主函数上我们有这样的东西:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="472f" class="lz ko iq lv b gy ma mb l mc md">func main() {<br/>    pixelgl.Run(run)<br/>}</span></pre><p id="08f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用<code class="fe me mf mg lv b">pixelgl.Run</code>将PixelGL置于主函数的控制之下，我们再也无法在主函数中运行任何代码。这就是为什么我们需要在<code class="fe me mf mg lv b">pixelgl.Run</code>内部传递另一个函数，也就是<code class="fe me mf mg lv b">run</code>函数。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="457a" class="lz ko iq lv b gy ma mb l mc md">func run() {<br/>    log.Println("Initial processing...")<br/>    pixelCount = 0<br/>    img = image.NewRGBA(image.Rect(0, 0, imgWidth, imgHeight))<br/>    cfg := pixelgl.WindowConfig{<br/>        Title:  "Parallel Mandelbrot in Go",<br/>        Bounds: pixel.R(0, 0, imgWidth, imgHeight),<br/>        VSync:  true,<br/>    }<br/><br/>    win, err := pixelgl.NewWindow(cfg)<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>    log.Println("Rendering...")<br/>    start := time.Now()<br/>    workBuffer := make(chan WorkItem, numBlocks)<br/>    threadBuffer := make(chan bool, numThreads)<br/>    drawBuffer := make(chan Pix, pixelTotal)<br/><br/>    workBufferInit(workBuffer)<br/>    go workersInit(drawBuffer, workBuffer, threadBuffer)<br/>    go drawThread(drawBuffer, win)<br/><br/>    for !win.Closed() {<br/>        pic := pixel.PictureDataFromImage(img)<br/>        sprite := pixel.NewSprite(pic, pic.Bounds())<br/>        sprite.Draw(win, pixel.IM.Moved(win.Bounds().Center()))<br/>        win.Update()<br/><br/>        if showProgress {<br/>            fmt.Printf("\r%d/%d (%d%%)", pixelCount, pixelTotal, int(100*(float64(pixelCount)/float64(pixelTotal))))<br/>        }<br/><br/>        if pixelCount == pixelTotal {<br/>            end := time.Now()<br/>            fmt.Println("\nFinished with time = ", end.Sub(start))<br/>            pixelCount++<br/><br/>            if closeOnEnd {<br/>                break<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="571c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg lv b">run</code>函数负责初始化和更新窗口，以及创建将用于我们的<em class="kl"> goroutines </em>的通道。</p><p id="89ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg lv b">workBuffer</code>是负责添加各块信息的通道(基于<code class="fe me mf mg lv b">numBlocks</code>)。在<code class="fe me mf mg lv b">workBufferInit</code>内部，初始和最终的<code class="fe me mf mg lv b">x</code>和<code class="fe me mf mg lv b">y</code>值被发送到通道，这样每个<em class="kl"> goroutines </em>就可以计算颜色，而不需要知道全局数据，只需要知道那个块的<code class="fe me mf mg lv b">x</code>和<code class="fe me mf mg lv b">y</code>的范围。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="a390" class="lz ko iq lv b gy ma mb l mc md">func workBufferInit(workBuffer chan WorkItem) {<br/>    var sqrt = int(math.Sqrt(numBlocks))<br/><br/>    for i := sqrt - 1; i &gt;= 0; i-- {<br/>        for j := 0; j &lt; sqrt; j++ {<br/>            workBuffer &lt;- WorkItem{<br/>                initialX: i * (imgWidth / sqrt),<br/>                finalX:   (i + 1) * (imgWidth / sqrt),<br/>                initialY: j * (imgHeight / sqrt),<br/>                finalY:   (j + 1) * (imgHeight / sqrt),<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="0634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg lv b">threadBuffer</code>负责基于<code class="fe me mf mg lv b">numThreads</code>创建<em class="kl"> goroutines </em>并控制<em class="kl"> goroutine </em>何时完成其工作，以便我们可以在它的位置运行另一个。那里面的逻辑<code class="fe me mf mg lv b">workersInit</code> <em class="kl"> goroutine </em>。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="d0d1" class="lz ko iq lv b gy ma mb l mc md">func workersInit(drawBuffer chan Pix, workBuffer chan WorkItem, threadBuffer chan bool) {<br/>    for i := 1; i &lt;= numThreads; i++ {<br/>        threadBuffer &lt;- true<br/>    }<br/><br/>    for range threadBuffer {<br/>        workItem := &lt;-workBuffer<br/><br/>        go workerThread(workItem, drawBuffer, threadBuffer)<br/>    }<br/>}</span></pre><p id="f6b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们从<code class="fe me mf mg lv b">workBuffer</code>(每个块)接收的每个<code class="fe me mf mg lv b">workItem</code>，我们创建一个名为<code class="fe me mf mg lv b">workerThread</code>的<em class="kl"> goroutine </em>来处理所有的Mandelbrot集合逻辑。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="ab73" class="lz ko iq lv b gy ma mb l mc md">func workerThread(workItem WorkItem, drawBuffer chan Pix, threadBuffer chan bool) {<br/>    for x := workItem.initialX; x &lt; workItem.finalX; x++ {<br/>        for y := workItem.initialY; y &lt; workItem.finalY; y++ {<br/>            var colorR, colorG, colorB int<br/>            for k := 0; k &lt; samples; k++ {<br/>                a := height*ratio*((float64(x)+RandFloat64())/float64(imgWidth)) + posX<br/>                b := height*((float64(y)+RandFloat64())/float64(imgHeight)) + posY<br/>                c := pixelColor(mandelbrotIteraction(a, b, maxIter))<br/>                colorR += int(c.R)<br/>                colorG += int(c.G)<br/>                colorB += int(c.B)<br/>            }<br/>            var cr, cg, cb uint8<br/>            cr = uint8(float64(colorR) / float64(samples))<br/>            cg = uint8(float64(colorG) / float64(samples))<br/>            cb = uint8(float64(colorB) / float64(samples))<br/><br/>            drawBuffer &lt;- Pix{<br/>                x, y, cr, cg, cb,<br/>            }<br/><br/>        }<br/>    }<br/>    threadBuffer &lt;- true<br/>}</span><span id="e410" class="lz ko iq lv b gy mt mb l mc md">func mandelbrotIteraction(a, b float64, maxIter int) (float64, int) {<br/>    var x, y, xx, yy, xy float64<br/><br/>    for i := 0; i &lt; maxIter; i++ {<br/>        xx, yy, xy = x*x, y*y, x*y<br/>        if xx+yy &gt; 4 {<br/>            return xx + yy, i<br/>        }<br/>        // xn+1 = x^2 - y^2 + a<br/>        x = xx - yy + a<br/>        // yn+1 = 2xy + b<br/>        y = 2*xy + b<br/>    }<br/><br/>    return xx + yy, maxIter<br/>}<br/><br/>func pixelColor(r float64, iter int) color.RGBA {<br/>    insideSet := color.RGBA{R: 0, G: 0, B: 0, A: 255}<br/><br/>    // check if it's inside the set<br/>    if r &gt; 4 {<br/>        // return hslToRGB(float64(0.70)-float64(iter)/3500*r, 1, 0.5)<br/>        return hslToRGB(float64(iter)/100*r, 1, 0.5)<br/>    }<br/><br/>    return insideSet<br/>}</span></pre><p id="ca13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg lv b">drawBuffer</code>是从正在计算Mandelbrot集合的<em class="kl">go routine</em>接收值的通道，一旦接收到数据，<code class="fe me mf mg lv b">drawThread</code> <em class="kl"> goroutine </em>将像素RGB值设置到图像中，然后<code class="fe me mf mg lv b">run</code>函数更新窗口。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="0800" class="lz ko iq lv b gy ma mb l mc md">func drawThread(drawBuffer chan Pix, win *pixelgl.Window) {<br/>    for i := range drawBuffer {<br/>        img.SetRGBA(i.x, i.y, color.RGBA{R: i.cr, G: i.cg, B: i.cb, A: 255})<br/>        pixelCount++<br/>    }<br/>}</span></pre><p id="30e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还有一些实用程序函数，用于生成随机数据并将<em class="kl"> hsl </em>和<em class="kl">色调</em>转换为<em class="kl"> RGB </em>:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="780e" class="lz ko iq lv b gy ma mb l mc md">var randState = uint64(time.Now().UnixNano())<br/><br/>func RandUint64() uint64 {<br/>    randState = ((randState ^ (randState &lt;&lt; 13)) ^ (randState &gt;&gt; 7)) ^ (randState &lt;&lt; 17)<br/>    return randState<br/>}<br/><br/>func RandFloat64() float64 {<br/>    return float64(RandUint64() / 2) / (1 &lt;&lt; 63)<br/>}<br/><br/>func hueToRGB(p, q, t float64) float64 {<br/>    if t &lt; 0 { t += 1 }<br/>    if t &gt; 1 { t -= 1 }<br/>    switch {<br/>    case t &lt; 1.0 / 6.0:<br/>        return p + (q - p) * 6 * t<br/>    case t &lt; 1.0 / 2.0:<br/>        return q<br/>    case t &lt; 2.0 / 3.0:<br/>        return p + (q - p) * (2.0 / 3.0 - t) * 6<br/>    default:<br/>        return p<br/>    }<br/>}<br/><br/>func hslToRGB(h, s, l float64) color.RGBA {<br/>    var r, g, b float64<br/>    if s == 0 {<br/>        r, g, b = l, l, l<br/>    } else {<br/>        var q, p float64<br/>        if l &lt; 0.5 {<br/>            q = l * (1 + s)<br/>        } else {<br/>            q = l + s - l * s<br/>        }<br/>        p = 2 * l - q<br/>        r = hueToRGB(p, q, h + 1.0 / 3.0)<br/>        g = hueToRGB(p, q, h)<br/>        b = hueToRGB(p, q, h - 1.0 / 3.0)<br/>    }<br/>    return color.RGBA{ R: uint8(r * 255), G: uint8(g * 255), B: uint8(b * 255), A: 255 }<br/>}</span></pre><p id="56d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终结果:</p><figure class="lq lr ls lt gt nj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f1f301c340f76d131acd95868fd65c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*5HBQAtYjW7QY1LudLTQ9RA.gif"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">并行Mandelbrot执行</figcaption></figure><figure class="lq lr ls lt gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/71904ffff82499e2fdd4d621ec3a2852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BvKRQF_wU-ab6Bt_ikotLQ.png"/></div></div></figure><p id="09b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长话短说:随着<em class="kl"> goroutines </em>工作的完成，新的工作被实例化，并继续处理这些块，直到整个图像呈现在屏幕上。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="4ccb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天到此为止！</p><p id="688a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望你喜欢它😊</p><p id="02bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🇧🇷这篇文章也有葡萄牙语版本，由参与这个项目的丹尼尔发表。查看他的帖子:<a class="ae km" href="https://danielferreiradev.medium.com/fractal-de-mandelbrot-paralelo-usando-golang-4ba497d9bbc5" rel="noopener">https://danielferreiradev . medium . com/fractal-de-Mandelbrot-parallelo-usando-golang-4ba 497d 9 bb C5</a></p><p id="799b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的源代码:【https://github.com/GiselaMD/parallel-mandelbrot-go T42】</p></div></div>    
</body>
</html>