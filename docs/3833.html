<html>
<head>
<title>Code coverage tools can cause unexpected Java Out of Memory errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码覆盖工具会导致意外的Java内存不足错误</h1>
<blockquote>原文：<a href="https://itnext.io/code-coverage-tools-can-cause-unexpected-java-out-of-memory-errors-c6932882bff0?source=collection_archive---------2-----------------------#2020-03-06">https://itnext.io/code-coverage-tools-can-cause-unexpected-java-out-of-memory-errors-c6932882bff0?source=collection_archive---------2-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="25d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我最近开始使用Jython，以便在Java虚拟机(JVM)中为Delphix的一个项目执行Python代码。对于那些不熟悉<a class="ae ko" href="https://www.jython.org/" rel="noopener ugc nofollow" target="_blank"> Jython </a>的人来说，这是一个基于JVM的Python实现。可以将Python源代码编译成Java字节码，在JVM中执行。当我们开始使用Jython时，一切都很顺利…直到我们开始对我们的产品进行功能测试。每隔一次测试运行都会遇到<code class="fe kp kq kr ks b">java.lang.OutOfMemoryError: Metaspace</code>错误。继续阅读，找出原因。</p><p id="eb71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Jython很容易。这就像为Jython解释器生成一个Java包装器的实例一样简单，并且您已经准备好执行任意Python代码了。在我们的项目中，我们创建了一个沙箱，这样代码就不能执行任何恶意的系统调用。作为沙盒的一部分，我们导入了大约50个客户可以利用的白名单模块。每个模块都被编译成一个类文件。这意味着对于Jython解释器对象的一个实例，我们必须加载大约50个新的Java类。值得一提的是，在我们最初的设计中，我们有多个运行不同代码的Jython解释器。我们用一个单元测试对代码进行了压力测试，这个单元测试将并行创建数百个Jython解释器并执行一些Python代码。我们从未遇到过任何问题。然而，一旦我们开始对我们的产品进行功能测试，我们就开始非常频繁地遇到<code class="fe kp kq kr ks b">java.lang.OutOfMemoryError: Metaspace</code>。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/de3d8e63f91f7c33a20a3f0ceb742d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xUTdmo9gvs-L_roA"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">java.lang.OutOfMemoryError:元空间堆栈跟踪</figcaption></figure><p id="55d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回顾一下，元空间是Java进程中包含类元数据的区域。在Java 8之前，元空间位于堆上，但是从Java 8开始，它从堆中移出，进入本机内存。默认情况下，元空间只受JVM进程可用的本机内存量的限制，但实际上，您应该将其限制在适合您的应用程序的大小(这需要一些调整和实验)。您可以使用名为<code class="fe kp kq kr ks b">MaxMetaspaceSize</code>的JVM标志来限制元空间的大小。如果不限制元空间，您可能直到很久以后才注意到内存泄漏(可能在生产环境中)。</p><p id="3f88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Java 8之前:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/46077c223a542a1436446cd1d8719cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/0*agAPUlrNhcibaaes"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">来源:<a class="ae ko" href="https://www.blogger.com/profile/15415177669352479825" rel="noopener ugc nofollow" target="_blank">Pardeep Kumar</a>via<a class="ae ko" href="http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html" rel="noopener ugc nofollow" target="_blank">Java-latte</a>【1】</figcaption></figure><p id="4a12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从Java 8开始</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lk"><img src="../Images/1b4a19afadf84f6e563bb6a3f26122e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bj9dMtR96jcicacr"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">来源:<a class="ae ko" href="https://www.blogger.com/profile/15415177669352479825" rel="noopener ugc nofollow" target="_blank">帕迪普·库马尔</a> via <a class="ae ko" href="http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html" rel="noopener ugc nofollow" target="_blank">爪哇咖啡</a> [1]</figcaption></figure><p id="3cfb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有几个原因可能会导致内存不足元空间错误。最常见的有:</p><ul class=""><li id="f18e" class="ll lm it js b jt ju jx jy kb ln kf lo kj lp kn lq lr ls lt bi translated">加载的类太多</li><li id="2d19" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn lq lr ls lt bi translated">加载了重复的类</li><li id="2b91" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn lq lr ls lt bi translated">大班</li><li id="aebb" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn lq lr ls lt bi translated">类加载器泄漏</li></ul><p id="63b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当发生元空间错误时，调查的第一步是查看JVM进程生成的堆转储。为了研究堆转储，我一直使用Eclipse MAT(内存分析工具)。我首先使用了“重复类”特性来查看一些类是否会被加载很多次，而没有什么好的理由。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/87a059c0606f955e10b8a0980c719a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e9KH_e8cX2MQzd0I"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">使用Eclipse MAT查找重复的类</figcaption></figure><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/fbd49a7a679e15222885ec35d652ac49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/0*JGWqO3xAVhyYXw0r"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">对应于Python模块的类的多个副本</figcaption></figure><p id="ed74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看上面的图片，你马上会发现有很多Java类的名字都是以<code class="fe kp kq kr ks b">$py</code>结尾的。这些课很多都有差不多20本！查看Eclipse MAT中的线程概述，只有少数线程执行Python代码。这意味着Jython解释器对象要么没有被垃圾收集器清理掉，要么清理得非常慢。现在让我们看看哪些对象阻止了这些类被垃圾收集。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/e0a906000ead7158ef46e8a9444f2911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6r9OCCCZt-0dKjSs"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">寻找重复类的GC根</figcaption></figure><p id="3d33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过合并到垃圾收集器根的最短路径，我们看到大多数阻止这些类被清理的引用都来自系统终结器。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/a65fc4a0161975c8ff004a252aee4e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C9Im1JruPLDXS8rv"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">大多数重复的类都由终结器引用</figcaption></figure><p id="9114" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提醒一下，所有实现了<code class="fe kp kq kr ks b">finalize()</code>方法的对象在被垃圾收集之前都会排队。有一个后台终结器线程运行并执行每个对象的<code class="fe kp kq kr ks b">finalize()</code>方法。只有这样，垃圾收集器才能释放与这些对象相关联的内存。正如Brian Goetz在关于“垃圾收集和性能”的文章中所指出的[2]:</p><blockquote class="ma mb mc"><p id="9539" class="jq jr md js b jt ju jv jw jx jy jz ka me kc kd ke mf kg kh ki mg kk kl km kn im bi translated">在可终结对象被回收之前，至少需要两个垃圾回收周期(最好的情况)。</p></blockquote><p id="69da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，Eclipse MAT允许您通过显示“Finalizer Overview”来查看哪些对象正在队列中等待被终结。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/d73eca491c7ca74632f42a5cfc382f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GHmjB0CQQP2LL7DT"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">终结器概述显示哪些对象正在等待终结</figcaption></figure><p id="0cee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我看到超过587k个Jython对象(<code class="fe kp kq kr ks b">org.python.*</code>)等待终结时，“终结器概述”令人惊讶。可以看到<code class="fe kp kq kr ks b">PythonTree</code>、<code class="fe kp kq kr ks b">PyString</code>、<code class="fe kp kq kr ks b">PyStringMap</code>等。正在等待终结器线程。我深入Jython源代码，注意到这些类都没有实现<code class="fe kp kq kr ks b">finalize()</code>方法。然而，事实证明它们都从<code class="fe kp kq kr ks b">PyObject</code>继承了<code class="fe kp kq kr ks b">finalize()</code>方法，这似乎是Java中任何Python对象的表示。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/f7006e5eb10cd78fc1038c2caa45a47f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/0*Img7-0JjCVAWVij7"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">等待终结器线程的大多数对象都是Jython对象</figcaption></figure><p id="9454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有趣的是，<code class="fe kp kq kr ks b">PyObject</code>的<code class="fe kp kq kr ks b">finalize()</code>方法是空的，但是它包含了一个注释，为进一步的研究提供了一些线索。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mi"><img src="../Images/77fbf807248c1c76b089b7c2e168aa00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aICYzJE_EG5jx-9Y"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated"><a class="ae ko" href="https://github.com/jythontools/jython/blob/master/src/org/python/core/PyObject.java#L130" rel="noopener ugc nofollow" target="_blank">PyObject.java源代码</a></figcaption></figure><p id="9bbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Jython代码期望空的<code class="fe kp kq kr ks b">finalize()</code>方法被优化掉。这在compile team中显然不会发生，因为我尝试了一个实验，用空的<code class="fe kp kq kr ks b">finalize()</code>方法编译一个Java类，反编译后它仍然存在。这意味着空的<code class="fe kp kq kr ks b">finalize()</code>方法必须在运行时被实时(JIT)编译器优化掉。显然，在我们运行功能测试的JVM中，情况并非如此。这让我想到，也许我们的一个JVM标志(我们有很多这样的标志)阻止了JIT编译器优化空的finalize方法。我阅读了我们传递给JVM进程的所有标志，将它们与Oracle文档和一些开发人员的博客进行了交叉引用，但没有猜到哪个标志可能有问题。因此，我决定设计一个小实验来帮助我找到罪犯。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mj"><img src="../Images/fe3e57f7d25c6cdd746bc657b93de9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zhhpScNMqC5f6Exp"/></div></div></figure><p id="f768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该实验基于以下想法:</p><ol class=""><li id="960a" class="ll lm it js b jt ju jx jy kb ln kf lo kj lp kn mk lr ls lt bi translated">编译具有空<code class="fe kp kq kr ks b">finalize()</code>方法的<code class="fe kp kq kr ks b">EmptyFinalize</code>类的源代码(在上面的截图中)。</li><li id="7077" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn mk lr ls lt bi translated">使用我们在测试虚拟机上运行的功能测试中使用的所有标志(除了一个标志)启动JVM进程。</li><li id="8ad2" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn mk lr ls lt bi translated">创建一个<code class="fe kp kq kr ks b">EmptyFinalize</code>的实例。</li><li id="a9b6" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn mk lr ls lt bi translated">进入无限循环。</li><li id="24d6" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn mk lr ls lt bi translated">采取堆转储。</li><li id="2977" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn mk lr ls lt bi translated">验证系统终结器在<code class="fe kp kq kr ks b">EmptyFinalize</code>对象的垃圾收集器根中(空的<code class="fe kp kq kr ks b">finalize()</code>方法没有被优化掉)。</li><li id="3c2c" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn mk lr ls lt bi translated">重复直到第6点。不是真的。</li></ol><p id="cb8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过漫长而乏味的过程后，我找到了导致JIT编译器不优化空<code class="fe kp kq kr ks b">finalize()</code>方法的标志:</p><pre class="ku kv kw kx gt ml ks mm mn aw mo bi"><span id="4834" class="mp mq it ks b gy mr ms l mt mu">-javaagent:/lib/org.jacoco/org.jacoco.agent-0.8.5.jar</span></pre><p id="891f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当时，我不知道什么是<a class="ae ko" href="https://www.eclemma.org/jacoco/" rel="noopener ugc nofollow" target="_blank"> JaCoCo </a>。经过一些快速的研究，我发现它是我们在功能和单元测试运行中用来测量代码覆盖率的工具。也就是说，上面的标志只在测试虚拟机上的测试运行期间传递给我们的JVM进程。这解释了为什么我从来没有能够在本地重现这个问题！现在，为什么JaCoCo会阻止JIT完成它的工作呢？JaCoCo对Java进程做了什么？<a class="ae ko" href="https://www.jacoco.org/jacoco/trunk/doc/implementation.html" rel="noopener ugc nofollow" target="_blank">JaCoCo文档</a>揭示了这个问题:</p><blockquote class="ma mb mc"><p id="d140" class="jq jr md js b jt ju jv jw jx jy jz ka me kc kd ke mf kg kh ki mg kk kl km kn im bi translated">**覆盖分析机制* *</p><p id="09bc" class="jq jr md js b jt ju jv jw jx jy jz ka me kc kd ke mf kg kh ki mg kk kl km kn im bi translated">覆盖率信息必须在运行时收集。为此，JaCoCo创建了原始类定义的测试版本。在使用所谓的Java代理加载类的过程中，插装过程是动态进行的。</p><p id="4268" class="jq jr md js b jt ju jv jw jx jy jz ka me kc kd ke mf kg kh ki mg kk kl km kn im bi translated">**字节代码操作* *</p><p id="f943" class="jq jr md js b jt ju jv jw jx jy jz ka me kc kd ke mf kg kh ki mg kk kl km kn im bi translated">插装需要修改和生成Java字节代码的机制。JaCoCo在内部使用ASM库来实现这个目的。</p></blockquote><p id="bac9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自然，对于JaCoCo来说，要测量代码覆盖率，它需要在运行时检测Java字节码。空的<code class="fe kp kq kr ks b">finalize()</code>方法不会被优化掉，因为它们从来都不是空的！如果我使用相同的Java字节码操作库(<a class="ae ko" href="https://asm.ow2.io/" rel="noopener ugc nofollow" target="_blank"> ASM </a>)来检查Jython对象的字节码，而这些对象的<code class="fe kp kq kr ks b">finalize()</code>方法应该被优化掉，我可能会注意到这一点。</p><p id="4c0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个故事的寓意是什么？我注意到，在我们的测试运行中，我们将JaCoCo代理传递给我们的JVM进程，而没有指定要检测哪些Java包来测量代码覆盖率。这意味着我们最终要检测项目所有(许多)依赖项的字节码！<a class="ae ko" href="https://www.eclemma.org/jacoco/trunk/doc/agent.html" rel="noopener ugc nofollow" target="_blank"> JaCoCo Java代理允许您传递标志来排除或包含您想要为</a>创建代码覆盖的包。这个故事的寓意是，您应该只为您自己的代码而不是第三方依赖来度量代码覆盖率，这可以通过将<code class="fe kp kq kr ks b">includes=com.your.package.name.*</code>标志传递给JaCoCO代理来完成。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><ol class=""><li id="399b" class="ll lm it js b jt ju jx jy kb ln kf lo kj lp kn mk lr ls lt bi translated">帕迪普·库马尔。(2020年2月25日)。<em class="md">Java 8中的Metaspace</em><a class="ae ko" href="http://java-latte.blogspot.com/2014/03/metaspace-in-java-8.html" rel="noopener ugc nofollow" target="_blank">http://Java-latte . blogspot . com/2014/03/Metaspace-in-Java-8 . html</a></li><li id="a731" class="ll lm it js b jt lu jx lv kb lw kf lx kj ly kn mk lr ls lt bi translated">布莱恩·戈茨。(2020年2月25日)。<em class="md">垃圾收集与性能</em><a class="ae ko" href="https://www.ibm.com/developerworks/library/j-jtp01274/index.html" rel="noopener ugc nofollow" target="_blank">https://www . IBM . com/developer works/library/j-jtp 01274/index . html</a></li></ol></div></div>    
</body>
</html>