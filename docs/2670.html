<html>
<head>
<title>A Beginner’s Guide to Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归初学者指南</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-how-recursion-works-by-using-arrays-a072ba653717?source=collection_archive---------1-----------------------#2019-07-08">https://itnext.io/understanding-how-recursion-works-by-using-arrays-a072ba653717?source=collection_archive---------1-----------------------#2019-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de00" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用数学函数学习递归如何在没有T1的情况下工作</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/7d455292790afb3a2cc131e084448068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*myJegT6UPUiopSgfHXUg-g.jpeg"/></div></div></figure><p id="bd8d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> <em class="lr">递归</em> </strong> <em class="lr"> </em>是所有计算机科学中最怪异的概念之一，理解它真的很有挑战性。但是试图通过使用<a class="ae ls" href="https://medium.com/quick-code/fibonacci-sequence-javascript-interview-question-iterative-and-recursive-solutions-6a0346d24053" rel="noopener">斐波那契</a>或<a class="ae ls" href="https://medium.com/@julianjohannesen/banging-my-head-against-recursive-functions-a79f53fbab0f" rel="noopener">指数</a>函数来学习它会使它变得更糟。现在，你不仅仅是在学习核心概念，你还在试图跟踪大量令人困惑的返回值。幸运的是，这些值实际上与递归没有任何关系，使用数组使这一切变得更加简单。</p><h1 id="49f4" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">什么是递归？</h1><p id="49d8" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">还有更好的定义，但是对于一个递归函数来说，它必须做两件事:1) <strong class="kx iu">调用自己</strong>和<strong class="kx iu"> 2)知道什么时候<em class="lr">停止</em>调用自己</strong>。就这样，就这样。技术上来说，你甚至不需要第二个。当然，没有它你的函数会爆炸，但是它会递归爆炸。</p><h1 id="cd0f" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">让我们构建一个简单的函数</h1><p id="06f7" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">首先，让我们创建一个基函数。它所做的只是在数组中记录一个值:</p><pre class="kk kl km kn gt mq mr ms mt aw mu bi"><span id="698c" class="mv lu it mr b gy mw mx l my mz">const <strong class="mr iu">recursiveFunc</strong> = (<strong class="mr iu">arr</strong>, <strong class="mr iu">idx</strong>) =&gt; {<br/>  <strong class="mr iu">console.log</strong>(`- ${<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>]}`);<br/>}; </span></pre><p id="66f7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">太美了。现在，假设我们想使用这个函数来列出数组中的每个值。我们<em class="lr">能不能</em>偷懒，一直给索引加一:</p><pre class="kk kl km kn gt mq mr ms mt aw mu bi"><span id="b844" class="mv lu it mr b gy mw mx l my mz">const <strong class="mr iu">arr</strong>= ['<em class="lr">a</em>', '<em class="lr">b</em>', '<em class="lr">c</em>'];<br/><strong class="mr iu">recursiveFunc(arr, </strong>0<strong class="mr iu">);<br/>recursiveFunc(arr</strong>, 1<strong class="mr iu">);<br/>recursiveFunc(num</strong>, 2<strong class="mr iu">);</strong></span></pre><h1 id="b51c" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">但是让我们把它变成递归的</h1><p id="7e93" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">我们所要做的就是在函数中添加“+1”步骤<em class="lr">:</em></p><pre class="kk kl km kn gt mq mr ms mt aw mu bi"><span id="58bd" class="mv lu it mr b gy mw mx l my mz">const <strong class="mr iu">recursiveFunc</strong> = (<strong class="mr iu">arr</strong>, <strong class="mr iu">idx</strong>) =&gt; {<br/>  <strong class="mr iu">console.log</strong>(`- ${<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>]}`);<br/>  <strong class="mr iu">recursiveFunc</strong>(<strong class="mr iu">arr</strong>, <strong class="mr iu">idx</strong> + 1);<br/>};</span></pre><p id="3a51" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们已经满足了递归的第一个要求:我们在函数内部调用函数。但是，如果我们运行这个，它会爆炸，因为我们从来没有告诉它在任何时候<em class="lr">停止</em>。我们仍然需要要求#2，一个停止条件:</p><pre class="kk kl km kn gt mq mr ms mt aw mu bi"><span id="3816" class="mv lu it mr b gy mw mx l my mz">const <strong class="mr iu">recursiveFunc</strong> = (<strong class="mr iu">arr</strong>, <strong class="mr iu">idx</strong>) =&gt; {<br/>  if (<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>]) {<br/>    <strong class="mr iu">console</strong>.log(`- ${<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>]}`);<br/>    <strong class="mr iu">recursiveFunc</strong>(<strong class="mr iu">arr</strong>, <strong class="mr iu">idx</strong> + 1);<br/>  }<br/>};</span></pre><p id="0dfe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，一旦我们命中一个不在数组中的索引，它不会做任何事情，链就断了。这就是它的作用:</p><pre class="kk kl km kn gt mq mr ms mt aw mu bi"><span id="309a" class="mv lu it mr b gy mw mx l my mz"><strong class="mr iu">recursiveFunc(</strong>[<em class="lr">'a'</em>, <em class="lr">'b'</em>, <em class="lr">'c'</em>]<strong class="mr iu">, </strong>0<strong class="mr iu">);<br/></strong># returns:<br/>- a <br/>- b <br/>- c</span></pre><p id="526e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这张方便的图表将帮助您了解正在发生的事情:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi na"><img src="../Images/a3e62692c5f8e19da3a6b16ad659d964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-K7CWKNTpKar-sc_GepUbg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">我们的递归函数，每个新调用都在一个嵌套的盒子里</figcaption></figure><p id="9e14" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如您所见，我们每次都将索引值增加1，因此我们遍历了整个数组。请注意，索引值会发生变化，但每次我们传入的都是同一个数组。当索引处没有值时，函数什么也不做，所以我们退出函数。</p><p id="fd77" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果这是你第一次使用递归，花点时间熟悉一下这个结构。不可否认，一个函数调用自己是<em class="lr">怪异</em>。</p><h1 id="729e" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">使它更加递归</h1><p id="2d44" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">我们的函数符合我们对递归的定义，但是它不能递归地遍历<em class="lr">嵌套的</em>数组。这不好，因为这实际上是递归的真实应用。循环处理迭代，然而递归是处理未知深度的嵌套对象的最好方法。为了说明嵌套，我们需要做的就是添加一个步骤，在这个步骤中我们检查值是否是一个数组:</p><pre class="kk kl km kn gt mq mr ms mt aw mu bi"><span id="900a" class="mv lu it mr b gy mw mx l my mz">const <strong class="mr iu">recursiveFunc</strong> = (<strong class="mr iu">arr</strong>, <strong class="mr iu">idx</strong>) =&gt; {<br/>  if (<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>]) {<br/>    <strong class="mr iu"><em class="lr">// add this extra check</em></strong><br/>    if (<strong class="mr iu">Array</strong>.isArray(<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>])) {<br/>      <strong class="mr iu">recursiveFunc</strong>(<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>], 0);<br/>    } else {<br/>      <strong class="mr iu">console</strong>.log(`- ${<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>]}`);<br/>    }<br/>    <strong class="mr iu">recursiveFunc</strong>(<strong class="mr iu">arr</strong>, <strong class="mr iu">idx</strong> + 1);<br/>  }<br/>};</span><span id="f9d2" class="mv lu it mr b gy nf mx l my mz"><strong class="mr iu">recursiveFunc(</strong>[<em class="lr">'a'</em>, [<em class="lr">'x', 'y'</em>], <em class="lr">'d'</em>]<strong class="mr iu">, </strong>0<strong class="mr iu">);<br/></strong># returns:<br/>- a <br/>- x<br/>- y<br/>- d</span></pre><p id="9828" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">同样，图表非常有用:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ng"><img src="../Images/cf97c475c06498efa527126aa630829f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZ6ZOXgpX-aW-DmiLfdGGw.jpeg"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">我们新的递归函数在另一个框中显示了单独的数组步骤</figcaption></figure><p id="e221" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是在新数组上开始另一个递归调用链。看看我们如何传入新的数组和<code class="fe nh ni nj mr b">0</code>来开始新的序列。一旦这个序列完成，我们回到我们的主链。另外，注意最后的<code class="fe nh ni nj mr b">recursiveFunc</code>调用是在数组检查之外的<em class="lr">。这是因为当我们进入一个数组后，我们总是希望在返回时继续下去。</em></p><h1 id="dd2f" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">通过想象来仔细检查</h1><p id="580a" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">为了确保您理解主要概念，为什么不尝试添加另一个参数呢？这是更好的印刷的新水平:</p><pre class="kk kl km kn gt mq mr ms mt aw mu bi"><span id="d3a0" class="mv lu it mr b gy mw mx l my mz">const <strong class="mr iu">recursiveFancy</strong> = (<strong class="mr iu">arr</strong>, <strong class="mr iu">idx</strong>, <strong class="mr iu">lvl</strong>) =&gt; {<br/>  if (arr[idx]) {<br/>    if (<strong class="mr iu">Array.</strong>isArray(<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>])) {<br/>      <strong class="mr iu">recursiveFancy</strong>(<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>], 0, <strong class="mr iu">lvl</strong> + 1);<br/>    } else {<br/>      <strong class="mr iu">console</strong>.log(`${'- '.repeat(<strong class="mr iu">lvl</strong>)}${<strong class="mr iu">arr</strong>[<strong class="mr iu">idx</strong>]}`);<br/>    }<br/>    <strong class="mr iu">recursiveFancy</strong>(<strong class="mr iu">arr</strong>, <strong class="mr iu">idx</strong> + 1, <strong class="mr iu">lvl</strong>);<br/>  }<br/>};</span><span id="8965" class="mv lu it mr b gy nf mx l my mz"><strong class="mr iu">recursiveFancy</strong>(['<em class="lr">a</em>', '<em class="lr">b</em>', ['<em class="lr">q</em>', ['<em class="lr">x</em>',]], '<em class="lr">c</em>'], 0, 1);<br/><em class="lr"># returns </em><br/>- a<br/>- b<br/>- - q<br/>- - - x<br/>- c</span></pre><p id="13dc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这就是递归的基础。既然基础知识已经完成，学习递归返回值应该会容易得多。看看他们如何处理<a class="ae ls" href="https://medium.com/quick-code/fibonacci-sequence-javascript-interview-question-iterative-and-recursive-solutions-6a0346d24053" rel="noopener">斐波纳契面试问题</a>。</p><p id="cfc7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">大家编码快乐，</p><p id="9007" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">迈克</p><p id="2f47" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr">最新文章:</em></p></div></div>    
</body>
</html>