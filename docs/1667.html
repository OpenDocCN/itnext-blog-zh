<html>
<head>
<title>One Approach To Filtering A D3 Interactive Dashboard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种过滤D3交互式仪表板的方法</h1>
<blockquote>原文：<a href="https://itnext.io/one-approach-to-filtering-a-d3-interactive-dashboard-f63e0244f77d?source=collection_archive---------2-----------------------#2018-12-27">https://itnext.io/one-approach-to-filtering-a-d3-interactive-dashboard-f63e0244f77d?source=collection_archive---------2-----------------------#2018-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a01474202478dcc147e3e9b9402f090f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGjE_pMxjzxDovsvrbS71g.png"/></div></div></figure><div class=""/><p id="ae89" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何交互式D3仪表板中需要的一个关键需求是，基于用户对一个或多个应用过滤器的选择来呈现数据的逻辑实现。它的设计应该是灵活的，并且能够根据用户要求包括额外的过滤器。</p><h2 id="4548" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">仪表板设计</h2><p id="6835" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">这个仪表板设计的想法是基于<a class="ae lu" href="https://interworks.com/people/david-siegel/" rel="noopener ugc nofollow" target="_blank">大卫·围攻</a>的<a class="ae lu" href="https://interworks.com/blog/dsiegel/2018/02/02/streetball-mecca-mapping-nyc-basketball-courts-tableau/" rel="noopener ugc nofollow" target="_blank"> Tableau项目</a>的发现，这是我在帮助一名学生寻找基于纽约市篮球场的数据集时偶然发现的。数据集仅限于曼哈顿和布鲁克林。然而，这是一个很好的起点，而且由于我过去曾经使用过Tableau，我知道我们可以通过下载项目来访问现有的数据。一旦我开始与仪表板交互，我就想到这将是一个使用D3重新创建的伟大项目。</p><p id="14eb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设计本身包括几个部分，每个部分都允许用户与可视化交互。这需要附上D3 <strong class="ka jc">。on() </strong>每个元素的事件监听器会调用适当的过滤函数。虽然有几个明显不同的过滤器，仪表板还允许用户与单个元素进行交互，这些元素本身可以启动数据的重新呈现。通过一些试验和错误，我相信我实现了一个可靠的方法来跟踪可能的过滤器选项。</p><h2 id="b891" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">滤波器设计</h2><p id="680a" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">完成滤波逻辑的第一步是决定最终设计将采用哪些滤波器。以下是用户可以使用的明确定义的过滤器:</p><ul class=""><li id="12ff" class="lv lw jb ka b kb kc kf kg kj lx kn ly kr lz kv ma mb mc md bi translated">神话；传奇</li><li id="3daa" class="lv lw jb ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">找个法院</li><li id="ade7" class="lv lw jb ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">选择一个区</li></ul><p id="b117" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户还可以通过以下方式进行交互:</p><ul class=""><li id="fcf1" class="lv lw jb ka b kb kc kf kg kj lx kn ly kr lz kv ma mb mc md bi translated">点击地图或条形图上的特定法院</li><li id="59a0" class="lv lw jb ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">在“必看”和“远离”部分点击特定的法庭</li><li id="6d67" class="lv lw jb ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">将鼠标悬停在特定的球场或公园上以启动工具提示</li></ul><p id="75bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据需求，我决定将过滤器选项组织成一个对象数组。每个对象包含一个被设置为过滤器名称的<strong class="ka jc">键</strong>和一个<strong class="ka jc">值</strong>，该值最初被设置为一个空字符串，然后根据用户交互进行更新。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4adb" class="kw kx jb mo b gy ms mt l mu mv">let filters = [<br/>  {key:'Overall court grouping',value:''},<br/>  {key:'Borough',value:''},<br/>  {key:'Name',value:''}</span></pre><p id="6697" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于激活过滤器来负责过滤数据集的函数有:</p><ol class=""><li id="db8b" class="lv lw jb ka b kb kc kf kg kj lx kn ly kr lz kv mw mb mc md bi translated"><strong class="ka jc"> findActiveFilters(): </strong>返回一个仅包含活动过滤器的数组</li><li id="63b3" class="lv lw jb ka b kb me kf mf kj mg kn mh kr mi kv mw mb mc md bi translated"><strong class="ka jc"> runFilter(): </strong>返回基于单个筛选值的筛选数据数组</li><li id="90fb" class="lv lw jb ka b kb me kf mf kj mg kn mh kr mi kv mw mb mc md bi translated"><strong class="ka jc"> filterData(): </strong>调用<strong class="ka jc"> findAcitveFilters </strong>并将项目数组和单个过滤器传递给<strong class="ka jc"> runFilter。</strong>然后<strong class="ka jc"> </strong>返回过滤元素的最终数组</li></ol><p id="cac0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数在过滤器数组中循环，只返回那些有值的过滤器。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="21bf" class="kw kx jb mo b gy ms mt l mu mv">function findActiveFilters() {<br/>  return filters.filter(d =&gt; d.value);<br/>}</span></pre><p id="609f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> runFilter(arr，filter) </strong>函数执行实际的过滤并返回一个新的过滤值数组。它将为每个活动过滤器调用，并传递要过滤的数组。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c2d4" class="kw kx jb mo b gy ms mt l mu mv">function runFilter(arr,filter){<br/>  return arr.filter( d =&gt; {<br/>    return d[filter.key] == filter.value<br/>  })<br/>}</span></pre><p id="1c6b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> filterData() </strong>函数<strong class="ka jc"> </strong>调用<strong class="ka jc"> findActiveFilters() </strong>函数来确定哪些过滤器是活动的，并将结果存储在<strong class="ka jc"> activeFilters </strong>中。然后，它对数组进行循环，并在第一个循环中传递<strong class="ka jc">run filter()</strong><strong class="ka jc">all data</strong>数组，在每个附加循环中传递<strong class="ka jc"> filteredData </strong>数组。该过程继续减少基于后续过滤器的元素数量。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9170" class="kw kx jb mo b gy ms mt l mu mv">function filterData() {<br/>  let filteredData = [];<br/>  let activeFilters = findActiveFilters();<br/>  activeFilters.forEach(d =&gt; {<br/>    if (filteredData.length == 0) {<br/>      filteredData = runFilter(allData, d);<br/>    } else {<br/>      filteredData = runFilter(filteredData, d);<br/>    }<br/>  });<br/>  return filteredData;<br/>}</span></pre><h2 id="2383" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">初始化图例过滤器</h2><p id="a104" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">过滤系统就绪后，现在由各个过滤器(如图例)首先调用它们的支持过滤功能，这些功能执行特定于该过滤器的操作。一旦完成，它就调用<strong class="ka jc"> filterData() </strong>函数。</p><p id="f814" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">初始化图例过滤器需要附加一个<strong class="ka jc">。on('click '，filterLegend </strong>)事件到每个渲染的图例。这里的回调，<strong class="ka jc"> filterLegend，</strong>是特定于过滤器的函数，并通过D3的<strong class="ka jc">数据绑定传递给绑定到该对象的实际元素。</strong></p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="d4f2" class="kw kx jb mo b gy ms mt l mu mv">let legends = gLegends.enter().append('g')<br/>    .on('click', filterLegend)</span></pre><p id="162a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管您在上面的配置中看不到被传递的元素，但是如果我们重新配置它，如下所示，那么很明显<strong class="ka jc"> filterLegend </strong>确实被直接传递给了元素。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="aa5d" class="kw kx jb mo b gy ms mt l mu mv">let legends = gLegends.enter().append('g')<br/>    .on('click', d =&gt; filterLegend(d)</span></pre><p id="bf13" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka jc"> filterLegend() </strong>函数中，我们首先评估如果用户连续点击相同的图例2x，是否需要重置图例值。如果实现该逻辑，则<strong class="ka jc">设置<strong class="ka jc">滤波器[0]。值</strong>转换为空字符串，并重新运行<strong class="ka jc">render legend(legend . domain())</strong>函数，向其传递图例值数组。</strong></p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="fdb8" class="kw kx jb mo b gy ms mt l mu mv">let legend = d3.scaleOrdinal()<br/>  .domain(["Very Good", "Mediocre", "Poor"])<br/>  .range(["#008000", "#FF9933", "#003399"]);</span><span id="0d67" class="kw kx jb mo b gy mx mt l mu mv">function filterLegend(legendVal){<br/>  if(filters[0].value == legendVal) {<br/>    filters[0].value = ''<br/>    renderLegend(legend.domain())<br/>  } else {<br/>      filters[0].value = legendVal<br/>      renderLegend([legendVal])<br/>  } <br/>  clearFilterParkValue()<br/>  findActiveFilters().length ? <br/>     showFilteredData(filterData()) :  showAllData();<br/>  filterBarChartBasedOnLegend()</span><span id="0ce0" class="kw kx jb mo b gy mx mt l mu mv">}</span></pre><p id="6a51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后<strong class="ka jc"> else </strong>负责设置<strong class="ka jc">滤波器[0]。value </strong>设置为选择的值，然后调用<strong class="ka jc">render legend([legend val])</strong>作为只有一个图例值的数组。renderLegend()函数是最初渲染图例的函数，它被配置为利用D3的<strong class="ka jc">更新</strong>和<strong class="ka jc">退出</strong>生命周期来转换图例的不透明度，这取决于哪一个是活动的。</p><p id="8a24" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，还会调用以下函数:</p><ul class=""><li id="48a9" class="lv lw jb ka b kb kc kf kg kj lx kn ly kr lz kv ma mb mc md bi translated">调用<strong class="ka jc"> clearFilterParkValue() </strong>来重置所有特定于公园的过滤器</li><li id="0c66" class="lv lw jb ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">三元运算符调用<strong class="ka jc"> showFilteredData() </strong>或<strong class="ka jc"> showAllData() </strong></li><li id="0c36" class="lv lw jb ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">调用<strong class="ka jc">filterBarChartBasedOnLegend()</strong>重置条形图</li></ul><h2 id="562f" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">附加过滤功能</h2><p id="eaeb" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">还创建了几个附加的过滤器类型函数来控制过滤。这里我要提到的另外两个是<strong class="ka jc"> filterBorough() </strong>和<strong class="ka jc"> filterPark()。</strong>这两个<strong class="ka jc"> </strong>本质上与<strong class="ka jc"> filterLegend() </strong>做的一样，但是，具体是在那些过滤器的上下文中做。我把它们列在下面作为参考。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="44c8" class="kw kx jb mo b gy ms mt l mu mv">function filterBorough(boroughVal) {<br/>  filters[2].value = "";<br/>  if (boroughVal == "all") {<br/>    filters[1].value = "";<br/>    showAllData()<br/>  } else {<br/>    filters[1].value = boroughVal;<br/>    filteredData = allData.filter(d =&gt; d.Borough == boroughVal)<br/>    renderBarChart(nestingData(filteredData));<br/>    renderTopParks(filteredData)<br/>    renderBottomParks(filteredData)<br/>  }<br/>  findActiveFilters().length ? <br/>     showFilteredData(filterData()) : showAllData();<br/>  clearFilterParkValue()<br/>}</span><span id="92ee" class="kw kx jb mo b gy mx mt l mu mv">function filterPark(parkVal) {<br/>  if(filters[2].value == parkVal.Name ) {<br/>     clearFilterParkValue()<br/>  } else {<br/>    filterParkValue(parkVal)<br/>  }<br/>  findActiveFilters().length ? <br/>    showFilteredData(filterData()) :  showAllData();<br/>}</span></pre><h1 id="cbec" class="my kx jb bd ky mz na nb lb nc nd ne le nf ng nh lh ni nj nk lk nl nm nn ln no bi translated">结论</h1><p id="98bc" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">整个过滤器功能需要花相当多的时间来完成，因为每个功能都有一些细微的差别。几个支持函数被配置为支持每个过滤器，过滤器可以依次调用它们自己的支持函数。最后，需要进行一次大的重构，以使它可以在不同的数据集上重用，我将在构建下一个仪表板时考虑这一点。</p><p id="cbf3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是<a class="ae lu" href="https://codepen.io/jkeohan/project/full/ZvKkKE" rel="noopener ugc nofollow" target="_blank">链接</a>到正在进行的项目。如果任何人对如何进一步简化流程有任何反馈、建议或想法，我很乐意听取您的意见。</p></div></div>    
</body>
</html>