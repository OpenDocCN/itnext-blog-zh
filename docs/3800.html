<html>
<head>
<title>The standard way to manage application configurations on Kubernetes clusters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes集群上管理应用程序配置的标准方式</h1>
<blockquote>原文：<a href="https://itnext.io/the-standard-way-to-manage-application-configurations-on-kubernetes-clusters-7e60e190bd9b?source=collection_archive---------0-----------------------#2020-02-28">https://itnext.io/the-standard-way-to-manage-application-configurations-on-kubernetes-clusters-7e60e190bd9b?source=collection_archive---------0-----------------------#2020-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/05723cd6718f58a7672c32fb4cb70812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzoaAG26kzzsdyV1_g6p7g.jpeg"/></div></div></figure><p id="8eaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">本文是跨</em> <a class="ae la" href="https://en.wikipedia.org/wiki/Deployment_environment" rel="noopener ugc nofollow" target="_blank"> <em class="kz">环境</em> </a> <em class="kz">和云管理配置数据的一系列实用且可重复的方法中的一部分。</em></p><p id="5e36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有这一切都源于我最近与一位客户会面的副产品，也源于我与一位合作伙伴的对话。</p><p id="85a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在给你一点背景知识…</p><h1 id="99ed" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">语境</h1><p id="0fec" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在我之前的<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/a-standard-way-of-managing-configurations-for-multiple-environments-and-clouds-ee8d54703efc">文章</a>中，我描述了使用Git作为事实来源的生产级系统和应用程序的配置管理组件的方法。如果你不打算读这篇文章，我会试着用几个要点概括一下。</p><ul class=""><li id="bba4" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">以JSON文件形式管理的配置数据</li><li id="21dd" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">提交到Github的JSON配置文件</li><li id="d595" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">每个应用程序/系统环境(开发、试运行、生产等。)为代表的Git分支。例如，Git分支<code class="fe ms mt mu mv b">dev</code>托管<a class="ae la" href="https://en.wikipedia.org/wiki/Deployment_environment" rel="noopener ugc nofollow" target="_blank">环境</a> <code class="fe ms mt mu mv b">DEV</code>的所有配置文件。不用说，分支永远不会被合并。</li><li id="ccde" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">通过配置服务以REST端点和JSON路径密钥的形式检索配置</li></ul><p id="80cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有助于理解这一概念的快速示例:</p><p id="953f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑下面的JSON配置文件<code class="fe ms mt mu mv b">my-service.json</code>在分支<code class="fe ms mt mu mv b">prod</code>(它服务于<code class="fe ms mt mu mv b">prod</code>环境)</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="0058" class="ne lc it mv b gy nf ng l nh ni">{<br/>"app" : "services",<br/>"port": "8000", <br/>"app-type" : "backend",<br/>"env" : "sandbox",<br/>"log-level": "debug"<br/>}</span></pre><p id="22e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，如果我要部署寻找其参数(如端口号等)的<code class="fe ms mt mu mv b">my-service</code>应用程序。它执行一个简单的REST GET调用来获取端口号和日志级别，如下所示:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="1ee9" class="ne lc it mv b gy nf ng l nh ni">$ curl <a class="ae la" href="http://config-service.mydomain/api/v2/my-service/prod/port" rel="noopener ugc nofollow" target="_blank">http://config-service.mydomain/api/v2/my-service/prod/port</a><br/>8000</span><span id="147e" class="ne lc it mv b gy nj ng l nh ni">$ curl <a class="ae la" href="http://config-service.mydomain/api/v2/my-service/prod/port" rel="noopener ugc nofollow" target="_blank">http://config-service.mydomain/api/v2/my-service/prod/</a>log-level<br/>info</span></pre><p id="66a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次你提交一个分支的变更，它会通过GitHooks自动传播到服务的缓存中，因此你的应用程序永远不会使用过期的配置数据。</p><p id="98f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法宣传了一系列高价值的好处，例如</p><ul class=""><li id="be2c" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">将配置管理归结为简单的REST调用</li><li id="cfc6" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">维护事实的单一版本——所有的配置数据都可以在Git分支中存储和管理</li><li id="490d" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">完全可追溯性和审计，所有传输</li><li id="88ae" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">更强的安全保证，与权威后端的集成</li><li id="d431" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">完全不受云限制(非常适合多云部署)</li></ul><h1 id="b8a9" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">好了，这一切都很好，现在怎么办。</h1><p id="f2eb" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">使用REST调用逐个获取配置对于大多数用例来说都很好，但是，当涉及到部署在Kubernetes上的应用程序时，使用Kubernetes提供的配置管理组件(ConfigMaps)绝对有意义，这是管理配置的最强大的方法之一。那么，我们如何获得由配置数据服务提供的配置(并由Git支持)并在“实时模式”下将其“翻译”成配置图，并确保它不会失去同步呢？</p><p id="2b26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，看起来相当棘手的解决方案结果非常简单——使用<a class="ae la" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank"> Kubernetes操作符</a>。Kubernetes算子到底是什么？操作员是与定制资源协同工作的控制者，执行“人类操作员”必须处理的任务。考虑部署一个具有可管理数量的节点的数据库集群，管理升级，甚至执行备份。自定义资源将指定数据库版本、要部署的节点数量、备份频率及其目标存储，控制器将实施执行这些操作所需的所有业务逻辑。例如，这就是<a class="ae la" href="https://github.com/coreos/etcd-operator" rel="noopener ugc nofollow" target="_blank"> etcd操作符</a>的作用。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="b457" class="lb lc it bd ld le nr lg lh li ns lk ll lm nt lo lp lq nu ls lt lu nv lw lx ly bi translated">与Kubernetes集群同步配置事实来源</h1><h2 id="9869" class="ne lc it bd ld nw nx dn lh ny nz dp ll km oa ob lp kq oc od lt ku oe of lx og bi translated">将配置数据推送到Kubernetes</h2><p id="0aca" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">这个高层次的草图旨在为下面描述的解决方案提供一个可视化的表示。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/753dd6c22eff4564c8cf55f8012d1ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpcbUjcGwTySvdIqHMgzrw.jpeg"/></div></div></figure><p id="b11a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，工作流程如下:</p><ul class=""><li id="25de" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">配置数据服务(CDS)从单一事实源(基于Git的repo)实时向应用程序提供所需的配置。它可以运行在单独的集群上，也可以运行在同一个集群上，可以运行在同一个云实例上，也可以运行在完全不同的云实例上，甚至可以运行在独立的虚拟机上——有许多部署选项。最重要的是，它公开了一组端点作为检索配置数据的手段。</li><li id="cb1a" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">您的单一事实源，在我的例子中是Github repo，包含一个简单的JSON文件<code class="fe ms mt mu mv b">configmaps.json</code>，它描述了什么配置(来自Github)将以ConfigMaps的形式被推送到您的Kubernetes集群。这里有一个这样的<code class="fe ms mt mu mv b">configmaps.json</code>的快速示例，可以在这里<a class="ae la" href="https://raw.githubusercontent.com/OlegGorj/config-data/sandbox/configmaps.json" rel="noopener ugc nofollow" target="_blank">找到</a></li></ul><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="434a" class="ne lc it mv b gy nf ng l nh ni">[  <br/>   {  <br/>      <strong class="mv iu">"namespace"</strong>:"default",<br/>      <strong class="mv iu">"configmap"</strong>:"cassandra-test",<br/>      <strong class="mv iu">"config"</strong>:"cassandra.json",<br/>      <strong class="mv iu">"keys"</strong>:[  <br/>         {  <br/>            <strong class="mv iu">"configmap_key"</strong>:"app",<br/>            <strong class="mv iu">"config_service_key"</strong>:"app"<br/>         }<br/>      ]<br/>   },<br/>   {  <br/>      <strong class="mv iu">"namespace"</strong>:"default",<br/>      <strong class="mv iu">"configmap"</strong>:"k8s-cluster",<br/>      <strong class="mv iu">"config"</strong>:"k8s-cluster.json",<br/>      <strong class="mv iu">"keys"</strong>:[  <br/>         {  <br/>            <strong class="mv iu">"configmap_key"</strong>:"app",<br/>            <strong class="mv iu">"config_service_key"</strong>:"name"<br/>         }<br/>      ]<br/>   }<br/>]</span></pre><p id="d9e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个例子提供了创建两个名为<code class="fe ms mt mu mv b">cassandra-test</code>和<code class="fe ms mt mu mv b">k8s-cluster</code>的配置图的说明。向下滚动查看此示例的详细分解。</p><ul class=""><li id="e5c1" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">下一个组件是实际的配置操作符。它所做的是，查看<code class="fe ms mt mu mv b">configmaps.json</code>文件，然后解析它并在您的Kube集群中生成配置映射。请记住，这是正在进行的工作:欢迎您使用它(带有快速参考:)，它工作，但我不认为它已经准备好进入生产的黄金时间。我仍在测试它，并添加错误处理程序等等。</li></ul><h2 id="7e89" class="ne lc it bd ld nw nx dn lh ny nz dp ll km oa ob lp kq oc od lt ku oe of lx og bi translated">configmaps.json文件示例</h2><p id="e447" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">让我们检查一个简单的<code class="fe ms mt mu mv b">configmaps.json</code>文件的例子，以及它如何转换成实际的ConfigMap资源。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="7c00" class="ne lc it mv b gy nf ng l nh ni">[<br/>   {  <br/>      <strong class="mv iu">"namespace"</strong>:"default",<br/>      <strong class="mv iu">"configmap"</strong>:"k8s-cluster",<br/>      <strong class="mv iu">"config"</strong>:"k8s-cluster.json",<br/>      <strong class="mv iu">"keys"</strong>:[  <br/>         {  <br/>            <strong class="mv iu">"configmap_key"</strong>:"app",<br/>            <strong class="mv iu">"config_service_key"</strong>:"name"<br/>         },<br/>         {  <br/>            <strong class="mv iu">"configmap_key"</strong>:"applications",<br/>            <strong class="mv iu">"config_service_key"</strong>:"apps"<br/>         },<br/>         {  <br/>            <strong class="mv iu">"configmap_key"</strong>:"cloud-api",<br/>            <strong class="mv iu">"config_service_key"</strong>:"cloud-provider.api-endpoint"<br/>         }<br/>      ]<br/>   }<br/>]</span></pre><p id="e398" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如上面的代码片段所示，这是一个ConfigMap配置列表，每个配置都有以下键:</p><ul class=""><li id="8185" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated"><code class="fe ms mt mu mv b">namespace</code> —您想要部署ConfigMap的名称空间</li><li id="ef9d" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe ms mt mu mv b">configmap</code> —配置图的实际名称</li><li id="1a3f" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe ms mt mu mv b">config</code> —包含配置映射的配置数据的配置文件(在Git上)</li><li id="0d69" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><code class="fe ms mt mu mv b">keys</code> —键对列表:<code class="fe ms mt mu mv b"><strong class="kd iu">config_service_key</strong></code>指向Git分支中的配置数据，<code class="fe ms mt mu mv b"><strong class="kd iu">configmap_key</strong></code>是ConfigMap中的键的名称</li></ul><p id="8288" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望下面的草图能提供这种映射的说明:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1ee01a803bed30eb0634b2b0d9e5d259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*q_b8sI5uFVHKqFH0cSJDSQ.jpeg"/></div></figure><p id="2d00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，下一节将展示Config Operator如何将这个configmaps.json转换成一组实际的ConfigMap资源。</p><h1 id="94d2" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Kubernetes配置运算符</h1><h2 id="5028" class="ne lc it bd ld nw nx dn lh ny nz dp ll km oa ob lp kq oc od lt ku oe of lx og bi translated">它是怎么做到的</h2><p id="0673" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在这一切的核心，有一个<a class="ae la" href="https://github.com/OlegGorj/config-data-operator" rel="noopener ugc nofollow" target="_blank">配置数据Kubernetes操作符</a>，它读取<code class="fe ms mt mu mv b">configmaps.json</code>文件并将其翻译成Kube集群上的一组配置映射。下图显示了这种转换是如何完成的，以及<code class="fe ms mt mu mv b">configmaps.json</code>中的哪些键映射到配置图中的属性。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/c556577d58400f457c4406ad2ca6b554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpJPTx4leMXBokNtIF6jdg.jpeg"/></div></div></figure><p id="a5ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，让我们快速看一下<code class="fe ms mt mu mv b">configmaps.json</code>文件的结构(这里有一个<a class="ae la" href="https://github.com/OlegGorj/config-data/blob/sandbox/configmaps.json" rel="noopener ugc nofollow" target="_blank">文件的例子</a>),更详细的分解请参考<a class="ae la" href="https://github.com/OlegGorj/config-data-operator/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>。</p><ul class=""><li id="0a34" class="me mf it kd b ke kf ki kj km mg kq mh ku mi ky mj mk ml mm bi translated">本质上，JSON文件是描述符的列表，这些描述符向操作员提供如何构建配置图的指令，因此您可以将每个块作为一个配置图</li><li id="ccc5" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">在每个块中，有一组键，在上面的示例中，一个键称为<code class="fe ms mt mu mv b">“namespace”</code>，其值为“default ”,指定将在其中部署此配置图的名称空间</li><li id="dbf1" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">下一个键是<code class="fe ms mt mu mv b">configmap</code>，它指定了配置图的名称</li><li id="bd1b" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">下一个，<code class="fe ms mt mu mv b">config</code>指向JSON文件(在同一个git repo中)，该文件为即将到来的ConfigMap提供了<strong class="kd iu"> <em class="kz">实际的</em> </strong>配置值。在上面的例子中，它指向文件<code class="fe ms mt mu mv b">k8s-cluster.json</code>。</li><li id="7437" class="me mf it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">现在，下一个叫做<code class="fe ms mt mu mv b">keys</code>的键有点棘手。它的作用是将配置文件(<code class="fe ms mt mu mv b">k8s-cluster.json</code>)中的密钥映射到待配置文件(<code class="fe ms mt mu mv b">k8s-cluster</code>)中的密钥，如下所示:</li></ul><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6139" class="ne lc it mv b gy nf ng l nh ni">"<strong class="mv iu">keys</strong>": [  <br/>   {  <br/>      <strong class="mv iu">"configmap_key"</strong>:"app",<br/>      <strong class="mv iu">"config_service_key"</strong>:"name"<br/>   },<br/>   {  <br/>      <strong class="mv iu">"configmap_key"</strong>:"applications",<br/>      <strong class="mv iu">"config_service_key"</strong>:"apps"<br/>   },<br/>   {  <br/>      <strong class="mv iu">"configmap_key"</strong>:"cloud-api",<br/>      <strong class="mv iu">"config_service_key"</strong>:"cloud-provider.api-endpoint"<br/>   }<br/>]</span></pre><h2 id="ff17" class="ne lc it bd ld nw nx dn lh ny nz dp ll km oa ob lp kq oc od lt ku oe of lx og bi translated">建设</h2><p id="b6e3" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">构建说明作为git repo的自述文件的一部分提供。如果在编译代码时有任何问题，请随时提出。</p><h2 id="d3e0" class="ne lc it bd ld nw nx dn lh ny nz dp ll km oa ob lp kq oc od lt ku oe of lx og bi translated">部署</h2><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="8468" class="ne lc it mv b gy nf ng l nh ni">$ kubectl describe configmap k8s-cluster</span><span id="9a0a" class="ne lc it mv b gy nj ng l nh ni">Name:         k8s-cluster</span><span id="db44" class="ne lc it mv b gy nj ng l nh ni">Namespace:    default</span><span id="e8d8" class="ne lc it mv b gy nj ng l nh ni">Labels:       maintained_by=config_operator</span><span id="a6e8" class="ne lc it mv b gy nj ng l nh ni">Data</span><span id="6732" class="ne lc it mv b gy nj ng l nh ni">====</span><span id="f010" class="ne lc it mv b gy nj ng l nh ni">app:</span><span id="c1e9" class="ne lc it mv b gy nj ng l nh ni">----</span><span id="ca53" class="ne lc it mv b gy nj ng l nh ni">angtc2FuZGJveAo=</span><span id="abf6" class="ne lc it mv b gy nj ng l nh ni">applications:</span><span id="4c5c" class="ne lc it mv b gy nj ng l nh ni">----</span><span id="f13e" class="ne lc it mv b gy nj ng l nh ni">WyB7ICJuYW1lIiA6ICJqZW5raW5zIiwgImFwcC10eXBlIiA6ICJkZXZvcHMiIH0sIHsgIm5hbWUiIDogImdyYWZhbmEiLCAiYXBwLXR5cGUiIDogImRldm9wcyIgfSwgeyAibmFtZSIgOiAiY2Fzc2FuZHJhIiwgImFwcC10eXBlIiA6ICJzdG9yYWdlIiB9IF0K</span><span id="e93b" class="ne lc it mv b gy nj ng l nh ni">cloud-api:</span><span id="0a10" class="ne lc it mv b gy nj ng l nh ni">----</span><span id="8b47" class="ne lc it mv b gy nj ng l nh ni">aHR0cHM6Ly9hcGkudXMtZWFzdC5ibHVlbWl4Lm5ldAo=</span><span id="69be" class="ne lc it mv b gy nj ng l nh ni">Events:  &lt;none&gt;</span><span id="da4c" class="ne lc it mv b gy nj ng l nh ni">$ echo angtc2FuZGJveAo= | base64 -D</span><span id="2854" class="ne lc it mv b gy nj ng l nh ni">jx-sandbox</span><span id="29dd" class="ne lc it mv b gy nj ng l nh ni">$ echo WyB7ICJuYW1lIiA6ICJqZW5raW5zIiwgImFwcC10eXBlIiA6ICJkZXZvcHMiIH0sIHsgIm5hbWUiIDogImdyYWZhbmEiLCAiYXBwLXR5cGUiIDogImRldm9wcyIgfSwgeyAibmFtZSIgOiAiY2Fzc2FuZHJhIiwgImFwcC10eXBlIiA6ICJzdG9yYWdlIiB9IF0K | base64 -D</span><span id="27cf" class="ne lc it mv b gy nj ng l nh ni">[ { "name" : "jenkins", "app-type" : "devops" }, { "name" : "grafana", "app-type" : "devops" }, { "name" : "cassandra", "app-type" : "storage" } ]</span></pre><h1 id="a922" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">待续..</h1><p id="dbcb" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在下一组文章中，我打算描述更多的用例，并提供更多关于如何在多租户和高复杂性环境中部署此类操作符的见解。</p><p id="e679" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一如既往，感谢任何反馈和问题。干杯！</p></div></div>    
</body>
</html>