<html>
<head>
<title>Autoreleasepool and swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Autoreleasepool和swift</h1>
<blockquote>原文：<a href="https://itnext.io/autoreleasepool-and-swift-c58d8e9bc448?source=collection_archive---------0-----------------------#2022-02-05">https://itnext.io/autoreleasepool-and-swift-c58d8e9bc448?source=collection_archive---------0-----------------------#2022-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/829445c326abb0b183a384bfcbd7fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZKoQ894GLbiEPRrTCv4Qg.png"/></div></div></figure><div class=""/><p id="07d8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">swift中的内存管理由ARC (=自动引用计数)处理。这意味着对对象的活动引用被计算在内，当对象不再被引用时就被释放。</p><p id="28ae" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Objective-C中(尤其是在Objective-C的早期，在引入ARC之前)，需要手动保留和释放对象。开发人员需要管理每个对象的内存，内存管理中的错误会导致内存泄漏或崩溃。</p><p id="c20e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Swift中，内存管理是通过ARC自动完成的，在大多数情况下，开发人员不需要担心如何管理它。不过也有一些例外。例如:</p><ul class=""><li id="27a6" class="kz la je kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">闭包中对self的引用会扰乱ARC</li><li id="a9b1" class="kz la je kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">swift中Objective-C对象的使用</li></ul><p id="a015" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">闭包中对self的引用可以通过使用关键字<strong class="kd jf"> weak </strong>和<strong class="kd jf"> unowned </strong>来处理。我在这里写了一篇关于它的小博文:</p><div class="is it gp gr iu ln"><a href="https://betterprogramming.pub/weak-and-unowned-keywords-in-swift-7bda8bdd97c4" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd jf gy z fp ls fr fs lt fu fw jd bi translated">Swift中的弱关键字和无主关键字</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">以及为什么在闭包中使用它们很重要——举个例子。</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">better编程. pub</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb ja ln"/></div></div></a></div><p id="0b13" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在swift中使用Objective-C对象会导致这些对象无法正确发布。此问题的修复程序是autoreleasepool。</p><h1 id="0091" class="mc md je bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">swift中的Autoreleasepool何时使用？</h1><p id="5b27" class="pw-post-body-paragraph kb kc je kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">有多篇文章解释了如何以及为什么应该使用autoreleasepool，例如:</p><div class="is it gp gr iu ln"><a href="https://betterprogramming.pub/what-is-autorelease-pool-in-swift-c652784f329e" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd jf gy z fp ls fr fs lt fu fw jd bi translated">Swift中的自动释放池是什么</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">以及如何优化循环中的内存使用</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">better编程. pub</p></div></div><div class="lw l"><div class="nf l ly lz ma lw mb ja ln"/></div></div></a></div><div class="is it gp gr iu ln"><a href="https://medium.com/mediate-tech/cleaning-memory-footprint-with-the-autoreleasepool-in-swift-71ff983b22aa" rel="noopener follow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd jf gy z fp ls fr fs lt fu fw jd bi translated">使用Swift中的自动释放池清理内存占用</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">在本文中，我们将讨论自动释放池，它减少了循环的内存使用，特别是在CPU密集型的…</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">medium.com</p></div></div><div class="lw l"><div class="ng l ly lz ma lw mb ja ln"/></div></div></a></div><p id="7c1f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个例子都将在循环中创建UIImage列为内存泄漏的来源，可以通过将对象初始化放在autoreleasepool中来解决。我不会解释autorelasepool到底是做什么的，但是会展示一些应该使用它的额外例子。</p><p id="a1c9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们编写完全swift的代码时，那么<strong class="kd jf">就不需要</strong>for auto release pool。然而，当我们使用Objective-C对象时，我们应该记住autoreleasepool。</p><p id="d0b0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，我们什么时候使用Objective-C对象呢？Objective-C对象是共享公共父类NSObject的对象。例如，这些对象是:</p><ul class=""><li id="477d" class="kz la je kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">任何以NS开头的东西..(这些类别中的大部分如今都有swift的对等物)</li><li id="4899" class="kz la je kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">UIKit中的任何东西(比如上面例子中的UIImage)</li><li id="21e5" class="kz la je kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">文件管理器</li><li id="3422" class="kz la je kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">URLSessionTask</li><li id="2f2c" class="kz la je kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">过程</li><li id="ecc6" class="kz la je kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">和许多其他人..</li></ul><p id="d1c7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅使用Objective-C对象的一个实例并不能保证使用autoreleasepool。然而，当我们在一个循环中初始化这些对象时，内存占用会增长得非常快(如上面的UIImage示例所示)。</p><h1 id="d62a" class="mc md je bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">例子</h1><p id="29cb" class="pw-post-body-paragraph kb kc je kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">为了给出更多的例子，我将展示在一个循环中使用URLSessionTask和Process时，使用autoreleasepool如何改变内存占用。</p><h2 id="862a" class="nh md je bd me ni nj dn mi nk nl dp mm km nm nn mq kq no np mu ku nq nr my ns bi translated">重复执行shell命令</h2><p id="eada" class="pw-post-body-paragraph kb kc je kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">在本例中，我创建了一个助手类，允许用户从swift代码运行任何终端查询(swift代码在这里作为命令行应用程序运行):</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8923" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我在for循环中使用了shellOptional函数。一旦没有自动释放池:</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="fe22" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一次使用autoreleasepool:</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b2fc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从下图中可以看出内存占用的差异:</p><figure class="nt nu nv nw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/b2ccff7884681f8e439927a46722fae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WkQBMW-Qr3QX-Y3ECXAQPA.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">内存使用的差异:不使用和使用自动释放池</figcaption></figure><p id="83e9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果没有自动释放池，内存使用量会稳步增长。使用autoreleasepool时，对象被正确释放，内存使用保持不变。</p><h2 id="9b93" class="nh md je bd me ni nj dn mi nk nl dp mm km nm nn mq kq no np mu ku nq nr my ns bi translated">使用urlSession.dataTask重复查询</h2><p id="c4be" class="pw-post-body-paragraph kb kc je kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">在这个例子中，我对本地主机上的数据库执行了重复查询。执行查询的函数实现如下:</p><figure class="nt nu nv nw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="86c4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和前面的例子一样，我首先在没有autoreleasepool的for循环中执行这个查询，然后使用autoreleasepool。这里可以看出内存使用的差异:</p><figure class="nt nu nv nw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/422999b98512c1fb92a61f6fc9e83e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBgihQE6ZZCZafCooVTupQ.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">内存使用的差异:有无自动释放池</figcaption></figure><p id="3cd8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管在这两个例子中，内存使用量都在增长(我不知道是什么原因造成的)，但使用的内存量有很大的不同。</p><p id="854f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这两个例子中，我运行程序大约1分钟，然后停止执行。在此期间，大约运行了7000个查询和1000个终端执行。虽然正常情况下一分钟内不会执行那么多，但这很好地展示了随着时间的推移内存使用情况会发生什么。</p><h1 id="d014" class="mc md je bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">附加注释</h1><p id="4b2e" class="pw-post-body-paragraph kb kc je kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">Autoreleasepool仅适用于在Apple平台(例如Mac OS或iOS)上运行的swift应用程序。在Linux上运行swift时，Objective-C类不可用，autoreleasepool未实施。如果使用autorelease的swift代码也能在linux上运行，则有必要检查代码运行的操作系统。在Swift中，这可以使用#if os(Linux)来完成。</p><h1 id="2eb5" class="mc md je bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">外卖食品</h1><ul class=""><li id="60fb" class="kz la je kd b ke na ki nb km of kq og ku oh ky le lf lg lh bi translated">尽管swift使用ARC，但有必要记住内存管理</li><li id="61de" class="kz la je kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">在循环中使用Objective-C对象(即NSObject子类)时，应该记住内存占用，并使用Xcode检查使用了多少内存</li></ul></div></div>    
</body>
</html>