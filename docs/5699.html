<html>
<head>
<title>16 Git Tips and Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">16个Git提示和技巧</h1>
<blockquote>原文：<a href="https://itnext.io/16-git-tips-and-tricks-bf08d0602d3b?source=collection_archive---------1-----------------------#2021-05-06">https://itnext.io/16-git-tips-and-tricks-bf08d0602d3b?source=collection_archive---------1-----------------------#2021-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="84a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Git 16岁生日的时候</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6bc7a2f17d751809bdb717e00ca185aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFnmhzH7vviMXbIe5HD76g.png"/></div></div></figure><p id="9815" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在过去的6年里，我一直在使用git，根据我的经验，这里有一些技巧，可以让你成为一个更有效的git用户:</p><h1 id="388f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x00。不要强行推动</h1><p id="3ea2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">你可能经历了一次不成功的经历。例如，当您改变提交的基数或挤压提交时，可能会发生这种情况。在这种情况下，可以强行推动:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="8aeb" class="mv lr it mq b gy mw mx l my mz">git push --force</span></pre><p id="66e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ide有一个“强制按下”按钮，有时甚至会鼓励这样做。但是，我会说:</p><blockquote class="na"><p id="e31f" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">不要强行推动，除非你想打破什么东西。</p></blockquote><p id="8a31" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">危险性较小的替代方案被称为“租借强制”。如果您进行了重新调整或修改，请使用以下替代方法:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="3431" class="mv lr it mq b gy mw mx l my mz">git push --force-with-lease</span></pre><p id="ee79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">了解更多:<a class="ae np" rel="noopener ugc nofollow" target="_blank" href="/git-force-vs-force-with-lease-9d0e753e8c41?source=user_profile---------0----------------------------">Git Force vs Force with Lease</a></p><h1 id="ac3a" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x01。使用别名</h1><p id="ffc4" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">人们使用<code class="fe mn mo mp mq b">--force</code>而不是<code class="fe mn mo mp mq b">--force-with-lease</code>的原因之一是他们必须键入的字符数量。这就是别名发挥作用的地方:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="4916" class="mv lr it mq b gy mw mx l my mz">git config --global alias.enforce "push --force-with-lease"</span></pre><p id="187b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我创建了一个新的别名<code class="fe mn mo mp mq b">enforce</code>，它的行为类似于<code class="fe mn mo mp mq b">push --force-with-lease</code>:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="42ea" class="mv lr it mq b gy mw mx l my mz">git enforce</span></pre><p id="69fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在<code class="fe mn mo mp mq b">git push --force</code>比<code class="fe mn mo mp mq b">git enforce</code>要输入更多的字符。</p><blockquote class="na"><p id="9719" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">愿力量与租约同在。</p></blockquote><h1 id="cfa0" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz nq ka mc kc nr kd me kf ns kg mg mh bi translated">0x02。设置上游</h1><p id="34c5" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">推送时，您可以指定要推送至哪个远程分支:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="13eb" class="mv lr it mq b gy mw mx l my mz">git push origin master</span></pre><blockquote class="nt nu nv"><p id="20a4" class="ku kv nw kw b kx ky ju kz la lb jx lc nx le lf lg ny li lj lk nz lm ln lo lp im bi translated">奖励点:您也可以使用enforce指定分支。</p></blockquote><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="7c36" class="mv lr it mq b gy mw mx l my mz">git enforce origin the-feature-branch</span></pre><p id="5ca5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，提到远程分支机构的名称几次后会变得很烦人。上游是一个默认的远程分支，当您没有指定它时，您希望将它推入。设置它就像在push命令中写入<code class="fe mn mo mp mq b">-u</code>一样简单:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="91ec" class="mv lr it mq b gy mw mx l my mz">git push -u origin the-feature-branch</span></pre><p id="9470" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从下一次开始，您可以省略远程分支。</p><blockquote class="na"><p id="9fd8" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">如果您想将多个数据推送到一个远程分支，那么设置上游更经济。</p></blockquote><h1 id="ace2" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz nq ka mc kc nr kd me kf ns kg mg mh bi translated">0x03。正确命名分支</h1><p id="527d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">处理许多不同的特性和错误，很快就会弄不清哪个分支是哪个分支。特别是，如果你命名一个分支<code class="fe mn mo mp mq b">the-new-feature</code>或者<code class="fe mn mo mp mq b">bug-fix</code>。</p><blockquote class="na"><p id="71d0" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">为您的分支使用一个描述性的名称。</p></blockquote><p id="81bb" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">更糟糕的是，另一个开发人员可能也在修复一个bug，或者正在开发与您类似的功能。所以，你们可能有相同的分支名称，并且在不知道的情况下破坏了彼此的工作。</p><blockquote class="na"><p id="d9eb" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">在你的分行名称前加上你的首字母。</p></blockquote><p id="2a25" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">我见过的被广泛使用的标准如下:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="10d2" class="mv lr it mq b gy mw mx l my mz">git checkout -b jto/add-noob-saibot</span></pre><p id="2521" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首字母是:名的1个字母，姓的2个字母。在这种情况下，约翰·托拜厄斯变成了<code class="fe mn mo mp mq b">jto</code>。然后是斜线，然后是特征描述。更好的是，将问题/票据/任务ID添加到组合中:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="989d" class="mv lr it mq b gy mw mx l my mz">git checkout -b jto/666-add-noob-saibot</span></pre><h1 id="6214" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x04。清理本地分支机构</h1><p id="76dc" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">另一件让你很难在本地分支之间进行搜索的事情是有太多无用的分支。</p><blockquote class="na"><p id="0f5f" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">合并后删除本地分支。</p></blockquote><p id="2884" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">我太懒或太健忘，不会做那件事。因此，我偶尔运行这个神奇的命令来删除每个非主分支:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="cf60" class="mv lr it mq b gy mw mx l my mz">git branch | grep -v master | xargs git branch -D</span></pre><p id="b34e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是还有另一个神奇的设置，如果从远程存储库中删除了本地分支，那么在获取时也会删除它们:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="f630" class="mv lr it mq b gy mw mx l my mz">git config fetch.prune true</span></pre><p id="f5cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以这取决于你。你想要控制还是自动化？</p><h1 id="027a" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x05。清理本地存储的远程分支</h1><p id="e871" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">人们可能不知道这一点，但是每次您提取或获取时，所有远程分支的副本都会被下载并存储在本地。当远程分支被删除时，这些分支不会被自动删除。</p><p id="6679" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行以下命令，列出本地git repo上存储的所有远程分支:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="b715" class="mv lr it mq b gy mw mx l my mz">git branch -r</span></pre><p id="6ae3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中一些可能在远程回购中不存在。要找出是哪些，请运行以下命令:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="fc37" class="mv lr it mq b gy mw mx l my mz">git remote prune origin --dry-run</span></pre><p id="5d92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要从本地删除这些分支，请运行以下命令:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="19bc" class="mv lr it mq b gy mw mx l my mz">git remote prune origin</span></pre><h1 id="713d" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x06。隐藏消息</h1><p id="bd23" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">一个普通的git用户知道<code class="fe mn mo mp mq b">git stash</code>是做什么的:它将您未提交的更改存储在一个堆栈中。当您想要提取或者切换带有未提交变更的分支时，这是特别需要的。通常情况下，git会指示你在拉取或结帐之前先把东西藏起来。</p><p id="616b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但这并不是存储的唯一用例。在做某件事的过程中，你可能会说，“哦，我需要稍后再完成这件事；我们就暂时把它藏在这里吧”。然后你把零钱藏起来，永远忘记它。</p><p id="fed0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过执行<code class="fe mn mo mp mq b">git stash</code>，它使用最后一次提交的消息来保存您的更改。但这通常是不相关的。要用合适的服装信息隐藏更改，请执行以下操作:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="4fc6" class="mv lr it mq b gy mw mx l my mz">git stash push -m "Change the ID into a string"</span></pre><h1 id="f2b5" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x07。重定基础而不是合并</h1><p id="0552" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">维护git分支通常有两种策略:rebase vs merge。当合并把你的git历史变成一个讨厌的蜘蛛网时，重定基础保持主分支的干净和线性。但是，出于任何原因，这是git的默认行为。</p><p id="cfca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我建议你研究一下重定基础和合并，如果你还没有做的话，然后选择重定基础而不是合并。</p><p id="ce23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要在拉动时重设基础，请执行以下操作:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="8fb2" class="mv lr it mq b gy mw mx l my mz">git pull --rebase</span></pre><p id="67f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，要用主文件的最新更改更新您的特征分支，请执行以下操作:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="2975" class="mv lr it mq b gy mw mx l my mz">git pull --rebase origin master</span></pre><p id="7782" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Github的pull请求中，merge按钮可以变成rebase按钮。在GitLab上，当将一个功能分支合并到主功能时，您可以更改项目的设置来进行“快进”(这意味着它将重新建立基础)。</p><blockquote class="na"><p id="b51e" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">你不应该合并。</p></blockquote><p id="31ed" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated"><em class="nw">注意。</em>重定一个本地分支后，你要<code class="fe mn mo mp mq b">enforce</code>它(参考0x01)。</p><h1 id="9dd6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x08。将重设基础设为默认值</h1><p id="70d4" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">当您执行<code class="fe mn mo mp mq b">git pull</code>时，默认行为是获取变更，然后将它们合并到您当前的分支中。要更改默认拉取行为，请执行以下操作:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="2048" class="mv lr it mq b gy mw mx l my mz">git config pull.rebase true</span></pre><p id="46f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这会让每一个<code class="fe mn mo mp mq b">git pull</code>都变成一个<code class="fe mn mo mp mq b">git pull --rebase</code>。</p><h1 id="9dfd" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x09。拉取时自动存储</h1><p id="3aa3" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在使用<code class="fe mn mo mp mq b">git pull</code>rebase代替合并，您可以享受其他优势，如自动存储:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="e84b" class="mv lr it mq b gy mw mx l my mz">git config rebase.autoStash true</span></pre><p id="ad3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着如果你正在做某件事，你不需要在拉之前把它们藏起来；git会帮你做的。它将隐藏更改，进行拉取(rebase)，然后将隐藏的更改应用到结果中。</p><h1 id="777e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x0A。壁球</h1><p id="1d80" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">挤压基本上意味着将几个提交组合在一起。在将pull/merge请求合并回master之前，压缩其中的所有提交是一个很好的做法。然后，您有机会编写一个很好的提交消息，将所有事情都考虑进去，并创建一个更好的主分支，每个拉/合并请求或问题提交一次。</p><p id="1025" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，挤压有点棘手。首先，您需要选择想要挤压的提交数量。假设是5。然后执行以下操作:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="06f5" class="mv lr it mq b gy mw mx l my mz">git rebase -i HEAD~5</span></pre><p id="4acd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个命令在最后5次提交时启动了一个叫做交互式rebase的东西。将启动一个编辑器(如<code class="fe mn mo mp mq b">nano</code>)，其内容如下:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="ddc5" class="mv lr it mq b gy mw mx l my mz">pick f72e7cb Feat: Resurrect flatMap<br/>pick 1a18b1c Feat: Add list transformations<br/>pick 3420af4 3.0.0<br/>pick f55a9ee Docs: Add marble diagrams to README<br/>pick 0433f9d Update README.md</span></pre><p id="f7f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">保持第一行不变，用<code class="fe mn mo mp mq b">s</code>(用于挤压)替换后面各行中的每个<code class="fe mn mo mp mq b">pick</code>:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="a627" class="mv lr it mq b gy mw mx l my mz">pick f72e7cb Feat: Resurrect flatMap<br/><strong class="mq iu">s</strong> 1a18b1c Feat: Add list transformations<br/><strong class="mq iu">s</strong> 3420af4 3.0.0<br/><strong class="mq iu">s</strong> f55a9ee Docs: Add marble diagrams to README<br/><strong class="mq iu">s</strong> 0433f9d Update README.md</span></pre><p id="99df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">保存并退出。然后，编辑器再次启动，显示所有5次提交的提交消息。随意删除全部，重写整个消息。保存。退出。还有tada！就这样。</p><blockquote class="na"><p id="eb93" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">壁球。</p></blockquote><p id="95a7" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated"><em class="nw">注意。</em>压扁后需要<code class="fe mn mo mp mq b">enforce</code>而不是<code class="fe mn mo mp mq b">push</code>。</p><h1 id="7544" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x0B。重置基础前挤压</h1><p id="d45f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">假设您有一个比主分支提前13次提交、落后3次提交的功能分支。这就是rebasing所做的:它删除您的13个提交，将来自master的3个提交添加到您的分支，然后开始一个接一个地应用所有的13个提交。所以，如果有冲突，很有可能你需要修复13次。我是凭经验说话的。</p><p id="5ba3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将你的13次提交压缩为1次，使得重置基础更加容易。特别是，如果您后来的提交恢复了先前的提交或者在某种意义上取消了它们。</p><h1 id="bfaa" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x0C。改进</h1><p id="2f15" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">你把所有的提交都压扁，推到远程repo，然后“妈的，少了个分号”。在这种情况下，请修改。</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="7c16" class="mv lr it mq b gy mw mx l my mz">git commit --amend</span></pre><p id="dbd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你压扁了，准备推，但是“妈的，我忘了在提交消息里提问题ID”:修改。</p><p id="c5f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你不喜欢挤压，但仍然想保持你所有的贡献在一个承诺:修改。</p><p id="a8b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你写了宪法法律，忘了在里面尊重人的尊严:修改。</p><p id="a763" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Amend会将更改添加到最后一次提交中，并允许您更改提交消息。</p><h1 id="a833" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x0D。重写历史</h1><p id="0e3e" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">交互式重置基础不仅用于挤压。你可以用它改写(即改变信息)一个旧的提交，你可以改变提交顺序或混合；例如，挤压最近的提交，在它之前有2个提交，保持中间的提交不变。</p><p id="c4a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，只需找到提交并将<code class="fe mn mo mp mq b">pick</code>更改为<code class="fe mn mo mp mq b">reword</code>:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="4393" class="mv lr it mq b gy mw mx l my mz">pick f72e7cb Feat: Resurrect flatMap<br/>pick 1a18b1c Feat: Add list transformations<br/><strong class="mq iu">reword</strong> 3420af4 3.0.0<br/>pick f55a9ee Docs: Add marble diagrams to README<br/>pick 0433f9d Update README.md</span></pre><p id="88bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要更改顺序，只需更改选择中的顺序:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="dd1b" class="mv lr it mq b gy mw mx l my mz">pick f72e7cb Feat: Resurrect flatMap<br/><strong class="mq iu">pick 3420af4 3.0.0<br/>pick 1a18b1c Feat: Add list transformations</strong><br/>pick f55a9ee Docs: Add marble diagrams to README<br/>pick 0433f9d Update README.md</span></pre><p id="e1ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">诸如此类。</p><blockquote class="na"><p id="67b0" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">历史是由最后一个开发者书写的。</p></blockquote><h1 id="236c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz nq ka mc kc nr kd me kf ns kg mg mh bi translated">0x0E。自动挤压</h1><p id="f396" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">挤压，并使用交互式rebase工具作为一个整体，是一个非常乏味的工作，特别是如果你想改变顺序和挤压一次。这就是自动挤压介入的地方。</p><p id="a6a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您在一个特性分支中处理了3个不同的特性(顺便说一下，这是一个糟糕的实践)，并且想要将它们作为3个不同的提交合并到主分支中。但是后来发现第一次提交有问题。在这种情况下，这是最后一次提交，一旦可以修改，但它有点棘手的提交之前。</p><p id="c2c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们的提交如下:</p><ul class=""><li id="f61a" class="oa ob it kw b kx ky la lb ld oc lh od ll oe lp of og oh oi bi translated"><code class="fe mn mo mp mq b">Feat: Add feature 1</code></li><li id="8943" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated"><code class="fe mn mo mp mq b">Feat: Add feature 2</code></li><li id="e6f8" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated"><code class="fe mn mo mp mq b">Feat: Add feature 3</code></li></ul><p id="4bd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为功能1制作补丁，并使用以下消息提交它:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="29db" class="mv lr it mq b gy mw mx l my mz">git commit -m "squash! Feat: Add feature 1"</span></pre><p id="b3ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，使用自动挤压标志进行交互式重设基础:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="21d1" class="mv lr it mq b gy mw mx l my mz">git rebase -i HEAD~4 --autosquash</span></pre><p id="4993" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编辑器将自动显示正确的作业:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="b6d1" class="mv lr it mq b gy mw mx l my mz">pick f72e7cb Feat: Add feature 1<br/>squash 1a18b1c squash! Feat: Add feature 1<br/>pick 3420af4 Feat: Add feature 2<br/>pick f55a9ee Feat: Add feature 3</span></pre><h1 id="9a7c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">0x0F。自动自动挤压</h1><p id="6465" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">通过设置以下配置，使自动挤压成为交互式重定基础的默认行为:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="b3e2" class="mv lr it mq b gy mw mx l my mz">git config rebase.autosquash true</span></pre><h1 id="5c1e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">进一步阅读</h1><ul class=""><li id="335f" class="oa ob it kw b kx mi la mj ld oo lh op ll oq lp of og oh oi bi translated"><a class="ae np" href="https://twitter.com/MohammadAliEN" rel="noopener ugc nofollow" target="_blank">在Twitter上关注作者</a>以获得未来工作的通知。</li><li id="7d37" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated"><a class="ae np" rel="noopener ugc nofollow" target="_blank" href="/ten-commandments-of-git-commit-messages-94bd6dcf6e0e">Git提交消息的十诫</a></li><li id="6df3" class="oa ob it kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated"><a class="ae np" rel="noopener ugc nofollow" target="_blank" href="/13-handy-rxjs-operators-ab5a9a1db60"> 13个处理数组和元组的便捷RxJS操作符</a></li></ul></div></div>    
</body>
</html>