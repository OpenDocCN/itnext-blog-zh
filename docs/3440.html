<html>
<head>
<title>Automated TypeScript typing with GraphQL &amp; Apollo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL和Apollo实现自动打字</h1>
<blockquote>原文：<a href="https://itnext.io/automated-typescript-typing-with-graphql-apollo-4ee2a92c2fda?source=collection_archive---------2-----------------------#2019-12-17">https://itnext.io/automated-typescript-typing-with-graphql-apollo-4ee2a92c2fda?source=collection_archive---------2-----------------------#2019-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/389326c4cbf1d0d1625863b2c8af69bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6Lbq37uP6LeMHyfbHgChQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@djjabbua?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·托里斯</a>在<a class="ae kc" href="https://unsplash.com/s/photos/apollo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="8d9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">将TypeScript与GraphQL结合使用的一种方法是基于GraphQL模式生成一个TypeScript类型库，为我们可能在代码中使用的所有对象创建接口，这确实很好。</p><p id="0e4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，有一种更安全的方法可以做到这一点，那就是在每种情况下都有唯一的类型，而不是到处都可以使用的共享类型。在本文中，我将解释这种方法的错误以及如何改进它的机制。</p><blockquote class="lk ll lm"><p id="61a2" class="kd ke ln kf b kg kh ki kj kk kl km kn lo kp kq kr lp kt ku kv lq kx ky kz la ij bi translated">所有的代码都可以在这里找到:<a class="ae kc" href="https://github.com/thomasparsons/graph-apollo-typing" rel="noopener ugc nofollow" target="_blank">https://github.com/thomasparsons/graph-apollo-typing</a></p></blockquote></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="e0f2" class="ly lz iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">生成和使用类型的第一种方法</h2><p id="6711" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">生成类型的一种机制是使用与上述项目中的<em class="ln">本机</em>文件夹中的<code class="fe mw mx my mz b">yarn generate-types</code>调用类似的方法:</p><p id="52a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my mz b">cd native &amp;&amp; yarn generate-types</code></p><p id="07fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将从图中生成的模式文件转换为匹配的类型，因此:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="c91f" class="ly lz iq mz b gy ni nj l nk nl">type DogInfo {<br/>  name: String!<br/>  age: String<br/>}</span></pre><p id="8cae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">被转换为:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="d8eb" class="ly lz iq mz b gy ni nj l nk nl">export type DogInfo = {<br/>  __typename?: 'DogInfo',<br/>  name: Scalars['String'],<br/>  age?: Maybe&lt;Scalars['String']&gt;,<br/>};</span></pre><p id="d0ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么在代码中，可能会有这样的内容:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="2595" class="ly lz iq mz b gy ni nj l nk nl">import {DogInfo} from "../generated/types"</span><span id="9c5b" class="ly lz iq mz b gy nm nj l nk nl">interface Props {<br/>  dogInfo: DogInfo<br/>}</span><span id="684c" class="ly lz iq mz b gy nm nj l nk nl">export default function DogInfo({dogInfo}: Props) {<br/>  const {age, name} = dogInfo</span><span id="e6e7" class="ly lz iq mz b gy nm nj l nk nl">render (<br/>    &lt;Text&gt;{name}: {age}&lt;/Text&gt; <br/>  )<br/>}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="7d1e" class="ly lz iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">这和阿波罗有什么关系</h2><p id="bc72" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">如果上面是redux，那就<em class="ln"> ok </em>，可能不完美，但是还可以……但是，在使用GraphQL时，由于响应是针对请求的数据的，所以需要更精确的输入，所以我们来看一个查询；在这个例子中，我们期待一组狗，包括它们的年龄和名字。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="6424" class="ly lz iq mz b gy ni nj l nk nl">query getDogs {<br/>  getDogs {<br/>    dogInfo {<br/>      age<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="3d70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，最初的输入就可以了，但是，如果从查询中删除了属性:<code class="fe mw mx my mz b">age</code>，因为可能只需要名称，那么可能会出现一些问题。由于类型化在接口上仍然有<code class="fe mw mx my mz b">age</code>值，一个工程师在以后修改代码时，可能会尝试并呈现那个<em class="ln"> age </em>值，但现在还不清楚它是否会有问题。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="f5b9" class="ly lz iq mz b gy ni nj l nk nl">const {age, name} = dogInfo</span><span id="30e8" class="ly lz iq mz b gy nm nj l nk nl">render (<br/>  &lt;Text&gt;{name}: {age}&lt;/Text&gt; // this won't work as expected!<br/>)</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="e1ff" class="ly lz iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">如果类型是从查询中生成的会怎么样？</h2><p id="c380" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">除了使用上述模式之外，还有一种替代方法……</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="29a4" class="ly lz iq mz b gy ni nj l nk nl">yarn generate-query-types</span><span id="ab6b" class="ly lz iq mz b gy nm nj l nk nl">or:</span><span id="678a" class="ly lz iq mz b gy nm nj l nk nl">apollo codegen:generate generated --localSchemaFile=./generated/schema.json --target=typescript</span></pre><p id="4619" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，这将为每个查询生成一组唯一的类型(突变等)。)以便可以导入生成的类型，有点像这样:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="bc97" class="ly lz iq mz b gy ni nj l nk nl">import {getDogs_getDogs_dogInfo} from "../Queries/generated/getDogs</span><span id="34ba" class="ly lz iq mz b gy nm nj l nk nl">interface Props {<br/>  dogInfo: getDogs_getDogs_dogInfo<br/>}</span><span id="7cf1" class="ly lz iq mz b gy nm nj l nk nl">export default function DogInfo({dogInfo}: Props) {<br/>  const {age, name} = dogInfo</span><span id="3d98" class="ly lz iq mz b gy nm nj l nk nl">render (<br/>    &lt;Text&gt;{name}: {age}&lt;/Text&gt; <br/>  )<br/>}</span></pre><p id="c396" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ln">注意:实际的组件逻辑不一定会改变</em></p><p id="0328" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在IDE或CI中，很快就会发现，如果查询中没有请求<code class="fe mw mx my mz b">age</code>值，就会出现lint错误，因为该值不在类型中。如果随后添加了<code class="fe mw mx my mz b">age</code>值，并且更新了类型，linter就会通过。</p><p id="593b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，如果一个新值被添加到图中还不可用的查询中，那么GraphQL lint将失败，Apollo类型生成器也将失败。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="20eb" class="ly lz iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">不利之处</h2><p id="57d6" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">有几个负面因素…</p><ul class=""><li id="d8f7" class="nn no iq kf b kg kh kk kl ko np ks nq kw nr la ns nt nu nv bi translated">太丑了。毫无疑问，<code class="fe mw mx my mz b">import {getDogs_getDogs_dogInfo} from "../Queries/generated"</code>不是最吸引人的代码编写方式…</li><li id="d59c" class="nn no iq kf b kg nw kk nx ko ny ks nz kw oa la ns nt nu nv bi translated">它需要运行大量的脚本来保持一切都是最新的，特别是<code class="fe mw mx my mz b">apollo codegen</code>命令来保持查询的输出类型是最新的。(你可以使用<code class="fe mw mx my mz b">--watch</code>命令来省去一些麻烦)</li><li id="8be1" class="nn no iq kf b kg nw kk nx ko ny ks nz kw oa la ns nt nu nv bi translated">我不得不在<code class="fe mw mx my mz b">eslint</code>中关闭<code class="fe mw mx my mz b">camelcase</code>规则，因为目前没有办法在不使用不同的包(例如<a class="ae kc" href="https://graphql-code-generator.com/" rel="noopener ugc nofollow" target="_blank">https://graphql-code-generator.com/</a>)的情况下移除下划线</li></ul></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="9d79" class="ly lz iq bd ma mb mc dn md me mf dp mg ko mh mi mj ks mk ml mm kw mn mo mp mq bi translated">普通类型还有位置吗？</h2><p id="1a4d" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">现在最有可能的是需要一个已经就位的系统，但是，不是在从图中获取数据的时候，图中的数据可能占组件数据的80%,另外20%是状态管理，等等。为此，当然有必要进行类型化，尽管有人可能会认为形式、状态和突变应该使用或扩展自动突变类型。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/f76f690bb0e4b45fc796036850c76b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*CKrowLeB6bjwhygd_RAmvg.gif"/></div></figure></div></div>    
</body>
</html>