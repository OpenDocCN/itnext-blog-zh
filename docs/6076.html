<html>
<head>
<title>Practical introduction to algebraic datatypes (ADTs) in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中代数数据类型(ADT)的实用介绍</h1>
<blockquote>原文：<a href="https://itnext.io/practical-introduction-to-algebraic-datatypes-adts-in-typescript-1cb6952e4c6d?source=collection_archive---------2-----------------------#2021-08-10">https://itnext.io/practical-introduction-to-algebraic-datatypes-adts-in-typescript-1cb6952e4c6d?source=collection_archive---------2-----------------------#2021-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d567" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">产品类型？求和类型？变种？工会？…用打字稿？！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d9f669888ea969bdb1596d02c484f5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*viTo-zDe40549eozgnA3iQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">您可能已经在代码中使用了ADT。</figcaption></figure><p id="bb61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代数数据类型或ADT是特定种类的复合类型或类型组合。ADT的主要类别是<strong class="kw iu">产品类型</strong>和<strong class="kw iu">总和类型</strong>。重要的是，它们允许你在编译时使用你的类型系统表达强大的思想，这样你就可以编写安全、健壮的代码，在运行前捕捉错误。</p><p id="5627" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在我们深入研究乘积和求和类型之前，让我们从一个没有ADT的小编码问题和解决方案开始。假设我们有一段前端代码，它必须根据API响应呈现一些文本。为了简单起见，让我们省略像发出API请求或像React这样的库。让我们只关注这个问题:根据响应呈现不同的东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/7ce3af3d9e8457fa0b613fc8f04abb0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*0rXxPja4LmcXKwynpbjynQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">API响应= &gt;文本</figcaption></figure><p id="f3ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单吧？除了我们的API响应有惊人多的情况要处理(高<a class="ae lr" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" rel="noopener ugc nofollow" target="_blank">圈复杂度</a>)。大量嵌套的if语句和抛出的错误…如果我告诉你它包含一个bug，你要多久才能发现它(或者告诉我我错了)？编译器能告诉你是否错过了一个分支吗？我们在处理所有可能的案件吗？</p><p id="628e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们用ADTs重构这段代码之前，让我们先学习一些基本的构建模块，所以我们要准备好锤子和钉子。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="95af" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">ADTs:产品类型</h1><p id="9ffc" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">产品类型本质上是其他类型的容器，一个有<em class="mw">字段的<em class="mw">东西</em>。</em> <strong class="kw iu">元组</strong>和<strong class="kw iu">记录</strong>是最常见的产品类型。它们都是包含字段<em class="mw">的类型，字段</em>包含一些其他类型。特定产品类型的所有值都包含相同的字段集。</p><p id="807d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript支持<strong class="kw iu">元组</strong>，也可以认为是固定长度的类型化数组。它们也是类型安全的，所以如果你访问一个2元组的第三项或者试图将一个字符串设置为一个数字字段等，你会得到编译错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/96dc35908c04d68604149cf925f7690e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*CirdkcafJ2RBDkDiaSsMKw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">一个“[数字，数字]的二元组”有两个总是数字的字段。</figcaption></figure><p id="78cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TS中的记录可能有点夸张，但是您肯定可以创建行为非常接近记录的结构。大致的想法是，一个元组有编号的字段，一个记录有命名的字段。所以你可以只使用一个对象文字，和元组一样，类型系统支持你:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/492dfb5d9f810eccc9932e40f998ff48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*Ab17Uz-N7OHb3vusgsCfjg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">记录{ a: number，b: string }有两个字段a和b，它们总是一个数字和一个字符串。其他的都是编译错误。</figcaption></figure><p id="a3e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么为什么这些被称为产品类型呢？这就把我们带到了类型论、范畴论、数学:“一个产品类型的所有可能值的集合<em class="mw">就是它的字段类型的所有可能值的集合的集合论乘积，即</em> <a class="ae lr" href="https://en.wikipedia.org/wiki/Cartesian_product" rel="noopener ugc nofollow" target="_blank"> <em class="mw">【笛卡尔积】</em> </a> <em class="mw">”。也许我们现在可以坚持使用元组和记录。</em></p><h1 id="f51d" class="lz ma it bd mb mc mz me mf mg na mi mj jz nb ka ml kc nc kd mn kf nd kg mp mq bi translated">ADTs:总和类型</h1><p id="e356" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">虽然<a class="ae lr" href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html" rel="noopener ugc nofollow" target="_blank">联合类型</a>非常接近，但TypeScript并没有真正的Sum类型。如果产品类型是字段的容器，那么Sum类型就像是可能性的容器。一个<em class="mw">东西</em>要么是<em class="mw">这个</em>要么是<em class="mw">那个</em>但不能两者都是。在TypeScript中，具有类型string或number的联合类型确保该类型的任何值都是字符串或数字:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="c840" class="nj ma it nf b gy nk nl l nm nn">type Thing = string | number // string or number</span></pre><p id="275a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了看到Sum类型的更强大的版本，我们需要改变我们的语言。让我们在最初问题的背景下看一个来自ReasonML(或现在的ReScript)的代码示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/372e285c63ada092c0b779acaefd782f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Xf65TsCQqJ1lgz1vi2e0w.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">“响应”是加载、错误或数据的总和类型。“api”属于响应类型(自动推断)。</figcaption></figure><p id="1e51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有几个新概念，请多包涵。“响应”类型是我们的求和类型，在ReasonML/ReScript中称为“变量类型”。它类似于TS联合类型，不同之处在于我们需要将可能的类型打包到类型构造函数中，如“Loading”或“Error”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nt"><img src="../Images/c05a2259feedb196c8d2a3730f1efb2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*129fisPBH_ayxM0zpKXbLQ.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">类型推断可以计算函数的签名。</figcaption></figure><p id="3d73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“render”函数接受一个名为“api”的参数，该参数实际上属于response类型。这是由类型系统自动推断的。</p><p id="48d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很酷的一点是，我们可以使用<a class="ae lr" href="https://en.wikipedia.org/wiki/Pattern_matching" rel="noopener ugc nofollow" target="_blank">模式匹配</a>通过使用switch语句来调查响应的内容。如果响应正在加载，那么它将匹配第一个分支，输出将是“仍在加载”，如果是错误，那么我们可以打印“错误！{s}”。我们知道s是一个字符串，因为响应类型有错误(字符串)。如果我们没有处理Sum类型的所有可能性，类型系统也可以计算出来:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f60ba6ffe345d2a58e3438afe8a02d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*Ip7-BQp0rIDqkTWrGWaF6g.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">哎呀！你没有检查foo是否没有值！</figcaption></figure><p id="0386" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么为什么称之为求和型呢？再一次，有点理论性，但是我们开始了:<em class="mw">“一个和类型的所有可能值的集合是集合论和，即它的变体的所有可能值的集合的</em> <a class="ae lr" href="https://en.wikipedia.org/wiki/Disjoint_union" rel="noopener ugc nofollow" target="_blank"> <em class="mw">【不相交的联合】</em> </a> <em class="mw">。”。</em>因此，这次它不是像Product type中那样是其字段的笛卡尔乘积，而是可能性的总和。如果这没有任何意义，不要担心。为了本文的目的，理解理论方面是不必要的。</p><h1 id="37a1" class="lz ma it bd mb mc mz me mf mg na mi mj jz nb ka ml kc nc kd mn kf nd kg mp mq bi translated">回到最初的问题，现在用ADTs</h1><p id="30af" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">所以，现在我们已经学习了基本的ADT，是时候将它们应用到我们最初的问题中，看看我们是否能摆脱这种令人讨厌的if-else混乱。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/690e14b0ba41840f09b9f726a3ba2e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*ZciiLREnApTVrk3QrqJIHg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">比原来的干净安全多了。</figcaption></figure><p id="78ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“APIResponse”是不同记录的联合类型。虽然不是一个完全合适的ADT，但对于我们的用例来说，它很好地模拟了Sum类型。</p><p id="996e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“render”使用一个常规开关来模拟匹配Sum类型的模式。我们使用特殊字段“t”来提供一个<a class="ae lr" href="https://en.wikipedia.org/wiki/Tagged_union" rel="noopener ugc nofollow" target="_blank">标记的联合</a>。</p><p id="cd92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript实际上足够聪明，可以在编译时解决几个问题:</p><ul class=""><li id="b57a" class="nw nx it kw b kx ky la lb ld ny lh nz ll oa lp ob oc od oe bi translated"><strong class="kw iu">开关盒必须处理所有的标签</strong>，<em class="mw">如果你添加一个新标签，编译器会告诉你</em>。</li><li id="e127" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated"><strong class="kw iu">开关盒中的分支能够识别应该使用哪个记录。</strong> <em class="mw">例如，“。foo”仅在case“Data”分支while”中可用。错误”仅在“错误”分支中可用。</em></li><li id="991e" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated"><strong class="kw iu"> Render必须返回一个字符串，以便正常检查所有返回语句。</strong> <em class="mw">果然不出所料。</em></li></ul><h1 id="131a" class="lz ma it bd mb mc mz me mf mg na mi mj jz nb ka ml kc nc kd mn kf nd kg mp mq bi translated">结论</h1><p id="bd99" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们现在已经通过一个实例介绍了ADTs: Product和Sum类型。通过几个基本的构建块，我们能够在TypeScript中将一个复杂的if-else场景重构为一个漂亮的模式匹配，该模式匹配于一个带标记的并集(如果您愿意，可以称为某种类型的Sum类型)。结果是清晰、安全的，并且可以很好地容忍像添加/删除病例这样的变化。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="1500" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">额外收获:关于Sum类型示例中的选项(字符串)</h1><p id="6ce3" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">Option是几种语言中非常常见的求和类型。使用我们的标记联合，TypeScript中的基本定义可能是这样的:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ea5f" class="nj ma it nf b gy nk nl l nm nn">// TypeScript<br/>type Option&lt;T&gt; = { t: 'Some', value: T } | { t: 'None' }</span><span id="f652" class="nj ma it nf b gy ok nl l nm nn">// OCaml / ReasonML / ReScript - a bit shorter<br/>type option&lt;'a&gt; = Some('a) | None</span></pre><p id="e377" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以它是一个sum类型，要么包含一个值，要么不包含。然而，类似于TypeScript中的可空值，在具有适当ADT的语言中通常根本没有“null ”,因为不需要它。毕竟，这是一个十亿美元的错误。当某些东西可能没有定义时，只需使用选项类型和模式匹配Some(x) | None分支并相应地采取行动:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a4dc" class="nj ma it nf b gy nk nl l nm nn">let do_it = opt =&gt; switch (opt) {<br/>  | Some(value) =&gt; "Yay, got {value}"<br/>  | None =&gt; "Value was not defined"<br/>}</span></pre><p id="7e50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其他类似于Option的非常有用的工具包括:Result，要么，…甚至List。它们的共同点是它们都可以实现为Sum类型。哦，他们也是单子。但这不是一个关于单子的帖子。或者是？；-)</p><h1 id="2400" class="lz ma it bd mb mc mz me mf mg na mi mj jz nb ka ml kc nc kd mn kf nd kg mp mq bi translated">额外收获:你可以看看TS图书馆</h1><p id="fe43" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">与下一级匹配的标记联合和开关盒模式:</p><ul class=""><li id="ff55" class="nw nx it kw b kx ky la lb ld ny lh nz ll oa lp ob oc od oe bi translated"><a class="ae lr" href="https://github.com/gvergnaud/ts-pattern" rel="noopener ugc nofollow" target="_blank">https://github.com/gvergnaud/ts-pattern</a></li></ul><p id="e4af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">先进，但功能强大。函数编程符合ADTs:</p><ul class=""><li id="727a" class="nw nx it kw b kx ky la lb ld ny lh nz ll oa lp ob oc od oe bi translated">https://github.com/gcanti/fp-ts<a class="ae lr" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank"/></li><li id="9177" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">【https://github.com/gcanti/io-ts T4】</li></ul></div></div>    
</body>
</html>