<html>
<head>
<title>Native Inverno with GraalVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有GraalVM的本机Inverno</h1>
<blockquote>原文：<a href="https://itnext.io/native-inverno-with-graalvm-f64bd1533aab?source=collection_archive---------5-----------------------#2021-09-28">https://itnext.io/native-inverno-with-graalvm-f64bd1533aab?source=collection_archive---------5-----------------------#2021-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ea82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除非你住在山洞里，否则你不可能错过围绕GraalVM的所有宣传，以及生成通常在JVM上运行的Java程序的优化本机映像的能力。<a class="ae kl" href="https://inverno.io" rel="noopener ugc nofollow" target="_blank"> Inverno Framework </a>旨在减少应用运行时开销，从而加快应用启动并改善资源消耗。通过依赖编译器而不是运行时库来组装应用程序组件，以及通过将反射的使用减少到几乎为零，这已经成为可能。理论上，所有这些都将极大地促进使用GraalVM生成原生映像，所以我决定看看它在实践中是如何进行的。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/7158358cd6c7f856a9648b271500d790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*q5tnX5SrCO7dG13czsQr1g.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">本土因弗诺</figcaption></figure><p id="006e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是首先，什么是本机映像以及它是如何工作的。当JVM启动一个Java程序时，它加载可从程序入口点访问的类:main方法，它解释字节码，并使用JIT编译器将其翻译成本机代码。这就是为什么Java经常被批评为慢的原因，这是真的也是假的，因为Java程序只是启动慢，但是过一段时间后，一旦所有代码都被JIT编译器翻译了，性能就可以和本机代码相比了。当构建本机映像时，我们试图在构建时而不是运行时提前完成JIT编译器的工作。由此产生的本机映像应该启动得更快，使用的内存更少，因为程序精确地集成了运行时所需的内容。可以想象，这并不是没有限制的，但是我稍后会谈到这些。</p><p id="8132" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们试一试吧！</p><p id="66c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本机映像生成需要<a class="ae kl" href="https://www.graalvm.org/downloads/" rel="noopener ugc nofollow" target="_blank"> GraalVM </a>和<a class="ae kl" href="https://www.graalvm.org/reference-manual/native-image/" rel="noopener ugc nofollow" target="_blank">本机映像命令</a>。</p><p id="fe5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我考虑了一个简单的<a class="ae kl" href="https://github.com/inverno-io/inverno-examples/tree/native-tests/inverno-example-http" rel="noopener ugc nofollow" target="_blank"> HTTP应用程序</a>，我对它进行了一点改造以进行一些测试(移除了TLS、HTTP压缩和epoll)。我还使用了<a class="ae kl" href="https://graalvm.github.io/native-build-tools/0.9.5/index.html" rel="noopener ugc nofollow" target="_blank"> GraalVM本地构建工具</a>来将本地映像构建过程集成到项目构建中。</p><p id="68a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我必须做的第一件事是提供<a class="ae kl" href="https://www.graalvm.org/reference-manual/native-image/BuildConfiguration/" rel="noopener ugc nofollow" target="_blank">构建配置</a>来告诉GraalVM本机映像构建器应该在构建时或运行时加载哪些类，哪些类通过反射加载，哪些资源应该集成到结果映像中……许多框架试图自动化这一步骤，主要是通过嵌入一些常见配置，但也有一些特别的静态代码分析。例如，Spring非常依赖反射，它提供了在构建时提取对象图形并生成合适配置的工具。</p><p id="4855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要学习的第一个经验是，实际上不需要提供任何特定的配置来正确支持Inverno的模块，因为Inverno不依赖反射来组装应用程序。然而，对于Log4j2、Netty或Jackson等第三方库来说，事情要复杂一些，不过我会在后面解释这些限制。使用<a class="ae kl" href="https://www.graalvm.org/reference-manual/native-image/Agent/" rel="noopener ugc nofollow" target="_blank"> GraalVM跟踪代理</a>并查看类初始化报告，我最终创建了一个工作配置。我基本上选择在构建时初始化Log4j2，在运行时初始化Netty。这可能不会产生最佳的图像，但至少它的工作没有太多的麻烦。</p><p id="2a14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图比较了本机映像和JVM上运行的应用程序的启动时间和吞吐量，也就是负载下的性能。这些数据是通过保留5次运行的最佳结果获得的，但冷JVM吞吐量除外，这是第一次在<em class="km">冷</em> JVM上运行的结果。使用具有256个连接的<a class="ae kl" href="https://github.com/wg/wrk" rel="noopener ugc nofollow" target="_blank"> wrk </a>获得吞吐量，在15秒内使用8个线程。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/022a262489c20fb73844766095941ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*GDYmyyzGfr7sRlp7NR3vcA.png"/></div></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi la"><img src="../Images/c3ff05542d98099de4038e0094d78e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*lJnasyWDqsing4p5z3amsg.png"/></div></div></figure><p id="10ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些结果基本上显示了两件有趣的事情。首先，本机映像将启动时间提高了98.84%，这是一个巨大的提高，尤其是考虑到它最初只有258毫秒<em class="km">和</em>。第二点更令人不安，本机映像的性能下降了54.45%。<em class="km">冷的</em> JVM数字正好证实了运行在JVM上的Java应用程序必须预热才能发挥其全部潜力。</p><p id="1570" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于原生映像目前不支持epoll等原生传输，这种性能下降会带来更多问题，在支持epoll的平台上，性能会再下降15%。除此之外，应用程序运行良好，我们还可以注意到，本机映像没有预热时间，吞吐量从一开始就是恒定的。</p><p id="837f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，我想知道其他的应用程序框架，如<a class="ae kl" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring </a>或<a class="ae kl" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>，它们积极地支持原生映像生成，是否存在同样的性能问题。为了测试这些，我创建了一个简单的<a class="ae kl" href="https://code.quarkus.io" rel="noopener ugc nofollow" target="_blank"> RESTEasy JAX-RS Quarkus </a>应用程序，并使用了Spring native<a class="ae kl" href="https://github.com/spring-projects-experimental/spring-native/tree/main/samples/webflux-netty" rel="noopener ugc nofollow" target="_blank">web flux Netty</a>示例应用程序。下图显示了Spring和Quarkus的结果。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/80a533ea18bb733bdd9731b88e1be581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*9tY6b02dYhvzLPm_9gAktQ.png"/></div></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi la"><img src="../Images/06c87a0deb7b053f012d08c344cc87d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*KYhMruY5IzbKkwU7QkytyA.png"/></div></div></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/f04ba29430ba3aad896dcc5696faa91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*oBfqckxuUjt5M7cNd8Bafw.png"/></div></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi la"><img src="../Images/270cf88901480e2ceadc740db48a57e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*3hPTRe_xBN-KIGPtzTgc_w.png"/></div></div></figure><p id="bbc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，我们使用Quakus或Spring Webflux观察到了相同的模式:与JVM相比，Quakus的性能下降了48 %, Spring的性能下降了52%,而启动时间却大大减少了。</p><p id="bd88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么为什么我们会有这样的差异呢？为了获得可能的最佳性能，JVM不仅仅将字节码翻译成本地代码，它还在运行时根据负载模式对其进行优化。这基本上意味着JIT编译器的输出可能会因运行的不同而不同。另一方面，当在构建时生成本机映像时，不可能预测会导致整体性能降低的负载模式。GraalVM Enterprise Edition提供了<a class="ae kl" href="https://www.graalvm.org/reference-manual/native-image/PGO/" rel="noopener ugc nofollow" target="_blank">配置文件引导优化</a>，基本上允许生成一个可在运行时收集代码执行频率配置文件的插装本机映像，该配置文件稍后可用于生成一个专门优化的本机映像。</p><p id="4d6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图将配置文件引导的优化本机映像的吞吐量与之前的结果进行了比较。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi la"><img src="../Images/875a390322559f0ce032570808f02fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*yfMTDWW-iYFMnLIbY-jexg.png"/></div></div></figure><p id="e7e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们清楚地看到PGO映像做得更好，但是它仍然落后JVM 32%。</p><p id="77cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于原生映像的限制，我已经提到了一个事实，即目前Netty的原生传输(epoll，kqueue…)不被支持，这导致了支持它的平台上的一些性能损失。Java模块系统也不被支持，这是非常不幸的，但目前这并不是一个问题。我最大的问题实际上与构建本机映像时必须明确指定的资源有关。在运行时，解析类路径或模块路径上的资源的方式非常不同，这引起了一些关注:因为没有模块，所以不能按模块解析资源，因为没有类路径，所以不能列出资源或区分具有相同路径的资源，必须知道资源的确切路径，否则会在映像中发生冲突。例如，Inverno Web模块受到影响，因为OpenAPI和WebJars功能依赖于以前的技术来发现和公开静态资源。</p><p id="b7ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论是使用反射、类路径/模块资源还是类初始化树，尤其是组件之间的依赖关系，构建本机映像的能力都会对应用程序的代码和架构产生一些影响。创建本机映像所需的封闭世界可能很困难，尤其是如果应用程序使用许多不提供或不能提供本机配置的第三方库。单个静态最终场可以对如何构建图像产生重大影响。</p><p id="c74b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于内存消耗的最后一点:我没有提到它，因为对于我测试过的任何框架，在高负载下，我没有看到本机映像和JVM之间的显著差异。然而，这在很大程度上取决于映像是如何构建的，所以对我来说，这是不确定的，尽管这显然是原生映像的承诺之一。</p><h1 id="42bd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">减去</h1><p id="fba9" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">随着云和容器技术的发展，JVM提供的可移植性已经变得不那么吸引人了，甚至因为不必要的长启动时间和预热阶段而被视为一个问题。本机映像部分解决了这个问题，并提供了极快的启动速度。</p><p id="a774" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，如果我考虑到复杂性、对代码的影响以及使用JVM全部功能的限制，我不确定为常规的长时间运行的微服务应用程序生成本机映像是否是可取的。考虑到本机映像与JVM相比表现不佳，这一点更是如此，即使使用配置文件引导的优化也不容易设置，并且只附带了非免费的GraalVM Enterprise Edition。</p><p id="5c3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么Java原生是Java的未来吗？是的，最有可能的是，这是行业的发展方向，但警告目前太大了，我现在能看到的唯一应用是无服务器/FaaS应用，对这些应用来说，极快的启动是必须的。但是对于任何其他用例，我认为重要的是将启动时间减少到最小，最有效地利用资源，让JVM做剩下的事情，这正是<a class="ae kl" href="https://inverno.io" rel="noopener ugc nofollow" target="_blank"> Inverno Framework </a>正在做的。</p></div></div>    
</body>
</html>