<html>
<head>
<title>The Hidden Power of Custom States For Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件自定义状态的隐藏功能</h1>
<blockquote>原文：<a href="https://itnext.io/the-hidden-power-of-custom-states-for-web-components-dcae5b048e20?source=collection_archive---------1-----------------------#2022-11-16">https://itnext.io/the-hidden-power-of-custom-states-for-web-components-dcae5b048e20?source=collection_archive---------1-----------------------#2022-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0094" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">定制元素发展的关键一步</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/fe0e23796a82c940c7a46f4dc7ea55e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AEWkDz1MR41S1CDu"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@justusmenke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Justus Menke </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c322" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我以前的文章“<a class="ae le" href="https://javascript.plainenglish.io/web-components-can-now-be-native-form-elements-107c7a93386" rel="noopener ugc nofollow" target="_blank"> Web组件现在可以是原生表单元素</a>和“<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/native-form-validation-of-web-components-a599e85176c7">Web组件的原生表单验证</a>”中，我提到了使定制元素与表单相关联的<code class="fe lf lg lh li b">ElementInternals</code>属性。</p><p id="8006" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该接口还使开发人员能够将自定义状态与自定义元素相关联，并基于这些状态来设计它们的样式。</p><p id="484d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">ElementInternals</code>的<code class="fe lf lg lh li b">states</code>属性返回一个<code class="fe lf lg lh li b">CustomStateSet</code>，它存储了一个定制元素的可能状态列表，并允许在该列表中添加和删除状态。</p><p id="3b19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">集合中的每个状态都由一个与CSS自定义属性形式相同的字符串表示，即<code class="fe lf lg lh li b">--mystate</code>。</p><p id="e8a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，可以使用自定义状态伪类从CSS中访问这些状态，就像访问内置状态一样。</p><p id="04b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，可以使用内置的<code class="fe lf lg lh li b">:checked</code>伪类从CSS访问选中的复选框:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="08c4" class="ln lo it li b be lp lq l lr ls">input[type=”checkbox”]:checked {<br/> outline: solid green;<br/>}<br/></span></pre><p id="91b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个例子是禁用的<code class="fe lf lg lh li b">button</code>，可以使用<code class="fe lf lg lh li b">:disabled</code>伪类从CSS中访问它:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="ab11" class="ln lo it li b be lp lq l lr ls">button:disabled {<br/> cursor: not-allowed;<br/>}</span></pre><p id="e635" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，包含自定义状态<code class="fe lf lg lh li b">--mystate</code>的元素可以从CSS中访问，如下所示:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="5ce4" class="ln lo it li b be lp lq l lr ls">my-element:--mystate {<br/> color: red;<br/>}</span></pre><h1 id="c090" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">自定义状态的用例</h1><p id="c102" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">自定义状态解锁了一个强大的功能。</p><p id="9a98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们使Web组件能够基于内部状态进行样式化，而不必向组件添加属性或类来反映这些状态，因此它们完全是内部的。</p><p id="bce5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，假设您有一个显示播放视频的播放按钮的<code class="fe lf lg lh li b">&lt;video-player&gt;</code>组件。</p><p id="c045" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当单击播放按钮并且视频开始播放时，您希望隐藏播放按钮并显示暂停按钮。</p><p id="c723" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，当点击暂停按钮时，它将被隐藏，播放按钮将再次显示。</p><p id="0b50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个简单的方法是引入一个<code class="fe lf lg lh li b">playing</code>属性，并将其反射到一个<code class="fe lf lg lh li b">playing</code>属性，并使用<code class="fe lf lg lh li b">:host</code>伪类来显示和隐藏按钮:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="f5d2" class="ln lo it li b be lp lq l lr ls">class VideoPlayer extends HTMLElement {<br/><br/>  constructor() {<br/>    super();<br/><br/>    const shadowRoot = this.attachShadow({mode: 'open'});<br/><br/>    shadowRoot.innerHTML = `<br/>      &lt;style&gt;<br/>        :host {<br/>          display: block;<br/>          width: 300px;<br/>          height: 300px;<br/>          border: 2px solid red;<br/>          display: flex;<br/>          justify-content: center;<br/>          align-items: center;<br/>          background-color: transparent;<br/>        }<br/><br/>        #pause {<br/>          display: none;<br/>        }<br/><br/>        :host([playing]) #play {<br/>          display: none;<br/>        }<br/><br/>        :host([playing]) #pause {<br/>          display: block;<br/>        }<br/>      &lt;/style&gt;<br/><br/>      &lt;button id="play" type="button"&gt;Play&lt;/button&gt;<br/>      &lt;button id="pause" type="button"&gt;Pause&lt;/button<br/>    `;<br/>  }<br/><br/>  connectedCallback() {<br/>    const playButton = this.shadowRoot.querySelector('#play');<br/>    const pauseButton = this.shadowRoot.querySelector('#pause');<br/><br/>    playButton.addEventListener('click', () =&gt; {<br/>      this.playing = true;<br/>    });<br/><br/>    pauseButton.addEventListener('click', () =&gt; {<br/>      this.playing = false;<br/>    });<br/>  }<br/><br/>  get playing() {<br/>    return this.hasAttribute('playing');<br/>  }<br/><br/>  set playing(isPlaying) {<br/>    if(isPlaying) {<br/>      this.setAttribute('playing', '');<br/>    }<br/>    else {<br/>      this.removeAttribute('playing');<br/>    }<br/>  }<br/>}</span></pre><p id="c2f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，将显示播放按钮。已经为<code class="fe lf lg lh li b">playing</code>属性定义了一个setter，它或者设置或者删除<code class="fe lf lg lh li b">playing</code>属性，CSS规则使用<code class="fe lf lg lh li b">:host</code>伪类来显示和隐藏按钮。</p><p id="b597" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个工作示例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用属性设置样式</figcaption></figure><p id="7434" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这样做很好，但是这种实现有一个潜在的问题。</p><p id="a0ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像这样将内部属性公开为属性可能并不总是可取的，并且会破坏封装。</p><p id="1ada" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，暴露一个<code class="fe lf lg lh li b">playing</code>属性可能不是一个坏主意，但它确实给用户通过添加属性来手动设置组件处于<code class="fe lf lg lh li b">playing</code>状态的能力，但它实际上不会开始播放视频。</p><p id="be6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">公开这个属性甚至会提高人们的期望，即只需添加<code class="fe lf lg lh li b">playing</code>属性就可以播放视频。</p><p id="5edf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，添加一个属性来将Web组件置于某种状态并不能真正将其置于该状态，因为它并没有设置相应的<em class="mx">属性:</em>仅仅添加<code class="fe lf lg lh li b">playing</code>属性并不会将<code class="fe lf lg lh li b">playing</code>属性设置为<code class="fe lf lg lh li b">true</code>。</p><p id="ec78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然在这种情况下，它可能不会造成真正的伤害，但总会有公开内部属性不是一个好主意的情况。</p><p id="92eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是自定义状态的一个完美用例:没有属性会被暴露，但是组件仍然可以基于这些状态使用CSS进行样式化。</p><h1 id="8afb" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">添加和移除自定义状态</h1><p id="a177" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">如上所述，所有定制状态都存储在一个<code class="fe lf lg lh li b">CustomStateSet</code>对象中，该对象存储在<code class="fe lf lg lh li b">ElementInternals</code>接口的<code class="fe lf lg lh li b">states</code>属性中。</p><p id="01aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它有方法<code class="fe lf lg lh li b">add</code>和<code class="fe lf lg lh li b">delete</code>来添加和删除状态，还有方法<code class="fe lf lg lh li b">has</code>来检查元素是否有特定的状态。</p><p id="1f01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他值得注意的方法有<code class="fe lf lg lh li b">clear</code>清除所有状态和<code class="fe lf lg lh li b">forEach</code>迭代元素的所有状态:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="ed3e" class="ln lo it li b be lp lq l lr ls">// attach the internals<br/>this.internals = this.attachInternals();<br/><br/>// add states<br/>this.internals.states.add('--foo');<br/>this.internals.states.add('--bar');<br/><br/>// iterate over states<br/>this.internals.states.forEach(state =&gt; {<br/> console.log(state); // foo bar<br/>});<br/><br/>// remove states<br/>this.internals.states.delete('--bar');<br/><br/>// check for existence of states<br/>this.internals.states.has('--foo'); // true<br/>this.internals.states.has('--bar'); // false</span></pre><p id="b12e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您试图添加一个不以<code class="fe lf lg lh li b">--</code>开头的状态时，将会抛出一个错误:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="4ae4" class="ln lo it li b be lp lq l lr ls">this.internals = this.attachInternals();<br/>this.internals.states.add('foo'); // error, does not start with '--'</span></pre><p id="755c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使前面的示例能够处理自定义状态，将“playing”属性的getter和setter更改为处理这些状态:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="2e80" class="ln lo it li b be lp lq l lr ls">get playing() {<br/>  return this.internals.states.has('--playing');<br/>}<br/><br/>set playing(isPlaying) {<br/>  if(isPlaying) {<br/>    this.internals.states.add('--playing');<br/>  }<br/>  else {<br/>    this.internals.states.delete('--playing');<br/>  }<br/>}</span></pre><p id="f732" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且<code class="fe lf lg lh li b">:host()</code>伪类现在使用<code class="fe lf lg lh li b">--playing</code>选择器而不是<code class="fe lf lg lh li b">[playing]</code>:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="44e6" class="ln lo it li b be lp lq l lr ls">host(:--playing) #play {<br/>  display: none;<br/>}<br/><br/>:host(:--playing) #pause {<br/>  display: block;<br/>}</span></pre><p id="eda4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这确保了没有内部属性被公开为属性，但是消费者仍然可以通过<code class="fe lf lg lh li b">internals</code>属性访问<code class="fe lf lg lh li b">states</code>，并通过调用<code class="fe lf lg lh li b">add</code>和<code class="fe lf lg lh li b">delete</code>方法来添加或移除状态:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="8b77" class="ln lo it li b be lp lq l lr ls">const player = document.querySelector('video-player');<br/>player.internals.states.add('--playing');</span></pre><p id="750f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更糟糕的是，消费者可以直接调用<code class="fe lf lg lh li b">playing</code>的setter来改变内部状态。</p><p id="e9e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过在getter和setter以及<code class="fe lf lg lh li b">internals</code>属性前面加上前缀<code class="fe lf lg lh li b">#</code>使它们私有来解决这个问题:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="4ca7" class="ln lo it li b be lp lq l lr ls">// internals is now private<br/>this.#internals = this.attachInternals();<br/><br/>get #playing() {<br/>  return this.#internals.states.has('--playing');<br/>}<br/><br/>set #playing(isPlaying) {<br/>  if(isPlaying) {<br/>    this.#internals.states.add('--playing');<br/>  }<br/>  else {<br/>    this.#internals.states.delete('--playing');<br/>  }<br/>}</span></pre><p id="2cff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为私有属性编写一个getter和setter对可能感觉违背直觉，但这实际上是可行的。 </p><p id="ad52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使<code class="fe lf lg lh li b">playing</code>定义了getter和setter，它仍然是私有的，只能从类内部访问。</p><p id="79e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给它赋值将调用setter，读取它的值将调用getter。</p><p id="7e37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是完整的代码:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="632f" class="ln lo it li b be lp lq l lr ls">class VideoPlayer extends HTMLElement {<br/>  #internals;  // class field needed for private property<br/><br/>  constructor() {<br/>    super();<br/><br/>    const shadowRoot = this.attachShadow({mode: 'open'});<br/><br/>    this.#internals = this.attachInternals();<br/><br/>    shadowRoot.innerHTML = `<br/>      &lt;style&gt;<br/>        :host {<br/>          width: 300px;<br/>          height: 300px;<br/>          border: 2px solid red;<br/>          display: flex;<br/>          justify-content: center;<br/>          align-items: center;<br/>          background-color: transparent;<br/>        }<br/><br/>        #pause {<br/>          display: none;<br/>        }<br/><br/>        :host(:--playing) #play {<br/>          display: none;<br/>        }<br/><br/>        :host(:--playing) #pause {<br/>          display: block;<br/>        }<br/>      &lt;/style&gt;<br/><br/>      &lt;button id="play" type="button"&gt;Play&lt;/button&gt;<br/>      &lt;button id="pause" type="button"&gt;Pause&lt;/button<br/>    `;<br/>  }<br/><br/>  connectedCallback() {<br/>    const playButton = this.shadowRoot.querySelector('#play');<br/>    const pauseButton = this.shadowRoot.querySelector('#pause');<br/><br/>          <br/>    playButton.addEventListener('click', () =&gt; {<br/>      this.#playing = true;<br/>    });<br/><br/>    pauseButton.addEventListener('click', () =&gt; {<br/>      this.#playing = false;<br/>    });<br/>  }<br/><br/>  get #playing() {<br/>    return this.#internals.states.has('--playing');<br/>  }<br/><br/>  set #playing(isPlaying) {<br/>    if(isPlaying) {<br/>      this.#internals.states.add('--playing')<br/>    }<br/>    else {<br/>      this.#internals.states.delete('--playing');<br/>    }<br/>  }<br/>}</span></pre><p id="f225" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个工作示例，在编写本文时，它只能在Chrome 90+上运行:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用自定义状态设置样式</figcaption></figure><p id="1159" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些例子展示了如何使用<code class="fe lf lg lh li b">:host</code>伪类，基于来自组件内<em class="mx">的定制状态来设计定制元素的样式。</em></p><p id="8df9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自定义元素也可以基于自定义状态从外部的<em class="mx">进行样式化。</em></p><p id="3166" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该样式与基于内置状态的样式组件具有相同的形式，如<code class="fe lf lg lh li b">:checked</code>和<code class="fe lf lg lh li b">:hover</code>:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="9934" class="ln lo it li b be lp lq l lr ls">video-player:--playing {<br/>  border: 1px solid red;<br/>}</span></pre><p id="8876" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当从内部和外部为同一CSS属性定义基于自定义状态的样式时，在外部定义的样式优先。</p><p id="50de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中，当组件处于<code class="fe lf lg lh li b">--playing</code>自定义状态时，它将获得一个绿色边框。</p><p id="4e1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">组件内为<code class="fe lf lg lh li b">--playing</code>状态定义的蓝色边框将被覆盖:</p><pre class="kp kq kr ks gt lj li lk bn ll lm bi"><span id="0ac8" class="ln lo it li b be lp lq l lr ls">// styling defined outside the component<br/>// this will have precedence so the component will get a green border<br/>video-player:--playing {<br/>  border: 2px solid green;<br/>}<br/><br/>// styling defined inside the component<br/>// this will be overwritten by the styling defined outside of it<br/>:host(:--playing) {<br/>  border: 2px solid blue;<br/>}</span></pre><h1 id="b00c" class="lt lo it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="f49a" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">自定义状态是Web组件发展过程中的关键一步。</p><p id="3fda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们支持组件的样式化，而不必添加类或属性，这允许组件的状态保持只读，因此它永远不会被外部操纵。</p><p id="48da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对<code class="fe lf lg lh li b">ElementInternals</code>的支持尚未登陆Safari，但已经在Safari技术预览版中部分实现。</p><p id="cbd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Twitter上关注我，在那里我写了现代网络能做什么，PWAs，和网络组件。</p></div></div>    
</body>
</html>