<html>
<head>
<title>Creating AWS Lambda Applications With SAM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SAM创建AWS Lambda应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/creating-aws-lambda-applications-with-sam-dd13258c16dd?source=collection_archive---------0-----------------------#2018-11-02">https://itnext.io/creating-aws-lambda-applications-with-sam-dd13258c16dd?source=collection_archive---------0-----------------------#2018-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="295d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将解释什么是AWS无服务器应用程序模型(SAM ),以及如何使用它来创建AWS Lambda应用程序。</p><h1 id="d003" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">问题是</h1><p id="9681" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">许多AWS Lambda教程要求您首先在AWS控制台中创建一个新的Lambda函数，此后不久，您将看到以下界面:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/c8ca4cd43995821a98c07759387ecf64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGcoFVD0FpJD2VcR5v9teg.png"/></div></div></figure><p id="fd57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个文本编辑器看起来很可疑。这是不是建议你在里面写Lambda函数的代码？在基础设施即代码(IaC)的时代，一切都被写入文件并受版本控制，Lambda函数的代码必须放在AWS网站上复杂的文本编辑器中，这可能吗？</p><p id="24fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不，一点也不。真正的方法是使用AWS <strong class="js iu">无服务器应用程序模型(SAM) </strong>。SAM是AWS的IaC解决方案，用于定义和部署Lambda应用程序，而无需接触AWS控制台。本文解释了如何使用SAM。</p><h1 id="f683" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">最终产品</h1><p id="96a6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在本文中，我们将逐步构建以下AWS Lambda应用程序。所有这些都将通过SAM“作为代码”创建，无需在AWS控制台中单击一下:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi md"><img src="../Images/b6c1684bf94b742e048d77bdd949700d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-mysbIDl5XmamF2LmW9M1g.png"/></div></div></figure><p id="8a0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该应用程序由一个API网关、一个Lambda函数和一个简单的通知服务(SNS)主题组成。当API网关接收到HTTP请求时，它触发Lambda函数，Lambda函数向SNS主题发布消息，这导致向该主题的所有订阅者发送电子邮件。</p><p id="2ce8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该应用程序的完整代码可在<a class="ae me" href="https://github.com/weibeld/sam-hello-world" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="cff2" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">AWS Lambda基础知识</h1><p id="550f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">首先，一些重要的基础。</p><h2 id="0c20" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">Lambda函数与Lambda应用</h2><p id="0287" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">一个<strong class="js iu"> Lambda函数</strong>是一段代码(由AWS管理)，每当它被来自事件源的事件触发时就被执行。λ应用程序是一个云应用程序，包括一个或多个λ函数，也可能包括其他类型的服务。</p><p id="443d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几乎在所有情况下，Lambda应用程序都包含多种类型和实例的服务。例如，上面描述的Lambda应用程序由一个Lambda函数、一个API网关和一个SNS主题组成。</p><h2 id="1583" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">λ执行模型</h2><p id="1d76" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">λ函数由所谓的事件源触发。事件源是一个AWS服务。目前有十几个AWS服务可以用作Lambda函数的事件源。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mr"><img src="../Images/53df502b366d8e519d100faf3fe26c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DKZWifE_VNv5rvHuVTEJQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">AWS Lambda执行模型。</figcaption></figure><p id="fd1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以充当Lambda函数的事件源的AWS服务包括API Gateway、S3、DynamoDB、SNS、SQS、Cognito、IoT、Kinesis等。Lambda函数可以有任意数量的事件源。</p><p id="171a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦Lambda函数开始运行，它基本上可以做任何你想做的事情。通常，一个Lambda函数使用其他AWS服务(这可能会触发另一个Lambda函数)。然而，Lambda函数并不局限于此，它们可以执行你想要的任何代码。例如，您可以使用AWS Lambda函数在谷歌云平台(GCP)上创建或更新Kubernetes集群。</p><h2 id="3c4f" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">λ运行时间</h2><p id="d093" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">AWS为Lambda函数提供了一组有限的运行时环境。它们目前包括以下内容(参见<a class="ae me" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html" rel="noopener ugc nofollow" target="_blank">文档</a>):</p><ul class=""><li id="5acf" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">Node.js (8.10和6.10)</li><li id="133a" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">Java (8)</li><li id="cbc4" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">Python (3.6和2.7)</li><li id="734e" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">去</li><li id="887e" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">。NET C# (2.1、2.0和1.0)</li></ul><p id="97f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着你必须用这些语言中的一种来编写Lambda函数的代码。</p><h1 id="16fe" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">山姆是什么？</h1><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nk"><img src="../Images/99fa4d7e2410f5c96f815e4ba24b1269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsUqL-pDtQAklYm4ggH4kQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">这是萨姆向你展示它能为你做什么(来自<a class="ae me" href="https://github.com/awslabs/serverless-application-model" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)。</figcaption></figure><p id="b915" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到我们的主题。如果你熟悉AWS和CloudFormation，那么SAM只不过是<a class="ae me" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> CloudFormation </a>的扩展。</p><h2 id="181e" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">云的形成</h2><p id="628e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果你不知道CloudFormation，那么知道CloudFormation是AWS的基础设施即代码(IaC)解决方案是很重要的。它与Terraform属于同一类工具(CloudFormation和Terraform之间的一个非常好的对比可以在<a class="ae me" href="https://cloudonaut.io/cloudformation-vs-terraform/" rel="noopener ugc nofollow" target="_blank">这里</a>找到)。</p><p id="9f27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用CloudFormation，您可以在YAML或JSON文件中声明性地指定您的云应用程序所需的AWS基础架构，称为<strong class="js iu">模板</strong>，然后<em class="nl">部署</em>该模板。在部署过程中，AWS会自动提供您在模板中指定的所有资源。</p><p id="3b6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您之前已经部署了，并且刚刚对您的模板进行了更改，那么AWS会计算一个<em class="nl">更改集</em>并应用它，以便您的基础设施的状态与您的规范相匹配(就像Kubernetes一样)。</p><h2 id="49a9" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">SAM扩展云形成</h2><p id="8a53" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">萨姆只是引擎盖下的云层。使用SAM，您可以在SAM模板中指定Lambda应用程序的资源，然后部署该模板。事实上，在部署之前，您的SAM模板会自动转换为CloudFormation模板，然后进行部署。</p><p id="5e64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SAM增加了一些CloudFormation中没有的资源类型。最重要的是这是<code class="fe nm nn no np b">AWS::Serverless::Function</code>资源类型，它允许简洁地定义Lambda函数。该资源类型具有Lambda函数所需的所有属性，包括作为Lambda函数事件源的可能事件类型列表。</p><p id="6fbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SAM的语法规范可以在这里找到:<a class="ae me" href="https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#event-source-types" rel="noopener ugc nofollow" target="_blank">版本2016–10–31。</a></p><h2 id="6f12" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">SAM模板</h2><p id="3195" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">最小的SAM模板(在YAML)如下所示(通常保存在一个名为<code class="fe nm nn no np b">template.yml</code>的文件中):</p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="2d7b" class="mf kp it np b gy nu nv l nw nx">AWSTemplateFormatVersion : '2010-09-09'<br/>Transform: AWS::Serverless-2016-10-31<br/>Resources:<br/>  HelloWorldFunction:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      Handler: index.handler<br/>      Runtime: nodejs8.10</span></pre><p id="9dd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该模板指定了一个由单一资源组成的Lambda应用程序。这个资源是一个Lambda函数(名为<code class="fe nm nn no np b">HelloWorldFunction</code>)，它使用Node.js 8.10运行时，这个Lambda函数的代码在<code class="fe nm nn no np b">handler</code>函数的文件<code class="fe nm nn no np b">index.js</code>中。</p><p id="9321" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意属性<code class="fe nm nn no np b">Transform: AWS::Serverless-2016-10-31</code>。这指定了该模板的格式，并告诉CloudFormation如何解释它，以便它可以将其转换为标准的CloudFormation模板，然后可以部署到AWS。</p><p id="ec1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，您可以像使用<a class="ae me" href="https://docs.aws.amazon.com/cli/latest/reference/cloudformation/index.html" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>部署任何CloudFormation模板一样部署这个SAM模板。然而，还有一种更好的方法，因为SAM也提供了自己的CLI。</p><h2 id="93f7" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">λ功能代码</h2><p id="83b0" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">除了SAM模板，您还必须定义Lambda函数的代码。这段代码的入口点的确切格式取决于所使用的Lambda运行时。对于Node.js 8.10，最小的代码文件如下所示:</p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="9977" class="mf kp it np b gy nu nv l nw nx">exports.handler = async function(event, context) {<br/>    return 'Hello World!';<br/>};</span></pre><p id="5adc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，这段代码可以保存在与模板文件相同目录下的一个名为<code class="fe nm nn no np b">index.js</code>的文件中。您可以选择任何想要的文件名和导出的处理函数的名称(在本例中为<code class="fe nm nn no np b">handler</code>)，但是您必须确保它与模板中Lambda函数的<code class="fe nm nn no np b">Handler</code>属性一致(例如，在本例中，该属性必须设置为<code class="fe nm nn no np b">Handler: index.handler</code>)。</p><p id="60f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AWS文档中的<a class="ae me" href="https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html" rel="noopener ugc nofollow" target="_blank">此处</a>描述了不同支持的编程语言所需的处理函数格式。</p><h2 id="0a9a" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">SAM CLI</h2><p id="9a3b" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">SAM提供了自己的CLI，虽然不是强制性的，但在使用SAM时非常方便。这个CLI的GitHub库在这里是<a class="ae me" href="https://github.com/awslabs/aws-sam-cli" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c130" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用以下命令简单地安装SAM CLI:</p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="0069" class="mf kp it np b gy nu nv l nw nx">pip install aws-sam-cli</span></pre><p id="51ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CLI将作为<code class="fe nm nn no np b">sam</code>提供。</p><h2 id="20d8" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">使用SAM CLI部署</h2><p id="bf82" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">您可以使用SAM CLI将SAM模板部署到AWS。部署包括两个(或可能三个)步骤:</p><p id="a053" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 1。包装</strong></p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="b7a2" class="mf kp it np b gy nu nv l nw nx">sam package \<br/>  --template-file template.yml \<br/>  --output-template-file package.yml \<br/>  --s3-bucket my-bucket</span></pre><p id="a758" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nm nn no np b">package</code>命令的目的是将Lambda应用程序需要的任何工件上传到AWS S3存储桶。当您稍后将Lambda应用程序部署到AWS时，工件将自动从这个S3桶中检索出来。</p><p id="0e41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Lambda函数的情况下，最重要的工件当然是Lambda函数的代码(包括所有的依赖项)。上述命令的结果是你的整个项目目录(包括代码)将被压缩并上传到S3桶。</p><p id="4ae8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令还生成一个名为<code class="fe nm nn no np b">package.yml</code>的输出文件。这是您的<code class="fe nm nn no np b">template.yml</code>模板文件的副本，但是模板中每个Lamda函数的<code class="fe nm nn no np b">CodeUri</code>属性都被设置为S3桶上的上传包的URI。</p><p id="5691" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一步中，您将把这个<code class="fe nm nn no np b">package.yml</code>文件部署到AWS。由于这个文件中的<code class="fe nm nn no np b">CodeUri</code>属性，AWS将能够从S3桶中定位和检索每个Lambda函数的代码。</p><p id="9836" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以为<code class="fe nm nn no np b">package</code>命令指定任何您想要的S3桶，并且您可以在多个应用中多次使用同一个桶。如果您还没有S3存储桶，那么您可以在AWS控制台中或者使用带有<code class="fe nm nn no np b">aws s3 mb s3://my-bucket</code>的AWS CLI轻松创建一个。这是部署过程中潜在的第三步。</p><p id="8e99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2。展开</strong></p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="1ecd" class="mf kp it np b gy nu nv l nw nx">sam deploy \<br/>  --template-file package.yml \<br/>  --stack-name my-sam-application \<br/>  --capabilities CAPABILITY_IAM</span></pre><p id="695c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令将在<code class="fe nm nn no np b">package.yml</code>文件中定义的模板部署到AWS。因为SAM是基于CloudFormation的，所以这个命令创建一个新的CloudFormation堆栈，或者更新一个现有的cloud formation堆栈。您必须使用<code class="fe nm nn no np b">--stack-name</code>选项来指定这个CloudFormation堆栈的名称。</p><p id="68d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nm nn no np b">--capabilities CAPABILITY_IAM</code>选项是授权您的堆栈创建<a class="ae me" href="https://aws.amazon.com/iam/" rel="noopener ugc nofollow" target="_blank"> IAM </a>角色所必需的，SAM应用程序默认会这样做。</p><p id="9c97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注:</strong></p><p id="f8af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nm nn no np b">sam package</code>和<code class="fe nm nn no np b">sam deploy</code>命令实际上只是<code class="fe nm nn no np b">aws cloudformation package</code>和<code class="fe nm nn no np b">aws cloudformation deploy</code>命令的别名。因此，如果您没有安装SAM CLI，您可以只使用后面这些命令来代替前面的命令。</p><p id="a286" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想查看<code class="fe nm nn no np b">sam package </code>和<code class="fe nm nn no np b">sam deploy</code>的完整用法，你可以分别在<code class="fe nm nn no np b">aws cloudformation package help</code>和<code class="fe nm nn no np b">aws cloudformation deploy help</code>下找到。</p><h2 id="9243" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">删除Lambda应用程序</h2><p id="02ba" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">SAM CLI不提供删除Lambda应用程序的命令。然而，由于Lambda应用程序只是一个CloudFormation堆栈，所以您可以通过使用AWS CLI删除CloudFormation堆栈来删除它:</p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="c09f" class="mf kp it np b gy nu nv l nw nx">aws cloudformation delete-stack --stack-name my-sam-application</span></pre><h2 id="e9b6" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">SAM替代方案</h2><p id="6dde" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">SAM不是唯一允许定义Lambda应用程序并将其部署到AWS的工具。一个值得注意的选择是<a class="ae me" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">无服务器框架</strong> </a>。SAM和无服务器框架的主要区别在于，后者并不特定于AWS，而是可以用于各种云提供商。SAM和无服务器框架之间的一个很好的比较可以在<a class="ae me" href="https://sanderknape.com/2018/02/comparing-aws-sam-with-serverless-framework/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="8824" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae me" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Terraform </strong> </a>也可以用来部署无服务器应用到AWS。</p><p id="705d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据您的使用情况，后一种工具可以用于多个云提供商可能是一种优势。然而，如果您无论如何都要使用AWS，那么SAM是一个很好的解决方案，因为它提供了与AWS概念的优化集成，例如IAM权限，这可以产生更简单的模板。</p><h1 id="8728" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">用SAM构建Lambda应用程序</h1><p id="b24b" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在让我们构建我在本文开头的<a class="ae me" href="#f683" rel="noopener ugc nofollow">部分介绍的Lambda应用程序。这是架构图:</a></p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi md"><img src="../Images/b6c1684bf94b742e048d77bdd949700d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-mysbIDl5XmamF2LmW9M1g.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">最终的Lambda应用程序。</figcaption></figure><p id="28c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该应用程序允许向特定的API端点发出HTTP请求，然后将电子邮件发送到特定的电子邮件地址。</p><p id="1df8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下文中，我们将分三步来构建这个应用程序:</p><ul class=""><li id="28ed" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated"><a class="ae me" href="#282e" rel="noopener ugc nofollow"> <strong class="js iu">第一步:单Lambda函数</strong> </a></li><li id="1e1b" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated"><a class="ae me" href="#568f" rel="noopener ugc nofollow"> <strong class="js iu">第二步:添加事件源</strong> </a></li><li id="3c03" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated"><a class="ae me" href="#c5c3" rel="noopener ugc nofollow"> <strong class="js iu">第三步:添加一个动作</strong> </a></li></ul><p id="75ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用<strong class="js iu"> Node.js 8.10 </strong>作为Lambda函数的运行时。也就是Lambda函数代码会用JavaScript写。</p><p id="aa50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有三个步骤的代码都可以在<a class="ae me" href="https://github.com/weibeld/sam-hello-world" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="282e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤1:单一Lambda函数</h1><p id="98d9" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">作为第一步，我们将创建一个中间Lambda应用程序，它只包含一个Lambda函数，没有其他内容。这将是它的样子:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi md"><img src="../Images/ebd29945eca760273e203e1e135ca03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03B3A8m-44xDlK2ImeA2dA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Lambda应用程序的第1阶段。</figcaption></figure><h2 id="c38e" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">代码</h2><p id="4e79" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">用以下文件创建一个新目录:</p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="d5b3" class="mf kp it np b gy nu nv l nw nx">sam-hello-world/<br/>  |-- template.yml<br/>  |-- index.js</span></pre><p id="a23a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些文件的内容如下:</p><p id="7b46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nm nn no np b"><strong class="js iu">template.yml</strong></code> <strong class="js iu"> : </strong></p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="b152" class="mf kp it np b gy nu nv l nw nx">AWSTemplateFormatVersion : '2010-09-09'<br/>Transform: AWS::Serverless-2016-10-31<br/>Resources:<br/>  HelloWorldFunction:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      Handler: index.handler<br/>      Runtime: nodejs8.10</span></pre><p id="cdce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nm nn no np b"><strong class="js iu">index.js</strong></code> <strong class="js iu"> : </strong></p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="6bf7" class="mf kp it np b gy nu nv l nw nx">exports.handler = async function(event, context) {<br/>  return 'Hello World!';<br/>};</span></pre><p id="0758" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该模板定义了一个Lambda应用程序，其中包含一个名为<code class="fe nm nn no np b">HelloWorldFunction</code>的Lambda函数。当这个函数被触发时，<code class="fe nm nn no np b">index.js</code>中的处理函数被执行，它简单地返回字符串<code class="fe nm nn no np b">Hello World!</code>。</p><h2 id="1b77" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">部署它</h2><p id="b70c" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们使用SAM CLI将该应用程序部署到AWS:</p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="83af" class="mf kp it np b gy nu nv l nw nx">sam package \<br/>  --template-file template.yml \<br/>  --output-template-file package.yml \<br/>  --s3-bucket my-bucket</span><span id="086c" class="mf kp it np b gy ny nv l nw nx">sam deploy \<br/>  --template-file package.yml \<br/>  --stack-name sam-hello-world-1 \<br/>  --capabilities CAPABILITY_IAM</span></pre><p id="37dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当<code class="fe nm nn no np b">sam deploy</code>完成时，我们的Lambda应用程序启动并运行在AWS上。</p><p id="a3e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>如果您以前从未使用过<a class="ae me" href="https://aws.amazon.com/cli/" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>，您现在应该安装并配置它，因为SAM CLI依赖于AWS CLI的配置和保存的凭证。使用<code class="fe nm nn no np b"><a class="ae me" href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html" rel="noopener ugc nofollow" target="_blank">pip install awscli</a></code>安装AWS CLI，并使用<code class="fe nm nn no np b"><a class="ae me" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-quick-configuration" rel="noopener ugc nofollow" target="_blank">aws configure</a></code>进行配置。这将创建文件<code class="fe nm nn no np b">~/.aws/config</code>和<code class="fe nm nn no np b">~/.aws/credentials</code>，它们也由SAM CLI使用。</p><h2 id="2c29" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">AWS控制台:Lambda</h2><p id="2e08" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">您可以通过在AWS控制台的<a class="ae me" href="https://console.aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"/></a>中导航到<strong class="js iu"> Lambda </strong>服务并点击<em class="nl">应用程序来检查应用程序是否已经部署。</em></p><p id="07ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那里，您应该会看到名为<code class="fe nm nn no np b">sam-hello-world-1</code>的全新Lambda应用程序:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nz"><img src="../Images/f5d3ba19bf8b33d9bac91d1ad1033e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tH-Gvf-5MclOBlrH_XQomw.png"/></div></div></figure><p id="5488" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您单击该应用程序，您会看到该应用程序包含的所有资源。在我们的例子中，这只是一个名为<code class="fe nm nn no np b">HelloWorldFunction</code>的Lambda函数:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi oa"><img src="../Images/bd07b44b2a8148cc70829871c0d548b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgL7xajIgzvLMotQZg9ysA.png"/></div></div></figure><p id="bccb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您单击该功能，您会看到关于该功能的所有详细信息。在那里，您还会再次遇到复杂的文本编辑器，其中预加载了您的函数代码，由于SAM，您<strong class="js iu">没有</strong>可以使用的<strong class="js iu"> </strong>:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi ob"><img src="../Images/f0dc4577df1fc6356c7defb1fc55e98f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0asBkBTW0nQVDXDpzH0pRw.png"/></div></div></figure><h2 id="24ba" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">AWS控制台:云形成</h2><p id="cdd2" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如上所述，使用SAM部署Lambda应用程序会创建(或更新)一个<strong class="js iu"> CloudFormation </strong>堆栈。通过在AWS控制台的<strong class="js iu"/><a class="ae me" href="https://console.aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">https://console.aws.amazon.com/cloudformation/</strong></a><em class="nl">导航到CloudFormation服务，您可以看到已经为您的Lambda应用程序创建的堆栈。</em></p><p id="9a5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那里，您应该看到名为<code class="fe nm nn no np b">sam-hello-world-1</code>的堆栈，它对应于您的Lambda应用程序(您在<code class="fe nm nn no np b">sam deploy</code>命令中指定了这个名称):</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi oc"><img src="../Images/7eb44c187186758bf0bc7d155780647a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cp1Lo7vfCDRxd0evKpZDyw.png"/></div></div></figure><p id="c571" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果单击堆栈，您会看到它包含的确切资源集:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi od"><img src="../Images/e2db262f02aecd08dd01e4595669a1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IaK6XMoWjRqCukJ-JakKjQ.png"/></div></div></figure><p id="1c71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，堆栈包含一个Lambda函数和一个IAM角色。这些都是构成您当前Lambda应用程序的资源。</p><p id="0b84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们现在可以确信我们的Lambda应用程序已经被正确地部署到AWS上了。现在，让我们扩展它。</p><h1 id="568f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤2:添加事件源</h1><p id="9bf4" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">上一步中创建的Lambda应用程序由一个Lambda函数组成，该函数没有任何关联的事件源。这意味着这个Lambda函数永远不会被事件触发，也就意味着它永远不会运行。</p><p id="783d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们通过设置来改变这一点，这样每当用户向特定的API端点发出HTTP请求时，就会触发Lambda函数。这是我们的扩展应用程序的外观:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi md"><img src="../Images/4715b4b40c93f16ae7f86411059fa780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPT_nb-x-ovSugGhCANBGg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Lambda应用程序的第2阶段。</figcaption></figure><h2 id="1347" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">代码</h2><p id="b3c0" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">按如下方式更改项目中的两个文件源文件。</p><p id="a29d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nm nn no np b"><strong class="js iu">template.yml</strong></code>T23:</p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="82d3" class="mf kp it np b gy nu nv l nw nx">AWSTemplateFormatVersion : '2010-09-09'<br/>Transform: AWS::Serverless-2016-10-31<br/>Resources:<br/>  HelloWorldFunction:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      Handler: index.handler<br/>      Runtime: nodejs8.10<br/><strong class="np iu">      Events:<br/>        HelloWorldApi:<br/>          Type: Api<br/>          Properties:<br/>            Path: /<br/>            Method: GET</strong></span></pre><p id="b250" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nm nn no np b"><strong class="js iu">index.js</strong></code> <strong class="js iu"> : </strong></p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="2f26" class="mf kp it np b gy nu nv l nw nx">exports.handler = async function(event, context) {<br/>  return { statusCode: 200, body: 'Hello World!' };<br/>};</span></pre><h2 id="15c0" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">解释:template.yml</h2><p id="8ff4" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">对于<code class="fe nm nn no np b">template.yml</code>，与之前版本的唯一区别是为Lambda函数添加了<code class="fe nm nn no np b">Events</code>属性(上面以粗体突出显示)。</p><p id="95dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">属性为我们的Lambda函数定义了一个事件源。我们将这个事件源定义为一个API ( <code class="fe nm nn no np b">Type: Api</code>)，并进行设置，以便每当对这个API的<code class="fe nm nn no np b">/</code>端点发出GET请求时，就发出事件，并触发我们的Lambda函数。</p><p id="356e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们稍后将这个应用程序部署到AWS时，这个模板将导致一个<a class="ae me" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> API网关</a> API被创建并与我们的Lambda应用程序相关联。</p><p id="8658" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注:</strong></p><p id="48c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们如何知道存在什么类型的事件源？一般来说，我们如何知道模板文件的语法、可用属性等等？答案是，由<strong class="js iu"> </strong> <a class="ae me" href="https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> SAM规范</strong> </a>。它定义了创建SAM模板所需的一切。例如，这里的列出并描述了所有可用的事件源<a class="ae me" href="https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#event-source-types" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="c44d" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">解释:index.js</h2><p id="004e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">关于<code class="fe nm nn no np b">index.js</code>，与之前版本的不同之处在于，我们返回的不是一个字符串，而是一个具有<code class="fe nm nn no np b">statusCode</code>和<code class="fe nm nn no np b">body</code>属性的对象。</p><p id="e747" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于API网关事件源的实现方式，这是必要的。它使用一个代理，该代理从Lambda函数中期待一个这种形式的对象。然后，代理将使用<code class="fe nm nn no np b">statusCode</code>值作为HTTP响应的状态代码，使用<code class="fe nm nn no np b">body</code>值作为响应的有效负载。</p><p id="55ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，这意味着API网关端点的调用者将收到一个带有状态代码200和<code class="fe nm nn no np b">Hello World!</code>主体的HTTP响应。事实上，这表明Lambda函数已经被正确地触发和执行。</p><h2 id="509e" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">部署它</h2><p id="1ac3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们将新的Lambda应用程序部署为<code class="fe nm nn no np b">sam-hello-world-2</code>:</p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="36f8" class="mf kp it np b gy nu nv l nw nx">sam package \<br/>  --template-file template.yml \<br/>  --output-template-file package.yml \<br/>  --s3-bucket my-bucket</span><span id="85d1" class="mf kp it np b gy ny nv l nw nx">sam deploy \<br/>  --template-file package.yml \<br/>  --stack-name sam-hello-world-2 \<br/>  --capabilities CAPABILITY_IAM</span></pre><p id="69cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您愿意，您也可以使用与以前版本相同的名称<code class="fe nm nn no np b">sam-hello-world-1</code>，而不是<code class="fe nm nn no np b">sam-hello-world-2</code>，在这种情况下，以前版本的应用程序将被覆盖。</p><h2 id="6b8b" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">触发该功能</h2><p id="b291" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果您现在转到AWS控制台中<strong class="js iu"/><a class="ae me" href="https://console.aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">https://console.aws.amazon.com/lambda/</strong></a>下的Lambda服务，您应该会在那里看到您的新Lambda应用程序<code class="fe nm nn no np b">sam-hello-world-2</code>。</p><p id="4237" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您选择该应用程序，您可以看到它包含一个额外的资源，即API网关:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi oa"><img src="../Images/3a3aadcb8175f9df849b99ca71bb8791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4hbXJkAK5w2XWbEfZX89Rw.png"/></div></div></figure><p id="1274" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您选择Lambda函数，您会看到API Gateway已经被添加为Lambda函数的事件源。如果单击API Gateway事件源，可以看到触发Lambda函数的API端点URL:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi oe"><img src="../Images/904ee3ab338e5976e08c548b0ca357d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oT8gRtEFP8i5E4RKmbo3ww.png"/></div></div></figure><p id="ab31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继续并在您的浏览器中打开此URL，或使用<code class="fe nm nn no np b">curl</code>发出请求。您应该收到一个带有状态代码200和一个<code class="fe nm nn no np b">Hello World!</code>主体的HTTP响应。这意味着你的Lambda函数已经被成功触发并执行了！</p><h2 id="42d1" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">CloudWatch日志</h2><p id="5228" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果你想知道更多关于你的Lambda函数何时以及如何执行的细节呢？这没有问题，因为AWS Lambda会自动为每个Lambda函数创建<a class="ae me" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank"> CloudWatch </a>日志。</p><p id="4db1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，这些日志包括Lambda函数每次执行的<em class="nl"> start </em>和<em class="nl"> end </em>事件，以及包含每次执行的持续时间和已用内存的<em class="nl"> report </em>语句。此外，你在Lambda函数代码中写给<code class="fe nm nn no np b">stdout</code>的所有东西(比如用<code class="fe nm nn no np b">console.log</code>)也会被发送到CloudWatch日志中。</p><p id="e376" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要查看CloudWatch，您可以转到AWS控制台中的功能详细信息，然后单击<em class="nl">监控</em>选项卡。在那里你会看到一个标签为<em class="nl">的按钮在CloudWatch中查看日志:</em></p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi oa"><img src="../Images/613c308013c7b2386212236175e618fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Y-bVFpDji5q6Q1_hecfaQ.png"/></div></div></figure><p id="e365" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单击该按钮将带您进入为此功能创建的CloudWatch日志组。在这里，您可以看到在函数的生命周期内生成的完整日志:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi of"><img src="../Images/0f873da6282d139216aadb9233dcb7ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQjtJmeUf61nKRfJxJDhFg.png"/></div></div></figure><p id="b520" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，现在我们的Lambda应用程序包含了一个Lambda函数和一个API网关作为事件源。但是这个函数还没有做任何有用的事情，它只是向API的调用者返回一个字符串。让我们增加一些动作。</p><h1 id="c5c3" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">步骤3:添加操作</h1><p id="963a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们最后的Lambda应用程序会在上一步的API端点收到GET请求时向给定的电子邮件地址发送一封电子邮件。</p><p id="d17c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将通过让Lambda函数向目标电子邮件地址订阅的<a class="ae me" href="https://aws.amazon.com/sns/" rel="noopener ugc nofollow" target="_blank">简单通知服务(SNS) </a>主题发布消息来实现这一点。</p><p id="1484" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是最终应用程序的样子:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi md"><img src="../Images/b6c1684bf94b742e048d77bdd949700d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-mysbIDl5XmamF2LmW9M1g.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Lambda应用程序的第3阶段(最终版)。</figcaption></figure><h2 id="0f0e" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">代码</h2><p id="4b5e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">按如下方式修改这两个源文件。</p><p id="1b0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nm nn no np b"><strong class="js iu">template.yml</strong></code>T20:</p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="2d05" class="mf kp it np b gy nu nv l nw nx">AWSTemplateFormatVersion : '2010-09-09'<br/>Transform: AWS::Serverless-2016-10-31<br/>Resources:<br/>  HelloWorldFunction:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      Handler: index.handler<br/>      Runtime: nodejs8.10<br/>      Events:<br/>        HelloWorldApi:<br/>          Type: Api<br/>          Properties:<br/>            Path: /<br/>            Method: GET<br/><strong class="np iu">      Policies:<br/>        - SNSPublishMessagePolicy:<br/>            TopicName: !GetAtt HelloWorldTopic.TopicName<br/>      Environment:<br/>        Variables:<br/>          SNS_TOPIC_ARN: !Ref HelloWorldTopic<br/>  HelloWorldTopic:<br/>    Type: AWS::SNS::Topic<br/>    Properties:<br/>      Subscription:<br/>        - Endpoint: youremail@example.com<br/>          Protocol: email</strong></span></pre><p id="8d1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nm nn no np b"><strong class="js iu">index.js</strong></code> <strong class="js iu"> : </strong></p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="19fd" class="mf kp it np b gy nu nv l nw nx">const aws = require('aws-sdk');<br/>aws.config.update({region: 'us-east-1'});<br/>const sns = new aws.SNS()</span><span id="cf1b" class="mf kp it np b gy ny nv l nw nx">exports.handler = async function(event, context) {</span><span id="0a3c" class="mf kp it np b gy ny nv l nw nx">  const params = {<br/>    Message: 'Hello World!',<br/>    Subject: 'SNS Notification from Lambda',<br/>    TopicArn: process.env.SNS_TOPIC_ARN<br/>  };</span><span id="6377" class="mf kp it np b gy ny nv l nw nx">  try {<br/>    await sns.publish(params).promise()<br/>    return { statusCode: 200, body: 'Message sent' };<br/>  } catch(err) {<br/>    return { statusCode: 500, body: JSON.stringify(err) };<br/>  }<br/>};</span></pre><h2 id="a2f4" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">解释:template.yml</h2><p id="f8fe" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><code class="fe nm nn no np b">template.yml</code>中有不少新行(粗体突出显示)。但是让我们更仔细地看看。实际上添加的是Lambda函数的两个属性，<code class="fe nm nn no np b">Policies</code>和<code class="fe nm nn no np b">Environment</code>，以及一个名为<code class="fe nm nn no np b">HelloWorldTopic</code>的全新资源。</p><p id="1b37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> SNS话题:</strong></p><p id="e750" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们先看看新的<code class="fe nm nn no np b">HelloWorldTopic</code>资源。是<code class="fe nm nn no np b">AWS::SNS::Topic</code>类型的，也就是SNS话题。实际上，这意味着当我们部署这个Lambda应用程序时，将会创建一个新的SNS主题。该主题还有一个立即定义的订阅，它包含一个电子邮件地址并使用电子邮件协议。</p><p id="ba57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，您无法在<a class="ae me" href="https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#event-source-types" rel="noopener ugc nofollow" target="_blank"> SAM规范</a>中找到资源类型<code class="fe nm nn no np b">AWS::SNS::Topic</code>。那么它来自哪里呢？答案是它是一个<strong class="js iu"> CloudFormation资源类型</strong>而不是SAM资源类型。SAM是CloudFormation的超集，因此您可以在SAM模板中使用传统的CloudFormation资源。</p><p id="f923" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在AWS文档的这里找到所有可用的云信息资源类型<a class="ae me" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html" rel="noopener ugc nofollow" target="_blank">的规范。例如，<code class="fe nm nn no np b">AWS::SNS::Topic</code>资源类型在这里被指定为</a><a class="ae me" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-topic.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="de27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">环境:</strong></p><p id="bcbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看<code class="fe nm nn no np b">HelloWorldFunction</code> Lambda函数的新<code class="fe nm nn no np b">Environment</code>属性。这个属性除了指定一个名为<code class="fe nm nn no np b">SNS_TOPIC_ARN</code>的环境变量之外什么也不做，这个变量可以从函数的源代码中获得(例如Node.js中的<code class="fe nm nn no np b">process.env</code>)。</p><p id="95be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个环境变量的值是<code class="fe nm nn no np b">HelloWorldTopic</code> SNS主题的ARN。Lambda函数代码需要这个ARN来发布这个主题的消息，我们接下来会看到。</p><p id="8651" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，这里我们使用了另一个称为<strong class="js iu">内在函数</strong>的CloudFormation特性。内在函数是内置的CloudFormation函数，可以从CloudFormation(或SAM)模板中调用。内在函数的完整列表可在<a class="ae me" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="91b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，我们使用<code class="fe nm nn no np b"><a class="ae me" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-ref.html" rel="noopener ugc nofollow" target="_blank">Ref</a></code>固有函数，它返回作为参数提供的资源的ARN。这里确实有必要使用一个内部函数，因为在第一次部署时，新SNS主题的ARN(尚未创建)是未知的。</p><p id="a55a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">政策:</strong></p><p id="924b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们看看Lambda函数的新的<code class="fe nm nn no np b">Policies</code>属性。简而言之，该属性授予Lambda函数向<code class="fe nm nn no np b">HelloWorldTopic</code> SNS主题发布消息的权限。</p><p id="a86d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是必要的，因为在默认情况下，Lambda函数被分配了一个没有任何权限的<a class="ae me" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html" rel="noopener ugc nofollow" target="_blank"> IAM角色</a>(除了写入CloudWatch日志)。这意味着对于Lambda函数必须访问的每个AWS服务，您必须为Lambda函数的角色添加适当的权限。</p><p id="79ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，我们通过使用一个名为<a class="ae me" href="https://github.com/awslabs/serverless-application-model/blob/master/docs/policy_templates.rst" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">策略模板</strong> </a>的SAM特性授予该功能所需的权限。策略模板是一组预定义的IAM策略，可以通过简单的字符串引用。</p><p id="2f73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的模板中，我们使用了<code class="fe nm nn no np b">SNSPublishMessagePolicy</code>策略模板，它符合我们的要求，即授予发布消息到特定SNS主题的权限。此策略模板需要一个名为<code class="fe nm nn no np b">TopicName</code>的参数，该参数必须是应该授予发布权限的SNS主题的名称。所有可用的SAM策略模板的规范都可以在<a class="ae me" href="https://github.com/awslabs/serverless-application-model/blob/develop/samtranslator/policy_templates_data/policy_templates.json" rel="noopener ugc nofollow" target="_blank">文件</a>中找到。</p><p id="3995" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们使用另一个CloudFormation内部函数<code class="fe nm nn no np b"><a class="ae me" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-getatt.html" rel="noopener ugc nofollow" target="_blank">GetAtt</a></code>来检索<code class="fe nm nn no np b">HelloWorldTopic</code> SNS主题的名称。这是必要的，因为该名称是自动生成的，并且在初始部署时是未知的。</p><h2 id="00a2" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">解释:index.js</h2><p id="cca1" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><code class="fe nm nn no np b">index.js</code>中的Lambda函数代码向应用程序的SNS主题(代码从<code class="fe nm nn no np b">SNS_TOPIC_ARN</code>环境变量中检索其ARN)发布一条消息，然后向API的调用者返回一个<code class="fe nm nn no np b">Message sent</code>响应(或者在发布到SNS时出现错误的情况下，返回一个错误响应)。</p><p id="a177" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，从AWS Lambda函数访问AWS服务的方式与从任何其他代码访问AWS服务的方式相同，即使用AWS SDK。这意味着，我们在Lambda函数中用来向SNS主题发布消息的代码与我们在任何其他应用程序中使用的代码是相同的。</p><p id="b0f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Node.js的AWS SDK的API参考可以在<a class="ae me" href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。SNS <code class="fe nm nn no np b">publish</code>方法的具体参考就是这里的<a class="ae me" href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/SNS.html#publish-property" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7598" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AWS Lambda的一个非常方便的特性是，默认情况下，AWS SDK依赖项在所有运行时环境中都可用。得益于此，我们可以在Node.js代码中执行<code class="fe nm nn no np b">require('aws-sdk')</code>，而不必先执行<code class="fe nm nn no np b">npm install aws-sdk</code>。这使我们的Lambda应用程序包保持精简，因为不需要<code class="fe nm nn no np b">node_modules</code>目录和<code class="fe nm nn no np b">package.json</code>文件。</p><h2 id="afcc" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">部署它</h2><p id="df4d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们部署最终的Lambda应用程序:</p><pre class="ls lt lu lv gt nq np nr ns aw nt bi"><span id="5857" class="mf kp it np b gy nu nv l nw nx">sam package \<br/>  --template-file template.yml \<br/>  --output-template-file package.yml \<br/>  --s3-bucket my-bucket</span><span id="e92e" class="mf kp it np b gy ny nv l nw nx">sam deploy \<br/>  --template-file package.yml \<br/>  --stack-name sam-hello-world-3 \<br/>  --capabilities CAPABILITY_IAM</span></pre><h2 id="67ad" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">确认SNS订阅</h2><p id="f95d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果您用自己的电子邮件地址替换了模板中的虚拟电子邮件地址，那么在部署完成后，您应该会收到一封电子邮件，提示您确认订阅新创建的SNS主题。</p><p id="5396" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您必须这样做，否则您将不会收到发布到该主题的所有后续消息的电子邮件。当新创建SNS主题(和您的订阅)时，您只需在第一次部署时这样做一次。</p><h2 id="faa7" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">测试一下</h2><p id="6416" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">和上一步一样，检索Lambda应用程序的API网关的API端点URL，并用浏览器或<code class="fe nm nn no np b">curl</code>向它发出GET请求。观察你的电子邮件收件箱。几秒钟后，您应该会收到一封来自SNS的电子邮件，其中包含您的内容。</p><p id="312d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，您已经成功构建了一个AWS Lambda应用程序，它包含一个Lambda函数、一个事件源和一个访问另一个AWS服务的动作。这一切都是因为萨姆。恭喜你！</p></div></div>    
</body>
</html>