<html>
<head>
<title>Printing money with your idle hardware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用你闲置的硬件印钞票</h1>
<blockquote>原文：<a href="https://itnext.io/opportunistically-mining-cryptocurrencies-in-kubernetes-94934d095c4d?source=collection_archive---------3-----------------------#2018-02-27">https://itnext.io/opportunistically-mining-cryptocurrencies-in-kubernetes-94934d095c4d?source=collection_archive---------3-----------------------#2018-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7864" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们假设您运营着一个大型裸机集群，您将其租赁给客户来运行他们的工作负载。</p><p id="0be9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到，在过去几个月中，该集群实际上平均只使用了60%。您保留了15%的空闲容量以应对电涌，并且您需要5%的群集容量来运行基础架构本身。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9b40afc087ea8df316d6241be541cde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVIqBkWlGjK3EokRKz6LKA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">基础架构中资源使用的分割</figcaption></figure><p id="db91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一天中的某些时候会出现负载达到90%的峰值，但这确实很难预测，因为它们取决于您客户的业务，并不遵循您所拥有的数据模式。总的来说，你总是有大约20%的未开发能力。</p><p id="ec5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为服务提供商，或者当您的办公室中有一堆服务器时，您可能会遇到这种情况。不管怎样<strong class="jp ir">，都是浪费</strong>。</p><p id="d2ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们能够充分利用这些资源并善加利用，会怎么样？让我们看看如何！是的<a class="lb lc ep" href="https://medium.com/u/24413768aadb?source=post_page-----94934d095c4d--------------------------------" rel="noopener" target="_blank">特斯拉汽车</a>这是给你的；D</p><h1 id="5c54" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">“机会自动缩放”</h1><h2 id="8292" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">Kubernetes和自动缩放</h2><p id="b8e5" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">从K8s的v1.2开始，可以使用水平Pod自动缩放器根据CPU消耗自动缩放一个app。很酷但非常有限的用例。</p><p id="aa5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从1.6版开始，您可以使用自定义指标来自动扩展群集中的应用程序。好多了。这意味着您可以公开API的命中次数或其延迟等指标，然后根据该指标而不是默认的CPU负载来扩展服务单元。</p><p id="436a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这难道不意味着我们可以公开集群的剩余容量(20%)，并利用它来自动调整印钞应用程序的规模，从而使集群永远以最佳容量使用吗？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/6ff70196c9ce782f87481c88bd71a368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yp7zlMtuhN58NQEupb4TXQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">你真正想要的是分裂</figcaption></figure><h2 id="72e3" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">机会主义</h2><p id="247f" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">以上行为我称之为“<strong class="jp ir">机会主义自动缩放</strong>”。应用程序利用基础设施未使用容量的能力，可能是CPU、内存或GPU。</p><p id="e69c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">业务关键型应用将根据其表现来衡量。例如，您的API必须总是以低延迟响应。另一方面，你的非商业应用程序只能消耗<em class="mt">剩余部分:</em></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/c50e5d672af5ba43e020912900af4e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_K7n2Z7br_lF8tsN6NlvFA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">可用于自动缩放的资源</figcaption></figure><p id="5dde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，“剩余容量”表现为:</p><ul class=""><li id="b216" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">如果集群上的“业务关键型”负载增加，剩余的资源就会减少，机会型应用也会随之减少。</li><li id="e508" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">相反，如果你的有效载荷下降，剩余容量上升，机会主义集装箱的数量应该上升。</li></ul><p id="aaa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目标是让负载在您定义的阈值(在我们的示例中为80%)附近尽可能保持恒定，从而收集平均20%的未使用功率并将其货币化。</p><h2 id="04e5" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">印刷钞票</h2><p id="b286" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">这可能看起来是一个愚蠢的应用程序，但我可以肯定地告诉你，当办公时间结束时，挖掘池似乎会看到负载增加，这表明(一些)业务资源肯定会在晚上用于挖掘！</p><p id="731e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在现实生活场景中，加密挖掘有效地向计算网格添加资源，因此它也有超越宣传和乐趣的意义。还有很多其他有趣的用例。除其他外:</p><ul class=""><li id="042b" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">使用无服务器框架的边缘Lambda(电信/云运营商)</li><li id="dd13" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">弹性转码(媒体实验室/云):想想宜家在工作站上做了什么，但是是在计算集群中</li><li id="4a48" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">边缘的人工智能(媒体实验室/云)</li><li id="2f8a" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">缓存(CDN)</li><li id="32ba" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">您将在评论中分享的酷用例</li></ul><p id="9bd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，说够了！让我们完成这项工作，增加收入。</p><p id="f1ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">免责声明</strong>:部署这个相当复杂，涉及多个步骤。因此，这篇文章比通常的文章要长得多，技术性也更强。如果你在这里是因为你喜欢这个用例，但是不希望深入技术细节，你可以直接从现在跳到结论。</p><h1 id="59a0" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用反向自定义指标</h1><p id="e739" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">在这篇博客中，我们将在裸机上创建一个带有自定义指标API的K8s集群。</p><p id="de1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们创建一个应用程序，该应用程序公开了如下指标</p><blockquote class="nj nk nl"><p id="a1b9" class="jn jo mt jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">剩余CPU =(群集中请求的CPU总量)-(所有应用程序请求的总量)</p></blockquote><p id="dc29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当集群负载增加时，该指标会降低，当负载减少时，该指标会增加。这将有效地使度量成为服务器上所请求负载的“客户端”。</p><p id="7758" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将使用该指标在Kubernetes中配置一个水平Pod自动缩放器(HPA)。这将使集群中的负载尽可能高。</p><h1 id="db4c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">财务事项的充分公布</h1><p id="6a15" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">这篇博客文章是由<a class="ae np" href="https://www.kontron.com/" rel="noopener ugc nofollow" target="_blank"> Kontron </a>赞助的，他很大方地允许我使用他们最新的<a class="ae np" href="https://symkloud.com" rel="noopener ugc nofollow" target="_blank"> SymKloud平台</a>的6节点集群，这是一个很棒的硬件，你可以在其中混合和匹配模块来创建集群。有带GPU、CPU的模块，有些专用于存储或缓存…每台2U服务器可包含多达9个“底座”，实际上多达576个核心带双CPU底座，或多达9个nVidia P4带288个核心。我的集群有6个工作人员，其中两个使用GPU。</p><p id="a9ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我的朋友<a class="ae np" href="https://www.linkedin.com/in/ronan-delacroix/" rel="noopener ugc nofollow" target="_blank">罗南·德拉克洛瓦</a>帮我编写了代码，并编写了这个实验所需的所有python代码。</p><p id="5da8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这项工作目前在巴塞罗纳MWC的<a class="ae np" href="https://www.mobileworldcongress.com/exhibitor/kontron/" rel="noopener ugc nofollow" target="_blank"> Kontron的展台</a>展示。</p><h1 id="c81b" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">库伯内特星团</h1><p id="b6b0" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">碰巧的是，Kontron与<a class="ae np" href="https://www.ubuntu.com/kubernetes" rel="noopener ugc nofollow" target="_blank"> Canonical </a>合作在SymKloud上运行Kubernetes。你不会感到惊讶，这篇文章是基于Kubernetes  (CDK)的<a class="ae np" href="https://www.ubuntu.com/kubernetes" rel="noopener ugc nofollow" target="_blank">规范发行版的1.8版本。</a></p><p id="8667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您需要以某种方式复制它，您将需要一个版本为1.8的K8s集群，其中RBAC是活动的，并且有一个管理员角色。</p><p id="7cb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要提示</strong>:我们将在这里使用的API非常不稳定，会有很大的变化。我真的建议你阅读K8s变更日志来检查它们。</p><ul class=""><li id="4082" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">例如，在1.8 中有一个关于API名称的<a class="ae np" href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.8.md" rel="noopener ugc nofollow" target="_blank">变化。如果您运行1.7版本的集群，这将会对您产生影响。</a></li><li id="5098" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">1.9也有变化，custon.metrics.k8s.io从v1alpha1移动到v1beta1。</li></ul><p id="4f2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们今天将看到的一些配置细节是在<a class="ae np" href="https://www.ubuntu.com/kubernetes" rel="noopener ugc nofollow" target="_blank"> CDK </a>上以某种方式完成的，在自托管集群上可能略有不同。只要有可能，我会尽量提到它们。无论如何，请在Q &amp; A中随意提问。</p><h2 id="185c" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">RBAC构型</h2><p id="5992" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated"><strong class="jp ir">注意</strong>:这适用于CDK，并且当API聚合与K8s 1.9一起正式上市时将适用于GKE。</p><p id="adc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在CDK和GKE上，从RBAC的角度来看，默认用户不是真正的管理员，因此您需要更新它，然后才能创建扩展您自己角色的其他集群角色绑定。</p><p id="ef57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先确保你知道你的身份</p><ul class=""><li id="42b1" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">CDK:你是用户管理员</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="2784" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">GKE:你的GCP用户是管理员</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e6d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在授予您自己集群管理员角色:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f95c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您可以通过以下方式查看:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="675b" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">舵安装</h2><p id="154e" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">为了让Helm在RBAC集群中运行，我们还需要将其添加为集群管理员:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="da3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们完成了集群的准备工作</p><p id="5a39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>:默认情况下，Helm的部署没有资源限制。当试图增加一个集群的负载并最大限度地利用它时，这意味着分蘖将成为荚的一部分，这些荚可能会因为资源耗尽而消失。如果不希望发生这种情况，可以编辑清单并重新应用它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="4ec5" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">自动缩放:准备集群</h1><h2 id="8912" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">简介和参考</h2><p id="d5c7" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">首先，我建议你看一下关于扩展Kubernetes的文档。</p><p id="0b90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后再看看关于用聚合层扩展Kubernetes的文档<a class="ae np" href="https://kubernetes.io/docs/concepts/api-extension/apiserver-aggregation/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4e36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个理论文档是关于建立一个API服务器的，你可以在这里找到它。</p><p id="e541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦聚合被激活，我们将部署2个定制API:<a class="ae np" href="https://github.com/kubernetes-incubator/metrics-server" rel="noopener ugc nofollow" target="_blank">度量服务器</a>和<a class="ae np" href="https://github.com/DirectXMan12/k8s-prometheus-adapter" rel="noopener ugc nofollow" target="_blank">定制度量适配器</a></p><p id="0d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在你已经精通了我们需要做的事情，让我们开始吧。</p><h2 id="d321" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">配置控制平面</h2><p id="9e6b" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">为了激活聚合层，我们必须向API服务器添加一些标志:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ba9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会注意到我们没有激活标志</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="93f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为CDK的代理使用的是Kubeconfig，而不是客户端证书。</p><p id="75ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，我们确实启用了聚合器路由，因为Kubernetes的控制平面不是自托管的，我们属于这种情况“如果您没有在运行API服务器的主机上运行kube-proxy，那么您必须确保系统启用了enable-aggregator-routing标志”。</p><p id="f670" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还添加了client-ca-file标志来导出集群中API服务器的ca。</p><p id="aa7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，对于控制器管理器，我们必须告诉它使用HPA，我们的做法是:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d436" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，这里的最后两个选项实际上是用于演示，以便快速观察操作的结果。对于您的用例，您可能不需要更改它们(它们默认为3m和5m)。</p><p id="85b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是为了确保应用了设置，请使用</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2f0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将使Kubernetes在kube-system名称空间中创建一个名为extension-API server-authentic ation的configmap，它包含我们生成的所有附加标志及其配置。你可以通过</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7256" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个API服务器现在都需要有一个RBAC授权来读取这个配置映射。谢天谢地K8s还会自动为它创建一个角色:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8927" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但同样重要的是，您现在不需要Heapster，所以请确保它不在那里，方法是:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="7947" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">初始API状态</h2><p id="312f" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">在您开始享受API服务器之前，请查看您的集群的状态:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="326d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一节的末尾，您将在这个列表中有3个以上的API:</p><ul class=""><li id="2854" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><strong class="jp ir">monitoring.coreos.com/v1</strong>，为普罗米修斯操作员</li><li id="9b24" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir"> metrics.k8s.io </strong>，用于收集CPU和内存指标的指标服务器</li><li id="d5e7" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir"> custom.metrics.k8s.io </strong>，用于您想要公开的定制指标</li></ul><h1 id="24a6" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">添加度量服务器API</h1><p id="25f8" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">这个阶段有2个Metrics API (metrics.k8s.io)的实现:Heapster和Metrics Server。在撰写本文时，Metrics Server有一个简单的部署方法，而Heapster需要我做一些工作，我懒得写代码。</p><p id="50e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以简单地部署它</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6727" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该清单包含:</p><ul class=""><li id="5341" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">度量服务器的服务帐户</li><li id="d6da" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">RoleBinding，以便度量服务器可以读取上面的配置图</li><li id="46be" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">一个ClusterRoleBinding，以便度量服务器继承system:auth-delegator cluster role(您可以在这里找到关于那个<a class="ae np" href="https://kubernetes.io/docs/admin/authorization/rbac/" rel="noopener ugc nofollow" target="_blank">的文档。</a></li><li id="1219" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">度量服务器的部署和集群IP服务</li><li id="08ca" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">APIService对象，它是新API在API服务器中的注册。</li></ul><p id="0c59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在再次检查我们的API:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ef84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太棒了…但是真的有用吗？通过kubectl查询API的端点以确保</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f463" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干得好，NodeMetrics和PodMetrics都公开了。看看你能从那里得到什么:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2611" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8734" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没什么好惊讶的，<strong class="jp ir">你可以实时访问CPU和内存消耗</strong>。有关如何查询API的更多详细信息，请参考文档。</p><h1 id="7ae2" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">安装自定义指标管道</h1><p id="97f3" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">就在我们走捷径之前，有一个度量管道可以作为聚合API直接公开。不幸的是，在定制指标的情况下，我们必须分两步完成。</p><p id="9323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们必须部署自定义指标管道，这将使我们能够收集指标。我们使用Prometheus作为K8s上度量收集系统的典型例子。</p><p id="ea93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将通过特定的API服务器公开这些指标。为此，我们将使用Sully (@DirectXMan12)的作品，可以在这里找到<a class="ae np" href="https://github.com/DirectXMan12/k8s-prometheus-adapter" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="aee2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">普罗米修斯有很多安装方法。我个人最喜欢的是<a class="ae np" href="https://github.com/coreos/prometheus-operator" rel="noopener ugc nofollow" target="_blank">普罗米修斯算子</a>。使用传统的解决方案来设计一个软件需要付出很多努力。但是，精心制作一个与底层分布式基础设施完美结合的软件模型更接近艺术，而不是其他任何东西。</p><p id="db62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是运营商的本质。操作员模拟应该如何给普罗米修斯一组条件，然后在Kubernetes中实现。哇，干得好@CoreOS。</p><p id="8447" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，你可以为任何东西创建一个操作符，就我所见，Tensorflow 也将会有类似的东西出现……不管怎样，我们不要分心。</p><p id="4fc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装Prometheus操作器，带有:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a3fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这包括:</p><ul class=""><li id="3c5c" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">操作员的服务帐户</li><li id="5f82" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">相当广泛的ClusterRole和ClusterRoleBinding，以便操作员可以为Prometheus(实例)、警报管理器和服务监视器部署自定义资源定义。</li><li id="2ea6" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">操作员舱的展开。</li></ul><p id="2296" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将允许操作员添加监控API:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e0e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在创建一个普罗米修斯的实例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="883a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RBAC清单将允许Prometheus读取任何对象(pod或服务)的集群和/指标端点中所需的指标。Prometheus清单定义了一个实例和一个服务，将其公开为一个节点端口(这样我们就可以看看UI)。</p><p id="5f34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个文件中最重要的部分是:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fca6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这实际上是将Prometheus实例专用于服务带有该标签(或标签集)的监视器。当我们定义要监控的应用程序以及如何监控时，我们将需要这些信息。</p><p id="907d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，这是一个简单的部署示例，没有持久存储或任何新奇的东西。如果你打算将它用于更多的产品级用途，你将需要在这上面花费一些时间。</p><p id="65fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在您可以在UI上进行连接，并检查您是否已经正确部署了所有东西。目前还很空…</p><h1 id="c408" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">安装自定义指标适配器</h1><p id="16fb" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">既然我们有能力通过我们的Prometheus管道收集指标，我们希望在聚合API下公开它们。</p><p id="5c13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，你需要一些证书。乔伊。这都记录在<a class="ae np" href="https://github.com/kubernetes-incubator/apiserver-builder/blob/master/docs/concepts/auth.md" rel="noopener ugc nofollow" target="_blank">这里</a>。运行以下命令来生成您的precious:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="95f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了根据Kubernetes API服务器认证我们的扩展API服务器，我们有几个选项:</p><ul class=""><li id="ae17" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">使用客户端证书</li><li id="3737" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">使用Kubeconfig文件</li><li id="f65b" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">使用基本身份验证或令牌身份验证</li></ul><p id="940f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在CDK添加有证书的用户本身就是一个项目，应该有自己的博客帖子。如果有兴趣，平我的问题，我们可以在DMs讨论这个。BasicAuth和Tokens很容易，但它们也需要在所有主机上编辑<strong class="jp ir">/root/CDK/known _ Tokens . CSV</strong>或<strong class="jp ir"> /root/cdk/basic_auth.csv </strong>，并在各处重新启动API服务器守护进程。</p><p id="0dfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以复杂性最小的解决方案实际上是Kubeconfig文件。多亏了RBAC，我们创建一个新用户所需要的唯一东西就是一个服务帐户，它将使我们能够访问一个认证令牌，然后我们可以将这个令牌放入我们的kubeconfig。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d5f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您可以创建您的。kube/config文件并编辑用户部分以添加自定义api服务器:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7cb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记还要编辑上下文以映射到该用户而不是admin。</p><p id="a116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在为舵图编辑一个cm-values.yaml文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2800" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，你现在可以下载并安装图表了</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b0a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们检查新的API是否在Kubernetes中注册:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="160a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了。现在让我们通过查询K8s端点来检查一切是否正常工作:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="995b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们发展的这一点上，如果我们得到200分而不是404分，我们就很好，我们有我们的自动扩展&amp;运行。如果你得到一个404，那么它没有正常工作。</p><h1 id="ac2c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">摘要</h1><p id="4aa6" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">在上面的长部分中，我们已经完成了以下工作</p><ol class=""><li id="1c35" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk ns nb nc nd bi translated">安装新的Metrics服务器，并将metrics.k8s.io API添加到集群中。这给了我们一个相当于heapster的访问，但是在经典API下公开了度量。</li><li id="cdc5" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk ns nb nc nd bi translated">安装自定义指标管道，以便能够收集任何指标。我们通过Prometheus实现了这一点，使用操作符创建一个Prometheus实例</li><li id="9fca" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk ns nb nc nd bi translated">通过安装Prometheus适配器来安装自定义指标API custom.metrics.k8s.io。</li></ol><p id="bf0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每一步，我们都验证了集群工作正常，符合预期。现在我们需要好好利用它。</p><h1 id="97c5" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用自定义指标</h1><h2 id="7a0e" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">演示应用程序:http_requests</h2><p id="89f0" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">首先，我们将使用一个由@luxas编写的非常简单的应用程序来测试我们的设置，该应用程序公开了/metric上的http_request指标。您可以通过以下方式部署它</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ab07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该清单包含:</p><ul class=""><li id="46a7" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">部署和服务，以便我们可以查询应用程序</li><li id="e96d" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">一个服务监视器，它将向prometheus实例指示它应该废弃应用程序的指标</li><li id="1b2b" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">水平Pod自动缩放器(HPA)，它将消耗http_requests的数量，并使用它来缩放应用程序。</li></ul><p id="f098" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看自置居所津贴:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9f4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，我们这里有</p><ul class=""><li id="ae3e" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">一个目标(我们的部署)，带有一个minReplicas和一个maxReplicas。</li><li id="69dc" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">一个pod类型的指标，它试图确保pod平均获得5亿次查询(略高于Kubernetes + Prometheus的标准负载)</li></ul><p id="3f2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这意味着您不需要应用程序依赖自己的指标。您可以将任何应用程序指标作为目标，并使用它们来管理另一个应用程序。非常强有力的原则。</p><p id="eb90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，假设您基于解耦调用的原则管理一个应用程序，比如聊天或订单管理解决方案。有一天，您开始在前端收到一个请求高峰，而后端没有跟上。队列填满了，您开始体验请求处理中的延迟。现在，您可以根据前端发出的请求来扩展处理队列的工作线程。您创建了一个在前端监控http_requests数量的目标对象，但是scale目标可能是您的应用程序。就这么简单。</p><p id="2c7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在看看自定义API对此如何反应(可能需要几分钟才能工作)</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以查询服务本身:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们看看我们的HPA:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="53d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，仅状态请求就占了每个pod 的433m <em class="mt">,比每400ms一个请求多一点。现在部署一个shell应用程序，这样我们就可以创建一些负载:</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="790d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在准备两个弹壳。在第一个示例中，使用</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="637e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二个例子中，跟踪HPA</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0771" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经成功地触发了一个应用的放大和缩小</p><h2 id="761e" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">主要应用:优化基础设施</h2><p id="9c0d" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">好吧！现在，我们有了一个可以在集群中生成负载并消耗资源的应用程序。现在让我们看看如何利用剩余的资源。</p><p id="2f74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们看看罗南编写的指标收集应用程序。它公开了以下指标:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2be6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，他还创建了一个很好的UI，可以实时显示这些值。</p><p id="2861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这需要Grafana安装。您可以通过以下方式安装这两个应用程序:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cfff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些清单包含</p><ul class=""><li id="e1e0" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">用于收集指标的集群角色和绑定</li><li id="9701" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">Grafana和python应用程序的部署</li><li id="9423" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">端口30505 (app)和30902 (Grafana)上的节点端口服务</li><li id="c6ec" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">配置映射来配置这两者</li></ul><p id="844d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此示例中，我们感兴趣的是“cpu_capacity_remaining”。正如简介中提到的，多亏了Kontron，我可以访问184核集群。我决定“保留”30个内核，或15%的容量，为负载高峰留出空间。这给了我一个自动缩放器，看起来像:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="66c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会注意到我使用<a class="ae np" href="https://electroneum.com/" rel="noopener ugc nofollow" target="_blank">电子神经</a>作为我的密码。这样做的原因是实际的。这是一种非常新的加密货币，目前分配给它的采矿资源有限，这意味着你可以直接衡量你的影响，并看到每日回报，这对演示来说很酷。如果你想知道，因为这种货币需要一个monero矿工，这种设置可以很容易地转换成更有利可图的东西指向一个真正的Monero池。</p><p id="9501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在您自己的机器上复制这个博客，请根据您自己的集群编辑src/manifest-etn.yaml文件，然后使用:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d447" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该清单包含:</p><ul class=""><li id="2340" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">矿工的部署</li><li id="dc9c" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">如上图所示的水平Pod自动缩放器</li><li id="f3ef" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">在节点的端口30500上公开UI的服务。</li></ul><p id="684d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们检查一下我们的颐康保障户口:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1911" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们都准备好了！现在我们终于可以检查我们的应用程序如何对负载做出反应了。</p><h1 id="a358" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">运动中的机会负载平衡器</h1><p id="f7e7" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">为了增强我们的集群，我们重用我们的shell-demo应用程序，在5分钟内每秒钟在API上产生10次点击。因为我们预计只有0.5次点击，这将很快触发横向扩展:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3ff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，我们可以看到新的吊舱进来了。每个新pod向群集请求4个CPU核心。这使得试图通过释放矿工来对抗的HPA失去平衡。在5分钟内，我们的应用程序将扩展到17个副本，因此集群需要68个内核，这将从采矿应用程序中释放出来。5分钟后，负载现在正常，我们看到简单的应用程序从17个pod缩减到2个副本的稳定版本。矿工的HPA将做出反应并开始获取产能。</p><p id="1a09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以在用户界面的CPU容量图上看到</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/91a44b8fa94cf5088f1910fa479c438e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2J7ajJRoxUG2rqZBTbGmw.png"/></div></div></figure><p id="af96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有了一个应用程序，它可以根据集群<em class="mt">中其他应用程序创建的负载自行调整</em>。为了更好地了解HPA的行为，我们可以直接查看Grafana:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/c5ef410c23225ac1e1cd231e754248d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofZPbbXd-XgIYjUdX2ry_Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">集群完美地自动适应业务负载</figcaption></figure><p id="c4a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，您可以清楚地看到第二个绿色图表中的负载峰值，以及HPA如何通过扩展API副本的数量来做出反应。在上面的图中，我们可以看到蓝色区域(业务负载)在上升，在黄线下降后不久(这是机会主义应用程序在缩小)，红色的“剩余CPU核心”在波动，而总数(黄色+蓝色+红色)大约是恒定的，代表系统中的核心总数(184)。</p><p id="6268" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我应该分享一个土豆，因为这个帖子真的真的很长。</p><h1 id="99d6" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">关于颐康保障户口的一些想法</h1><h2 id="db17" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">保持低的非业务负载</h2><p id="cff1" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">在创建这个博客的时候，我花了很大的力气来配置HPA，使它稳定和收敛，而不是完全不稳定。人们必须明白，K8s中的HPA到目前为止是相当愚蠢的。这并不完全是从过去中学习，而是系统地重复同样的反应模式，而不管他们在过去失败或成功的事实。</p><p id="d972" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设自定义指标是其目标值的150%，那么群集将执行150%的容量增加。这意味着，如果您的应用程序为1%的规模增长创造2%的HPA资源价值，您将进入一个湍流区，HPA被证明无法收敛，因为它总是对环境反应过度。</p><p id="7fe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这种行为，如果机会性负载占集群总负载的大部分，您就有产生不断波动的次优HPA的风险。下面是一个示例，其中挖掘平台在15到120个内核(集群的60%)之间变化，而业务负载仅为大约20%。在这种情况下，集群需要很长时间才能收敛，实际上，有时永远不会收敛。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/fb2f181b62c2ada7793a48f5a57d71dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GC0ozVUZrrSEISgvFwLGA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">处于非收敛状态的集群</figcaption></figure><p id="a752" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长话短说:永远不要使用会发散的HPA！！试验和学习，保持HPA在集群中的合理影响。</p><h2 id="5310" class="mb le iq bd lf mc md dn lj me mf dp ln jy mg mh lr kc mi mj lv kg mk ml lz mm bi translated">完全失效</h2><p id="4ad1" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">所以这是我无法完全调试的东西。</p><p id="006e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的最后一个Grafana屏幕中，您可以看到在第二次负载浪涌中有一个更长的高负载峰值。实际上，HPA卡住了，由于某种原因，除非你强迫它，否则它永远不会返回。</p><p id="c9ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我的经验，这只会发生在HPA大幅波动然后达到最大值的时候。在这一点上，如果这种情况持续太长时间，它将无法缩小规模，从而有效地崩溃。</p><p id="2401" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还是那句话，在搭建HPA的时候，做一些实验。测试您的指标，确保它们能够很好地协同工作。</p><h1 id="ba79" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="b963" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我一直梦想建造“<em class="mt">机会主义自动缩放器</em>”。这是我人生中的第一次，感谢Ronan，Kontron，以及Kubernetes和Canonical on CDK社区所做的出色工作，我得以将它们整合在一起。而且“就是管用”！</p><p id="a807" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在文章的开始，我们希望通过降低成本或增加收入来增加价值。根据你的机会主义应用，你可能属于其中一种或两种情况。</p><p id="38d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，在这个月的时间里，我们成功地</p><ul class=""><li id="60f8" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">平均约25个空闲CPU内核，而HPA中的目标是24个，每30分钟产生一次随机负载。</li><li id="bc64" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">投机性地平均消耗30个内核，否则这些内核将会丢失。</li></ul><p id="1c40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开采密码能赚钱吗？不多。测试期间，我们开采了约1000颗ETN，总价值约为100美元。比什么都没有多，但不是很多。</p><p id="7cbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是现在想想无服务器，算一算。30个内核在任何时候都相当于1个系统底座。假设这也转化为相同数量的空闲RAM:</p><ul class=""><li id="6f2e" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">一个底座可以有高达256GB的RAM。</li><li id="0418" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">对于Lambda，AWS收取0，00001667美元/GB-s的费用，外加一点调用费用</li><li id="da1a" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">有86400x365，25 = 31 557 600秒/年</li></ul><p id="1f90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">soooo… 256 * 0，00001667 * 31 557 600 =<strong class="jp ir">$ 134 672.69</strong></p><blockquote class="nj nk nl"><p id="d61d" class="jn jo mt jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">134，672，69美元是我们刚刚使用的雪橇的商业价值，如果它一直100%永久运行的话。对于“未使用”的资源来说，这已经不错了。</p></blockquote><p id="5e64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这给了你一些想法吗？</p><h1 id="d86c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">参考</h1><p id="4c40" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我要特别感谢@Luxas和@DirectXMan12激发了我的创作灵感，感谢他们写了这里的<a class="ae np" href="https://github.com/luxas/kubeadm-workshop" rel="noopener ugc nofollow" target="_blank">和那里的</a><a class="ae np" href="https://github.com/DirectXMan12/k8s-prometheus-adapter/blob/master/docs/walkthrough.md" rel="noopener ugc nofollow" target="_blank">这两个精彩的穿越，这在我写作的时候给了我很大的帮助。</a></p><p id="5d43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用户界面的代码在这里:<a class="ae np" href="https://github.com/ronhanson/crypto-miner-webui" rel="noopener ugc nofollow" target="_blank">https://github.com/ronhanson/crypto-miner-webui</a></p><p id="860f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">K8s的源代码和清单在这里:<a class="ae np" href="https://github.com/madeden/blogposts/tree/master/k8s-autoscaling" rel="noopener ugc nofollow" target="_blank">https://github . com/madeden/blogposts/tree/master/K8s-auto scaling</a></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="60a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mt">原载于</em><a class="ae np" href="https://gist.github.com/d8142e6cbd72b894d03d12d1f1eb8687" rel="noopener ugc nofollow" target="_blank"><em class="mt">gist.github.com</em></a><em class="mt">。</em></p></div></div>    
</body>
</html>