<html>
<head>
<title>Bulk with RESTful APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">批量使用RESTful APIs</h1>
<blockquote>原文：<a href="https://itnext.io/bulk-with-restfull-apis-7c5e6be84ed3?source=collection_archive---------1-----------------------#2020-01-09">https://itnext.io/bulk-with-restfull-apis-7c5e6be84ed3?source=collection_archive---------1-----------------------#2020-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1022c75a1ab76514daee3bf782b215b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wnmt0TpAbcPuUv8a"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">丹尼尔·蒙泰罗在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="8e6c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="ll">当我们使用RESTful APIs时如何处理批量操作。<br/>处理不同的HTTP响应&amp;后面流程的注意事项。<br/>选择正确的解决方案，避免减速和错误配置。<br/>由</em> <a class="lm ln ep" href="https://medium.com/u/a4d26b34962?source=post_page-----7c5e6be84ed3--------------------------------" rel="noopener" target="_blank"> <em class="ll">曼努埃尔拉亚</em></a><em class="ll">&amp;</em><a class="lm ln ep" href="https://medium.com/u/a36f378c5095?source=post_page-----7c5e6be84ed3--------------------------------" rel="noopener" target="_blank"><em class="ll">佩德罗埃斯库德罗</em> </a> <em class="ll">。</em></p><h2 id="3cc3" class="lo lp it bd lq lr ls dn lt lu lv dp lw ky lx ly lz lc ma mb mc lg md me mf mg bi translated">散装RESTful，谢谢</h2><p id="04d9" class="pw-post-body-paragraph kn ko it kp b kq mh ks kt ku mi kw kx ky mj la lb lc mk le lf lg ml li lj lk im bi translated">在RESTful API中处理批量请求是这种架构中最常考虑的情况之一。当您的系统需要面对相当大的流量时，这一点尤其明显。</p><p id="a415" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在进行更深入的分析之前，我们想澄清一下，当要完成的操作是同一类型、在同一集合上时，我们认为我们正在执行批量操作。在其他情况下，我们将讨论批处理动作(我们留给下一篇文章的另一个问题是批处理动作是否是REsTful的)。如果您想要更多关于这方面的文档，我们邀请您访问由John Apostolidis 撰写的关于<a class="ae kf" href="http://apostolidis.me/bulk-operations/" rel="noopener ugc nofollow" target="_blank">批量操作的文档。</a></p><p id="0145" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">此外，作为免责声明，我们知道SSE、WS、SFTP加载和其他推送数据的方法，但是在本文中，我们将针对这一挑战分析RESTful选项。正如我们在结论中提到的，最终的解决方案将取决于一系列因素，其中包括您以前的基础设施、监控系统、员工的知识、产品要求、确切的流量等。</p><h2 id="52ad" class="lo lp it bd lq lr ls dn lt lu lv dp lw ky lx ly lz lc ma mb mc lg md me mf mg bi translated">问题</h2><p id="1597" class="pw-post-body-paragraph kn ko it kp b kq mh ks kt ku mi kw kx ky mj la lb lc mk le lf lg ml li lj lk im bi translated">假设您想用一个常规的RESTful请求创建(或更新，或删除)一个项目。您可以对适当的端点进行POST HTTP调用，类似于<strong class="kp iu">POST</strong><a class="ae kf" href="http://yourdomain/collection," rel="noopener ugc nofollow" target="_blank"><strong class="kp iu">HTTP://your domain/collection</strong>，</a>所需的数据。然后，如果一切顺利，您会得到201响应，如果失败，您会得到4xx / 5xx回复。初级工作。别紧张，皮斯。</p><p id="b255" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在，假设您想用一个HTTP调用创建两个项目。这种动作绝对有道理。您节省了传输层的时间，并且客户端应用程序避免了发出多个请求。</p><p id="2ea4" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">嗯，如果一切顺利，您的API将会以201作为响应。但是，当创造失败时会发生什么呢？或者当请求需要创建1000个项目而不是2个，并且服务器应用程序需要10秒以上的时间来处理时呢？是啊，这才是重点。</p><p id="2986" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里你有一些方法来处理这个问题:</p><h2 id="67c5" class="lo lp it bd lq lr ls dn lt lu lv dp lw ky lx ly lz lc ma mb mc lg md me mf mg bi translated">1.用202回答，稍后处理数据</h2><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/73ece7fceaa003bcfa1fc1961964c274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*K49EfswpR65m-zxh7NzONg.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一般输入工作流程</figcaption></figure><p id="98df" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这种情况下，端点接受一个带有一堆要处理的元素的请求，并将它们存储在一个队列系统中。然后，一个工人将使用和处理队列中的消息。</p><p id="b652" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">考虑因素:</p><ul class=""><li id="9f86" class="mr ms it kp b kq kr ku kv ky mt lc mu lg mv lk mw mx my mz bi translated">除了请求的格式之外，在端点级别验证收到的数据不是一个好的做法。把支票留给工人。</li><li id="89b0" class="mr ms it kp b kq na ku nb ky nc lc nd lg ne lk mw mx my mz bi translated">您需要为每个请求创建一个回调端点。这是显示过程结果的地方(访问将使用长轮询方法来完成，如果需要的话，使用速率限制来强制执行)。</li></ul><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/19f33d82accf1a31c898ffafb88f8360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*0s36LTzVXf_GBwtds2oSVQ.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">客户端API工作流</figcaption></figure><ul class=""><li id="c035" class="mr ms it kp b kq kr ku kv ky mt lc mu lg mv lk mw mx my mz bi translated">您可以选择更适合您的需求、知识或当前基础设施的队列系统(例如，<a class="ae kf" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ是一个很好的选择</a>)。我们已经看到了用于存储NoSQL数据库的实现。在这些情况下，程序的速度应该无关紧要。一个简单的后端任务，没有硬性的时间表。</li></ul><h2 id="f27c" class="lo lp it bd lq lr ls dn lt lu lv dp lw ky lx ly lz lc ma mb mc lg md me mf mg bi translated">2.用200(或201)响应，处理当前数据</h2><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b3ae7bed1d1a895ff41aebec95fa3cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*ptOdeYEcVTlotIroLPB4-A.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一般工作流程</figcaption></figure><p id="e27f" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">使用这种方法，客户端发送完整的批量请求，整个批量被处理，然后处理请求的实例发送响应。该解决方案有一些优点，但也有一些缺点:</p><ul class=""><li id="e0f3" class="mr ms it kp b kq kr ku kv ky mt lc mu lg mv lk mw mx my mz bi translated">数据正在快速处理中。提供了同步响应，并且没有可能降低工作流速度的附加层。</li><li id="7c50" class="mr ms it kp b kq na ku nb ky nc lc nd lg ne lk mw mx my mz bi translated">开发成本不高。它非常类似于任何其他RESTfull端点。</li><li id="86c4" class="mr ms it kp b kq na ku nb ky nc lc nd lg ne lk mw mx my mz bi translated">维护成本很低。不需要更多的基础设施。</li><li id="f86b" class="mr ms it kp b kq na ku nb ky nc lc nd lg ne lk mw mx my mz bi translated">如果处理请求的实例失败(意外关闭)，客户机不知道数据是全部处理了，还是部分处理了，或者根本没有处理。</li><li id="a40e" class="mr ms it kp b kq na ku nb ky nc lc nd lg ne lk mw mx my mz bi translated">为了正确处理响应，需要为发送的每个元素添加一些逻辑。</li></ul><h2 id="5021" class="lo lp it bd lq lr ls dn lt lu lv dp lw ky lx ly lz lc ma mb mc lg md me mf mg bi translated">3.回复206</h2><p id="a86c" class="pw-post-body-paragraph kn ko it kp b kq mh ks kt ku mi kw kx ky mj la lb lc mk le lf lg ml li lj lk im bi translated">虽然我们还没有看到这个选项最终实现，但是我们已经在一些会议上看到一些开发人员提出了这个选项。在不止一个国家。在不同的公司。不仅仅是大三。所有这些加在一起，似乎是对何时使用206响应，或者更具体地说是什么的误解。</p><p id="545d" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">HTTP 206响应旨在用于成功的范围请求。我猜混乱来自于指南<em class="ll">“206部分内容”</em>中对这段代码的描述。范围请求被认为是处理请求，允许只从服务器向客户机发送HTTP消息的一部分。这主要用于下载jpg、mp4、pdf等大文件。你可以在<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests" rel="noopener ugc nofollow" target="_blank">这个Mozilla页面上找到关于范围请求</a>的更深入的解释。</p><h2 id="7a15" class="lo lp it bd lq lr ls dn lt lu lv dp lw ky lx ly lz lc ma mb mc lg md me mf mg bi translated">4.回复一个200，就跳，信任(完全不要这样！！！)</h2><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/07c93140df70f411d0ac7284366b2a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IXHQ8FQwGkLHkkYi"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@yapics?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莱昂·塞伯特</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="65cb" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这是最懒的解决方法。也是最弱的一个。当接收到请求时，发送一个200 HTTP响应，而不关心请求的操作是否成功。这种行为带来了关键问题，比如客户端缺乏可跟踪性(更不用说它是如何违背RESTful原则的)。</p><p id="a6a2" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">也许，您认为这种替代方法对于<em class="ll">发送并忘记方法</em>来说很好，有时在日志记录中使用。但是如果你退后一步，重新思考它，你会意识到如果你不关心一些数据，很可能你不需要它。无论如何，这个糟糕的选择在一段时间内是可行的。直到你需要在危机中挖掘日志，而那些日志并不在那里。</p><p id="5280" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">多年来，我们已经看到了这种实现的几种变体。这些都不值得开发时间:</p><ul class=""><li id="fc96" class="mr ms it kp b kq kr ku kv ky mt lc mu lg mv lk mw mx my mz bi translated">将消息排队并在以后处理。类似于选项一，但做得很差，没有任何回调端点(同样，202比200更准确)。</li><li id="ba0e" class="mr ms it kp b kq na ku nb ky nc lc nd lg ne lk mw mx my mz bi translated">在响应前验证每个元素。如果有错误，发送400。但是，如果在验证之后，还有另一个问题(例如，在持久性方面)没有充分地传达给客户端。</li><li id="6af2" class="mr ms it kp b kq na ku nb ky nc lc nd lg ne lk mw mx my mz bi translated">要求客户端调用资源端点来检查对象是否存在(或者当请求的操作是PUT或PATCH时，检查它是否以正确的值出现)。如果他们没有预期的答案，那么操作失败了。这种选择完全没有效率。端点将以一种非常奇怪的方式被调用。日志记录和调试将成为一场噩梦。仅仅检查请求就会使应该提供内容的端点过载。此外，当您偏离标准时，与您的系统的集成将会是痛苦的和容易出错的。</li></ul><h2 id="5761" class="lo lp it bd lq lr ls dn lt lu lv dp lw ky lx ly lz lc ma mb mc lg md me mf mg bi translated">那么，我们该怎么办呢？</h2><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/2033cd94d81fdc144c266a7fdd5c0fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7G8yTNh2YfGokrK9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">埃文·丹尼斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="493a" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">没有非黑即白的情况，但也没有灰色的情况。您需要了解您的下划线架构，并分析您的客户和业务需求。在任何情况下，除非您自己探索或者做一个快速的概念验证，否则我们强烈建议您避免选择3和4。</p><p id="4d58" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">关于备选方案1和2，备选方案1似乎更有力。响应a 202并在稍后处理数据，您可以确保在出现意外问题时提供保护，并确保数据完整性。然而，根据您的应用程序的需求和您可以假设的权衡，此时处理数据仍然是一个有效的解决方案。</p><p id="9516" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">请记住，您对如何在API级别组织通信的决定将决定您的应用程序的速度。您自己的相关微服务、合作伙伴应用以及web和移动开发的集成将取决于此。</p><p id="3d28" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="ll">记住，代码是诗，但前提是你要小心。</em></p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/b359f0040a18f2c6685cbcb52be63673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RZdxokC49Rfq13iA"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div></div>    
</body>
</html>