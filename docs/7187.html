<html>
<head>
<title>Building a Schema Inference Data Pipeline for Large CSV files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为大型CSV文件构建模式推理数据管道</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-schema-inference-data-pipeline-for-large-csv-files-7a45d41ad4df?source=collection_archive---------1-----------------------#2022-07-09">https://itnext.io/building-a-schema-inference-data-pipeline-for-large-csv-files-7a45d41ad4df?source=collection_archive---------1-----------------------#2022-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a022" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">python的并行实现</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb2477f48a6cb3db14324d2740b8c456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWVA5PpIJiAbXONX1mptbA.png"/></div></div></figure><p id="1d1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数据分析中最重要的任务之一是为<a class="ae lq" href="https://en.wikipedia.org/wiki/Comma-separated_values" rel="noopener ugc nofollow" target="_blank">中的列分配、推断或推断数据类型。csv文件</a>，如果事先不了解业务中涉及的变量或者数据集非常大，这可能会非常复杂。在本文中，我将构建一个数据管道来推断大型csv文件中每一列的数据类型，还值得一提的是，为了构建一个可接受的工具，可能会出现一些障碍:</p><ul class=""><li id="8762" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">有必要迭代数据集中的所有记录和值吗？</li><li id="94a9" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">在大型数据集中逐个查看值可能会花费大量时间来浏览数据并将数据类型分配给数据集中的所有像元。一个好的方法是并行化和分块浏览数据集。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/c73c18ce66df8f22035d6d912d477302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zzMSJ-Tsw6g19VWWhvwFQ.png"/></div></div></figure><ul class=""><li id="d8f7" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">如果已经浏览、检查了某个列的值，并为其分配了数据类型，则没有必要再做一次，每列中的每个值都将被缓存。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/72abf54e440b15bc4b444ce5e99654e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1_OJbTfLfBE3WErfhf5Rg.png"/></div></div></figure><ul class=""><li id="e5df" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">最初，我们不知道记录顺序的性质，这可能会导致重复偏差，并且只能看到一小部分数据集中的一组数据类型。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/890584f01b3623b3dc189d5c864d4ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCDBz1NgX6O4LSoeFKUsGA.png"/></div></div></figure><ul class=""><li id="d2fb" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">我们必须保证记录的分布是均匀的，这样我就可以只取其中相当大的一部分来更精确更快速地推断，所以我不需要100%的记录。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/e03b388a683b37361301a6f4a12f3693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rpa2valVFhq9C1Y39gozbw.png"/></div></div></figure><ul class=""><li id="eeec" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">空值不是一种数据类型，它是列的一个特性，在我们的例子中，如果列中有很多空值，那么我们将为它分配<strong class="kw iu">字符串</strong>数据类型。</li></ul><p id="2b09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我考虑了上面提到的所有障碍，它们将适合作为加速推理过程的策略。<strong class="kw iu">那么让我们开始编码</strong>。</p><h1 id="5366" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">用于模式推理的数据管道</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/64cfb7d2cc010702d691a18efbc61253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_M9no-0cuMgtgtxQ2aFuQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated"><strong class="bd ml">数据管道</strong>:大型CSV文件的模式推断</figcaption></figure><ul class=""><li id="2350" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">我将使用带有mmap   的<a class="ae lq" href="https://realpython.com/python-mmap/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> <em class="ng">内存映射，这将通过避免几次系统调用来提高I/O性能，并将减少昂贵的数据缓冲传输。</em></strong></a></li><li id="79c2" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">我还将估计文件有多少行，这将有助于我在记录均匀分布后获得文件的一部分，我已经提到了参数，我将使用公式:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0c4c2b4ab74b66b013fa874120104cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*cjI9LDDM52kqt3ACRFI8cA.png"/></div></figure><ul class=""><li id="0ed5" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">一旦记录被均匀分布，并且这些记录中的一部分被取走，那么我将继续并行化推理过程，该过程负责将数据集分割成大小相等的块，并将每个块分配给单个处理器。</li><li id="bcfd" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">数据集的每个块的推断过程的结果将返回不同的模式，为了具有单个模式，有必要连接结果，使用来自多个结果的单个模式，我们现在可以推导或推断每个列的近似数据类型，并且还能够检测哪个列具有空值。下图显示了这一过程。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/dc835b52fcb710dad4f6325595046989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9LoZzHdf7g7PecfoAfWwA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated"><strong class="bd ml">连接来自并行运行的不同推理过程的多个模式</strong></figcaption></figure><ul class=""><li id="bfbd" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">精度值将帮助我们推断哪些数据类型将被拒绝作为可能的最终数据类型，它只接受大于或等于精度值的值</li></ul><h1 id="4f71" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">用于模式推断的数据管道代码</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/5e0b26b68fd9101316be2bec9bb24615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z93yCcCnaJ12plR0TLAb8A.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated"><strong class="bd ml">推理过程</strong></figcaption></figure><h1 id="95ea" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">让我们运行一个真实的例子</h1><p id="930e" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">查看我的GitHub库<a class="ae lq" href="https://github.com/Wittline/csv-schema-inference" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">CSV-schema-inference</strong></a>以获得关于代码的更多信息。</p><h2 id="7402" class="no mk it bd ml np nq dn mp nr ns dp mt ld nt nu mv lh nv nw mx ll nx ny mz nz bi translated">让我们首先检查csv文件</h2><p id="d54a" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">本例中的真实记录有1.000.000条</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="80ca" class="no mk it bd ml np nq dn mp nr ns dp mt ld nt nu mv lh nv nw mx ll nx ny mz nz bi translated">让我们安装库</h2><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="d5c9" class="no mk it od b gy oh oi l oj ok">pip install csv-schema-inference</span></pre><h2 id="fa3a" class="no mk it bd ml np nq dn mp nr ns dp mt ld nt nu mv lh nv nw mx ll nx ny mz nz bi translated">让我们导入“CSV-模式-推理”库</h2><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="1621" class="no mk it od b gy oh oi l oj ok">from csv_schema_inference import csv_schema_inference</span></pre><h2 id="6701" class="no mk it bd ml np nq dn mp nr ns dp mt ld nt nu mv lh nv nw mx ll nx ny mz nz bi translated"><strong class="ak">设置“CSV-模式-推理”配置</strong></h2><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="1dcc" class="no mk it od b gy oh oi l oj ok">csv_infer = csv_schema_inference.CsvSchemaInference(portion=0.7, max_length=100, acc = 0.8, seed=2, header=True, sep=",")</span><span id="b229" class="no mk it od b gy ol oi l oj ok">pathfile = "/content/data.csv"</span></pre><ul class=""><li id="f998" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><strong class="kw iu">部分</strong>:请注意，我们将只使用原始数据集总记录的70%</li><li id="891d" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><strong class="kw iu"> max-length: </strong>对于字符串数据类型，它将只缓存100个字符。没有必要在内存中保存这么多数据。</li><li id="d5b0" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><strong class="kw iu"> acc: </strong>本例的精度值将只考虑至少存在80%的数据类型</li></ul><h2 id="6d68" class="no mk it bd ml np nq dn mp nr ns dp mt ld nt nu mv lh nv nw mx ll nx ny mz nz bi translated">运行推理</h2><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="e8ae" class="no mk it od b gy oh oi l oj ok">aprox_schema = csv_infer.run_inference(pathfile)</span></pre><h2 id="11c7" class="no mk it bd ml np nq dn mp nr ns dp mt ld nt nu mv lh nv nw mx ll nx ny mz nz bi translated">每列的近似数据类型推断</h2><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="b5e5" class="no mk it od b gy oh oi l oj ok">csv_infer.pretty(aprox_schema)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">推理结果</figcaption></figure><p id="cb6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的输出显示了哪些列是<strong class="kw iu">可空的</strong>以及什么是<strong class="kw iu">近似的数据类型。</strong></p><h2 id="95a2" class="no mk it bd ml np nq dn mp nr ns dp mt ld nt nu mv lh nv nw mx ll nx ny mz nz bi translated">让我们看看在特定列中找到的所有值及其出现频率。</h2><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="3d47" class="no mk it od b gy oh oi l oj ok">result = csv_infer.get_schema_columns(columns = {"disc_6"})<br/>csv_infer.pretty(result)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="5aa4" class="no mk it bd ml np nq dn mp nr ns dp mt ld nt nu mv lh nv nw mx ll nx ny mz nz bi translated">浏览特定列的所有可能的数据类型</h2><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="dde6" class="no mk it od b gy oh oi l oj ok">result = csv_infer.explore_schema_column(column = "disc_6")</span><span id="6995" class="no mk it od b gy ol oi l oj ok">csv_infer.pretty(result)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="8192" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">89 %是整数值，10.06 %是空值，它们自动表示为字符串。在这种情况下，正确的推断数据类型是整数，因为它最接近精度值。</p><h1 id="9692" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">基准</strong></h1><p id="c157" class="pw-post-body-paragraph ku kv it kw b kx nj ju kz la nk jx lc ld nl lf lg lh nm lj lk ll nn ln lo lp im bi translated">这些测试是用9。csv文件，21列，不同大小和数量的记录，每个进程平均执行5次，<strong class="kw iu">洗牌时间</strong>和<strong class="kw iu">推断时间</strong>。</p><ul class=""><li id="a498" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">file _ _ 20m . CSV:2000万条记录</li><li id="5dfa" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">file _ _ 15m . CSV:1500万条记录</li><li id="f45a" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">file _ _ 12m . CSV:1200万条记录</li><li id="a43c" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">file _ _ 10m . CSV:1000万条记录</li><li id="f80b" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">诸如此类…</li></ul><p id="c08c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想了解更多关于洗牌的过程，你可以查看另一个库:<a class="ae lq" href="https://github.com/Wittline/csv-shuffler" rel="noopener ugc nofollow" target="_blank">一个自动洗牌的工具。csv文件</a>，洗牌过程将帮助我们:</p><ul class=""><li id="8011" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">增加在一列中找到所有数据类型的可能性。</li><li id="3b4a" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">避免迭代整个数据集。</li><li id="e48e" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">避免在数据中看到偏见，这可能是其有机行为的一部分，也是由于不知道其结构的性质。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/e2b5ac3f23b6e490f2e51bd8a75f0797.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*g02DG09H0zmQcuip0MmsAA.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">基准</figcaption></figure><h1 id="cee8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><ul class=""><li id="08e8" class="lr ls it kw b kx nj la nk ld on lh oo ll op lp lw lx ly lz bi translated">多处理代码可以通过使用一个可以被所有进程共享的数据结构来改进，尽管我已经尝试这样做了，但我还没有能够实现它，如果你能够修改代码以使用一个公共的数据结构，那就太好了。我确信这将缩短响应时间。</li><li id="4c6a" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">这段代码在非常大的数据集上进行了测试，从1，000，000条记录到20，000，000条记录，在所有情况下平均有20列，响应时间是可以接受的。</li><li id="30fa" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">我非常确定，如果使用数据压缩策略将数据块传输到处理器，响应时间将会缩短，前提是压缩时间加上解压缩时间小于不压缩的时间。</li><li id="43ad" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">代码还没有准备好投入生产，为了获得更精确的推断，需要考虑其他日期格式。</li><li id="b477" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">空值和布尔值也是可以参数化的特性。</li></ul><blockquote class="oq"><p id="e527" class="or os it bd ot ou ov ow ox oy oz lp dk translated">查看我的GitHub库<a class="ae lq" href="https://github.com/Wittline/csv-schema-inference" rel="noopener ugc nofollow" target="_blank"><strong class="ak">CSV-schema-inference</strong></a>以获得关于代码的更多信息。</p></blockquote></div></div>    
</body>
</html>