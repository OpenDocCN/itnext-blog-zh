<html>
<head>
<title>Lodash-es vs individual Lodash utilities: Size comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lodash-es与单个Lodash公用事业:规模比较</h1>
<blockquote>原文：<a href="https://itnext.io/lodash-es-vs-individual-lodash-utilities-size-comparison-676f14b07568?source=collection_archive---------2-----------------------#2019-03-28">https://itnext.io/lodash-es-vs-individual-lodash-utilities-size-comparison-676f14b07568?source=collection_archive---------2-----------------------#2019-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/41a17c3c72b9e42b2f20aaad0cf77d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWWY6ZLQa8AQ1SJCzNGY7w.jpeg"/></div></div></figure><p id="cef2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在工作中，我们在前端应用程序中使用<code class="fe kw kx ky kz b">lodash</code>。我们还在应用程序使用的共享模块中使用了<code class="fe kw kx ky kz b">lodash</code>。有时我们的应用程序使用<code class="fe kw kx ky kz b">lodash-es</code>，而一些模块使用单独的工具(<code class="fe kw kx ky kz b">lodash.utilityName</code>，反之亦然。显然，代码复制并不理想，所以我们需要选择其中之一。哪一个会导致更小的束尺寸？</p><p id="6431" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">结果</strong></p><p id="5d21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管比较是在<code class="fe kw kx ky kz b">lodash-es</code>和单个lodash工具之间进行的，我也测试了最初的common-js <code class="fe kw kx ky kz b">lodash</code>。这些包是使用下面的代码生成的。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="0f83" class="li lj iq kz b gy lk ll l lm ln">import drop from 'lodash/drop';<br/>import drop from 'lodash-es/drop';<br/>import drop from 'lodash.drop';</span></pre><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="c55a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该表显示了单个<code class="fe kw kx ky kz b">lodash.utility</code>封装变小，直到封装数量增加。一旦我们达到10个实用程序的标准，<code class="fe kw kx ky kz b">lodash-es</code>就会以最小的包大小领先。我将此归因于<code class="fe kw kx ky kz b">lodash-es</code>能够在函数间共享代码，而单个<code class="fe kw kx ky kz b">lodash.utility</code>函数是孤立的，不能共享代码。</p><p id="6133" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">公用设施是如何选择的？</strong></p><p id="31c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些包是以大致随机的顺序选择的，以避免从一个特定的类型中选择包，例如，只是数组或日期函数。相同类型的函数可能共享许多相同的实用程序，我不希望这成为测试中的一个因素。然而，有些实用程序比其他实用程序大得多，随着实用程序数量的增加，这可以从大小增加的不一致性中看出。</p><p id="dddd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">捆绑包是如何生成的？</strong></p><p id="0514" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我有一个非常简单的webpack配置来运行<code class="fe kw kx ky kz b">webpack-bundle-analyzer</code>，如下所示:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9eb8" class="li lj iq kz b gy lk ll l lm ln">// webpack.config.js</span><span id="f0d9" class="li lj iq kz b gy lq ll l lm ln">const path = require('path');</span><span id="4d65" class="li lj iq kz b gy lq ll l lm ln">const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;</span><span id="2992" class="li lj iq kz b gy lq ll l lm ln">module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'main.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  },<br/>  plugins: [<br/>    new BundleAnalyzerPlugin(),<br/>  ]<br/>};</span></pre><p id="885b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我的<code class="fe kw kx ky kz b">src/index.js</code>简单地导入函数并引用它们，这样它们就不会发生树抖动。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="e645" class="li lj iq kz b gy lk ll l lm ln">// src/index.js<br/>import drop from 'lodash-es/drop';<br/>import omit from 'lodash-es/omit';<br/>import fill from 'lodash-es/fill';<br/>import flatten from 'lodash-es/flatten';<br/>import head from 'lodash-es/head';</span><span id="ef84" class="li lj iq kz b gy lq ll l lm ln">drop<br/>omit<br/>fill<br/>flatten<br/>head</span></pre><p id="aad6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">收尾</strong></p><p id="3ea6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您花时间阅读这篇文章，我希望您能从中获得一些价值。接下来，我将看看<code class="fe kw kx ky kz b">Lodash</code>本身是否可以被<code class="fe kw kx ky kz b">Just</code>(<a class="ae lr" href="https://github.com/angus-c/just" rel="noopener ugc nofollow" target="_blank">https://github.com/angus-c/just</a>)取代，后者是<code class="fe kw kx ky kz b">Lodash</code>的轻量级替代品。</p></div></div>    
</body>
</html>