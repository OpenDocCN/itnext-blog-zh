<html>
<head>
<title>Managing Local State with Apollo Client and React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Apollo客户端和React钩子管理本地状态</h1>
<blockquote>原文：<a href="https://itnext.io/managing-local-state-with-apollo-client-and-react-hooks-9ad357e6d649?source=collection_archive---------0-----------------------#2019-09-09">https://itnext.io/managing-local-state-with-apollo-client-and-react-hooks-9ad357e6d649?source=collection_archive---------0-----------------------#2019-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bfee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本帖中，我们将学习如何在Apollo客户端处理本地数据</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/fe2b959921270b27075670cd741ad743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YXI0o2UNFQSAp6c3"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">塞尔索·奥利维拉在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="f3a8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">对地方政府的需求</h1><p id="42c7" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现代网络和移动应用已经变得非常数据驱动。构建大型单页应用程序是复杂的，因为数据会随着时间不断变化。每次检测这些数据变化并重新呈现UI是很痛苦的。</p><p id="4d6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望以最佳方式访问应用程序不同组件中存储的所有属性。</p><p id="d10a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">进入阿波罗客户端</strong></p><blockquote class="mf mg mh"><p id="8962" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">Apollo客户端具有内置的本地状态处理功能，允许您将本地数据与远程数据一起存储在Apollo缓存中。要访问本地数据，只需用GraphQL查询即可。您甚至可以在同一个查询中请求本地和服务器数据！— <a class="ae lb" href="https://www.apollographql.com/docs/react/essentials/local-state/#handling-client-fields-with-the-cache" rel="noopener ugc nofollow" target="_blank">阿波罗文档</a></p></blockquote><p id="9af1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始设置apollo客户机和本地状态:</p><h1 id="66e8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">设置Apollo客户端🚀</strong></h1><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Apollo客户端配置</figcaption></figure><p id="a77c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，阿波罗客户端由几个关键部分组成。</p><ul class=""><li id="77cb" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><a class="ae lb" href="https://www.apollographql.com/docs/react/advanced/network-layer/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Apollo link</strong></a><strong class="jp ir">—</strong>这是用来配置Apollo客户端的<code class="fe mx my mz na b">network layer</code>也就是说，Apollo link可以让你配置如何通过HTTP发送查询。</li><li id="38f0" class="mo mp iq jp b jq nb ju nc jy nd kc ne kg nf kk mt mu mv mw bi translated"><a class="ae lb" href="https://www.apollographql.com/docs/react/advanced/caching/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">缓存</strong> </a> —阿波罗客户端使用阿波罗缓存实例来处理其缓存策略。</li><li id="df93" class="mo mp iq jp b jq nb ju nc jy nd kc ne kg nf kk mt mu mv mw bi translated"><a class="ae lb" href="https://www.apollographql.com/docs/react/essentials/local-state/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">解析器</strong></a>——将本地状态更新实现为GraphQL变异</li><li id="b9c0" class="mo mp iq jp b jq nb ju nc jy nd kc ne kg nf kk mt mu mv mw bi translated"><a class="ae lb" href="https://www.apollographql.com/docs/react/essentials/local-state/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">typedef s</strong></a><strong class="jp ir">—</strong>到<strong class="jp ir"> </strong>可选设置一个客户端模式，用于Apollo客户端。这个模式在<a class="ae lb" href="https://github.com/apollographql/apollo-client-devtools" rel="noopener ugc nofollow" target="_blank"> Apollo客户端开发工具</a>中用于自省，在那里你可以在GraphiQL中探索你的模式。</li></ul><p id="48a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把上面的每一部分连接起来。我们将为名为<code class="fe mx my mz na b">isDarkModeEnabled</code>的属性设置一个本地状态。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="edbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们创建一个新的Apollo实例<code class="fe mx my mz na b">InMemoryCache</code>。这就是我们当地州的所在地。然后我们定义我们的网络层，以便apollo客户机连接到GraphQL服务器。</p><p id="45a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mx my mz na b">getState</code>和<code class="fe mx my mz na b">writeState</code>是读写缓存<strong class="jp ir">中数据的两个辅助函数。</strong>助手函数实现了<code class="fe mx my mz na b">cache.readData</code>和<code class="fe mx my mz na b">cache.writeData</code>，它们在缓存上充当getter和setter方法。接下来，我们<a class="ae lb" href="https://www.apollographql.com/docs/react/essentials/local-state/#initializing-the-cache" rel="noopener ugc nofollow" target="_blank">用默认值初始化</a>我们的阿波罗状态。将初始状态写入缓存很重要，这样在触发突变(更新本地状态)之前查询数据的任何组件都不会出错。最后，我们初始化我们的阿波罗客户端。</p><p id="7498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续定义类型定义和解析器。我们有一个定义应用程序状态的简单模式。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="c4ca" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">管理缓存📝</h1><p id="d892" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">当您使用Apollo客户端管理应用程序状态时，Apollo缓存是唯一的事实来源，或者用redux术语来说是“存储”。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="aeb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mx my mz na b">readState</code>和<code class="fe mx my mz na b">writeState</code>辅助函数的帮助下，我们查询初始/当前状态，然后用新值更新它。为了查询本地状态，我们在state上使用了<code class="fe mx my mz na b">@client</code>指令，表示应该从Apollo客户端缓存或本地解析器函数中解析它。</p><p id="f3a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们用一个简单的例子来看看如何更新应用程序状态</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="338c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！所有监听本地状态的组件都将获得<code class="fe mx my mz na b">appState</code>的更新值，并在更新后重新呈现。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ng mn l"/></div></figure></div></div>    
</body>
</html>