<html>
<head>
<title>Making a simple GraphQL server with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go制作一个简单的GraphQL服务器</h1>
<blockquote>原文：<a href="https://itnext.io/making-a-simple-graphql-server-with-go-dcb9b60460c6?source=collection_archive---------2-----------------------#2019-10-11">https://itnext.io/making-a-simple-graphql-server-with-go-dcb9b60460c6?source=collection_archive---------2-----------------------#2019-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e6a0e33cf1f7d513e80dbb2d0f957afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UO9VDG_Sx5wPe_kIc3WFqA.png"/></div></div></figure><h1 id="b4fc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="5631" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正如你在<a class="ae lu" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank"> AWS AppSync </a>和<a class="ae lu" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"> Prisma </a>中看到的，GraphQL不仅用于前端应用，还用于制作封装各种数据库的数据层。因为Go具有良好的类型安全和并发模型，所以在Go中实现GraphQL服务器是合理的。</p><h1 id="7875" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">为Go选择GraphQL模块</h1><p id="9060" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有一些用于Go的GraphQL模块。它们在设计上有所不同，比如模式处理。因为graph-gophers/graphql-go看起来很接近Apollo，所以我在本文中使用它。</p><ul class=""><li id="3c50" class="lv lw iq ky b kz lx ld ly lh lz ll ma lp mb lt mc md me mf bi translated"><a class="ae lu" href="https://github.com/graphql-go/graphql" rel="noopener ugc nofollow" target="_blank"> graphql-go/graphql </a></li><li id="bfc1" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated"><a class="ae lu" href="https://github.com/graph-gophers/graphql-go" rel="noopener ugc nofollow" target="_blank">graph-gophers/graph QL-go</a></li><li id="4759" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated"><a class="ae lu" href="https://gqlgen.com/" rel="noopener ugc nofollow" target="_blank"> gqlgen </a></li><li id="09e4" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated"><a class="ae lu" href="https://github.com/samsarahq/thunder" rel="noopener ugc nofollow" target="_blank">惊雷</a></li></ul><p id="8434" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">在本文中，我将<a class="ae lu" href="https://github.com/graph-gophers/graphql-go" rel="noopener ugc nofollow" target="_blank">graph-gophers/graphql-go</a>称为graph QL-go。</p><h1 id="92f0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">(计划或理论的)纲要</h1><p id="d060" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">与Apollo类似，graphql-go使用<a class="ae lu" href="https://graphql.github.io/graphql-spec/June2018/" rel="noopener ugc nofollow" target="_blank"> GraphQL模式</a>作为其输入。在schema中，您可以定义类型、查询、突变等。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4580" class="mx jz iq mt b gy my mz l na nb">const Schema = `<br/>type Vegetable {<br/>    name: String!<br/>    price: Int!<br/>    image: String<br/>}</span><span id="b5ef" class="mx jz iq mt b gy nc mz l na nb">type Query {<br/>    vegetable(name: String!): Vegetable<br/>}</span><span id="cc93" class="mx jz iq mt b gy nc mz l na nb">schema {<br/>    query: Query<br/>}<br/>`</span></pre><p id="faa8" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">它可以按如下方式进行解析和服务。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f816" class="mx jz iq mt b gy my mz l na nb">import (<br/>    "context"<br/>    "log"<br/>    "net/http"<br/>    "strings"</span><span id="203c" class="mx jz iq mt b gy nc mz l na nb">    "github.com/friendsofgo/graphiql"<br/>    graphql "github.com/graph-gophers/graphql-go"<br/>    "github.com/graph-gophers/graphql-go/relay"<br/>)</span><span id="45e9" class="mx jz iq mt b gy nc mz l na nb">// TODO: Schema</span><span id="add1" class="mx jz iq mt b gy nc mz l na nb">// TODO: Model</span><span id="bc7c" class="mx jz iq mt b gy nc mz l na nb">type query struct{}</span><span id="76ae" class="mx jz iq mt b gy nc mz l na nb">// TODO: Resolver</span><span id="d130" class="mx jz iq mt b gy nc mz l na nb">func main() {<br/>    schema := graphql.MustParseSchema(s, &amp;query{})<br/>    http.Handle("/query", &amp;relay.Handler{Schema: schema})</span><span id="3c63" class="mx jz iq mt b gy nc mz l na nb">    // TODO: init model</span><span id="d639" class="mx jz iq mt b gy nc mz l na nb">    // TODO: graphiql</span><span id="436c" class="mx jz iq mt b gy nc mz l na nb">    // Run<br/>    log.Println("Server ready at 8080")<br/>    log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="6cdd" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">此时，您将会遇到一个异常错误，提示没有名为<code class="fe nd ne nf mt b">vegetable</code>的方法。</p><h1 id="7dda" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">用于Go的GraphQL IDE</h1><p id="6dbe" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当您创建浏览实际数据的查询时，拥有可视化IDE非常有用。有一个很好的围棋模块，名叫<code class="fe nd ne nf mt b">graphiql</code>。</p><p id="9ded" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">添加这些行来替换<code class="fe nd ne nf mt b">graphiql</code>注释。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c582" class="mx jz iq mt b gy my mz l na nb">// First argument must be same as graphql handler path<br/>graphiqlHandler, err := graphiql.NewGraphiqlHandler("/query")<br/>if err != nil {<br/>    panic(err)<br/>}</span><span id="a947" class="mx jz iq mt b gy nc mz l na nb">http.Handle("/", graphiqlHandler)</span></pre><h1 id="bca2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">实施解析器</h1><p id="3bef" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们继续实现解析器。解析器是在模式文件中定义了字段的结构。</p><p id="a738" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">使用模型结构作为解析器是可能的，但是我不推荐这样做，因为解析器和模型在null处理中可能有不同的方式。在graphql-go中，可空类型是指针类型。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="123e" class="mx jz iq mt b gy my mz l na nb">type VegetableResolver struct {<br/>    v *Vegetable<br/>}</span><span id="489c" class="mx jz iq mt b gy nc mz l na nb">func (r *VegetableResolver) Name() string   { return r.v.name }<br/>func (r *VegetableResolver) Price() int32   { return int32(r.v.price) }<br/>func (r *VegetableResolver) Image() *string { return r.v.image }</span></pre><p id="c6b9" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">上面的解析器由接受参数的查询解析器返回。<br/>它必须是一个查询对象的方法。</p><p id="3010" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">查询参数作为结构中的第二个参数传递。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bcd8" class="mx jz iq mt b gy my mz l na nb">func (q *query) Vegetable(ctx context.Context, args struct{ Name string }) *VegetableResolver {<br/>    v, ok := vegetables[strings.ToLower(args.Name)]<br/>    if ok {<br/>        return &amp;VegetableResolver{v: &amp;v}<br/>    }<br/>    return nil<br/>}</span></pre><p id="29ee" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">您应该使用为每个请求创建的上下文，而不是背景。使用Stackdriver时很重要。</p><p id="a23b" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">因此，解析器与模式相关联。</p><h1 id="5f78" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">数据模型</h1><p id="90f4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了简化这个例子，让我们考虑一个简单的struct映射作为我们的数据源。您可以在ORM需要的字段中添加标签。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1e28" class="mx jz iq mt b gy my mz l na nb">type Vegetable struct {<br/>    name  string<br/>    price int<br/>    image *string<br/>}</span><span id="4946" class="mx jz iq mt b gy nc mz l na nb">var vegetables map[string]Vegetable</span><span id="e429" class="mx jz iq mt b gy nc mz l na nb">// Utils<br/>func strPtr(str string) *string {<br/>    return &amp;str<br/>}</span></pre><p id="283e" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated"><code class="fe nd ne nf mt b">func main</code>中的初始化是:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5098" class="mx jz iq mt b gy my mz l na nb">// init model<br/>vegetables = map[string]Vegetable{<br/>    "tomato": Vegetable{name: "Tomato", price: 100, image: strPtr("https://picsum.photos/id/152/100/100")},<br/>    "potato": Vegetable{name: "Potato", price: 50, image: strPtr("https://picsum.photos/id/159/100/100")},<br/>    "corn": Vegetable{name: "Corn", price: 200},<br/>}</span></pre><p id="b17e" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">通过运行包含所有代码片段的main.go并打开<code class="fe nd ne nf mt b">http://localhsot:8080/</code>，您可以尝试这样的查询。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/780e8c6cccd179bb909a40706aedb371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*s3sfIRzbNlMonUobEmTn6Q.png"/></div></figure><h1 id="42e3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="8d8b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因此，在Go中制作一个基本的GraphQL服务器并不困难。一旦您制作了一个简单的服务器，集成各种数据库客户机就非常简单了。此外，您可以通过应用<code class="fe nd ne nf mt b">go generate</code>或<code class="fe nd ne nf mt b">reflect</code>模块来简化这些集成。</p></div></div>    
</body>
</html>