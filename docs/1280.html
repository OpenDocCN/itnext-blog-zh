<html>
<head>
<title>Useful “reduce” use cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的“减少”用例</h1>
<blockquote>原文：<a href="https://itnext.io/useful-reduce-use-cases-91a86ee10bcd?source=collection_archive---------3-----------------------#2018-08-28">https://itnext.io/useful-reduce-use-cases-91a86ee10bcd?source=collection_archive---------3-----------------------#2018-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/667e12eaeee8be74a955030d3f2b0298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ji3NuzK3DyQUmg-NUBUtOQ.jpeg"/></div></div></figure><p id="920f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近看到一个开发人员的推文，他说他理解array <code class="fe kw kx ky kz b">reduce</code>函数，但是想不出很多有用的用例。在这篇文章中，我的目标是给出几个真实世界的<code class="fe kw kx ky kz b">reduce</code>用例。</p><p id="fbb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">帖子会假设你对JavaScript承诺感到满意；如果没有，我在之前的帖子里有一个非常简单的入门教程，你可以看看。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="d76c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">承诺链</h1><p id="ee36" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated"><code class="fe kw kx ky kz b">Promise.all()</code>并行运行多个承诺非常有用，但是如果你的承诺应该解决的<strong class="ka ir">顺序</strong>很重要呢？在这种情况下，您需要按顺序运行它们。下面的函数将完全做到这一点。</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="0d75" class="mt lj iq kz b gy mu mv l mw mx">const promiseQueue = (promiseFn, list) =&gt;<br/>  list.reduce(<br/>    (queue, item) =&gt; queue.then(async result =&gt; {<br/>      const itemResult = await promiseFn(item);<br/>      return result.concat([itemResult]);<br/>    }),<br/>    Promise.resolve([])<br/>  );</span></pre><h1 id="81cc" class="li lj iq bd lk ll my ln lo lp mz lr ls lt na lv lw lx nb lz ma mb nc md me mf bi translated">数字总和</h1><p id="c533" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">使用<code class="fe kw kx ky kz b">reduce</code>最常见、最经典的例子是获取一组数字的总和，所以没有它这个列表就不完整。但是它不一定是一个数字数组——您可以使用更复杂的数据结构。</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="ed23" class="mt lj iq kz b gy mu mv l mw mx">const cities = [<br/>  {<br/>    city: "Chongqing",<br/>    population: 30165500<br/>  },<br/>  {<br/>    city: "Shanghai",<br/>    population: 24183300<br/>  },<br/>  {<br/>    city: "Beijing",<br/>    population: 21707000<br/>  },<br/>  {<br/>    city: "Lagos",<br/>    population: 16060303<br/>  },<br/>  // ...etc<br/>]</span><span id="c5b4" class="mt lj iq kz b gy nd mv l mw mx">const totalPopulation = cities.reduce(<br/>  (sum, city) =&gt; sum + city.population,<br/>  0<br/>);</span></pre><h1 id="92fd" class="li lj iq bd lk ll my ln lo lp mz lr ls lt na lv lw lx nb lz ma mb nc md me mf bi translated">过滤和映射</h1><p id="1cab" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">当你有一个数据集需要通过一些标准过滤，并且你也想操作每一个剩余的项目时，一个好的但是有点幼稚的选择是首先对它运行<code class="fe kw kx ky kz b">filter</code>，然后再对它运行<code class="fe kw kx ky kz b">map</code>，本质上比需要做更多的循环项目。更好的选择是使用<code class="fe kw kx ky kz b">reduce</code>。</p><p id="e52d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">比方说，你有所有写了某篇论文的学生的成绩，但你只对所有分数超过80分的学生的全名感兴趣。</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="d6e5" class="mt lj iq kz b gy mu mv l mw mx">const studentsData = [<br/>  {<br/>    firstName: "Albert",<br/>    lastName: "Einstein",<br/>    score: 53<br/>  },<br/>  {<br/>    firstName: "Charles",<br/>    lastName: "Dickens"<br/>    score: 84<br/>  },<br/>  {<br/>    firstName: "Marilyn",<br/>    lastName: "vos Savant",<br/>    score: 99<br/>  },<br/>  // etc.<br/>];</span><span id="2aac" class="mt lj iq kz b gy nd mv l mw mx">const smartestStudents = studentsData.reduce(<br/>  (result, student) =&gt; {<br/>    // do your filtering<br/>    if (student.score &lt;= 80) {<br/>      return result;<br/>    }</span><span id="4a4f" class="mt lj iq kz b gy nd mv l mw mx">    // do your mapping<br/>    result.push(`${student.firstName} ${student.lastName}`);<br/>    return result;<br/>  },<br/>  []<br/>);</span></pre><h1 id="3b6e" class="li lj iq bd lk ll my ln lo lp mz lr ls lt na lv lw lx nb lz ma mb nc md me mf bi translated">数组到对象的转换</h1><p id="3bb2" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">有时，您需要一个对象作为一个数组的输出，而不是另一个数组的输出。所有其他数组高阶函数将<em class="ne">始终</em>产生一个数组作为输出。</p><p id="2dff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">比方说，您有一个带有有效性约束的表单字段数组，您想要一个约束对象，其中字段的名称是对象中的顶级键。</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="9259" class="mt lj iq kz b gy mu mv l mw mx">const fields = [<br/>  {<br/>    type: 'text',<br/>    title: 'Title',<br/>    name: 'title',<br/>    constraints: {<br/>      required: {<br/>        message: '^Title is required',<br/>        allowEmpty: false<br/>      }<br/>    },<br/>  },<br/>  {<br/>    type: 'text',<br/>    title: 'Slug',<br/>    name: 'slug',<br/>    constraints: {<br/>      required: {<br/>        message: '^Slug is required',<br/>        allowEmpty: false<br/>      },<br/>      format: {<br/>        pattern: '[a-z0-9_-]+',<br/>        flags: 'i',<br/>        message: '^Can only be a valid slug'<br/>      }<br/>    },<br/>  },<br/>  // etc.<br/>];</span><span id="2792" class="mt lj iq kz b gy nd mv l mw mx">const validationRules = fields.reduce(<br/>  (rules, field) =&gt; Object.assign(rules, { [field.name]: field.constraints }),<br/>  {}<br/>);</span></pre><p id="d9e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这会产生类似这样的结果:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="9512" class="mt lj iq kz b gy mu mv l mw mx">{<br/>  title: {<br/>    required: {<br/>      message: '^Title is required',<br/>      allowEmpty: false<br/>    }<br/>  },<br/>  slug: {<br/>    required: {<br/>      message: '^Slug is required',<br/>      allowEmpty: false<br/>    },<br/>    format: {<br/>      pattern: '[a-z0-9_-]+',<br/>      flags: 'i',<br/>      message: '^Can only be a valid slug'<br/>    }<br/>  },<br/>  // etc.<br/>}</span></pre><p id="6df3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ne">注意:如果你不关心数据的变化，你可以考虑使用</em> <code class="fe kw kx ky kz b"><em class="ne">Object.assign({}, rules, { [field.name]: field.constraints })</em></code> <em class="ne">或者使用对象扩展语法，</em> <code class="fe kw kx ky kz b"><em class="ne">{ ...rules, [field.name]: field.constraints }</em></code> <em class="ne">。我建议不要这样做。就个人而言，我坚信不变数据的价值，但带有实用主义色彩。在这种情况下，将为每次迭代创建一个新对象，这可能会在应用程序中使用大量不必要的内存。</em></p><h1 id="fe6c" class="li lj iq bd lk ll my ln lo lp mz lr ls lt na lv lw lx nb lz ma mb nc md me mf bi translated">管道或合成功能</h1><p id="c25e" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">有时您有一系列函数，您希望为特定值调用这些函数。有用的函数式编程方法<code class="fe kw kx ky kz b">compose</code>和<code class="fe kw kx ky kz b">pipe</code>非常适合这一点，但不幸的是，它们不是JavaScript语言的固有部分(目前还不是！).不用担心，我们可以轻松地编写自己的代码:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="dd83" class="mt lj iq kz b gy mu mv l mw mx">const pipe = (...fns) =&gt; x =&gt; fns.reduce((v, f) =&gt; f(v), x)</span></pre><p id="f2eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">pipe</code>是一个接受函数列表的函数，依次调用每个函数，前一个函数的输出作为下一个函数的输入。</p><p id="54b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">compose</code>很相似；它只是以相反的顺序调用函数，从最后到第一个，所以它可以这样实现:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="1e10" class="mt lj iq kz b gy mu mv l mw mx">const compose = (...fns) =&gt; x =&gt; fns.reverse().reduce((v, f) =&gt; f(v), x)</span></pre><p id="fe90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个例子可以是计算一个在线商店的结帐总额:</p><pre class="ml mm mn mo gt mp kz mq mr aw ms bi"><span id="e894" class="mt lj iq kz b gy mu mv l mw mx">const calculateTotal = pipe(<br/>  applyAnySales,<br/>  minusStoreCredit,<br/>  applyCouponCode,<br/>  addTaxes<br/>)</span><span id="b40c" class="mt lj iq kz b gy nd mv l mw mx">const cardValue = 250;</span><span id="8028" class="mt lj iq kz b gy nd mv l mw mx">const total = calculateTotal(cardValue)</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="e9a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你还有其他使用 <code class="fe kw kx ky kz b"><em class="ne">reduce</em></code> <em class="ne">的实例，请留下评论，以便我向你学习。</em></p></div></div>    
</body>
</html>