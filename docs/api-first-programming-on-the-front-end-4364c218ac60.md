# API-前端优先编程

> 原文：<https://itnext.io/api-first-programming-on-the-front-end-4364c218ac60?source=collection_archive---------3----------------------->

![](img/d7f92e5fbde91f5d2f8a37f22a717828.png)

照片由 [rawpixel](https://unsplash.com/@rawpixel?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

API 是程序各部分之间的协议，是某些功能的提供者和消费者之间的协议。典型的 API 交互是在一个数据服务(比如 Google Maps)和一个向它发送一些数据(比如两个地址)并接收返回数据(比如从第一个地址到第二个地址的步骤列表)的网站之间进行的。

然而，API 的提供者和消费者不必如此分离。上面描述的交互，其中消费者向提供者发送数据并接收回数据，与*功能*的描述相匹配。函数可以彼此非常接近，甚至在同一个文件中。

API 中的 I 代表“接口”，意思是两个黑盒接触的边缘。把*你的*代码想象成一个黑盒可能有点奇怪，但是 API 提供者除了你发送给它的内容之外，对你的代码没有任何洞察力，就像你除了通过它的响应之外，对服务提供者做什么没有任何洞察力一样。虽然程序员编写依赖于自身外部隐式信息的函数是可能的，也是常见的，但将每个函数视为一个具有自己 API 的黑盒通常是有用的。

## 基本原理

为什么要像对待黑盒一样对待代码中的函数和对象，对彼此的内部和上下文一无所知？为什么要关心定义它们的 API 呢？答案是这样做加强了关注点的分离。正确分割的程序可以安全快速地发展，知道只要部件之间的边界(API)被尊重，部件本身可以改变和改进。这个边界可以通过测试来覆盖，以保证在内部变化时保持一致。

## 编写 API

当一个函数是一个黑盒时，它的 API 是它与消费者交流的主要方式。(其他方法是通过文档和源代码。)重要的是，这个接口，即函数调用，尽可能地可预测和自文档化。在编写这个 API 的过程中，您可以做几件事来帮助您。

你可以**很好地命名事物**。该函数正在检索一个值吗？称之为`getValueName`。使用`set*`设定值。用`onEvent`订阅或回复事件。构式应该是大写的名词(如`new Car()`)，但大多数功能应该是**动词**，因为它们在主谓宾语句中充当动词(如`slideshow = combine(slides);`)。

避免在名称中编码返回类型，而是描述函数将执行的操作。`getLocations`击败`getLocationArray`。返回类型可以用 IDE 将使用的类型系统进行编码。

一般来说，名字要足够长以描述功能，并且要足够短以方便使用。避免使用缩写，保持名字的可读性，以便于讨论。如果您发现自己在为函数命名时遇到困难，这是一个危险信号，表明该函数可能在做不止一件事情，并且可以从分解中受益。

您可以**最小化参数长度**。零个或一个参数是最好的，因为参数顺序不会混乱。我喜欢将我的函数限制在三个或更少的参数，如果我需要传入更多的数据，就使用一个对象。使用对象会给函数提供伪命名参数:

```
// self-documenting function call
new Character({
  magic: true,
  strength: 3,
  movement: 5,
  weapons: ['sword', 'staff'],
  abilities: ['curse', 'stab'],
})// wtf??
new Character(
  true,
  3,
  5,
  ['sword', 'staff'],
  ['curse', 'stab']
)
```

一般来说，您的函数应该请求执行其任务所需的最少信息。永远不要要求可以从其他论据中合理推导出的信息。

您可以**避免布尔参数**，因为它们在阅读时描述性较差。例如`increaseSize(false)`就令人困惑。是加大尺寸还是不加大？它是否设置了一些可选的尺寸变化？不需要布尔形参，要么需要一个具有布尔属性的对象(`increaseSize({ width: false })`)，要么将函数一分为二(`increaseHeight`和`increaseSize`)，两者都不需要实参。

您可以**将不同的行为拆分成单独的功能，而不是拆分单个功能的行为**。与上面的例子类似，基于输入的拆分行为被称为“重载”一个函数。做得好的话，重载函数可以是一种神奇的用户体验。做得不好，功能会陷入混乱的泥潭。无论哪种方式，请注意，您是在为减少 API 表面而牺牲可预测性。

您可以**将默认为当前行为的可选参数**添加到函数签名的末尾。面对现实吧，代码会改变。有时候一个函数并没有像它本该写的那样好。有时，当你意识到它依赖于一个可能需要改变的假设时，已经太晚了(在函数被使用之后)。如前所述，您可以编写一个新的函数来处理相同的任务，但是假设发生了变化，*或*您可以添加一个可选参数。如果您这样做，请将其默认为之前的假设，这样您就不会强制更改当前的使用。

您可以**可预测地对参数进行排序**。可选参数放在最后，所以可以省略。不得不写`doThing(null, null, 3)`令人沮丧，因为前两个参数是可选的。即使在可选参数中，有些参数比其他参数*更*可选，例如`Array.prototype.slice`中的`endIndex`，所以按可选性升序排列。类似地，如果您将所有可选或配置参数组合成一个`options`对象参数，它应该放在最后— `throttle(fn, 300, { leading: true })`。

可变或“重要”的参数排在前面，比如`copy(array, startIndex, endIndex)`或`merge(toObject, fromObject)`。争论的相对“重要性”(我故意含糊其辞)应该继续在一个方向上，比如在`pipe(firstFn, secondFn, thirdFn)`和`compose(thirdFn, secondFn, firstFn)`中。我没有一个好的方法来决定这个*应该按照什么顺序*出现，但是它应该按照*和*的顺序出现，而不是像`doStuff(secondFn, firstFn, thirdFn)`那样。

可以**不写函数**。您可以选择保持逻辑内联，而不是放入新的函数中。请记住，将逻辑抽象成一个函数会引入间接性，并且[不会减少重复](https://medium.com/@ntgard/duplication-first-programming-2cc9fc89cffe)。在引入一个新功能之前，要确保它的好处是值得付出的。

此外，在程序中不需要的地方暴露更少的函数。将您的助手封装在您需要的地方，并防止从其他地方访问。如果发现该函数在其他地方有用，可以将其提升并作为程序的官方 API 的一部分公开。否则，将其隐藏在闭包中，或者作为模块中未导出的方法。

广泛公开功能/逻辑的一个典型借口是这是测试所必需的。测试应该总是蒙着眼睛进行。你应该测试的是公开的接口，而不是内部机制或状态。当一个未公开的助手函数的公开消费者被完全覆盖时，这个函数将在测试中被覆盖。

你可以从函数中**返回一致的值**。如果函数的一个分支返回一个承诺，那么每个分支都应该返回一个承诺。“快乐之路”返回一个数组吗？让“悲伤路径”返回空数组。避免让函数的消费者检查它返回了什么。与函数输出的交互应该和调用它一样可预测。

## 关于滚装的一个注记

RO/RO 模式(请求对象/返回对象)很棒，我推荐使用它，但是它引入了一个新的挑战:命名对象的属性。本着保持 API 一致性的精神，对象应该被很好地命名(参见前面的章节),并且**应该只增长**。取消或重命名这些对象中的一个属性是影响函数使用者的重大更改。

## 结论

通过保持函数之间的边界小、可预测且定义明确，可以防止变化在程序中蔓延。不改变 API 的代码变化将以最小的代价带来改进，因为 API 的消费者不需要改变。将函数签名视为 API 使得测试能够轻松地覆盖输入和输出的每一种可能性，而无需操纵或依赖函数的内部或上下文。这就产生了健壮的测试套件，为程序接种疫苗防止程序出错。

## 附加阅读

[https://emptysqua.re/blog/api-evolution-the-right-way/](https://emptysqua.re/blog/api-evolution-the-right-way/)