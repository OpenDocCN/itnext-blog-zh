<html>
<head>
<title>Interceptors in gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC中的拦截器</h1>
<blockquote>原文：<a href="https://itnext.io/grpc-interceptors-e221aa4cc49?source=collection_archive---------0-----------------------#2021-01-12">https://itnext.io/grpc-interceptors-e221aa4cc49?source=collection_archive---------0-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="caa3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们是什么，我们如何使用它们？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e5e95e0d196de835e67641c71889eb3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*msLHScCPYP4ENsiGqU3_wg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@thomweerd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Thom </a>在<a class="ae ky" href="https://unsplash.com/s/photos/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ae59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我交谈过的许多人都非常清楚什么是中间件。然而，拦截器似乎不太为人所知。让我们剖析拦截器，学习如何使用和编写它们，以及为什么我们应该这样做。</p><p id="ffe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gRPC是一项伟大的技术，我已经用它替换了我的许多API。我发现编写gRPC比常规的基于HTTP的API更容易。我建议你投入时间学习它。</p><p id="3c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个系列的第二部分，然而，你<strong class="lb iu">不需要先验知识</strong>，没有第一部分和1.1部分也可以继续，<strong class="lb iu">但是我建议阅读它们</strong>。</p><ul class=""><li id="cffe" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://programmingpercy.tech/blog/using-grpc-tls-go-react-no-reverse-proxy/" rel="noopener ugc nofollow" target="_blank">【第1部分】—使用gRPC和TLS、Golang、React，无需特使</a></li><li id="b2bb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://programmingpercy.tech/blog/embedd-web-application-golang/" rel="noopener ugc nofollow" target="_blank">[第1.1部分] —在Golang二进制文件中嵌入React应用程序</a></li><li id="d99b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">[̵p̵a̵r̵t̵̵2̵]̵̵-̵̵y̵o̵u̵'̵r̵e̵̵h̵e̵r̵e̵</li><li id="284c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/streaming-data-with-grpc-2eb983fdee11">【第3部分】—使用gRPC传输数据</a></li></ul><p id="0f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在常规的HTTP服务器中，我们会有一个中间件来包装服务器上的处理程序。在实际提供正确的内容之前，这个中间件可以用来执行服务器想要做的任何事情，它可以是认证或日志或任何事情。</p><p id="4078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gRPC是不同的，它允许<strong class="lb iu">拦截器</strong>在服务器和<strong class="lb iu">客户端都使用<strong class="lb iu">。这非常好，因为它允许API的用户或消费者添加任何想要的拦截器，比如定制日志。</strong></strong></p><p id="64d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入挖掘拦截器之前，我相信gRPC本身有一些东西我们需要理解。这是gRPC服务的核心理念。</p><h2 id="377c" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">gRPC核心概念</h2><p id="1ba9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们必须理解gRPC服务中使用的两个词。我们大多数人也在使用一元词。您发送一个请求，得到一个响应。<br/> <strong class="lb iu"> Stream </strong>是你改为发送或接收protobuf消息的数据管道。这意味着，如果gRPC服务用一个流来响应，那么消费者可以在这个流中得到不止一个响应。流是由关键字流引起的，很简单吧？</p><p id="f7df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，gRPC允许四个不同的RPC调用。</p><ul class=""><li id="2601" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">一元RPC <br/> </strong>一元RPC是指一个客户端可以发送一个请求，并得到一个响应。</li><li id="26ba" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">服务器流RPC <br/> </strong>服务器流RPC是客户端发送一元请求，但返回一个流</li><li id="4ff5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">客户端流RPC <br/> </strong>客户端流RPC是当客户端发送流请求时，返回一元响应。当使用完所有消息时，将发送服务器响应。</li><li id="600c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">双向流RPC <br/> </strong>双向流是指客户端发送流请求，返回流响应。</li></ul><p id="23d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们怎么知道这些电话看起来像什么呢？<br/>下面是一些虚构用户RPC服务的例子。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="39fb" class="mj mk it ni b gy nm nn l no np">// Unary example, One request, One Response<br/>rpc GetUser(UserRequest) returns (UserResponse);<br/>// Server streaming example, Unary request, Stream response<br/>rpc GetNewUsers(EmptyRequest) returns (stream UserResponse);<br/>// Client streaming example, Stream request, Unary Response<br/>rpc RegisterUsers(stream UserRequest) returns (StatusResponse);<br/>// Bidirectional example, Stream request, Stream response<br/>rpc FindUser(stream UserRequest) returns (stream UserResponse);</span></pre><p id="0e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们理解了gRPC支持的消息，那么学习拦截器就更容易了。让我们从什么是拦截器以及存在的不同种类开始。</p><p id="ac5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拦截器就像它听起来的那样，它在API请求被执行之前拦截它们。这可以用来记录日志、认证或在处理API请求之前发生的任何事情。使用HTTP APIs，这在Golang中很容易，您可以用中间件包装您的HTTP处理程序。对于gRPC，它需要更多的知识，因此之前解释了一元和流。</p><p id="e846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种<strong class="lb iu">拦截器</strong>和<strong class="lb iu">通信双方</strong>。</p><h2 id="bd72" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">两种截击机</strong></h2><ul class=""><li id="3d73" class="lv lw it lb b lc nc lf nd li nq lm nr lq ns lu ma mb mc md bi translated"><strong class="lb iu">unary interceptors</strong>—用于API调用，即一个客户端请求和一个服务器响应。</li><li id="85e1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> StreamInterceptors — </strong>在API调用中使用，在这种调用中，客户端发送请求，但接收返回的数据流，允许服务器随着时间的推移响应多个项目。实际上，因为gRPC是双向的，所以它也可以用于客户端发送数据。</li></ul><h2 id="c198" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">双方的截击机</strong></h2><ul class=""><li id="d832" class="lv lw it lb b lc nc lf nd li nq lm nr lq ns lu ma mb mc md bi translated"><strong class="lb iu">客户端</strong> —客户端触发的拦截器</li><li id="4262" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">服务器</strong> —在服务器端触发的拦截器</li></ul><p id="ef28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得我说过gRPC拦截器比HTTP中的中间件更难理解吗？正因为如此，我们实际上也知道我们想要拦截哪种gRPC呼叫。</p><h2 id="b81b" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi">2 + 2 = 4</h2><p id="89b0" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">因为gRPC允许在客户机和服务器以及一元和流调用中使用拦截器。我们有4种不同的拦截器。</p><p id="070a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们去<a class="ae ky" href="https://godoc.org/google.golang.org/grpc" rel="noopener ugc nofollow" target="_blank"> go-grpc </a>库看看他们是如何处理的，我们可以看到四种不同的用例。这两种拦截器类型对服务器和客户机都可用。</p><ul class=""><li id="a7e5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">这些拦截器在创建客户端流时被触发。</li><li id="c902" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/grpc/grpc-go/tree/master/interceptor.go#L101" rel="noopener ugc nofollow" target="_blank">streamservericeptor</a>—这些拦截器在服务器上执行流之前被触发。</li><li id="e36c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/grpc/grpc-go/tree/master/interceptor.go#L43" rel="noopener ugc nofollow" target="_blank">unarcyclientinterceptor</a>—拦截客户端的所有一元gRPC调用。</li><li id="7b75" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/grpc/grpc-go/tree/master/interceptor.go#L84" rel="noopener ugc nofollow" target="_blank"> UnaryServerInterceptor </a> —在服务器端拦截一元gRPC调用。</li></ul><p id="18cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的要点显示了四种的定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">所有可用的gRPC拦截器类型</figcaption></figure><h2 id="fb6b" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">[计]元数据</h2><p id="e67b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">所以我们现在知道拦截器是什么了。是时候讨论一下我喜欢用它们做什么，为什么。gRPC允许发送<a class="ae ky" href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md" rel="noopener ugc nofollow" target="_blank">自定义元数据</a>。元数据是<strong class="lb iu">键值的一个非常简单的概念。</strong></p><p id="701e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们查看<a class="ae ky" href="https://godoc.org/google.golang.org/grpc/metadata#MD" rel="noopener ugc nofollow" target="_blank"> golang元数据规范</a>，我们可以看到它是一个<strong class="lb iu">map[string][]字符串。</strong></p><p id="30b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元数据可以作为报头或报尾发送。</p><ul class=""><li id="b1a0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">报头</strong>应该在数据之前<strong class="lb iu">发送。</strong></li><li id="d4e3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">拖车</strong>应在加工完成后发送<strong class="lb iu"/></li></ul><p id="3cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元数据允许我们在不改变protobuf消息的情况下向请求添加数据。这通常用于添加与请求相关但不是请求一部分的数据。例如，我们可以在请求的元数据中添加JWT令牌作为身份验证。这允许我们用逻辑扩展API端点，而不改变实际的服务器逻辑。这对于<strong class="lb iu">认证、速率限制或日志记录非常有用。</strong></p><h2 id="08bc" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">我们走吧！</h2><p id="5bf5" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">理论够了！我相信我们已经准备好开始测试了。如果你还没有，我建议你读一读。</p><div class="nv nw gp gr nx ny"><a href="https://programmingpercy.tech/blog/using-grpc-tls-go-react-no-reverse-proxy/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">将gRPC与TLS、Golang、React一起使用，无需反向代理(Envoy)</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">一篇关于如何在Go后端服务器和React客户端之间实现gRPC而不使用反向代理的文章…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">编程percy.tech</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div><p id="ac68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不想太——这里是我们将用作基础的<a class="ae ky" href="https://github.com/percybolmer/grpcexample" rel="noopener ugc nofollow" target="_blank">库</a>。</p><p id="3d77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是一个运行Ping gRPC API的简单服务器。我们将用一些拦截器来更新这个Ping API，以了解如何去做。</p><p id="2a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先获取存储库，构建web应用程序，并通过运行以下命令生成有效的TLS密钥</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d68e" class="mj mk it ni b gy nm nn l no np">mkdir grpcexample-interceptors<br/>git init<br/>git pull <a class="ae ky" href="https://github.com/percybolmer/grpcexample" rel="noopener ugc nofollow" target="_blank">https://github.com/percybolmer/grpcexample</a><br/>cd cert &amp;&amp; sudo bash certgen.sh<br/>cd ../ui/pingpongapp &amp;&amp; npm install &amp;&amp; npm run build &amp;&amp; cd ../../</span></pre><p id="b496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行程序，然后访问<a class="ae ky" href="https://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> localhost </a>，确保一切正常。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="206a" class="mj mk it ni b gy nm nn l no np">go run * .go</span></pre><p id="54b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的第一件事是向我们的API添加一个PingCounter。让我们假设这个神奇的Ping应用程序是卖给客户的。我们为许多客户使用相同的gRPC服务器和客户端。但是，我们今天为之工作的这位客户想要统计已经执行的Pings操作。这太棒了，我们可以用一个新奇的拦截器包装我们的<strong class="lb iu">一元</strong> Ping函数，而不会增加我们服务器的代码。</p><p id="6af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计票将在<strong class="lb iu">服务器</strong>中完成。这意味着我们将创建的第一个拦截器是一个<strong class="lb iu"> UnaryServerInterceptor。如果你不记得那是什么意思，请随意重读。</strong></p><p id="2f6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu"> UnaryServerInterceptor </strong>在go-grpc库中被定义为:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="ee89" class="mj mk it ni b gy nm nn l no np">type UnaryServerInterceptor func(ctx context.Context, req interface{},  info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err  error)<br/></span></pre><p id="3196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先创建一个名为interceptors的新文件夹，其中有一个名为pingCounter.go的文件。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5f0b" class="mj mk it ni b gy nm nn l no np">mkdir interceptors<br/>touch pingCounter.go</span></pre><p id="a7b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开<em class="on"> pingCounter.go </em>，这是我们编写拦截器的地方，这个包将被称为<strong class="lb iu">拦截器</strong>。现在我们要创建一个结构体，它保存一个整数来计算Ping请求的数量。我喜欢使用带有拦截器的<strong class="lb iu">结构作为方法</strong>，这样很容易访问需要的数据。它还允许访问数据库，因为您的结构可以包含这一点，这在身份验证拦截器中很有用。你可以用一个全局变量来代替，但是我倾向于避免使用它们。我知道开发人员在方法中返回gRPC拦截器也很常见。这是另一种方式，看起来像下面的要点，来自<a class="ae ky" href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/logging/zap/client_interceptors.go" rel="noopener ugc nofollow" target="_blank"> go-grpc-middleware </a>的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">代码来自go-grpc-middleware存储库，展示了它们如何返回一个函数。</figcaption></figure><p id="291b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的拦截器非常简单，它会计算自启动API以来Ping请求的数量，并将其附加到响应的<strong class="lb iu">元数据</strong>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">该代码显示了一个超级简单的UnaryServerInterceptor</figcaption></figure><p id="bf1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，一旦我们进入<em class="on"> pingCounter.go，</em>之后，我们就可以花时间创建一个<strong class="lb iu"> UnaryClientInterceptor。</strong>它们被定义为</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="dc9b" class="mj mk it ni b gy nm nn l no np">type UnaryClientInterceptor func(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption) error</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">UnaryClientInterceptor的示例。</figcaption></figure><p id="4b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我的<em class="on"> pingCounter.go </em>看起来是下面这个主旨。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">pingCounter.go外观的完整示例</figcaption></figure><p id="046e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要将这个拦截器应用到服务器和客户端。打开<em class="on"> main.go </em>并向下滚动到第68行，在那里你会找到<strong class="lb iu">generate lsapi。</strong>该函数返回一个grpc。服务器，让我们对它应用拦截器。添加拦截器是通过将它作为一个参数添加到grpc中来完成的。新服务器()。稍后我们将会看到链式拦截器。正如您所看到的，我们实际上并没有改变grpc服务的任何逻辑，只是改变了它的初始化。如果我们的服务器是某种超级高级的授权服务，那就太好了。我们轻松地添加了功能，而没有触及<em class="on">服务器中的任何逻辑</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们已经向服务器添加了一个PingCounter拦截器</figcaption></figure><p id="201b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也打开<em class="on">client/main . go。</em>我们将使用客户端来确保一切正常，然后再继续向react应用程序添加新功能。我们希望用ClientPingCounter包装gRPC连接，以查看客户端执行了多少次pings。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">如何给客户端添加一个拦截器的例子。</figcaption></figure><p id="9f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行服务器，同时运行客户端进行测试。您应该看到一条消息，显示您的客户机负责多少次pings(总是1次)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/d43809abf4dbdca46873efa5c7c9deb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8l90WcBWQ0TChzAaD523A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行服务器和测试客户端的示例</figcaption></figure><p id="1f5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也更新我们的web应用程序，以便我们可以使用附加到标题的元数据。打开<em class="on">ui/pingpongapp/src/app . js</em>我要做的第一件事就是添加服务器发给我们的元数据。这可以通过监听“元数据”事件来完成。gRPC-web有两个与元数据相关的事件。<strong class="lb iu">头</strong>元数据可以在<strong class="lb iu">元数据</strong>事件中找到。<strong class="lb iu">预告片</strong>元数据可以在<strong class="lb iu">状态</strong>事件中找到。我希望得到与golang客户机相同的输出，所以让我们添加一个元数据监听器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">如何监听携带ping计数的元数据事件的示例</figcaption></figure><p id="5574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，让我们也更新一下我们的web应用程序，以统计它发出的请求数。首先我们需要弄清楚一些事情。gRPC拦截器正在拦截离开的实际请求/响应。我们将在react应用程序中做的实际上不是拦截器，而是提供相同的功能。通常你想在拦截器中做的是像令牌一样获取/添加授权数据。如果你想在grpc-web中向服务器发送元数据，我强烈建议在客户端方法调用中完成。javascript客户机中的gRPC调用类似于下面的代码片段。包装它并给元数据对象添加一个认证令牌是非常容易的。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2bcf" class="mj mk it ni b gy nm nn l no np">client.functionname(request, metadata,callback)<br/>// An example what we use<br/>client.ping(pingRequest, metadata,function(err,response){<br/>    var pong = response.toObject();<br/>    setStatus(pong.ok);</span><span id="92c8" class="mj mk it ni b gy op nn l no np">});</span></pre><p id="535f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我这么说的原因是因为向客户端调用添加元数据比拦截它并在那里添加元数据要容易得多。<br/>在本教程中，我将按照我认为更简单的方式来做，如果你想做一个合适的gRPC-web拦截器，这里有一些例子。</p><p id="8b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是一个真实拦截器的<a class="ae ky" href="https://github.com/grpc/grpc-web/blob/master/net/grpc/gateway/examples/echo/commonjs-example/client.js#L36" rel="noopener ugc nofollow" target="_blank">示例，也是web客户端的</a><a class="ae ky" href="https://github.com/grpc/grpc-web/issues/766" rel="noopener ugc nofollow" target="_blank">示例</a>，这里是关于为什么一元拦截器在gRPC-web中被称为Stream的讨论<a class="ae ky" href="https://github.com/grpc/grpc-web/issues/942" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="002a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于上面的链接，您可以随意实现gRPC-web拦截器。我将使用我自己的方法，下面的要点展示了一个例子，在发送请求之前，我在元数据中添加了一个JWT令牌。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在发送gRPC请求之前，我在元数据中添加了一个JWT令牌。</figcaption></figure><p id="4686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个PingPong应用程序中，我们只想计算客户端pings数。因此，我将添加一个新的状态来对它们进行计数，并在发送请求时增加计数。这是我后来的全部App.js。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">显示来自服务器和客户端计数的元数据的应用程序</figcaption></figure><p id="fc3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候确保一切正常工作了，所以让我们在修改<em class="on"> App.js. </em>之后重新构建react应用程序，然后重启服务器，然后让我们访问<a class="ae ky" href="https://localhost:8080/" rel="noopener ugc nofollow" target="_blank">应用程序</a>。我还会在访问网站后尝试使用golang客户端，以确保<strong class="lb iu">服务器拦截器</strong>正常工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/f72a9559ba962cb909dd17ab958343f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*u7jHcrVaJ89MacNRKSmeug.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这就是网站给我的感觉。</figcaption></figure><p id="ed92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以从我们的待办事项列表中检查出<strong class="lb iu">unaryclienterceptor</strong>和<strong class="lb iu"> UnaryServerInterceptor </strong>。</p><p id="3313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们结束这一部分之前，让我们尝试一下<strong class="lb iu">链接拦截器。我在拦截器文件夹中创建了一个名为<em class="on"> logger.go </em>的文件。这是一个超级简单的记录器，它向stdout输出已经发出的请求，以及针对哪个gRPC端点。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这个拦截器将记录paint /main。乒乓/Ping到标准输出</figcaption></figure><p id="39b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要更新<em class="on"> main.go </em>来使用这个新的记录器。我们将再次修改<strong class="lb iu">generate lsapi</strong>。我们将增加grpc。ChainUnaryInterceptor，它接受数量可变的拦截器，并按顺序执行它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有链接的新一代SApi</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">最后的主线。开始</figcaption></figure><p id="884b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行服务器然后使用golang客户端之后，我们应该在终端中看到如下输出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/bed459178a709485aca767efaa816820.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*4LA3QDeENicCppmig7Af7g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们可以看到记录器正在工作</figcaption></figure><p id="3415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，我们现在有了一个带有一元拦截器的gRPC API，并且正在使用元数据。我推荐去看看gRPC生态系统。他们试图创建任何人都可以使用即插即用的拦截器。</p><p id="7162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的代码可以在<a class="ae ky" href="https://github.com/percybolmer/grpcexample/tree/interceptors" rel="noopener ugc nofollow" target="_blank"> github </a>找到</p><p id="f07b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本系列的下一部分可以在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/streaming-data-with-grpc-2eb983fdee11">这里找到，在这里我们将讨论流数据。</a></p></div></div>    
</body>
</html>