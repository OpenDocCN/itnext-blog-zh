<html>
<head>
<title>How to access Kubernetes applications using Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用服务访问Kubernetes应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-access-kubernetes-applications-using-services-c437a4c940ad?source=collection_archive---------0-----------------------#2019-12-16">https://itnext.io/how-to-access-kubernetes-applications-using-services-c437a4c940ad?source=collection_archive---------0-----------------------#2019-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="529d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎👋 👋这是<a class="ae kl" href="https://medium.com/@abhishek1987/kubernetes-in-a-nutshell-blog-series-c3a97fce9445" rel="noopener">“Kubernetes in the坚果壳”</a>博客系列的另一部分，它关注Kubernetes的“广度”并涵盖基本主题，如<a class="ae kl" href="https://dev.to/itnext/stateless-apps-in-kubernetes-beyond-pods-4p52" rel="noopener ugc nofollow" target="_blank">编排无状态应用</a>，如何<a class="ae kl" href="https://dev.to/itnext/hands-on-guide-configure-your-kubernetes-apps-using-the-configmap-object-44gj" rel="noopener ugc nofollow" target="_blank">使用</a> <code class="fe km kn ko kp b"><a class="ae kl" href="https://dev.to/itnext/hands-on-guide-configure-your-kubernetes-apps-using-the-configmap-object-44gj" rel="noopener ugc nofollow" target="_blank">ConfigMap</a></code>配置Kubernetes应用等。</p><div class="kq kr gp gr ks kt"><a rel="noopener  ugc nofollow" target="_blank" href="/kubernetes-in-a-nutshell-blog-series-c3a97fce9445"><div class="ku ab fo"><div class="kv ab kw cl cj kx"><h2 class="bd ir gy z fp ky fr fs kz fu fw ip bi translated">“果壳中的库伯内特”——博客系列</h2><div class="la l"><h3 class="bd b gy z fp ky fr fs kz fu fw dk translated">本系列将涵盖Kubernetes的“广度”和核心/基础主题(见下一节)。它会…</h3></div><div class="lb l"><p class="bd b dl z fp ky fr fs kz fu fw dk translated">itnext.io</p></div></div></div></a></div><p id="d4aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分，我们将深入Kubernetes服务。您将了解到:</p><ul class=""><li id="d767" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">Kubernetes内部和外部通信的服务类型</li><li id="99f5" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">集群内服务发现技术</li><li id="20ba" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">如何访问外部服务等。</li></ul><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/9b90c7b15d94c90c03c3fcfcc5bf6ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*Ol7zhQlEVXgo5v4HLuWEWA.png"/></div></figure><p id="60aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往的码(还有<code class="fe km kn ko kp b">YAML</code>！)在GitHub 上<a class="ae kl" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell/blob/master/services" rel="noopener ugc nofollow" target="_blank">可用</a></p><blockquote class="ly lz ma"><p id="5589" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">很高兴通过</em><a class="ae kl" href="https://twitter.com/abhi_tweeter" rel="noopener ugc nofollow" target="_blank"><em class="iq">Twitter</em></a><em class="iq">获得您的反馈，或者发表评论🙏🏻</em></p></blockquote></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="27b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes <code class="fe km kn ko kp b">Pod</code>是短暂的，也就是说，它们不会在重启或重新调度后保留其属性。这适用于容器存储(卷)、身份(<code class="fe km kn ko kp b">Pod</code>名称)，甚至IP地址。这给应用程序访问带来了挑战。像<code class="fe km kn ko kp b">Deployment</code>这样的高层抽象控制几个<code class="fe km kn ko kp b">Pod</code>并将它们视为无状态实体——客户端如何访问这些<code class="fe km kn ko kp b">Pod</code>组？客户需要知道<code class="fe km kn ko kp b">Deployment</code>下面每个<code class="fe km kn ko kp b">Pod</code>的坐标吗？另外，你不能指望<code class="fe km kn ko kp b">Pod</code>在重启后获得相同的IP——客户端应用程序如何继续访问<code class="fe km kn ko kp b">Pod</code>？</p><p id="1cf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入Kubernetes服务！</p><h1 id="8b01" class="mm mn iq bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">Kubernetes服务</h1><p id="8ba8" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">一个<code class="fe km kn ko kp b">Service</code>是一个更高级别的组件，它提供对一组<code class="fe km kn ko kp b">Pod</code>的访问。它将客户端应用从一个<code class="fe km kn ko kp b">Deployment</code>(或一组<code class="fe km kn ko kp b">Pod</code>的细节中分离出来，以实现可预测和稳定的访问。</p><p id="e665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes定义了以下类型的服务:</p><ul class=""><li id="a34b" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><code class="fe km kn ko kp b">ClusterIP</code> —仅适用于Kubernetes集群内的访问</li><li id="8db4" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><code class="fe km kn ko kp b">NodePort</code> —使用Kubernetes节点本身的IP和端口进行访问</li><li id="2dd7" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><code class="fe km kn ko kp b">LoadBalancer</code> —使用外部负载平衡器(通常是特定于云提供商的)，例如<a class="ae kl" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> AKS </a>中的<a class="ae kl" href="https://docs.microsoft.com/azure/load-balancer/load-balancer-overview?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure负载平衡器</a></li><li id="1102" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><code class="fe km kn ko kp b">ExternalName</code> —将<code class="fe km kn ko kp b">Service</code>映射到外部DNS名称</li></ul><p id="1041" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">人们可以将访问模式分为两大类:</p><ul class=""><li id="500a" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">从外部接近</li><li id="7a20" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">内部访问</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="10df" class="mm mn iq bd mo mp np mr ms mt nq mv mw mx nr mz na nb ns nd ne nf nt nh ni nj bi translated">从外部接近</h1><p id="4341" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">如果您希望外部客户端访问Kubernetes集群中的应用程序，您可以使用<code class="fe km kn ko kp b">NodePort</code>或<code class="fe km kn ko kp b">LoadBalancer</code>服务。</p><h2 id="2620" class="nu mn iq bd mo nv nw dn ms nx ny dp mw jy nz oa na kc ob oc ne kg od oe ni of bi translated">节点端口</h2><p id="6e78" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated"><code class="fe km kn ko kp b">NodePort</code>就像它听起来的那样——使得使用节点的IP(在其上已经调度了<code class="fe km kn ko kp b">Pod</code>)和Kubernetes分配的随机端口访问集群内的应用成为可能，例如，对于HTTP端点，您可以使用<code class="fe km kn ko kp b">http://&lt;node_ip&gt;:&lt;port&gt;</code></p><p id="6a37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个例子:</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="8729" class="nu mn iq kp b gy ok ol l om on">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: kin-nodeport-service<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>    - port: 80<br/>      targetPort: 8080<br/>  selector:<br/>    app: kin-service-app</span></pre><p id="5129" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然<code class="fe km kn ko kp b">NodePort</code>在概念上很简单，但这里有几点你应该注意</p><ul class=""><li id="c9fd" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">随机端口分配受限于范围— <code class="fe km kn ko kp b">30000–32767</code></li><li id="db47" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">该端口对于集群中的每个节点都是相同的</li><li id="a301" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">可以指定一个静态端口号，但是由于端口分配、无效端口等原因，<code class="fe km kn ko kp b">Service</code>创建可能会失败。</li></ul><h2 id="20af" class="nu mn iq bd mo nv nw dn ms nx ny dp mw jy nz oa na kc ob oc ne kg od oe ni of bi translated">负载平衡器</h2><p id="b004" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">当在云提供商中运行时，<code class="fe km kn ko kp b">LoadBalancer</code>服务类型触发外部负载均衡器的供应，该负载均衡器在后台之间分配流量。</p><p id="a729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了看到这一点，让我们在<a class="ae kl" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务</a>上部署一个应用程序，并使用<code class="fe km kn ko kp b">LoadBalancer</code>服务公开它。</p><blockquote class="ly lz ma"><p id="5bee" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">使用基于多节点(至少两个)云的Kubernetes集群可以很容易地演示这一概念。随意使用任何其他云提供商(例如</em> <code class="fe km kn ko kp b"><em class="iq">GKE</em></code> <em class="iq">来尝试这个场景)</em></p></blockquote><p id="764e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想用<a class="ae kl" href="https://azure.microsoft.com/" rel="noopener ugc nofollow" target="_blank"> Azure </a>试试这个，这里有一些先决条件，你应该在阅读本文教程之前完成:</p><ul class=""><li id="b069" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">获得一个<a class="ae kl" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">免费的微软Azure账户</a>！</li><li id="ac15" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="https://docs.microsoft.com/cli/azure/install-azure-cli?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">安装Azure CLI工具</a></li><li id="c82b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">安装</a> <code class="fe km kn ko kp b"><a class="ae kl" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">kubectl</a></code>来访问您的Kubernetes集群</li><li id="7440" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="https://docs.microsoft.com/en-in/azure/aks/kubernetes-walkthrough" rel="noopener ugc nofollow" target="_blank">使用CLI在Azure上设置一个双节点Kubernetes集群</a></li></ul><p id="4b9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成集群设置后，确保使用<code class="fe km kn ko kp b"><a class="ae kl" href="https://docs.microsoft.com/cli/azure/aks?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu#az-aks-get-credentials" rel="noopener ugc nofollow" target="_blank">az aks get-credentials</a></code>命令配置<code class="fe km kn ko kp b">kubectl</code>连接到集群——这会下载凭证并配置Kubernetes CLI来使用它们。</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="689d" class="nu mn iq kp b gy ok ol l om on">az aks get-credentials --name &lt;AKS-cluster-name&gt; --resource-group &lt;AKS-resource-group&gt;</span></pre><p id="6c6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你现在应该都准备好了。让我们从创建<code class="fe km kn ko kp b">Service</code>以及示例应用程序开始。</p><p id="4e3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简单起见，YAML文件直接从<a class="ae kl" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中引用，但是你也可以下载文件到你的本地机器上，以同样的方式使用它。</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="5b68" class="nu mn iq kp b gy ok ol l om on">kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/loadbalancer/service.yaml</span><span id="a13b" class="nu mn iq kp b gy oo ol l om on">kubectl apply -f <a class="ae kl" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/app/app.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/app/app.yaml</a></span></pre><blockquote class="ly lz ma"><p id="9f97" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq"/><a class="ae kl" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell/tree/master/services/app" rel="noopener ugc nofollow" target="_blank"><em class="iq">示例应用</em> </a> <em class="iq">其实很简单</em> <a class="ae kl" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">走</em> </a> <em class="iq">程序</em></p></blockquote><p id="8335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确认<code class="fe km kn ko kp b">Service</code>已经创建</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="efa2" class="nu mn iq kp b gy ok ol l om on">kubectl get svc/kin-lb-service</span></pre><p id="588d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会得到类似下面的响应</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="04bb" class="nu mn iq kp b gy ok ol l om on">NAME             TYPE           CLUSTER-IP    <strong class="kp ir"> EXTERNAL-IP </strong>    PORT(S)        AGE<br/>kin-lb-service   LoadBalancer   10.0.149.217   <strong class="kp ir">&lt;pending&gt;</strong>        80:31789/TCP   1m</span></pre><p id="a042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">EXTERNAL-IP</code>的<code class="fe km kn ko kp b">pending</code>状态是暂时的——这是因为AKS正在幕后提供一个<a class="ae kl" href="https://docs.microsoft.com/azure/load-balancer/load-balancer-overview?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure负载均衡器</a>。</p><p id="4e74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一段时间后，您应该会看到<code class="fe km kn ko kp b">EXTERNAL-IP</code>填充了负载均衡器的公共IP</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="3c7f" class="nu mn iq kp b gy ok ol l om on">NAME             TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)        AGE<br/>kin-lb-service   LoadBalancer   10.0.149.217   242.42.420.42   80:31789/TCP   2m</span></pre><p id="7bde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查应用程序是否也已部署——您应该看到两个<code class="fe km kn ko kp b">Pod</code>处于<code class="fe km kn ko kp b">Running</code>状态</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="326c" class="nu mn iq kp b gy ok ol l om on">kubectl get pod -l=app=kin-service-app</span><span id="2c82" class="nu mn iq kp b gy oo ol l om on">NAME                              READY   STATUS    RESTARTS   AGE<br/>kin-service-app-775f989dd-gr4jk   1/1     Running   0          5m<br/>kin-service-app-775f989dd-rmq6r   1/1     Running   0          5m</span></pre><p id="c7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用负载平衡器IP访问应用程序，如下所示:</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="00ee" class="nu mn iq kp b gy ok ol l om on">curl <a class="ae kl" href="http://242.42.420.42/" rel="noopener ugc nofollow" target="_blank">http://242.42.420.42/</a></span></pre><blockquote class="ly lz ma"><p id="b4b6" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">请注意，在您的情况下，IP会有所不同。另外，根据</em> <code class="fe km kn ko kp b"><em class="iq">Service</em></code> <em class="iq">清单中的</em> <code class="fe km kn ko kp b"><em class="iq">spec.ports.port</em></code> <em class="iq">属性，负载平衡器端口为</em> <code class="fe km kn ko kp b"><em class="iq">80</em></code> <em class="iq">。</em></p></blockquote><p id="a48b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会看到类似以下内容的响应:</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="f951" class="nu mn iq kp b gy ok ol l om on">Hello from Pod IP 10.244.0.151 on Node aks-agentpool-37379363-0</span></pre><p id="1933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此输出显示:</p><ul class=""><li id="888c" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><code class="fe km kn ko kp b">Pod</code>的IP，以及，</li><li id="6b35" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">Pod所在的<code class="fe km kn ko kp b">Node</code>的名称</li></ul><p id="2033" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您再次尝试访问应用程序(<code class="fe km kn ko kp b">curl http://242.42.420.42/</code>)，您很可能会被负载平衡到另一个实例<code class="fe km kn ko kp b">Pod</code>，该实例可能位于不同的<code class="fe km kn ko kp b">Node</code>上，您可能会看到如下响应:</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="5462" class="nu mn iq kp b gy ok ol l om on">Hello from Pod IP 10.244.1.139 on Node aks-agentpool-37379363-1</span></pre><blockquote class="ly lz ma"><p id="8e82" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">您可以扩展您的应用程序(向内和向外扩展),并使用负载平衡器IP继续访问它。</em></p></blockquote><p id="c4d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想使用CLI获取Azure负载平衡器的详细信息，请使用以下命令:</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="7d80" class="nu mn iq kp b gy ok ol l om on">export AZURE_RESOURCE_GROUP=[enter AKS resource group]<br/>export AKS_CLUSTER_NAME=[enter AKS cluster name]</span></pre><p id="9402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe km kn ko kp b"><a class="ae kl" href="https://docs.microsoft.com/cli/azure/aks?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">az aks show</a></code>命令获取AKS集群基础架构资源组名称</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="fdfb" class="nu mn iq kp b gy ok ol l om on">INFRA_RG=$(az aks show --resource-group $AZURE_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --query nodeResourceGroup -o tsv)</span></pre><p id="421d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用它列出带有<code class="fe km kn ko kp b"><a class="ae kl" href="https://docs.microsoft.com/cli/azure/network/lb?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu#az-network-lb-list" rel="noopener ugc nofollow" target="_blank">az network lb list</a></code>命令的负载平衡器(您将得到一个带有负载平衡器信息的JSON响应)</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="207d" class="nu mn iq kp b gy ok ol l om on">az network lb list -g $INFRA_RG</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="9c1c" class="mm mn iq bd mo mp np mr ms mt nq mv mw mx nr mz na nb ns nd ne nf nt nh ni nj bi translated">使用<code class="fe km kn ko kp b">ClusterIP</code>进行内部访问</h1><p id="f687" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated"><code class="fe km kn ko kp b">ClusterIP</code>服务类型和可以在集群内使用的通信——只需在<code class="fe km kn ko kp b">spec.type</code>中指定<code class="fe km kn ko kp b">ClusterIP</code>,就可以了！</p><blockquote class="ly lz ma"><p id="b993" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><code class="fe km kn ko kp b"><em class="iq">ClusterIP</em></code> <em class="iq">是默认的服务类型</em></p></blockquote><p id="cae4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使对于具有<code class="fe km kn ko kp b">ClusterIPService</code>类型的集群内通信，也必须有一种方法让应用<code class="fe km kn ko kp b">A</code>调用应用<code class="fe km kn ko kp b">B</code>(通过<code class="fe km kn ko kp b">Service</code>)。集群中的应用有两种服务发现方式:</p><ul class=""><li id="df8c" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">环境变量</li><li id="9172" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><code class="fe km kn ko kp b">DNS</code></li></ul><h2 id="4452" class="nu mn iq bd mo nv nw dn ms nx ny dp mw jy nz oa na kc ob oc ne kg od oe ni of bi translated">环境变量</h2><p id="b7b5" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">每个<code class="fe km kn ko kp b">Pod</code>都有一组特定于<code class="fe km kn ko kp b">Service</code>的环境变量。让我们看看这是怎么回事！如下创建一个<code class="fe km kn ko kp b">ClusterIP</code>服务，并确认它已经被创建</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="bad7" class="nu mn iq kp b gy ok ol l om on">kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/clusterip/service.yaml</span><span id="91d7" class="nu mn iq kp b gy oo ol l om on">kubectl get svc/kin-cip-service</span></pre><p id="ecee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得我们为探索<code class="fe km kn ko kp b">LoadBalancer</code> <code class="fe km kn ko kp b">Service</code>类型而部署的应用程序吗？好吧，删除并重新创建它一次(我会解释为什么这样做，一会儿)</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="74b7" class="nu mn iq kp b gy ok ol l om on">kubectl delete -f https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/app/app.yaml</span><span id="9817" class="nu mn iq kp b gy oo ol l om on">kubectl apply -f <a class="ae kl" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/app/app.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/app/app.yaml</a></span></pre><p id="dad6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦app处于<code class="fe km kn ko kp b">Running</code>状态(检查<code class="fe km kn ko kp b">kubectl get pod -l=app=kin-service-app</code>)，<code class="fe km kn ko kp b"><a class="ae kl" href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#exec" rel="noopener ugc nofollow" target="_blank">exec</a></code>(直接在<code class="fe km kn ko kp b">Pod</code>内部执行命令)进入<code class="fe km kn ko kp b">Pod</code>检查其环境变量</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="501f" class="nu mn iq kp b gy ok ol l om on">kubectl exec &lt;enter-pod-name&gt; -- env | grep KIN_CIP</span></pre><p id="514f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将看到类似下面的结果:</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="aa6d" class="nu mn iq kp b gy ok ol l om on">KIN_CIP_SERVICE_PORT_9090_TCP_ADDR=10.0.44.29<br/>KIN_CIP_SERVICE_SERVICE_PORT=9090<br/>KIN_CIP_SERVICE_PORT_9090_TCP_PROTO=tcp<br/>KIN_CIP_SERVICE_PORT_9090_TCP=tcp://10.0.44.29:9090<br/>KIN_CIP_SERVICE_PORT=tcp://10.0.44.29:9090<br/>KIN_CIP_SERVICE_SERVICE_HOST=10.0.44.29<br/>KIN_CIP_SERVICE_PORT_9090_TCP_PORT=9090</span></pre><p id="2414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意环境变量名称的格式了吗？其中包括<code class="fe km kn ko kp b">ClusterIP</code> <code class="fe km kn ko kp b">Service</code>本身的名称(即<code class="fe km kn ko kp b">kin-cip-service</code>)，将<code class="fe km kn ko kp b">-</code>替换为<code class="fe km kn ko kp b">_</code>，其余为大写。这是一种预定义的格式，如果您知道支持它的<code class="fe km kn ko kp b">Service</code>的名称，它可以用来与另一个应用程序通信。</p><blockquote class="ly lz ma"><p id="c5a3" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">这里有一个警告:只有在</em> <code class="fe km kn ko kp b"><em class="iq">Service</em></code> <em class="iq">之前创建了</em> <code class="fe km kn ko kp b"><em class="iq">Pod</em></code> <em class="iq">时，才会将环境变量植入其中！这就是我们必须重新创建应用程序来查看效果的原因。</em></p></blockquote><p id="534d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用环境变量从另一个<code class="fe km kn ko kp b">Pod</code>访问这个应用程序。用<code class="fe km kn ko kp b">curl</code>再运行一次<code class="fe km kn ko kp b">Pod</code></p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="4f42" class="nu mn iq kp b gy ok ol l om on">kubectl run --rm --generator=run-pod/v1 curl --image=radial/busyboxplus:curl -i --tty</span></pre><blockquote class="ly lz ma"><p id="a3de" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">你应该很快就会看到一个命令提示符</em></p></blockquote><p id="657a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确认这个<code class="fe km kn ko kp b">Pod</code>也有环境变量(使用<code class="fe km kn ko kp b">env | grep KIN_CIP</code>，然后使用环境变量简单地<code class="fe km kn ko kp b">curl</code>应用程序端点</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="8b47" class="nu mn iq kp b gy ok ol l om on">curl <a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/$KIN_CIP_SERVICE_SERVICE_HOST:$KIN_CIP_SERVICE_SERVICE_PORT">http://$KIN_CIP_SERVICE_SERVICE_HOST:$KIN_CIP_SERVICE_SERVICE_PORT</a></span></pre><p id="8ad6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会看到与<code class="fe km kn ko kp b">LoadBalancer</code>示例相同的响应，即</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="e46e" class="nu mn iq kp b gy ok ol l om on">Hello from Pod IP 10.244.0.153 on Node aks-agentpool-37379363-0</span></pre><p id="ad73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多试几次，以确认负载在各个吊舱之间达到平衡！因此，我们基于<code class="fe km kn ko kp b">Service</code>名称导出环境变量，即<code class="fe km kn ko kp b">kin-cip-service</code>被转换为<code class="fe km kn ko kp b">KIN_CIP_SERVICE</code>，其余部分被添加- <code class="fe km kn ko kp b">_SERVICE_HOST</code>和<code class="fe km kn ko kp b">_SERVICE_PORT</code>，分别用于主机和端口。</p><h2 id="4695" class="nu mn iq bd mo nv nw dn ms nx ny dp mw jy nz oa na kc ob oc ne kg od oe ni of bi translated">域名服务器(Domain Name Server)</h2><p id="288f" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">Kubernetes有一个内置的DNS服务器(例如<code class="fe km kn ko kp b">CoreDNS</code>)，为每个<code class="fe km kn ko kp b">Service</code>维护DNS记录。就像环境变量一样，DNS技术提供了一个一致的命名方案，基于这个方案，如果您知道应用程序的<code class="fe km kn ko kp b">Service</code>名称(如果需要的话，还有其他信息，比如<code class="fe km kn ko kp b">namespace</code>)，您就可以访问应用程序。</p><blockquote class="ly lz ma"><p id="dc7e" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">好的一点是，这种技术不像环境变量</em>那样依赖于 <code class="fe km kn ko kp b"><em class="iq">Service</em></code> <em class="iq">和</em> <code class="fe km kn ko kp b"><em class="iq">Pod</em></code> <em class="iq">的创建顺序</em></p></blockquote><p id="828d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以马上试试:</p><p id="8ecf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次运行<code class="fe km kn ko kp b">curl</code> <code class="fe km kn ko kp b">Pod</code></p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="32c6" class="nu mn iq kp b gy ok ol l om on">kubectl run --rm --generator=run-pod/v1 curl --image=radial/busyboxplus:curl -i --tty</span></pre><p id="8b38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要访问应用程序:</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="bdf8" class="nu mn iq kp b gy ok ol l om on">curl <a class="ae kl" href="http://kin-cip-service.default.svc.cluster.local:9090" rel="noopener ugc nofollow" target="_blank">http://kin-cip-service.default.svc.cluster.local:9090</a></span></pre><p id="a114" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都应该以同样的方式工作！FQDN格式为<code class="fe km kn ko kp b">&lt;service-name&gt;.&lt;namespace&gt;.&lt;cluster-domain-suffix&gt;</code>。在我们的例子中，它映射到:</p><ul class=""><li id="1cb2" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><code class="fe km kn ko kp b">service-name</code> - <code class="fe km kn ko kp b">kin-cip-service</code></li><li id="3a1d" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><code class="fe km kn ko kp b">namespace</code> - <code class="fe km kn ko kp b">default</code></li><li id="47f0" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><code class="fe km kn ko kp b">cluster-domain-suffix</code> - <code class="fe km kn ko kp b">svc.cluster.local</code></li></ul><blockquote class="ly lz ma"><p id="3c0d" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">对于同一个</em> <code class="fe km kn ko kp b"><em class="iq">namespace</em></code> <em class="iq">中的应用程序，你实际上可以跳过大部分，只使用服务名！</em></p></blockquote></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="05fd" class="mm mn iq bd mo mp np mr ms mt nq mv mw mx nr mz na nb ns nd ne nf nt nh ni nj bi translated">映射外部服务</h1><p id="df9d" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">有些情况下，您需要从Kubernetes集群内部的应用程序引用外部服务。你可以用几种方法来做到这一点</p><ul class=""><li id="e6ff" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">以静态方式使用<code class="fe km kn ko kp b">Endpoints</code>资源</li><li id="660d" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">使用<code class="fe km kn ko kp b">ExternalName</code>服务类型</li></ul><h2 id="f3aa" class="nu mn iq bd mo nv nw dn ms nx ny dp mw jy nz oa na kc ob oc ne kg od oe ni of bi translated">静态<code class="fe km kn ko kp b">Endpoints</code></h2><p id="948a" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">这是揭示Kubernetes为您创建的每一个<code class="fe km kn ko kp b">Service</code>创建一个<code class="fe km kn ko kp b">Endpoints</code>资源的好时机(如果您使用一个<code class="fe km kn ko kp b">selector</code>，这是除了少数场景之外的大多数情况)。这个<code class="fe km kn ko kp b">Endpoints</code>对象实际上捕获了后台<code class="fe km kn ko kp b">Pod</code>的IP。你可以使用<code class="fe km kn ko kp b">kubectl get endpoints</code>查看现有的IP。</p><p id="7f92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想要访问外部服务，您需要:</p><ul class=""><li id="5db4" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">创建一个没有任何<code class="fe km kn ko kp b">selector</code>的<code class="fe km kn ko kp b">Service</code>——Kubernetes不会创建一个<code class="fe km kn ko kp b">Endpoints</code>对象</li><li id="dc4e" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">手动创建与您的<code class="fe km kn ko kp b">Service</code>(同名)和您想要访问的服务的IP/port对应的<code class="fe km kn ko kp b">Endpoints</code>资源。</li></ul><p id="8117" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这给了你同样的好处，即你可以保持<code class="fe km kn ko kp b">Service</code>不变，并在需要时在后台更新实际实体。例如，我们将使用这种技术抽象对公共HTTP端点<code class="fe km kn ko kp b">http://demo.nats.io:8222/</code>的访问。</p><p id="7764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先创建<code class="fe km kn ko kp b">Service</code></p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="8fb8" class="nu mn iq kp b gy ok ol l om on">kubectl apply -f <a class="ae kl" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/external/static/service.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/external/static/service.yaml</a></span></pre><p id="0e3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是<code class="fe km kn ko kp b">Service</code>的样子。注意，我们将<code class="fe km kn ko kp b">port</code> <code class="fe km kn ko kp b">8080</code>映射到我们想要访问的实际(目标)端口<code class="fe km kn ko kp b">8222</code></p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="6b99" class="nu mn iq kp b gy ok ol l om on">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: demo-nats-public-service<br/>spec:<br/>  type: ClusterIP<br/>  ports:<br/>    - port: 8080<br/>      targetPort: 8222</span></pre><p id="fc20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看<code class="fe km kn ko kp b">Endpoints</code>资源。</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="1bee" class="nu mn iq kp b gy ok ol l om on">kind: Endpoints<br/>apiVersion: v1<br/>metadata:<br/>  name: demo-nats-public-service<br/>subsets:<br/>  - addresses:<br/>      - ip: 107.170.221.32<br/>    ports:<br/>      - port: 8222</span></pre><p id="c9b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意以下事项:</p><ul class=""><li id="f0f3" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">资源名称(<code class="fe km kn ko kp b">demo-nats-public-service</code>)与<code class="fe km kn ko kp b">Service</code>相同</li><li id="7c38" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">我们已经使用了<code class="fe km kn ko kp b">subsets</code>属性来指定<code class="fe km kn ko kp b">ip</code>和<code class="fe km kn ko kp b">port</code>(我们通过简单地使用<code class="fe km kn ko kp b">ping demo.nats.io</code>找到了支持<code class="fe km kn ko kp b">demo.nats.io</code>的<code class="fe km kn ko kp b">ip</code></li></ul><p id="0cb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下方式创建:</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="a788" class="nu mn iq kp b gy ok ol l om on">kubectl apply -f <a class="ae kl" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/external/static/endpoints.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/external/static/endpoints.yaml</a></span></pre><p id="e102" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！让我们看看这是否有效。只需运行一个<code class="fe km kn ko kp b">curl</code> <code class="fe km kn ko kp b">Pod</code></p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="0c37" class="nu mn iq kp b gy ok ol l om on">kubectl run --rm --generator=run-pod/v1 curl --image=radial/busyboxplus:curl -i --tty</span></pre><p id="54bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们需要使用的只是我们的<code class="fe km kn ko kp b">Service</code>的名称，即<code class="fe km kn ko kp b">demo-nats-public-service</code>(以及端口<code class="fe km kn ko kp b">8080</code>)，它将完成这个任务。</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="a6ec" class="nu mn iq kp b gy ok ol l om on">curl <a class="ae kl" href="http://demo-nats-public-service:8080" rel="noopener ugc nofollow" target="_blank">http://demo-nats-public-service:8080</a></span></pre><p id="84e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会看到以下响应(这与您浏览到<code class="fe km kn ko kp b"><a class="ae kl" href="http://demo.nats.io:8222)" rel="noopener ugc nofollow" target="_blank">http://demo.nats.io:8222</a></code> <a class="ae kl" href="http://demo.nats.io:8222)" rel="noopener ugc nofollow" target="_blank"> ) </a></p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="6ddf" class="nu mn iq kp b gy ok ol l om on">&lt;html lang="en"&gt;<br/>   &lt;head&gt;<br/>    &lt;link rel="shortcut icon" href="http://nats.io/img/favicon.ico"&gt;<br/>    &lt;style type="text/css"&gt;<br/>      body { font-family: "Century Gothic", CenturyGothic, AppleGothic, sans-serif; font-size: 22; }<br/>      a { margin-left: 32px; }<br/>    &lt;/style&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;img src="http://nats.io/img/logo.png" alt="NATS"&gt;<br/>    &lt;br/&gt;<br/>	&lt;a href=/varz&gt;varz&lt;/a&gt;&lt;br/&gt;<br/>	&lt;a href=/connz&gt;connz&lt;/a&gt;&lt;br/&gt;<br/>	&lt;a href=/routez&gt;routez&lt;/a&gt;&lt;br/&gt;<br/>	&lt;a href=/gatewayz&gt;gatewayz&lt;/a&gt;&lt;br/&gt;<br/>	&lt;a href=/leafz&gt;leafz&lt;/a&gt;&lt;br/&gt;<br/>	&lt;a href=/subsz&gt;subsz&lt;/a&gt;&lt;br/&gt;<br/>    &lt;br/&gt;<br/>    &lt;a href=https://docs.nats.io/nats-server/configuration/monitoring.html&gt;help&lt;/a&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h2 id="aba9" class="nu mn iq bd mo nv nw dn ms nx ny dp mw jy nz oa na kc ob oc ne kg od oe ni of bi translated"><code class="fe km kn ko kp b">ExternalName service</code></h2><p id="76ae" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated"><code class="fe km kn ko kp b">ExternalName</code>是另一种<code class="fe km kn ko kp b">Service</code>类型，可用于将<code class="fe km kn ko kp b">Service</code>映射到DNS名称。请注意，这是一个DNS名称，而不是上述策略中的IP/端口组合(使用手动创建的<code class="fe km kn ko kp b">Endpoints</code>)。</p><p id="b155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe km kn ko kp b">Serivce</code>清单中:</p><ul class=""><li id="03c8" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">不包括一个<code class="fe km kn ko kp b">selector</code></li><li id="141d" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">使用<code class="fe km kn ko kp b">externalName</code>属性指定DNS名称，例如<code class="fe km kn ko kp b">test.example.com</code></li><li id="7ea7" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">不允许使用IP地址</li></ul><p id="5334" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个例子:</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="9048" class="nu mn iq kp b gy ok ol l om on">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: demo-nats-public-service2<br/>spec:<br/>  type: ExternalName<br/>  externalName: demo.nats.io</span></pre><p id="d509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在创建一个名为<code class="fe km kn ko kp b">demo-nats-public-service2</code>的<code class="fe km kn ko kp b">Service</code>，它使用<code class="fe km kn ko kp b">spec.type</code>即<code class="fe km kn ko kp b">ExternalName</code>映射到DNS名称<code class="fe km kn ko kp b">demo.nats.io</code>。</p><p id="b409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其工作方式相同，即您需要使用<code class="fe km kn ko kp b">Service</code>名称来访问外部实体。唯一的区别(与手动<code class="fe km kn ko kp b">Endpoints</code>方法相比)是您还需要知道端口。要尝试这种方法:</p><p id="85d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建<code class="fe km kn ko kp b">Service</code></p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="7d62" class="nu mn iq kp b gy ok ol l om on">kubectl apply -f <a class="ae kl" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/external/external-name/service.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/external/external-name/service.yaml</a></span></pre><p id="ee1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需运行一个<code class="fe km kn ko kp b">curl</code> <code class="fe km kn ko kp b">Pod</code></p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="af9e" class="nu mn iq kp b gy ok ol l om on">kubectl run --rm --generator=run-pod/v1 curl --image=radial/busyboxplus:curl -i --tty</span></pre><p id="f240" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们需要使用的只是我们的<code class="fe km kn ko kp b">Service</code>的名称，即<code class="fe km kn ko kp b">demo-nats-public-service2</code>(以及端口<code class="fe km kn ko kp b">8222</code>)</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="dcb1" class="nu mn iq kp b gy ok ol l om on">curl <a class="ae kl" href="http://demo-nats-public-service2:8222" rel="noopener ugc nofollow" target="_blank">http://demo-nats-public-service2:8222</a></span></pre><p id="a21f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会看到与上一个场景相同的响应</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="25e7" class="mm mn iq bd mo mp np mr ms mt nq mv mw mx nr mz na nb ns nd ne nf nt nh ni nj bi translated"><code class="fe km kn ko kp b">Headless</code>服务</h1><p id="b3a3" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">您可以使用<code class="fe km kn ko kp b">LoadBalancer</code>、<code class="fe km kn ko kp b">NodePort</code>和<code class="fe km kn ko kp b">ClusterIP</code>服务类型在一组<code class="fe km kn ko kp b">Pod</code>之间实现负载平衡。A <code class="fe km kn ko kp b">Headless</code> <code class="fe km kn ko kp b">Service</code>允许访问单个<code class="fe km kn ko kp b">Pod</code>s——这种情况下不涉及代理。这在许多情况下都很有用，例如</p><ul class=""><li id="f2ee" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">考虑一个对等系统，其中各个实例(pod)需要相互访问。</li><li id="c951" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">一种主从式服务，其中从实例需要知道主Pod</li></ul><p id="fdeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了创建一个<code class="fe km kn ko kp b">Headless</code> <code class="fe km kn ko kp b">Service</code>，您需要明确指定<code class="fe km kn ko kp b">None</code>作为<code class="fe km kn ko kp b">.spec.clusterIP</code>的值。这里有一个例子:</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="b373" class="nu mn iq kp b gy ok ol l om on">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: kin-hl-service<br/>spec:<br/>  clusterIP: None<br/>  ports:<br/>    - port: 9090<br/>      targetPort: 8080<br/>  selector:<br/>    app: kin-service-app</span></pre><p id="93d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与其他类型相比，您使用无头服务的方式是不同的。针对服务(例如<code class="fe km kn ko kp b">&lt;service-name&gt;.&lt;namespace&gt;.svc.cliuster.local</code>)的DNS查找返回对应于不同<code class="fe km kn ko kp b">Pods</code>的多个IP(与其他服务类型情况下的单个虚拟IP相比)。让我们来看看实际情况</p><p id="883f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建<code class="fe km kn ko kp b">Service</code></p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="fe25" class="nu mn iq kp b gy ok ol l om on">kubectl apply -f <a class="ae kl" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/headless/service.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/services/headless/service.yaml</a></span></pre><p id="4994" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行<code class="fe km kn ko kp b">curl</code> <code class="fe km kn ko kp b">Pod</code></p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="a3e3" class="nu mn iq kp b gy ok ol l om on">kubectl run --rm --generator=run-pod/v1 curl --image=radial/busyboxplus:curl -i --tty</span></pre><p id="2343" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查衬垫<code class="fe km kn ko kp b">Pod</code> IPs</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="10f7" class="nu mn iq kp b gy ok ol l om on">nslookup kin-hl-service.default.svc.cluster.local</span></pre><p id="b8c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将得到类似下面的响应</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="c127" class="nu mn iq kp b gy ok ol l om on">[ root@curl:/ ]$ nslookup kin-hl-service<br/>Server:    10.0.0.10<br/>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local</span><span id="4333" class="nu mn iq kp b gy oo ol l om on">Name:      kin-hl-service<br/>Address 1: 10.244.0.153 10-244-0-153.kin-hl-service.default.svc.cluster.local<br/>Address 2: 10.244.1.141 10-244-1-141.kin-hl-service.default.svc.cluster.local</span></pre><p id="cb14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">10-244-0-153.kin-hl-service.default.svc.cluster.local</code>和<code class="fe km kn ko kp b">10.244.1.141 10-244-1-141.kin-hl-service.default.svc.cluster.local</code>对应于个人<code class="fe km kn ko kp b">Pod</code>的坐标——这在传统的<code class="fe km kn ko kp b">Service</code>类型中是不可能的。您现在可以使用它来访问特定的<code class="fe km kn ko kp b">Pod</code>,例如</p><pre class="lr ls lt lu gt og kp oh oi aw oj bi"><span id="c60b" class="nu mn iq kp b gy ok ol l om on">curl http://10-244-0-153.kin-hl-service.default.svc.cluster.local:8080</span><span id="1a5e" class="nu mn iq kp b gy oo ol l om on">//response<br/>Hello from Pod IP 10.244.0.153 on Node aks-agentpool-37379363-0</span><span id="dfc4" class="nu mn iq kp b gy oo ol l om on">curl http://10-244-1-141.kin-hl-service.default.svc.cluster.local:8080</span><span id="5782" class="nu mn iq kp b gy oo ol l om on">//response<br/>Hello from Pod IP 10.244.1.141 on Node aks-agentpool-37379363-1</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="d175" class="mm mn iq bd mo mp np mr ms mt nq mv mw mx nr mz na nb ns nd ne nf nt nh ni nj bi translated">进入</h1><p id="f726" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">我们确实讨论了Kubernetes <code class="fe km kn ko kp b">Service</code>的基础知识，但是我确实想强调一下<code class="fe km kn ko kp b">Ingress</code>，它完全值得一个单独的帖子。<code class="fe km kn ko kp b">Ingress</code>不是<code class="fe km kn ko kp b">Service</code>类型(如<code class="fe km kn ko kp b">ClusterIP</code>等。)——把它想象成一个<code class="fe km kn ko kp b">Service</code>之上的抽象。就像<code class="fe km kn ko kp b">Service</code>的前端一堆<code class="fe km kn ko kp b">Pod</code>一样，一个<code class="fe km kn ko kp b">Ingress</code>可以被配置为与几个后台<code class="fe km kn ko kp b">Service</code>一起工作，并按照你可以定义的规则转发请求。</p><p id="62ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由<code class="fe km kn ko kp b">Ingress</code>提供的智能实际上是以<code class="fe km kn ko kp b">Ingress</code>控制器的形式实现的。例如，<a class="ae kl" href="https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube自带基于NGINX的入口控制器</a>。控制器负责在评估<code class="fe km kn ko kp b">Ingress</code>规则后，提供对适当支持<code class="fe km kn ko kp b">Service</code>的访问。</p><p id="c313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是“果壳中的库伯内特”系列的这一部分。敬请关注更多内容！</p><blockquote class="ly lz ma"><p id="84d3" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">友情提示如果有兴趣学习Kubernetes和Containers使用</em> <a class="ae kl" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Azure </em> </a> <em class="iq">！只需</em> <a class="ae kl" href="https://azure.microsoft.com/en-us/free/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">创建一个</em> <strong class="jp ir"> <em class="iq">免费</em> </strong> <em class="iq">账号</em> </a> <em class="iq">就可以了！一个好的起点是使用文档中的</em> <a class="ae kl" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">快速入门、教程和代码示例</em> </a> <em class="iq">来熟悉该服务。我也强烈推荐查看一下</em> <a class="ae kl" href="https://azure.microsoft.com/resources/kubernetes-learning-path/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> 50天Kubernetes学习路径</em> </a> <em class="iq">。高级用户可能希望参考</em> <a class="ae kl" href="https://docs.microsoft.com/azure/aks/best-practices?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Kubernetes最佳实践</em> </a> <em class="iq">或观看一些</em> <a class="ae kl" href="https://azure.microsoft.com/resources/videos/index/?services=kubernetes-service&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">视频</em> </a> <em class="iq">以了解演示、主要功能和技术会议。</em></p></blockquote><p id="ebb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的希望你喜欢这篇文章，并从中学到了一些东西🙌如果你做了，请喜欢并跟随！</p></div></div>    
</body>
</html>