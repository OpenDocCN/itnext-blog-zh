<html>
<head>
<title>How to make transactions in Nest.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Nest.js中进行交易</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-make-transactions-in-nest-js-9bff9b2b02af?source=collection_archive---------3-----------------------#2021-03-15">https://itnext.io/how-to-make-transactions-in-nest-js-9bff9b2b02af?source=collection_archive---------3-----------------------#2021-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/35877dce080a153d3b2fffd0b597036d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbGMergVELRv1xIumaOtUg.png"/></div></div></figure><p id="264a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在许多情况下，开发人员在服务器上执行各种操作时必须使用事务。例如，资金转移或其他可衡量的价值，等等。对于这样的操作，我真的不希望收到一个会中断进程和破坏数据完整性的错误。</p><p id="5877" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">究竟什么是“交易”？维基百科<a class="ae kw" href="https://en.wikipedia.org/wiki/Database_transaction" rel="noopener ugc nofollow" target="_blank">说</a>:</p><p id="0263" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir">数据库事务</strong>象征着在一个数据库管理系统(或类似系统)中针对一个数据库执行的一个工作单元，并且以一种独立于其他事务的一致和可靠的方式被处理。事务通常代表数据库中的任何变化。数据库环境中的事务有两个主要目的:</p><ol class=""><li id="a85a" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">提供可靠的工作单元，允许从故障中正确恢复并保持数据库的一致性，即使在系统故障的情况下，当执行停止(完全或部分)并且对数据库的许多操作仍未完成，状态不明时。</li><li id="12c2" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">在并发访问数据库的程序之间提供隔离。如果不提供这种隔离，程序的结果可能是错误的。</li></ol><p id="3bdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，考虑一种可能发生错误的情况，如果不使用事务，会导致非常不愉快的后果。</p><p id="dd44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我做了一个小的<a class="ae kw" href="https://github.com/alphamikle/nest_transact/tree/master/example" rel="noopener ugc nofollow" target="_blank">项目</a>，其中有两个实体:</p><ul class=""><li id="82d3" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv ll ld le lf bi translated">用户</li><li id="7735" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv ll ld le lf bi translated">钱包</li></ul><p id="2e22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户可以互相转账。转账时，除了许多其他检查之外，还会检查转账人的余额是否充足。如果发生这样的情况，钱已经从发送者的余额中被借记，但是没有被转移到接收者的账户，或者相反，我们将看到一个非常悲伤、愤怒的人，或者我们将不会看到一个非常高兴的人(<em class="lm">取决于转移金额</em>)。</p><p id="5e1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，事实上交易很重要，需要整理(<em class="lm">希望每个人都同意这一点</em>)。但是你如何应用它们呢？</p><p id="7f91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们看看如果使用PostgreSQL，有错和无错查询的选项。</p><p id="bc8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有错误的常见查询集:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="7f70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，我没有手写这个请求，而是从ORM日志中提取的，但是它反映了本质。一切都非常简单明了。为了构建查询，使用了<a class="ae kw" href="https://typeorm.io/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>,稍后我们将回到这一点。</p><p id="f23a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ORM和Postgres设置是默认设置的，因此每个操作都将在自己的事务中执行，但是为了利用这一优势，您需要编写一个查询，其中与数据库相关的所有逻辑都将同时发生。</p><p id="8ec1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是在一个事务中执行多个查询的示例:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="37ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与前一个请求示例的主要区别在于，在这种情况下，所有请求都在一个事务中执行，因此，如果在某个阶段发生错误，整个事务将回滚，其中包含所有请求。或多或少像这样:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="db49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，这里是产生所有以前的SQL查询的代码。它包含一个标志，当设置时，错误在最不合适的时刻发生:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="61e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧。我们把自己从损失或非常不安的用户中拯救出来(至少在与资金转移相关的事情上是这样的)。</p><p id="08bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有人睡着吗？</p><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/0eb936726c4d218ea5c1a8eb870ebb7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/1*JJBwr4bWeUXylkFmCVkhSg.gif"/></div></figure><h1 id="015f" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">其他方式</h1><p id="39e4" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">下一步是什么？还有哪些写交易的方法？碰巧的是，你正在读的那个人(<em class="lm">这是我</em>)在他不得不写后端的时候，他真的很喜欢一个奇妙的框架。这个框架的名字叫<a class="ae kw" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> Nest.js </a>。它在Node.js平台上工作，里面的代码是用Typescript写的。这个伟大的框架几乎开箱即用，支持非常类型的表单。哪个(还是哪个？)我，正好，也真的喜欢。我不喜欢的只有一件事——在我看来，这是一种相当混乱、过于复杂的编写交易的方法。</p><p id="02f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是编写事务的官方<a class="ae kw" href="https://typeorm.io/#/transactions" rel="noopener ugc nofollow" target="_blank">示例</a>:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="f8c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从文档创建交易的第二种方法:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="c8a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，这种方法的要点如下:您需要获得一个<code class="fe mx my mz na b">transactionEntityManager: EntityManager</code>——一个允许您在事务中执行查询的实体。然后将该实体用于基的所有操作。听起来不错，只要你不需要在实践中使用这种方法。</p><p id="0d14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我真的不喜欢将依赖项直接注入服务类的方法中的想法，以及这样编写的方法在使用注入服务本身的依赖项方面变得孤立的事实。该方法工作所需的所有依赖项都必须放入其中。但最烦人的是，如果你的方法调用了嵌入在你的方法中的其他服务，那么你就不得不在那些第三方服务中创建同样的特殊方法。并在其中传递<code class="fe mx my mz na b">transactionEntityManager</code>。同时，应该记住，如果您决定通过decorator使用该方法，那么当您将<code class="fe mx my mz na b">transactionEntityManager</code>从一个服务转移到第二个服务时，第二个服务的方法也将被修饰——在第二个方法中，您将接收到没有作为依赖项传递的<code class="fe mx my mz na b">transactionEntityManager</code>和由decorator创建的【】,这意味着两个不同的事务，这意味着不幸的用户。</p><h1 id="330a" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">从例子开始</h1><p id="d4c2" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">下面是处理用户请求的控制器操作的代码:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="c39f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们需要访问<code class="fe mx my mz na b">connection</code>对象来创建一个<code class="fe mx my mz na b">transactionManager</code>。我们可以按照TypeORM文档的建议去做——只使用如上所示的<code class="fe mx my mz na b">getConnection</code>函数:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="defa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在我看来这样的代码会更难测试，这根本就是错误的(<em class="lm">大论证</em>)。因此，我们必须将<code class="fe mx my mz na b">connection</code>依赖项传递给控制器构造函数。非常幸运的是，Nest允许您通过简单地用适当的类型描述构造函数中的字段来做到这一点:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="fc6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们得出结论，为了在使用TypeORM时能够在Nest中使用事务，有必要将<code class="fe mx my mz na b">connection</code>类传递到控制器/服务构造函数中，因为现在我们只记住了这一点。</p><p id="69a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们来看看我们<code class="fe mx my mz na b">appService</code>的<code class="fe mx my mz na b">makeRemittanceWithTypeOrmV1</code>方法:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="e4bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个项目是合成的，但是为了显示这种方法的不愉快之处——我将用于保存钱包的<code class="fe mx my mz na b">savePurse</code>方法移动到一个单独的<code class="fe mx my mz na b">appServiceV2</code>服务中，并在考虑的<code class="fe mx my mz na b">makeRemittanceWithTypeOrmV1</code>方法中使用这个服务和这个方法。您可以在下面看到这个方法和服务的代码:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="63e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，在这种情况下，我们会得到以下SQL查询:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="e89d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们发送一个发生错误的请求，我们将清楚地看到来自<code class="fe mx my mz na b">appServiceV2</code>的内部事务没有回滚，因此我们的用户再次感到愤怒。</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="4223" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们得出结论，对于标准的中继方法，您需要有特殊的方法，您需要将<code class="fe mx my mz na b">transactionEntityManager</code>传递到这些方法中。</p><p id="7714" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想摆脱将<code class="fe mx my mz na b">transactionEntityManager</code>显式注入相应方法的需要，那么文档建议我们看看装饰者。</p><p id="a901" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过应用它们，我们得到这种控制器动作:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="e534" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在它变得更简单了——不需要使用<code class="fe mx my mz na b">connection</code>类，无论是在构造函数中，还是通过调用全局方法TypeORM。完全正确。但是我们服务的方法仍然应该得到一个依赖——<code class="fe mx my mz na b">transactionEntityManager</code>。这就是那些装饰者来拯救的地方:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="6aaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经弄清楚了这样一个事实，简单地使用第三方服务方法会破坏我们的事务。因此，我们使用了第三方服务的新方法<code class="fe mx my mz na b">transactionEntityManager</code>，它看起来是这样的:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="7d2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你从代码中看到的，在这个方法中我们也使用了decorator——这样我们实现了项目中所有方法的一致性(<em class="lm"> yep yep </em>),并且也消除了在使用我们的服务<code class="fe mx my mz na b">appServiceV2</code>的控制器的构造器中使用<code class="fe mx my mz na b">connection</code>的需要。</p><p id="02d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这种方法，我们得到以下请求:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="66a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，错误会破坏事务和应用程序逻辑:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="12d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文档中描述的唯一可行的方法是避免使用decorators。如果你同时在所有方法中使用decoratorss，那么那些将被其他服务使用的decorator将会注入它们自己的<code class="fe mx my mz na b">transactionEntityManagers</code>，就像我们的<code class="fe mx my mz na b">appServiceV2</code>服务和它的<code class="fe mx my mz na b">savePurseInTransaction</code>方法一样。让我们试着用另一种方法来代替这种方法:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="ff20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了我们的方法的一致性，并摆脱已经出现的层次结构，这表现在一些方法可以调用其他方法，但仍有其他方法将不能调用第一个——我们将改变<code class="fe mx my mz na b">appService</code>类的方法。因此，从文档中获得第一个选项后。</p><h1 id="4b48" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">另一途径</h1><p id="6444" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">嗯，看起来我们仍然需要将这个<code class="fe mx my mz na b">connection</code>注入到控制器构造函数中。但是提议的用事务编写代码的方式看起来仍然非常麻烦和不方便。怎么办？为了解决这个问题，我做了一个包，让你用最简单的方式使用事务。它被称为<a class="ae kw" href="https://stackedit.io/%28https://www.npmjs.com/package/nest-transact" rel="noopener ugc nofollow" target="_blank">嵌套事务</a>。</p><p id="4a58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他在做什么？这里一切都很简单。对于我们的用户和资金转移示例，让我们看看用nest-transact编写的相同逻辑。</p><p id="33ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的控制器的代码没有改变，因为我们已经确定在构造函数中不能没有<code class="fe mx my mz na b">connection</code>，我们将指定它:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="2fe6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">控制器的动作:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="4d79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在使用文档中的第一种方法的情况下，它与操作的区别在于:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="bea3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用通常的服务方法，而无需为需要通过<code class="fe mx my mz na b">transactionManager</code>的交易创建特定的变体。此外，在使用我们的服务业务方法之前，我们在同一个服务上调用<code class="fe mx my mz na b">withTransaction</code>方法，并将我们的<code class="fe mx my mz na b">transactionManager</code>传递给它。这里你可以问这样一个问题——这个方法是从哪里来的？因此:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="4cda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是请求代码:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="fd38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">错误是:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="ada5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是你已经从一开始就看到了。</p><p id="6acc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要让这种魔法发挥作用，你需要完成两个步骤:</p><ul class=""><li id="50b3" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv ll ld le lf bi translated">我们的服务必须继承自类<code class="fe mx my mz na b">TransactionFor &lt;ServiceType&gt;</code></li><li id="9a5a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv ll ld le lf bi translated">我们的服务必须在构造函数依赖列表中有一个特殊的类<code class="fe mx my mz na b">moduleRef: ModuleRef</code></li></ul><p id="c215" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">都是。顺便说一句，由于框架本身的依赖注入还没有实现——您不必显式抛出<code class="fe mx my mz na b">moduleRef</code>。<em class="lm">仅用于测试。</em></p><p id="2675" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会想— <em class="lm">为什么我要继承这个类？如果我的服务必须继承其他服务怎么办？</em>如果您认为，那么我建议计算一下您的服务中有多少是从其他类继承的，并在事务中使用。</p><p id="f76b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在它是如何工作的？出现的<code class="fe mx my mz na b">withTransaction</code>方法——为该事务重新创建您的服务，以及您的服务的所有依赖项和依赖项的依赖项——一切，一切，一切。接下来，如果您以某种方式在您的服务中存储一些状态(<em class="lm">但是如果呢？</em> ) -那么当以这种方式创建交易时，它将不存在。您的服务的原始实例仍然存在，当您调用它时，一切都会像以前一样。</p><p id="6425" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了前面的例子，我还添加了一个贪婪的方法:带佣金的转移，它在一个控制器动作中同时使用两个服务:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="ead8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此方法提出以下请求:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="309e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从中我们可以看到，所有请求仍然发生在一个事务中，它将正确工作。</p><p id="5a5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，我想说——当在几个实际项目中使用这个包时，我得到了一种更方便的编写事务的方法——当然是在Nest.js + TypeORM堆栈中。希望你也觉得有用。如果你喜欢这个包并决定尝试一下，小小的愿望——在<a class="ae kw" href="https://github.com/alphamikle/nest_transact" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上给它一个星号。对你不难，但对我和这个包有用。我也很高兴听到建设性的批评和改进这一解决方案的可能方法。</p></div></div>    
</body>
</html>