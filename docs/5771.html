<html>
<head>
<title>Eventual Consistency with Spring for Apache Kafka: Part 2 of 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Kafka与Spring的最终一致性:第2部分，共2部分</h1>
<blockquote>原文：<a href="https://itnext.io/eventual-consistency-with-spring-for-apache-kafka-part-2-of-2-23bedd512ccf?source=collection_archive---------2-----------------------#2021-05-21">https://itnext.io/eventual-consistency-with-spring-for-apache-kafka-part-2-of-2-23bedd512ccf?source=collection_archive---------2-----------------------#2021-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="77ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Spring for Apache Kafka跨多个微服务管理MongoDB中的分布式数据模型</h2></div><p id="b3b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如本帖第一部分中所讨论的，给定一个由多个微服务组成的现代<a class="ae le" href="https://en.wikipedia.org/wiki/Distributed_computing" rel="noopener ugc nofollow" target="_blank">分布式系统</a>，每个微服务拥有一个域集合数据的子集，系统几乎肯定会有一些数据重复。鉴于这种重复，我们如何保持数据的一致性？在这篇由两部分组成的文章中，我们探索了这个挑战的一个可能的解决方案——<a class="ae le" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡</a>和<a class="ae le" href="https://en.wikipedia.org/wiki/Eventual_consistency" rel="noopener ugc nofollow" target="_blank">最终一致性</a>的模型。</p><h1 id="3cdc" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">第二部分</h1><p id="38b0" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在本文的第二部分中，我们将回顾如何在本地开发环境中部署和运行storefront API组件，该环境运行在Kubernetes上，使用<a class="ae le" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>，使用<a class="ae le" href="https://minikube.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> minikube </a>。为了简单起见，我们将只运行每个微服务的一个实例。此外，我们不会实施自定义域名、TLS/HTTPS、身份验证和授权、API密钥，也不会限制对任何敏感的运营API端点或端口的访问，所有这些都是我们在实际生产环境中肯定会做的。</p><p id="ab0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了提供运营可见性，我们将在我们的系统中添加雅虎的<a class="ae le" href="https://github.com/yahoo/CMAK" rel="noopener ugc nofollow" target="_blank">CMAK</a>(Apache Kafka的集群管理器)<a class="ae le" href="https://github.com/mongo-express/mongo-express" rel="noopener ugc nofollow" target="_blank"> Mongo Express </a>、<a class="ae le" href="https://kiali.io/" rel="noopener ugc nofollow" target="_blank"> Kiali </a>、<a class="ae le" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>和<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank">格拉法纳</a>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/e58f52ad1cd6386a782e98d225343c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5Ps-bHtxOVzcbzTQTSGSg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">来自Kiali的店面API流量视图</figcaption></figure><h2 id="bde6" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">先决条件</h2><p id="dc55" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">这篇文章假设读者对Kubernetes、minikube、Docker和Istio有基本的了解。此外，这篇文章假设你已经安装了最新版本的<a class="ae le" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> minikube </a>、<a class="ae le" href="https://kubernetes.io/docs/tasks/tools/install-kubectl-macos/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>、<a class="ae le" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae le" href="https://istio.io/latest/docs/setup/getting-started/#download" rel="noopener ugc nofollow" target="_blank"> Istio </a>。这意味着<code class="fe ne nf ng nh b">kubectl</code>、<code class="fe ne nf ng nh b">istioctl</code>、<code class="fe ne nf ng nh b">docker</code>和<code class="fe ne nf ng nh b">minikube</code>命令都可以从终端获得。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/7eb666bc9e8a2919c9d4428c98a76c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CSCSp7DEb4MwSbgZNGu9g.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">所需应用程序的当前安装版本</figcaption></figure><p id="31f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我使用一台运行macOS的苹果MacBook Pro作为我的开发机器。某些命令可能特定于macOS。</p><h2 id="3690" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">源代码</h2><p id="0f16" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">这篇文章的源代码是开源的，可以在GitHub上公开获得。使用以下命令克隆GitHub项目:</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="4860" class="ms lg it nh b gy nn no l np nq">clone --branch 2021-istio \<br/>    --single-branch --depth 1 \<br/>    <a class="ae le" href="https://github.com/garystafford/storefront-demo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/storefront-demo.git</a></span></pre><h2 id="a04b" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">迷你库贝</h2><p id="6a86" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">作为Kubernetes项目的一部分，<a class="ae le" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank"> minikube </a>是本地的Kubernetes，致力于使Kubernetes易于学习和开发。Minikube在macOS、Linux和Windows上快速建立本地Kubernetes集群。鉴于我们将部署到minikube的Kubernetes资源的数量，我建议至少3个CPU和4–5 GB的内存。如果您选择部署多种可观察性工具，如果您负担得起，您可能希望增加这两种资源。在设置这个演示的时候，我多次使CPU和内存达到极限，导致minikube临时锁定。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="c816" class="ms lg it nh b gy nn no l np nq">minikube --cpus 3 --memory 5g --driver=docker start start</span></pre><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/46b77f8016ceb8029171367426a8c482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spgfRuuKEgkAOw3S53PjJQ.png"/></div></div></figure><p id="4a51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker驱动程序允许你将Kubernetes安装到现有的Docker安装中。如果您正在使用Docker，请注意您必须至少有等量的资源分配给Docker才能分配给minikube。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nr"><img src="../Images/523250641754cf7c77e2895a6086e831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXSAXsJdR6twZV6kNhYGKA.png"/></div></div></figure><p id="1018" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">继续之前，确认minikube已启动并运行，并确认<code class="fe ne nf ng nh b">kubectl</code>的当前上下文为<code class="fe ne nf ng nh b">minikube</code>。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="3f17" class="ms lg it nh b gy nn no l np nq">minikube status<br/>kubectl config current-context</span></pre><p id="3a46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些状态应该类似于以下内容:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/38cd41f91bc4ce698045cf08b285ded1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4o8nytjclOqg2TyIKXrgQ.png"/></div></div></figure><p id="b9aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用下面的<code class="fe ne nf ng nh b">eval</code>命令将您的shell指向minikube的docker-daemon。您可以使用<code class="fe ne nf ng nh b">docker image ls</code>和<code class="fe ne nf ng nh b">docker container ls</code>命令来确认正确的上下文，以查看minikube上正在运行的Kubernetes容器。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="98d7" class="ms lg it nh b gy nn no l np nq">eval $(minikube -p minikube docker-env)</span><span id="f78a" class="ms lg it nh b gy ns no l np nq">docker image ls</span><span id="a6b0" class="ms lg it nh b gy ns no l np nq">docker container ls</span></pre><p id="c28b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出应该类似于下面的屏幕截图。请注意正在运行的Kubernetes容器。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nt"><img src="../Images/84e96c4bf438883bc0f5afafe20677d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eW5SRNHlIX_NK9yn3CtJrg.png"/></div></div></figure><p id="5b4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你也可以从Docker桌面查看minikube的状态。Minikube作为一个容器运行，从Docker映像实例化，<code class="fe ne nf ng nh b">gcr.io/k8s-minikube/kicbase</code>。查看容器的统计信息，如下所示。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nr"><img src="../Images/0eb2677eb5705c550c60cb7314350ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Um5hYtYr60NsOC6p7uffxg.png"/></div></div></figure><h2 id="bfb5" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">伊斯迪奥</h2><p id="53e7" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">假设您已经下载并配置了Istio，将其安装到minikube上。我目前已经安装了<a class="ae le" href="https://istio.io/latest/news/releases/1.10.x/announcing-1.10/" rel="noopener ugc nofollow" target="_blank"> Istio 1.10.0 </a>，并且在我的<a class="ae le" href="https://ohmyz.sh/" rel="noopener ugc nofollow" target="_blank"> Oh My Zsh </a> <code class="fe ne nf ng nh b">.zshrc</code>文件中设置了<code class="fe ne nf ng nh b">ISTIO_HOME</code>环境变量。我还在我的<code class="fe ne nf ng nh b">PATH</code>环境变量中设置了Istio的<code class="fe ne nf ng nh b">bin/</code>子目录。<code class="fe ne nf ng nh b">bin/</code>子目录包含了<code class="fe ne nf ng nh b">istioctl</code>可执行文件。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="5ee2" class="ms lg it nh b gy nn no l np nq">echo $ISTIO_HOME                                                                </span><span id="4cb6" class="ms lg it nh b gy ns no l np nq"><em class="nu">&gt; /Applications/Istio/istio-1.10.0</em></span><span id="cf25" class="ms lg it nh b gy ns no l np nq">where istioctl</span><span id="e854" class="ms lg it nh b gy ns no l np nq"><em class="nu">&gt; /Applications/Istio/istio-1.10.0/bin/istioctl</em></span><span id="dbba" class="ms lg it nh b gy ns no l np nq">istioctl version<br/>                                                               <br/><em class="nu">&gt; client version: 1.10.0<br/>  control plane version: 1.10.0<br/>  data plane version: 1.10.0 (4 proxies)</em></span></pre><p id="8484" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Istio带有几个内置配置<a class="ae le" href="https://istio.io/latest/docs/setup/additional-setup/config-profiles/" rel="noopener ugc nofollow" target="_blank">配置文件</a>。这些配置文件提供了对Istio控制平面和Istio数据平面侧柜的定制。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="b8e9" class="ms lg it nh b gy nn no l np nq">istioctl profile list</span><span id="2454" class="ms lg it nh b gy ns no l np nq"><em class="nu">&gt; Istio configuration profiles:<br/>    default<br/>    demo<br/>    empty<br/>    external<br/>    minimal<br/>    openshift<br/>    preview<br/>    remote</em></span></pre><p id="9714" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个演示，我们将使用默认的概要文件，它安装了<code class="fe ne nf ng nh b">istiod</code>和一个<code class="fe ne nf ng nh b">istio-ingressgateway</code>。我们不需要使用<code class="fe ne nf ng nh b">istio-egressgateway</code>，因为所有组件都将在minikube上本地安装。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="17b5" class="ms lg it nh b gy nn no l np nq">istioctl install --set profile=default -y</span><span id="36db" class="ms lg it nh b gy ns no l np nq"><em class="nu">&gt; ✔ Istio core installed<br/>  ✔ Istiod installed<br/>  ✔ Ingress gateways installed<br/>  ✔ Installation complete</em></span></pre><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/55ececf90ff01fe579a7b5171a675b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NUwnnQ_sz9s5QbBXinySHw.png"/></div></div></figure><h2 id="f353" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">迷你库贝隧道</h2><p id="b2ef" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">类型为<code class="fe ne nf ng nh b">LoadBalancer</code>的Kubernetes服务可以通过使用<code class="fe ne nf ng nh b">minikube tunnel</code>命令公开(不要将Spring Boot <em class="nu">服务</em>(又名微服务)与Kubernetes <em class="nu">服务</em>资源类型混淆)。Minikube隧道必须在单独的终端窗口中运行，以保持<code class="fe ne nf ng nh b">LoadBalancer</code>运行。我们之前创建了<code class="fe ne nf ng nh b">istio-ingressgateway</code>。运行以下命令，注意<code class="fe ne nf ng nh b">EXTERNAL-IP</code>的状态为<code class="fe ne nf ng nh b">&lt;pending&gt;</code>。目前没有与我们的<code class="fe ne nf ng nh b">LoadBalancer</code>相关联的外部IP地址。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="d753" class="ms lg it nh b gy nn no l np nq">kubectl get svc istio-ingressgateway -n istio-system</span></pre><p id="e64a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要关联IP地址，请在单独的终端选项卡中运行<code class="fe ne nf ng nh b">minikube tunnel</code>命令。因为它需要打开特权端口80和443来暴露，这个命令将提示您输入您的<code class="fe ne nf ng nh b">sudo</code>密码。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="f5fd" class="ms lg it nh b gy nn no l np nq">minikube tunnel</span></pre><p id="ddce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重新运行上一个命令。现在应该有一个与<code class="fe ne nf ng nh b">LoadBalancer.</code>相关联的外部IP地址，在我的例子中是<code class="fe ne nf ng nh b">127.0.0.1.</code></p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="ff12" class="ms lg it nh b gy nn no l np nq">kubectl get svc istio-ingressgateway -n istio-system</span></pre><p id="582c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显示的外部IP地址是我们将用来<a class="ae le" href="https://minikube.sigs.k8s.io/docs/handbook/accessing/" rel="noopener ugc nofollow" target="_blank">访问我们选择在minikube上对外公开的资源</a>的地址。</p><h2 id="8aea" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">Minikube仪表板</h2><p id="b337" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">再次，在一个单独的终端选项卡中，打开Minikube仪表板(又名Kubernetes仪表板)。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="aaf7" class="ms lg it nh b gy nn no l np nq">minikube dashboard</span></pre><p id="65a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仪表板将为您提供所有已安装的Kubernetes组件的可视化概览。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/2e139e1a11a1d9c576128682f6548c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcvTbS3TUOftSK3Wx0cZcQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">显示istio-system名称空间的Minikube仪表板</figcaption></figure><h2 id="0942" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">名称空间</h2><p id="1c02" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Kubernetes支持由同一个物理集群支持的多个虚拟集群。这些虚拟集群被称为<a class="ae le" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" rel="noopener ugc nofollow" target="_blank">名称空间</a>。在这个演示中，我们将使用四个名称空间来组织我们部署的资源:<code class="fe ne nf ng nh b">dev</code>、<code class="fe ne nf ng nh b">mongo</code>、<code class="fe ne nf ng nh b">kafka</code>和<code class="fe ne nf ng nh b">storefront-kafka-project</code>。<code class="fe ne nf ng nh b">dev</code>名称空间是我们将部署Storefront API的微服务的地方:<code class="fe ne nf ng nh b">accounts</code>、<code class="fe ne nf ng nh b">orders</code>和<code class="fe ne nf ng nh b">fulfillment</code>。我们将把<a class="ae le" href="https://www.mongodb.com/1" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>和<a class="ae le" href="https://github.com/mongo-express/mongo-express" rel="noopener ugc nofollow" target="_blank"> Mongo Express </a>部署到<code class="fe ne nf ng nh b">mongo</code>名称空间。最后，我们将使用<code class="fe ne nf ng nh b">kafka</code>和<code class="fe ne nf ng nh b">storefront-kafka-project </code>名称空间将<a class="ae le" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Kafka </a>部署到minikube，使用<a class="ae le" href="https://strimzi.io/" rel="noopener ugc nofollow" target="_blank"> Strimzi </a>、一个<a class="ae le" href="https://cncf.io/" rel="noopener ugc nofollow" target="_blank">云本地计算基金会</a>沙盒项目和CMAK。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="a765" class="ms lg it nh b gy nn no l np nq">kubectl apply -f ./minikube/resources/namespaces.yaml</span></pre><h2 id="d8ea" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">自动边车注射</h2><p id="fdd2" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">为了利用Istio的所有功能，网格中的单元必须运行Istio边车代理。当您在一个名称空间上设置了<code class="fe ne nf ng nh b">istio-injection=enabled</code> <code class="fe ne nf ng nh b">label</code>并且启用了injection webhook时，在该名称空间中创建的任何新pod都会自动添加一个sidecar。将<code class="fe ne nf ng nh b">dev</code>命名空间标记为<a class="ae le" href="https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/#automatic-sidecar-injection" rel="noopener ugc nofollow" target="_blank">自动边车注入</a>确保我们的店面API的微服务——<code class="fe ne nf ng nh b">accounts</code>、<code class="fe ne nf ng nh b">orders</code>和<code class="fe ne nf ng nh b">fulfillment</code>——将有Istio边车代理自动注入到它们的<a class="ae le" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank"> pods </a>中。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="91e6" class="ms lg it nh b gy nn no l np nq">kubectl label namespace dev istio-injection=enabled</span></pre><h2 id="3948" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">MongoDB</h2><p id="d259" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">接下来，将MongoDB和Mongo Express部署到minikube上的<code class="fe ne nf ng nh b">mongo</code>名称空间。为了确保从Mongo Express成功连接到MongoDB，我建议在部署Mongo Express之前给MongoDB一个完全启动的机会。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="3874" class="ms lg it nh b gy nn no l np nq">kubectl apply -f ./minikube/resources/mongodb.yaml -n mongo</span><span id="50f7" class="ms lg it nh b gy ns no l np nq">sleep 60</span><span id="2327" class="ms lg it nh b gy ns no l np nq">kubectl apply -f ./minikube/resources/mongo-express.yaml -n mongo</span></pre><p id="4319" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要确认部署成功，请使用以下命令:</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="b0be" class="ms lg it nh b gy nn no l np nq">kubectl get services -n mongo</span></pre><p id="aaba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者使用Kubernetes仪表板来确认部署。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/4bfd65cb38a22fa51506bac3a5e87a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGldngD4fD_x7C6rVAK7zA.png"/></div></div></figure><h2 id="b545" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">Mongo Express用户界面访问</h2><p id="e2dc" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">对于应用程序的某些部分(例如，前端)，您可能希望将服务公开到集群外部的外部IP地址上。Kubernetes <code class="fe ne nf ng nh b"><a class="ae le" href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types" rel="noopener ugc nofollow" target="_blank">ServiceTypes</a></code>允许你指定你想要什么样的服务；默认是<code class="fe ne nf ng nh b">ClusterIP</code>。</p><p id="7ad3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，MongoDB使用的是<code class="fe ne nf ng nh b">ClusterIP</code>，而Mongo Express使用的是<code class="fe ne nf ng nh b"><a class="ae le" href="https://kubernetes.io/docs/concepts/services-networking/service/#nodeport" rel="noopener ugc nofollow" target="_blank">NodePort</a></code>。使用NodePort，服务在每个节点的IP上的一个静态端口上公开(即<code class="fe ne nf ng nh b">NodePort</code>)。您可以通过请求<code class="fe ne nf ng nh b">&lt;NodeIP&gt;:&lt;NodePort&gt;</code>从集群外部联系<code class="fe ne nf ng nh b">NodePort</code>服务。</p><p id="f5f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在单独的终端选项卡中，使用以下命令打开Mongo Express:</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="2f53" class="ms lg it nh b gy nn no l np nq">minikube service --url mongo-express -n mongo</span></pre><p id="5716" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该会看到类似如下的输出:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/fa59e182d2467bc329c390e92542ceee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9TCDmmu0j36OCLjYxy9WA.png"/></div></div></figure><p id="ca44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">点击链接打开Mongo Express。在UI中应该可以看到三个MongoDB操作数据库。这三个店面数据库和集合将在本文后面自动创建:<code class="fe ne nf ng nh b">accounts</code>、<code class="fe ne nf ng nh b">orders</code>和<code class="fe ne nf ng nh b">fulfillment</code>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nv"><img src="../Images/d32286120ee1b4bc5eb6331588b09a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0_Rhs9jrEaH3rcyA3mJ1g.png"/></div></div></figure><h2 id="4513" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">阿帕奇卡夫卡使用斯特里姆齐</h2><p id="5743" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">接下来，我们将使用<a class="ae le" href="https://strimzi.io/" rel="noopener ugc nofollow" target="_blank"> Strimzi </a>将Apache Kafka和Apache Zookeeper安装到minikube上的<code class="fe ne nf ng nh b">kafka</code>和<code class="fe ne nf ng nh b">storefront-kafka-project </code>名称空间中。由于Strimzi有一个很棒的，易于使用的<a class="ae le" href="https://strimzi.io/docs/operators/latest/quickstart.html" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>，我不会在这篇文章中详述完整的安装过程。我建议使用他们的指南来理解这个过程和每个命令的作用。然后，使用我在下面包含的稍加修改的Strimzi命令来安装Kafka和Zookeeper。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="0531" class="ms lg it nh b gy nn no l np nq"><em class="nu"># assuming 0.23.0 is latest version available<br/></em>curl -L -O <a class="ae le" href="https://github.com/strimzi/strimzi-kafka-operator/releases/download/0.23.0/strimzi-0.23.0.zip" rel="noopener ugc nofollow" target="_blank">https://github.com/strimzi/strimzi-kafka-operator/releases/download/0.23.0/strimzi-0.23.0.zip</a></span><span id="7e8c" class="ms lg it nh b gy ns no l np nq">unzip strimzi-0.23.0.zip</span><span id="36cc" class="ms lg it nh b gy ns no l np nq">cd strimzi-0.23.0</span><span id="cc1a" class="ms lg it nh b gy ns no l np nq">sed -i '' 's/namespace: .*/namespace: kafka/' install/cluster-operator/*RoleBinding*.yaml</span><span id="aab5" class="ms lg it nh b gy ns no l np nq"><em class="nu"># manually change STRIMZI_NAMESPACE value to storefront-kafka-project<br/></em>nano install/cluster-operator/060-Deployment-strimzi-cluster-operator.yaml</span><span id="208a" class="ms lg it nh b gy ns no l np nq">kubectl create -f install/cluster-operator/ -n kafka</span><span id="f162" class="ms lg it nh b gy ns no l np nq">kubectl create -f install/cluster-operator/020-RoleBinding-strimzi-cluster-operator.yaml -n storefront-kafka-project</span><span id="ed04" class="ms lg it nh b gy ns no l np nq">kubectl create -f install/cluster-operator/032-RoleBinding-strimzi-cluster-operator-topic-operator-delegation.yaml -n storefront-kafka-project</span><span id="5a59" class="ms lg it nh b gy ns no l np nq">kubectl create -f install/cluster-operator/031-RoleBinding-strimzi-cluster-operator-entity-operator-delegation.yaml -n storefront-kafka-project</span><span id="9ca8" class="ms lg it nh b gy ns no l np nq">kubectl apply -f ../storefront-demo/minikube/resources/strimzi-kafka-cluster.yaml -n storefront-kafka-project</span><span id="f677" class="ms lg it nh b gy ns no l np nq">kubectl wait kafka/kafka-cluster --for=condition=Ready --timeout=300s -n storefront-kafka-project</span><span id="3e79" class="ms lg it nh b gy ns no l np nq">kubectl apply -f ../storefront-demo/minikube/resources/strimzi-kafka-topics.yaml -n storefront-kafka-project</span></pre><h2 id="4de1" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">动物园入口</h2><p id="3f72" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们想安装雅虎的<a class="ae le" href="https://github.com/yahoo/CMAK" rel="noopener ugc nofollow" target="_blank">CMAK</a>(Apache Kafka的集群管理器)，为Kafka提供一个管理界面。然而，CMAK要求接触动物园管理员。你不能从CMAK直接访问Strimzi的动物园管理员；这是为了避免性能和安全问题。参见<a class="ae le" href="https://github.com/strimzi/strimzi-kafka-operator/issues/1337" rel="noopener ugc nofollow" target="_blank">GitHub问题</a>以获得更好的解释。我们将使用适当命名的动物园入口作为CMAK动物园管理员的代理来克服这个挑战。</p><p id="f294" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要安装动物园入口，请查看GitHub项目的安装指南，然后使用以下命令:</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="fdd6" class="ms lg it nh b gy nn no l np nq">git clone <a class="ae le" href="https://github.com/scholzj/zoo-entrance.git" rel="noopener ugc nofollow" target="_blank">https://github.com/scholzj/zoo-entrance.git</a></span><span id="c9d9" class="ms lg it nh b gy ns no l np nq">cd zoo-entrance</span><span id="72cf" class="ms lg it nh b gy ns no l np nq"><em class="nu"># optional: change my-cluster to kafka-cluster<br/></em>sed -i '' 's/my-cluster/kafka-cluster/' deploy.yaml</span><span id="c258" class="ms lg it nh b gy ns no l np nq">kubectl apply -f deploy.yaml -n storefront-kafka-project</span></pre><h2 id="435e" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">Apache Kafka的集群管理器</h2><p id="87ab" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">接下来，安装雅虎的<a class="ae le" href="https://github.com/yahoo/CMAK" rel="noopener ugc nofollow" target="_blank">CMAK</a>(Apache Kafka的集群管理器)给我们一个Kafka的管理界面。运行以下命令将CMAK部署到<code class="fe ne nf ng nh b">storefront-kafka-project</code>名称空间中。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="3f9b" class="ms lg it nh b gy nn no l np nq">kubectl apply -f ./minikube/resources/cmak.yaml -n storefront-kafka-project</span></pre><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/78b83278ef3e54908c01fc1578ce78bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZdRpSaBADNCT26PKdmZgLw.png"/></div></div></figure><p id="c82d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于Mongo Express，我们可以使用它的<code class="fe ne nf ng nh b">NodePort</code>访问CMAK的UI。在单独的终端选项卡中，运行以下命令:</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="077e" class="ms lg it nh b gy nn no l np nq">minikube service --url cmak -n storefront-kafka-project</span></pre><p id="54ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该看到类似于Mongo Express的输出。点击提供的链接访问CMAK。在CMAK选择“添加集群”,将我们现有的Kafka集群添加到CMAK的管理界面。使用Zoo Enterence的服务地址作为集群Zookeeper Hosts值。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="3929" class="ms lg it nh b gy nn no l np nq">zoo-entrance.storefront-kafka-project.svc:2181</span></pre><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/495b0ec88142bea36d2ffe5c472ff184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVLnmxRxljgIZnpSiar1Fw.png"/></div></div></figure><p id="acf5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦完成，您应该会看到我们之前用Strimzi创建的三个Kafka主题:<code class="fe ne nf ng nh b">accounts.customer.change</code>、<code class="fe ne nf ng nh b">fulfillment.order.change</code>和<code class="fe ne nf ng nh b">orders.order.change</code>。每个主题将有三个分区、一个副本和一个代理。您还应该看到<code class="fe ne nf ng nh b">_consumer_offsets</code>主题，Kafka使用它来存储关于每组消费者(groupID)的每个<code class="fe ne nf ng nh b">topic:partition</code>的<a class="ae le" href="https://kafka.apache.org/0110/documentation.html#impl_zkconsumeroffsets" rel="noopener ugc nofollow" target="_blank">承诺补偿</a>的信息。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/7e58f96f78297b33b869302ec8962198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSRGwj93jAB9Ceq91ND_BQ.png"/></div></div></figure><h2 id="dd36" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">店面API微服务</h2><p id="e367" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们终于准备好将Storefront API的微服务安装到<code class="fe ne nf ng nh b">dev</code>名称空间中了。每个微服务都被预先配置为在各自的名称空间中访问Kafka和MongoDB。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="ba09" class="ms lg it nh b gy nn no l np nq">kubectl apply -f ./minikube/resources/accounts.yaml -n dev</span><span id="bc3f" class="ms lg it nh b gy ns no l np nq">kubectl apply -f ./minikube/resources/orders.yaml -n dev</span><span id="48a7" class="ms lg it nh b gy ns no l np nq">kubectl apply -f ./minikube/resources/fulfillment.yaml -n dev</span></pre><p id="b4ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Spring Boot服务通常需要大约两分钟才能完全启动。从<a class="ae le" href="https://hub.docker.com/u/garystafford" rel="noopener ugc nofollow" target="_blank">docker.com</a>下载Docker映像所需的时间和启动时间意味着三个微服务中的每一个都可能需要3-4分钟来准备接受API流量。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nw"><img src="../Images/bc915586a98624ab4555d1e6fc5502e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xX_OgRjH7D-h6EArorUSRQ.png"/></div></div></figure><p id="60c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们看到一个<code class="fe ne nf ng nh b">accounts</code> pod同时运行一个<code class="fe ne nf ng nh b">accounts</code>容器和一个<code class="fe ne nf ng nh b">istio-proxy</code>容器。pos还包含一个<code class="fe ne nf ng nh b">istio-init</code> init容器。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/881897d7e1fdd7f55d2f4cfaa5163a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ueWieT1XHn02hOW5rav_Jg.png"/></div></div></figure><h2 id="e1d2" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">Istio组件</h2><p id="3bae" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们希望能够通过我们的Kubernetes <code class="fe ne nf ng nh b">LoadBalancer</code>访问我们的店面API的微服务，同时利用Istio作为服务网格的所有功能。为此，我们需要部署一个Istio <code class="fe ne nf ng nh b"><a class="ae le" href="https://istio.io/latest/docs/reference/config/networking/gateway/" rel="noopener ugc nofollow" target="_blank">Gateway</a></code>和一个<code class="fe ne nf ng nh b"><a class="ae le" href="https://istio.io/latest/docs/reference/config/networking/virtual-service/" rel="noopener ugc nofollow" target="_blank">VirtualService</a></code>。我们还需要部署<code class="fe ne nf ng nh b"><a class="ae le" href="https://istio.io/latest/docs/reference/config/networking/destination-rule/" rel="noopener ugc nofollow" target="_blank">DestinationRule</a></code>资源。<code class="fe ne nf ng nh b"><a class="ae le" href="https://istio.io/latest/docs/reference/config/networking/gateway/" rel="noopener ugc nofollow" target="_blank">Gateway</a></code>描述了在网格边缘运行的负载均衡器，接收传入或传出的HTTP/TCP连接。<code class="fe ne nf ng nh b"><a class="ae le" href="https://istio.io/latest/docs/reference/config/networking/virtual-service/" rel="noopener ugc nofollow" target="_blank">VirtualService</a></code>定义了当主机被寻址时要应用的一组流量路由规则。最后，<code class="fe ne nf ng nh b"><a class="ae le" href="https://istio.io/latest/docs/reference/config/networking/destination-rule/" rel="noopener ugc nofollow" target="_blank">DestinationRule</a></code>定义了在路由发生后应用于服务流量的策略。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="9086" class="ms lg it nh b gy nn no l np nq">kubectl apply -f ./minikube/resources/destination_rules.yaml -n dev</span><span id="a211" class="ms lg it nh b gy ns no l np nq">kubectl apply -f ./minikube/resources/istio-gateway.yaml -n dev</span></pre><h2 id="209d" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">测试系统并创建样本数据</h2><p id="3480" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我提供了一个Python 3脚本，该脚本针对Storefront API以特定的顺序运行一系列七个<code class="fe ne nf ng nh b">HTTP GET</code>请求。这些调用将验证部署，确认API的Spring Boot服务可以访问Kafka和MongoDB，生成一些初始数据，并根据初始Insert语句自动创建MongoDB数据库集合。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="1ad6" class="ms lg it nh b gy nn no l np nq"><em class="nu">python3 -m pip install -r </em>./utility_scripts/<em class="nu">requirements.txt -U</em></span><span id="0714" class="ms lg it nh b gy ns no l np nq">python3 ./utility_scripts/refresh.py</span></pre><p id="22a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该脚本的输出应该如下所示:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/93fff29ded96a04b805b70f07ea2fe2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA1xXlEkUUvdJJKCBedKqg.png"/></div></div></figure><p id="8e19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们现在看一下Mongo Express，我们应该注意到三个新的数据库:<code class="fe ne nf ng nh b">accounts</code>、<code class="fe ne nf ng nh b">orders</code>和<code class="fe ne nf ng nh b">fulfillment</code>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/38c20a5a21ac4cdfb1d110fd918419ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6vEwmvB6mlli8oaYbrhSSA.png"/></div></div></figure><h2 id="e6c5" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">可观察性工具</h2><p id="883f" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Istio使得<a class="ae le" href="https://istio.io/latest/docs/ops/integrations/" rel="noopener ugc nofollow" target="_blank">将</a>与几个常用工具集成变得很容易，包括<a class="ae le" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank">证书管理器</a>、<a class="ae le" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>、<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank">格拉夫纳</a>、<a class="ae le" href="https://kiali.io/" rel="noopener ugc nofollow" target="_blank">基亚里</a>、<a class="ae le" href="https://zipkin.io/" rel="noopener ugc nofollow" target="_blank">齐普金</a>和<a class="ae le" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank">耶格</a>。为了更好地观察我们的店面API，我们将安装三个著名的观察工具:Kiali、Prometheus和Grafana。幸运的是，这些工具都包含在Istio中。您可以将这些软件中的任何一个或全部安装到minikube上。我建议一次安装一个工具，以免压垮minikube的CPU和内存资源。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="b431" class="ms lg it nh b gy nn no l np nq">kubectl apply -f ./minikube/resources/prometheus.yaml</span><span id="0963" class="ms lg it nh b gy ns no l np nq">kubectl apply -f $ISTIO_HOME/samples/addons/grafana.yaml</span><span id="581c" class="ms lg it nh b gy ns no l np nq">kubectl apply -f $ISTIO_HOME/samples/addons/kiali.yaml</span></pre><p id="75ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">部署完成后，要访问这些工具的任何UI，请在新的终端窗口中使用<code class="fe ne nf ng nh b">istioctl dashboard</code>命令:</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="0763" class="ms lg it nh b gy nn no l np nq">istioctl dashboard kiali</span><span id="4b26" class="ms lg it nh b gy ns no l np nq">istioctl dashboard prometheus</span><span id="2403" class="ms lg it nh b gy ns no l np nq">istioctl dashboard grafana</span></pre><h2 id="ee24" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">基亚利</h2><p id="1aa3" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Kiali是一个基于Istio的服务网格的管理控制台。它提供了仪表板、可观察性，并允许您使用健壮的配置和验证功能来操作网格。下面我们看到了Kiali的一个视图，其中店面API流量流向Kafka和MongoDB。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/4d617e3e40a03d8f15c2b224982dbb72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_W1HT7VCVy-kkW1SOGQfQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">来自Kiali的店面API流量视图</figcaption></figure><h2 id="6d73" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">普罗米修斯</h2><p id="d74f" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Prometheus是云本地计算基金会的一个项目，是一个系统和服务监控系统。它以给定的时间间隔从配置的目标收集度量，评估规则表达式，显示结果，并可以在观察到指定条件时触发预警。</p><p id="d7c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">三个Storefront API微服务都有对Micrometer的依赖，具体来说就是对<code class="fe ne nf ng nh b">micrometer-registry-prometheus</code>的依赖。作为一个仪器门面，<a class="ae le" href="https://micrometer.io/" rel="noopener ugc nofollow" target="_blank"> Micrometer </a>允许您通过一个供应商中立的接口用维度度量来测试您的代码，并在最后一步决定监控系统。用Micrometer检测核心库代码允许将库包含在向不同后端传送度量的应用程序中。给定<a class="ae le" href="https://micrometer.io/docs/registry/prometheus" rel="noopener ugc nofollow" target="_blank">微米普罗米修斯</a>依赖，每个微服务公开一个<code class="fe ne nf ng nh b">/prometheus</code>端点(例如<code class="fe ne nf ng nh b"><a class="ae le" href="http://127.0.0.1/accounts/actuator/prometheus)," rel="noopener ugc nofollow" target="_blank">http://127.0.0.1/accounts/actuator/prometheus</a></code> <a class="ae le" href="http://127.0.0.1/accounts/actuator/prometheus)," rel="noopener ugc nofollow" target="_blank"> ) </a>如下图所示在Postman。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nx"><img src="../Images/e95295c38ad8d0b7a06d8f30cc2caf88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCR3mU6Ik6cdHq5UQENemg.png"/></div></div></figure><p id="ac77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ne nf ng nh b">/prometheus</code>端点公开了许多有用的指标，并被配置为由Prometheus收集。这些指标可以显示在Prometheus中，并通过Prometheus间接显示在Grafana仪表板中。我已经定制了<a class="ae le" href="https://istio.io/latest/docs/ops/integrations/prometheus/" rel="noopener ugc nofollow" target="_blank"> Istio的普罗米修斯</a>版本，并将其包含在项目(<code class="fe ne nf ng nh b">prometheus.yaml</code>)中，该项目现在抓取店面API的指标。</p><pre class="md me mf mg gt nj nh nk nl aw nm bi"><span id="0d06" class="ms lg it nh b gy nn no l np nq">scrape_configs:<br/>    - job_name: 'spring_micrometer'<br/><strong class="nh iu">      metrics_path: '/actuator/prometheus'<br/></strong>      scrape_interval: 5s<br/>      static_configs:<br/>        - targets: ['accounts.dev:8080','orders.dev:8080','fulfillment.dev:8080']</span></pre><p id="5ba4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在普罗米修斯中，我们可以看到一个春天卡夫卡听众指标<code class="fe ne nf ng nh b">spring_kafka_listener_seconds_sum</code>的示例图。我们的系统向普罗米修斯暴露了几十个指标，我们可以对其进行观察和警告。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nv"><img src="../Images/70b45fa5955524ce9d1b8d2010594d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_hSUTrOcAjMt9CGn4pjAA.png"/></div></div></figure><h2 id="7ff0" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">格拉夫纳</h2><p id="c8ad" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Grafana允许您查询、可视化、提醒和了解您的指标，无论它们存储在哪里。与您的团队一起创建、探索和共享仪表板，以培养数据驱动的文化。最后，这里有一个Grafana的<a class="ae le" href="https://grafana.com/grafana/dashboards/11378" rel="noopener ugc nofollow" target="_blank"> Spring Boot仪表板</a>的例子。Grafana的社区<a class="ae le" href="https://grafana.com/grafana/dashboards" rel="noopener ugc nofollow" target="_blank">仪表盘页面</a>提供了更多仪表盘。Grafana仪表板使用Prometheus作为其指标数据的来源。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/519a1e6acfc8d0f537947ac6ba15a828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOyZXW4Z6UVQnKjz9xF8wQ.png"/></div></div></figure><h2 id="bbea" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">店面API端点</h2><p id="5a8f" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">这三个店面API的Spring Boot服务都是功能齐全的<a class="ae le" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>、<a class="ae le" href="https://projects.spring.io/spring-data-rest/" rel="noopener ugc nofollow" target="_blank"> Spring Data REST </a>、<a class="ae le" href="https://spring.io/projects/spring-hateoas" rel="noopener ugc nofollow" target="_blank"> Spring HATEOAS-enabled </a>应用。每个都公开了一组丰富的CRUD端点，用于与微服务的数据实体进行交互。为了更好地理解Storefront API，每个Spring Boot微服务都使用<a class="ae le" href="http://springfox.github.io/springfox/" rel="noopener ugc nofollow" target="_blank"> SpringFox </a>，它为用Spring构建的API生成自动化的JSON API文档。微服务构建还包括<code class="fe ne nf ng nh b">springfox-swagger-ui</code> <a class="ae le" href="http://www.webjars.org/" rel="noopener ugc nofollow" target="_blank"> web jar </a>，它与<a class="ae le" href="https://github.com/swagger-api/swagger-ui" rel="noopener ugc nofollow" target="_blank"> Swagger UI </a>一起提供。<a class="ae le" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>利用一系列用于生成、可视化和维护API文档的解决方案，将手工工作从API文档中解放出来。</p><p id="a6dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从web浏览器中，您可以使用三个微服务中的任何一个的<code class="fe ne nf ng nh b"><a class="ae le" href="http://127.0.0.1/accounts/swagger-ui/" rel="noopener ugc nofollow" target="_blank">/swagger-ui</a>/</code>子目录/子路径来访问全功能的Swagger UI(例如<code class="fe ne nf ng nh b"><a class="ae le" href="http://127.0.0.1/accounts/swagger-ui/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1/accounts/swagger-ui/</a></code>)。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/f78bf1ffaef3837b1d5d3e4f29060a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s85s5fTftM0mdDoMkJ7JPQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">帐户服务客户实体端点</figcaption></figure><p id="af87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个微服务的数据模型(POJOs)也通过Swagger UI暴露出来。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/301edd90b8c05350b1a823b506306f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkjtgrdxy2ayLYB2UqCB3w.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">帐户服务数据模型</figcaption></figure><h2 id="e753" class="ms lg it bd lh mt mu dn ll mv mw dp lp kr mx my lr kv mz na lt kz nb nc lv nd bi translated">Spring Boot执行器</h2><p id="69f7" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">此外，每个微服务包括<a class="ae le" href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator" rel="noopener ugc nofollow" target="_blank"> Spring Boot致动器</a>。致动器公开了额外的操作端点，允许我们观察正在运行的微服务。使用Actuator，您可以获得许多功能，包括使用<code class="fe ne nf ng nh b">/actuator/</code>子目录/子路径(例如<code class="fe ne nf ng nh b"><a class="ae le" href="http://127.0.0.1/accounts/actuator/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1/accounts/actuator/</a></code>)访问可用的面向操作的端点。在这个演示中，我没有限制对任何可用执行器端点的访问。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/c23287f3faf8092d54e1d138d19afc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QVKEGizl0ZilZtTaZiA57w.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">使用Swagger看到的Spring Boot执行器端点的部分列表</figcaption></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nx"><img src="../Images/e78dbdd10e2d8b3b40b122f6ae115382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KoS1rNjxa0-3XMYIdU4V5g.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">使用Postman看到的Spring Boot执行器端点的部分列表</figcaption></figure><h1 id="95e3" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">结论</h1><p id="4bef" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在这篇由两部分组成的文章中，我们学习了如何使用Spring Boot构建一个API。对于Apache Kafka项目，我们使用pub/sub模型和Spring来确保API的分布式数据完整性。当一个微服务更改了相关数据时，该状态更改会触发一个状态更改事件，该事件会使用Kafka主题与其他微服务共享。</p><p id="4b2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还学习了如何使用minikube在Kubernetes上运行的本地开发环境中部署和运行API。我们增加了经过生产测试的可观察性工具来提供操作可见性，包括CMAK、Mongo Express、Kiali、Prometheus和Grafana。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="4456" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇博客代表我自己的观点，而不是我的雇主亚马逊网络服务公司(AWS)的观点。所有产品名称、徽标和品牌都是其各自所有者的财产。</p></div></div>    
</body>
</html>