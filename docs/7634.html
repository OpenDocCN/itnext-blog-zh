<html>
<head>
<title>A mentally-efficient multiplication algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种心理有效的乘法算法</h1>
<blockquote>原文：<a href="https://itnext.io/a-mentally-efficient-multiplication-algorithm-7acc34cbaf7d?source=collection_archive---------0-----------------------#2022-12-03">https://itnext.io/a-mentally-efficient-multiplication-algorithm-7acc34cbaf7d?source=collection_archive---------0-----------------------#2022-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="aeb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在你的头脑中把5位数相乘被认为是不可能的，或者只限于专家的领域。今天，你将学会自己完成不可能的事情，同时看到一些解决问题的技巧和我在设计这个算法时采取的步骤。如果您感兴趣的话，我还会在最后包含实现这种新方法的代码。</p><p id="db82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更先进的技术，如<a class="ae ko" href="https://en.wikipedia.org/wiki/Karatsuba_algorithm" rel="noopener ugc nofollow" target="_blank"> Karatsuba算法</a>有额外的开销，所以它们只有在超过几百位数时才优于传统方法。正因为如此，Java BigInteger之类的库使用传统的方法，直到达到那个截止点。</p><p id="be95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法需要更少的内存，这使得心算更容易，同时也减少了求和步骤的数量。这对于资源受限的设备也是一个很好的选择。</p><p id="6b6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">两个N位数相乘的其他算法比较:</strong></p><ul class=""><li id="f461" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><a class="ae ko" href="https://www.splashlearn.com/math-vocabulary/multiplication/long-multiplication" rel="noopener ugc nofollow" target="_blank">小学方法</a> : <strong class="js iu"> 2N + 2N加法</strong>使用一种避免加零的巧妙方法。如果心算，你还需要记住需要求和的中间值，而代码实现可以重用结果空间。</li><li id="1600" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://en.wikipedia.org/wiki/Lattice_multiplication" rel="noopener ugc nofollow" target="_blank">点阵乘法</a> : <strong class="js iu"> N + 2N加法</strong>加额外内存，用于每个单元顶部三角形中的所有进位。如果沿着对角线求和，这比小学方法需要少N次加法，而不是将它们所代表的具有许多零的大值相加。</li><li id="4e33" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">这个算法:<strong class="js iu">只有N次加法</strong>并且通过只跟踪一次进位而非常有效地存储。</li></ul><p id="eee9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有3种算法执行的乘法次数相同，不同之处在于加法次数和内存效率。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h2 id="dc33" class="lk ll it bd lm ln lo dn lp lq lr dp ls kb lt lu lv kf lw lx ly kj lz ma mb mc bi translated">探索之路</h2><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/da4f903b41bddca224c8df0940c651c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mhgkf8BBCYhbm4_E"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@profwicks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本威克斯</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="66e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">学校教授的方法需要计算许多大的中间值，这使得心理计算很快崩溃:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/de54c5d83e4c9e8491f7fb76de501355.png" data-original-src="https://miro.medium.com/v2/resize:fit:274/format:webp/1*4WqOdcdq5rdWInczaQTkRw.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">只有3位数的小学方法</figcaption></figure><p id="608f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了找到一种更有效的方法，我们将应用小学的方法，但使用变量代替数字，并分析它们如何影响答案。</p><p id="450a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将从一位数相乘开始，在寻找模式的同时逐渐增加位数。当处理较少的数字时，我们将选择相同的最低有效变量，以便变量在迭代中是相同的:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/5dd65af8b22e8b5cea9157e1d5640d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*wKkUzBVCpRy-T-IlehfOvg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">数字的变量</figcaption></figure><p id="1788" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种技术是至关重要的，以便用较少的努力看到模式。</p><p id="6960" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 1位数:</strong></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/daa89002ca8afb70a1db8d7190099b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/format:webp/1*Ts8vv62-GCFc8j1wrKInJQ.png"/></div></figure><p id="83ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在乘以个位数之后，没有新的见解出现，因为到目前为止我们还没有真正说什么。</p><p id="325b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">方括号表示结果中没有结转的数字。我的方法是用不需要结转的小数位来处理这个问题的一个更简单的版本，然后在最后发展解决方案来处理结转。</p><p id="9659" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">两位数字:</strong></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/fc0405959da4e507914c7399deeb3020.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*g-JuF3Vh8bRH53WsqzZbvQ.png"/></div></figure><p id="9645" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，最后一个数字<strong class="js iu">【H * D】</strong>，对于两次迭代是相同的，但是我们不能真正推断出太多，因为我们只有2个样本。</p><p id="e5fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">三位数:</strong></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/fb282e179c723ba5ed05def0564036c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*N7r5FAwDtI66X5CN2gESlg.png"/></div></figure><p id="965d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哦，这看起来很有趣，因为倒数第二个数字<strong class="js iu">【H * C+G * D】</strong>，现在也匹配了！让我们再来看一次迭代，以获得更强的信号。</p><p id="aedd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 4位数字:</strong></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi my"><img src="../Images/2208a5583a0923abd041111484522d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*-LNapU0qpBWEiJ1q7ZYC1w.png"/></div></div></figure><p id="6851" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该模式在这里进一步延伸，因此我们看到:</p><ul class=""><li id="331c" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">最后一位数字始终是<strong class="js iu">【H * D】</strong></li><li id="ba33" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">当将至少有两位数的数相乘时，倒数第二位总是<strong class="js iu"> [H*C + G*D] </strong></li><li id="9e48" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">当将至少有3位数的数相乘时，倒数第3位数总是<strong class="js iu"> [H*B + G*C + F*D] </strong></li></ul></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h2 id="092f" class="lk ll it bd lm ln lo dn lp lq lr dp ls kb lt lu lv kf lw lx ly kj lz ma mb mc bi translated">洞察力</h2><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mz"><img src="../Images/260097cac0b563570b10e9c0756eb255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WRdcwZu3c6no1eJw"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">胡安·鲁米普努在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><ol class=""><li id="3bf0" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn na kv kw kx bi translated">当任何数字与至少<strong class="js iu"> k位</strong>数字相乘时，第<strong class="js iu"> k位</strong>最后一位数字总是具有相同的结构</li><li id="737d" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn na kv kw kx bi translated">结果的第<strong class="js iu"> k </strong>个最后一位数仅由每个输入的最后<strong class="js iu"> k </strong>位数组成。</li></ol><p id="6e8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一点是有希望的，因为它表明，如果我们能够发现第<strong class="js iu"> k </strong>个最后一位数的模式，我们就可以计算每个数字。然而，将两个<strong class="js iu"> k </strong>位数字相乘会产生一个2* <strong class="js iu"> k </strong>位数字的结果，所以我们只完成了一半。我的计划是为最后的k位数字找到一个模式，并使其适应整个结果，因为我希望一个一致的模式适用于所有的数字。</p><p id="bc1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二点更有希望，因为它表明我们应该能够从最低有效数字开始逐渐反向生成结果，而不是一次计算整个结果。这应该有助于减少精神开销。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h2 id="e37f" class="lk ll it bd lm ln lo dn lp lq lr dp ls kb lt lu lv kf lw lx ly kj lz ma mb mc bi translated">解锁第k个最后一位数模式</h2><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nb"><img src="../Images/9ec2a88706ea1b20452212065d16cce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YnFBwduaJ21ZbLT3"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">保罗·斯科鲁普斯卡斯在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2e7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我非常支持尽可能直观地描绘问题，因为与分析方法相比，我们的视觉皮层在识别模式方面要好得多。使用4位数迭代，让我们在结果中每个数字需要相乘的所有数字之间画一条线。</p><p id="51ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">最后一位:</strong>【H * D】</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/7edf2c188b04078b1dc3984a54807272.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*UJzc-b8lmSCGy1hs65M6OQ.png"/></div></figure><p id="c194" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第二位-最后一位:</strong>【H * C+G * D】</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/4d9096f47398e13002ce0ef90117606a.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*IV-iVEtQzG7h5eLZUSQVVQ.png"/></div></figure><p id="427f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第三位-最后一位:</strong>【H * B+G * C+F * D】</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/57646cdd151e6f1a96956038d897c426.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*jlfJc3MiuAjXZvcWew24PQ.png"/></div></figure><p id="5b51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第4位-最后一位:</strong>【H * A+G * B+F * C+E * D】</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/074d14ae7b8d58295f1a5d4fde5ab39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*8qmI4EN6N78CnUobngUxMg.png"/></div></figure><p id="43f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第5位-最后一位:</strong>【G * A+F * B+E * C】</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/22da40801a7576a27ed63a646c58af1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*OZe8y0CYxFNaQ7UD6RmrUQ.png"/></div></figure><p id="3222" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第6位-最后一位:</strong>【F * A+E * B】</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/fe8053602d9e9592e72acbb237c71b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*5nnM_sO6ij8GCLcewrmexQ.png"/></div></figure><p id="4430" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第7位-最后一位:</strong>【E * A】</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/bc2409900d3ab2955ed11d186d5dd1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*HAmTMdOJjOYE5HNj6D0iXQ.png"/></div></figure><h2 id="2e67" class="lk ll it bd lm ln lo dn lp lq lr dp ls kb lt lu lv kf lw lx ly kj lz ma mb mc bi translated">找到了。</h2><p id="3231" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">数字的模式非常容易想象！</p><ol class=""><li id="8474" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn na kv kw kx bi translated">创建一个足够宽的滑动窗口来容纳所有的数字。从右边包含每个输入的最后一位数字的窗口开始。</li><li id="7db5" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn na kv kw kx bi translated">用对角线交叉窗口中的每个数字。将所有交叉的数字相乘，并将乘积相加，生成结果中的当前数字。</li><li id="6d2b" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn na kv kw kx bi translated">将窗口向左滑动1个位置，重复上一步生成下一个数字，直到窗口不再包含任何数字。</li></ol><p id="c4f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">滑动窗口很容易用你的拇指和索引查找可视化。</p><p id="0b66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二步的好处是它的内存效率非常高，因为你只需要记录当前的计数，并一次添加一对交叉的数字到计数中。这使得通过几次练习就能很容易地在心理上表现出来。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h2 id="fd79" class="lk ll it bd lm ln lo dn lp lq lr dp ls kb lt lu lv kf lw lx ly kj lz ma mb mc bi translated">结转</h2><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ni"><img src="../Images/6f14a2df2fc69991f38e63e664671bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b9ciV9o-KTi3BGxG"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@obi_wayne?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔丹·昆斯</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="d99f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应用上述方法会失败，因为在添加交叉对之后，一些计算出的数字最终会占用1个以上的数字。因为这不可能是正确的，所以让我们只保留计算的最后一位数字，并将其余数字结转，看看会发生什么。</p><p id="12c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们用新方法乘以87 X 96 = 8352:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/522f2722502caf60feb6fc5ca7c34158.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*H578l0ZJAuXQOjmXN1PTtw.png"/></div></figure><pre class="me mf mg mh gt nk nl nm bn nn no bi"><span id="4266" class="np ll it nl b be nq nr l ns nt">tally = <strong class="nl iu">6</strong> * <strong class="nl iu">7</strong> = <strong class="nl iu">42</strong></span></pre><p id="8fb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">截掉成绩的最后一位数字，并将其余数字结转:</p><pre class="me mf mg mh gt nk nl nm bn nn no bi"><span id="c366" class="np ll it nl b be nq nr l ns nt">result = <strong class="nl iu">_ _ _ 2</strong> (<strong class="nl iu">2</strong> from <strong class="nl iu">42</strong>)<br/>carry-over = <strong class="nl iu">4</strong> (after chopping off the last digit from <strong class="nl iu">42</strong>)</span></pre><p id="a243" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向左滑动窗口生成下一个数字:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/f29c57932ab9041e54a1ee4244cfb292.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*TZNXWJOxy243qlKV-W5cPQ.png"/></div></figure><pre class="me mf mg mh gt nk nl nm bn nn no bi"><span id="f1ee" class="np ll it nl b be nq nr l ns nt">tally = <strong class="nl iu">4</strong> + <strong class="nl iu">6</strong>*<strong class="nl iu">8</strong> (carry-over + first criss-cross)<br/>      = <strong class="nl iu">4</strong> + <strong class="nl iu">48</strong><br/>      = <strong class="nl iu">52</strong><br/><br/>tally = <strong class="nl iu">52</strong> + <strong class="nl iu">9</strong>*<strong class="nl iu">7</strong> (tally + remaining criss-cross)<br/>      = <strong class="nl iu">52</strong> + <strong class="nl iu">63</strong><br/>      = <strong class="nl iu">115</strong></span></pre><p id="3c70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从计数中去掉最后一个数字作为结果中的下一个数字:</p><pre class="me mf mg mh gt nk nl nm bn nn no bi"><span id="cd55" class="np ll it nl b be nq nr l ns nt">result = <strong class="nl iu">_ _ 52</strong> (<strong class="nl iu">5</strong> from <strong class="nl iu">115</strong> in front of previous result of <strong class="nl iu">_ _ _ 2</strong>)<br/>carry-over = <strong class="nl iu">11</strong> (after chopping off the last digit from <strong class="nl iu">115</strong>)</span></pre><p id="7c1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一次向左滑动车窗:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/237d30964583fc25aba5b24902ce42f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*qKVUR9xgPJhCkGofL8Ijqg.png"/></div></figure><pre class="me mf mg mh gt nk nl nm bn nn no bi"><span id="3665" class="np ll it nl b be nq nr l ns nt">tally = <strong class="nl iu">11</strong> + <strong class="nl iu">9</strong>*<strong class="nl iu">8</strong> (carry-over + criss-cross)<br/>      = <strong class="nl iu">11</strong> + <strong class="nl iu">72</strong><br/>      = <strong class="nl iu">83</strong></span></pre><p id="b672" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们不能再向左滑动窗口，所以83的计数成为结果的剩余数字:</p><pre class="me mf mg mh gt nk nl nm bn nn no bi"><span id="eebb" class="np ll it nl b be nq nr l ns nt">result = <strong class="nl iu">8352</strong> (tally <strong class="nl iu">83</strong> in front of the previous result of <strong class="nl iu">_ _ 52</strong>)</span></pre><p id="e9f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">成功，结果符合我们的期望！</p><p id="bc9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当处理不同数量的数字时，这种方法的工作方式是相同的，因为您只需要将两个数字右对齐，并在用完数字时停止纵横交错，因为缺少的数字是零。</p><p id="9d05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在展示你的新技能之前，我建议做一些2位数的练习，一次逐渐增加一位数，因为需要一点练习来适应这种思维方式。我建议在你从右到左计算的时候写下结果的数字，因为无论如何你最终都需要给出答案，这样就少了一件需要记忆的事情。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><p id="9c74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个基于10进制的Kotlin实现:</p><pre class="me mf mg mh gt nk nl nm bn nn no bi"><span id="d741" class="np ll it nl b be nq nr l nu nt">/** <br/> * Multiplies [value1] times [value2] where these are arrays <br/> * with 1 digit per element.<br/> */<br/>fun multiply(value1: IntArray, value2: IntArray): IntArray {<br/>    val smaller: IntArray<br/>    val larger: IntArray<br/>    if (value1.size &lt; value2.size) {<br/>        smaller = value1<br/>        larger = value2<br/>    } else {<br/>        smaller = value2<br/>        larger = value1<br/>    }<br/><br/>    val result = IntArray(smaller.size + larger.size) { 0 }<br/>    var resultIndex = result.lastIndex<br/>    var carry = 0<br/><br/>    // Handle the first phase until the window no longer hangs off <br/>    // the right side<br/>    for (windowStart in larger.lastIndex downTo 1) {<br/>        var tally = carry<br/>        // criss-cross the right side of the smaller value with left side <br/>        // of the larger value<br/>        var smallerIndex = smaller.lastIndex<br/>        // Stop when no digits are left in the smaller value<br/>        // as those will all be zeros<br/>        val numStepsInCurrentWindow = min(smaller.size, larger.size - windowStart)<br/>        for (largerIndex in windowStart until windowStart + numStepsInCurrentWindow) {<br/>            tally += smaller[smallerIndex] * larger[largerIndex]<br/>            smallerIndex--<br/>        }<br/>        val (nextDigit, updatedCarry) = getNextDigitAndCarry(tally)<br/>        carry = updatedCarry<br/>        result[resultIndex] = nextDigit<br/>        resultIndex--<br/>    }<br/><br/>    // Handle the second phase where the window slides off the left side<br/>    // until no digits are left in the smaller value<br/>    for (windowEnd in smaller.lastIndex downTo 0) {<br/>        var tally = carry<br/>        var smallerIndex = windowEnd<br/>        for (largerIndex in 0..windowEnd) {<br/>            tally += smaller[smallerIndex] * larger[largerIndex]<br/>            smallerIndex--<br/>        }<br/>        val (nextDigit, updatedCarry) = getNextDigitAndCarry(tally)<br/>        carry = updatedCarry<br/>        result[resultIndex] = nextDigit<br/>        resultIndex--<br/>    }<br/><br/>    // handle the remaining carry.  An efficient implementation<br/>    // in a binary base would use a bit shift without looping here<br/>    while (carry &gt; 0) {<br/>        val (nextDigit, updatedCarry) = getNextDigitAndCarry(carry)<br/>        result[resultIndex] = nextDigit<br/>        carry = updatedCarry<br/>        resultIndex--<br/>    }<br/>    return result<br/>}<br/><br/>/**<br/> * Computes the next digit in the result along with the carry-over.<br/> *<br/> * An efficient implementation would remove this function as it <br/> * creates an object in the tight inner loops.<br/> */<br/>fun getNextDigitAndCarry(tally: Int): Pair&lt;Int, Int&gt; {<br/>    // Bit shifts would be more efficient here when dealing with a binary base<br/>    val carry = tally / 10<br/>    return Pair(tally - 10 * carry, carry)<br/>}</span></pre></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><p id="f10e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nv">如果你觉得这很有趣，你可以通过</em> <a class="ae ko" href="https://roosterdan.medium.com/membership" rel="noopener"> <em class="nv">加入媒体</em> </a> <em class="nv">获得其他上千名类似作家的全部权限。</em></p></div></div>    
</body>
</html>