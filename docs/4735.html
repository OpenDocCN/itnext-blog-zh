<html>
<head>
<title>Build EKS cluster with Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用地形构建EKS集群</h1>
<blockquote>原文：<a href="https://itnext.io/build-an-eks-cluster-with-terraform-d35db8005963?source=collection_archive---------0-----------------------#2020-09-04">https://itnext.io/build-an-eks-cluster-with-terraform-d35db8005963?source=collection_archive---------0-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6926c09b389eaa2066df3abfa6f9d333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BR9d3d-OGD0EWFXL.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://nicosingh.gitlab.io/medium-deploy-eks-cluster-using-terraform/" rel="noopener ugc nofollow" target="_blank">更新版本</a> | <a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/-/blob/master/components.py" rel="noopener ugc nofollow" target="_blank">源代码</a> |用一种叫做<a class="ae kf" href="https://diagrams.mingrammer.com/" rel="noopener ugc nofollow" target="_blank">的奇妙工具制作的图表</a></figcaption></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="427a" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kp iu">🚀2022年5月更新</strong>:鉴于我个人使用下面解释的代码的经验，以及在过去两年中收到的大量反馈，我决定将Terraform定义分为两个不同的模块:</p><ul class=""><li id="7852" class="ll lm it kp b kq kr ku kv ky ln lc lo lg lp lk lq lr ls lt bi translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/-/tree/master/base" rel="noopener ugc nofollow" target="_blank">Base</a>:AWS中<strong class="kp iu">创建</strong> VPC &amp; EKS资源的地形模块。</li><li id="866a" class="ll lm it kp b kq lu ku lv ky lw lc lx lg ly lk lq lr ls lt bi translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/-/tree/master/config" rel="noopener ugc nofollow" target="_blank">配置</a> : terraform模块，<strong class="kp iu">配置</strong>EKS集群中的Kubernetes组件(入口控制器、名称空间、点终止处理程序等)。</li></ul><p id="093d" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这一决定背后的原因是将基础设施的<em class="lz">创建</em>和<em class="lz">配置</em>拆分为“不同的项目”(将infra-as-code视为分布式单元，而不是整体)，以及避免与Terraform提供者对位于同一项目中的其他资源创建的一些模块的依赖性相关的一些问题。这种方法为将来使用新工具/平台以更灵活的方式配置基础设施提供了可能性。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h2 id="182b" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">介绍</h2><p id="a407" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">这篇文章描述了在AWS中使用Terraform和一些AWS模块创建一个多区域Kubernetes集群。具体来说，我们将使用<a class="ae kf" href="https://www.hashicorp.com/blog/infrastructure-as-code-in-a-private-or-public-cloud/" rel="noopener ugc nofollow" target="_blank">基础设施作为代码</a>来创建:</p><ul class=""><li id="e826" class="ll lm it kp b kq kr ku kv ky ln lc lo lg lp lk lq lr ls lt bi translated">新的<strong class="kp iu"> VPC </strong>具有多区域公共&amp;私有子网和单个NAT网关。</li><li id="82e2" class="ll lm it kp b kq lu ku lv ky lw lc lx lg ly lk lq lr ls lt bi translated">一个<strong class="kp iu"> Kubernetes集群</strong>，基于在私有子网中运行的Spot EC2实例，带有一个基于平均CPU使用率的自动扩展组。</li><li id="e3f6" class="ll lm it kp b kq lu ku lv ky lw lc lx lg ly lk lq lr ls lt bi translated">一个<strong class="kp iu">应用负载均衡器(ALB) </strong>来接受公共HTTP调用并将它们路由到Kubernetes节点，以及运行健康检查来扩展Kubernetes服务(如果需要的话)。</li><li id="2e29" class="ll lm it kp b kq lu ku lv ky lw lc lx lg ly lk lq lr ls lt bi translated">集群内部的一个<strong class="kp iu"> AWS负载平衡器控制器</strong>，用于接收&amp;将来自外部世界的HTTP请求转发到Kubernetes pods。</li><li id="a1eb" class="ll lm it kp b kq lu ku lv ky lw lc lx lg ly lk lq lr ls lt bi translated">带有<strong class="kp iu"> SSL证书</strong>的<strong class="kp iu"> DNS区域</strong>为每个Kubernetes服务提供HTTPS。这个区域将由一个叫做<strong class="kp iu">外部DNS </strong>的服务从Kubernetes管理。</li><li id="e993" class="ll lm it kp b kq lu ku lv ky lw lc lx lg ly lk lq lr ls lt bi translated">一个<strong class="kp iu">示例应用程序</strong>将部署到我们的集群中，使用一个小的Helm图表。</li></ul><p id="8302" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">官方Terraform模块的使用为我们带来了AWS组件编码的简单性，遵循了经验证的提供商的最佳实践(又名<em class="lz">不要重新发明轮子</em>)，如专用网络或Kubernetes集群。</p><h2 id="93aa" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">要求</h2><ul class=""><li id="71de" class="ll lm it kp b kq mt ku mu ky my lc mz lg na lk lq lr ls lt bi translated">AWS帐户，可编程访问。稍后我们将使用这些凭证来配置一些环境变量。</li><li id="fbe2" class="ll lm it kp b kq lu ku lv ky lw lc lx lg ly lk lq lr ls lt bi translated">Terraform CLI或Terraform Cloud。在本文档中，我们使用1.1.9 <em class="lz"> </em>版本，但是如果您愿意，也可以随意使用更新的版本。我的建议是使用<a class="ae kf" href="https://hub.docker.com/r/hashicorp/terraform" rel="noopener ugc nofollow" target="_blank"> docker镜像</a>或<a class="ae kf" href="https://github.com/tfutils/tfenv" rel="noopener ugc nofollow" target="_blank"> tfenv </a>，以简化特定版本的安装和使用。</li><li id="890b" class="ll lm it kp b kq lu ku lv ky lw lc lx lg ly lk lq lr ls lt bi translated">运行Terraform CLI的终端，如果使用Terraform Cloud，则为源代码管理报告。就我个人而言，我使用CI管道来实现这一点，以打破计算机运行Terraform命令的依赖性，并应用过去部署的历史记录。</li></ul><p id="e257" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">💰<strong class="kp iu">预算标注</strong>:创建EKS VPC&amp;DNS资源可能会给你的AWS月度账单带来一些成本，因为有些资源可能会超出免费等级。因此，在应用任何地形图之前，请注意这一点！。</p><h2 id="1a34" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">地形结构</h2><p id="ae76" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">在简短的介绍之后，让我们以代码的形式进入我们的基础设施！我们将看到每个步骤所需的地形配置的小片段；随意复制它们，并尝试在自己身上应用这些计划。但是，如果您对完成这项工作感到好奇或不耐烦，请查看由CI管道管理的所有Terraform配置的存储库<a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform" rel="noopener ugc nofollow" target="_blank">以应用它们。</a></p><p id="b8cb" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">Terraform的第一步是定义与版本、提供商和状态文件后端相关的Terraform配置:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/terraform.tf" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="18e9" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">✅ <strong class="kp iu">建议</strong>:在对我们的基础设施进行编码时，声明要使用的Terraform版本是一个好主意，这样可以避免在将来运行terraform时，如果我们使用较新/较旧的版本，可能会影响我们代码的任何重大更改。</p><p id="7957" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">✅ <strong class="kp iu">推荐</strong>:在运行<em class="lz"> init </em>命令的同时，资源提供者可以被Terraform自动处理。然而，使用版本号(如上所示)显式地定义它们是一个好主意，以避免未来版本引起的数据源/资源中断更改。</p><p id="3fb4" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">✅ <strong class="kp iu">推荐</strong> : AWS Terraform provider配置包括一个<em class="lz"> default_tags </em>定义，这是一个很好的选项，可以自动为AWS中创建的所有资源创建标签。这些标签不是强制性的，但是对于以有组织的方式<a class="ae kf" href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html" rel="noopener ugc nofollow" target="_blank">跟踪成本</a>是一个很好的建议。</p><p id="777a" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">✅ <strong class="kp iu">推荐</strong>:后台配置几乎是空的，那是有目的的。如果需要的话，建议将这个设置外部化到几个文件中(例如，每个环境有一个配置)。在这种情况下，我们将使用单个S3后端，每个terraform工作空间有几个状态文件:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/backend.tfvars" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="fe25" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这意味着我们将使用一个名为“我的充满活力的应用程序基础架构”的S3存储桶，看起来像这样:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="0336" class="ma mb it ni b gy nm nn l no np">s3://my-vibrant-and-nifty-app-infra/<br/>|_environment/<br/>  |_development/<br/>  | |_infra.json<br/>  |_staging/<br/>  | |_infra.json<br/>  |_production/<br/>  | |_infra.json</span></pre><p id="ed4f" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">其中每个文件夹代表一个托管Terraform远程状态文件的环境(开发、暂存和生产)。</p><p id="3b33" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">另一方面，建议<strong class="kp iu">避免</strong>在<em class="lz">提供者</em>块中定义AWS凭证。相反，我们可以为此使用环境变量，Terraform 会自动使用这些环境变量来验证AWS APIs:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="ca8d" class="ma mb it ni b gy nm nn l no np">AWS_ACCESS_KEY_ID=AKIAXXXXXXXXXXXXXXXX<br/>AWS_SECRET_ACCESS_KEY=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br/>AWS_DEFAULT_REGION=us-west-2</span></pre><p id="80fe" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">⚠️ <strong class="kp iu">重要提示</strong>:这里定义的S3桶如果在AWS中不存在，Terraform不会创建。这个bucket是通过手动操作或使用CI/CD工具运行如下命令在外部创建的:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="daba" class="ma mb it ni b gy nm nn l no np">aws s3 mb s3://my-vibrant-and-nifty-app-infra --region us-west-2</span></pre><p id="ed31" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">⚠️ <strong class="kp iu">重要提示</strong>:请记住，S3存储桶名称必须在全球范围内<strong class="kp iu">唯一</strong>，跨AWS客户和地区。运行<em class="lz"> aws s3 mb </em>命令时，以及定义<em class="lz"> backend.tfvars </em>文件时，尝试为您的bucket使用自定义名称。这就是为什么我选择了一个非常个性化的名字“我的充满活力和漂亮的应用基础设施”。</p><p id="7600" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">要初始化每个工作区，例如“development ”,我们应该运行以下命令:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="33fb" class="ma mb it ni b gy nm nn l no np">terraform init -backend-config=backend.tfvars<br/>terraform workspace new development</span></pre><p id="7ed0" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在将来的执行中，我们可以使用以下命令选择现有的工作区:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="8022" class="ma mb it ni b gy nm nn l no np">terraform init -backend-config=backend.tfvars<br/>terraform workspace select development</span></pre><p id="d3d2" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在，我们准备开始将我们的基础设施写成代码了！。</p><h1 id="2add" class="nq mb it bd mc nr ns nt mf nu nv nw mi nx ny nz ml oa ob oc mo od oe of mr og bi translated">局部模块结构</h1><p id="b69b" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">如前所述，文章中描述的所有Terraform资源都分布在单个repo中托管的两个模块中，称为<strong class="kp iu"> Base </strong>和<strong class="kp iu"> Config </strong>。它们将从根文件夹中调用，如下所示:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/main.tf" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="2440" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">模块的这种使用将通过使用<em class="lz"> module.base.cluster_id </em>作为第二个模块的输入来创建Terraform中的隐式依赖关系，第二个模块是第一个模块的输出，并且依赖于EKS集群的创建。换句话说，在Config模块中定义的所有资源都将依赖于在Base模块中创建的Kubernetes集群，而不使用令人厌烦的<a class="ae kf" href="https://www.terraform.io/language/meta-arguments/depends_on" rel="noopener ugc nofollow" target="_blank"> depends_on </a>选项。</p><p id="a72c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">上面使用的所有变量都在一个名为<a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/-/blob/master/variables.tf" rel="noopener ugc nofollow" target="_blank"> variables.tf </a>的文件中定义，该文件位于项目的根目录下。它们也在每个模块文件中定义，并将在下一节中详细解释。</p><h2 id="1b91" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">[基础模块] VPC创作</h2><p id="e2ff" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">让我们从创建一个新的VPC开始，在我们的基础设施terraform项目中使用AWS发布的<a class="ae kf" href="https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws" rel="noopener ugc nofollow" target="_blank">官方VPC terraform模块</a>,将我们的EKS相关资源隔离在一个安全的地方:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/base/network.tf" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="5b48" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">正如在前面的代码块中所评论的，我们将创建一个新的VPC，每个可用区域上有子网，有一个NAT网关以节省一些成本，添加一些EKS 要求的标签<a class="ae kf" href="https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html#vpc-subnet-tagging" rel="noopener ugc nofollow" target="_blank">。记住还要为前一个块定义一些变量值文件(例如，每个环境一个):</a></p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/base-network-development.tfvars" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="91f8" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在，我们应该准备好使用Terraform创建这个VPC资源了。如果我们已经运行了<em class="lz"> init </em>命令，我们可以使用<em class="lz"> plan </em>命令检查Terraform要创建或更新的资源:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="7b01" class="ma mb it ni b gy nm nn l no np">terraform plan -out=development.tfplan \<br/>  -var-file=base-network-development.tfvars</span></pre><p id="0545" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然后，在用户确认后，我们可以使用<em class="lz">应用</em>命令应用这些更改:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="7d77" class="ma mb it ni b gy nm nn l no np">terraform apply development.tfplan</span></pre><h2 id="198e" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">[基本模块] EKS集群</h2><p id="4273" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">下一步是使用<a class="ae kf" href="https://registry.terraform.io/modules/terraform-aws-modules/eks/aws" rel="noopener ugc nofollow" target="_blank">官方EKS Terraform模块</a>创建一个新的Kubernetes集群:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/base/eks.tf" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="5e32" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如前面的代码块所示，我们正在创建一个EKS集群，该集群使用一个针对Kubernetes的EC2自动伸缩组，该组由基于CPU平均使用率自动伸缩的Spot实例组成。</p><p id="0245" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">请记住，此Terraform配置块使用了在之前的Terraform块中定义的一些变量，因此需要将其作为新文件存储在与VPC定义文件相同的文件夹中。但是，有些变量是新的，所以我们需要在一个新文件中定义它们相应的值:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/-/blob/master/base-eks-development.tfvars" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="061c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">正如我们在上面看到的，我们正在定义两个EKS节点组(它们将在后台处理Kubernetes的EC2实例)。一个具有X86 spot实例(Intel和AMD)，一个具有按需ARM实例(<a class="ae kf" href="https://aws.amazon.com/ec2/graviton/" rel="noopener ugc nofollow" target="_blank"> Graviton </a>)。这只是因为我想这样做；<strong class="kp iu">根据您自己的基础设施要求/预算/限制，随时更改它</strong>。</p><p id="16a1" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">✅ <strong class="kp iu">建议:</strong>为了方便代码阅读和变量文件的使用，最好创建一个单独的Terraform配置文件来一次定义所有变量(例如<em class="lz"> variables.tf </em>)，然后将几个变量值文件定义为:</p><ul class=""><li id="c9fc" class="ll lm it kp b kq kr ku kv ky ln lc lo lg lp lk lq lr ls lt bi translated">一个单独的<em class="lz"> terraform.tfvars </em>文件(由terraform命令自动加载),包含所有通用变量值，没有定制值或环境特定值。</li><li id="1518" class="ll lm it kp b kq lu ku lv ky lw lc lx lg ly lk lq lr ls lt bi translated">特定环境或情况<em class="lz"> *。带有所有变量值的tfvars </em>文件，这些变量值将特定于特定情况或环境，并将在运行<em class="lz"> terraform plan </em>命令时明确使用。</li></ul><p id="b731" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然而，为了简单起见，我们将跳过这些规则，以逐步简化对AWS资源创建的每个部分的理解。这意味着我们将运行<em class="lz"> terraform plan </em>命令添加每个变量值文件，同时我们编写新的配置块:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="8265" class="ma mb it ni b gy nm nn l no np">terraform plan -out=development.tfplan \<br/>  -var-file=base-network-development.tfvars \<br/>  -var-file=base-eks-development.tfvars</span><span id="8663" class="ma mb it ni b gy oh nn l no np">terraform apply development.tfplan</span></pre><p id="5258" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">一旦计划得以实施，我们在AWS中就有了一个全新的EKS集群！让我们继续这个Kubernetes集群的配置，使用另一个Terraform模块。</p><h2 id="04b3" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">[配置模块] EKS集群</h2><p id="c342" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">由于我们现在处于另一个Terraform模块中，并且EKS集群已经存在，我们将不得不使用数据源来获取它们的数据。让我们做这件事和其他一些东西:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/config/eks.tf" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="0e3e" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如你所见，我们在这里:</p><ul class=""><li id="0b6b" class="ll lm it kp b kq kr ku kv ky ln lc lo lg lp lk lq lr ls lt bi translated">获取我们现有的EKS集群作为数据源，以便配置Kubernetes &amp; Helm Terraform提供商。</li><li id="5f8b" class="ll lm it kp b kq lu ku lv ky lw lc lx lg ly lk lq lr ls lt bi translated">为<a class="ae kf" href="https://github.com/aws/aws-node-termination-handler" rel="noopener ugc nofollow" target="_blank"> EC2 Kubernetes Spot终止处理程序</a>部署一个舵图，当Spot实例被AWS自动终止时，它负责重新分配Kubernetes对象。</li></ul><p id="0ea4" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">使用两件事所需的变量:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/config-eks-development.tfvars" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="6e19" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以像往常一样规划和应用:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="2833" class="ma mb it ni b gy nm nn l no np">terraform plan -out=development.tfplan \<br/>  -var-file=base-network-development.tfvars \<br/>  -var-file=base-eks-development.tfvars \<br/>  -var-file=config-eks-development.tfvars</span><span id="733d" class="ma mb it ni b gy oh nn l no np">terraform apply development.tfplan</span></pre><p id="0e58" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">Terraform将负责为我们运行“头盔安装”命令。</p><h2 id="0eaa" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">[配置模块] IAM访问</h2><p id="9aab" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">下一步是配置AWS用户进入EKS集群所需的任何访问权限。为此，我们将使用aws-auth ConfigMap:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/config/iam.tf" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="ac05" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果我们仔细阅读aws-auth <a class="ae kf" href="https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html" rel="noopener ugc nofollow" target="_blank">文档</a>，我们还需要在我们的Kubernetes集群中配置RBAC访问。这就是为什么我们为我们的开发人员用户创建一个ClusterRoleBinding对象，自定义对Kubernetes pods的<em class="lz"> get </em>和<em class="lz"> port-forward </em>访问。</p><p id="b73b" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这些资源的变量文件如下所示:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/config-iam-development.tfvars" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="c321" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">⚠️ <strong class="kp iu">注意</strong>:上面显示的用户id是虚构的，当然它们必须根据你的AWS账户中的用户组进行定制。请记住，这些用户名<strong class="kp iu"> do </strong> <strong class="kp iu"> not </strong>在创建EKS集群或分配RBAC访问权限时必须作为AWS IAM身份存在，因为它们将只存在于Kubernetes集群中。IAM/Kubernetes用户名关联由AWS CLI在<a class="ae kf" href="https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html#create-kubeconfig-automatically" rel="noopener ugc nofollow" target="_blank">向EKS集群</a>进行身份验证时处理。</p><p id="ac40" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了计划和应用这些定义，我们应该像这样运行:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="d9b0" class="ma mb it ni b gy nm nn l no np">terraform plan -out=development.tfplan \<br/>  -var-file=base-network-development.tfvars \<br/>  -var-file=base-eks-development.tfvars \<br/>  -var-file=config-eks-development.tfvars \<br/>  -var-file=config-iam-development.tfvars</span><span id="5213" class="ma mb it ni b gy oh nn l no np">terraform apply development.tfplan</span></pre><h2 id="ac83" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">[配置模块]负载平衡器</h2><p id="1e89" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">现在我们可以继续创建一个应用程序负载平衡器(ALB ),来处理对我们服务的HTTP请求。ALB的创建将由<a class="ae kf" href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest" rel="noopener ugc nofollow" target="_blank"> AWS负载平衡器控制器</a>服务负责，该服务将使用Helm:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/config/ingress.tf" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="bb93" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">正如你在上面看到的，入口定义使用了一个新的AWS颁发的SSL证书来提供我们的ALB中的HTTPS，该证书将放在我们的Kubernetes pods前面，并且还定义了一些<a class="ae kf" href="https://github.com/aws/eks-charts/tree/master/stable/aws-load-balancer-controller#installing-the-chart" rel="noopener ugc nofollow" target="_blank">负载平衡器控制器</a>所需的注释。</p><p id="f6b1" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这个舵图<strong class="kp iu">安装的Kubernetes服务不会</strong>在AWS中创建任何ALBs或DNS记录。一旦在Kubernetes中使用所需的注释创建了新的入口对象，这些资源将分别由负载平衡器控制器和外部DNS服务创建。我们将在文章的最后深入讨论这些注释。</p><p id="38e7" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在创建EKS群集期间，管理ALBs和Route53记录所需的IAM权限已经授予LB控制器和外部DNS服务。</p><p id="39f9" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">⚠️ <strong class="kp iu">注意</strong>:此处显示的terraform项目重复使用了在此Terraform工作空间之外创建的DNS区域(在“dns_base_domain”变量中定义)。这就是为什么我们使用<em class="lz">数据源</em>来获取现有的Route53区域，而不是创建新的<em class="lz">资源</em>的原因。如果需要，请随意更改，如果您还没有DNS资源，请创建新的DNS资源。</p><p id="8673" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">和其他Terraform配置文件一样，这个文件也使用了一些新的变量。因此，让我们为我们的“开发”环境定义它们:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/config-ingress-development.tfvars" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="2fdd" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然后运行<em class="lz">地形图</em> &amp; <em class="lz">应用</em>:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="af93" class="ma mb it ni b gy nm nn l no np">terraform plan -out=development.tfplan \<br/>  -var-file=base-network-development.tfvars \<br/>  -var-file=base-eks-development.tfvars \<br/>  -var-file=config-eks-development.tfvars \<br/>  -var-file=config-iam-development.tfvars \<br/>  -var-file=config-ingress-development.tfvars</span><span id="de13" class="ma mb it ni b gy oh nn l no np">terraform apply development.tfplan</span></pre><h2 id="52e9" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">[配置模块]外部DNS</h2><p id="3ccd" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">下一步是部署<a class="ae kf" href="https://github.com/kubernetes-sigs/external-dns" rel="noopener ugc nofollow" target="_blank"> ExternalDNS </a>服务，它将负责管理Kubernetes中每个入口定义所请求的Route53记录:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/config/external-dns.tf" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="2d07" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">正如我们在上面看到的，external-dns Helm图表需要一些与新生成的ACM证书相关的注释来提供SSL连接，还需要Route53基域来创建/修改/删除Kubernetes中的记录。</p><p id="27eb" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">terraform定义需要一些其他变量来设置日志级别和同步频率:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/config-external-dns-development.tfvars" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="7a47" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在用户确认后，将按如下方式应用:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="5a9c" class="ma mb it ni b gy nm nn l no np">terraform plan -out=development.tfplan \<br/>  -var-file=base-network-development.tfvars \<br/>  -var-file=base-eks-development.tfvars \<br/>  -var-file=config-eks-development.tfvars \<br/>  -var-file=config-iam-development.tfvars \<br/>  -var-file=config-ingress-development.tfvars \<br/>  -var-file=config-external-dns-development.tfvars</span><span id="012e" class="ma mb it ni b gy oh nn l no np">terraform apply development.tfplan</span></pre><h2 id="324b" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">[配置模块] Kubernetes名称空间</h2><p id="c599" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">最后一步——实际上不是强制性的，但建议这样做——是定义一些Kubernetes名称空间来分隔我们的部署，并在我们的集群中实现更好的应用程序管理和可见性:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/config/namespaces.tf" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="9f0b" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这个配置文件期望在我们的EKS集群中创建一个名称空间列表:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform/blob/master/config-namespaces-development.tfvars" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="ff18" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这可以应用为:</p><pre class="nb nc nd ne gt nh ni nj nk aw nl bi"><span id="aa27" class="ma mb it ni b gy nm nn l no np">terraform plan -out=development.tfplan \<br/>  -var-file=base-network-development.tfvars \<br/>  -var-file=base-eks-development.tfvars \<br/>  -var-file=config-eks-development.tfvars \<br/>  -var-file=config-iam-development.tfvars \<br/>  -var-file=config-ingress-development.tfvars \<br/>  -var-file=config-external-dns-development.tfvars \<br/>  -var-file=config-namespaces-development.tfvars</span><span id="0b90" class="ma mb it ni b gy oh nn l no np">terraform apply development.tfplan</span></pre><p id="1045" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">就是这样！我们终于有了一个生产就绪的EKS集群，可以通过公共IP访问来托管应用程序🎉。记得访问下面的<a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform-infra" rel="noopener ugc nofollow" target="_blank"/>&amp;<a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform-config" rel="noopener ugc nofollow" target="_blank">Config</a>库，全面了解所有这些Terraform配置，以及在AWS中应用它们的示例CI管道。</p><h2 id="27c3" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">[奖励]示例应用程序部署</h2><p id="2fb7" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">作为奖励，我将为<a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform-sample-app" rel="noopener ugc nofollow" target="_blank">留下一个样例应用程序</a>的链接，它基于这个<a class="ae kf" href="https://github.com/nginxinc/NGINX-Demos/tree/master/nginx-hello" rel="noopener ugc nofollow" target="_blank"> docker映像</a>，使用Helm将一个非常小的容器部署到我们新的Kubernetes集群中。它还包含一些CI作业，可以帮助您熟悉<em class="lz"> aws eks </em>和<em class="lz"> helm </em>命令。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/3a3dc151b1ecbbf97adfeb179d940076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7W7s4F4Bh6iC4Yy-FNqwxQ.png"/></div></div></figure><p id="0410" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如前所述，每个应用程序内部的入口对象拥有创建ALB和管理Route53记录的魔力:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://gitlab.com/nicosingh/medium-deploy-eks-cluster-using-terraform-sample-app/blob/master/helm/templates/ingress.yaml" rel="noopener ugc nofollow" target="_blank">源代码</a></figcaption></figure><p id="bc88" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">以<em class="lz">Alb . ingress . kubernetes . io</em>开头的注释负责通过LB控制器(<a class="ae kf" href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/ingress/annotations/" rel="noopener ugc nofollow" target="_blank">引用</a>)管理AWS中的alb，以<em class="lz">external-DNSαkubernetes . io</em>开头的注释负责通过ExternalDNS ( <a class="ae kf" href="https://github.com/kubernetes-sigs/external-dns/blob/master/docs/tutorials/aws.md#verify-externaldns-works-service-example" rel="noopener ugc nofollow" target="_blank">引用</a>)管理Route53记录。</p><h2 id="95da" class="ma mb it bd mc md me dn mf mg mh dp mi ky mj mk ml lc mm mn mo lg mp mq mr ms bi translated">包扎</h2><p id="57f3" class="pw-post-body-paragraph kn ko it kp b kq mt ks kt ku mu kw kx ky mv la lb lc mw le lf lg mx li lj lk im bi translated">暂时就这样吧！我希望这个页面能够帮助您理解AWS中基本Kubernetes集群背后的一些关键概念，并掌握一些关于Terraform配置文件的良好实践。</p><p id="83ca" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我真的很感激任何类型的反馈，问题或评论。在这里随意ping我<a class="ae kf" href="https://nico.singh.cl" rel="noopener ugc nofollow" target="_blank">，或者在这个帖子里发表任何评论。</a></p><div class="oj ok gp gr ol om"><a href="https://github.com/sponsors/nicosingh" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">GitHub赞助商上的赞助商@nicosingh</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">非常感谢你的支持😊我感谢你对做开源软件和分享知识的认可…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa jz om"/></div></div></a></div></div></div>    
</body>
</html>