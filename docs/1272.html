<html>
<head>
<title>From Scala app to Kubernetes, part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Scala应用到Kubernetes，第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/more-kubernetes-goodness-for-scala-apps-ff6d9f507140?source=collection_archive---------0-----------------------#2018-08-26">https://itnext.io/more-kubernetes-goodness-for-scala-apps-ff6d9f507140?source=collection_archive---------0-----------------------#2018-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="20ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的副业<a class="ae kl" href="http://ticofab.io/Caterina-side-project/" rel="noopener ugc nofollow" target="_blank"> Caterina </a>是关于(试图)将一种加密货币的具体事件与其价格波动联系起来。事实上，这更像是一个借口，从A到Z运行一个项目，同时<a class="ae kl" href="https://medium.com/@ticofab/doing-things-the-proper-way-b085068cba71" rel="noopener">学习东西</a>。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="5190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都在云端运行，这是我的一个主要学习点。这篇文章和<a class="ae kl" href="https://medium.com/@ticofab/from-scala-app-to-kubernetes-pod-d67e0cd6bfaf" rel="noopener">上一篇</a>是关于我如何把我的JVM服务从我舒适的本地环境带到云和更远的地方。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/4f947c7015d0c7a554829218023331df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9YaaOEA4rvHR0yuB673sA.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">攀登通往天堂的阶梯，版权所有</figcaption></figure><h2 id="68e5" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">将pod生命周期委托给控制器</h2><p id="873d" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我首先将服务作为单个Pod运行，这是Kubernetes上下文中的基本执行单元。但是，<a class="ae kl" href="https://cloud.google.com/kubernetes-engine/docs/concepts/pod" rel="noopener ugc nofollow" target="_blank">这不是推荐的方式</a>。相反，我们应该将Pod的生命周期委托给控制器，比如部署。控制器管理pod的生命周期，这意味着他们可以在崩溃时重新启动它，或者旋转同一pod的多个实例以实现水平扩展。我们只需要稍微修改一下我们的yaml文件:</p><pre class="ku kv kw kx gt mh mi mj mk aw ml bi"><span id="c132" class="lj lk iq mi b gy mm mn l mo mp">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: my-service<br/>spec:<br/>  selector:<br/>    matchLabels: <br/>      app: my-service-pod     // &lt;- which pod? (see metadata below)<br/>  replicas: 1                 // &lt;- only one instance of this pod <br/>  template:<br/>    metadata:<br/>      name: my-service<br/>      labels:<br/>        app: my-service-pod<br/>    spec:<br/>      containers:<br/>      - image: eu.gcr.io/my-project-id/my-app:latest<br/>        name: my-app-image<br/>        env:<br/>        - name: MY_ENV_VARIABLE<br/>          value: the_value_of_my_env_variable</span></pre><p id="01e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道——有点冗长。有一些工具添加了额外的抽象层，为yaml文件提供模板，以减少复制/粘贴和样板文件。最受欢迎的是<a class="ae kl" href="https://helm.sh" rel="noopener ugc nofollow" target="_blank">赫尔姆</a>。我的边项目只有<a class="ae kl" href="https://medium.com/@ticofab/from-event-storming-to-architecture-c2dc49e9c2d0" rel="noopener">两个服务</a>，所以<a class="ae kl" href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)" rel="noopener ugc nofollow" target="_blank">我用基本yaml文件</a>就可以了。</p><p id="df13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查我们集群的状态现在也需要查看部署:</p><pre class="ku kv kw kx gt mh mi mj mk aw ml bi"><span id="2a23" class="lj lk iq mi b gy mm mn l mo mp">kubectl get pods,deployment</span></pre><p id="f7be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将向我们展示，我们确实有一个运行一个单元的部署:</p><pre class="ku kv kw kx gt mh mi mj mk aw ml bi"><span id="648f" class="lj lk iq mi b gy mm mn l mo mp">NAME                            READY     STATUS    RESTARTS   AGE<br/>pod/my-service-pod-85f8-ctcdq   1/1       Running   0          10m</span><span id="4c38" class="lj lk iq mi b gy mq mn l mo mp">NAME                    DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE<br/>deployment/my-service   1        1        1           1          10m</span></pre><p id="90a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们的pod的名称带有一个惟一的字符串(<code class="fe mr ms mt mi b">85f8-ctcdq</code>)，它是由控制器添加的。我们只要求一个实例(在<code class="fe mr ms mt mi b">replicas: 1</code>中)，但可能有更多，随机字符串确保每个实例都有唯一的名称。</p><p id="c795" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果pod由于任何原因(例如您没有管理的内部故障)而终止，控制器将检测它的过早消失并启动一个新的实例。相当狡猾。</p><h2 id="ba0e" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">在Kubernetes的秘密中保护您的敏感数据</h2><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mu"><img src="../Images/3a868a52db2595f575e685d4e7d226b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEleHxYsd6oVW9q-nX-b-w.jpeg"/></div></div></figure><p id="b119" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes提供“秘密服务”。您可以将密码或API密钥嵌入到Kubernetes会为您安全存储的一个<a class="ae kl" href="http://kubernetesbyexample.com/secrets/" rel="noopener ugc nofollow" target="_blank"> Secret </a>对象中，而不是将它们写在yaml文件中。然后，您可以将机密数据作为公开的环境变量或装入卷中的文件来访问。</p><p id="1fea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的yaml文件中，我们有一个环境变量:</p><pre class="ku kv kw kx gt mh mi mj mk aw ml bi"><span id="17a9" class="lj lk iq mi b gy mm mn l mo mp">env:<br/>  - name: MY_ENV_VARIABLE<br/>    value: the_value_of_my_env_variable</span></pre><p id="932d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用它创建一个秘密对象是通过<code class="fe mr ms mt mi b">kubectl</code>完成的。我可以创建一个名为<code class="fe mr ms mt mi b">my_env_var</code>的文件，其中包含<code class="fe mr ms mt mi b">the_value_of_my_env_variable</code>。命令</p><pre class="ku kv kw kx gt mh mi mj mk aw ml bi"><span id="a386" class="lj lk iq mi b gy mm mn l mo mp">kubectl create secret generic my-env-secret --from-file=./my_env_var</span></pre><p id="64cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个名为<code class="fe mr ms mt mi b">my-env-secret</code>的键-值秘密，其中键<code class="fe mr ms mt mi b">my_env_var</code>指向值<code class="fe mr ms mt mi b">the_value_of_my_env_variable</code>。我们现在可以将环境变量inclusion重新连接为:</p><pre class="ku kv kw kx gt mh mi mj mk aw ml bi"><span id="4d77" class="lj lk iq mi b gy mm mn l mo mp">env:<br/>  - name: MY_ENV_VARIABLE<br/>    valueFrom:<br/>      secretKeyRef:<br/>        name: my-env-secret<br/>        key: my_env_var</span></pre><p id="fcf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像之前一样，我们的服务将看到一个名为<code class="fe mr ms mt mi b">MY_ENV_VARIABLE</code>和值为<code class="fe mr ms mt mi b">the_value_of_my_env_variable</code>的环境变量。</p><p id="f594" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在挂载卷上以文件形式访问机密有一个基本情况:存储凭证以从pod内部访问其他Google云服务。程序略有不同，在此以<a class="ae kl" href="https://cloud.google.com/kubernetes-engine/docs/tutorials/authenticating-to-cloud-platform" rel="noopener ugc nofollow" target="_blank">为例</a>进行说明。</p><h2 id="ea57" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">记录</h2><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mv"><img src="../Images/7381c9dd30bdb7712e9eb6c2fc220daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pdVL1jAFFHBGC3mkxI9LPg.jpeg"/></div></div></figure><p id="a357" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过<code class="fe mr ms mt mi b">kubectl logs</code>从您的容器中访问日志，但是这不会被持久化。使用谷歌的云日志监控资源<a class="ae kl" href="https://cloud.google.com/stackdriver/" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>要好得多。事实上，它在所有新创建的Kubernetes集群中都是默认启用的。</p><p id="b205" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我唯一悬而未决的问题是日志的严重性。我使用的是<a class="ae kl" href="https://github.com/wvlet/airframe/tree/master/airframe-log" rel="noopener ugc nofollow" target="_blank">机身日志</a>，一个Scala的轻量级日志记录器。出于某种原因，所有日志都作为错误出现在Stackdriver中。这显然很烦人，一旦我找到解决办法，我会尽快更新这个帖子。</p><p id="29b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新</strong>:解决了！我显然没有看过文件。我将日志格式切换到Airframe <code class="fe mr ms mt mi b">BareFormatter</code>(简单地按原样记录字符串)，并添加了一个<code class="fe mr ms mt mi b">severity</code>字段。典型的日志现在看起来像这样</p><pre class="ku kv kw kx gt mh mi mj mk aw ml bi"><span id="41b2" class="lj lk iq mi b gy mm mn l mo mp">{ "msg" : "....", "severity" : "INFO" }</span></pre><p id="90f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Stackdriver现在从这个有效载荷中剥离出<code class="fe mr ms mt mi b">severity</code>部分，并相应地标记它的消息——它包含了另一个丰富的信息。</p><h2 id="d29d" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">连续交货？</h2><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mw"><img src="../Images/7d4f6b91572b1f0fbce0fee4826aad6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNPIz8laDemjcDF7-Yp6GQ.jpeg"/></div></div></figure><p id="7214" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的Caterina项目的<a class="ae kl" href="https://medium.com/@ticofab/from-event-storming-to-architecture-c2dc49e9c2d0" rel="noopener">架构概述</a>中，我提到我选择BitBucket作为云版本控制提供商，因为我很想尝试他们的流水线特性。实际上，我在BitBucket上托管了我的回购，我对管道做了一点小小的尝试，但最终选择了<em class="mx">而不是</em>进行任何连续交付设置。</p><p id="d371" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个决定是在注意到设置这一切的工作量之后做出的。当我想要部署服务的新版本时，我需要:</p><ul class=""><li id="0700" class="my mz iq jp b jq jr ju jv jy na kc nb kg nc kk nd ne nf ng bi translated">构建docker图像(<code class="fe mr ms mt mi b">sbt docker:publishLocal</code>)</li><li id="e088" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">上传到Google容器注册表(<code class="fe mr ms mt mi b">docker push --[SERVICE]:latest</code>)</li><li id="7988" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">停止当前正在运行的部署(<code class="fe mr ms mt mi b">kubectl delete -f all.yaml</code></li><li id="ff62" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">告诉Kubernetes重新开始部署(<code class="fe mr ms mt mi b">kubectl apply -f all.yaml</code></li></ul><p id="8863" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做的缺点是，为了进行部署，我需要在我的机器上安装所有的东西。但是要从管道系统进行构建和部署，我需要安排云凭证、安装SBT和下载依赖项，这意味着我应该把我的公共库放在某个可用的地方(比如<a class="ae kl" href="https://jfrog.com/artifactory/" rel="noopener ugc nofollow" target="_blank"> JFrog artifactory </a>)。总的来说，这将是额外的工作和成本，我不能完全证明。</p><p id="40dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我只是一个有两个服务的单身男人，一个<em class="mx"> shell脚本</em>看起来更快。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="b78b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的云之旅还远未结束，但我已经学到了很多。最有收获的是随之而来的赋权。下一步:巩固管道，让它运行一段时间。然后我的数据地盘就可以玩了！</p><div class="nm nn gp gr no np"><a href="https://medium.com/@ticofab" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">法比奥·特里蒂奇科-中等</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">技术领导和社区人员。寻找一个DevRel角色！</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ld np"/></div></div></a></div></div></div>    
</body>
</html>