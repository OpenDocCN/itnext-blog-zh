<html>
<head>
<title>13 Handy RxJS Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">13个方便的RxJS运算符</h1>
<blockquote>原文：<a href="https://itnext.io/13-handy-rxjs-operators-ab5a9a1db60?source=collection_archive---------4-----------------------#2021-03-16">https://itnext.io/13-handy-rxjs-operators-ab5a9a1db60?source=collection_archive---------4-----------------------#2021-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="36ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理数组和元组</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40b665f0b71fdbea27e91d1a659990db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5xvZ3JcJj6eptS7-LTvD8g.png"/></div></div></figure><p id="9d8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像<code class="fe lq lr ls lt b">map</code>、<code class="fe lq lr ls lt b">flatMap</code>和<code class="fe lq lr ls lt b">reduce</code>这样的流操作符是Rx实现如此强大的主要原因。在这方面，RxJS做得很好，将操作符从可观察类中分离出来，允许社区创建自己的操作符并单独发布。</p><p id="784b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将从NPM包<code class="fe lq lr ls lt b"><a class="ae lu" href="https://www.npmjs.com/package/@rxjsx/rxjsx" rel="noopener ugc nofollow" target="_blank">@rxjsx/rxjsx</a></code>中引入13个RxJS操作符来处理数组和元组。有关运营商的完整列表以及更多详细信息，请参考<a class="ae lu" href="https://github.com/rxjsx/rxjsx" rel="noopener ugc nofollow" target="_blank"> Github报告</a>。</p><h1 id="ad8f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">TL；速度三角形定位法(dead reckoning)</h1><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="7be2" class="mr lw it lt b gy ms mt l mu mv">npm install --save rxjs @rxjsx/rxjsx</span></pre><h1 id="76b2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目录</h1><ul class=""><li id="6402" class="mw mx it kw b kx my la mz ld na lh nb ll nc lp nd ne nf ng bi translated"><a class="ae lu" href="#3685" rel="noopener ugc nofollow">背景</a></li><li id="9d25" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#62ca" rel="noopener ugc nofollow">沙盒</a></li><li id="49ba" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#0dfd" rel="noopener ugc nofollow"> 5基础知识:到元组和返回</a></li><li id="bfbb" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#393c" rel="noopener ugc nofollow"> 4个坐标运算符</a></li><li id="ddd3" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#8dc0" rel="noopener ugc nofollow"> 4列表操作符</a></li><li id="ab08" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#26de" rel="noopener ugc nofollow">结论</a></li></ul><h1 id="87fc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">操作员列表</h1><ul class=""><li id="fed1" class="mw mx it kw b kx my la mz ld na lh nb ll nc lp nd ne nf ng bi translated"><a class="ae lu" href="#7384" rel="noopener ugc nofollow">邮政编码图</a></li><li id="bb36" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#4033" rel="noopener ugc nofollow"> flatZipMap </a></li><li id="2812" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#c547" rel="noopener ugc nofollow"> projectToFormer </a></li><li id="6799" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#af09" rel="noopener ugc nofollow">project to later</a></li><li id="7ce3" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#14f9" rel="noopener ugc nofollow">项目到</a></li><li id="57d2" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#d56c" rel="noopener ugc nofollow">地图形成器</a></li><li id="6878" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#a897" rel="noopener ugc nofollow">地图绘制者</a></li><li id="94ad" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#fc64" rel="noopener ugc nofollow">平台映射器</a></li><li id="dddc" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#69e2" rel="noopener ugc nofollow">平台映射器</a></li><li id="5494" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#5b58" rel="noopener ugc nofollow">列表映射</a></li><li id="ea43" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#b27a" rel="noopener ugc nofollow">平面列表图</a></li><li id="300b" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#2314" rel="noopener ugc nofollow">列表平面图</a></li><li id="cf48" class="mw mx it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><a class="ae lu" href="#ee69" rel="noopener ugc nofollow"> flatListFlatMap </a></li></ul></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="3685" class="lv lw it bd lx ly nt ma mb mc nu me mf jz nv ka mh kc nw kd mj kf nx kg ml mm bi translated">背景</h1><p id="d061" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">在RxJava中，流操作符是可观察类的成员。例如，查看RxJava的<code class="fe lq lr ls lt b"><a class="ae lu" href="https://raw.githubusercontent.com/ReactiveX/RxJava/3.x/src/main/java/io/reactivex/rxjava3/core/Flowable.java" rel="noopener ugc nofollow" target="_blank">Flowable</a></code>类(flowable基本上是RxJava中observable类的重新实现)。这个类很大(大约20K行代码),因为所有的操作符都是它的成员。</p><p id="a0f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RxJS在这里有很大的设计优势。运算符是分开的，并作为函数传递给可观察对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="ed69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，<code class="fe lq lr ls lt b">Observable</code>类实现的唯一东西是<code class="fe lq lr ls lt b">pipe</code>函数，这使得整个<code class="fe lq lr ls lt b"><a class="ae lu" href="https://github.com/ReactiveX/rxjs/blob/master/src/internal/Observable.ts" rel="noopener ugc nofollow" target="_blank">Observable</a></code>类有大约500行代码。这允许用户创建自己的操作员。举以下例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oc l"/></div></figure><p id="882a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">阅读代码的人需要一段时间才能意识到<code class="fe lq lr ls lt b">reduce</code>在做什么。将此代码与以下代码进行比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oc l"/></div></figure><p id="3df5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码看起来更高级。运算符的顶级用法没有太多不必要的细节。或者如罗伯特·c·马丁所说，代码不那么粗鲁。</p><p id="16bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">人们可以定义一堆这样的操作符，并把它们打包成一个NPM包。RxJS扩展<code class="fe lq lr ls lt b">@rxjsx/rxjsx</code>就是这种情况。</p><p id="bbd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将介绍这个库中的13个操作符，它们在处理数组和元组时非常方便。</p><h1 id="62ca" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">沙箱</h1><p id="b5c6" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">下面是一个沙盒环境，用于测试我们将要介绍的操作符。<code class="fe lq lr ls lt b">rxjs</code>和<code class="fe lq lr ls lt b">@rxjsx/rxjsx</code>都已经安装。您可以随意更改代码，并对您将要学习的每个操作符进行试验。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe oc l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">一个小沙盒环境，可以和操作者一起玩。请随意弄脏你的手。</figcaption></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="0dfd" class="lv lw it bd lx ly nt ma mb mc nu me mf jz nv ka mh kc nw kd mj kf nx kg ml mm bi translated">5个基础:到元组和返回</h1><p id="cc4c" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">与许多语言不同(以Python或Scala为例)，JavaScript中的元组基本上是数组。主要原因是没有对数组的所有元素强制类型。</p><p id="74c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在TypeScript中，可以将<code class="fe lq lr ls lt b">[T1, T2]</code>的类型强加给一个变量，使其成为一个2元组。例如，您不能将类型为<code class="fe lq lr ls lt b">string[]</code>的值赋给类型为<code class="fe lq lr ls lt b">[string, string]</code>的变量。</p><p id="546f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只是因为元组是从数组中分离出来的，所以没有得到足够的重视。RxJS也是如此，它没有对元组流的直接支持。RxJSx提供了对元组的支持。</p><p id="6eaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是在元组和值之间来回移动的运算符。运算符<code class="fe lq lr ls lt b">zipMap</code>和<code class="fe lq lr ls lt b">flatZipMap</code>基本上是注入运算符(值到元组)，而<code class="fe lq lr ls lt b">projectToFormer</code>、<code class="fe lq lr ls lt b">projectToLatter</code>、<code class="fe lq lr ls lt b">projectTo</code>是投影运算符(元组到值)。在这5个中，前4个用于2-元组。</p><h2 id="7384" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">zipMap</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/49970dfe9d16019a98686c24466af616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9k0RcydeQGFirSuL8yyTA.png"/></div></figure><p id="15e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当希望转换一个值，但又希望保留原始值以供以后访问时，这很有用:</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="168b" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { zipMap } from '@rxjsx/rxjsx';</span><span id="1f50" class="mr lw it lt b gy ov mt l mu mv">of(1, 2, 3)<br/>  .pipe(<strong class="lt iu">zipMap</strong>(x =&gt; `${x}`))<br/>  .subscribe(([x, s]) =&gt; console.log(x, s));</span></pre><p id="7637" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代替下面的代码或类似的解决方案来存储可观察的原始值:</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="91be" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { map, tap } from 'rxjs/operators';</span><span id="32bd" class="mr lw it lt b gy ov mt l mu mv">let nummericalVal: number;</span><span id="797b" class="mr lw it lt b gy ov mt l mu mv">of(1, 2, 3)<br/>  .pipe(tap(x =&gt; nummericalVal = x))<br/>  .pipe(map(x =&gt; `${x}`))<br/>  .subscribe(s =&gt; console.log(nummericalVal, s));</span></pre><p id="8243" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/keeping-original-value-when-transforming-in-rxjs-f4650e12c4cf">本文</a>关注这个用例:“在RxJS中转换时保持原始值”。</p><h2 id="4033" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">flatZipMap</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/232755a9287b6b6e8b7e9071aca6a2be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*7OAP1qn6wN2pnvZhLrD5bQ.png"/></div></figure><p id="0879" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似于<code class="fe lq lr ls lt b">zipMap</code>，当转换返回一个可观察值时使用。</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="395f" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { flatZipMap } from '@rxjsx/rxjsx';</span><span id="6f09" class="mr lw it lt b gy ov mt l mu mv">of(1, 2, 3)<br/>  .pipe(<strong class="lt iu">flatZipMap</strong>(x =&gt; of(`${x}`)))<br/>  .subscribe(([x, s]) =&gt; console.log(x, s));</span></pre><h2 id="c547" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">projectToFormer</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/9217a10edfe2cd8a3a5a110eb66d80d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1_5MH8tPno1WHQB9coLHw.png"/></div></figure><p id="2add" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将一个对的可观测值，即<code class="fe lq lr ls lt b">Observable&lt;[T1, T2]&gt;</code>投影到第一个坐标，得到一个<code class="fe lq lr ls lt b">Observable&lt;T1&gt;</code>。</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="1de5" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { projectToFormer } from '@rxjsx/rxjsx';</span><span id="4d25" class="mr lw it lt b gy ov mt l mu mv">of&lt;[number, string]&gt;([1, '1'], [2, '2'])<br/>  .pipe(<strong class="lt iu">projectToFormer</strong>())<br/>  .subscribe((n: number) =&gt; console.log(n));</span></pre><h2 id="af09" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">projectToLatter</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/1441a9daa1228620165cddf9e7cdbf49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oyUhz7FyyTo09FMBwnIUaQ.png"/></div></figure><p id="c818" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将一个可观察的对，即<code class="fe lq lr ls lt b">Observable&lt;[T1, T2]&gt;</code>投影到第二个坐标，得到一个<code class="fe lq lr ls lt b">Observable&lt;T2&gt;</code>。</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="e13c" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { projectToLatter } from '@rxjsx/rxjsx';</span><span id="9128" class="mr lw it lt b gy ov mt l mu mv">of&lt;[number, string]&gt;([1, '1'], [2, '2'])<br/>  .pipe(<strong class="lt iu">projectToLatter</strong>())<br/>  .subscribe((s: string) =&gt; console.log(s));</span></pre><h2 id="14f9" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">projectTo</h2><p id="41e9" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">将元组的一个可观察值，即<code class="fe lq lr ls lt b">Observable&lt;T[]&gt;</code>，投影到一个自定义坐标上，得到一个<code class="fe lq lr ls lt b">Observable&lt;T&gt;</code>。</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="c7b6" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { projectTo } from '@rxjsx/rxjsx';</span><span id="920e" class="mr lw it lt b gy ov mt l mu mv">of([1, 2, 3], [4, 5, 6])<br/>  .pipe(<strong class="lt iu">projectTo</strong>(1)) // of(2, 5)<br/>  .subscribe(console.log);</span></pre><h1 id="393c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4个坐标运算符</h1><p id="ace5" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">当处理元组流时，在其中一个坐标上进行转换通常是非常麻烦的。如果转换返回一个可观测的自身，它将变得极其肮脏。坐标操作符就是用来解决这些问题的。</p><h2 id="d56c" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">地图形成器</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/3394a159cc9dba75d75df0738df47fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hc842y8PQsVztIG52pmfg.png"/></div></figure><p id="efda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">转换成对可观察的第一个坐标。</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="e30f" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { mapFormer } from '@rxjsx/rxjsx';</span><span id="bdf2" class="mr lw it lt b gy ov mt l mu mv">of&lt;[number, string]&gt;([1, '1'], [2, '2'])<br/>  .pipe(<strong class="lt iu">mapFormer</strong>(x =&gt; x * 2)) // [2, '1'], [4, '2']<br/>  .subscribe(console.log);</span></pre><h2 id="a897" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">mapLatter</h2><p id="1576" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">转换成对可观察的第二个坐标。</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="5ad8" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { mapLatter } from '@rxjsx/rxjsx';</span><span id="d5bb" class="mr lw it lt b gy ov mt l mu mv">of&lt;[number, string]&gt;([1, '1'], [2, '2'])<br/>  .pipe(<strong class="lt iu">mapLatter</strong>(y =&gt; `${y}+${y}`)) // [1, '1+1'], [2, '2+2']<br/>  .subscribe(console.log);</span></pre><h2 id="fc64" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">平面地图形成器</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/3ed6f9d3bd3c23409a7daa01f28e578c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBnDxyQEof_08XkC2IPe3Q.png"/></div></figure><p id="9228" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似于<code class="fe lq lr ls lt b">mapFormer</code>，但是工作于流返回转换:</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="902c" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { flatMapFormer } from '@rxjsx/rxjsx';</span><span id="0683" class="mr lw it lt b gy ov mt l mu mv">of&lt;[number, string]&gt;([1, '1'], [2, '2'])<br/>  .pipe(<strong class="lt iu">flatMapFormer</strong>(x =&gt; of(x * 2))) // [2, '1'], [4, '2']<br/>  .subscribe(console.log);</span></pre><h2 id="69e2" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">扁平疣</h2><p id="380d" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">类似于<code class="fe lq lr ls lt b">mapLatter</code>，但是工作于流返回转换:</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="3ec6" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { flatMapLatter } from '@rxjsx/rxjsx';</span><span id="ec94" class="mr lw it lt b gy ov mt l mu mv">of&lt;[number, string]&gt;([1, '1'], [2, '2'])<br/>  .pipe(<strong class="lt iu">flatMapLatter</strong>(y =&gt; of(`${y}+${y}`))) // [1, '1+1'], [2, '2+2']<br/>  .subscribe(console.log);</span></pre><h1 id="8dc0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4列表运算符</h1><p id="1510" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">通常，对于列表/数组的可观测量，人们应该混合使用JS数组操作符和RxJS操作符。举以下例子:</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="935a" class="mr lw it lt b gy ms mt l mu mv">of([1, 2, 3], [4], [5, 6])<br/>  .pipe(<strong class="lt iu">map</strong>(l =&gt; l.<strong class="lt iu">map</strong>(x =&gt; x*2));</span></pre><p id="31bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那里有两个<code class="fe lq lr ls lt b">map</code>，第一个是RxJS图，第二个是JS图。该操作简称为<code class="fe lq lr ls lt b">listMap</code>:</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="33ea" class="mr lw it lt b gy ms mt l mu mv">of([1, 2, 3], [4], [5, 6])<br/>  .pipe(<strong class="lt iu">listMap</strong>(x =&gt; x*2);</span></pre><p id="b9ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RxJS和JS <code class="fe lq lr ls lt b">map</code>中的任何一个都可以是<code class="fe lq lr ls lt b">flatMap</code>，因此我们得到4个这样的操作符:<code class="fe lq lr ls lt b">listMap</code>、<code class="fe lq lr ls lt b">flatListMap</code>、<code class="fe lq lr ls lt b">listFlatMap</code>和<code class="fe lq lr ls lt b">flatListFlatMap</code>。</p><p id="f786" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了减少混淆，单词“list”之前的单词“flat”是指RxJS运算符的平坦性，而“list”之后的单词是指JS的平坦性。</p><h2 id="5b58" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">列表地图</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/da692937bac7b7e55fe681ddde523de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*txVRip1Nk_PKnfOXIUdqiA.png"/></div></figure><p id="cdb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用列表元素上的映射转换列表的可观察对象:</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="83c0" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { listMap } from '@rxjsx/rxjsx';</span><span id="58b1" class="mr lw it lt b gy ov mt l mu mv">of([1, 2, 3])<br/>  .pipe(<strong class="lt iu">listMap</strong>(x =&gt; x * 2))<br/>  .subscribe(console.log); // [2, 4, 6]</span></pre><h2 id="b27a" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">平面列表地图</h2><p id="7bf0" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">使用流返回成员转换来转换列表的可观察对象:</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="ed1b" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { flatListMap } from '@rxjsx/rxjsx';</span><span id="359f" class="mr lw it lt b gy ov mt l mu mv">of([1, 2, 3])<br/>  .pipe(<strong class="lt iu">flatListMap</strong>(x =&gt; of(x * 2)))<br/>  .subscribe(console.log); // [2, 4, 6]</span></pre><h2 id="2314" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">列表平面图</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/437009b2e311b667d00ff57e65af7031.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*fbVuDjxhmsfV_7Yg4bVKEA.png"/></div></figure><p id="b152" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用返回列表的成员转换来转换列表的可观察对象:</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="4f11" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { listFlatMap } from '@rxjsx/rxjsx';</span><span id="9d3b" class="mr lw it lt b gy ov mt l mu mv">of([1, 2, 3])<br/>  .pipe(<strong class="lt iu">listFlatMap</strong>(x =&gt; [x, x * 2]))<br/>  .subscribe(console.log); // [1, 2, 2, 4, 3, 6]</span></pre><h2 id="ee69" class="mr lw it bd lx oj ok dn mb ol om dp mf ld on oo mh lh op oq mj ll or os ml ot bi translated">平面列表平面地图</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/47211ca341f382c7b9ffc528285cd2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Xzg03Jaum14auVOHwnoMUw.png"/></div></figure><p id="92a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用列表可观察值返回转换来转换列表的可观察值:</p><pre class="kj kk kl km gt mn lt mo mp aw mq bi"><span id="2e19" class="mr lw it lt b gy ms mt l mu mv">import { of } from 'rxjs';<br/>import { flatListFlatMap } from '@rxjsx/rxjsx';</span><span id="474a" class="mr lw it lt b gy ov mt l mu mv">of([1, 2, 3])<br/>  .pipe(<strong class="lt iu">flatListFlatMap</strong>(x =&gt; of([x, x * 2])))<br/>  .subscribe(console.log); // [1, 2, 2, 4, 3, 6]</span></pre><h1 id="26de" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="345e" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld ny lf lg lh nz lj lk ll oa ln lo lp im bi translated">使用高级定制流操作符使您的代码可读性更好，也更容易维护。还有，正如孔子所说:<a class="ae lu" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="9dd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你有更多的运营商想法，或者如果你在做RxJS时重复自己，请随意创建一个问题或向<a class="ae lu" href="https://github.com/rxjsx/rxjsx" rel="noopener ugc nofollow" target="_blank">这个库的Github repo </a>提出合并请求。</p><p id="c333" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你有进一步的问题，请随时发表评论或<a class="ae lu" href="https://twitter.com/MohammadAliEN" rel="noopener ugc nofollow" target="_blank">发推文给我</a>。</p></div></div>    
</body>
</html>