<html>
<head>
<title>Left folds and other reductions: The 114 C++ algorithms series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">左折叠和其他简化:114 C++算法系列</h1>
<blockquote>原文：<a href="https://itnext.io/left-folds-and-other-reductions-the-114-c-algorithms-series-6195724d324?source=collection_archive---------0-----------------------#2022-04-21">https://itnext.io/left-folds-and-other-reductions-the-114-c-algorithms-series-6195724d324?source=collection_archive---------0-----------------------#2022-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="08e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎学习114种标准C++算法的第五部分。在本章中，我们将讨论归约算法，即将一个范围归约为单个值的算法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/6c0195b6d7755b79d3975bf17e4a3bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-eh-0N7whc27HsxCaGHRg.png"/></div></div></figure><p id="b8e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将涵盖三组算法，严格线性运算的左折叠，C++17的广义归约和布尔归约。我们还会稍微绕一下路，谈谈在C++中混合数值类型的注意事项。</p><h2 id="f1e9" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">该系列:</h2><ul class=""><li id="fe08" class="lq lr iq jp b jq ls ju lt jy lu kc lv kg lw kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/the-114-standard-c-algorithms-introduction-2a75a2df4300">简介</a></li><li id="4b30" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/sorting-partitioning-the-114-c-algorithms-series-6503ad41cede">排序和分割算法</a></li><li id="8f1e" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/divide-conquer-and-sets-the-114-c-algorithms-series-d0085a38046e">对排序或分区范围进行操作的算法</a></li><li id="f7c1" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/transformations-the-114-c-algorithms-series-deacdbd4c373">转换算法</a></li><li id="5f59" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">左折叠和其他减少</li><li id="dddd" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/generators-copies-and-moves-the-114-c-algorithms-series-1d0774472877">生成器、副本和移动</a></li><li id="6c9c" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/heap-and-heap-the-114-c-algorithms-series-1d4215ae9f0d">堆和堆</a></li><li id="a7f8" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/@simontoth/8a6ed951ad40" rel="noopener">搜索和最小值-最大值</a></li><li id="e5ab" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">结论(即将发布)</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="34b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们今天要讨论的所有算法(除了布尔约简)都来自于<em class="mo"> &lt;数字&gt; </em>头，在C++20 ranges库中没有对应的内容(在C++23中有一些支持)。</p><h1 id="38be" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">累积，内积</h1><p id="a6af" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">我们从左折叠开始，算法严格从左到右操作，为每个元素计算<em class="mo">累加器= op(累加器，元素)</em>并返回最终的<em class="mo">累加器</em>值。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/ad68fce40c436d2e62f1bcff23f295ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMQPmpBY1O8-a5S9VvW-bQ.png"/></div></div></figure><p id="38ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于严格的线性运算，我们无法获得这些算法的并行版本。默认版本的accumulate使用二元<em class="mo">操作符+ </em>，如果指定，二元仿函数不允许修改范围内的元素或使迭代器无效。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7c21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要把任何一个左折叠算法变成右折叠，我们可以使用<em class="mo"> rbegin() </em>和<em class="mo"> rend() </em>(只要范围是双向的)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="58c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过添加另一个范围和一个连接操作，我们得到了<em class="mo">内积</em>。左折叠操作变为<em class="mo"> accumulator = op(accumulator，join(elem1，elem2)) </em>，其中<em class="mo"> elem1 </em>来自第一范围，<em class="mo"> elem2 </em>来自第二范围。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/04b05fc55cb9132f871787c099b5141f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9CZ_L9lEKYd21EzciV6tg.png"/></div></div></figure><p id="df70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认版本使用<em class="mo">运算符+ </em>进行累加，使用<em class="mo">运算符* </em>进行连接。如果指定，则不允许任何一个函子修改元素或使迭代器无效。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="68ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们也可以使用单个范围的<em class="mo">内积</em>，例如，计算连续元素之间的绝对差之和:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="f96a" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">短暂的算术迂回</h2><p id="8a91" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated"><em class="mo"> &lt;数字&gt; </em>标题中的算法可以有尖锐的边缘。这主要与C++处理混合数值类型的方式以及模板演绎的工作方式有关。例如，下面是一个容易犯的错误:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c49c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们传递了一个<em class="mo"> 0 </em>作为累加器的初始值，它是一个类型为<em class="mo"> int </em>的常量，所以累加器以<em class="mo"> int </em>结束。然后，每个fold操作将一个整数和一个双精度数相加，得到一个浮点值。但是，它会立即将其存储在一个整数变量中，截断该值。</p><p id="61c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想避免这个问题，你需要熟悉文字后缀:</p><ul class=""><li id="dc96" class="lq lr iq jp b jq jr ju jv jy nn kc no kg np kk lx ly lz ma bi translated"><a class="ae mb" href="https://en.cppreference.com/w/cpp/language/integer_literal#The_type_of_the_literal" rel="noopener ugc nofollow" target="_blank">整数文字后缀</a></li><li id="7f20" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" href="https://en.cppreference.com/w/cpp/language/floating_literal" rel="noopener ugc nofollow" target="_blank">浮点文字后缀</a></li><li id="4198" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" href="https://en.cppreference.com/w/cpp/header/cstdint#Function_macros_for_integer_constants" rel="noopener ugc nofollow" target="_blank">固定大小的整数文字宏</a></li></ul><p id="b83b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个问题出现在混合不同的整数类型时，尤其是有符号和无符号整数。同样，只要不混合类型，就不会遇到问题，但是要记住，重要的类型是元素类型、初始累加器值、仿函数参数和返回类型。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8186" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些可以说是非常合成的例子，不应该出现在产品代码库中。</p><p id="2b5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对整数转换和提升的更多细节感兴趣，hackingcpp 有一个关于这个主题的极好的<a class="ae mb" href="https://twitter.com/hackingcpp/status/1492242039110524935/photo/1" rel="noopener ugc nofollow" target="_blank">备忘单。</a></p><h1 id="a3b5" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">部分总和</h1><p id="3927" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated"><em class="mo"> partial_sum </em>算法在这里有点离群，因为它不是一个严格的归约算法。相反，它计算给定范围的部分和。第<em class="mo">n</em>个生成元素是源范围内前<em class="mo"> n </em>个元素的和。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/f0a86606f3013b53b41fc5b8c3295a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tPxNXZ6F8du-cId7RP-aw.png"/></div></div></figure><p id="71cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出迭代器允许作为输入范围的开始迭代器。默认操作是二进制加号，不允许自定义仿函数修改元素或使迭代器无效。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="6b84" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">减少，转换_减少</h1><p id="0455" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">前面讲的算法都是左折叠。它们从左到右严格地线性求值，这消除了并行执行的任何可能性。</p><p id="5730" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当我们处理关联运算<em class="mo"> op(a，op(b，c)) == op(op(a，b)，c) </em>和交换运算<em class="mo"> op(a，b) == op(b，a) </em>时，元素的排列和运算的顺序并不重要，我们总是会得到相同的结果。</p><p id="5de3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在C++17中，与其他并行算法一起，我们收到了<em class="mo"> reduce </em>、<em class="mo"> inclusive_scan </em>和<em class="mo"> exclusive_scan、</em>，它们是<em class="mo"> accumulate </em>、<em class="mo"> inner_product </em>和<em class="mo"> partial_sum </em>的宽松版本，需要关联和交换操作来产生确定性结果。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/6769a051e078bab1622d02338abf74de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fa4an35qe7PJURDOJkCYrA.png"/></div></div></figure><p id="dc21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了<em class="mo">累加</em>等效值之外，我们还得到一个重载，去掉了初始累加器值，减少了前面提到的数值问题。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7c11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">累加器将属于范围元素的类型，并将进行值初始化。因此，在本例中，累加器将为double类型，并初始化为零。</p><p id="789b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，这也适用于自定义类型:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cca7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">累加器的初始值将是“嘎嘎”的。加上另外两只鸭子，我们最终得到了“呱呱呱呱”。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="a861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与<em class="mo"> inner_product </em>相对应的是<em class="mo"> transform_reduce </em>，增加了一元情况(单范围)的额外重载。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/eac68e2a1b100b452bb5a9b413f63765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TISmUZaj78sJzqH5mpteDA.png"/></div></div></figure><p id="281e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与<em class="mo"> reduce </em>相同，前提是函子不能修改元素或使迭代器无效。此外，归约函子必须是结合的和交换的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="3606" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">排除扫描，包含扫描，转换排除扫描，转换包含扫描</h1><p id="a816" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">最后一个没有平行对位的左折算法是<em class="mo"> partial_sum </em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/2ff7c55cccb640a7f62255cde083d7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ve7sIjpJHNotoJRj9rQYMg.png"/></div></div></figure><p id="1349" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与<em class="mo">partial _ sum</em>1:1对应的是<em class="mo"> inclusive_scan，</em>遵循相同的逻辑:<em class="mo">第n个</em>生成元素是前<em class="mo"> n个</em>源元素的和。除此之外，我们还得到<em class="mo"> exclusive_scan </em>，其中第<em class="mo">个</em>生成的元素是前<em class="mo">个n-1个</em>源元素的总和。或者:包含版包含第<em class="mo">n</em>位的元素，独占版不包含。</p><p id="4851" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，对于<em class="mo"> exclusive_scan </em>算法，我们必须指定累加器的初始值，这将是第一个生成元素的值。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/f6532080bb6aad917b4dc4f3a3774073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8Q8im9hPymFmEIYnCt9PQ.png"/></div></div></figure><p id="bde6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mo"> inclusive_scan </em>和<em class="mo"> exclusive_scan </em>的变换变体对每个元素应用一元变换。不幸的是，我们没有得到可以在两个输入范围上操作的重载(以<em class="mo"> inner_product </em>的风格)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="1c5b" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">所有的，任何的，没有的</h1><p id="1a39" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">最后，我们切换回<em class="mo"> &lt;算法&gt; </em>头，这里我们有三个布尔约简。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nu"><img src="../Images/6f785dc7e7a2144244720243c41e786e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3GDZ38tEAW1XWpvJhTS9w.png"/></div></div></figure><p id="94c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">算法遵循预期的布尔逻辑。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nv"><img src="../Images/28eea990859269c5dc317e546e0116f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95176_slD8oS-XsQWoX7uw.png"/></div></div></figure><p id="54ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，的<em class="mo">any _需要正存在；如果谓词至少有一个元素在空范围内返回<em class="mo">真</em>和<em class="mo">假</em>，那么它只返回<em class="mo">真</em>。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="a5f7" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">感谢您的阅读</h1><p id="adf0" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">不要忘记关注，这样你就不会错过本系列的其他文章。例如，下一篇文章将讨论生成值的算法和复制或移动元素的算法。</p><p id="0dff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在Twitter或LinkedIn上联系我。</p></div></div>    
</body>
</html>