<html>
<head>
<title>Promise Mate: Delegating asynchronous results in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Promise Mate:委托JavaScript中的异步结果</h1>
<blockquote>原文：<a href="https://itnext.io/promise-mate-delegating-asynchronous-results-in-javascript-895c912069e3?source=collection_archive---------5-----------------------#2019-01-30">https://itnext.io/promise-mate-delegating-asynchronous-results-in-javascript-895c912069e3?source=collection_archive---------5-----------------------#2019-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0b7f6f4dae7455e0d560305bcf9c036b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTFHZF-HOasGOrECUV_8vA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">来自www.flaticon.com<a class="ae jd" href="http://www.flaticon.com/" rel="noopener ugc nofollow" target="_blank">的<a class="ae jd" href="https://www.flaticon.com/authors/freepik" rel="noopener ugc nofollow" target="_blank"> Freepik </a>制作的图标</a></figcaption></figure><div class=""/><p id="8c12" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我创建了一个Node.js CLI来帮助完成我工作中一个比较繁琐的部分。CLI将监控多达三个不同的API端点的变化，并根据某些标准，在信息发生变化时向我发出警报。例如，我添加了一个检查，以便在特定的API值自上次检查以来发生变化时发出警报。</p><p id="1c9a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这个工具是模块化的，你可以定义单独的“检查”来测试变化，并按照你的意愿混合和匹配。我没有<em class="lb">而不是</em>想要获取所有的端点，因为我知道这将会浪费时间和资源，这取决于所提供的检查。</p><p id="728b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我使用<code class="fe lc ld le lf b">Promise.all</code>只请求所需的资源，并将它们分配给需要它们的检查。在这篇文章中，我将描述这个概念和由此产生的模块，<a class="ae jd" href="https://npm.im/promise-mate" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">【承诺伴侣</strong> </a>。</p><p id="edab" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这是从JavaScript项目开发的，所以我可能会使用JavaScript术语，比如“promise”。然而，其基本概念可能适用于任何具有并行性的语言。</p><h1 id="0b52" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">纲要</h1><p id="1711" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">这种方法适用于…</p><ul class=""><li id="ba35" class="mj mk jg kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">您有一个依赖于异步结果的操作池。</li><li id="7965" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">其中一些行动可能取决于同样的结果。</li><li id="4c07" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">即使需要多个操作，结果也应该只解析一次。</li><li id="047e" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">动作可以/应该在运行之前等待所有的解决方案(甚至是它们不需要的解决方案)(如JavaScript的<code class="fe lc ld le lf b">Promise.all</code>)。</li><li id="856e" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">在解决问题后，按顺序运行操作是有利的，也是不合理的(如果不这样做，还有其他方法)。</li><li id="d772" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">当涉及到动作及其相关的异步结果时，可重用性和/或模块化是关注的问题。</li></ul><h1 id="4cd6" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">概念</h1><p id="4487" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">让我们创建一个示例项目，作为解释这个概念的框架。</p><figure class="my mz na nb gt is gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/5c34e7661a1b767314c95f67c2a7537e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*izTTcx_NXEDLN0Bb50MBTw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">行动、资源以及两者之间的关系。</figcaption></figure><p id="6618" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有四个可能的<strong class="kf jh">资源</strong>需要并行解析*: A、B、C和d。我们有四个<strong class="kf jh">动作</strong>需要执行:1、2、3和4。基于我们可能的资源，这四个动作有<strong class="kf jh">需求</strong>:动作1和2需要资源A，动作2也需要资源B，动作3需要资源C，动作4不需要任何资源，任何动作都不需要资源D。</p><p id="d6dc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何重复的需求将减少到只有一个请求(例如资源A将仅被提取一次而不是两次)。此外，将不获取不需要的资源(例如没有请求资源D，因此它不会被请求)。</p><p id="60dd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请求资源，并且当所有资源都被解析时，它们被传递给它们的请求动作进行处理。</p><p id="5fa4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> *这不一定是资源获取，它本身可以是一个动作，如发布数据、保存文件等。甚至返回一个常量变量。然而，我将在整个文档中使用“resource ”,坚持使用这个示例项目中引入的措辞。</em></p><h1 id="120d" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">将概念付诸实践</h1><p id="f475" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">从这个概念框架出发，我创建了模块Promise Mate(因为动作与它们的承诺以及彼此之间是“匹配”的)。以下是如何在模块中实现这一概念。</p><h2 id="f5d1" class="nc lh jg bd li nd ne dn lm nf ng dp lq ko nh ni lu ks nj nk ly kw nl nm mc nn bi translated">资源</h2><p id="cc25" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">使用Promise Mate，你必须定义如何获取你的资源。这些定义是一个标准对象，其关键字标识资源，值或者是一个生成承诺的函数，或者是一个将按原样传递给<code class="fe lc ld le lf b">Promise.all</code>的变量。</p><pre class="my mz na nb gt no lf np nq aw nr bi"><span id="8d33" class="nc lh jg lf b gy ns nt l nu nv">const resources = {<br/>  A: () =&gt; fetch('A.txt').then(res =&gt; res.text()),<br/>  B: 'B',<br/>  C: () =&gt; Promise.resolve('C'),<br/>  D: Promise.resolve('D')<br/>}</span></pre><h2 id="589b" class="nc lh jg bd li nd ne dn lm nf ng dp lq ko nh ni lu ks nj nk ly kw nl nm mc nn bi translated">行动</h2><p id="a62b" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">在Promise Mate中，动作需要定义它们所需的资源(如果有的话)和回调函数来调用这些解析的资源。标准格式如下:</p><pre class="my mz na nb gt no lf np nq aw nr bi"><span id="9792" class="nc lh jg lf b gy ns nt l nu nv">const action2 = {<br/>  requires: ['A', 'B'],<br/>  then(a, b) { console.log(a, b) }<br/>}</span></pre><p id="d2b4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">then</code>函数是所有承诺(包括这个特定动作不需要的承诺)被解析时的回调函数。所需的资源按照定义的顺序作为参数传递给该函数。</p><p id="9870" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">requires</code>属性声明了动作成功运行所需的资源。通常，它是一个字符串数组，对应于已定义资源的键。当只请求一个资源时，也可以只使用相关的键，而不使用数组:</p><pre class="my mz na nb gt no lf np nq aw nr bi"><span id="5b8a" class="nc lh jg lf b gy ns nt l nu nv">const action1 = { requires: 'A', then: (a) =&gt; { console.log(a) } }</span></pre><p id="77ce" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lc ld le lf b">requires</code>属性没有可解析的键(它们要么不是字符串，要么没有被定义)，那么它们被假定为要传递给回调的常量。</p><pre class="my mz na nb gt no lf np nq aw nr bi"><span id="830d" class="nc lh jg lf b gy ns nt l nu nv">const action3 = {<br/>  requires: [{ prefix: 'I found ' }, 'C'],<br/>  then: ({ prefix }, c) =&gt; { console.log(`${prefix}${c}`) }<br/>}</span><span id="07bf" class="nc lh jg lf b gy nw nt l nu nv">const action4 = {<br/>  requires: undefined,  // Essentially the same as just not defining the requires property or as an empty array<br/>  then() { console.log('Check complete!') }<br/>}</span></pre><h2 id="e629" class="nc lh jg bd li nd ne dn lm nf ng dp lq ko nh ni lu ks nj nk ly kw nl nm mc nn bi translated">把这一切联系在一起</h2><p id="8f12" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">现在，您可以像下面这样运行所有内容:</p><pre class="my mz na nb gt no lf np nq aw nr bi"><span id="78a1" class="nc lh jg lf b gy ns nt l nu nv">import Mate from 'promise-mate'</span><span id="beab" class="nc lh jg lf b gy nw nt l nu nv">Mate<br/>  .all(resources, [action1, action2, action3, action4])<br/>  .then(() =&gt; { console.log('All done!') })</span><span id="234c" class="nc lh jg lf b gy nw nt l nu nv">// Console output:<br/>// A<br/>// A B<br/>// I found C<br/>// Check complete!<br/>// All done!</span></pre><p id="0633" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，对于可重用和可扩展的资源定义，您可以采用更加面向对象的方法:</p><pre class="my mz na nb gt no lf np nq aw nr bi"><span id="265a" class="nc lh jg lf b gy ns nt l nu nv">import Mate from 'promise-mate'</span><span id="e9e2" class="nc lh jg lf b gy nw nt l nu nv">const runner = new Mate(resources)<br/>runner.define('C', () =&gt; Promise.resolve('B'))</span><span id="6942" class="nc lh jg lf b gy nw nt l nu nv">runner<br/>  .all([action1, action2, action3, action4])<br/>  .then(() =&gt; { console.log('All done!') })</span></pre><p id="4ff5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，尽管资源将被异步解析，但一旦解析，操作将按顺序运行。</p><h2 id="8cd7" class="nc lh jg bd li nd ne dn lm nf ng dp lq ko nh ni lu ks nj nk ly kw nl nm mc nn bi translated">继续还是打破承诺链</h2><p id="c227" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated"><code class="fe lc ld le lf b">Mate.all</code>和<code class="fe lc ld le lf b">Mate.prototype.all</code>都返回一个承诺，这个承诺用每个动作的回调函数返回的数组(如果有的话)来解析。这样，您可以做如下事情:</p><pre class="my mz na nb gt no lf np nq aw nr bi"><span id="6a32" class="nc lh jg lf b gy ns nt l nu nv">runner<br/>  .all([action1, action2])<br/>  .then(([result1, result2]) =&gt; { console.log(result1, result2) })</span></pre><p id="6186" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你的行为可能会带来承诺，你可以使用<code class="fe lc ld le lf b">Promise.all</code>来解决它们:</p><pre class="my mz na nb gt no lf np nq aw nr bi"><span id="2384" class="nc lh jg lf b gy ns nt l nu nv">const promises = await runner.all([action1, action2])<br/>const [result1, result2] = await Promise.all(promises)<br/>console.log(result1, result2)</span></pre><p id="1b34" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果在一个承诺中遇到错误或拒绝，<em class="lb">所有的</em>都将被拒绝(就像<code class="fe lc ld le lf b">Promise.all</code>中一样)。</p><pre class="my mz na nb gt no lf np nq aw nr bi"><span id="62c5" class="nc lh jg lf b gy ns nt l nu nv">runner<br/>  .all([action1, action2, action3, action4])<br/>  .catch((err) =&gt; { console.error(err) })</span></pre><p id="4217" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我建议，如果一个承诺最终被拒绝，那就没有必要了，那就用<a class="ae jd" href="https://www.npmjs.com/package/p-reflect" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> p-reflect </strong> </a>(或类似的说法):</p><pre class="my mz na nb gt no lf np nq aw nr bi"><span id="3457" class="nc lh jg lf b gy ns nt l nu nv">import reflect from 'p-reflect'</span><span id="4417" class="nc lh jg lf b gy nw nt l nu nv">runner.define('E', () =&gt; reflect(getText("dubious.txt")))</span><span id="8211" class="nc lh jg lf b gy nw nt l nu nv">const action5 = {<br/>  requires: ['A', 'E']<br/>  then(a, e) {<br/>    if (e.isFulfilled) {<br/>      console.log(a, e.value)<br/>    } else {<br/>      console.warn(e.reason)<br/>      console.log(a)<br/>    }<br/>  }<br/>}</span><span id="c8fd" class="nc lh jg lf b gy nw nt l nu nv">runner.all([action1, action5])</span></pre><h1 id="1a23" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="1d7b" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">如前所述，这种模式并不适用于每种情况，但在适用的情况下可能非常有效。</p><p id="97ed" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请随意浏览<a class="ae jd" href="https://github.com/czycha/promise-mate" rel="noopener ugc nofollow" target="_blank"> Promise Mate </a>的源代码，了解任何底层实现细节。您还可以使用<code class="fe lc ld le lf b">npm i promise-mate</code>或<code class="fe lc ld le lf b">yarn add promise-mate</code>将它添加到Node.js项目中。</p></div></div>    
</body>
</html>