<html>
<head>
<title>GraphQL + Mongoose: A design-first approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">graph QL+mongose:设计优先的方法</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-mongoose-a-design-first-approach-d97b7f0c869?source=collection_archive---------0-----------------------#2018-03-16">https://itnext.io/graphql-mongoose-a-design-first-approach-d97b7f0c869?source=collection_archive---------0-----------------------#2018-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b65a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fgraphql-mongoose-a-design-first-approach-d97b7f0c869" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p><p id="577d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们应该以及如何优雅地将GraphQL模式从解析器中分离出来。</p><h1 id="90ac" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">TL；速度三角形定位法(dead reckoning)</h1><ol class=""><li id="5df5" class="lk ll iq jp b jq lm ju ln jy lo kc lp kg lq kk lr ls lt lu bi translated">在<code class="fe lv lw lx ly b">docs/api.graphql</code>中设计你的GraphQL模式；</li><li id="7fc1" class="lk ll iq jp b jq lz ju ma jy mb kc mc kg md kk lr ls lt lu bi translated">在<code class="fe lv lw lx ly b">server/models/users.js</code>中设计你的Mongoose模式；</li><li id="efa1" class="lk ll iq jp b jq lz ju ma jy mb kc mc kg md kk lr ls lt lu bi translated"><strong class="jp ir">使用<code class="fe lv lw lx ly b">server/app/graphql/projection.js</code>中的</strong>T2将它们连接在一起；</li><li id="11be" class="lk ll iq jp b jq lz ju ma jy mb kc mc kg md kk lr ls lt lu bi translated">把你的商业逻辑写在<code class="fe lv lw lx ly b">server/app/graphql/users.js</code>；</li><li id="398e" class="lk ll iq jp b jq lz ju ma jy mb kc mc kg md kk lr ls lt lu bi translated">设置猫鼬、阿波罗和快车；那就好好享受吧！</li></ol><blockquote class="me mf mg"><p id="048d" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">注意:本指南假设您应该对MongoDB有所了解，并且熟悉<a class="ae kl" href="https://docs.mongodb.com/manual/applications/data-models-relationships/" rel="noopener ugc nofollow" target="_blank">建模关系</a>。</p></blockquote></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="910a" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">好的设计</h1><p id="ca19" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">一个设计良好的后端服务应该具备哪些素质？<br/> <a class="ae kl" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依存倒置原则</a>表明:</p><blockquote class="na"><p id="c675" class="nb nc iq bd nd ne nf ng nh ni nj kk dk translated">A.高层模块不应该依赖低层模块。两者都应该依赖于抽象。</p><p id="2ed2" class="nb nc iq bd nd ne nf ng nh ni nj kk dk translated">B.抽象不应该依赖于细节。细节应该依赖于抽象。</p></blockquote><p id="3ba0" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">所以现在我们不难区分好的和坏的设计:</p><figure class="nq nr ns nt gt nu gh gi paragraph-image"><div class="gh gi np"><img src="../Images/a7351b623a5fb93eeba07122a6bfa733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*51yXNGRKpwkm8Fy34W6mrA.png"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="cffb" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">将GraphQL模式与实现分开</h1><p id="5b6d" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">一种常见但不明智的做法是大量使用<code class="fe lv lw lx ly b">graphql-js</code>的构造函数，如<code class="fe lv lw lx ly b">GraphQLObjectType</code>、<code class="fe lv lw lx ly b">GraphQLSchema</code>、<code class="fe lv lw lx ly b">GraphQLString</code>或其他。然而，这是一个糟糕的设计，因为GraphQL API没有与JavaScript实现分离。换句话说，如果前端开发人员想要查看后端API，他/她必须进入用后端JavaScript(或者更糟，Python或Ruby或与前端JavaScript完全不同的东西)编写的网关源代码。</p><p id="aea7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看下面哪个对前端开发人员来说更抽象、更友好。</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="79b1" class="nz kn iq bd ko oa ob dn ks oc od dp kw jy oe of la kc og oh le kg oi oj li ok bi translated">救生员:<a class="ae kl" href="https://www.apollographql.com/docs/graphql-tools/generate-schema.html" rel="noopener ugc nofollow" target="_blank">makexecutableschema</a></h2><p id="c390" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">谢天谢地，包<code class="fe lv lw lx ly b">graphql-tools</code>提供了一个叫<code class="fe lv lw lx ly b">makeExecutableSchema</code>的很棒的函数。在继续之前，您可能希望看一下<a class="ae kl" href="http://graphql-tools" rel="noopener ugc nofollow" target="_blank">的API </a>。</p><p id="e4ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码片段是如何将它用于单独的GraphQL模式文件的示例。你可以把<code class="fe lv lw lx ly b">fs.readFileSync</code>换成<code class="fe lv lw lx ly b">fs.readFile</code>来加速启动。</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="355d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在一切都变得简单了，因为我们使用正确的工具来完成正确的任务——schema是用GraphQL编写的，而DB调用是由JavaScript处理的。此外，前端开发人员可以简单地参考<code class="fe lv lw lx ly b">api.graphql</code>，轻松获得他们想要的东西。他们不应该也不能进入后端-JavaScript！</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="49f0" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">设计您的Mongoose模式</h1><p id="8974" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">请记住，您的Mongoose模式不一定与您的GraphQL模式完全匹配，尤其是在一对多关系的建模上。在GraphQL中，我们写道:</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b2f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在猫鼬身上，我们有两种选择:</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5b06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两者各有利弊，用哪个由你决定。你也可以参考<a class="ae kl" href="https://stackoverflow.com/a/5373969" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出答案</a>了解更多细节。当然，我会在下面的文章中讨论这两个问题！</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="db56" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">轻松连接GraphQL和Mongoose</h1><p id="8a5e" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">所以我们已经有了<code class="fe lv lw lx ly b">makeExecutableSchema</code>。但这还不够:</p><ol class=""><li id="6a3f" class="lk ll iq jp b jq jr ju jv jy ol kc om kg on kk lr ls lt lu bi translated">客户端可能只需要部分字段，但是<code class="fe lv lw lx ly b">User.findById(id)</code>会从MongoDB中检索所有字段。最好使用<code class="fe lv lw lx ly b">User.findById(id, projection)</code>，其中<code class="fe lv lw lx ly b">projection</code>应该是动态计算的。这个过程叫做<strong class="jp ir">投影</strong>。</li><li id="405b" class="lk ll iq jp b jq lz ju ma jy mb kc mc kg md kk lr ls lt lu bi translated">GraphQL模式字段名称可能与Mongoose模式字段名称不匹配，因此默认的GraphQL解析器功能不正常。你需要添加你自己的<strong class="jp ir">解析器</strong>(别担心，有自动工具可以完成)。</li><li id="5bf6" class="lk ll iq jp b jq lz ju ma jy mb kc mc kg md kk lr ls lt lu bi translated">对于那些使用引用模式的人来说，一个单独的<code class="fe lv lw lx ly b">User.findById</code>调用可能不足以检索客户机需要的所有信息。两个选项都必须做:a .猫鼬的<strong class="jp ir">填充</strong>；b. MongoDB的<strong class="jp ir"> $lookup </strong>。前者产生更干净的代码，而后者带来更好的性能。</li></ol><p id="c415" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多软件包已经被开发出来解决第一个问题，但是很少有人解决第二个或者第三个问题。所以我开发了<code class="fe lv lw lx ly b"><a class="ae kl" href="https://github.com/b1f6c1c4/graphql-advanced-projection" rel="noopener ugc nofollow" target="_blank">graphql-advanced-projection</a></code>，使得<strong class="jp ir">自动创建投影和解析器</strong>。只需稍加修改，它也可以用于填充。</p><blockquote class="me mf mg"><p id="44d6" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">注意:<code class="fe lv lw lx ly b">graphql-advanced-projection@1.0</code>还不支持自动聚合和$lookup。我正在做这个，以后会支持的。</p></blockquote><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完美。并且仍然有足够的空间供您添加自定义逻辑。如果你想要更多的例子，请查看这个。<code class="fe lv lw lx ly b">gqlProjection</code>的完整API文档可从<a class="ae kl" href="https://github.com/b1f6c1c4/graphql-advanced-projection/wiki/API" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="d6e4" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">设置猫鼬，阿波罗，快递等。</h1><p id="8fe8" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">由于这类问题的文章太多，这里只列出一些链接。</p><ul class=""><li id="6ad8" class="lk ll iq jp b jq jr ju jv jy ol kc om kg on kk oo ls lt lu bi translated">要设置Mongoose，请参考<a class="ae kl" href="http://mongoosejs.com/docs/index.html" rel="noopener ugc nofollow" target="_blank">其官方文档</a>。</li><li id="9a87" class="lk ll iq jp b jq lz ju ma jy mb kc mc kg md kk oo ls lt lu bi translated">要设置Apollo服务器，请参考<a class="ae kl" href="https://www.apollographql.com/docs/apollo-server/" rel="noopener ugc nofollow" target="_blank">其官方文档</a>。</li><li id="317e" class="lk ll iq jp b jq lz ju ma jy mb kc mc kg md kk oo ls lt lu bi translated">要设置Express，请参考<a class="ae kl" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">其官方文件</a>。</li><li id="ca0d" class="lk ll iq jp b jq lz ju ma jy mb kc mc kg md kk oo ls lt lu bi translated">要进行集成测试，可以尝试<code class="fe lv lw lx ly b"><a class="ae kl" href="https://github.com/b1f6c1c4/jest-mongoose" rel="noopener ugc nofollow" target="_blank">jest-mongoose</a></code>。</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="8856" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">包扎</h1><p id="6b20" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">在本文中，我首先声称GraphQL模式(类型定义)应该从解析器中分离出来，以实现依赖倒置原则。然后我演示了如何利用<code class="fe lv lw lx ly b">graphql-tools</code>来连接GraphQL模式和Mongoose。最后，我提出了<code class="fe lv lw lx ly b"><a class="ae kl" href="https://github.com/b1f6c1c4/graphql-advanced-projection" rel="noopener ugc nofollow" target="_blank">graphql-advanced-projection</a></code>，它解决了连接过程中的三个主要问题:投影、解析器创建和填充。</p><p id="11d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对<code class="fe lv lw lx ly b"><a class="ae kl" href="https://github.com/b1f6c1c4/graphql-advanced-projection" rel="noopener ugc nofollow" target="_blank">graphql-advanced-projection</a></code>有任何问题，请随时提出。我会尽力改进它。</p></div></div>    
</body>
</html>