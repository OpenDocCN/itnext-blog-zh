<html>
<head>
<title>Creating your own Markdown Parser from Scratch in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中从头开始创建您自己的Markdown解析器</h1>
<blockquote>原文：<a href="https://itnext.io/creating-your-own-markdown-parser-from-scratch-in-swift-a8fa6f185bc8?source=collection_archive---------2-----------------------#2021-05-11">https://itnext.io/creating-your-own-markdown-parser-from-scratch-in-swift-a8fa6f185bc8?source=collection_archive---------2-----------------------#2021-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4500" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你知道Markdown吧？这种文本格式使用时髦的字符如<code class="fe kl km kn ko b">#</code>、<code class="fe kl km kn ko b">**</code>或<code class="fe kl km kn ko b">&gt;</code>来创建格式良好的文档？厉害！许多平台每天都在使用它，所以你最终也会使用它。</p><p id="4b14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果您的Swift应用程序需要一个markdown解析器，该怎么办呢？好吧，我们可以只使用其中一个经过良好测试的版本(可以在GitHub上使用您最喜欢的搜索引擎找到)，但取而代之的是……您也可以创建自己的版本。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/8971f05be62566d605ae2d2fc599d02e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*S5uBWbywD4XLTwR16-cGoQ.jpeg"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">德雷克可能也更喜欢写自己的解决方案</figcaption></figure><p id="7f5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">玩笑归玩笑:如果可能，不要重新发明轮子。如果一个现有的框架有一个活跃的维护者能满足你的需求，就使用那个。在<a class="ae lc" href="https://techprimate.com" rel="noopener ugc nofollow" target="_blank"> techprimate </a>我们决定创建自己的解决方案，<a class="ae lc" href="https://github.com/techprimate/CoolDown" rel="noopener ugc nofollow" target="_blank">冷却</a>，因为即将推出的应用程序使用Markdown和许多自定义扩展，因此完全控制更方便。</p><p id="1271" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文还将向您介绍如何解析结构化的纯文本文档。下面简单介绍一下我们将涉及的内容:</p><ol class=""><li id="19fc" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">降价文档结构</li><li id="bfbf" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">文档解析器的结构</li><li id="339e" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">实施准则</li><li id="6434" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">按字符解析片段</li></ol><h1 id="e14f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">降价文档结构</h1><p id="f77b" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">Markdown文档完全用纯文本编写，任何额外的资源只作为URL引用添加。</p><p id="b8ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多年来，出现了多种Markdown规范，许多平台(例如GitHub)都采用并扩展了它。最终它被标准化以消除歧义。对于本教程，我们将使用<a class="ae lc" href="https://spec.commonmark.org/0.29/" rel="noopener ugc nofollow" target="_blank"> CommonMark 0.29 </a>规范作为参考，因为它是一个相当常见的规范(双关语)。</p><h2 id="b29b" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">结构元素</h2><p id="6167" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">文档的一个主要结构元素是<em class="lb">双换行符/空行</em>，因为它将我们的文档组织成一系列的<em class="lb">块</em>。请看下面的例子:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0aeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很明显，这些应该被认为是两个块，但是下面仅仅是单个块:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5a20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些块甚至可以进一步分类为<em class="lb">叶块</em>(例如标题)、<em class="lb">容器块</em>(例如列表)和<em class="lb">内联</em>(例如代码跨度)。我现在不会进一步深入细节，因为您可以查看详细的CommonMark文档。</p><p id="224c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要更仔细地看一下单个块:</p><pre class="kq kr ks kt gt ni ko nj nk aw nl bi"><span id="a20f" class="mu ls iq ko b gy nm nn l no np">This is a full text *with some cursive* and some **bold text**.</span></pre><p id="73f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这仍然是一个块，但它由5个内嵌块/元素组成:</p><ol class=""><li id="9e1d" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">纯文本:<code class="fe kl km kn ko b">This·is·a·full·text·</code>(包括尾部空白)</li><li id="45d5" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">草书文字:<code class="fe kl km kn ko b">with·some·cursive</code></li><li id="9ab5" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">纯文本:<code class="fe kl km kn ko b">·and·some·</code></li><li id="83f9" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">粗体文本:<code class="fe kl km kn ko b">bold·text</code></li><li id="bd25" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">纯文本:<code class="fe kl km kn ko b">.</code></li></ol><h1 id="1b6d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">文档解析器的结构</h1><p id="0aa0" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">好了，现在你对我们要处理的数据有了一些基本的了解。现在您需要知道如何解析一个普通的文本文档。一条经验法则:</p><blockquote class="nq"><p id="0f70" class="nr ns iq bd nt nu nv nw nx ny nz kk dk translated">在处理每个块之前，将文本分成尽可能小的块</p></blockquote><p id="3e38" class="pw-post-body-paragraph jn jo iq jp b jq oa js jt ju ob jw jx jy oc ka kb kc od ke kf kg oe ki kj kk ij bi translated">如前所述，我们的文档由一系列块组成。这已经让我们的生活变得更容易了，因为我们现在可以单独分析积木了。</p><p id="0741" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们知道没有一个减价元素的跨度超过一行。即使是下面这个例子，一个多行代码段，也可以看成三个“子块”。为了简化我们的命名，从现在开始我将把它们称为<em class="lb">片段:</em></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7a8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经将一个大文档分解成块，然后再分解成片段。由于各个片段的内容各不相同，我们无法再进一步细分。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi of"><img src="../Images/471eaba84ffab9ff7ee21d03714f72b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oV75cDIooAre7oB0o4u64g.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Markdown文档由块组成，而块又由片段和内联组成</figcaption></figure><p id="f650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住这种结构，我们可以创建以下基本算法:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="8ce7" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">实施准则</h1><p id="db1a" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">你的时间到了。是时候写一些代码了🔥</p><p id="67de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们的库是完全基于逻辑的，并作为一个黑盒工作(文本作为输入，解析的文档作为输出)，这是一个很好的<strong class="jp ir">测试驱动开发(TDD) </strong>的用例。<br/>这种开发策略的主要思想是首先定义一个测试用例，它会故意失败，然后编写代码来修复它。</p><p id="b859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步，使用您选择的终端和<code class="fe kl km kn ko b">swift package init --type library</code>或使用Xcode创建一个新的Swift包<strong class="jp ir"><em class="lb">MarkdownParser</em></strong>:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi ok"><img src="../Images/021a7cc337cbc38e7a17289e56309d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbgWdOyIAHKC8IjAnfvgmw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Xcode还提供了创建Swift包的选项</figcaption></figure><p id="0467" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，打开<code class="fe kl km kn ko b">MarkdownParserTests.swift</code>并创建您的第一个测试用例:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8104" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码很简单，但是为了方便起见，我将解释一下:首先定义输入文本，然后使用输入文本创建一个解析器，并调用<code class="fe kl km kn ko b">parse()</code>将它转换成一个节点树。最后，我们编写一个测试断言来检查它是否返回了预期的结果。</p><p id="225e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Xcode通常会很快告诉你语法问题:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi ol"><img src="../Images/99a89113a2ce0279135fffa3b071848a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sDvFyFqF6UOhHwCyWJuG4g.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Xcode会抱怨，但这是在进行测试驱动开发时所期望的</figcaption></figure><p id="90f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决这种情况的唯一方法是实现满足测试期望的类<code class="fe kl km kn ko b">MarkdownParser</code>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="14db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次运行测试，它将不会再失败(现在<em class="lb">*伏笔加剧</em> *)🎉</p><h2 id="210d" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">创建我们的第一个内容节点</h2><p id="7250" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">在添加更多功能之前，添加一个新的测试用例:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再次需要修改代码，通过向已知的节点类型添加新的内容节点类型来满足期望</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6c01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并更改我们的解析器以满足两个测试用例:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><blockquote class="om on oo"><p id="0cef" class="jn jo lb jp b jq jr js jt ju jv jw jx op jz ka kb oq kd ke kf or kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong> <br/>在本教程中，我使用一个<code class="fe kl km kn ko b">enum</code>来定义不同的节点，因为它很简单。您还可以创建<code class="fe kl km kn ko b">struct's</code>甚至<code class="fe kl km kn ko b">classes</code>来返回解析后的节点。</p></blockquote><h2 id="cb28" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">加快我们的解析游戏</h2><p id="70d7" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">好吧，好吧，好吧…简单的文本解析已经足够了。到目前为止，您有望理解TDD是如何工作的，所以让我们向前跳几步，创建一个更高级的测试用例:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8bd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理这个复杂示例的第一步是创建必要的节点类型:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="72f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在记住引言中的算法:首先我们需要将文本分成块，然后迭代它们。我们通过创建一个所谓的<code class="fe kl km kn ko b">Lexer</code>，一个将我们的原始内容分割成更小块的类(所谓的<em class="lb"> lexems </em>)，以一种可测试的方式做到这一点。<br/>此外，它实现了迭代器协议，以使用标准化的循环机制:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0a42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的Markdown解析器正在发展，我们算法的前两步已经实现:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="29c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进展顺利！接下来让我们关注第3步和第4步:</p><blockquote class="om on oo"><p id="6125" class="jn jo lb jp b jq jr js jt ju jv jw jx op jz ka kb oq kd ke kf or kh ki kj kk ij bi translated">3.将每个块分割成碎片<br/> 4。迭代所有片段并将它们解析成节点(例如粗体文本)</p></blockquote><p id="c720" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建另一个类<code class="fe kl km kn ko b">BlockParser</code>,它将迭代块中的每个片段并单独解析它们:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ea0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调整<code class="fe kl km kn ko b">MarkdownParser.parse()</code>以将其用于每个模块，并完成我们算法的第3步:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="65a0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">按字符解析片段</h1><p id="025f" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">到目前为止，文档的结构是众所周知的(由空行分割的块，由换行符分割的片段)。</p><p id="bd38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于实际的片段解析逻辑，您可以从多种方法中进行选择(比如使用Regex ),但是在这种方法中，我们使用的是基于字符的词法分析器。</p><p id="0ed3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">片段词法分析器与前面的不同，因为它通过每个字符迭代内容，并且还提供了额外的方法来使<em class="lb">在更多的字符处到达峰值</em>(不增加迭代器计数器)和<em class="lb">回退</em>以向后移动迭代器。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="634f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用我们在本教程中收集的所有知识，让我们创建最后一个缺失的解析器<code class="fe kl km kn ko b">FragmentParser</code>。这个类将使用我们的<code class="fe kl km kn ko b">FragmentLexer</code>并通过特定的字符来标识不同的节点，正如规范中所声明的。<br/>在第一个版本中，我们将每个字符连接成一个<code class="fe kl km kn ko b">.text(...)</code>节点，以完成我们的第二个测试用例:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="cca9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于简单的用例很好，但是对于更复杂的用例，我们需要一个额外的数据结构来有效地跟踪片段中的抽象嵌套位置。</p><h2 id="4669" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">内联堆栈</h2><p id="7bf0" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">为了理解发生了什么，我们通过一个更复杂的块(甚至比前面的更复杂)的解析逻辑来思考:</p><pre class="kq kr ks kt gt ni ko nj nk aw nl bi"><span id="01a3" class="mu ls iq ko b gy nm nn l no np">This is a text block **with bold *and cursive*** text.</span></pre><p id="1ee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应该映射以下结构:</p><pre class="kq kr ks kt gt ni ko nj nk aw nl bi"><span id="cee8" class="mu ls iq ko b gy nm nn l no np">.paragraph(nodes: [<br/>    .text("This is a text block"),<br/>    .bold("with bold"),<br/>    .boldCursive("and cursive"),<br/>    .text(" text.")<br/>]),</span></pre><p id="f726" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们的片段解析算法将如下工作:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6f14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，这是伪代码，应该只帮助理解发生了什么。</p><p id="67a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在看看下面这个略有不同的例子:</p><pre class="kq kr ks kt gt ni ko nj nk aw nl bi"><span id="a860" class="mu ls iq ko b gy nm nn l no np">This is a text block **with bold *and none cursive** text.</span></pre><p id="2f2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">删除最后一个星号后，解析后的结构看起来会有点不同:</p><pre class="kq kr ks kt gt ni ko nj nk aw nl bi"><span id="b8ec" class="mu ls iq ko b gy nm nn l no np">.paragraph(nodes: [<br/>    .text("This is a text block"),<br/>    .bold("with bold *and none cursive"),<br/>    .text(" text.")<br/>]),</span></pre><p id="da88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，这也取决于我们的解析器，因为下面的输出也可能是有效的:</p><pre class="kq kr ks kt gt ni ko nj nk aw nl bi"><span id="1e70" class="mu ls iq ko b gy nm nn l no np">.paragraph(nodes: [<br/>    .text("This is a text block *"),<br/>    .cursive("with bold "),<br/>    .text("and none cursive"),<br/>    .cursive(""),<br/>    .text(" text."),<br/>]),</span></pre><p id="fd20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个你必须做出的软件设计决定。如果你想知道我是如何实现的，请查看GitHub上的<a class="ae lc" href="https://github.com/techprimate/CoolDown/blob/main/Tests/CoolDownParserTests/BoldCursiveInlineSpec.swift" rel="noopener ugc nofollow" target="_blank">boldcursiveinlinespec . swift</a>的冷却时间。</p><p id="6a83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为跟踪嵌套的一种有效方式，我决定使用一个堆栈，它在开始字符(比如<code class="fe kl km kn ko b">**</code>)上添加一个额外的节点，并在找到结束字符时将它从堆栈中移除。</p><p id="2cba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了不进一步增加本教程的复杂性，我将不讨论堆栈机制的确切实现。如果你现在想了解更多，<a class="ae lc" href="https://github.com/techprimate/CoolDown" rel="noopener ugc nofollow" target="_blank">冷却</a>评论的很好。</p><h2 id="e655" class="mu ls iq bd lt mv mw dn lx mx my dp mb jy mz na mf kc nb nc mj kg nd ne mn nf bi translated">完成我们的解析器</h2><p id="271a" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">好了，这是本教程范围的最后一个<code class="fe kl km kn ko b">FragmentParser</code>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f18d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码被注释了，所以它应该是不言自明的。在这个例子中，你也可以看到为什么我们的<code class="fe kl km kn ko b">FragmentLexer</code>有额外的<code class="fe kl km kn ko b">peak</code>和<code class="fe kl km kn ko b">rewind</code>方法。</p><p id="b286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您再次运行测试用例时，它们仍然会失败，结果如下:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6fe0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对将两个块合并成一个块感到满意，做得好，改变测试，你就完成了😄</p><p id="b96b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有，改变<code class="fe kl km kn ko b">MarkdownParser.parse()</code>方法，将每个块的节点分组，如果发现不止一个块，它将把它们包装在段落节点中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="02f3" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="f62c" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">你成功了！祝贺你🥳</p><p id="e32b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程只涵盖了使用和解析Markdown的一小部分可能性。显然，这三个测试不足以转换实现的功能，所以请确保编写更多的测试！</p><p id="0393" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还多次引用了我们的自定义解析器@ techprimate，名为CoolDown，它仍在开发中，但最终会投入生产。我们决定将其构建为一个开源的Swift包，所以检查一下<a class="ae lc" href="https://github.com/techprimate/CoolDown" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><p id="860f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了实际编写一个小的工作解析器之外，您还对文档格式本身有了更多的了解。现在，您应该能够从那里开始学习，并继续研究解析器。</p><p id="438b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想了解更多，请查看我的其他文章，在<a class="ae lc" href="https://twitter.com/philprimes" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，并随时给我发短信。<br/>你有具体的话题想让我报道吗？让我知道！😃</p></div></div>    
</body>
</html>