<html>
<head>
<title>Let’s Play with (Meta)Compilers — Designing an Automated Scanner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来玩玩(元)编译器——设计一个自动化的扫描器</h1>
<blockquote>原文：<a href="https://itnext.io/lets-play-with-meta-compilers-designing-an-automated-scanner-2ffe2e0e609c?source=collection_archive---------3-----------------------#2021-08-08">https://itnext.io/lets-play-with-meta-compilers-designing-an-automated-scanner-2ffe2e0e609c?source=collection_archive---------3-----------------------#2021-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b5f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和其他可怕的事情…😨</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/f857336bb43837f7320923afec7a44f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*oI2te2d-g8txaOU8vSxN5Q.jpeg"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">就像做蛋糕一样…但也不尽然</figcaption></figure><p id="b124" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我能告诉你什么读者，文件系统不能吸引我的想象力，编译器只是为我做的。说真的，我去年花了大部分时间试图做一个。这是一个有趣的项目，但我最终失败了，因为编译器是非常重理论的，你真的需要进入一个清晰而简洁的计划。</p><p id="ba6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我没有一个清晰简洁的计划，有点不知道自己在说什么或做什么。当我最终鼓起勇气访问r/Compilers subredit并询问我一直在纠结的问题时，这一点变得很明显。</p><p id="a8cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">读者们，编译器在理论上是如此的密集，以至于当谈论某些你正在纠结的事情时，你很快就会意识到用CompSci speak说话是真正通过这些部分的最好方法。您经常会看到来自多个编译器开发人员的不同代码体，它们看起来非常不同，但当以行话的形式向任何阅读它们的人讲述时，它们立刻就有了意义。起初，这确实令人望而生畏；努力了解扫描、解析和词法分析之间的区别，以及抽象语法树生成规则对于某些语言和语法是如何工作的，您不可避免会错过的东西几乎是无穷无尽的。</p><p id="ba9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我很自然地认为这是一个挑战，并决定尝试打破所有这些东西，所以也许有一天当时间旅行成为一件事时，我会给过去的自己发一条信息，也许她第一次尝试就不会那么痛苦了。</p><p id="0640" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一件值得一提的重要事情是，我的理论计算机科学知识来之不易，因为我被迫在真空中自学这些东西；一半是因为我害怕开放的互联网，一半是因为我害怕索要资料，一半是因为我选择了错误的书籍来开始，通常是从一些超出我基本技能的跳跃式发展开始。</p><p id="5643" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，这个新的文章系列(是的，我们又做了一次！)，我将进入我已经工作了几个星期的定制编译器生成器的设计和实现。你会问什么是编译器生成器？嗯，这就像如果你把Lex，Yacc和协议缓冲区融合在一起，最终会得到无限糟糕和畸形的东西，如果你把它涂在吐司上，味道可能会很差，或者至少我的可能会很差😄。我保证，我们一会儿会谈到这个😅</p><p id="4733" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总而言之，这是我给自己的最大的技术挑战，公开谈论它也将有助于检查自己，并确保我掌握这些东西，如果我能让它有意义，如果比我更好的编译器开发人员能审查我的工作。</p><p id="a7dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事不宜迟，让我们开始吧！</p><h2 id="9edd" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">到底什么是编译器生成器</strong></h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/1bc685c4b65d922842f3ec916eb54339.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*303_fDrnJJ3FQBCIXjyE0Q.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">我怎么又来了…？😵</figcaption></figure><p id="0f17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始之前，我发现某种术语表可能是有价值的。我发现自己被我一直在使用的术语绊倒了，却没有机会用一种不打断这篇相当密集的文章的方式来解释它们。因此，在我们开始讨论肉和土豆之前，这里有一些有用的术语需要了解。</p><ul class=""><li id="9185" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated"><strong class="jp ir">确定性有限自动机(DFA) </strong> —这是模式匹配的科学。从概念上讲，这些是有向图，其节点称为状态。当根据特定的DFA模式对字符串进行分析和检查时，字符串中的每个字符都在DFA中的每个点进行评估，如果当前状态接受当前字符，则在DFA中会遍历新的状态。这个过程重复进行，直到输入字符串用尽；如果字符串的最后一个字符没有结束于接受状态，则该模式将被DFA拒绝。</li></ul><p id="f86d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例DFA:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/26a9540e4f62c4624ef885dd47e6c895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*uZ1UlbHuS63PQaKGeYmv6A.jpeg"/></div></figure><p id="4f78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上面的DFA为例，最终状态(最右边的双圈)是接受状态。状态<code class="fe mb mc md me b">a</code>是我们的开始状态。我们在状态<code class="fe mb mc md me b">a</code>中的转换告诉我们，如果我们的下一个输入是<code class="fe mb mc md me b">0</code>，那么我们停留在状态<code class="fe mb mc md me b">a</code>，如果是<code class="fe mb mc md me b">1</code>，我们将遍历到状态<code class="fe mb mc md me b">b</code>。观察这种模式，我们可以猜测无论字符串最终是什么，所有可接受的字符串都以<code class="fe mb mc md me b">10</code>或<code class="fe mb mc md me b">000</code>结尾。自动机理论很难理解，但是对于本文来说，这个基本的理解就足够了。</p><ul class=""><li id="6dcb" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">Lex  —这是一个用于自动生成扫描仪的工具，也是这个项目的灵感来源。它也为它的扫描器生成器使用一个规范文件，并且专门生成C代码，当进一步编译时，创建您的标记器。可以在这里详细了解:<a class="ae mf" href="https://en.wikipedia.org/wiki/Lex_(software)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Lex _(软件)</a></li><li id="8103" class="lr ls iq jp b jq mg ju mh jy mi kc mj kg mk kk lw lx ly lz bi translated"><strong class="jp ir"> Regex </strong> —正则表达式；这是一种指定要搜索的字符串模式的字符和符号格式。在这个项目中，它被用来替代代码中的DFA实现。DFA可以转换成正则表达式，反之亦然。</li><li id="8c5d" class="lr ls iq jp b jq mg ju mh jy mi kc mj kg mk kk lw lx ly lz bi translated"><strong class="jp ir">抽象语法树(ASTs) </strong> —一种以特定方式布局的令牌的树状结构，在评估编程语言的语义(或其“含义”)时展示优先顺序。这将不会被涵盖，但我的名字下降，现在，然后😅。</li></ul><p id="e8ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译器生成器或<em class="ml">元编译器</em>背后的想法是，能够为任何一种语言编写规范，将其传递给生成器，就创建了该语言的编译器。很酷，对吧？</p><p id="b359" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">失败的可能性几乎是无穷无尽的。</p><p id="b462" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的元编译器项目将被分成三个主要部分，只要每个部分的输出格式与下一个部分的输入格式相匹配，这些部分就可以单独工作。编译器已经有了这种结构，但是我们将通过自动生成这些组件来更进一步。</p><p id="e5af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这三个部分是:</p><ul class=""><li id="a398" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated"><strong class="jp ir">前端</strong> —编译器的一部分，负责接收源代码，根据语言规范验证标记的语义正确性，并将输出(有时作为抽象语法树)发送到下一层。</li><li id="d2d3" class="lr ls iq jp b jq mg ju mh jy mi kc mj kg mk kk lw lx ly lz bi translated"><strong class="jp ir">中间件</strong> —该部分负责中间代码的生成；这段代码是一种类似汇编指令的伪代码，与任何真正的汇编语言或体系结构完全无关。这让您对最终的程序集输出有了一个概念，并在不依赖于架构的情况下进行优化。如果优化过程很复杂，这个步骤可以由多个层叠的子步骤组成。</li><li id="88a2" class="lr ls iq jp b jq mg ju mh jy mi kc mj kg mk kk lw lx ly lz bi translated"><strong class="jp ir">后端</strong>——这是我们将中间代码转换成目标机器的本机汇编以供实际执行或进一步编译成目标代码，然后再编译成可执行文件的部分，无论哪种情况都可以。</li></ul><p id="0436" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们将在接下来的几个月里试图构建的东西。</p><p id="7e91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:有些人发现使用“前端”这个词来描述编译器(看起来很像后端)会让人混淆。这个术语有时被用来描述一个具有多层的大型系统的“前端”部分——这只是我本周在工作中学到的一个有趣的事实。</p><p id="a78a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，让我们先谈谈我们要做什么。</p><h2 id="d602" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">前端——让我们做一个扫描仪</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/33f6f645870a578302306c8413ff0d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3s1959tbNLd7tXxQXdZf4A.jpeg"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">看到了吗？有趣是因为…它是HTML…因为前端…😶</figcaption></figure><p id="4dc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，首先，扫描仪。我们将制作一个扫描器，它可以接收一个规范文件和一个或多个源文件，并使用我们在该规范文件中指定的规则来标记源代码；将语言中的每个有效“单词”转换成单个标记。如果你熟悉<code class="fe mb mc md me b">lex</code>，那么你可能会明白我在这里要说的一点点。</p><p id="b1c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令牌可以是任何东西，从单个字符如<code class="fe mb mc md me b">=</code>或<code class="fe mb mc md me b">a</code>到整个字符串如<code class="fe mb mc md me b">"hello world"</code>。每个令牌由两个值分类；其<em class="ml">文字值</em>及其<em class="ml">类型</em>；所以令牌<code class="fe mb mc md me b">"hello world"</code>的字面值是<code class="fe mb mc md me b">"hello world"</code>，其类型是a <code class="fe mb mc md me b">STRING</code>或a <code class="fe mb mc md me b">LITERAL</code>，令牌<code class="fe mb mc md me b">+</code>的值是<code class="fe mb mc md me b">+</code>，其类型是<code class="fe mb mc md me b">PLUS</code>，以此类推。</p><p id="65ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几组特殊的令牌被归类为<code class="fe mb mc md me b">RESERVED</code>。这些是该语言专门用于其功能、特性和结构的词。考虑大多数语言中单词之间的差异；<code class="fe mb mc md me b">if</code>、<code class="fe mb mc md me b">while</code>和<code class="fe mb mc md me b">for</code>以及<code class="fe mb mc md me b">_x</code>、<code class="fe mb mc md me b">hello42</code>和<code class="fe mb mc md me b">this_is_a_function</code>字样。前者通常用于功能性(分别用于if语句、while和for循环)，而后者用于变量和/或函数名。前者令牌将具有单一类型，例如<code class="fe mb mc md me b">RESERVED</code>或<code class="fe mb mc md me b">KEYWORD</code>，而后者将被分类为<code class="fe mb mc md me b">IDENTIFIERS</code>。</p><p id="fcce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:有时你可以给每个关键字一个独特的类型；如<code class="fe mb mc md me b">if</code>为<code class="fe mb mc md me b">IF</code>型，而<code class="fe mb mc md me b">WHILE</code>型。如果您的编译器的后续部分需要这种级别的清晰度，那么这没有什么坏处，但是建议将所有不重要的字母数字标记都放在一个类型下，如<code class="fe mb mc md me b">ID</code>或<code class="fe mb mc md me b">IDENTIFIER</code>，因为尽管命名不同，它们通常会遵循相同的规则集。我经常这样做，因为害怕仅仅用<code class="fe mb mc md me b">KEYWORD</code>来代表不同的价值观会产生歧义，而这些价值观会做不同的事情来反咬我一口。</p><p id="8029" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，简单的介绍结束了，让我们来谈谈我们将采取什么样的过程来自动生成我们想要的任何东西的扫描仪。</p><p id="aba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用的方法依赖于编译器理论中称为<strong class="jp ir">表驱动扫描</strong>的概念。</p><h2 id="9076" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">但是什么是表格驱动扫描呢？</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mr"><img src="../Images/bd4618658ce0a29cf0bff69eb48be060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HVgQcEUehiAt7NfhGII7aw.jpeg"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">当你坐在高档餐桌旁时，咖啡总是更好喝，☕️😁</figcaption></figure><p id="8fc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">表格驱动扫描仪是三种常见的扫描仪开发方法之一(另外两种是直接编码扫描仪和手动编码扫描仪)。这种方法利用了三个内存中的表，并在其中存储了成功扫描目标语言所需的所有信息。这种方法看起来很不受欢迎，因为内存中的所有数据都存在缓存访问问题，但它非常适合我们的需求，尽管我最终可能会以某种方式为此付出代价。这种方法依赖于预先确定的表，表中有解析目标语言所需的所有规则和信息。我们的spec文件将被设计成适合这些表，尽管会做一些修改，使它在代码和正则表达式方面更容易一些。</p><p id="3797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顾名思义，这种类型的扫描依赖于表格的使用；准确地说是三个；一个存储用于处理我们的语言的所有DFA(DFA表)，另一个用于将标记值与它们的标记类型配对(标记表)，另一个用于识别和分类输入中的字符类型(分类器表)；比如说<code class="fe mb mc md me b">a-zA-Z</code>是<code class="fe mb mc md me b">alphabetic</code>和<code class="fe mb mc md me b">0-9</code>是<code class="fe mb mc md me b">digits</code>。在我们的实现中，我们将把最后一个表扔掉，因为它本身不需要成为一个表。</p><p id="3cc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">表格驱动扫描的基本算法如下所示:</p><pre class="km kn ko kp gt ms me mt mu aw mv bi"><span id="21b9" class="kx ky iq me b gy mw mx l my mz">tables = initTables()<br/>acceptedStates = stack()</span><span id="c097" class="kx ky iq me b gy na mx l my mz">currentToken = ""<br/>while c = NextChar(){<br/>   if c == EOL<br/>      break<br/>   <br/>   currentToken.append(c)<br/>   if tables.DFA_match(currentToken) is true {<br/>      push currentToken to acceptedStates<br/>   else if tables.DFA_match(currentToken) is false {<br/>      if acceptedState is not empty<br/>          currentToken = acceptedStates.pop()<br/>          c = rollBack() input to last accepted state<br/>          break<br/>      else<br/>          return error</span><span id="efec" class="kx ky iq me b gy na mx l my mz">if currentToken in tables.tokenTypes <br/>    return token value and token type<br/>else<br/>    return invalid token error</span></pre><p id="3bca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这基本上概括了表驱动扫描概念背后的思想；依靠访问保存在表格中的信息来帮助我们的扫描仪做出决策。</p><p id="1850" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将这样做，但需要对算法进行一些修改，以满足我们的定制需求。</p><h2 id="ce84" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">我们经过大量修改的版本</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/36bb389582e02402d1483cd3058cc951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*r8RVqQQxj5X-mm4k19Pdgg.gif"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">改装！太好了。！💥</figcaption></figure><p id="0829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的将在循环实现和回滚方面使用相同的前提，除了<code class="fe mb mc md me b">DFA_table</code>将只是一个接受正则表达式的字典(一个正则表达式表，如果你愿意的话)；键是正则表达式模式，值是正则表达式模式的标识符。我们将DFA表和分类器表合并成一个更好的修改过的AWESOME Regex表！太好了。！</p><p id="3051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将添加的唯一附加表是一个调整版的Regex表，例外的是这个表被设计为使用分隔模式的Regex所以一张餐桌。这个额外的表对于处理像正则表达式匹配字符串和注释这样的事情似乎是必要的；令牌开头的<code class="fe mb mc md me b">"</code>通过接受任何和所有字符来改变正则表达式模式匹配的规则，忽略所有其他匹配模式，直到它看到另一个<code class="fe mb mc md me b">"</code>。我把它做成一个单独的表，因为当我试图把它和其他单标记正则表达式模式放在一起时，它最终做了一些非常不可靠的事情。</p><p id="fd66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将为所有令牌类型添加一个令牌表。</p><p id="9eaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和我们的三个表决定；regexes、delims和token类型，我们设置的最后一个难题是讨论我要实现的东西，当然还有spec文件看起来会是什么样子。</p><h2 id="a03c" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">路到此为止</strong></h2><p id="7f6f" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">我将把代码实现留到另一篇文章中，因为要解包的内容太多了，但是我将在这里展示一些伪代码，一个工作规范文件😃。</p><p id="6b1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">伪代码</strong></p><p id="a281" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事情是这样的</p><pre class="km kn ko kp gt ms me mt mu aw mv bi"><span id="b8c0" class="kx ky iq me b gy mw mx l my mz">savedTokens = tokenList()<br/>tables = tables()<br/>sourceCode = ""<br/>acceptedState = stack()<br/></span><span id="840d" class="kx ky iq me b gy na mx l my mz">function scanner() <br/>    tables = createFromSpecFile(specFile)<br/>    sourecCode = readSourceFiles()<br/>    <br/>    while sourceCode not at EOF<br/>        scan()<br/>        </span><span id="d61f" class="kx ky iq me b gy na mx l my mz">function scan()<br/>    currentToken = ""<br/>    while c = nextChar()<br/>        if c == EOF {<br/>           break        <br/>        }<br/>        currentToken += c<br/>        if currentToken in tables.Regex_table<br/>           save currentToken and c position in acceptedState<br/>        else <br/>           if acceptedState not empty<br/>              currentToken, c = acceptedState.pop()<br/>              break<br/>          else<br/>              return error</span><span id="20b7" class="kx ky iq me b gy na mx l my mz">    if currentToken not in tables.Tokentype<br/>       return error<br/>    else<br/>       savedTokens.add(currentToken, tables.Tokentype[currentToken])</span><span id="f1c2" class="kx ky iq me b gy na mx l my mz"><br/>scanner()</span></pre><p id="6874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这几乎是表驱动扫描中使用的方法的精确复制/粘贴，但魔鬼在管理表和使用正则表达式和函数来模拟DFA遍历的细节，但在其他时间更多。😅</p><p id="9114" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">减去许多血淋淋的细节，我的实现看起来像这样，但在去。</p><p id="856b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">规格文件</strong></p><p id="519f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">程序获取的规范文件格式如下。</p><pre class="km kn ko kp gt ms me mt mu aw mv bi"><span id="c59e" class="kx ky iq me b gy mw mx l my mz"># classifiers<br/>[classifier tokens go here]<br/>%%<br/># delims<br/>[delim tokens here]<br/>%%<br/># tokenTypes<br/>[and token types here</span></pre><p id="e974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很快，就像变魔术一样，我们准备好了我们的规格格式。让我们来看看如果我们指定C语言会是什么样子；</p><pre class="km kn ko kp gt ms me mt mu aw mv bi"><span id="88c1" class="kx ky iq me b gy mw mx l my mz"># Classifier<br/><br/>alphabet    [_a-zA-Z]<br/>digit       [0-9]<br/>number      {digit}+<br/>newline     %NEWLINE<br/>word        {alphabet}({alphabet}|{digit})*<br/>symbols     [-+/\*&amp;!\|\{\}=&gt;&lt;:^;,]<br/>equ         ([+-/=*!&amp;\|]|((&gt;)?&gt;)|((&lt;)?&lt;))?=<br/>left        (&lt;)?&lt;<br/>right       (&gt;)?&gt;<br/>brackets    [\[\]\(\)]<br/>comment     //.*{newline}<br/>mcomment    /\*.*\*/<br/>float       [0-9]+((\.[0-9]*)|e((\+|-)?[0-9]+))<br/>hex         0[xX][a-fA-Z0-9]+<br/>string      ".*"<br/>char        '[(\')(\t)(\n)]|(.*)'<br/>arrow       -&gt;<br/><br/>%%<br/><br/># Delim<br/>'     {char}<br/>"     {string}<br/>//    {comment}<br/>/\*   {mcomment}<br/><br/>%%<br/><br/># TokenType<br/><br/>{string}    STRING<br/>{number}    INTEGER<br/>{word}      ID<br/>{char}      CH<br/>char        CHAR<br/>int         INT<br/>long        LONG<br/>void        VOID<br/>unsigned    UNSIGNED<br/>*           STAR<br/>...</span></pre><p id="fa44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">x86汇编怎么样(反正是OSX版)</p><pre class="km kn ko kp gt ms me mt mu aw mv bi"><span id="0e40" class="kx ky iq me b gy mw mx l my mz"># Classifiers</span><span id="9a2c" class="kx ky iq me b gy na mx l my mz">alphabet   [_a-zA-Z]<br/>digit      [0-9]<br/>number     {digit}+<br/>hex        {digit}+h<br/>word       {alphabet}({alphabet}|{digit})*<br/>label      _{alphabet}({alphabet}|{digit})*:<br/>colon      :<br/>newline    %NEWLINE<br/>comma      ,<br/>brackets   [\[\]]<br/>space      %SPACE<br/>gen_regs   [er][abcd]x<br/>small_regs [abcd][lhx]<br/>push       push(a)?<br/>pop        pop(a)?<br/>hex        0[xX][a-fA-F0-9]+<br/>comment    ;.*{newline}<br/>string     ".*"<br/>char       '.*'</span><span id="9bb7" class="kx ky iq me b gy na mx l my mz">%%<br/># delim</span><span id="0f2f" class="kx ky iq me b gy na mx l my mz">;      {comment}<br/>"      {string}<br/>'      {char}<br/>0[xX]  {hex}</span><span id="fae4" class="kx ky iq me b gy na mx l my mz">%%<br/># tokenType</span><span id="65b8" class="kx ky iq me b gy na mx l my mz">{string}  STRING<br/>{word}    ID<br/>section   SECTION<br/>extern    EXTERN<br/>include   INCLUDE<br/>_data     DATA<br/>_text     TEXT<br/>_bss      BSS<br/>db        DB<br/>dq        DQ<br/>dw        DW<br/>mov       MOV<br/>cmp       CMP<br/>rax       GREG64<br/>rbx       GREG64<br/>rcx       GREG64<br/>rdx       GREG64<br/>eax       GREG32<br/>ebx       GREG32<br/>ecx       GREG32<br/>edx       GREG32<br/>ax        GREG16<br/>bx        GREG16<br/>cx        GREG16<br/>dx        GREG16<br/>al        GREG8<br/>ah        GREG8<br/>bl        GREG8<br/>bh        GREG8<br/>cl        GREG8<br/>ch        GREG8<br/>dl        GREG8<br/>dh        GREG8<br/>push      PUSH<br/>pop       POP<br/>pusha     PUSHA<br/>,         COLON<br/>popa      POPA<br/>int       INT<br/>[         OPENBRACKET<br/>]         CLOSEBRACKET</span></pre><p id="1886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它在一个由3个部分组成的文件中接受一个可接受标记的规范，这3个部分由一个<code class="fe mb mc md me b">&amp;&amp;</code>分隔，每个部分都在它指定的表中(分类器用于我们的regex表)。</p><p id="19c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将为我们的生成器添加一个<code class="fe mb mc md me b">config</code>文件，因为我已经预见到未来对各种配置的需求。</p><p id="5bf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，它只有一条线</p><pre class="km kn ko kp gt ms me mt mu aw mv bi"><span id="acf4" class="kx ky iq me b gy mw mx l my mz">spec:{specfile name}</span></pre><p id="585b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它已经被设置为解析语言。</p><p id="312b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这里有一个扫描仪工作版本的快速演示</p><p id="3ca8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑:所以我在录制后才发现，当我使用<code class="fe mb mc md me b">asciinema</code>时，演示并没有记录我的鼠标滚动，所以有很多…不动作，那些空隙是我滚动的。但是在这篇文章之后，您可以随意尝试一下；项目链接在文末。在我的回购的自述中还有一个更清晰的版本😓</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">很抱歉质量不好，我的Github上有更好的😭</figcaption></figure><p id="3f78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们所在的地方！😄。</p><p id="b351" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢这篇文章，我希望它是可以理解的。我在测试我翻译复杂的计算机科学材料的能力。如果你在我的信息中发现任何不准确的地方，请让我知道，这样我可以快速编辑。我将在后面的文章中详细介绍我的代码实现，因为它非常多，而且在我计划项目的后续部分时，我会不断地清理和改进它。</p><p id="096f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我添加的一个小特性是init代码，它将在新创建的spec文件中生成默认的正则表达式，因为它们可能会令人望而生畏，并且在许多语言中也是相似的。</p><p id="ece8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我知道你对我的项目的看法。你可以在这里查看。</p><div class="nj nk gp gr nl nm"><a href="https://github.com/AlysonBee/CompilerGenerator" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">GitHub-alyson bee/compiler generator:我当前编译器项目的报告</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">这个回购的目的是存储我目前的中型项目的所有代码。这个项目，目前名为…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa kr nm"/></div></div></a></div><p id="b86a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，还有激发这一切的那本书:<a class="ae mf" href="https://www.amazon.com/Engineering-Compiler-Keith-Cooper/dp/012088478X" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . com/Engineering-Compiler-Keith-Cooper/DP/012088478 x</a></p><p id="7f72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快乐阅读！👋</p><p id="ea7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阿利松</p></div></div>    
</body>
</html>