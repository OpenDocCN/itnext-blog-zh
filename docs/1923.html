<html>
<head>
<title>Redux-Observable without Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux-没有Redux的可观察</h1>
<blockquote>原文：<a href="https://itnext.io/redux-observable-without-redux-ff4a2b5a4b39?source=collection_archive---------5-----------------------#2019-02-24">https://itnext.io/redux-observable-without-redux-ff4a2b5a4b39?source=collection_archive---------5-----------------------#2019-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/df69e74a4d3c23663f4479572b737715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4_rhSBLQBMFy7K0B"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Gabriel Matula 在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><div class=""><h2 id="9e1c" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">用Redux-Observable编写无状态浏览器插件</h2></div><p id="7901" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">就像</em> <a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/pointlessly-writing-redux-in-lua-b64894e8ede5"> <em class="lr">为什么我用Lua </em> </a> <em class="lr">写Redux一样，我把这篇文章从头到尾写成了一个故事，这样你就可以了解我是如何在没有Redux的情况下使用Redux-Observable的，以及它是如何解决一个特定于我所处情况的业务问题的。</em></p><p id="03a0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">虽然这听起来可能是一个复杂的想法，但我强烈推荐使用Redux-Observable，或者一个类似的风格，因为它确实有助于代码的可维护性，弄清楚动作和消息的流程，并使调试变得非常容易。</em></p><h1 id="1272" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">历史</h1><p id="a2a3" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">早在11月，我就开始了一项兼职工作，开始编写一个浏览器插件。虽然我在过去写了一个非常简单的程序，并事先做了一些研究，但直到我开始使用它时，我才意识到共享的信息是有限的，这也很奇怪，因为有这么多的浏览器插件，而且大部分都是JavaScript、CSS和HTML。</p><p id="92a9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最初，他们想让我派生出另一个开源项目，但是在评估了我们的选择并尝试了一会儿之后，我们决定从头开始构建一个。</p><h1 id="9fb1" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">从头开始</h1><p id="f731" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我习惯于从每个项目开始，用配置文件写出一个构建系统，然后从那里开始。我做过的几乎每个项目都是这样开始的，但是因为我是按小时计酬的，并且只能在业余时间工作，所以我不得不使用现有的解决方案。</p><p id="fae6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在网上搜索了几个小时后，在<a class="ae jd" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>上几乎什么也没找到，没有信息的文章，以及一些分散的npm项目，我登陆了<a class="ae jd" href="https://github.com/suevalov/create-react-chrome-extension" rel="noopener ugc nofollow" target="_blank">create-react-chrome-extension</a>。谢天谢地，我得到了使用React的许可，因为编写HTML和vanilla JS最终会让我编写一些节省时间的框架。</p><p id="5729" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这个create-react-chrome-extension的细节并不重要，但它为我提供了类似的创建-react-app的体验，并帮助我开始使用。快进到今天，我将编写自己的系统，但这是一个奇妙的起点:)。</p><h1 id="3a1a" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">信息系统</h1><p id="98f7" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">虽然Redux-Observable是我在RxJS上使用过的最好的消息系统，但是它有一个巨大的需求:Redux。我签约的公司不是一家网络公司，所以复杂的JS是一个禁忌。虽然Redux很简单，但它需要很多知识，RxJS也是如此，然后Redux-Observable是最重要的。我继续使用函数式编程，在此基础上增加更多的复杂性对于任何非web人员来说都是有害的；即使是一个经验丰富的浏览器插件开发人员也会很纠结。</p><p id="68e3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我原本计划只工作几个月，所以在某些时候，我不得不把这些代码交给另一个开发人员。由于我在一个紧张的期限内工作，并且希望尽快得到一些可交付的东西，我开始直接用普通的JS来处理<code class="fe mp mq mr ms b">background.js</code>中的业务逻辑。</p><p id="5976" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可悲的是，这最终是一个糟糕的选择。当然，我有一些工作很快的东西，但是浏览器插件；至少那些使用web标准的(looking ' in you Safari)是完全基于消息的，大量使用回调。它看起来越来越像Redux-Observable一直是正确的选择，但是由于该插件实际上是无状态的——使用本地存储并将转换后的AJAX响应直接传递给其他特定于插件的函数——它没有意义。</p><h1 id="8444" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">添加RxJS</h1><p id="08aa" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">接下来我做的就是介绍RxJS。没过多久，这一堆复杂的回调逻辑就需要某种转换层了。如果你读了我关于用转换器加速JavaScript数组 <a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/using-transducers-to-speed-up-javascript-arrays-92677d000096">的文章，这就是需要转换器的插件。关于</a><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/handling-cache-and-ajax-race-conditions-4cb152db8764">处理缓存和AJAX竞争条件</a>的文章也是因为这个向RxJS的特殊转变而受到刺激。</p><p id="4427" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">没有进入太多的细节，我很快发现使用RxJS本身是不够的。我需要在它的基础上开发一个消息传递系统，使代码更容易使用。尽管如此，我还是不想引入Redux或Redux-Observable，因为这些库的重量加上它们引入的代码复杂性对于这个简单的浏览器插件来说太大了。</p><p id="8f81" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为RxJS主题是消息传递的门户，既是观察者又是被观察对象，所以我创建了相当多的主题，然后用这些主题加载了我的<code class="fe mp mq mr ms b">background.js</code>文件:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="6eeb" class="nb lt jg ms b gy nc nd l ne nf">someDataFromLocalStorage$<br/>.subscribe()</span><span id="68a2" class="nb lt jg ms b gy ng nd l ne nf">someOtherDataList$<br/>.subscribe(someMessage$)</span></pre><p id="948a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">试图弄清楚一个主题从哪里开始，另一个主题从哪里结束，很快变得很难。这几乎就像是我在命令式地写作；传递函数以在其他函数完成处理后调用。这比根本不用它更糟糕！</p><p id="203d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更重要的是，一些API使用实际上可以接受同步返回值的回调，而其他API发送一个响应消息的回调。虽然后者很容易管理，但前者不是由RxJS的<code class="fe mp mq mr ms b">fromEventPattern</code>自然处理的。我必须创建一些东西来发送预期的参数和同步回调函数来管理这个用例。这个解决方案要复杂得多，但是由于RxJS的可组合性，它完全是一个黑盒，应该是未来文章的主题。</p><h1 id="0ef1" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">Redux-没有Redux的可观察</h1><p id="2a4c" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">好消息来了，对吧？</p><p id="b008" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在没有Redux-Observable的情况下，我已经创建了一个Redux兼容的<code class="fe mp mq mr ms b">actions.js</code>文件来帮助判断插件的各个部分之间正在发送什么样的消息。这是我意识到我应该为应用程序的其余部分做类似的事情的地方，因为所有那些在<code class="fe mp mq mr ms b">background.js</code>管理的订阅都太复杂了。</p><p id="b094" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我已经在应用程序的一部分中有了一个Redux兼容的系统，所以我认为利用我对其API的了解来编写Redux-Observable的简化版本不会太难。</p><p id="5759" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一件事是创建一个<code class="fe mp mq mr ms b">action$</code>主题，然后通过编写RxJS的<code class="fe mp mq mr ms b">filter</code>操作符来编写我自己的<code class="fe mp mq mr ms b">ofType</code>。</p><p id="39e8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很简单:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="cb0f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在测试了一段时间后，我注意到如果遇到错误的话,<code class="fe mp mq mr ms b">ofType</code>会导致整个插件死亡。为什么？不知道，但我不会让这阻止我。我创建了一个单独的用于本地调试的<code class="fe mp mq mr ms b">actionLoggerEpic</code>,并将我的不正确动作错误处理程序放在那里。然后我让<code class="fe mp mq mr ms b">ofType</code>有弹性:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c1d1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然我可以将所有的逻辑放在一个<code class="fe mp mq mr ms b">filter</code>中，但我选择使用3，因为它更符合每个<code class="fe mp mq mr ms b">filter</code>执行一个简单任务的情况。我还发现它更容易阅读。</p><p id="e039" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在对于好的东西，我需要一些方法来创建一个根史诗，然后订阅<code class="fe mp mq mr ms b">action$</code>主题。可悲的是，我做了件蠢事:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="06b4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是可行的，但完全是愚蠢的。反正我没有正确使用<code class="fe mp mq mr ms b">combineEpics</code>，这非常难读。现在看这个，对自己挺失望的。我想“哦，是的，Redux-Observable有<code class="fe mp mq mr ms b">combineEpics</code>和<code class="fe mp mq mr ms b">createRootEpic</code>。我真聪明！”。</p><p id="41a0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我非常快速地构建了这个解决方案，没有检查我的其他Redux-Observable项目或其源代码。事实上，我完全忘记了。我知道这很愚蠢。</p><p id="f2ce" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">没过多久，我就把它重构成了这样:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="dabc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唷！之前的修改让我很困扰，不去想它我很难入睡。</p><p id="e74f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">综上所述，这是您可以在自己的项目中使用的内容:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fa2e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个无状态的Redux-Observable，不需要Redux。看到这是多么简单后，我的大脑“轰”的一声。我不敢相信我一直在避免使用Redux-Observable，而实际上使用它是如此简单。</p><p id="2924" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在重写了整个插件以利用Redux-Observable之后，它变得容易多了，我能够通过简单地记录每个动作并在出错的地方抛出错误来快速调试问题。</p><p id="60c4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是<code class="fe mp mq mr ms b">actionLoggerEpic</code>的样子:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="edf5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还添加了一个黑名单，或者我称之为<code class="fe mp mq mr ms b">ignoreList</code>,用于隐藏记录太频繁的行为。</p><p id="0636" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还能够通过动作名称模块化所有东西，这修复了旧系统中可能出现的许多兔子洞调试。Redux-Observable就像尽可能把所有东西都移到左边，与回调-hell相反。</p><h1 id="26a4" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">结论</h1><p id="fbfd" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你熟悉Redux-Observable或者另一个消息系统，比如CQRS，我强烈建议你在异步应用中使用这些概念；尤其是像浏览器插件这样完全依赖异步发送消息的插件。</p><p id="e94c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在过去几周围绕Redux-Observable重新编写了插件之后，更快地获得可交付成果变得更加容易了。</p><h1 id="3c9f" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">更多阅读</h1><p id="5071" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你喜欢你所读的，你也应该检查我的其他文章；尤其是Redux上的那些:</p><ul class=""><li id="115f" class="nj nk jg kx b ky kz lb lc le nl li nm lm nn lq no np nq nr bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/using-redux-reducers-in-react-components-4e92985dd9cb">在React组件中使用Redux还原剂</a></li><li id="d972" class="nj nk jg kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a" rel="noopener">使用Redux的秘密:createNamespaceReducer </a></li><li id="7284" class="nj nk jg kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e" rel="noopener">为什么不需要React-Redux的“连接”</a></li><li id="c881" class="nj nk jg kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li></ul></div></div>    
</body>
</html>