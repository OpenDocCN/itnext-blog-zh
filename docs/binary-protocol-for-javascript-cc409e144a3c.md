# JavaScript 的二进制协议

> 原文：<https://itnext.io/binary-protocol-for-javascript-cc409e144a3c?source=collection_archive---------3----------------------->

![](img/3e72fbd2412028a2d557d799f06c6934.png)

拥有对 JSON 的本机支持是开发全栈 JavaScript 应用程序的乐趣之一。JSON 是简单的、无模式的、人类可读的——当我们的数据模型仍然易于变化时，这些特性在开发的早期阶段特别有用。然而，这种灵活性是以运行时的大小和处理开销为代价的。

JSON 是一种基于文本的格式，将所有值编码为 UTF-8，这导致在处理非文本数据时会产生大小开销。无模式意味着我们必须将数据模型的结构(例如对象键)和数据一起编码。我们在处理时也做了额外的工作，因为我们必须在编码之前将值转换为文本表示，在解析为 JSON 之前将二进制解码回文本。

诚然，这种开销对于一般的 web 应用程序来说不是问题；通过使用压缩和 JavaScript 引擎擅长解析 JSON，这个问题得到了缓解。然而，也有开销成问题的情况，例如压缩效率低，并且可能增加消息的大小，例如在收集遥测数据时交换小消息，在实时应用中交换数据，或者发送通知。为了解决 JSON 的这些限制，我们可以采用二进制格式。

# 二进制格式

在已建立的数据序列化格式 [](#568c) 中有过多的二进制格式，它们具有各种各样的属性。为了解决 JSON 的局限性，我们必须关注两个属性:a)它们是否基于模式，b)支持零拷贝操作。

与 JSON 相比，无模式二进制格式(如 MessagePack 或 FlexBuffers)的大小有所减小。这些格式的主要优点是，它们可以作为 JSON 的替代物，只需很少的工作。然而，a)我们仍然用数据对结构进行编码，因此有很大的开销，b)我们不能进行零拷贝操作。使用基于模式的格式，如协议缓冲区、FlatBuffers 或 Cap'n Proto，我们可以避免对消息中的结构信息进行编码，尽管以偏移指针的形式存在一些开销。

在这个上下文中，零拷贝操作意味着我们能够在不拷贝数据或解码整个消息的情况下查找部分消息。例如，在服务器上，我们可以先检查请求的重要部分，而不用解析整个请求体；在客户端，我们可以部分地解析和呈现大的响应，以最小化我们的 FCP [](#6073)时间。这意味着在某些情况下，处理时间可以减少几个数量级。在数据序列化格式中，Cap'n Proto 和 FlatBuffers 支持零拷贝操作，而协议缓冲区、JSON 和无模式格式不支持。然而，Cap'n Proto 和 FlatBuffers 都将内存访问速度优先于消息大小，由于数据对齐使用了填充，导致了大小开销。

# 带视图的原始缓冲区

为了实现零拷贝访问的最小化，我们可以使用所谓的原始缓冲区。例如，要对一个 JavaScript 对象进行编码，我们可以计算它的每个字段所需的大小，按顺序排列它们以导出布局模式，并使用它对 ArrayBuffer 中的字段进行编码。得到的缓冲区有“原始”数据，没有任何关于其结构的信息。我们可以对它进行整体解码，或者使用布局模式来访问单个字段，因为它对所有同类型的对象都是通用的。我们将需要可选和可变长度字段的指针，但是开销仍然远远小于键编码或数据对齐。

[structuraie 的 View](https://github.com/zandaqo/structurae#binary-protocol) 接口正是这样做的:给定一个对象(或数组，或任何支持的类型)的 JSON 模式，View 将计算布局模式，将其存储为原始缓冲区，并创建一个类来处理扩展 DataView 的缓冲区:

视图使用 JSON 模式进行模式定义。除了为开发人员所熟悉之外，使用 JSON 模式还允许在其他工具中重用模式，比如作为单一事实来源的 JSON 验证器。架构和所有派生类都是强类型的，以利用 ide 中的类型提示和智能感知。与其他流行的基于模式的格式不同，View 不需要预编译—布局在初始化时计算一次。总的来说，View 旨在很好地适应以 JSON 为中心的架构和现代 web 应用程序的开发工作流。

值得注意的是，View 的目标并不是在整个全栈 JavaScript 应用程序中取代 JSON。而是最大限度地提高应用程序部分的性能，通过使用零拷贝操作，可以大大减少消息大小并避免额外的解析步骤。我们可以在 JSON 做不到的所有情况下使用它:受益于二进制编码的大量数据、实时应用程序中或工作进程之间的高速消息交换，或者用于验证的部分消息处理。

# 完整堆栈示例

为了展示视图结构的作用，我们将使用一个熟悉的留言板例子；这不是使用二进制的最佳例子，但是更恰当的例子是特定领域的，很难理解。

想象一下，你正在维护戒酒联合会 [](#56a5) 当地分会的留言板。让我们定义我们的消息结构:

现在，在客户端，我们可以使用`MessageView`类对消息进行编码。由于它是一个数据视图，我们可以使用 Fetch API 直接将它作为请求体发送:

例如，在使用 Express.js 的服务器节点上，我们可以将消息作为缓冲区接收并对其进行操作，而无需解析或复制请求体:

例如，现在我们可以进行访问控制，检查消息作者是否可以在线程中发布消息，并拒绝未经授权的请求，而无需解析整个请求体:

从缓冲区读取一个数字比解析 JSON 快几个数量级，更不用说从长远来看减少了 GC 的负载。

在这个例子中，我们可以更进一步。该视图使用一个特殊的类 [StringView](https://github.com/zandaqo/structurae#strings) 来处理 UTF-8 编码的字符串，该类使用几个与字符串相关的方法来扩展 DataView，这些方法可以对编码的字符串进行操作，而无需将它们解码为 JavaScript 字符串。比方说，我们决定引入一点审查机制，屏蔽包含“zer b-vord”的消息:

使用`view.getView`，我们在缓冲区的一部分上实例化了一个 DataView(在本例中是一个 StringView ),而没有对该部分进行解码，然后使用一个方法在编码的数据内部进行搜索。同样，我们在解析无效请求方面节省了速度和 GC 压力。

最后，我们可以将消息解码成 JavaScript 对象。在这种情况下，由于我们在创建视图类时提供了构造函数类，所以我们把它放入了一个`BoardMessage`实例:

视图还利用了 JavaScript 引擎使用的隐藏类优化 [⁴](#0238) :视图不是创建一个空对象`{}`并用解码的字段填充它，而是使用一个提供的构造函数(如上例所示)或者为这样的构造函数生成代码，这样每个新对象都用相同数量和顺序的字段进行实例化。这使得对对象的操作速度更快，同时降低了 GC 压力。

因此，通过缩减消息大小、零拷贝零解析检查和序列化优化，我们极大地提高了主板的消息处理能力。让那些不务正业的狼人现在给我们发垃圾邮件吧！

1.  [数据序列化格式的比较](https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats)
2.  [第一幅内容丰富的画](https://developer.mozilla.org/en-US/docs/Glossary/First_contentful_paint)
3.  [disc world 戒酒联盟](https://wiki.lspace.org/%C3%9Cberwald_League_of_Temperance)
4.  [V8 隐藏类](https://engineering.linecorp.com/en/blog/v8-hidden-class/)