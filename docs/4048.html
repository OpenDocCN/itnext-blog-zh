<html>
<head>
<title>Creating a Helm repo on Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在谷歌云上创建Helm repo</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-helm-repo-on-google-cloud-d970cccb60c9?source=collection_archive---------2-----------------------#2020-04-16">https://itnext.io/creating-a-helm-repo-on-google-cloud-d970cccb60c9?source=collection_archive---------2-----------------------#2020-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/291d9119b72f0a7349b9998638970c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*xF00TwYS9MOqQRA3RjTVXg.png"/></div></figure><h1 id="cdf7" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">问题陈述</h1><p id="a783" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这项工作的问题陈述如下:</p><p id="ad3a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">作为一名</strong>平台工程师<br/> <strong class="ku ir">我希望</strong>新的图表版本能够尽快在所有env上发布。<br/> <strong class="ku ir">以便</strong> HelmReleases在启动时不会因为版本不存在而失败。<br/> <strong class="ku ir">和</strong>对HelmReleases的依赖保持在集群之外。</p><h1 id="d807" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">当前实施</h1><p id="e315" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在这项工作开始之前，我们曾经构建了一个舵注册容器，作为将舵图变更合并到<code class="fe lv lw lx ly b">k8s-helm-charts</code>的<code class="fe lv lw lx ly b">master</code>分支的一部分。</p><p id="425c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">然后，我们在每个集群内进行了部署，应用了以下flux注释:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="3518" class="mh jv iq ly b gy mi mj l mk ml">annotations:<br/>    flux.weave.works/automated: "true"<br/>    flux.weave.works/tag.k8s-helm-charts: semver:~2.0</span></pre><p id="1cc5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">注意:当我们使用Helm v2时，图像标签是<code class="fe lv lw lx ly b">2.0.x</code>。</p><p id="e6b6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">然而，这种方法存在许多问题:</p><ul class=""><li id="cc44" class="mm mn iq ku b kv lq kz lr ld mo lh mp ll mq lp mr ms mt mu bi translated">新映像部署到我们集群的速度</li><li id="02f1" class="mm mn iq ku b kv mv kz mw ld mx lh my ll mz lp mr ms mt mu bi translated">缺乏可见性，无法轻易知道哪些图表版本可用</li><li id="39c0" class="mm mn iq ku b kv mv kz mw ld mx lh my ll mz lp mr ms mt mu bi translated">我们所有的定制<code class="fe lv lw lx ly b">HelmReleases</code>都依赖于服务的运行</li></ul><h1 id="72db" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">可能的选择</h1><p id="fa63" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当开始任何一项工作时，最好看一下我们能处理的所有可能的选择。</p><h2 id="376b" class="mh jv iq bd jw na nb dn ka nc nd dp ke ld ne nf ki lh ng nh km ll ni nj kq nk bi translated">图表博物馆</h2><p id="caa2" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">图表博物馆(<a class="ae nl" href="https://github.com/helm/chartmuseum" rel="noopener ugc nofollow" target="_blank">https://github.com/helm/chartmuseum</a>)是主要的备选方案，但是，我们认为这不是一个可行的方案，原因如下:</p><ul class=""><li id="f6cd" class="mm mn iq ku b kv lq kz lr ld mo lh mp ll mq lp mr ms mt mu bi translated">因为我们希望保持所有环境之间的“空隙”,所以我们需要每个环境都有一个S3存储桶，这将使CI成为更新所有环境的噩梦。此外，当升级在某些环境下有效，而在其他环境下无效时，您如何处理这种情况。</li><li id="ef92" class="mm mn iq ku b kv mv kz mw ld mx lh my ll mz lp mr ms mt mu bi translated">真正的障碍是chartmuseum本身需要在集群中运行，所以从引导的角度来看，我们现在比以前更好。</li></ul><h1 id="00a8" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">被选中的人</h1><p id="bf73" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">该团队决定选择从谷歌云平台(GCP)的存储桶中运行Helm存储库。采取这种方法的原因是:</p><ul class=""><li id="26b0" class="mm mn iq ku b kv lq kz lr ld mo lh mp ll mq lp mr ms mt mu bi translated">从CI的角度来看，它是“一劳永逸的”,一旦产品包放入存储桶中，就可以立即从所有环境中利用它们。</li><li id="c759" class="mm mn iq ku b kv mv kz mw ld mx lh my ll mz lp mr ms mt mu bi translated">默认情况下，Buckets有自己的DNS记录，所以我们可以直接在我们的HelmReleases中使用它。<br/> <code class="fe lv lw lx ly b"><a class="ae nl" href="https://kubernetes-charts.storage.googleapis.com/" rel="noopener ugc nofollow" target="_blank">https://&lt;bucket name&gt;.storage.googleapis.com</a></code></li><li id="00a2" class="mm mn iq ku b kv mv kz mw ld mx lh my ll mz lp mr ms mt mu bi translated">存储桶带有一个新的用户界面，使浏览它们和搜索对象变得超级容易，这是工程师的理想选择。</li><li id="1d8c" class="mm mn iq ku b kv mv kz mw ld mx lh my ll mz lp mr ms mt mu bi translated">将我们的集群放在GCP的AWS和Helm Repository中是一个很好的关注点分离，并减少了我们现有基础架构堆栈的爆炸半径。</li></ul><h1 id="7e43" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">履行</h1><p id="718f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们在Mettle的所有基础设施都由Terraform管理，即使我们部署到GCP，也没有什么不同。</p><p id="f9be" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">创建此桶和相应服务帐户的Terraform代码如下所示:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="7cbe" class="mh jv iq ly b gy mi mj l mk ml">data "google_iam_policy" "admin" {<br/>  binding {<br/>    role = "roles/storage.admin"<br/>    members = [<br/>      "serviceAccount:terraform-helm-registry@terraform-helm-registry.iam.gserviceaccount.com",<br/>    ]<br/>  }<br/><br/>  binding {<br/>    role = "roles/storage.objectViewer"<br/>    members = [<br/>      "allUsers",<br/>    ]<br/>  }<br/><br/>}<br/><br/>resource "google_service_account" "helm_registry_service_account" {<br/>  account_id   = "terraform-helm-registry"<br/>  display_name = "CircleCI Service Account for Helm Registry"<br/>  project      = var.project_id<br/>}<br/><br/>resource "google_service_account_key" "mykey" {<br/>  service_account_id = google_service_account.helm_registry_service_account.name<br/>  public_key_type    = "TYPE_X509_PEM_FILE"<br/>}<br/><br/>resource "google_storage_bucket" "this" {<br/>  name               = "&lt;redacted&gt;"<br/>  project            = var.project_id<br/>  location           = var.location<br/>  force_destroy      = var.force_destroy<br/>  bucket_policy_only = var.bucket_policy_only<br/>  versioning {<br/>    enabled = var.bucket_versioning<br/>  }<br/>}<br/><br/>resource "google_storage_bucket_iam_policy" "policy" {<br/>  bucket      = google_storage_bucket.this.name<br/>  policy_data = data.google_iam_policy.admin.policy_data<br/>}</span></pre><p id="ba53" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">现在我们有了一个bucket和服务帐户，我们需要更新CI配置，以安全的方式将必要的对象推送到bucket中。</p><h1 id="03ee" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">CI变更</h1><p id="ac5f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">首先要考虑的是我们需要构建的脚本，以将必要的对象推送到桶本身。这个脚本可以在下面找到，它混合使用了<code class="fe lv lw lx ly b">helm package</code>和<code class="fe lv lw lx ly b">gsutil</code>(谷歌云工具)来构建<code class="fe lv lw lx ly b">.tgz</code>文件，并将它们推送到我们在GCP的桶中。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="a838" class="mh jv iq ly b gy mi mj l mk ml"><strong class="ly ir">#! /usr/bin/env bash<br/><br/></strong>set -o errexit<br/>set -o nounset<br/>set -o pipefail<br/><br/>readonly HELM_URL=https://storage.googleapis.com/kubernetes-helm<br/>readonly HELM_TARBALL=helm-v2.16.5-linux-amd64.tar.gz<br/>readonly REPO_URL=https://redacted-charts.storage.googleapis.com/<br/>readonly GCS_BUCKET=gs://redacted-charts<br/><br/>main() {<br/>  setup_helm_client<br/><br/>  if ! sync_repo charts "$GCS_BUCKET" "$REPO_URL"; then<br/>      log_error "Not all charts could be packaged and synced!"<br/>  fi<br/>}<br/><br/>setup_helm_client() {<br/>  echo "Setting up Helm client..."<br/><br/>  curl --user-agent curl-ci-sync -sSL -o "$HELM_TARBALL" "$HELM_URL/$HELM_TARBALL"<br/>  tar xzfv "$HELM_TARBALL"<br/><br/>  PATH="$(pwd)/linux-amd64/:$PATH"<br/><br/>  helm init --client-only<br/>}<br/><br/>sync_repo() {<br/>  local repo_dir="${1?Specify repo dir}"<br/>  local bucket="${2?Specify repo bucket}"<br/>  local repo_url="${3?Specify repo url}"<br/>  local sync_dir="${repo_dir}-sync"<br/>  local index_dir="${repo_dir}-index"<br/><br/>  echo "Syncing repo '$repo_dir'..."<br/><br/>  mkdir -p "$sync_dir"<br/>  mkdir -p "$index_dir"<br/><br/>  # Copy the index.yaml file from the bucket.<br/>  if ! gsutil cp "$bucket/index.yaml" "$index_dir/index.yaml"; then<br/>    log_error "Exiting because unable to copy index locally. Not safe to proceed."<br/>    exit 1<br/>  fi<br/><br/>  local return_value=0<br/><br/>  # Loop around each chart and package.<br/>  for dir in "$repo_dir"/*; do<br/>    if helm dependency build "$dir"; then<br/>      helm package --destination "$sync_dir" "$dir"<br/>    else<br/>      log_error "Problem building dependencies. Skipping packaging of '$dir'."<br/>      return_value=1<br/>    fi<br/>  done<br/><br/>  if helm repo index --url "$repo_url" --merge "$index_dir/index.yaml" "$sync_dir"; then<br/><br/>    # Move updated index.yaml to sync folder so we don't push the old one again<br/>    mv -f "$sync_dir/index.yaml" "$index_dir/index.yaml"<br/><br/>    # Push all the local chart tarballs to the bucket.<br/>    gsutil -m rsync "$sync_dir" "$bucket"<br/><br/>    # Make sure index.yaml is synced last<br/>    gsutil cp "$index_dir/index.yaml" "$bucket"<br/><br/>  else<br/>    log_error "Exiting because unable to update index. Not safe to push update."<br/>    exit 1<br/>  fi<br/><br/>  ls -l "$sync_dir"<br/><br/>  return "$return_value"<br/>}<br/><br/><br/>log_error() {<br/>    printf '\e[31mERROR: %s\n\e[39m' "$1" <em class="nm">&gt;&amp;</em>2<br/>}<br/><br/>main</span></pre><p id="b609" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">为了将此与Circle CI挂钩，我们更新了我们的<code class="fe lv lw lx ly b">.circleci/config.yml</code>文件，以包括以下内容:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="aaa9" class="mh jv iq ly b gy mi mj l mk ml">publish:<br/>  docker:<br/>    - image: google/cloud-sdk<br/>  steps:<br/>    - checkout<br/>    - setup_remote_docker<br/>    - run:<br/>        name: sync<br/>        command: |<br/>          echo $GCLOUD_SERVICE_KEY | gcloud auth activate-service-account --key-file=-<br/>          gcloud --quiet config set project ${GOOGLE_PROJECT_ID}<br/>          gcloud --quiet config set compute/zone ${GOOGLE_COMPUTE_ZONE}<br/>          bin/sync-repo.sh</span></pre><p id="a1df" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><code class="fe lv lw lx ly b">GCLOUD_SERVICE_KEY</code>是一个环境变量，是在Terraform中构建的JSON服务帐户密钥。</p><p id="6cf6" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在连接上它之后，我们的桶里装满了文件，我们可以在我们的<code class="fe lv lw lx ly b">HelmReleases</code>中毫无问题地使用它。</p><p id="eafa" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><strong class="ku ir">任务完成…嗯，还没完成！</strong></p><h1 id="f61e" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">缺少图表版本问题</h1><p id="581c" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">即使在完成这次迁移后，我们的一些HelmReleases仍然显示<code class="fe lv lw lx ly b">chart version X.Y.Z not could in repository …</code>,尽管图表版本明显存在于桶中。</p><p id="77e0" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在网上做了一些调查后，我们看到了下面的片段:</p><blockquote class="nn no np"><p id="f384" class="ks kt nm ku b kv lq kx ky kz lr lb lc nq ls lf lg nr lt lj lk ns lu ln lo lp ij bi translated">缓存控制。在对象上指定<code class="fe lv lw lx ly b"><a class="ae nl" href="https://cloud.google.com/storage/docs/metadata#cache-control" rel="noopener ugc nofollow" target="_blank">Cache-Control</a></code> <a class="ae nl" href="https://cloud.google.com/storage/docs/metadata#cache-control" rel="noopener ugc nofollow" target="_blank">元数据</a>将有利于热对象或频繁访问的对象的读取延迟。关于<code class="fe lv lw lx ly b">Cache-Control</code>等对象元数据的设置说明，请参见<a class="ae nl" href="https://cloud.google.com/storage/docs/viewing-editing-metadata#edit" rel="noopener ugc nofollow" target="_blank">查看和编辑元数据</a>。</p></blockquote><p id="3b59" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">因此，我们决定更新我们的脚本，在我们所有的对象上设置<code class="fe lv lw lx ly b">no-cache </code>。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="b749" class="mh jv iq ly b gy mi mj l mk ml">gsutil -m setmeta -h "Cache-Control:no-cache" "$bucket"/*.tgz<br/>gsutil -m setmeta -h "Cache-Control:no-cache" "$bucket"/index.yaml</span></pre><p id="42f8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在应用了这些设置后，Flux现在几乎可以立即看到新的图表版本，这个问题已经解决了。</p><p id="1520" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">关于<code class="fe lv lw lx ly b"> Cache-Control</code>元数据的更多信息，我强烈推荐<a class="ae nl" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/HTTP/Headers/Cache-Control</a>。</p><h1 id="7f76" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">摘要</h1><p id="66f8" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">总之，从编写Terraform代码到更改所有的HelmReleases以使用新的存储库，这项工作花了大约一天时间才全部完成。就成本而言，目前托管我们的图表每月约1美元，对于它为我们的工作流程提供的优势而言，这是显而易见的，我们只是希望我们能早点这样做😞</p></div></div>    
</body>
</html>