<html>
<head>
<title>K8s Deployments &amp; Replicasets — Part1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s部署和副本集—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/k8s-deployments-replicasets-part1-babdb0215156?source=collection_archive---------4-----------------------#2021-02-13">https://itnext.io/k8s-deployments-replicasets-part1-babdb0215156?source=collection_archive---------4-----------------------#2021-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/64c3362867924987dca36d68a4ef71e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/0*25Ehje1-qnxyIHUP.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.freepik.com/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="2990" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博文中，我们将讨论<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a> &amp; <a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" rel="noopener ugc nofollow" target="_blank">复制集</a> K8s对象。为了理解部署，我们将从副本集开始(我们很快就会知道为什么)。下面是这篇文章的流程。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3e26" class="lk ll iq lg b gy lm ln l lo lp">- What are Replicasets &amp; why exactly do we need them?</span><span id="7fbb" class="lk ll iq lg b gy lq ln l lo lp">- Practical example with Replicasets</span><span id="735b" class="lk ll iq lg b gy lq ln l lo lp">- What are Deployments &amp; why exactly do we need them?</span><span id="a92c" class="lk ll iq lg b gy lq ln l lo lp">- Practical example with Deployments</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/8795eb4aae6be377c6d26f589bad308e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ETAL3IX3BrcJc9782xbxg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">单舱应用</figcaption></figure><p id="c50b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设Mark开始在单个POD中托管一个业务应用程序。</p><p id="367b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于传入请求的数量很少，因此这个单独的POD可以轻松处理所有传入请求。Mark进展顺利，对应用程序的整体性能感到满意。</p><blockquote class="ls lt lu"><p id="4a89" class="kd ke lv kf b kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">由于业务增长，当Mark的应用程序开始收到更多请求时，会发生什么情况？</p></blockquote><p id="984a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着传入请求量的增加，在某个时间点之后，单个POD通常将无法处理传入请求的负载。此外，还会涉及可靠性、性能、可扩展性等问题。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/b2a51b2a3c256e00f35b92080875196d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YiiJC4UnagCfhFIE7LrERA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序请求增加的单个pod似乎带来了许多悲伤。</figcaption></figure><blockquote class="ls lt lu"><p id="b235" class="kd ke lv kf b kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">当然，手动添加更多的pod怎么样？</p></blockquote><p id="8ed2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想想看，管理我们如何以及何时扩展可能是痛苦的——每次传入的请求增加或减少。我们现在如何管理所有扩展的节点，比如如果它们崩溃了，或者我们需要进一步向上和向下扩展怎么办？</p><blockquote class="ls lt lu"><p id="58a9" class="kd ke lv kf b kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">当然，那么我们如何管理pod的扩展呢？</p></blockquote><p id="6742" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常我们在一个叫做<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" rel="noopener ugc nofollow" target="_blank">副本集</a>的容器中运行应用程序；这些POD的副本(原始POD的相同副本)可能存在于K8s集群中的相同或不同工作节点上。现在将会发生的是，不是传入的请求进入单个POD，而是它们将分布在副本集中的不同POD中。</p><p id="b760" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">客户端请求到达一个叫做<a class="ae kc" href="https://medium.com/swlh/kubernetes-services-part-1-399a0dd05211" rel="noopener"> K8s服务对象</a>的东西，它有助于在给定R <a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" rel="noopener ugc nofollow" target="_blank"> eplicaset </a>中的各种副本PODs之间分配应用程序的传入请求负载(以前称为副本控制器)。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/785b777a4e39a6b6227808784295442b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amxEBSza0aIqpOiOAyJSkg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用户请求通过K8s服务对象路由到应用程序单元。</figcaption></figure><blockquote class="ls lt lu"><p id="9dd0" class="kd ke lv kf b kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">那么当一个POD在一个大小为3的复制集中倒下时会发生什么呢？</p></blockquote><p id="f561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能是由多种原因造成的；假设POD所在的节点出现故障。作为调度程序，控制器组件的工作是确保始终维护应用程序的3个副本。它会自动执行相同的操作，而无需手动操作。</p><p id="e027" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在K8s集群中的大小为3的复制集中重复，控制器将始终确保PODs/应用程序的3个副本始终为该给定的复制集运行，这很棒，因为它以一种自动化的方式完成了许多否则必须手动完成的工作。</p><blockquote class="ls lt lu"><p id="dfdf" class="kd ke lv kf b kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">如果负载增加，replicaset大小3不够好怎么办？</p></blockquote><p id="c5f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何时候都可以指示控制器节点将复制集缩放到更大的数字，甚至缩小到更小的数字。Replicaset还尽可能地将它试图维护的副本跨节点分布。了解副本如何跨节点分布是很有趣的。这篇文章的范围将留给另一篇博客文章，但有一个简短的说明，本地和基于云的K8s集群将有不同的方式在节点之间分发副本。</p><p id="ccdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">真实集群中的pod的扩大和缩小在自动扩展中自动发生(稍后讨论)。</p><blockquote class="ls lt lu"><p id="fb72" class="kd ke lv kf b kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">那么什么是复制集呢？</p></blockquote><p id="0f50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Replicaset是一个K8s对象，一组描述一组Pod副本的Pod模板。它使用一个模板来描述每个Pod必须包含的内容。它确保所需数量的副本(运行应用程序的容器)始终保持不变，正如在创建副本集时提到的那样。</p><blockquote class="ls lt lu"><p id="97f8" class="kd ke lv kf b kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">但是为什么是另一个物体呢？</p></blockquote><p id="7276" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">K8s中的Replicaset对象有助于提高可靠性(始终保持副本大小不变)、负载平衡(使用服务在不同副本之间分配负载)以及以自动化方式扩展应用程序，而用户不必指示控制器。想象一下，对于需求不断变化的现代应用程序，必须手动执行同样的操作。对象就像K8s提供的抽象，抽象完成分配给它们的工作，用户不必担心内部细节。</p><blockquote class="ls lt lu"><p id="6f93" class="kd ke lv kf b kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">复制集到底是如何工作的？</p></blockquote><p id="2aa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">副本集的三个关键组件是</p><ol class=""><li id="1d63" class="mb mc iq kf b kg kh kk kl ko md ks me kw mf la mg mh mi mj bi translated">Selector = &gt;如何识别副本集可以获取的单元(使用标签)</li><li id="bc17" class="mb mc iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated">number = &gt; replica set应该维护多少个单元。</li><li id="c63c" class="mb mc iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated">模板= &gt;内容(图像、标签、网络等。)要由复制集使用的pod</li></ol><p id="36d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Replicaset通过创建或删除pod来实现达到所需数量的目的&amp;它总是试图保持所需的数量。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="879b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望Replicaset的理论概念是清楚的；现在，让我们快速跳到一些实际的例子。如果您想在本地拥有一个K8s集群，我建议您从这里或类似的地方使用步骤<a class="ae kc" href="https://github.com/itwonderlab/ansible-vbox-vagrant-kubernetes" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ba34" class="lk ll iq lg b gy lm ln l lo lp">cat <strong class="lg ir">replicaset.yml</strong><br/>apiVersion: apps/v1<br/>kind: ReplicaSet<br/>metadata:<br/>  name: nginxwebserver<br/>spec:<br/>  replicas: 3 <strong class="lg ir"># Desired number of replicas for the given application</strong><br/>  selector:<br/>        matchLabels:<br/>               app: nginxwebserver <strong class="lg ir"># any pod with this label will be monitored by the replicaset</strong><br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginxwebserver # <strong class="lg ir">label for the image, this should match with the selector image</strong><br/>    spec:<br/>      containers:<br/>        - name: nginxwebserver<br/>          image: nginx</span></pre><p id="7c66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用上面的文件来创建<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/#example" rel="noopener ugc nofollow" target="_blank"> Replicaset </a>，请密切注意文件中的注释，以将我们之前所学的理论概念连接起来。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="594e" class="lk ll iq lg b gy lm ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl create -f replicaset.yml</strong><br/>replicaset.apps/nginxwebserver created</span><span id="1f01" class="lk ll iq lg b gy lq ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get rs</strong><br/>NAME             DESIRED   CURRENT   READY   AGE<br/>nginxwebserver   3         3         3       4s</span><span id="571d" class="lk ll iq lg b gy lq ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get pods</strong><br/>NAME                   READY   STATUS    RESTARTS   AGE<br/>nginxwebserver-4tzf5   1/1     Running   0          9s<br/>nginxwebserver-bjjsd   1/1     Running   0          9s<br/>nginxwebserver-vzkql   1/1     Running   0          9s</span></pre><p id="e5ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得注意的是，这些副本/pod是副本集的一部分，分布在k8s集群中的三个workers上。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2634" class="lk ll iq lg b gy lm ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get pods -o wide</strong><br/>NAME                   READY   STATUS    RESTARTS   AGE   IP                NODE      NOMINATED NODE   READINESS GATES<br/>nginxwebserver-4tzf5   1/1     Running   0          18s   192.x.x.x   <strong class="lg ir">k8s-n-3</strong>   &lt;none&gt;           &lt;none&gt;<br/>nginxwebserver-bjjsd   1/1     Running   0          18s   192.x.x.x     <strong class="lg ir">k8s-n-1</strong>   &lt;none&gt;           &lt;none&gt;<br/>nginxwebserver-vzkql   1/1     Running   0          18s   192.x.x.x   <strong class="lg ir">k8s-n-2</strong>   &lt;none&gt;           &lt;none&gt;</span></pre><p id="9979" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要找到一个POD属于哪个复制集，我们可以执行以下操作。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ae16" class="lk ll iq lg b gy lm ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl describe pod nginxwebserver-vzkql | grep  Replica</strong><br/>Controlled By:  ReplicaSet/nginxwebserver</span></pre><p id="f029" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了找到属于一个复制集的所有pod(在我们的例子中是<strong class="kf ir"> nginxwebserver </strong>)，我们可以执行以下操作，因为我们可以拥有数千个pod。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c3f3" class="lk ll iq lg b gy lm ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get pods -l app=nginxwebserver --show-labels</strong><br/>NAME                   READY   STATUS    RESTARTS   AGE     LABELS<br/>nginxwebserver-4tzf5   1/1     Running   0          8m47s   app=nginxwebserver<br/>nginxwebserver-bjjsd   1/1     Running   0          8m47s   app=nginxwebserver<br/>nginxwebserver-vzkql   1/1     Running   0          8m47s   app=nginxwebserver</span></pre><p id="4c71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们从复制集中删除一个POD会怎么样？让我们试试，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="260d" class="lk ll iq lg b gy lm ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get pods</strong><br/>NAME                   READY   STATUS    RESTARTS   AGE<br/>nginxwebserver-bjjsd   1/1     Running   0          10m<br/>nginxwebserver-s62sq   1/1     Running   0          4s<br/>nginxwebserver-vzkql   1/1     Running   0          10m</span><span id="adcf" class="lk ll iq lg b gy lq ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl delete pod nginxwebserver-vzkql</strong><br/>pod "nginxwebserver-vzkql" deleted</span><span id="9b31" class="lk ll iq lg b gy lq ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get pods</strong><br/>NAME                   READY   STATUS    RESTARTS   AGE<br/>nginxwebserver-bjjsd   1/1     Running   0          10m<br/>nginxwebserver-kvdf7   1/1     Running   0          30s<br/>nginxwebserver-s62sq   1/1     Running   0          47s</span></pre><p id="d1d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们看到在删除了名为<strong class="kf ir"> nginxwebserver-vzkql，</strong>的pod之后，Replicaset继续创建另一个名为<strong class="kf ir"> nginxwebserver-kvdf7，</strong>的pod，即Replicaset总是试图保持3个副本的期望状态。</p><p id="9319" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">博客<a class="ae kc" href="https://medium.com/swlh/kubernetes-services-part-1-399a0dd05211" rel="noopener">帖子</a>解释了如何通过一个称为K8s服务对象的用户请求接口来连接上述所有单元。</p><p id="3033" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们尝试创建一个服务对象来访问这个复制集中的pod</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1ad6" class="lk ll iq lg b gy lm ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get rs</strong><br/>NAME             DESIRED   CURRENT   READY   AGE<br/>nginxwebserver   3         3         3       16m</span><span id="45e3" class="lk ll iq lg b gy lq ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl expose replicaset </strong>nginxwebserver --port 80<br/>service/nginxwebserver exposed</span><span id="c4e9" class="lk ll iq lg b gy lq ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get svc</strong><br/>NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br/>kubernetes       ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   2d6h<br/>nginxwebserver   ClusterIP   10.103.76.193   &lt;none&gt;        80/TCP    8s</span></pre><p id="9b51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们尝试到达由我们创建的服务对象公开的IP地址，这意味着服务对象现在正在副本集中的副本/pod之间分发输入请求。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4043" class="lk ll iq lg b gy lm ln l lo lp">~/kubernetes$ <strong class="lg ir">curl </strong><a class="ae kc" href="http://10.103.76.193" rel="noopener ugc nofollow" target="_blank"><strong class="lg ir">http://10.103.76.193</strong></a><strong class="lg ir"> | tail -4<br/></strong>&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="e94d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们尝试将副本集从当前数量的<strong class="kf ir"> 3 </strong>缩放到<strong class="kf ir"> 5 </strong></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e5a9" class="lk ll iq lg b gy lm ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get rs</strong><br/>NAME             DESIRED   CURRENT   READY   AGE<br/>nginxwebserver   3         3         3       22m</span><span id="80db" class="lk ll iq lg b gy lq ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl scale replicaset nginxwebserver --replicas=5</strong><br/>replicaset.apps/nginxwebserver scaled</span><span id="9d62" class="lk ll iq lg b gy lq ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get rs</strong><br/>NAME             DESIRED   CURRENT   READY   AGE<br/>nginxwebserver   5         5         5       22m</span></pre><p id="8fe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似地，我们可以使用相同的命令将副本缩小到<strong class="kf ir"> 2 </strong>。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ef65" class="lk ll iq lg b gy lm ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl scale replicaset </strong>nginxwebserver --replicas=2<br/>replicaset.apps/nginxwebserver scaled</span><span id="0d45" class="lk ll iq lg b gy lq ln l lo lp">vagrant@k8s-m-1:~/kubernetes$ <strong class="lg ir">kubectl get rs</strong><br/>NAME             DESIRED   CURRENT   READY   AGE<br/>nginxwebserver   2         2         2       24m</span></pre><p id="aa1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用声明性的方式(使用YAML文件)来执行上述所有命令，而不是我们在这里遵循的命令性方式。<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/#scaling-a-replicaset" rel="noopener ugc nofollow" target="_blank">K8s文档</a>在这一点上非常详细。</p><p id="8e73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们对复制集有了很好的理解，希望我们能深入到这篇博文的<a class="ae kc" href="https://sandeepbaldawa.medium.com/k8s-deployments-replicasets-part2-3d9284f72429" rel="noopener">第二部分的</a><a class="ae kc" href="https://sandeepbaldawa.medium.com/k8s-deployments-replicasets-part2-3d9284f72429" rel="noopener">部署K8s对象</a>。在那之前，再见！注意安全。</p></div></div>    
</body>
</html>