<html>
<head>
<title>Azure Functions HTTP Worker / Custom Handler: Bindings and Schemas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure函数HTTP Worker /自定义处理程序:绑定和模式</h1>
<blockquote>原文：<a href="https://itnext.io/azure-functions-http-worker-bindings-and-schemas-f32f126a3654?source=collection_archive---------4-----------------------#2020-03-19">https://itnext.io/azure-functions-http-worker-bindings-and-schemas-f32f126a3654?source=collection_archive---------4-----------------------#2020-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/673062b6c6c02df5794cf6f79e477f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLfw9L5XvldYxXQz92Z1Gg.png"/></div></div></figure><div class=""/><p id="2525" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近一直在关注Azure Functions团队的新HTTP Worker特性——参见<a class="ae kw" href="https://medium.com/@damoo/write-azure-functions-in-any-language-with-the-http-worker-34d01f522bfd" rel="noopener">这篇文章</a>的概述和入门。</p><p id="1210" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章着眼于用你选择的语言编写非http触发的函数。我们将看到一个非常常见的场景:<em class="kx">一个函数被一个队列触发，然后将输出存储在另一个队列和一个cosmos集合中。</em></p><p id="3a2c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里看一个工作样本:<a class="ae kw" href="https://github.com/damoodamoo/azure-func-go-java" rel="noopener ugc nofollow" target="_blank">https://github.com/damoodamoo/azure-func-go-java</a>。</p><h2 id="f135" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">您需要做的事情:</h2><ul class=""><li id="5906" class="lr ls jb ka b kb lt kf lu kj lv kn lw kr lx kv ly lz ma mb bi translated">创建<code class="fe mc md me mf b">function.json</code>文件来配置绑定</li><li id="278a" class="lr ls jb ka b kb mg kf mh kj mi kn mj kr mk kv ly lz ma mb bi translated">创建一个API端点来接收输入绑定对象</li><li id="38de" class="lr ls jb ka b kb mg kf mh kj mi kn mj kr mk kv ly lz ma mb bi translated">对我们获得的数据做“一些事情”(对于我们的示例来说，做什么并不重要)</li><li id="ee57" class="lr ls jb ka b kb mg kf mh kj mi kn mj kr mk kv ly lz ma mb bi translated">创建一个新的输出对象发送回函数宿主。</li></ul><p id="39ac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将用Java来做这件事——但是你也可以使用你自己选择的语言。</p><h1 id="a6ec" class="ml kz jb bd la mm mn mo ld mp mq mr lg ms mt mu lj mv mw mx lm my mz na lp nb bi translated">输入和输出绑定</h1><p id="5e85" class="pw-post-body-paragraph jy jz jb ka b kb lt kd ke kf lu kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">当使用HTTP Worker时，我们不再使用任何代码注释进行绑定，只使用json。你可以在文档<a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings#supported-bindings" rel="noopener ugc nofollow" target="_blank">这里</a>找到所有支持绑定的例子。</p><h2 id="9dac" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">函数. json</h2><p id="8b1f" class="pw-post-body-paragraph jy jz jb ka b kb lt kd ke kf lu kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">让我们看一个function.json，它将导致存储队列触发一个函数，并将其结果发送到另一个队列和一个cosmos集合:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="1ae3" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">绑定-&gt;对象</h2><p id="a174" class="pw-post-body-paragraph jy jz jb ka b kb lt kd ke kf lu kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">对于HTTP Worker，所有的函数输入绑定都包装在一个<code class="fe mc md me mf b">InvokeRequest</code>对象中，所有发送回函数主机的输出绑定都需要包装在<code class="fe mc md me mf b">InvokeResponse</code>对象中。这些是看起来像这样的普通物体:</p><p id="f177" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> InvokeRequest - &gt;数据进入您的函数</strong></p><pre class="nf ng nh ni gt nl mf nm nn aw no bi"><span id="08a2" class="ky kz jb mf b gy np nq l nr ns">{<br/>  "data": {... some data...}<br/>  "metadata": {...}<br/>}</span></pre><p id="eac2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Java中，这看起来像:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">InvokeRequest.java</figcaption></figure><p id="433d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">调用响应- &gt;数据流出您的函数</strong></p><p id="a452" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是函数宿主期望从您那里返回的对象的形状:</p><pre class="nf ng nh ni gt nl mf nm nn aw no bi"><span id="b0d2" class="ky kz jb mf b gy np nq l nr ns">{<br/>  "outputs": { <br/>    "output1": {..some data..},<br/>    "output2": {..some data..},<br/>  },<br/>  "logs": {<br/>    "Log message 1",<br/>    "Log message 2",<br/>  },<br/>  "returnValue": {..some data..}<br/>}</span></pre><p id="e8c9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Java中，这看起来像:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="ff2d" class="ml kz jb bd la mm mn mo ld mp mq mr lg ms mt mu lj mv mw mx lm my mz na lp nb bi translated">我们的API</h1><p id="be9e" class="pw-post-body-paragraph jy jz jb ka b kb lt kd ke kf lu kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">现在让我们创建API端点来接收<code class="fe mc md me mf b">InvokeRequest</code>并返回<code class="fe mc md me mf b">InvokeResponse</code>对象:</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="258c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，我们简单地获取请求中给我们的<code class="fe mc md me mf b">.Data</code>有效负载(队列项数据)，并将其传递给输出绑定(名为<code class="fe mc md me mf b">output1</code>和<code class="fe mc md me mf b">output2</code>)。显然，你可能想对这里的数据做点什么:)</p><p id="3b33" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意输出绑定与<code class="fe mc md me mf b">function.json</code>的关系:</p><pre class="nf ng nh ni gt nl mf nm nn aw no bi"><span id="9a20" class="ky kz jb mf b gy np nq l nr ns">{<br/>  "name": "<strong class="mf jc">output1</strong>", <br/>  "type": "cosmosDB",     <br/>  ...<br/>},<br/>{ "name": "<strong class="mf jc">output2</strong>",<br/>  "type": "queue",<br/>  ...<br/>}</span></pre><h1 id="5c33" class="ml kz jb bd la mm mn mo ld mp mq mr lg ms mt mu lj mv mw mx lm my mz na lp nb bi translated">更高级的HTTP绑定</h1><p id="2cc6" class="pw-post-body-paragraph jy jz jb ka b kb lt kd ke kf lu kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">因为HTTP响应也是一个输出绑定，所以您可以使用这种方法来提供更加定制的响应。<em class="kx">注意</em>:如果你的函数是http in和out，你不需要*这样做(你可以返回任意的有效载荷)，但是它给了你更多的控制，比如状态代码和响应。</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="143a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意在上面的代码中，我们现在可以在返回HTTP时指定一个状态代码和自定义头。</p></div></div>    
</body>
</html>