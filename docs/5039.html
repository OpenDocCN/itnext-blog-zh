<html>
<head>
<title>How to implement password recovery securely in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在PHP中安全地实现密码恢复</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-implement-password-recovery-securely-in-php-db2275ab3560?source=collection_archive---------0-----------------------#2020-11-23">https://itnext.io/how-to-implement-password-recovery-securely-in-php-db2275ab3560?source=collection_archive---------0-----------------------#2020-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c20874feea9dd9231611e6fe90154339.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*DE9s3ho-2pBBvkmpAl-WjA.jpeg"/></div></figure><p id="e441" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">前言</strong></p><p id="cee5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文旨在向PHP开发人员介绍正确实现安全特性的思维过程。我们都曾经是PHP开发新手，认为如果其中有md5()，那么它一定是安全的。</p><p id="cc1b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇文章背后的主要动机是建立在PHP社区的努力之上，使安全最佳实践在大量陈旧和不安全的建议中更加明显。当我在2017年6月出于沮丧首次写下这篇文章时，谷歌搜索“密码恢复php”的前10个结果中有9个是不安全的实现。三年多后，这些相同的结果仍然存在。这是我们作为一个社区给所有语言新手的建议。这种情况必须改变，所以这是我的一点微薄之力。</p><p id="eaee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">互联网上的安全建议(尤其是PHP安全建议)已经过时了。如果你在几年后读到这篇文章，那就要持保留态度，尽管它背后的思维过程仍然适用。</p><p id="04e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">说完了，让我们开始吧。</p><h1 id="b33e" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">如何(不)在PHP中实现密码恢复机制</h1><p id="f21a" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">如果你在互联网上呆过一段时间，你可能已经使用过某个网站的密码恢复功能。标准的做法是要求用户提供他们的电子邮件地址(当他们在网站注册时，您会要求提供)，并向该地址发送一封带有链接的电子邮件。该链接包含一些特定的信息，让应用程序知道正在为哪个用户进行密码恢复。然后它会要求输入新密码，我们就都准备好了。</p><p id="e12d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你在想“为什么我不把他们已经有的密码用电子邮件发给他们呢？”这意味着你一开始就没有散列它们。在你继续阅读之前去做那件事。不开玩笑。PHP提供了一种安全的方式来实现<a class="ae lv" href="https://www.php.net/manual/en/ref.password.php" rel="noopener ugc nofollow" target="_blank">密码散列和验证</a>，并且默认值是合理的。进一步的阅读材料可以在<a class="ae lv" href="https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="683b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可能会想“嘿，连我都知道你不应该这么做！”，但至少有几个谷歌搜索结果中的例子将密码存储在数据库中，没有进行哈希运算。因此，它似乎值得重复，并把我们带到我们的第一个不要。</p><p id="1cdb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">不要1:不要在数据库中存储明文密码。</strong></p><p id="5242" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您的站点在将密码保存到数据库之前是否对其进行了哈希处理？很好，我们继续。</p><p id="f261" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">回到给用户发电子邮件的链接，这样他们就可以重置他们的密码。让我们假设您站点的密码恢复url是:</p><p id="3b33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae lv" href="https://your.site/password_recovery.php" rel="noopener ugc nofollow" target="_blank">https://your.site/password_recovery.php</a></p><p id="91dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个简单的解决方案(再次参见顶部的Google搜索结果)可能是这样做:</p><p id="35d4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">【https://your.site/password_recovery.php?user=john@gmail.com T2】号</p><p id="7c3d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这不安全。为什么？因为如果攻击者知道某人的电子邮件，他就可以更改他的密码。这是我们第二次不要了。</p><p id="b846" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">不要2:不要使用公共信息作为密码恢复令牌</strong></p><p id="5981" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可能会想:“我还能从用户那里获得哪些我可以使用的信息？也许是用户名？”</p><p id="e986" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae lv" href="https://your.site/password_recovery.php?user_id=13" rel="noopener ugc nofollow" target="_blank">https://your.site/password_recovery.php?user_id=13</a></p><p id="a6bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这也不安全。为什么？虽然攻击者可能不知道他们正在更改哪个用户的密码，但他可以锁定用户的帐户。此外，如果您的站点有某种管理功能，那么user_id=1很可能是一个管理用户，现在您已经让自己陷入了痛苦的世界。</p><p id="97ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">不要3:不要使用顺序id号作为密码恢复令牌。</strong></p><p id="30b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此时，您可能已经意识到不能直接使用数据库之外的任何东西。但是，在尝试解决这个问题时，您会想:“让我们使用md5，这应该可以防止攻击者猜测用户的权利？”。所以你试着这样做:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="dd77" class="mf kt iq mb b gy mg mh l mi mj">$token = md5($user["email"]);</span></pre><p id="a216" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae lv" href="https://your.site/password_recovery.php?token=$token" rel="noopener ugc nofollow" target="_blank">https://your.site/password_recovery.php?token=$token</a></p><p id="7005" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你甚至可以使用mysql中的md5函数直接在数据库中查找！</p><p id="b3ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这也不安全。为什么？因为如果我能猜出令牌是如何生成的，例如:通过查看我的令牌(或者你已经在github中发布了代码，或者说，我猜出了你复制并粘贴了前10个google实现中的哪一个)，那么我就可以为每个人生成令牌。正如伟大的克劳德·香农(Claude Shannon)所说:“我们应该在假设敌人会立即完全熟悉系统的情况下设计系统”。</p><p id="61b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">不要4:不要让你的安全依赖于你的代码是秘密的这个事实。不会的。</strong></p><p id="9715" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有一些不光彩的提及。来自谷歌搜索结果中的两个:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="789d" class="mf kt iq mb b gy mg mh l mi mj">$token = md5(18247*2567 + $user["id"]);<br/></span><span id="db63" class="mf kt iq mb b gy mk mh l mi mj">$salt = "SOME!BIG#RANDOM@STRING1337"<br/>$token = md5($salt.$user["email"])</span></pre><p id="1e0e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">两者都落入别4。如果我知道您的哈希是如何构建的，我就可以为您的所有用户创建恢复令牌。即使你确定别4对你不适用，也不要用这些。它们容易受到超出本文范围的其他攻击，但是您可以自己随意破解它们。</p><p id="90a3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为一个额外的注意，这些都失败了“不满的(前)同事攻击”，即:你的同事，或你自己，可以为任何用户创建令牌，而不需要与系统交互。在这种系统中，这不是一个好的属性。</p><p id="9cdc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">不要5:不要以了解系统的人也可以离线生成的方式生成令牌</strong></p><p id="4a3f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“但是等等！”，你可能会想。“如果我们使用加密而不是散列会怎么样？我可以将密钥置于版本控制之外，我们应该防止上面的问题，对吗？”</p><p id="775a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管您可以:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1a58" class="mf kt iq mb b gy mg mh l mi mj">$token = encrypt($user["email"],$some_key);</span></pre><p id="4a1c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这带来的问题比它解决的更多。</p><ol class=""><li id="b56e" class="ml mm iq jw b jx jy kb kc kf mn kj mo kn mp kr mq mr ms mt bi translated">您需要找到一种安全处理密钥的方法。</li><li id="7669" class="ml mm iq jw b jx mu kb mv kf mw kj mx kn my kr mq mr ms mt bi translated">如果密钥泄露，并且您想要更改它，您将会破坏以前的令牌。</li><li id="e43a" class="ml mm iq jw b jx mu kb mv kf mw kj mx kn my kr mq mr ms mt bi translated">根据算法和密钥大小，密钥可能是可恢复的，因为明文和算法是已知的(参见第4页)。</li><li id="2595" class="ml mm iq jw b jx mu kb mv kf mw kj mx kn my kr mq mr ms mt bi translated">如果密钥被恢复(无论是通过暴力还是由于其他弱点),那么攻击者(或你的同事，见第5页)可以为任何离线用户生成重置令牌。</li></ol><p id="e9b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">不要6:如果可以避免，就不要使用加密技术。它带来的问题比它解决的更多。而你大概</strong> <a class="ae lv" href="http://www.cryptofails.com/page/18" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">反正不知道怎么安全地实现</strong> </a></p><p id="3777" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此时，可能没有更多的方法来使用您已经拥有的数据来生成重置令牌。相反，您必须从一些其他数据中生成它，并将其存储在某个地方，比如用户表中的一个新列。这确实解决了离线生成有效令牌的问题。</p><p id="bf94" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Do 1:生成不依赖于用户数据的令牌。</strong></p><p id="e2d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从现在开始，我们正在改变攻击模式。到目前为止，攻击者一直在猜测与特定用户相关联的令牌。这已经不可能了。攻击者所能做的就是触发用户的密码重置，并猜测生成了什么令牌。</p><p id="366d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">"那么我该如何生成这个令牌呢？"，你扪心自问。也许使用PHP已经给我们的东西，比如<a class="ae lv" href="https://www.php.net/manual/en/function.uniqid.php" rel="noopener ugc nofollow" target="_blank"> uniqid </a>:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="49b9" class="mf kt iq mb b gy mg mh l mi mj">php &gt; echo uniqid();<br/>593aceadf16aa</span></pre><p id="15a9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这应该是一个随机的，唯一的id，对吗？？？</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d7657fd2b169a87e93f202def6567e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*aNyaI7MbY5HRE9aM"/></div></figure><p id="cc27" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">uniqid的输出专门从当前服务器时间生成。攻击者控制他何时请求密码更改，因此即使它使用的分辨率高达微秒，他也可能将范围缩小到几毫秒，使id在几千次尝试后就可被猜出</p><p id="be05" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">不要7:不要根据时间生成您的令牌，它们是可猜测的。</strong></p><p id="c30c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意:散列一个可猜测的令牌不会增加任何安全性。它看起来确实更安全，但事实并非如此。这就像在猜测某人的密码时，你并不关心他的密码的哈希是什么，如果你只能猜测用户很懒，他们的密码就是字面上的“密码”。</p><p id="2ee4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此时，作为一个聪明的男人/女人，你可能会说:“如果我想要随机的东西，为什么我要用uniqid呢？我就用PHP的随机数函数吧！”</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="682f" class="mf kt iq mb b gy mg mh l mi mj">$token = rand(); // Value between 0 and 2147483647.</span></pre><p id="a9af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(许多)随机数生成器的特点是它们是确定性的。如果你知道几个输出，你实际上可以知道下一个会是什么。是的，你没看错。不，我没疯。如果你不相信我，去读读<a class="ae lv" href="http://phpsecurity.readthedocs.io/en/latest/Insufficient-Entropy-For-Random-Values.html" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae lv" href="https://softwareengineering.stackexchange.com/questions/76229/predicting-the-output-of-phps-rand" rel="noopener ugc nofollow" target="_blank">这个</a>。回来的时候别忘了你的锡纸帽子。</p><p id="00cb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae lv" href="https://www.php.net/manual/en/function.rand" rel="noopener ugc nofollow" target="_blank"> rand() </a>和<a class="ae lv" href="https://www.php.net/manual/en/function.mt-rand.php" rel="noopener ugc nofollow" target="_blank"> mt_rand() </a>都容易受到这种攻击。鲜为人知的<a class="ae lv" href="https://www.php.net/manual/en/function.lcg-value" rel="noopener ugc nofollow" target="_blank"> lcg_value </a>也是。PHP 7 <a class="ae lv" href="http://php.net/manual/en/migration70.new-features.php#migration70.new-features.csprng-functions" rel="noopener ugc nofollow" target="_blank">引入了</a> <a class="ae lv" href="https://www.php.net/manual/en/function.random-bytes.php" rel="noopener ugc nofollow" target="_blank"> random_bytes() </a>和<a class="ae lv" href="https://www.php.net/manual/en/function.random-int.php" rel="noopener ugc nofollow" target="_blank"> random_int() </a>，它们以一种对这类应用安全的方式返回随机数据，即它们是加密安全的随机数生成器。</p><p id="e1fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">不要8:不要使用rand、mt_rand或lcg_value作为任何安全相关的随机数来源。</strong></p><p id="7ab7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Do 2:对安全随机数使用random_int或random_bytes。</strong></p><p id="3581" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么，如何构建一个随机且不可预测的令牌呢？</p><p id="f082" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个简单的方法是:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1001" class="mf kt iq mb b gy mg mh l mi mj">$length = 16; // Adjust length to fit your new paranoia level. 16 is probably a sane default and the same length as md5 (if you are migrating from a method that uses it)<br/>$token = bin2hex(random_bytes($length)); // bin2hex output is url safe.</span></pre><p id="be08" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就这样，我们结束了。我们有一个安全令牌用于密码恢复。</p><p id="1d36" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，您可以开始实现其余的功能了。不过，当你这么做的时候，有几件额外的事情你需要记住。</p><p id="ee68" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">重置令牌不应该永远有效，所以您应该在令牌旁边添加一个新列，注明创建日期，并使用它来检查它是否应该被接受。此外，它们应该是一次性令牌。因此，一旦用户重置了密码，就要删除令牌。</p><p id="9c5c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">做3:为你的重置令牌设置一个生命周期，越短越好。1小时可能是一个合理的默认值。</strong></p><p id="f34b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">做4:使用后丢弃重置令牌。</strong></p><h1 id="922a" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">Wrapping up/TL；博士</strong></h1><p id="7b49" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">综上所述，您的一般应用程序流程应该如下所示:</p><p id="7fbe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">1)用户请求重置密码，并提供了他们的电子邮件</p><p id="0128" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2)使用电子邮件地址在数据库中查找用户</p><p id="0873" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">3)安全地创建令牌，并将其与创建时间一起存储在数据库中。</p><p id="da46" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ae89" class="mf kt iq mb b gy mg mh l mi mj">$token = bin2hex(random_bytes(16));</span></pre><p id="731d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">4)发送一封电子邮件，其中包含指向您的密码恢复页面的链接，以及作为查询字符串参数的令牌</p><p id="5d5a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">5)使用令牌在数据库中查找用户，如果找到且未过期，提示他输入新密码</p><p id="c0c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">6)将新密码存储在数据库中</p><p id="49c7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">7)从数据库中删除已使用的令牌。</p><p id="3927" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">记住，千万不要:</strong></p><p id="623a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">1)不要将明文密码存储在数据库中。</p><p id="23d7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2)不要使用公共信息作为密码恢复令牌。</p><p id="9a5f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">3)不要使用连续的id号作为密码恢复令牌。</p><p id="32dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">4)不要让你的安全性依赖于你的代码是秘密的这一事实。</p><p id="3b04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">5)不要以离线生成令牌的方式生成令牌</p><p id="ff07" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">6)不要使用加密</p><p id="9748" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">7)不要根据时间来生成令牌</p><p id="87da" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">8)不要使用rand、mt_rand或lcg_value作为任何安全相关的随机数来源</p><p id="1c11" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">记住，做:</strong></p><p id="de88" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">1)生成不依赖于用户数据的令牌，并将它们存储在数据库中。</p><p id="a913" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2)对安全随机数使用random_int或random_bytes。</p><p id="6a82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">3)为您的重置令牌设置生命周期。</p><p id="7819" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">4)使用后丢弃重置令牌。</p></div></div>    
</body>
</html>