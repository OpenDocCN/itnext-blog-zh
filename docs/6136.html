<html>
<head>
<title>Benchmarking sine functions.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基准正弦函数。</h1>
<blockquote>原文：<a href="https://itnext.io/benchmarking-sine-functions-16b067bf63ce?source=collection_archive---------6-----------------------#2021-08-30">https://itnext.io/benchmarking-sine-functions-16b067bf63ce?source=collection_archive---------6-----------------------#2021-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="29a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很少有人想避开<a class="ae kl" href="https://www.tutorialspoint.com/c_standard_library/c_function_sin.htm" rel="noopener ugc nofollow" target="_blank"> sin() </a>函数，但是，在一些情况下，这样做是有益的。本文针对线性插值波表、混叠波表、无限脉冲响应正弦波和七个不同精度的多项式近似值，对常规sin()函数进行了基准测试。</p><p id="6c5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">IIR正弦波是用初始参数设置的，然后在每个节拍的基础上调用，这不是那种每次调用都要传递参数的函数；正在初始化。当您需要简单、高质量的低成本正弦波时，这些非常适合音频应用。提供的所有其他函数都被设计为在每次调用时传递θ、ω、弧度、度数等。</p><p id="2470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续之前，您可能想看看基准测试的代码并自己编译它，如果不是这样也没关系，但是如果您这样做了，就在这里:<br/><a class="ae kl" href="https://gist.github.com/mrbid/1f25bfc27d97b81d5d9ec5e45f81a6e1" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/mrbid/1 f 25 bfc 27d 97 b 81 D5 d 9 e C5 e 45 f 81 a6 e 1</a><br/>使用命令编译；<code class="fe km kn ko kp b">gcc sine_bench.c -Ofast -lm -o sine_bench</code></p><p id="9480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于基准测试，需要记住的一点是，这些基准测试是在启用了-Ofast优化标志的情况下执行的，其原因是，与仅使用常规的sin()函数相比，性能增益非常有限，以至于没有任何性能增益值得精度损失。</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="0586" class="ky kz iq kp b gy la lb l lc ld">Slowest to fastest...<br/>Executions in 1 second...<br/>-------------------------<br/>sin():         26,557,697<br/>fast_sin1():   33,017,414<br/>fast_sin2():   34,991,929<br/>lerp_sin():    37,344,972<br/>fast_sin4():   37,701,782<br/>fast_sin7():   45,245,155<br/>fast_sin5():   45,613,310<br/>fast_sin3():   45,926,931<br/>fast_sin6():   46,565,172<br/>aliased_sin(): 47,113,225<br/>IIRSine2():    69,406,434<br/>IIRSine():     70,789,548</span></pre><p id="9e94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们可以看到<code class="fe km kn ko kp b">IIRSine()</code>明显更快，所以如果你可以使用这些函数，这是显而易见的。我们也看到<code class="fe km kn ko kp b">sin()</code>通常是最慢的，但这是精度函数的预期，当我们寻找更快的替代方案时，我们必须牺牲精度。</p><p id="5f88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们来看看函数的精度，平均偏差超过6位小数(0.000001):</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="c733" class="ky kz iq kp b gy la lb l lc ld">Avg error of functions from 0 to 3.1 ...<br/>----------------------------------------<br/>lerp_sin():    0.000032<br/>aliased_sin(): 0.000030<br/>fast_sin1():   0.002653<br/>fast_sin2():   0.000125<br/>fast_sin3():   0.035730<br/>fast_sin4():   0.000012<br/>fast_sin5():   0.000832<br/>fast_sin6():   0.378000<br/>fast_sin7():   2.774034</span><span id="efac" class="ky kz iq kp b gy le lb l lc ld">Avg error of functions from 0 to 6.3 ...<br/>----------------------------------------<br/>lerp_sin():    0.000032<br/>aliased_sin(): 0.000030<br/>fast_sin1():   0.002660<br/>fast_sin2():   0.000125<br/>fast_sin3():   5.304368<br/>fast_sin4():   0.181263<br/>fast_sin5():   0.386772<br/>fast_sin6():   3.512034<br/>fast_sin7():   41.145363</span><span id="ceeb" class="ky kz iq kp b gy le lb l lc ld">Avg error of functions from 0 to 9.4 ...<br/>----------------------------------------<br/>lerp_sin():    0.000032<br/>aliased_sin(): 0.000030<br/>fast_sin1():   0.002661<br/>fast_sin2():   0.000121<br/>fast_sin3():   64.467628<br/>fast_sin4():   33.455360<br/>fast_sin5():   1.473552<br/>fast_sin6():   11.423285<br/>fast_sin7():   471.490936</span><span id="7d33" class="ky kz iq kp b gy le lb l lc ld">Avg error of functions from 0 to 12.6 ...<br/>-----------------------------------------<br/>lerp_sin():    0.000031<br/>aliased_sin(): 0.000030<br/>fast_sin1():   0.002621<br/>fast_sin2():   0.000117<br/>fast_sin3():   322.956146<br/>fast_sin4():   1181.200317<br/>fast_sin5():   1.779256<br/>fast_sin6():   22.638031<br/>fast_sin7():   3915.010742</span></pre><p id="94fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，<code class="fe km kn ko kp b">aliased_sin()</code>是迄今为止最精确的近似值，但仅略高于<code class="fe km kn ko kp b">lerp_sin()</code>。<code class="fe km kn ko kp b">aliased_sin()</code>的计算速度也比多项式逼近快得多，而且精度保持得更久。所有的多项式近似都变得相当糟糕——相当快，除了<a class="ae kl" href="https://www.gamedev.net/nightcracker/" rel="noopener ugc nofollow" target="_blank"> nightcracker </a>在<a class="ae kl" href="https://www.gamedev.net/forums/topic/621589-extremely-fast-sin-approximation/" rel="noopener ugc nofollow" target="_blank"> GameDev论坛</a>上的<code class="fe km kn ko kp b">fast_sin2()</code>。<code class="fe km kn ko kp b">fast_sin1()</code>也很不错，但它总是比<code class="fe km kn ko kp b">fast_sin2()</code>稍慢，也不太准确。</p><p id="3a1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这些结果中，我可以总结出，如果你真的需要高性能和高质量的正弦波，可以使用<code class="fe km kn ko kp b">IIRSine()</code>函数，否则，你必须不惜一切代价避免<code class="fe km kn ko kp b">sin()</code>函数，那么你最好的选择是尝试线性插值波表或混叠波表<code class="fe km kn ko kp b">lerp_sin()</code>和<code class="fe km kn ko kp b">aliased_sin()</code>函数，它们分别比原始<code class="fe km kn ko kp b">sin()</code>函数快33.7%和55.8%，是最快和最精确的替代方案。但是，如果内存是一个限制，并且您真的无法为一个波表留出1024字节到262千字节的空间，那么<code class="fe km kn ko kp b">fast_sin2()</code>多项式就是您的下一个最佳选择。</p><p id="9650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后说明:<br/><em class="lf"/><code class="fe km kn ko kp b"><em class="lf">lerp_sin()</em></code><em class="lf">函数使用带线性插值的256样本波表，而</em> <code class="fe km kn ko kp b"><em class="lf">aliased_sin()</em></code> <em class="lf">函数使用不带插值的65536样本波表。</em> <code class="fe km kn ko kp b"><em class="lf">aliased_sin()</em></code> <em class="lf">结果更准确的原因很简单，因为有更多的样本，而且事实证明，在现代硬件上，有更多样本比有更少样本的插值更快。</em></p><figure class="kq kr ks kt gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lg"><img src="../Images/02fcad3c5e443d54813592942b616f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kORTuXacGSlSW29D.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">图片来源:<a class="ae kl" href="https://commons.wikimedia.org/wiki/File:Simple_sine_wave.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure></div></div>    
</body>
</html>