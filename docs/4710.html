<html>
<head>
<title>Step-by-Step Centralized Authentication for Kubernetes with Keycloak and the Ambassador Edge Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keycloak和Ambassador Edge堆栈对Kubernetes进行分步集中认证</h1>
<blockquote>原文：<a href="https://itnext.io/step-by-step-centralized-authentication-for-kubernetes-with-keycloak-and-the-ambassador-edge-stack-539dcf8ec699?source=collection_archive---------1-----------------------#2020-08-28">https://itnext.io/step-by-step-centralized-authentication-for-kubernetes-with-keycloak-and-the-ambassador-edge-stack-539dcf8ec699?source=collection_archive---------1-----------------------#2020-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8946" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当您构建Kubernetes应用程序时，很容易陷入“身份验证蔓延”,所有服务都有不同的身份验证机制。本教程介绍了如何使用IdP和API网关来集中您的身份验证机制。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c6ab9643990b7b4925729c33bad9b8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZwnrfLKzZrueugXd.png"/></div></div></figure><p id="86cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://www.keycloak.org/" rel="noopener ugc nofollow" target="_blank"> Keycloak </a>是一个广泛采用的身份和访问管理(<a class="ae ln" href="https://www.getambassador.io/learn/kubernetes-glossary/iam/" rel="noopener ugc nofollow" target="_blank">简称</a>IAM)开源解决方案。2014年对于突破性技术来说是重要的一年，因为Keycloak和Kubernetes项目最初都是相隔几周发布的。不足为奇的是，许多Kubernetes最终用户将Keycloak作为管理对其平台的安全API和服务的访问的首选方式。</p><p id="5064" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，仅仅在Kubernetes中运行Keycloak并不能保证平台的安全。许多问题留给了用户来配置和实现:从使用TLS和<a class="ae ln" href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" rel="noopener ugc nofollow" target="_blank">入口控制器</a>来公开Keycloak API端点，到在特定的业务端点上实施安全策略。在解决这些问题时，我们倾向于使用API网关解决方案来处理加密连接和集中API管理策略，而不是在您的微服务架构的每种语言和应用中重新实施身份验证策略。</p><p id="a787" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们今天的目标是将Keycloak安装为我们的IAM解决方案，并将其保护在<a class="ae ln" href="https://www.getambassador.io" rel="noopener ugc nofollow" target="_blank"> Ambassador Edge Stack </a>之后，我们的API网关充当Kubernetes入口控制器。最后一步，我们将部署一个示例应用程序，并演示如何使用Keycloak作为身份提供者(简称为<a class="ae ln" href="https://www.getambassador.io/learn/kubernetes-glossary/idp/" rel="noopener ugc nofollow" target="_blank">IdP</a>)来使用请求过滤器通过OAuth2限制对此应用程序的访问。</p><h1 id="ce1d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">入门指南</h1><p id="0389" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在本教程中，我们将使用非生产就绪的Keycloak安装。为了简化我们的依赖图，我们将使用内存中的数据存储，它完全适合于演示，但不能保证生产环境中的高可用性。如果您正在寻找生产级的持久性，<a class="ae ln" href="https://www.keycloak.org/docs/latest/server_installation/index.html#_database" rel="noopener ugc nofollow" target="_blank"> Keycloak提供了多种存储解决方案</a>。</p><p id="e6d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">入口控制器是大多数Kubernetes产品中缺失的构建模块。尽管Kubernetes定义了一个入口资源，但它实际上并没有得到任何将资源转化为公共服务的实现的支持！入口解决方案的选择和安装由运营商决定。在这里，我们将使用Ambassador Edge堆栈的社区版本，因为它直接与Keycloak集成以进行身份验证，从而公开和保护来自互联网请求的公共流量，使其流向运行在我们的Kubernetes集群中的下游私有服务。</p><p id="4cc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程结束时，我们将启动并运行Ambassador Edge堆栈，在Kubernetes网络的边缘进行TLS端接，在<code class="fe ml mm mn mo b">/auth/</code>下公开我们的Keycloak安装，并在<code class="fe ml mm mn mo b">/backend/</code>下保护我们的报价应用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/6165e8f6f0b7595a1df370f1fe933654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmOka1EySynu-Jsr_SIyEw.png"/></div></div></figure><h2 id="1148" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">用K8s初始化器搭建</h2><p id="f306" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">库伯内特斯经常被取笑，因为它需要大量的YAML。我们将使用<a class="ae ln" href="https://app.getambassador.io/" rel="noopener ugc nofollow" target="_blank"> K8s初始化器</a>为我们生成所有的Kubernetes资源，而不是去寻宝游戏寻找YAML样本，并从陈旧的资源中将所有的拼图拼在一起。K8s初始化器是一个项目生成器工具，类似于为应用程序开发人员提供的工具:想想Spring Initializr或Yeoman。</p><p id="18d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">K8s初始化器的向导式界面将引导我们回答几个问题，以了解和配置不同云提供商的特定设置。这些实现细节通常是承诺被打破和可移植性不足的地方，使得难以配置入口控制器和向公共流量公开服务。希望我们可以通过使用像K8s初始化器这样的综合工具来消除这些小问题，它将为我们提供一个最佳的配置。</p><p id="72e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">特别是对于本教程，我们选择了我们的目标Kubernetes集群:“Google Kubernetes引擎”和“Google外部负载平衡器(L4)”负载平衡器。我们还为我们的安装选择了一个公共主机名。使用公共主机名将需要额外的步骤来配置DNS条目以指向我们的安装，但是考虑到我们想要演示如何构建公共安全应用程序堆栈，额外的努力是值得的。至于K8s初始化器的Auth配置，我们毫无疑问选择了Keycloak，带有临时密码。</p><p id="e536" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦对我们的K8s初始化选项感到满意，我们点击“下载”按钮。我们会得到一套现成的YAML文件和说明。</p><p id="56dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">试试看！【https://app.getambassador.io/ T4】</p><h2 id="35b4" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">安装大使边缘堆栈</h2><p id="be51" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们将从安装Ambassador Edge栈开始，因为它包含了一堆<a class="ae ln" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank"> Kubernetes自定义资源定义</a>依赖项。假设您可以访问您想要的Kubernetes集群，安装将非常简单，只需运行<code class="fe ml mm mn mo b">kubectl apply</code>命令并配置一个DNS条目以指向所提供服务的外部IP。</p><h2 id="f433" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">安装钥匙锁</h2><p id="9e81" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">从生成的YAML安装Keycloak也很简单:一个简单的<code class="fe ml mm mn mo b">kubectl apply</code>命令。一只好奇的猫可能会偷看奇洛克·YAML的档案，别担心，它不会杀了你的！实际上，您将能够体会到<a class="ae ln" href="https://www.getambassador.io/docs/latest/topics/using/intro-mappings/" rel="noopener ugc nofollow" target="_blank">大使映射</a>资源将如何指示到达公共<code class="fe ml mm mn mo b">/auth/</code>前缀端点的流量转发到我们在Kubernetes集群中运行的私有Keycloak pod。</p><p id="afed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给Keycloak几分钟的启动时间，然后我们将能够在<a class="ae ln" href="https://domain-name/auth/" rel="noopener ugc nofollow" target="_blank">https://domain-name/auth/</a>访问它的UI。由于我们在K8s初始化器选项中选择了“<em class="nc"> Ambassador使用Let ' s Encrypt certificate”</em>终止TLS，因此我们可以理解如何使用Keycloak安装的安全证书自动终止TLS。</p><p id="0e95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以使用默认的<code class="fe ml mm mn mo b">admin</code>用户名和我们之前选择的临时密码登录到Keycloak的管理控制台UI，根据我们的需要配置Keycloak...并更改密码！</p><h1 id="0215" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">使用Keycloak保护您的API</h1><h2 id="e4be" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">配置密钥锁领域、客户端和用户</h2><p id="1a5b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了保护我们的API，我们将使用全新的Keycloak安装作为我们的IdP。我们首先需要创建一个客户端来处理来自Ambassador Edge堆栈的身份验证请求。所有这些配置步骤都可以使用Keycloak UI来完成。</p><ol class=""><li id="a4eb" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated">我们首先从创建一个新的“领域”开始。将鼠标悬停在右侧导航栏中的“主”标签上，我们可以单击“添加领域”。我们选择了<code class="fe ml mm mn mo b">ambassador</code>作为我们新领域的“名字”。稍后将需要配置授权过滤器中的<code class="fe ml mm mn mo b">authorizationURL</code>字段。</li><li id="cda5" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">我们将通过导航到“Clients”并单击“create”来创建一个新客户端。我们选择了以下设置:<br/> - <em class="nc">客户端ID </em> : <code class="fe ml mm mn mo b">ambassador</code> -该值将用于授权过滤器的<code class="fe ml mm mn mo b">clientID</code>字段。<br/> - <em class="nc">客户端协议</em> : <code class="fe ml mm mn mo b">openid-connect</code> <br/> - <em class="nc">根URL </em>:无，留空</li><li id="4b41" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">在下面的屏幕上，我们为客户端配置了:<br/> - <em class="nc">访问类型</em>:<code class="fe ml mm mn mo b">confidential</code>-<br/>-<em class="nc">有效重定向URIs </em> : <code class="fe ml mm mn mo b">*</code></li><li id="3b91" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">导航到我们的客户端中的“Mappers”选项卡，我们单击“Create”并使用以下设置:<br/> - <em class="nc">协议</em>:<code class="fe ml mm mn mo b">openid-connect</code>-<br/>名称:<code class="fe ml mm mn mo b">Ambassador Mapper</code>-<br/>-<em class="nc">映射器类型</em> : <code class="fe ml mm mn mo b">Audience</code> <br/> - <em class="nc">包括的客户端受众</em>:从下拉列表中选择客户端的名称。记住，我们给客户取名为<code class="fe ml mm mn mo b">ambassador</code>。</li><li id="a65a" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">回到我们的<code class="fe ml mm mn mo b">ambassador</code>客户端，我们导航到“客户端范围”部分，并为<code class="fe ml mm mn mo b">offline_access</code>配置我们的客户端。</li><li id="f4ec" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">回到我们的<code class="fe ml mm mn mo b">ambassador</code>客户端，然后我们导航到“凭证”部分。我们注意到了“Secret”值，因为稍后在配置我们的auth Filter时会用到它。</li></ol><p id="b931" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了我们的客户端配置，让我们配置一个Keycloak“用户”:</p><ol class=""><li id="e3e9" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated">导航到Keycloak管理控制台的“用户”部分，我们将单击“添加用户”。我们给用户一个简单的用户名:<code class="fe ml mm mn mo b">my-keycloak-user</code>，然后点击“保存”。</li><li id="7e93" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">在接下来的屏幕上，我们切换到用户的“Credentials”选项卡来设置临时密码。</li></ol><p id="9c3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了一个可以用来验证自己身份的用户，让我们来部署一个应用程序。</p><h2 id="c094" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">部署报价服务</h2><p id="624f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在Kubernetes上部署定制应用程序是通过创建一些Kubernetes资源来实现的，这些资源被定义为…你猜对了，更多的YAML！这一次，因为我们正在部署一个示例后端应用程序，所以这个示例有些轻量级。您可以将以下定义保存到一个“quote-service.yaml”文件中，并使用<code class="fe ml mm mn mo b">kubectl apply -f quote-service.yaml</code>进行部署。</p><pre class="kg kh ki kj gt nr mo ns nt aw nu bi"><span id="a386" class="mq lp iq mo b gy nv nw l nx ny">---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: quote<br/>  namespace: default<br/>spec:<br/>  ports:<br/>  - name: http<br/>    port: 80<br/>    targetPort: 8080<br/>  selector:<br/>    app: quote<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: quote<br/>  namespace: default<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: quote<br/>  strategy:<br/>    type: RollingUpdate<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: quote<br/>    spec:<br/>      containers:<br/>      - name: backend<br/>        image: docker.io/datawire/quote:0.4.1<br/>        ports:<br/>        - name: http<br/>          containerPort: 8080<br/>---<br/>apiVersion: getambassador.io/v2<br/>kind: Mapping<br/>metadata:<br/>  name: quote-backend<br/>  namespace: default<br/>spec:<br/>  prefix: /backend/<br/>  service: quote</span></pre><p id="3add" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将创建一个Kubernetes <code class="fe ml mm mn mo b">Deployment</code>、<code class="fe ml mm mn mo b">Service</code>和<code class="fe ml mm mn mo b">Mapping</code>来公开展示我们在<code class="fe ml mm mn mo b">/backend/</code>路径下运行的报价应用程序。试试看，目前未保护:<a class="ae ln" href="https://domain-name/backend/" rel="noopener ugc nofollow" target="_blank">https://domain-name/back end/</a>。</p><h2 id="b2b1" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">保护访问</h2><p id="5183" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">基于我们在前面的“配置Keycloak领域、客户端和用户”一节中应用于我们的Keycloak安装的配置，我们将在Kubernetes中创建OAuth2 <code class="fe ml mm mn mo b">Filter</code>和<code class="fe ml mm mn mo b">FilterPolicy</code>资源。不要忘记用您安装的值替换这个YAML示例中的占位符！再次将下面的定义保存到一个“keycloak-filter.yaml”文件中，并使用<code class="fe ml mm mn mo b">kubectl apply -f keycloak-filter.yaml</code>部署它。</p><pre class="kg kh ki kj gt nr mo ns nt aw nu bi"><span id="3087" class="mq lp iq mo b gy nv nw l nx ny">---<br/>apiVersion: getambassador.io/v2<br/>kind: Filter<br/>metadata:<br/>  name: keycloak-filter<br/>  namespace: ambassador<br/>spec:<br/>  OAuth2:<br/>    authorizationURL: https://{domain-name}/auth/realms/ambassador<br/>    audience: ambassador<br/>    clientID: ambassador<br/>    secret: {client_secret}<br/>    protectedOrigins:<br/>    - origin: https://{domain-name}<br/>---<br/>apiVersion: getambassador.io/v2<br/>kind: FilterPolicy<br/>metadata:<br/>  name: quote-policy<br/>  namespace: default<br/>spec:<br/>  rules:<br/>    - host: "*"<br/>      path: /backend/<br/>      filters:<br/>        - name: keycloak-filter<br/>          namespace: ambassador<br/>          arguments:<br/>            scopes:<br/>            - "offline_access"</span></pre><p id="2ddd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于<code class="fe ml mm mn mo b">FilterPolicy</code>在<code class="fe ml mm mn mo b">/backend/</code>路径上起作用，当导航到<a class="ae ln" href="https://domain-name/backend/" rel="noopener ugc nofollow" target="_blank">https://domain-name/back end/</a>下的报价服务时，我们现在被提示通过Keycloak进行身份验证！尝试使用我们之前创建的<code class="fe ml mm mn mo b">my-keycloak-user</code>用户名登录！</p><p id="b653" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们距离扩展这一FilterPolicy配置以使用相同的身份验证策略保护多个路径、端点和服务仅一步之遥。谈论一种推广单点登录和集中您的身份验证机制的有效方法！<a class="ae ln" href="https://www.getambassador.io/docs/latest/howtos/sso/keycloak/" rel="noopener ugc nofollow" target="_blank">现在，只需按照这些说明使用Keycloak </a>配置过滤器和过滤器策略资源的细粒度设置。</p><h1 id="5c06" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">了解更多信息</h1><p id="3c94" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在本教程中，我们展示了如何通过将Keycloak部署为IdP并将Ambassador Edge堆栈部署为Kubernetes-native API网关，在Kubernetes中集中您的身份验证。在K8s初始化器的帮助下，您只需点击几下鼠标就可以启动并运行这些工具。</p><p id="d671" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要了解有关这些工具和集中式身份验证策略的更多信息，请查看以下资源:</p><ul class=""><li id="e6e8" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm nz nj nk nl bi translated"><a class="ae ln" href="https://www.keycloak.org/" rel="noopener ugc nofollow" target="_blank">钥匙锁</a></li><li id="1a1c" class="nd ne iq kt b ku nm kx nn la no le np li nq lm nz nj nk nl bi translated"><a class="ae ln" href="https://www.getambassador.io/" rel="noopener ugc nofollow" target="_blank">大使缘栈</a></li><li id="d735" class="nd ne iq kt b ku nm kx nn la no le np li nq lm nz nj nk nl bi translated"><a class="ae ln" href="https://app.getambassador.io/" rel="noopener ugc nofollow" target="_blank"> K8s初始化器</a></li><li id="f278" class="nd ne iq kt b ku nm kx nn la no le np li nq lm nz nj nk nl bi translated"><a class="ae ln" href="http://d6e.co/slack" rel="noopener ugc nofollow" target="_blank">加入我们的行列</a></li></ul></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="caa0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nc">原载于2020年8月28日</em><a class="ae ln" href="https://blog.getambassador.io/centralized-authentication-with-keycloak-and-ambassador-edge-stack-d509ffbc7b6f" rel="noopener ugc nofollow" target="_blank"><em class="nc">https://blog . getambassador . io</em></a><em class="nc">。</em></p></div></div>    
</body>
</html>