<html>
<head>
<title>Desktop GUI Implementation using Flutter WEB (Part 3: Draggable &amp; Resizable windows)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flutter WEB实现桌面GUI(第3部分:可拖动和可调整大小的窗口)</h1>
<blockquote>原文：<a href="https://itnext.io/desktop-gui-implementation-using-flutter-web-part-3-draggable-resizable-windows-46ea26049605?source=collection_archive---------1-----------------------#2021-07-14">https://itnext.io/desktop-gui-implementation-using-flutter-web-part-3-draggable-resizable-windows-46ea26049605?source=collection_archive---------1-----------------------#2021-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/680e57919566bcf719b27e7165fe5d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOTv85UT8XqllgQm99xIuA.png"/></div></div></figure><p id="47ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大家好，欢迎来到我的使用Flutter WEB实现桌面GUI指南的第三部分！</p><p id="34c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您还没有理解第1和第2部分，我邀请您阅读:</p><ul class=""><li id="7bda" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lf" href="https://achraf-feydi.medium.com/desktop-gui-implementation-using-flutter-web-part-1-introduction-42d21a6e7937" rel="noopener"> <strong class="ka ir">第一部分:简介</strong> </a></li><li id="fef3" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><a class="ae lf" href="https://medium.com/nerd-for-tech/desktop-gui-implementation-using-flutter-web-part-2-dock-3ade96f4af8a" rel="noopener"> <strong class="ka ir">第二部分:停靠</strong> </a></li></ul><p id="2df3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一步，我们将讨论我在<a class="ae lf" href="https://www.fluttergui.com/" rel="noopener ugc nofollow" target="_blank"> FlutterGUI项目</a>中实现的MDI系统的一个更简单的实现。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/f8bf6174cd0480d037b368b7e134dc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*6I-9DERFFOuQLb6rwfBlNw.gif"/></div></figure><p id="aeca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本教程结束时，你将能够实现一个简单的MDI系统，包括一些基本的功能，如拖动和调整大小。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/be2c2976b0b1896fff9e9fd4136dad46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*gv6tnmOubLv_bX-xmj0LrQ.gif"/></div></figure><h1 id="005b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">目录:</h1><ol class=""><li id="eca6" class="kw kx iq ka b kb mo kf mp kj mq kn mr kr ms kv mt lc ld le bi translated">什么是计量吸入器？</li><li id="06fb" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv mt lc ld le bi translated">设置一个简单的测试用户界面</li><li id="0691" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv mt lc ld le bi translated">使小部件可拖动</li><li id="01d9" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv mt lc ld le bi translated">修复小部件的叠加</li><li id="9659" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv mt lc ld le bi translated">计算器示例</li><li id="7374" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv mt lc ld le bi translated">使小部件可调整大小</li></ol></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="832f" class="lq lr iq bd ls lt nb lv lw lx nc lz ma mb nd md me mf ne mh mi mj nf ml mm mn bi translated">什么是计量吸入器？</h1><p id="8db1" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">当我在做这个项目时，我甚至不知道什么是MDI系统。幸运的是，<a class="ae lf" href="https://www.reddit.com/user/jrheisler" rel="noopener ugc nofollow" target="_blank"> jrheisler </a>在我的Reddit帖子上让我知道我正在做的实际上是一个MDI(多文档界面)。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fc51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">据<a class="ae lf" href="https://en.wikipedia.org/wiki/Multiple-document_interface" rel="noopener ugc nofollow" target="_blank">我们的好朋友</a> <a class="ae lf" href="https://en.wikipedia.org/wiki/Multiple-document_interface" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="nl nm nn"><p id="387f" class="jy jz no ka b kb kc kd ke kf kg kh ki np kk kl km nq ko kp kq nr ks kt ku kv ij bi translated">一个<strong class="ka ir">多文档界面</strong> ( <strong class="ka ir"> MDI </strong>)是一个图形用户界面，其中多个窗口位于一个父窗口下。这种系统通常允许子窗口嵌入其他窗口，从而创建复杂的嵌套层次结构。</p></blockquote><p id="704a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">果然，这正是我正在建设的！</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="9ea5" class="lq lr iq bd ls lt nb lv lw lx nc lz ma mb nd md me mf ne mh mi mj nf ml mm mn bi translated">设置一个简单的测试UI</h1><p id="0140" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">所以，让我们从一个空屏幕开始:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="76c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我正在使用Flutter Desktop (macOS)测试这款应用，但你可以在任何支持Flutter WEB、Linux或Windows的浏览器上运行它。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/603ac80564f6448ff948835cace97da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AL2D6IZH0wP8Vz7T1QVL0Q.png"/></div></div></figure><p id="4627" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建三个dart文件:</p><ul class=""><li id="c941" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">mdiManager.dart :表示父窗口的有状态窗口小部件。它包含所有窗口，并负责在屏幕上排列子窗口。</li><li id="d3cd" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">mdiController  : Dart类，保存打开窗口的列表，并负责添加、删除和更新窗口。</li><li id="227c" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">resizableWindow.dart :一个有状态的小部件，作为子窗口的模板。它包含标题栏和主体，并且能够检测拖动和调整大小的手势。</li></ul><p id="3ac0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从<strong class="ka ir"> ResizableWindow </strong>类开始，我们将从声明一些重要的属性开始，比如:</p><ul class=""><li id="d271" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">currentHeight、defaultHeight、currentWidth和defaultWidth:这些属性将在调整窗口大小时使用。</li><li id="ae9d" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">x，y:表示子窗口在父窗口中的位置(TopLeft为0，0)。</li></ul><p id="d394" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们将ResizableWindow制作成一个简单的方形小部件:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="062b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在对于控制器，我们将声明一个列表<strong class="ka ir"> _windows </strong>来保存打开的子窗口，并声明一个回调函数_onUpdate来在窗口改变位置或大小时触发状态更新。</p><p id="3a44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还将定义<strong class="ka ir"> _createNewWindowedApp() </strong>私有方法来创建新的子窗口并将其添加到打开的窗口列表中。</p><p id="6f45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将添加<strong class="ka ir"> addWindow() </strong>公共方法，该方法将用于创建和添加一个仅用于测试目的的子窗口。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="2c8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经理很简单。它会将ResizableWindow对象的列表转换为定位对象的列表，然后将它们放入堆栈中。就这么简单。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="d398" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们转到<strong class="ka ir"> main.dart </strong>文件，使用我们已经创建的小部件！</p><p id="2192" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建一个MdiController，并将其传递给Scaffold主体中的MdiManager小部件。</p><p id="6b8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我添加了一个FloatingActionButton来测试通过控制器方法<strong class="ka ir"> addWindow()添加新的子窗口。</strong></p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2e4a1c12a1001dcf435b1bb27aed2f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*arUD8VbCN-2t6Z5L7grLLw.gif"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">创建随机窗口</figcaption></figure><p id="9103" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有点难看，不是吗？</p><p id="7f1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让它看起来像一个真正的窗口应用程序。现在，将小部件分成两部分就足够了:标题栏<strong class="ka ir"> _getHeader() </strong>和正文<strong class="ka ir"> _getBody() </strong>。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="3a12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Tadaaaa！</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/014c7788e915cd53841acdcefa1f8526.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*5dZuHqo5kdK9IfVYHYfHPw.png"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">窗口模板</figcaption></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="4c25" class="lq lr iq bd ls lt nb lv lw lx nc lz ma mb nd md me mf ne mh mi mj nf ml mm mn bi translated">使小部件可拖动</h1><p id="3860" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">戴上你的眼镜，握紧你的指关节，准备好——我们刚刚到达有趣的部分！</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="oa nk l"/></div></figure><p id="108f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现拖动行为就足以检测到拖动手势，然后相应地更新x和y属性。</p><p id="231f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们将首先声明<strong class="ka ir"> onWindowDragged </strong>回调函数，然后使用<strong class="ka ir">手势检测器</strong>的<strong class="ka ir">on更新</strong>回调函数中的<strong class="ka ir"> dx </strong>和<strong class="ka ir"> dy </strong>值来调用它。</p><p id="67ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一种选择，我只做了TileBar (Header) Draggable，因为这是大多数MDI的常见行为。</p><p id="fb73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> onPanUpdate </strong>的输出是一个包含拖动手势的<strong class="ka ir"> dx </strong>和<strong class="ka ir"> dy </strong>的对象。<strong class="ka ir"> dx </strong>是拖动手势根据X轴的变化。dy和Y轴也一样。</p><p id="083b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果用户向左拖动窗口3个像素，dx = 3。要计算新位置:</p><pre class="lm ln lo lp gt ob oc od oe aw of bi"><span id="9589" class="og lr iq oc b gy oh oi l oj ok">x = x + dx; <br/>y = y + dy; </span></pre><p id="cd8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在实现:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="be5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> MdiController </strong>的<strong class="ka ir"> _createNewWindowedApp() </strong>方法将负责更新x和y属性，并触发<strong class="ka ir"> _update() </strong>方法重建widget树:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/cb9c68d88101cd85c5d8bad3f20c8bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*sJ8SFbYKA9_4Z4C1WgQ08Q.gif"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">拖动窗口的演示</figcaption></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="eda1" class="lq lr iq bd ls lt nb lv lw lx nc lz ma mb nd md me mf ne mh mi mj nf ml mm mn bi translated">修复小部件的叠加</h1><p id="8248" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">我们还有一个问题要解决。窗口不能在堆栈中重新排列。一旦一个子窗口在堆栈的底部，即使我们把它拖到另一个窗口上，它也会一直在堆栈的底部。</p><p id="27e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最简单的方法是移除窗口并将其重新插入堆栈。它将被自动添加到堆栈的顶部。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="21e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法的问题是，当我们移除窗口并将其重新插入小部件树时，窗口的状态将会丢失。这与Flutter如何更新小部件树有关。</p><p id="c91e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用以下密钥来解决这个问题:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="fc6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不熟悉在Flutter中使用按键，我推荐你看看这篇<a class="ae lf" href="https://medium.com/flutterdevs/keys-in-flutter-104fc01db48f" rel="noopener">中型文章</a>。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c93d442f96591f9f460c34d20bf9b19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*l3pV6rvii7FbyZP3z6VR6g.gif"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">窗口叠加演示</figcaption></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="0d91" class="lq lr iq bd ls lt nb lv lw lx nc lz ma mb nd md me mf ne mh mi mj nf ml mm mn bi translated"><strong class="ak">计算器示例</strong></h1><p id="440c" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">让我们用一个简单的例子来测试我们的MDI！为此，我选择使用<a class="ae lf" href="https://pub.dev/packages/flutter_simple_calculator" rel="noopener ugc nofollow" target="_blank">flutter _ simple _ calculator</a>插件。</p><p id="e531" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在我们开始之前，我们需要通过向其构造函数添加参数来使ResizableWindow小部件动态化——一个用于标题，另一个用于我们将在窗口内运行的“应用程序”。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="09b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在页眉上添加标题:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="8c4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，body对<strong class="ka ir"> _getBody() </strong>方法:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="98e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们更新<strong class="ka ir"> _createNewWindowedApp </strong>的参数如下，以传递标题和子App。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="4721" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们需要添加计算器应用程序依赖项:</p><pre class="lm ln lo lp gt ob oc od oe aw of bi"><span id="00f3" class="og lr iq oc b gy oh oi l oj ok">flutter_simple_calculator: ^1.0.4</span></pre><p id="aabc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…并将一个SimpleCalculator小部件传递给_createNewWindowedApp()调用。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="1deb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您将在下面看到的，即使在拖动和重新排列子窗口之后，Calculator应用程序的每个克隆体的状态仍然保持不变。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/847ae04309a45e1a75598b58a42cdbce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*gmIPyo_YCWhOPvCpcJPezw.gif"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">状态守恒演示</figcaption></figure><p id="2bd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以这样添加一个<em class="no">关闭</em>按钮:</p><p id="9575" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将<strong class="ka ir"> onCloseButtonClicked </strong>添加到<strong class="ka ir"> ResizableWindow </strong>类中。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="d5e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将红色按钮本身添加到<strong class="ka ir"> _getHeader() </strong>方法中:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="83f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们更新_createNewWindowedApp()方法以适应这些变化:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5c47cf5a978ffada741eb0b3de7aed85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*aKbpMrihg8g2OAotE9ZOyQ.gif"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">使用关闭按钮的演示</figcaption></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="d4bf" class="lq lr iq bd ls lt nb lv lw lx nc lz ma mb nd md me mf ne mh mi mj nf ml mm mn bi translated">使窗口可调整大小</h1><p id="f6b0" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">调整窗口大小并不简单。</p><p id="d732" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该首先检测窗口边缘的拖动手势，然后根据拖动的<strong class="ka ir">位置</strong>和<strong class="ka ir">方向</strong>做出相应的动作。</p><p id="ad42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我选择使用带有嵌套定位小部件的堆栈小部件来定义可拖动区域(调整大小区域)。</p><p id="ad56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还改变了鼠标光标，以显示我可以从哪些区域调整大小。</p><p id="96ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有8个可以调整大小的区域:左、右、上、下、左上、右上、左下和右下。</p><p id="b015" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的例子中，我给调整大小的区域添加了颜色，使它们可见:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/318c7989f281506e94c3352bcc1c36bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*u7tAXMwMRSbwhkY1Ija4uw.gif"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">调整区域大小</figcaption></figure><p id="9f5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在下面的代码中看到<strong class="ka ir">右侧</strong>调整大小区域的实现:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="f15a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GestureDetector小部件提供了许多回调函数。我们将使用的是:</p><ul class=""><li id="3880" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">onverticaldragdupdate</strong>检测顶部和底部调整大小区域的拖动手势。</li><li id="4067" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir"> onHorizentalDragUpdate </strong>检测左右尺寸调整区域的拖拽手势。</li><li id="18e3" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir">on更新</strong>基本上同时检测两者。我们将在可以同时在两个轴上调整大小的角落使用它。</li></ul><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="05ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该知道，当我们使用顶部、左侧或顶部左侧调整区域时，我们需要更新窗口的位置(x，y)以及currentHeight和currentWidth属性。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/cc57864f129500e657e9ce777a6bde26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*1XA7q7HtS2LMflywyXQODA.gif"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">演示x和y何时随着调整大小而变化</figcaption></figure><p id="eece" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了满足这个需求，我们可以使用拖动信息调用onScreenResized方法。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><p id="9481" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其余部分:</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="ns nk l"/></div></figure><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/be2c2976b0b1896fff9e9fd4136dad46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*gv6tnmOubLv_bX-xmj0LrQ.gif"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">最终结果！</figcaption></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="1617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">完整代码:</strong></p><div class="ol om gp gr on oo"><a href="https://github.com/achreffaidi/flutter_app_mdi/tree/v0.0.1" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">achreffaidi/flutter_app_mdi</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">新的颤振应用。这个项目是颤振应用的起点。一些资源让你…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc jw oo"/></div></div></a></div><h1 id="9c44" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">下一步是什么？</h1><p id="2464" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">本教程只是我在FlutterGUI项目中实现复杂小部件的总体指南中的一步。希望能帮助其他开发者做出又酷又<strong class="ka ir">有用的</strong>项目。</p><p id="9cbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你最终可以找到下面所有的链接。我会一路更新他们！</p><ul class=""><li id="54ea" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lf" href="https://achraf-feydi.medium.com/desktop-gui-implementation-using-flutter-web-part-1-introduction-42d21a6e7937" rel="noopener"> <strong class="ka ir">第1部分:简介</strong> </a></li><li id="462b" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><a class="ae lf" href="https://medium.com/nerd-for-tech/desktop-gui-implementation-using-flutter-web-part-2-dock-3ade96f4af8a" rel="noopener"> <strong class="ka ir">第二部分:停靠</strong> </a></li><li id="54f9" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">第三部分:可拖动的可调整大小的窗口</li><li id="ed03" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir">第四部分:Windows XP崩溃</strong></li><li id="71e1" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated">第五部分:全屏动画</li><li id="d2bc" class="kw kx iq ka b kb lg kf lh kj li kn lj kr lk kv lb lc ld le bi translated"><strong class="ka ir">第6部分:Github页面和自定义URL </strong></li></ul></div></div>    
</body>
</html>