<html>
<head>
<title>Transforming lists into maps using Java Stream API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Java Stream API将列表转换为映射</h1>
<blockquote>原文：<a href="https://itnext.io/transforming-lists-into-maps-using-java-stream-api-b29ef743b440?source=collection_archive---------0-----------------------#2022-08-18">https://itnext.io/transforming-lists-into-maps-using-java-stream-api-b29ef743b440?source=collection_archive---------0-----------------------#2022-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="917e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">令人印象深刻的将列表转换成地图的便捷API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c1acaa91a95d45f074b6084a4455891c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YepBG-PW9XXnw3eULHTbqg.png"/></div></div></figure><p id="8cfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">源数据通常以列表的形式存储。例如，关系数据库的表或Excel文件就是一列行。当源数据被处理以最终可视化时，地图可能经常被用作中间或最终的数据结构。</p><p id="9473" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Java有一个令人印象深刻的流API，它使得列表到映射的转换成为一项简单的任务。Java流不能比<code class="fe lq lr ls lt b">for</code>-循环做得更多或更快，但是使用stream API的代码通常会更短、更易读。在这篇文章中，我回顾了将流转换成地图的合理方法。</p><p id="7be0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从一个<code class="fe lq lr ls lt b">Stream</code>返回一个<code class="fe lq lr ls lt b">Map</code>有四种简单的方法。由<code class="fe lq lr ls lt b"> Collectors</code>类的重载方法<code class="fe lq lr ls lt b">toMap()</code>、<code class="fe lq lr ls lt b">groupingBy()</code>或<code class="fe lq lr ls lt b">partitioningBy()</code>产生的收集器可以在终端方法<code class="fe lq lr ls lt b">Stream.collect(collector)</code>内部使用。它的形式<code class="fe lq lr ls lt b">collect(supplier, accumulator, combiner)</code>可以不使用任何收集器直接返回一张地图。因此，根据变换的不同，可能有几种生成地图的方法。这些选项在代码大小上可能略有不同。</p><p id="4f15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了说明这篇文章，我使用了由15个不同的<code class="fe lq lr ls lt b">Player</code>对象组成的<code class="fe lq lr ls lt b">List</code>。每个玩家都有唯一的用户名、性别、分数，并且属于一个团队:</p><p id="1f62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">public record Player(String name, String sex, int score, String team) {}</code></p><p id="921e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我导入了<code class="fe lq lr ls lt b">Collectors</code>类的所有静态方法，这样这些方法就不必以类名为前缀，这样代码就更有意义了:</p><p id="25f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">import static java.util.stream.Collectors.*;</code></p><h2 id="736a" class="lu lv it bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">包含产生唯一键的所有元素的列表</h2><p id="7035" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">这种映射通常用于连接两个实体列表。</p><p id="a9c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe lq lr ls lt b">toMap(keyMapper,valueMapper)</code>收集器可以生成将id链接到对象的映射:</p><p id="2889" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Player&gt; playersByName = players.stream().collect(toMap(Player::name, p -&gt; p));</code></p><p id="8b72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生成的地图中前三个相关的键和值(键和值用<code class="fe lq lr ls lt b">=&gt;</code>分隔，未显示的条目用<code class="fe lq lr ls lt b">…</code>符号表示):</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="af4b" class="lu lv it lt b gy mw mx l my mz">Charles =&gt;Player[name=Charles, sex=M, score=2, team=Green]<br/>Evelyn  =&gt;Player[name=Evelyn, sex=F, score=7, team=Blue]<br/>Madison =&gt;Player[name=Madison, sex=F, score=9, team=Blue]<br/>...</span></pre><p id="e505" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">toMap(keyMapper,valueMapper)</code> collector也可以用来制作一个连接同一个对象的两个属性的地图。例如，保存用户分数的地图。</p><p id="f9bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Integer&gt; playerScores = players.stream().collect(toMap(Player::name, Player::score));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="0e30" class="lu lv it lt b gy mw mx l my mz">Charles =&gt;2<br/>Evelyn  =&gt;7<br/>Madison =&gt;9<br/>..</span></pre><p id="5f57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当源列表的每个元素都确定会产生一个唯一的键时，可以使用<code class="fe lq lr ls lt b">toMap(keyMapper,valueMapper)</code>。如果生成的键已经在映射中，收集器将引发异常。</p><h2 id="c70d" class="lu lv it bd lw lx ly dn lz ma mb dp mc ld md me mf lh mg mh mi ll mj mk ml mm bi translated">列出产生非唯一键的列表</h2><p id="99be" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">我不确定哪里需要它，但是如果需要简单地覆盖先前插入的值，可以使用没有任何收集器的代码行。</p><p id="abf9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Player&gt; playersByName2 = players.stream().collect(HashMap::new, (m, p) -&gt; m.put(p.team(), p),(m1, m2) -&gt; m1.putAll(m2));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="a618" class="lu lv it lt b gy mw mx l my mz">Red =&gt;Player[name=Mila, sex=F, score=0, team=Red]<br/>Blue =&gt;Player[name=Madison, sex=F, score=9, team=Blue]<br/>Green =&gt;Player[name=Isabella, sex=F, score=6, team=Green]</span></pre><p id="93a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">处理产生非唯一键的对象的一种更常见的方法是将所有具有相同键的值收集到一个列表中。这可以通过<code class="fe lq lr ls lt b">groupingBy(keyMapper)</code>收集器实现:</p><p id="53bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, List&lt;Player&gt;&gt; playersByTeam = layers.stream().collect(groupingBy(Player::team));</code></p><p id="a5cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生成的地图中的第一个关键字:</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="a865" class="lu lv it lt b gy mw mx l my mz">Red =&gt;[Player[name=Addison, sex=F, score=7, team=Red], Player[name=Lucy, sex=F, score=8, team=Red], Player[name=Mila, sex=F, score=0, team=Red]]<br/>...</span></pre><p id="3912" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个类似的收集器<code class="fe lq lr ls lt b">partitioningBy(predicate)</code>允许将一个列表分成与<code class="fe lq lr ls lt b">true</code>和<code class="fe lq lr ls lt b">false</code>键相关联的两个列表。</p><p id="4828" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;Boolean, List&lt;Player&gt;&gt; bestPlayers = players.stream().collect(partitioningBy(p -&gt; p.score() &gt; 1000));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="24a1" class="lu lv it lt b gy mw mx l my mz">false =&gt;[Player[name=Lily, sex=F, score=2, team=Blue], Player[name=Addison, sex=F, score=7, team=Red], Player[name=Logan, sex=M, score=4, team=Green], ...]<br/>true =&gt;[]</span></pre><p id="09a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几乎等价的多值<code class="fe lq lr ls lt b">Map</code>可以用具有相同谓词的<code class="fe lq lr ls lt b">groupingBy(keyMapper)</code>生成:</p><p id="5731" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;Boolean, List&lt;Player&gt;&gt; bestPlayers2 = players.stream().collect(groupingBy(p -&gt; p.score() &gt; 1000));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="0623" class="lu lv it lt b gy mw mx l my mz">false =&gt;[Player[name=Lily, sex=F, score=2, team=Blue], Player[name=Addison, sex=F, score=7, team=Red], Player[name=Logan, sex=M, score=4, team=Green], ...]</span></pre><p id="43d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">partitioningBy(predicate)</code>和<code class="fe lq lr ls lt b">groupingBy(keyMapper)</code>的唯一区别在于<code class="fe lq lr ls lt b">partitioningBy(predicate)</code>返回的地图包含<code class="fe lq lr ls lt b">false</code>和<code class="fe lq lr ls lt b">true</code>键的<code class="fe lq lr ls lt b">List</code> s，即使<code class="fe lq lr ls lt b">predicate</code>从不返回<code class="fe lq lr ls lt b">true</code>或<code class="fe lq lr ls lt b">false</code>。</p><p id="05cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由<code class="fe lq lr ls lt b">groupingBy(keyMapper, collector)</code>返回的收集器创建了一个映射，在这个映射中，对应于一个给定键的多个值没有被添加到一个列表中，而是被传递给嵌套的收集器，而嵌套的收集器又可以有一个嵌套的收集器。</p><p id="b3e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一个示例中的嵌套收集器具有不言自明的名称。</p><p id="7ae5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Integer&gt; totalScoreByTeam = players.stream().collect(groupingBy(Player::team, summingInt(Player::score)));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="4444" class="lu lv it lt b gy mw mx l my mz">Red   =&gt;15<br/>Blue  =&gt;32<br/>Green =&gt;25</span></pre><p id="5946" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Double&gt; avgScoreByTeam = players.stream().collect(groupingBy(Player::team, averagingInt(Player::score)));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="fa14" class="lu lv it lt b gy mw mx l my mz">Red   =&gt;5.0<br/>Blue  =&gt;5.333333333333333<br/>Green =&gt;4.166666666666667</span></pre><p id="dadc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Long&gt; teamMemberCount = players.stream().collect(groupingBy(Player::team, counting()));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="7b33" class="lu lv it lt b gy mw mx l my mz">Red   =&gt;3<br/>Blue  =&gt;6<br/>Green =&gt;6</span></pre><p id="f2c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">分组值不必减少，它们可以通过另一个<code class="fe lq lr ls lt b">keyMapper</code>功能进一步分组到附加地图中:</p><p id="361d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Map&lt;String, Long&gt;&gt; sexCountInTeams = players.stream().collect(groupingBy(Player::team, groupingBy(Player::sex, counting())));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="f44e" class="lu lv it lt b gy mw mx l my mz">Red<br/> F =&gt;3<br/>Blue<br/> F =&gt;4<br/> M =&gt;2<br/>Green<br/> F =&gt;3<br/> M =&gt;3</span></pre><p id="1fd5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嵌套收集器可以包装在辅助收集器<code class="fe lq lr ls lt b">mapping(valueMapper, collector)</code>中，在将值传递给嵌套收集器之前对其进行转换:</p><p id="c663" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, List&lt;String&gt;&gt; namesBySex = players.stream().collect(groupingBy(Player::sex, mapping(Player::name, toList())));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="fb36" class="lu lv it lt b gy mw mx l my mz">F =&gt;[Lily, Addison, Emilia, Olivia, Lucy, Mila, Eleanor, Evelyn, Isabella, Madison]<br/>M =&gt;[Logan, Elijah, Charles, Asher, Wyatt]</span></pre><p id="8af3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Set&lt;Integer&gt;&gt; teamUniqueScores = players.stream().collect( groupingBy(Player::team, mapping(Player::score, toSet())));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="f1ce" class="lu lv it lt b gy mw mx l my mz">Red =&gt;[0, 7, 8]<br/>Blue =&gt;[2, 3, 5, 6, 7, 9]<br/>Green =&gt;[2, 3, 4, 5, 6]</span></pre><p id="4f46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Set&lt;Integer&gt;&gt; sortedUniqueScoresBySex = players.stream().collect(groupingBy(Player::sex, mapping(Player::score, toCollection(TreeSet::new))));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="f75f" class="lu lv it lt b gy mw mx l my mz">F =&gt;[0, 2, 3, 5, 6, 7, 8, 9]<br/>M =&gt;[2, 3, 4, 5, 6]</span></pre><p id="6e86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, String&gt; teamMemberNames = players.stream().collect(groupingBy(Player::team,mapping(Player::name, joining(", "))));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="f50d" class="lu lv it lt b gy mw mx l my mz">Red =&gt;Addison, Lucy, Mila<br/>Blue =&gt;Lily, Emilia, Elijah, Evelyn, Wyatt, Madison<br/>Green =&gt;Logan, Olivia, Eleanor, Charles, Asher, Isabella</span></pre><p id="2f70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后的结果也可以用<code class="fe lq lr ls lt b">toMap(keyMapper, valueMapper, mergeFunction)</code>产生:</p><p id="3de4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, String&gt; teamMemberNames2 = players.stream().collect(<br/>toMap(Player::team, Player::name, (t, v) -&gt; t + ", "+ v));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="5034" class="lu lv it lt b gy mw mx l my mz">Red =&gt;Addison, Lucy, Mila<br/>Blue =&gt;Lily, Emilia, Elijah, Evelyn, Wyatt, Madison<br/>Green =&gt;Logan, Olivia, Eleanor, Charles, Asher, Isabella</span></pre><p id="2428" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后两段代码产生相同的<code class="fe lq lr ls lt b">Map</code>，其中团队名称与团队成员的串联名称相关联。这样的地图是不可接受的，因为名字没有排序。如何对它们进行排序？</p><p id="cff5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个相当糟糕的选择是使用<code class="fe lq lr ls lt b">collectingAndThen(collector, finisher)</code>收集器。它只是将值传递给嵌套收集器，并在处理完所有值后，将嵌套收集器返回的结果传递给finisher函数:</p><p id="61a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, String&gt; teamMemberNames4 = players.stream().collect(groupingBy(Player::team,mapping(Player::name, collectingAndThen(toList(), l -&gt; l.stream().sorted().collect(joining(", "))))));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="377f" class="lu lv it lt b gy mw mx l my mz">Red =&gt;Addison, Lucy, Mila<br/>Blue =&gt;Elijah, Emilia, Evelyn, Lily, Madison, Wyatt<br/>Green =&gt;Asher, Charles, Eleanor, Isabella, Logan, Olivia</span></pre><p id="a61c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种不太尴尬的方法是在分组前对值进行排序:</p><p id="a719" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, String&gt; teamMemberNames5 = players.stream().sorted(Comparator.comparing(Player::name)).collect(groupingBy(Player::team,mapping(Player::name, joining(", "))));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="92b4" class="lu lv it lt b gy mw mx l my mz">Red =&gt;Addison, Lucy, Mila<br/>Blue =&gt;Elijah, Emilia, Evelyn, Lily, Madison, Wyatt<br/>Green =&gt;Asher, Charles, Eleanor, Isabella, Logan, Olivia</span></pre><p id="1c7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嵌套<code class="fe lq lr ls lt b">groupingBy()</code>收集器的另一个常见例子是:</p><p id="e200" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String,Map&lt;String,List&lt;String&gt;&gt;&gt; namesByTeamAndSex = players.stream().collect(groupingBy(Player::team, groupingBy(Player::sex, mapping(Player::name, toList()))));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="9a1f" class="lu lv it lt b gy mw mx l my mz">Red<br/> F =&gt;[Addison, Lucy, Mila]<br/>Blue<br/> F =&gt;[Lily, Emilia, Evelyn, Madison]<br/> M =&gt;[Elijah, Wyatt]<br/>Green<br/> F =&gt;[Olivia, Eleanor, Isabella]<br/> M =&gt;[Logan, Charles, Asher]</span></pre><p id="4d50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在流API中，痛苦的来源之一通常是无用或不需要的<code class="fe lq lr ls lt b">Optional</code>类型。一些内置的收集器返回<code class="fe lq lr ls lt b">Optional</code>，除了例外情况，不必要地延长了代码:</p><p id="dbd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Optional&lt;Player&gt;&gt; highestScoreByTeam = players.stream().collect(groupingBy(Player::team, maxBy(Comparator.comparing(Player::score))));</code></p><p id="b711" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，为了从<code class="fe lq lr ls lt b">Optional</code>中提取玩家，代码的大小必须加倍:</p><p id="ea38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Player&gt; highestScoreByTeam2 = players.stream().collect(groupingBy(Player::team,maxBy(Comparator.comparing(Player::score)))).entrySet().stream().collect(toMap(e -&gt; e.getKey(), e -&gt; e.getValue().get()));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="763b" class="lu lv it lt b gy mw mx l my mz">Red =&gt;Player[name=Lucy, sex=F, score=8, team=Red]<br/>Blue =&gt;Player[name=Madison, sex=F, score=9, team=Blue]<br/>Green =&gt;Player[name=Isabella, sex=F, score=6, team=Green]</span></pre><p id="dcef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还好<code class="fe lq lr ls lt b">Optional</code>只由三个不可或缺的收藏者产生:<code class="fe lq lr ls lt b">reducing(binaryOperator)</code>、<code class="fe lq lr ls lt b">minBy(comparator)</code>和<code class="fe lq lr ls lt b">maxBy(comparator)</code>。</p><p id="f6f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果使用<code class="fe lq lr ls lt b">toMap(keyMapper, valueMapper, mergeFunction)</code>，可以用更少的代码获得相同的结果。<code class="fe lq lr ls lt b">mergeFunction</code>组合相同键值。</p><p id="13c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, Player&gt; highestScoreInTeam3 = players.stream().collect(toMap(Player::team, p -&gt; p,(p1, p2) -&gt; p1.score() &gt; p2.score()? p1 : p2));</code></p><p id="bec7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是为了同时计算最佳和最差玩家，最短的解决方案是使用<code class="fe lq lr ls lt b">minBy(comparator)</code>和<code class="fe lq lr ls lt b">maxBy(comparator)</code>:</p><p id="5291" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">record MinMax(Player min, Player max) {};</code></p><p id="d662" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Map&lt;String, MinMax&gt; highestScoreInTeam4 = players.stream().collect(groupingBy(Player::team, teeing( minBy(Comparator.comparing(Player::score)), maxBy(Comparator.comparing(Player::score)),(a, b) -&gt; new MinMax(a.get(), b.get()))));</code></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="9a63" class="lu lv it lt b gy mw mx l my mz">Red =&gt;MinMax[min=Player[name=Mila, sex=F, score=0, team=Red], max=Player[name=Lucy, sex=F, score=8, team=Red]]<br/>Blue =&gt;MinMax[min=Player[name=Lily, sex=F, score=2, team=Blue], max=Player[name=Madison, sex=F, score=9, team=Blue]]<br/>Green =&gt;MinMax[min=Player[name=Charles, sex=M, score=2, team=Green], max=Player[name=Isabella, sex=F, score=6, team=Green]]</span></pre><p id="6fd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">teeing(collector1, collector2, mergeFunction)</code>是两个收集器的包装。它将元素传递给它们两个，最后将它们的结果传递给<code class="fe lq lr ls lt b">mergeFunction.</code></p><p id="b3ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b"><a class="ae na" href="https://marian-caikovski.medium.com/efficiently-loading-associations-with-jdbc-hibernate-and-eclipselink-20ee88584938" rel="noopener">reducing(mergeFunction)</a></code> <a class="ae na" href="https://marian-caikovski.medium.com/efficiently-loading-associations-with-jdbc-hibernate-and-eclipselink-20ee88584938" rel="noopener">对于分解从数据库加载的实体连接非常有用。</a>但是很难想象有意义的例子用<code class="fe lq lr ls lt b">reducing(mergeFunction)</code>产生不像上面的结果或者比上面的代码更短。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="0241" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，这些是制作地图最常见的方法。这个API是多余的，也是详尽的。stream API对于将连接产品分解成实体或连接相关对象的列表特别方便。如果一个实体有多个关联，那么使用映射连接相关实体的内存列表会比使用单个查询加载一个巨大的连接产品更有效。</p><p id="5f6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最大的不便是一些收集器返回无意义的<code class="fe lq lr ls lt b">Optional</code>，这总是需要额外的代码。但是，如果要在多个应用程序中重用代码，可以创建一个定制的通用收集器。<a class="ae na" rel="noopener ugc nofollow" target="_blank" href="/advantages-of-not-using-spring-data-and-hibernate-with-relational-data-8a509faf0c48">我在之前的帖子中描述了一个自定义收集器。</a></p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="52c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码可以从<a class="ae na" href="https://github.com/marianc000/ListToMap" rel="noopener ugc nofollow" target="_blank">https://github.com/marianc000/ListToMap</a>下载</p></div></div>    
</body>
</html>