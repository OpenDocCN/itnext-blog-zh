<html>
<head>
<title>Effective Automation Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效的自动化测试</h1>
<blockquote>原文：<a href="https://itnext.io/write-valuable-automation-tests-a6148ff6090c?source=collection_archive---------1-----------------------#2020-10-02">https://itnext.io/write-valuable-automation-tests-a6148ff6090c?source=collection_archive---------1-----------------------#2020-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3ff7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自动化测试不是惩罚。他们的目的不是满足验收标准，通过代码审查，或者满足代码覆盖工具。它们通过防止回归提高了代码的可信度，并减少了手工测试所花费的时间。以下几点说明了如何更有效地使用它们。</p><h1 id="4e2c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">测试行为，而不是实现</h1><p id="bb79" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated"><em class="lo">挑战:</em>只使用函数的输出和参数(签名)编写函数测试。这种策略是测试驱动开发的一个关键组成部分，并将产生更简单的应用程序代码。如果这被证明是有挑战性的，考虑拆分职能以减少复杂性和责任。</p><p id="7a8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面将以假函数为例。它增加一个数，确保下一个数大于前一个数。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">一个人为的增加数字的例子——适用于其他语言。</figcaption></figure><p id="0308" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现测试的目标是函数的内部，以确定如何设置和模拟。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">使用实现来确定模拟的示例测试</figcaption></figure><p id="c02f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">行为测试关注的是结果，并且只能改变函数参数的值(在本例中是没有)。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">关注getNextSequence函数行为的示例测试</figcaption></figure><p id="5272" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两个测试都通过了，但是关注实现的测试没有通过下面的重构。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="cdc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ma mb mc md b">getNextSequence</code>函数的行为没有改变，应用程序仍然工作。然而，实现测试的目标是一个不再存在的隐藏细节，并设置了一个不再有效的模拟。它会失败，这是一个<strong class="jp ir">假阴性</strong>。</p><h2 id="2713" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">什么是假阴性？</h2><p id="e6b5" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">一个假阴性是当一个测试失败时，即使该功能按预期工作；失败不是一个合理的应用程序错误。</p><h2 id="f58b" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">假阴性的危险</h2><ul class=""><li id="0baf" class="mq mr iq jp b jq lj ju lk jy ms kc mt kg mu kk mv mw mx my bi translated">开发人员对测试失去了信心。在编写代码时，通常会手动测试代码变更(TDD可能并不总是遵循)。开发人员会认为别人写的失败的测试是不可靠的，可能会因为浪费时间去理解、更新或删除它而感到沮丧。</li><li id="b7fc" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><strong class="jp ir">开发者对应用失去信心。当一个代码库因糟糕的测试而声名狼藉时，像升级框架这样的大规模改变就会变得令人生畏。这些改变最终被搁置或从未完成。</strong></li><li id="68ed" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><strong class="jp ir">故障排除造成的时间损失。</strong>数百行设置会使根本原因分析变得困难。花在测试代码中诊断bug的时间本可以用在应用程序中的bug上。一个更短的解决方案是禁用被破坏的测试，这会导致覆盖率和可信度的损失。</li><li id="64ab" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><strong class="jp ir">建造时间翻倍或三倍。</strong>间歇性失败的测试是不可靠的。当构建可以通过重新启动来修复时，这就成了故障排除的第一步。当开发人员接受这一规范时，他们可能直到第二次或第三次尝试才看到失败构建的输出。</li><li id="f356" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><strong class="jp ir">增加了人工测试。如果自动化测试不被信任，团队将会退回到手工测试。手动测试速度较慢，容易出现人为错误，而且成本较高，但却提供了缺失的信心。</strong></li></ul><h2 id="97a7" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">什么是误报？</h2><p id="c89b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当测试通过时，即使应用程序被破坏，也会出现误报。</p><p id="0c7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前面的示例中，<code class="fe ma mb mc md b">generateId</code>正在被存根化。假设实际函数有如下定义。</p><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="2df2" class="me km iq md b gy ni nj l nk nl">let counter = 0;<br/>function generateId() {<br/>  // Counting down, not up!<br/>  counter -= 1;<br/>  return counter;<br/>}</span></pre><p id="3775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现测试会错误地通过，因为我们用假数据覆盖了返回值。行为测试将陷入无限循环，超时，并成功失败。</p><p id="f22d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">奖励示例:</p><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="f7c6" class="me km iq md b gy ni nj l nk nl">test('create user', function () {<br/>  createUsers()<br/>    .then((user) =&gt; {<br/>      expect(user.id).to.not.be.null();<br/>    });<br/>});</span></pre><p id="2ae2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的测试没有等待异步<code class="fe ma mb mc md b">createUsers</code>调用完成，所以不管结果如何，它都会通过。根据测试框架的不同，有多种修复方法可用。</p><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="7613" class="me km iq md b gy ni nj l nk nl">// Include a done callback<br/>test('create user', function (done) {<br/>  createUser()<br/>    .then((user) =&gt; {<br/>      expect(user.id).to.not.be.null();<br/>      done();<br/>    });<br/>});</span><span id="7404" class="me km iq md b gy nm nj l nk nl">// return the createUser() promise<br/>test('create user', function () {<br/>  return createUser()<br/>    .then((user) =&gt; {<br/>      expect(user.id).to.not.be.null();<br/>    });<br/>});</span><span id="0b46" class="me km iq md b gy nm nj l nk nl">// use async/await. The test will catch unhandled exceptions<br/>test('create user', async function () {<br/>  const user = await createUser();<br/>  expect(user.id).to.not.be.null();<br/>});</span></pre><p id="507d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，这些类型的误报可能会逃过代码审查。</p><p id="9fa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预防它们的方法:</p><ul class=""><li id="727a" class="mq mr iq jp b jq jr ju jv jy nn kc no kg np kk mv mw mx my bi translated">使用lint插件，如<a class="ae nq" href="https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/prefer-expect-assertions.md" rel="noopener ugc nofollow" target="_blank"> prefer-expect-assertions </a></li><li id="6cf2" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">对于测试驱动的开发，测试从失败状态开始，直到编写了实现才会通过。</li><li id="e7ab" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">有些框架，像<a class="ae nq" href="https://github.com/avajs/ava" rel="noopener ugc nofollow" target="_blank"> ava </a>，除非做出断言，否则不会通过测试。</li></ul><h2 id="7024" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">假阳性的危险</h2><ul class=""><li id="efb6" class="mq mr iq jp b jq lj ju lk jy ms kc mt kg mu kk mv mw mx my bi translated">开发人员对测试失去信心。测试失败了，这是他们唯一的任务。还有哪些测试实际上并不测试任何东西？</li><li id="f6db" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><strong class="jp ir">质量保证(QA)对开发人员失去信心。尽管通过了自动化测试，QA测试人员还是会对测试环境中引入的明显错误感到沮丧。他们会更慢地接受自动化的理念，并觉得有必要手动验证每张票。</strong></li><li id="e144" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><strong class="jp ir">bug发货生产。自动化测试的一个好处是及时验证系统的每个部分。QA测试员是人，根据公司的不同，是不存在的。客户获得了报告bug的责任，这有时可能会导致节目停止。他们可能懒得报告，要么默默地怨恨应用程序，要么转移到另一个平台。</strong></li></ul><h1 id="0d73" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">代码覆盖率是一个指南，而不是代码质量的衡量标准</h1><p id="aa09" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">像<code class="fe ma mb mc md b">nyc</code>这样的工具，通知代码行缺少测试覆盖，给一些管理者的思维带来了有害的变化。百分之百的测试覆盖率产生递减的回报。这种心态鼓励测试实现细节，以便覆盖每个if语句，而不管对行为的影响。在<code class="fe ma mb mc md b">getNextSequence</code>的例子中，开发人员的时间被浪费在为一个不必要的实现测试建立模型，然后诊断一个有效重构产生的假阴性。</p><p id="f7e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这并不意味着覆盖工具是无用的。代码覆盖工具是用来提供帮助的，而不是发号施令的。他们可以在测试完全缺失的地方找到疏忽，或者提供弹药向产品所有者提出关于代码可信度的案例。</p><h1 id="e317" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">不要依赖嘲讽库</h1><p id="6f7a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">许多开发人员认为嘲笑像<code class="fe ma mb mc md b">sinon</code>这样的库是一种代码味道。</p><blockquote class="nr"><p id="57ac" class="ns nt iq bd nu nv nw nx ny nz oa kk dk translated">"代码气味是一种表面迹象，通常对应于系统中更深层次的问题."~马丁·福勒</p></blockquote><p id="ffdb" class="pw-post-body-paragraph jn jo iq jp b jq ob js jt ju oc jw jx jy od ka kb kc oe ke kf kg of ki kj kk ij bi translated">模拟可用于访问未通过参数或类变量公开的内部代码。然而，在远离测试实现细节之后，对它们的需求就减少了。其他的可以通过依赖注入模式移除。请参见下面示例的调整。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">ID生成器函数作为参数传递，而不是导入</figcaption></figure><p id="be98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以直接传递一个函数，而不是存根<code class="fe ma mb mc md b">generatorIdFunction</code>:<code class="fe ma mb mc md b">getNextSequence((lastSequence) =&gt; { return lastSequence + 1; });</code></p><p id="2891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然mocks可能不是必需的，但它们确实有一个方便且富于表现力的API: <code class="fe ma mb mc md b">expect(callback).to.be.calledOnce();</code>然而，它们应该只能通过参数进行有限的访问。</p><h2 id="fc7d" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">处理第三方库</h2><p id="dd5c" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">第三方库不是嘲笑库的理由。使用依赖注入，一个接口很容易被替换成一个假的实现。</p><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="4c72" class="me km iq md b gy ni nj l nk nl">import serverUploader from "./serverUploader";</span><span id="ab9d" class="me km iq md b gy nm nj l nk nl">const uploadToServer(file) {<br/>  if (!file) {<br/>    // This is what we're testing<br/>    throw new Error("You didn't include a file!"); <br/>  }<br/>  <br/>  serverUploader.upload(file);<br/>}</span></pre><p id="f81f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要导入<code class="fe ma mb mc md b">serverUpload</code>，而是将其作为注入的依赖项。</p><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="7339" class="me km iq md b gy ni nj l nk nl">const uploadToServer(serverUploader, file) {<br/>  if (!file) {<br/>    throw new Error("You didn't include a file!"); <br/>  }<br/>  <br/>  serverUploader.upload(file);<br/>}</span></pre><p id="24ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者</p><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="ebf5" class="me km iq md b gy ni nj l nk nl">class ServerUploader {<br/>  constructor(serverUploader) {<br/>    this.serverUploader = serverUploader;<br/>  }</span><span id="9dde" class="me km iq md b gy nm nj l nk nl">  uploadToServer(file} {<br/>    if (!file) {<br/>      throw new Error("You didn't include a file!"); <br/>    }<br/>  <br/>    this.serverUploader.upload(file);<br/>  }<br/>}</span></pre><p id="c7f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着对<code class="fe ma mb mc md b">serverUploader</code>访问的增加，提供一个<code class="fe ma mb mc md b">() =&gt; { // do nothing }</code>的假实现变得微不足道。</p><h2 id="868d" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated"><strong class="ak">应尽可能测试第三方代码</strong></h2><p id="0ab8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">像<code class="fe ma mb mc md b">moment.js</code>这样的外部库有它们自己的测试，所以没有必要覆盖每一种情况，但是明智的做法是覆盖应用程序正在使用的情况，或者至少不故意排除它们。进行这些测试可以捕捉升级版本的错误，并确保在切换到像<code class="fe ma mb mc md b">luxon</code>这样的库时功能仍然存在。</p><h1 id="22ff" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">不测试常量和变量赋值</strong></h1><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="9097" class="me km iq md b gy ni nj l nk nl">function getTodoAction(title) {<br/>  return { type: 'ADD_TODO', title };<br/>}</span><span id="4e55" class="me km iq md b gy nm nj l nk nl">test('returns todo action', function () {<br/>  const todo = getTodoAction('Test');<br/>  expect(todo.type).to.equal('ADD_TODO');<br/>  expect(todo.title).to.equal('Test');<br/>});</span></pre><p id="8448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子可能看起来很极端(我见过)，但是经常发生在受代码覆盖工具支配的开发人员身上。</p><p id="7603" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里没有什么可测试的，因为没有行为。上面的测试是测试一个变量被赋值，这是语言最基本的功能之一。如果失败了，将会有更大的问题需要解决。</p><p id="36ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种测试不仅没有增加价值，而且还减少了价值。每次开发者改变动作的结构或者类型的名字，他们也必须修复<strong class="jp ir">假阴性</strong>测试失败。</p><p id="ffb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些线将被集成和端到端测试隐式地覆盖。</p><h1 id="b0e7" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">以小块的形式提取和测试遗留代码</h1><p id="bee9" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">有时候编写测试是一个巨大的负担，尤其是在处理没有考虑测试的遗留代码时。害怕接触这些代码的开发人员将依赖手工验证来减少工作量。</p><p id="fc56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将代码分割成逻辑上可管理的块可以减轻负担:在一个2000行的函数中取100行相关的代码，并将它们提取到一个单独的文件中。通过分离，可以毫不费力地添加依赖注入等模式。</p><p id="fe00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">劈了一小块后，<strong class="jp ir">停止</strong>。遗留代码可能不会经常更改，而且可能没有多少人完全理解它。由于缺乏自动化，较大的变更会带来风险。为什么不发布一个小的改变，然后在以后的日子里再拆分更多呢？</p><p id="a025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果经理/员工要求彻底改变，这可能无法实现，尽管让他们参与进来的一个方法是使用关键词<strong class="jp ir">减轻</strong>和<strong class="jp ir">风险</strong>。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="b5b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遗留代码库的另一个困难是过时或写得不好的测试。处理一个2，000行的测试文件是很困难的，尤其是当测试相互依赖的时候。幸运的是，为同一个目标拥有两个测试文件是一个合理的解决方案。为新测试创建一个新文件，并将旧文件重命名为<code class="fe ma mb mc md b">filename.deprecated.test.js</code>。</p><h1 id="b7b1" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">编写独立的测试</h1><p id="bb66" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">隔离测试让开发人员更加确信其他测试数据不会产生误报和漏报。考虑下面的例子。</p><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="fda3" class="me km iq md b gy ni nj l nk nl">test('user is created', async function () {<br/>  for (let i = 0; i &lt; 10; i += 1) {<br/>    await createUser();<br/>  }</span><span id="3566" class="me km iq md b gy nm nj l nk nl">  const users = await getUsers();<br/>  expect(users).to.have.lengthOf(10);<br/>});</span></pre><p id="704d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个测试本身不会清理，这意味着在它之后运行的每个测试在数据库中都有十个用户。或者，它可能是另一个没有清除的测试的受害者，这可能导致它意外失败并且难以诊断，特别是如果该用户是在另一个文件中创建的。</p><p id="391e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更安全的方法是每次测试都从一个新的数据库开始，即使运行时间更长。</p><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="124a" class="me km iq md b gy ni nj l nk nl">beforeEach(function () {<br/>  cleanDatabase();<br/>});</span></pre><h1 id="ca77" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">使用测试驱动开发(TDD)</h1><p id="daf7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这种方法论让一些人呻吟；其他人质疑其可行性。目标是在编写函数的实现之前编写函数的测试，使用函数的预期行为作为指南。对于习惯于测试实现细节的人来说，这个任务似乎不合理。</p><p id="1260" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遵循TDD有助于开发人员…</p><ul class=""><li id="d2e2" class="mq mr iq jp b jq jr ju jv jy nn kc no kg np kk mv mw mx my bi translated">想想他们的界面和反应</li><li id="5d30" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">保持小的功能，只有一个责任</li><li id="550b" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">避免测试实现细节——现在还没有！</li><li id="287c" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">想想依赖注入，导致更少或没有模仿。</li></ul><p id="3818" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">何时不使用它:</p><ul class=""><li id="50f9" class="mq mr iq jp b jq jr ju jv jy nn kc no kg np kk mv mw mx my bi translated"><strong class="jp ir">创建概念证明时</strong>。这是可以接受的有明显错误的代码。动作要快，不要费心写测试，因为这只是一个你要扔掉的实验。自动化的缺乏可能会被用作破坏它的杠杆，因为产品所有者可能想要发运它。</li><li id="d52a" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><strong class="jp ir">最终架构不明朗时。有时开发人员直到开始实施时才知道实施中涉及到什么。他们想不出任何类和函数签名，因为他们仍然不确定他们是否采取了正确的方法。在这个阶段编写测试只会浪费时间，因为你很可能会删除/重写它们。</strong></li></ul><h1 id="d06f" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">消除测试中的随机性</h1><p id="2586" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">由于样本的多样性，引入随机性似乎很有吸引力。</p><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="bb38" class="me km iq md b gy ni nj l nk nl">test('planet is created', function () {<br/>  planets = ['mars', 'pluto', ...theRestOfThem];<br/>  randomPlanet = selectRandomFrom(planets);</span><span id="2319" class="me km iq md b gy nm nj l nk nl">  const planet = createPlanet(randomPlanet);</span><span id="a435" class="me km iq md b gy nm nj l nk nl">  expect(planet.name).to.be.oneOf(planets);<br/>}</span></pre><p id="02df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种测试有几个主要缺点:</p><ul class=""><li id="b489" class="mq mr iq jp b jq jr ju jv jy nn kc no kg np kk mv mw mx my bi translated">如果这项测试在冥王星(即<code class="fe ma mb mc md b">planets.filter(p =&gt; p !== “pluto")</code>)上失败，将很难诊断，尤其是在包括银河系以外的行星时。这将被视为<strong class="jp ir">假阴性</strong>，因为测试样本不符合排除Pluto的业务要求。</li><li id="d11b" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">如果没有记录，导致失败的星球将是未知的。为测试进行日志记录是一种代码味道。</li><li id="f5a4" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">不太可能在本地重现故障，构建将在下一次CI运行时传递。该测试将被认为是片状的并被忽略，破坏了增加随机性的初衷。</li><li id="d144" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">每个测试运行只检查一个案例。如果所有的行星都需要检查，那么在大多数框架中可以将它们分成单独的测试。</li></ul><pre class="lp lq lr ls gt ne md nf ng aw nh bi"><span id="e926" class="me km iq md b gy ni nj l nk nl">test.each(planets, 'planet x is created', function () { ... }</span></pre><ul class=""><li id="b204" class="mq mr iq jp b jq jr ju jv jy nn kc no kg np kk mv mw mx my bi translated">想象一下<code class="fe ma mb mc md b">createPlanet</code>调用trims的名字:<code class="fe ma mb mc md b">planet.name.slice(0,4)</code>。这项测试在所有情况下都会失败，除了火星(只有银河系)，在那里它会产生一个<strong class="jp ir">假阳性。</strong></li></ul><blockquote class="on oo op"><p id="c853" class="jn jo lo jp b jq jr js jt ju jv jw jx oq jz ka kb or kd ke kf os kh ki kj kk ij bi translated">类似的事情也发生在我身上。有人在我修改的代码测试中加入了随机性。奇迹般地，测试在本地通过了(10分之一的机会)，并且再一次通过了我的公关。然而，一旦它被合并，我的运气就用完了，每个人的构建都开始失败。我浪费时间试图诊断环境变量的差异，却发现测试是罪魁祸首。</p></blockquote><h1 id="65c3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">编写更多的集成测试</h1><blockquote class="nr"><p id="b488" class="ns nt iq bd nu nv nw nx ny nz oa kk dk translated">编写测试。不太多。主要是整合。吉列尔莫·劳赫</p></blockquote><figure class="ou ov ow ox oy lt gh gi paragraph-image"><div role="button" tabindex="0" class="oz pa di pb bf pc"><div class="gh gi ot"><img src="../Images/910a93bdef254dd5a9132ec7f19756af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-NbT7EN-sOyScm1LISyKA.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">就价值而言，集成测试&gt;单元测试&gt;端到端测试，不一定是频率</figcaption></figure><p id="7dda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个新的范例正在出现，将集成测试放在测试金字塔中最有价值的位置。测试通过以与用户相同的方式运行代码来确保功能和外部系统之间的内聚性。尽管它们可能覆盖了一些单元测试，<strong class="jp ir">单元测试仍然是有价值的。</strong></p><p id="ab0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">集成测试…</p><ul class=""><li id="a4e0" class="mq mr iq jp b jq jr ju jv jy nn kc no kg np kk mv mw mx my bi translated">通过像用户那样使用代码来提供更多的信心。</li><li id="b363" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">限制对实现细节的暴露。唯一可用的访问是输入和输出。</li><li id="5cee" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">比端到端测试更可靠、更快速，后者引入了外部变量，如浏览器、延迟和操作系统。</li><li id="4b3c" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">更少的假阳性和假阴性。</li><li id="1b7d" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">运行时间比单元测试长，因为它们可能会与外部系统(如数据库)交互。</li></ul><p id="ebb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点只是现代处理器的一个小缺点。如果主要关注的是开发速度，有以下几种选择:</p><ul class=""><li id="d535" class="mq mr iq jp b jq jr ju jv jy nn kc no kg np kk mv mw mx my bi translated">慢点。匆忙的代码容易出现人为错误。即将到来的最后期限真的值得因为bug而失去客户吗？</li><li id="d84e" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">限制范围可以为测试创造更多的时间。</li><li id="2866" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">许多测试框架都有一个<code class="fe ma mb mc md b">--watch</code>命令，只运行与变更相关的测试。<em class="lo">国旗不会在CI渠道上运行。</em></li><li id="9f9f" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">考虑一个可以异步或者在分布式环境中运行测试的框架。毕竟，<strong class="jp ir">测试不应该互相依赖。</strong></li><li id="c1c0" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">本地禁用无关测试。大多数框架都有一个选项，只运行当前正在处理的文件或测试。(即<code class="fe ma mb mc md b">describe.only('...</code>)</li></ul><h1 id="ef79" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="8720" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">将与应用程序代码相同的质量放入测试中。如果一个测试没有价值，不要害怕重写它或者完全删除它。不要把测试覆盖率看得太重。考试是为了提供信心，而不是负担或琐事。</p></div></div>    
</body>
</html>