# Type Yoga:使用 TypeScript 的高级特性键入灵活的函数

> 原文：<https://itnext.io/type-yoga-typing-flexible-functions-with-typescripts-advanced-features-6bb3292732bb?source=collection_archive---------4----------------------->

几个月前，我决定将 TypeScript 绑定添加到我的库中。如果您不熟悉， *shades* 提供了一种快速和声明性地描述对象路径的方法，可以用来提取它的值，甚至不变地“修改”它(通过创建一个值已更改的新对象)。如果你想更多地了解这些坏男孩(我认为你应该了解)，你可以看看我在 Reactathon 的演讲。

但是我们如何输入如此灵活的函数呢？例如，[*get*](https://github.com/jamesmcnamara/shades#get)*可以将代表路径的可变数量的不同输入输入到一个对象中，并且仍然推断出该路径末端的输出类型:*

*![](img/0efbaa8efade7e25dbcf7e040dfdc174.png)*

*魔法*

*上图中，`get` 正在创建一个函数，该函数获取一个**用户**对象，提取其`friends` 属性，过滤出只有`goldMember` 状态为`true`的用户，然后从该列表中传递并选择出黄金会员的每个名字。那最终的结果是什么？一个`string[]`。*

*更重要的是，`get`在一个**用户**被传入之前创建了完成所有这些工作的函数。这意味着它不知道它将对一个**用户**进行类型检查。事实上，任何具有`friends`属性的对象，也就是具有`goldMember` 和`name` 属性的对象列表，都可以使用新的 getter 函数，并且会生成一个列表，其中包含新对象上的`name`内容。*

*那么我们如何给如此普通的东西赋予一个有意义的类型呢？嗯，如果我们看看这种新型吸气剂，它有点吓人。*

*![](img/f78f032f092300f2c35de323b2d6a1d8.png)*

*Wowzers*

*![](img/d382d5b269148061c8698c1c424fe3a7.png)*

*请继续关注我几分钟，我们将构建一个这个函数类型的完整版本，包括所有的附加功能。如果您从未使用过 *shades* ，请不要担心，我们将从头开始构建一切，我们将慢慢进入这个池，这样我们就不会失去任何人。您所需要的只是熟悉 TypeScript 及其一些特性。*

# *婴儿学步*

*我们将从创建一个简化版本的`get`开始。这个`get`只接受代表键的字符串，并产生一个新函数，该函数可以接受某个对象并从该对象中提取路径。*

*![](img/8b294204f6752f4a068ec21605fbeb2d.png)*

*在我们开始输入之前，我们将创建一个名为 **HasKey** 的助手类型，这样就不会太混乱了。*

*![](img/32ed05854a09cc7f56d31bca66b5151b.png)*

***HasKey** 是一个[映射类型](http://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)。它表示一个对象，该对象将某个给定的字符串`K`映射到某个值。注意，它需要第二个可选参数`V`，让我们在`K`指定类型，但它默认为`any`。*

*因此，如果我们想定义一个类型 **HasName** ，它有一个映射到**字符串的`name`属性，**我们可以这样做:*

*![](img/04d441be5e9876879535e398027f36fc.png)*

***HasKey** 是一个很一般的类型，乍一看好像不是特别有用。诀窍是我们可以在函数中使用它作为约束来保证我们的输入有我们需要的键。有了这些，我们就可以编写我们的第一个`get` 函数了。*

## *V1:线一直往下*

*![](img/075c39365ca4accb950e76172fbadb3d.png)*

*上面的函数接受一个字符串`K`并产生一个新函数，该函数接受任何对象*，只要该对象*将`K`作为键。这就是 **HasKey** 的神奇之处；我们可以用它作为一个`extends`子句的一部分，来强制我们得到的任何东西都有我们想要的密钥。那么结果类型就是`S`上`K`键的类型。*

*我们还可以将这些堆叠在一起，得到嵌套的访问器:*

*![](img/c427585541f76f4c769c07e4b8509de6.png)*

*嵌套玩偶*

*注意我们现在如何使用可选的第二个参数 **HasKey** ？我们指定我们的输入`S`必须是带有某个键`K1` *的对象，它本身是带有某个键`K2`的对象*。我们可以不断重复这个过程，以保证任何数量的关键点和任何深度路径。*

# *s[现在怎么办？]*

*返回类型中的那个`S[K]`可能不熟悉。它被称为[指数类型](http://www.typescriptlang.org/docs/handbook/advanced-types.html#index-types)。这是 TypeScript 的一个内置特性，允许我们在事先不知道某个对象的键的情况下引用该键的类型。虽然它在我们上面的例子中工作得很好，但坏消息是当我们开始将更多抽象路径如[遍历](https://github.com/jamesmcnamara/shades#traversals)和[虚拟透镜](https://github.com/jamesmcnamara/shades#virtual-lenses)混合到我们的 getters 中时，它将无法处理。*

*好消息是，TypeScript 为我们提供了滚动我们自己的索引类型所需的工具，这些索引类型将与我们需要的任何值组合一起工作。银弹是[条件类型](http://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types)。*

*条件类型就像类型的 if 语句。事实上，他们正是如此。它们让你问一个关于类型的问题，并根据答案返回不同的类型。我们可以用它来创建我们自己的索引类型，称为 **KeyAt。***

*![](img/b96a0722e61d4c4e1b3c8b4f368dd8bb.png)*

***KeyAt** 接受一个对象和一个字符串，而*如果*该对象将该字符串作为键，则返回该键的类型。如果没有，它只是返回 **never** ，一个(顾名思义)永远不可能存在的内置类型。当密钥丢失时， **KeyAt** 仍然可以做*某事*这一事实将允许我们在这样的情况下使用它:我们*知道一个对象将有正确的密钥，但是 TS 在没有一点帮助的情况下无法证明它。这将是编写更复杂的`get`函数的关键。**

*![](img/5e69a55e87bc039fcba85a0694c911b2.png)*

*KeyAt 的作用类似于类型的函数*

## *V2:打他们*

*![](img/9a9dd27252afa5a691784d93ce0077f8.png)*

*这个版本几乎是相同的，除了它使用了与我们在新的**键**上使用的 **HasKey** 相同的嵌套技巧。注意嵌套发生在相反的方向:我们询问什么对象是`KeyAt<S, K1>`，从结果中我们将提取`K2`。*

*我们现在已经创建了一个函数，它接受一个或两个字符串，并产生一个访问器函数，该函数可以接受任何具有给定键的对象，并从中提取正确的类型。我们已经创造了一些相当灵活和真实的世界，我们应该给自己拍一下背。*

*现在我们到了真正要开始用煤气做饭的时候了。*

# *遍历*

*[Traversals](https://github.com/jamesmcnamara/shades#traversals) 表示一种方法，用于过滤我们沿途遇到的对象的*集合*，并继续从集合中的*单个*对象中提取值，将结果汇总到输出的集合中。例如，在我们的 intro 中，`matching`是一个遍历，它过滤掉了`friends`列表，只过滤了拥有黄金会员身份的用户，然后我们能够将他们的所有名字提取到一个列表中。这种行为在*阴影*中是最引人注目的，所以我们肯定想看看如何键入它。*

*![](img/79f59aa4cf91d8b6c53e11dca2fd3e34.png)*

*什么是**遍历**？嗯这只是一个**遍历***

***遍历**描述了一个遍历对象的形状。奇怪的是，我们实际上并不需要它来容纳任何东西。它只是作为一个标记，给`get`一个信号，路径中的这个位置将是`Item`的集合。正因为如此，我们将能够使用同一个对象来处理任何集合类型(比如一个**数组**，一个**对象**，ES2015 **映射** s 和**集合**，甚至是不可变的. js 集合)。对于我们的例子，我们将只使用数组来保持简单(目前)。*

## *V3:遍历和字符串进入酒吧*

*让我们从一个激励人心的例子开始。我们将把用户的`friends`过滤到那些拥有 5 个以上好友的人，然后将他们的名字提取到一个列表中。我们将使用函数`matching`进行过滤，该函数从`A`到`boolean`接受一个过滤函数，并产生一个`Traversal<A>`:*

*![](img/3831098c8ee4dd7a1f2bd4df913125f1.png)*

*在我们开始之前，让我们考虑一下这个问题。我们首先要遍历我们的集合，这意味着我们以某种方式过滤数组。但是过滤根本不会改变输出类型的类型，到目前为止，一切顺利。但是接下来我们要提取名字，所以我们会得到一个字符串列表。这方面的天真尝试会遇到问题:*

*![](img/e92f613577024b9859507edb0b951295.png)*

*我们在返回类型中从我们的**键处**得到一个`never`类型。这是因为`S`并不代表一个**用户**对象。是一个**用户[]** 。我们能从中提取的唯一密钥是`length`、`map`等。我们可以用一些技巧来解决这个问题:*

*![](img/cbe1f8031142bdc3d511b3c40cf365ae.png)*

*如果没有类型签名，沃尔多在哪里*

*你看出区别了吗？我们将类型约束`S`改为集合的*元素*，然后说我们的输入将是一个数组`S`。*

*当我们知道一个容器将要拥有的结构(在本例中是一个**数组**)并且我们想要约束或引用元素类型时，这种方法非常好用。然而，它有一个很大的缺点，而且，我已经在最后一句话里说过了。它要求我们*知道*集装箱将要拥有的结构。我们希望能够编写通用函数，能够同时处理许多不同类型的容器，如 **Map** s、 **Set** s、 **Array** s 和 **Object** s。为此，我们需要拿出大枪。*

# *拆包和收集*

*还记得我们之前讨论过的那些条件类型吗？我们可以使用它们来创建一个非常强大的实用程序类型，名为 **Unpack:***

*![](img/02ead42361bf6fb32070d9107d9d27ff.png)*

*你首先想到的可能是`infer`关键字。这是为我们工作的秘方。当我们问一个条件类型的问题时，例如“这是给定的`F`一个`A`的数组吗？”我们可能不知道确切的类型`A`。`[infer](http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types)`让我们给我们*不知道但 TypeScript 知道的内部类型命名。因此**解包**所做的是允许我们询问给定对象是否是任意数量的集合类型之一(**数组**、**集合**、**映射**、**承诺**等)。)，并计算出该集合中的*是什么类型。***

*![](img/80fef3b61723e3ea33bf856b43187ece.png)*

*这是我们的`get`函数接受多种类型的容器作为输入的第一步。接下来，让我们创建一个**容器**类型，它将包含我们可能想要遍历的所有集合。*

*![](img/82fb9a21edb16bd0cf26c51ed5a569cd.png)*

*所以现在，如果我们回到我们的原始 V3，用集合**替换所有的**数组**，并放入一个精心放置的**解包**，我们将*几乎*拥有一些工作的东西。***

*![](img/4ba0135a5196a7080f5f02d61709ee07.png)*

*你能看出我们结果的问题吗？*

*TS 只知道我们的输出是一个`Collection<string, any>`，但是我们知道它实际上应该是一个`string[]`。这个错误是因为，这正是我们告诉它的。*

# *高等类型*

*先来个简短的题外话，说说为什么上面是个问题。想象一下，你正在编写一个版本的`Array::map`，它适用于各种不同的类型，例如`A[] => B[]`和`Map<K, A> => Map<K, B>`。你会怎么做？(嘶！如果你想要这个，它的[可用](https://github.com/jamesmcnamara/shades#map)在*阴影*。传统的面向对象方法是创建一个接口`Mappable`，然后我们为所有的容器类实现`Mappable`。但是有一个大问题:这将产生与上面相同的问题。*

*![](img/52ba997c585b6e13cada7d656d76f1b8.png)*

*接口**mapable**不知道它将要实现的容器类的类型，所以它只是说函数`map`将返回一个`Mappable<B>`。当我们在我们的**列表**容器类上实现这个时，我们将类型签名匹配到我们的接口，我们的`List::map`也返回一个`Mappable<B>`。但是这意味着我们丢失了类型信息！`List::map`可以返回任何其他实现**可映射**的类。*

*更重要的是，这意味着 TS 不知道`out`是一个**列表**，所以我们不能在我们的输出上调用任何**列表**方法，或者将它传递给一个期望一个**列表**的函数。如果我们想在数据容器上有一个通用的接口，比如列表**列表** s，**地图** s，**集合** s，等等，这确实是个麻烦。(注意，精通 TS 的用户可能会注意到，这个确切的用例实际上是可以修复的，但是一般来说，TS 不能处理像`map`这样的功能，我们将把重点放在那些更一般的问题上。)我们真正想要的是这样的东西:*

*![](img/0bd9effa4a097d3c85c5b4eda5a60c4d.png)*

*对容器进行抽象*

*这种能够说`F`是某种通用容器的想法，我们的函数返回`F<A>`被称为 ***更高级的多态*** ，是 Scala 和 Haskell 等语言的关键部分。唉，TS 不支持( [*还没*](https://github.com/microsoft/TypeScript/issues/1213) )。*

*所以我们要假装。*

# *函子*

*最常见的更高级类型是**函子**，它正是上面的`Mappable<F, A>`:它接受某个类型`F<A>`，一个`(a: A) => B`函数，并返回一个`F<B>`，*，不管那个* `F` *是什么。它实际上只是代表了一种你可以调用的类型。如上所述，我们实际上不能在 TS 中实现这一点，但是我们*可以*选择我们可能想要映射的所有类型，并编写一个版本的**仿函数**来处理其中的任何一个。怎么会？对于我们的老伙伴条件类型:**

*![](img/444f061b8cce411b73bcbb4a646995e0.png)*

*穷人的函子*

*我们使用我们的类型`F`并依次询问它是否是这些容器中的任何一个:**数组**、**对象**、**集合**等等。如果我们得到一个命中结果，我们会指出正确的`F<B>`返回类型应该是什么。*

# *最终草案*

*好吧，这是一个漫长的过程，你一直很有耐心。让我们重温一下我们的 V3，用我们的**仿函数**增强它:*

*![](img/a324d437eef8821954952c789c0ac2d8.png)*

*有用！*

*让我们来看看到底发生了什么变化。我们没有返回一个**集合**，而是使用我们的**仿函数**类来计算出我们想要返回的集合。**函子**想要两个参数:*

1.  *我们正在转换的整个集合对象:`S`。*
2.  *集合的新成员类型。这和以前是一样的；我们希望提取出`S`的成员项上键`K`的类型。我们使用我们的伙伴**打开**来提取集合`S`中的任何内容，然后使用 **KeyAt** 来获得正确的密钥。*

*现在让我们后退一步；我们已经逐步做到了这一点，所以它可能看起来还不是很酷。我们有一个函数`get`，它可以接受一些通用的**遍历**对象和一个随机字符串，并将它们解释为到一些未知对象的抽象路径。我们得到一个函数，它将接受任何与抽象路径匹配的对象，解释该路径对这个对象的意义，并为这个用例构造一个精确而有用的返回类型。*

*它甚至会捕捉细微的错误！例如，如果我们输入`namez`而不是`name`会怎么样？TS 将捕获它，并彻底分析出了什么问题:*

*![](img/b4ca7668409f23cbb8ca82fa11d7e4f3.png)*

*你不能冒险*

*TS 做了大量的工作，创建了一个足够灵活的类型系统来处理我们 JavaScript 程序员使用的所有奇怪的技巧。我们只需要舒服地驾驭它那令人敬畏的力量。*