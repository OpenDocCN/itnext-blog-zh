<html>
<head>
<title>Improve your Dockerfile, best practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进您的docker文件、最佳实践</h1>
<blockquote>原文：<a href="https://itnext.io/improve-your-dockerfile-best-practices-33bf81defabf?source=collection_archive---------9-----------------------#2019-05-05">https://itnext.io/improve-your-dockerfile-best-practices-33bf81defabf?source=collection_archive---------9-----------------------#2019-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a889c139f79b63c247b5f772156a8df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hp7SCiB-r7mzThAyLrOSWQ.jpeg"/></div></div></figure><p id="3e68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，很高兴接受您对主题或改进的建议/Chris</p><p id="dbff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，那么你知道你在码头附近的路。你可能在我的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/docker-from-the-beginning-part-i-ae809b84f89f"> 5部分Docker系列</a>或其他地方找到了它。无论如何，你正处于从理解基础到做得更好的阶段。这就是本文向您展示的内容，尤其是如何提高Dockerfiles的现有基础知识</p><h1 id="ec7d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">资源</h1><p id="b25f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">-<a class="ae kw" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank">docker files的最佳实践</a>这里有一个长长的提示列表。迟早你会想看看这里，改善你的设置。<br/> - <a class="ae kw" href="https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-docker-cli?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank">将您的Docker映像推送到云中的容器注册表</a>您的Docker映像需要存储在Docker Hub的某个地方，这是一个只有您和您的同事才能访问的私有注册表，或者为什么不是云中的私有注册表。</p><h1 id="4f34" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们对Dockerfile的了解</h1><p id="739e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们知道Dockerfile就像一个配方文件，我们可以在其中指定它所基于的操作系统映像、应该安装的库、环境变量、我们想要运行的命令等等。一切都在那里，在文件中指定，它超级清楚你正在得到什么。这是一个很大的进步，以前我们只是在机器上工作，或者花几个小时或几天来安装东西——这是进步。</p><h1 id="5f1a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们的docker文件样本</h1><p id="dfb9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们创建了一个docker文件，让您了解它的样子。让我们讨论一下文件的各个部分，以便更好地理解它。这是:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1493" class="mj ky iq mf b gy mk ml l mm mn">// Dockerfile </span><span id="2ce0" class="mj ky iq mf b gy mo ml l mm mn">FROM node:latest </span><span id="90fe" class="mj ky iq mf b gy mo ml l mm mn">WORKDIR /app </span><span id="f264" class="mj ky iq mf b gy mo ml l mm mn">COPY . . </span><span id="361d" class="mj ky iq mf b gy mo ml l mm mn">RUN npm install </span><span id="892d" class="mj ky iq mf b gy mo ml l mm mn">EXPOSE 3000 ENTRYPOINT ["node", "app.js"]</span></pre><p id="63dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个非常典型的文件。我们选择一个操作系统映像，设置一个工作目录，复制我们需要的文件，安装一些库，打开一个端口，最后运行应用程序。那有什么问题呢？</p><h1 id="1e16" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">操作系统映像大小</h1><p id="bd68" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">乍一看，一切看起来都像我们期望的那样，但是仔细看，我们可以看到我们正在使用<code class="fe mp mq mr mf b">node:latest</code>作为一个图像。让我们尝试使用以下命令将它构建到Docker映像中:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d7dd" class="mj ky iq mf b gy mk ml l mm mn">docker build -t optimize/node .</span></pre><p id="34e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在让我们运行<code class="fe mp mq mr mf b">docker images</code>来查看我们的图像并获取更多的统计数据:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/a35c9ec2042b70c663045e4d64946ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k1GjY7xcOI5QYNQz.png"/></div></div></figure><p id="3853" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它的重量为<strong class="ka ir"> 899 MB </strong> <br/>好了，我们没有什么可以比较的，但是让我们将图像更改为一个名为<code class="fe mp mq mr mf b">node:alpine</code>的图像，并重建我们的图像:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/3ee8eb978004863ff633d6a7ee78cc55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j5om6Oumu18FF5y6.png"/></div></div></figure><p id="96ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 77.7 MB </strong>，哇！！！这是一个巨大的差异，我们的码头形象小十倍。这是为什么呢？</p><p id="cf3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这张图片是基于<a class="ae kw" href="https://alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> Alpine Linux项目</a> <br/>的。一般来说，Alpine Linux图片比正常的发行版要小得多。它带有一些限制，这里有一个阅读<a class="ae kw" href="https://github.com/nodejs/docker-node/tree/a8dbfa5c7cac9dca9145c6f429cd2c4f11176707#nodealpine" rel="noopener ugc nofollow" target="_blank">的</a>。总的来说，这是一个安全的选择。</p><h1 id="0763" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">缓存</h1><p id="42ee" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">对于您在docker文件中指定的每个命令，它都会创建另一个图像层。然而，Docker所做的是，在尝试创建一个层之前，首先检查缓存以查看现有层是否可以重用。</p><p id="7942" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们谈到像添加和复制这样的指令时，我们应该知道它们在缓存的上下文中是如何操作的。对于这两个命令，Docker会计算每个文件的校验和，并将其存储在缓存中。在新构建Docker映像时，会比较每个校验和，如果由于文件中的更改而导致校验和不同，则会重新计算校验和并执行命令。此时，它会创建一个新的图像层。</p><h1 id="c3a4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">秩序至关重要</h1><p id="2dde" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Docker的运营方式是尽量复用。我们能做的最好的事情是把指令放在docker文件中，从最不可能改变的到最可能改变的。</p><blockquote class="mt mu mv"><p id="fe66" class="jy jz mw ka b kb kc kd ke kf kg kh ki mx kk kl km my ko kp kq mz ks kt ku kv ij bi translated"><em class="iq">这是什么意思？</em></p></blockquote><p id="ffdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看docker文件的顶部:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5754" class="mj ky iq mf b gy mk ml l mm mn">FROM node:alpine WORKDIR /app</span></pre><p id="185c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们可以看到FROM命令首先出现，然后是WORKDIR。这两个命令都不太可能改变操作系统，它们被正确地放置在顶部。</p><blockquote class="mt mu mv"><p id="e3d6" class="jy jz mw ka b kb kc kd ke kf kg kh ki mx kk kl km my ko kp kq mz ks kt ku kv ij bi translated"><em class="iq">什么可能会改变？</em></p></blockquote><p id="c12a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，你正在构建一个应用程序，所以你的应用程序的源文件，或者你意识到你可能突然需要的库，比如一个<code class="fe mp mq mr mf b">npm install</code>，放在文件的更下面是有意义的。</p><blockquote class="mt mu mv"><p id="0a75" class="jy jz mw ka b kb kc kd ke kf kg kh ki mx kk kl km my ko kp kq mz ks kt ku kv ij bi translated">这样做我们能得到什么？</p></blockquote><p id="d0a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">速度，我们在构建Docker映像时获得了速度，并且尽可能高效地放置了命令。总之，添加、复制、运行是应该在docker文件中稍后执行的命令。</p><h1 id="e341" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最小化图层</h1><p id="f90c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">您输入的每个命令都会创建一个新的图像层。确保将命令数量保持在最低水平。如果可以的话，把他们分组。而不是写:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0f6a" class="mj ky iq mf b gy mk ml l mm mn">RUN command<br/>RUN command2</span></pre><p id="ade0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像这样组织它们:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="34dd" class="mj ky iq mf b gy mk ml l mm mn">RUN command \<br/>    command2</span></pre><h1 id="110e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">只包括你需要的东西</h1><p id="7884" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当你开发一个应用的时候。它很容易包含大量的文件，但是当你真正需要创建你的Docker图像时，它却是少量的文件。如果你创建了一个<code class="fe mp mq mr mf b">.dockerignore</code>文件，你可以定义一些模式来确保当我们包含文件时，我们只得到我们需要的那些，用于我们的容器。</p><h1 id="36ea" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">定义启动脚本</h1><p id="d51e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">无论你使用命令CMD还是ENTRYPOINT，你都应该像这样直接调用应用程序<code class="fe mp mq mr mf b">node app.js</code>。相反，尝试像这样定义一个启动脚本<code class="fe mp mq mr mf b">npm start</code>。</p><p id="d660" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想确保我们是灵活的，不太可能改变这一指示。我们可能最终会改变我们开始应用程序的方式，逐渐地给它添加标记，就像这样。你知道，这是一个潜在的移动目标。然而，通过我们依靠启动脚本<code class="fe mp mq mr mf b">npm start</code>，我们得到了更灵活的东西。</p><h1 id="8c96" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用标签</h1><p id="141e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">使用命令标签是更好地描述docker文件的好方法。你可以用它来组织文件，帮助自动化和潜在的使用案例，你最清楚什么信息放在那里是有意义的，但它的存在是为了支持你把所有的图像整理得井井有条，所以要充分利用它。标签值是一个键值对，就像这样<code class="fe mp mq mr mf b">LABEL [key]-[value]</code>。每个标签命令可以有多个标签。事实上，它被认为是在一个标签命令下收集所有的标签。您可以通过用空格字符或类似字符分隔每个键值对来做到这一点:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="35d4" class="mj ky iq mf b gy mk ml l mm mn">LABEL key=value \ <br/>      key2=value2</span></pre><h1 id="5263" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用EXPOSE依赖默认端口</h1><p id="395b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">EXPOSE是用来打开容器上的端口的。为了确保我们可以与该端口上的容器对话，我们可以结合使用<code class="fe mp mq mr mf b">-p</code>命令和Docker run <code class="fe mp mq mr mf b">docker run -p [external]: [exposed docker port]</code>。将暴露的端口设置为您正在使用的默认端口被认为是最佳实践，比如apache服务器的端口80和Mongo DB数据库的端口27017等。</p><h1 id="1593" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">明确地说，使用复制而不是添加</h1><p id="4c8b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">乍一看，复制和添加做的是同样的事情，但是有区别。ADD也能提取TAR文件，这是COPY做不到的。所以要明确，当你打算复制文件时使用COPY，并确保只在你打算使用某些特定的特性时使用ADD，比如前面提到的TAR提取。</p><h1 id="2076" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h1><p id="cec8" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">说到Dockerfile，还有很多最佳实践可以遵循，但我在这篇文章中提到的最大收获是使用尽可能小的图像，如alpine。它可以为您的图像大小创造奇迹，特别是如果存储大小是您付费的。</p><p id="86f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请阅读<a class="ae kw" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank"> Dockerfile最佳实践文档</a>了解更多有用的技巧</p></div></div>    
</body>
</html>