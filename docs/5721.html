<html>
<head>
<title>I made Semantic Versioning easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我简化了语义版本控制</h1>
<blockquote>原文：<a href="https://itnext.io/i-made-semantic-versioning-easy-556a4117aaa0?source=collection_archive---------5-----------------------#2021-05-10">https://itnext.io/i-made-semantic-versioning-easy-556a4117aaa0?source=collection_archive---------5-----------------------#2021-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0447" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无论您在什么平台上工作，都可以轻松地将语义版本集成到开发周期中。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0164114d63d8c979ca3d7a101de2da98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZP6rgVSD2XY3rYBT"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">分支和清晰的定义可能会很复杂。基拉·奥德·海德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="ffbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> S </span>软件的动态版本控制——无论我们在哪里谈论微服务或整体应用，都会给工作中的关系带来严重的压力。听起来可能很荒谬——补丁、次要版本和最终主要版本的理论很简单。尽管如此，团队内部实现的难度，即所谓的人为因素，随着项目中开发人员的数量呈指数增长，并随着他们的服务年限而成倍增长。对一个人来说是小事的事情可能被另一个人认为是补丁，带走了作为新发布参与者的快乐，并直接影响了在项目中做出贡献的心情和意愿。</p><p id="e47d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">在我目前从事的一个项目中，对语义版本化的需求变得很明显。微服务无处不在，使用多种语言和技术，自动化部署周期，除此之外，一个经验丰富的工程师团队试图实施最佳实践，带有一点个人偏好偏见和牢不可破的自豪感。最初关于语义的讨论让我思考— <em class="me">我们真的需要经历所有这些吗</em>因为数字本身甚至不是让我们去赞美的，而是让基础设施的所有部分去收集它们可以使用的适当版本。毕竟——这不像是<em class="me"> 1.8.124 </em>会成为我的新纹身，我新生儿的名字或者一个幸运数字，对吧？</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="b0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">我最初的版本化方法远非最佳，容易出错(我的过失)，尽管它是完全自动化的。它允许我推送提交，版本号是自动生成的——允许我识别包含我一直在轻松开发的特定微服务版本的容器。我已经在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/unified-microservices-builds-using-github-actions-3442c4ee175e?sk=e0879dc75de9b9e249d9fee608350369"> Kubernetes、微服务和Github Actions文章</a>中描述了我一直在使用的整个工作流程。它简单地工作，满足了基本要求。使用构建号和GitHub运行对于我的个人项目来说是绝对足够的，这个项目分布在30多个存储库中。尽管如此，我们现在是在一个职业联赛中，我们应该调整方法，以适应semver.org<a class="ae ky" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">所描述的既定标准。</a></p><p id="4a2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原则和问题在实际工作开始之前，我整个周五下午和晚上大部分时间都在问自己:</p><ul class=""><li id="9257" class="mm mn it lb b lc ld lf lg li mo lm mp lq mq lu mr ms mt mu bi translated">如何实现正确的版本控制，而不用花费团队的大部分时间来争论引入的变更是小的还是简单的补丁。</li><li id="b49a" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">谁允许开发人员，那些创建应该被版本化的软件的人同时做出自主的决定。</li><li id="28b2" class="mm mn it lb b lc mv lf mw li mx lm my lq mz lu mr ms mt mu bi translated">最后，让它完全自动化，这样就没人需要浪费时间去摆弄标签和按按钮了。</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><blockquote class="na nb nc"><p id="70fa" class="kz la me lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">12个小时的通宵编码</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ed3b49433ebf07c4bedbc7cffda672a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xVmvbleFPfPt3B92"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼·豪在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> It </span>凌晨5点，解决方案就摆在我面前，我决定公开给大家，一劳永逸地解除手工管理语义版本的负担。几个最后的润色，把它给正在为同一个问题挣扎的朋友测试和收集反馈，导致了一些额外的修复和功能。</p><p id="ba87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为您呈现的是<a class="ae ky" href="https://github.com/lukaszraczylo/semver-generator" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">语义版本生成器</strong> </a>，一夜无眠的成果，希望能在开发过程中节省您的时间和神经。</p><div class="nh ni gp gr nj nk"><a href="https://github.com/lukaszraczylo/semver-generator" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">lukaszraczylo/SEM ver-发电机</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">一夜之间创建的项目，证明语义版本管理并不痛苦，也不需要争论…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div><p id="742f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以作为Linux ( amd64和arm64)、OSX ( amd64和arm 64——所以M1用户不会孤单)和Windows(我个人不喜欢Windows，但也有很多优秀的开发人员)的二进制文件。<br/>最重要的是，如果你想自己运行它，你有amd64和arm64 docker图像，我第一次<a class="nz oa ep" href="https://medium.com/u/8df3bf3c40ae?source=post_page-----556a4117aaa0--------------------------------" rel="noopener" target="_blank"> GitHub </a>行动，我有些自豪，也可以在<a class="ae ky" href="https://github.com/marketplace/actions/semantic-version-generator" rel="noopener ugc nofollow" target="_blank"> GitHub Marketplace </a>上获得。</p><div class="nh ni gp gr nj nk"><a href="https://github.com/marketplace/actions/semantic-version-generator" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">语义版本生成器- GitHub市场</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">一夜之间创建的项目，证明语义版本管理并不痛苦，也不需要争论…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="ob l nv nw nx nt ny ks nk"/></div></div></a></div></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="9e5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">你可能会问，它是如何工作的？原理比较简单。开发人员应该已经提到了自治，我不太喜欢那些在用户身上强加某些命名约定的项目；因此，您有一个包含配置的简单YAML文件。您可以将这个配置文件放在您的代码库中，GitHub操作将在运行过程中获取它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="da1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">词语</strong>部分是配置的核心。它允许您定义关键字集，版本的特定部分将在这些关键字集上递增。我强烈建议任何人不要使用示例配置，并设置足够独特的词语，以免触发误报。</p><p id="e2d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有一个使用任何版本控制的项目，以确保您不会突然从1.5.7之前的版本0.0.5开始，那么Force 部分非常方便。你可以设置程序的次要版本、主要版本和补丁版本(或者其中的任何一个)，应该考虑“默认”的起始值。</p><p id="e262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你注意到<strong class="lb iu">提交</strong>的定义了吗？它将允许您指定提交的散列，计算将从该散列开始。如果你正在使用提到的神秘的<em class="me"> 1.5.7 </em>版本。你决定使用<em class="me">语义版本生成器，</em>但是由于之前缺乏规则，它计算出下一个版本是<em class="me">25 . 32 . 7</em>——你不是一个人，我支持你。指定开始提交后，所有计算都从那里开始。</p><p id="6b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保持适当的顺序，可以使用以下内容作为配置文件的一部分:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="ee98" class="oj ok it of b gy ol om l on oo">force:<br/>  major: 1<br/>  minor: 5<br/>  patch: 7<br/>  commit: 97d3682ed94168600926f9ff6da650403d1f3317</span></pre><p id="d5ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而下一个生产的版本将是<em class="me"> 1.5.9 </em>，因为提交<em class="me"> 97d368 </em>算作一个。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="d6a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">关于措辞设置本身需要记住的几件事</em> </strong></p><p id="2292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在那里放置任何东西，尽管您应该记住，如果您使用<strong class="lb iu"/>作为补丁版本<strong class="lb iu"/>——您很可能会在一个频繁更新的存储库中得到版本1.20.823281。唯一性是关键。</p><p id="896a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单词匹配使用模糊匹配；因此，<em class="me"> whl </em>可以取为<em class="me">轮</em>或<em class="me">鲸</em>。</p><p id="5fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">补丁版本将在每一次提交时在<strong class="lb iu">递增，如果检测到来自指定配置的字，它将再加1。这是为了在<em class="me">挤压</em>的情况下，创造机会添加“空白”版本和补丁发布之间的间隔。</strong></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="9e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对该功能有任何其他建议，请不要犹豫，在存储库内提出问题。我很乐意接受反馈，我收集的想法越多，产生的结果就越好(因为我坚信开源运动和社区的力量)。❤️</p></div></div>    
</body>
</html>