<html>
<head>
<title>How To Reduce Your Tests Boilerplate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何减少你的测试样本</h1>
<blockquote>原文：<a href="https://itnext.io/minimize-your-tests-boilerplate-a871bcf72650?source=collection_archive---------5-----------------------#2018-08-16">https://itnext.io/minimize-your-tests-boilerplate-a871bcf72650?source=collection_archive---------5-----------------------#2018-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="21d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">套件包装简介</h2></div><p id="a64f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试应该是可读的，并且包含理解测试用例所需的最少信息。额外的数据和样板文件会分散读者的注意力，让他们更难理解系统的行为。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/2291b77c61434c9d7b326f9b658de000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ceNqBGrfcqcqd1EHnbzWqQ.png"/></div></div></figure><p id="e5e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">减少额外的信息和样板文件有很多方法。其中之一是使用测试驱动程序，它保存了如何运行被测单元的实现细节，并让测试自己做什么。另一种技术是使用测试套件将外部资源的使用卸载到具有清晰API的套件中。</p><p id="d928" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">驱动程序、测试工具包和其他技术非常有用，也非常值得推荐，但是，它们很容易因为大量的样板文件而适得其反。例如，假设您想要启动一个数据库(当然是在内存中！).您需要从一个连接开始，然后可能通过运行<code class="fe ln lo lp lq b">before</code>和<code class="fe ln lo lp lq b">after</code>块中的代码来关闭它——这些代码与测试并不直接相关，只是为了支持它。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lr"><img src="../Images/8305272c88b651a3a4c288de7b8d21eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AjE7UFShXI-szechkQl8SA.png"/></div></div></figure><p id="c9ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试变得单调乏味，可读性更差。想想需要更多样板文件和启动代码的其他用法。此外，要创建另一个使用相同样板代码的套件，您需要复制/粘贴相同的代码，这会导致代码重复，使系统更难维护。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3351" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是西装包装纸？</h1><p id="8698" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">套件包装器可以帮助我们去除与代码不直接相关的样板文件，而是属于正在使用的测试套件/其他工具。套装包装器保存准备样板并无缝运行它。</p><p id="12ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">suit wrappers实现与测试框架如<code class="fe ln lo lp lq b">mocha</code>、<code class="fe ln lo lp lq b">jest</code>和<code class="fe ln lo lp lq b">jasmine</code>紧密耦合，并为测试提供干净的API。为了实现这一点，我们将使用隐式执行的<code class="fe ln lo lp lq b">before</code>和<code class="fe ln lo lp lq b">after</code>语句来扩展套件。</p><p id="1fa4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">套装包装由3部分组成:</p><ul class=""><li id="97bb" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated">测试框架包装器——提供用特定实现包装测试框架功能的能力。</li><li id="79a5" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">测试套件包装器——使用测试框架包装器，并扩展特定的测试套件功能。</li><li id="12dc" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">测试套件——没有额外样板代码的实际测试。</li></ul><h2 id="f3be" class="nk ma iq bd mb nl nm dn mf nn no dp mj ko np nq ml ks nr ns mn kw nt nu mp nv bi translated">测试框架包装器</h2><p id="02ef" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">测试框架包装器提供了创建定制包装器的功能，并引入了包括测试套件功能的定制套件。<br/>例如，摩卡包装纸:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nw"><img src="../Images/7ebb2ca0fe1da3b90b68130ddf9bf33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjOx92zGEMjIAGfJUtk9Yw.png"/></div></div></figure><p id="5ebd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们导出了一个API，它获得了一个<code class="fe ln lo lp lq b">conf</code>条目，这个条目包含了我们想要添加到suit中的实现。给定一个T1，我们可以在T2阻塞之前运行它。同样的道理也适用于<code class="fe ln lo lp lq b">afterDesc</code>、<code class="fe ln lo lp lq b">beforeIt</code>和<code class="fe ln lo lp lq b">afterIt</code>。</p><h2 id="15b2" class="nk ma iq bd mb nl nm dn mf nn no dp mj ko np nq ml ks nr ns mn kw nt nu mp nv bi translated">测试套件包装</h2><p id="284d" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">测试套件包装器使用测试框架包装器，并为测试套件提供额外的功能。例如，我们可以在这里实现启动和关闭我们想要使用的外部数据库的功能，或者我们想要在测试前后运行的任何其他功能。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nw"><img src="../Images/a50d4cc723fad1ffe7e980e1ab64e0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bgq74TZiHxRX7oYdvwXULw.png"/></div></div></figure><h2 id="3fa3" class="nk ma iq bd mb nl nm dn mf nn no dp mj ko np nq ml ks nr ns mn kw nt nu mp nv bi translated">测试服使用</h2><p id="4737" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">测试套件使用测试套件包装器，并通过简单地使用<code class="fe ln lo lp lq b">mySuit.describe</code>和<code class="fe ln lo lp lq b">mySuit.it</code>将上下文和测试套件对象暴露给测试。测试在没有额外代码的情况下获得了额外的功能，并使测试更加精简。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nx"><img src="../Images/5492cf33e7ddd752d4f12732005ddbaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECsPttxBNYL2a5jHqvaNJQ.png"/></div></div></figure><p id="abe0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的测试看起来简洁明了，然而，很多事情正在进行。在测试实际运行之前，测试套件<code class="fe ln lo lp lq b">before</code>模块执行，然后套件<code class="fe ln lo lp lq b">beforeEach</code>运行，然后是测试，最后是测试套件<code class="fe ln lo lp lq b">after</code>模块。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7098" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">放弃</h1><p id="8ac3" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">套装包装器，作为测试驱动和测试套件，是我们工具包中的工具。我们应该明智地使用它们，因为它们对于简单的场景来说可能是过度的。这种误用会导致过于复杂，并导致代码库不可维护。</p><p id="8313" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了明智地使用这些工具，我建议在不使用工具的情况下编写测试，然后搜索一个实际上会使代码更好的工具。这是我们在遇到一个混乱的测试时所做的——我们尝试的所有其他工具都没有完成工作，测试变得更干净，最后我们想到了套件包装器。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ny"><img src="../Images/e41a3e5d8f7ac2050b9226dcc888c0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hFZmU20xikMU3P1_"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">照片由<a class="ae od" href="https://unsplash.com/@gohrhyyan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Goh Rhy Yan </a>在<a class="ae od" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f5d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一方面，suit包装器的使用会导致共享对象的使用，这些对象很容易被创建，并且会使测试在没有明显原因的情况下失败。由测试包包装器来启动和清理测试包，并维护上下文，这样就不会发生这样的事情。另一方面，suit wrappers可以将对象保存在内存中，并在每次测试之间对环境进行软清理，因此可以更快地运行测试。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="85da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里找到所有的例子:<br/><a class="ae od" href="https://gist.github.com/alonn24/e18fe297fcfd8ad5ca47ce020944d2d9" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/alonn 24/e 18 Fe 297 fcfd 8 ad 5 ca 47 ce 020944 D2 d 9</a></p><p id="831a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读！对这个问题有意见吗？请评论！我很想听听这件事。</p></div></div>    
</body>
</html>