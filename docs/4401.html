<html>
<head>
<title>Create a “Fully private” AKS infrastructure with Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform创建“完全私有”的AKS基础架构</h1>
<blockquote>原文：<a href="https://itnext.io/create-a-fully-private-aks-infrastructure-with-terraform-e92358f0bf65?source=collection_archive---------0-----------------------#2020-06-24">https://itnext.io/create-a-fully-private-aks-infrastructure-with-terraform-e92358f0bf65?source=collection_archive---------0-----------------------#2020-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/14f2c8fd32e0b3f844d714cee7f77212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7QavgNbE9if9GqlZ8Y0dJg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">基础设施来自https://medium . com/@ Dennis zielke/full-private-aks-clusters-without-any-public-IPS-finally-7f 5688411184</figcaption></figure><p id="4d5a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在Azure中，你可以<a class="ae ld" href="https://docs.microsoft.com/en-us/azure/aks/private-clusters" rel="noopener ugc nofollow" target="_blank">创建一个<strong class="kh iu">私有</strong> AKS集群</a>，其中节点池和API服务器之间的流量不会离开私有网络。但是，通常，仅使节点和控制平面之间的通信私有并不足以满足您的安全需求。在<em class="le">完全</em>私有集群中，你也不想暴露和使用公共IP。</p><p id="2e44" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本文详细描述了这种架构:</p><div class="lf lg gp gr lh li"><a href="https://medium.com/@denniszielke/fully-private-aks-clusters-without-any-public-ips-finally-7f5688411184" rel="noopener follow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">完全私有的AKS群集—没有任何公共IP—终于实现了！</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">在我上一篇关于利用azure防火墙的文章发表一年后，我想重温一下这个场景，因为我们刚刚推出了…</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">medium.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw jz li"/></div></div></a></div><p id="3c56" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这里，我将描述Terraform脚本，它将像上面的帖子一样管理确切的基础设施。我只是偶尔解释一下为什么我们需要不同的Azure资源，所以你可能想先看看Dennis的文章。</p><p id="623b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我发现这个项目也是实践不同地形特征的一个很好的例子:</p><ul class=""><li id="1a96" class="lx ly it kh b ki kj km kn kq lz ku ma ky mb lc mc md me mf bi translated">将项目组织成模块</li><li id="e151" class="lx ly it kh b ki mg km mh kq mi ku mj ky mk lc mc md me mf bi translated">定义terraform和提供商版本</li><li id="2516" class="lx ly it kh b ki mg km mh kq mi ku mj ky mk lc mc md me mf bi translated">类型约束</li><li id="64de" class="lx ly it kh b ki mg km mh kq mi ku mj ky mk lc mc md me mf bi translated">each和for_each表达式</li><li id="3ec2" class="lx ly it kh b ki mg km mh kq mi ku mj ky mk lc mc md me mf bi translated">功能</li><li id="55e7" class="lx ly it kh b ki mg km mh kq mi ku mj ky mk lc mc md me mf bi translated">定义显式依赖关系</li><li id="e550" class="lx ly it kh b ki mg km mh kq mi ku mj ky mk lc mc md me mf bi translated">甚至使用置备程序！</li></ul><p id="023e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">源代码可以在这个资源库中找到:<a class="ae ld" href="https://github.com/patuzov/terraform-private-aks" rel="noopener ugc nofollow" target="_blank">https://github.com/patuzov/terraform-private-aks</a></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="dbd8" class="ms mt it bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">资源组</h1><p id="07bd" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">中心网络和分支网络将有两个独立的资源组。因此，在这里，它们位于<em class="le"> main.tf、</em>以及<em class="le"> terraform </em>和<em class="le"> provider </em>块中。</p><p id="f53e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="le">注意，从版本2.5开始，我们将需要azurerm provider，因为这是为AKS群集资源引入</em><strong class="kh iu"><em class="le">outbound _ type</em></strong><em class="le">参数的时候。</em></p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><pre class="nv nw nx ny gt ob oc od oe aw of bi"><span id="d3db" class="og mt it oc b gy oh oi l oj ok">terraform init<br/>terraform apply</span></pre><p id="363a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">…我们可以在Azure门户中看到我们的两个资源组。</p><h1 id="7121" class="ms mt it bd mu mv ol mx my mz om nb nc nd on nf ng nh oo nj nk nl op nn no np bi translated">建立工作关系网</h1><h2 id="7830" class="og mt it bd mu oq or dn my os ot dp nc kq ou ov ng ku ow ox nk ky oy oz no pa bi translated">虚拟网络，子网</h2><p id="a918" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">至于网络，我们将需要一个VNET和一个或多个子网:中心和分支。这是使用<strong class="kh iu">地形模块</strong>的好机会。使用模块，您可以隐藏复杂性，最重要的是，在Terraform中重用代码。</p><p id="38d9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将创建一个<em class="le">模块</em>文件夹和一个<em class="le"> vnet </em>文件夹，其中包含一个模块的所有常用文件:<em class="le"> main.tf、variables.tf、outputs.tf. </em></p><p id="69d7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">虚拟网络资源没有什么稀奇的。只需设置通过输入变量提供的值:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="43b6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，我们可能想要在这个vnet中创建一个子网列表，并且我们需要接收每个子网的以下输入值:名称和IP地址范围。我们可以接收包含以下信息的对象列表作为输入:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="efe5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">…在我看来，这对于这个模块的<em class="le">接口</em>是有意义的。</p><p id="b952" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于每个这样的对象，可以使用<a class="ae ld" href="https://www.terraform.io/docs/configuration/resources.html#for_each-multiple-resource-instances-defined-by-a-map-or-set-of-strings" rel="noopener ugc nofollow" target="_blank"> <em class="le"> for_each </em> </a>表达式创建一个子网资源。但是这个表达式要么需要一个字符串列表，要么需要一个映射。所以我们必须将我们的对象列表转换成一张地图。<em class="le">为</em>表达救场:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="79f7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">表达式的<em class="le">将创建一个映射，将<em class="le"> subnet.name </em>作为关键字，将<em class="le">subnet . address _ prefixes</em>作为相应的值。对于每个这样的键/值对，将创建一个<em class="le"> azurerm_subnet </em>资源。</em></p><p id="7182" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本模块中，我们需要虚拟网络和子网id。我们在<em class="le"> outputs.tf </em>中对此进行了定义。使用同样的<em class="le">技术</em>和<em class="le"> for </em>表达式来获取子网id作为映射:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="da5d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们在我们的main.tf中使用这个模块:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="33dd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您需要再次运行<code class="fe pb pc pd oc b">terraform init</code>来初始化新模块。之后，您可以<em class="le">应用</em>，VNETs也在门户中，在相应的资源组下。</p><h2 id="4006" class="og mt it bd mu oq or dn my os ot dp nc kq ou ov ng ku ow ox nk ky oy oz no pa bi translated">凝视</h2><p id="b9ad" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">现在我们需要对等虚拟网络。<em class="le"> azurerm </em>提供者拥有<em class="le">azure RM _ virtual _ network _ peering</em>资源。但是，由于对等必须双向进行，最好将其抽象到一个新的模块中。</p><p id="a90a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是这个非常简单的模块的<em class="le"> main.tf </em>代码:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ae1b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们是这样使用它的:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="45fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意我们如何使用一个模块的输出作为另一个模块的输入。</p><p id="0463" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不要忘记<code class="fe pb pc pd oc b">terraform init</code>，以便初始化新模块。</p><p id="4991" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果应用此配置，您将在两个虚拟网络下看到<em class="le">peering</em>设置。</p><h2 id="b440" class="og mt it bd mu oq or dn my os ot dp nc kq ou ov ng ku ow ox nk ky oy oz no pa bi translated">防火墙</h2><p id="a97e" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">Azure防火墙将需要一个公共IP，我们还将为AKS需要的所有<em class="le">外部访问</em>配置例外，以便正常运行(如获取映像或操作系统更新)。那么为什么不把它全部隐藏到另一个模块中呢？</p><p id="24d9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里是公共IP的代码，防火墙本身和一个网络规则的例子，用于<em class="le"> aks基础</em>(定义了更多的规则集合——参见<a class="ae ld" href="https://github.com/patuzov/terraform-private-aks/blob/master/modules/firewall/main.tf" rel="noopener ugc nofollow" target="_blank"> git repo </a> ) <em class="le"> : </em></p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="dd36" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们可以使用该模块:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5491" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="le">注意我们如何从网络模块的输出中获得Azure防火墙子网ID。</em></p><h2 id="5be0" class="og mt it bd mu oq or dn my os ot dp nc kq ou ov ng ku ow ox nk ky oy oz no pa bi translated">路由表</h2><p id="4b33" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">最后，我们将创建一个用户定义的路由，强制所有流量(0.0.0.0/0)从AKS子网流向防火墙(具体来说，流向其私有IP)。为此，我们需要创建包含相应路由的路由表，并将其关联到AKS子网。是的，我们将为此创建一个新模块:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="48fa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">并使用该模块:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="3554" class="ms mt it bd mu mv ol mx my mz om nb nc nd on nf ng nh oo nj nk nl op nn no np bi translated">问</h1><p id="d483" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">我们终于准备好定义AKS集群了！</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="dca5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里有两件重要的事情需要提及:</p><ul class=""><li id="1fd5" class="lx ly it kh b ki kj km kn kq lz ku ma ky mb lc mc md me mf bi translated">启用实际私有AKS集群功能:<code class="fe pb pc pd oc b">private_cluster_enabled = true</code>。这也将创建一个<em class="le">私有DNS区域</em>资源，它将有一个<em class="le"> A记录</em>指向API的<strong class="kh iu">私有</strong> IP地址，允许来自AKS VNET(分支)的<em class="le">每个人</em>解析控制平面的地址。</li><li id="60c2" class="lx ly it kh b ki mg km mh kq mi ku mj ky mk lc mc md me mf bi translated">将<em class="le">出站类型</em>设置为<em class="le">用户定义路由</em>，这将阻止为集群的出口流量创建公共IP，并使用“用户定义的”路由表:<code class="fe pb pc pd oc b">outbound_type = "userDefinedRouting"</code>。</li></ul><p id="293c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">还有，你注意到<code class="fe pb pc pd oc b">depends_on</code>的争论了吗？Terraform可以识别资源是否依赖于另一个资源。例如，为了在“aks-subnet”子网中部署这个AKS集群，Terraform知道它必须首先创建vnet和子网。这些是<em class="le">隐式</em>依赖关系。如果Terraform没有<em class="le">看到资源之间的</em>依赖关系，它会【幸运地】并行创建它们。</p><p id="d489" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是在我们的例子中，当我们设置了<em class="le">userdefinerouting</em>出站类型时，AKS将期望有一个与其子网相关联的路由表，所以它实际上依赖于路由表资源。我们可以通过<em class="le">用<code class="fe pb pc pd oc b">depends_on</code>参数显式地</em>定义它，让Terraform知道这个依赖关系。</p><p id="8978" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，由于仍有<a class="ae ld" href="https://github.com/Azure/AKS/issues/1557" rel="noopener ugc nofollow" target="_blank">未解决的问题</a>，我们需要通过定义<em class="le"> azure角色分配，允许创建的服务Prcinipal(通过托管身份)编辑来自<em class="le"> vnet </em>资源组的路由表中的用户定义的路由。</em></p><p id="7a6a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们完事了。我们现在有一个AKS集群，其中的API没有公共端点，只通过Azure Backbone与节点通信。该集群也不会暴露和使用任何公共IP(除了我们允许的那些)。</p><h1 id="d9ab" class="ms mt it bd mu mv ol mx my mz om nb nc nd on nf ng nh oo nj nk nl op nn no np bi translated">跳箱</h1><p id="4e76" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">问题是，由于控制平面不公开任何公共端点，你将无法管理你的集群，比如说，从你的本地机器上使用kubectl，或者甚至从Azure DevOps管道(如果你使用微软托管的代理)使用<a class="ae ld" href="https://docs.microsoft.com/en-us/azure/aks/private-clusters#limitations" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e41c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">还记得上一步中的<em class="le">私有DNS区域</em>吗？只有辐条VNET可以解析API。但是我们也可以连接其他虚拟网络。因此，让我们在Hub VNET创建一个(Linux)虚拟机，在其上安装kubectl，并在私有DNS区域中链接VNET。</p><p id="71cf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">毫无疑问:我将<em class="le">把这一切隐藏在一个单独的模块中。</em></p><p id="efab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我将跳过公共ip、网络安全组等的所有声明。你可以在<em class="le"> jumpbox </em>模块下的<a class="ae ld" href="https://github.com/patuzov/terraform-private-aks/tree/master/modules/jumpbox" rel="noopener ugc nofollow" target="_blank"> github repo中找到它们。以下是最重要的事情:</a></p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="941c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这个演示中，我将为虚拟机管理员创建一个随机密码(使用Terraform的<em class="le"> random_string </em>资源),并在terraform输出中显示它，这样我就可以稍后通过ssh访问虚拟机。</p><p id="79f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可能注意到了VM资源中的一个块，这是Terraform中的一个<em class="le">禁忌</em>:<a class="ae ld" href="https://www.terraform.io/docs/provisioners/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu">remote-exec provisioner</strong></a>。Terraform提供了它们，并恳请您不要使用它们。但是，在这种情况下，它完全符合！我们启动这个虚拟机只是为了测试我们可以从我们的私有网络用kubectl连接到控制平面。而且，由于不愿意手动安装，我将让provisioner在创建VM时自动安装kubectl和azure cli。</p><p id="f56b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如前所述，我们还需要将集线器VNET链接到专用DNS区域(由AKS集群自动创建)。我们可以使用<em class="le">azure RM _ private _ DNS _ zone _ virtual _ network _ link</em>资源轻松实现这一点。</p><p id="ca5a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本模块中，我们需要以下信息:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c1ae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要使用这个模块，我们面临一个挑战:获取专用DNS区域的名称。它是在创建私有AKS集群时由Azure自动生成的(它不是由Terraform直接维护的),它甚至包含一个GUID:</p><p id="374c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="le">9 C3 df 69 f-b281–42ef-9996–89941 b 484906 . private link . westeurope . azmk 8s . io</em></p><p id="e5aa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，它不是随机的。如果您查看API的私有FQDN，您会看到:</p><p id="5611" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="le">私人-aks-7b099028。</em><strong class="kh iu"><em class="le">9 C3 df 69 f-b281–42ef-9996–89941 b 484906 . private link . westeurope . azmk 8s . io</em></strong></p><p id="e9ec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些信息被Terraform所知。我们只需要从中提取专用DNS区域的名称，使用各种Terraform函数:<em class="le"> join，slice，split </em>和<em class="le"> length: </em></p><pre class="nv nw nx ny gt ob oc od oe aw of bi"><span id="2410" class="og mt it oc b gy oh oi l oj ok"><strong class="oc iu">join</strong>(“.”, <strong class="oc iu">slice</strong>(<strong class="oc iu">split</strong>(“.”, azurerm_kubernetes_cluster.privateaks.private_fqdn), 1, <strong class="oc iu">length</strong>(split(“.”, azurerm_kubernetes_cluster.privateaks.private_fqdn))))</span></pre><p id="e39f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">模块的使用方法如下:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="66ed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们想要定义我们的输出:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6fd5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">应用整个配置后，我们得到如下输出:</p><figure class="nv nw nx ny gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pe"><img src="../Images/688dfa920402d3434c5373fc580d18f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2SxN7LEpc7XJbfSDQe-qA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">地形输出</figcaption></figure><p id="778a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们可以ssh到已经安装了kubectl和azure cli的Linux VM。剩下的就是<a class="ae ld" href="https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli?view=azure-cli-latest#sign-in-interactively" rel="noopener ugc nofollow" target="_blank">向Azure </a>认证，<a class="ae ld" href="https://docs.microsoft.com/en-us/cli/azure/aks?view=azure-cli-latest#az-aks-get-credentials" rel="noopener ugc nofollow" target="_blank">获取kubectl </a>的配置，然后我们可以连接到API:</p><figure class="nv nw nx ny gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pf"><img src="../Images/68e12cd17e4261f291ece10ef11fdf85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AW6zSyYj4vHC87if_GdY5A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在私有AKS集群中使用kubectl</figcaption></figure><p id="3e7d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">来自pod的流量将被重定向到Azure防火墙，并将应用相应的规则。让我们检查一下。</p><p id="3be5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<em class="le">防火墙</em>模块中，定义了一个<em class="le">测试</em>规则，它将允许<em class="le">bing.com</em>的流量:</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2226" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们创建一个pod，并尝试从它的容器发出几个请求:</p><figure class="nv nw nx ny gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pg"><img src="../Images/03e4a7781e06551dda7ee64a38fa95f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AbwOCEaquKJ_yrCa3ODzg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">从容器发出外部http请求</figcaption></figure><p id="f10d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这正是我们想要实现的:外部流量被阻止，除非我们有明确的规则允许它。</p></div></div>    
</body>
</html>