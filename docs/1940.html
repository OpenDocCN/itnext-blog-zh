<html>
<head>
<title>Serverless Framework: Deploy a REST API using AWS Lambda and DynamoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器框架:使用AWS Lambda和DynamoDB部署REST API</h1>
<blockquote>原文：<a href="https://itnext.io/serverless-framework-deploy-a-rest-api-using-aws-lambda-and-dynamodb-9c396a49e52?source=collection_archive---------1-----------------------#2019-02-27">https://itnext.io/serverless-framework-deploy-a-rest-api-using-aws-lambda-and-dynamodb-9c396a49e52?source=collection_archive---------1-----------------------#2019-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="7207" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">目标</h1><p id="654d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我之前的教程“<a class="ae lj" href="https://medium.com/@micheleriso/serverless-framework-deploy-an-http-endpoint-using-nodejs-lambda-on-aws-30558422de1b" rel="noopener">无服务器框架:在AWS </a>上使用NodeJS，Lambda部署HTTP端点”中，我们已经学习了如何使用<a class="ae lj" href="http://serverless.com" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>创建一个用<a class="ae lj" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>在NodeJS中实现的<a class="ae lj" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a> HTTP端点。</p><p id="7b55" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">今天我们将学习如何:</p><ul class=""><li id="26bd" class="lp lq iq kn b ko lk ks ll kw lr la ls le lt li lu lv lw lx bi translated">使用Express、Serverless和<a class="ae lj" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>创建并部署带有两个端点(GET、POST)的<a class="ae lj" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST API </a></li><li id="d6e3" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">使用无服务器语法提供一个<a class="ae lj" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>表</li><li id="fd58" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">使用<a class="ae lj" href="https://aws.amazon.com/tools/" rel="noopener ugc nofollow" target="_blank"> AWS SDK </a>连接到DynamoDB</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi md"><img src="../Images/c49650cfa7c3de8c4581aefcb356123b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*MFvtJPjmug6qbWa92mp5UA.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">我们旨在实现的架构</figcaption></figure><h1 id="a068" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是DynamoDB？</h1><blockquote class="mp mq mr"><p id="47d2" class="kl km ms kn b ko lk kq kr ks ll ku kv mt lm ky kz mu ln lc ld mv lo lg lh li ij bi translated">Amazon DynamoDB是一个完全托管的NoSQL数据库服务，提供快速、可预测的性能和无缝的可伸缩性。—docs.aws.amazon.com</p></blockquote><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/4537ee56928c95f2ce5838d5030fd103.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/0*OCyfW1pnOByDsOTc.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">DynamoDB徽标</figcaption></figure><p id="9942" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">简而言之，<strong class="kn ir"> DynamoDB </strong> <em class="ms">是一个无服务器数据库，适用于任何规模都需要高性能的应用</em>。</p><p id="b693" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，在无服务器应用程序中使用无服务器数据库听起来非常正确！</p><h1 id="b582" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">先决条件</h1><p id="8bfd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本教程考虑到您已经学习了我的上一个教程，并且熟悉无服务器的基本概念。如果不是，或者你只是想刷新一下你的思维，请看看“<a class="ae lj" href="https://medium.com/@micheleriso/serverless-framework-deploy-an-http-endpoint-using-nodejs-lambda-on-aws-30558422de1b" rel="noopener">无服务器框架:在AWS </a>上使用NodeJS，Lambda部署HTTP端点”</p><h1 id="2668" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">开始吧！</h1><p id="181d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我之前的教程中，部署一个用硬编码的“Hello Serverless！”然而，它并不那么值钱。今天，我们将了解如何动态地持久存储和检索数据。因此，我们将在一个用户表中创建一个DynamoDB，在这个表中我们将按userId存储用户。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/5834a21dcc434b3754c421c2ee82b047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7___nP5eWtVtX52KxDCmkQ.png"/></div></div></figure><h2 id="9e88" class="nc jo iq bd jp nd ne dn jt nf ng dp jx kw nh ni kb la nj nk kf le nl nm kj nn bi translated">配置无服务器</h2><p id="d9d5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">作为第一步，我们需要配置无服务器，以便:</p><ul class=""><li id="1fa1" class="lp lq iq kn b ko lk ks ll kw lr la ls le lt li lu lv lw lx bi translated">授予我们对DynamoDB的Lambda读写权限</li><li id="af36" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">在资源部分提供用户表</li></ul><p id="a4ca" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们在serverless.yml上复制以下代码</p><pre class="me mf mg mh gt no np nq nr aw ns bi"><span id="34d9" class="nc jo iq np b gy nt nu l nv nw">service: serverless-aws-nodejs-dynamodb</span><span id="4422" class="nc jo iq np b gy nx nu l nv nw">custom:<br/>  tableName: 'users-table-${self:provider.stage}'</span><span id="1025" class="nc jo iq np b gy nx nu l nv nw">provider:<br/>  name: aws <br/>  runtime: nodejs8.10<br/>  stage: dev<br/>  region: eu-central-1<br/>  iamRoleStatements:<br/>    - Effect: Allow<br/>      Action:<br/>        - dynamodb:Query<br/>        - dynamodb:Scan<br/>        - dynamodb:GetItem<br/>        - dynamodb:PutItem<br/>        - dynamodb:UpdateItem<br/>        - dynamodb:DeleteItem<br/>      Resource:<br/>        - { "Fn::GetAtt": ["UsersDynamoDBTable", "Arn" ] }<br/>  environment:<br/>    USERS_TABLE: ${self:custom.tableName}</span><span id="5944" class="nc jo iq np b gy nx nu l nv nw">functions:<br/>  app:<br/>    handler: app.server<br/>    events:<br/>      - http:<br/>          path: /<br/>          method: ANY<br/>          cors: true<br/>      - http:<br/>          path: /{proxy+}<br/>          method: ANY<br/>          cors: true</span><span id="09be" class="nc jo iq np b gy nx nu l nv nw">resources:<br/>  Resources:<br/>    UsersDynamoDBTable:<br/>      Type: 'AWS::DynamoDB::Table'<br/>      Properties:<br/>        AttributeDefinitions:<br/>          -<br/>            AttributeName: userId<br/>            AttributeType: S<br/>        KeySchema:<br/>          -<br/>            AttributeName: userId<br/>            KeyType: HASH<br/>        ProvisionedThroughput:<br/>          ReadCapacityUnits: 1<br/>          WriteCapacityUnits: 1<br/>        TableName: ${self:custom.tableName}</span></pre><p id="5f68" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们可以注意到，我们增加了3个部分:</p><ul class=""><li id="7f04" class="lp lq iq kn b ko lk ks ll kw lr la ls le lt li lu lv lw lx bi translated">Custom:这是一个自定义部分，我们可以使用它来保存我们想要重用的任何类型的配置。特别是，我们正在保存用户表名</li><li id="b237" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><em class="ms"> iamRoleStatements </em>:通过这个部分，我们可以定义lambda函数与AWS DynamoDB交互所需的权限。对于本教程的范围，我们给了Lambda管理员访问权限。在实际场景中，请记住使用“<a class="ae lj" href="https://kb.iu.edu/d/amsv" rel="noopener ugc nofollow" target="_blank">最小特权</a>”原则，并始终给出所需的最小权限</li><li id="8e01" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><em class="ms"> resources </em>:使用这个部分，我们可以使用CloudFormation语法定义AWS需要使用或创建的堆栈(如果不存在的话)。特别是，我们正在定义和提供用户表。如果你不熟悉CloudFormation，请看看亚马逊网站上的官方文档。<a class="ae lj" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank">自动气象站云形成</a></li></ul><h2 id="9c1e" class="nc jo iq bd jp nd ne dn jt nf ng dp jx kw nh ni kb la nj nk kf le nl nm kj nn bi translated">编辑服务器逻辑</h2><p id="a486" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">定义了AWS堆栈之后，我们需要修改NodeJS应用程序，以便:</p><ul class=""><li id="24a8" class="lp lq iq kn b ko lk ks ll kw lr la ls le lt li lu lv lw lx bi translated">实现GET/POST端点:我们将使用GET <code class="fe ny nz oa np b">/user/{userId}</code>来检索用户信息，并使用POST <code class="fe ny nz oa np b">/user</code>来创建一个新的信息</li><li id="8f16" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">与迪纳摩数据库交互</li></ul><p id="d5f7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">作为第一步，我们需要安装AWS SDK和bodyparser。AWS SDK是官方工具，它使我们能够与所有AWS服务和组件进行交互。Bodyparser用于解析HTTP请求的主体</p><pre class="me mf mg mh gt no np nq nr aw ns bi"><span id="a19c" class="nc jo iq np b gy nt nu l nv nw"><em class="ms">$ npm install --save aws-sdk body-parser</em></span></pre><p id="be74" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在，让我们将以下代码复制到app.js中:</p><pre class="me mf mg mh gt no np nq nr aw ns bi"><span id="5232" class="nc jo iq np b gy nt nu l nv nw">// app.js <br/>const sls = require('serverless-http');<br/>const bodyParser = require('body-parser');<br/>const express = require('express')<br/>const app = express()<br/>const AWS = require('aws-sdk');</span><span id="337e" class="nc jo iq np b gy nx nu l nv nw">const USERS_TABLE = process.env.USERS_TABLE;<br/>const dynamoDb = new AWS.DynamoDB.DocumentClient();</span><span id="6b74" class="nc jo iq np b gy nx nu l nv nw">app.use(bodyParser.json({ strict: false }));</span><span id="5bb4" class="nc jo iq np b gy nx nu l nv nw">// Create User endpoint<br/>app.post('/users', function (req, res) {<br/>  const { userId, name } = req.body;</span><span id="d233" class="nc jo iq np b gy nx nu l nv nw">const params = {<br/>    TableName: USERS_TABLE,<br/>    Item: {<br/>      userId: userId,<br/>      name: name,<br/>    },<br/>  };</span><span id="8ff4" class="nc jo iq np b gy nx nu l nv nw">dynamoDb.put(params, (error) =&gt; {<br/>    if (error) {<br/>      console.log(error);<br/>      res.status(400).json({ error: `Could not create user ${userId}` });<br/>    }<br/>    res.json({ userId, name });<br/>  });<br/>})</span><span id="c7ba" class="nc jo iq np b gy nx nu l nv nw">// Get User endpoint<br/>app.get('/users/:userId', function (req, res) {<br/>  const params = {<br/>    TableName: USERS_TABLE,<br/>    Key: {<br/>      userId: req.params.userId,<br/>    },<br/>  }</span><span id="974a" class="nc jo iq np b gy nx nu l nv nw">dynamoDb.get(params, (error, result) =&gt; {<br/>    if (error) {<br/>      console.log(error);<br/>      res.status(400).json({ error: `Could not get user ${userId}` });<br/>    }<br/>    if (result.Item) {<br/>      const {userId, name} = result.Item;<br/>      res.json({ userId, name });<br/>    } else {<br/>      res.status(404).json({ error: `User ${userId} not found` });<br/>    }<br/>  });<br/>})</span><span id="0720" class="nc jo iq np b gy nx nu l nv nw">module.exports.server = sls(app)</span></pre><p id="30e8" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们删除了通用端点，并添加了2个新端点:</p><ul class=""><li id="f0d7" class="lp lq iq kn b ko lk ks ll kw lr la ls le lt li lu lv lw lx bi translated">帖子<code class="fe ny nz oa np b">/users</code>，我们可以用它来创建一个新用户</li><li id="9346" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">GET <code class="fe ny nz oa np b">/users/{userId</code>，我们将使用它来检索提供了userId的用户</li></ul><p id="c335" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为了简单起见，我们没有对请求的参数进行任何安全检查。然而，在真实的场景中，请记住，您至少需要检查类型(例如，如果userId是一个字符串)。在POST请求中，您还可以净化参数以避免最常见的攻击(例如，使用<a class="ae lj" href="https://github.com/cure53/DOMPurify" rel="noopener ugc nofollow" target="_blank"> DOM PURIFY </a>)</p><h2 id="894f" class="nc jo iq bd jp nd ne dn jt nf ng dp jx kw nh ni kb la nj nk kf le nl nm kj nn bi translated">部署！</h2><p id="4988" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们用众所周知的命令<code class="fe ny nz oa np b">sls deploy</code>再部署一次。输出和以前一样，但是这次Serverless也提供了一个DynamoDB。</p><h2 id="ec1b" class="nc jo iq bd jp nd ne dn jt nf ng dp jx kw nh ni kb la nj nk kf le nl nm kj nn bi translated">测试</h2><p id="4dd4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们尝试使用curl创建一个新用户:</p><pre class="me mf mg mh gt no np nq nr aw ns bi"><span id="364d" class="nc jo iq np b gy nt nu l nv nw">$ curl -X POST "<a class="ae lj" href="https://rrp9vypgn3.execute-api.eu-central-1.amazonaws.com/dev/users" rel="noopener ugc nofollow" target="_blank">https://xxxxxxxx.execute-api.eu-central-1.amazonaws.com/dev/users</a>" -d '{"userId":"micheleriso","name":"Michele Riso"}' -H "Content-Type: application/json"</span><span id="ac36" class="nc jo iq np b gy nx nu l nv nw">{"userId":"micheleriso","name":"Michele Riso"}%#THE OUTPUT</span></pre><p id="a9bc" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在找回它:</p><pre class="me mf mg mh gt no np nq nr aw ns bi"><span id="8e24" class="nc jo iq np b gy nt nu l nv nw">$ curl -X GET "<a class="ae lj" href="https://rrp9vypgn3.execute-api.eu-central-1.amazonaws.com/dev/users/micheleriso" rel="noopener ugc nofollow" target="_blank">https://xxxxxxxx.execute-api.eu-central-1.amazonaws.com/dev/users/micheleriso</a>" -H "Content-Type: application/json"</span><span id="563f" class="nc jo iq np b gy nx nu l nv nw">{"userId":"micheleriso","name":"Michele Riso"}% #THE OUTPUT</span></pre><p id="d84a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们在DynamoDB上创建了一个新用户！真的很酷，不是吗？:-)</p><h1 id="2e3d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="d006" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本教程中，我们学习了如何使用无服务器框架将REST API Lambda函数互连部署到DynamoDB。</p><p id="57f4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在下一个教程中，<a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/serverless-framework-warming-up-aws-lambda-to-avoid-cold-start-2be579475531"> <strong class="kn ir">无服务器框架:预热AWS Lambda以避免“冷启动”</strong> </a>，我们将了解什么是AWS Lambda函数的“冷启动”问题，以及如何使用无服务器框架来解决它</p><p id="ea78" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这里链接到<a class="ae lj" href="https://bitbucket.org/mriso/serverless-aws-nodejs-dynamodb" rel="noopener ugc nofollow" target="_blank">比特桶回购</a></p></div></div>    
</body>
</html>