<html>
<head>
<title>C++20 — Practical Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++20 —实用协同程序</h1>
<blockquote>原文：<a href="https://itnext.io/c-20-practical-coroutines-79202872ebba?source=collection_archive---------2-----------------------#2021-11-30">https://itnext.io/c-20-practical-coroutines-79202872ebba?source=collection_archive---------2-----------------------#2021-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f455" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在C++20中，编写定制的协程不是一项简单的任务。在本文中，我将通过三个越来越复杂的协程示例来指导您。</p><p id="68da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然本文将详细解释每个例子，但我不会深入研究协程的基础知识。为此，请阅读我的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/c-20-coroutines-complete-guide-7c3fc08db89d"> C++20协程</a>文章。所有的例子都来自我的<a class="ae kl" href="https://github.com/HappyCerberus/ces" rel="noopener ugc nofollow" target="_blank">协程Epoll和套接字库</a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/875511ea307af70fbc6ec076e180fe8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SrIceZNM-ZPzLFrPIyorA.png"/></div></div></figure><h1 id="330b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">同步协同程序</h1><p id="ee7d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">最简单的协程是行为像普通函数的协程。因此，当然，实现这样一个协程似乎是没有意义的。但是请记住，我们不能在协程之外使用像<code class="fe mb mc md me b">co_await</code>这样的协程关键字。所以为了方便起见，我们可以为异步main编写一个特殊的协程类型。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2f13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与完全同步的协程的主要区别是我们在<code class="fe mb mc md me b">final_suspend()</code>中返回<code class="fe mb mc md me b">std::suspend_always</code>(第8行)。如果没有这个，promise将在协程结束运行时被破坏。但是，我们用承诺来存储结果。我们在<code class="fe mb mc md me b">return_value</code>(第10行)中设置它，在<code class="fe mb mc md me b">co_return</code>上调用它，然后在到<code class="fe mb mc md me b">int</code>操作符的转换中读取它(第23行)。</p><p id="7d45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要写一个析构函数，因为协程现在必须被显式销毁(第20行)。</p><p id="f14a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以用这个协程来代替<code class="fe mb mc md me b">main</code>,如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3834" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的<code class="fe mb mc md me b">async_main</code>中，我们现在可以在其他协程上<code class="fe mb mc md me b">co_await</code>了。</p><h1 id="af2e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">可链接的协程</h1><p id="315c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">协程的一个引人注目的特性是对称传输的能力。使用同步代码，我们很少需要关心栈空间的耗尽。然而，在异步代码中，只执行一小块代码，然后将控制权交给程序的另一部分是很常见的。避免堆栈空间问题需要精心设计。有了协程，我们可以完全依靠编译器生成的代码来避免这个问题。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="57d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在下一节讨论<code class="fe mb mc md me b">chainable_task</code>，不过，让我们先来看看这里发生了什么。我们根据<code class="fe mb mc md me b">async_op()</code>的结果调用<code class="fe mb mc md me b">co_await</code>。这就需要结果类型<code class="fe mb mc md me b">chainable_task</code>提供所需的<code class="fe mb mc md me b">await_ready()</code>、<code class="fe mb mc md me b">await_suspend()</code>和<code class="fe mb mc md me b">await_resume()</code>接口。用<code class="fe mb mc md me b">await_resume()</code>提供结果值。</p><p id="4901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从调用者的角度来看，这就像同步调用一样。调用结束后，调用方被挂起，只在结束时继续读取结果值。然而，在后台，我们改为链接协程而不嵌套它们。</p><p id="319a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看后台发生了什么:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a2bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把重点放在关键部分。首先，第43–48行上的可编辑界面相对简单:</p><ul class=""><li id="dc57" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">我们希望调用者暂停，所以我们在<code class="fe mb mc md me b">await_ready()</code>中返回<code class="fe mb mc md me b">false</code></li><li id="952a" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">在<code class="fe mb mc md me b">await_suspend()</code>中，我们记住调用者的句柄(调用者在最后一个例子中是<code class="fe mb mc md me b">demo()</code>)并返回我们的句柄，这将恢复这个协程(在最后一个例子中是<code class="fe mb mc md me b">async_op()</code>)</li><li id="6c84" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">在<code class="fe mb mc md me b">await_resume()</code>中，我们返回存储的结果</li></ul><p id="1a62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，承诺类型(第16-19行)本身就是我们设定任务主要行为的地方:</p><ul class=""><li id="9875" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">我们在<code class="fe mb mc md me b">initial_suspend()</code>中暂停，将控制(和<code class="fe mb mc md me b">chainable_task</code>的一个实例)返回给调用者，调用者然后调用前面讨论的<code class="fe mb mc md me b">co_await</code></li><li id="dcb9" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">在<code class="fe mb mc md me b">final_suspend()</code>中，我们希望将控制权交还给调用者，所以我们返回一个特殊的可调用对象，该对象返回(第5行)我们存储在第45行<code class="fe mb mc md me b">await_suspend()</code>中的句柄</li><li id="6366" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">最后，第19行上的<code class="fe mb mc md me b">return_value()</code>方法存储结果，然后在第48行上的<code class="fe mb mc md me b">await_resume()</code>中读取结果</li></ul><p id="cd39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些加在一起是为了链接执行，而不是嵌套执行。这是一个很大的挑战，所以如果你还在挣扎，我建议你获取库代码，并在构造函数和析构函数中添加调试打印。它将允许您在更改代码时观察行为的变化。</p><h1 id="d6c0" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">分离的任务</h1><p id="d769" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">到目前为止，我们只讨论了线性执行模型。我的意思是，我们编写的代码仍然表现得像完全同步的代码。当我们写<code class="fe mb mc md me b">co_await some_coro()</code>时，下面一行将只在<code class="fe mb mc md me b">some_coro()</code>结束运行时执行。</p><p id="f866" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象这样的代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fe50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们从未在server1上收到连接，该代码将阻止server2接受连接，即使我们有很多连接。当然，我们可以在单独的线程上产生这些，但是我们可以避免这种情况，仍然可以用协程在一个线程上运行所有的东西。</p><p id="da1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从概念上讲，我们希望在外部事件(连接到达、要读取的数据、定时器到期等)发生时阻止协程。)处于挂起状态，并且只有当我们确定它们有工作要做时才恢复它们。</p><p id="508f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，我们需要引入一个全局组件，一个协程调度器。我们希望调度程序成为一个生成器风格的协程，它保持循环，并将控制权让给可以运行的协程:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="39b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发射器是事件的外部来源(连接到达、套接字准备写入、条件评估为真、超时过期等)。).然后，调度程序将接收到的事件映射到被它阻塞的相应协程，并恢复它:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="708e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在CES库中，被事件阻塞的协程句柄是发出事件的一部分。因此，我们只需使用一种特殊的可唤醒类型切换到协程。</p><p id="08ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有一种方法来恢复暂停的协程。然而，我们仍然需要另一方面，这是一种挂起协程并在调度程序中注册它的方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="6e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种适当的类型存储阻塞协程的事件的延续和信息。在<code class="fe mb mc md me b">await_ready</code>中，当协程<code class="fe mb mc md me b">co_awaits</code>条件已经成立时，我们也处理提前返回的情况。第14行的<code class="fe mb mc md me b">notify_emitters</code>调用是上一个例子中<code class="fe mb mc md me b">notify_departure</code>调用的反向调用。发出通知的发射器将注册要被观看的事件，离开将取消注册该事件以减轻fantom事件。</p><p id="73ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">难题的最后一部分是调用协程来产生多个分离的协程的方法。除此之外，我们还需要一种方法将事件发射器添加到调度程序中。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="4a8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个接口，多个协程可以排队，然后调度程序通过调用<code class="fe mb mc md me b">run</code>恢复。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="421b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="4ab6" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">所有的代码例子要么直接取自一个简化的来自<a class="ae kl" href="https://github.com/HappyCerberus/ces" rel="noopener ugc nofollow" target="_blank"> CES: Coroutines，Epoll和Sockets库</a>。这个库使用GCC 12的主干版本进行了测试和运行。</p><h1 id="cdc3" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="badf" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="ae83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在<a class="ae kl" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae kl" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>