<html>
<head>
<title>GraphQL: Centralize existing REST API endpoints for easier development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL:集中现有的REST API端点以便于开发</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-centralize-existing-rest-api-endpoints-for-easier-development-abd7b007d7c4?source=collection_archive---------5-----------------------#2020-08-27">https://itnext.io/graphql-centralize-existing-rest-api-endpoints-for-easier-development-abd7b007d7c4?source=collection_archive---------5-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/8427d69614fad1f1ab98abf15f56e835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*HCSpp3QecZ17LztL.png"/></div></figure><p id="0573" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">API网关非常适合开发团队，因为它们在一个中心位置公开了各种不同用途所需的数据。有一些很棒的REST API网关，比如<a class="ae kv" href="https://www.krakend.io/" rel="noopener ugc nofollow" target="_blank"> KrakenD </a>，但是如果您想换一个方向，选择GraphQL作为您的API基础设施，该怎么办呢？嗯，这很完美，因为这是GraphQL的目标之一:将许多不同的服务抽象到一个地方，并允许开发人员对他们需要的数据进行非常细粒度的控制。</p><p id="3cda" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇文章中，我们将查看一个GraphQL实现，它牢记着前面的句子:将现有的REST API端点抽象到一个快速的GraphQL服务器中。为了构建GraphQL服务器，我们将使用Golang:它速度快，内存效率高，提供的工具刚好够用，但不会太多。我们将使用的GraphQL包是github.com/graphql-go/graphql的T2。这个包与JavaScript实现<a class="ae kv" href="https://github.com/graphql/graphql-js" rel="noopener ugc nofollow" target="_blank"> graphql-js </a>非常接近。这使它成为一个完美的候选，因为您将能够遵循JavaScript教程，并能够移植它。</p><h1 id="3b5e" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">入口点</h1><p id="e8ef" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">为了展示如何在GraphQL中抽象现有的REST API端点，我们需要一个示例项目。我已经在<a class="ae kv" href="https://github.com/roelofjan-elsinga/graphql-rest-abstraction" rel="noopener ugc nofollow" target="_blank">github.com/roelofjan-elsinga/graphql-rest-abstraction</a>创建了一个示例项目。在这篇文章中，你可以用它来跟进，因为我将介绍GraphQL服务器的不同部分，并解释发生了什么。</p><p id="3844" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的GraphQL服务器的入口点是<a class="ae kv" href="https://github.com/roelofjan-elsinga/graphql-rest-abstraction/blob/master/main.go" rel="noopener ugc nofollow" target="_blank"> main.go </a>。这里我们指定了GraphQL服务器中的两个资源:users和user。</p><p id="c5ec" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们打算使用一个伪<a class="ae kv" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> REST API服务</a>来获取所有用户和单个用户的JSON数据。“用户”资源将用于获取在<a class="ae kv" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users</a>的所有用户，而“用户”资源将用于从<a class="ae kv" href="https://jsonplaceholder.typicode.com/users/1" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users/1</a>获取单个用户的ID或我们可用的任何其他用户。</p><h1 id="9753" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">获取所有用户</h1><p id="8dad" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">现在我们有了一个可以使用的REST API，我们可以创建一个资源来通过GraphQL资源获取这些数据。您可以在<a class="ae kv" href="https://github.com/roelofjan-elsinga/graphql-rest-abstraction/blob/master/queries/users.go" rel="noopener ugc nofollow" target="_blank">查询/用户中找到该资源。</a></p><p id="9f7f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这里你会发现一个方法“fetchUsers”，在这里我们调用REST API端点并将数据转换成Go结构，它位于<a class="ae kv" href="https://github.com/roelofjan-elsinga/graphql-rest-abstraction/blob/master/models/user.go" rel="noopener ugc nofollow" target="_blank"> models/user.go </a>中。我们的字段“Users”将从“fetchUsers”返回用户切片。</p><p id="8309" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在“users”字段声明中，我们指定了我们期望从这个GraphQL资源接收的类型:graphql。NewList(userObject)。我们告诉GraphQL我们正在返回多个用户。userObject是我们的GraphQL资源之一，你可以<a class="ae kv" href="https://github.com/roelofjan-elsinga/graphql-rest-abstraction/blob/master/queries/users.go#L134" rel="noopener ugc nofollow" target="_blank">在这里</a>查看它的全部内容。这里的内联代码太多了，所以我把它链接到了源代码中你需要的那一行。userObject本身也包含字段和嵌套对象(<a class="ae kv" href="https://github.com/roelofjan-elsinga/graphql-rest-abstraction/blob/master/queries/users.go#L77" rel="noopener ugc nofollow" target="_blank">地址</a>和<a class="ae kv" href="https://github.com/roelofjan-elsinga/graphql-rest-abstraction/blob/master/queries/users.go#L13" rel="noopener ugc nofollow" target="_blank">公司</a>)。这些嵌套对象也链接到确切的行。如您所见，对象可以嵌套在嵌套对象中。</p><p id="aa96" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">既然我们已经指定了所有字段，并且可以从REST API中检索数据，那么是时候尝试一下我们的新GraphQL资源了。按照<a class="ae kv" href="https://github.com/roelofjan-elsinga/graphql-rest-abstraction#how-to-launch-the-server-for-development" rel="noopener ugc nofollow" target="_blank">设置步骤</a>(只有4个，很简单)尝试执行以下GraphQL查询:</p><p id="3cd3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，您应该看到所有用户都出现在响应中，但只有我们在查询中指定的字段:</p><p id="124f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我已经编辑了其余的用户，以避免这段代码太长。如您所见，正如我们对GraphQL的期望，我们只返回请求的字段。</p><h1 id="21dc" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">获取单个用户</h1><p id="549f" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">既然我们已经看到可以检索所有用户，我们还将检索单个用户。userObject与我们之前看到的相同，所以我不会再重复，但是“user”的字段声明与“users”相比有了一点变化，查询也是如此。让我们先看看字段声明。它位于<a class="ae kv" href="https://github.com/roelofjan-elsinga/graphql-rest-abstraction/blob/master/queries/user.go" rel="noopener ugc nofollow" target="_blank"> queries/user.go </a>中，如下所示:</p><p id="f640" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有三个主要区别:</p><ol class=""><li id="b234" class="lz ma it jz b ka kb ke kf ki mb km mc kq md ku me mf mg mh bi translated">我们期望的类型现在是userObject而不是graphql。NewList(userObject)。我们只期待1个用户。</li><li id="86ff" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">我们的字段声明有一个Args键。我们用它来告诉服务器我们需要一个用户ID来进行查询，并且不能为空:graphql。NewNonNull(graphql。Int)</li><li id="da51" class="lz ma it jz b ka mi ke mj ki mk km ml kq mm ku me mf mg mh bi translated">我们将用户ID传递给fetchSingleUser方法，并将其附加到REST端点</li></ol><p id="43ca" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我提到GraphQL查询现在也发生了变化，所以让我们看看它是什么样子的:</p><p id="3906" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该查询需要提交一个user_id(类型为Int！)，所以我们可以使用{"user_id": 1}或者您希望从API端点检索的任何user_id来实现。</p><p id="35be" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该查询产生以下响应:</p><p id="23d0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如您所见，我们现在只有ID为1的用户。</p><h1 id="b707" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="cc81" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">本指南向您展示了如何使用GraphQL创建API网关，从而在您现有的REST API端点之前创建一个抽象层。还缺少一些东西，比如身份验证，一个用于高效数据获取的数据加载器，但是这是一个简单的例子来展示它是如何工作的。使用这种方法，您可以在GraphQL中一点一点地扩展您的API网关，并覆盖您的整个REST API端点列表，而不会干扰您现有的客户。您现有的客户仍然可以从您的REST API中获取数据，但是随着时间的推移，您可以帮助他们迁移到您易于使用的GraphQL API网关。</p><p id="de57" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">发布时间:2020年8月26日</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="b2f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="mu">最初发表于</em><a class="ae kv" href="https://roelofjanelsinga.com/articles/graphql-centralize-existing-rest-api-endpoints" rel="noopener ugc nofollow" target="_blank">T5【https://roelofjanelsinga.com】</a><em class="mu">。</em></p></div></div>    
</body>
</html>