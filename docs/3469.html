<html>
<head>
<title>Scalability in NodeJS: Creating a Zero-downtime cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS的可伸缩性:创建零停机集群</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-zero-downtime-cluster-in-nodejs-ad879ee3160?source=collection_archive---------4-----------------------#2019-12-21">https://itnext.io/creating-a-zero-downtime-cluster-in-nodejs-ad879ee3160?source=collection_archive---------4-----------------------#2019-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="357e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一次我们将构建一个系统，它使用节点<strong class="js iu">集群模块</strong>来克隆实例，并以更好的方式管理我们的请求。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b7e6e9a41e49b151c36b9339c25dac74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vQy-Cxd609j5lqYM.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">在NodeJS中创建零停机集群</figcaption></figure><p id="a2b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了介绍这篇文章，我想引用书中著名的scale cube模型:<em class="le">《可伸缩性的艺术:现代企业的可伸缩Web架构、流程和组织》，作者:</em> <em class="le"> Martin L. Abbott和Michael T </em>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/592804adf2a41b095b2c7d2d4f375e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*vg7OmsTnpeUZbaRYxkF_7w.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">缩放立方体模型</figcaption></figure><p id="9d1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个可伸缩性的三维模型中，原点(0，0，0)代表可伸缩性最低的系统。它假设系统是部署在单个服务器实例上的一个整体。如图所示，一个系统可以通过在三维空间中投入适当的努力来扩展。</p><ul class=""><li id="d6cc" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated"><strong class="js iu"> x轴:</strong>克隆</li><li id="1865" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><strong class="js iu"> y轴:</strong>按服务/功能分解</li><li id="fb0c" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated"><strong class="js iu"> z轴:</strong>按数据分区分割</li></ul><p id="a360" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个整体的、未扩展的应用程序最直观的演变是沿着x轴<em class="le">向右移动</em>，这很简单，大多数时候不贵(就开发成本而言)，而且非常高效。这项技术背后的原理很简单，即克隆同一个应用程序<em class="le"> n次</em>并让每个实例处理工作负载的1/n。</p><p id="27f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">沿着y轴<em class="le">扩展意味着根据应用的功能、服务或用例来分解应用。在大多数情况下，这意味着从一个单一的应用程序分解成更小的服务。</em></p><p id="f00d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<em class="le"> z轴</em>缩放中，应用程序被分割，每个实例只负责全部数据的一部分。这是一种主要用于数据库的技术，也叫做<strong class="js iu">水平分区或分片。</strong></p><p id="93e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑到应用程序的复杂性，只有在其他两个应用程序得到充分利用，并且我们的应用程序具有真正值得在这种复杂扩展类型上投资的规模时，才应该考虑沿着<em class="le"> z轴</em>扩展应用程序。</p><p id="6157" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="le"> y轴</em>缩放是一个包含大量信息的主题。主角会是第一个:<em class="le"> x轴</em>。</p><p id="53a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你曾在任何云应用中工作过，它可能已经在使用任何<strong class="js iu">扩展机制</strong>来克隆实例，例如通过自动扩展策略。</p><p id="b478" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很好，也很有效。但是，它<strong class="js iu">是有成本的。</strong>任何云提供商都会向您收取以下费用:</p><ul class=""><li id="d8f3" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">使用负载平衡器</li><li id="d25f" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">添加更多机器</li><li id="c611" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">垂直扩展机器</li></ul><p id="2081" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一种机制不太常见，但可能会发生。</p><p id="1fe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然那东西很好，也很必要；我们能从代码方面做些什么来降低成本和增加灵活性呢？<strong class="js iu">创建集群。</strong>🚀</p><p id="223c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了执行它，我们需要使用来自节点的<a class="ae lu" href="https://nodejs.org/api/cluster.html" rel="noopener ugc nofollow" target="_blank">集群模块。集群模块简化了同一应用程序新实例的<strong class="js iu">分叉</strong>，并自动在它们之间分配传入连接，如下图所示:</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lv"><img src="../Images/54f63cf5467db9dccf022a62e6309683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZlU22WLcbO-DgARx.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">集群模块</figcaption></figure><p id="99a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主进程接收信号，发出日志，并负责生成大量进程(<strong class="js iu"> workers </strong>)，每个进程代表我们想要扩展的应用程序的一个实例。他们都使用同一个商店。然后，每个传入的连接通过克隆的工作线程进行分配，在它们之间分配负载。</p><p id="34eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">扩展应用程序还带来了其他优势，特别是即使在出现故障或崩溃的情况下也能保持一定的服务水平。这个属性也被称为<strong class="js iu">弹性</strong>，它有助于系统的可用性，是维护一个<strong class="js iu"> SLA </strong>的关键。</p><p id="d629" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有两种常见的情况会影响我们的SLA:</p><ul class=""><li id="3b54" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">出现错误</li><li id="ca61" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">代码需要更新</li></ul><p id="f6a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这两种情况下，应用程序都需要重启，所以有一个小窗口，我们的应用程序<strong class="js iu">不可用。</strong>💥使用集群模块，这是一个非常简单的任务；该模式包括<strong class="js iu">一次重启一个工人。</strong>通过这种方式，剩余的工作人员可以继续操作和维护可用的应用程序服务。我们来实现这个吧！💻</p><p id="2e89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> app.js </strong>非常简单，如下图所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/a686aa6ce01484440c598821ccd41028.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*5Ws2rb8o8hYlFUzTJQljRA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">app.js</figcaption></figure><p id="3b33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它通过发回包含其<strong class="js iu"> PID </strong>的消息来响应任何请求；这将有助于识别应用程序的哪个实例正在处理请求。此外，为了模拟一些实际的CPU工作，我们执行了1000万次空循环；如果没有这一点，考虑到我们将为这个例子运行的小规模测试，服务器负载将几乎为零。</p><p id="ae89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们尝试使用集群模块来扩展我们的应用程序。为了便于解释，我分成了几个小部分。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/5e58ecb11d317230fac0abe10a4bf0ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*l-Vj6MROeIRkAOC8hzmflQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">集群应用第1部分</figcaption></figure><p id="d294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，在需要模块之后，我们只为主线程创建一个if语句。在内部，我们获得CPU的数量，然后，我们使用<strong class="js iu"> fork </strong>函数通过CPU创建一个worker。后面，fork使用<a class="ae lu" href="https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options" rel="noopener ugc nofollow" target="_blank"> child_process.fork() </a>来实现拆分。</p><p id="1302" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们为<a class="ae lu" href="https://nodejs.org/api/cluster.html#cluster_event_exit" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">出口事件</strong> </a>创建一个监听器。这一部分很重要，因为当一个错误发生时，实例会死亡，但是我们再次使用<strong class="js iu"> fork </strong>创建另一个实例。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ly"><img src="../Images/88408b9ffc2ae13513a7da9f4d2d0d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*WD5RorG9R_l_CD8Uc0n7yw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">集群应用第二部分</figcaption></figure><p id="b5bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当进程终止时，我们需要管理案例。我们用的是<a class="ae lu" href="http://people.cs.pitt.edu/~alanjawi/cs449/code/shell/UnixSignals.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> SIGUSR2 </strong> </a>那是用户发出的UNIX信号(对不起windows用户)。</p><p id="8525" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦应用程序收到该信号，它就会递归地重新启动每个工作线程。您可能会注意到，在任何时候都会有多个工作线程并行重启，因此我们会确保可用性。<em class="le"> restartWorker </em>函数断开工作线程并为退出事件创建一个监听器。这一次，处理程序会有所不同。<a class="ae lu" href="https://nodejs.org/api/cluster.html#cluster_worker_exitedafterdisconnect" rel="noopener ugc nofollow" target="_blank"><em class="le">exited after disconnect</em>如果工人因<code class="fe lz ma mb mc b">.kill()</code>或<code class="fe lz ma mb mc b">.disconnect()</code>退出，T22为<code class="fe lz ma mb mc b">true</code>。</a></p><p id="e066" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦旧的工作者存在，我们就创建一个新的工作者和一个监听器，一旦它在监听，我们就知道什么时候可以重新启动下一个工作者。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi md"><img src="../Images/ea20fd0ba7291f6f4e2394a52e31d029.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*S_q2P-ZF92dDnPIV8hBYnw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">集群应用第3部分</figcaption></figure><p id="8132" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后但同样重要的是；还记得文件开头的<em class="le"> if </em>语句吗？不是主线程的工作线程会直接进入<strong class="js iu">执行我们的app </strong>。</p><p id="1be8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经有了实现，让我们执行它。</p><p id="0dcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们应该用命令<code class="fe lz ma mb mc b">node clusteredApp</code>运行应用程序</p><p id="e6b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要用<code class="fe lz ma mb mc b">ps af</code>找到主流程PID</p><p id="b799" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主流程应该是一组节点流程的父流程。一旦我们有了PID，我们就可以向它发送信号:<code class="fe lz ma mb mc b">kill -SIGUSR2 &lt;PID&gt;</code></p><p id="86b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在<em class="le"> clusteredApp </em>应用程序的输出应该显示如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi me"><img src="../Images/b0f6e0c3c64960f644cfeb90bd897113.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*guk7PuVXaE8I1QuxRBJBrQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">集群应用输出</figcaption></figure><p id="4f86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以尝试使用<a class="ae lu" href="https://www.joedog.org/siege-home/" rel="noopener ugc nofollow" target="_blank">围攻</a>来验证在工作进程重启期间，我们不会对我们的应用程序的可用性产生任何重大影响:</p><p id="a594" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lz ma mb mc b">siege -c200 -t10S <a class="ae lu" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></code></p><p id="05cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前面的命令将在10秒钟内向服务器加载200个并发连接。作为参考，具有4个处理器的系统的结果是每秒90个事务，平均CPU利用率仅为20%</p><p id="843f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该过程大约需要10秒钟，尝试如上所示终止主进程，以尽可能测试系统。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mf"><img src="../Images/e24886049a1e361926c7bd24a9e31250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWg7r_mnkBOxo1YfCrW0VQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">围攻测试</figcaption></figure><p id="2050" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在左侧控制台中，我们可以看到<em class="le"> app.js </em>处理请求的输出。右边终端显示围攻测试(10个过程击杀)的最终输出，带有(嘿！😎)100%的可用性。</p><p id="21d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用过的代码在<a class="ae lu" href="https://github.com/boxgames1/nodejs-patterns/tree/master/scalability-architectural-patterns/zero-downtime-cluster" rel="noopener ugc nofollow" target="_blank"> GitHub仓库</a>里。</p><p id="7eb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lu" href="https://github.com/Unitech/pm2" rel="noopener ugc nofollow" target="_blank"> PM2 </a>是一个基于集群的小工具，它提供负载平衡、进程监控、零停机重启和其他功能。这篇文章是为了学习的目的，但如果你想达到这样的目标，PM2应该会有所帮助。</p><p id="1d28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望您喜欢这篇提炼了Node魔力的文章🍄</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="b3e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我是奥利弗·阿隆索，在西班牙远程工作的软件工程师。你可以在<a class="ae lu" href="https://oliveralonso.dev/" rel="noopener ugc nofollow" target="_blank">我的网络</a>或<a class="ae lu" href="https://github.com/boxgames1" rel="noopener ugc nofollow" target="_blank"> Github账户中找到更多关于我的资料。</a></p><p id="0f63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读！</p></div></div>    
</body>
</html>