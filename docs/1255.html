<html>
<head>
<title>Refactoring in Swift: Closure Callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的重构:闭包回调</h1>
<blockquote>原文：<a href="https://itnext.io/refactoring-swift-closure-properties-9be70c986ef8?source=collection_archive---------5-----------------------#2018-08-22">https://itnext.io/refactoring-swift-closure-properties-9be70c986ef8?source=collection_archive---------5-----------------------#2018-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="66ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当使用闭包时，闭包的内容通常只包含一行:对使用参数执行工作的函数的调用。这需要三行代码，对于它的功能来说，太多了两行。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3adbf859170fc2effce149a851b52cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KE9tHwBMiQYrolu0BOCR2w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">是的，我们会谈到currying，但不是这些成分…</figcaption></figure><p id="311a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你以前见过这个吗，可能是在<code class="fe lr ls lt lu b">viewDidLoad</code>里？</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="c7ea" class="lz ma iq lu b gy mb mc l md me">self.model.intakeValueChanged = { [weak self] value in<br/>    self?.updateIntake(to: value)<br/>}<br/><br/>self.model.calorieValueChanged = { [weak self] calories in<br/>    self?.updateCalories(to: calories)<br/>}<br/><br/>self.model.dataIsValid = { [weak self] valid in<br/>    self?.updateSaveButton(active: valid)<br/>}<br/><br/>self.model.saveActionCompleted = { [weak self] in<br/>    self?.resetData()<br/>}</span></pre><p id="21d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这并不可怕，但我所能看到的是一个重复的模式，它将被这个正则表达式匹配。当我们在代码中看到重复的模式时，我们该怎么办？我们重构。</p><p id="0655" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">开箱即用，Swift允许您将一个功能分配给一个闭包属性。因此，我们可以这样做来进行重构:</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="917c" class="lz ma iq lu b gy mb mc l md me">self.model.intakeValueChanged = self.updateIntake(to:)</span><span id="d772" class="lz ma iq lu b gy mg mc l md me">self.model.calorieValueChanged = self.updateCalories(to:)</span><span id="04e8" class="lz ma iq lu b gy mg mc l md me">self.model.dataIsValid = self.updateSaveButton(active:)</span><span id="7ae1" class="lz ma iq lu b gy mg mc l md me">self.model.saveActionCompleted = self.resetData</span></pre><p id="c8ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是合法的，然而警钟应该在你的脑海中响起:我们的<code class="fe lr ls lt lu b">weak</code>怎么办？</p><p id="e57a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">T19】</strong></p><p id="2d41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第一个例子中，在代码运行后调用<code class="fe lr ls lt lu b">print(CFGetRetainCount(self))</code>会导致<code class="fe lr ls lt lu b">7</code>被打印到控制台，然而从第二个例子的底部调用它会打印<code class="fe lr ls lt lu b">8</code>。我们创造了一个保留周期。</p><p id="eb7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输入我的同事告诉我的所谓的“函数currying ”,我不相信他，所以我谷歌了一下(这是几年前…)。在这种情况下，currying意味着我们可以将我们的实例函数转换为一个以实例为参数并返回原始函数的函数。</p><blockquote class="mi"><p id="4a13" class="mj mk iq bd ml mm mn mo mp mq mr lq dk translated"><code class="fe lr ls lt lu b"><strong class="ak">self.someFunc(arg:) == type(of: self).someFunc(self)</strong></code></p></blockquote><p id="4050" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">例如，假设我们的<code class="fe lr ls lt lu b">updateIntake(to:)</code>函数位于<code class="fe lr ls lt lu b">ViewController</code>内部:</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="013c" class="lz ma iq lu b gy mb mc l md me">class ViewController: UIViewController {<br/> <br/>    func updateIntake(to value: Int) {<br/>        ...<br/>    }<br/>}</span></pre><p id="5b44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要从<code class="fe lr ls lt lu b">ViewController</code>内部调用<code class="fe lr ls lt lu b">updateIntake(to:)</code>，我们通常只需使用<code class="fe lr ls lt lu b">self.updateIntake(to: someInt)</code>。然而，这种说法的“俗套”方式是:</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="e8eb" class="lz ma iq lu b gy mb mc l md me">let function: ((Int) -&gt; ()) = ViewController.updateIntake(self)<br/>function(someInt)</span></pre><p id="70f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是因为静态版本的<code class="fe lr ls lt lu b">updateIntake(to:)</code>接受了一个<code class="fe lr ls lt lu b">ViewController</code>的实例，并返回一个与其实例版本相同的函数。为了清楚起见，我在上面的代码片段中添加了类型声明——您所需要的就是<code class="fe lr ls lt lu b">ViewController.updateIntake(self)(someInt)</code>。</p><p id="0133" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，可以使用一个简单的函数在实例函数和闭包之间进行映射，而不会增加<code class="fe lr ls lt lu b">self</code>的引用数。这是一个适用于只有一个参数而没有返回值的函数的版本:</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="35c2" class="lz ma iq lu b gy mb mc l md me">protocol Bindable: class {}<br/>extension Bindable {<br/>    <br/>    typealias Function = Self<br/>    <br/>    func weak&lt;Args&gt;(_ method: @escaping ((Function) -&gt; ((Args) -&gt; Void))) -&gt; ((Args) -&gt; Void) {<br/>        return { [weak self] arg in<br/>            guard let `self` = self else { return }<br/>            method(self)(arg)<br/>        }<br/>    }<br/>}</span></pre><p id="1f48" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了使它更加可重用，我定义了一个名为<code class="fe lr ls lt lu b">Function</code>的typealias，它只是映射到类名。让你的班级符合<code class="fe lr ls lt lu b">Bindable</code>，你就可以开始了:</p><pre class="kg kh ki kj gt lv lu lw lx aw ly bi"><span id="1004" class="lz ma iq lu b gy mb mc l md me">self.model.intakeValueChanged = weak(Function.updateIntake(to:))</span><span id="2106" class="lz ma iq lu b gy mg mc l md me">self.model.calorieValueChanged = weak(Function.updateCalories(to:))</span><span id="2685" class="lz ma iq lu b gy mg mc l md me">self.model.dataIsValid = weak(Function.updateSaveButton(active:))</span><span id="2adf" class="lz ma iq lu b gy mg mc l md me">self.model.saveActionCompleted = weak(Function.resetData)</span></pre><p id="5efa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您需要在<code class="fe lr ls lt lu b">Bindable</code>中添加另一个不带<code class="fe lr ls lt lu b">Args</code>的函数，以便支持最后一行，因为<code class="fe lr ls lt lu b">saveActionCompleted</code> / <code class="fe lr ls lt lu b">resetData</code>没有任何参数。您还可以为具有返回值的闭包创建一个<code class="fe lr ls lt lu b">unowned</code>版本。</p><p id="e3bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">再次运行之前的<code class="fe lr ls lt lu b">print(CFGetRetainCount(self))</code>测试，注意这次保留计数没有增加！</p></div></div>    
</body>
</html>