<html>
<head>
<title>React Clean Code — Simulate Network Scenarios with Mirage.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应干净的代码-使用Mirage.js模拟网络场景</h1>
<blockquote>原文：<a href="https://itnext.io/react-clean-code-simulate-network-scenarios-with-mirage-js-9b2c165b12e9?source=collection_archive---------0-----------------------#2022-12-20">https://itnext.io/react-clean-code-simulate-network-scenarios-with-mirage-js-9b2c165b12e9?source=collection_archive---------0-----------------------#2022-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="df73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的书<a class="ae kl" href="https://leanpub.com/maintainable-react" rel="noopener ugc nofollow" target="_blank">可维护反应</a>中，我介绍了我不久前开发的一个特性。这个特性在很多方面都很有趣，我选择它是因为它涉及到视图中的几个状态——这也是为什么构建UI很复杂的原因之一。</p><p id="9b72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们不是典型的UI状态，而是服务器缓存状态，正如Kent在这里的文章中所描述的。所有的网络请求都可能出错、超时、请求过多甚至服务中断。在视图中，我们需要相应地反映这些网络状态。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ks kt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">如果你喜欢视频，我已经在我的频道上发布了两个相应的视频。</figcaption></figure><h1 id="fcaa" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">不同的地位</h1><p id="7569" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这里的<strong class="jp ir">直接引导</strong>的功能是，当用户开始进入页面时，我们需要检查订单的当前状态。如果正在进行，我们需要显示一个禁用的按钮<code class="fe mb mc md me b">I'm here</code>和一些提示消息。在某些时候，当订单准备好提货时，需要启用按钮，这样我们就可以单击它来通知商店。点击该按钮时，会发送一条通知，订单会直接送到您的汽车行李箱中。此外，如果出现任何问题，我们会显示一个号码作为备用，这样我们就可以打电话给商店。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/8b78455566f0b700262d9dcb851b0a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ByYDfRhJNzzU6V7oFzkX7Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">“直接到图书”应用程序的不同状态</figcaption></figure><p id="f025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们至少需要考虑以下事情:</p><ul class=""><li id="ba8f" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">从服务器获取数据</li><li id="5b3f" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">如果网络出现问题，请重试</li><li id="3b80" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">如果返回的数据不是我们想要的，请重试</li><li id="2e50" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">当我们失败太多次时停止重试</li><li id="361f" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">向服务器更新数据</li><li id="33cd" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">处理每个网络请求的错误</li></ul><p id="42b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们为上面的描述画一个<code class="fe mb mc md me b">statechart</code>，会是下图这样的东西。在命令是<code class="fe mb mc md me b">ready</code>之前，我们需要重试几次。并且通知可能有另一个重试计数器(在这个图表中我们没有这样做)。此外，每个网络请求都可能导致错误。注意，快乐路径(空闲→就绪→通知)只是分支中的<strong class="jp ir">一个。</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi na"><img src="../Images/171c4ea73334eb1472776196e926dd26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4d6aNZNlyxhv2w_2VCgmg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">直接启动的状态图</figcaption></figure><h1 id="cc4b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">快乐之路</h1><p id="605b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们可以从快乐的道路开始，因为这是最容易的一步，也是我们希望确保发生的最重要的事情。</p><p id="c413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在测试中,(初始化→就绪)的最佳路径可以描述为:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nb"><img src="../Images/cda961996984de9e749cf4766f8bfcee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UObUVOGmKCr97AW9jb5l6w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们快乐之路的第一个测试</figcaption></figure><h1 id="4778" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">嘲笑快乐之路的请求</h1><p id="49f7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在我的书中，我使用<code class="fe mb mc md me b">msw</code>作为嘲讽服务器，它工作得相当好。为了简单起见，我在这里使用<code class="fe mb mc md me b">mirage.js</code>。我也喜欢库的数据建模部分。这里没多大关系，你<a class="ae kl" href="https://miragejs.com/docs/comparison-with-other-tools/" rel="noopener ugc nofollow" target="_blank">可以用任何一个</a>。</p><p id="d09b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们可以定义一个<code class="fe mb mc md me b">get</code> API来检查测试中的订单状态。它拦截发送到<code class="fe mb mc md me b">/api/orders/&lt;id&gt;</code>的请求，并总是返回一个状态为<code class="fe mb mc md me b">ready</code>的对象。</p><pre class="kn ko kp kq gt nc me nd bn ne nf bi"><span id="2962" class="ng kz iq me b be nh ni l nj nk">import { createServer } from "miragejs";<br/><br/>const createMockServer = () =&gt; createServer({<br/>  routes() {<br/>    this.get("/api/orders/:id", (schema, request) =&gt; {<br/>      return {<br/>        id: request.params.id,<br/>        status: "ready",<br/>      };<br/>    });<br/>  }<br/>})</span></pre><p id="1e77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们在每次测试开始时创建一个服务器，并在测试结束时关闭它。</p><pre class="kn ko kp kq gt nc me nd bn ne nf bi"><span id="6fb3" class="ng kz iq me b be nh ni l nj nk">describe("Direct To Boot", () =&gt; {<br/>  beforeEach(() =&gt; {<br/>    server = createMockServer();<br/>  })<br/>  <br/>  afterEach(() =&gt; {<br/>    server.shutdown()<br/>  })<br/>  <br/>  //...<br/>});</span></pre><p id="6747" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该API看起来很直观，并且正如预期的那样工作。在我们的组件中，我们可以像对待真正的API一样发送请求和消费响应。</p><h1 id="e07d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用react-query实现提取</h1><p id="e5b2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/the-pragmatic-guide-to-react-network-programming-c6f9de9962ed">我之前的文章</a>中，我详细讨论了提出一个“简单”的网络请求需要考虑多少琐碎的事情。以及如果您使用<code class="fe mb mc md me b">react-query</code>而不是手动实现它会有多简单。</p><p id="9fc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用<code class="fe mb mc md me b">react-query</code>，首先我们需要定义一个<code class="fe mb mc md me b">query</code>函数。注意这里如果<code class="fe mb mc md me b">res.data.status</code>不是<code class="fe mb mc md me b">ready</code>，会抛出一个错误。并且<code class="fe mb mc md me b">react-query</code>可以检测该错误并触发<code class="fe mb mc md me b">refetch</code>(如果配置的话)。</p><pre class="kn ko kp kq gt nc me nd bn ne nf bi"><span id="adbc" class="ng kz iq me b be nh ni l nj nk">const fetchOrder = (orderId: string) =&gt; {<br/>  return axios.get(`/api/orders/${orderId}`).then((res) =&gt; {<br/>    if (res.data.status === "ready") {<br/>      return res.data;<br/>    } else {<br/>      throw new Error("fetch error");<br/>    }<br/>  });<br/>};</span></pre><p id="ac16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在有了<code class="fe mb mc md me b">fetchQuery</code>函数，我就可以调用<code class="fe mb mc md me b">useQuery</code>，并将整个逻辑封装在一个钩子<code class="fe mb mc md me b">useOrder</code>中</p><pre class="kn ko kp kq gt nc me nd bn ne nf bi"><span id="4ec9" class="ng kz iq me b be nh ni l nj nk">const useOrder = (orderId: string) =&gt; {<br/>  const [status, setStatus] = useState&lt;string&gt;("initialised");<br/><br/>  useQuery(["fetchOrder"], () =&gt; fetchOrder(orderId), {<br/>    retry: 5,<br/>    onError: () =&gt; setStatus("error"),<br/>    onSuccess: () =&gt; setStatus("ready"),<br/>  });<br/>    return { status }<br/>}</span></pre><p id="2214" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将retry设置为5，这样无论何时发生实际错误(比如服务器端发生500个错误)或者当<code class="fe mb mc md me b">res.data.status</code>不是<code class="fe mb mc md me b">ready</code>时，<code class="fe mb mc md me b">react-query</code>都会重试。并且<a class="ae kl" href="https://tanstack.com/query/v4/docs/react/guides/query-retries#retry-delay" rel="noopener ugc nofollow" target="_blank">它不会立即重试</a>，而是等待一段时间，作为每次失败之间的延迟。</p><h1 id="9002" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">模拟错误</h1><p id="ce3b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在<code class="fe mb mc md me b">mirage.js</code>中，模拟测试要捕捉的错误相当简单。我还发现有几个会触发错误的<code class="fe mb mc md me b">id</code>很有帮助，这样您就可以测试不同的错误处理逻辑。</p><p id="53dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们可以定义一个在使用时指示错误的<code class="fe mb mc md me b">id</code>列表。</p><pre class="kn ko kp kq gt nc me nd bn ne nf bi"><span id="c35f" class="ng kz iq me b be nh ni l nj nk">this.get("/api/orders/:id", (schema, request) =&gt; {<br/>  if(['error-id', 'timeout-id'].includes(request.params.id)) {<br/>    return new Response(500, {}, {error: "something went wrong"});<br/>  }<br/>  <br/>  return {<br/>    id: request.params.id,<br/>    status: "ready",<br/>  };<br/>});</span></pre><p id="7173" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在我们的测试中，我们可以使用<code class="fe mb mc md me b">error-id</code>或<code class="fe mb mc md me b">timeout-id</code>作为<code class="fe mb mc md me b">orderId</code>来模拟误差:</p><pre class="kn ko kp kq gt nc me nd bn ne nf bi"><span id="62e2" class="ng kz iq me b be nh ni l nj nk">it("shows a fallback call the store button", async () =&gt; {<br/>  render(&lt;DirectToBoot orderId="error-id"/&gt;);<br/><br/>  await waitFor(() =&gt;<br/>    expect(<br/>      screen.getByText("Seems something went wrong...")<br/>    ).toBeInTheDocument(), { timeout: 3000});<br/>  <br/>  const button = screen.getByText("04 23 33");<br/>  await waitFor(() =&gt; expect(button).toBeInTheDocument(), {timeout: 3000})<br/>});</span></pre><h1 id="9a7d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">请求失败时模拟重试</h1><p id="75f4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在我们的特性中，我们还想模拟<code class="fe mb mc md me b">long-running</code>顺序，以确保UI不会被初始获取阻塞。我们可以通过定义一个具有<code class="fe mb mc md me b">initialised</code>状态的变量来模拟它，然后使用一个定时器来更新这个值。</p><pre class="kn ko kp kq gt nc me nd bn ne nf bi"><span id="424f" class="ng kz iq me b be nh ni l nj nk">const longRunningOrder = {<br/>  id: 'long-running-order',<br/>  status: "initialised",<br/>}<br/><br/>//...<br/>const createMockServer = () =&gt; createServer({<br/>  routes() {<br/>    this.get("/api/orders/:id", (schema, request) =&gt; {<br/>      if(['long-running-order'].includes(id)) {<br/>        const timerId = setTimeout(() =&gt; {<br/>          longRunningOrder.status = 'ready'<br/>          clearTimeout(timerId);<br/>        }, 2000)<br/>        return longRunningOrder;<br/>      }<br/>    });<br/>  }<br/>})</span></pre><p id="2a14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在几次重试之后，视图最终获得了<code class="fe mb mc md me b">ready</code>状态，并准备好通知商店。请注意控制台中的“幻影”在这种情况下已经重试了三次。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nl"><img src="../Images/d6531bb414666c08e7282eb6e5da80a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPM4l8PZlgv08s2F2-c4HQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">mirage.js在控制台中重试</figcaption></figure><h1 id="7d98" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最终代码</h1><p id="7db4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让<code class="fe mb mc md me b">react-query</code>来处理所有与网络相关的逻辑，可以想象最终的<code class="fe mb mc md me b">Direct To Order</code>组件本身可以被简化得多么简单。</p><pre class="kn ko kp kq gt nc me nd bn ne nf bi"><span id="2fdd" class="ng kz iq me b be nh ni l nj nk">export function DirectToBoot({ orderId }: { orderId: string }) {<br/>  const {status, notifyStore} = useOrder(orderId);<br/><br/>  return (<br/>    &lt;div className="container"&gt;<br/>      &lt;h3&gt;Direct to boot&lt;/h3&gt;<br/>      &lt;p&gt;{getMessage(status)}&lt;/p&gt;<br/>      &lt;div className="buttonContainer"&gt;<br/>        {createButton(status, notifyStore)}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="65f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以本质上，组件<code class="fe mb mc md me b">DirectToBoot</code>接受<code class="fe mb mc md me b">orderId</code>作为参数，使用一个钩子获取状态，使用一个函数更新状态。</p><p id="6847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用钩子作为状态机，就像我们在文章开始时展示的<strong class="jp ir">状态图</strong>一样。</p><h1 id="342a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="6610" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在本文中，我们已经讨论了如何使用<code class="fe mb mc md me b">mirage.js</code>来简化网络模拟，如果您在前端代码中与真正的API对话，无论是不可能还是困难的情况。我们看了使用<code class="fe mb mc md me b">mirage.js</code>的快乐路径、错误处理和重试，以及使用<code class="fe mb mc md me b">react-query</code>来简化实现网络相关代码的逻辑是多么容易。</p><p id="ca8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到这篇文章的完整源代码。如果你喜欢视频，我已经在我的YouTuBe频道上发布了这些长达2小时的视频。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="2954" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果你喜欢阅读，请</strong> <a class="ae kl" href="https://icodeit.com.au/#subscribe" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">报名参加我的邮件列表</strong> </a> <strong class="jp ir">。我每周通过</strong> <a class="ae kl" href="https://juntao-qiu.medium.com/" rel="noopener"> <strong class="jp ir">博客</strong></a><strong class="jp ir"/><a class="ae kl" href="https://leanpub.com/u/juntao" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">书籍</strong> </a> <strong class="jp ir">和</strong> <a class="ae kl" href="https://www.youtube.com/@icodeit.juntao" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">视频</strong> </a> <strong class="jp ir">分享干净代码和重构技术。</strong></p></div></div>    
</body>
</html>