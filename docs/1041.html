<html>
<head>
<title>Better Typescript support for Jasmine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Jasmine更好的类型脚本支持</h1>
<blockquote>原文：<a href="https://itnext.io/better-typescript-support-for-jasmine-20dc7454ba94?source=collection_archive---------5-----------------------#2018-07-10">https://itnext.io/better-typescript-support-for-jasmine-20dc7454ba94?source=collection_archive---------5-----------------------#2018-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/098363af56151bb5753afd8292e021b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnuSyoJ_kTGiIBn0osCIdQ.png"/></div></div></figure><p id="4eac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Typescript是一种很棒的语言，它通过利用类型安全使Javascript开发人员更有效率。然而，当使用Jasmine测试时，您会失去这个好处，因为在大多数情况下，您必须使用类型<code class="fe kw kx ky kz b">any</code>。</p><p id="5473" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用Angular示例，但是该场景适用于任何其他框架。</p><h1 id="db8f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">问题是</h1><p id="0455" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">假设我们有一项服务:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="a0c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要用Jasmine测试这个服务，您通常需要编写类似如下的设置代码:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="cd93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个问题在第3行:<code class="fe kw kx ky kz b">let http: any</code>。这意味着所有的类型安全都消失了，不再有来自你钟爱的IDE的代码建议。</p><h1 id="563a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">向模拟添加类型安全</h1><p id="edb0" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">幸运的是，解决第一个问题很简单。声明一个<a class="ae mj" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#mapped-types" rel="noopener ugc nofollow" target="_blank">映射类型</a>:</p><pre class="md me mf mg gt mk kz ml mm aw mn bi"><span id="0b55" class="mo lb iq kz b gy mp mq l mr ms">export type Spied&lt;T&gt; = {  <br/>  [Method in keyof T]: jasmine.Spy;<br/>};</span></pre><p id="94bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从<code class="fe kw kx ky kz b">any</code>变为<code class="fe kw kx ky kz b">Spied&lt;HttpClient&gt;</code>:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e72a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以输入关于该服务的信息，此外还有关于jasmine spy的信息:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/ab0b903211a52891f979a35f20ad8973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-tn1d18f8QNZvZI5sv6HiQ.jpeg"/></div></div></figure><p id="42fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于这种方法的详细信息可以在<a class="ae mj" href="http://pragmatic-coder.net/author/zewa/" rel="noopener ugc nofollow" target="_blank">Vildan Softic</a>blog post<a class="ae mj" href="http://pragmatic-coder.net/typesafe-jasmine-spies/" rel="noopener ugc nofollow" target="_blank">类型安全Jasmine Spies </a>中找到。</p><h1 id="bd26" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">简化jamsine.createSpyObj()函数</h1><p id="08df" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">测试的第二个问题在第11行:</p><pre class="md me mf mg gt mk kz ml mm aw mn bi"><span id="6de6" class="mo lb iq kz b gy mp mq l mr ms">useValue: jasmine.createSpyObj('http', ['get'])</span></pre><p id="2a03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果将来你添加了一个使用POST动作的方法，你将不得不返回并添加<code class="fe kw kx ky kz b">post</code>到声明中。这很烦人，而且容易出错。例如，在重构期间更新了一个方法名，但是您的spy将保持不变，因此您的测试将会失败。</p><p id="fe7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望有一个只接受类类型的方法<code class="fe kw kx ky kz b">spyOnClass</code>，以及一个将所有方法作为返回值的spy，例如<code class="fe kw kx ky kz b">useValue: spyOnClass(HttpClient)</code>。</p><p id="cc15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是实现过程:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ab90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在代码中添加了一些注释，但想法很简单:我们获得类原型的所有属性和方法，过滤方法，并用这些方法创建一个spy对象。现在我们可以为任何类创建一个spy，我们不需要关心方法中的拼写错误，也支持重命名/重构😍！</p><h1 id="bdfe" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">让它变得更好</h1><p id="c204" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">现在我们可以这样模仿一个类:</p><pre class="md me mf mg gt mk kz ml mm aw mn bi"><span id="e8e1" class="mo lb iq kz b gy mp mq l mr ms">{ provide: HttpClient, useValue: spyOnClass(HttpClient) }</span></pre><p id="b6a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种类型的代码会在任何地方重复出现，让我们也将它移到一个函数中:</p><pre class="md me mf mg gt mk kz ml mm aw mn bi"><span id="6b22" class="mo lb iq kz b gy mp mq l mr ms">export function provideMock&lt;T&gt;(spiedClass: Type&lt;T&gt;) {<br/>  return {<br/>    provide: spiedClass,<br/>    useValue: spyOnClass(spiedClass)<br/>  };<br/>}</span></pre><p id="2a31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，设置变得更加简单:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="dace" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里，我们的间谍现在有打字信息，间谍创造本身是简单和通用的。下面是一个完整的工作堆栈示例:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mu mi l"/></div></figure><p id="28f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请👏如果你觉得这个信息有用。上面的技术已经对我们当前的项目帮助很大。</p></div></div>    
</body>
</html>