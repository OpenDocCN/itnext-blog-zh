<html>
<head>
<title>Change React Native screen animation direction with react-navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用react-navigation更改React本机屏幕动画方向</h1>
<blockquote>原文：<a href="https://itnext.io/change-react-native-screen-animation-direction-with-react-navigation-8cec0f66f22?source=collection_archive---------0-----------------------#2020-11-01">https://itnext.io/change-react-native-screen-animation-direction-with-react-navigation-8cec0f66f22?source=collection_archive---------0-----------------------#2020-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="70e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将检查如何为任何我们想要的屏幕产生从下到上或从右到左的过渡。在我们的例子中，我们将有几个屏幕处于<em class="kl">模态</em>和<em class="kl">堆栈</em>模式。</p><p id="1433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将创建带有自定义标题的导航堆栈。对于某些屏幕，左侧动作必须是带有十字图标(<strong class="jp ir"> X </strong>)的<strong class="jp ir"> <em class="kl">关闭</em> </strong>，而对于某些屏幕，必须是带有向左箭头图标(←)的<strong class="jp ir"> <em class="kl">返回</em> </strong>动作。</p><p id="ea07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于带有关闭(<strong class="jp ir"> X) </strong>图标的屏幕，屏幕必须表现得像模态屏幕一样，在出现屏幕时有自下而上的动画，在关闭屏幕时有自上而下的动画。</p><p id="7034" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于带有back (←)图标的屏幕，屏幕必须像堆栈一样运行，因此动画应该在左右方向上。</p><h1 id="42be" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">设置导航</h1><p id="0f80" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">首先，让我们创建导航栈。我们将创建三个主屏幕— <strong class="jp ir">主页</strong>、<strong class="jp ir">模态堆栈</strong>和<strong class="jp ir">非模态</strong>。Home和NotModal将只是一个简单的屏幕，而ModalStack将是我们新的屏幕堆栈。它应该以模态的形式出现，但是它里面的屏幕应该像普通的堆栈一样。</p><p id="59ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将headerMode设置为<strong class="jp ir"> <em class="kl"> none </em> </strong>，因为我们将使用我们自己的自定义头组件。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="4c54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们的屏幕应该是这样的:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lw"><img src="../Images/558d5f9f4310f576bebdac541d652770.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/1*cz54CVqQ5qumHQgcrNKSyA.gif"/></div></div></figure><p id="8f96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所注意到的，我们的屏幕都没有“模态”行为。接下来我们将把<strong class="jp ir"> <em class="kl"> mode=modal </em> </strong>添加到我们的根导航器道具中。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="6f29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的模态栈，我们现在已经得到了我们想要的。模态是作为<strong class="jp ir"> <em class="kl">模态</em> </strong>本身打开的，但是模态内的其他屏幕有<em class="kl">堆栈式的</em>左右过渡。在Android上，你仍然可以看到模态堆栈中的其他屏幕不是从右到左的，但是我们稍后会讨论这个问题。</p><p id="be12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，但是非模态屏幕呢？当我们将根导航器切换到<strong class="jp ir"> <em class="kl">模态</em> </strong>模式时，其中的所有屏幕现在也是模态的。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi md"><img src="../Images/63c5782243e96a0205827d19ce980bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/1*InV1nvxbwINaRVZGutX_kQ.gif"/></div></figure><h1 id="0ea6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">添加自定义过渡</h1><p id="7216" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">幸运的是，react-navigation 5让我们有机会将自定义过渡添加到屏幕上。由于这一点，我们可以创建类似模态的和类似堆栈的导航，并在任何我们想要的地方添加它们。</p><p id="76f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你在react-navigation doc(【https://reactnavigation.org/docs/stack-navigator】)中查看<strong class="jp ir"><em class="kl">create stack navigator</em></strong>options props，你可以找到一堆操纵动画的选项。出于我们的目的，我们将使用<strong class="jp ir"><em class="kl">cardStyleInterpolator</em></strong>。这个回调给了我们很多关于当前布局和当前过渡进度的信息，所以我们可以基于这些信息创建我们的自定义动画。我们只需要返回新的<strong class="jp ir"> <em class="kl"> cardStyle </em> </strong>对象，在那里我们可以添加我们的动画，就像我们对普通的react本地动画所做的那样。</p><p id="b794" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果我们想为react native中某些组件准备从右向左的动画，我们可以这样做:</p><pre class="lp lq lr ls gt mf mg mh mi aw mj bi"><span id="a27c" class="mk kn iq mg b gy ml mm l mn mo">animatedStyle = {</span><span id="579f" class="mk kn iq mg b gy mp mm l mn mo">  transform: [</span><span id="fd6d" class="mk kn iq mg b gy mp mm l mn mo">    {</span><span id="d159" class="mk kn iq mg b gy mp mm l mn mo">      translateX: animation.interpolate({</span><span id="a3d9" class="mk kn iq mg b gy mp mm l mn mo">        inputRange: [0, 1],</span><span id="811b" class="mk kn iq mg b gy mp mm l mn mo">        outputRange: [screen.width, 0],</span><span id="5cd8" class="mk kn iq mg b gy mp mm l mn mo">      }),</span><span id="c117" class="mk kn iq mg b gy mp mm l mn mo">    },</span><span id="9c34" class="mk kn iq mg b gy mp mm l mn mo">  ],</span><span id="d986" class="mk kn iq mg b gy mp mm l mn mo">};</span></pre><p id="8df0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，当动画在它的起始点(<strong class="jp ir"> inputRange = 0 </strong>)时，我们将整个组件平移到屏幕右边缘之外。所以我们将translateX设置为screen.width值(<strong class="jp ir">output range = screen . width</strong>)。在转换结束时(<strong class="jp ir"> inputRange = 1 </strong>)，我们希望将translateX设置为0 ( <strong class="jp ir"> outputRange = 0 </strong>)，这样它就不会被转换，完全可见。</p><p id="e16f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像我们在反应导航屏幕上做的一样。我们访问的不是<strong class="jp ir"> <em class="kl">动画</em> </strong>对象，而是<strong class="jp ir"> <em class="kl">当前进度</em> </strong>对象，这只是一个动画类型的对象。当谈到<strong class="jp ir"> <em class="kl"> screen.width </em> </strong>时，在我们的<strong class="jp ir"><em class="kl">cardStyleInterpolator</em></strong>回调中我们可以访问<strong class="jp ir"><em class="kl">layouts . screen</em></strong>对象，这是一个布局类型。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="3a6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一句<strong class="jp ir"><em class="kl">cardStyleInterpolator</em></strong>提供了比仅仅<strong class="jp ir"> <em class="kl">当前</em> </strong>和<strong class="jp ir"> <em class="kl">布局</em> </strong>更多的数据，所以如果你想准备更多花哨的过渡，你可以在react-navigation文档中查看。</p><p id="2638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要做的最后一件事是将我们的新品牌动画添加到我们的react-<strong class="jp ir"><em class="kl">not modal</em></strong>options道具中。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="9761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而对于现在我们的<strong class="jp ir"> <em class="kl">非模态</em> </strong>屏幕动画有水平方向。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi md"><img src="../Images/85f928f515ae8b7aa493da18ae408916.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/1*qszoez8XZr01vWUE2f4EHw.gif"/></div></figure><p id="8b32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要做的最后一件事是为<strong class="jp ir"> <em class="kl">手势方向</em> </strong>道具添加适当的值。当我们改变过渡时，我们也应该调整与导航屏幕相关的用户手势的适当行为。我们可以将其设置为垂直、水平、垂直倒置或水平倒置。在我们的例子中，我们将它的值设置为水平，所以用户可以通过水平滑动返回。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="35f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以回到Android了。我们现在有了自定义的水平动画，我们也可以将它添加到我们的<strong class="jp ir"> <em class="kl">模式堆栈中。导航器</em> </strong>屏幕选项。在Android上，这个堆栈中的屏幕也可以表现得像“模态”一样，具有自下而上的过渡动画，所以现在我们可以改变它。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/597b9fde30523fc208b0cff8654a1f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*9vB-LyVPxg0XOKTiD_m1QQ.gif"/></div></figure><p id="d8c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个工具，我们也可以改变水平动画到垂直。</p><p id="2c7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">垂直动画看起来与水平动画非常相似。我们只需要从屏幕的最底部开始插值，然后沿着Y轴平移一切。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="f4bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以改变任何屏幕的动画方向。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/3069c86e1f59e8b94940acf638f7c1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*O4_KDGx3CEEX78mYtSt6Og.gif"/></div></figure><h2 id="ed59" class="mk kn iq bd ko mr ms dn ks mt mu dp kw jy mv mw la kc mx my le kg mz na li nb bi translated"><a class="ae me" href="https://github.com/justynasowinska/react_native_navigation_transition_direction" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">你会在Github上找到带有Typescript的完整项目。</strong>T11】</a></h2></div></div>    
</body>
</html>