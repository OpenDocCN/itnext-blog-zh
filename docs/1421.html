<html>
<head>
<title>FP-style Pointfree Selenium Tests in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的FP风格的无指针硒测试</h1>
<blockquote>原文：<a href="https://itnext.io/fp-style-pointfree-selenium-tests-in-javascript-35257a932eed?source=collection_archive---------6-----------------------#2018-10-10">https://itnext.io/fp-style-pointfree-selenium-tests-in-javascript-35257a932eed?source=collection_archive---------6-----------------------#2018-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/5f70cc8344edd85057d27bb1957e966d.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*46jMgMa0_rnpNahKwfGGEw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">selenium-webdriver</figcaption></figure><p id="b57b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章是一个以自由风格编写<a class="ae kw" href="https://www.seleniumhq.org/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>测试的教程。这应该会减少你的用户体验测试的规模，因为以一种无点数的方式编写它们可以消除大多数变量和“等待”的测试代码(aysnc/await)。这里有一个例子来说明我的意思。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="453d" class="lg lh iq lc b gy li lj l lk ll">test('User can login', () =&gt; S.seq(<br/>  S.call('get', ROOT_URL),<br/>  S.click('[data-go="login"]'),<br/>  S.fillForm(forms.login, user.credentials),<br/>  S.click('button[type="submit"]'),<br/>)(opts))</span></pre><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lm"><img src="../Images/eabb04d34c02e93b85b914cf83f75dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-mhTBEJtvIFAQTPO"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae kw" href="https://unsplash.com/@randomlies?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ashim D'Silva </a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的“按钮打印帖子”</figcaption></figure><h2 id="2c4e" class="lg lh iq bd lr ls lt dn lu lv lw dp lx kj ly lz ma kn mb mc md kr me mf mg mh bi translated">Selenium-webdriver和Node.js</h2><p id="a036" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我使用<a class="ae kw" href="https://seleniumhq.github.io/selenium/docs/api/javascript/index.html" rel="noopener ugc nofollow" target="_blank"> Selenium-Webdriver </a>和<a class="ae kw" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>来编写自动化浏览器测试。我不会详细讨论这个问题，但是如果你搜索“selenium-webdriver jest”或者“selenium-webdriver mocha ”,你会发现一些很好的博客文章，它们更详细地描述了如何将两者结合使用。一般来说，Jest或<a class="ae kw" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> Mocha </a>是测试运行程序，selenium-webdriver在测试中用于与浏览器交互。下面的代码摘自<a class="ae kw" href="https://medium.com/@andrey.dobra/web-testing-using-selenium-webdriver-part-4-adding-javascript-node-js-and-mocha-656df2a12787" rel="noopener">其中一篇博文</a>。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="f55d" class="lg lh iq lc b gy li lj l lk ll">test('01 Drums Access Await', async function () {<br/>  await driver.get("https://andreidbr.github.io/JS30/");<br/>  const drumsLink = await<br/>    driver.findElement(By.xpath('/html/body/div[2]/div[1]'));<br/>  await drumsLink.click();<br/>  const pageTitle = await driver.getTitle();<br/>  await assert.equal(pageTitle, "JS30: 01 Drums");<br/>}</span></pre><h2 id="6238" class="lg lh iq bd lr ls lt dn lu lv lw dp lx kj ly lz ma kn mb mc md kr me mf mg mh bi translated">自由点样式和函数组合</h2><p id="4510" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">函数组合的工作原理是将一系列函数调用组合成一个函数。还有像<a class="ae kw" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>这样的实用程序库，包含组合函数的帮助器。这些助手通常被称为合成或管道/序列。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="db73" class="lg lh iq lc b gy li lj l lk ll">const log =&gt; txt =&gt; () =&gt; console.log(txt)<br/>const name = { first: 'Bob', last: 'Cobb' }</span><span id="77a4" class="lg lh iq lc b gy mn lj l lk ll">// Composed functions run last to first<br/>let logName = compose(log(name.first), log(', '), log(name.last))<br/>logName() // prints "Cobb, Bob"</span><span id="b4c0" class="lg lh iq lc b gy mn lj l lk ll">// Piped or sequenced functions run first to last<br/>logName = pipe(log(name.first), log(' '), log(name.last))<br/>logName() // prints "Bob Cobb"</span></pre><p id="75cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Pointfree是一种可以通过函数组合实现的编码风格。上面的例子没有显示出来，但是组合函数接收前一个函数的结果作为唯一的参数。只有第一个运行的函数可以接收多个参数。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5e15" class="lg lh iq lc b gy li lj l lk ll">const add = x =&gt; y =&gt; x + y<br/>const add7 = compose(add(2), add(5))</span><span id="0be3" class="lg lh iq lc b gy mn lj l lk ll">const value = add7(10)<br/>console.log(value) // prints "17"</span></pre><p id="a045" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，第一个运行的函数是“add(5)”。它接收10作为参数，结果是15。然后，“add(2)”接收15作为它的参数，最终结果是17。它被称为pointfree，因为我们从来不需要在自己的代码中把15存储在一个变量中。</p><h2 id="435b" class="lg lh iq bd lr ls lt dn lu lv lw dp lx kj ly lz ma kn mb mc md kr me mf mg mh bi translated">异步序列</h2><p id="400a" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">现在，我们如何构造异步函数呢？有一些库可以完成这项工作，但是如果您使用的是node版本8或更高版本，完成这项工作的代码很简单。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="fe23" class="lg lh iq lc b gy li lj l lk ll">const seq = (...fns) =&gt; async function seq (...args) {<br/>  if (!fns.length) return<br/>  let result = await fns[0](...args)<br/>  for (let i = 1; i &lt; fns.length; i++) {<br/>    result = await fns[i](result)<br/>  }<br/>  return result<br/>}</span></pre><p id="020c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了传递结果，我们还可以调整这个“seq”函数，这样就可以在函数之间传递上下文对象。这将使每个函数能够访问配置设置和状态，以及先前函数的结果。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4905" class="lg lh iq lc b gy li lj l lk ll">const seq = (...fns) =&gt; async function seq (ctx) {<br/>  for (let i = 0; i &lt; fns.length; i++) {<br/>    ctx = Object.assign(ctx, await fns[i](ctx))<br/>  }<br/>  return ctx<br/>}</span></pre><h2 id="4fdb" class="lg lh iq bd lr ls lt dn lu lv lw dp lx kj ly lz ma kn mb mc md kr me mf mg mh bi translated">与硒一起使用</h2><p id="4f14" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">最后一步是开始将Selenium-Webdriver API封装到可以插入异步管道的函数中。让我们将这些助手函数分组到一个名为“selenium-webdriver-fp”的实用程序库中。下面是使用我们的fp helper库从上面重写代码的样子。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d6b3" class="lg lh iq lc b gy li lj l lk ll">const S = require('selenium-webdriver-fp')</span><span id="f2d0" class="lg lh iq lc b gy mn lj l lk ll">test('01 Drums Access Await', () =&gt; S.seq(<br/>  S.call('get', 'https://andreidbr.github.io/JS30/'),<br/>  S.click(By.xpath('/html/body/div[2]/div[1]')),<br/>  S.call('getTitle'),<br/>  ctx =&gt; { assert.equal(ctx.callResult, 'JS30: 01 Drums') }<br/>)({ driver }))</span></pre><p id="72cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于助手函数，需要注意以下几点:</p><ul class=""><li id="c63a" class="mo mp iq ka b kb kc kf kg kj mq kn mr kr ms kv mt mu mv mw bi translated">组合函数是S.seq的结果，必须向其传递一个具有“driver”属性的对象，即selenium-webdriver实例。</li><li id="b5ca" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">运行时，所有函数都以上下文作为唯一参数来调用</li><li id="ae6b" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">配置助手时，所有参数都可以是值或函数。如果是函数，它接收上下文并返回值。</li><li id="49d0" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">如果选择器是一个字符串，则假定它是一个CSS选择器。</li><li id="9c3f" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">上下文有一些关键字。“callResult”是最后一次调用“S.call”的值，“element”和“selector”是最后一次调用“S.getElement”的值。</li></ul><h2 id="12b0" class="lg lh iq bd lr ls lt dn lu lv lw dp lx kj ly lz ma kn mb mc md kr me mf mg mh bi translated">Selenium-webdriver-fp</h2><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae kw" href="https://gist.github.com/rhythnic/fb6d4f0f5ec0d9c1266e827f145a62f6" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/rhythnic/FB 6d 4 f 0 F5 EC 0 d9 c 1266 e 827 f 145 a 62 f 6</a></figcaption></figure></div></div>    
</body>
</html>