<html>
<head>
<title>Angular Routing — Best Practices for Enterprise Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度路由—企业应用的最佳实践</h1>
<blockquote>原文：<a href="https://itnext.io/angular-routing-best-practices-for-enterprise-applications-da539e4a6d42?source=collection_archive---------3-----------------------#2019-02-24">https://itnext.io/angular-routing-best-practices-for-enterprise-applications-da539e4a6d42?source=collection_archive---------3-----------------------#2019-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class="jn jo gp gr jp jq"><a href="https://ultimatecourses.com/courses/angular/ref/wes.grimes/" rel="noopener  ugc nofollow" target="_blank"><div class="jr ab fo"><div class="js ab jt cl cj ju"><h2 class="bd ir gy z fp jv fr fs jw fu fw ip bi translated">ultimate Angular |专家指导的在线Angular和TypeScript培训课程</h2><div class="jx l"><h3 class="bd b gy z fp jv fr fs jw fu fw dk translated">学习最新的Angular，TypeScript，通过NGRX和超越。通过我们的在线课程，成为在线角度专家。</h3></div><div class="jy l"><p class="bd b dl z fp jv fr fs jw fu fw dk translated">ultimatecourses.com</p></div></div><div class="jz l"><div class="ka l kb kc kd jz ke kf jq"/></div></div></a></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/297ddc85516e16004df96d9b8b399fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6sTa63CidDVx9BET.jpg"/></div></div></figure><h1 id="bc55" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">在开始之前</h1><p id="5d0e" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">本文并不打算成为Angular中布线的教程。如果您是Angular路由的新手，我强烈建议您查看以下资源之一:</p><ul class=""><li id="733c" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm mu mv mw mx bi translated"><a class="ae my" href="https://bit.ly/2WubqhW" rel="noopener ugc nofollow" target="_blank">终极课程</a></li><li id="b84c" class="mn mo iq lr b ls mz lw na ma nb me nc mi nd mm mu mv mw mx bi translated"><a class="ae my" href="https://angular.io/guide/router" rel="noopener ugc nofollow" target="_blank">官方角度文件</a></li></ul><h1 id="2505" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">背景</h1><p id="70a4" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">下面是我在构建了几个企业角度应用程序后，在日常工作中开发的一个模式。虽然大多数在线教程在奠定基础方面做得很好，但我很难找到展示大型可伸缩应用程序的推荐约定和模式的文章。</p><p id="15aa" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">使用这种模式，您应该对应用程序中所有与路由相关的问题有一个清晰简洁的组织。</p><h1 id="4fa1" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">先决条件</h1><p id="0b28" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">对于上下文，本文假设您正在使用以下版本的Angular:</p><ul class=""><li id="12ed" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm mu mv mw mx bi translated">角度v7.2.6</li></ul><h1 id="97c3" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">最佳实践#1 —创建顶级路由数组文件</h1><blockquote class="nh ni nj"><p id="0ecd" class="lp lq nk lr b ls mp lu lv lw mq ly lz nl ne mc md nm nf mg mh nn ng mk ml mm ij bi translated"><em class="iq">官方</em> <a class="ae my" href="https://angular.io/guide/router#refactor-the-routing-configuration-into-a-routing-module" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Angular docs推荐</em> </a> <em class="iq">为您打造一款全面成熟的</em> <code class="fe no np nq nr b"><em class="iq">app-routing.module.ts</em></code> <em class="iq">顶级路由。我发现这额外的一层在大多数情况下是不必要的。</em></p></blockquote><p id="2078" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">让我们采用以下方法:</p><ol class=""><li id="de49" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm ns mv mw mx bi translated">在根目录<code class="fe no np nq nr b">src/app</code>下创建一个名为<code class="fe no np nq nr b">app.routes.ts</code>的新文件。这个文件将保存我们的顶级<code class="fe no np nq nr b">Routes</code>数组。我们将在整篇文章的后面回来并填充它。现在，让我们用以下内容来搭建它:</li></ol><blockquote class="nh ni nj"><p id="0da0" class="lp lq nk lr b ls mp lu lv lw mq ly lz nl ne mc md nm nf mg mh nn ng mk ml mm ij bi translated"><em class="iq">热提示:这里只注册顶级路由，如果你计划实现特性模块，那么子路由将存在于各自的</em> <code class="fe no np nq nr b"><em class="iq">feature.routes.ts</em></code> <em class="iq">文件之下。我们希望尽可能保持这个顶级routes文件的整洁，并遵循组件树结构。</em></p></blockquote><pre class="kh ki kj kk gt nt nr nu nv aw nw bi"><span id="0b19" class="nx ks iq nr b gy ny nz l oa ob">import { Routes } from '@angular/router'; <br/>export const AppRoutes: Routes = [];</span></pre><ol class=""><li id="e7d0" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm ns mv mw mx bi translated">在<code class="fe no np nq nr b">app.module.ts</code>文件中注册<code class="fe no np nq nr b">AppRoutes</code>。</li></ol><ul class=""><li id="9da8" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm mu mv mw mx bi translated">从<code class="fe no np nq nr b">app.routes.ts</code>导入<code class="fe no np nq nr b">AppRoutes</code></li><li id="80e5" class="mn mo iq lr b ls mz lw na ma nb me nc mi nd mm mu mv mw mx bi translated">从<code class="fe no np nq nr b">@angular/router</code>导入<code class="fe no np nq nr b">RouterModule</code></li><li id="3599" class="mn mo iq lr b ls mz lw na ma nb me nc mi nd mm mu mv mw mx bi translated">将<code class="fe no np nq nr b">RouterModule.forRoot(AppRoutes)</code>添加到您的<code class="fe no np nq nr b">imports</code>数组中</li></ul><p id="71a1" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">您更新后的<code class="fe no np nq nr b">app.module.ts</code>将如下所示:</p><pre class="kh ki kj kk gt nt nr nu nv aw nw bi"><span id="d765" class="nx ks iq nr b gy ny nz l oa ob">import { NgModule } from '@angular/core';<br/>import { BrowserModule } from '@angular/platform-browser';<br/>import { RouterModule } from '@angular/router';<br/>import { AppComponent } from './app.component';<br/>import { AppRoutes } from './app.routes';<br/><br/>@NgModule({<br/>  declarations: [AppComponent],<br/>  imports: [BrowserModule, RouterModule.forRoot(AppRoutes)],<br/>  providers: [],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule {}</span></pre><h1 id="4b2c" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">最佳实践# 2-创建要素级路径数组文件</h1><p id="2bf2" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">以类似于我们构建<code class="fe no np nq nr b">app.routes.ts</code>的方式，我们将创建一个<code class="fe no np nq nr b">feature.routes.ts</code>来列出该功能模块的各个路线。我们希望我们的路线尽可能靠近源头。这将与干净的代码方法保持一致，并具有良好的关注点分离。</p><ol class=""><li id="a723" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm ns mv mw mx bi translated">创建一个名为<code class="fe no np nq nr b">feature/feature.routes.ts</code>的新文件，其中<code class="fe no np nq nr b">feature</code>与您的<code class="fe no np nq nr b">feature.module.ts</code>前缀相匹配。这个文件将保存我们的特性级<code class="fe no np nq nr b">Routes</code>数组。请记住，您将使用您的模块的实际名称替换<code class="fe no np nq nr b">Feature</code>,让我们用以下内容来搭建它:</li></ol><pre class="kh ki kj kk gt nt nr nu nv aw nw bi"><span id="21f8" class="nx ks iq nr b gy ny nz l oa ob">import { Routes } from '@angular/router';<br/><br/>export const FeatureRoutes: Routes = [];</span></pre><p id="712d" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">2.在<code class="fe no np nq nr b">feature/feature.module.ts</code>文件中注册<code class="fe no np nq nr b">FeatureRoutes</code>。我们将利用<code class="fe no np nq nr b">RouterModule.forChild</code>导入，以便这些路由自动注册到延迟加载。</p><ul class=""><li id="5381" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm mu mv mw mx bi translated">从<code class="fe no np nq nr b">feature.routes.ts</code>导入<code class="fe no np nq nr b">FeatureRoutes</code></li><li id="781d" class="mn mo iq lr b ls mz lw na ma nb me nc mi nd mm mu mv mw mx bi translated">从<code class="fe no np nq nr b">@angular/router</code>导入<code class="fe no np nq nr b">RouterModule</code></li><li id="0fee" class="mn mo iq lr b ls mz lw na ma nb me nc mi nd mm mu mv mw mx bi translated">将<code class="fe no np nq nr b">RouterModule.forChild(FeatureRoutes)</code>添加到您的<code class="fe no np nq nr b">imports</code>数组中</li></ul><p id="4aad" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">您更新后的<code class="fe no np nq nr b">feature/feature.module.ts</code>将类似于下图:</p><pre class="kh ki kj kk gt nt nr nu nv aw nw bi"><span id="4831" class="nx ks iq nr b gy ny nz l oa ob">import { CommonModule } from '@angular/common';<br/>import { NgModule } from '@angular/core';<br/>import { RouterModule } from '@angular/router';<br/>import { FeatureRoutes } from './feature.routes';<br/><br/>@NgModule({<br/>  declarations: [],<br/>  imports: [CommonModule, RouterModule.forChild(FeatureRoutes)]<br/>})<br/>export class FeatureModule {}</span></pre><p id="84b2" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">带有子路线的<code class="fe no np nq nr b">feature.routes.ts</code>文件示例如下:</p><pre class="kh ki kj kk gt nt nr nu nv aw nw bi"><span id="9b35" class="nx ks iq nr b gy ny nz l oa ob">import { Routes } from '@angular/router';<br/>import { FeatureOneComponent } from './feature-one.component';<br/>import { FeatureSpecificCanActivateGuard } from './_guards';<br/><br/>export const FeatureOneRoutes: Routes = [<br/>  {<br/>    path: '',<br/>    component: FeatureOneComponent,<br/>    canActivate: [FeatureSpecificCanActivateGuard]<br/>  }<br/>];</span></pre><h1 id="1d1b" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">最佳实践# 3-将延迟加载的要素添加到顶级路径文件中</h1><blockquote class="nh ni nj"><p id="8d3a" class="lp lq nk lr b ls mp lu lv lw mq ly lz nl ne mc md nm nf mg mh nn ng mk ml mm ij bi translated"><em class="iq">延迟加载的概念是将代码资产(javascript、样式)的加载推迟到用户真正需要使用资源的时候。这可以大大提高应用程序的感知加载时间，因为不必在第一次绘制时下载整个代码集。</em></p><p id="bcf1" class="lp lq nk lr b ls mp lu lv lw mq ly lz nl ne mc md nm nf mg mh nn ng mk ml mm ij bi translated"><em class="iq"> Angular为给定的路线提供了一个很好的方式来处理这个与</em> <code class="fe no np nq nr b"><em class="iq">loadChildren</em></code> <em class="iq">选项。更多信息可参见</em> <a class="ae my" href="https://angular.io/guide/router#lazy-loading-route-configuration" rel="noopener ugc nofollow" target="_blank"> <em class="iq">官方角度文档</em> </a> <em class="iq">。</em></p></blockquote><p id="4a33" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">一旦创建了<code class="fe no np nq nr b">app.routes.ts</code>和<code class="fe no np nq nr b">*.routes.ts</code>文件，就需要注册任何想要延迟加载的特性模块。</p><h2 id="892e" class="nx ks iq bd kt oc od dn kx oe of dp lb ma og oh lf me oi oj lj mi ok ol ln om bi translated">每个功能模块…</h2><p id="6ba3" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">更新<code class="fe no np nq nr b">app.routes.ts</code>文件中的<code class="fe no np nq nr b">AppRoutes</code>数组，以包含一个新的特征路线:</p><pre class="kh ki kj kk gt nt nr nu nv aw nw bi"><span id="96bd" class="nx ks iq nr b gy ny nz l oa ob">import { Routes } from '@angular/router';<br/><br/>export const AppRoutes: Routes = [<br/>  {<br/>    path: 'feature',<br/>    loadChildren: './feature/feature.module#FeatureModule'<br/>  }<br/>];</span></pre><p id="9c4a" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">通过将上述路由添加到数组中，当用户在浏览器中请求<code class="fe no np nq nr b">/feature</code>时，Angular lazy使用给定的路径加载模块，然后使用<code class="fe no np nq nr b">RouterModule.forChild</code>导入自动注册<code class="fe no np nq nr b">feature.routes.ts</code> <code class="fe no np nq nr b">FeatureRoutes</code>数组中定义的任何路由。</p><p id="6282" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">对于每个额外的特性模块，您将向<code class="fe no np nq nr b">AppRoutes</code>数组添加另一个项目。如果您有多个功能，它可能如下所示:</p><pre class="kh ki kj kk gt nt nr nu nv aw nw bi"><span id="8c6a" class="nx ks iq nr b gy ny nz l oa ob">import { Routes } from '@angular/router';<br/><br/>export const AppRoutes: Routes = [<br/>  {<br/>    path: '',<br/>    pathMatch: 'full',<br/>    redirectTo: 'feature-one'<br/>  },<br/>  {<br/>    path: 'feature-one',<br/>    loadChildren: './feature-one/feature-one.module#FeatureOneModule'<br/>  },<br/>  {<br/>    path: 'feature-two',<br/>    loadChildren: './feature-two/feature-two.module#FeatureTwoModule'<br/>  }<br/>];</span></pre><h1 id="36e2" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">最佳实践#4 —保持路由器防护有序</h1><p id="06ef" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">这里有一些让你的路由器防护保持有序的小技巧。这些只是指导方针，但我发现它们非常有帮助。</p><h2 id="a852" class="nx ks iq bd kt oc od dn kx oe of dp lb ma og oh lf me oi oj lj mi ok ol ln om bi translated">给你的卫兵起个好名字</h2><p id="0c7e" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">警卫应使用以下命名约定:</p><ul class=""><li id="6182" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm mu mv mw mx bi translated">文件名:<code class="fe no np nq nr b">name.function.guard.ts</code></li><li id="00cd" class="mn mo iq lr b ls mz lw na ma nb me nc mi nd mm mu mv mw mx bi translated">班级名称:<code class="fe no np nq nr b">NameFunctionGuard</code></li></ul><p id="6f4e" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">每个部分被标识为:</p><ul class=""><li id="8786" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm mu mv mw mx bi translated">这是你的守卫的名字。你在防范什么？</li><li id="e9b4" class="mn mo iq lr b ls mz lw na ma nb me nc mi nd mm mu mv mw mx bi translated"><code class="fe no np nq nr b">function</code> -这是你的守卫将被附加的功能。角形支架<code class="fe no np nq nr b">CanActivate</code>、<code class="fe no np nq nr b">CanActivateChild</code>、<code class="fe no np nq nr b">CanDeactivate</code>和<code class="fe no np nq nr b">Resolve</code>。</li></ul><p id="0283" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">一个附加到<code class="fe no np nq nr b">CanActivate</code>函数的授权保护的例子命名如下:</p><ul class=""><li id="4ce1" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm mu mv mw mx bi translated">文件名:<code class="fe no np nq nr b">auth.can-activate.guard</code></li><li id="1abf" class="mn mo iq lr b ls mz lw na ma nb me nc mi nd mm mu mv mw mx bi translated">类别名称:<code class="fe no np nq nr b">AuthCanActivateGuard</code></li></ul><h2 id="5df4" class="nx ks iq bd kt oc od dn kx oe of dp lb ma og oh lf me oi oj lj mi ok ol ln om bi translated"><code class="fe no np nq nr b">_guards</code>文件夹下的组</h2><blockquote class="nh ni nj"><p id="4843" class="lp lq nk lr b ls mp lu lv lw mq ly lz nl ne mc md nm nf mg mh nn ng mk ml mm ij bi translated">注意文件夹上的下划线“_”前缀，这只是为了在编辑器中进行排序。我总是希望这些文件夹显示在顶部。我为<code class="fe no np nq nr b"><em class="iq">_models</em></code>和<code class="fe no np nq nr b"><em class="iq">_services</em></code>做同样的事情。</p></blockquote><p id="0963" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">将所有顶级守卫组织在一个名为<code class="fe no np nq nr b">src/app/_guards</code>的文件夹下。我见过应用程序在顶级目录中抛弃守卫，这很混乱，尤其是如果你最终有几个以上的守卫。</p><h2 id="6304" class="nx ks iq bd kt oc od dn kx oe of dp lb ma og oh lf me oi oj lj mi ok ol ln om bi translated">使用桶出口</h2><blockquote class="nh ni nj"><p id="c2a5" class="lp lq nk lr b ls mp lu lv lw mq ly lz nl ne mc md nm nf mg mh nn ng mk ml mm ij bi translated">使用桶导出是否被官方认为是“最佳实践”，甚至是否得到Angular style guide的支持，还没有定论。然而，我非常喜欢这种干净的组织。这种方法是作为建议提供的。</p></blockquote><p id="e870" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">确保<code class="fe no np nq nr b">src/app/_guards</code>有一个漂亮干净的<code class="fe no np nq nr b">index.ts</code>桶出口。木桶导出是简单的<code class="fe no np nq nr b">index.ts</code>文件，它们组合在一起，从一个目录中导出所有公共文件。一个例子如下:</p><pre class="kh ki kj kk gt nt nr nu nv aw nw bi"><span id="31cf" class="nx ks iq nr b gy ny nz l oa ob">export * from './auth.can-activate.guard';<br/>export * from './require-save.can-deactivate.guard';</span></pre><p id="b28f" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">不带桶出口:</p><pre class="kh ki kj kk gt nt nr nu nv aw nw bi"><span id="db41" class="nx ks iq nr b gy ny nz l oa ob">import { AuthCanActivateGuard } from 'src/app/_guards/auth.can-activate.guard';<br/>import { RequireSaveCanDeactivateGuard } from 'src/app/_guards/require-save.can-deactivate.guard';</span></pre><p id="8c2d" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">桶出口:</p><pre class="kh ki kj kk gt nt nr nu nv aw nw bi"><span id="96e9" class="nx ks iq nr b gy ny nz l oa ob">import { AuthCanActivateGuard, RequireSaveCanDeactivateGuard } from 'src/app/_guards';</span></pre><p id="84a8" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">带有<code class="fe no np nq nr b">_guards</code>目录的示例应用程序如下所示:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi on"><img src="../Images/918e0b8b5fae7d87a9f3d3a3872fdcac.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/0*3s5C5fWhZvSXP100.png"/></div></figure><h2 id="1ac1" class="nx ks iq bd kt oc od dn kx oe of dp lb ma og oh lf me oi oj lj mi ok ol ln om bi translated">组织特定功能的路径保护</h2><p id="c35a" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">如果你有在特定的<code class="fe no np nq nr b">FeatureRoutes</code>阵列中只使用<em class="nk">的</em>守卫，那么将这些路线存储在你的特征文件夹下名为<code class="fe no np nq nr b">_guards</code>的文件夹下。确保遵循上面定义的相同命名约定，以及桶导出。</p><ul class=""><li id="14bb" class="mn mo iq lr b ls mp lw mq ma mr me ms mi mt mm mu mv mw mx bi translated">在特征文件夹下名为<code class="fe no np nq nr b">_guards</code>的文件夹下放置防护</li><li id="b601" class="mn mo iq lr b ls mz lw na ma nb me nc mi nd mm mu mv mw mx bi translated">确保为干净的导入创建一个桶导出<code class="fe no np nq nr b">index.ts</code></li></ul><p id="2767" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">带有<code class="fe no np nq nr b">_guards</code>的特征目录示例如下:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/09637d77a7085d7deb3a109cb4c49bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/0*FFtIzvWWjssPRctv.png"/></div></figure><h1 id="775e" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">完成的应用程序结构</h1><p id="7571" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">完整的应用程序结构应该如下所示:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi op"><img src="../Images/06fd3b954f543a5c67d85f5bd42787b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/0*SVk8FLCbwbnr_rJs.png"/></div></figure><h1 id="ca27" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">GitHub资源库示例</h1><p id="fad1" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">我在GitHub上创建了一个演示库。随意派生、克隆和提交PRs。</p><div class="jn jo gp gr jp jq"><a href="https://github.com/wesleygrimes/angular-routing-best-practices" rel="noopener  ugc nofollow" target="_blank"><div class="jr ab fo"><div class="js ab jt cl cj ju"><h2 class="bd ir gy z fp jv fr fs jw fu fw ip bi translated">Wesley Grimes/角度路由最佳实践</h2><div class="jx l"><h3 class="bd b gy z fp jv fr fs jw fu fw dk translated">角度路由-企业应用的最佳实践-Wesley Grimes/角度路由-最佳实践</h3></div><div class="jy l"><p class="bd b dl z fp jv fr fs jw fu fw dk translated">github.com</p></div></div><div class="jz l"><div class="oq l kb kc kd jz ke kf jq"/></div></div></a></div><h1 id="0fd1" class="kr ks iq bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">结论</h1><p id="8a15" class="pw-post-body-paragraph lp lq iq lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">重要的是要记住，我已经在几个“真实世界”的应用程序中实现了这些最佳实践。虽然我发现这些最佳实践是有帮助的，并且是可维护的，但是我不认为它们是组织项目中路线的终极解决方案；我就是这么做的。我很好奇你们都是怎么想的？在使用routing构建企业级Angular应用程序时，请随时提供您所学到的任何建议、技巧或最佳实践，我将更新文章以反映这一点。</p><p id="7dc2" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated">编码快乐！</p></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><p id="d6d3" class="pw-post-body-paragraph lp lq iq lr b ls mp lu lv lw mq ly lz ma ne mc md me nf mg mh mi ng mk ml mm ij bi translated"><em class="nk">原载于2019年2月24日</em><a class="ae my" href="https://wesleygrimes.com/angular/2019/02/24/angular-routing-best-practices-for-enterprise-applications.html" rel="noopener ugc nofollow" target="_blank"><em class="nk">wesleygrimes.com</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>