<html>
<head>
<title>Steganography — LSB Introduction with Python — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">隐写术Python的LSB介绍—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/steganography-101-lsb-introduction-with-python-4c4803e08041?source=collection_archive---------2-----------------------#2019-10-07">https://itnext.io/steganography-101-lsb-introduction-with-python-4c4803e08041?source=collection_archive---------2-----------------------#2019-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="24ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在PNG图像文件像素的RGB通道中隐藏纯文本消息</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/90a480932e0e69c64eef84ea6b3aa5d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7EgVv9pLBPHYmnYY.jpg"/></div></div></figure><p id="95e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kx translated"><span class="l ky kz la bm lb lc ld le lf di">几周前，我的一位</span>朋友向我介绍了<a class="ae lg" href="https://www.hackthebox.eu" rel="noopener ugc nofollow" target="_blank"> hackthebox.eu </a>，从那以后，尽管这不是挑战的主要类别，但我已经对隐写术的世界着迷了。一个看似无害的容器把秘密数据藏在里面的整个概念让我大吃一惊，当我还是个孩子的时候，我第一次发现我可以用柠檬汁写秘密信息。</p><blockquote class="li lj lk"><p id="7bed" class="jn jo lh jp b jq jr js jt ju jv jw jx ll jz ka kb lm kd ke kf ln kh ki kj kk ij bi translated"><a class="ae lg" href="https://en.wikipedia.org/wiki/Steganography" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>(/ˌstɛɡəˈnɒɡrəfi/(steg-ə-nog-rə-fee)是将一个文件、消息、图像或视频隐藏在另一个文件、消息、图像或视频中的做法。“隐写术”一词由希腊语“隐写术”(στεγᾰνός)和“书写术”(γραφή)结合而成，前者意为“覆盖或隐藏”。</p></blockquote><p id="25e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就好像你突然拥有了这种超能力，即使你永远都不需要使用它。你把自己想象成一名间谍，携带着即使最聪明的人也无法发现的隐藏数据。</p><p id="cb75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，现实并不完全是这样，有无数的工具可以帮助好奇的头脑找到数据。正是这些工具的盲目使用使我试图理解这个过程，并且在我这样做的同时，编写一些工具来帮助我们隐藏和检索其他文件中的数据。</p><p id="8b1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我强调一下<strong class="jp ir"> find </strong>这个词，因为尽管它通常与加密结合使用，但最基本形式的隐写术只会将一些数据隐藏在容器内。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="d897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kx translated"><span class="l ky kz la bm lb lc ld le lf di">我</span>今天想重点讨论图像固定器内部的LSB隐写术。LSB代表最低有效位，它指的是用构成我们想要隐藏的数据的位替换创建容器文件的字节的最低有效位的过程。</p><p id="7142" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最初的目标是将字符串“ledger”隐藏在一个12x12的图像中。在我们做了这些之后，我会在另一篇文章中跟进如何将一个图像隐藏在另一个图像中，并改进我们今天写的代码，以提供一些故障保险。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lv"><img src="../Images/91f955115a27a9a7342b4ea87f7b599d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5R51MoHG-7taq05taqplQ.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">一个简单的纯色图像作为源</figcaption></figure><p id="242d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们用类似于<code class="fe ma mb mc md b">PIL</code>的东西从这个图像中读取像素，我们将得到一个包含RGB(如果有的话+alpha)通道的值(0–255)的元组。这意味着对于每个像素，我们有3-4位来处理。字符串“<em class="lh"> ledger </em>”的二进制表示是<code class="fe ma mb mc md b">011011000110010101100100011001110110010101110010</code>，它有48位长，这意味着我们至少需要16个像素，因为我们假设没有alpha通道。</p><h1 id="d9ef" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">视觉上，这是如何工作的？</h1><p id="2018" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi kx translated"><span class="l ky kz la bm lb lc ld le lf di"> E </span>图像的每个像素包含三个通道，分别代表该像素颜色的红色、绿色和蓝色值。该值可以用一个字节表示，合并它们(你可以在你的图像编辑器中使用<em class="lh">变亮</em>混合模式)当然会返回源颜色。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/a60ced7dd249247d4e04ba6ce81703c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HeqPeanxAKuHwFHIPev7nw.png"/></div></div></figure><p id="f67a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，替换最低有效位意味着将代表紫檀木颜色的<code class="fe ma mb mc md b">01100100</code>转换为<code class="fe ma mb mc md b">01100101</code>，但是由于我们数据的前三位是<code class="fe ma mb mc md b">011</code>，我们只需要用<code class="fe ma mb mc md b">10010001</code>替换绿色的<code class="fe ma mb mc md b">10010000</code>。这意味着在大多数情况下，我们甚至不需要修改所有的频道</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/cc558bffe4a1f8e22db4848037895994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hr_Hk27_k2lIWKbpX9DNCg.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">相信我，底部的矩形是两种不同的颜色</figcaption></figure><p id="e167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然数字不会说谎，但<code class="fe ma mb mc md b">#6490F1</code>和<code class="fe ma mb mc md b">#6491F1</code>之间的视觉差异可以忽略不计。此外，我们需要记住，当在现实世界中这样做时，它将被托管在一个具有更多不同颜色的图像上，这使得肉眼几乎不可能看出任何差异。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="d4c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我能想到的将任意二进制数据写入png图像而无需任何数据长度检查、提示或帮助的最简单代码如下。代码应该非常简单，唯一的例外可能是位操作。<code class="fe ma mb mc md b">pixel[n] &amp; ~1</code>将从通道中清除LSB，然后我们只需在数据显示时更改为<code class="fe ma mb mc md b">1</code>，运行<code class="fe ma mb mc md b">| 1</code>将LSB变为1，而<code class="fe ma mb mc md b">| 0</code>将保持原样。</p><pre class="km kn ko kp gt nj md nk nl aw nm bi"><span id="9dd9" class="nn mf iq md b gy no np l nq nr">i=<em class="lh">0<br/></em>data = "011011000110010101100100011001110110010101110010" #ledger<br/>with Image.open("source.png") as img:<br/>    width, height = img.size<br/>    for x in range(<em class="lh">0</em>, width):<br/>        for y in range(<em class="lh">0</em>, height):<em class="lh"><br/>            </em>pixel = list(img.getpixel((x, y)))<br/>            for n in range(<em class="lh">0</em>,<em class="lh">3</em>):<br/>                if(i &lt; len(data)):<em class="lh"><br/>                    </em>pixel[n] = pixel[n] &amp; ~<em class="lh">1 </em>| int(data[i])<br/>                    i+=<em class="lh">1<br/>            </em>img.putpixel((x,y), tuple(pixel))<br/>    img.save("source_secret.png", "PNG")</span></pre><p id="d1c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我相信还有其他方法可以做到这一点，正如我上面提到的，我在写这篇文章的时候也在学习，所以如果我做错了，请随时提供一些意见:)</p><h2 id="4219" class="nn mf iq bd mg ns nt dn mk nu nv dp mo jy nw nx ms kc ny nz mw kg oa ob na oc bi translated">怎么把数据拿回来？</h2><p id="991b" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">要提取的代码实际上与要编写的代码是一样的，但是我们只是读取它，而不是修改LSB。为了读取python中一个字节的LSB，我们做了一个按位AND运算<code class="fe ma mb mc md b">&amp;1</code></p><pre class="km kn ko kp gt nj md nk nl aw nm bi"><span id="f4d9" class="nn mf iq md b gy no np l nq nr">extracted_bin = []<br/>with Image.open("source_secret.png") as img:<br/>    width, height = img.size<br/>    byte = []<br/>    for x in range(<em class="lh">0</em>, width):<br/>        for y in range(<em class="lh">0</em>, height):<br/>            pixel = list(img.getpixel((x, y)))<br/>            for n in range(<em class="lh">0</em>,<em class="lh">3</em>):<br/>                extracted_bin.append(pixel[n]&amp;<em class="lh">1</em>)<br/><br/>data = "".join([str(x) for x in extracted_bin])</span></pre><p id="05c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们忽略了隐藏数据的长度，所以输出将在开头，后面是图像其余部分的文本表示，类似于在文本编辑器上打开图像时会发生的情况。</p><h2 id="018c" class="nn mf iq bd mg ns nt dn mk nu nv dp mo jy nw nx ms kc ny nz mw kg oa ob na oc bi translated">能这样存储的数据极限是多少？</h2><p id="421f" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">假设我们替换图像的每个像素的LSB，理论上我们可以存储<code class="fe ma mb mc md b">W*H*3/8</code>字节的数据，考虑到我们正在使用的固定器图像是12×12像素，将在LSB中给我们54字节的存储。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi od"><img src="../Images/c4d5a0694eb799b97e04de1321b442e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svpDkpJqusI1ZQEA5SWVTg.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">这张图片包含一个秘密信息，但medium可能会处理它们，所以这里有一个到原始<a class="ae lg" href="https://raw.githubusercontent.com/juan-cortes/steg/master/test_secret.png" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/Juan-cortes/steg/master/test _ secret . png</a>的链接</figcaption></figure><p id="7fec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会告诉你更多的进展。</p></div></div>    
</body>
</html>