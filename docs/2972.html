<html>
<head>
<title>How to orchestrate stateless apps in Kubernetes?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Kubernetes中编排无状态应用？</h1>
<blockquote>原文：<a href="https://itnext.io/stateless-apps-in-kubernetes-beyond-pods-f0f584eda91b?source=collection_archive---------3-----------------------#2019-09-09">https://itnext.io/stateless-apps-in-kubernetes-beyond-pods-f0f584eda91b?source=collection_archive---------3-----------------------#2019-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好Kubernauts！欢迎来到“果壳中的库伯内特”博客系列:-)</p><p id="31a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是介绍用于管理无状态应用程序的原生Kubernetes原语的第一部分。Kubernetes最常见的用例之一是编排和操作无状态服务。在Kubernetes中，您需要一个<code class="fe kl km kn ko b">Pod</code>(或者在大多数情况下需要一个<code class="fe kl km kn ko b">Pod</code>的<em class="kp">组</em>来表示一个服务或应用程序——但是还有更多！我们将超越基本的<code class="fe kl km kn ko b">Pod</code>，探索其他高级组件，即<code class="fe kl km kn ko b">ReplicaSet</code>和<code class="fe kl km kn ko b">Deployment</code></p><p id="8fdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，代码<a class="ae kq" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell" rel="noopener ugc nofollow" target="_blank">可以在GitHub </a>上获得</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/28d47c3d6b86b97615e153222e63c28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*zGQfdIwvexM9wzx4.gif"/></div></figure><p id="357d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，您需要一个Kubernetes集群。这可能是一个简单的使用<code class="fe kl km kn ko b"><a class="ae kq" href="https://kubernetes.io/docs/setup/learning-environment/minikube/" rel="noopener ugc nofollow" target="_blank">minikube</a></code>、<code class="fe kl km kn ko b"><a class="ae kq" href="https://blog.docker.com/2018/01/docker-mac-kubernetes/" rel="noopener ugc nofollow" target="_blank">Docker for Mac</a></code>等的单节点本地集群。或者来自<a class="ae kq" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">Azure</a><a class="ae kq" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank">Google</a><a class="ae kq" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank">AWS</a>等的托管Kubernetes服务。要访问你的Kubernetes集群，你需要<code class="fe kl km kn ko b"><a class="ae kq" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank">kubectl</a></code>，它很容易安装。</p><p id="07e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，要为Mac安装<code class="fe kl km kn ko b">kubectl</code>,您只需</p><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="3bc2" class="ld le iq ko b gy lf lg l lh li">curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl &amp;&amp; \<br/>chmod +x ./kubectl &amp;&amp; \<br/>sudo mv ./kubectl /usr/local/bin/kubectl</span></pre><p id="4141" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你已经安装了<a class="ae kq" href="https://docs.microsoft.com/cli/azure/?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure CLI </a>，你需要做的就是<code class="fe kl km kn ko b"><a class="ae kq" href="https://docs.microsoft.com/cli/azure/acs/kubernetes?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu#az-acs-kubernetes-install-cli" rel="noopener ugc nofollow" target="_blank">az acs kubernetes install-cli</a></code>。</p><blockquote class="lj lk ll"><p id="7d11" class="jn jo kp jp b jq jr js jt ju jv jw jx lm jz ka kb ln kd ke kf lo kh ki kj kk ij bi translated"><em class="iq">如果你有兴趣学习Kubernetes和Containers使用</em><a class="ae kq" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"><em class="iq">Azure</em></a><em class="iq">，只需</em> <a class="ae kq" href="https://azure.microsoft.com/en-us/free/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">创建一个</em> <strong class="jp ir"> <em class="iq">免费</em> </strong> <em class="iq">账号</em> </a> <em class="iq">就可以开始了！一个好的起点是使用文档中的</em> <a class="ae kq" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">快速入门、教程和代码示例</em> </a> <em class="iq">来熟悉该服务。我也强烈推荐查看一下</em> <a class="ae kq" href="https://azure.microsoft.com/resources/kubernetes-learning-path/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> 50天Kubernetes学习路径</em> </a> <em class="iq">。高级用户可能希望参考</em> <a class="ae kq" href="https://docs.microsoft.com/azure/aks/best-practices?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Kubernetes最佳实践</em> </a> <em class="iq">或观看一些</em> <a class="ae kq" href="https://azure.microsoft.com/resources/videos/index/?services=kubernetes-service&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">视频</em> </a> <em class="iq">以了解演示、主要功能和技术会议。</em></p></blockquote><p id="6bc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从理解<code class="fe kl km kn ko b">Pod</code>的概念开始。</p><h1 id="3d92" class="lp le iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><code class="fe kl km kn ko b">Pod</code></h1><p id="0b4b" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">一个<code class="fe kl km kn ko b">Pod</code>是Kubernetes中最小的可能抽象，它可以运行一个或多个容器。这些容器共享资源(存储、卷)，并且可以通过<code class="fe kl km kn ko b">localhost</code>相互通信。</p><p id="6f62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用下面的YAML文件创建一个简单的<code class="fe kl km kn ko b">Pod</code>。</p><blockquote class="lj lk ll"><p id="6fa6" class="jn jo kp jp b jq jr js jt ju jv jw jx lm jz ka kb ln kd ke kf lo kh ki kj kk ij bi translated"><code class="fe kl km kn ko b"><em class="iq">Pod</em></code> <em class="iq">只是一个Kubernetes资源或对象。YAML文件是描述其期望状态以及一些基本信息的东西——它也被称为</em> <code class="fe kl km kn ko b"><em class="iq">manifest</em></code> <em class="iq">、</em> <code class="fe kl km kn ko b"><em class="iq">spec</em></code> <em class="iq">(规范的简写)或</em> <code class="fe kl km kn ko b"><em class="iq">definition</em></code> <em class="iq">。</em></p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="305f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为<code class="fe kl km kn ko b">Pod</code>规范的一部分，我们传达了在Kubernetes中运行<code class="fe kl km kn ko b"><a class="ae kq" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank">nginx</a></code>的意图，并使用<code class="fe kl km kn ko b">spec.containers.image</code>指向其在<a class="ae kq" href="https://hub.docker.com/_/nginx" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>上的容器图像。</p><p id="449e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe kl km kn ko b"><a class="ae kq" href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply" rel="noopener ugc nofollow" target="_blank">kubectl apply</a></code>命令向Kubernetes提交<code class="fe kl km kn ko b">Pod</code>信息。</p><blockquote class="lj lk ll"><p id="16d8" class="jn jo kp jp b jq jr js jt ju jv jw jx lm jz ka kb ln kd ke kf lo kh ki kj kk ij bi translated"><em class="iq">为了简单起见，直接从</em><a class="ae kq" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell" rel="noopener ugc nofollow" target="_blank"><em class="iq">GitHub repo</em></a><em class="iq">中引用YAML文件，但是您也可以将文件下载到您的本地机器上，并以同样的方式使用它。</em></p></blockquote><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="79a0" class="ld le iq ko b gy lf lg l lh li">$ kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/stateless-apps/kin-stateless-pod.yaml</span><span id="48ca" class="ld le iq ko b gy mt lg l lh li">pod/kin-stateless-1 created</span><span id="4b59" class="ld le iq ko b gy mt lg l lh li">$ kubectl get pods</span><span id="7283" class="ld le iq ko b gy mt lg l lh li">NAME                               READY   STATUS    RESTARTS   AGE<br/>kin-stateless-1                    1/1     Running   0          10s</span></pre><p id="b12a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这应该如预期的那样工作。现在，让我们删除<code class="fe kl km kn ko b">Pod</code>，看看会发生什么。为此，我们需要使用<code class="fe kl km kn ko b">kubectl delete pod &lt;pod_name&gt;</code></p><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="3dd6" class="ld le iq ko b gy lf lg l lh li">$ kubectl delete pod kin-stateless-1<br/>pod "kin-stateless-1" deleted</span><span id="e234" class="ld le iq ko b gy mt lg l lh li">$ kubectl get pods<br/>No resources found.</span></pre><p id="ddbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">….就这样，<code class="fe kl km kn ko b">Pod</code>消失了！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/f05fad2a660feada01a44ea727446689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*_ajB8E9BaVTzipps.gif"/></div></figure><p id="e55b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于严肃的应用程序，您必须注意以下几个方面:</p><ul class=""><li id="8eb2" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><strong class="jp ir">高可用性和弹性</strong> —理想情况下，您的应用程序应该足够健壮，能够自我修复并在出现故障时保持可用，例如<code class="fe kl km kn ko b">Pod</code>由于节点故障导致的删除等。</li><li id="9423" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir">可伸缩性</strong>——如果你的应用程序的单个实例(<code class="fe kl km kn ko b">Pod</code>)不够用怎么办？您不想运行副本/多个实例吗？</li></ul><p id="8efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦有多个应用程序实例跨集群运行，您将需要考虑:</p><ul class=""><li id="3d7a" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><strong class="jp ir">缩放</strong> —你能指望底层平台自动处理水平缩放吗？</li><li id="98f4" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir">访问您的应用程序</strong> —客户端(内部或外部)如何访问您的应用程序，多个实例之间的流量是如何调节的？</li><li id="8419" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir">升级</strong> —您如何以无中断方式(即不停机)处理应用程序更新？</li></ul><p id="5c3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题说够了。让我们来看看一些可能的解决方案！</p><h1 id="747a" class="lp le iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Pod控制器</h1><p id="946a" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">虽然可以直接创建<code class="fe kl km kn ko b">Pod</code> s，但是使用Kubernetes在<code class="fe kl km kn ko b">Pod</code> s之上提供的更高级别的组件来解决上述问题是有意义的。简单来说，这些组件(也称为<code class="fe kl km kn ko b">Controllers</code>)可以创建和管理一组<code class="fe kl km kn ko b">Pod</code></p><p id="e1d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下控制器在<code class="fe kl km kn ko b">Pod</code>和无状态应用的环境中工作:</p><ul class=""><li id="f3fb" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><strong class="jp ir">复制集</strong></li><li id="a40f" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir">部署</strong></li><li id="6250" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir">复制控制器</strong></li></ul><blockquote class="lj lk ll"><p id="13e2" class="jn jo kp jp b jq jr js jt ju jv jw jx lm jz ka kb ln kd ke kf lo kh ki kj kk ij bi translated"><em class="iq">还有其他的</em> <code class="fe kl km kn ko b"><em class="iq">Pod</em></code> <em class="iq">控制器，如</em><code class="fe kl km kn ko b"><em class="iq">StatefulSet</em></code><em class="iq"/><code class="fe kl km kn ko b"><em class="iq">Job</em></code><em class="iq"/><code class="fe kl km kn ko b"><em class="iq">DaemonSet</em></code><em class="iq">等。但是它们与无状态应用程序无关，因此不在这里讨论</em></p></blockquote><h1 id="eb2a" class="lp le iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">复制集</h1><p id="2b00" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">一个<code class="fe kl km kn ko b">ReplicaSet</code>可以用来确保应用程序的固定数量的副本/实例(<code class="fe kl km kn ko b">Pod</code>)总是可用的。它在(用户定义的)选择器的帮助下识别需要管理的一组<code class="fe kl km kn ko b">Pod</code>并协调它们(创建或删除)以维护期望的实例计数。</p><p id="b24c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个常见的<code class="fe kl km kn ko b">ReplicaSet</code>规格</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9cee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建<code class="fe kl km kn ko b">ReplicaSet</code></p><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="632f" class="ld le iq ko b gy lf lg l lh li">$ kubectl apply -f  https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/stateless-apps/kin-stateless-replicaset.yaml</span><span id="7eb3" class="ld le iq ko b gy mt lg l lh li">replicaset.apps/kin-stateless-rs created</span><span id="73c0" class="ld le iq ko b gy mt lg l lh li">$ kubectl get replicasets</span><span id="7239" class="ld le iq ko b gy mt lg l lh li">NAME               DESIRED   CURRENT   READY   AGE<br/>kin-stateless-rs   2         2         2       1m11s</span><span id="6e93" class="ld le iq ko b gy mt lg l lh li">$ kubectl get pods --selector=app=kin-stateless-rs</span><span id="f905" class="ld le iq ko b gy mt lg l lh li">NAME                     READY   STATUS    RESTARTS   AGE<br/>kin-stateless-rs-zn4p2   1/1     Running   0          13s<br/>kin-stateless-rs-zxp5d   1/1     Running   0          13s</span></pre><p id="a60b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<code class="fe kl km kn ko b">ReplicaSet</code>对象(名为<code class="fe kl km kn ko b">kin-stateless-rs</code>)是和两个<code class="fe kl km kn ko b">Pod</code>一起创建的(注意<code class="fe kl km kn ko b">Pod</code>的名称包含一个随机的字母数字字符串，例如<code class="fe kl km kn ko b">zn4p2</code>)</p><p id="bf91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是按照我们在YAML提供的(规格):</p><ul class=""><li id="1461" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><code class="fe kl km kn ko b">spec.replicas</code>被设置为<code class="fe kl km kn ko b">two</code></li><li id="645a" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><code class="fe kl km kn ko b">selector.matchLabels</code>被设置为<code class="fe kl km kn ko b">app: kin-stateless-rs</code>并匹配<code class="fe kl km kn ko b">Pod</code>规格中的<code class="fe kl km kn ko b">.spec.template.metadata.labels</code>字段。</li></ul><blockquote class="lj lk ll"><p id="75a8" class="jn jo kp jp b jq jr js jt ju jv jw jx lm jz ka kb ln kd ke kf lo kh ki kj kk ij bi translated"><a class="ae kq" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">标签是简单的键值对</em> </a> <em class="iq">，可以添加到对象中(比如本例中的</em> <code class="fe kl km kn ko b"><em class="iq">Pod</em></code> <em class="iq">)。</em></p></blockquote><p id="5541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在<code class="fe kl km kn ko b">kubectl get</code>命令中使用了<code class="fe kl km kn ko b">--selector</code>来根据标签过滤<code class="fe kl km kn ko b">Pod</code>，在本例中是<code class="fe kl km kn ko b">app=kin-stateless-rs</code>。</p><p id="8c8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">试着删除一个<code class="fe kl km kn ko b">Pod</code>(就像你在前面的例子中做的那样)</p><blockquote class="lj lk ll"><p id="6507" class="jn jo kp jp b jq jr js jt ju jv jw jx lm jz ka kb ln kd ke kf lo kh ki kj kk ij bi translated"><em class="iq">请注意，</em> <code class="fe kl km kn ko b"><em class="iq">Pod</em></code> <em class="iq">名称在您的情况下会有所不同，所以请确保使用正确的名称。</em></p></blockquote><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="abef" class="ld le iq ko b gy lf lg l lh li">$ kubectl delete pod kin-stateless-rs-zxp5d</span><span id="d645" class="ld le iq ko b gy mt lg l lh li">pod "kin-stateless-rs-zxp5d" deleted</span><span id="2f54" class="ld le iq ko b gy mt lg l lh li">$ kubectl get pods -l=app=kin-stateless-rs</span><span id="992a" class="ld le iq ko b gy mt lg l lh li">NAME                     READY   STATUS    RESTARTS   AGE<br/>kin-stateless-rs-nghgk   1/1     Running   0          9s<br/>kin-stateless-rs-zn4p2   1/1     Running   0          5m</span></pre><p id="ed69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还有两个<code class="fe kl km kn ko b">Pod</code> s！这是因为创建了一个新的<code class="fe kl km kn ko b">Pod</code>(突出显示)来满足<code class="fe kl km kn ko b">ReplicaSet</code>的副本计数(两个)。</p><p id="cdac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要水平扩展您的应用程序，您需要做的就是更新清单文件中的<code class="fe kl km kn ko b">spec.replicas</code>字段并再次提交它。</p><blockquote class="lj lk ll"><p id="2dd6" class="jn jo kp jp b jq jr js jt ju jv jw jx lm jz ka kb ln kd ke kf lo kh ki kj kk ij bi translated">作为一个练习，试着把它扩大到五个副本，然后再回到三个。</p></blockquote><p id="b4cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止一切顺利！但这并不能解决所有问题。其中之一是处理应用程序更新，特别是以不需要停机的方式。Kubernetes提供了另一个在<code class="fe kl km kn ko b">ReplicaSet</code> s之上工作的组件来处理这个和更多的问题。</p><h1 id="4272" class="lp le iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">部署</h1><p id="08ae" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">一个<code class="fe kl km kn ko b">Deployment</code>是管理一个<code class="fe kl km kn ko b">ReplicaSet</code>的抽象——回想一下上一节，一个<code class="fe kl km kn ko b">ReplicaSet</code>管理一组pod。除了弹性可伸缩性之外，<code class="fe kl km kn ko b">Deployment</code>还提供了其他有用的特性，允许您管理更新、回滚到以前的状态、暂停和恢复部署过程等。让我们来探讨这些。</p><p id="fed9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes <code class="fe kl km kn ko b">Deployment</code>从其底层<code class="fe kl km kn ko b">ReplicaSet</code>借用了以下特性:</p><ul class=""><li id="7ae6" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><strong class="jp ir">弹性</strong> —由于<code class="fe kl km kn ko b">ReplicaSet</code>，如果一个Pod崩溃，它会自动重启。唯一的例外是当您将<code class="fe kl km kn ko b">Pod</code>规格中的<code class="fe kl km kn ko b">restartPolicy</code>设置为<code class="fe kl km kn ko b">Never</code>时。</li><li id="e90c" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><strong class="jp ir">缩放</strong> —这也由底层<code class="fe kl km kn ko b">ReplicaSet</code>对象负责。</li></ul><p id="bd70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是典型的<code class="fe kl km kn ko b">Deployment</code>规格的样子</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2b6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建<code class="fe kl km kn ko b">Deployment</code>并查看创建了哪些Kubernetes对象</p><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="405f" class="ld le iq ko b gy lf lg l lh li">$ kubectl apply -f  https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/stateless-apps/kin-stateless-deployment.yaml<br/>deployment.apps/kin-stateless-depl created</span><span id="5e9a" class="ld le iq ko b gy mt lg l lh li">$ kubectl get deployment kin-stateless-dp<br/>NAME               READY   UP-TO-DATE   AVAILABLE   AGE<br/>kin-stateless-dp   2/2     2            2           10</span><span id="1ead" class="ld le iq ko b gy mt lg l lh li">$ kubectl get replicasets<br/>NAME                         DESIRED   CURRENT   READY   AGE<br/>kin-stateless-dp-8f9b4d456   2         2         2       12</span><span id="73c5" class="ld le iq ko b gy mt lg l lh li">$ kubectl get pods -l=app=kin-stateless-dp<br/>NAME                               READY   STATUS    RESTARTS   AGE<br/>kin-stateless-dp-8f9b4d456-csskb   1/1     Running   0          14s<br/>kin-stateless-dp-8f9b4d456-hhrj7   1/1     Running   0          14s</span></pre><p id="1d8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">Deployment</code> ( <code class="fe kl km kn ko b">kin-stateless-dp</code>)与<code class="fe kl km kn ko b">spec.replicas</code>字段中指定的<code class="fe kl km kn ko b">ReplicaSet</code>和(两个)<code class="fe kl km kn ko b">Pod</code>一起创建。太好了！现在，让我们看一下<code class="fe kl km kn ko b">Pod</code>看看我们使用的是哪个<code class="fe kl km kn ko b">nginx</code>版本——请注意，在您的情况下<code class="fe kl km kn ko b">Pod</code>名称会有所不同，所以请确保您使用的是正确的名称</p><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="8930" class="ld le iq ko b gy lf lg l lh li">$ kubectl exec kin-stateless-dp-8f9b4d456-csskb -- nginx -v<br/>nginx version: nginx/1.17.3</span></pre><p id="bc35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为<code class="fe kl km kn ko b">nginx</code>图像的<code class="fe kl km kn ko b">latest</code>标签是从<a class="ae kq" href="https://hub.docker.com/_/nginx" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>中获取的，而该标签在编写时恰好是<code class="fe kl km kn ko b">v1.17.3</code>。</p><blockquote class="lj lk ll"><p id="e2df" class="jn jo kp jp b jq jr js jt ju jv jw jx lm jz ka kb ln kd ke kf lo kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">什么是</em> </strong> <code class="fe kl km kn ko b"><strong class="jp ir"><em class="iq">kubectl exec</em></strong></code> <strong class="jp ir"> <em class="iq">？</em> </strong> <em class="iq">简单来说，它允许你在一个</em> <code class="fe kl km kn ko b"><em class="iq">Pod</em></code> <em class="iq">内的特定容器中执行一个命令。在这种情况下，我们的</em> <code class="fe kl km kn ko b"><em class="iq">Pod</em></code> <em class="iq">有一个单独的容器，所以我们不需要指定一个</em></p></blockquote><h1 id="919f" class="lp le iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">更新一个<code class="fe kl km kn ko b">Deployment</code></h1><p id="737c" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">您可以通过修改<code class="fe kl km kn ko b">Pod</code>规范的模板部分来触发对现有<code class="fe kl km kn ko b">Deployment</code>的更新——一个常见的例子是更新到容器映像的较新版本(标签)。您可以使用<code class="fe kl km kn ko b">Deployment</code>清单中的<code class="fe kl km kn ko b">spec.strategy.type</code>来指定，有效选项为- <code class="fe kl km kn ko b">Rolling</code>更新和<code class="fe kl km kn ko b">Recreate</code>。</p><p id="0480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">滚动更新</strong></p><p id="8d71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">滚动更新确保您不会在更新过程中导致应用程序停机——这是因为更新一次只发生一次<code class="fe kl km kn ko b">Pod</code>。在某个时间点，应用程序的早期版本和当前版本共存。一旦更新完成，旧的<code class="fe kl km kn ko b">Pod</code>将被删除，但是在某个阶段，部署中的<code class="fe kl km kn ko b">Pod</code>的总数将超过指定的<code class="fe kl km kn ko b">replicas</code>计数。</p><p id="ef39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以使用<code class="fe kl km kn ko b">maxSurge</code>和<code class="fe kl km kn ko b">maxUnavailable</code>设置进一步调整该行为。</p><ul class=""><li id="5bf9" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><code class="fe kl km kn ko b">spec.strategy.rollingUpdate.maxSurge</code> —除了指定的副本数量之外，可以创建的最大数量的<code class="fe kl km kn ko b">Pod</code></li><li id="d5bb" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><code class="fe kl km kn ko b">spec.strategy.rollingUpdate.maxUnavailable</code> —定义不可用的<code class="fe kl km kn ko b">Pod</code>的最大数量</li></ul><p id="1e51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">再造</strong></p><p id="4b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这非常简单——在推出新版本之前，旧的一组pod会被删除。你可以使用<code class="fe kl km kn ko b">ReplicaSet</code> s获得同样的结果，首先删除旧的，然后用更新的规格创建一个新的(例如，新的docker图像等)。)</p><p id="bcbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们尝试通过指定一个显式的Docker图像标签来更新应用程序——在这种情况下，我们将使用<code class="fe kl km kn ko b">1.16.0</code>。这意味着一旦我们更新了我们的应用程序，这个版本应该在我们反省我们的<code class="fe kl km kn ko b">Pod</code>时反映出来。</p><p id="5733" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下载上面的<code class="fe kl km kn ko b">Deployment</code>清单，更新它以将<code class="fe kl km kn ko b">spec.containers.image</code>从<code class="fe kl km kn ko b">nginx</code>更改为<code class="fe kl km kn ko b">nginx:1.16.0</code>，并提交给集群——这将触发更新</p><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="f5eb" class="ld le iq ko b gy lf lg l lh li">$ kubectl apply -f deployment.yaml<br/>deployment.apps/kin-stateless-dp configured</span><span id="10ee" class="ld le iq ko b gy mt lg l lh li">$ kubectl get pods -l=app=kin-stateless-dp<br/>NAME                                READY   STATUS    RESTARTS   AGE<br/>kin-stateless-dp-5b66475bd4-gvt4z   1/1     Running   0          49s<br/>kin-stateless-dp-5b66475bd4-tvfgl   1/1     Running   0          61s</span></pre><p id="3a2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您现在应该会看到一组新的<code class="fe kl km kn ko b">Pod</code>(注意名称)。要确认更新:</p><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="d84f" class="ld le iq ko b gy lf lg l lh li">$ kubectl exec kin-stateless-dp-5b66475bd4-gvt4z -- nginx -v<br/>nginx version: nginx/1.16.0</span></pre><blockquote class="lj lk ll"><p id="b257" class="jn jo kp jp b jq jr js jt ju jv jw jx lm jz ka kb ln kd ke kf lo kh ki kj kk ij bi translated"><em class="iq">请注意，</em> <code class="fe kl km kn ko b"><em class="iq">Pod</em></code> <em class="iq">名称会因您的情况而异，所以请确保使用正确的名称</em></p></blockquote><h1 id="b796" class="lp le iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">反转</h1><p id="a3fc" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">如果当前的<code class="fe kl km kn ko b">Deployment</code>不尽如人意，您可以恢复到以前的版本，以防新版本不能如预期那样工作。这是可能的，因为Kubernetes以修订版的形式存储了<code class="fe kl km kn ko b">Deployment</code>的首次展示历史。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/772b59f859e1bf0085f6a6f04ba6d599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*tMEwmyPWMJkloWqJ.gif"/></div></figure><p id="4c7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要检查<code class="fe kl km kn ko b">Deployment</code>的历史记录:</p><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="5151" class="ld le iq ko b gy lf lg l lh li">$ kubectl rollout history deployment/kin-stateless-dp</span><span id="ecde" class="ld le iq ko b gy mt lg l lh li">deployment.extensions/kin-stateless-dp</span><span id="3c56" class="ld le iq ko b gy mt lg l lh li">REVISION  CHANGE-CAUSE<br/>1         &lt;none&gt;<br/>2         &lt;none&gt;</span></pre><p id="d6a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意有两个版本，其中<code class="fe kl km kn ko b">2</code>是最新版本。我们可以使用<code class="fe kl km kn ko b">kubectl rollout undo</code>回滚到前一个</p><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="7c0b" class="ld le iq ko b gy lf lg l lh li">$ kubectl rollout undo deployment kin-stateless-dp<br/>deployment.extensions/kin-stateless-dp rolled back</span><span id="7066" class="ld le iq ko b gy mt lg l lh li">$ kubectl get pods -l=app=kin-stateless-dp<br/>NAME                                READY   STATUS        RESTARTS   AGE<br/>kin-stateless-dp-5b66475bd4-gvt4z   0/1     Terminating   0          10m<br/>kin-stateless-dp-5b66475bd4-tvfgl   1/1     Terminating   0          10m<br/>kin-stateless-dp-8f9b4d456-d4v97    1/1     Running       0          14s<br/>kin-stateless-dp-8f9b4d456-mq7sb    1/1     Running       0          7s</span></pre><p id="6e9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意中间状态，Kubernetes忙于终止旧的<code class="fe kl km kn ko b">Deployment</code>的<code class="fe kl km kn ko b">Pod</code>，同时确保创建新的<code class="fe kl km kn ko b">Pod</code>来响应回滚请求。</p><p id="e148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你再次检查<code class="fe kl km kn ko b">nginx</code>版本，你会看到这个应用确实已经回滚到<code class="fe kl km kn ko b">1.17.3</code>。</p><pre class="ks kt ku kv gt kz ko la lb aw lc bi"><span id="3784" class="ld le iq ko b gy lf lg l lh li">$ kubectl exec kin-stateless-dp-8f9b4d456-d4v97 -- nginx -v<br/>nginx version: nginx/1.17.3</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/86cd26d9496631b41b08dabb7758873b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*7yBNtGghzZ1iiuNe.gif"/></div></figure><h1 id="ded8" class="lp le iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">暂停和继续</h1><p id="9961" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">也可以暂停<code class="fe kl km kn ko b">Deployment</code>卷展栏，并在对其应用更改后将其恢复(在暂停状态期间)。</p><h1 id="eaf5" class="lp le iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><code class="fe kl km kn ko b">ReplicationController</code></h1><p id="e817" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">一个<code class="fe kl km kn ko b">ReplicationController</code>类似于一个<code class="fe kl km kn ko b">Deployment</code>或者<code class="fe kl km kn ko b">ReplicaSet</code>。然而，对于无状态应用程序编排来说，它不是推荐的方法，因为T3提供了更丰富的功能(如前一节所述)。你可以在Kubernetes文档中读到更多关于它们的内容。</p><h1 id="7512" class="lp le iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">参考</h1><p id="d702" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">查看Kubernetes文档，了解我们在本文中讨论的资源的API细节，即<code class="fe kl km kn ko b">Pod</code>、<code class="fe kl km kn ko b">ReplicaSet</code>和<code class="fe kl km kn ko b">Deployment</code></p><ul class=""><li id="6a3f" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated"><a class="ae kq" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#pod-v1-core" rel="noopener ugc nofollow" target="_blank"> Pod API参考</a></li><li id="e609" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><a class="ae kq" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#replicaset-v1-apps" rel="noopener ugc nofollow" target="_blank">复制集API参考</a></li><li id="c365" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated"><a class="ae kq" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#deployment-v1-apps" rel="noopener ugc nofollow" target="_blank">部署API参考</a></li></ul><p id="e5fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">敬请关注本系列的下一部分！</strong></p><p id="b7d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的希望你喜欢这篇文章，并从中学到了一些东西！如果你做了，请喜欢并跟随。很高兴通过<a class="ae kq" href="https://twitter.com/abhi_tweeter" rel="noopener ugc nofollow" target="_blank"> @abhi_tweeter </a>获得反馈或发表评论。</p></div></div>    
</body>
</html>