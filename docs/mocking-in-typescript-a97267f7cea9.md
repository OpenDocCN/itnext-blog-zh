# 模仿打字稿中的对象，函数风格

> 原文：<https://itnext.io/mocking-in-typescript-a97267f7cea9?source=collection_archive---------0----------------------->

![](img/169a885c873d6ebfbf6005b1c9d833af.png)

我喜欢测试驱动开发的想法，因为它让你思考什么代码做什么，而不是 T2 如何做。

在我目前的工作场所，我正在 Angular 中开发一个**非常**面向客户的在线商店应用程序。

即使我还没有达到 TDD 的水平，我也会努力让我的代码得到高的测试覆盖率，避免深夜打电话来说产品中的一个 bug，以及可能会破坏我女儿的睡眠。

作为一家网上商店，我正在与像**价格**和**产品**这样的实体打交道。这些是非常精简的**价格**和**产品**接口版本。实际上，后端 API 返回超过 25 个属性的对象。

Price.ts

产品. ts

这里有一段代码类似于我每天都要测试的代码，它使用了上面的接口。

产品用途

**filterProductsByName** 和 **addPriceToProduct** 都是使用 spread 运算符的纯定制函数。

如果你对函数式编程感兴趣，我推荐你观看 Mattias Petter Johansson 的视频。

上面的代码**按名称过滤** **产品**，而**将**价格**添加到**产品**中。**

# 嗯，让我们看看它是否真的有效！

我已经用 *Jest* 、 *Mocha* 以及当然还有 *TypeScript* 实现了测试。

产品实用程序规范

Uff，**超过 60 行**的测试代码，用于 14 行实际实现。

# 这伤害了我可爱的小灵魂！

因为我们对考试很认真，所以我们需要做些什么。

这个想法是在看了一篇 [Netanel Basal](https://medium.com/u/b889ae02aa26?source=post_page-----a97267f7cea9--------------------------------) 关于 [TypeScript 的部分](https://netbasal.com/getting-to-know-the-partial-type-in-typescript-ecfcfbc87cb6)的文章后想到的。

如果我不声明整个**产品**实体，而是使用一个**工厂函数**，它接受一个**部分<产品>** 参数(属于产品接口的属性子集)，并将其与一组默认属性合并，会怎么样？

即使我很着急，决定不带任何参数地调用 **getProductMock** ，我仍然可以安全地使用一个有效的默认**产品**类型对象。

产品.模拟. ts

价格.模拟. ts

# 在我们的工具带中有那些花哨的工厂，让我们嘲笑吧！

模拟产品实用程序规范

正如你所看到的，使用这些模拟函数的测试是**简洁的**，并且比不使用模拟函数的测试少一半的大小。

在这里，我只需要一个**蓬松产品** (grrr，倾向于写 pussy:)，只提供它的名字。你猜怎么着？ **getProductMock** 方法让我得以脱身，返回一个有效的产品。

# 就是这样，快乐嘲讽！

我希望你喜欢这篇文章，并会用这种简单的方式来嘲笑你的利益！