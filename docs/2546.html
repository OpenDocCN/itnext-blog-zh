<html>
<head>
<title>Bringing TypeScript Types at Runtime with TypeOnly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeOnly在运行时引入TypeScript类型</h1>
<blockquote>原文：<a href="https://itnext.io/bringing-typescript-types-at-runtime-with-typeonly-c317e9dd8880?source=collection_archive---------1-----------------------#2019-06-12">https://itnext.io/bringing-typescript-types-at-runtime-with-typeonly-c317e9dd8880?source=collection_archive---------1-----------------------#2019-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0a4a1252ed2aa803a8038af17ffff00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-TrnDPzDTm3k9T_ypQmtg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">感谢<a class="ae kc" href="https://www.goodfreephotos.com/south-africa/cape-town/sunrise-above-the-clouds-on-the-mountain-in-cape-town-south-africa.jpg.php" rel="noopener ugc nofollow" target="_blank">好的免费照片</a>。</figcaption></figure><p id="3aeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的团队中有一个人，我们最近发布了一个附带项目的初步版本，可能很有前途。我写这篇文章是为了介绍我们的工作。我从这个问题开始:为什么我们决定创建TypeOnly？</p><h1 id="3288" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">因为用TypeScript编写枯燥的代码并不总是可能的…</h1><p id="67b0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript类型定义在运行时不可用。有时这迫使我们重复自己，如下面的例子:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="827f" class="mn lc iq mj b gy mo mp l mq mr">type ColorName = "red" | "green" | "blue"</span><span id="3eeb" class="mn lc iq mj b gy ms mp l mq mr">function isColorName(name: string): name is ColorName {<br/>  return ["red", "green", "blue"].includes(name)<br/>}</span></pre><p id="6c52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种代码并不理想。Github上有一个与此主题相关的<a class="ae kc" href="https://github.com/microsoft/TypeScript/issues/3628" rel="noopener ugc nofollow" target="_blank">公开讨论</a>，TypeScript团队还不准备提供解决方案。</p><h1 id="6e32" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一种新语言？</h1><p id="a5ba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeOnly是一种新语言，但不是新语法。TypeOnly旨在成为并保持TypeScript的严格子集:任何使用TypeOnly编译的代码也将使用TypeScript编译。它是TypeScript的“纯类型化”部分:只有<code class="fe mt mu mv mj b">interface</code>和<code class="fe mt mu mv mj b">type</code>定义。要了解更多，请阅读TypeOnly语言的详细描述。</p><p id="8e6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeOnly解析器是从头开始实现的，不需要TypeScript作为依赖项。它可以在TypeScript项目之外使用，比如在JavaScript项目中，或者使用命令行工具来验证JSON数据。</p><h1 id="1258" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何用TypeOnly验证JSON数据(命令行版本)</h1><p id="cec7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">用以下代码创建一个文件<em class="mw"> "drawing.d.ts" </em>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f9ca" class="mn lc iq mj b gy mo mp l mq mr">// drawing.d.ts</span><span id="0733" class="mn lc iq mj b gy ms mp l mq mr">export interface Drawing {<br/>  color: ColorName<br/>  dashed?: boolean<br/>  shape: Rectangle | Circle<br/>}</span><span id="0bb9" class="mn lc iq mj b gy ms mp l mq mr">export type ColorName = "red" | "green" | "blue"</span><span id="4f6e" class="mn lc iq mj b gy ms mp l mq mr">export interface Rectangle {<br/>  kind: "rectangle",<br/>  x: number<br/>  y: number<br/>  width: number<br/>  height: number<br/>}</span><span id="2afd" class="mn lc iq mj b gy ms mp l mq mr">export interface Circle {<br/>  kind: "circle",<br/>  x: number<br/>  y: number<br/>  radius: number<br/>}</span></pre><p id="7f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，创建一个JSON文件<em class="mw"> "drawing.json" </em>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5952" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "color": "green",<br/>  "shape": {<br/>    "kind": "circle",<br/>    "x": 100,<br/>    "y": 100,<br/>    "radius": "wrong value"<br/>  }<br/>}</span></pre><p id="b114" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们准备验证JSON文件:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3c79" class="mn lc iq mj b gy mo mp l mq mr">$ npx @typeonly/validator-cli -s drawing.d.ts -t "Drawing" drawing.json<br/>In property 'radius', value '"wrong value"' is not conform to number.</span></pre><p id="5dd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JSON文件中检测到一个错误。通过用一个有效的数字替换属性<code class="fe mt mu mv mj b">"radius"</code>的值来修复它。比如:<code class="fe mt mu mv mj b">"radius": 50</code>。并再次运行该命令:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5924" class="mn lc iq mj b gy mo mp l mq mr">$ npx @typeonly/validator-cli -s drawing.d.ts -t "Drawing" drawing.json<br/>The JSON file is conform.</span></pre><p id="4eea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好。验证器不再抱怨。</p><h1 id="c4ca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">仅类型工具套件</h1><p id="7f30" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在上一节中，包含类型的文件是动态解析的。对于命令行验证程序来说，这是一个非常有用的特性，但是如果您需要验证Node.js程序中的几个JSONs，那么您需要解析一次输入，然后多次重用解析过的内容。或者，甚至更好:您希望在编译时解析类型定义，保存解析结果，然后在运行时不再需要解析器。这是使用TypeOnly的默认方式。因此，使用类型化元数据是一个快速和轻量级的过程。</p><p id="102d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeOnly目前附带4个npm包:</p><ul class=""><li id="642f" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated"><a class="ae kc" href="https://www.npmjs.com/package/typeonly" rel="noopener ugc nofollow" target="_blank"> typeonly </a>:使用<a class="ae kc" href="https://www.antlr.org/" rel="noopener ugc nofollow" target="_blank"> ANTLR </a>实现的解析器，性能很好，而且很小。它获取<code class="fe mt mu mv mj b">.d.ts</code>文件并生成RTO文件(RTO代表Raw TypeOnly，文件扩展名为<code class="fe mt mu mv mj b">.rto.json</code>)。</li><li id="28e2" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" href="https://www.npmjs.com/package/@typeonly/loader" rel="noopener ugc nofollow" target="_blank"> @typeonly/loader </a>:帮助加载RTO文件的轻量级API。</li><li id="1f43" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" href="https://www.npmjs.com/package/@typeonly/validator" rel="noopener ugc nofollow" target="_blank"> @typeonly/validator </a>:验证JSON或JavaScript数据的轻量级API。</li><li id="f77e" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">@typeonly/validator-cli :一个动态使用解析器和验证器的cli。</li></ul><h1 id="3223" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">教程，第一部分:解析仅类型代码</h1><p id="4820" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本教程中，我们将了解如何在JavaScript或TypeScript项目中使用TypeOnly。在一个新目录中，安装<code class="fe mt mu mv mj b">typeonly</code>作为一个依赖项:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a7c4" class="mn lc iq mj b gy mo mp l mq mr">npm init<br/>npm install typeonly --save-dev</span></pre><p id="b415" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个子目录<code class="fe mt mu mv mj b">src/</code>，并将上面例子中给出的<code class="fe mt mu mv mj b">drawing.d.ts</code>文件复制到其中。然后，编辑文件<code class="fe mt mu mv mj b">package.json</code>并在<code class="fe mt mu mv mj b">"scripts"</code>部分添加一个条目:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9c6f" class="mn lc iq mj b gy mo mp l mq mr">"scripts": {<br/>  "typeonly": "typeonly -o dist-rto/ -s src/"<br/>},</span></pre><p id="e57e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以通过我们的脚本执行TypeOnly解析器:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a8b3" class="mn lc iq mj b gy mo mp l mq mr">npm run typeonly</span></pre><p id="392e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该命令在新目录<code class="fe mt mu mv mj b">dist-rto/</code>中创建一个文件<code class="fe mt mu mv mj b">drawing.rto.json</code>。RTO ( <code class="fe mt mu mv mj b">.rto.json</code>)文件包含从<code class="fe mt mu mv mj b">.d.ts </code>打字文件中提取的有用元数据。在接下来的部分中，我们将看到使用这个生成的RTO文件的两种方法。</p><h1 id="61bf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">教程，第二部分:在运行时使用类型化元数据</h1><p id="4624" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了在运行时浏览RTO ( <code class="fe mt mu mv mj b">.rto.json</code>)文件，我们需要<code class="fe mt mu mv mj b">@typeonly/loader</code>包:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a415" class="mn lc iq mj b gy mo mp l mq mr">npm install @typeonly/loader</span></pre><p id="2236" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个包含以下内容的文件<code class="fe mt mu mv mj b">src/main.js</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="52e3" class="mn lc iq mj b gy mo mp l mq mr">// src/main.js<br/>const { loadModules, literals } = require("@typeonly/loader")</span><span id="1b89" class="mn lc iq mj b gy ms mp l mq mr">async function main() {<br/>  const modules = await loadModules({<br/>    modulePaths: ["./drawing"],<br/>    baseDir: `${__dirname}/../dist-rto`<br/>  })</span><span id="2981" class="mn lc iq mj b gy ms mp l mq mr">  const { ColorName } = modules["./drawing"].namedTypes<br/>  console.log("Color names:", literals(ColorName, "string"))<br/>}</span><span id="dd8b" class="mn lc iq mj b gy ms mp l mq mr">main().catch(console.error)</span></pre><p id="74d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在TypeScript源文件中编写这段代码，只需用标准的<code class="fe mt mu mv mj b">import</code>替换<code class="fe mt mu mv mj b">require </code>语法。</p><p id="222b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以执行我们的程序:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c479" class="mn lc iq mj b gy mo mp l mq mr">$ node src/main.js<br/>Color names: [ 'red', 'green', 'blue' ]</span></pre><p id="7399" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，看起来很简单:颜色名称列表现在在运行时可用。</p><p id="8b58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，在运行时，我们的代码不依赖于TypeOnly解析器。我们使用<code class="fe mt mu mv mj b">@typeonly/loader</code>，它是<code class="fe mt mu mv mj b">.rto.json</code>文件的轻量级包装器。</p><h1 id="0685" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">教程，第三部分:如何用TypeOnly验证JSON数据(API版本)</h1><p id="ea59" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">包<code class="fe mt mu mv mj b">@typeonly/validator</code>是使用<code class="fe mt mu mv mj b">@typeonly/loader</code>构建的。我们需要它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7da3" class="mn lc iq mj b gy mo mp l mq mr">npm install @typeonly/validator</span></pre><p id="3708" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个<code class="fe mt mu mv mj b">src/validate-main.js</code>文件，内容如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c968" class="mn lc iq mj b gy mo mp l mq mr">// src/validate-main.js<br/>const { createValidator } = require("@typeonly/validator")</span><span id="bc06" class="mn lc iq mj b gy ms mp l mq mr">const data = {<br/>  "color": "green",<br/>  "shape": {<br/>    "kind": "circle",<br/>    "x": 100,<br/>    "y": 100,<br/>    "radius": 50<br/>  }<br/>}</span><span id="e57d" class="mn lc iq mj b gy ms mp l mq mr">async function main() {<br/>  const validator = await createValidator({<br/>    loadModules: {<br/>      modulePaths: ["./drawing"],<br/>      baseDir: `${__dirname}/../dist-rto`<br/>    }<br/>  })<br/>  const result = validator.validate("./drawing", "Drawing", data)<br/>  console.log(result)<br/>}</span><span id="dd01" class="mn lc iq mj b gy ms mp l mq mr">main().catch(console.error)</span></pre><p id="8e80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行这个新程序:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0955" class="mn lc iq mj b gy mo mp l mq mr">$ node src/validate-main.js<br/>{ valid: true }</span></pre><p id="7a5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前一节所述，我们的代码在运行时不依赖于TypeOnly解析器。验证器使用加载器，它只加载<code class="fe mt mu mv mj b">.rto.json</code>文件。</p><h1 id="aa3a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><h2 id="a7e2" class="mn lc iq bd ld nl nm dn lh nn no dp ll ko np nq lp ks nr ns lt kw nt nu lx nv bi translated">这篇文章没有涉及到什么？</h2><p id="42ac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这里描述的是仅类型语言<a class="ae kc" href="https://github.com/tomko-team/typeonly/blob/master/typeonly-language.md" rel="noopener ugc nofollow" target="_blank">。特别是，它允许导入和导出，这意味着您可以将您的输入拆分到几个源文件中。</a></p><p id="0a96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">包<code class="fe mt mu mv mj b">typeonly</code>、<code class="fe mt mu mv mj b">@typeonly/loader</code>和<code class="fe mt mu mv mj b">@typeonly/validator</code>的API还没有很好的文档化，但是它们类型化得很好。您将需要TypeScript IDE的帮助来查看所有选项和提供的数据结构。</p><h2 id="9e82" class="mn lc iq bd ld nl nm dn lh nn no dp ll ko np nq lp ks nr ns lt kw nt nu lx nv bi translated">下一步是什么？</h2><p id="4886" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">非常感谢贡献者的帮助。对我们来说，TypeOnly只是一个附带项目，我们没有太多的时间。但是，我们计划在不久的将来研究几个主题:</p><ol class=""><li id="ecd6" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nw nd ne nf bi translated">泛型还没有完全实现，我们希望在这方面努力。</li><li id="7d5e" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nw nd ne nf bi translated">我们必须改进解析器，以便检测更棘手的情况，我们目前允许通过，但在TypeScript中无效。</li><li id="85e5" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nw nd ne nf bi translated">验证器可以通过<code class="fe mt mu mv mj b">/** doc comments */</code>中的注释来增强，以改进检查，比如字符串等日期格式。</li><li id="ab37" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nw nd ne nf bi translated">我正在考虑使用TypeOnly和Express来替代Node.js的GraphQL。我不喜欢GraphQL打字和TypeScript打字的糟糕集成，我认为可以做一些更令人愉快的事情。</li></ol></div></div>    
</body>
</html>