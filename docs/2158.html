<html>
<head>
<title>Containerizing a Symfony application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器化Symfony应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/containerizing-a-symfony-application-14d03f9c0b18?source=collection_archive---------0-----------------------#2019-04-09">https://itnext.io/containerizing-a-symfony-application-14d03f9c0b18?source=collection_archive---------0-----------------------#2019-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d8e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我的任务是在Kubernetes上部署和操作Symfony应用程序。由于PHP不再是我的主要工作领域，我希望找到一些关于该主题的最新指南和/或最佳实践，但遗憾的是根本没有，所以我决定写关于应用程序容器化、构建基础设施并将其部署在Kubernetes上的过程。</p><p id="2346" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这是一个相对较大的话题，我决定把它分成几个小帖子。在这一部分中，您可以了解如何将Symfony应用程序容器化。</p><p id="0f2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对最终结果很好奇，可以在<a class="ae kl" href="https://gitlab.com/docker-symfony" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>上找到。</p><h1 id="fe35" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">应用程序堆栈</h1><p id="1858" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这些年来，我成了一个画画的人。不是因为我擅长，而是因为形象化有助于理解问题，让思考过程更容易遵循。</p><p id="a171" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于之前对Symfony的一些了解，第一张图纸可能是这样的:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/64ee559f69f2fc740aa56f5442b86198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WTNiX-1aoIrGzvJU.png"/></div></div></figure><p id="1348" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如图所示，应用程序环境有四个主要组件:</p><ul class=""><li id="6151" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">PHP-运行应用程序的FPM</li><li id="94fa" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">Nginx提供内容并通过FastCGI与FPM通信</li><li id="08db" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">某种背景工作者</li><li id="a36d" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">保存应用程序数据的数据库</li></ul><p id="fc52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在现实生活中，堆栈可以有更多的组件(例如，更多的工人，缓存等)。)，但为了简单起见我们就从这四个开始。</p><p id="7da3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们给图片添加一些容器:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/5ae24159cc52cac7c4de021c745e8a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TJg9Hi9YgAmiO9h8.png"/></div></div></figure><p id="1d0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你在互联网上搜索，你可以找到Symfony的各种容器设置，通常与上面的有很大不同:</p><ul class=""><li id="fca7" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">用modphp代替Nginx和FPM的Apache</li><li id="270b" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">Nginx和FPM在同一个容器中</li><li id="35b4" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">Nginx和FPM和工人在同一个集装箱里(通常与<a class="ae kl" href="http://supervisord.org/" rel="noopener ugc nofollow" target="_blank">主管</a>结合使用)</li></ul><p id="2d66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这些肯定是工作设置，但作为web服务器，我更喜欢Nginx而不是Apache。此外，在容器环境中，有一种常见的(我甚至可以说是最好的)做法是将每个进程放入单独的容器中。遵循这些偏好和指导原则，上面的设置似乎是最佳的。</p><p id="8d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(注意，我们谈论的是<em class="mp">容器</em>，而不是<em class="mp">图像</em>。)</p><p id="c0f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到，我没有将数据库放在容器中。虽然在容器中运行数据库在开发(甚至预览/测试)环境中完全有效，但我更喜欢在生产中使用托管服务。几乎所有的云提供商(甚至Digital Ocean now)都提供托管数据库服务，这最终会比运营自己的数据库集群便宜得多(就直接和间接成本而言)。</p><h1 id="3924" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">应用图像</h1><p id="a68d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们继续创建我们的第一个容器图像。这个映像将用于启动FPM和工作容器，因为它们共享代码库和运行时环境。</p><p id="6bf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(记住:我们正在从<em class="mp">容器</em>切换到<em class="mp">图像</em>。)</p><p id="62a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保最终图像不包含任何不必要的垃圾或构建时间依赖，我们将使用<a class="ae kl" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多级</a> <code class="fe mq mr ms mt b">Dockerfile</code>来创建图像。</p><h1 id="bf15" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">第一阶段:FPM基地形象</h1><p id="4be6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">第一阶段是FPM基础映像，因为这是最不可能改变的，我们希望利用构建缓存。</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="46a6" class="my kn iq mt b gy mz na l nb nc">FROM php:7.3.3-fpm-alpine as base<br/><br/>WORKDIR /var/www<br/><br/># Override Docker configuration: listen on Unix socket instead of TCP<br/>RUN sed -i "s|listen = 9000|listen = /var/run/php/fpm.sock\nlisten.mode = 0666|" /usr/local/etc/php-fpm.d/zz-docker.conf<br/><br/># Install dependencies<br/>RUN set -xe \<br/>    &amp;&amp; apk add --no-cache bash icu-dev \<br/>    &amp;&amp; docker-php-ext-install pdo pdo_mysql intl pcntl<br/><br/>CMD ["php-fpm"]</span></pre><blockquote class="nd ne nf"><p id="8f5a" class="jn jo mp jp b jq jr js jt ju jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj kk ij bi translated">专业提示:对基本图像使用精确版本。升级变成了手动的，但是它保证了你在任何地方都使用相同的版本。</p></blockquote><p id="74ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个阶段相对简单:我们将workdir设置为所需的(web服务器)docroot，安装一些依赖项，并将FPM配置为默认命令。</p><p id="c172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一奇怪的部分是这个配置覆盖使FPM监听Unix套接字。在传统的设置中，Nginx和FPM将使用Unix套接字进行通信，但是在容器设置中，它们位于不同的容器中(记住一个进程，一个容器的规则)，没有共享的文件系统。这就是为什么官方的FPM镜像启用了TCP，这是可以理解的。</p><p id="61ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在两个容器之间共享文件是完全可能的:使用卷。因此，我们不再使用TCP，而是将配置改回Unix套接字，我们将把它安装在Nginx容器中。</p><h1 id="8e74" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">第二阶段:作曲家</h1><p id="9fe0" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">进入下一阶段:使用<a class="ae kl" href="https://getcomposer.org/" rel="noopener ugc nofollow" target="_blank"> Composer </a>安装依赖项。</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="ba08" class="my kn iq mt b gy mz na l nb nc">FROM composer:1.8.4 as composer<br/><br/>RUN rm -rf /var/www &amp;&amp; mkdir /var/www<br/>WORKDIR /var/www<br/><br/>COPY composer.* /var/www/<br/><br/>ARG APP_ENV=prod<br/><br/>RUN set -xe \<br/>    &amp;&amp; if [ "$APP_ENV" = "prod" ]; then export ARGS="--no-dev"; fi \<br/>    &amp;&amp; composer install --prefer-dist --no-scripts --no-progress --no-suggest --no-interaction $ARGS<br/><br/>COPY . /var/www<br/><br/>RUN composer dump-autoload --classmap-authoritative</span></pre><p id="bb68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个阶段有两件事值得一提:</p><ol class=""><li id="1744" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk nj mh mi mj bi translated"><code class="fe mq mr ms mt b">APP_ENV</code> build参数控制是否安装开发依赖项。这在下一阶段会很有用。</li><li id="65ea" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nj mh mi mj bi translated">为了生成用于自动加载的权威类别映射，我们在此阶段将所有内容复制到映像中。</li></ol><blockquote class="nd ne nf"><p id="4a4c" class="jn jo mp jp b jq jr js jt ju jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj kk ij bi translated"><strong class="jp ir"> Pro提示:</strong>在Composer的<a class="ae kl" href="https://getcomposer.org/doc/06-config.md#platform" rel="noopener ugc nofollow" target="_blank">平台</a>配置中将PHP版本锁定为您的生产环境中使用的版本，以确保正确的PHP版本的依赖关系得到解决。</p></blockquote><p id="1f94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了这些，这个舞台和作曲家的安装是非常标准的。</p><h1 id="78af" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">最终阶段:应用程序映像</h1><p id="e2f5" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">构建的最后阶段也很简单。</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="5310" class="my kn iq mt b gy mz na l nb nc">FROM base<br/><br/>ARG APP_ENV=prod<br/>ARG APP_DEBUG=0<br/><br/>ENV APP_ENV $APP_ENV<br/>ENV APP_DEBUG $APP_DEBUG<br/><br/>COPY --from=composer /var/www/ /var/www/<br/><br/># Memory limit increase is required by the dev image<br/>RUN php -d memory_limit=256M bin/console cache:clear<br/>RUN bin/console assets:install</span></pre><p id="6a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以再次看到<code class="fe mq mr ms mt b">APP_ENV</code>建造的论点。在这种情况下，它将是用于构建和运行应用程序的Symfony环境。所有的缓存预热和基本上每个改变容器的进程都必须在这里发生，这样运行的容器每次都可以快速启动并以相同的方式运行。</p><p id="b5e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过更改<code class="fe mq mr ms mt b">APP_ENV</code>变量，我们可以构建单独的开发和生产映像。开发图像在调试的预览环境中很有用。</p><p id="fbbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建映像还需要一个东西(除了应用程序本身):一个<code class="fe mq mr ms mt b">.dockerignore</code>文件。很像<code class="fe mq mr ms mt b">.gitignore</code>，它控制什么应该从图像中去掉。当docker文件中有像<code class="fe mq mr ms mt b">COPY . /whatever</code>这样的语句时，这很有用，在我们的例子中就是这样。</p><p id="97e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在点击<code class="fe mq mr ms mt b">docker build</code>命令之前，将以下内容放在项目根目录下的一个名为<code class="fe mq mr ms mt b">.dockerignore</code>的文件中:</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="51d4" class="my kn iq mt b gy mz na l nb nc">*<br/><br/>!/bin/<br/>!/config/<br/>!/public/<br/>!/src/<br/>!/templates/<br/>!/translations/<br/>!/.env<br/>!/composer.*<br/>!/symfony.lock</span></pre><p id="af14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，它看起来和一个<code class="fe mq mr ms mt b">.gitignore</code>文件非常相似，工作方式也很相似。在我们的例子中，我们从排除图像中的所有内容开始，并为我们需要的文件添加例外。这样，您可以确保只有那些运行应用程序所必需的文件才被复制到最终映像中。</p><p id="8201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您需要其他文件/文件夹来运行应用程序，请确保将它们添加到忽略文件中，否则您可能会看到如下错误:</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="d4d2" class="my kn iq mt b gy mz na l nb nc">Step 22/23 : COPY docker/nginx/default.conf /etc/nginx/conf.d/default.conf<br/>COPY failed: stat /var/lib/docker/tmp/docker-builder152684387/docker/nginx/default.conf: no such file or directory</span></pre><p id="ebf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您现在可以开始构建生产映像了:</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="5d37" class="my kn iq mt b gy mz na l nb nc">docker build -t symfony-app:local .<br/># OR build a development image<br/>docker build -t symfony-app:local-dev --build-arg APP_ENV=dev .</span></pre><h1 id="c659" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Web服务器映像</h1><p id="5381" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">互联网上的大多数指南和帖子会告诉你docker文件应该是自包含的，这意味着你应该能够通过代码和docker文件本身来构建图像。遗憾的是，在我们的例子中，这意味着必须复制应用Dockerfile中的大部分指令，因为从<code class="fe mq mr ms mt b">public/</code>目录提供的资产也必须构建。</p><p id="17a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这样做肯定没有错，但是我将向您展示另一个解决方案，它需要的维护开销要少得多，并且会导致更快的CI构建时间。</p><p id="1edf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到资产构建已经是应用程序映像的一部分。它不是偶然出现的，我们将把资产文件从已经构建的应用程序映像复制到web服务器映像中。以下是方法:</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="5cfe" class="my kn iq mt b gy mz na l nb nc">ARG ASSET_IMAGE<br/><br/>FROM ${ASSET_IMAGE} AS assets<br/><br/><br/>FROM nginx:1.15.9-alpine<br/><br/>COPY docker/nginx/default.conf /etc/nginx/conf.d/default.conf<br/><br/>COPY --from=assets /var/www/public /var/www/public</span></pre><p id="520e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的Dockerfile文件将期望一个名为<code class="fe mq mr ms mt b">ASSET_IMAGE</code>的构建参数，这是我们刚刚构建的应用程序映像的名称。映像将作为构建阶段挂载(因此这也是一个多阶段构建)，最后一个阶段将从第一个阶段复制所需的文件。将以上几行粘贴到Dockerfile文件中(例如<code class="fe mq mr ms mt b">Dockerfile.nginx</code>)。</p><p id="076f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在进行映像构建之前，我们还需要做一件事:配置nginx。以下配置基于<a class="ae kl" href="https://symfony.com/doc/current/setup/web_server_configuration.html#nginx" rel="noopener ugc nofollow" target="_blank"> Symfony文档</a>中的最小示例:</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="8fd9" class="my kn iq mt b gy mz na l nb nc"># Based on https://symfony.com/doc/current/setup/web_server_configuration.html#nginx<br/>server {<br/>    listen 80 default_server;<br/><br/>    server_name localhost;<br/>    root /var/www/public;<br/><br/>    location / {<br/>        # try to serve file directly, fallback to index.php<br/>        try_files $uri /index.php$is_args$args;<br/>    }<br/><br/>    location ~ ^/index\.php(/|$) {<br/>        fastcgi_pass unix:/var/run/php/fpm.sock;<br/>        fastcgi_split_path_info ^(.+\.php)(/.*)$;<br/>        include fastcgi_params;<br/><br/>        # When you are using symlinks to link the document root to the<br/>        # current version of your application, you should pass the real<br/>        # application path instead of the path to the symlink to PHP<br/>        # FPM.<br/>        # Otherwise, PHP's OPcache may not properly detect changes to<br/>        # your PHP files (see https://github.com/zendtech/ZendOptimizerPlus/issues/126<br/>        # for more information).<br/>        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;<br/>        fastcgi_param DOCUMENT_ROOT $realpath_root;<br/>        # Prevents URIs that include the front controller. This will 404:<br/>        # http://domain.tld/index.php/some-path<br/>        # Remove the internal directive to allow URIs like this<br/>        internal;<br/>    }<br/><br/>    # return 404 for all other php files not matching the front controller<br/>    # this prevents access to other php files you don't want to be accessible.<br/>    location ~ \.php$ {<br/>        return 404;<br/>    }<br/><br/>    # Turn off logging for favicons and robots.txt<br/>    location ~ ^/android-chrome-|^/apple-touch-|^/browserconfig.xml$|^/coast-|^/favicon.ico$|^/favicon-|^/firefox_app_|^/manifest.json$|^/manifest.webapp$|^/mstile-|^/open-graph.png$|^/twitter.png$|^/yandex- {<br/>        log_not_found off;<br/>        access_log off;<br/>    }<br/><br/>    location = /robots.txt {<br/>        log_not_found off;<br/>        access_log off;<br/>    }<br/>}</span></pre><p id="e177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在将以上几行粘贴到<code class="fe mq mr ms mt b">docker/nginx/default.conf</code>并将<code class="fe mq mr ms mt b">!/docker/</code>添加到<code class="fe mq mr ms mt b">.dockerignore</code>文件后，您可以继续构建图像:</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="0953" class="my kn iq mt b gy mz na l nb nc">docker build -t symfony-web:local --build-arg ASSET_IMAGE=symfony-app:local -f Dockerfile.nginx .<br/># OR build a development image<br/>docker build -t symfony-web:local-dev --build-arg ASSET_IMAGE=symfony-app:local-dev -f Dockerfile.nginx .</span></pre><h1 id="c962" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">设置Docker撰写</h1><p id="e45e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">是时候测试我们的容器化应用程序了。在这一点上，手动启动容器是很容易的，但是将来我们可能也会使用测试环境，所以使用Docker Compose似乎是一个显而易见的选择。现在，让我们只关注web和应用程序容器:</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="04bc" class="my kn iq mt b gy mz na l nb nc">version: "3.7"<br/><br/>services:<br/>    app:<br/>        image: symfony-app:local<br/>        volumes:<br/>            - phpsocket:/var/run/php<br/><br/>    web:<br/>        image: symfony-web:local<br/>        ports:<br/>            - 8080:80<br/>        volumes:<br/>            - phpsocket:/var/run/php<br/>        depends_on:<br/>            - app<br/><br/>volumes:<br/>    phpsocket:</span></pre><p id="c379" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意卷挂载，它在容器之间共享unix套接字。</p><p id="732c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将上面的代码片段保存为<code class="fe mq mr ms mt b">docker-compose.yml</code>，并执行以下代码:</p><pre class="lq lr ls lt gt mu mt mv mw aw mx bi"><span id="1834" class="my kn iq mt b gy mz na l nb nc">docker-compose up -d</span></pre><p id="04d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切顺利，您应该会看到一个404页面(因为我们在prod env中，我们没有添加任何控制器)。您可以尝试修改合成文件以使用开发图像，Symfony欢迎页面应该会欢迎您。</p><h1 id="1e5b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="ef16" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">容器化Symfony应用程序相对容易，与任何传统设置没有太大区别，但更具可移植性和可伸缩性。所提供的Docker Compose设置已经能够作为开发/测试环境。向它添加额外的组件(数据库、工作程序等)是很简单的。</p><p id="8aad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例应用程序和Docker编写设置都可以在<a class="ae kl" href="https://gitlab.com/docker-symfony" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>上找到。</p><p id="ade7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在接下来的文章中，我将自动构建容器映像，设置一个简单的Kubernetes集群，并配置构建管道来自动部署应用程序。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="7b2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mp">原载于</em><a class="ae kl" href="https://sagikazarmark.hu/blog/containerizing-a-symfony-application/" rel="noopener ugc nofollow" target="_blank"><em class="mp">sagikazarmark . Hu</em></a><em class="mp">。</em></p></div></div>    
</body>
</html>