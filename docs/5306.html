<html>
<head>
<title>Cross-Origin Requests With Dotnet Core Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了使用Dotnet核心的跨来源请求</h1>
<blockquote>原文：<a href="https://itnext.io/cross-origin-requests-with-dotnet-core-explained-e7284e1ec083?source=collection_archive---------0-----------------------#2021-02-06">https://itnext.io/cross-origin-requests-with-dotnet-core-explained-e7284e1ec083?source=collection_archive---------0-----------------------#2021-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d63461b9fdf1a86236f0b8171ff18e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dg-CEFVxCtizENgbVoLbBA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@punttim?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂姆·高</a>在<a class="ae kc" href="https://unsplash.com/s/photos/frustrated?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="8e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跨源请求是HTTP规范的一部分，由于让两个网站相互对话看起来非常复杂，这使得许多开发人员达到了理智的极限。原则上，CORS的存在实际上是为了让这变得更容易:它允许选择退出同源政策。这意味着如果没有CORS，对另一个域进行API调用是绝对不可能的。</p><p id="3650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，显然CORS是来帮忙的，那又怎么样呢？CORS规范允许<strong class="kf ir">服务器</strong>设置报头，该报头指示同源策略的一部分不应被实施。然而，这种实施发生在浏览器中，因此在<strong class="kf ir">客户端</strong>侧。这无疑是CORS最大的困惑来源:许多人要么试图修复JavaScript中的CORS错误(这没什么可说的)，要么试图找出他们后端的哪一部分出现了故障(这并没有导致故障)。在本文中，我将展示CORS是如何工作的，以及您需要做些什么来实现跨域请求。</p><h1 id="fcdd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">预检和HTTP选项</h1><p id="1806" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">CORS请求分为两类:简单请求和非简单请求。对于非简单请求，浏览器将发出预检请求，询问服务器是否允许主请求。对于简单的请求，浏览器只是继续请求，然后拒绝调用。关于什么是简单请求，什么不是的完整定义可以在关于这个主题的优秀的<a class="ae kc" href="https://developer.mozilla.org/nl/docs/Web/HTTP/CORS#simple_requests" rel="noopener ugc nofollow" target="_blank"> MDN页面</a>上找到。</p><p id="bd76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务器通过发送<code class="fe me mf mg mh b">Access-Control-Allow-*</code>头允许来自其他域的访问。最重要的一个是<code class="fe me mf mg mh b">Access-Control-Allow-Origin</code>头，它允许从其他域访问URL，但是还有更多访问控制头。当一个预检发生时，你也会看到<code class="fe me mf mg mh b">Access-Control-Request-*</code>标题，用来告诉服务器一个客户想要哪个访问控制。这些是客户端发送的头，但是你永远不需要自己设置它们，它们也不会授予你实际的访问权限。</p><p id="3541" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下示例显示了Dotnet核心中的一个简单实现。Dotnet有更好的方法来配置CORS，而不是直接在控制器中设置头，但是我想首先向您展示最基本的底层实现，而不涉及很多框架魔法。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">CORS请求的简单工作示例</figcaption></figure><p id="b60d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此示例中，会发生以下情况:</p><ul class=""><li id="39b8" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">浏览器向服务器发出<code class="fe me mf mg mh b">HTTP GET</code>请求。</li><li id="a033" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">服务器发回响应(正常情况下，头后面跟正文)。</li><li id="6aba" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">标题一出现在浏览器中，就会用网站的当前来源验证<code class="fe me mf mg mh b">Access-Control-Allow-Origin</code>标题的值，如果不匹配，就会拒绝响应。</li></ul><p id="df14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个示例显示了一个正在进行飞行前CORS请求。注意这里我们有两个动作:一个用于<code class="fe me mf mg mh b">HTTP OPTIONS</code>起飞前呼叫，一个用于<code class="fe me mf mg mh b">HTTP GET</code>‘正常’呼叫。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">要求使用非标准标题进行飞行前检查的请求示例</figcaption></figure><p id="1b54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，由于自定义标题<code class="fe me mf mg mh b">myheader</code>，浏览器需要发出预检请求，因此还会发生一些事情:</p><ul class=""><li id="b404" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">浏览器向服务器发出<code class="fe me mf mg mh b">HTTP OPTIONS</code>请求，以验证该请求是否被允许。在这个请求中，它将包括两个用于访问控制的报头:<code class="fe me mf mg mh b">Access-Control-Request-Headers: myheader</code>和<code class="fe me mf mg mh b">Access-Control-Request-Method: GET</code>。</li><li id="68ff" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">浏览器用<code class="fe me mf mg mh b">Access-Control-Allow</code>头响应浏览器作为<code class="fe me mf mg mh b">Access-Control-Request</code>头发送的内容:<code class="fe me mf mg mh b">Access-Control-Allow-Headers: myheader</code>和<code class="fe me mf mg mh b">Access-Control-Allow-Origin: http://localhost:8080</code>。我们不必为该方法发送allow头，因为默认情况下已经允许了一个<code class="fe me mf mg mh b">GET</code>。如果授予的访问控制与请求的不匹配，浏览器将拒绝API调用。</li><li id="2131" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">然而，如果它们匹配，浏览器将发出常规的<code class="fe me mf mg mh b">HTTP GET</code>请求。</li><li id="a280" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">标题一出现在浏览器中，就会用网站的当前来源验证<code class="fe me mf mg mh b">Access-Control-Allow-Origin</code>的值，如果不匹配，就会拒绝响应。注意，它只是再次验证原点，而不是任何其他<code class="fe me mf mg mh b">Access-Control-Allow</code>头。</li></ul><h1 id="a20e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">网络核心CORS政策</h1><p id="6465" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如前所述，有更好的方法来管理Dotnet Core中的CORS，而不是到处手动设置标头。如链接文档中所述，有多种方法可以实现CORS。我推荐的方法是使用带有动作属性的命名策略。通过这种方式，您可以将所有配置放在一个地方，但是您仍然有一个可以从其他域访问的终端的显式白名单。它还允许您为不同的域配置不同的配置。在我看来，这是安全性和便利性的最佳结合。</p><div class="nc nd gp gr ne nf"><a href="https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-5.0" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">在ASP.NET核心中启用跨来源请求(CORS)</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">Rick Anderson和Kirk Larkin撰写的这篇文章展示了如何在ASP.NET核心应用中启用CORS。浏览器安全性…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">docs.microsoft.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt jw nf"/></div></div></a></div><p id="5a79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要做的第一件事是在应用程序的<code class="fe me mf mg mh b">Startup</code>中添加一个命名策略。除此之外，我们还需要在<code class="fe me mf mg mh b">app</code>上调用<code class="fe me mf mg mh b">UseCors</code>。策略的名称在常量中定义，因此我们可以在其他地方使用它来引用我们创建的策略:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d881" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用这个策略，我们可以用<code class="fe me mf mg mh b">EnableCors</code>属性来注释一个动作(或者一个控制器)。当使用命名策略时，我们需要向它提供策略的名称，否则它会试图找到一个默认策略(我们没有设置)。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="1d00" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c925" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我希望这篇文章能让你了解CORS是如何工作的，当你看到控制台中出现<code class="fe me mf mg mh b">‘Access to fetch at…’</code>错误时，你应该去哪里找，并向你展示如何在一个. net核心应用程序中正确地配置CORS。</p></div></div>    
</body>
</html>