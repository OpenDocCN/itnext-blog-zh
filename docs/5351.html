<html>
<head>
<title>Another variant to compromise frontend developers by malicious packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过恶意软件包危害前端开发人员的另一个变种</h1>
<blockquote>原文：<a href="https://itnext.io/another-variant-to-compromise-frontend-developers-by-malicious-packages-b724dd4fef9?source=collection_archive---------4-----------------------#2021-02-14">https://itnext.io/another-variant-to-compromise-frontend-developers-by-malicious-packages-b724dd4fef9?source=collection_archive---------4-----------------------#2021-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3512" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几天前我在看Node.js 的<a class="ae kl" href="https://www.youtube.com/watch?v=M3BM9TB-8yA" rel="noopener ugc nofollow" target="_blank"> 10件让我后悔的事情，而对</a><a class="ae kl" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>的介绍就是从这张关于安全性的幻灯片开始的。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/5692887d6264cf1501e2cf5872478be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*B8vp4KvElFbfY9igFv5UFQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae kl" href="https://youtu.be/M3BM9TB-8yA?t=1012" rel="noopener ugc nofollow" target="_blank">https://youtu.be/M3BM9TB-8yA?t=1012</a></figcaption></figure><blockquote class="ky kz la"><p id="e2aa" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated"><em class="iq">默认情况下，脚本应该在没有任何网络或文件系统写权限的情况下运行</em></p></blockquote><p id="01f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是有意义的，特别是对于前端领域，我们大部分时间都在开发要在浏览器中运行的代码，而在浏览器中，您没有文件系统写权限。</p><p id="2d42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我的目标角色将是一名前端开发人员，开发只能在浏览器中运行的代码。值得一提的是，它没有考虑到<a class="ae kl" href="https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation" rel="noopener ugc nofollow" target="_blank"> SSG </a>或<a class="ae kl" href="https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering" rel="noopener ugc nofollow" target="_blank"> SSR </a>，因为他们可以添加更多的变量来考虑(我稍后会对此进行评论)。在执行方面，前端开发者是在操作系统上作为用户执行项目(没有容器或者虚拟机)。</p><p id="8e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发者信任集成到浏览器中的安全机制和边界。让我们以一个包为例，它是一个项目依赖的一部分，受到损害，在新版本中包含恶意代码。开发人员应该担心一个恶意的包试图在他的本地机器上执行代码吗？答案是肯定的。</p><p id="a3ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将回顾到目前为止已知的技术，它们的缓解措施，并介绍另一种变体(我找不到以前的参考资料)来实现用户运行测试套件时的代码执行。这是去年五月向脸书Bug Bounty报告的，但根据他们的说法，这似乎是项目特征的一部分。</p><blockquote class="ky kz la"><p id="44d0" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">他们允许我公开谈论这件事</p></blockquote><h1 id="986f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">面向前端开发人员的威胁分析</h1><p id="5333" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">假设在你的依赖项中有一个恶意的包，并且这个包在你的应用程序中使用。你有多少种方式？</p><ul class=""><li id="207b" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">在通过<a class="ae kl" href="https://www.nerdycode.com/prevent-npm-executing-scripts-security/" rel="noopener ugc nofollow" target="_blank">包脚本</a>安装包时:可以使用<code class="fe mr ms mt mu b">ignore-scripts</code>指令缓解。</li><li id="d244" class="mi mj iq jp b jq mv ju mw jy mx kc my kg mz kk mn mo mp mq bi translated">当您的应用程序在浏览器中运行时，恶意代码就会被执行，并导致客户端代码执行(就像在跨站点脚本中一样)。</li><li id="d53c" class="mi mj iq jp b jq mv ju mw jy mx kc my kg mz kk mn mo mp mq bi translated">执行恶意逻辑，因为它是您使用NodeJS本地调用的脚本的一部分。</li><li id="d12b" class="mi mj iq jp b jq mv ju mw jy mx kc my kg mz kk mn mo mp mq bi translated">在SSG/SSR的例子中，有些代码是要在服务器端运行的，您可能会像后端开发人员一样受到影响:一个恶意的包可以在您的本地机器上远程执行命令。</li></ul><blockquote class="ky kz la"><p id="0155" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">如果你能想到一些新的场景，我很乐意更新这个列表！</p></blockquote><p id="52d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我的经验，目标人物角色可能主要受前两者的影响。第三种情况在简单的设置中并不常见，第四种情况仅适用于SSG/SSR，但本例并非如此。</p><p id="13f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这个目标角色可以设置指令<code class="fe mr ms mt mu b">ignore-scripts</code>，恶意软件包的任何其他影响都是在浏览器级别。够不够？不，因为我想介绍另一个不太为人所知的变种。</p><h1 id="558a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">测试套件中的代码执行</h1><p id="4984" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">现在大多数软件项目都有一个测试套件。当您使用类似<a class="ae kl" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>的实用程序来初始化react应用程序时，它会添加一个测试运行程序(<a class="ae kl" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>)和一个小测试套件。从关于测试的<a class="ae kl" href="https://create-react-app.dev/docs/running-tests/" rel="noopener ugc nofollow" target="_blank">文档中我们可以读到:</a></p><blockquote class="ky kz la"><p id="fb23" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">Jest是一个基于节点的运行器。这意味着测试总是在节点环境中运行，而不是在真实的浏览器中。这让我们能够实现快速的迭代速度，并防止剥落。</p><p id="bcf5" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">由于<a class="ae kl" href="https://github.com/tmpvar/jsdom" rel="noopener ugc nofollow" target="_blank"> jsdom </a>，Jest提供了像<code class="fe mr ms mt mu b">window</code>这样的浏览器全局变量，但它们只是真实浏览器行为的近似值。Jest旨在用于逻辑和组件的单元测试，而不是DOM怪癖。</p></blockquote><p id="79e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">起初有点混乱，因为<em class="lb"> Jest </em>有一个名为<a class="ae kl" href="https://jestjs.io/docs/en/configuration#testenvironment-string" rel="noopener ugc nofollow" target="_blank"> testEnvironment </a>的配置选项，可以设置为<code class="fe mr ms mt mu b">jsdom</code>或<code class="fe mr ms mt mu b">node</code>。由于默认设置为<code class="fe mr ms mt mu b">jsdom</code>，我以为<em class="lb"> Jest </em>使用<a class="ae kl" href="https://github.com/jsdom/jsdom" rel="noopener ugc nofollow" target="_blank"> jsdom </a>在<em class="lb"> jsdom </em>创建的环境中执行测试，但事实并非如此。让我们看看这种行为的安全含义。</p><p id="b385" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<a class="ae kl" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>设置一个React应用程序。步骤很简单:<code class="fe mr ms mt mu b">npx create-react-app my-app &amp;&amp; cd my-app</code>。我们将从一个名为<code class="fe mr ms mt mu b">external-package.js</code>的本地文件中导入一个React组件，我们可以用一个第三方包进行并行处理，因为这个导入以同样的方式工作(所以从现在开始我们将称它为<code class="fe mr ms mt mu b">external-package</code>)。这是<code class="fe mr ms mt mu b">external-package.js</code>的内容:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="973e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个不太有用的组件，它创建了一个以<code class="fe mr ms mt mu b">hello</code>作为文本的段落。我们的<code class="fe mr ms mt mu b">App.js</code>文件将导入这个<code class="fe mr ms mt mu b">external-package</code>组件并在应用程序中使用它(第3行和第10行):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="10d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们运行测试套件，一切都按预期运行(用<code class="fe mr ms mt mu b">CI=true</code>运行它，没有交互运行)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2e2d7422fbf07a80195788dbcb551d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*is1EditpppKt5w7oxfgG4Q.png"/></div></figure><p id="f326" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么现在，如果<code class="fe mr ms mt mu b">external-package</code>妥协了会怎么样？我们的威胁分析告诉我们，它只会影响在浏览器上运行的应用程序，但事实是<em class="lb"> Jest </em>正在使用<code class="fe mr ms mt mu b">node</code>运行代码，这意味着<strong class="jp ir">受损的包</strong>可能包含一些有效的<a class="ae kl" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> NodeJS </em> </a>逻辑，这些逻辑将在测试套件运行时执行。让我们在实践中看到它。</p><p id="e85f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了给出一些真实世界的上下文，想象一下直到现在我们都在使用<code class="fe mr ms mt mu b">external-package-1.0.0</code>。一个攻击者设法破坏了存储库，发布了一个新版本<code class="fe mr ms mt mu b">external-package-1.0.1</code>，在某个时候我们将更新我们的本地包并安装<code class="fe mr ms mt mu b">external-package-1.0.1</code>。新版本包含以下逻辑:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="43e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与版本<code class="fe mr ms mt mu b">1.0.0</code>相比，攻击者增加了第5行到第7行。第<code class="fe mr ms mt mu b">5</code>行检查脚本是否由<code class="fe mr ms mt mu b">node</code>执行，而不是由浏览器执行。这是实现秘密利用的重要检查，否则<code class="fe mr ms mt mu b">yarn start</code>服务会警告我们应用程序中的错误:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/9b7d05cae57d433ccd28ae7a424aa3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1ZJ3vKkUXX9MGxvwsvUNA.png"/></div></div></figure><p id="b04e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<code class="fe mr ms mt mu b">if</code>语句使<code class="fe mr ms mt mu b">yarn start</code>运行良好，因此我们的前端开发人员不会检测到恶意代码。在<code class="fe mr ms mt mu b">6</code>行中，我们调用NodeJS <a class="ae kl" href="https://nodejs.org/api/child_process.html#child_process_child_process_execsync_command_options" rel="noopener ugc nofollow" target="_blank"> execSync </a>函数来执行<code class="fe mr ms mt mu b">id</code>命令，并且我们记录控制台命令的输出。现在，让我们再次运行我们的测试套件:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ni"><img src="../Images/636a09a41e8a23d5232957c92c78d170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6wRg367Yq88wIJ4bslZKQg.png"/></div></div></figure><p id="5d8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<code class="fe mr ms mt mu b">id</code>命令被执行了。显然，我们可以在没有那个<code class="fe mr ms mt mu b">console.log</code>声明的情况下秘密进行，但这只是一个概念证明，以表明利用正在工作。</p><h1 id="70af" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">影响</h1><p id="6da2" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">这种攻击可能在两种情况下发生:</p><ol class=""><li id="1dc6" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk nj mo mp mq bi translated">在本地运行测试套件的前端开发人员可能会导致整个本地帐户受损。</li><li id="a352" class="mi mj iq jp b jq mv ju mw jy mx kc my kg mz kk nj mo mp mq bi translated">运行测试套件并执行恶意代码的持续集成环境。</li></ol><p id="67a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想每个人都明白第一种情况的范围。然而，第二种情况令人担忧:我想参考这篇关于一个名为Webmin的项目中的后门的故事的博客:</p><blockquote class="ky kz la"><p id="c311" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">这个漏洞是由一个不知名的黑客秘密植入的，他成功地在其构建基础设施的某个点注入了一个后门，令人惊讶地持续到Webmin的各个版本(1.882到1.921)，并最终隐藏了一年多。</p><p id="ac51" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated">开发人员证实，官方的Webmin下载只在项目的SourceForge仓库上被后门包取代，而不是在Webmin的Github仓库上。</p></blockquote><p id="bf50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在CI环境中执行的恶意代码可能会引发一系列新案例:</p><ol class=""><li id="cc07" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk nj mo mp mq bi translated">它可以实现对您的CI基础架构的持久访问。</li><li id="ccb4" class="mi mj iq jp b jq mv ju mw jy mx kc my kg mz kk nj mo mp mq bi translated">它可能会在你的版本中插入恶意代码，因此受影响的人数会成倍增加。</li></ol><p id="313a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最糟糕的是，这种攻击不容易被检测到，因为攻击是在CI服务器上进行的，并且在代码库中没有任何踪迹。</p><h1 id="e863" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">缓解措施</h1><p id="234a" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在我看来，我认为应该采取一些缓解措施:</p><ul class=""><li id="8242" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">对于开发，将您的前端应用程序放在一个容器中，并在容器中运行测试套件。</li><li id="3c80" class="mi mj iq jp b jq mv ju mw jy mx kc my kg mz kk mn mo mp mq bi translated">使用一次性容器在您的CI环境中运行您的测试套件，这样任何恶意代码在时间和影响上都将受到限制。禁用网络，以防你不需要它。</li><li id="c482" class="mi mj iq jp b jq mv ju mw jy mx kc my kg mz kk mn mo mp mq bi translated">要捕获一个受损的包:留意测试套件执行的命令、访问的文件和建立的网络连接。</li></ul><p id="3213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个列表并不详尽，但它是改善您的安全状况的一个很好的起点。</p><h1 id="ed12" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">关于安全的思考</h1><p id="0290" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">关于Jest的行为，我认为应该在文档中提及，因为大多数人不会考虑这种风险，然后他们将无法采取正确的措施。</p><p id="3ed6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我的角度来看，<a class="ae kl" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>在使用安全沙箱运行代码(在本例中是测试套件)的事实上是正确的。查看一些在线代码编辑器，他们提到<a class="ae kl" href="https://codesandbox.io/docs/tests" rel="noopener ugc nofollow" target="_blank">他们在浏览器</a>上运行Jest，因此有可能以更安全的方式运行测试套件。</p><p id="c383" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，问题在于有两个上下文，浏览器端和服务器端，每个上下文都应该单独处理，或者至少使用安全原语来确保预期的边界。</p></div></div>    
</body>
</html>