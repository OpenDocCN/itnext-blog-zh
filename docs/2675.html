<html>
<head>
<title>Django Chatbot with Celery, WebSockets, and Redis.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django聊天机器人与芹菜，网络插座，和Redis。</h1>
<blockquote>原文：<a href="https://itnext.io/heroku-chatbot-with-celery-websockets-and-redis-340fcd160f06?source=collection_archive---------2-----------------------#2019-07-09">https://itnext.io/heroku-chatbot-with-celery-websockets-and-redis-340fcd160f06?source=collection_archive---------2-----------------------#2019-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0f29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个聊天机器人，它可以使用Celery异步执行任务，并通过WebSockets进行通信。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/3575021144dffb4ddcd6c18700ddc519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*O3oDCtp5Db-Z6tZqxfGSCw.jpeg"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">詹姆斯·罗亚尔·劳森的聊天机器人</figcaption></figure><h2 id="3b5d" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">TL；博士</h2><p id="ee79" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这里有一个<a class="ae kx" href="https://github.com/slyapustin/django-chatbot" rel="noopener ugc nofollow" target="_blank"> Github repo </a>，点击<code class="fe lw lx ly lz b"><a class="ae kx" href="https://heroku.com/deploy?template=https://github.com/inoks/django-chatbot" rel="noopener ugc nofollow" target="_blank">Deploy to Heroku</a></code>即可。</p><h1 id="96ac" class="ma kz iq bd la mb mc md ld me mf mg lg mh mi mj lj mk ml mm lm mn mo mp lp mq bi translated">姜戈</h1><p id="e59e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们将使用Django作为我们应用程序的基础:</p><ul class=""><li id="aa0c" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">HTTP请求处理程序</li><li id="923b" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">应用程序配置</li><li id="e562" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">模板引擎</li></ul><h1 id="9bb8" class="ma kz iq bd la mb mc md ld me mf mg lg mh mi mj lj mk ml mm lm mn mo mp lp mq bi translated">雷迪斯</h1><p id="12e8" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们需要在几个地方使用Redis:</p><ul class=""><li id="86b5" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">高速缓冲存储</li><li id="e3b1" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">Celery消息代理和结果后端</li><li id="c8de" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">WebSocket通信的通道层</li></ul><p id="5c09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用Heroku进行部署，因此不需要手动安装和配置Redis。Redis DSN将作为环境变量<code class="fe lw lx ly lz b">REDIS_URL</code>可用，因此我们可以在任何需要的地方使用它。</p><h2 id="698f" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">Redis作为高速缓存存储</h2><p id="f791" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Django内部不支持Redis，所以我们需要使用额外的包。我们将使用<code class="fe lw lx ly lz b"><a class="ae kx" href="https://github.com/niwinz/django-redis" rel="noopener ugc nofollow" target="_blank">django-redis</a></code>。这是Django的全功能Redis缓存后端。</p><pre class="km kn ko kp gt nf lz ng nh aw ni bi"><span id="3f79" class="ky kz iq lz b gy nj nk l nl nm">pip install django-redis</span></pre><p id="2d48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将安装更多的依赖项，包括<code class="fe lw lx ly lz b"><a class="ae kx" href="https://github.com/andymccurdy/redis-py" rel="noopener ugc nofollow" target="_blank">redis-p</a>y</code>——Redis的Python接口。</p><p id="590d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只需要用<code class="fe lw lx ly lz b">CACHES</code>设置更新我们的Django项目配置。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="2b0c" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">芹菜与Redis作为消息代理</h2><p id="17cc" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们将有一些任务，这可能需要一段时间。例如，从远程服务器获得响应。因此，我们需要在后台执行这些操作，并在结果可用时将其发送回客户端。</p><p id="670f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">芹菜的配置非常简单，我们将重用芹菜的<code class="fe lw lx ly lz b">REDIS_URL</code><code class="fe lw lx ly lz b">BROKER_URL</code>和<code class="fe lw lx ly lz b">RESULT_BACKEND</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="26c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在<code class="fe lw lx ly lz b">project/celery.py</code>中定义芹菜实例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4d2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要在项目中导入Celery实例，以确保在Django启动时加载应用程序。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="724b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在我们的芹菜准备好了，我们可以向我们的项目添加后台任务。比如这个:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="70c5" class="ma kz iq bd la mb mc md ld me mf mg lg mh mi mj lj mk ml mm lm mn mo mp lp mq bi translated">带有Django通道的WebSockets</h1><p id="90a5" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">当结果可用时，我们希望立即将结果从发送到客户端。而不需要通过预定的AJAX调用每隔几秒查询一次。</p><p id="a7a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">WebSocket 是一种计算机通信协议，通过单一TCP连接提供全双工通信通道。因此，用户可以向后端发送数据，后端也可以向用户发送数据。</p><p id="a85b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://github.com/django/channels" rel="noopener ugc nofollow" target="_blank">如果你需要WebSockets，Django频道</a>是必经之路。现在有两个可用的版本1.x和2.x。它们有重大的变化，如果您有一个相当大的应用程序，从1.x升级到2.x可能是一个大项目。不再支持1.x版本，所以对于新项目，应该使用2.x分支。</p><p id="47dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Django-Channels在官方网站上有非常好的<a class="ae kx" href="https://channels.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>，所以我鼓励你去看看。</p><p id="f2f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关键时刻是——我们需要改变应用程序中的一些东西来支持WebSockets。</p><h2 id="63cf" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">达芙尼</h2><p id="0bff" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">为了使用WebSockets，我们需要一个支持它的web服务器。所以我们需要用Daphne 来代替<a class="ae kx" href="https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/gunicorn/" rel="noopener ugc nofollow" target="_blank"> Gunicorn </a>，我们通常用它来服务Django驱动的网站。</p><p id="c233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Daphne是一个HTTP、HTTP2和WebSocket协议服务器，用于ASGI和ASGI-HTTP。</p><p id="dfcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的应用程序不需要配置任何东西，我们可以像运行WSGI应用程序一样运行它，但是我们需要将它指向ASGI应用程序，而不是WSGI:</p><pre class="km kn ko kp gt nf lz ng nh aw ni bi"><span id="edf5" class="ky kz iq lz b gy nj nk l nl nm">daphne project.asgi:application</span></pre><p id="f40a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ASGI配置看起来和WSGI一样，但是指向Django Channels应用程序:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="6812" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">Django频道和Redis</h2><p id="ab4c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Django通道是某种通信系统，它允许多个消费者实例相互交谈，并与Django的其他部分交谈。</p><p id="e808" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通道层提供了以下抽象:</p><ul class=""><li id="bad5" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">一个<strong class="jp ir">通道</strong>是一个可以接收消息的邮箱。每个频道都有一个名称。任何拥有频道名称的人都可以向该频道发送消息。</li><li id="6bc9" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><strong class="jp ir">组</strong>是一组相关的频道。一个团体有一个名字。任何拥有群组名称的人都可以通过名称向群组添加/移除频道，并向群组中的所有频道发送消息。</li></ul><p id="c9be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个消费者实例都有一个自动生成的唯一通道名，因此可以通过通道层进行通信。</p><p id="47b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们为这个项目定义<code class="fe lw lx ly lz b">CHANNEL_LAYERS</code>。为此，我们将使用<code class="fe lw lx ly lz b"><a class="ae kx" href="https://github.com/django/channels_redis/" rel="noopener ugc nofollow" target="_blank">channels_redis</a></code>。所以我们需要定义后端并提供Redis DSN:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="02a2" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">WebSocket消费者和路由</h2><p id="bf41" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在我们需要定义我们将如何与我们的客户交互——前端JS调用。因此，我们将接收来自客户端的每条消息(以JSON字符串的形式)并对其进行处理。</p><p id="c400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是它可能的样子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="17f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们的应用程序可以有多个消费者(就像我们可能有多个Django视图一样),我们需要类似于Django <code class="fe lw lx ly lz b">urls.py</code>文件的URL路由:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，当客户端向WebSocket <code class="fe lw lx ly lz b">/ws/chat/</code>路径发送消息时，它将由我们的<code class="fe lw lx ly lz b">ChatConsumer</code>处理。</p><p id="c675" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要将我们的应用程序URL包含到主路由器— <code class="fe lw lx ly lz b">project/routing.py</code>:</p><pre class="km kn ko kp gt nf lz ng nh aw ni bi"><span id="a0a6" class="ky kz iq lz b gy nj nk l nl nm"># project/routing.py<br/>from channels.routing import ProtocolTypeRouter, URLRouter<br/>import chat.routing </span><span id="67d8" class="ky kz iq lz b gy np nk l nl nm">application = ProtocolTypeRouter({    <br/>    # (http-&gt;Django views is added by default)    <br/>    'websocket':    <br/>        URLRouter(<br/>            chat.routing.websocket_urlpatterns<br/>        ),<br/>})</span></pre><p id="01c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并从我们的<code class="fe lw lx ly lz b">project/settings.py</code>文件中指向它:</p><pre class="km kn ko kp gt nf lz ng nh aw ni bi"><span id="9a7c" class="ky kz iq lz b gy nj nk l nl nm">ASGI_APPLICATION = "project.routing.application"</span></pre><h1 id="1966" class="ma kz iq bd la mb mc md ld me mf mg lg mh mi mj lj mk ml mm lm mn mo mp lp mq bi translated">部署到Heroku</h1><p id="e8c0" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我将使用Heroku进行部署，因为这是一步完成所有部署的最快方式。而且——这是免费的(尽管他们需要账户验证)。</p><h2 id="e2c1" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">Procfile</h2><p id="0c49" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">该文件包含进程类型定义:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e99b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们定义了在应用程序<code class="fe lw lx ly lz b">release</code>阶段需要做什么，并配置了两个应用程序实例:</p><ul class=""><li id="85f0" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated"><code class="fe lw lx ly lz b">web</code> — Daphne服务器，它将监听<code class="fe lw lx ly lz b">$PORT</code>并处理我们的<code class="fe lw lx ly lz b">https://</code>和<code class="fe lw lx ly lz b">wss://</code>请求。</li><li id="170b" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated"><code class="fe lw lx ly lz b">worker</code> — Celery worker实例处理我们的异步任务队列。</li></ul><h2 id="c583" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">Heroku app.json清单</h2><p id="beff" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这个文件将用于从头开始创建一个新的Heroku网站实例。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><ul class=""><li id="f2be" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">我们需要为我们的应用程序设置环境变量(如Django <code class="fe lw lx ly lz b">SECRET_KEY</code>值)</li><li id="87c2" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">我们需要哪些服务(PostgreSQL、Redis)</li><li id="8642" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">我们想要哪种类型的虚拟机<code class="fe lw lx ly lz b">heroku/python</code>。</li></ul><p id="550b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该文件也可以用来创建一个漂亮的<code class="fe lw lx ly lz b">Deploy to Heroku</code>按钮。所以下次可以一键部署。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><a href="https://heroku.com/deploy?template=https://github.com/inoks/django-chatbot"><div class="gh gi nq"><img src="../Images/9cb85dd7004fa644a18ad0e2a80cfd4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*CYwWx7OT3d1bndflT8Bfsg.png"/></div></a></figure><p id="d55a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个简单的解释，没有涉及太多的细节(将在下一篇文章中介绍)。</p><p id="471f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Github上可用的项目:<a class="ae kx" href="https://github.com/slyapustin/django-chatbot" rel="noopener ugc nofollow" target="_blank">https://github.com/slyapustin/django-chatbot</a></p><p id="f133" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">试玩聊天机器人:<a class="ae kx" href="https://django-chat-bot.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://django-chat-bot.herokuapp.com/</a></p></div></div>    
</body>
</html>