<html>
<head>
<title>Introduction to abortable async functions for React with hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用钩子反应的可移植异步函数介绍</h1>
<blockquote>原文：<a href="https://itnext.io/introduction-to-abortable-async-functions-for-react-with-hooks-768bc72c0a2b?source=collection_archive---------2-----------------------#2018-12-11">https://itnext.io/introduction-to-abortable-async-functions-for-react-with-hooks-768bc72c0a2b?source=collection_archive---------2-----------------------#2018-12-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9735" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">寻求反应钩的可能性。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3916344ee0365b637f145a942318ae47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRSzCUwR3fXyL2Z-A8Xraw.png"/></div></div></figure><blockquote class="la lb lc"><p id="787a" class="jq jr ld js b jt ju jv jw jx jy jz ka le kc kd ke lf kg kh ki lg kk kl km kn im bi translated">有一篇后续文章描述了该库的实现细节。请点击访问<a class="ae lh" href="https://medium.com/p/1f2091b5a1c3" rel="noopener">。</a></p></blockquote><h2 id="9b68" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="56fd" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">只需访问codesandbox中的<a class="ae lh" href="https://codesandbox.io/s/github/dai-shi/react-hooks-async/tree/master/examples/04_typeahead" rel="noopener ugc nofollow" target="_blank">示例</a>并尝试一下。</p><h2 id="59e2" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">背景</h2><p id="41e0" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在JavaScript中你不能取消承诺，这也是像redux-saga和redux-observables这样的库受欢迎的原因之一，因为它们允许取消。虽然它们和Redux一样都是很好的解决方案，但是可能会出现这样的情况:您只想要一个承诺的取消机制，而不是整个框架。如前所述，JavaScript没有取消机制，但是DOM有。它叫做<a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank">人工流产控制器</a>。它仅在最新的浏览器中受支持，但polyfills应该对旧浏览器和Node.js有所帮助。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="7a0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React Hooks API是React 16.7即将推出的新特性。您可以创建一个自定义挂钩来跨组件共享逻辑。钩子只是函数，你可以很容易地组合它们。有许多关于定制钩子的提议，包括处理异步函数。据我所知，还没有关于可移植异步函数的提议。如果我们可以用钩子轻松地使用可移植的异步函数，这对于引入大框架不是一个好的选择的小用例来说将是有用的。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="2523" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们用一个用例来说明如何在钩子中实现它。我们不深入研究库的实现，而是关注它的使用来理解它是如何被接受的。用例是所谓的“提前输入搜索”，你有一个可以输入的文本框，当你输入一个搜索查询时，搜索结果会即时显示出来。在这个用例中有三个困难；a)我们必须处理钩子中的异步副作用，b)我们需要中止先前不再有效的不完整搜索，c)我们希望在开始搜索之前有一个延迟，以减少网络请求的数量。</p><h2 id="7cff" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">处理异步函数的钩子</h2><p id="d885" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">现在，让我们看看处理可移植异步函数的钩子。第一个是创建异步任务的钩子。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="e7f0" class="li lj it mo b gy ms mt l mu mv">const task = useAsyncTask(func, inputs);</span></pre><p id="209f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mw mx my mo b">func</code>是一个带有AbortController参数的函数。该函数返回一个承诺，但该函数负责取消AbortController的承诺。只是这个钩子的一个规则。没有魔法。<code class="fe mw mx my mo b">inputs</code>是一个输入数组，就像<code class="fe mw mx my mo b">useEffect</code>的第二个参数一样。这控制何时创建异步任务。这确实很棘手，但是让我们假设开发人员已经习惯于使用第二个参数<code class="fe mw mx my mo b">useEffect</code>。这个钩子返回的<code class="fe mw mx my mo b">task</code>包含了任务状态的信息，你可以很容易地对它进行析构:<code class="fe mw mx my mo b">const { pending, error, result } = task;</code></p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="2d32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个钩子运行由上面第一个钩子创建的异步任务。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="fad1" class="li lj it mo b gy ms mt l mu mv">useAsyncRun(task);</span></pre><p id="ef34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只会启动一次异步任务。然而，这并不意味着只有一个异步任务会运行。如上所述，我们可以通过<code class="fe mw mx my mo b">inputs</code>控制创建异步任务，因此最终它会运行几个异步任务。<code class="fe mw mx my mo b">useAsyncRun</code>的重要之处在于，如果前一个任务尚未完成，它会自动中止该任务。您可以向<code class="fe mw mx my mo b">useAsyncRun</code>的参数传递一个falsy值，通过它您可以控制何时启动一个异步任务。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="606c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">核心钩子就是上面的两个，但是我们需要另一个钩子用于我们的用例。第三个挂钩是顺序组合几个异步任务。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="b165" class="li lj it mo b gy ms mt l mu mv">const combinedTask = useAsyncCombineSeq(task1, task2);</span></pre><p id="beef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个钩子返回的<code class="fe mw mx my mo b">combinedTask</code>包含了关于组合任务状态的信息，但是对于<code class="fe mw mx my mo b">result</code>，从每个任务中读取它应该更容易并且类型安全。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="fe41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然<code class="fe mw mx my mo b">useAsyncTask</code>足以创建一个异步任务，但是用它需要处理AbortController的规则编写一个<code class="fe mw mx my mo b">func</code>并不容易。因此，我们提供了两个包装<code class="fe mw mx my mo b">useAsyncTask</code>的辅助钩子。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="8cdb" class="li lj it mo b gy ms mt l mu mv">const task1 = useAsyncTaskTimeout(func, delay);<br/>const task2 = useAsyncTaskFetch(url);</span></pre><p id="51a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mw mx my mo b">useAsyncTaskTimeout</code>只是等待一定的时间，然后运行<code class="fe mw mx my mo b">func</code>。</p><p id="c908" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mw mx my mo b">useAsyncTaskFetch</code>是从<code class="fe mw mx my mo b">url</code>获取JSON数据。您还可以使用“POST”方法并通过选项获取非JSON数据。</p><h2 id="0aae" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">用例示例</h2><p id="a639" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">是时候编码并运行用例了。我们使用GitHub知识库搜索。在这个用例示例中，当您键入一个查询字符串时，它将显示搜索结果。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/be5174f9ac3d8e2cb2cbbdf25982e7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9K0f29MQN52qegA4u2R1Hw.gif"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">示例的截屏</figcaption></figure><p id="19fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是实现这个例子的代码。关于TypeScript中的具体代码，请访问codesandbox中的<a class="ae lh" href="https://codesandbox.io/s/github/dai-shi/react-hooks-async/tree/master/examples/04_typeahead" rel="noopener ugc nofollow" target="_blank">示例</a>或GitHub中的<a class="ae lh" href="https://github.com/dai-shi/react-hooks-async" rel="noopener ugc nofollow" target="_blank">库</a>。</p><pre class="kp kq kr ks gt mn mo mp mq aw mr bi"><span id="52bb" class="li lj it mo b gy ms mt l mu mv">const GitHubSearch = ({ query }) =&gt; {<br/>  const url =<br/>    `https://api.github.com/search/repositories?q=${query}`;<br/>  const timeoutTask = useAsyncTaskTimeout(<br/>    useCallback(() =&gt; true, [query]),<br/>    500,<br/>  );<br/>  const fetchTask = useAsyncTaskFetch(url);<br/>  const combinedTask = useAsyncCombineSeq(timeoutTask, fetchTask);<br/>  useAsyncRun(query &amp;&amp; combinedTask);<br/>  if (!query) return null;<br/>  if (timeoutTask.pending) return &lt;div&gt;Waiting...&lt;/div&gt;;<br/>  if (fetchTask.error) return &lt;Err error={fetchTask.error} /&gt;;<br/>  if (fetchTask.pending) return &lt;Loading abort={fetchTask.abort} /&gt;;<br/>  return (<br/>    &lt;ul&gt;<br/>      {fetchTask.result.items.map(({ id, name, html_url }) =&gt; (<br/>        &lt;li key={id}&gt;<br/>          &lt;a target="_blank" href={html_url}&gt;{name}&lt;/a&gt;<br/>        &lt;/li&gt;<br/>      ))}<br/>    &lt;/ul&gt;<br/>  );<br/>};<br/><br/>const App = () =&gt; {<br/>  const [query, setQuery] = useState('');<br/>  return (<br/>    &lt;div&gt;<br/>      Query:<br/>      &lt;input<br/>        value={query}<br/>        onChange={e =&gt; setQuery(e.target.value)}<br/>      /&gt;<br/>      &lt;GitHubSearch query={query} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="a0fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码的一些注释:</p><ol class=""><li id="3b48" class="ne nf it js b jt ju jx jy kb ng kf nh kj ni kn nj nk nl nm bi translated"><code class="fe mw mx my mo b">useAsyncTaskTimeout</code>的第一个论点是最棘手的一个。因为钩子使用输入标识来创建一个异步任务，所以您需要记忆它来控制它。在这种情况下，我们使用<code class="fe mw mx my mo b">useCallback</code>。注意，第一个参数函数的返回值在这里并不重要。</li><li id="1ac5" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated">我们在<code class="fe mw mx my mo b">useAsyncRun</code>的第一个论点中使用<code class="fe mw mx my mo b">query &amp;&amp;</code>。这是为了防止在<code class="fe mw mx my mo b">query === ''</code>时运行异步任务，我们在<code class="fe mw mx my mo b">if (!query) return null;</code>前不渲染任何东西。</li><li id="2754" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated"><code class="fe mw mx my mo b">timeoutTask.pending</code>代表500ms延迟的等待阶段，而<code class="fe mw mx my mo b">fetchTask.pending</code>代表联网阶段。不幸的是，我们无法在网络阶段区分连接阶段和传输阶段。</li><li id="e020" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated">您可以通过按下<code class="fe mw mx my mo b">&lt;Loading abort={fetchTask.abort} /&gt;</code>中的一个按钮来手动中止获取任务，该按钮的代码没有在本文中显示。</li></ol><p id="d1dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在演示中看看它是如何工作的。</p><div class="ns nt gp gr nu nv"><a href="https://codesandbox.io/s/github/dai-shi/react-hooks-async/tree/master/examples/04_typeahead?module=%2Fsrc%2FGitHubSearch.tsx" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">react-hooks-async-example-code sandbox</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">为web应用程序定制的在线代码编辑器</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">codesandbox.io</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ky nv"/></div></div></a></div><h2 id="bcfa" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">图书馆</h2><p id="8508" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">如果你有兴趣，请去图书馆看看。我们仍然不确定这是如何被接受的，并希望听到各种反馈，包括自定义挂钩设计、用例、实现问题等等。请通过Medium responses、Twitter和GitHub问题给我留言。</p><div class="ns nt gp gr nu nv"><a href="https://github.com/dai-shi/react-hooks-async" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">戴式/反应式挂钩异步</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">React Hooks-Dai-Shi/React-Hooks-async的异步函数库</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj ky nv"/></div></div></a></div><h2 id="dfdb" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">最终注释</h2><p id="3262" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在开始开发这个想法之前，我犹豫了一下，因为在React路线图中，我们预计在不久的将来会有悬念和react-cache。总的来说，这将大大改变数据获取。</p><p id="920d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，在写作的时候，悬念和反应缓存还没有出现。不过，胡克也不是。对于某个用例，没有悬念的钩子在数据获取中可能起作用，也可能不起作用。我们会看到的。</p></div></div>    
</body>
</html>