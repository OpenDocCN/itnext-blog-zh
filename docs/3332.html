<html>
<head>
<title>Destructuring Arrays &amp; Objects: JavaScript ES6 Feature Series (Pt 10)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">析构数组和对象:JavaScript ES6特性系列(第10部分)</h1>
<blockquote>原文：<a href="https://itnext.io/destructuring-arrays-objects-javascript-es6-feature-series-pt-10-507108471c07?source=collection_archive---------0-----------------------#2019-11-24">https://itnext.io/destructuring-arrays-objects-javascript-es6-feature-series-pt-10-507108471c07?source=collection_archive---------0-----------------------#2019-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="ab01" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">对于简洁的变量语法，花括号从来没有像现在这样重要</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ca14f27a3ac8a68a2b4941368d2d8581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zqEYDhfbTpl8beM6Oex0JA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">帕特里克·罗伯特·道尔在<a class="ae lb" href="https://unsplash.com/s/photos/learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="ba06" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">介绍</h1><p id="abed" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi mm translated"><span class="l mn mo mp bm mq mr ms mt mu di"> T </span>这些作品的灵感很简单:JavaScript，尤其是一些新的ES6+版本，乍一看可能会让许多开发人员有些困惑。直截了当地说:当另一层旨在使我们的生活更容易的句法糖被添加进来时，他们曾经认为他们理解的东西变成了一个全新的野兽。</p><p id="7b42" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">也就是说，根据维基百科的数据，在今天1000万个最受欢迎的网页中，95%仍然使用JavaScript。</p><p id="1e65" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">JavaScript只会继续在web中扮演越来越重要的角色，我想提供一些我经常使用的ES6+特性的文章和例子，供其他开发人员参考。</p><p id="7467" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">我们的目标是让这些文章简短、深入地解释对该语言的各种改进，我希望它们能启发您使用JS编写一些真正酷的东西。谁知道呢，在这个过程中你可能会学到一些新东西。😄</p><blockquote class="na"><p id="5388" class="nb nc iq bd nd ne nf ng nh ni nj ml dk translated">在本系列的最后一篇文章中，我将讨论数组和对象析构:这是不费吹灰之力将值和属性提取到单个变量中的最简洁的方法。</p></blockquote></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="edb3" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">析构一开始听起来很简单…</h1><p id="9106" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">ES 2015中首次引入的<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构赋值</a>，是我最喜欢的JavaScript标准语法新增内容之一。正如我上面所说的，析构使得将数组中的值或者对象中的属性解包到不同的变量中成为可能。</p><p id="14b2" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">当您第一次听到它时，这可能听起来很简单，但是实际上要将它付诸实施，特别是对于深度嵌套的数组或对象，就有点难掌握了。但是在我进入可能会使你出错的部分之前，让我们先讨论一下在两个数组中析构是什么样子的，以及最近的对象。</p><h1 id="41bf" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">数组析构</h1><p id="cd19" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">在对象析构之前，ECMAScript语言引入并最终确定了数组析构。</p><p id="8ccc" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">正如对象和数组文字表达式提供了一种创建数据包的简单方法，就像这样:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="0e04" class="np jo iq nl b gy nq nr l ns nt">const a = [<!-- -->'alpha', 'beta', 'gamma', 'delta', 'epsilon'<!-- -->];</span></pre><p id="80a5" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">那些相同数组的析构赋值使用相似的语法，但是在赋值的左边定义从源变量中解包什么值。</p><p id="6b63" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">剖析数组析构语法</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="4a63" class="np jo iq nl b gy nq nr l ns nt">let b, c, more;<br/>const a = [<!-- -->'alpha', 'beta', 'gamma', 'delta', 'epsilon'<!-- -->];</span><span id="51e0" class="np jo iq nl b gy nv nr l ns nt">[b, c] = a;</span><span id="0799" class="np jo iq nl b gy nv nr l ns nt">console.log(b); // 'alpha'<br/>console.log(c); // 'beta'</span><span id="3014" class="np jo iq nl b gy nv nr l ns nt">[b, c, ...more] = ['alpha', 'beta', 'gamma', 'delta', 'epsilon'];<br/>console.log(more); // [ 'gamma', 'delta', 'epsilon' ]</span></pre><p id="4621" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">上面的简短例子演示了数组析构和使用rest模式在名为<code class="fe nw nx ny nl b">a</code>的数组上分配额外的值，这是我在这里关于<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/spread-rest-parameters-javascript-es6-feature-series-pt-4-c9e9f0c0228f?source=friends_link&amp;sk=9ff75e9781a0b55ee4572ec02f2f02c1">写的</a>。</p><p id="030e" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">注意，变量<code class="fe nw nx ny nl b">b</code>和<code class="fe nw nx ny nl b">c</code>被括在括号(<code class="fe nw nx ny nl b">[b, c]</code>)中，并被赋值为等于<code class="fe nw nx ny nl b">a</code>数组。<code class="fe nw nx ny nl b">[b, c] = a;</code></p><p id="e37d" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">当这些值被调用时，它们将接受数组中的第一个和第二个元素。<code class="fe nw nx ny nl b">console.log(b); // 'alpha'</code>和<code class="fe nw nx ny nl b">console.log(c); // 'beta';</code></p><p id="963e" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">rest模式带有变量<code class="fe nw nx ny nl b">more</code>。该变量被设计为在将变量添加到数组中时，通过将rest语法(<code class="fe nw nx ny nl b">...more</code>)放在变量名称的前面来继承<code class="fe nw nx ny nl b">a</code>数组中所有剩余的值。然后，当调用<code class="fe nw nx ny nl b">more</code>时，它打印出自己数组中的其余值。<code class="fe nw nx ny nl b">console.log(more); // ['gamma', 'delta', 'epsilon']</code>。</p><p id="0059" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">好了，让我们来看看数组析构的不同用法。</p><h2 id="0e82" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">基本变量赋值</h2><p id="f169" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">最基本的数组析构是取一个数组的值，并将这些值赋给等量的新变量。</p><p id="8752" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">基本数组变量析构赋值示例</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="ae1c" class="np jo iq nl b gy nq nr l ns nt">const govtBranches = [ 'executive', 'judicial', 'legislative' ];</span><span id="3f34" class="np jo iq nl b gy nv nr l ns nt">const [branch1, branch2, branch3] = govtBranches;</span><span id="6e88" class="np jo iq nl b gy nv nr l ns nt">console.log(branch1); // 'executive'<br/>console.log(branch2); // 'judicial'<br/>console.log(branch3); // 'legislative'</span></pre><p id="c3d3" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><code class="fe nw nx ny nl b">govtBranches</code>的三个值中的每一个都有一个对应的变量，该变量包含在数组括号<code class="fe nw nx ny nl b">branch1</code>、<code class="fe nw nx ny nl b">branch2</code>或<code class="fe nw nx ny nl b">branch3</code>中。</p><p id="76bd" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">然后，如果这些变量中的任何一个被调用，它们将反映来自<code class="fe nw nx ny nl b">govtBranches</code>数组的一个单独的值。</p><h2 id="2c89" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">赋值与声明分离</h2><p id="f89c" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">接下来是什么时候可以先声明一个变量(或者使用关键字<code class="fe nw nx ny nl b">let</code>或者<code class="fe nw nx ny nl b">var</code>，而不是<code class="fe nw nx ny nl b">const</code>)，然后通过析构为其赋值。</p><p id="5503" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">变量声明和析构赋值的例子</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="aa9a" class="np jo iq nl b gy nq nr l ns nt">let agency1, agency2;</span><span id="38e3" class="np jo iq nl b gy nv nr l ns nt">[agency1, agency2] = [ 'FBI', 'CIA' ];</span><span id="5686" class="np jo iq nl b gy nv nr l ns nt">console.log(agency1); // 'FBI'<br/>console.log(agency2); // 'CIA'</span></pre><p id="f957" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">如你所见，变量<code class="fe nw nx ny nl b">agency1</code>和<code class="fe nw nx ny nl b">agency2</code>首先被声明为未定义变量。接下来，它们被放在数组括号中，并被赋给包含值<code class="fe nw nx ny nl b">'FBI'</code>和<code class="fe nw nx ny nl b">'CIA'</code>的数组。从那里，每个变量可以被单独调用，它代表数组中的一个值。</p><h2 id="3399" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">默认值</h2><p id="0e02" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">有趣的是，你可以给变量分配一个默认值，类似于<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/default-function-parameter-values-javascript-es6-feature-series-pt-3-bd8392a88a12">默认函数参数值</a>，以防从数组中解包的值是<code class="fe nw nx ny nl b">undefined</code>。</p><p id="9b90" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">当创建的变量比数组中的值多时，就会发生这种情况。</p><p id="9b2a" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">数组析构中的默认值示例</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="b84b" class="np jo iq nl b gy nq nr l ns nt">let one, two;<br/>[one='a', two='b'] = ['c'];</span><span id="1619" class="np jo iq nl b gy nv nr l ns nt">console.log(one); // 'c'<br/>console.log(two); // 'b'</span></pre><p id="0266" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">两个变量<code class="fe nw nx ny nl b">one</code>和<code class="fe nw nx ny nl b">two</code>在被分配给包含单个值<code class="fe nw nx ny nl b">'c'</code>的数组之前被分配默认值<code class="fe nw nx ny nl b">'a'</code>和<code class="fe nw nx ny nl b">'b'</code>。</p><p id="a0d4" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">当变量<code class="fe nw nx ny nl b">one</code>在数组析构发生后被调用时，由于数组中的值，其值被覆盖为<code class="fe nw nx ny nl b">'c'</code>。因为数组不包含第二个值，所以<code class="fe nw nx ny nl b">two</code>的值不会改变，所以那个值，如果存在的话，应该是<code class="fe nw nx ny nl b">undefined</code>。</p><h2 id="c7b9" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">交换变量</h2><p id="1124" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">你知道两个变量值可以在一次析构赋值中交换吗？它们可以，而且很方便的是，你不再需要一个临时变量来实现这一点。</p><p id="5edf" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">使用数组析构交换变量值的示例</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="ce06" class="np jo iq nl b gy nq nr l ns nt">let boots = 'cat';<br/>let rocky = 'dog';</span><span id="18c1" class="np jo iq nl b gy nv nr l ns nt">[boots, rocky] = [rocky, boots];</span><span id="6886" class="np jo iq nl b gy nv nr l ns nt">console.log(boots); // 'dog'<br/>console.log(rocky); // 'cat'</span></pre><p id="8dc1" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">最初，变量<code class="fe nw nx ny nl b">boots</code>是一个<code class="fe nw nx ny nl b">'cat'</code>而变量<code class="fe nw nx ny nl b">rocky</code>是一个<code class="fe nw nx ny nl b">'dog'</code>，但是简单地通过交换数组中它们被赋值的值的顺序，它们的值可以被交换，因此<code class="fe nw nx ny nl b">boots</code>变成了<code class="fe nw nx ny nl b">'dog'</code>而<code class="fe nw nx ny nl b">rocky</code>变成了<code class="fe nw nx ny nl b">'cat'</code>。</p><p id="2b47" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">在某些情况下，这是一个非常有用的技巧。</p><h2 id="cc2c" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">解析从函数返回的数组</h2><p id="b2a7" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">从一个函数中获取一个数组并不是什么新鲜事，但是现在你可以析构被返回的值以使处理它们更加简洁。</p><p id="ce5b" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">解析从函数</em>返回的数组的示例</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="bddf" class="np jo iq nl b gy nq nr l ns nt">function color() {<br/>  return ['red', 'yellow', 'green', 'blue']<br/>}</span><span id="d5b8" class="np jo iq nl b gy nv nr l ns nt">let r, y, g;<br/>[r, y, g] = color();</span><span id="7bdd" class="np jo iq nl b gy nv nr l ns nt">console.log(r); // 'red'<br/>console.log(g); // 'green'</span></pre><p id="8efc" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">函数的作用是:返回一组颜色。通过对函数破坏变量<code class="fe nw nx ny nl b">r</code>、<code class="fe nw nx ny nl b">y</code>、<code class="fe nw nx ny nl b">g</code>，数组中的这些值被分配给这些变量。</p><h2 id="98c3" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">忽略一些返回值</h2><p id="404e" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">同样地，解构可以让您忽略您不感兴趣的某些阵列值。</p><p id="0649" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">忽略具有破坏的数组中的值的示例</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="e3d2" class="np jo iq nl b gy nq nr l ns nt">function ignoreColor() {<br/>  return ['indigo', 'orange', 'lime']<br/>}</span><span id="087d" class="np jo iq nl b gy nv nr l ns nt">const [i, ,l] = ignoreColor();</span><span id="4548" class="np jo iq nl b gy nv nr l ns nt">console.log(i); // 'indigo'<br/>console.log(l); // 'lime'</span></pre><p id="4b6a" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">只需在被破坏的数组中添加一个空白，就可以选择不从函数<code class="fe nw nx ny nl b">ignoreColor()</code>返回值<code class="fe nw nx ny nl b">'orange'</code>。</p><p id="4510" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">如果你愿意，你也可以选择忽略函数中的所有值(尽管我并没有看到太多这样的用例)。</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="915d" class="np jo iq nl b gy nq nr l ns nt">[ , , ] = ignoreColor();</span></pre><h2 id="800c" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">将数组的其余部分分配给变量</h2><p id="4c63" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">我再次回到我在第一个数组销毁示例中展示的内容:使用rest运算符(<code class="fe nw nx ny nl b">...</code>)从数组中拾取任何剩余值。</p><p id="9cbb" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">通过数组破坏为变量分配剩余值的示例</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="64d5" class="np jo iq nl b gy nq nr l ns nt">const [commanderInChief, ...staff] = ['President', 'Vice President', 'Chief of Staff', 'Press Secretary'];</span><span id="4050" class="np jo iq nl b gy nv nr l ns nt">console.log(commanderInChief); // 'President'<br/>console.log(staff); // [ 'Vice President', 'Chief of Staff', 'Press Secretary' ]</span></pre><p id="74b2" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">和前面一样，<code class="fe nw nx ny nl b">commanderInChief</code>获取数组中的第一个值，通过使用rest语法，<code class="fe nw nx ny nl b">...staff</code>将数组中的所有剩余值作为自己的新数组。</p><p id="0f9e" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">就这么简单。现在让我们来看看如何在对象上进行破坏。</p><h1 id="9da4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">对象破坏</h1><p id="ab10" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">对象析构的方法类似于数组析构，只是可以从对象中取出属性(键)及其值，而不是从数组中取出值。</p><p id="a1f6" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">下面是一些例子来说明这种情况。</p><h2 id="9227" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">基本对象破坏分配</h2><p id="a680" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">我再一次从最基本的例子开始，说明对象如何进行破坏。</p><p id="8b14" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">基本对象破坏示例</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="5356" class="np jo iq nl b gy nq nr l ns nt">const pieIngredients = { pumpkin: '1 can', pieCrust: '1 crust', spice: '2 tsp'};</span><span id="10da" class="np jo iq nl b gy nv nr l ns nt">const { pumpkin, pieCrust, spice} = pieIngredients;</span><span id="63e4" class="np jo iq nl b gy nv nr l ns nt">console.log(pumpkin); // '1 can'<br/>console.log(pieCrust); // '1 crust'<br/>console.log(spice); // '2 tsp'</span></pre><p id="ea27" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">通过将属性环绕在对象<code class="fe nw nx ny nl b">pieIngredients</code>中并将其设置为等于对象，每个属性<code class="fe nw nx ny nl b">pumpkin</code>、<code class="fe nw nx ny nl b">pieCrust</code>和<code class="fe nw nx ny nl b">spice</code>都成为其自己的变量，并且附加到它的值成为新变量的值。</p><h2 id="850b" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">无声明转让</h2><p id="857d" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">变量也可以使用与其声明分开的析构来分配其值，就像使用数组析构一样。</p><p id="2fa9" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">单独声明变量后分配变量示例</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="cf03" class="np jo iq nl b gy nq nr l ns nt">let hobby, sports;</span><span id="c620" class="np jo iq nl b gy nv nr l ns nt">({hobby, sports} = {hobby: 'knitting', sports: 'croquet'});</span><span id="1a72" class="np jo iq nl b gy nv nr l ns nt">console.log(hobby); // 'knitting'<br/>console.log(sports); // 'croquet'</span></pre><p id="a64b" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">请注意，当使用不带声明的对象字面析构赋值时，赋值语句周围的括号<code class="fe nw nx ny nl b">( ... )</code>是必需的。</p><p id="8981" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">否则，语法被认为是无效的，因为左边的语法<code class="fe nw nx ny nl b">{hobby, sports}</code>被认为是一个块，而不是一个对象文字。不过，将整行用括号括起来，可以澄清意图并使其有效。</p><h2 id="688a" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">分配给新的变量名</h2><p id="0676" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">有一点很有帮助，那就是可以将一个属性从一个对象中解包并赋给一个与对象属性不同名称的变量。</p><p id="7c6b" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">将析构对象属性重新分配给新变量名的例子</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="74c9" class="np jo iq nl b gy nq nr l ns nt">const car = {speed: 110, color: 'red'};<br/>const { speed: fast, color: cherry } = car;</span><span id="3f2f" class="np jo iq nl b gy nv nr l ns nt">console.log(fast); // 110<br/>console.log(cherry); // 'red'</span></pre><p id="05c8" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">例如，在这里，<code class="fe nw nx ny nl b">const {speed: fast} = car</code>从对象<code class="fe nw nx ny nl b">car </code>获取名为<code class="fe nw nx ny nl b">speed</code>的属性，并将其赋给名为<code class="fe nw nx ny nl b">fast</code>的局部变量。</p><h2 id="0e22" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">默认值</h2><p id="6f5e" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">就像数组析构一样，析构对象的变量可以被赋予一个默认值，在这种情况下，从对象解包的值是<code class="fe nw nx ny nl b">undefined</code>。</p><p id="da5d" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">向对象析构变量分配默认值的示例</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="5cad" class="np jo iq nl b gy nq nr l ns nt">const { redWine = 'cabernet', whiteWine = 'pinot grigio'} = { redWine: 'malbec'};</span><span id="71fa" class="np jo iq nl b gy nv nr l ns nt">console.log(redWine); // 'malbec'<br/>console.log(whiteWine); // 'pinot grigio'</span></pre><p id="090e" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">在本例中，变量<code class="fe nw nx ny nl b">redWine</code>和<code class="fe nw nx ny nl b">whiteWine</code>被赋予默认值<code class="fe nw nx ny nl b">'cabernet'</code>和<code class="fe nw nx ny nl b">'pinot grigio'</code>。然后<code class="fe nw nx ny nl b">redWine</code>变量被重新赋值为<code class="fe nw nx ny nl b">'malbec'</code>的值，但是因为<code class="fe nw nx ny nl b">whiteWine</code>没有在被析构的对象中定义，所以它保留了原来的值。</p><h2 id="6f24" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">从作为函数参数传递的对象中解包字段</h2><p id="3c2b" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">对象析构的另一个特性是，你可以在函数调用的中使用析构语法<em class="nu">来取回那些值。看看这个。</em></p><p id="ba66" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">将析构对象属性作为函数参数传递的示例</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="ecae" class="np jo iq nl b gy nq nr l ns nt">const girl = {<br/>  name: 'Paige',<br/>  age: 30,<br/>  eyeColor: 'blue',<br/>  hair: {<br/>    type: 'curly',<br/>    color: 'red',<br/>    length: 'shoulder-length'<br/>  }<br/>}</span><span id="bf48" class="np jo iq nl b gy nv nr l ns nt">const getUserName = ({name}) =&gt; {<br/>  return {name};<br/>}</span><span id="e91a" class="np jo iq nl b gy nv nr l ns nt">console.log(getUserName(girl)); // { name: 'Paige' }</span><span id="20d7" class="np jo iq nl b gy nv nr l ns nt">const getUserHair = ({hair: {type, color}}) =&gt; {<br/>  return `Her hair is ${color} and ${type}`;<br/>}</span><span id="6769" class="np jo iq nl b gy nv nr l ns nt">console.log(getUserHair(girl)); // Her hair is red and curly</span></pre><p id="f7d3" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">在这里的例子中，对象<code class="fe nw nx ny nl b">girl</code>是一个非常标准的对象。它有两层嵌套属性，但除此之外，它并不起眼。</p><p id="bb99" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">需要注意的是两个功能<code class="fe nw nx ny nl b">getUserName()</code>和<code class="fe nw nx ny nl b">getUserHair()</code>。您将看到传递给它的函数参数实际上是来自它接收的对象的属性<code class="fe nw nx ny nl b">name</code>的析构版本。</p><p id="6fad" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">所以当整个<code class="fe nw nx ny nl b">girl</code>对象被传递给函数时，它只返回<code class="fe nw nx ny nl b">name</code>的属性和值作为函数的输出。</p><p id="eede" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">第二个函数<code class="fe nw nx ny nl b">getUserHair()</code>更加有趣，因为它试图访问的值实际上位于传递给该函数的对象的下两层，所以首先必须访问<code class="fe nw nx ny nl b">hair</code>的属性，然后才能访问<code class="fe nw nx ny nl b">hair</code>特有的属性，即<code class="fe nw nx ny nl b">type</code>和<code class="fe nw nx ny nl b">color</code>。</p><p id="6a4c" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">当用对象<code class="fe nw nx ny nl b">girl</code>调用该函数时，该函数将返回一个字符串，说明对象的头发颜色和头发类型作为输出。</p><p id="1d6f" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">这也是一个如何使用析构访问嵌套对象的例子，我接下来会谈到。</p><h2 id="c144" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">嵌套对象析构</h2><p id="3c7c" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">这是一个让我花了一些时间来理解的话题(老实说，当我想析构多层嵌套对象时，我通常还得回头再看一遍文档。</p><p id="e435" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">基本要点是:如果你的对象在你的对象中不止一层，你必须首先访问它的父属性，它的父属性，等等，直到你到达最外层的对象属性值。</p><p id="5152" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">深度嵌套对象析构的例子</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="793e" class="np jo iq nl b gy nq nr l ns nt">const girl = {<br/>  name: 'Paige',<br/>  age: 30,<br/>  eyeColor: 'blue',<br/>  hobbies: {<br/>    primaries: [<br/>      {<br/>        mostFavorite: [<br/>          'drawing',<br/>          'art'<br/>        ],<br/>        frequentlyDone: 'cooking',<br/>        relaxing: {<br/>          reading: 'fictionBooks'<br/>        }<br/>      }<br/>    ]<br/>  }<br/>}</span><span id="85ad" class="np jo iq nl b gy nv nr l ns nt">const {<br/>  hobbies: {<br/>      primaries: [<br/>      {<br/>        mostFavorite<br/>      }<br/>    ]<br/>  }<br/>} = girl</span><span id="57f0" class="np jo iq nl b gy nv nr l ns nt">console.log(mostFavorite[0]); // 'drawing'<br/>console.log(mostFavorite[1]); // 'art'</span><span id="ca99" class="np jo iq nl b gy nv nr l ns nt">const {<br/>  hobbies: {<br/>    primaries: [<br/>      {<br/>        relaxing: {<br/>          reading<br/>        }<br/>      }<br/>    ]<br/>  }<br/>} = girl</span><span id="b742" class="np jo iq nl b gy nv nr l ns nt">console.log(reading); // // 'fictionBooks'</span></pre><p id="6c42" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">我使用了前一个例子中的相同的<code class="fe nw nx ny nl b">girl</code>对象，但是我将<code class="fe nw nx ny nl b">hobbies</code>的属性添加到了该对象中，并在其中添加了一些新的数组和对象，这样我就可以展示如何从中提取值。</p><p id="4ad6" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">我创建的第一个新对象拉出了<code class="fe nw nx ny nl b">mostFavorite</code>的嵌套对象属性，恰好是一个有两个值的数组。为了达到这些值，首先，我必须将<code class="fe nw nx ny nl b">girl</code>的最外层属性,<code class="fe nw nx ny nl b">hobbies</code>用花括号括起来。接下来，我必须包装<code class="fe nw nx ny nl b">primaries</code>的<code class="fe nw nx ny nl b">hobbies'</code>属性。然后，我必须深入到数组和<code class="fe nw nx ny nl b">primaries</code>包含的对象中，以到达实际保存我所寻找的值的<code class="fe nw nx ny nl b">mostFavorite</code>属性。</p><p id="cc90" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">从这里开始，很容易就可以记录下<code class="fe nw nx ny nl b">mostFavorite</code>的任何值。</p><p id="24f3" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">同样，要获得深埋在<code class="fe nw nx ny nl b">girl</code>对象中的属性<code class="fe nw nx ny nl b">reading</code>的值，我必须再次开始用花括号将<code class="fe nw nx ny nl b">hobbies</code>括起来，然后继续到<code class="fe nw nx ny nl b">primaries</code>，进入数组并找到<code class="fe nw nx ny nl b">relaxing</code>的对象属性，最后将属于<code class="fe nw nx ny nl b">relaxing</code>的父对象的属性<code class="fe nw nx ny nl b">reading</code>括起来。</p><p id="c0b7" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">然后，我可以简单地调用<code class="fe nw nx ny nl b">reading</code>作为它自己的变量，并获取嵌套在<code class="fe nw nx ny nl b">girl</code>对象中的值。</p><p id="3ac0" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">这肯定需要一些练习才能掌握，但是看看获得这些值所需的语法比以前少了多少。</p><p id="cbd6" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">这么长的<code class="fe nw nx ny nl b">const reading = girl.hobbies.primaries[0].relaxing.reading;</code>，我不会错过的。</p><p id="a673" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">如果您想了解更多关于嵌套对象析构的内容，几个月前我专门写了另一篇文章，介绍了在值不可用时避免未定义错误的方法。这是到它的链接。😄</p><h2 id="ff19" class="np jo iq bd jp nz oa dn jt ob oc dp jx lz od oe kb md of og kf mh oh oi kj oj bi translated">对象析构中的Rest语法</h2><p id="d79e" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">最后一个例子，在我写这篇文章的时候，还在ECMAScript第4阶段的提议中，我可能会加上:rest语法加上对象析构。</p><p id="f272" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">我在第一个数组析构演示中展示了这一点，但是我还没有在对象析构中展示过。事实证明，它对对象和数组的作用是一样的。</p><p id="7c00" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">使用rest语法进行对象析构的示例</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="c50e" class="np jo iq nl b gy nq nr l ns nt">let myObjectOfNums = {<br/>  ex: 'ten',<br/>  why: 'twnety',<br/>  zed: 'thirty',<br/>  dee: 'forty',<br/>  ee: 'fifty'<br/>}</span><span id="6695" class="np jo iq nl b gy nv nr l ns nt">let {ex, why, zed, ...allOthers} = myObjectOfNums;</span><span id="6c15" class="np jo iq nl b gy nv nr l ns nt">console.log(ex); // 'ten'<br/>console.log(why); // 'twenty'<br/>console.log(zed); // 'thirty'<br/>console.log(allOthers); // { dee: 'forty', ee: 'fifty' }</span></pre><p id="f2e4" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">看看从对象<code class="fe nw nx ny nl b">myObjectOfNums</code>中提取前三个属性及其值，以及使用rest参数将其他属性保存在一个名为<code class="fe nw nx ny nl b">allOthers</code>的新对象中是多么容易？</p><p id="c381" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">其他的析构规则在这里仍然适用。如果您想将变量名从<code class="fe nw nx ny nl b">ex</code>或<code class="fe nw nx ny nl b">why</code>更改为<code class="fe nw nx ny nl b">a</code>和<code class="fe nw nx ny nl b">b</code>，您可以像之前一样操作。</p><p id="9e0d" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nu">用rest语法析构对象和变量再分配的例子</em></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="465e" class="np jo iq nl b gy nq nr l ns nt">let { ex: a, why: b, zed, ...allOthers } = myObjectOfNums;</span><span id="cb51" class="np jo iq nl b gy nv nr l ns nt">console.log(a); // 'ten'<br/>console.log(b); // 'twenty'<br/>console.log(zed); // 'thirty'<br/>console.log(allOthers); // { dee: 'forty', ee: 'fifty' }</span></pre><p id="9388" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">这也是完全正确的。很酷吧。😃</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="b047" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">结论</h1><p id="d8b4" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">数组和对象析构在Perl和Python等语言中已经存在了很长时间，但直到ECMAScript 2015，JavaScript才开始在这一领域获得一些平等。</p><p id="1dcc" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">这种利用花括号的新语法使得用非常简洁的代码轻松访问数组中的单个变量甚至对象成为可能。我是它的忠实粉丝。</p><p id="a6ef" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">本系列的目标是研究您每天使用但可能不知道所有微妙和细微差别的ES6语法，这样您可以成为更好的web开发人员。</p><p id="0b55" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">过几周再来看看，我会写更多关于JavaScript和ES6或其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="0ccd" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">感谢您的阅读，我希望我已经把数组和对象析构弄得更清楚了，也希望您能在自己的代码库中尝试一下。</p><p id="51ef" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我在这个系列中的其他作品:</p><ul class=""><li id="5a71" class="ok ol iq lq b lr mv lv mw lz om md on mh oo ml op oq or os bi translated"><a class="ae lb" href="https://medium.com/better-programming/object-keys-values-and-entries-javascript-es6-feature-series-part-9-d71268791089" rel="noopener">对象键、值和条目:JavaScript ES6特性系列(Pt 9) </a></li><li id="e38a" class="ok ol iq lq b lr ot lv ou lz ov md ow mh ox ml op oq or os bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/classes-and-inheritance-javascript-es6-feature-series-part-8-4a81fa3adf0f">类和继承:JavaScript ES6特性系列(Pt 8) </a></li><li id="fd5b" class="ok ol iq lq b lr ot lv ou lz ov md ow mh ox ml op oq or os bi translated"><a class="ae lb" href="https://medium.com/better-programming/built-in-module-imports-and-exports-javascript-es6-feature-series-part-7-5f0864049e1f" rel="noopener">内置模块导入导出:JavaScript ES6特性系列(Pt 7) </a></li><li id="1a20" class="ok ol iq lq b lr ot lv ou lz ov md ow mh ox ml op oq or os bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/enhanced-object-literal-value-shorthand-javascript-es6-feature-series-pt-6-e00dfdc24f64">增强的对象文字值速记:JavaScript ES6特性系列(Pt 6) </a></li><li id="ccbf" class="ok ol iq lq b lr ot lv ou lz ov md ow mh ox ml op oq or os bi translated"><a class="ae lb" href="https://medium.com/better-programming/string-template-literals-javascript-es6-feature-series-pt-5-a40e55a5485b" rel="noopener">字符串模板文字:JavaScript ES6特性系列(Pt 5) </a></li><li id="7235" class="ok ol iq lq b lr ot lv ou lz ov md ow mh ox ml op oq or os bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/spread-rest-parameters-javascript-es6-feature-series-pt-4-c9e9f0c0228f"> Spread &amp; Rest参数:JavaScript ES6特性系列(Pt 4) </a></li><li id="d4fe" class="ok ol iq lq b lr ot lv ou lz ov md ow mh ox ml op oq or os bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/default-function-parameter-values-javascript-es6-feature-series-pt-3-bd8392a88a12">默认函数参数值:JavaScript ES6特性系列(Pt 3) </a></li><li id="48dc" class="ok ol iq lq b lr ot lv ou lz ov md ow mh ox ml op oq or os bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/arrow-functions-javascript-es6-feature-series-pt-2-e8c31c823392">箭头功能:JavaScript ES6特性系列(第二部分)</a></li><li id="e865" class="ok ol iq lq b lr ot lv ou lz ov md ow mh ox ml op oq or os bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/var-let-const-javascript-es6-feature-series-pt-1-fa603567809e"> Var，Let &amp; Const: JavaScript ES6特性系列(Pt 1) </a></li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="aaf2" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">参考资料和更多资源</h1><ul class=""><li id="5456" class="ok ol iq lq b lr ls lv lw lz oy md oz mh pa ml op oq or os bi translated">Destructuring assignments，MDN docs:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/destructing _ assignment</a></li></ul></div></div>    
</body>
</html>