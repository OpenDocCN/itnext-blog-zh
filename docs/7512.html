<html>
<head>
<title>When Should You Assign IDs to Your Entities?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么时候应该给实体分配id？</h1>
<blockquote>原文：<a href="https://itnext.io/when-should-you-assign-ids-to-your-entities-ae17454376dd?source=collection_archive---------3-----------------------#2022-10-17">https://itnext.io/when-should-you-assign-ids-to-your-entities-ae17454376dd?source=collection_archive---------3-----------------------#2022-10-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8eb7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">答案是“一旦你的实体被创建”…但是真的那么简单吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/57ddf20395f59d3a2e46584617ab6196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g2fowXKJwWnFpsla"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">布雷特·乔丹在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不久前，我和一位同事讨论我们正在构建的一个应用程序的技术设计。在这种情况下，我们的富客户端生成一段数据，并通过ReST API发布它。这些数据代表一个离散的实体；因此，需要给它分配一个ID。所以问题出现了:实体的ID应该在哪里生成？</p><p id="c1e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们讨论我们的选择时，我的同事评论道，“戴上我的DBA帽子，我认为数据库应该自动生成实体的ID，然后将该ID传递回客户端。”</p><p id="6fec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，这是一种常见的模式。但在这种情况下，跟随它似乎有些令人畏缩。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给实体分配id的想法本身并不总是让我满意。毕竟，我们通常对真实世界的对象进行建模。我们通常不是通过一些ID，而是通过它们过多的特征来识别现实世界的物体。例如，我们认识到我们最喜欢的椅子，不是T4椅，而是蓝色转椅，有带软垫的扶手，中间凹陷，我们可以直接折叠进去。</p><p id="68dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说了这么多，我们的车型简单来说就是:<em class="mc">车型</em>。尽管我们可能会尝试，但我们无法用一个数据模型捕捉真实世界对象的所有细微差别。此外，许多现实世界的物体<em class="mc">都被</em>分配了id。汽车有vin。包裹有追踪号码。就连人都有身份证号。事实上，我的嫂子可以证明，当催收机构不看一个人的SSN，而是看他们的名字是“玛丽·马丁”并住在特定城市的特定公寓时，一个人的信用评分会发生什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d510" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到手头的问题。我们的特定用例有些不典型，但却是一个很好的例子。我们的领域包括<em class="mc">用户</em>、<em class="mc">提示</em>和<em class="mc">故事</em>。用户很简单——他们代表注册使用我们服务的人。<em class="mc">提示</em>是发送给每个用户的预先写好的问题(即每个用户将收到相同的提示)。<em class="mc">故事</em>就是用户登录并阅读提示后产生的东西。</p><p id="913a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以一个典型的交互应该是这样的:</p><ul class=""><li id="7a89" class="md me it lb b lc ld lf lg li mf lm mg lq mh lu mi mj mk ml bi translated">用户登录我们的富应用程序，下载一系列提示。</li><li id="43fe" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">然后，用户为每个提示写下一个故事。</li><li id="7d77" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">这些故事然后被提交给我们的后端API并持久化。</li><li id="794c" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">用户继续与故事进行交互，提供附加信息，该附加信息又被提交并与他们已经保存的故事相关联。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/c64d5a60f6e669498fcb421c3b3d6e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*TWa1psWywHfmMAImYSSd_g.png"/></div></figure><p id="0aed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们的讨论集中在何时以及如何为那些持久存储在后端API上的故事生成id。正如我的同事所调侃的那样，传统上我们会让数据库在保存故事时分配ID——通常通过一个由序列支持的自动递增列。</p><p id="e2cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为什么这是传统的、规范的方法呢？(至少)有两个主要原因:</p><ul class=""><li id="bdf0" class="md me it lb b lc ld lf lg li mf lm mg lq mh lu mi mj mk ml bi translated"><strong class="lb iu">易用性</strong>。大多数关系数据库都有生成和跟踪数字序列的内置机制，这在我们这边几乎不需要做什么工作。</li><li id="dbb4" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated"><strong class="lb iu">集中序列管理</strong>。我们的数据库已经是管理数据的集中位置，因此将它用作管理数字序列的集中位置是有意义的。</li></ul><p id="e083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，问题是，一个故事在被插入数据库之前就已经存在了。具体来说，它在应用程序中创作的那一刻就存在了。这可能看起来是吹毛求疵。但在我们的案例中，故事不仅仅是在应用程序中创建，然后就被遗忘了。相反，故事提交给API后，仍然驻留在应用程序中，用户仍然与它们交互。随着故事更新的提交，我们将一次又一次地需要这些id。</p><p id="53de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们有什么选择呢？当然，我们可以在HTTP响应中返回数据库生成的id，并将每个id附加到应用程序中相应的故事。事实上，ReST模式告诉我们这是首选的方法:向服务器发送一个资源，让服务器生成ID，并在响应中反映新的资源——充满了服务器生成的ID。</p><p id="e2b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了。但是我们如何找到正确的故事来附加新的ID呢？我们<em class="mc">可以</em>在响应中返回完整的故事对象，然后使用用户输入的文本将返回的故事与内存中的故事进行匹配。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/d03195ebe4e922e59e5287a514d983ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*D4sdq0f7G00VuulHwXwoiA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">API服务返回所有新故事的列表，包括它们的新id。由客户机执行字符串匹配来确定哪个内存中的故事被分配了哪个ID。</figcaption></figure><p id="d4e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在理论上可行，但做起来效率不高(而且可能是一种相当脆弱的方法)。</p><p id="a1f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们考虑的另一个选择是依靠订购。我们将最初的故事集合作为有序列表提交，然后以相同的顺序返回结果id。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/d59b19c297c615b1b80d01f3cd587f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*aIOKc11xPTFiRhaAAGBwKg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">API服务将生成的故事id作为有序列表返回。由客户端决定是否遍历该列表及其故事列表，并在每次迭代中将一个ID与一个故事相关联。</figcaption></figure><p id="67b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在理论上也行得通，但似乎有点太脆弱了。如果未来的任何更新以任何方式打破了排序，我们将会把故事与错误的ID关联起来。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，即使在使用传统方法的简单案例中也会出现同样的问题。让我们跳回到几十年前，用简单的形式构建一个简单的网页。该表单将要求用户输入他们的名和姓，以及他们最喜欢的食物的逗号分隔列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/31665d9c1df8bfd0c0443b94c02b29e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*CM1Rc6I_CC1dSA_W6NM6xQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">还记得以前HTML表单是这样的吗？</figcaption></figure><p id="c153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当有人提交表单时，我们将在我们的<code class="fe mv mw mx my b">USER</code>表中创建一条记录，并在我们的<code class="fe mv mw mx my b">FAVORITE_FOOD</code>表中创建<em class="mc"> n </em>条相关记录。我们的伪PHP-ASP-JSP-XYZP代码可能如下所示:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="5d3c" class="nd ne it my b gy nf ng l nh ni">&lt;?<br/>$fname = $form['fname'];<br/>$lname = $form['lname'];<br/>$foods = explode($form['foods'], ',');</span><span id="a565" class="nd ne it my b gy nj ng l nh ni">$db.execute(<br/>  'INSERT INTO USER (FNAME, LNAME) VALUES($fname, $lname)');<br/>// remember, this was a few decades ago<br/>// before we'd learned about SQL injection 😄</span><span id="72f3" class="nd ne it my b gy nj ng l nh ni">$uid = db_get_last_id();<br/>foreach ($f in $foods) {<br/>  $db.execute(<br/>    'INSERT INTO FAVORITE_FOOD (USER_ID, FOOD) VALUES($uid, $f)');<br/>}</span><span id="be3a" class="nd ne it my b gy nj ng l nh ni">?&gt;</span></pre><p id="2da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们使用的数据库和驱动程序，我们可能有类似于<code class="fe mv mw mx my b">db_get_last_id()</code>调用的功能来查找新插入行的ID。但是事情是这样的:<em class="mc">这不是靠魔法</em>起作用的。在幕后，驱动程序正在做一些我们之前描述过的事情；也就是说，它对数据库进行后续查询以找到该ID。虽然在处理单次插入时，这在历史上相当简单，但对于批量插入，这很快就会变得棘手(例如，Google "<em class="mc">SQL how to retrieve id of batch insert</em>")。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d8b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到当前的问题上来。我们认为，最好的解决方案是应用程序本身在故事创建后立即为每个故事生成一个ID。</p><p id="69a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从表面上看，这似乎是一个问题。前面，我们讨论了数据库生成的IDs如何为我们提供了一种维护数字序列的集中机制。如果我们让我们的单个应用程序实例维护它们自己的序列，那么我们就会遇到唯一性的问题。因此，不同的应用程序会很快开始用相互冲突的id发布故事。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/aa563e53b934ca7c7b7645412d535aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*uE6ojxlK_l3DDt8Uy2Nj2A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第一个发布ID为<em class="nl"> 1的故事的客户端将会成功；其余的将失败</em></figcaption></figure><p id="4da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们应该问自己:我们需要用数值作为id吗？例如，我们可以将应用内计数器值与代表应用实例的某个唯一值(例如，设备的MAC地址)结合起来。见鬼，我们甚至可以创建一个API端点，每个应用程序只调用一次，然后返回一个应用程序可以使用的有保证的唯一int。因此我们的id可以采用<code class="fe mv mw mx my b">&lt;app-specific-int&gt;-1</code>、<code class="fe mv mw mx my b">&lt;app-specific-int&gt;-2</code>等形式。</p><p id="92bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，更常见的方法是简单地使用<a class="ae ky" href="https://www.techtarget.com/searchapparchitecture/definition/UUID-Universal-Unique-Identifier" rel="noopener ugc nofollow" target="_blank">uuid</a>。UUIDs是128位标识符(通常表示为32个十六进制数字)，几乎可以在任何计算平台上轻松生成，并且几乎保证是唯一的。一个样本UUID(从<a class="ae ky" href="https://www.uuidgenerator.net/" rel="noopener ugc nofollow" target="_blank">在线UUID生成器</a>获得)是<code class="fe mv mw mx my b">4ea8c548-fb4b-4b55–9ca9–01d3ba9cd3c9</code>。值得注意的是，UUIDs有几种不同的版本；这意味着我们可以生成针对安全性/随机性、索引性能等进行优化的UUIDs。</p><p id="1735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以使用字符串类型来表示我们的实体id。有些人实际上使用UUID数据类型本身，尽管我不喜欢在跨网络边界反序列化这些值时需要考虑的固有错误处理。</p><p id="ea89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一点需要注意。这些实体最终将被存储在底层数据库中。根据所使用的数据库(以及其他因素，比如我们使用的UUID版本)，与使用数值相比，使用uuid或其他类似的字符串/varchar时，我们的数据库索引的性能可能会更差。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="dd87" class="nd ne it bd nm nn no dn np nq nr dp ns li nt nu nv lm nw nx ny lq nz oa ob oc bi translated">我们在修理没坏的东西吗？</h2><p id="eb20" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">有人可能会说，我们让数据库分配id已经很多年了——如果不是几十年的话——这个解决方案基本上是可行的。这是一个有效的观点。但是有时候这种模式会崩溃，让事情变得困难。早些时候，我将我的<em class="mc">故事</em>用例描述为有点不典型，这可能是事实。但是还有无数其他的例子。</p><p id="884f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子。不久前，我的公司已经确定，在我们的用户注册过程中的任何下降都将花费我们大量的金钱。所以我们的任务是让这个过程更有弹性。一个计划是应用<a class="ae ky" href="https://medium.com/geekculture/bulkhead-pattern-microservice-design-pattern-9e30d414a0fd" rel="noopener">隔板模式</a>。这是一种微服务模式，旨在限制给定操作(在我们的例子中是注册过程)中涉及的服务范围。此外，我们希望建立一个“最坏情况”机制，在服务中断期间，我们仍然可以收集一些用户信息，并将准系统用户帐户保存到一个文本文件中，使我们至少能够在以后联系这些用户。</p><p id="e7a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，要做到这一点，我们仍然需要生成唯一的用户id，这就需要调用“UserAccount”微服务(它反过来管理我们用来生成id的数据库)。如果我们允许onboarding web应用程序生成用户id，我们的问题就已经解决了。不幸的是，我们的整个架构假设用户ID是长的而不是字符串，所以我们只能依赖单一的中央数据库来跟踪我们的用户ID索引。</p><p id="d29d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他更阴险的例子出现时，我们的假设，一个单一的集中ID序列被证明是错误的。这种情况通常发生在我们需要合并数据的时候。假设我们收购了另一家公司，需要合并我们的产品或用户数据库。当然，这绝不是一项容易的任务。但是，如果这些数据库中的用户id或产品id是分别由它们自己的数据库管理序列生成的，那就变得更加困难了。</p><p id="2f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您看，当每个数据库中的数据生成时，假设所有的id都由一个序列管理。但是由于这两个数据集现在需要合并，这个假设不再有效。我们现在有一个数据集，它的id是由两个不同的序列生成的。毫无疑问，我们会发现许多相互冲突的id。唯一的解决方案是为其中一个数据集生成新的id，这项任务可能是简单的(例如，如果id完全包含在原始数据库中)，也可能是可怕的(例如，如果id从原始数据库中泄露出去)。</p><p id="6c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果这两个数据库使用UUIDs作为实体id，那么这个问题就可以完全避免。</p><p id="0a6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以原谅将这些例子贴上过于复杂的标签，并认为大多数用例要简单得多。那可能是真的。但是我们应该问自己:即使是最简单的表单处理web应用程序，仅仅为了生成一个ID就需要将一个实体插入到数据库中，这不是很尴尬吗？</p><h2 id="189b" class="nd ne it bd nm nn no dn np nq nr dp ns li nt nu nv lm nw nx ny lq nz oa ob oc bi translated">所以我们应该立即为每一位数据生成一个ID？</h2><p id="0c26" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">所有这些并不是说，我们应该在创建每个离散数据时就为其生成一个UUID。相反，我们应该将我们的实体建模为<a class="ae ky" href="https://betterprogramming.pub/why-your-microservices-architecture-needs-aggregates-342b16dd9b6d" rel="noopener ugc nofollow" target="_blank">集合</a>。这样，我们通常只需要为聚合根生成一个UUID。我们可以让底层存储机制处理关联聚合的值对象的机制。</p><p id="270a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前面的例子为例，假设一个故事由一组段落组成，其中一个段落由一些文本和一些元数据字段组成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f0a48e4507aa8eb437ffb864471da873.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*a-sqCppOBf5xv3pEo41hug.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个故事包含多个段落</figcaption></figure><p id="52b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序不需要为段落创建id。这是因为它不需要从其母故事中单独跟踪单个段落。当用户更新一个现有的故事时，应用程序会将整个故事(包含所有段落)推送到API服务器。将由服务器及其数据存储库来存储故事旁边的段落。</p><p id="0917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，API服务器可能将故事保存在关系数据库中。数据库可能有一个由一个<code class="fe mv mw mx my b">STORY</code>表和一个<code class="fe mv mw mx my b">PARAGRAPH</code>表组成的模式，从后者到前者有一个外键引用。</p><p id="f60f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，API服务器可以将故事保存在文档数据库中(毕竟，“故事”和“文档”在某种程度上是同义词)。在这种情况下，文章将以如下格式存储:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="8d46" class="nd ne it my b gy nf ng l nh ni">{<br/>  "id": "5afc4f69-b67c-40b6-9ec8-fdb7a6eb2be7",<br/>  "name": "My Story",<br/>  "paragraphs": [<br/>    {<br/>      "text": "Four score and seven years ago",<br/>      "metadata1": 0,<br/>      "metadata2": "foo"<br/>    },<br/>    {<br/>      "text": "The quick brown fox jumps over the lazy dog",<br/>      "metadata1": 1,<br/>      "metadata2": "bar"<br/>    }<br/>  ]<br/>}</span></pre><h2 id="0b82" class="nd ne it bd nm nn no dn np nq nr dp ns li nt nu nv lm nw nx ny lq nz oa ob oc bi translated">每个实体多个id？</h2><p id="6214" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">我们可能会问的一个问题是:这会对URL产生什么影响？当构造直接链接到实体的URL时，我们通常包括实体的ID。所以我们会从类似</p><p id="069d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">https://my.domain.com/stories/1234</code></p><p id="fb91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于</p><p id="e74b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">https://my.domain.com/stories/5afc4f69-b67c-40b6–9ec8-fdb7a6eb2be7</code></p><p id="84ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有人可能会说这可能会使URL更麻烦，更不方便用户使用。毕竟，虽然URL主要用于支持超链接，但它们经常被我们的用户阅读和打印出来。从这个角度来看，从用户的角度来看，上面的第二个URL更难处理。</p><p id="8429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，事情是这样的。以前的URL有一些固有的缺点。首先，它暴露了这样一个事实，即我们正在使用(或者很可能使用)一个数据库序列来形成标识符。此外，恶意(或者只是好奇)用户很容易插入其他id来查看发生了什么。</p><p id="ac7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我点击一个带我去<code class="fe mv mw mx my b">https://my.domain.com/stories/1234</code>的链接，那么也许我会试着编辑到<code class="fe mv mw mx my b">https://my.domain.com/stories/1235</code>的URL，看看我是否能访问一些我不应该能访问的东西。毕竟，<code class="fe mv mw mx my b">1235</code>很可能代表一个有效的实体id。(当然，我们应该有适当的授权来防止这种情况发生。但是我们想尽可能地提供多层次的安全保护。)</p><p id="6bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有时我们希望用户以URL之外的方式与实体id进行交互。例如，财务帐户通常在报表和各种其他文档中列出帐户id。我们的用户可能需要呼叫客户支持，并读出他们呼叫的实体的ID。在这些情况下，生成第二个ID并不罕见，这是专门为人类消费而设计的。这种ID的目标是:</p><ul class=""><li id="2625" class="md me it lb b lc ld lf lg li mf lm mg lq mh lu mi mj mk ml bi translated">提供用户易于阅读的标识符</li><li id="9218" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">采用一种使用户很难看到一个这样的标识符并猜出另一个有效标识符的机制</li></ul><p id="26e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方案可能会使用固定数量的随机生成的字母。确切的数字取决于我们特定实体集的基数。例如，如果我们的用户数量相对较少，每个用户拥有一个帐户，那么我们的id长度可以是四到五个字符。更大的客户群和/或更大的实体集将需要更多的字符，可能是10-12个。</p><p id="b22e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用字母而不是数字，因为这将增加可能的id的范围。例如，允许重复的字母，四个字符的id会给我们456，976个可能的id，而四位数的id只会给我们9999个选项。当然，为了减少我们的成员猜测其他有效id的能力，我们希望确保我们实际上使用了我们可能的id范围中的一小部分。虽然我们可能不打算使用数字，但明智的做法是避免像<code class="fe mv mw mx my b">I</code>或<code class="fe mv mw mx my b">O</code>这样容易与数字混淆的字母(当然，我们可以决定将数字2-9添加到组合中，从而增加我们潜在id的范围)。</p><p id="d966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了生成这样一个ID，我们可能会回到依赖一个专门的中央服务来随机分配唯一的值。然而，这些以用户为中心的ID通常可以在实体生命周期的后期生成，从而减少或消除与中央ID生成服务相关的问题。</p><h2 id="7b3f" class="nd ne it bd nm nn no dn np nq nr dp ns li nt nu nv lm nw nx ny lq nz oa ob oc bi translated">最后一个音符</h2><p id="7cc0" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">完成所有这些之后，您可能会决定，对于您的用例，使用您的数据库来生成id是最好的方法。那很好。只要确保你是故意这样做的，而不仅仅是因为“每个人都是这样做的。”确保你考虑了所有的用例——现在的和未来的——这样你就不会把自己画在一个角落里。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="93b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mc">觉得这个故事有用吗？想多读点？只需</em> <a class="ae ky" href="https://dt-23597.medium.com/subscribe" rel="noopener"> <em class="mc">订阅此处</em> </a> <em class="mc">即可将我的最新故事直接发送到您的收件箱。</em></p><p id="ec9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mc">你也可以通过</em> <a class="ae ky" href="https://dt-23597.medium.com/membership" rel="noopener"> <em class="mc">成为今天的</em> </a> <em class="mc">灵媒会员来支持我和我的写作，并获得无限量的故事。</em></p></div></div>    
</body>
</html>