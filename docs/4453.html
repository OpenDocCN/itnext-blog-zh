<html>
<head>
<title>Application Configuration Management with Kustomize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kustomize进行应用程序配置管理</h1>
<blockquote>原文：<a href="https://itnext.io/application-configuration-management-with-kustomize-ab4cf430522f?source=collection_archive---------6-----------------------#2020-07-03">https://itnext.io/application-configuration-management-with-kustomize-ab4cf430522f?source=collection_archive---------6-----------------------#2020-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><a href="https://www.giantswarm.io/"><div class="gh gi jn"><img src="../Images/592533fc61bb0c1bc53d12c99b1f384b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*shVqoXGB-_zcFdo6"/></div></a></figure><p id="9bdb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上一篇文章中，我们探讨了赫尔姆的优点，这一次我们将把注意力转向<a class="ae ks" href="https://kustomize.io/" rel="noopener ugc nofollow" target="_blank">的Kustomize </a>。</p><p id="20dd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们揭开Kustomize的盖子，看看它能为我们做什么之前，让我们花点时间看看它是从哪里来的。Kustomize是谷歌在2018年年中<a class="ae ks" href="https://kubernetes.io/blog/2018/05/29/introducing-kustomize-template-free-configuration-customization-for-kubernetes/" rel="noopener ugc nofollow" target="_blank">宣布</a>的一个开源项目，主要是受到Kubernetes缺乏可信的<a class="ae ks" href="https://docs.google.com/document/d/1cLPGweVEYrVqQvBLJg6sxV-TrE5Rm2MNOBA_cxZP2WU/edit" rel="noopener ugc nofollow" target="_blank">声明式应用管理</a>解决方案的启发。它避开了Helm用来呈现资源的模板方法，而是专注于修补和覆盖现有的配置。</p><h1 id="3289" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">kustomize——基本原理</h1><p id="3ddd" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Kustomize与Helm分享了很多灵感；那就是寻求为应用程序提供配置，但是能够定制配置以适合特定的目的或环境。它旨在为定制应用程序和那些被归类为普通现成(COTS)应用程序的应用程序提供这一功能。</p><p id="09f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它与Helm方法的不同之处在于它坚持使用YAML进行定制定义，而不是一种深奥的模板语言。打赌使用Kubernetes的DevOps人员已经熟悉了它的API资源和用于定义它们的YAML语法。至少在理论上，熟悉有助于无痛苦的采用。</p><p id="5186" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kustomize可以向大量不同的资源(例如，标签或注释)添加一个公共字段，修改现有字段的值(例如，部署副本的数量)，并部分修补作为“基本”配置提供的资源。它甚至可以从规范的源定义中生成ConfigMap和Secret资源配置，稍后将详细介绍。</p><h1 id="a2d1" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Kustomize是如何工作的？</h1><p id="debf" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Kustomize的工作方式是从一组现有定义和kustomize . YAML文件中定义的新配置构建定制的资源定义。</p><p id="5d9a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们解释一下这是如何工作的。</p><h1 id="81ed" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">调用Kustomize</h1><p id="ab37" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">首先，要调用定制配置的构建，有两种方法可用。</p><p id="05bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">1.一个独立的Kustomize二进制文件可以与其“构建”或“创建”子命令一起使用。</p><p id="055b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2.或者，更方便的是，从Kubernetes v1.14开始，Kustomize可以作为Kubernetes本地kubectl CLI的一个组成部分被调用。</p><p id="e9a9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">管理员和CI/CD工具每天都在使用kubectl CLI，因此Kustomize功能可供每个人使用。然而，请注意，在撰写本文时，Kustomize的嵌入式版本远远落后于独立版本。在这个延迟问题解决之前，我们建议使用独立的Kustomize二进制文件，而不是嵌入式版本。</p><p id="c44e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">至少可以说，Kustomize在kubectl中的嵌入是<a class="ae ks" href="https://groups.google.com/d/msg/kubernetes-sig-architecture/lw8AJXGrEW8/Y3BiTYMFFQAJ" rel="noopener ugc nofollow" target="_blank">有争议的</a>。它的行为就像一个插件，但是绕过了kubectl <a class="ae ks" href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/#writing-kubectl-plugins" rel="noopener ugc nofollow" target="_blank">插件机制</a>，这使得它的可用性是可选的。这为Kustomize提供了比Helm或其他竞争配置管理解决方案更低的采用门槛。这些往往需要在使用前<a class="ae ks" href="https://helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank">安装</a>。鉴于Kustomize和Kubernetes源自Google，一些人不难推断Kustomize是社区中最有影响力的人青睐的首选方法。这是真是假现在已经不重要了，因为Kustomize功能是kubectl二进制文件的公认部分。</p><p id="7268" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在处理现有的Kubernetes集群时，要查看kustomize将通过定制资源生成什么，可以使用以下命令，而不是使用Kustomize命令:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="677f" class="mf ku iq mb b gy mg mh l mi mj">$ kubectl kustomize &lt;directory&gt;</span></pre><p id="5153" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该目录包含kustomization.yaml文件和其他资源定义，呈现的内容被发送到STDOUT流。如果我们需要将定制的应用程序资源定义应用到集群，以下命令可以实现这一点:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8875" class="mf ku iq mb b gy mg mh l mi mj">$ kubectl apply -k &lt;directory&gt;</span></pre><p id="b543" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是生成定制资源定义的机制，现在让我们看看定制是如何定义的。</p><h1 id="bf0d" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">定义资源自定义</h1><p id="a5fc" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">作为命令调用的一部分指定的目录必须包含kustomization.yaml文件。这个文件告诉Kustomize如何渲染资源。它将列出将成为定制主题的资源，以及构成定制的任何转换和添加。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a4ed" class="mf ku iq mb b gy mg mh l mi mj">apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization resources: - deployment.yaml - service.yaml namespace: my-app-ns commonLabels: app.kubernetes.io/name: my-app</span></pre><p id="227b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的示例中，部署和服务资源(在其同名文件中定义)将使用“my-app-ns”名称空间定义以及“app.kubernetes.io/name”标签和“my-app”值进行定制。</p><p id="ff63" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，Kustomize允许我们定制基本资源定义，但是我们如何处理多个定制场景而不重复呢？例如，我们如何对开发、试运行和生产环境进行细微的定制？</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7ed0" class="mf ku iq mb b gy mg mh l mi mj">├── base │ ├── deployment.yaml │ ├── kustomization.yaml │ └── service.yaml └── overlays ├── dev │ ├── kustomization.yaml │ └── patch.yaml ├── prod │ ├── kustomization.yaml │ └── patch.yaml └── staging ├── kustomization.yaml └── patch.yaml</span></pre><p id="97f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了实现这一点，Kustomize使用一个“基本”配置，可以使用附加kustomization.yaml文件中的定义对其进行进一步定制。“覆盖/暂存”目录中kustomization.yaml文件的内容如下所示:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d4cd" class="mf ku iq mb b gy mg mh l mi mj">apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization commonLabels: environment: staging bases: - ../../base/ patchesStrategicMerge: - patch.yaml</span></pre><p id="c9a4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它引用“基本”目录中的原始定制，然后根据其内容应用进一步的定制。在这种情况下，它添加了另一个公共标签和一个在' patch.yaml '中定义的配置补丁。</p><p id="c2f8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种定义通用配置和覆盖以支持相似但不同场景的技术非常强大。这与我们使用Helm模板所能达到的效果没有什么不同。但是，它是用纯YAML实现的，不需要定义复杂的参数化模板。此外，按照作者的定义，原始资源文件保持不变。这有助于从依赖的上游应用程序配置定义开始工作。</p><h1 id="b0c1" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">生成配置</h1><p id="cf43" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Kustomize的名字非常适合它的用途，使用覆盖层修补配置正是您所期望的。也许你不会想到Kustomize也有能力从头生成Kubernetes API资源。嗯，可以，但是因为资源有限，而且理由很充分。</p><p id="3078" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kustomize可以从文字定义或规范的源文件(环境或常规)生成配置映射和秘密。通常，配置映射和机密是为工作负载强制创建的(使用“kubectl create”)，因此通过在kustomization.yaml文件中定义它们的生成，Kustomize提供了一种更具声明性的方法。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="6c0e" class="mf ku iq mb b gy mg mh l mi mj">apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization configMapGenerator: - name: my-app-config &gt; files: - config.json &lt;snip&gt;</span></pre><p id="aacc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里,' kustomization.yaml文件根据本地文件' config.json '的内容定义了一个名为' my-app-config '的配置映射。在发出“kubectl apply -k”命令时，将会创建ConfigMap，并且假设它的使用是在Pod模板规范中定义的，则内容随后将可供工作负载使用。</p><p id="f2f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是，如果配置数据或密码更新了，会发生什么呢？我们如何让工作量认识到变化？这是Kubernetes中的一个常见问题，虽然新内容可以通过卷挂载获得，但应用程序可能没有意识到这一点。除非它重新启动。</p><p id="da19" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kustomize试图通过创建带有后缀名称的配置映射和机密来解决这种边缘情况。后缀是对象内容的散列，因此每次内容改变时，替换对象的名称也会改变。如果规范数据源被更改，一个“kubectl apply -k”将生成一个具有不同名称的新配置映射或秘密，并且Pod模板规范也将得到更新以反映新的对象名称。此外，由于相关的控制器协调循环，它还将导致工作负载更新，这将导致创建新的工作负载来访问修改后的内容。</p><p id="d59b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个资源生成特性将Kustomize扩展到了定制资源定义的纯领域之外，并有助于解决一个其他类似解决方案难以解决的问题。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><a href="https://www.giantswarm.io/on-demand-webinar-kubernetes-for-software-architects?utm_campaign=Blog%20CTA%20Conversion&amp;utm_source=Kubernetes%20for%20Software%20Architects_Blog&amp;utm_medium=Blog%20CTA&amp;utm_term=Kubernetes%20for%20Software%20Architects"><div class="gh gi mk"><img src="../Images/06c9a5f8a32b850e1daf3f3f76556446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lMlt5XoEnN5PcE4Pre8HUw.jpeg"/></div></a></figure><h1 id="33fd" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Kustomize和Helm一起</h1><p id="1c88" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Kustomize对于所有者创作的、定制的配置资源非常有用，但是如果您需要使用COTS应用程序，会发生什么情况呢？</p><p id="408c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您不拥有或维护基本资源定义。这些应用程序通常被打包成舵图，而不是库斯托米化配置，并且包含模板定义，而不是纯粹的YAML。</p><p id="6468" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kustomize和Helm能一起工作吗，或者Kustomize能以某种方式消耗Helm图表吗？</p><p id="2019" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简单的回答是肯定的。</p><p id="449b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Helm可以使用“helm template”命令和合适的<a class="ae ks" href="https://helm.sh/docs/chart_template_guide/values_files/" rel="noopener ugc nofollow" target="_blank"> values.yaml </a>文件强制呈现资源定义。呈现的内容可以重定向到本地文件，Kustomize可以将这些文件作为基本资源定义。但是，如果COTS应用程序不断发展，并且这些变化非常重要，不容忽视，会发生什么呢？</p><p id="3789" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kustomize项目鼓励fork/modify/rebase工作流，其中上游配置最初被分叉到Git存储库。分叉的资源使用“helm template”呈现，根据定义的定制进行修改，并使用Kustomize应用。对上游资源的更改可以通过“git rebase”定期同步。</p><h1 id="4988" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="9d94" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在应用程序配置管理方面，Kustomize是Helm的一个非常可靠的替代方案。从它在<a class="ae ks" href="https://github.com/kubernetes-sigs/kustomize" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>上的明星数量、贡献者数量和活跃程度来看，它也非常受欢迎。</p><blockquote class="ml mm mn"><p id="1114" class="ju jv mo jw b jx jy jz ka kb kc kd ke mp kg kh ki mq kk kl km mr ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="iq">但它并没有成为Kubernetes中应用配置管理的新灵丹妙药。也许，它从来没有承诺过。</em> </strong></p></blockquote><p id="654d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然对于定制应用来说，这是一个很好的解决方案，但对于COTS应用来说，它仍然隐含着对更流行的Helm chart解决方案的依赖。像Helm这样打包和分发应用程序的工具的吸引力并不难估计Docker的成功就是这一事实的证明。Kustomize当然可以成为Helm的一个有价值的辅助工具，但它不太可能取代Helm成为管理应用程序配置管理的事实工具。最终，当Helm兑现其用<a class="ae ks" href="https://sweetcode.io/a-first-look-at-the-helm-3-plan/" rel="noopener ugc nofollow" target="_blank"> Lua脚本</a>取代模板的承诺时，它也可能会失去一些流通性。只有时间能证明一切。</p><p id="988b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由<a class="ae ks" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank">Puja Abbas si</a>——开发者倡议@ <a class="ae ks" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型虫群</a>撰写</p></div></div>    
</body>
</html>