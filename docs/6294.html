<html>
<head>
<title>Gopaddle Configurator: A Kubernetes-native Versioning System for Application Configuration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gopaddle Configurator:一个用于应用程序配置的Kubernetes原生版本系统</h1>
<blockquote>原文：<a href="https://itnext.io/gopaddle-configurator-a-kubernetes-native-versioning-system-for-application-configuration-1e5c5481a972?source=collection_archive---------2-----------------------#2021-10-11">https://itnext.io/gopaddle-configurator-a-kubernetes-native-versioning-system-for-application-configuration-1e5c5481a972?source=collection_archive---------2-----------------------#2021-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1f6287a1b0e0a803f674816c990fce9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z7HqXVj5e13wryaoiomeNg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/s/photos/flamingos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@gkumar2175?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">甘帕尼·库马尔</a>拍摄</figcaption></figure><p id="f2c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">火烈鸟是滤食性动物，它们会把头“倒过来”吃东西。到了吃东西的时候，火烈鸟会把头倒扣在水里，喙指向脚。然后，它左右摆动头部，用舌头将水抽进和抽出它的嘴。沿着喙边缘的梳状板为水流出创造了一个过滤器，同时将食物截留在里面。(来源:</em><a class="ae kc" href="https://nationalzoo.si.edu/animals/news/why-are-flamingos-pink-and-other-flamingo-facts" rel="noopener ugc nofollow" target="_blank"><em class="lb"/></a><em class="lb">)</em></p><h1 id="8f81" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">配置映射和机密API资源</h1><p id="94aa" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Kubernetes提供ConfigMap和Secret API资源来帮助将应用程序的配置从应用程序容器中分离出来。将配置与应用分离的能力使得跨不同部署环境和云提供商移植应用变得毫不费力。ConfigMap用于存储非机密数据，而Secret用于存储机密数据，如凭据和令牌。pod可以将配置图和机密作为环境变量、命令行参数或卷中的配置文件来使用。这些资源的使用超出了存储配置数据的范围；例如，可以将外壳脚本存储在配置图中，将其安装在initContainer中并执行该脚本，以便在应用容器启动之前执行应用特定的init动作。</p><h1 id="d74f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">配置映射和机密的版本控制</h1><p id="9dcc" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在应用程序的生命周期中，应用程序的配置数据很容易发生变化，对配置映射和机密的变化进行版本控制是一个很好的实践。版本控制有助于审计，能够顺利回滚到上一个工作版本，并通过允许检查应用程序的先前配置来帮助排除应用程序故障。然而，Kubernetes没有为这些资源的版本控制提供一个树内解决方案。为此，我们必须使用树外解决方案。</p><p id="fc4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何Kubernetes API资源的版本控制系统都可以通过两种不同的方式实现:( I)使用合适的附加组件在Kubernetes集群中创建新的API资源实例;( ii)使用外部版本控制系统，如Git。原则上，前一种方法使用K8s的etcd数据存储来维护版本，而后一种方法只是使用Git进行版本控制。在这篇博文中，我将解释Configurator，一个开源的Kubernetes插件，它有助于版本控制和同步配置图和秘密。</p><h1 id="a900" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">配置器概述</h1><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/98a055d8e3dcdb595960f485b1fa8374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bpI9F5XFkdGEEHun"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">配置器徽标</figcaption></figure><p id="1c9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Configurator使用CRDs允许用户创建<strong class="kf ir"> CustomConfigMaps </strong>和<strong class="kf ir"> CustomSecrets，</strong>，进而创建单独的ConfigMap和Secret资源，并在资源名称<em class="lb">后附加一个<em class="lb">后缀</em>。</em>当在CustomConfigMap或CustomSecret中检测到更改时，Configurator会自动生成一个带有<em class="lb">新后缀</em>的新配置图。这相当于对配置映射和机密的版本控制。</p><p id="fd0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使部署和状态集与最新版本的ConfigMap保持同步，用户必须首先创建一个自定义ConfigMap。这将创建一个带有后缀的新配置映射，即初始版本。然后，用户必须在其部署和Statefulset规范中引用ConfigMap和postfix。从此，用户可以直接更新CustomConfigMap。CustomConfigMap中的任何更改都将自动推广到引用初始ConfigMap版本的所有部署和状态集。</p><h1 id="e661" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用配置器的好处</h1><p id="ff02" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">像Configurator这样的解决方案可以在几个不同的方面发挥作用。我在下面列出了其中的一些:</p><ul class=""><li id="3985" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated"><strong class="kf ir">集群内版本控制系统:</strong>一个简单的集群内版本控制系统，用于配置映射和秘密资源，使用Kubernetes本身来维护版本。这在没有Git存储库或者集群没有足够的计算资源来运行单独的Git服务器(例如，边缘集群)的环境中非常有用</li><li id="127a" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated"><strong class="kf ir">自动版本化:</strong>资源的版本化由配置器自动完成。用户只需更新/编辑原始CustomConfigMap资源。</li><li id="c616" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated"><strong class="kf ir">自动同步服务:</strong> Configurator跟踪不同版本的CustomConfigMap，并自动将更改同步到使用ConfigMap的pod。用户不需要跟踪版本，也不需要手动更新和部署部署/状态集。</li><li id="069d" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated"><strong class="kf ir">不可变的配置映射和秘密:</strong>配置器帮助实现不可变的配置映射和秘密，因为对资源的任何修改都会导致创建资源的新版本，而先前的版本保持不变。</li></ul><h1 id="5a90" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">配置器如何工作</h1><p id="1646" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Kubernetes允许开发者通过定制资源来扩展kubernetes api。配置器定义自定义资源种类<strong class="kf ir"> CustomConfigMap </strong>和<strong class="kf ir"> CustomSecret </strong>。它实现了一个定制控制器(名为配置器控制器)。用户可以使用kubectl命令来创建和删除CustomConfigMap和CustomSecret资源。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/0c9f05d9806f8742c095a9a79e7f2a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oAbGFic2-tG4u4pV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">配置器如何工作</figcaption></figure><p id="2e6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当创建新的CustomConfigMap或修改现有的CustomConfigMap时，配置器控制器使用Informer框架来获得通知。然后，控制器将资源排入工作队列。工作队列由多个工作线程监控(作为Go例程实现)。工作者的角色是监视工作队列并调用同步处理程序来处理作业。</p><p id="fbe2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于给定的CustomConfigMap，使用<em class="lb">标签选择器</em>获取K8s ConfigMap的所有现有版本。当需要创建新版本的配置图时，会创建一个带有标签<code class="fe mz na nb nc b">name:&lt;configmap name&gt;</code>的新配置图资源。使用特殊标签<code class="fe mz na nb nc b">latest:true</code>识别配置图的最新版本。有一个单独的监视程序，监视由配置器管理的新配置图。然后，观察器获取使用先前版本的配置图的所有部署和状态集，然后修改部署/状态集以使用新创建的配置图。此修改触发部署/状态集上的滚动更新，因此新的pod将开始使用新版本的配置图。</p><h1 id="3abf" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">立即试用配置器</h1><p id="2c6b" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在Github repo(<a class="ae kc" href="https://github.com/gopaddle-io/configurator" rel="noopener ugc nofollow" target="_blank">github.com/gopaddle-io/configurator</a>)的部署文件夹下有用于部署最新版本配置器的YAML文件。您需要部署CRDs、控制器和RBAC配置。</p><pre class="mg mh mi mj gt nd nc ne nf aw ng bi"><span id="dcba" class="nh ld iq nc b gy ni nj l nk nl">kubectl apply -f deploy/crd-customConfigMap.yaml<br/>kubectl apply -f deploy/crd-customSecret.yaml<br/>kubectl create ns configurator<br/>kubectl apply -f deploy/configurator-clusterrole.yaml<br/>kubectl apply -f deploy/configurator-clusterrolebinding.yaml<br/>kubectl apply -f deploy/configurator-serviceaccount.yaml<br/>kubectl apply -f deploy/configurator-deployment.yaml</span></pre><p id="d561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证配置器<em class="lb">控制器</em>是否创建成功。</p><pre class="mg mh mi mj gt nd nc ne nf aw ng bi"><span id="365e" class="nh ld iq nc b gy ni nj l nk nl">kubectl get deployment -n configurator<br/>NAME                                 READY   UP-TO-DATE   AVAILABLE   AGE<br/>configurator-controller              1/1     1            1           4h38m</span></pre><p id="c9c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在集群中部署配置器后，开始创建自定义配置映射。样例CustomConfigMaps位于工件/示例文件夹下。创建CustomConfigMap。这将创建一个带有后缀的K8s配置映射。</p><pre class="mg mh mi mj gt nd nc ne nf aw ng bi"><span id="b7ad" class="nh ld iq nc b gy ni nj l nk nl">kubectl apply -f artifacts/exmaples/example-customConfigMap.yaml</span></pre><p id="b46e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一次列出配置图并记下后缀。</p><pre class="mg mh mi mj gt nd nc ne nf aw ng bi"><span id="faf9" class="nh ld iq nc b gy ni nj l nk nl">kubectl get configmap -n test<br/>NAME               DATA   AGE<br/>testconfig-srseq   1      9s</span></pre><p id="c55e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的<code class="fe mz na nb nc b">srseq</code>是后缀。创建引用新创建的ConfigMap的部署。请注意，部署元数据标签必须包含最初创建的配置名称和配置后缀，例如<code class="fe mz na nb nc b">testconfig: srseq</code>。在“VolumeMounts”部分，使用配置图的完整名称，即<code class="fe mz na nb nc b">testconfig-srseq</code></p><pre class="mg mh mi mj gt nd nc ne nf aw ng bi"><span id="3b09" class="nh ld iq nc b gy ni nj l nk nl">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: busybox-deployment<br/>  labels:<br/>   <strong class="nc ir">testconfig: srseq</strong><br/>    app: busybox<br/>spec:<br/>  replicas: 1<br/>  revisionHistoryLimit: 1<br/>  strategy:<br/>    type: RollingUpdate<br/>  selector:<br/>    matchLabels:<br/>      app: busybox<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: busybox<br/>    spec:<br/>      containers:<br/>      - name: busybox<br/>        image: busybox<br/>        imagePullPolicy: IfNotPresent<br/>        command: ['sh', '-c', 'echo Container 1 is Running ; sleep 3600']<br/>        volumeMounts:<br/>        - mountPath: /test<br/>          name: test-config<br/>      volumes:<br/>      - name: test-config<br/>        <strong class="nc ir">configMap:<br/>          name: testconfig-srseq</strong></span></pre><p id="f0a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从现在开始，您可以直接更新CustomConfigMap，这将创建一个带有新后缀的配置映射，并将相关部署与新创建的配置映射自动同步。同样的功能也适用于机密。</p><h1 id="07d8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="085f" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在这篇博客中，我解释了在Kubernetes集群中对ConfigMap和Secret资源进行版本控制的重要性，以及实现这种版本控制的两种不同方法。然后我深入研究了Configurator，这是一个开源的插件，用于实现Kubernetes-native集群内解决方案，用于版本化应用程序配置。请务必访问Github(<a class="ae kc" href="https://github.com/gopaddle-io/configurator" rel="noopener ugc nofollow" target="_blank">github.com/gopaddle-io/configurator</a>)中的项目库，并尝试一下。如果你碰巧知道类似的解决方案，请在评论区留言。</p><p id="7b77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">👉<em class="lb">我定期在Kubernetes和云原生技术上发微博。</em> <em class="lb">跟我上</em> <a class="ae kc" href="https://twitter.com/senthilrch" rel="noopener ugc nofollow" target="_blank"> <em class="lb">推特</em> </a> <em class="lb">和</em> <a class="ae kc" href="https://medium.com/@senthilrch" rel="noopener"> <em class="lb">中</em> </a></p><p id="6dea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">👉<em class="lb">查看</em><a class="ae kc" href="https://github.com/senthilrch/kube-fledged" rel="noopener ugc nofollow" target="_blank"><em class="lb">kube-edged</em></a><em class="lb">，这是一个kubernetes操作器，用于直接在集群工作节点上创建和管理容器映像的缓存，因此应用程序pods几乎可以立即启动</em></p></div></div>    
</body>
</html>