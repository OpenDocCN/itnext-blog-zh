<html>
<head>
<title>Refactoring the Simple Blazor MVVM client: Adventures in Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构简单的Blazor MVVM客户端:依赖注入的冒险</h1>
<blockquote>原文：<a href="https://itnext.io/refactoring-the-simple-blazor-mvvm-client-adventures-in-dependency-injection-e9866d194ee9?source=collection_archive---------2-----------------------#2019-04-15">https://itnext.io/refactoring-the-simple-blazor-mvvm-client-adventures-in-dependency-injection-e9866d194ee9?source=collection_archive---------2-----------------------#2019-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8686cfd665f32462b6a7ba17426b12e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-wx9Fsh2nXJ6qAiXqz3KA.png"/></div></div></figure><p id="f925" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文是关于在ASP.Net客户端Blazor中实现模型视图ViewModel的系列文章的第四篇。如果您想从头开始阅读本系列，第一篇文章位于此处:</p><div class="kz la gp gr lb lc"><a rel="noopener  ugc nofollow" target="_blank" href="/a-simple-mvvm-implementation-in-client-side-blazor-8c875c365435"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">客户端Blazor中一个简单的MVVM实现。</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">如前所述，我正致力于将我的生产Silverlight应用程序迁移到一个新的平台上。我的…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">itnext.io</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq jz lc"/></div></div></a></div><p id="6325" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个项目的源代码可以从GitHub获得。本文起点的代码在ArticleThree分支和4.3版本中。本文末尾的代码是ArticleFour分支和4.4版本。</p><div class="kz la gp gr lb lc"><a href="https://github.com/lchendricks/BlazorMVVM" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">lchendrick s/blazormvm</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">一个客户端Blazor MVVM实现。通过在…上创建帐户，为lchendricks/BlazorMVVM的开发做出贡献</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="lr l ln lo lp ll lq jz lc"/></div></div></a></div><p id="a335" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我们将探讨使用内置的几种方法。我们的Blazor客户端中的Net Core DI容器。在前面的文章中，我们已经看到了如何将一个类注册为一个接口，然后通过类的构造函数或者使用@inject将它作为视图中的一个属性注入。今天我们来看两个我们还没有讨论过的场景。第一个场景是将同一个类注册为两个不同的接口。第二个场景是将两个不同的类注册为同一个接口。我们将保持实现非常简单，以防止这篇文章变得太大。之后，我们将讨论一种在Startup.cs中自动注册服务的方法。</p><h1 id="da11" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">新的业务需求</h1><p id="fe16" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">我们假想的雇主进行了成本效益分析，并决定今后只使用国家气象局API。我们需要改变系统，只使用这项服务来提供基本的，增强的和每小时的预测。我们将借此机会重构和改进我们的模型，同时将这种变化落实到位。</p><p id="5e57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们回头看看FetchDataModel.cs，我们有3个公开的方法。这些方法中的每一个都包含一个对外部API的硬编码引用，其中两个返回一个类而不是一个接口。这段代码将很难编写合适的测试，并且在以后的支持过程中可能会变得很痛苦。我们还可以通过不在每次用户在每日和每小时预测之间导航时调用API来提高我们的性能。</p><p id="d7e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们今天的方法是为模型创建两个孩子，一个用于每日预测，一个用于每小时预测，并让依赖注入帮助我们使用它们来满足我们的需求。我们还将添加私有变量来存储检索到的预测，以避免对API的多余调用。</p><h1 id="fdfc" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">第一个子模型</h1><p id="308b" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">在我们添加模型之前，我们将通过声明一个接口来准备我们的代码，在这个接口中，我们当前在整个代码中使用一个类。在共享项目中，进入WeatherDotGovForecast并提取一个接口:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c4a3" class="ne lt it na b gy nf ng l nh ni">public interface IWeatherDotGovForecast<br/>{<br/>   Geometry geometry { get; set; }<br/>   Properties properties { get; set; }<br/>   string type { get; set; }<br/>}</span></pre><p id="84c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将从我们的每日预测开始，因此进入Models文件夹并创建一个新的类DailyForecastModel.cs。我们要做的第一件事是设置新的子模型以通过构造函数注入接收HttpClient并保存对它的引用。接下来，我们将向该类添加一个方法来下拉我们的每日预测:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="cf45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着数据采集的进行，我们将需要返回增强预测和基本预测的方法。增强预测是一种简单的传递方法:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cf43" class="ne lt it na b gy nf ng l nh ni">public async Task&lt;IWeatherDotGovForecast&gt; RetrieveFullForecast()<br/>{<br/>   var forecast = await RetrieveForecast();<br/>   return forecast;<br/>}</span></pre><p id="fd58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本预测需要更多的工作。我们只需要检索信息的子集，我们也只需要每天一次预测。我们将使用一点Linq，仅从预测中提取奇数编号的周期，然后仅从结果集中提取我们要寻找的数据点。我们将创建的方法如下所示:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="02a0" class="ne lt it na b gy nf ng l nh ni">public async Task&lt;IWeatherForecast[]&gt; RetrieveBasicForecast()<br/>{<br/>   var forecast = await RetrieveForecast();<br/>   var basicForecast = (from Period p in forecast.properties.periods<br/>   where p.number % 2 == 0</span><span id="8f7f" class="ne lt it na b gy nl ng l nh ni">   select new WeatherForecast<br/>   {<br/>      Date = p.startTime,<br/>      TemperatureC = (int)((p.temperature - 32) * 5 / 9),<br/>      Summary = p.shortForecast<br/>   }).ToArray();<br/>   return basicForecast;<br/>}</span></pre><p id="6510" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以将这个类注册为一个接口，并让父模型进行两个不同的方法调用来获取它需要的数据(在现实世界的应用程序中我们会这样做)。在今天的练习中，我们将这个类注册为两个不同的接口，并让模型不知道它正在查看同一个类来进行不同的方法调用。在现实世界中，当一个类需要在应用程序的不同部分以不同的方式显示时，而不是在一个类中，更有可能使用这种方法。</p><p id="3774" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的第一个界面将展示我们的完整预测:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0bd7" class="ne lt it na b gy nf ng l nh ni">public interface IFullForecastModel<br/>{<br/>   Task&lt;IWeatherDotGovForecast&gt; RetrieveFullForecast();<br/>}</span></pre><p id="6e57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个界面将显示基本预测:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e4ac" class="ne lt it na b gy nf ng l nh ni">public interface IBasicForecastModel<br/>{<br/>   Task&lt;IWeatherForecast[]&gt; RetrieveBasicForecast();<br/>}</span></pre><p id="ea35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以用这些接口更新我们的类，之后它将看起来像这样:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6f2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">新类完成后，我们可以进入<code class="fe nm nn no na b">Startup.cs</code>中的<code class="fe nm nn no na b">ConfigureServices()</code>，在两个接口下注册新类。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="752b" class="ne lt it na b gy nf ng l nh ni">services.AddTransient&lt;IFullForecastModel, DailyForecastModel&gt;();</span><span id="0141" class="ne lt it na b gy nl ng l nh ni">services.AddTransient&lt;IBasicForecastModel, DailyForecastModel&gt;();</span></pre><h1 id="71ef" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用第一个子模型</h1><p id="5f39" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">现在一切就绪，我们可以开始在父模型中使用我们的新孩子了。进入FetchDataModel.cs并进行以下更改。添加两个新的私有变量来保存对子模型实例的引用</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7e30" class="ne lt it na b gy nf ng l nh ni">private IFullForecastModel _dailyForecast;</span><span id="a9f0" class="ne lt it na b gy nl ng l nh ni">private IBasicForecastModel _basicForecast;</span></pre><p id="f4fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并更新父类的构造函数，通过注入接收这两个实例，并保存对它们的引用。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="017e" class="ne lt it na b gy nf ng l nh ni">public FetchDataModel(HttpClient http, IFullForecastModel dailyForecast, IBasicForecastModel basicForecast)<br/>{<br/>   _http = http;<br/>   _dailyForecast = dailyForecast;<br/>   _basicForecast = basicForecast;<br/>}</span></pre><p id="8e80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们更新ViewModel调用的方法，以使用这些新的引用。当我们这样做时，如果我们还没有这样做，我们将通过只进行API调用来提高性能。首先，我们将更新获得基本预测的方法</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6440" class="ne lt it na b gy nf ng l nh ni">public async Task RetrieveForecastsAsync()<br/>{<br/>   if (_weatherForecasts == null)<br/>   {<br/>      _weatherForecasts = await <br/>         _basicForecast.RetrieveBasicForecast();<br/>   }<br/>}</span></pre><p id="e724" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们将为我们的增强预测做同样的事情。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="912b" class="ne lt it na b gy nf ng l nh ni">public async Task RetrieveRealForecastAsync()<br/>{<br/>   if (_realWeatherForecast == null)<br/>   {<br/>      _realWeatherForecast = await<br/>         _dailyForecast.RetrieveFullForecast();<br/>   }<br/>}</span></pre><p id="c06a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这些更新完成后，我们将有一些类型不匹配的地方，我们需要将类声明改为接口声明。更新后的模型现在看起来像这样:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9a38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成后，我们可以启动应用程序，并看到它仍然像预期的那样工作。我们现在已经通过两个不同的接口将同一个类注入到我们的应用程序中。</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/1cf15008492c2986f241aea8c5f8daf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3mgE8Gee9PoIdn78wqECQ.png"/></div></div></figure><h1 id="1e90" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">第二胎模型</h1><p id="8bab" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">对于每小时预测的模型，我们将返回到我们的模型文件夹，并创建另一个新类<code class="fe nm nn no na b">HourlyForecastModel.cs</code>。这个类将会和我们的第一个子模型有很多相同的内容，除了它将只实现“完整的”接口，并且只有一次方法。这个类一开始会是这样的:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6805" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该类还需要在Startup.cs中注册。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="76d4" class="ne lt it na b gy nf ng l nh ni">services.AddTransient&lt;IFullForecastModel, HourlyForecastModel&gt;();</span></pre><p id="cd30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止，一切都很标准。然而，我们现在已经注册了两个不同的<code class="fe nm nn no na b">IFullForecastModel</code>实现，那么当我们运行我们的应用程序时会发生什么呢？简单的回答是。Net Core的DI容器将返回接口的最后一个注册实例。这意味着我们现在的代码将总是注入<code class="fe nm nn no na b">HourlyForecastModel</code>。这不是我们想要的，那么我们该如何应对呢？我们将让注册服务告诉我们它们可以做什么，这样我们就可以选择我们想要接收的服务。</p><p id="900b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们将制作一个<code class="fe nm nn no na b">enum</code>，它允许我们区分不同的注册服务，并将其作为公共属性公开。将它添加到<code class="fe nm nn no na b">BlazorMVVMSample.Client.Models</code>名称空间中的某个地方。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3b36" class="ne lt it na b gy nf ng l nh ni">public enum supports { daily, hourly}</span></pre><p id="6731" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在向两个子模型添加相同的属性</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0326" class="ne lt it na b gy nf ng l nh ni">public supports Supports { get; private set; }</span></pre><p id="9f35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并拉高到<code class="fe nm nn no na b">IFullForecastModel</code>接口。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f315" class="ne lt it na b gy nf ng l nh ni">supports Supports { get; }</span></pre><p id="35b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">剩下的工作就是在子模型的构造函数中分配所需的支持类型</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0006" class="ne lt it na b gy nf ng l nh ni">Supports = supports.daily;   </span><span id="5e81" class="ne lt it na b gy nl ng l nh ni">        or</span><span id="111f" class="ne lt it na b gy nl ng l nh ni">Supports = supports.hourly;</span></pre><h1 id="8487" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">注入正确的模型</h1><p id="b21e" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">既然我们已经做出了这一更改，我们可以更新父模型来利用这一点并选择正确的模型。首先，我们需要更新我们的构造函数定义，用一个<code class="fe nm nn no na b">IEnumerable&lt;IFullForceastModel&gt;</code>来获取每个注册的实例，而不仅仅是最后一个。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="4105" class="ne lt it na b gy nf ng l nh ni">public FetchDataModel(HttpClient http, IEnumerable&lt;IFullForecastModel&gt; fullForecasts, IBasicForecastModel basicForecast)</span></pre><p id="9581" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们可以访问它们，我们就可以使用Linq在我们的构造函数中指定一个我们想要的类型，如下所示:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0926" class="ne lt it na b gy nf ng l nh ni">_dailyForecast = fullForecasts<br/>     .Where( f =&gt; f.Supports == supports.daily )<br/>     .First();</span></pre><p id="b522" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的前提是，我们正在通过我们的注册服务寻找一个符合我们需求的服务。我们只注册了两个班级，标准非常简单。这可以很容易地应用于一长串服务，并且在搜索合适的服务时有多个匹配的标准。现在，我们已经制定了注射，我们可以利用我们的第二个孩子模型。我们需要在FetchDataModel中声明一个私有变量</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9d0e" class="ne lt it na b gy nf ng l nh ni">private IFullForecastModel _hourlyForecast;</span></pre><p id="d8f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在构造函数中填充它</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d6cb" class="ne lt it na b gy nf ng l nh ni">_hourlyForecast = fullForecasts.Where(f =&gt; f.Supports == supports.hourly).First();</span></pre><p id="ca5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并更新检索每小时预报的方法。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fa55" class="ne lt it na b gy nf ng l nh ni">public async Task RetrieveHourlyForecastAsync()<br/>{<br/>   if (_hourlyWeatherForecast == null)<br/>   {<br/>      _hourlyWeatherForecast = await     <br/>      _hourlyForecast.RetrieveFullForecast();<br/>   }<br/>}</span></pre><p id="d408" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这之后，我们将有更多的类型不匹配，我们将需要用接口替换类声明，我们将一切就绪。FetchDataModel现在看起来像这样:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9a88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以再次启动该应用程序，它的功能完全正常。我们不再调用旧的API，我们使用两个不同的接口注入了一个类，并且使用同一个接口注入了两个不同的类。</p><h1 id="fdfa" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">依赖关系的自动注册</h1><p id="2467" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">如果我们看看我们的<code class="fe nm nn no na b">ConfigureServices()</code>方法的内容，它现在看起来像这样:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="265e" class="ne lt it na b gy nf ng l nh ni">services.AddTransient&lt;IFetchDataViewModel, FetchDataViewModel&gt;();</span><span id="b101" class="ne lt it na b gy nl ng l nh ni">services.AddTransient&lt;IFetchDataModel, FetchDataModel&gt;();</span><span id="4ad4" class="ne lt it na b gy nl ng l nh ni">services.AddTransient&lt;IBasicForecastViewModel, BasicForecastViewModel&gt;();</span><span id="b531" class="ne lt it na b gy nl ng l nh ni">services.AddTransient&lt;IFullForecastModel, DailyForecastModel&gt;();</span><span id="1052" class="ne lt it na b gy nl ng l nh ni">services.AddTransient&lt;IBasicForecastModel, DailyForecastModel&gt;();</span><span id="4db0" class="ne lt it na b gy nl ng l nh ni">services.AddTransient&lt;IFullForecastModel, HourlyForecastModel&gt;();</span></pre><p id="f2fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们构建一个需要注册几十或几百个类的大型应用程序时会发生什么？每当我们需要注册另一个接口时，我们就在这个方法中添加另一行代码，或者我们可以设置我们的应用程序来自动注册。像AutoFac和StructureMap这样的DI框架的用户已经在这么做了。Net Core DI容器用户也在这么做。</p><p id="2650" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了用代码注册我们的服务，我们需要使用反射。首先，我们需要确定要搜索哪个或哪些程序集。之后，我们可以确定我们想要的类并注册它们。为了做好这一点，我们需要为我们的类和程序集设计一个命名方案，确保我们只注册我们的类，并且只注册一次。在我们的应用程序中，如果我们使用“FullName.Contains("Model ")”这样的标准，我们将注册我们的模型和视图模型，这可能不是我们想要的。</p><p id="304f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将采取的第一步是获取对我们的客户端程序集的引用:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d92f" class="ne lt it na b gy nf ng l nh ni">var assembly = AppDomain.CurrentDomain.GetAssemblies()<br/>   .Where(a =&gt; a<br/>   .FullName.StartsWith("BlazorMVVM.Client"))<br/>   .First();</span></pre><p id="a048" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该语句查看所有程序集，并提取具有匹配名称的所有程序集。我们已经提前知道我们将只有一个匹配，所以我们可以避免收到一个带有<code class="fe nm nn no na b">.First()</code>的数组。下一步是获取我想要注册的所有类。我不想意外地获取我不想要的类，所以我将使用Visual Studio重命名我所有的模型，以<code class="fe nm nn no na b">_model</code>结尾。这将使我更容易抓住他们注册。幸运的是，我在Startup.cs的屏幕上有它们，所以只需点击几下就可以重命名父模型和两个子模型。完成后，我可以像这样抓住它们:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="84b6" class="ne lt it na b gy nf ng l nh ni">var classes = assembly.ExportedTypes</span><span id="4a95" class="ne lt it na b gy nl ng l nh ni">.Where(a =&gt; a.FullName.Contains("_Model"));</span></pre><p id="43f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我只需要遍历这些类，然后遍历它们的接口，并注册每个类，如下所示:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="990e" class="ne lt it na b gy nf ng l nh ni">foreach (Type t in classes)<br/>{<br/>   foreach (Type i in t.GetInterfaces())<br/>   {<br/>      services.AddTransient(i, t);<br/>   }<br/>}</span></pre><p id="404c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在在<code class="fe nm nn no na b">ConfigureServices()</code>中只剩下两个手动注册的视图模型和一个已经自动注册了我们所有模型的代码块。更新后的<code class="fe nm nn no na b">ConfigureServices()</code>会是这样的:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bfcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再次，当我们启动我们的应用程序时，它就像我们手动注册每个服务时一样工作。</p><p id="9d5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在一个更大的应用程序中，你可能会把那个代码从<code class="fe nm nn no na b">ConfigureServices</code>中取出来，使它成为一个单独的方法，甚至是另一个完全不同的类。您可能对不同的程序集使用不同的标准，并且您可能有其他要求，比如只注册公共类或接口。只要你提前计划并坚持你自己的指导方针，你就可以很容易地注册你所有的依赖项。</p><h1 id="6c11" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">包扎</h1><p id="e16e" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">即使我们没有改变任何对用户可见的东西，我们也能够消除一个不需要的API，并对我们的实现进行一些改进。我们看到了如何对实现两个不同接口的类以及由两个不同类实现的接口使用依赖注入。我们还看到了在Startup.cs中用几行代码自动注册我们的服务是多么容易。</p><p id="6ec8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本系列还将继续其他文章。如果有你想看到的话题，请留下反馈或发推文给我。更新:第五篇文章已经发表:</p><div class="kz la gp gr lb lc"><a href="https://medium.com/@haywireiv/working-with-the-view-in-blazor-mvvm-functions-vs-code-behind-vs-viewmodel-ed3508dba86a" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">在Blazor MVVM中使用视图:函数{} vs代码隐藏vs视图模型</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">这是关于在客户端Blazor中使用模型-视图-视图模型模式的一种方法的系列文章的第五篇。如果…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="nr l ln lo lp ll lq jz lc"/></div></div></a></div></div></div>    
</body>
</html>