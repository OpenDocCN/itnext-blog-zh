<html>
<head>
<title>A React Router From Scratch in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中从头开始使用React路由器</h1>
<blockquote>原文：<a href="https://itnext.io/a-react-router-from-scratch-in-typescript-f0eec6ccb293?source=collection_archive---------1-----------------------#2020-02-09">https://itnext.io/a-react-router-from-scratch-in-typescript-f0eec6ccb293?source=collection_archive---------1-----------------------#2020-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/90e2009ebe9caa6be8ca611b5b33550d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvKwBg0SqrSNptIBG8hoqA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@elton_yung?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃尔顿·容</a>在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3da5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">路由是每个单页面应用程序的基本部分。在React生态系统<a class="ae kc" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank">中，react-router </a>是实现客户端路由的最流行的包。有了这个库，路由简单地以优雅和声明的方式完成。但在幕后，有许多先进的概念正在进行，使这一切工作。在本文中，我将探讨其中的一些，并给出React路由库的一个示例实现。</p><p id="b624" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始之前，我有一点要坦白:虽然标题是“从头开始”,但我今天将引用来自NPM的两个包，因为重写它们本身至少是一篇文章。但是我仍然认为这个适合于TypeScript中的'<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/a-web-server-from-scratch-in-typescript-854642a85402">一个从零开始的Web服务器和节点</a>'以及TypeScript中的'<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/a-workerpool-from-scratch-in-typescript-and-node-c4352106ffde">一个从零开始的Workerpool和节点</a>'(实际上我将只使用一个)。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">React中的声明性路由</figcaption></figure><h1 id="46fb" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">挑战</h1><p id="c5c8" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">现代单页应用程序的路由器库有一些主要的挑战需要克服。首先，它必须连接到浏览器并劫持路由。它还必须实现一些高级设计模式，以创建我们喜欢的react-router的声明式风格。我们必须确保用正确的html呈现客户端链接(意味着仍然使用<code class="fe mk ml mm mn b">&lt;a&gt;</code>标签和呈现<code class="fe mk ml mm mn b">href</code>)。</p><h1 id="8877" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">历史API</h1><p id="6793" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">JavaScript中的<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/History" rel="noopener ugc nofollow" target="_blank">历史</a> API允许开发者监听事件并操纵路由器状态。在这个项目中，我将使用来自NPM的<a class="ae kc" href="https://www.npmjs.com/package/history" rel="noopener ugc nofollow" target="_blank"> history </a>包，它提供了HTML5 history API的跨浏览器实现。它与react-router使用的相同。在我们的库中，我将创建一个单例实例，可以在应用程序的任何地方轻松使用。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h1 id="8e74" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">路由器组件</h1><p id="f195" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated"><code class="fe mk ml mm mn b">Router</code>组件保存路由器的状态。它必须监听来自<code class="fe mk ml mm mn b">history</code>的事件以更新其状态。每次导航发生时，<code class="fe mk ml mm mn b">listen</code>回调将被调用并更新<code class="fe mk ml mm mn b">Router</code>的状态。请注意，我们没有清理我们的侦听器，并且带着有点天真的假设生活，即<code class="fe mk ml mm mn b">Router</code>组件将总是被呈现。为了保持简单，我将让它保持原样。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h1 id="b702" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">路由组件</h1><p id="102a" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">路由是用位于<code class="fe mk ml mm mn b">Router</code>组件内部的<code class="fe mk ml mm mn b">Route</code>组件声明的。<code class="fe mk ml mm mn b">Router</code>将确保只呈现路径与当前url匹配的路线。这与react-router略有不同，因为我们没有<code class="fe mk ml mm mn b">Switch</code>组件。这是因为react-router使用react的上下文将路由器的状态传递给交换机，因此它可以支持嵌套。我们不会走这条路，所以我们不需要<code class="fe mk ml mm mn b">Switch</code>组件。</p><p id="2f42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mk ml mm mn b">Route</code>组件与普通组件略有不同。如果你看看它的实现，如下图所示，你会注意到它什么也不做，但仍然是作为一个类来实现的。这是因为<code class="fe mk ml mm mn b">Route</code>组件的工作仅仅是作为一个指示器存在于<code class="fe mk ml mm mn b">Router</code>中，它应该被区别对待。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="0e25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使<code class="fe mk ml mm mn b">Route</code>工作，我们必须更新<code class="fe mk ml mm mn b">Router</code>组件，以查找其子组件中的任何路由。这里我们将遍历<code class="fe mk ml mm mn b">Router</code>的子节点，隐藏任何路径与当前url不匹配的路由。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="aeac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要执行多项检查。第一个是检查我们的孩子是不是一个数组。如果是，我们映射它并检查每个孩子是否是一个<code class="fe mk ml mm mn b">Route</code>。为此，我们在react中使用了一个不太为人所知的技巧:如果您想检查某个元素是否是某个组件的实例，您可以将该元素的<code class="fe mk ml mm mn b">type</code>属性与组件类进行比较。如果是一个<code class="fe mk ml mm mn b">Route</code>，我们将该路径与状态中的url进行比较。除此之外，我们还对孩子的<code class="fe mk ml mm mn b">null</code>和<code class="fe mk ml mm mn b">undefined</code>进行了检查，以防止孩子不是<code class="fe mk ml mm mn b">ReactElement</code>(如<code class="fe mk ml mm mn b">string</code>或<code class="fe mk ml mm mn b">null</code>)时发生崩溃。</p><h1 id="7d97" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">链接组件</h1><p id="bcb5" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated"><code class="fe mk ml mm mn b">Link</code>组件使用正确的<code class="fe mk ml mm mn b">href</code>呈现一个<code class="fe mk ml mm mn b">&lt;a&gt;</code>标签，但是实际上使用<code class="fe mk ml mm mn b">onClick</code>将新的状态推送到<code class="fe mk ml mm mn b">history</code>。我们确实需要这样做，因为我们不希望当用户点击一个链接时页面重新加载，但仍然希望我们的html中的链接具有可访问性和SEO。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="2699" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们把所有这些放在一起时，我们可以编写一个路由应用程序，如下所示。我们还不支持的一件重要事情是通配符和其他有用特性的路径模式。为了实现这些，我建议看一下<a class="ae kc" href="https://www.npmjs.com/package/path-to-regexp" rel="noopener ugc nofollow" target="_blank"> path-to-regexp </a>，react-router也使用它。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h1 id="ca93" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="261a" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在本文中，我们已经了解了React应用程序中的路由。我希望您了解了所有这些组件如何一起工作来创建React社区已经学会喜欢的漂亮的声明式路由器接口。源代码可以在<a class="ae kc" href="https://github.com/WimJongeneel/ts-react-router" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p></div></div>    
</body>
</html>