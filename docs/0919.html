<html>
<head>
<title>Relay modern: Cache requests.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中继现代:缓存请求。</h1>
<blockquote>原文：<a href="https://itnext.io/relay-modern-cache-requests-a0faaa275108?source=collection_archive---------2-----------------------#2018-06-18">https://itnext.io/relay-modern-cache-requests-a0faaa275108?source=collection_archive---------2-----------------------#2018-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3ac3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Relay modern 是一个很棒的图书馆，它已经存在几年了。Relay的第一个版本(例如classic)具有开箱即用的请求缓存，并且工作得非常好。来自facebook的家伙决定在Relay Modern中默认不使用请求缓存，但是他们给了我们<a class="ae kl" href="https://github.com/facebook/relay/blob/master/packages/relay-runtime/network/RelayQueryResponseCache.js" rel="noopener ugc nofollow" target="_blank">一个工具</a>来这样做。它还没有出现在官方文档中，但是我们现在就可以使用它。这是我自己使用它的经验，我相信有更好的方法，但我还没有找到。让我们开始吧。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/bf5089a68ea5a15d1fd87b8371c3c046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkOVyyttD4g9PBZUyImChg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">感谢graph cool&amp;<a class="ae kl" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank">https://www.prisma.io/</a>供图。</figcaption></figure></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="6b87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要了解请求缓存在Relay中是如何工作的。每当我们想要扩展时，服务器中继会使用它的网络助手来完成对API的所有调用。中继网络需要一个函数(解析器),它必须实现API调用，这就是神奇的地方。假设它看起来像这样:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="29b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其思想是通过查询名称和变量将响应数据保存到缓存存储中。查询名称是在查询中定义的，例如:</p><pre class="kn ko kp kq gt ln lo lp lq aw lr bi"><span id="6318" class="ls lt iq lo b gy lu lv l lw lx">graphql`<br/>  query MyQueryExample($country: String!) {<br/>    getUsersByCountry(country: $country) {<br/>      name<br/>      age<br/>    }<br/>  }<br/>`</span></pre><p id="d7f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此查询的查询名称将是MyQueryExample。我决定使用查询名而不是散列(这个是relay-compiler在将graphql查询转换成relay查询时创建的)，因为它很冗长。稍后，只需使用名称就可以轻松地清除该查询的缓存。variables参数也是必需的，因为您可能有两个同名但变量不同的查询，例如:</p><pre class="kn ko kp kq gt ln lo lp lq aw lr bi"><span id="6686" class="ls lt iq lo b gy lu lv l lw lx">// this is a pseudocode, usually it is done by passing args to relay // query renderer<br/>const getRuUsers = relay.fetch({ country: 'Russia' });<br/>const getEuUsers = relay.fetch({ country: 'Europe' });</span></pre><p id="d7d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个从俄罗斯获取用户，第二个从欧洲获取用户。如果我们只使用查询名称作为关键字，那么relay会用第二个响应覆盖第一个响应，因为relay不能只通过名称来区分这两个查询。再来一次:使用查询名(或散列)和变量为缓存存储构建一个键。</p><pre class="kn ko kp kq gt ln lo lp lq aw lr bi"><span id="91c1" class="ls lt iq lo b gy lu lv l lw lx">cache.set(queryID, variables, data);</span></pre><p id="3f80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在看看它是如何工作的，在我们强制relay向服务器发送请求之前，我们尝试从缓存中获取对该查询的响应</p><pre class="kn ko kp kq gt ln lo lp lq aw lr bi"><span id="f008" class="ls lt iq lo b gy lu lv l lw lx">const cachedData = cache.get(queryID, variables);</span></pre><p id="37ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有，我们就返回它，如果没有缓存，我们就把它发送到服务器。一旦我们向服务器发送请求，我们需要使用相同的名称和变量将其响应保存在缓存中。基本就是这样。</p><p id="24c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">中继将在ttl参数中定义的时间内保留缓存，在我的例子中是60 * 5 * 1000 ms，相当于5分钟。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="e15f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这很好，也很有效，但是我们如何为特定的查询或所有查询清除缓存呢？中继缓存帮助器有一个名为clear的方法，用于清除所有缓存。要仅删除特定查询的缓存，我们需要重置它。</p><pre class="kn ko kp kq gt ln lo lp lq aw lr bi"><span id="4f59" class="ls lt iq lo b gy lu lv l lw lx">cache.set(queryName, vars, null);</span></pre><p id="267f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这部分还没做好。要清除特定查询的缓存，您需要知道调用该查询时使用的名称和变量。在我的例子中，我在定义查询的地方调用了一个突变，所以我得到了我需要的所有东西，但是正如我所说的，这并不理想。如果你认为这样做可能会更好——留下你的评论吧！</p><p id="68e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">喜欢这家店吗？鼓掌和分享。谢谢！</p></div></div>    
</body>
</html>