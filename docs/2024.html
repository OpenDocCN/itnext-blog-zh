<html>
<head>
<title>How to deploy and scale Symfony web applications on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Kubernetes上部署和扩展Symfony web应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/scaling-your-symfony-application-and-preparing-it-for-deployment-on-kubernetes-c102bf246a93?source=collection_archive---------1-----------------------#2019-03-18">https://itnext.io/scaling-your-symfony-application-and-preparing-it-for-deployment-on-kubernetes-c102bf246a93?source=collection_archive---------1-----------------------#2019-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c09cb63bb9edc8c6ac4d9d3bcebcdb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p5u4QTmkIxmUy5JZXoRTnA.png"/></div></div></figure><p id="1a06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经和一个同事合作一个项目有一段时间了。该项目基本上是一个网站，正在使用Symfony 3.4建立，它仍然处于开发阶段。</p><p id="caac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我决定分享我将我们的基础设施从Amzon AWS迁移到Digital Ocean上的Kubernetes的经验，以及我必须对我们的symfony代码进行的更改。</p><h1 id="e669" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">缩放一个网站/应用意味着什么？</h1><p id="541c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这意味着，通过简单地添加更多资源(服务器、存储等)，以一种使应用程序能够服务更多客户(更多请求)的方式来设计应用程序。</p><p id="5878" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于一个网站来说，这基本上意味着以一种可以在任意数量的可用服务器之间分配负载的方式来设计和构建您的网站。</p><h1 id="23e8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">迁移前我们的基础设施如何？</strong></h1><p id="bdcb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">由于我们的网站仍处于开发阶段，我们真的没有考虑太多的规模，因为我们总是推迟。</p><ul class=""><li id="7a18" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">我们使用一个单独的开发服务器，在那里我们托管我们单独的web服务器。</li><li id="f5e7" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">我们的mySql数据库使用Amazon RDS(关系数据库服务)托管。它包括一个网站的数据库，和吉拉和类似的东西的几个其他数据库。</li><li id="b790" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">对于文件存储，我们将文件本地存储在web服务器上，会话信息也存储在磁盘上，这可能是我们正确扩展web服务器的第一个挑战，因为存储应该在不同的服务器之间共享并保持一致，无论您的请求来自哪里。</li><li id="9b7c" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">代码过去(现在仍然)托管在github上。然而，我们有一个非常幼稚的cron脚本运行在开发服务器上，监视新的提交。每当一个新的提交被推送时，它就在拉取它，做一些构建操作，并更新网站的开发版本。实际上，它为我们做了一件伟大的工作。</li></ul><p id="31bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们开始接近完成我们的开发和启动我们的项目时，我们开始考虑一个永久的基础设施来托管我们的网站，并允许我们轻松扩展。</p><p id="be12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除此之外，我只有一个AWS服务器和一个RDS，这已经花费了很多钱，使得它不具备真正的可伸缩性(成本方面也是如此)。因此，我们决定转向更灵活的基础架构，我们可以根据需要轻松地对其进行扩展和缩减，并且更加经济高效。</p><p id="2c60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那一刻，我觉得这是一个了解containers、docker和Kubernetes的好机会，因为它们正是我一直在寻找的！</p><h1 id="498d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">我们是如何在Kubernetes上部署我们的Symfony应用程序的？</h1><p id="ad4a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这里，我会试着记起最显著的挑战，以及我们是如何摆脱它们的。如果你需要任何特定主题的进一步细节，请让我知道。</p><p id="5a7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">首先，摆脱本地文件存储！</strong></p><p id="82c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，这是对我最大的挑战。如果这部分让你感到困惑也没关系。当你进入实现阶段时，这可能真的很有帮助，你可以从这里得到一些想法。</p><p id="c25b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先让我对这篇伟大的文章表示赞赏，因为它给了我很好的提示，告诉我可以从哪里开始</p><div class="mn mo gp gr mp mq"><a href="https://medium.com/@galopintitouan/how-to-build-a-scalable-symfony-application-on-kubernetes-30f23bf304e" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">如何在Kubernetes上构建可伸缩的Symfony应用程序</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">现代web应用程序很复杂。您的用户对您的应用程序的期望是不断的…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne jw mq"/></div></div></a></div><p id="c9df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如上面的文章所建议的，我开始使用文件系统抽象层来访问文件(本质上是用户上传的图像和其他附件/文件)。</p><p id="747d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是等等，我该怎么做？我会有太多需要重构的地方？！</p><p id="e05f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，这倒是真的。我将尝试非常简要地解释我做了什么，但是如果有人感兴趣，我可以写另一篇关于我如何尽快实现文件系统抽象的详细文章。</p><p id="783d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用了一个名为“<strong class="ka ir"> League Flysystem </strong>的Symfony包来抽象文件系统访问</p><div class="mn mo gp gr mp mq"><a href="https://github.com/thephpleague/flysystem" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">超级联赛/飞行系统</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">本地和远程文件系统的抽象。通过创建一个帐户来为超级联赛/飞行系统的发展做贡献…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne jw mq"/></div></div></a></div><p id="a3f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，由于数字海洋不支持kubernetes上的NFS存储(至少目前如此)，我发现这是我使用数字海洋空间的另一个好机会(因为它提供了一个额外的优势，一个免费的CDN来在全球分发我的资产！)</p><p id="f46f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我使用Leage Flysystem和DigitalOcean spaces存储来存储用户上传的图片、我的网站资产等。</p><p id="eb7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，这不是现成的，你仍然需要找到你访问文件系统的每个地方，并用一个Leage文件系统调用来替换它。然而，做到这一点并不难。</p><p id="2915" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，我用自己的MountManager覆盖了Leage Flysystem中的默认mount manager，这样我就可以控制何时访问远程文件系统(数字海洋空间，以及使用哪个bucket)以及何时访问本地文件系统，这取决于我们试图访问的路径。</p><p id="6553" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，由于这个自定义挂载管理器，我能够在我的数据库中只存储一个相对文件路径(例如，image _ path:images/2019/03/16/123 . jpg ),而不用关心/存储它的存储位置，因为我的自定义挂载管理器知道“images”文件夹存储在数字海洋空间中，并且它应该使用这个特定的文件系统和那个特定的适配器来获取它。</p><p id="05e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使事情变得更简单，我还为Symfony Liip Imaging bundle编写了自定义解析器，允许它从抽象文件系统(连接到数字海洋空间)中获取原始图像，并在那里写入缓存的图像。</p><p id="60f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不仅如此，我使用Redis集群来存储我们是否已经有了图像的缓存版本，以便所有web服务器都可以共享thins信息，而不是让每个web服务器都生成自己的缓存版本。</p><p id="17e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以在这里讲得太深，但这将超出本文的范围(我猜它已经够混乱了)。如果你需要关于这个话题的详细信息，请告诉我。</p><p id="1fd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2-会话管理:在您的网络服务器之间共享用户会话</strong></p><p id="a471" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在典型的可伸缩web应用程序中，如果用户请求由不同的web服务器提供服务，我们应该不会有任何问题。</p><p id="9e63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果我们在本地存储用户会话，就会有问题。</p><p id="be9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运是，symfony为会话存储提供了方便的抽象。在我的例子中，我在kubernetes集群上安装了一个redis集群，并使用它来存储会话信息。</p><div class="mn mo gp gr mp mq"><a href="https://github.com/snc/SncRedisBundle" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">snc/SncRedisBundle</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">Symfony支持Predis和PhpRedis - snc/SncRedisBundle的Redis包</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="ng l nb nc nd mz ne jw mq"/></div></div></a></div><p id="6dda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您并不真正关心用户的请求在哪里得到服务，因为用户会话将在您所有的web服务器之间共享！</p><p id="c9b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3-数据库！</strong></p><p id="59ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我迁移到Digital Ocean时，他们还没有现成的关系数据库服务(现在，他们有了，但是有限，还不支持mysql。预计将很快推出)</p><p id="01ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建了自己的mysql集群，采用一主多从架构。我使用了kubernetes网站上提供的例子，但是必须处理安全性和其他问题。我花了两天时间才让它运行起来，所以我打算写一篇关于如何在kubernetes上设置mysql cluster的文章。</p><p id="6aa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nh" href="https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tasks/run-application/run-replication-stateful-application/</a></p><p id="1fcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您的情况下，您可能会决定使用现成的数据库服务，而不是自己维护一个DB集群。</p><h1 id="86ee" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">4- Kubernetes！</h1><p id="2368" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这里我不打算详细讨论kubernetes的实现细节。我将简单介绍一下您的集群可能是什么样子</p><p id="363e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在接下来的部分中，我假设您已经对kubernetes有了一些了解。这不是一个完整的实现细节，只是一个简单的概述。</p><p id="9911" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过，如果需要的话，我很乐意分享另一篇包含所有细节的文章。</p><h2 id="8617" class="ni kx iq bd ky nj nk dn lc nl nm dp lg kj nn no lk kn np nq lo kr nr ns ls nt bi translated">网络豆荚</h2><p id="e512" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我为我的web服务器角色创建了一个pod定义，它包含nginx容器和php-fpm容器，一起运行并共享代码量。</p><p id="f9a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，我不需要Nginx容器，因为我在默认映像中唯一改变的是为我的网站添加一个配置文件和密码保护(出于开发目的)。但是使用Kubernetes configMap可以很容易地做到这一点，只需在容器中挂载配置文件。</p><p id="6bb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用StatefulSet，它允许我为我的web服务器设置任意数量的副本。我将解释为什么我使用StatefulSet而不是Deployment。</p><p id="59fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将symfony代码文件夹附加到php容器中，我只是用initContainer将它复制到Nginx容器中。</p><p id="a669" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的php Dockerfile定义如下</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="1736" class="ni kx iq nz b gy od oe l of og"><em class="oh"># PHP Dockerfile<br/><br/></em><strong class="nz ir">FROM </strong>composer:1.5.1 <strong class="nz ir">AS <em class="oh">composer<br/></em>FROM </strong>php:7.1.24<strong class="nz ir">-</strong>fpm<br/><br/><strong class="nz ir">RUN </strong>apt-get update <strong class="nz ir">&amp;&amp; </strong>apt-get install <strong class="nz ir">-</strong>y \<br/>      acl \<br/>      libfreetype6-dev \<br/>      libjpeg62-turbo-dev \<br/>      libpng-dev \<br/>      libbz2-dev \<br/>      libicu-dev \<br/>      libzip-dev \<br/>      zip \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-install <strong class="nz ir">-</strong>j$(nproc) iconv \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-install bz2 \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-configure gd <strong class="nz ir">--</strong>with-freetype-dir=<strong class="nz ir">/</strong>usr<strong class="nz ir">/</strong>include<strong class="nz ir">/ --</strong>with-jpeg-dir=<strong class="nz ir">/</strong>usr<strong class="nz ir">/</strong>include<strong class="nz ir">/ </strong>\<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-install <strong class="nz ir">-</strong>j$(nproc) gd \<br/>    <strong class="nz ir">&amp;&amp; </strong>apt-get install jpegoptim \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-install intl \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-install mysqli \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-install pdo_mysql \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-install opcache \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-configure zip <strong class="nz ir">--</strong>with-libzip \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-install zip \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-install exif \<br/>    <strong class="nz ir">&amp;&amp; </strong>pecl install xdebug-2.5.0 \<br/>    <strong class="nz ir">&amp;&amp; </strong>docker-php-ext-enable xdebug \<br/>    <strong class="nz ir">&amp;&amp; </strong>apt-get install <strong class="nz ir">-</strong>y vim;<br/><br/><em class="oh"># copy the Composer PHAR from the Composer image into the PHP image<br/></em><strong class="nz ir">COPY --</strong>from=<strong class="nz ir"><em class="oh">composer </em>/</strong>usr<strong class="nz ir">/</strong>bin<strong class="nz ir">/</strong>composer <strong class="nz ir">/</strong>usr<strong class="nz ir">/</strong>bin<strong class="nz ir">/</strong>composer<br/><br/><strong class="nz ir">RUN </strong>echo <strong class="nz ir">'memory_limit = 2048M' &gt;&gt; /</strong>usr<strong class="nz ir">/</strong>local<strong class="nz ir">/</strong>etc<strong class="nz ir">/</strong>php<strong class="nz ir">/</strong>conf.d<strong class="nz ir">/</strong>docker-php-memlimit.ini<br/><br/><em class="oh"># Create user codekeeper, and use it as owner of the code<br/></em><strong class="nz ir">RUN </strong>useradd <strong class="nz ir">-</strong>ms <strong class="nz ir">/</strong>bin<strong class="nz ir">/</strong>bash codekeeper<br/><br/><strong class="nz ir">RUN </strong>mkdir <strong class="nz ir">-</strong>p <strong class="nz ir">/</strong>code<br/><strong class="nz ir">WORKDIR /</strong>code<br/><strong class="nz ir">RUN </strong>chown codekeeper:codekeeper .<br/><br/><strong class="nz ir">USER </strong>codekeeper<br/><br/><em class="oh"># Install composer packages (by starting with coping only composer file, to make use of docker layering feature)<br/></em><strong class="nz ir">COPY </strong>symfony<strong class="nz ir">/</strong>composer.json symfony<strong class="nz ir">/</strong>composer.lock .<strong class="nz ir">/<br/>RUN </strong>composer install <strong class="nz ir">--</strong>prefer-dist <strong class="nz ir">--</strong>no-scripts <strong class="nz ir">--</strong>no-dev <strong class="nz ir">--</strong>no-autoloader<br/><br/><em class="oh"># Now, copy the code<br/></em><strong class="nz ir">COPY --</strong>chown=codekeeper:codekeeper symfony <strong class="nz ir">/</strong>code<br/><strong class="nz ir">WORKDIR /</strong>code<br/><br/><em class="oh"># Remove execute permissions from all files in (/code), but add it only for directories (to allow traversal)<br/></em><strong class="nz ir">USER </strong>root<br/><em class="oh">#RUN chmod -R -x+X .<br/></em><br/><br/><em class="oh"># Give permissions to write to var<br/></em><strong class="nz ir">RUN </strong>setfacl <strong class="nz ir">-</strong>dR <strong class="nz ir">-</strong>m u:www-data:rwX <strong class="nz ir">-</strong>m u:codekeeper:rwX var<br/><strong class="nz ir">RUN </strong>setfacl <strong class="nz ir">-</strong>R <strong class="nz ir">-</strong>m u:www-data:rwX <strong class="nz ir">-</strong>m u:codekeeper:rwX var<br/><br/><br/><strong class="nz ir">CMD </strong>[<strong class="nz ir">"sh"</strong>, <strong class="nz ir">"-c"</strong>, <strong class="nz ir">"(setfacl -R -m u:www-data:rwX -m u:codekeeper:rwX var) &amp;&amp; (setfacl -dR -m u:www-data:rwX -m u:codekeeper:rwX var) &amp;&amp; php-fpm"</strong>]</span></pre><p id="8fae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我首先复制composer.lock内容，安装composer，最后一步复制代码。这样，当重新构建docker映像时，代码更改将只触发构建步骤(最后一层)</p><p id="ec60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不用分享我的<strong class="ka ir">。dockerignore </strong>，但是值得一提的是我忽略了node_modules。它们是通过initContainer构建的，但是它们被缓存在PV(持久卷)中，所以它们不会在每次pod重新启动时被下载。当然，你也要忽略。来自docker映像的git存储库。</p><p id="dc84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，最重要的部分是web pod的定义。这可能感觉有点复杂！我决定分享它，以防有人需要它。</p><p id="9b33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我用StatefulSet实现了它，所以我可以为每个pod请求一个PVC，而不需要手动创建它们。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="5300" class="ni kx iq nz b gy od oe l of og"><strong class="nz ir">apiVersion</strong>: apps/v1<br/><strong class="nz ir">kind</strong>: StatefulSet<br/><strong class="nz ir">metadata</strong>:<br/>  <strong class="nz ir">name</strong>: webserver<br/>  <strong class="nz ir">labels</strong>:<br/>    <strong class="nz ir">app</strong>: webserver<br/><strong class="nz ir">spec</strong>:<br/>  <strong class="nz ir">selector</strong>:<br/>    <strong class="nz ir">matchLabels</strong>:<br/>      <strong class="nz ir">app</strong>: webserver<br/>  <strong class="nz ir">serviceName</strong>: webserver<br/>  <strong class="nz ir">replicas</strong>: 4<br/>  <strong class="nz ir">template</strong>:<br/>    <strong class="nz ir">metadata</strong>:<br/>      <strong class="nz ir">name</strong>: webserver<br/>      <strong class="nz ir">labels</strong>:<br/>        <strong class="nz ir">app</strong>: webserver<br/>    <strong class="nz ir">spec</strong>:</span><span id="08ce" class="ni kx iq nz b gy oi oe l of og">     <strong class="nz ir">initContainers</strong>:<br/>        - <strong class="nz ir">name</strong>: init-php<br/>          <strong class="nz ir">image</strong>: your-php-image (PLEASE REPLACE THIS)<br/>          <strong class="nz ir">env</strong>:<br/>          - <strong class="nz ir">name</strong>: DATABASE_HOST_RW<br/>            <strong class="nz ir">valueFrom</strong>:<br/>              <strong class="nz ir">configMapKeyRef</strong>:<br/>                <strong class="nz ir">name</strong>: website-config<br/>                <strong class="nz ir">key</strong>: DATABASE_HOST_RW<br/><br/>          - <strong class="nz ir">name</strong>: DATABASE_HOST_RO<br/>            <strong class="nz ir">valueFrom</strong>:<br/>              <strong class="nz ir">configMapKeyRef</strong>:<br/>                <strong class="nz ir">name</strong>: website-config<br/>                <strong class="nz ir">key</strong>: DATABASE_HOST_RO<br/><br/>          - <strong class="nz ir">name</strong>: DATABASE_NAME<br/>            <strong class="nz ir">valueFrom</strong>:<br/>              <strong class="nz ir">configMapKeyRef</strong>:<br/>                <strong class="nz ir">name</strong>: website-config<br/>                <strong class="nz ir">key</strong>: DATABASE_NAME<br/><br/>          - <strong class="nz ir">name</strong>: DATABASE_USER<br/>            <strong class="nz ir">valueFrom</strong>:<br/>              <strong class="nz ir">configMapKeyRef</strong>:<br/>                <strong class="nz ir">name</strong>: website-config<br/>                <strong class="nz ir">key</strong>: DATABASE_USER<br/><br/>          - <strong class="nz ir">name</strong>: DATABASE_PASSWORD<br/>            <strong class="nz ir">valueFrom</strong>:<br/>              <strong class="nz ir">secretKeyRef</strong>:<br/>                <strong class="nz ir">name</strong>: some-secret-name-you-added<br/>                <strong class="nz ir">key</strong>: password<br/><br/>          - <strong class="nz ir">name</strong>: REDIS_HOST<br/>            <strong class="nz ir">valueFrom</strong>:<br/>              <strong class="nz ir">configMapKeyRef</strong>:<br/>                <strong class="nz ir">name</strong>: website-config<br/>                <strong class="nz ir">key</strong>: REDIS_HOST<br/><br/>          - <strong class="nz ir">name</strong>: REDIS_PORT<br/>            <strong class="nz ir">valueFrom</strong>:<br/>              <strong class="nz ir">configMapKeyRef</strong>:<br/>                <strong class="nz ir">name</strong>: website-config<br/>                <strong class="nz ir">key</strong>: REDIS_PORT<br/><br/>          <strong class="nz ir">volumeMounts</strong>:<br/>          - <strong class="nz ir">name</strong>: code<br/>            <strong class="nz ir">mountPath</strong>: /code<br/><br/>          <strong class="nz ir">command</strong>:<br/>          - bash<br/>          - <strong class="nz ir">"-c"<br/>          </strong>- |<br/>            # Copy the code to the shared volume, this will be mounted later into both of nginx and php<br/>            cp -r /var/www/html/you_web_site/* /code/<br/>            cd /code<br/>            composer install<br/>            php bin/console assets:install<br/>            php bin/console cache:clear --env=dev<br/>            php bin/console cache:clear --env=prod</span><span id="cfcd" class="ni kx iq nz b gy oi oe l of og"># I use this image to build my npm packages and webpack assets<br/>        - <strong class="nz ir">name</strong>: node<br/>          <strong class="nz ir">image</strong>: node:11<br/>          <strong class="nz ir">volumeMounts</strong>:<br/>          - <strong class="nz ir">name</strong>: code<br/>            <strong class="nz ir">mountPath</strong>: /var/www/html/you_web_site/<strong class="nz ir"><br/><br/>          command</strong>:<br/>          - bash<br/>          - <strong class="nz ir">"-c"<br/>          </strong>- |<br/>            set -ex<br/>            cd /var/www/html/you_web_site/<br/>            npm install || echo "npm install did not work"<br/>            ./node_modules/.bin/webpack --mode=production<br/><br/>      <strong class="nz ir">containers</strong>:<br/>      - <strong class="nz ir">name</strong>: nginx<br/>        <strong class="nz ir">image</strong>: you-nginx-image or offecial image (PLEASE REPLACE THIS)<br/>        <strong class="nz ir">imagePullPolicy</strong>: Always # you might want to change this<br/>        <strong class="nz ir">volumeMounts</strong>:<br/>        - <strong class="nz ir">name</strong>: code<br/>          <strong class="nz ir">mountPath</strong>: /var/www/html/you_web_site/<br/><br/>      - <strong class="nz ir">name</strong>: php<br/>        <strong class="nz ir">image</strong>: your-php-image<br/>        <strong class="nz ir">imagePullPolicy</strong>: Always # again<br/>        <strong class="nz ir">volumeMounts</strong>:<br/>        - <strong class="nz ir">name</strong>: code<br/>          <strong class="nz ir">mountPath</strong>: /var/www/html/you_web_site/<br/><br/>        <strong class="nz ir">env</strong>:<br/>            # I'm not gonna reput them.. please copy them from<br/>            # initContainer -&gt; first Container<br/>            # Here, I do pass two extra env vars to store auth to digital ocean spaces</span><span id="675e" class="ni kx iq nz b gy oi oe l of og">- <strong class="nz ir">name</strong>: FS_KEY<br/>          <strong class="nz ir">valueFrom</strong>:<br/>            <strong class="nz ir">secretKeyRef</strong>:<br/>              <strong class="nz ir">name</strong>: your-secret-name<br/>              <strong class="nz ir">key</strong>: key<br/><br/>        - <strong class="nz ir">name</strong>: FS_SECRET<br/>          <strong class="nz ir">valueFrom</strong>:<br/>            <strong class="nz ir">secretKeyRef</strong>:<br/>              <strong class="nz ir">name</strong>:  your-secret-name<br/>              <strong class="nz ir">key</strong>: secret<br/>         # That's another var I use to force my app to use local file system when it's set to false.<br/>        - <strong class="nz ir">name</strong>: FS_USE_REMOTE<br/>          <strong class="nz ir">value</strong>: <strong class="nz ir">"true"<br/><br/>      # if your images are stored in private repo<br/>      imagePullSecrets</strong>:<br/>      - <strong class="nz ir">name</strong>: your-image-pull-secret<br/><br/>      <strong class="nz ir">volumes</strong>:<br/>      - <strong class="nz ir">name</strong>: webserver-config-map<br/>        <strong class="nz ir">configMap</strong>:<br/>          <strong class="nz ir">name</strong>: webserver</span><span id="7db8" class="ni kx iq nz b gy oi oe l of og"># I use a persistent volume to store code, so I don't rebuild everything on every pod restart (like, node_modules). However, it's perfectly fine to use temp volume, it will just take a bit longer to start the container</span><span id="5708" class="ni kx iq nz b gy oi oe l of og">  <strong class="nz ir">volumeClaimTemplates</strong>:<br/>  - <strong class="nz ir">metadata</strong>:<br/>      <strong class="nz ir">name</strong>: code<br/>    <strong class="nz ir">spec</strong>:<br/>      <strong class="nz ir">accessModes</strong>: [<strong class="nz ir">"ReadWriteOnce"</strong>]<br/>      <strong class="nz ir">resources</strong>:<br/>        <strong class="nz ir">requests</strong>:<br/>          <strong class="nz ir">storage</strong>: 4Gi<br/>      <strong class="nz ir">storageClassName</strong>: do-block-storage</span></pre><p id="2ef4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将configMap中的所有键作为ENV变量导入可能是一个更好的主意，但是我觉得太懒了，不想改变它。</p><p id="fabc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，有两个initContainers，第一个将代码从我的php容器复制到一个卷中，该卷也安装在nginx容器中。它还做一些其他的操作</p><p id="5704" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个initContainer只是一个临时节点映像，我用它将node_modules安装到挂载的卷上，并构建webpack资产。</p><p id="0c56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，这里有太多的配置图和秘密..我不打算告诉你如何生成它们(我假设你知道)。</p><p id="d41a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为分享的最后一件事可能是有用的，那就是symfony patameters.yml</p><p id="72b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想向您展示这如何映射到上面的kubernetes配置(特别是env变量)</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="b3b6" class="ni kx iq nz b gy od oe l of og"><em class="oh"># This file is auto-generated during the composer install<br/></em><strong class="nz ir">parameters</strong>:<br/>    <strong class="nz ir">database_host_rw</strong>: <strong class="nz ir">'%env(DATABASE_HOST_RW)%'<br/>    database_host_ro</strong>: <strong class="nz ir">'%env(DATABASE_HOST_RO)%'<br/>    database_port</strong>: <strong class="nz ir">'%env(DATABASE_PORT)%'<br/>    database_name</strong>: <strong class="nz ir">'%env(DATABASE_NAME)%'<br/>    database_user</strong>: <strong class="nz ir">'%env(DATABASE_USER)%'<br/>    database_password</strong>: <strong class="nz ir">'%env(DATABASE_PASSWORD)%'<br/>    redis.host</strong>: <strong class="nz ir">'%env(REDIS_HOST)%'<br/>    redis.port</strong>: <strong class="nz ir">'%env(REDIS_PORT)%'<br/>    filesystem.use_remote</strong>: <strong class="nz ir">'%env(FS_USE_REMOTE)%'<br/>    filesystem.endpoint</strong>: <strong class="nz ir">'your spaces or amazon s3 endpoint'<br/>    filesystem.buckets.uploads.cdn</strong>: <strong class="nz ir">'your cdn prefix' # i use this to translate filepaths to web urls<br/>    filesystem.credentials.key</strong>: <strong class="nz ir">'%env(FS_KEY)%'<br/>    filesystem.credentials.secret</strong>: <strong class="nz ir">'%env(FS_SECRET)%'</strong></span><span id="ee09" class="ni kx iq nz b gy oi oe l of og"><strong class="nz ir"># Now, we are defining defaults<br/>    env(DATABASE_HOST_RW)</strong>: localhost<br/>    <strong class="nz ir">env(DATABASE_HOST_RO)</strong>: localhost<br/>    <strong class="nz ir">env(DATABASE_PORT)</strong>: 3306<br/>    <strong class="nz ir">env(DATABASE_NAME)</strong>: your local db name<br/>    <strong class="nz ir">env(DATABASE_USER)</strong>: db_user<br/>    <strong class="nz ir">env(DATABASE_PASSWORD)</strong>: db_password_local<br/>    <strong class="nz ir">env(REDIS_HOST)</strong>: localhost<br/>    <strong class="nz ir">env(REDIS_PORT)</strong>: 6379<br/>    <strong class="nz ir">env(FS_USE_REMOTE)</strong>: false</span><span id="6c8e" class="ni kx iq nz b gy oi oe l of og"><br/>    <strong class="nz ir">assets_base</strong>: http://localhost:8080<br/>    <strong class="nz ir">default_timezone</strong>: Asia/Damascus</span></pre><h2 id="486b" class="ni kx iq bd ky nj nk dn lc nl nm dp lg kj nn no lk kn np nq lo kr nr ns ls nt bi translated">服务</h2><p id="1fc4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我有三项主要服务:</p><ul class=""><li id="efaa" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">web服务从客户端(<a class="ae nh" href="https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nginx-ingress-with-cert-manager-on-digitalocean-kubernetes" rel="noopener ugc nofollow" target="_blank">通过入口控制器</a>)接收web请求，并将它们转发给任何web pods(如上所述)</li><li id="c867" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">Mysql服务:实际上有两个，一个将请求转发给主pod(用于读写请求)，另一个将请求转发给任何从pod(只读)</li><li id="0adc" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">Redis服务:它只是将请求转发给Redis集群中的任何pod。</li></ul><p id="4d6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我还有其他服务于吉拉、kubernetes仪表板、自动部署等的对象..都在同一个集群上运行..但是我不打算在这里详细讨论。</p><h2 id="613f" class="ni kx iq bd ky nj nk dn lc nl nm dp lg kj nn no lk kn np nq lo kr nr ns ls nt bi translated">我们如何在笔记本电脑上开发？自动化部署呢？</h2><p id="f0b2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">实际上，所有开发都在我们的机器上本地进行，这些机器运行的代码版本与集群上运行的代码版本相同，但是使用单独的Apache服务器来提供web内容，从本地独立的php-fpm安装，使用单独的本地mysql安装和单独的redis集群。所以基本上，当地没有库伯内特。</p><p id="89c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将参数<strong class="ka ir"> FS_USE_REMOTE </strong>设置为false，我们的本地机器告诉我们的定制挂载管理器总是使用本地文件系统进行存储，而不是使用数字海洋空间存储。</p><p id="9679" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让您的部署自动发生在开发集群上，并使用在线数据查看它们，这非常方便。至少，对我们来说，我们曾经是这样做的！</p><p id="91e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过在每次推送新的提交时重新部署web pods来实现这一点，但是对于我们来说，正如我提到的，我们过去只是推送，并看到我们的更改自动反映出来(这要感谢在旧设置中已经提到的幼稚的cron脚本)。</p><p id="bcf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想在kubernetes集群上有一个类似的设置，为此我使用了这个包</p><p id="4588" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">https://github.com/keel-hq/keel<a class="ae nh" href="https://github.com/keel-hq/keel" rel="noopener ugc nofollow" target="_blank"/></p><p id="8b03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很简单，很容易设置，我只需要按照链接，找到如何做到这一点。</p><h2 id="db95" class="ni kx iq bd ky nj nk dn lc nl nm dp lg kj nn no lk kn np nq lo kr nr ns ls nt bi translated">从kubernetes豆荚伐木怎么样？</h2><p id="0326" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们还没有做那部分的工作。那绝对是我需要马上做的事情。</p><h1 id="557a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">我们对这个基础设施满意吗？</h1><p id="a3d2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">绝对的！虽然我们还没有在生产环境中测试它，但是现在我真的可以称我们的网站，一个比以前更具可扩展性的网站。</p><p id="02af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑一下我的网站上线后，流量显著增加的情况。我该怎么办？</p><p id="9470" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，非常简单！向集群添加更多节点(对于数字海洋，这意味着单击几个按钮)，然后调整我的web服务器pod的副本数量，以启动更多服务器。别担心，我的应用程序现在可以很好地分配负载！</p><p id="4250" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MySql的读操作过载了？好了，让我们通过修改一行代码来增加奴隶的数量吧！</p><p id="8f34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不能否认集群有时会有一些问题，特别是对kubernetes的数字海洋支持仍然有限，但绝对值得努力。</p><h1 id="8628" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">最后</h1><p id="c11e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我真的希望这篇文章对你或你们中的一些人有所帮助。</p><p id="6344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我的第一篇关于媒体的文章，我知道它可能太长，太无聊，尤其是没有图片..因此，请随时向我发送您可能有的任何反馈。</p><p id="0b54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，请随时询问任何问题，并告诉我您是否希望我更详细地写这篇文章中提到的任何特定主题。</p><p id="cd85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谢谢！</p></div></div>    
</body>
</html>