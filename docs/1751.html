<html>
<head>
<title>That’s So Intersectional</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这是如此的交叉</h1>
<blockquote>原文：<a href="https://itnext.io/thats-so-intersectional-5dcd7e8d0b6b?source=collection_archive---------5-----------------------#2019-01-18">https://itnext.io/thats-so-intersectional-5dcd7e8d0b6b?source=collection_archive---------5-----------------------#2019-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用交叉点观察器API，加载更加缓慢。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/851b8a8853955541027405a04275356c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yoCSYq_KGFKYpPNgT9TeZQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">laccaria ochropurpurea——一种可爱的小蘑菇，长着粉红色/紫色的鳃。</figcaption></figure><p id="6d86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几周前偶然发现了<a class="ae lb" href="https://w3c.github.io/IntersectionObserver/" rel="noopener ugc nofollow" target="_blank">路口观察者API </a>。它仍处于工作草案阶段，但<a class="ae lb" href="https://caniuse.com/#feat=intersectionobserver" rel="noopener ugc nofollow" target="_blank">已经得到了很好的支持</a>，只有一个明显的例外:Safari，包括iOS版。但是，它是一个整洁的小API，可以有许多不同的用途，对于它提供增强或者我们可以编写合理的后备的情况，今天没有理由不使用它。</p><h1 id="c793" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用交叉点观察器API</h1><p id="7700" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">为了演示其中一些用途，我将使用<a class="ae lb" href="https://nabrown.github.io/intersection-observer/index-basic.html" rel="noopener ugc nofollow" target="_blank">这个简单的滚动照片库。</a></p><p id="787a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这方面的标记很简单，使用<code class="fe mf mg mh mi b">figure</code>和<code class="fe mf mg mh mi b">figcaption</code>，以及带有<code class="fe mf mg mh mi b">srcset</code>属性的<code class="fe mf mg mh mi b">img</code>，为不同的视窗尺寸提供大小合适的图像。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h2 id="cc87" class="ml ld iq bd le mm mn dn li mo mp dp lm jy mq mr lq kc ms mt lu kg mu mv ly mw bi translated">伟大的想法</h2><p id="690c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">与其绑定到<code class="fe mf mg mh mi b">scroll</code>事件并煞费苦心地检查元素的位置以及它们是否在视口内，我们可以创建一个观察者向我们报告这些信息。</p><p id="5a27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本的设置是:我们告诉观察者观察什么<em class="mx">目标</em>元素，测量什么<em class="mx">根</em>元素的交集(默认为浏览器窗口)，以及我们关心什么交集<em class="mx">阈值</em>。(相交阈值是与根元素相交的元素的百分比)。</p><p id="e850" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，每当一个元素跨越一个阈值(我称之为“交集变化”)时，观察者将执行一个回调函数。</p><h2 id="49ed" class="ml ld iq bd le mm mn dn li mo mp dp lm jy mq mr lq kc ms mt lu kg mu mv ly mw bi translated">增强照片库</h2><p id="9f50" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">其他人，包括Google，已经写了关于使用这个新API 的<a class="ae lb" href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/" rel="noopener ugc nofollow" target="_blank">延迟加载(更多内容在下面)，但是我们可以使用交叉点观察器API做什么其他的改进呢？让我们看看</a><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry" rel="noopener ugc nofollow" target="_blank">为每个路口变化提供的所有数据</a>:</p><pre class="km kn ko kp gt my mi mz na aw nb bi"><span id="03df" class="ml ld iq mi b gy nc nd l ne nf">var callback = function(changes, observer) { <br/>  changes.forEach(change =&gt; {<br/>    //   change.target<br/>    //   change.isIntersecting<br/>    //   change.time<br/>    //   change.intersectionRatio<br/>    //   change.rootBounds<br/>    //   change.boundingClientRect<br/>    //   change.intersectionRect     <br/>  });<br/>};</span></pre><p id="38db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个<code class="fe mf mg mh mi b">change</code>具有关于一个被观察元素的<em class="mx">的交点变化的信息:</em></p><ul class=""><li id="05ff" class="ng nh iq jp b jq jr ju jv jy ni kc nj kg nk kk nl nm nn no bi translated"><code class="fe mf mg mh mi b">target</code>是交集发生变化的元素</li><li id="340a" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated">如果目标与根相交，返回真，否则返回假</li><li id="2be0" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><code class="fe mf mg mh mi b">time</code>路口发生了变化</li><li id="7fc1" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><code class="fe mf mg mh mi b">intersectionRatio</code>:元素<code class="fe mf mg mh mi b">target</code>与所选根相交的比例是多少，用小数表示</li><li id="2c2a" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated">描述根元素(<code class="fe mf mg mh mi b">rootBounds</code>)、被观察元素(<code class="fe mf mg mh mi b">boundingClientRect</code>)和两者交集(<code class="fe mf mg mh mi b">intersectionRect</code>)的矩形。</li></ul><p id="4754" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了开始观察十字路口，我们需要做一点设置:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="405b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有几个配置变量，然后我们获取想要观察的元素，并将它们传递给一个<code class="fe mf mg mh mi b">createObserver</code>函数。</p><p id="1d22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mf mg mh mi b">createObserver</code>中，我们:</p><ol class=""><li id="1d7c" class="ng nh iq jp b jq jr ju jv jy ni kc nj kg nk kk nu nm nn no bi translated">为观察者设置<code class="fe mf mg mh mi b">options</code>。除了提供一组从0到1.0的阈值之外，我们将坚持使用默认值。每当观察到的元素的交集比率超过该数组中的阈值时，我们的回调函数将被调用。</li><li id="9f98" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nu nm nn no bi translated">创建观察者，传入回调函数<code class="fe mf mg mh mi b">handleIntersection</code>和<code class="fe mf mg mh mi b">options</code>。</li><li id="d169" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nu nm nn no bi translated">在我们想要观察的每个元素上部署观察者。</li></ol><h2 id="0588" class="ml ld iq bd le mm mn dn li mo mp dp lm jy mq mr lq kc ms mt lu kg mu mv ly mw bi translated">使用交集比率</h2><p id="07d6" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在，我们可以使用新发现的交叉点数据。首先，使用<code class="fe mf mg mh mi b">intersectionRatio</code>，我们可以根据视图中的百分比淡入和淡出每个<code class="fe mf mg mh mi b">img</code>:</p><pre class="km kn ko kp gt my mi mz na aw nb bi"><span id="8764" class="ml ld iq mi b gy nc nd l ne nf">function handleIntersection(changes) {<br/>  changes.forEach((change) =&gt; {<br/>    let figure = change.target;<br/>    let img = figure.getElementsByTagName("img")[0];<br/>    let ratio = change.intersectionRatio;<br/>    img.style.opacity = minOpacity + (1 - minOpacity) * ratio;<br/>  });<br/>}</span></pre><p id="f029" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将淡入图像，从我们设置的最小不透明度到完全不透明度。随着<code class="fe mf mg mh mi b">transition: opacity 500ms;</code>的应用，我们得到了一个很好的平滑过渡。</p><p id="ad3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还想在图像全图显示时隐藏标题，就像这样:</p><pre class="km kn ko kp gt my mi mz na aw nb bi"><span id="72fc" class="ml ld iq mi b gy nc nd l ne nf">let caption = figure.getElementsByTagName('figcaption')[0];</span><span id="6f6f" class="ml ld iq mi b gy nv nd l ne nf">if (ratio &lt; 0.9) {<br/>  caption.style.opacity = 1;<br/>} else {<br/>  caption.style.opacity = 0;<br/>}</span></pre><p id="ac66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://nabrown.github.io/intersection-observer/index-enhanced.html" rel="noopener ugc nofollow" target="_blank">画廊现在看起来是这样的</a>。</p><h2 id="6f6c" class="ml ld iq bd le mm mn dn li mo mp dp lm jy mq mr lq kc ms mt lu kg mu mv ly mw bi translated">使用交叉点时间戳</h2><p id="d59b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">站点分析中一个常用的统计数据是第页上的<em class="mx">时间，但是由于许多简单的站点放弃了多个页面而选择了更长的滚动页面，交叉点观察器API可以帮助我们跟踪用户在每个部分花费的时间。在我们的例子中，假设我们想知道用户花多长时间凝视我们的每张照片。</em></p><p id="6fe9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到了每个路口变化发生的时间。因此，我们可以计算出一个被观察的元素在相交阈值内有多长。在我们的简单例子中——每个<code class="fe mf mg mh mi b">figure</code>在浏览器视窗中可见多长时间？</p><p id="e670" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，我们还可以补充:</p><pre class="km kn ko kp gt my mi mz na aw nb bi"><span id="df5d" class="ml ld iq mi b gy nc nd l ne nf">if(ratio &gt; .8 &amp;&amp; figure.dataset.startTime === undefined){<br/>  figure.dataset.startTime = entry.time;<br/>}<br/>if(ratio &lt; .8 &amp;&amp; figure.dataset.startTime !== undefined){<br/>  console.log(entry.time - figure.dataset.startTime)<br/>  delete figure.dataset.startTime;<br/>}</span></pre><p id="4352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我选择了0.8，或者说80%可见，作为阈值，我会把它算作“可见”。我们只是在目标元素上名为<code class="fe mf mg mh mi b">startTime</code>的数据属性中存储数字第一次越过. 8阈值的时间。当它第二次越过这个阈值时，我们<code class="fe mf mg mh mi b">console.log</code>这个差值，然后删除<code class="fe mf mg mh mi b">startTime</code>数据属性。(您可能不希望在数百个元素上添加和删除数据属性。或者，您可以将数据保存在对象中)。</p><p id="60e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，将日志记录到控制台并不太有趣，因此您可以将计时数据发送到分析工具。例如:</p><pre class="km kn ko kp gt my mi mz na aw nb bi"><span id="4286" class="ml ld iq mi b gy nc nd l ne nf">if(ratio &gt; .8 &amp;&amp; figure.dataset.startTime === undefined){<br/>  figure.dataset.startTime = change.time;<br/>}<br/>if(ratio &lt; .8 &amp;&amp; figure.dataset.startTime !== undefined){<br/>  ga('send', {<br/>    hitType: 'timing',<br/>    timingCategory: 'Images',<br/>    timingVar: 'view_time',<br/>    timingValue: change.time - figure.dataset.startTime,<br/>    timingLabel: figure.getElementsByTagName('img')[0].getAttribute('src')<br/>  });<br/>  delete figure.dataset.startTime;<br/>}</span></pre><p id="32c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当该数字高于和低于80%阈值时，将记录一个单独的“在视图中”时间，因此我们将在报告端进行一些汇总。</p><h2 id="d5ff" class="ml ld iq bd le mm mn dn li mo mp dp lm jy mq mr lq kc ms mt lu kg mu mv ly mw bi translated">使用边界矩形</h2><p id="5084" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">实际上，我想不出这些的用例。如果你想出了一个，请在下面留下评论！<a class="ae lb" href="https://codepen.io/noraspice/full/roEELv" rel="noopener ugc nofollow" target="_blank">我做了这个，但是我觉得不算<em class="mx">有用</em> </a>。</p><h2 id="a843" class="ml ld iq bd le mm mn dn li mo mp dp lm jy mq mr lq kc ms mt lu kg mu mv ly mw bi translated">使用isIntersecting</h2><p id="1e33" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果我们只需要知道目标元素是否与根元素相交，我们可以使用布尔值<code class="fe mf mg mh mi b">isIntersecting</code>。继续懒惰装载！</p><h1 id="c695" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用交叉点观察器API进行延迟加载</h1><p id="0ec8" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们将使用占位符图像和<code class="fe mf mg mh mi b">data</code>属性，并添加一个<code class="fe mf mg mh mi b">unveil</code>类，稍微修改一下我们的标记来实现延迟加载:</p><pre class="km kn ko kp gt my mi mz na aw nb bi"><span id="7bf4" class="ml ld iq mi b gy nc nd l ne nf">&lt;img src="img/placeholder-v.png" class="unveil" <br/>  data-src="img/black-trumpet-700.jpg"<br/>  data-srcset="img/black-trumpet-1400.jpg 1400w, img/black-trumpet-2800.jpg 2800w"<br/>  alt="Top view of a delicate light gray-brown, funnel-shaped mushroom amongst leaf litter on the forest floor."<br/>/&gt;</span></pre><p id="4b62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，<a class="ae lb" href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/" rel="noopener ugc nofollow" target="_blank"> Google有一个很好的代码示例</a>并浏览了一下。我做了一些改变，使它成为一个带有可配置的<code class="fe mf mg mh mi b">lookAhead</code>和回调的插件。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c944" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种设置与我们目前使用的略有不同。设置了<code class="fe mf mg mh mi b">rootMargin</code>选项，它扩展了根元素的边界框，因此当图像仍然在浏览器视窗之外时，它们被触发开始加载。此外，在这种情况下，我们只关心一个阈值(默认的<code class="fe mf mg mh mi b">[0]</code>)，所以没有必要在这里传递我们自己的值。</p><pre class="km kn ko kp gt my mi mz na aw nb bi"><span id="18c0" class="ml ld iq mi b gy nc nd l ne nf">document.addEventListener("DOMContentLoaded", function() {<br/>  let options = {<br/>    // <!-- -->allows us to start loading before the element is visible<br/>    rootMargin: `${lookAhead}px 0px`<br/>  }<br/>  let lazyImageObserver = new IntersectionObserver(unveil, options);</span><span id="96f3" class="ml ld iq mi b gy nv nd l ne nf">images.forEach(function(img) {<br/>    lazyImageObserver.observe(img);<br/>  });<br/>});</span><span id="0583" class="ml ld iq mi b gy nv nd l ne nf">function unveil(changes, observer) {<br/>  changes.forEach(function(change) {<br/>    if (change.isIntersecting) {<br/>      let img = change.target;<br/>      img.src = img.dataset.src;<br/>      img.srcset = img.dataset.srcset;<br/>      img.classList.remove("unveil");<br/>      // no need to observe this image anymore<br/>      observer.unobserve(img);<br/>      if (typeof callback === "function") callback.call(img);<br/>    }<br/>  });<br/>}</span></pre><p id="9a96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，一旦图像被加载，我们不再需要观察它，所以我们可以使用<code class="fe mf mg mh mi b">unobserve</code>方法:</p><pre class="km kn ko kp gt my mi mz na aw nb bi"><span id="8b4f" class="ml ld iq mi b gy nc nd l ne nf">observer.unobserve(img);</span></pre><p id="4d2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">交叉点观察器API不可用时的备选方案包括:使用聚合填充、立即加载图像或使用其他延迟加载方法。我认为最后一个选项在保持轻量级和提供延迟加载的性能优势之间取得了很好的平衡，特别是对于iOS上的Safari。对于<a class="ae lb" href="https://github.com/nabrown/unveil-intersect" rel="noopener ugc nofollow" target="_blank">这个插件</a>，我使用交叉点观察器API作为第一道攻击线，并使用一个jQuery插件的<a class="ae lb" href="https://medium.com/@norabrown/breaking-up-with-jquery-is-hard-to-do-27defe486b11" rel="noopener"> plain-js重写作为退路。</a></p><h1 id="cd4d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="eb07" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><a class="ae lb" href="https://nabrown.github.io/intersection-observer/" rel="noopener ugc nofollow" target="_blank">这是最终的图库</a>，有细微的增强和基于交叉点观察者的延迟加载。</p><p id="5cbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Intersection Observer API易于理解和实现，除了Safari之外也得到很好的支持，并且比绑定到<code class="fe mf mg mh mi b">scroll</code>事件和手动处理元素位置更高效、更容易使用。</p><p id="bd93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你已经把它投入使用，我很乐意听到它——请留下评论！</p><h1 id="ba0c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">进一步阅读</h1><ul class=""><li id="d279" class="ng nh iq jp b jq ma ju mb jy nw kc nx kg ny kk nl nm nn no bi translated"><a class="ae lb" href="https://www.w3.org/TR/intersection-observer/" rel="noopener ugc nofollow" target="_blank"> W3C路口观察器API工作草案</a></li><li id="c6b7" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">MDN上的交叉点观察器</a></li><li id="6ab0" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><a class="ae lb" href="https://caniuse.com/#feat=intersectionobserver" rel="noopener ugc nofollow" target="_blank">can使用兼容性信息</a></li><li id="6222" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><a class="ae lb" href="https://medium.com/@norabrown/breaking-up-with-jquery-is-hard-to-do-27defe486b11" rel="noopener">用普通Javascript重写jQuery延迟加载插件</a></li><li id="ddc9" class="ng nh iq jp b jq np ju nq jy nr kc ns kg nt kk nl nm nn no bi translated"><a class="ae lb" href="https://www.robinosborne.co.uk/2016/05/16/lazy-loading-images-dont-rely-on-javascript/" rel="noopener ugc nofollow" target="_blank">关于使延迟加载非js友好的想法</a></li></ul></div></div>    
</body>
</html>