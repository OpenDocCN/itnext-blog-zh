<html>
<head>
<title>Predicting Credit Risk by using PySpark ML and Docker Part-2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PySpark ML和Docker Part-2预测信用风险</h1>
<blockquote>原文：<a href="https://itnext.io/predicting-credit-risk-by-using-pyspark-ml-and-docker-part-2-7d3be25ae5e5?source=collection_archive---------5-----------------------#2020-01-08">https://itnext.io/predicting-credit-risk-by-using-pyspark-ml-and-docker-part-2-7d3be25ae5e5?source=collection_archive---------5-----------------------#2020-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d28b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们端到端分类项目的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/predicting-credit-risk-by-using-pyspark-ml-and-docker-part-1-eef141a50a7e">第一部分</a>中，通过对特征进行分类，信用风险数据集被转换并可用于机器学习算法。在这一部分，将实现各种分类算法来预测<code class="fe km kn ko kp b">Loan_Status</code>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/43d5b26c39be52d4c64c800aa177e48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYTP2Yhc3DZ-PxGFMkP6TA.jpeg"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><a class="ae kl" href="https://unsplash.com/@ray30?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">雷锐</a>在<a class="ae kl" href="https://unsplash.com/s/photos/machine--learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="8205" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">管道</strong></p><p id="8c98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在机器学习中，运行不同的算法来处理和学习数据。我们从每个单词创建数字特征向量，然后算法从这些向量和标签中学习。每个流水线包括或者是<code class="fe km kn ko kp b">Transformer</code>或者是<code class="fe km kn ko kp b">Estimator</code>的阶段。</p><p id="7699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，一个<code class="fe km kn ko kp b">Transformer</code>实现了一个方法<code class="fe km kn ko kp b">transform()</code>，它将一个<code class="fe km kn ko kp b">DataFrame</code>转换成另一个，通常是通过追加一个或多个列。另一方面，<code class="fe km kn ko kp b">Estimator</code>接受数据帧并通过<code class="fe km kn ko kp b">fit()</code>方法创建模型。让我们开始构建我们的管道:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lg lh l"/></div></figure><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi li"><img src="../Images/e5ccd1920728e08780e21cf8eb590eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VGsmHB2v77rVhShpawFl6A.png"/></div></div></figure><p id="7494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">管道已经建立，我们准备将数据分成两部分:训练和测试。</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="6bb2" class="ln lo iq kp b gy lp lq l lr ls">(train, test) = df.randomSplit([0.7, 0.3], seed = 1)</span></pre><p id="bdff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">逻辑回归</strong></p><p id="101c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spark ML在数据帧之上提供了一组高级API，使我们能够实现ML算法。逻辑回归是预测分类结果的一种众所周知的算法。该算法使用逻辑函数来模拟二元因变量。逻辑回归有不同的类型，如二元，多项式和有序逻辑回归。在本文中，我们使用二元逻辑回归来预测一个二元结果，它有两个分类结果，如是或否。</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="da8d" class="ln lo iq kp b gy lp lq l lr ls">## Logistic Regression<br/>from pyspark.ml.classification import LogisticRegression</span><span id="89ce" class="ln lo iq kp b gy lt lq l lr ls">lr = LogisticRegression(featuresCol = ‘features’, labelCol = ‘label’, maxIter=100)<br/>lrModel = lr.fit(train)</span></pre><p id="0cb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来解释这些系数:</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="a813" class="ln lo iq kp b gy lp lq l lr ls">import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="e9bb" class="ln lo iq kp b gy lt lq l lr ls">beta = np.sort(lrModel.coefficients)<br/>plt.plot(beta)<br/>plt.ylabel(‘Beta Coefficients’)<br/>plt.show()</span></pre><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lu"><img src="../Images/e1d77a15c02b7c3af46b78092ab76462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JcUUK_-OtqbezGvBBBJz0w.png"/></div></div></figure><p id="c4c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们画出<code class="fe km kn ko kp b">ROC</code> ( <strong class="jp ir">接收器工作特性</strong>)和<code class="fe km kn ko kp b">AUC</code> ( <strong class="jp ir">曲线下面积</strong>)。它是检验任何分类模型性能的最重要的评价指标之一。这将为我们提供一个性能测量，这是机器学习的一个基本任务。我们可以将ROC定义为概率曲线，AUC代表可分性的度量。它确保了我们的模型能够区分不同的类。</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="a510" class="ln lo iq kp b gy lp lq l lr ls">trainSet = lrModel.summary<br/>roc = trainSet.roc.toPandas()<br/>plt.plot(roc[‘FPR’],roc[‘TPR’])<br/>plt.ylabel(‘False Positive Rate’)<br/>plt.xlabel(‘True Positive Rate’)<br/>plt.title(‘ROC Curve’)<br/>plt.show()<br/>print(‘TrainSet areaUnderROC: ‘ + str(trainSet.areaUnderROC))</span></pre><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lv"><img src="../Images/e79b91ca104a4be0b9450a9323190b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e75hc_MnUyCz3KOqFVSwvg.png"/></div></div></figure><p id="a498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">精度和召回显示如下:</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="d867" class="ln lo iq kp b gy lp lq l lr ls">pr = trainSet.pr.toPandas()<br/>plt.plot(pr[‘recall’],pr[‘precision’])<br/>plt.ylabel(‘Precision’)<br/>plt.xlabel(‘Recall’)<br/>plt.show()</span></pre><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lw"><img src="../Images/f4f4f7521577e85b0884fe41fea45854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSeSU9gakNZB7F2NCe-zBA.png"/></div></div></figure><p id="514b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在测试集上做一些预测:</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="f424" class="ln lo iq kp b gy lp lq l lr ls">## make predictions</span><span id="65a5" class="ln lo iq kp b gy lt lq l lr ls">predictions = lrModel.transform(test)</span><span id="8cc0" class="ln lo iq kp b gy lt lq l lr ls">predictions.select(‘ApplicantIncome’, ‘CoapplicantIncome’, ‘Loan_Amount_Term’, ‘Credit_History’, ‘prediction’, ‘probability’).show(10)</span></pre><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lx"><img src="../Images/1a5999057c6ccd6a0c7c4c06ae54b495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1riVxvAYuhVtqQcIWLWHXg.png"/></div></div></figure><p id="c674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">二元分类</strong></p><p id="788c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">Binary Classification</code>的任务是预测一个二进制标签。在我们的模型中，我们将预测一个人能否获得贷款。</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="af3d" class="ln lo iq kp b gy lp lq l lr ls">from pyspark.ml.evaluation import BinaryClassificationEvaluator</span><span id="8644" class="ln lo iq kp b gy lt lq l lr ls">evaluator = BinaryClassificationEvaluator()<br/>print(‘Test Area Under ROC’, evaluator.evaluate(predictions))</span></pre><p id="07e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ROC下哪个给出的测试Ares:<em class="ly">0.86838383831</em></p><p id="4e3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">随机森林</strong></p><p id="e5ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随机森林是一组决策树，每个决策树使用<code class="fe km kn ko kp b">Mojority of Voting</code>。该算法通过组合决策树来降低过拟合的风险。</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="b6f1" class="ln lo iq kp b gy lp lq l lr ls">## Random Forest Classifier</span><span id="088c" class="ln lo iq kp b gy lt lq l lr ls">from pyspark.ml.classification import RandomForestClassifier</span><span id="3e04" class="ln lo iq kp b gy lt lq l lr ls"># Creating RandomForest model.<br/>rf = RandomForestClassifier(labelCol=”label”, featuresCol=”features”)</span><span id="324f" class="ln lo iq kp b gy lt lq l lr ls">## train the model<br/>rfModel = rf.fit(train)</span><span id="360e" class="ln lo iq kp b gy lt lq l lr ls">## make predictions<br/>predictions = rfModel.transform(test)<br/>rfPredictions = predictions.select("label", "prediction", "probability")<br/>rfPredictions.show(10)</span></pre><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi gj"><img src="../Images/c064c2c37c4488a312921147b2acbaee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-kglRMu98IrcybD9V7OAw.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">随机森林预测</figcaption></figure><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="d51b" class="ln lo iq kp b gy lp lq l lr ls">## evaluate the Rnadom Forest Classifier</span><span id="e660" class="ln lo iq kp b gy lt lq l lr ls">from pyspark.ml.evaluation import BinaryClassificationEvaluator</span><span id="f3b4" class="ln lo iq kp b gy lt lq l lr ls">evaluator = BinaryClassificationEvaluator()<br/>evaluator.evaluate(predictions)</span><span id="8d42" class="ln lo iq kp b gy lt lq l lr ls">print(‘Random Forest Test areaUnderROC: {}’.format(evaluator.evaluate(predictions)))</span></pre><p id="6d50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和随机森林试验区:0.84866686767767</p><p id="eae2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">梯度增强树分类器</strong></p><p id="0d16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">梯度增强的树分类器也是一组决策树，它们迭代地训练决策树以最小化损失函数。</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="d468" class="ln lo iq kp b gy lp lq l lr ls">## Gradient-Boosted Tree Classifier</span><span id="6afb" class="ln lo iq kp b gy lt lq l lr ls">from pyspark.ml.classification import GBTClassifier</span><span id="863f" class="ln lo iq kp b gy lt lq l lr ls">gbt = GBTClassifier(labelCol=”label”, featuresCol=”features”,maxIter=10)</span><span id="86f7" class="ln lo iq kp b gy lt lq l lr ls">pipeline = Pipeline(stages=stages+[gbt])<br/>(traininggbt, testgbt) = df_copy.randomSplit([0.7, 0.3], seed=1)<br/>gbtModel = pipeline.fit(traininggbt)</span></pre><p id="743e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进行预测:</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="6d2a" class="ln lo iq kp b gy lp lq l lr ls">from pyspark.ml.evaluation import MulticlassClassificationEvaluator</span><span id="da5e" class="ln lo iq kp b gy lt lq l lr ls">predictions =gbtModel.transform(testgbt)</span><span id="32a4" class="ln lo iq kp b gy lt lq l lr ls"># Show predictions<br/>predictions.select(‘label’, ‘prediction’, ‘probability’).show(10)</span></pre><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/66f2c946cd7ffea33b0ebd1562963a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*5jTmgkKk86JrPeXLs7wEPw.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">GBT预言</figcaption></figure><p id="194d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">梯度增强树分类器的评估可以如下进行:</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="b9b4" class="ln lo iq kp b gy lp lq l lr ls">evaluator = BinaryClassificationEvaluator()</span><span id="5de6" class="ln lo iq kp b gy lt lq l lr ls">print(“GBT Test Area Under ROC: “ + str(evaluator.evaluate(predictions, {evaluator.metricName: “areaUnderROC”})))</span></pre><p id="a933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导致<em class="ly"> GBT试验区ROC: 0.813024203211119 </em>。</p><p id="1464" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> ParamGridBuilder和CrossValidator </strong></p><p id="6391" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模型选择，也称为调整，在机器学习中有着重要的作用。目标是试图为给定的数据集找到最佳的模型或参数，以提高性能。在本文中，我们将使用五重交叉验证。对于大型数据集来说，这一过程的成本可能很高，因为Spark应该检查参数的几种组合。</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="c0ec" class="ln lo iq kp b gy lp lq l lr ls">from pyspark.ml.tuning import ParamGridBuilder, CrossValidator</span><span id="8fe7" class="ln lo iq kp b gy lt lq l lr ls">paramGrid = ParamGridBuilder()\<br/> .addGrid(lr.aggregationDepth,[2,5,10])\<br/> .addGrid(lr.elasticNetParam,[0.0, 0.5, 1.0])\<br/> .addGrid(lr.fitIntercept,[False, True])\<br/> .addGrid(lr.maxIter,[10, 100, 1000])\<br/> .addGrid(lr.regParam,[0.01, 0.5, 2.0]) \<br/> .build()</span></pre><p id="a331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们创建五重交叉验证器:</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="e0d6" class="ln lo iq kp b gy lp lq l lr ls">cv = CrossValidator(estimator=lr, estimatorParamMaps=paramGrid, evaluator=evaluator, numFolds=5)</span><span id="a0a5" class="ln lo iq kp b gy lt lq l lr ls"># Run cross validations<br/>cvModel = cv.fit(train)</span><span id="cfc1" class="ln lo iq kp b gy lt lq l lr ls">predict_train=cvModel.transform(train)<br/>predict_test=cvModel.transform(test)<br/>print(“Cross-validation areaUnderROC for train set is {}”.format(evaluator.evaluate(predict_train)))<br/>print(“Cross-validation areaUnderROC for test set is {}”.format(evaluator.evaluate(predict_test)))</span></pre><p id="73dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这导致:</p><pre class="kr ks kt ku gt lj kp lk ll aw lm bi"><span id="3551" class="ln lo iq kp b gy lp lq l lr ls">Cross-validation areaUnderROC for train set is 0.8361628101944998<br/>Cross-validation areaUnderROC for test set is 0.811416490486258</span></pre><p id="8204" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong></p><p id="d91b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，本文描述了PySpark中基本的二进制分类实现。我们展示了不同的算法来进行比较，并最终应用交叉验证来提高性能。它还展示了Apache Spark的效率及其特性。</p><p id="2d1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考文献</strong></p><div class="ma mb gp gr mc md"><a href="https://spark.apache.org/docs/latest/ml-pipeline.html" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ir gy z fp mi fr fs mj fu fw ip bi translated">ML管道</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">\newcommand{\R}</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">spark.apache.org</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr la md"/></div></div></a></div><div class="ma mb gp gr mc md"><a href="https://spark.apache.org/docs/latest/ml-classification-regression.html" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ir gy z fp mi fr fs mj fu fw ip bi translated">分类和回归</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">\newcommand{\R}</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">spark.apache.org</p></div></div><div class="mm l"><div class="ms l mo mp mq mm mr la md"/></div></div></a></div><div class="ma mb gp gr mc md"><a href="https://spark.apache.org/docs/latest/ml-tuning.html" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ir gy z fp mi fr fs mj fu fw ip bi translated">ML Tuning - Spark 2.4.4文档</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">\newcommand{\R}</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">spark.apache.org</p></div></div><div class="mm l"><div class="mt l mo mp mq mm mr la md"/></div></div></a></div></div></div>    
</body>
</html>