<html>
<head>
<title>Explain to me Go Concurrency Worker Pool Pattern like I’m five</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向我解释Go并发工作池模式，就像我五岁时一样</h1>
<blockquote>原文：<a href="https://itnext.io/explain-to-me-go-concurrency-worker-pool-pattern-like-im-five-e5f1be71e2b0?source=collection_archive---------0-----------------------#2021-06-26">https://itnext.io/explain-to-me-go-concurrency-worker-pool-pattern-like-im-five-e5f1be71e2b0?source=collection_archive---------0-----------------------#2021-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d4ab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简单解释一下这个模式的所有组件如何协同工作来并发处理一批作业。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b22ccc32ee71b1a7726f850ea06744b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ya3fa36roBBhZlMl-kChXw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">并发工人池模式</figcaption></figure><h2 id="3a4e" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">介绍</h2><blockquote class="lr ls lt"><p id="e002" class="lu lv lw lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated"><strong class="lx ir">【TL；DR] </strong> <em class="iq">跳过简介，直接进入</em> <a class="ae mr" href="#fe56" rel="noopener ugc nofollow"> <em class="iq">实施细节</em> </a> <em class="iq">如果你想。</em></p></blockquote><p id="ff39" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">当我第一次接触Go语言时，我有点不喜欢它的语法和冗长。几个月后，我开始慢慢爱上了它的简单性、可读性、性能优势，以及比其他语言占用的内存少。</p><p id="b00d" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">我对这种语言特别感兴趣，因为它有丰富的并发模型。但是，尽管有“新语言蜜月”之类的东西，我也努力想弄清楚这种模式是如何工作的。</p><p id="58ca" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">因为我赶不上最后期限，所以我直接进入了模式实现的例子，而不是首先理解并发性的基础。<strong class="lx ir"> <em class="lw">错了！</em> </strong></p><p id="ee62" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">所以我强烈建议你们去看看这些文档，作为起点。尽管Go简单地处理并发性并不意味着编程并发代码就那么容易掌握。</p><p id="dabb" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">尽管如此，我会尽我所能在这里更口语化。我还为<a class="ae mr" href="https://github.com/godoylucase/workers-pool" rel="noopener ugc nofollow" target="_blank"><strong class="lx ir"><em class="lw">GitHub repo</em></strong></a>提供了该模式的实现，并测试了示例用法。</p><h1 id="fe56" class="ms kw iq bd kx mt mu mv la mw mx my ld jw mz jx lh jz na ka ll kc nb kd lp nc bi translated">实施细节</h1><blockquote class="lr ls lt"><p id="8a42" class="lu lv lw lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在继续之前有一件事值得一提:<em class="iq">这是</em> <strong class="lx ir"> <em class="iq">不是</em> </strong> <em class="iq">讲并发概念的帖子</em>，而是<strong class="lx ir">并发原生如何被编排以实现一组定义的作业的并发执行。</strong></p></blockquote><p id="531d" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">尽管如此，下图描述了这种模式的一般情况。下文将对幕后发生的事情进行更深入和详细的描述。(你也可以点击查看<a class="ae mr" href="https://drive.google.com/file/d/1yiOu9V3T8FsXSd0RbQVCguF-5IIHJhEh/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">的大图版本。为了更好的理解，我用我的爱为你做了这个！).</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/92dee42556c59e11d3a4b5a7476cf0a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xe4DmSW7U1PNY8vzryKZ6Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">WorkerPool组件编排</figcaption></figure><h2 id="13f5" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">1.作业批次</h2><p id="29ad" class="pw-post-body-paragraph lu lv iq lx b ly ne jr ma mb nf ju md le ng mg mh li nh mk ml lm ni mo mp mq ij bi translated">我创建了一个名为<code class="fe nj nk nl nm b">Job</code>的最小工作单元，由一个<code class="fe nj nk nl nm b">ExecutionFn</code>组成，让我们为返回一个<code class="fe nj nk nl nm b">Result</code>的<code class="fe nj nk nl nm b">Job</code>编写定制逻辑。后者可能是一辆<code class="fe nj nk nl nm b">value</code>或一辆<code class="fe nj nk nl nm b">error</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5790" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">第二步，我使用<code class="fe nj nk nl nm b">generator</code>并发模式将所有的<code class="fe nj nk nl nm b">Job</code>流入<code class="fe nj nk nl nm b">WorkerPool</code>。这是怎么回事？在一些客户定义的<code class="fe nj nk nl nm b">Job</code> s片上生成一个流，将它们推送到一个通道，即<code class="fe nj nk nl nm b">Job</code> s通道。其将用于同时进给<code class="fe nj nk nl nm b">WorkerPool</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="f7a1" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">2.作业的渠道</h2><p id="1fa6" class="pw-post-body-paragraph lu lv iq lx b ly ne jr ma mb nf ju md le ng mg mh li nh mk ml lm ni mo mp mq ij bi translated">它是一个缓冲通道(workers count capped ),一旦它被填满，任何进一步的写操作都将阻塞当前的goroutine(在这种情况下，流的生成器goroutine从1开始)。在任何时候，如果任何<code class="fe nj nk nl nm b">Job</code>出现在通道上，将被<code class="fe nj nk nl nm b">Worker</code>函数消耗，以便稍后执行。通过这种方式，通道将为来自前一点的<code class="fe nj nk nl nm b">generator</code>的新的<code class="fe nj nk nl nm b">Job</code>写入开放。</p><h2 id="a04a" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">3.工人池</h2><p id="145b" class="pw-post-body-paragraph lu lv iq lx b ly ne jr ma mb nf ju md le ng mg mh li nh mk ml lm ni mo mp mq ij bi translated">这是拼图的主要部分，这个实体由<code class="fe nj nk nl nm b">Result</code>、<code class="fe nj nk nl nm b">Job</code>和<code class="fe nj nk nl nm b">Done</code>通道组成，加上池将托管的<code class="fe nj nk nl nm b">Worker</code>的数量。它将在不同的goroutines上生成与工作线程数指示的一样多的<code class="fe nj nk nl nm b">Worker</code> s，也称为<strong class="lx ir"> <em class="lw">扇出</em> </strong>。</p><p id="8042" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">当<code class="fe nj nk nl nm b">Worker</code>可用时，他们自己将负责从渠道获取<code class="fe nj nk nl nm b">Job</code>。然后，他们执行<code class="fe nj nk nl nm b">Job</code>并将<code class="fe nj nk nl nm b">Result</code>发布到<code class="fe nj nk nl nm b">Result</code> s通道上。只要<code class="fe nj nk nl nm b">cancel()</code>函数没有被<code class="fe nj nk nl nm b">Context</code>调用，<code class="fe nj nk nl nm b">Worker</code>就会执行前面提到的操作。否则，回路制动且<code class="fe nj nk nl nm b">WaitGroup</code>标记为<code class="fe nj nk nl nm b">Done()</code>。这和想到<em class="lw">《杀死</em><code class="fe nj nk nl nm b"><em class="lw">Worker</em></code><em class="lw"/>颇为相似。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b3b4" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">在所有可用的<code class="fe nj nk nl nm b">Job</code>从其通道中取出后，<code class="fe nj nk nl nm b">WorkerPool</code>将通过关闭其自身的<code class="fe nj nk nl nm b">Done</code>和<code class="fe nj nk nl nm b">Result</code>通道来完成其执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="5aea" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">4.结果频道</h2><p id="7625" class="pw-post-body-paragraph lu lv iq lx b ly ne jr ma mb nf ju md le ng mg mh li nh mk ml lm ni mo mp mq ij bi translated">如前所述，即使工人在不同的goroutines上运行，他们也通过将<code class="fe nj nk nl nm b">Job</code>的执行<code class="fe nj nk nl nm b">Result</code>复用到<code class="fe nj nk nl nm b">Result</code>的通道上来发布它们，也就是<strong class="lx ir"> <em class="lw">扇入</em> </strong>。<code class="fe nj nk nl nm b">WorkerPool</code>的客户端可以从该源读取数据，即使通道因上述任何原因关闭。</p><h2 id="0e7e" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">5.阅读结果</h2><p id="e20f" class="pw-post-body-paragraph lu lv iq lx b ly ne jr ma mb nf ju md le ng mg mh li nh mk ml lm ni mo mp mq ij bi translated">只要缓冲通道上至少有一个客户端存在，<code class="fe nj nk nl nm b">WorkerPool</code>的客户端就可以读取<code class="fe nj nk nl nm b">Result</code> s通道。否则，从空的<code class="fe nj nk nl nm b">Result</code> s通道读取会阻塞客户端的goroutine，直到出现一个值或通道关闭。</p><p id="7e2f" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">一旦关闭的<code class="fe nj nk nl nm b">WorkerPool</code>的<code class="fe nj nk nl nm b">Done</code>通道返回并向前移动，for循环就会中断。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="7464" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">X.优雅地取消</h2><p id="1df1" class="pw-post-body-paragraph lu lv iq lx b ly ne jr ma mb nf ju md le ng mg mh li nh mk ml lm ni mo mp mq ij bi translated">在任何情况下，如果客户端需要优雅地关闭<code class="fe nj nk nl nm b">WorkerPool</code>执行，要么它可以根据给定的<code class="fe nj nk nl nm b">Context</code>调用<code class="fe nj nk nl nm b">cancel()</code>函数，要么已经配置了由with <code class="fe nj nk nl nm b">Context.WithTimeout</code>方法定义的超时持续时间。</p><p id="2355" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">无论一个或另一个选项发生(两者都结束调用<code class="fe nj nk nl nm b">cancel()</code>函数，一个显式地，另一个在超时发生后),一个关闭的<code class="fe nj nk nl nm b">Done</code>通道将从<code class="fe nj nk nl nm b">Context</code>返回，该通道将被传播到所有的<code class="fe nj nk nl nm b">Worker</code>函数。这使得<code class="fe nj nk nl nm b">for select</code>循环中断，因此<code class="fe nj nk nl nm b">Worker</code>停止消耗通道外的<code class="fe nj nk nl nm b">Job</code> s。随后，<code class="fe nj nk nl nm b">WaitGroup</code>被标记为完成。但是，运行的工人将在<code class="fe nj nk nl nm b">WorkerPool</code>关闭之前完成他们的工作。</p><h1 id="6685" class="ms kw iq bd kx mt mu mv la mw mx my ld jw mz jx lh jz na ka ll kc nb kd lp nc bi translated">总结</h1><p id="3ce9" class="pw-post-body-paragraph lu lv iq lx b ly ne jr ma mb nf ju md le ng mg mh li nh mk ml lm ni mo mp mq ij bi translated">当我们利用这种模式时，我们将利用我们的系统来实现并发的执行，从而在作业执行中获得更高的性能和一致性。</p><p id="9869" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">乍一看，这种模式可能很难理解。但是，请花时间来消化它，尤其是如果您是GoLang并发模型的新手。</p><p id="7cd8" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">有一件事可能会有所帮助，那就是将信道视为管道，数据从一端流向另一端，可容纳的数据量是有限的。因此，如果我们想注入更多的数据，我们只需要在等待时先取出一些数据，为它腾出一些额外的空间。反过来说，如果我们想从管道中消费，就必须有一些东西，否则，我们就等着它发生。通过这种方式，我们使用这些管道在<code class="fe nj nk nl nm b">goroutines</code>之间通信和共享数据。</p><h1 id="fdb0" class="ms kw iq bd kx mt mu mv la mw mx my ld jw mz jx lh jz na ka ll kc nb kd lp nc bi translated">资源</h1><p id="7ae2" class="pw-post-body-paragraph lu lv iq lx b ly ne jr ma mb nf ju md le ng mg mh li nh mk ml lm ni mo mp mq ij bi translated"><strong class="lx ir">【实现】</strong>该模式在本<a class="ae mr" href="https://github.com/godoylucase/workers-pool" rel="noopener ugc nofollow" target="_blank"><strong class="lx ir"><em class="lw">GitHub repo</em></strong></a><strong class="lx ir"><em class="lw">中完全实现。</em>T13】</strong></p><p id="038c" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated"><strong class="lx ir">【书】</strong>如果你有兴趣阅读关于并发主题的更多内容，我可以推荐一本书:<a class="ae mr" href="https://www.oreilly.com/library/view/concurrency-in-go/9781491941294/" rel="noopener ugc nofollow" target="_blank">Go中的并发——OReilly</a><br/>对我来说，当我面临这种使用并发方法解决的问题时，这是一个很好的资源。</p><p id="47a3" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated">感谢您的阅读，我希望您能发现这是有用的！</p><p id="33f5" class="pw-post-body-paragraph lu lv iq lx b ly lz jr ma mb mc ju md le mf mg mh li mj mk ml lm mn mo mp mq ij bi translated"><strong class="lx ir"> <em class="lw">【更新】</em> </strong> <em class="lw">我已经写了另一种实现这种模式的方法，但只是使用通道(没有更多的</em> <code class="fe nj nk nl nm b"><em class="lw">sync.WaitGroup</em></code> <em class="lw">)。你可以在这里找到:</em></p><div class="np nq gp gr nr ns"><a rel="noopener  ugc nofollow" target="_blank" href="/refactor-go-worker-pool-a-way-around-to-the-sync-package-7d45b1afb768"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">[Refactor]Go Worker Pool——一种绕过同步包的方法</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">通过使用信号量模式而不是sync.WaitGroup来同步工作线程执行。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">itnext.io</p></div></div><div class="ob l"><div class="oc l od oe of ob og kp ns"/></div></div></a></div></div></div>    
</body>
</html>