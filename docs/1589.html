<html>
<head>
<title>The intricacies of nesting navigators in React Native using react-navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用react-navigation在React Native中嵌套导航器的复杂性</h1>
<blockquote>原文：<a href="https://itnext.io/the-intricacies-of-nesting-navigators-in-react-native-using-react-navigation-fef52ca72964?source=collection_archive---------0-----------------------#2018-12-03">https://itnext.io/the-intricacies-of-nesting-navigators-in-react-native-using-react-navigation-fef52ca72964?source=collection_archive---------0-----------------------#2018-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/13d4ff39d61dd502a8e631bb920fddc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fHSUkLSz6Dw_ugee"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@andrewtneel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德鲁·尼尔</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="2868" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km jh">这是关于使用React Native为</strong><a class="ae jd" href="https://uncovercity.com/" rel="noopener ugc nofollow" target="_blank"><strong class="km jh">uncovercity</strong></a><strong class="km jh">构建iOS和Android应用程序的4部分系列文章中的最后一篇。你可以在这里找到其他的:</strong></p><ol class=""><li id="66ad" class="li lj jg km b kn ko kr ks kv lk kz ll ld lm lh ln lo lp lq bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/speeding-up-the-build-of-a-surprise-dinner-app-in-react-native-using-expo-2c18beabaaa7">使用Expo加速React Native中惊喜晚餐应用的构建</a></li><li id="d93e" class="li lj jg km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/battle-testing-a-ride-sharing-api-and-react-natives-mapview-in-expo-c0ce5d50cbf0?source=your_stories_page---------------------------">在Expo中对战测试拼车API和React Native的MapView</a></li><li id="0aa4" class="li lj jg km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated"><a class="ae jd" href="https://medium.com/@marcelkalveram/supporting-multiple-languages-in-react-native-with-expos-localization-module-9611f9e3b6a0" rel="noopener">通过Expo本地化在React Native中支持多种语言</a></li><li id="202c" class="li lj jg km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">使用react-navigation在React Native中嵌套导航器的复杂性</li></ol></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="2b6e" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在我最近的一个项目中，我使用React Native为西班牙初创公司<a class="ae jd" href="https://uncovercity.com/" rel="noopener ugc nofollow" target="_blank"> uncovercity </a>开发了原生应用。</p><p id="3df6" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我面临的最有趣的挑战之一是基于一组视觉设计建立导航结构。在这篇文章中，我将详细讨论它们，并向你介绍我提出的解决方案。</p><h1 id="9b50" class="lw lx jg bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">一切都从一棵树开始</h1><p id="a5a4" class="pw-post-body-paragraph kk kl jg km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh ij bi translated">以下要点说明了该应用程序的结构。我已经给了您一点提示，告诉您我对包含子路由的每个元素使用了哪种类型的导航器。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="c546" class="ni lx jg ne b gy nj nk l nl nm">- Main <strong class="ne jh">(StackNavigator)</strong><br/>  - Home<br/>  - Login<br/>  - Recover password<br/>  - Sidebar <strong class="ne jh">(DrawerNavigator)</strong><br/>    - Router <strong class="ne jh">(StackNavigator)</strong><br/>      - Experience<br/>      - Experience Map<br/>      - Experience Active<br/>      - Experience Active Detail<br/>      - Map<br/>      - Evaluation<br/>    - PastExperiences<br/>    - FAQ<br/>    - Contact</span></pre><p id="ec2e" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我一步一步带你穿过这棵树。</p><h2 id="8a43" class="ni lx jg bd ly nn no dn mc np nq dp mg kv nr ns mk kz nt nu mo ld nv nw ms nx bi translated">级别1:堆栈导航器—欢迎和登录屏幕</h2><p id="e074" class="pw-post-body-paragraph kk kl jg km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh ij bi translated">如您所见，根元素是一个<code class="fe ny nz oa ne b"><strong class="km jh">StackNavigator</strong></code>。由于前三个屏幕(主页、登录、恢复密码)只是在你从一个屏幕移动到下一个屏幕时一个接一个地显示，我们可以使用一个简单的<code class="fe ny nz oa ne b">StackNavigator</code>，它有一个很好的默认过渡(iOS上向左滑动，Android上向上滑动)。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8f157445ebd547818e91096fbf2be5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/1*iftff5iPBn7ioKAU_phrtw.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">运行中的堆栈导航器</figcaption></figure><h2 id="2d39" class="ni lx jg bd ly nn no dn mc np nq dp mg kv nr ns mk kz nt nu mo ld nv nw ms nx bi translated">级别2:抽屉导航器——侧边栏</h2><p id="3361" class="pw-post-body-paragraph kk kl jg km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh ij bi translated">下一个组件充当一组其他路由的容器。我们在这里使用<code class="fe ny nz oa ne b"><strong class="km jh">DrawerNavigator</strong></code>,这样用户可以使用触摸手势或屏幕左上角有争议的汉堡图标从左侧滑入侧边栏菜单。</p><p id="ce5b" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">从侧边栏，用户可以快速访问一些静态页面，如FAQ和Contact。但是默认情况下，它显示另一个容器元素，其中包含几个其他子路由，即<strong class="km jh">路由器</strong>。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1337036bc4f3fc85ba7dd544bb6b7fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/1*Q_YC9FUU9pNGxzm22X9faQ.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">运行中的抽屉导航器</figcaption></figure><h2 id="5836" class="ni lx jg bd ly nn no dn mc np nq dp mg kv nr ns mk kz nt nu mo ld nv nw ms nx bi translated">第3级:堆栈导航器—路由器</h2><p id="ec0a" class="pw-post-body-paragraph kk kl jg km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh ij bi translated">路由器是应用程序的核心，包含了大部分内容。在这里，用户可以看到她(晚餐)体验的当前状态，一个显示场地详细信息的屏幕，一个显示接送点的地图，以及一个让她在结束时对体验进行评级的评估屏幕。</p><p id="ee58" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这又是一个<code class="fe ny nz oa ne b"><strong class="km jh">StackNavigator</strong></code>，因为我们想在iOS和Android上使用默认过渡。但是路由器还包含一些额外的启动逻辑，我将在下面详细介绍。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b9a978f5f41dec042de43f524642c8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/1*apa-PiYw_qec1NxLwmMeLQ.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">运行中的嵌套堆栈导航器</figcaption></figure><h1 id="a706" class="lw lx jg bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">我在使用react-navigation时面临的挑战</h1><p id="9d4f" class="pw-post-body-paragraph kk kl jg km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh ij bi translated"><a class="ae jd" href="https://reactnavigation.org/" rel="noopener ugc nofollow" target="_blank"> React导航</a>简化了很多原生iOS和Android很难实现的东西。但它也有自己的一系列问题，其解决方案或变通办法并不总是直截了当的。</p><p id="8e47" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">以下是我遇到的不同问题以及我是如何解决它们的。</p><h2 id="12ac" class="ni lx jg bd ly nn no dn mc np nq dp mg kv nr ns mk kz nt nu mo ld nv nw ms nx bi translated">挑战#1:在DrawerNavigator中启用标题栏</h2><p id="4b75" class="pw-post-body-paragraph kk kl jg km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh ij bi translated"><code class="fe ny nz oa ne b">StackNavigator</code>有一个默认启用的标题栏。可以使用<code class="fe ny nz oa ne b">StackNavigator</code>的<a class="ae jd" href="https://reactnavigation.org/docs/en/stack-navigator.html#stacknavigatorconfig" rel="noopener ugc nofollow" target="_blank">视觉选项</a>上的<code class="fe ny nz oa ne b">headerMode: none</code>将其禁用。当您希望当前屏幕覆盖整个视窗，包括标题通常占据的空间时，这是可取的。</p><p id="9a63" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">不太直观的是，当你在一个<code class="fe ny nz oa ne b">DrawerNavigator</code>中，想要为它的所有子元素启用标题栏。<code class="fe ny nz oa ne b">DrawerNavigator</code>不像<code class="fe ny nz oa ne b">StackNavigator</code>那样提供可继承的<code class="fe ny nz oa ne b">headerMode</code>选项，因为它的目的不是给你一个可导航的屏幕堆栈，而是一个包含默认无标题屏幕的平面层次结构。</p><p id="3392" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了启用这些屏幕的标题栏，您需要用一个额外的<code class="fe ny nz oa ne b">StackNavigator</code>将它们包装起来。这将带回每个子屏幕的标题栏，尽管我们只有一个标题栏，并且实际上为了这个简单的目的滥用了<code class="fe ny nz oa ne b">StackNavigator</code>。虽然这看起来像是一个黑客，但它似乎仍然是大多数情况下最常见的解决方法。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="3044" class="ni lx jg ne b gy nj nk l nl nm">const One = <strong class="ne jh">StackNavigator</strong>(<br/>  {<br/>    main: { screen: Main } // only has one route<br/>  },<br/>  {<br/>    navigationOptions: {<br/>      <strong class="ne jh">headerMode: 'screen'</strong> // enabling header mode for main screen<br/>    }<br/>  }<br/>);</span><span id="f67f" class="ni lx jg ne b gy oe nk l nl nm">const AppNavigator = <strong class="ne jh">DrawerNavigator</strong>({<br/>  one: { screen: One },<br/>  two: { screen: Two }<br/>});</span></pre><h2 id="2bcc" class="ni lx jg bd ly nn no dn mc np nq dp mg kv nr ns mk kz nt nu mo ld nv nw ms nx bi translated">挑战2:从嵌套路由中切换侧边栏</h2><p id="dd9c" class="pw-post-body-paragraph kk kl jg km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh ij bi translated">接下来，我想知道如何从嵌套路由中的组件切换<code class="fe ny nz oa ne b">DrawerNavigator</code>的侧边栏。</p><p id="643f" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">自从React Navigation的2.0更新以来，您可以在<code class="fe ny nz oa ne b">navigation</code>属性上使用<code class="fe ny nz oa ne b">openDrawer</code>功能。但是这个属性并不是在每个组件中都可用的，除非你把它作为一个<code class="fe ny nz oa ne b">prop</code>传递下去，这有时意味着沿着一个长的组件链传递下去。</p><p id="7e2c" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">一个更简洁的解决方案(在<a class="ae jd" href="https://reactnavigation.org/docs/en/navigating-without-navigation-prop.html" rel="noopener ugc nofollow" target="_blank"> react-navigation的文档</a>中发现)是将<code class="fe ny nz oa ne b">DrawerNavigator</code>的引用存储在一个服务中，并在需要访问<code class="fe ny nz oa ne b">openDrawer</code>函数的任何地方导入它。这是服务的方法所做的事情:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="d85f" class="ni lx jg ne b gy nj nk l nl nm">function <strong class="ne jh">setTopLevelNavigator</strong>(navigatorRef) {<br/>  _navigator = navigatorRef;<br/>}</span><span id="e2df" class="ni lx jg ne b gy oe nk l nl nm">function <strong class="ne jh">openDrawer</strong>(routeName, params){<br/>  _navigator.dispatch(DrawerActions.openDrawer());<br/>}</span></pre><p id="01d0" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">呈现<code class="fe ny nz oa ne b">DrawerNavigator</code>的组件必须将导航器引用传递给<code class="fe ny nz oa ne b">setTopLevelNavigator</code>函数。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="76ce" class="ni lx jg ne b gy nj nk l nl nm">&lt;TopLevelNavigator<br/>  ref={<strong class="ne jh">navigatorRef</strong> =&gt; {<strong class="ne jh"><br/> </strong>   NavigationService.setTopLevelNavigator(<strong class="ne jh">navigatorRef</strong>);<br/>  }}<br/>/&gt;</span></pre><p id="ad37" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在你可以简单地从任何地方调用<code class="fe ny nz oa ne b">navigate</code>函数来访问<code class="fe ny nz oa ne b">DrawerNavigator</code>的<code class="fe ny nz oa ne b">openDrawer</code>方法:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="f81a" class="ni lx jg ne b gy nj nk l nl nm">NavigationService.<strong class="ne jh">openDrawer</strong>();</span></pre><blockquote class="of og oh"><p id="f2a1" class="kk kl oi km b kn ko kp kq kr ks kt ku oj kw kx ky ok la lb lc ol le lf lg lh ij bi translated">您也许可以使用React的上下文API(React 16.3中引入的)或使用Redux或Mobx来完成相同的任务，但是在编写这段代码时，这似乎是最简单的解决方案，没有引入任何开销。</p></blockquote><h2 id="14ee" class="ni lx jg bd ly nn no dn mc np nq dp mg kv nr ns mk kz nt nu mo ld nv nw ms nx bi translated">挑战#3:将经过身份验证的用户带到用户区</h2><p id="0644" class="pw-post-body-paragraph kk kl jg km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh ij bi translated">如果你是一名注册用户，并且之前已经登录过该应用程序，显然你希望下次回来时被视为已登录用户。</p><p id="f123" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">回到上面概述的导航树，这意味着将她从根导航器(主)带到嵌套在路由器堆栈中的一个屏幕。相当大的飞跃！</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="fffe" class="ni lx jg ne b gy nj nk l nl nm"><strong class="ne jh">Main</strong> <strong class="ne jh">-&gt;</strong> Sidebar <strong class="ne jh">-&gt;</strong> Router <strong class="ne jh">-&gt;</strong> <strong class="ne jh">Experience<br/>     -&gt; Login</strong></span></pre><p id="72e9" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在<strong class="km jh"> Main </strong>中，我们从手机的本地存储中获取用户的当前状态(<code class="fe ny nz oa ne b">AsyncStorage</code>)。如果用户<em class="oi">登录了</em>，它将包含一个包含用户详细信息(ID、电子邮件、姓名)的对象，我们将她带到下一个级别，<strong class="km jh">侧栏。</strong>如果她<em class="oi">未</em>登录，她将转到<strong class="km jh">登录</strong>屏幕。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="a8fc" class="ni lx jg ne b gy nj nk l nl nm">const user = await <strong class="ne jh">AsyncStorage</strong>.getItem('user');</span></pre><p id="35c9" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">因为它是一个<code class="fe ny nz oa ne b">async</code>函数，我们需要在渲染外部导航器之前等待它完成，所以我们在渲染函数中返回一个加载屏幕，并且我们只在<code class="fe ny nz oa ne b">AsyncStorage</code>操作完成后将<code class="fe ny nz oa ne b">loading</code>设置为true。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="bd49" class="ni lx jg ne b gy nj nk l nl nm">if (this.state.loading) {<br/>  return &lt;<strong class="ne jh">LoadingScreen</strong> /&gt;;<br/>}</span></pre><p id="18e1" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在我们第二级导航器的<code class="fe ny nz oa ne b">navigationOptions</code>(<strong class="km jh">侧栏</strong>)中，我们根据用户的登录状态将<code class="fe ny nz oa ne b">initialRouteName</code>设置为导航层级中的下一个屏幕。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="446c" class="ni lx jg ne b gy nj nk l nl nm">const Navigator = createStackNavigator({<br/>   ...routesObject...<br/>  }, <br/>    {<br/>      <strong class="ne jh">initialRouteName</strong>: (this.props.loggedIn) ? '<strong class="ne jh">Sidebar</strong>' : '<strong class="ne jh">Login</strong>',<br/>    },<br/>});</span></pre><p id="889a" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在<strong class="km jh">侧栏</strong>中，我们接着进入初始路由<strong class="km jh">路由器</strong>，其同级路由器可通过<code class="fe ny nz oa ne b">DrawerNavigator</code>访问。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="f185" class="ni lx jg ne b gy nj nk l nl nm">const Drawer = createDrawerNavigator({<br/>  <strong class="ne jh">Router</strong>: { screen: <strong class="ne jh">Router</strong> }, // another StackNavigator in here<br/>  <strong class="ne jh">PastExperiences</strong>: { screen: PastExperiencesScreen },<br/>  <strong class="ne jh">FAQ</strong>: { screen: FaqScreen },<br/>  <strong class="ne jh">Contact</strong>: { ContactScreen }<br/>})</span></pre><p id="14e5" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">然而，我们向用户显示的屏幕取决于用户体验的当前状态。体验细节是后续API请求的一部分，只有在用户登录后才会解决。</p><p id="5ea7" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这导致了我必须解决的另外几个路由问题，这是我接下来要讨论的。</p><h2 id="2d53" class="ni lx jg bd ly nn no dn mc np nq dp mg kv nr ns mk kz nt nu mo ld nv nw ms nx bi translated">挑战#4:在不破坏用户体验的情况下，显示基于API响应的嵌套屏幕</h2><p id="9d98" class="pw-post-body-paragraph kk kl jg km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh ij bi translated">最后但同样重要的是，我必须解决一个与应用程序如何与API交互相关的问题。在<strong class="km jh">路由器</strong>内部，用户看到的屏幕基于来自拼车服务的API响应。</p><p id="b228" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">用户看到以下之一:<strong class="km jh">接送</strong>、<strong class="km jh">返回</strong>、<strong class="km jh">地图</strong>或<strong class="km jh">评估、</strong>基于带她去餐馆并返回的乘坐装置的当前状态。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="c352" class="ni lx jg ne b gy nj nk l nl nm">Main -&gt; Sidebar -&gt; <strong class="ne jh">Router</strong> -&gt; Pickup screen<br/>                          -&gt; Map<br/>                          -&gt; Return screen<br/>                          -&gt; Evaluation</span></pre><p id="6003" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这在理论上听起来很容易，但我必须注意三件事，以防止应用程序的UX感到尴尬和困惑:</p><ul class=""><li id="080c" class="li lj jg km b kn ko kr ks kv lk kz ll ld lm lh om lo lp lq bi translated">首先，我必须只渲染初始屏幕<em class="oi">一次</em>。因为我们依靠<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/battle-testing-a-ride-sharing-api-and-react-natives-mapview-in-expo-c0ce5d50cbf0">轮询</a>来获取API更新，所以每个后续的更新都不应该重新渲染路由器，否则会导致非常讨厌的闪烁效果。</li><li id="4b9a" class="li lj jg km b kn lr kr ls kv lt kz lu ld lv lh om lo lp lq bi translated">其次，我必须确保在调用初始路线或打开应用程序之前获得拼车更新，这将总是导致从初始屏幕(接送)到当前屏幕(地图、返回或评估)的转换。</li><li id="52e3" class="li lj jg km b kn lr kr ls kv lt kz lu ld lv lh om lo lp lq bi translated">第三，我必须考虑到，用户可能会在一段时间内对应用程序进行后台处理，一旦他们回到应用程序，当前屏幕的更新就会被触发，以防其间发生任何变化。</li></ul><p id="1c39" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km jh">第一期</strong>，我用了<code class="fe ny nz oa ne b">shouldComponentUpdate</code>，写了一些逻辑，只在实际路线改变的情况下更新屏幕。这帮助我摆脱了闪烁效应，尽管我最近了解到<code class="fe ny nz oa ne b">shouldComponentUpdate</code>实际上不应该被<a class="ae jd" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">滥用于这种目的</a>。</p><p id="87a8" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km jh">对于第二个问题</strong>，我必须请求对API做一点小小的修改，以便在来自服务器的<em class="oi">初始</em>响应中返回用户的状态(最初并不是为此目的而设计的)。但在评估响应之前，我还必须确保屏幕不会出现。所以我不得不使用我在挑战2中已经用过的技术，只要组件生命周期中正在执行其他逻辑，就返回一个<code class="fe ny nz oa ne b">LoadingScreen</code>。</p><p id="4e85" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">对于那些生活在技术前沿的人来说，<a class="ae jd" href="https://blog.logrocket.com/async-rendering-in-react-with-suspense-5d0eaac886c8" rel="noopener ugc nofollow" target="_blank"> React悬念</a>将在未来帮助实现这种异步渲染。</p><p id="98a4" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km jh">对于第三个问题</strong>(到目前为止最棘手的)，我必须将路由器包装在另一个React组件中，以确保在应用程序后台化后进行更新。</p><p id="0550" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">因为我之前提到的预防逻辑(<code class="fe ny nz oa ne b">shouldComponentUpdate</code>)也让用户停留在当前屏幕上，所以我必须确保包含路由器的组件在发生更新时呈现一个新的路由器。</p><p id="2823" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这大概就是无状态功能组件的样子。它在两种情况下创造了一个新的<code class="fe ny nz oa ne b">StackNavigator</code>:</p><ul class=""><li id="44ff" class="li lj jg km b kn ko kr ks kv lk kz ll ld lm lh om lo lp lq bi translated"><code class="fe ny nz oa ne b">initialRouteName</code>变了</li><li id="2f70" class="li lj jg km b kn lr kr ls kv lt kz lu ld lv lh om lo lp lq bi translated">以前没有定义过<code class="fe ny nz oa ne b">RouterStack</code>。</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="1ed3" class="ni lx jg ne b gy nj nk l nl nm">let RouterStack;<br/>let lastRouteName</span><span id="d5f1" class="ni lx jg ne b gy oe nk l nl nm">const <strong class="ne jh">RouterStackWithInitialRoute</strong> = ({ initialRouteName }) =&gt; {<br/>  if (RouterStack === null || lastRouteName !== initialRouteName) {<br/>    lastRouteName = initialRouteName;<br/>    <strong class="ne jh">RouterStack</strong> = createStackNavigator(<br/>      require('../../../constants/routeConfig').default,<br/>      {<br/>        initialRouteName,<br/>      });<br/>     }<br/>  return &lt;<strong class="ne jh">RouterStack</strong> /&gt;;<br/>};</span></pre><p id="53bd" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">将初始路由名传递给该组件，如下所示:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="1d1b" class="ni lx jg ne b gy nj nk l nl nm">render() {<br/>  return this.state.loading ?<br/>    &lt;LoadingScreen /&gt; :<br/>    &lt;RouterStackWithInitialRoute <br/>      <strong class="ne jh">initialRouteName={this.state.initialRouteName}</strong> /&gt;;<br/>}</span></pre><p id="009b" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在，每次用户回到应用程序，她都会立即看到与当前体验状态相对应的屏幕。</p><blockquote class="of og oh"><p id="53b3" class="kk kl oi km b kn ko kp kq kr ks kt ku oj kw kx ky ok la lb lc ol le lf lg lh ij bi translated">请记住，所有代码示例都只是对实际代码的简化，以说明我想要表达的观点。因此，如果您试图复制/粘贴它们中的任何一个，也不能保证它们会正常工作:)</p></blockquote><h1 id="bb08" class="lw lx jg bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">在React Native中构建一个看似简单的移动应用的心得</h1><p id="5d12" class="pw-post-body-paragraph kk kl jg km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh ij bi translated">这就是我为非覆盖性构建移动应用系列的全部内容。</p><p id="e87d" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我不得不承认，从最初的用户旅程来看，我没有预料到表面上看起来如此简单的东西会如此复杂。我可能也不总是能为这些问题中的每一个提出最优雅的解决方案。</p><p id="7247" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">但是考虑到所有可能的用户场景和在现实生活条件下项目中出现的API问题，很容易低估像这样的项目需要付出的努力。</p><p id="ca87" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果你必须处理第三方API、社区驱动的库和像React Native这样的尖端技术，那么发布一个经过战斗测试、没有错误的移动应用程序的实际工作可能会呈指数级增长。</p><p id="8cd2" class="pw-post-body-paragraph kk kl jg km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果你碰巧在西班牙，你可以在<a class="ae jd" href="https://itunes.apple.com/us/app/uncovercity/id1394531362?l=es&amp;ls=1&amp;mt=8" rel="noopener ugc nofollow" target="_blank"> iOS </a>和<a class="ae jd" href="https://play.google.com/store/apps/details?id=com.uncovercity.app&amp;hl=de" rel="noopener ugc nofollow" target="_blank">谷歌</a>应用商店找到这款应用。请务必在上预订一张桌子，以获得完整的应用程序体验:)</p></div></div>    
</body>
</html>