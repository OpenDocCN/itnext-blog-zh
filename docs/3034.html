<html>
<head>
<title>Don’t think about rotation of the screen. Moxy fixes the problem.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要考虑屏幕的旋转。Moxy解决了这个问题。</h1>
<blockquote>原文：<a href="https://itnext.io/dont-think-about-rotation-of-the-screen-moxy-fix-the-problem-e861d52a0d12?source=collection_archive---------4-----------------------#2019-09-18">https://itnext.io/dont-think-about-rotation-of-the-screen-moxy-fix-the-problem-e861d52a0d12?source=collection_archive---------4-----------------------#2019-09-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="15c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大家好。如果你是一名android开发人员，你会知道屏幕旋转是Android世界中最大的问题之一。当用户旋转屏幕时，视图被破坏。我们不能改变这一点，因为这是android操作系统的默认行为。或者，我们能做什么？</p><h2 id="f7cb" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">主要思想</h2><p id="9595" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">这个问题有一个简单的解决方法。我非常喜欢简单的解决方案；我的团队成员都知道。我们不能改变操作系统的行为。Android在用户旋转设备时会破坏你的活动和碎片。然而，我们可以创建一个对象，当用户旋转设备时，它仍然存在。将视图中的所有逻辑移动到该类中。</p><p id="2929" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们需要做下一步:保存presenter在视图上调用的所有方法，并在新的视图对象上重新调用它们。我们称这个类为视图状态。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/1361ec58810f16cefebd2829f7c0a99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PpM8b9BJsDfJkkTNe5Ii8w.gif"/></div></div></figure><h1 id="b0b2" class="ly kp it bd kq lz ma mb kt mc md me kw mf mg mh kz mi mj mk lc ml mm mn lf mo bi translated">解决办法</h1><p id="daf0" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">Moxy是一个帮助在android项目中实现MVP UI模式的库。</p><h2 id="65e9" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">视图状态</h2><p id="8279" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">ViewState是一个实现视图接口的对象。Moxy将视图状态字段注入到演示者中。另外，演示者可以访问所有视图方法，但不能访问上下文。</p><h2 id="c5de" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">查看者和演示者</h2><p id="655d" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">Moxy为活动和片段提供了基类。Moxy拥有所有活动和片段的父类。您的视图接口必须从MvpView扩展。演示者必须从多视图演示者<yourviewinterface/></p><h2 id="5b12" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">提出者</h2><p id="0eff" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">MvpPresenter有一个受保护的方法getViewState()，该方法返回实现视图接口的对象的实例。<br/> MvpPresenter有一个开放的受保护方法onFirstViewAttach()。当视图第一次附加到演示者时，将调用此方法。我建议重写该方法，并将其用于执行加载数据的调用。</p><h2 id="5e0b" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">样品</h2><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d526" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时android os会恢复视图状态。Moxy有处理所有情况的策略。</p><h2 id="d82d" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">AddToEndSingleStrategy</h2><p id="408a" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">最受欢迎的策略。该策略重新调用演示者在视图状态上调用的每个方法。但是，如果演示者不止一次调用一个方法，该方法将使用最后一个参数重新调用一次。这意味着新视图具有最后的状态。<br/>例如，演示者调用一个方法“printLog(“1”)，然后printLog(“2”)，在屏幕旋转后，视图状态将只调用带有参数“2”的方法。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mr"><img src="../Images/fdc801c23ab06a6a3d99c896f88ea712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAFgbYU-pCDwyJ43mgWhrA.png"/></div></div></figure><h2 id="2366" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">一个执行策略</h2><p id="00e8" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">我只对显示片段或开始活动的方法使用这种策略。因为android os处理这种情况不需要帮助。使用这种策略的方法只会被调用一次。如果此时视图不存在，演示者调用ViewState上的方法，该方法将在新视图上调用。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ms"><img src="../Images/c1a5dab00b1ed3c1752c33ee67bb393f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61g_GNdj6WQ9PXo7Fr0MVQ.png"/></div></div></figure><h2 id="1fb9" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">skip战略</h2><p id="7167" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">该策略类似于OneExecutionStrategy。该方法将被调用一次，或者根本不被调用。该方法不会保存到视图状态中。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi ms"><img src="../Images/f506168fc7b6b7fb94d19df88cedf00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0n_Dh33WrAlkT6Wx9ukWig.png"/></div></div></figure><h2 id="cff0" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">AddToEndSingleTagStrategy</h2><p id="f775" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">我对互斥方法使用这种策略。比如“showProgress()”和“hideProgress()”。例如，演示者调用“showProgress()”,然后调用“hideProgress()”。该策略仅在屏幕旋转后重新调用“hideProgress()”。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="27a6" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">AddToEndStrategy</h2><p id="a926" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">我不使用AddToEndStrategy，也不推荐你使用。该策略为每个新视图实例重新调用所有方法。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mt"><img src="../Images/0726729a6633f2c3e0b7f5447183e7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OMqbmxHz5y5QCoYKCSGSBg.png"/></div></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="2b53" class="ly kp it bd kq lz nb mb kt mc nc me kw mf nd mh kz mi ne mk lc ml nf mn lf mo bi translated">在后台</h1><p id="ec1f" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">它是如何工作的？</p><p id="bbb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Moxy使用代码生成。Moxy为每个视图方法生成一个命令类，为每个视图接口生成一个视图状态类。视图状态实现了您的视图接口。Moxy在编译时生成视图状态。基本演示者中的字段视图状态将由生成的类的实例初始化。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mp mq l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="8ed3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">访问github 上的<a class="ae nh" href="https://github.com/moxy-community/Moxy" rel="noopener ugc nofollow" target="_blank"> Moxy库，如果你用简单的方法解决困难的任务，就打一颗星。</a></p><p id="45cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编辑:<a class="ni nj ep" href="https://medium.com/u/3775b139ac75?source=post_page-----e861d52a0d12--------------------------------" rel="noopener" target="_blank"> Vova Usachov </a></p><p id="531b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae nh" href="https://schoolhelper.tech/2019/09/10/dont-think-about-rotation-of-the-screen-moxy-fixes-the-problem/" rel="noopener ugc nofollow" target="_blank">发表在我的网站上</a></p></div></div>    
</body>
</html>