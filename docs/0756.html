<html>
<head>
<title>Understanding provider scope in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Angular中的提供者范围</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-provider-scope-in-angular-4c2589de5bc?source=collection_archive---------0-----------------------#2018-05-22">https://itnext.io/understanding-provider-scope-in-angular-4c2589de5bc?source=collection_archive---------0-----------------------#2018-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f7a3de43ead2252f9cca9e427b717215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2M9gGIbk5m5Fo3QOGgtTg.png"/></div></div></figure><p id="b537" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务是每个Angular应用程序的基本模块之一。Service只是一个有或者没有<strong class="ka ir"> @Injectable </strong> decorator的TypeScript类。</p><p id="13d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建服务，我们需要做的就是创建一个类</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="511d" class="lf lg iq lb b gy lh li l lj lk">export class VoteService {}</span></pre><p id="241d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并注册到<strong class="ka ir"> @NgModule </strong>的providers数组中</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="312a" class="lf lg iq lb b gy lh li l lj lk">import {VoteService} from './vote.service';</span><span id="bea8" class="lf lg iq lb b gy ll li l lj lk">...<br/>@NgModule({<br/>  imports:      [ BrowserModule],<br/>  declarations: [ AppComponent],<br/>  bootstrap:    [ AppComponent],<br/>  providers: [VoteService]<br/>})</span></pre><p id="5989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二种方式(在Angular 6中更受欢迎)是使用<code class="fe lm ln lo lb b">@Injectable</code>装饰器并在属性中指定<strong class="ka ir">provided</strong></p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6261" class="lf lg iq lb b gy lh li l lj lk">import { Injectable } from '@angular/core';</span><span id="ff9b" class="lf lg iq lb b gy ll li l lj lk">@Injectable({   <br/>  providedIn: 'root', <br/>}) <br/>export class VoteService { }</span></pre><p id="ed18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“根”意味着我们希望在根级别(AppModule)提供服务</p><blockquote class="lp lq lr"><p id="3a11" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated">当您在根级别提供服务时，Angular会创建一个服务的共享实例，并注入到任何请求它的类中。在<code class="fe lm ln lo lb b">@Injectable</code>元数据中注册服务提供者也允许Angular通过删除服务来优化一个应用程序，如果它最终没有被使用的话。</p></blockquote><p id="7be7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是事情变得更有趣的地方。当您将服务提供者添加到根模块(根注入器)时，它可用于整个应用程序。这意味着，如果你有一个在providers中带有服务的特性模块，并且该服务也在root模块中提供，在这种情况下，两个模块将使用相同的服务实例(singleton模式)。因此，请记住，无论何时向根模块添加服务，该服务在整个应用程序中都是可用的，并且所有组件/指令都可以访问该服务的同一个实例，除非功能模块是懒惰的。</p><p id="5d56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用代码来看看这个。我们有一个在根模块(<code class="fe lm ln lo lb b">AppModule</code>)中提供的<code class="fe lm ln lo lb b">VoteService </code></p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="9559" class="lf lg iq lb b gy lh li l lj lk">import { Injectable } from '@angular/core';</span><span id="482f" class="lf lg iq lb b gy ll li l lj lk">@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class VoteService {<br/>  votes: number = 10;</span><span id="67ae" class="lf lg iq lb b gy ll li l lj lk">  constructor() { }</span><span id="fe04" class="lf lg iq lb b gy ll li l lj lk">  getVotes() {<br/>    return this.votes;<br/>  }</span><span id="a718" class="lf lg iq lb b gy ll li l lj lk">  setVotes(vote: number) {<br/>      this.votes = vote;<br/>  }<br/>}</span></pre><p id="da09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这里我们有一个简单的带有<code class="fe lm ln lo lb b">votes</code>属性和两个方法的服务。一个用于获取属性值，另一个用于设置新值。初始值设置为10</p><p id="d4bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们在app.component中注入我们的服务，并显示<code class="fe lm ln lo lb b">votes</code>的值</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c829" class="lf lg iq lb b gy lh li l lj lk">@Component({<br/>  selector: 'my-app',<br/>  template: `app component - {{votes}}`<br/>})<br/>export class AppComponent  {<br/>  votes: any;</span><span id="ca49" class="lf lg iq lb b gy ll li l lj lk">constructor(private vt: VoteService) {}<br/>  <br/>  ngOnInit() {<br/>    this.votes = this.vt.getVotes()<br/>    this.vt.setVotes(25);<br/>  }<br/>}</span></pre><p id="9983" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们在构造函数中注入我们的服务，将来自服务的投票值赋给组件变量，并设置新值。到目前为止，我们将在浏览器中看到这一点</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="84f1" class="lf lg iq lb b gy lh li l lj lk">app component - 10</span></pre><p id="f25f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">10是最初设置的值。现在让我们创建一个功能模块(不是懒惰的)并提供<code class="fe lm ln lo lb b">VoteService</code></p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="2c44" class="lf lg iq lb b gy lh li l lj lk">@NgModule({<br/>  imports: [CommonModule],<br/>  declarations: [FeatureComponent],<br/>  exports: [FeatureComponent],<br/>  providers: [VoteService]<br/>})<br/>export class FeatureModule { }</span></pre><p id="0be2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<code class="fe lm ln lo lb b">FeatureModule </code>是在根模块(AppModule)中导入的。所以在<code class="fe lm ln lo lb b">FeatureComponent </code>中我们也可以注入<strong class="ka ir"> VoteService </strong>并得到<code class="fe lm ln lo lb b">votes</code>的值</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="72a3" class="lf lg iq lb b gy lh li l lj lk">@Component({<br/>  selector: 'app-fac',<br/>  template: `{{votes}}`<br/>})<br/>export class FeatureComponent implements OnInit {<br/>  votes: number;<br/>  constructor(private vt: VoteService) { }</span><span id="9b41" class="lf lg iq lb b gy ll li l lj lk">ngOnInit() {<br/>    this.votes = this.vt.getVotes()<br/>  }<br/>}</span></pre><p id="89c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们修改<code class="fe lm ln lo lb b">AppComponent</code>模板做显示<code class="fe lm ln lo lb b">FeatureComponent</code></p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="cefa" class="lf lg iq lb b gy lh li l lj lk">template: `app component - {{votes}}<br/>           &lt;br&gt;<br/>           feature component - &lt;app-fac&gt;&lt;/app-fac&gt;`</span></pre><p id="16d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果我们会看到</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="9d1b" class="lf lg iq lb b gy lh li l lj lk">app component - 10<br/>feature component - 25</span></pre><p id="585e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么这样原因是app组件和feature组件都在使用同一个<code class="fe lm ln lo lb b">VoteService</code>实例。让我们看看这是如何工作的。</p><ol class=""><li id="8dec" class="lw lx iq ka b kb kc kf kg kj ly kn lz kr ma kv mb mc md me bi translated">我们的模块(AppModule和FeatureModule)在其提供者中都有<code class="fe lm ln lo lb b">VoteService</code></li></ol><p id="524e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.因为我们将FeatureModule导入到AppModule，并且两者都有一个具有相同令牌(相同服务)的提供者，所以AppModule胜出。这是因为两个提供者被添加到同一个注入器中。</p><blockquote class="lp lq lr"><p id="3987" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated">Angular使用喷射系统。当在应用程序启动时加载根模块时，来自所有导入模块的所有提供者都被添加到根注入器，这就是为什么它们在整个应用程序中都是可访问的。</p></blockquote><p id="b1f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们导入两个提供相同服务的模块时，第二个模块总是胜出，因为它是最后添加的。</p><p id="b4d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.在app.component中，当我们注入<code class="fe lm ln lo lb b">VoteService </code> Angular时，开始在该组件中搜索提供者，然后按层次向上搜索，直到在根模块(根注入器)中找到它。之后，Angular检查是否有实例。如果没有，新的实例将被创建并返回到app.component。这就是为什么当我们在feature.component中注入<code class="fe lm ln lo lb b">VoteService</code>时，我们实际上使用了已经创建的类的实例，因此我们得到了25票而不是最初的10票。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/07353252a62b7fc7fed4e31b5ac3f63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BrPOg9x0qDtBPl8X-oPlw.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">提供者范围的可视化表示</figcaption></figure><h2 id="1839" class="lf lg iq bd mk ml mm dn mn mo mp dp mq kj mr ms mt kn mu mv mw kr mx my mz na bi translated">懒惰模块怎么办？</h2><p id="90fd" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">当我们使用懒惰模块时，事情变得更加有趣。惰性模块是使用惰性加载的模块。这意味着只有在真正需要的时候才加载模块。例如，在你的网站上有一个关于“新产品”的页面，但是用户很少访问这个页面。你可以拆分你的应用程序的逻辑，创建一个懒惰的模块来负责那个页面，这样你的应用程序会启动得更快，因为一个模块只有在有人访问那个页面的时候才会被加载。</p><p id="5ea9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建一个懒惰模块，我们需要使用路由。因此，让我们在AppModule中配置应用程序路由</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8c46" class="lf lg iq lb b gy lh li l lj lk">RouterModule.forRoot([{<br/>      path: 'lazy', <br/>      loadChildren : './lm/lazy.module#LazyModule'<br/>    }])</span></pre><p id="d2c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们说如果URL的路径将是<code class="fe lm ln lo lb b">/lazy </code>加载这个模块，我们提供我们的懒惰模块的相对路径。不要忘记创建那个模块。您可以使用CLI生成一个模块— <code class="fe lm ln lo lb b">ng generate module lazy</code>。我们不在根模块中导入懒惰模块。</p><p id="2de7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要在<strong class="ka ir"> LazyModule </strong>中配置路由。所以在<em class="ls">导入</em>数组的<strong class="ka ir"> LazyModule </strong>里面我们可以这样做</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="280c" class="lf lg iq lb b gy lh li l lj lk">RouterModule.forChild([{<br/>        path: '', component: LazyComponent<br/>      }])</span></pre><p id="0321" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为路径，我们使用空字符串，因为在AppModule中我们已经提供了一个路由。还要注意，我们用<strong class="ka ir">代替<strong class="ka ir">表示根</strong>表示孩子。</strong></p><p id="1028" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，现在我们有了懒惰模块和激活该模块的路径。让我们添加一些可以改变路线的按钮。</p><p id="0ee9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更改app.component的模板</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b8ce" class="lf lg iq lb b gy lh li l lj lk">@Component({<br/>  selector: 'my-app',<br/>  template: `app component - {{votes}}&lt;br&gt;<br/>      &lt;button routerLink='lazy'&gt;lazy load module&lt;/button&gt;<br/>  <br/>    &lt;button (click)="refresh()"&gt;refresh&lt;/button&gt;<br/>    &lt;router-outlet&gt;&lt;/router-outlet&gt;<br/>  `<br/>})<br/>...</span></pre><p id="c7a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们仍然显示来自我们服务的<code class="fe lm ln lo lb b">votes </code> count，但是我们也添加了2个按钮，一个用于更改路线和加载我们的惰性模块，另一个用于刷新<code class="fe lm ln lo lb b">votes </code>属性。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5039" class="lf lg iq lb b gy lh li l lj lk">refresh() {<br/>    this.votes = this.vt.getVotes()<br/>  }</span></pre><p id="ddec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，让我们为我们的懒惰组件创建一个模板</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="31e1" class="lf lg iq lb b gy lh li l lj lk">...<br/>template: `&lt;br&gt;lazy component - {{votes}} <br/>   &lt;button routerLink='/'&gt;back to app component&lt;/button&gt;`<br/>...</span></pre><p id="3de0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在我们的<strong class="ka ir"> LazyModule </strong>中，我们还提供了<code class="fe lm ln lo lb b">VoteService</code>。该服务被注入到<strong class="ka ir"> LazyComponent </strong>中，因此我们可以创建一个<code class="fe lm ln lo lb b">votes</code>变量，并使用它来显示来自<code class="fe lm ln lo lb b">VoteService</code>的投票数</p><p id="15ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是将要发生的事情。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/180a688dbe5315f9ae5d813c1616a8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zTmF2kqhmKzsUm6PXZ7frA.gif"/></div></div></figure><p id="d656" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最初<code class="fe lm ln lo lb b">votes</code>的值是10。当我们延迟加载一个模块时，这个值又是10，而不是25。当我们刷新时，<code class="fe lm ln lo lb b">votes</code>的值只对app.component改变，对lazy.component它保持10。现在让我们更详细地看看</p><ol class=""><li id="3566" class="lw lx iq ka b kb kc kf kg kj ly kn lz kr ma kv mb mc md me bi translated">我们有两个模块(AppModule和LazyModule)提供相同的服务。</li><li id="d140" class="lw lx iq ka b kb nh kf ni kj nj kn nk kr nl kv mb mc md me bi translated">当应用程序启动时，根注入器由来自所有模块的所有服务创建。然而，由于我们的模块是懒惰的，Angular不知道我们的懒惰模块的存在。这意味着在我们的LazyModule的providers数组中列出的任何服务都是不可用的，因为根注入器还不知道LazyModule。当我们激活路由时，将加载惰性模块并创建新的注入器。想象一个注入器树，顶部是根注入器，对于每个懒惰模块，将创建新的<em class="ls">子注入器</em>。</li><li id="c99a" class="lw lx iq ka b kb nh kf ni kj nj kn nk kr nl kv mb mc md me bi translated">根注入器中的所有服务都将添加到子注入器中。如果根注入器和子注入器提供相同的服务，Angular优先选择来自<em class="ls">子注入器的服务实例。</em>所以每个懒惰组件都获得服务的本地实例，而不是根应用注入器中的实例。这就是为什么当我们刷新状态时，只有app.component的<code class="fe lm ln lo lb b">votes</code>发生了变化，因为lazy.component正在与服务的另一个实例一起工作。</li></ol><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/f417f0b7816371443491335f55c89e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJ_PubfYe2_f_ujRyJPhzQ.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">用惰性模块限制提供者的范围</figcaption></figure><p id="dcb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以快速回顾一下</p><ol class=""><li id="bc90" class="lw lx iq ka b kb kc kf kg kj ly kn lz kr ma kv mb mc md me bi translated">如果我们有几个提供相同服务的特性模块，那么只有最后一个模块的服务会被添加到根注入器中</li><li id="fec0" class="lw lx iq ka b kb nh kf ni kj nj kn nk kr nl kv mb mc md me bi translated">如果我们有几个提供相同服务的功能模块，并且该服务是在AppModule(根模块)中提供的，那么只有从AppModule创建的实例才会被添加到根注入器中。因此，即使FeatureModules的组件也将使用来自AppModule的服务实例</li><li id="b715" class="lw lx iq ka b kb nh kf ni kj nj kn nk kr nl kv mb mc md me bi translated">如果我们有不提供服务的懒惰模块，它将使用从根注入器(AppModule)创建的实例</li><li id="32e9" class="lw lx iq ka b kb nh kf ni kj nj kn nk kr nl kv mb mc md me bi translated">但是如果懒惰模块确实提供了服务，那么该模块的组件将使用该服务的本地实例(而不是来自根注入器的实例)</li></ol><h2 id="f059" class="lf lg iq bd mk ml mm dn mn mo mp dp mq kj mr ms mt kn mu mv mw kr mx my mz na bi translated">用组件限制提供者范围</h2><p id="019e" class="pw-post-body-paragraph jy jz iq ka b kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ij bi translated">限制提供者范围的另一种方法是在<em class="ls">@组件</em>装饰器内的<em class="ls">提供者</em>数组中提供服务。组件提供者和NgModule提供者是相互独立的。在组件中提供服务会将服务仅限于该组件和该组件内的组件(组件树)</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="1811" class="lf lg iq lb b gy lh li l lj lk">@Component({<br/>  ...<br/>  providers: [VoteService]<br/>})</span></pre><p id="8690" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。希望现在没那么复杂了。完整的代码可在<a class="ae nm" href="https://stackblitz.com/edit/angular-wg7wrk" rel="noopener ugc nofollow" target="_blank">这里</a></p></div></div>    
</body>
</html>