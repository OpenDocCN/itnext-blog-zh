<html>
<head>
<title>Laravel: The Power of Authentication [Part 2]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel:认证的力量(第2部分)</h1>
<blockquote>原文：<a href="https://itnext.io/laravel-the-power-of-authentication-part-2-f2386eaebcad?source=collection_archive---------5-----------------------#2019-05-06">https://itnext.io/laravel-the-power-of-authentication-part-2-f2386eaebcad?source=collection_archive---------5-----------------------#2019-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4a4b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">忘记使用您的控制器来手动登录您的用户，学习真正的方法！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f369dd4d412623881d814f5dc426c386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9prU4LL77vPyqbX6"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@kutanural?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">库坦乌拉尔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="400f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为我的文章<a class="ae kv" href="https://medium.com/@DarkGhostHunter/laravel-making-your-own-passwordless-auth-guard-b7740c89adf8" rel="noopener">关于认证如何在Laravel </a>中工作的<em class="ls">的后续</em>，这里我将写一下认证机制的活动部分，比如认证中间件、防护、驱动程序、用户提供者和可认证者。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="489c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们知道了<a class="ae kv" href="https://medium.com/p/4510f721d8ff" rel="noopener">我们的认证中间件做了什么</a>，下一部分是知道什么是认证防护。</p><h1 id="e667" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">那么，什么是认证守卫呢？</h1><p id="c396" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">身份验证警卫负责:</p><ol class=""><li id="6c2b" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">在请求中查找凭据。</li><li id="cb0d" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">使用凭据检索用户。</li><li id="2284" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">比较和验证凭证。</li><li id="19fc" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">返回已验证的用户以供进一步使用。</li></ol><p id="e93e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了完成这些任务，Guard概念由两个移动部分组成:Guard驱动程序<strong class="ky ir">和用户提供程序<strong class="ky ir">。这两者有明确的<a class="ae kv" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>:一个定位并验证凭证，另一个“提供”或“定位”这些凭证的用户，后者必须符合<code class="fe nl nm nn no b">Authenticatable</code>契约(或者接口，如果你愿意的话)。</strong></strong></p><p id="5725" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你看到<a class="ae kv" href="https://github.com/laravel/laravel/blob/master/config/auth.php" rel="noopener ugc nofollow" target="_blank">你的</a> <code class="fe nl nm nn no b"><a class="ae kv" href="https://github.com/laravel/laravel/blob/master/config/auth.php" rel="noopener ugc nofollow" target="_blank">auth.php</a></code> <a class="ae kv" href="https://github.com/laravel/laravel/blob/master/config/auth.php" rel="noopener ugc nofollow" target="_blank">配置文件</a>，你会看到一个名为<code class="fe nl nm nn no b">guards</code>的键。在这里，每个守卫的名字都会有一个<code class="fe nl nm nn no b">driver</code>和一个<code class="fe nl nm nn no b">provider</code>。这允许你在不影响其他驱动程序的情况下交换它们，或者用其他驱动程序和提供程序创建其他防护。想象一下，警卫拿着一个司机的包，司机拿着一个标签。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/69660ad6e29613c590c9dbff55ad4dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vADfUKv_iSnyDQzNjigwng.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">config/auth.php</figcaption></figure><p id="5066" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在我们的<code class="fe nl nm nn no b">web</code> guard中，您可以将“用户”提供者更改为一个假想的“外部”提供者，该提供者将从Twitter、Firebase、Auth0或任何其他地方提取用户，并保持相同的“会话”驱动程序以保持用户登录。这个“外部”提供者将用户数据保存在缓存或数据库中，以避免在每次请求时调用外部API:</p><pre class="kg kh ki kj gt nq no nr ns aw nt bi"><span id="6afa" class="nu mb iq no b gy nv nw l nx ny">'guards' =&gt; [<br/>    // ...</span><span id="28da" class="nu mb iq no b gy nz nw l nx ny">    'web' =&gt; [<br/>        'driver' =&gt; 'session',<br/>        'provider' =&gt; 'external'<br/>    ],</span></pre><p id="1879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您不理解配置文件，请不要担心，我们将在最后一部分再次讨论这个问题。</p><h1 id="16d9" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">警卫司机</h1><p id="3116" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">所有的守卫都遵从<a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Contracts/Auth/Guard.php" rel="noopener ugc nofollow" target="_blank">底座</a> <code class="fe nl nm nn no b"><a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Contracts/Auth/Guard.php" rel="noopener ugc nofollow" target="_blank">Guard</a></code> <a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Contracts/Auth/Guard.php" rel="noopener ugc nofollow" target="_blank">接口</a>。这个接口为做三件事奠定了基础:检查是否有用户通过了身份验证，验证传递的凭证并返回当前通过身份验证的用户。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/4c0ed6df5cdc38a06cdac281eed7a858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3fVnIRv_IwLW6L1muOZaA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照明/合同/授权/警卫</figcaption></figure><p id="8769" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是Laravel 附带的<a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Auth/TokenGuard.php" rel="noopener ugc nofollow" target="_blank"/><code class="fe nl nm nn no b"><a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Auth/TokenGuard.php" rel="noopener ugc nofollow" target="_blank">TokenGuard</a></code><a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Auth/TokenGuard.php" rel="noopener ugc nofollow" target="_blank">使用的。守卫检查请求头中的<code class="fe nl nm nn no b">token</code>，并提取匹配的用户。如果令牌不存在或不正确，身份验证将失败。</a></p><p id="9c23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个接口是由另一个<a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Contracts/Auth/StatefulGuard.php" rel="noopener ugc nofollow" target="_blank"/><code class="fe nl nm nn no b"><a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Contracts/Auth/StatefulGuard.php" rel="noopener ugc nofollow" target="_blank">StatefulGuard</a></code>扩展的。顾名思义，它添加了一些方法来方便地对用户进行身份验证，在后续请求中保持身份验证，并使身份验证无效。这主要分别通过<code class="fe nl nm nn no b">login()</code>、<code class="fe nl nm nn no b">viaRemember()</code>和<code class="fe nl nm nn no b">logout()</code>方法完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/a15a659f35271debc0c82d492ab47aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AX0FVZ12tzWdsTmXD8abUA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照明/合同/授权/国家警卫</figcaption></figure><p id="1801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是通过<a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Auth/SessionGuard.php" rel="noopener ugc nofollow" target="_blank"/><code class="fe nl nm nn no b"><a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Auth/SessionGuard.php" rel="noopener ugc nofollow" target="_blank">SessionGuard</a></code>实现的。顾名思义，它使用应用程序的会话处理程序来保存和识别身份验证信息。这允许在会话有效且未过期的情况下保持用户登录，因为它会检查这一点以持续拉出用户。</p><p id="ab77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些保护方法通常调用用户提供者，它负责检索<code class="fe nl nm nn no b">Authenticatable</code>用户，不管它是什么，比如API或moon。</p><h2 id="4b5f" class="nu mb iq bd mc oc od dn mg oe of dp mk lf og oh mm lj oi oj mo ln ok ol mq om bi translated">有状态和无状态的区别</h2><p id="b1df" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果你不明白其中的区别，这里有一个提示。有状态保护提供了保持用户登录的方法，为了实现这一点，有状态保护提供了类似<code class="fe nl nm nn no b">attempt()</code>和<code class="fe nl nm nn no b">login()</code>的方法，负责检查特定用户是否拥有正确的凭证，并在下一个请求中保持身份验证，例如使用会话和记住令牌。</p><p id="d9ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随后的请求不会询问用户密码，而是记住令牌。无论哪种方式，有状态防护都将使用用户提供程序，使用记住令牌来检索用户。</p><p id="be56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，只要用户的凭证是正确的，无状态保护(如果您愿意，也可以称为“简单保护”)就会对用户进行身份验证，这是用户必须在每个请求中设置的。当您使用外部API时，这种情况会经常发生，这需要在所有请求的请求头中设置一个特殊的令牌，以标识发出请求的用户。</p><h1 id="472a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">用户提供者</h1><p id="5c97" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe nl nm nn no b"><a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Contracts/Auth/UserProvider.php" rel="noopener ugc nofollow" target="_blank">UserProvider</a></code> <a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Contracts/Auth/UserProvider.php" rel="noopener ugc nofollow" target="_blank">接口</a>设置识别和检索想要被认证的用户的基础。无论你做什么来完成它都是你自己的事情，只要它返回实现<code class="fe nl nm nn no b">Authenticatable</code>契约的实例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/25fcf33034691162c57c42e0631765b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__pNg475HjBatwjWiNJFTQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照明/合同/授权/用户提供者</figcaption></figure><p id="17ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个用户提供者必须通过ID(在数据库中通常是主列)和令牌来检索用户，这允许用户通过多个请求被“记住”或被认证，而不暴露其他凭证。这个最后的凭证通常是默认的<code class="fe nl nm nn no b">users</code>表中的“remember_token”列。同样，您使用什么来持久化和检索令牌是您自己的事情。</p><p id="6508" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还负责通过凭据组合(如用户名、密码和其他信息)检索用户，并验证这些凭据的正确性，例如检查密码是否匹配。</p><p id="6e06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，<code class="fe nl nm nn no b"><a class="ae kv" href="https://github.com/laravel/framework/blob/5.8/src/Illuminate/Auth/EloquentUserProvider.php#L106-L132" rel="noopener ugc nofollow" target="_blank">EloquentUserProvider</a></code>接收一组凭证来构建查询，该查询检查是否找到了这些凭证的用户。之后，用户再次被接收，但是带有凭证以比较这些凭证是否相同。</p><h1 id="025c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">可信的</h1><p id="ad80" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">当一切正常时，我们将检索用户，它应该是 <code class="fe nl nm nn no b"><a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Contracts/Auth/Authenticatable.php" rel="noopener ugc nofollow" target="_blank">Authenticatable</a></code>的一个<a class="ae kv" href="https://github.com/laravel/framework/blob/master/src/Illuminate/Contracts/Auth/Authenticatable.php" rel="noopener ugc nofollow" target="_blank">实例。这个接口基本上是一个契约，它迫使开发人员使用通用的方法来管理凭证，如密码、记住令牌及其用于身份验证的唯一标识符。</a></p><p id="b9f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然惟一标识符通常是数据库中的主列，但并不局限于此。在一个极端的例子中，您可以将他的标识符设置为远程API的唯一UUID。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/9dcdb66878b3d2f48ab145b721fa5e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IEwkdPyrBfrboCsJvLLYsA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照明/合同/授权/可认证</figcaption></figure><p id="20e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一点非常重要:<strong class="ky ir">认证机制与实现</strong>相关联，而不是硬编码到类中。如果将来您想要将您的<em class="ls">可认证的</em>用户的位置从Firebase或Auth0更改到您的本地数据库，您将需要将用户提供者从<code class="fe nl nm nn no b">firebase</code>更改为<code class="fe nl nm nn no b">eloquent</code>，就这样。</p><p id="b754" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，安全驱动程序不关心用户从哪里取出(API、远程数据库等)，用户提供者也不关心用户凭证从哪里取出(cookie、会话、请求头，谁知道呢)。这允许保持您的网站功能不变，而不必求助于几乎重新连接整个认证过程。</p><p id="48c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一部分，我们把所有的东西粘在一起。</p><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/laravel-the-power-of-authentication-part-3-d691224f3afb"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">Laravel:认证的力量(第3部分)</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">忘记使用您的控制器来手动登录您的用户，学习真正的方法！</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">itnext.io</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kp os"/></div></div></a></div></div></div>    
</body>
</html>