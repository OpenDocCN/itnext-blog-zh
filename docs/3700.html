<html>
<head>
<title>Liskov Substitution Principle in a nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">里斯科夫替代原理简而言之</h1>
<blockquote>原文：<a href="https://itnext.io/liskov-substitution-principle-in-a-nutshell-8679015ada50?source=collection_archive---------2-----------------------#2020-02-06">https://itnext.io/liskov-substitution-principle-in-a-nutshell-8679015ada50?source=collection_archive---------2-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6d76758fdc218cbb0fb3852d85061fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtYTxMtli-SaIp_fJWvvcw.jpeg"/></div></div></figure><div class=""/><p id="570b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在坚实的原理中，利斯科夫替代原理可能是最难熟悉的。它的定义很“学术”，第一次读的时候不是很直白。</p><p id="ed47" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，正如我们将在这篇文章中看到的，它的实际概念一点也不复杂。</p><h1 id="4233" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">定义</h1><blockquote class="lx ly lz"><p id="a9ac" class="kb kc ma kd b ke kf kg kh ki kj kk kl mb kn ko kp mc kr ks kt md kv kw kx ky im bi translated">如果对于每一个S类型的对象o1，都有一个T类型的对象o2，使得对于所有用T定义的程序P，当o1代替o2时，P的行为不变，那么S就是T的一个子类型</p><p id="2587" class="kb kc ma kd b ke kf kg kh ki kj kk kl mb kn ko kp mc kr ks kt md kv kw kx ky im bi translated">—芭芭拉·利斯科夫，“数据抽象和层次”(1988年5月)</p></blockquote><p id="4241" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你需要读两遍才能明白，对吗？我会试着用简单的英语重写它。</p><p id="ac0e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您有两个类(S和T)，那么您有它们的两个实例(分别是o1和o2)。如果你有一个程序(P)使用了类T，当你用O1(S的实例)代替O2(T的实例)时，它的行为没有改变，这意味着S是T的子类。</p><h1 id="c6d8" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">意义</h1><p id="c41f" class="pw-post-body-paragraph kb kc je kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">根据这个原则的定义，Robert Martin试图告诉你，在你使用继承的情况下，确保你的子类和它的父类100%兼容。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="73ce" class="ms la je mo b gy mt mu l mv mw">class Main {<br/>   func foo(int a) : int {<br/>       return 1<br/>   }<br/>}</span><span id="b0cc" class="ms la je mo b gy mx mu l mv mw">class Sub extends Main {<br/>   func foo(int a) : string {<br/>       return "Hello"<br/>   }<br/>}</span></pre><p id="c46d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个愚蠢的例子，在子类中我用不同的返回类型覆盖了一个函数。</p><p id="7fdd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑使用<code class="fe my mz na mo b">Main</code>实例的第三个类，它需要来自<code class="fe my mz na mo b">foo()</code>的整数。如果你用一个<code class="fe my mz na mo b">Sub</code>替换那个实例，它可能会失败，对吗？</p><p id="1493" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以这个例子违反了LSP。</p><h1 id="4eec" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">前置条件和后置条件</h1><p id="00fd" class="pw-post-body-paragraph kb kc je kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">不幸的是，LSP不仅仅是关于返回类型。如果子类使用父类的不同数据集，也可能违反LSP。</p><p id="8e79" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您有一个使用<code class="fe my mz na mo b">Main</code>的方法<code class="fe my mz na mo b">foo</code>的类<code class="fe my mz na mo b">Random</code>。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="547a" class="ms la je mo b gy mt mu l mv mw">class Random {<br/>   func bar(Main x) {<br/>      // x is an instance of Main<br/>      do.Some.Stuff.With.x.foo();<br/>    }<br/>}</span></pre><p id="0d85" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，假设<code class="fe my mz na mo b">Main.foo()</code>只返回正整数，而<code class="fe my mz na mo b">Random.bar()</code>也需要正整数。假设<code class="fe my mz na mo b">Sub.foo()</code>既可以返回正值，也可以返回负值。</p><p id="3430" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您将<code class="fe my mz na mo b">Sub</code>的一个实例传递给<code class="fe my mz na mo b">Random.bar()</code>，您就违反了LSP，因为<code class="fe my mz na mo b">Random.bar()</code>期望一组正整数，而您实际上也传递了负值。</p><p id="3979" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之，我们说主类的输出集应该小于子类的输出集。对于一个类的输入来说，情况正好相反。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nb"><img src="../Images/e920509dfd8da2cb4365443d1f09691a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZbmaIMUtfU43nFjgvRMhg.png"/></div></div></figure><p id="3ccc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">前置条件:</strong>子类接受的输入范围应等于或大于基类。</p><p id="313c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">后置条件:</strong>输出应该是基类输出的子集。</p><h1 id="80e9" class="kz la je bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="37fa" class="pw-post-body-paragraph kb kc je kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">我希望这篇文章能帮助你更好地理解这个设计原则。</p><p id="4fa5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请记住，这一点和其他坚实的原则只是一个工具:不要为了遵循这些原则而强迫您的代码过度架构。请记住这些原则的存在，并在设计应用程序时尝试应用它们。</p></div></div>    
</body>
</html>