<html>
<head>
<title>Any, Unit, Nothing and all their friends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">任何，单位，虚无和他们所有的朋友</h1>
<blockquote>原文：<a href="https://itnext.io/any-unit-nothing-and-all-their-friends-e39613b48235?source=collection_archive---------1-----------------------#2020-01-18">https://itnext.io/any-unit-nothing-and-all-their-friends-e39613b48235?source=collection_archive---------1-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3b6bd37457bd0ddd60e3c52c1e627302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPsMlnvtZhqONF_cflKZAQ.jpeg"/></div></div></figure><h1 id="6a03" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">任何的</h1><p id="654b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是一个简单的类型，Any只是“根”类型，所以其他类型都是从它扩展而来的。这就像Java中的Object，实际上，为Any类型的值编译的代码是一个对象。</p><p id="42d8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">// <strong class="lb iu">科特林</strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="2a1c" class="ml kc it mh b gy mm mn l mo mp">val greeting: Any = "Hi there!"</span></pre><p id="8163" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">// <strong class="lb iu"> Java </strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e4f5" class="ml kc it mh b gy mm mn l mo mp">private final Object greeting = "Hi there!";</span></pre><h1 id="52e8" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">单位</h1><p id="41e6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">Kotlin中的函数返回单元在Java中的意思是返回void。此外，Kotlin中的函数返回单元不需要显式地返回它。所以这两个函数编译成相同的:</p><p id="bc64" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">// <strong class="lb iu">科特林</strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a6c8" class="ml kc it mh b gy mm mn l mo mp">fun returnsUnit(): Unit {<br/>}</span><span id="c8e4" class="ml kc it mh b gy mq mn l mo mp">fun returnsUnitExplicitly(): Unit {<br/>    return Unit<br/>}</span></pre><p id="164c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">// <strong class="lb iu"> Java </strong></p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a88f" class="ml kc it mh b gy mm mn l mo mp">public final void returnsUnit() {<br/>}<br/><br/>public final void returnsUnitExplicitly() {<br/>}</span></pre><h2 id="b0aa" class="ml kc it bd kd mr ms dn kh mt mu dp kl lk mv mw kp lo mx my kt ls mz na kx nb bi translated">那么什么是单位呢？</h2><p id="a0fb" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">单元被定义为单一实例。因此，该类型只有一个有效值:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="217b" class="ml kc it mh b gy mm mn l mo mp">val <em class="nc">unit</em>: Unit = Unit</span></pre><p id="7d5c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">从类型层次结构的角度来看，与任何其他类型类似，Unit是any的子级:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="16ff" class="ml kc it mh b gy mm mn l mo mp">val <em class="nc">unit</em>: Any = Unit</span></pre><h1 id="1086" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">没有任何东西</h1><p id="3b97" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">没有什么是没有任何可能值的类型。这是因为它被定义为具有私有构造函数的常规类。根据文档:<em class="nc"> Nothing没有实例。可以用Nothing来表示“一个从来不存在的值”。</em></p><p id="2291" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">那么如果没有办法构造或获取任何Nothing类型的值，它又有什么用呢？</p><h2 id="e46d" class="ml kc it bd kd mr ms dn kh mt mu dp kl lk mv mw kp lo mx my kt ls mz na kx nb bi translated">键入从不返回(或抛出异常)的函数</h2><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="cbd4" class="ml kc it mh b gy mm mn l mo mp">fun infiniteLoop(): Nothing {<br/>    while (true) {<br/>        <em class="nc">println</em>("Hi there!")<br/>    }<br/>}</span></pre><p id="0d3f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">或者</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="2b7b" class="ml kc it mh b gy mm mn l mo mp">fun throwException(): Nothing {<br/>    throw IllegalStateException()<br/>}</span></pre><p id="99d1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">编译器足够聪明，可以在这两种情况下推断出函数永远不会(正确地)返回。这就是为什么任何放在函数调用后不返回任何内容的代码都将被忽略。编译器将对不可访问的代码显示警告。</p><p id="f526" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们定义一个可能抛出异常(或返回null)的新函数:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1bd1" class="ml kc it mh b gy mm mn l mo mp">fun mayThrowAnException(<em class="nc">throwException</em>: Boolean): Nothing? {<br/>    return if (<em class="nc">throwException</em>) {<br/>        throw IllegalStateException()<br/>    } else {<br/>        <em class="nc">println</em>("Exception not thrown :)")<br/>        null<br/>    }<br/>}</span></pre><p id="5991" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果我们从我们的主:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="af3a" class="ml kc it mh b gy mm mn l mo mp">fun main() {<br/>    val <em class="nc">result </em>= <em class="nc">mayThrowAnException</em>(true)<br/>    if (<em class="nc">result </em>== null) { // <strong class="mh iu">Always true</strong><br/>        <em class="nc">println</em>("Ignored code")<br/>    }<br/>}</span></pre><p id="50cd" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">编译器提示我们结果将总是空的。这是为什么呢？因为程序在调用<em class="nc"> mayThrowAnException </em>函数后继续运行的唯一方法是返回一个null(因为否则它将什么都不是)。如果函数没有返回任何东西，是因为它会抛出一个异常，这将导致我们的程序中断。</p><h2 id="c867" class="ml kc it bd kd mr ms dn kh mt mu dp kl lk mv mw kp lo mx my kt ls mz na kx nb bi translated">将抛出和返回转换为表达式</h2><p id="9d4e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">你有没有想过为什么这是可能的？</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6b24" class="ml kc it mh b gy mm mn l mo mp">val <em class="nc">nullableValue</em>: String? = null<br/>val <em class="nc">value </em>= <em class="nc">nullableString </em>?: throw IllegalStateException()</span></pre><p id="2a9c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><code class="fe nd ne nf mh b">nullableString</code>的类型是字符串？，而<code class="fe nd ne nf mh b">throw IllegalStateException()</code>什么都不是。碰巧没有什么是每种类型的子类型。这就是该表达式最终计算为字符串的原因。</p><p id="131c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">另一个例子:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="134d" class="ml kc it mh b gy mm mn l mo mp">val <em class="nc">nullableValue</em>: String? = null<br/>val <em class="nc">value: Int </em>= <em class="nc">nullableValue</em>?.<em class="nc">toInt</em>() ?: return</span></pre><p id="39dc" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这种情况类似于前一种情况，但是我们没有抛出异常，而是从函数中返回。<code class="fe nd ne nf mh b">return</code>的类型什么都没有，同上。</p><p id="d43c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">最终，该语言将return和throw都“转换”成表达式(其类型为Nothing)，这导致了更简洁的编程(而不是成为“异常”语句)。</p><h2 id="1df6" class="ml kc it bd kd mr ms dn kh mt mu dp kl lk mv mw kp lo mx my kt ls mz na kx nb bi translated">类型层次结构中什么都没有？</h2><p id="cc86" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们在文章的开头说过，Any是在类型系统之上的。没有什么是相反的，是在底部。这是什么意思？这意味着没有什么是每个类型的子类型。这就是上面显示的代码示例有效的原因。让我们回顾一下上一个例子的最后一部分:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="2ca4" class="ml kc it mh b gy mm mn l mo mp"><em class="nc">nullableValue</em>?.<em class="nc">toInt</em>() ?: return</span></pre><p id="9f34" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><code class="fe nd ne nf mh b">nullableValue?.toInt</code>的类型是Int？然后在nullableValue为空的情况下，我们从函数中使用<a class="ae ng" href="https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator" rel="noopener ugc nofollow" target="_blank"> elvis算子</a>到<code class="fe nd ne nf mh b">return</code>。而返回表达式的类型是Nothing。</p><p id="7066" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">所以映射到类型，我们会有:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="fd84" class="ml kc it mh b gy mm mn l mo mp">Int? ?: Nothing</span></pre><p id="13d7" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">整个表达式的返回类型是两种类型共有的类型。因为没有什么是每个类型的子类型，Int？是他们的共同点。<strong class="lb iu">一般来说，类型T和Nothing之间的共同类型永远是T</strong></p></div></div>    
</body>
</html>