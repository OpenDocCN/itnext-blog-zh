<html>
<head>
<title>Buildkit: local build, caching and image scanning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Buildkit:本地构建、缓存和图像扫描</h1>
<blockquote>原文：<a href="https://itnext.io/buildkit-local-build-caching-and-image-scanning-450040d9ebb0?source=collection_archive---------6-----------------------#2022-11-06">https://itnext.io/buildkit-local-build-caching-and-image-scanning-450040d9ebb0?source=collection_archive---------6-----------------------#2022-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f0fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的文章<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/jenkins-k8s-building-docker-image-without-docker-d41cffdbda5a">第1部分</a>和<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/jenkins-k8s-buildkit-life-behind-the-corporate-proxy-cb052bd7f969">第2部分</a>中，我们讨论了在Jenkins管道中使用Buildkit构建Docker映像。所描述的方法有一个缺陷。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d9dcd3857a41a7fde22e982151e99de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptd37NrkOyPyIyKHH_WsDg.jpeg"/></div></div></figure><p id="6084" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看下面这个阶段:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="3628" class="ld le iq kz b gy lf lg l lh li">stage('Build Docker Image') {<br/>            container('buildkit') {<br/>                sh """<br/>                  buildctl build \<br/>                      --frontend dockerfile.v0 \<br/>                      --local context=. \<br/>                      --local dockerfile=. \<br/>                      --output type=image,name=${image},push=true<br/>                  buildctl build \<br/>                      --frontend dockerfile.v0 \<br/>                      --local context=. \<br/>                      --local dockerfile=. \<br/>                      --output type=image,name=${repository}:${tag},push=true<br/>                """<br/>                milestone(1)<br/>            }<br/>        }</span></pre><p id="d7a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，<code class="fe lj lk ll kz b">buildctl</code>执行了两次，这两次都将运行完整的构建，从而使阶段执行时间加倍。</p><p id="dc71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个可以改进吗？</p><p id="dfa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，Buildkit的缓存效率很高，我们只是在上面描述的阶段没有使用它。</p><p id="daa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了利用Buildkit缓存层的能力，我们必须在第一次执行<code class="fe lj lk ll kz b">buildctl</code>时将其导出到本地容器文件系统，然后在第二次运行时将其导入。</p><p id="f94d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将图层导出到本地缓存，添加以下选项:<code class="fe lj lk ll kz b">--export-cache type=local,dest=/tmp/buildkit/cache</code>。</p><p id="900e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要稍后导入它，请添加以下选项:<code class="fe lj lk ll kz b">--import-cache type=local,src=/tmp/buildkit/cache</code>。</p><p id="ebe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果管道中有两个以上对<code class="fe lj lk ll kz b">buildctl</code>工具的调用，那么除了第一个调用之外，对所有调用都使用<code class="fe lj lk ll kz b">--export-cache</code>和<code class="fe lj lk ll kz b">--import-cache</code>选项是有意义的。</p><p id="d022" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，要在上面的示例阶段利用缓存，我们必须将其修改如下:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="293e" class="ld le iq kz b gy lf lg l lh li">stage('Build Docker Image') {<br/>            container('buildkit') {<br/>                sh """<br/>                  buildctl build \<br/>                      --frontend dockerfile.v0 \<br/>                      --local context=. \<br/>                      --local dockerfile=. \<br/>                      --export-cache type=local,dest=/tmp/buildkit/cache \<br/>                      --output type=image,name=${image},push=true<br/>                  buildctl build \<br/>                      --frontend dockerfile.v0 \<br/>                      --local context=. \<br/>                      --local dockerfile=. \<br/>                      --import-cache type=local,src=/tmp/buildkit/cache \<br/>                      --output type=image,name=${repository}:${tag},push=true<br/>                """<br/>                milestone(1)<br/>            }<br/>        }</span></pre><p id="e3cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还想讨论另外两个使用案例。</p><p id="d479" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中之一是在Docker映像构建期间编译源代码。历史上，我们首先编译结果executble或archive(在Java世界中),然后以某种方式将其提供给Docker映像。</p><p id="c434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，作为Docker映像构建的一部分，没有什么能真正阻止我们这样做。一个小问题阻止了我在管道中使用这种方法多年。</p><p id="da3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你看，我通常会将测试报告发布到Jenkins作业运行中，这样就可以通过Jenkins fronetend访问它们。从图像中提取这些报告并不简单。</p><p id="f6fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用plain Docker构建映像时，我必须首先构建映像，并在构建阶段结束时停止。然后，我必须从该映像创建一个容器，并将报告和其他文件从映像复制到主机文件系统。</p><p id="9995" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我必须再次构建它，直到获得最终将被推送到注册表的最终图像。</p><p id="50e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Buildkiy简化了这项任务。它支持结果图像的多种输出格式。它可以作为目录结构刷新到磁盘，或者作为OCI映像存储。tar文件。因此，在这种情况下，我可能更喜欢将映像构建为本地目录，然后将文件复制出来。</p><p id="1767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有以下构建Spring Boot应用程序的Dockerfile文件:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="ed6b" class="ld le iq kz b gy lf lg l lh li">FROM eclipse-temurin:17.0.4.1_1-jdk as source</span><span id="80f3" class="ld le iq kz b gy lm lg l lh li">ARG version="1.0.0"<br/>ARG build_number</span><span id="5320" class="ld le iq kz b gy lm lg l lh li">ENV BUILD_NUMBER=${build_number}</span><span id="1615" class="ld le iq kz b gy lm lg l lh li">RUN mkdir /app</span><span id="a2d5" class="ld le iq kz b gy lm lg l lh li">COPY .gradle.properties /root/.gradle/gradle.properties</span><span id="512b" class="ld le iq kz b gy lm lg l lh li">COPY gradle /app/gradle<br/>COPY build.gradle gradle.properties gradlew settings.gradle sonar-project.properties /app/</span><span id="b359" class="ld le iq kz b gy lm lg l lh li">WORKDIR /app</span><span id="a681" class="ld le iq kz b gy lm lg l lh li">RUN ./gradlew clean</span><span id="60c5" class="ld le iq kz b gy lm lg l lh li">FROM source as build</span><span id="3dc4" class="ld le iq kz b gy lm lg l lh li">ARG version="1.0.0"<br/>ARG build_number</span><span id="2b5d" class="ld le iq kz b gy lm lg l lh li">ENV BUILD_NUMBER=${build_number}</span><span id="23dc" class="ld le iq kz b gy lm lg l lh li">COPY src /app/src<br/>COPY test /app/test</span><span id="b4fc" class="ld le iq kz b gy lm lg l lh li">RUN ./gradlew build</span><span id="bce4" class="ld le iq kz b gy lm lg l lh li">FROM eclipse-temurin:17.0.4.1_1-jre as app</span><span id="7972" class="ld le iq kz b gy lm lg l lh li">ARG version="1.0.0"<br/>ARG build_number</span><span id="afc9" class="ld le iq kz b gy lm lg l lh li">RUN groupadd -g 1001 devops \<br/>    &amp;&amp; useradd -u 1001 -g 1001 devops \<br/>    &amp;&amp; mkdir -p /app/config \<br/>    &amp;&amp; chown -R devops /app</span><span id="3af4" class="ld le iq kz b gy lm lg l lh li">ENV BUILD_NUMBER=${build_number}</span><span id="780c" class="ld le iq kz b gy lm lg l lh li">COPY --from=build /app/build/libs/service-${version}.${build_number}.jar /app/service-${version}.${build_number}.jar<br/>RUN ln -s /app/service-${version}.${build_number}.jar /app/service.jar</span><span id="8c68" class="ld le iq kz b gy lm lg l lh li">RUN mkdir -p /app/config \<br/> &amp;&amp; chown -R devops /app</span><span id="24b0" class="ld le iq kz b gy lm lg l lh li">EXPOSE 8080</span><span id="3435" class="ld le iq kz b gy lm lg l lh li">WORKDIR /app<br/>USER devops</span><span id="05ca" class="ld le iq kz b gy lm lg l lh li">FROM app as debug</span><span id="ada5" class="ld le iq kz b gy lm lg l lh li">CMD ["java", "-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005", "-jar", "/app/service.jar"]</span><span id="70d9" class="ld le iq kz b gy lm lg l lh li">FROM app</span><span id="ddc7" class="ld le iq kz b gy lm lg l lh li">CMD java $JAVA_OPTS -jar /app/service.jar</span></pre><p id="c5b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，要构建它，我需要首先将它运行到构建目标。在这种情况下,“构建Java代码”阶段应该如下所示:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="0385" class="ld le iq kz b gy lf lg l lh li">container('buildkit') {<br/>            stage('Build Java Code') {<br/>                try {<br/>                    sh """<br/>                        mkdir -p /root/.gradle; cat /etc/.gradle/gradle-new.properties &gt; /root/.gradle/gradle.properties<br/>                        cp /etc/.gradle/gradle-new.properties .gradle.properties<br/>                        chmod 755 ./gradlew<br/>                        buildctl build \<br/>                             --frontend dockerfile.v0 \<br/>                             --local context=. \<br/>                             --local dockerfile=. \<br/>                             --export-cache type=local,dest=/tmp/buildkit/cache \<br/>                             --output type=local,dest=/tmp/app \<br/>                             --opt network=host \<br/>                             --opt build-arg:version=${version} \<br/>                             --opt build-arg:build_number=${env.BUILD_NUMBER} \<br/>                             --opt target=build<br/>                        cp -R /tmp/app/app/build ./<br/>                    """<br/>                } catch (error) {<br/>                    step([$class: 'Mailer',<br/>                        notifyEveryUnstableBuild: true,<br/>                        recipients: emailextrecipients([[$class: 'CulpritsRecipientProvider'],<br/>                                                        [$class: 'DevelopersRecipientProvider']]),<br/>                        sendToIndividuals: true])<br/>                    throw error<br/>                } finally {<br/>                    step([$class: 'JUnitResultArchiver', testResults: 'build/test-results/test/*.xml'])<br/>                    step([$class: 'JacocoPublisher',<br/>                        execPattern: 'build/jacoco/*.exec',<br/>                        classPattern: 'build/classes',<br/>                        sourcePattern: 'src/main/java',<br/>                        exclusionPattern: 'src/test*'<br/>                    ])<br/>                }<br/>            }</span></pre><p id="0190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在执行buildctl之后，我们将构建目录复制回工作区:<code class="fe lj lk ll kz b">cp -R /tmp/app/app/build ./</code>。</p><p id="d1eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在最后一个模块中，我们将测试结果和Jacoco测试结果发布给Jenkins job。</p><p id="5993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们现在可以从sonar cube容器中运行sonar cube扫描，因为所有必需的文件都在工作区中。</p><p id="35a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们正在缓存层，因此，如果我们现在运行构建到结束，Buildkit将不会再次编译代码，而只是使用缓存层。</p><p id="d165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想在管道中做的另一件事是，我想扫描结果图像的漏洞。</p><p id="1356" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">历史上，我们使用Anchore服务器扫描图像的漏洞。使用这种方法，图像应该在扫描之前被推送到注册表，这并不理想，因为如果我们在图像中发现漏洞，它将不会被使用，而只是挂在注册表中，占用磁盘空间。</p><p id="53e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，理想情况下，我们希望在推送图像之前，先对其进行本地扫描。此外，我们希望推动图像只有当它是从主分支机构建立的，但我们希望扫描每个分支机构和每个公关。</p><p id="fea3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Grype的出现让我们可以轻松地在本地扫描图像，但是在使用Buildkit方法时，如前所述，我们无法访问有问题的图像:我们构建并立即推送它。</p><p id="82d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，为了扫描生成的图像，我们希望构建它并将其存储在本地，这次可能是作为OCI图像。tar文件。</p><p id="4269" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一阶段将如下所示:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="f236" class="ld le iq kz b gy lf lg l lh li">stage('Build Docker Image') {<br/>    try {<br/>        sh """<br/>            buildctl build \<br/>               --frontend dockerfile.v0 \<br/>               --local context=. <br/>               --local dockerfile=. \<br/>               --export-cache type=local,dest=/tmp/buildkit/cache \<br/>               --import-cache type=local,src=/tmp/buildkit/cache \<br/>               --output type=oci,dest=/tmp/image.tar \<br/>               --opt network=host \<br/>               --opt build-arg:version=${version} \<br/>               --opt build-arg:build_number=${env.BUILD_NUMBER}<br/>        """<br/>    } catch (error) {<br/>        step([$class: 'Mailer',<br/>            notifyEveryUnstableBuild: true,<br/>            recipients: emailextrecipients([[$class: 'CulpritsRecipientProvider'],<br/>                                            [$class: 'RequesterRecipientProvider']]),<br/>            sendToIndividuals: true])<br/>            throw error<br/>    }<br/>}</span></pre><p id="3a9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们在stage中同时使用了<code class="fe lj lk ll kz b">--export-cache</code>和<code class="fe lj lk ll kz b">--import-cache</code>，生成的图像被存储为<code class="fe lj lk ll kz b">/tmp/image.tar</code>文件。</p><p id="7ac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我可以对。tar文件，因为grype支持OCI图像。我将使用以下阶段来扫描图像:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="7cba" class="ld le iq kz b gy lf lg l lh li">stage('Scan Docker Image') {<br/>            try {<br/>                sh """<br/>     wget <a class="ae kl" href="https://raw.githubusercontent.com/anchore/grype/main/install.sh" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/anchore/grype/main/install.sh</a><br/>     chmod 755 install.sh</span><span id="a57c" class="ld le iq kz b gy lm lg l lh li">./install.sh<br/>     mv bin/grype /usr/local/bin/<br/>     <br/>                    GRYPE_MATCH_GOLANG_USING_CPES=false \<br/>                          /usr/local/bin/grype \<br/>                                  oci-archive:/tmp/image.tar \<br/>                                  -f high \<br/>                                  --scope all-layers \<br/>                                  -o template \<br/>                                  --file report.html \<br/>                                  -t grype.tmpl \<br/>                                  --only-fixed<br/>                """<br/>            } catch (error) {<br/>                step([$class: 'Mailer',<br/>                    notifyEveryUnstableBuild: true,<br/>                    recipients: emailextrecipients([[$class: 'CulpritsRecipientProvider'],<br/>                                                    [$class: 'RequesterRecipientProvider']]),<br/>                    sendToIndividuals: true])<br/>                    throw error<br/>            } finally {<br/>                publishHTML (target : [allowMissing: false,<br/>                 alwaysLinkToLastBuild: true,<br/>                 reportDir: '',<br/>                 keepAll: true,<br/>                 reportFiles: 'report.html',<br/>                 reportName: 'Grype Scan Report',<br/>                 reportTitles: 'Grype Scan Report'])<br/>            }<br/>            milestone()<br/>            }</span></pre><p id="90d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上阶段假设<code class="fe lj lk ll kz b">grype.tmpl</code>文件在工作区中可用。此文件是为grype扫描生成html报告并将其发布到Jenkins作业运行所必需的。更多关于在grype中使用模板的细节可以在<a class="ae kl" href="https://github.com/anchore/grype#using-templates" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="881b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，现在如果所有阶段都成功了，并且如果正在讨论的构建是针对主分支的，那么我们可以像以前一样构建和推送结果映像。</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="4adf" class="ld le iq kz b gy lf lg l lh li">if (env.BRANCH_NAME == "master") {<br/>            //Release stage is only executed from the 'master' branch<br/>            stage('Tagging Source Code') {<br/>                values = version.tokenize(".")<br/>                def repositoryCommitterEmail = "<a class="ae kl" href="mailto:jenkins@iktech.io" rel="noopener ugc nofollow" target="_blank">jenkins@iktech.io</a>"<br/>                def repositoryCommitterUsername = "jenkinsCI"</span><span id="a0d4" class="ld le iq kz b gy lm lg l lh li">sh "git config user.email ${repositoryCommitterEmail}"<br/>                sh "git config user.name '${repositoryCommitterUsername}'"<br/>                sh "git tag -d v${values[0]} || true"<br/>                sh "git push origin :refs/tags/v${values[0]}"<br/>                sh "git tag -d v${values[0]}.${values[1]} || true"<br/>                sh "git push origin :refs/tags/v${values[0]}.${values[1]}"<br/>                sh "git tag -d v${version} || true"<br/>                sh "git push origin :refs/tags/v${version}"</span><span id="a1a9" class="ld le iq kz b gy lm lg l lh li">sh "git tag -a v${values[0]} -m \"passed CI\""<br/>                sh "git tag -a v${values[0]}.${values[1]} -m \"passed CI\""<br/>                sh "git tag -a v${version} -m \"passed CI\""<br/>                sh "git tag -a v${version}.${env.BUILD_NUMBER} -m \"passed CI\""<br/>                sh "git push --tags"<br/>            }<br/>            milestone()</span><span id="023d" class="ld le iq kz b gy lm lg l lh li">stage('Push Docker Image to the registry') {<br/>                container('buildkit') {<br/>                    try {<br/>                        sh """<br/>                            wget <a class="ae kl" href="https://amazon-ecr-credential-helper-releases.s3.us-east-2.amazonaws.com/0.6.0/linux-amd64/docker-credential-ecr-login" rel="noopener ugc nofollow" target="_blank">https://amazon-ecr-credential-helper-releases.s3.us-east-2.amazonaws.com/0.6.0/linux-amd64/docker-credential-ecr-login</a> -O /usr/local/bin/docker-credential-ecr-login<br/>          chmod 755 /usr/local/bin/docker-credential-ecr-login</span><span id="f581" class="ld le iq kz b gy lm lg l lh li">mkdir -p /root/.docker<br/>          cp /tmp/docker/config.json /root/.docker/<br/>                            buildctl build \<br/>                                 --frontend dockerfile.v0 \<br/>                                 --local context=. \<br/>                                 --local dockerfile=. \<br/>                                 --output type=image,name=${image},push=true \<br/>                                 --export-cache type=local,dest=/tmp/buildkit/cache \<br/>                                 --import-cache type=local,src=/tmp/buildkit/cache \<br/>                                 --opt network=host \<br/>                                 --opt build-arg:version=${version} \<br/>                                 --opt build-arg:build_number=${env.BUILD_NUMBER}<br/>                            buildctl build \<br/>                                --frontend dockerfile.v0 \<br/>                                --local context=. \<br/>                                --local dockerfile=. \<br/>                                --output type=image,name=${repository}:latest,push=true \<br/>                                --export-cache type=local,dest=/tmp/buildkit/cache \<br/>                                --import-cache type=local,src=/tmp/buildkit/cache \<br/>                                --opt network=host \<br/>                                --opt build-arg:version=${version} \<br/>                                --opt build-arg:build_number=${env.BUILD_NUMBER}<br/>                        """<br/>                    } catch (error) {<br/>                        step([$class: 'Mailer',<br/>                            notifyEveryUnstableBuild: true,<br/>                            recipients: emailextrecipients([[$class: 'CulpritsRecipientProvider'],<br/>                                                            [$class: 'RequesterRecipientProvider']]),<br/>                            sendToIndividuals: true])<br/>                            throw error<br/>                    }<br/>                }<br/>            }</span><span id="5733" class="ld le iq kz b gy lm lg l lh li">stage('Publish Service docker image version to the artifactz.io') {<br/>                publishArtifact name: 'service',<br/>                                description: 'Test Service',<br/>                                type: 'DockerImage',<br/>                                stage: 'Development',<br/>                                flow: 'Simple',<br/>                                version: "${version}.${env.BUILD_NUMBER}"<br/>            }</span><span id="4eeb" class="ld le iq kz b gy lm lg l lh li">stage('Push Service docker image version to the Automated Integration Testing stage') {<br/>                pushArtifact name: 'service', stage: 'Development'<br/>            }<br/>        } else {<br/>            echo 'Skipping release for branch [' + env.BRANCH_NAME + ']. Release are only executed from the master.'<br/>            stage('Notify') {<br/>                node('master') {<br/>                    if(!hudson.model.Result.SUCCESS.equals(currentBuild.getPreviousBuild()?.getResult())) {<br/>                        step([$class: 'Mailer',<br/>                            notifyEveryUnstableBuild: true,<br/>                            recipients: emailextrecipients([[$class: 'CulpritsRecipientProvider'],<br/>                                                            [$class: 'RequesterRecipientProvider']]),<br/>                            sendToIndividuals: true])<br/>                    }<br/>                }<br/>            }<br/>        }</span></pre><p id="9d9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，Buildkit为我们在管道中的工作提供了很大的灵活性。</p></div></div>    
</body>
</html>