<html>
<head>
<title>Dependency injection vs stubbing in Javascript tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript测试中的依赖注入与存根</h1>
<blockquote>原文：<a href="https://itnext.io/dependency-injection-vs-stubbing-in-javascript-tests-769759900cb3?source=collection_archive---------8-----------------------#2018-03-04">https://itnext.io/dependency-injection-vs-stubbing-in-javascript-tests-769759900cb3?source=collection_archive---------8-----------------------#2018-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2702" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们最近一直在尝试用<a class="ae kl" href="https://aws.amazon.com/lambda/features/" rel="noopener ugc nofollow" target="_blank"> AWS Lambdas </a>作为一个项目的技术栈<a class="ae kl" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>。在那之前，我最近一次接触Javascript是在去年，当时我们做了一个<a class="ae kl" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React应用</a>(当时我对React一无所知)。在那之前，我最后一次遇到是在2015年，当时我在做一个<a class="ae kl" href="http://backbonejs.org/" rel="noopener ugc nofollow" target="_blank"> Backbone.js </a>项目。</p><p id="2486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在react项目中，我们使用了<a class="ae kl" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest框架</a>，而主干框架使用了<a class="ae kl" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank"> Jasmine </a>。可以说，我已经接触了一些javascript测试，但仍然不够。</p><p id="ee93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们当前的项目中，我需要做一些单元测试，因为我主要是一名Ruby开发人员，所以我主要只是将我在Ruby中的习惯翻译成Javascript。如果你是双语者(像我一样)，你会知道有时有些单词、习语等没有直接的翻译。编程语言也是如此——尤其是那些具有不同范例的语言。</p><p id="c49d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Ruby中，我们通常的单元测试方法是简单地将服务、<a class="ae kl" href="https://www.google.com.au/search?q=ruby+poro" rel="noopener ugc nofollow" target="_blank"> POROs </a>等存根化。使用模拟。这里有一个人为的例子。假设您有一个向API发送请求的类。该类使用RouteBuilder类，如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">RouteBuilder只是接受一些参数，并在您调用“run”时返回一个URL。</figcaption></figure><p id="ae85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在Ruby中测试这一点，我们通常只需要存根RouteBuilder，这样我们就可以轻松地设置如下场景:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="df28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是回顾一下，我们基本上只是说在测试中，每当调用<code class="fe kx ky kz la b">RouteBuilder.new</code>时，它都会返回一个根据上下文表现不同的假的(在这种情况下，它要么抛出一个错误，要么返回一个有效的URL)。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi li"><img src="../Images/92f1573dd4cb9259f29285ffebd77fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NI2IPn9ZLMk4-3aZwUGoSQ.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">胜利的依赖注入！(有时)</figcaption></figure><p id="07e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在在Javascript领域，我一直在做(或者至少是试图做)同样的事情。如果我们遵循我们团队在Ruby中的POROs模式，我们总是实例化和对象化，并有一个名为<code class="fe kx ky kz la b">run</code>的方法，这就很好了。不同之处在于，在Javascript中，您可以像这样导出一个函数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="9989" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给定一个这样使用它的类:</p><pre class="km kn ko kp gt lp la lq lr aw ls bi"><span id="57e1" class="lt lu iq la b gy lv lw l lx ly">const routeBuilder = require('../lib/routeBuilder')</span><span id="9356" class="lt lu iq la b gy lz lw l lx ly">module.exports.run = (params, context, callback) =&gt; {<br/>  const endpoint = routeBuilder.myUrl(params.uploader, 'update')</span><span id="2228" class="lt lu iq la b gy lz lw l lx ly">  ...<br/>end</span></pre><p id="9392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我试着做同样的事情，把它踩断:</p><pre class="km kn ko kp gt lp la lq lr aw ls bi"><span id="e72a" class="lt lu iq la b gy lv lw l lx ly">routeBuilderMock = sinon.stub(routeBuilder, 'myUrl')<br/>routeBuilderMock.withArgs('some-uploader').returns('/api/test')</span></pre><p id="258b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这确实有效。但是对于一些函数，尤其是纯函数，很难做到这一点(至少对我来说)，因为<a class="ae kl" href="https://github.com/sinonjs/sinon/issues/562" rel="noopener ugc nofollow" target="_blank"> sinon不支持它。</a>我想这是因为它是一种气味(从功能的角度来说),所以我四处打听了一下。<a class="ae kl" href="https://github.com/rstacruz/" rel="noopener ugc nofollow" target="_blank">里科斯塔。克鲁兹</a>建议<a class="ae kl" href="http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript" rel="noopener ugc nofollow" target="_blank">依赖注入</a>让我的生活更轻松。</p><p id="a372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在Ruby中，依赖注入也是我们使用的一种模式。我们通常将它用于在每个环境中具有不同行为的对象(登台、生产等)。)在函数式范例中，这使我们的生活变得更容易，因为现在我们甚至不需要存根！只需传入假的对象/函数或其他东西，让它按照我们想要的方式运行。</p><p id="7380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们通过修改使用我们的路径构建器的函数来尝试一下:</p><pre class="km kn ko kp gt lp la lq lr aw ls bi"><span id="3594" class="lt lu iq la b gy lv lw l lx ly">const defaultRouteBuilder = require('../lib/routeBuilder')</span><span id="826d" class="lt lu iq la b gy lz lw l lx ly">module.exports.run = (params, context, callback) =&gt; {<br/>  const routeBuilder = context.routeBuilder || defaultRouteBuilder</span><span id="690a" class="lt lu iq la b gy lz lw l lx ly">...<br/>end</span></pre><p id="67bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单快速的改变！基本上，我们现在将它设置为缺省值，让调用者可以选择通过<code class="fe kx ky kz la b">context</code>参数传入路线构建器，而不是只需要路线构建器函数并使用它。当被调用时，它看起来像这样:</p><pre class="km kn ko kp gt lp la lq lr aw ls bi"><span id="7dde" class="lt lu iq la b gy lv lw l lx ly">apiCaller.run('some-uploader', { routeBuilder: newRouteBuilder }, callback)</span></pre><p id="4584" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的测试中，更改也很容易:</p><pre class="km kn ko kp gt lp la lq lr aw ls bi"><span id="ad43" class="lt lu iq la b gy lv lw l lx ly">const routeBuilderMock = { dispatchUrl: () =&gt; '/api/test' }<br/>const context = { routeBuilder: routeBuilderMock }</span><span id="10c1" class="lt lu iq la b gy lz lw l lx ly">const result = apiCaller.run(params, context, callback)</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="3f06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，我们应该为我们的任务使用适当的工具。虽然我喜欢使用sinon或依赖注入来存根化路由生成器是如此容易，但是对于我们所有的函数来说，这样做可能是困难的(由于这样或那样的原因)。此外，有时我还想确保(在我的测试中)构建器得到正确的参数。如果我使用依赖注入，将会有更多的样板文件来测试它是否应该得到<code class="fe kx ky kz la b">some-uploader</code>作为它的参数。</p><p id="c433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，Jest似乎也已经可以访问几乎所有这些，所以在接下来的几周内，我将尝试将其纳入我们的测试套件。</p><p id="8c6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，存根和依赖注入对测试都很重要。选择哪种风格取决于您的用例和测试设置——如果您想要测试传递给函数的参数并控制它返回什么，请使用<a class="ae kl" href="http://sinonjs.org/releases/v4.3.0/stubs/" rel="noopener ugc nofollow" target="_blank"> sinon或stubbing </a>(尤其是检查参数的样式)，如果您只想模拟某些东西而不考虑参数，那么依赖注入将为您完成这项工作。</p></div></div>    
</body>
</html>