<html>
<head>
<title>Make implicit and explicit animations with the animated_styled_widget package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用animated_styled_widget包制作隐式和显式动画</h1>
<blockquote>原文：<a href="https://itnext.io/make-implicit-and-explicit-animations-with-the-responsive-styled-widget-package-7303bffe5c53?source=collection_archive---------9-----------------------#2021-03-15">https://itnext.io/make-implicit-and-explicit-animations-with-the-responsive-styled-widget-package-7303bffe5c53?source=collection_archive---------9-----------------------#2021-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dbdeba676a3f8e612e9a38838e0559ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_HfQ7xa6kqS3_cw2eK_2EQ.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这就是我们将在本文中实现的目标</figcaption></figure><p id="42a4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://pub.dev/packages/animated_styled_widget" rel="noopener ugc nofollow" target="_blank"> animated_styled_widget </a>包刚刚升级到支持明确的动画。如果您不知道该软件包以前可以做什么，这里有一个简短的回顾:</p><ol class=""><li id="84ac" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">还有Style类，它是主要UI元素的响应数据类，如宽度、高度、边距、填充、背景装饰、形状、阴影、变换、文本样式等。从某种意义上来说，它们是响应性的，因为所有这些类都接受一个Dimension实例，而该实例的本意是一个double px值。例如，您可以这样写:</li></ol><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="893d" class="lt lu iq lp b gy lv lw l lx ly">var width = Dimension.clamp(100.toPXLength, 10.toVWLength, 200.toPXLength);</span></pre><p id="ee05" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">其规定宽度为屏幕宽度的10%,但也限制在100像素和200像素之间。点击查看尺寸包<a class="ae la" href="https://pub.dev/packages/dimension" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7e25" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">样式的定义如下:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="ab06" class="lt lu iq lp b gy lv lw l lx ly">Style style = Style(<br/>  width: 80.toVMINLength,<br/>  height: 80.toVMINLength,<br/>  backgroundDecoration: BoxDecoration(<br/>      gradient:<br/>          LinearGradient(colors: [Colors.<em class="lz">cyanAccent</em>, Colors.<em class="lz">purpleAccent</em>])),<br/>  shapeBorder: RectangleShapeBorder(<br/>          cornerStyles: RectangleCornerStyles.all(CornerStyle.cutout),<br/>          borderRadius: DynamicBorderRadius.all(<br/>              DynamicRadius.circular(100.toPercentLength))),<br/>);</span></pre><p id="3ce8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.样式实例将被提供给StyledContainer类，该类为您提供了一个容器小部件。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="7ede" class="lt lu iq lp b gy lv lw l lx ly">Widget widget = StyledContainer(<br/>  style: style,<br/>  child: child<br/>  );</span></pre><p id="a03f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.您可以轻松地使StyledContainer隐式动画化。只需使用AnimatedStyledContainer类:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="724e" class="lt lu iq lp b gy lv lw l lx ly">Widget widget = AnimatedStyledContainer(<br/>  curve: Curves.linear,<br/>  duration: Duration(milliseconds: 100),<br/>  style: toggleStyle ? beginStyle : endStyle,<br/>  child: child<br/>);</span></pre><p id="42bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当您在开始样式和结束样式之间切换时，小部件将在两种样式之间自动显示动画。</p><p id="cef1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下是AnimatedStyledContainer可以实现的一些效果:</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="8e29" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基本上，这个包给了你一个超级容器/动画容器类。</p><h1 id="5d00" class="mc lu iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">现在我们来谈谈显性动画</h1><p id="b08d" class="pw-post-body-paragraph kc kd iq ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">隐式动画易于使用，但无法实现我们想要的每一种效果。这就是我设计ExplicitAnimatedStyledContainer类的原因:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="707b" class="lt lu iq lp b gy lv lw l lx ly">Widget widget = ExplicitAnimatedStyledContainer(<br/>  style: style,<br/>  child: child,<br/>  localAnimations: localAnimations,<br/>  globalAnimationIds: globalAnimationIds,<br/>  id: id,<br/>  ...<br/>);</span></pre><p id="ffc4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您仍然为小部件提供初始样式，但是随后您使用局部/全局动画来制作小部件样式的动画。让我们先来谈谈本地动画:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="efcd" class="lt lu iq lp b gy lv lw l lx ly">Map&lt;AnimationTrigger, MultiAnimationSequence&gt; localAnimations</span></pre><p id="df27" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它是AnimationTrigger和MultiAnimationSequence之间的映射。当前支持的AnimationTrigger如下:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="939a" class="lt lu iq lp b gy lv lw l lx ly">enum AnimationTrigger {<br/>  mouseEnter,<br/>  mouseExit,<br/>  tap,<br/>  visible,<br/>  scroll,<br/>}</span></pre><p id="f09f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当触发事件发生时(例如，您点击了这个小部件)，相应的MultiAnimationSequence被触发。多动画序列包含一个序列映射:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="8302" class="lt lu iq lp b gy lv lw l lx ly">Map&lt;AnimationProperty, AnimationSequence&gt; sequences</span></pre><p id="abc1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">其中AnimationProperty是对应于Style类的每个属性的枚举类，AnimationSequence是一个通用值、持续时间、延迟和曲线的列表，它告诉我们某个动画属性是如何发展的。例如:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="65e0" class="lt lu iq lp b gy lv lw l lx ly">MultiAnimationSequence(sequences: {<br/>AnimationProperty.width: AnimationSequence()<br/>  ..add(<br/>      delay: Duration(seconds: 1),<br/>      duration: Duration(milliseconds: 200),<br/>      curve: Curves.<em class="lz">linear</em>,<br/>      value: 100.toPXLength)<br/> ..add(<br/>      duration: Duration(milliseconds: 200),<br/>      curve: Curves.<em class="lz">easeIn</em>,<br/>      value: 200.toPXLength)<br/>});</span></pre><p id="45d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将延迟1秒，然后在200毫秒内将宽度从当前值动画显示为100像素，然后在200毫秒内动画显示为200像素。您可以使用相同的语法制作其他属性的动画。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2a14" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种鼠标悬停效果是通过编写以下内容实现的:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="6dcc" class="lt lu iq lp b gy lv lw l lx ly">Widget widget = ExplicitAnimatedStyledContainer(<br/>  style: style,<br/>  child: child,<br/>  localAnimations: {<br/>  AnimationTrigger.mouseEnter: enterSequence,<br/>  AnimationTrigger.mouseExit: exitSequence,<br/>  }<br/>);</span></pre><p id="1a37" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">鼠标的进入和退出可以有不同的持续时间和曲线，不同的样式属性也可以有不同的持续时间和曲线。</p><p id="31e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在来说说其他的动画触发器。AnimationTrigger.tap很容易理解。当小部件在视口中可见时，将触发AnimationTrigger.visible(通过使用<a class="ae la" href="https://pub.dev/packages/visibility_detector" rel="noopener ugc nofollow" target="_blank"> visibility_detector </a>包)。当小部件位于可滚动窗口(如ListView)中时，就会触发AnimationTrigger.scroll。然后，小部件将根据其沿滚动方向的位置显示动画:</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/dc4e851389ec543de39ce2de07ead03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_2GAMARiC26xPdZQKi_Jg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">动画进度从0%到100%</figcaption></figure><p id="2390" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">默认情况下，动画进度的计算方法如上图所示(如果水平滚动)。但是您也可以使用两个百分比偏移使动画提前或推迟开始/结束。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在垂直和水平方向滚动动画</figcaption></figure><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一个长的动画，我们慢慢地动画每个属性</figcaption></figure><h1 id="8b43" class="mc lu iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">预设动画</h1><p id="4a5a" class="pw-post-body-paragraph kc kd iq ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">现在这些多动画序列看起来很强大，但编码起来也很复杂。我准备了一些通用的预定义动画。它们被分为入口、注意力寻求者和出口。例如，一个称为SlideInAnimation的常见入口动画被定义为:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="9da4" class="lt lu iq lp b gy lv lw l lx ly">class SlideInAnimation extends PresetAnimation {<br/>  final AxisDirection direction;<br/>  final Dimension distance;<br/>  const SlideInAnimation(<br/>      {this.distance = const Length(100, unit: LengthUnit.vmax),<br/>      this.direction = AxisDirection.up,<br/>      Duration duration = const Duration(seconds: 1),<br/>      Duration delay = Duration.<em class="lz">zero</em>,<br/>      Curve curve = Curves.<em class="lz">linear</em>,<br/>      CustomAnimationControl control = CustomAnimationControl.PLAY})<br/>      : super(duration: duration, delay: delay, curve: curve, control: control);<br/>  ...<br/>}</span></pre><p id="8c5f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以配置滑动距离和方向，以及持续时间、延迟、曲线和控制(动画应该播放一次还是无限播放)。其他预定义的动画有:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="ad2e" class="lt lu iq lp b gy lv lw l lx ly">FadeInAnimation<br/>ZoomInAnimation<br/>FadeOutAnimation<br/>SlideOutAnimation<br/>ZoomOutAnimation<br/>FlipAnimation<br/>FlashAnimation<br/>PulseAnimation<br/>SwingAnimation<br/>WobbleAnimation<br/>RainbowAnimation<br/>ElevateAnimation<br/>...</span></pre><p id="5a32" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以这样使用它们:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="1f76" class="lt lu iq lp b gy lv lw l lx ly">Widget widget = ExplicitAnimatedStyledContainer(<br/>  style: style,<br/>  child: child,<br/>  localAnimations: {<br/>  AnimationTrigger.visible:                                                       FadeInAnimation().getAnimationSequences()<br/>  }<br/>);</span></pre><p id="68b7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后每次小工具移动到屏幕上，它就会淡入(不透明度从0到1)。多动画序列的另一个特性是能够合并或扩展其他多动画序列。所以你可以这样做:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="a90a" class="lt lu iq lp b gy lv lw l lx ly">Widget widget = ExplicitAnimatedStyledContainer(<br/>  style: style,<br/>  child: child,<br/>  localAnimations: {<br/>  AnimationTrigger.visible: FadeInAnimation().getAnimationSequences()..merge(<br/>SlideInAnimation().getAnimationSequences())<br/>  }<br/>);</span></pre><p id="899a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后小工具将会淡入淡出。如果使用extend，动画将一个接一个播放。预设动画使动画更容易使用，同时还为您提供了很大的灵活性。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一个简单的动画编辑器，让您在各种预设动画中进行选择</figcaption></figure><h1 id="3110" class="mc lu iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">全局显式动画</h1><p id="0f8e" class="pw-post-body-paragraph kc kd iq ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">如果我们想在不同的窗口小部件之间错开动画，我们可以通过提供全局动画来实现。全局动画包含字符串和多动画序列之间的映射，其中字符串是小部件的标识符。您提供了所有您想要在动画池中使用的全局动画。然后你可以像这样触发一个全局动画:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="2043" class="lt lu iq lp b gy lv lw l lx ly">var animationPool = {<br/>"animation1": GlobalAnimation(sequences: {<br/>"container1" : sequence1,<br/>"container2": sequence2,<br/>...})<br/>}</span><span id="cbad" class="lt lu iq lp b gy nf lw l lx ly">...</span><span id="69fd" class="lt lu iq lp b gy nf lw l lx ly">ChangeNotifierProvider&lt;GlobalAnimationNotifier&gt;(<br/>    create: (_) =&gt;<br/>        GlobalAnimationNotifier(animationPool: animationPool), child: child<br/>)</span><span id="1256" class="lt lu iq lp b gy nf lw l lx ly">...</span><span id="9c8a" class="lt lu iq lp b gy nf lw l lx ly">Widget widget = ExplicitAnimatedStyledContainer(<br/>  id: "container1",<br/>  style: style,<br/>  child: child,<br/>  globalAnimationIds: {<br/>  AnimationTrigger.visible: "animation1"  <br/>  }<br/>);</span></pre><p id="0332" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">id不必是唯一的。您可以拥有多个id相同的小部件，这样它们将在同一个全局动画下进行动画制作。请注意，如果小部件根本不使用全局动画，就不需要id。</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">浮动动作按钮触发的交错全局动画</figcaption></figure><p id="7eed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在你有了<a class="ae la" href="https://pub.dev/packages/animated_styled_widget" rel="noopener ugc nofollow" target="_blank">动画_样式_容器</a>包的隐式和显式动画。此套件中还有其他功能，如:</p><ol class=""><li id="f39e" class="lb lc iq ke b kf kg kj kk kn ld kr le kv lf kz lg lh li lj bi translated">一切都是可序列化的。所以你可以设计、存储和重用这些样式和动画。</li><li id="1daf" class="lb lc iq ke b kf ng kj nh kn ni kr nj kv nk kz lg lh li lj bi translated">您可以通过调用ExplicitAnimatedStyledContainer的子容器内部的类似内容，以编程方式更改动画的状态:</li></ol><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="d66d" class="lt lu iq lp b gy lv lw l lx ly">Provider.<em class="lz">of</em>&lt;LocalAnimationNotifier&gt;(context, listen: false)<br/> .updateAnimationStatus(animationSequence, status);<br/>Provider.<em class="lz">of</em>&lt;GlobalAnimationNotifier&gt;(context, listen: false)<br/> .updateAnimationStatus(animationId, status);</span></pre><p id="3b3b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.您可以随动画一起提供对AnimationTrigger事件的回调:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="4c89" class="lt lu iq lp b gy lv lw l lx ly">Widget widget = ExplicitAnimatedStyledContainer(<br/>  style: style,<br/>  child: child,<br/>  localAnimations: {<br/>  AnimationTrigger.visible: animationSequence<br/>  },<br/>  onVisible: onVisible,<br/>);</span></pre><p id="75bf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个包仍在快速开发中，仍然缺乏文档。所以请耐心等待，并提供您的反馈。在<a class="ae la" href="https://pub.dev/packages/responsive_styled_widget" rel="noopener ugc nofollow" target="_blank">发布与开发</a>上查看。谢谢大家！</p></div></div>    
</body>
</html>