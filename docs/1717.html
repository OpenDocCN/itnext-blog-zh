<html>
<head>
<title>RxJS-Toolkit: Convenient everyday RxJS utilities with pipeable operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS-Toolkit:方便的日常RxJS工具，带有可管道化的操作器</h1>
<blockquote>原文：<a href="https://itnext.io/rxjs-toolkit-convenient-everday-rxjs-utilities-with-pipeable-operators-a3ba09d22cf3?source=collection_archive---------2-----------------------#2019-01-09">https://itnext.io/rxjs-toolkit-convenient-everday-rxjs-utilities-with-pipeable-operators-a3ba09d22cf3?source=collection_archive---------2-----------------------#2019-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/c6aafabd184abc4ca50ea957406e9af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*vXJ4-TZd2cNfForoLNes1A.png"/></div></figure><div class=""/><blockquote class="ju jv jw"><p id="89d5" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">rxjs-toolkit现已无人维护，并作为现有技术保留下来，以供将来参考。请注意，有些运算符在IE11中不起作用。10/5/19</p></blockquote><p id="8212" class="pw-post-body-paragraph jx jy ix ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">这是<code class="fe kz la lb lc b">rxjs-toolkit</code>的开始，这是一个基于自定义<a class="ae ld" href="https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md" rel="noopener ugc nofollow" target="_blank">管道操作符</a>的小型实用程序库，专注于可重用性和日常使用。目前只有一小部分可用，随着时间的推移，会有更多的可用。</p><p id="bec5" class="pw-post-body-paragraph jx jy ix ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">通过您喜欢的节点包管理器安装<code class="fe kz la lb lc b">rxjs-toolkit</code>:</p><pre class="le lf lg lh gt li lc lj lk aw ll bi"><span id="94af" class="lm ln ix lc b gy lo lp l lq lr">npm i rxjs-toolkit<br/>yarn add rxjs-toolkit</span></pre><p id="0c49" class="pw-post-body-paragraph jx jy ix ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">下面是一些操作符，可以帮助您入门:</p><h1 id="17ad" class="ls ln ix bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">tapLog</h1><p id="7000" class="pw-post-body-paragraph jx jy ix ka b kb mp kd ke kf mq kh ki kw mr kl km kx ms kp kq ky mt kt ku kv ij bi translated">当谈到调试<code class="fe kz la lb lc b">RxJS</code>流时，通常最好的工具之一是使用<code class="fe kz la lb lc b">tap</code>操作符并记录通过的信号。在<code class="fe kz la lb lc b">rxjs-toolkit</code>，有一个叫做<code class="fe kz la lb lc b">tapLog</code>的运营商。</p><figure class="le lf lg lh gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="7f37" class="ls ln ix bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">ignoreFalsySignals</h1><p id="1e5b" class="pw-post-body-paragraph jx jy ix ka b kb mp kd ke kf mq kh ki kw mr kl km kx ms kp kq ky mt kt ku kv ij bi translated">有时，不需要的<code class="fe kz la lb lc b">null</code>或<code class="fe kz la lb lc b">undefined</code>值可能会被压入<code class="fe kz la lb lc b">Observable</code>流。我们可以在<code class="fe kz la lb lc b">map</code>中使用分支逻辑来缓解这些信号，或者使用<code class="fe kz la lb lc b">filter</code>操作符只让真信号通过。这是针对这种情况的<code class="fe kz la lb lc b">ignoreFalsySignals</code>操作符:</p><figure class="le lf lg lh gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e80a" class="pw-post-body-paragraph jx jy ix ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">这里有一个更合理的情况，当你有一个来自一个函数的流设置，这个函数正在调用一个API:</p><figure class="le lf lg lh gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e2a4" class="pw-post-body-paragraph jx jy ix ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">在上面的例子中，我们保证了信号不是虚假的，但是我们没有保证<code class="fe kz la lb lc b">signal.foo</code>的真实存在。我们可以用<code class="fe kz la lb lc b">propsAreTruthy</code>来解决这个问题。</p><h1 id="bcf3" class="ls ln ix bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">propsAreTruthy</h1><p id="9156" class="pw-post-body-paragraph jx jy ix ka b kb mp kd ke kf mq kh ki kw mr kl km kx ms kp kq ky mt kt ku kv ij bi translated">当一个对象在流中行进时，有时它对于给定的属性没有真值。我们可以使用<code class="fe kz la lb lc b">propsAreTruthy</code>操作符来检查是否所有的顶级属性都是真值。如果不是，信号将被映射到<code class="fe kz la lb lc b">false</code>:</p><figure class="le lf lg lh gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8ded" class="pw-post-body-paragraph jx jy ix ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">与检查所有顶级属性的默认设置不同，可以通过传递逗号分隔的字符串列表来检查特定属性和嵌套属性:</p><figure class="le lf lg lh gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="8c02" class="ls ln ix bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">composable:props are true+ignoreFalsyValues</h1><p id="c770" class="pw-post-body-paragraph jx jy ix ka b kb mp kd ke kf mq kh ki kw mr kl km kx ms kp kq ky mt kt ku kv ij bi translated">为了让我们的生活变得简单一点，我们可以一起使用这两个助手。</p><ul class=""><li id="9778" class="mw mx ix ka b kb kc kf kg kw my kx mz ky na kv nb nc nd ne bi translated">检查对象属性的真实性</li><li id="80ce" class="mw mx ix ka b kb nf kf ng kw nh kx ni ky nj kv nb nc nd ne bi translated">如果我们关心的对象属性为falsy，则忽略该信号</li><li id="f118" class="mw mx ix ka b kb nf kf ng kw nh kx ni ky nj kv nb nc nd ne bi translated">保持水流畅通，让下一个信号通过</li></ul><figure class="le lf lg lh gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="92f7" class="pw-post-body-paragraph jx jy ix ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">尽情享受吧！更多运营商即将推出:)</p></div></div>    
</body>
</html>