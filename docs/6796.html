<html>
<head>
<title>Understanding GTK Layouts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解GTK布局</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-gtk-layouts-13e5a36256fa?source=collection_archive---------0-----------------------#2022-02-28">https://itnext.io/understanding-gtk-layouts-13e5a36256fa?source=collection_archive---------0-----------------------#2022-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="958b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用GTK UI工具包的GUI布局，重点是GtkBuilder XML格式。理解打包、对齐、填充和扩展等概念。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2fd5a40e132a0b486e9a9cb740c9b470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YYQxKMpOwx8jlGW8l9IF7g.png"/></div></div></figure><p id="96e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章的目的是为那些想快速掌握GTK GUI布局而不需要大量阅读和实验的懒人创造一些东西。我们将通过视觉演示不同的布局选项在GTK是如何工作的来做到这一点。</p><p id="a0ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们将关注对齐和打包的概念，因为这些概念对于初学者来说是最不明显的。</p><p id="e4ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在大多数例子中，我将使用一个放置在布局容器中的按钮。按钮的类型是<a class="ae lq" href="https://docs.gtk.org/gtk3/class.Button.html" rel="noopener ugc nofollow" target="_blank"> GtkButton </a>，我将在示例中使用的布局容器是<a class="ae lq" href="https://docs.gtk.org/gtk3/class.Box.html" rel="noopener ugc nofollow" target="_blank"> GtkBox </a>和<a class="ae lq" href="https://docs.gtk.org/gtk3/class.Grid.html" rel="noopener ugc nofollow" target="_blank"> GtkGrid </a>。请记住，<code class="fe lr ls lt lu b">GtkBox</code>可以垂直或水平放置。</p><p id="94c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在示例中，我们将探索GTK组件如何根据我们选择的<strong class="kw iu">对准</strong>和<strong class="kw iu">包装</strong>选项改变位置、扩展和收缩。</p><h1 id="b4f5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用GtkBuilder XML格式描述GUI</h1><p id="f8ae" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">在进入示例之前，快速介绍一下<a class="ae lq" href="https://glade.gnome.org" rel="noopener ugc nofollow" target="_blank"> Glade </a>和<a class="ae lq" href="https://docs.gtk.org/gtk3/class.Builder.html" rel="noopener ugc nofollow" target="_blank"> GtkBuilder </a>使用的XML格式是很有用的。Glade是一个GUI设计器应用程序，它以XML格式存储已设计的贵由，GtkBuilder类的实例可以读取这种格式。</p><p id="3032" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面你会看到一个以这种格式定义的极简GUI。这段代码所做的就是创建一个标题为<em class="ms"> Hello world </em>标识符为<code class="fe lr ls lt lu b">mywin</code>的空窗口。所有GTK组件都可以使用<code class="fe lr ls lt lu b">id</code> XML属性选择性地拥有一个标识符。</p><pre class="kj kk kl km gt mt lu mu mv aw mw bi"><span id="ffc9" class="mx lw it lu b gy my mz l na nb">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;interface&gt;<br/>    &lt;requires lib="gtk+" version="3.20"/&gt;<br/>    &lt;object class="GtkWindow" id="mywin"&gt;<br/>        &lt;property name="can_focus"&gt;False&lt;/property&gt;<br/>        &lt;property name="title"&gt;Hello world&lt;/property&gt; <br/>    &lt;/object&gt;<br/>&lt;/interface&gt;</span></pre><p id="e3ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些标识符使得从代码中访问GUI组件变得更加容易。例如，如果上面的XML文件名为<code class="fe lr ls lt lu b">hello.glade</code>，我可以用Julia代码加载它，并像这样更改标题:</p><pre class="kj kk kl km gt mt lu mu mv aw mw bi"><span id="cb37" class="mx lw it lu b gy my mz l na nb"><strong class="lu iu">using</strong> Gtk<br/><br/>builder = GtkBuilder(filename="hello.glade")<br/>win = builder["mywin"]<br/>set_gtk_property!(win, :title, "goodbye mars")</span></pre><p id="b3ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个GUI对象都用<code class="fe lr ls lt lu b">object</code> XML标签定义。每个对象可以有许多用<code class="fe lr ls lt lu b">property</code>标签定义的属性。使用<code class="fe lr ls lt lu b">child</code>标签将每个GUI对象放入一个父容器中，比如一个<code class="fe lr ls lt lu b">GtkBox</code>。在<code class="fe lr ls lt lu b">child</code>标签中，您可以为添加为子对象的对象指定<code class="fe lr ls lt lu b">packing</code>。</p><pre class="kj kk kl km gt mt lu mu mv aw mw bi"><span id="e3d2" class="mx lw it lu b gy my mz l na nb">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;interface&gt;<br/>    &lt;requires lib="gtk+" version="3.20"/&gt;<br/>    &lt;object class="GtkWindow" id="mywin"&gt;<br/>        &lt;property name="can_focus"&gt;False&lt;/property&gt;<br/>        &lt;property name="title"&gt;Hello world&lt;/property&gt;<br/>        <br/>        &lt;child&gt;<br/>            &lt;object class="GtkBox"&gt;<br/>                &lt;property name="orientation"&gt;vertical&lt;/property&gt;<br/>                <br/>                &lt;child&gt;<br/>                  &lt;object class="GtkSpinButton"&gt;<br/>                    &lt;property name="visible"&gt;True&lt;/property&gt;<br/>                  &lt;/object&gt;<br/>                  <br/>                  &lt;packing&gt;<br/>                    &lt;property name="expand"&gt;False&lt;/property&gt;<br/>                    &lt;property name="fill"&gt;True&lt;/property&gt;<br/>                  &lt;/packing&gt;<br/>                &lt;/child&gt;<br/>                <br/>            &lt;/object&gt;<br/>        &lt;/child&gt;        <br/>    &lt;/object&gt;<br/>&lt;/interface&gt;</span></pre><p id="7aea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你已经有了一些大概的了解，我们可以进入更具体的内容了。在下面的例子中，为了清楚起见，我将删除布局标记之外的XML代码。</p><h1 id="711e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在容器单元格内对齐GUI对象</h1><p id="586c" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">下面是一个定义文本标签的XML代码示例，该文本标签在其容器单元格中右对齐并垂直居中。</p><pre class="kj kk kl km gt mt lu mu mv aw mw bi"><span id="743a" class="mx lw it lu b gy my mz l na nb">&lt;object class="GtkLabel"&gt;<br/>  &lt;property name="halign"&gt;end&lt;/property&gt;<br/>  &lt;property name="valign"&gt;center&lt;/property&gt;<br/>  &lt;property name="label"&gt;Name&lt;/property&gt;<br/>&lt;/object&gt;</span></pre><p id="c35c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更好地理解对齐是如何工作的，我将使用一个插图来可视化对齐的组件和它的容器之间的关系。第一行显示了为<code class="fe lr ls lt lu b">halign</code>(水平对齐)属性设置不同值的效果。第二行显示了修改<code class="fe lr ls lt lu b">valign</code>(垂直对齐)属性值的效果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/1281e2661cb17541f71daf7a8b42526a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*kdbDIa17Z2fmWwcRVUWGDw.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">水平和垂直GtkBox中的对齐</figcaption></figure><p id="4e95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能会注意到，对齐方式与文字处理器或图形设计工具中文本的对齐方式非常相似。对齐指定了GUI对象如何放置在它所在的单元格中。在插图中，您可以看到容器有三个单元格，我们将<code class="fe lr ls lt lu b">GtkLabel</code>对象放在第一个单元格中。</p><h1 id="f151" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">指定带包装的容器单元</h1><p id="86bb" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">包装会影响GUI对象放在哪个容器单元中。因此，每个包装组件的可用属性取决于容器类型。<code class="fe lr ls lt lu b">GtkBox</code>与<code class="fe lr ls lt lu b">GtkGrid</code>具有不同的包装属性。</p><h2 id="f3eb" class="mx lw it bd lx nh ni dn mb nj nk dp mf ld nl nm mh lh nn no mj ll np nq ml nr bi translated">包装类型—添加开始的地方</h2><p id="5129" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">使用<code class="fe lr ls lt lu b">pack-type</code>我们可以指定是从头到尾添加组件还是相反。对于垂直放置的盒子，<code class="fe lr ls lt lu b">start</code>表示顶部，<code class="fe lr ls lt lu b">end</code>表示底部。使用<code class="fe lr ls lt lu b">start</code>，GUI组件被添加到容器中的第一个单元格，而<code class="fe lr ls lt lu b">end</code>会将其添加到容器中的最后一个单元格。</p><pre class="kj kk kl km gt mt lu mu mv aw mw bi"><span id="2dcc" class="mx lw it lu b gy my mz l na nb">&lt;child&gt;<br/>  &lt;object class="GtkButton"&gt;<br/>    &lt;property name="label"&gt;click me!&lt;/property&gt;<br/>  &lt;/object&gt;<br/>  &lt;packing&gt;<br/>    &lt;property name="pack-type"&gt;end&lt;/property&gt;<br/>  &lt;/packing&gt;<br/>&lt;/child&gt;</span></pre><p id="ba83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">start</code>和<code class="fe lr ls lt lu b">end</code>的含义会根据<code class="fe lr ls lt lu b">GtkBox</code>是配置为<code class="fe lr ls lt lu b">vertical</code>还是<code class="fe lr ls lt lu b">horizontal</code>(用<code class="fe lr ls lt lu b">orientation</code>属性指定)而有所不同</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/1f9083c6be01e88fc92c0b33fae183db.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ZsYPBL9jq-UoA65gfGJEww.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">卧式和立式GtkBox的包装类型</figcaption></figure><h2 id="8571" class="mx lw it bd lx nh ni dn mb nj nk dp mf ld nl nm mh lh nn no mj ll np nq ml nr bi translated">位置—直接定位控制</h2><p id="8eba" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">为了更好地控制GUI组件的位置，我们可以使用<code class="fe lr ls lt lu b">position</code>属性。该属性可以与<code class="fe lr ls lt lu b">pack-type</code>属性结合使用。这种组合只有在<code class="fe lr ls lt lu b">pack-typ</code>被设置为<code class="fe lr ls lt lu b">start</code>值时才有效，否则没有意义。</p><pre class="kj kk kl km gt mt lu mu mv aw mw bi"><span id="8627" class="mx lw it lu b gy my mz l na nb">&lt;child&gt;<br/>  &lt;object class="GtkButton"&gt;<br/>    &lt;property name="label"&gt;click me!&lt;/property&gt;<br/>  &lt;/object&gt;<br/>  &lt;packing&gt;<br/>      &lt;property name="pack-type"&gt;start&lt;/property&gt;<br/>      &lt;property name="position"&gt;0&lt;/property&gt;<br/>  &lt;/packing&gt;<br/>&lt;/child&gt;</span></pre><p id="91c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编号从0开始。如果子组件的数量不同，并且您希望保证将一个组件放在最后，那么使用带有<code class="fe lr ls lt lu b">end</code>值的<code class="fe lr ls lt lu b">pack-type</code>属性会更有意义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/d7ee4fc8542ade9f8072ebaa56fd4015.png" data-original-src="https://miro.medium.com/v2/format:webp/1*U1PDAwdvDe1R16Idz0gutQ.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">定位水平和垂直GtkBox</figcaption></figure><h2 id="5d1a" class="mx lw it bd lx nh ni dn mb nj nk dp mf ld nl nm mh lh nn no mj ll np nq ml nr bi translated">填充和扩展—空间消耗</h2><p id="4299" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated"><code class="fe lr ls lt lu b">fill</code> &amp; <code class="fe lr ls lt lu b">expand</code>打包设置影响GUI组件消耗多少空间。下面代码示例中的按钮占用了其布局单元格中的所有空间，但是布局单元格本身不会随着父单元格的增大而扩展。换句话说，当您调整包含窗口的大小时，按钮的大小看起来是固定的。</p><pre class="kj kk kl km gt mt lu mu mv aw mw bi"><span id="88c2" class="mx lw it lu b gy my mz l na nb">&lt;child&gt;<br/>  &lt;object class="GtkButton"&gt;<br/>    &lt;property name="label"&gt;click me!&lt;/property&gt;<br/>  &lt;/object&gt;<br/>  &lt;packing&gt;<br/>      &lt;property name="expand"&gt;False&lt;/property&gt;<br/>      &lt;property name="fill"&gt;True&lt;/property&gt;<br/>  &lt;/packing&gt;<br/>&lt;/child&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/3d5a11d6e46815dabc3df64cb3972c6a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*RtO4TwIdt8tcCJayRl3yww.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">填充和扩展如何影响空间需求</figcaption></figure><h1 id="b983" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置容器的边距和间距</h1><p id="b9d4" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">您可以指定容器的边距和间距。容器的边距在容器的内容和它的父容器之间创建了空间。</p><p id="6bec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，间距在容器的<em class="ms">子容器</em>之间。</p><pre class="kj kk kl km gt mt lu mu mv aw mw bi"><span id="1455" class="mx lw it lu b gy my mz l na nb">&lt;object class="GtkBox"&gt;<br/>    &lt;property name="margin-start"&gt;10&lt;/property&gt;<br/>    &lt;property name="margin-top"&gt;6&lt;/property&gt;<br/>    &lt;property name="orientation"&gt;vertical&lt;/property&gt;<br/>    &lt;property name="spacing"&gt;15&lt;/property&gt;<br/><br/>    &lt;child&gt;<br/>      ...  <br/>    &lt;/child&gt;<br/>    <br/>    &lt;child&gt;<br/>      ...  <br/>    &lt;/child&gt;<br/>    <br/>&lt;/object&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/48e29a2f7d41e3c76a420017d7b98dab.png" data-original-src="https://miro.medium.com/v2/format:webp/1*O9iffDb9UukbHocBe8qZww.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">调整边距和间距对容器的影响</figcaption></figure><h1 id="f51f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">外卖食品</h1><p id="eb48" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">我们看到的第一个设置，如对齐和打包，与单个GUI组件如何与它所在的单元相关联有关。相反，边距和间距对容器本身起作用。边距与父对象相关，而间距与子对象相关。</p><p id="d8d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些属性为你在GTK布局图形用户界面提供了很大的灵活性。</p><h1 id="76af" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">相关故事</h1><p id="bcfc" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">如果你对GTK编程或GUI设计感兴趣，你可能会对我的其他一些故事感兴趣。</p><ul class=""><li id="0c07" class="ns nt it kw b kx ky la lb ld nu lh nv ll nw lp nx ny nz oa bi translated"><a class="ae lq" href="https://towardsdev.com/hiccups-writing-gtk3-gui-code-in-julia-on-macos-2467483c2e78" rel="noopener ugc nofollow" target="_blank">在macOS上用Julia写GTK3 GUI代码时的打嗝</a> —在macOS上用Julia进入GTK编程时如何妥善处理回调、选择等问题。</li><li id="0a46" class="ns nt it kw b kx ob la oc ld od lh oe ll of lp nx ny nz oa bi translated"><a class="ae lq" href="https://erik-engheim.medium.com/understanding-visual-layout-in-gui-design-2fa91792edef" rel="noopener">理解GUI设计中的视觉布局</a>——你应该如何放置按钮、标签、单选按钮等来传达用户界面的意图？</li><li id="b0fc" class="ns nt it kw b kx ob la oc ld od lh oe ll of lp nx ny nz oa bi translated"><a class="ae lq" href="https://erik-engheim.medium.com/the-no-bullshit-guide-to-icon-design-and-usage-40948878dbbb" rel="noopener">图标设计和使用指南</a>——我读了太多关于如何设计好图标的无聊文章后写了这篇文章。从创建用户友好图标的角度来看，这是关于如何设计好图标的非常具体的建议。</li><li id="4184" class="ns nt it kw b kx ob la oc ld od lh oe ll of lp nx ny nz oa bi translated"><a class="ae lq" href="https://medium.com/swlh/what-makes-godot-engine-great-for-advance-gui-applications-b1cfb941df3b" rel="noopener">用Godot制作高级GUI应用程序是未来吗？</a> —我详细讲述了我使用视频游戏GUI工具包的经历，我对此印象深刻。这是我用过的最令人印象深刻的GUI工具包解决方案之一。</li><li id="b9c7" class="ns nt it kw b kx ob la oc ld od lh oe ll of lp nx ny nz oa bi translated"><a class="ae lq" href="https://erik-engheim.medium.com/godot-concepts-dda36c3fff91" rel="noopener"> Godot游戏引擎概念上</a></li></ul></div></div>    
</body>
</html>