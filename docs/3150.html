<html>
<head>
<title>React: Lifting state up is killing your app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应:提升状态会扼杀你的应用</h1>
<blockquote>原文：<a href="https://itnext.io/react-lifting-state-up-is-killing-your-app-3ad6f0e1213d?source=collection_archive---------0-----------------------#2019-10-13">https://itnext.io/react-lifting-state-up-is-killing-your-app-3ad6f0e1213d?source=collection_archive---------0-----------------------#2019-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/5568e1ea89a7295640ab76f80506e119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*mk2jEnHzliPOPETroEzMpQ.jpeg"/></div></figure><p id="dc0f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">&gt;我现在有了一个闪亮的新博客。阅读这篇文章的最新更新<a class="ae ks" href="https://blog.goncharov.page/react-lifting-state-up-is-killing-your-app" rel="noopener ugc nofollow" target="_blank">https://blog . goncharov . page/react-lifting-state-up-is-killing-your-app</a></p><p id="6c2d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你听说过“提升国家”吗？我猜你有，这就是你在这里的确切原因。React官方文档中列出的12个主要概念之一<a class="ae ks" href="https://reactjs.org/docs/lifting-state-up.html" rel="noopener ugc nofollow" target="_blank">怎么可能导致糟糕的性能？在本文中，我们将考虑实际情况。</a></p><h1 id="640e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">第一步:抬起来</h1><p id="d9f2" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我建议你创建一个简单的井字游戏。对于游戏，我们需要:</p><ol class=""><li id="ac6d" class="lw lx iq jw b jx jy kb kc kf ly kj lz kn ma kr mb mc md me bi translated">一些游戏状态。没有真正的游戏逻辑来判断我们是赢是输。只是一个简单的二维数组，填充了<code class="fe mf mg mh mi b">undefined</code>、<code class="fe mf mg mh mi b">”x”</code>或<code class="fe mf mg mh mi b">”0”</code>。</li></ol><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="09cf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2.一个父容器来存放我们游戏的状态。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6362" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">3.显示单个单元格状态的子组件。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d5c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-1" rel="noopener ugc nofollow" target="_blank">现场演示#1 </a></p><p id="41de" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">到目前为止看起来不错。一个你能以光速与之互动的完美反应场:)我们来增大尺寸。比方说，到100。是的，是时候点击演示链接并改变最上面的<code class="fe mf mg mh mi b">size</code>变量了。对你来说还算快吗？试试200或者使用Chrome 内置的<a class="ae ks" href="https://twitter.com/chromiumdev/status/961537247240753152?lang=en" rel="noopener ugc nofollow" target="_blank"> CPU节流。你现在是否发现在你点击一个单元格的时间和它的内容改变的时间之间有明显的延迟？</a></p><p id="a172" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们将<code class="fe mf mg mh mi b">size</code>改回10，并添加一些分析来调查原因。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b722" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-2" rel="noopener ugc nofollow" target="_blank">现场演示#2 </a></p><p id="371d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对，就是这样。简单的<code class="fe mf mg mh mi b">console.log</code>就足够了，因为它可以在每个渲染上运行。</p><p id="396f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么我们看到了什么？根据我们控制台中“单元格渲染”语句的数量(对于<code class="fe mf mg mh mi b">size</code> = N，应该是N ),似乎每次单个单元格发生变化时，整个字段都会重新渲染。</p><p id="3d7c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最显而易见的做法是按照React文档的建议添加一些键。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2acd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-3" rel="noopener ugc nofollow" target="_blank">现场演示#3 </a></p><p id="759f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，在再次增加<code class="fe mf mg mh mi b">size</code>后，我们发现问题仍然存在。如果我们能看到为什么任何组件呈现...幸运的是，我们可以在神奇的<a class="ae ks" href="https://reactjs.org/blog/2019/08/15/new-react-devtools.html" rel="noopener ugc nofollow" target="_blank"> React DevTools </a>的帮助下。它能够记录组件被渲染的原因。不过，您必须手动启用它。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/b28efc193f3a499b517e2dd94ecc8c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*4R0tOf2C__4qQ6Zy5Ncc0g.png"/></div></figure><p id="85fe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">启用后，我们可以看到所有的单元格都被重新渲染了，因为它们的道具发生了变化，特别是，<code class="fe mf mg mh mi b">setContent</code>道具。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/0984861d9bb83e5e4c463e93cdcc7f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKaFDYrSfqJeYVMPBU5wMA.png"/></div></div></figure><p id="7c8d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每个细胞有两个道具:<code class="fe mf mg mh mi b">content</code>和<code class="fe mf mg mh mi b">setContent</code>。如果单元格[0][0]更改，单元格[0][1]的内容不会更改。另一方面，<code class="fe mf mg mh mi b">setContent</code>在其结尾捕获了<code class="fe mf mg mh mi b">field</code>、<code class="fe mf mg mh mi b">cellI</code>和<code class="fe mf mg mh mi b">rowI</code>。<code class="fe mf mg mh mi b">cellI</code>和<code class="fe mf mg mh mi b">rowI</code>保持不变，但<code class="fe mf mg mh mi b">field</code>随着任何单元格的每次变化而变化。</p><p id="f406" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们重构代码，保持<code class="fe mf mg mh mi b">setContent</code>不变。</p><p id="d074" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了保持对<code class="fe mf mg mh mi b">setContent</code>的引用不变，我们应该去掉闭包。我们可以通过使我们的<code class="fe mf mg mh mi b">Cell</code>显式地将<code class="fe mf mg mh mi b">cellI</code>和<code class="fe mf mg mh mi b">rowI</code>传递给<code class="fe mf mg mh mi b">setContent</code>来消除<code class="fe mf mg mh mi b">cellI</code>和<code class="fe mf mg mh mi b">rowI</code>闭包。至于<code class="fe mf mg mh mi b">field</code>，我们可以利用<code class="fe mf mg mh mi b">setState</code> - <a class="ae ks" href="https://reactjs.org/docs/hooks-reference.html#functional-updates" rel="noopener ugc nofollow" target="_blank">的一个简洁特性，它接受回调</a>。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e30a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这使得<code class="fe mf mg mh mi b">App</code>看起来像这样</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="bda3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在<code class="fe mf mg mh mi b">Cell</code>必须将<code class="fe mf mg mh mi b">cellI</code>和<code class="fe mf mg mh mi b">rowI</code>传递给<code class="fe mf mg mh mi b">setContent</code>。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6859" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-4" rel="noopener ugc nofollow" target="_blank">现场演示#4 </a></p><p id="bc40" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们来看看DevTools的报告。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mv"><img src="../Images/07171353f3da7486f1f37a1d2db5cbea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yU5JXWl-Hx5wJRJcL5j35Q.png"/></div></div></figure><p id="8309" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">什么？！为什么上面写着“父母道具改变”？所以事情是这样的，每次我们的字段被更新时<code class="fe mf mg mh mi b">App</code>都会被重新渲染。因此，它的子组件被重新呈现。好的。stackoverflow说了什么关于React性能优化的有用的东西吗？互联网建议使用<code class="fe mf mg mh mi b">shouldComponentUpdate</code>或其近亲:<code class="fe mf mg mh mi b">PureComponent</code>和<code class="fe mf mg mh mi b">memo</code>。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="538b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-5" rel="noopener ugc nofollow" target="_blank">现场演示#5 </a></p><p id="3b74" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">耶！现在，一旦内容发生变化，只有一个单元格被重新呈现。但是等等……有什么惊喜吗？我们遵循最佳实践，并获得了预期的结果。邪恶的笑声应该在这里。既然我不在你身边，请尽可能努力去想象。继续在<a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-5" rel="noopener ugc nofollow" target="_blank">现场演示#5 </a>中增加<code class="fe mf mg mh mi b">size</code>。这一次你可能要用大一点的数字。然而，滞后仍然存在。为什么？？？</p><p id="095f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们再来看看DebTools的报告。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mw"><img src="../Images/f6c4fa0047fe830618ab548beab2c6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfnIg_BaMcxzFdslniPWJQ.png"/></div></div></figure><p id="be6c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">只有一张<code class="fe mf mg mh mi b">Cell</code>的渲染图，速度很快，但是还有一张<code class="fe mf mg mh mi b">App</code>的渲染图，花了不少时间。事情是，每次重新渲染<code class="fe mf mg mh mi b">App</code>时，每个<code class="fe mf mg mh mi b">Cell</code>都必须将其新道具与之前的道具进行比较。即使它决定不呈现(这正是我们的情况)，这种比较仍然需要时间。O(1)，但O(1)出现了<code class="fe mf mg mh mi b">size</code> * <code class="fe mf mg mh mi b">size</code>次！</p><h1 id="94e5" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">第二步:向下移动</h1><p id="3b32" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们能做些什么来解决这个问题？如果渲染<code class="fe mf mg mh mi b">App</code>花费我们太多，我们必须停止渲染<code class="fe mf mg mh mi b">App</code>。如果继续使用<code class="fe mf mg mh mi b">useState</code>在<code class="fe mf mg mh mi b">App</code>中托管我们的状态是不可能的，因为这正是触发重新渲染的原因。所以我们必须将我们的状态下移，让每个<code class="fe mf mg mh mi b">Cell</code>自己订阅状态。</p><p id="1119" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们创建一个专用的类，它将成为我们状态的容器。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6647" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么我们的<code class="fe mf mg mh mi b">App</code>可能是这样的:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1a7f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的<code class="fe mf mg mh mi b">Cell</code>可以自己显示来自<code class="fe mf mg mh mi b">field</code>的内容:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="00c2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-6" rel="noopener ugc nofollow" target="_blank">现场演示#6 </a></p><p id="3343" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这一点上，我们可以看到我们的领域正在呈现。然而，如果我们点击一个单元格，什么都不会发生。在日志中，我们可以看到每次点击的“setCell ”,但是单元格保持空白。这里的原因是没有什么告诉细胞重新渲染。我们在React之外的状态发生了变化，但是React并不知道。这种情况必须改变。</p><p id="9946" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们如何以编程方式触发渲染？</p><p id="0d9d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于类，我们有<a class="ae ks" href="https://reactjs.org/docs/react-component.html#forceupdate" rel="noopener ugc nofollow" target="_blank"> forceUpdate </a>。这是否意味着我们必须重新编写类的代码？不完全是。我们对功能组件所能做的是引入一些虚拟状态，我们改变它只是为了迫使我们的组件重新呈现。</p><p id="282a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是我们如何创建一个自定义钩子来强制重新渲染。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="35b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了在我们的字段更新时触发重新渲染，我们必须知道它何时更新。这意味着我们必须能够以某种方式订阅现场更新。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1ea8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以订阅现场更新。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b369" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-7" rel="noopener ugc nofollow" target="_blank">现场演示#7 </a></p><p id="356c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们用这个实现来玩一下<code class="fe mf mg mh mi b">size</code>。尝试将它增加到之前感觉滞后的值。和...是时候开一瓶上好的香槟了！我们开发了一个应用程序，只在一个单元格的状态发生变化时才显示该单元格。</p><p id="5591" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们来看看DevTools的报告。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mx"><img src="../Images/9c1100d9c95d4aeabdc954b22681ffd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZNR-oL01xUJEtpAan3COjg.png"/></div></div></figure><p id="e2da" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如我们现在看到的，只有<code class="fe mf mg mh mi b">Cell</code>被渲染，而且速度非常快。</p><p id="777e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果说我们的<code class="fe mf mg mh mi b">Cell</code>的now代码是内存泄漏的潜在原因呢？如你所见，在<code class="fe mf mg mh mi b">useEffect</code>中，我们订阅小区更新，但我们从不退订。这意味着即使<code class="fe mf mg mh mi b">Cell</code>被摧毁，它的订阅仍然存在。让我们改变这一点。</p><p id="7f16" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们需要教<code class="fe mf mg mh mi b">Field</code>什么是退订。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6f9a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以将<code class="fe mf mg mh mi b">unsubscribeCellUpdates</code>应用于我们的<code class="fe mf mg mh mi b">Cell</code>。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="18f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-8" rel="noopener ugc nofollow" target="_blank">现场演示#8 </a></p><p id="8ecf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么这里的教训是什么呢？什么时候将状态向下移动到组件树中是有意义的？绝不！嗯，不尽然:)坚持最佳实践，直到它们失败，不要做任何过早的优化。老实说，我们上面考虑的情况有些特殊，但是，如果你需要显示一个非常大的列表，我希望你能回忆起来。</p><h1 id="0193" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">额外的一步:现实世界的重构</h1><p id="56c1" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在<a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-8" rel="noopener ugc nofollow" target="_blank">现场演示#8 </a>中，我们使用了全局<code class="fe mf mg mh mi b">field</code>，这在现实应用中是不应该的。为了解决这个问题，我们可以在我们的<code class="fe mf mg mh mi b">App</code>中托管<code class="fe mf mg mh mi b">field</code>，并使用<a class="ae ks" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>沿着树向下传递它。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0f28" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以在我们的<code class="fe mf mg mh mi b">Cell</code>中从上下文中消费<code class="fe mf mg mh mi b">field</code>。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="96bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://stackblitz.com/edit/lifting-state-up-is-killing-your-app-9" rel="noopener ugc nofollow" target="_blank">现场演示#9 </a></p><p id="afdd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">希望你已经找到了对你的项目有用的东西。请随时将您的反馈传达给我！我非常感谢任何批评和问题。</p><p id="b2a9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请在<a class="ae ks" href="https://twitter.com/ai_goncharov" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae ks" href="https://www.linkedin.com/in/aigoncharov/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我，继续关注新文章！订阅我的<a class="ae ks" href="https://blog.goncharov.page/" rel="noopener ugc nofollow" target="_blank">简讯</a>或者<a class="ae ks" href="https://blog.goncharov.page/rss.xml" rel="noopener ugc nofollow" target="_blank"> RSS </a>。如果你有任何问题，请给我发一封电子邮件。</p><p id="5318" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">UPD: <a class="ae ks" href="https://www.reddit.com/r/reactjs/comments/dhck3y/react_lifting_state_up_is_killing_your_app/" rel="noopener ugc nofollow" target="_blank">在Reddit上跟帖讨论</a></p></div></div>    
</body>
</html>