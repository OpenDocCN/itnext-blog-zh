<html>
<head>
<title>Flutter: BLOCs at Scale | 2 — Keeping BLOCs Lean</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤动:成比例的块| 2-保持块倾斜</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-blocs-at-scale-2-keeping-blocs-lean-1b659536e3ec?source=collection_archive---------0-----------------------#2022-08-02">https://itnext.io/flutter-blocs-at-scale-2-keeping-blocs-lean-1b659536e3ec?source=collection_archive---------0-----------------------#2022-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e18d6a5de75706665427d1c44d9657d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8id6T74oLv6xF91-07slkA.png"/></div></div></figure><h1 id="15b5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="3f24" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">欢迎来到<strong class="ky ir">集团</strong>系列<strong class="ky ir">第二部</strong>。</p><blockquote class="lu lv lw"><p id="1108" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated">如果你准备好用新的概念提升你的博客，这将使你的代码更健壮，更结构化，更不容易出错——你在正确的地方！</p></blockquote><p id="aa38" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">在<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/flutter-blocs-at-scale-1-the-state-machine-fce5f086d7b9"> <strong class="ky ir">上一篇文章</strong> </a>中，我们阐述了设计&amp;架构概念，这些概念有助于实现可伸缩的块。对于完整的图片，我强烈建议阅读第1部分之前，这一点。</p><p id="e7d0" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">本文主要关注前两个概念，它们将帮助您清理BLOCs，避免逻辑混乱和代码重复。</p><p id="605f" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">这个系列使用的是下面的<a class="ae mg" href="https://pub.dev/packages/bloc" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="lx"> BLOC包</em></strong><em class="lx">(pub . dev)</em></a><strong class="ky ir">。</strong></p><p id="798e" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">让我们开始吧！</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="3f94" class="mo jz iq bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">1.接吻——保持简单，分开🪓</h2><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cf6ec2125bde117a8b9ec9459fe6cf0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1s4jaOH0rRkG_z3K1VmWIw.png"/></div></div></figure><p id="2220" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">值得注意的是，一个集团的规模和复杂程度通常表明它可能有太多的责任。</p><p id="587f" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">挑战:</strong></p><ul class=""><li id="2095" class="ne nf iq ky b kz ly ld lz lh ng ll nh lp ni lt nj nk nl nm bi translated">在您的集团中维护或实现新逻辑变得越来越困难了吗？</li><li id="d7c6" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">当扩展集团的特性时，需要许多新的状态吗？</li></ul><p id="3d3b" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">例如:</strong></p><p id="2984" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">让我们用下面的例子来说明这些问题。</p><p id="969f" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">为了这个例子，让我们假设我们有一个预先存在的<code class="fe ns nt nu nv b"><strong class="ky ir">UserBloc</strong></code>来获取和存储用户相关的信息。如果你已经读过<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/flutter-blocs-at-scale-1-the-state-machine-fce5f086d7b9"> <strong class="ky ir"> PART1 </strong> </a>，那么你会记得它，因为我们已经在一步一步的过程中定义了整个状态机。</p><p id="232b" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">其状态机图如下所示:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/d9ba9b17124287fc4ccbb06b0d9de3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7yr5ipSvmZQcacgEr2TYg.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated"><strong class="bd ka"> UserBloc </strong>状态机图。</figcaption></figure><p id="872e" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">保存实际用户相关数据的<code class="fe ns nt nu nv b"><strong class="ky ir">UserInitialized</strong></code>抽象状态<em class="lx">(图中右侧虚线边框)</em>如下所示:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/c4c01b2f8ffedc6b163ce2f87d158465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkIQ8NxhZsXCDLEIUVG6PA.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated"><strong class="bd ka"> UserInitialized </strong>抽象状态实现。在上面的状态机图中，它表示保存数据的状态的右侧虚线边界框。</figcaption></figure><h2 id="dc7b" class="mo jz iq bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">功能请求:假设这是一个电子商务应用程序，用户可以将产品添加到他的购物车 🛒.对于这个用例，有多种方式来表示<strong class="ak">用户</strong>和<strong class="ak">购物车</strong>的状态。</h2><p id="edaf" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">❌ <strong class="ky ir">选项1 —(不)使用“添加另一项资产”方法</strong></p><p id="8e5c" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">一种简单的方法是尝试将购物车的状态添加到<code class="fe ns nt nu nv b"><strong class="ky ir">UserBloc</strong></code>中，因为购物车显然与用户相关。让我们向保存用户购物车中当前产品信息的<code class="fe ns nt nu nv b"><strong class="ky ir">UserInitialized</strong></code>状态添加一个新的自定义类型<code class="fe ns nt nu nv b"><strong class="ky ir">Cart</strong></code>的购物车属性。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/865204760c51250257f33188bbd60039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbpbL6Ai9lzGmcxmdUVUxQ.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated"><strong class="bd ka"> UserInitialized </strong>状态现在保存用户购物车的信息。</figcaption></figure><p id="f74a" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">如果我们之前只在<code class="fe ns nt nu nv b"><strong class="ky ir">UserBloc</strong></code> <em class="lx">上声明了几个事件(例如</em> <code class="fe ns nt nu nv b"><em class="lx">FetchUser</em></code> <em class="lx">、</em> <code class="fe ns nt nu nv b"><em class="lx">UpdateUser</em></code> <em class="lx"> ) </em>，我们现在需要添加相当多的额外事件<em class="lx">(例如</em> <code class="fe ns nt nu nv b"><em class="lx">AddToCart</em></code> <em class="lx">、</em> <code class="fe ns nt nu nv b"><em class="lx">RemoveFromCart</em></code> <em class="lx"> ) </em>。这也增加了<code class="fe ns nt nu nv b"><strong class="ky ir">UserBloc</strong></code>中可能的事件+状态组合的数量。</p><p id="7e16" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">如果您在这一点上没有看到这种方法的问题，作为一个练习，尝试用状态机图来表示这样的BLOC。您将很快注意到，设计一个清晰直观的状态机变得极其困难。</p><p id="02de" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><em class="lx">这是由于逻辑上不相关的内部状态属性(cart)合并到外部“父状态”(用户)中而发生的。</em></p><p id="18a2" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">✅ <strong class="ky ir">选择2 —(做)把它分成单独的集团</strong></p><p id="c514" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">与其给<code class="fe ns nt nu nv b"><strong class="ky ir">UserBloc</strong></code>增加新的职责，不如让它保持原样，创建一个新的集团，其唯一的目的是代表购物车的状态。这使我们能够清晰地设计状态机，并在以后轻松地扩展它。再也不用担心由于第一个例子中出现的逻辑不兼容而增加复杂性。</p><p id="053b" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><code class="fe ns nt nu nv b"><strong class="ky ir">CartBloc</strong></code>的一个极简实现<em class="lx">(仅使用本地购物车状态)</em>可能如下所示:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/dad19c8c234c69a975ab8c4d53adfedb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sNOK_Y9D4kc-6fUDHJjRdQ.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated"><strong class="bd ka"> CartBloc </strong>状态机图。</figcaption></figure><p id="f55b" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">解决方案:<br/> </strong>如果你的区块处理太多事情，把它们分成多个更小的区块，这样:</p><ul class=""><li id="7a39" class="ne nf iq ky b kz ly ld lz lh ng ll nh lp ni lt nj nk nl nm bi translated">每个逻辑状态对象都有自己块</li><li id="39a0" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">每个集团都有一个单一的责任</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="69b9" class="mo jz iq bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">2.介绍可重复使用的区块♻️</h2><p id="6388" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您已经使用BLOC完成了一个更大的项目，那么您可能会遇到多个BLOC，它们的状态机图几乎完全相同。</p><p id="33a6" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">在本节中，我们将看看如何通过引入<strong class="ky ir">可重用块</strong>来消除块之间的<strong class="ky ir">“代码重复”</strong>。</p><p id="8a42" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">挑战:</strong></p><ul class=""><li id="2373" class="ne nf iq ky b kz ly ld lz lh ng ll nh lp ni lt nj nk nl nm bi translated">您是否为行为方式非常相似的不同逻辑域反复编写相同的BLOC状态逻辑？</li><li id="6ae9" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">你的代码库中有很多重复的块逻辑吗？</li></ul><p id="68e8" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">例如:</strong></p><p id="fa94" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">让我们再次以<code class="fe ns nt nu nv b"><strong class="ky ir">UserBloc</strong></code>为例:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/d9ba9b17124287fc4ccbb06b0d9de3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7yr5ipSvmZQcacgEr2TYg.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated"><code class="fe ns nt nu nv b"><strong class="bd ka">UserBloc</strong> State Machine Diagram example from <a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/flutter-blocs-at-scale-1-the-state-machine-fce5f086d7b9"><strong class="bd ka">Part1</strong></a>.</code></figcaption></figure><p id="dd26" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">这个块的全部目的是获取一些远程API数据，并用它填充状态。这是现代应用程序中非常常见的用例，也可能导致大量代码重复。</p><p id="fd6c" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">假设我们现在想要添加一个<code class="fe ns nt nu nv b"><strong class="ky ir">ProductBloc</strong></code>，它负责从远程API数据中获取产品，并用它填充状态。</p><p id="6a8d" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">让我们试着想象一下这个<code class="fe ns nt nu nv b"><strong class="ky ir">ProductBloc</strong></code>的状态机图:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/36317076849aeeae2b7c38aaef19ae7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bWNJyCKipQIAmU860D5Lew.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated"><strong class="bd ka"> ProductBloc </strong>状态机图。</figcaption></figure><p id="e343" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">如你所见，<code class="fe ns nt nu nv b"><strong class="ky ir">UserBloc</strong></code>和<code class="fe ns nt nu nv b"><strong class="ky ir">ProductBloc</strong></code>的状态机实际上是一样的。在处理大规模应用程序时，这可能会发生多次，这是不必要的代码重复的一个重要标志。</p><blockquote class="of"><p id="0f3e" class="og oh iq bd oi oj ok ol om on oo lt dk translated">W <!-- -->如果我们可以通过引入可重用的<strong class="ak">块</strong>来消除状态逻辑的重复会怎么样？</p></blockquote><p id="bfe5" class="pw-post-body-paragraph kw kx iq ky b kz op lb lc ld oq lf lg lh or lj lk ll os ln lo lp ot lr ls lt ij bi translated"><strong class="ky ir">让我们一起探索吧！</strong></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><blockquote class="lu lv lw"><p id="2770" class="kw kx lx ky b kz ly lb lc ld lz lf lg ma mb lj lk mc md ln lo me mf lr ls lt ij bi translated">目标是替换<code class="fe ns nt nu nv b"><strong class="ky ir">UserBloc</strong></code>和<code class="fe ns nt nu nv b"><strong class="ky ir">ProductBloc</strong></code>内部的状态机逻辑副本。这可以通过利用从新创建的可重用块继承的逻辑来实现。</p></blockquote><p id="1e8c" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">第一步:设计</strong> <br/>让我们从实现一个抽象<code class="fe ns nt nu nv b"><strong class="ky ir">RemoteDataBloc</strong></code>开始，它将负责获取和处理远程数据。</p><p id="d8d5" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><em class="lx">其状态机图将与</em> <code class="fe ns nt nu nv b"><strong class="ky ir"><em class="lx">UserBloc</em></strong></code> <em class="lx">和</em> <code class="fe ns nt nu nv b"><strong class="ky ir"><em class="lx">ProductBloc</em></strong></code> <em class="lx">的状态机图相对应。</em></p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/c050868e422c6b3341872b30f423d8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hLuJ-V5MC1xqig3E0C5J0A.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated"><strong class="bd ka">远程数据块</strong>状态机图。</figcaption></figure><p id="28a5" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">实现将由以下文件组成:</p><ul class=""><li id="6a11" class="ne nf iq ky b kz ly ld lz lh ng ll nh lp ni lt nj nk nl nm bi translated">抽象块类(<code class="fe ns nt nu nv b">remote_data_bloc.dart</code>)</li><li id="e4c0" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">事件(<code class="fe ns nt nu nv b">remote_data_event.dart</code>)</li><li id="67c4" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">州(<code class="fe ns nt nu nv b">remote_data_state.dart</code>)</li><li id="6a64" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">事件处理器逻辑(<code class="fe ns nt nu nv b">remote_data_event_handler.dart</code> ) →分离事件+状态组合的处理器逻辑的帮助文件</li></ul><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ou"><img src="../Images/8ac8564e7ac28493b2dcec560ba100cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWZjm1vQN1oJFjngFYzQ9w.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">可重复使用的<strong class="bd ka"> RemoteDataBloc的文件夹结构。</strong></figcaption></figure><p id="79a2" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">步骤2:定义状态</strong> <br/>让我们从实现上面状态机图中的状态(<code class="fe ns nt nu nv b">remote_data_state.dart</code>)开始:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated"><strong class="ak"> remote_data_state.dart </strong>实现。</figcaption></figure><p id="d932" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">重要提示:</strong></p><ul class=""><li id="5102" class="ne nf iq ky b kz ly ld lz lh ng ll nh lp ni lt nj nk nl nm bi translated">如果你对mixins的用途感到好奇，可以随意阅读<a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/flutter-blocs-at-scale-1-the-state-machine-fce5f086d7b9"><strong class="ky ir">Flutter:BLOCs at Scale | 1—状态机</strong> </a> <strong class="ky ir">。</strong>简而言之——我们用它来过滤掉<strong class="ky ir">无操作</strong>。</li><li id="4808" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">为了使BLOC可重用，它需要接受任意数据类型。这里，我们通过定义类型<code class="fe ns nt nu nv b"><strong class="ky ir">Data</strong></code>的状态类来利用Dart的类型功能，如下所示:</li></ul><pre class="na nb nc nd gt ox nv oy oz aw pa bi"><span id="fde0" class="mo jz iq nv b gy pb pc l pd pe">abstract class RemoteDataState<strong class="nv ir">&lt;Data&gt; ...</strong></span></pre><p id="3888" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">第三步:定义事件让我们继续进行事件声明。因为这个块的主要功能是获取远程数据，所以它只保存一个名为<code class="fe ns nt nu nv b"><strong class="ky ir">FetchRemoteData</strong></code>的事件。</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="1a2c" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">步骤4:事件处理程序逻辑实现</strong> <br/>让我们将事件处理程序实现提取到一个单独的文件中，以保持块的干净。该文件保存了的<strong class="ky ir">逻辑，为<strong class="ky ir">发出每个有效事件+状态组合</strong>的新状态，如上面状态机图所示。</strong></p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="8e34" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">重要提示:<br/> </strong>从上面的状态机图可以看出，BLOC只需要处理<br/> 2种不同的事件+状态组合:</p><ul class=""><li id="1f04" class="ne nf iq ky b kz ly ld lz lh ng ll nh lp ni lt nj nk nl nm bi translated">初始获取— <code class="fe ns nt nu nv b"><strong class="ky ir">[FetchRemoteData]</strong>event + <strong class="ky ir">[RemoteDataUninitialized]</strong>state</code></li><li id="7d3f" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">Refetch — <code class="fe ns nt nu nv b"><strong class="ky ir">[FetchRemoteData]</strong>event + <strong class="ky ir">[RemoteDataLoaded]</strong>state</code></li></ul><p id="ece4" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">第五步:BLOC实现</strong> <br/>主BLOC文件负责:</p><ul class=""><li id="9fdd" class="ne nf iq ky b kz ly ld lz lh ng ll nh lp ni lt nj nk nl nm bi translated">用初始状态定义和初始化块</li><li id="68fa" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">初始化<code class="fe ns nt nu nv b"><strong class="ky ir">RemoteDataEventHandler</strong></code> <strong class="ky ir"> </strong>实例<em class="lx">(或者也可以作为依赖注入)</em></li><li id="08e3" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">注册顶级事件处理程序(<code class="fe ns nt nu nv b"><strong class="ky ir">on&lt;eventName&gt;</strong></code>关键字)</li><li id="632f" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">定义顶层事件处理逻辑函数，这些函数调用适当的<code class="fe ns nt nu nv b"><strong class="ky ir">RemoteDataEventHandler</strong></code> <strong class="ky ir"> </strong>函数。这些函数通常被命名为<code class="fe ns nt nu nv b">map&lt;eventName&gt;ToState()</code> <em class="lx">(例如</em> <code class="fe ns nt nu nv b"><em class="lx">mapFetchRemoteDataToState()</em></code> <em class="lx"> ) </em>。</li><li id="ae0f" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">提取函数的抽象实现<em class="lx">(将被实现块覆盖)</em></li></ul><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated"><strong class="ak"> remote_data_bloc.dart </strong>实现。</figcaption></figure><p id="98f1" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">重要提示:</strong></p><ul class=""><li id="1b9a" class="ne nf iq ky b kz ly ld lz lh ng ll nh lp ni lt nj nk nl nm bi translated"><strong class="ky ir">第9行:</strong>我们定义一个抽象类<code class="fe ns nt nu nv b"><strong class="ky ir">RemoteDataBloc&lt;Data&gt;</strong></code> <strong class="ky ir">。</strong>实现BLOC<em class="lx">(例如</em> <code class="fe ns nt nu nv b"><strong class="ky ir"><em class="lx">UserBloc</em></strong></code> <em class="lx"> ) </em>以后会扩展这个可重用的抽象BLOC类。</li><li id="8453" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated"><strong class="ky ir">第12–15行:</strong>我们用初始状态<code class="fe ns nt nu nv b"><strong class="ky ir">RemoteDataUninitialized</strong></code> <strong class="ky ir"> </strong>初始化BLOC，还初始化<code class="fe ns nt nu nv b"><strong class="ky ir">RemoteDataEventHandler</strong></code> <strong class="ky ir"> </strong>，这使我们能够访问调用事件处理程序的实现。这里也是定义顶级事件及其各自处理函数的地方。</li><li id="639b" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated"><strong class="ky ir">第17–37行:</strong>顶层事件处理程序逻辑函数，检测事件+状态组合，并将其传递给相应的<code class="fe ns nt nu nv b"><strong class="ky ir">RemoteDataEventHandler</strong></code> <strong class="ky ir"> </strong>处理程序<strong class="ky ir"> </strong>函数<strong class="ky ir">。</strong></li><li id="b72c" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated"><strong class="ky ir">第39–55行:</strong>可选的帮助器函数，以更简洁的方式将事件传递给相应的事件处理程序。</li><li id="a4c9" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated"><strong class="ky ir">第61行:</strong>获取将被实现块覆盖的函数。</li></ul><p id="e6a8" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated"><strong class="ky ir">结果:</strong></p><p id="42a1" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">在实现了<code class="fe ns nt nu nv b"><strong class="ky ir">RemoteDataBloc</strong></code>之后，我们现在可以通过重构<code class="fe ns nt nu nv b"><strong class="ky ir"><em class="lx">UserBloc</em></strong></code> <em class="lx">和</em> <code class="fe ns nt nu nv b"><strong class="ky ir"><em class="lx">ProductBloc</em></strong></code> <strong class="ky ir"> <em class="lx">来看到它的运行。</em> </strong></p><h2 id="d38b" class="mo jz iq bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated"><code class="fe ns nt nu nv b">UserBloc</code></h2><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h2 id="bf13" class="mo jz iq bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">产品区块</h2><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="0450" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">正如你在上面看到的，由于我们的可重用的<strong class="ky ir"> </strong> <code class="fe ns nt nu nv b"><strong class="ky ir">RemoteDataBloc</strong></code> <strong class="ky ir">，这些BLOCs的整个实现是<strong class="ky ir"> ~15行代码</strong>。</strong>如果您需要实现另一个块，其主要功能是获取一些远程数据——只需创建一个包含15行代码的新文件<em class="lx">(而不是大约200行)</em>并修改<code class="fe ns nt nu nv b"><strong class="ky ir">fetchAndParseData()</strong></code>函数。</p><p id="97eb" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">🏆就是这样！🏆</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="f0e1" class="mo jz iq bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">结论</h2><p id="feb0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">感谢您在BLOCs in scale的第2部分中走到这一步！</p><p id="7132" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">还有很多方法可以让BLOC在规模上更精简，我将在BLOC系列的第3部分与您分享。</p><p id="10fd" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">如果你的博客缺少本文所描述的一些东西，请随意尝试这些方法，并在评论中告诉我进展如何:)</p><p id="d8b4" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh mb lj lk ll md ln lo lp mf lr ls lt ij bi translated">如果你想用一些新的概念装备自己并提升你的团体游戏，请继续关注这个系列的剩余部分。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h2 id="efe4" class="mo jz iq bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">本系列文章</h2><p id="9148" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">1 — <a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/flutter-blocs-at-scale-1-the-state-machine-fce5f086d7b9">状态机</a> <br/> 2 —保持BLOCs精简<br/> 3 —(即将推出)<br/> 4 —(即将推出)</p><h2 id="8920" class="mo jz iq bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">*谢谢你</h2><p id="b6ff" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">给每一个读到这篇文章的人。<br/>如果你想要<strong class="ky ir">更多类似</strong>的文章，请随意:</p><ul class=""><li id="0d74" class="ne nf iq ky b kz ly ld lz lh ng ll nh lp ni lt nj nk nl nm bi translated">💬<strong class="ky ir">评论</strong>您自己使用颤振、阻塞和状态管理解决方案的一般经验。</li><li id="fc71" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">👏<strong class="ky ir">发几个拍手</strong>。这将激励我继续分享关于颤振开发的生产准备技巧。</li><li id="79e7" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">➕在我的媒体上按下跟随键。</li><li id="e9bd" class="ne nf iq ky b kz nn ld no lh np ll nq lp nr lt nj nk nl nm bi translated">🔗在你的社区内分享这个系列。</li></ul></div></div>    
</body>
</html>