<html>
<head>
<title>Enhancing JavaScript Objects with Descriptors and Symbols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用描述符和符号增强JavaScript对象</h1>
<blockquote>原文：<a href="https://itnext.io/enhancing-javascript-objects-with-descriptors-and-symbols-2cdc95e9b422?source=collection_archive---------2-----------------------#2018-11-02">https://itnext.io/enhancing-javascript-objects-with-descriptors-and-symbols-2cdc95e9b422?source=collection_archive---------2-----------------------#2018-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f1162a1d6f53617d8b90d664ca87454f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W-OIJz7JSjYHVEgw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@terminath0r?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Thor Alvis </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上发布的“棕色和黑色城市景观3D地图”</figcaption></figure><p id="7dbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不久前，我和我的同事遇到了一个相当有趣的问题，但我们无法立即解决。我们非常广泛地使用<a class="ae kc" href="https://facebook.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank">不可变库</a>——尤其是记录，因为它们允许点存取器和对象析构。</p><p id="78f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有以下形状的记录:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0400" class="lk ll iq lg b gy lm ln l lo lp">const record = Record({<br/>    a: 1,<br/>    b: 2,<br/>    c: 3<br/>})();</span></pre><p id="a825" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望从该记录中提取一个属性，并将其余的属性组织到一个单独的对象中，因此我们像往常一样进行了析构:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="80a0" class="lk ll iq lg b gy lm ln l lo lp">const { a, ...rest } = record;</span></pre><p id="bae3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你知道我们所做的有什么问题吗？我们没有。直到大量的挖掘之后，我们才能够想出为什么<code class="fe lq lr ls lg b">rest</code>总是<code class="fe lq lr ls lg b">undefined</code>。</p><p id="c283" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们发现，答案是，虽然不可变记录允许点访问和析构，但是记录上的属性没有一个是<em class="lt">可枚举的</em>，猜猜<code class="fe lq lr ls lg b">...</code> object rest操作符将哪种属性组合在一起？没错，可枚举属性。所以我们永远不会用这个方法得到一个不是<code class="fe lq lr ls lg b">undefined</code>的对象。</p><p id="3224" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在整个调试过程中，我陷入了一个相当大的兔子洞，围绕着如何使用vanilla JS配置对象的属性和定制其功能。有了这些知识，我们可以重新创建许多不可变记录的行为，甚至可以极大地增加对象默认行为的基本功能。</p><p id="9c8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用一个具体的示例，我们将创建一个可能的数据库条目，其中包括计算的属性、访问和设置属性的预处理和后处理，以及一些元编程特性，以使我们的条目对其执行上下文有一些自我意识。</p><h1 id="e689" class="lu ll iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">入门指南</h1><p id="dc51" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">首先，我们将考察我们的条目的特性。最好能实现一个(n):</p><ul class=""><li id="1524" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">身份</li><li id="46da" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">名字</li><li id="636c" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">上次访问日期</li><li id="09c4" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">上次修改日期</li><li id="b7c4" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">出生年月日</li><li id="1f85" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">severely subnormal 智力严重逊常</li></ul><p id="6c86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们创建数据库条目:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="54b9" class="lk ll iq lg b gy lm ln l lo lp">const dbEntry = Object.create( null );</span></pre><p id="4283" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我选择使用<code class="fe lq lr ls lg b">Object.create</code>而不是更熟悉的<code class="fe lq lr ls lg b">{}</code>语法，因为前一个条目允许我们指定对象的原型应该是什么，通过传入<code class="fe lq lr ls lg b">null</code>，我解除了这个对象与任何原型的链接。实际上，这个对象除了我们在它上面定义的功能之外，没有任何其他功能。</p><h1 id="8781" class="lu ll iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">属性数据描述符</h1><p id="da79" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">属性数据描述符是分配给对象属性的对象(每个属性一个描述符),它指示JavaScript引擎将如何处理该属性。数据描述符可以有四个键:</p><ul class=""><li id="e34a" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><code class="fe lq lr ls lg b">value</code>:我们希望属性的实际值(默认值<code class="fe lq lr ls lg b">undefined</code>)</li><li id="0ca7" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe lq lr ls lg b">enumerable</code>:属性是否应该出现在枚举对象键的操作中，比如<code class="fe lq lr ls lg b">for...in</code>循环或者<code class="fe lq lr ls lg b">Object.keys()</code>(默认为<code class="fe lq lr ls lg b">false</code>)</li><li id="2ed0" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe lq lr ls lg b">configurable</code>:指示我们是否可以在以后更改描述符设置或删除对象的属性(默认值<code class="fe lq lr ls lg b">false</code>)</li><li id="7908" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe lq lr ls lg b">writable</code>:告知属性值是否可以更改(默认<code class="fe lq lr ls lg b">false</code>)</li></ul><p id="8e39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们通常设置一个对象的属性时，这些值是自动建立的，从而使我们能够完全控制该属性。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3a27" class="lk ll iq lg b gy lm ln l lo lp">const obj = {};<br/>obj.a = 1;</span><span id="6f1b" class="lk ll iq lg b gy nk ln l lo lp">Object.getOwnPropertyDescriptor(obj, 'a');<br/>// { value: 1,<br/>//   writable: true,<br/>//   enumerable: true,<br/>//   configurable: true }</span></pre><p id="92e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，当我们设置一个属性时，我们如何着手限制可以做的事情呢？使用<code class="fe lq lr ls lg b">Object.defineProperty</code>并传入我们想要的配置。</p><p id="d05a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以让我们在我们的<code class="fe lq lr ls lg b">dbEntry</code>对象上设置一个ID。因为这代表了它在数据库中的主键，一旦它被设置，我们就不能更改它，但是如果我们遍历条目的键，我们可能希望能够访问它。因此，我们将执行以下操作:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="bf83" class="lk ll iq lg b gy lm ln l lo lp">Object.defineProperty(<br/>    dbEntry,              // Object we're defining property on<br/>    'id',                 // Property name<br/>    {                     // Property descriptor<br/>        value: 1,<br/>        enumerable: true<br/>    }<br/>);</span></pre><p id="cbaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe lq lr ls lg b">dbEntry.id</code>的值设置为1(当然，不管它的实际主键是什么，它都会是1)，并指定我们希望能够枚举它。我们不需要传入<code class="fe lq lr ls lg b">configurable</code>或<code class="fe lq lr ls lg b">writable</code>标志，因为当我们定义一个属性并且没有指定描述符设置时，JavaScript将使用上面指定的各自的默认值(在这些情况下是<code class="fe lq lr ls lg b">false</code>)。从现在开始，我将指定所有的描述符选项，即使缺省值是我想要的。</p><p id="1564" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们也为SSN和生日添加属性:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="53c9" class="lk ll iq lg b gy lm ln l lo lp">Object.defineProperties(<br/>    dbEntry,                      // Object to define props on<br/>    {                             // Object of props and descriptors<br/>        ssn: {<br/>            value: '123-45-6789',<br/>            writable: false,<br/>            enumerable: true,<br/>            configurable: false<br/>        },<br/>        birthdate: {<br/>            value: '01/21/1980',<br/>            writable: false,<br/>            enumerable: true,<br/>            configurable: false<br/>        }<br/>    }<br/>);</span></pre><p id="6551" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次我们使用了<code class="fe lq lr ls lg b">Object.defineProperties</code>方法来同时添加多个属性，而不是必须调用<code class="fe lq lr ls lg b">Object.defineProperty</code>两次。第二个参数只是一个对象，其键将成为指定对象的属性，其值是描述符。</p><h1 id="df65" class="lu ll iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">属性访问器描述符</h1><p id="9adc" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">虽然我们已经可以通过使用数据描述符对对象进行一些很好的控制(<em class="lt">例如</em>，增强不变性，确定一个键有多“可访问”)，但是如果我们从数据描述符(相当静态)转移到访问器描述符(允许我们拥有相当动态的对象属性)，我们仍然可以发挥相当多的额外能力。</p><p id="7fc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">访问器描述符和数据描述符之间的主要区别在于，访问器用<code class="fe lq lr ls lg b">get</code>和<code class="fe lq lr ls lg b">set</code>函数替换了早期的<code class="fe lq lr ls lg b">value</code>和<code class="fe lq lr ls lg b">writable</code>配置标志。</p><p id="43f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用它们来定义一个名称属性。在后台，我们希望分别存储名、中间名和姓，但向用户显示实际的全名。这允许数据库有选择地搜索我们想要的名字的任何部分，同时允许用户看到更可读的形式。这也是使用<code class="fe lq lr ls lg b">get</code>和<code class="fe lq lr ls lg b">set</code>的完美方式。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="299d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始使用它们之前，我们需要指出一个要点。从某种意义上说，getters和setters是<em class="lt">虚</em>。这意味着，如果我们有一个用<code class="fe lq lr ls lg b">get</code>和<code class="fe lq lr ls lg b">set</code>访问器定义的<code class="fe lq lr ls lg b">obj.prop</code>，那么<code class="fe lq lr ls lg b">get</code>和<code class="fe lq lr ls lg b">set</code> <em class="lt">必须使用不同的存储位置来保存我们正在获取/设置的实际数据。</em></p><p id="126b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做的原因是，如果我们在代码中的任何地方调用<code class="fe lq lr ls lg b">obj.prop</code>，JavaScript引擎将调用在其上定义的<code class="fe lq lr ls lg b">get</code>函数，但是因为<code class="fe lq lr ls lg b">get</code>从<code class="fe lq lr ls lg b">obj.prop</code>提取数据，我们进入了<code class="fe lq lr ls lg b">obj.prop</code>的另一个循环，调用它的getter，然后getter再次调用自己，<em class="lt">无限地调用</em>。当我们进入一个无限递归的函数调用集时，这导致了一个<code class="fe lq lr ls lg b">Maximum call stack size exceeded</code>错误。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="7f53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据上面的警告，让我们在<code class="fe lq lr ls lg b">dbEntry</code>上定义一个新的属性来存放“后端”数据，供我们所有的getter/setter使用。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6801" class="lk ll iq lg b gy lm ln l lo lp">Object.defineProperty(<br/>    dbEntry,<br/>    '_',<br/>    {<br/>        value: {},<br/>        writable: false,<br/>        enumerable: false,<br/>        configurable, false<br/>    }<br/>);</span></pre><p id="1e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们将创建<code class="fe lq lr ls lg b">firstname</code>、<code class="fe lq lr ls lg b">middlename</code>和<code class="fe lq lr ls lg b">lastname</code>属性来实际存储名称数据。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6e87" class="lk ll iq lg b gy lm ln l lo lp">Object.defineProperties(<br/>    dbEntry._,<br/>    {<br/>        firstname: {<br/>            value: 'John',<br/>            writable: true,<br/>            enumerable: false,<br/>            configurable: false<br/>        },<br/>        middlename: {<br/>            value: 'Jack',<br/>            writable: true,<br/>            enumerable: false,<br/>            configurable: false<br/>        },<br/>        lastname: {<br/>            value: 'Doe',<br/>            writable: true,<br/>            enumerable: false,<br/>            configurable: false<br/>        }<br/>    }<br/>);</span></pre><p id="b7f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">做完这些，我们终于可以整合我们的财产了。为了保持代码简单，我们假设每个传入的名字都有一个名、中间名和姓。我们还会设置<code class="fe lq lr ls lg b">configurable: true</code>；这一点以后会很重要。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3c8d" class="lk ll iq lg b gy lm ln l lo lp">Object.defineProperty(<br/>    dbEntry,<br/>    'name',<br/>    {<br/>        enumerable: true,<br/>        configurable: true,<br/>        get() {<br/>            const { firstname, middlename, lastname } = this._;<br/>            return `${firstname} ${middlename} ${lastname}`;<br/>        },<br/>        set(newName) {<br/>            const [<br/>                firstname,<br/>                middlename,<br/>                lastname<br/>            ] = newName.split(' ');<br/>            this._.firstname = firstname;<br/>            this._.middlename = middlename;<br/>            this._.lastname = lastname;<br/>        }<br/>    }<br/>);</span></pre><p id="116f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们检索<code class="fe lq lr ls lg b">dbEntry.name</code>，我们将得到“约翰·杰克·多伊”,如果我们设置<code class="fe lq lr ls lg b">dbEntry.name = 'John Stuart Mill'</code>,我们可以看到我们在<code class="fe lq lr ls lg b">dbEntry._</code>中的姓名数据确实发生了变化。</p><p id="ca07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于访问器描述符的一个非常好的事情是它们考虑到了副作用。在<code class="fe lq lr ls lg b">get</code>或<code class="fe lq lr ls lg b">set</code>函数中，我们可以执行API调用，记录到控制台，或者在每次调用时对输入/输出(仅举几个例子)进行某种处理。</p><p id="8f9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始吧。每当设置或检索<code class="fe lq lr ls lg b">dbEntry.name</code>时，我们将在该对象上设置各自的<code class="fe lq lr ls lg b">lastAccessed</code>和<code class="fe lq lr ls lg b">lastModified</code>属性。因为我们说过<code class="fe lq lr ls lg b">dbEntry.name</code>仍然是可配置的，所以添加这个功能只是重新定义它的属性描述符。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="461d" class="lk ll iq lg b gy lm ln l lo lp">Object.defineProperties(<br/>    dbEntry,<br/>    {<br/>        lastAccessed: {<br/>            value: Date.now(),<br/>            writable: true,<br/>            configurable: false,<br/>            enumerable: true<br/>        },<br/>        lastModified: {<br/>            value: Date.now(),<br/>            writable: true,<br/>            configurable: false,<br/>            enumerable: true<br/>        },<br/>        name: {<br/>            enumerable: true,<br/>            configurable: false,<br/>            get() {<br/>                this.lastAccessed = Date.now();</span><span id="a28e" class="lk ll iq lg b gy nk ln l lo lp">                const { firstname, middlename, lastname } = this._;<br/>                return `${firstname} ${middlename} ${lastname}`;<br/>            },<br/>            set(newName) {<br/>                this.lastModified = Date.now();</span><span id="c579" class="lk ll iq lg b gy nk ln l lo lp">                const [<br/>                    firstname,<br/>                    middlename,<br/>                    lastname<br/>                ] = newName.split(' ');<br/>                this._.firstname = firstname;<br/>                this._.middlename = middlename;<br/>                this._.lastname = lastname;<br/>            }<br/>        }<br/>    }<br/>);</span></pre><p id="b342" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，每当我们检索或设置条目的名称时，我们将启动一个副作用来更新上次修改或访问记录的时间。另外，我们在name属性上设置了<code class="fe lq lr ls lg b">configurable: false</code>,所以现在我们不能再修改它了。此外，如果我们没有使<code class="fe lq lr ls lg b">birthdate</code>和<code class="fe lq lr ls lg b">ssn</code>不可配置，我们可以将它们改为getters和setters，以类似地更新<code class="fe lq lr ls lg b">lastAccessed</code>和<code class="fe lq lr ls lg b">lastModified</code>。</p><h1 id="ff8c" class="lu ll iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">用符号添加元编程</h1><p id="77f5" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们已经展示了许多有趣的方法，可以让我们的对象做比我们通常只使用典型赋值所做的更多的事情(<em class="lt">例如</em> <code class="fe lq lr ls lg b">obj.a = 3</code>)，事实上我们可以在getter或setter中做任何我们想做的事情，这是一个非常强大的特性。</p><p id="5df1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们可以通过添加众所周知的符号来进一步改善我们的数据库条目。我不会深入什么是符号，但是众所周知的(<em class="lt">即</em>，全局)符号允许对象的行为根据它所在的代码的上下文而改变。</p><h2 id="8d5d" class="lk ll iq bd lv ns nt dn lz nu nv dp md ko nw nx mh ks ny nz ml kw oa ob mp oc bi translated">符号迭代器</h2><p id="ae78" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在之前的文章中，我谈到了如何使用<code class="fe lq lr ls lg b">Symbol.iterator</code>使对象可迭代。这将是一个方便的功能，所以让我们打开可迭代性:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="13e4" class="lk ll iq lg b gy lm ln l lo lp">Object.defineProperty(<br/>    dbEntry,<br/>    Symbol.iterator,<br/>    {<br/>        value: function* () {<br/>            yield this.id;<br/>            yield this.name;<br/>            yield this.birthdate;<br/>            yield this.ssn;<br/>            yield this.lastAccessed;<br/>            yield this.lastModified;<br/>        }<br/>    }<br/>);</span></pre><p id="bc5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以通过编程以明确定义的顺序循环遍历我们的键。注意，我们也可以使用<code class="fe lq lr ls lg b">Object.keys</code>而不是定义<code class="fe lq lr ls lg b">Symbol.iterator</code>，但是因为<code class="fe lq lr ls lg b">Object.keys</code>不保证顺序，所以当涉及到我想在这个基础上构建的特性时，它对我们来说用处不大。注意，基于<code class="fe lq lr ls lg b">Symbol</code>的属性是不可写、不可枚举、不可配置的——即使您在描述符中将这些标志作为<code class="fe lq lr ls lg b">true</code>传递。</p><p id="6873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想拥有iterability的真正原因是因为有一个非常简洁的<code class="fe lq lr ls lg b">Symbol</code>,它允许我们根据JavaScript引擎提供的“提示”(由对象上正在执行的操作类型决定的提示)将对象强制转换为字符串或数字原语。</p><h2 id="9ca5" class="lk ll iq bd lv ns nt dn lz nu nv dp md ko nw nx mh ks ny nz ml kw oa ob mp oc bi translated">符号. toPrimitive</h2><p id="08dc" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在使用Python和Ruby的过程中，我一直喜欢能够定义自定义行为来将两个类添加在一起，这是朝着同一个方向迈出的一步。所以，让我们定义如何初始化我们的对象。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3fd1" class="lk ll iq lg b gy lm ln l lo lp">Object.defineProperty(<br/>    dbEntry,<br/>    Symbol.toPrimitive,<br/>    {<br/>        value: function (hint) {<br/>            if (hint === 'string') {<br/>                return [ ...this ].join(', ');<br/>            }</span><span id="23c9" class="lk ll iq lg b gy nk ln l lo lp">            return NaN;<br/>        }<br/>    }<br/>);</span></pre><p id="1ecb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们的<code class="fe lq lr ls lg b">dbEntry</code>发现自己处于一个“字符串化”环境中时，它将返回一个逗号分隔的列表，其中包含我们在<code class="fe lq lr ls lg b">Symbol.iterator</code>属性中定义的所有属性。据我所知，唯一这样的环境就是字符串插值(<em class="lt">即</em>，执行类似<code class="fe lq lr ls lg b">`${dbEntry}`</code>的东西)。</p><p id="0bc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有其他情况将返回<code class="fe lq lr ls lg b">NaN</code>。这是有意义的，因为为像<code class="fe lq lr ls lg b">dbEntry + 1</code>这样的东西定义行为实际上没有多大意义，尽管如果有意义，我们会想为<code class="fe lq lr ls lg b">hint === 'number'</code>添加一些东西。</p><h1 id="f559" class="lu ll iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">兜了一圈</h1><p id="e216" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们最初开始这次跋涉是因为我们不能在对象析构中使用<code class="fe lq lr ls lg b">...</code> rest操作符。现在让我们看看当我们尝试使用它时会得到什么:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6afb" class="lk ll iq lg b gy lm ln l lo lp">const { id, ...rest } = dbEntry;</span><span id="3975" class="lk ll iq lg b gy nk ln l lo lp">id;   // 1<br/>rest; // {<br/>      //     birthdate: '01/21/1980',<br/>      //     lastAccessed: 1540940075708,<br/>      //     lastModified: 1540940079708,<br/>      //     name: 'John Stuart Mill',<br/>      //     ssn: '123-45-6789'<br/>      // }</span></pre><p id="3cbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们的<code class="fe lq lr ls lg b">_</code>属性和我们熟知的符号都不在我们的<code class="fe lq lr ls lg b">rest</code>对象中，因为它们都是不可枚举的。然而，有可能把它们从我们的物体上专门摘下来。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="99f4" class="lk ll iq lg b gy lm ln l lo lp">const { [Symbol.iterator]: iterator, _ } = dbEntry;</span><span id="a608" class="lk ll iq lg b gy nk ln l lo lp">iterator; // f* () { ... }<br/>_;        // {<br/>          //      firstname: 'John',<br/>          //      middlename: 'Stuart',<br/>          //      lastname: 'Mill'<br/>          // }</span></pre><h1 id="61a7" class="lu ll iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">最后几句话</h1><p id="71e4" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">关于属性描述符的使用，还有几件事情需要提及。</p><ul class=""><li id="4071" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">如果您定义了一个可写但不可配置的属性，那么您<em class="lt">可以</em>实际返回并更新该属性的配置，关闭可写性(以及最后一次设置它的值)。</li><li id="4f71" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">如果你试图给一个属性重新赋值，而这个属性的<code class="fe lq lr ls lg b">writable</code>标志被设置为<code class="fe lq lr ls lg b">false</code>，那么操作会无声地失败，除非你处于严格模式下——在这种情况下，你会得到一个<code class="fe lq lr ls lg b">TypeError</code>。</li><li id="137c" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">我们可以直接在我们的对象上定义我们众所周知的符号属性，而不是使用<code class="fe lq lr ls lg b">Object.defineProperty</code>，我们将得到完全相同的属性描述符配置。我们这样做只是为了保持一致性。</li></ul><p id="3517" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在实现我们自己的自定义属性描述符(尤其是访问器)方面有很大的自由度，并且您可以用它们做的事情实际上只受您的想象力的限制。我们没有时间实现的功能将是在我们对属性进行<code class="fe lq lr ls lg b">set</code>后对数据进行更加精细的后处理(<em class="lt">例如</em>，数据净化/验证)或对数据进行<code class="fe lq lr ls lg b">get</code>的预处理(<em class="lt">例如</em>，检查用户的安全凭证，如果他们没有被授权查看该数据，则屏蔽它)。</p><p id="222f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们确实看到了足够的东西来展示我们如何用比我们通常在教程中学到的更健壮的东西来升级我们的对象的典型功能。毕竟，很多库都利用了这种功能，那么我们为什么不把它用在自己身上呢？</p><p id="688b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://gist.github.com/ryandabler/e9c5f757813894e752f7153f35091657" rel="noopener ugc nofollow" target="_blank">这个要点</a>有一个我们定义的对象及其功能的完整例子，尽管它的形式比我们在文章中给出的稍微有所改变。</p></div></div>    
</body>
</html>