<html>
<head>
<title>Of the Huge Pull Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">巨大的拉动请求</h1>
<blockquote>原文：<a href="https://itnext.io/of-the-huge-pull-requests-b851d45fe9e?source=collection_archive---------0-----------------------#2022-11-07">https://itnext.io/of-the-huge-pull-requests-b851d45fe9e?source=collection_archive---------0-----------------------#2022-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af03" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何划分它们</h2></div><p id="3edb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://medium.com/@aerabi/list/git-weekly-9fe103e35b4b" rel="noopener"> Git周刊</a> #21 <br/>等级:中级🥈</p><p id="7507" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让一个工程师检查一个有20行代码变更的拉请求，他们会发现其中有10个问题。让他们回顾500行变更，他们会说LGTM——在我看来不错。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/12420d478a0b0d5f2fe475741cdb5825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlCAg9qIfxeNRDYweQS1PA.png"/></div></div></figure><p id="4ea4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不喜欢大尺寸的PRs。我完全反对在一次公关中解决多个问题。在我上一个工作场所，我做得太过分了，对拉取请求设置了以下规则:</p><ol class=""><li id="2ef8" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld lw lx ly lz bi translated">“拉”请求中的变更不能超过500行，</li><li id="10ca" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated">所有提交消息都必须遵循特定的格式，</li><li id="0de2" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated">当PR被接受时，它必须被压缩成一个提交，然后这个提交被ff合并。</li></ol><p id="3b4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">规则(1)之所以存在，是因为超过500行太大了，除非有特殊情况，并且有大量自动代码更改，例如从NPM包锁版本1升级到版本2。这是我们案例中唯一的例外，因为我们没有提交任何其他自动生成的代码。</p><p id="631a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管500行代码变更是极限，我们试图创造一种更小的PRs的文化。</p><p id="e8af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">规则(2)也分两部分执行:</p><ul class=""><li id="bd27" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld mf lx ly lz bi translated">我们有一个提交消息linter来检查提交消息，</li><li id="a96e" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld mf lx ly lz bi translated">我们有一些软规则，例如，提交消息必须包含一个到它正在解决的问题的链接。</li></ul><p id="130f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，根据规则(3)，我们有一个规则，即每个公关必须解决一个问题。如果代码中缺少某些东西，我们想要解决它，那么我们必须首先在问题跟踪系统中创建一个问题，然后在PR和提交消息中链接它。这有助于提高可见度。</p><h1 id="f320" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">重大问题</h1><p id="4c29" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">到目前为止一切顺利。但有时问题又太大了。假设“将该服务迁移到AWS”。这对于单个PR和单个commit来说都太大了。</p><p id="c639" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们通常的工作方式:</p><ul class=""><li id="e187" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld mf lx ly lz bi translated">创建特征分支，</li><li id="557f" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld mf lx ly lz bi translated">开始解决这个问题，做一些小的承诺，</li><li id="11dc" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld mf lx ly lz bi translated">公开公关评论，</li><li id="3057" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld mf lx ly lz bi translated">当一切正常时，将提交压缩成一个。</li></ul><p id="6a39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么？因为:</p><ol class=""><li id="4c78" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld lw lx ly lz bi translated">拥有多次提交有助于更好地审查和更好地处理代码审查。您可能只是回复一个提交来处理一个评论。评论者可能对正在发生的事情有更好的理解。如果您在单独的提交中处理注释，那么在处理注释时会有更好的可视性。</li><li id="22c6" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld lw lx ly lz bi translated">如果你做了多次提交，然后意识到PR太大，你可以把它分成几份，例如，为每一次提交创建一个新的PR，然后让他们分别被检查。</li></ol><blockquote class="nd"><p id="fb52" class="ne nf it bd ng nh ni nj nk nl nm ld dk translated">你承诺的越多，你就越能灵活地将一份公关分成多份。</p></blockquote><h1 id="6c04" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz nn ka ms kc no kd mu kf np kg mw mx bi translated">如何分解拉取请求</h1><p id="ec11" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">让我们假设在您的分支中有3个提交，您想从它们中生成3个单独的PRs。首先，做一个git日志，在某个地方记录提交散列。</p><pre class="lg lh li lj gt nq nr ns nt aw nu bi"><span id="fc9c" class="nv mh it nr b gy nw nx l ny nz">git log --oneline</span></pre><p id="162f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回应与此类似:</p><pre class="lg lh li lj gt nq nr ns nt aw nu bi"><span id="ea89" class="nv mh it nr b gy nw nx l ny nz"><strong class="nr iu">e6e9196</strong> (HEAD -&gt; aerabi/fix-icon, origin/aerabi/fix-icon) :gear: Add build and push scripts<br/><strong class="nr iu">3dc3a5a </strong>:pencil: Update the README<strong class="nr iu"><br/>df059e5</strong> :wrench: Add icon and update metadata<br/><strong class="nr iu">30c4219</strong> (origin/master, master) :wrench: Load the list of Git Weekly issues and render it (#2)<br/><strong class="nr iu">4d5389c</strong> :pencil: Add README<br/><strong class="nr iu">41d064b</strong> :gear: Initial commit</span></pre><p id="c6f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们希望从这3个提交中产生3个分支:</p><ul class=""><li id="b378" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld mf lx ly lz bi translated">⚙️添加构建和推送脚本</li><li id="53f5" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld mf lx ly lz bi translated">📝更新自述文件</li><li id="d4a3" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld mf lx ly lz bi translated">🔧添加图标并更新元数据</li></ul><h2 id="5471" class="nv mh it bd mi oa ob dn mm oc od dp mq kr oe of ms kv og oh mu kz oi oj mw ok bi translated">三个简单的PRs</h2><p id="5d84" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">回到主分支，并从中创建一个新分支:</p><pre class="lg lh li lj gt nq nr ns nt aw nu bi"><span id="d4f7" class="nv mh it nr b gy nw nx l ny nz">git switch master<br/>git switch -c aerabi/add-icon-and-metadata</span></pre><p id="308b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后仔细挑选第一个提交:</p><pre class="lg lh li lj gt nq nr ns nt aw nu bi"><span id="6430" class="nv mh it nr b gy nw nx l ny nz">git cherry-pick <strong class="nr iu">df059e5</strong></span></pre><p id="060c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提交将被带到这个分支。然后，从这个分支上创建另一个分支，并在那里进行另一次精选:</p><pre class="lg lh li lj gt nq nr ns nt aw nu bi"><span id="cb45" class="nv mh it nr b gy nw nx l ny nz">git switch -c aerabi/update-readme<br/>git cherry-pick <strong class="nr iu">3dc3a5a</strong></span></pre><p id="0fdc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下次再做一次:</p><pre class="lg lh li lj gt nq nr ns nt aw nu bi"><span id="74fa" class="nv mh it nr b gy nw nx l ny nz">git switch -c aerabi/add-build-and-push-scripts<br/>git cherry-pick <strong class="nr iu">e6e9196</strong></span></pre><p id="93c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过这样做，我们创建了3个分支，每个分支都在另一个分支之上。然后，我们将它们推送到远程分支机构，并从中创建PRs。</p><blockquote class="ol om on"><p id="af22" class="ki kj oo kk b kl km ju kn ko kp jx kq op ks kt ku oq kw kx ky or la lb lc ld im bi translated">注意:让它们一个一个地合并，一旦前面的合并了，就把剩下的重新组合。</p></blockquote><h2 id="8192" class="nv mh it bd mi oa ob dn mm oc od dp mq kr oe of ms kv og oh mu kz oi oj mw ok bi translated">四个PRs</h2><p id="3f2c" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">如果其中一个提交也很大，我们需要将它分解成两个或更多的提交，那么我们需要在开始前面提到的过程之前这样做。</p><p id="1167" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要了解如何分解提交，请参考以下文章:</p><ul class=""><li id="07cf" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld mf lx ly lz bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/git-split-commit-b42a609a6bf3">在Git中拆分提交</a></li></ul><h1 id="1488" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最后的话</h1><p id="9d5a" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">Git有<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/git-merge-vs-rebase-938950fb218">三种合并分支的方式</a>。人们可以简单地进行挤压合并，而不是挤压然后进行ff合并。我倾向于前者，原因如下:</p><ul class=""><li id="e994" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld mf lx ly lz bi translated">当进行挤压合并时，通常发生在git软件中，例如GitHub或GitLab。进行挤压合并的人可以在点击合并按钮之前编辑提交消息。首先，合并者可以是维护者或评审者，这与作者不是同一个人，我相信作者是必须编写或修改提交消息的人。其次，如果您有一个检查提交消息的CI作业，它不能检查在GitHub上动态编辑的提交消息。</li><li id="cae4" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld mf lx ly lz bi translated">进行ff-merge将使git更容易理解合并到主节点的提交是feature分支中的同一个提交，并使重新定基更容易。</li></ul><p id="15a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我每周都会在git上写一篇博文。</p><ul class=""><li id="faaa" class="lr ls it kk b kl km ko kp kr lt kv lu kz lv ld mf lx ly lz bi translated"><a class="ae le" href="https://medium.com/subscribe/@aerabi" rel="noopener">订阅</a>my Medium publishes，以便在新一期Git周刊出版时获得通知。</li><li id="a580" class="lr ls it kk b kl ma ko mb kr mc kv md kz me ld mf lx ly lz bi translated">在Twitter 上关注<a class="ae le" href="https://twitter.com/MohammadAliEN" rel="noopener ugc nofollow" target="_blank">我，了解更多其他平台上发布的更新和文章。</a></li></ul></div></div>    
</body>
</html>