<html>
<head>
<title>Hooks for React.js — the new ketchup?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.js的钩子——新的番茄酱？</h1>
<blockquote>原文：<a href="https://itnext.io/hooks-for-react-js-the-new-ketchup-86e8cb03b70?source=collection_archive---------1-----------------------#2019-01-27">https://itnext.io/hooks-for-react-js-the-new-ketchup-86e8cb03b70?source=collection_archive---------1-----------------------#2019-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="9a79" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">钩子是一个即将到来的特性，它允许你使用状态和其他React特性，而不需要编写一个类组件——函数FTW。</em></p></blockquote><p id="1c05" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">钩子是最新的样式，是一个实验性的特征，据说比切片面包或番茄酱更好，你决定；).每个人过去都疯狂迷恋<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/the-amazing-render-props-pattern-for-react-js-lifecycle-begone-14e520fc3821">渲染道具</a>，但现在都是钩子。</p><p id="4fb3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">钩子目前在React v16.8.0-alpha.0中，所以你已经可以试用它们了:)</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/9b8776eaaab11cfbbaf546f0411e2b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NjefR5Y6wMlqACcP.png"/></div></div></figure><h1 id="1322" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Hooks试图解决的问题</h1><p id="9384" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">每次有新的东西出来，我们都很兴奋。是番茄酱，是切片面包之类以来最好吃的东西。我们希望这将最终解决我们所有的问题，所以我们一次又一次地使用它。我们都曾经犯过这样的错误，滥用了一种模式或范式，是的，我们使用的模式一直是有限的。</p><p id="16af" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">下面我将试着列出所有不同的痛点，这些痛点让我们看到钩子是一个新的伟大的东西。不过，提醒一句，即使是钩子也会有缺点，所以在有意义的地方使用它。但是现在回到一些抨击和狂言，我们过去构建React应用程序的方式是多么糟糕；)</p><p id="2157" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">Hooks正在努力解决许多问题。以下是违规者名单:</p><ul class=""><li id="e4c9" class="mi mj iq jt b ju jv jy jz kp mk kq ml kr mm ko mn mo mp mq bi translated"><strong class="jt ir">包装地狱</strong>，我们都知道所谓的<em class="js">包装地狱</em>。组件被一层层的<code class="fe mr ms mt mu b">providers</code>、<code class="fe mr ms mt mu b">consumers</code>、<code class="fe mr ms mt mu b">higher-order components</code>、<code class="fe mr ms mt mu b">render props</code>等抽象包围，还没穷尽？；)</li></ul><p id="dc21" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">就像整个包装本身还不够糟糕，我们需要重组我们的组件，这是乏味的，但最重要的是，我们失去了对数据如何流动的跟踪。</p><ul class=""><li id="995a" class="mi mj iq jt b ju jv jy jz kp mk kq ml kr mm ko mn mo mp mq bi translated"><strong class="jt ir">越来越复杂</strong>，开始时很小的东西随着时间的推移会变得很大很复杂，特别是当我们添加生命周期方法时</li><li id="167f" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir">生命周期方法做了太多事情</strong>，组件可能会在<code class="fe mr ms mt mu b">componentDidMount</code>和<code class="fe mr ms mt mu b">componentDidUpdate</code>中执行一些数据获取。同一个<code class="fe mr ms mt mu b">componentDidMount</code>方法也可能包含一些不相关的逻辑来设置事件监听器，清理在<code class="fe mr ms mt mu b">componentWillUnmount</code>中执行</li></ul><blockquote class="jn jo jp"><p id="bc2a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">仅仅创建更小的组件？</p></blockquote><p id="fbed" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在许多情况下，这是不可能的，因为:</p><ul class=""><li id="b3b2" class="mi mj iq jt b ju jv jy jz kp mk kq ml kr mm ko mn mo mp mq bi translated"><strong class="jt ir">难测试</strong>，有状态逻辑无处不在，因此很难测试</li><li id="7fb1" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir">类混淆了人和机器</strong>，你必须理解<code class="fe mr ms mt mu b">this</code>在JavaScript中是如何工作的，你必须将它们绑定到事件处理程序等等。React中函数和类组件之间的区别以及何时使用每一个<em class="js">会导致分歧</em>并且我们都知道当我们为自己的观点而战时会怎样，空格vs制表符谁:)。</li><li id="1b60" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir">缩小问题</strong>，类也给今天的工具带来了问题。例如，类不能很好地缩小，它们使得热重装变得不可靠。有些人可能喜欢类，有些人可能认为函数是唯一的方法。不管怎样，我们只能在React和类中使用某些特性，如果它导致这些缩小问题，我们必须找到一个更好的方法。</li></ul><h1 id="5a9c" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">挂钩的卖点</h1><p id="bff5" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">钩子让你不用类就能使用更多React的特性<strong class="jt ir">。不仅如此，我们还能打造挂钩，让您:</strong></p><ul class=""><li id="b1b3" class="mi mj iq jt b ju jv jy jz kp mk kq ml kr mm ko mn mo mp mq bi translated"><strong class="jt ir">从一个组件中提取有状态逻辑</strong>，这样它可以被独立测试和重用。</li><li id="d0c9" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir">重用有状态逻辑</strong>，不改变你的组件层次结构。这使得在许多组件之间或与社区共享钩子变得容易。</li></ul><h1 id="17ac" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是钩子？</h1><p id="ba31" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">钩子让你<em class="js">根据什么<em class="js">片段相关</em>将一个组件分割成更小的功能</em>(比如设置订阅或获取数据)，而不是基于生命周期方法强制分割。</p><p id="c7bd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">让我们来概述一下可以使用的不同挂钩。挂钩分为<code class="fe mr ms mt mu b">Basic Hooks</code>和<code class="fe mr ms mt mu b">Additional Hooks</code>。让我们先列出<code class="fe mr ms mt mu b">Basic Hooks</code>并简要说明它们的作用:</p><h1 id="4226" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基本挂钩</h1><ul class=""><li id="8d8e" class="mi mj iq jt b ju md jy me kp na kq nb kr nc ko mn mo mp mq bi translated"><strong class="jt ir"> useState </strong>，这是一个钩子，允许你在函数组件内部使用状态</li><li id="8f26" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir">使用效果</strong>，这是一个钩子，允许你以一种替代几种生命周期方法的方式来执行副作用</li><li id="f534" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir"> useContext </strong>，接受上下文对象(从React.createContext返回的值)并返回当前上下文值，该值由给定上下文的最近上下文提供者给出。当提供者更新时，这个钩子将触发用最新的上下文值重新呈现。</li></ul><p id="7ad5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在本文中，我们将重点讨论<code class="fe mr ms mt mu b">useState</code>和<code class="fe mr ms mt mu b">useEffect</code>。</p><h1 id="8471" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">附加挂钩</h1><p id="b0cb" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">我们将不再讨论<code class="fe mr ms mt mu b">Additional Hooks</code>，因为这篇文章太长了，但是我们鼓励你在<a class="ae ks" href="https://reactjs.org/docs/hooks-reference.html#additional-hooks" rel="noopener ugc nofollow" target="_blank">附加钩子</a>上阅读更多关于它们的内容</p><ul class=""><li id="ee21" class="mi mj iq jt b ju jv jy jz kp mk kq ml kr mm ko mn mo mp mq bi translated"><strong class="jt ir"> useReducer </strong>，一个<code class="fe mr ms mt mu b">useState</code>的替代，它接受一个Reducer并返回一对当前状态和一个<code class="fe mr ms mt mu b">dispatch</code>函数</li><li id="2443" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir"> useCallback </strong>，将返回回调的记忆版本，仅当其中一个输入发生变化时才会发生变化。这在将回调传递给依赖引用相等的优化子组件以防止不必要的呈现时非常有用</li><li id="5c8a" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir"> useMemo </strong>，传递一个<em class="js"> create </em>函数和一个输入数组。<code class="fe mr ms mt mu b">useMemo</code>仅当其中一个输入发生变化时，才会重新计算记忆值。这种优化有助于避免每次渲染时进行昂贵的计算。</li><li id="7788" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir"> useRef </strong>，返回一个可变Ref对象，其<code class="fe mr ms mt mu b">.current</code>属性被初始化为传递的参数(initialValue)。返回的对象<em class="js">将在组件</em>的整个生命周期内持续存在</li><li id="de1e" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir"> useImperativeHandle </strong>，定制使用ref时暴露给父组件的实例值</li><li id="c73b" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir"> useLayoutEffect </strong>，签名与useEffect相同，但它在所有DOM突变后同步触发<em class="js"/>。使用它从DOM中读取布局并同步重新渲染</li><li id="fddc" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir"> useDebugValue </strong>，可用于显示React DevTools中自定义钩子的标签</li></ul><p id="1f9e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">正如你在上面看到的，我已经从文档中借用了每个<code class="fe mr ms mt mu b">Additional Hooks</code>的解释。其目的仅仅是描述存在的东西，给它们每一个都加一行，并敦促你一旦感觉已经掌握了<code class="fe mr ms mt mu b">Basic Hooks</code>就去研究文档。</p><h1 id="4aab" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用状态挂钩</h1><p id="b2a0" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">这个钩子让我们可以在函数组件内部使用状态。是的，我引起你的注意了，对吗？通常，这是不可能的，我们需要使用一个<code class="fe mr ms mt mu b">class</code>来实现。不再是了。让我们看看使用<code class="fe mr ms mt mu b">useState</code>钩子是什么样子。我们需要做两件事来开始使用钩子:</p><ul class=""><li id="09fa" class="mi mj iq jt b ju jv jy jz kp mk kq ml kr mm ko mn mo mp mq bi translated"><strong class="jt ir">脚手架</strong>使用Create React App的项目</li><li id="276a" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir">升级</strong> <code class="fe mr ms mt mu b">react</code>和<code class="fe mr ms mt mu b">react-dom</code></li></ul><p id="2d65" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们将通过键入以下内容来解决第一个问题:</p><blockquote class="jn jo jp"><p id="0941" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq"> npx创建-反应-应用挂钩-演示</em></p></blockquote><p id="766a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">接下来，我们需要升级<code class="fe mr ms mt mu b">react</code>和<code class="fe mr ms mt mu b">react-dom</code>，这样它们就可以使用实验版的React，其中包含了钩子:</p><blockquote class="jn jo jp"><p id="05d3" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">纱线添加react@next react-dom@next </em></p></blockquote><p id="e8ec" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在我们可以走了。</p><h2 id="b25b" class="nd lg iq bd lh ne nf dn ll ng nh dp lp kp ni nj lt kq nk nl lx kr nm nn mb no bi translated">我们的第一个钩子</h2><p id="cbd5" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">让我们使用<code class="fe mr ms mt mu b">useState</code>创建我们的第一个钩子，并专注于理解如何使用它。让我们来看一些代码:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="fe94" class="nd lg iq mu b gy nt nu l nv nw">import React, { useState } from 'react';</span><span id="fd70" class="nd lg iq mu b gy nx nu l nv nw">const Counter = () =&gt; { <br/>  const [counter, setCounter] = useState(0); <br/>  <br/>  return ( <br/>    &lt;div&gt; {counter} <br/>      &lt;button onClick={() =&gt; setCounter(counter +1)}&gt;<br/>      Increment<br/>      &lt;/button&gt; <br/>   &lt;/div&gt; <br/>  ) <br/>}</span><span id="2ac9" class="nd lg iq mu b gy nx nu l nv nw">export default Counter;</span></pre><p id="1623" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">好的，我们看到我们通过调用钩子<code class="fe mr ms mt mu b">useState</code>来使用它，我们像这样调用它:</p><blockquote class="jn jo jp"><p id="da8a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">使用状态(0) </em></p></blockquote><p id="6020" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这意味着我们给它一个初始值0。接下来发生的是，当我们调用<code class="fe mr ms mt mu b">useState</code>时，我们得到一个数组，我们对其进行析构。让我们仔细检查一下:</p><blockquote class="jn jo jp"><p id="3c01" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq"> const [counter，set counter]= use state(0)；</em></p></blockquote><p id="5b4d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">好，我们将数组中的第一个值命名为<code class="fe mr ms mt mu b">counter</code>，第二个值命名为<code class="fe mr ms mt mu b">setCounter</code>。第一个值是我们可以在我们的<code class="fe mr ms mt mu b">render</code>方法中展示的实际值。第二个值<code class="fe mr ms mt mu b">setCounter()</code>是一个函数，我们可以调用它来改变<code class="fe mr ms mt mu b">counter</code>的值。所以从某种意义上来说，<code class="fe mr ms mt mu b">setCounter(3)</code>相当于写作:</p><blockquote class="jn jo jp"><p id="bf4a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">this . setstate({ counter:3 })</em></p></blockquote><h2 id="7afb" class="nd lg iq bd lh ne nf dn ll ng nh dp lp kp ni nj lt kq nk nl lx kr nm nn mb no bi translated">第二个挂钩示例——使用手推车</h2><p id="807e" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">为了确保我们完全理解如何使用它，让我们再创建几个状态:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="f553" class="nd lg iq mu b gy nt nu l nv nw">import React, { useState } from 'react';</span><span id="3e34" class="nd lg iq mu b gy nx nu l nv nw">const ProductList = () =&gt; { <br/>  const [products] = useState([{ id: 1, name: 'Fortnite' }]); <br/>  const [cart, setCart] = useState([]);<br/> <br/>  const addToCart = (p) =&gt; { <br/>    const newCartItem = { ...p }; <br/>    setCart([...cart, newCartItem]); <br/>  }</span><span id="148c" class="nd lg iq mu b gy nx nu l nv nw">return ( <br/>    &lt;div&gt; <br/>      &lt;h2&gt;Cart items&lt;/h2&gt; <br/>      {cart.map(item =&gt; &lt;div&gt;{item.name}&lt;/div&gt;)} <br/>     &lt;h2&gt;Products&lt;/h2&gt; <br/>     {products.map(p =&gt; &lt;div onClick={() =&gt; addToCart(p)}&gt;{p.name}&lt;/div&gt;)} <br/>    &lt;/div&gt; <br/>  ) <br/>}</span><span id="1ffa" class="nd lg iq mu b gy nx nu l nv nw">export default ProductList;</span></pre><p id="498b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">上面我们正在创建状态<code class="fe mr ms mt mu b">products</code>和<code class="fe mr ms mt mu b">cart</code>，这样做我们也得到它们各自的变化函数<code class="fe mr ms mt mu b">setProducts</code>和<code class="fe mr ms mt mu b">setCart</code>。我们可以在标记中看到，如果单击我们的<code class="fe mr ms mt mu b">products</code>列表中的任何一项，我们就会调用方法<code class="fe mr ms mt mu b">addToCart()</code>。这将导致调用<code class="fe mr ms mt mu b">setCart</code>，这将导致所选产品不能作为购物车商品添加到<code class="fe mr ms mt mu b">cart</code>中。这是一个简单的例子，但它真正展示了<code class="fe mr ms mt mu b">setState</code>钩子的用法。</p><h1 id="e183" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">介绍效果挂钩</h1><p id="eba4" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">效果挂钩是用来执行副作用的，例如HTTP调用。它执行与生命周期方法<code class="fe mr ms mt mu b">componentDidMount</code>、<code class="fe mr ms mt mu b">componentDidUpdate</code>和<code class="fe mr ms mt mu b">componentWillUnmount</code>相同的任务。</p><p id="f082" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">下面是我们如何使用它:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="5ca6" class="nd lg iq mu b gy nt nu l nv nw">import React, { useEffect, useState } from 'react';</span><span id="c6c7" class="nd lg iq mu b gy nx nu l nv nw">const products = [<br/>  { id: 1, name: "Fortnite" }, <br/>  { id: 2, name: "Doom" }<br/>];</span><span id="9f23" class="nd lg iq mu b gy nx nu l nv nw">const api = { <br/>  getProducts: () =&gt; { return Promise.resolve(products);},<br/>  getProduct: (id) =&gt; { return Promise.resolve(<br/>    products.find(p =&gt; p.id === id)); <br/>  } <br/>}</span><span id="c0a1" class="nd lg iq mu b gy nx nu l nv nw">const ProductList = () =&gt; { <br/>  const [products, setProducts] = useState([]); <br/>  const [product, setProduct] = useState(''); <br/>  const [selected, setSelected] = useState(2);</span><span id="332c" class="nd lg iq mu b gy nx nu l nv nw">async function fetchData() { <br/>    const products = await api.getProducts(); <br/>    setProducts(products); <br/>  }</span><span id="9eec" class="nd lg iq mu b gy nx nu l nv nw">async function fetchProduct(productId) { <br/>    const p = await api.getProduct(productId); <br/>    setProduct(p.name); <br/>  } <br/>  <br/>  useEffect(() =&gt; { <br/>    console.log('use effect'); <br/>    fetchData(); <br/>    fetchProduct(selected); <br/>  }, [selected]);</span><span id="1e23" class="nd lg iq mu b gy nx nu l nv nw">return ( <br/>    &lt;React.Fragment&gt; <br/>      &lt;h1&gt;Async shop&lt;/h1&gt; <br/>      &lt;h2&gt;Products&lt;/h2&gt; <br/>      {products.map(p =&gt; &lt;div&gt;{p.name}&lt;/div&gt;)} <br/>     &lt;h3&gt;Selected product&lt;/h3&gt; {product} <br/>     &lt;button onClick={() =&gt; setSelected(1)}&gt;Change selected&lt;/button<br/>    &lt;/React.Fragment&gt; <br/>  ); <br/>}</span><span id="ed70" class="nd lg iq mu b gy nx nu l nv nw">export default ProductList;</span></pre><p id="574a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">好吧，这里发生了很多有趣的事情。让我们先来看看<code class="fe mr ms mt mu b">useEffect</code>的用法:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="cc8d" class="nd lg iq mu b gy nt nu l nv nw">useEffect(() =&gt; { <br/>  console.log('use effect'); <br/>  fetchData(); <br/>  fetchProduct(selected); <br/>}, [selected]);</span></pre><p id="e3c1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们在上面看到的是我们调用<code class="fe mr ms mt mu b">fetchData</code>和<code class="fe mr ms mt mu b">fetchProduct</code>。这两种方法都调用标记为<code class="fe mr ms mt mu b">async</code>的方法。为什么不能在<code class="fe mr ms mt mu b">useEffect</code> async中只做调用函数呢？不幸的是，这是钩子的局限性。</p><p id="b1ca" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">查看这两种方法的定义，如下所示:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="74ff" class="nd lg iq mu b gy nt nu l nv nw">async function fetchData() { <br/>  const products = await api.getProducts(); <br/>  setProducts(products); <br/>}</span><span id="60cb" class="nd lg iq mu b gy nx nu l nv nw">async function fetchProduct(productId) { <br/>  const p = await api.getProduct(productId); <br/>  setProduct(p.name); <br/>}</span></pre><p id="9e6c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们在上面看到，我们在<code class="fe mr ms mt mu b">api</code>上调用<code class="fe mr ms mt mu b">getProducts</code>和<code class="fe mr ms mt mu b">getProduct</code>，它们都返回一个承诺。在收到解决的承诺后，使用<code class="fe mr ms mt mu b">await</code>我们调用<code class="fe mr ms mt mu b">setProducts</code>和<code class="fe mr ms mt mu b">setProduct</code>，它们是我们从<code class="fe mr ms mt mu b">useState</code>钩子得到的函数。好了，这解释了在这种情况下<code class="fe mr ms mt mu b">useEffect</code>如何像<code class="fe mr ms mt mu b">componentDidMount</code>一样工作，但是还有一个细节。让我们再来看看我们的<code class="fe mr ms mt mu b">useEffect</code>函数:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="7aa0" class="nd lg iq mu b gy nt nu l nv nw">useEffect(() =&gt; { <br/>  console.log('use effect'); <br/>  fetchData(); <br/>  fetchProduct(selected); <br/>}, [selected]);</span></pre><p id="b1b4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">上面有趣的部分是第二个论点<code class="fe mr ms mt mu b">[selected]</code>。这是我们查看<code class="fe mr ms mt mu b">selected</code>变量，并让我们自己得到变化通知，如果<code class="fe mr ms mt mu b">selected</code>发生变化，那么我们将运行我们的<code class="fe mr ms mt mu b">useEffect</code>函数。</p><p id="958d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在，试着点击底部的按钮，你会看到<code class="fe mr ms mt mu b">setSelected</code>被调用，触发<code class="fe mr ms mt mu b">useEffect</code>，因为我们正在观察它。</p><h2 id="d5b2" class="nd lg iq bd lh ne nf dn ll ng nh dp lp kp ni nj lt kq nk nl lx kr nm nn mb no bi translated">生命周期</h2><p id="707f" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">一般来说，钩子代替了对许多生命周期方法的需求，所以理解哪些方法对我们来说很重要。</p><p id="f5e1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">让我们特别讨论一下效果挂钩和它们的生命周期。</p><p id="cfbf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">以下是对其生命周期的了解:</p><ul class=""><li id="4ef4" class="mi mj iq jt b ju jv jy jz kp mk kq ml kr mm ko mn mo mp mq bi translated">默认情况下，React会在每次渲染后运行效果</li><li id="288e" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated">我们的效果是在React刷新了对DOM的更改之后运行的——包括第一次渲染</li></ul><h2 id="3829" class="nd lg iq bd lh ne nf dn ll ng nh dp lp kp ni nj lt kq nk nl lx kr nm nn mb no bi translated">访问DOM树</h2><p id="e4d7" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">让我们讨论一下当我们访问DOM树时，要执行的一个副作用。如果我们不使用钩子，我们将在方法<code class="fe mr ms mt mu b">componentDidMount</code>和<code class="fe mr ms mt mu b">componentDidUpdate</code>中使用。原因是我们不能使用<code class="fe mr ms mt mu b">render</code>方法，否则它会提前发生。</p><p id="5990" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">让我们展示如何使用生命周期方法来更新DOM:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="de61" class="nd lg iq mu b gy nt nu l nv nw">componentDidMount() { <br/>  document.title = 'Component started'; <br/>}</span><span id="7352" class="nd lg iq mu b gy nx nu l nv nw">componentDidUpdate() { <br/>  document.title = 'Component updated' <br/>}</span></pre><p id="5c96" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们看到，我们可以使用两种不同的生命周期方法来做到这一点。</p><p id="cba2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">用一个Effects钩子访问DOM树如下所示:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="7175" class="nd lg iq mu b gy nt nu l nv nw">const TitleHook = () =&gt; { <br/>  const [title, setTitle] = useState('no title');</span><span id="6c41" class="nd lg iq mu b gy nx nu l nv nw">useEffect(() =&gt; { <br/>    document.title = `App name ${title} times`; <br/>  }) <br/>}</span></pre><p id="a0bc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">正如你在上面看到的，我们可以访问<code class="fe mr ms mt mu b">props</code>以及<code class="fe mr ms mt mu b">state</code>和DOM。</p><p id="999f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">让我们提醒自己，我们对效果挂钩的了解是这样的:</p><blockquote class="jn jo jp"><p id="6a05" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">我们的效果是在React刷新DOM后运行的——包括第一次渲染</em></p></blockquote><p id="d75d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这意味着两种生命周期方法可以被一种效应所取代。</p><h2 id="d52c" class="nd lg iq bd lh ne nf dn ll ng nh dp lp kp ni nj lt kq nk nl lx kr nm nn mb no bi translated">处理安装/拆卸</h2><p id="07f5" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">现在让我们看看这个问题的另一个方面，那就是我们能够，并且我们应该在我们自己之后清理干净。这个想法是这样的:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="5e37" class="nd lg iq mu b gy nt nu l nv nw">useEffect(() =&gt; { <br/>  // set up <br/>  // perform side effect <br/>  return () =&gt; { <br/>    // perform clean up here <br/>  } <br/>});</span></pre><p id="54b5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">上面我们看到在我们的<code class="fe mr ms mt mu b">useEffect()</code>函数内部，我们像往常一样执行我们的副作用，但是我们也可以进行设置。我们还看到我们返回了一个函数。所述函数将在最后发生的事情时被调用。</p><p id="d4af" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们这里有<em class="js">设置</em>和<em class="js">拆除</em>。那么我们如何利用这一点呢？让我们看一个人为的例子，这样我们就明白了:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="561d" class="nd lg iq mu b gy nt nu l nv nw">useEffect(() =&gt; { <br/>  const id = setInterval(() =&gt; console.log('logging'));</span><span id="b8cd" class="nd lg iq mu b gy nx nu l nv nw">return () =&gt; { <br/>    clearInterval(id); <br/>  } <br/>})</span></pre><p id="565e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">上面演示了整个<em class="js">设置</em>和<em class="js">拆除</em>的场景，但正如我所说的，这有点做作。你更有可能做一些其他的事情，比如建立一个套接字连接，比如某种订阅，如下所示:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="53b3" class="nd lg iq mu b gy nt nu l nv nw">onMessage = (message) =&gt; { <br/>  // do something with message<br/>}<br/> <br/>useEffect(() =&gt; { <br/>  chatRoom.subscribe('roomId', onMessage) <br/>  return () =&gt; { <br/>    chatRoom.unsubscribe('roomId'); <br/>  } <br/>})</span></pre><h1 id="9821" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我可以创建自己的钩子吗？</h1><p id="6ca7" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">是的，你可以。有了<code class="fe mr ms mt mu b">useState</code>和<code class="fe mr ms mt mu b">useEffect</code>，世界完全开放了。你可以创建任何你需要的钩子。</p><p id="222a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">问自己以下问题:我的组件会有状态吗？我需要进行DOM操作或者AJAX调用吗？最重要的是，它是不是可以让不止一个组件受益的有用的东西？如果这里有几个<em class="js"> yes </em>你可以用一个钩子来创建它。</p><p id="3bef" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">让我们看看一些有趣的候选人，看看我们如何使用钩子来构建他们:</p><p id="b004" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">你可以创造这样的东西:</p><ul class=""><li id="6342" class="mi mj iq jt b ju jv jy jz kp mk kq ml kr mm ko mn mo mp mq bi translated"><strong class="jt ir">一个模态</strong>，它有一个状态，表示它是否显示，我们需要操作DOM来添加模态本身，当模态关闭时，它也需要清理自身</li><li id="85f1" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated">一个特征标志，特征标志将会有一个状态，在这个状态中，它将会说明某个东西是否应该被显示，它将需要从类似<code class="fe mr ms mt mu b">localStorage</code>的地方和/或通过HTTP获得它的初始状态</li><li id="3ed6" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated">电子商务应用程序中的购物车是最有可能在我们的应用程序中跟随我们的东西。我们可以将购物车同步到<code class="fe mr ms mt mu b">localStorage</code>以及后端端点。</li></ul><h1 id="2926" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">特征标志</h1><p id="00ae" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">让我们试着勾勒出我们的钩子，以及它应该如何表现:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="023b" class="nd lg iq mu b gy nt nu l nv nw">import React, { useState } from 'react';</span><span id="af84" class="nd lg iq mu b gy nx nu l nv nw">function useFeatureFlag(flag) { <br/>  let flags = localStorage.getItem("flags"); flags = flags ? JSON.parse(flags) : null;</span><span id="dca2" class="nd lg iq mu b gy nx nu l nv nw">const [enabled] = useState(Boolean(flags ? flags[flag]: false));</span><span id="92df" class="nd lg iq mu b gy nx nu l nv nw">return [enabled]; <br/>}</span><span id="9f63" class="nd lg iq mu b gy nx nu l nv nw">export default useFeatureFlag;</span></pre><p id="ca4d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">上面我们已经创建了一个名为<code class="fe mr ms mt mu b">useFeatureFlag</code>的钩子。它从<code class="fe mr ms mt mu b">localStorage</code>中读取它的值，并使用<code class="fe mr ms mt mu b">useState</code>来设置我们的钩子状态。我们不在钩子中析构一个set方法的原因是我们不想改变这个值，除非我们重新读取整个页面，此时我们将从<code class="fe mr ms mt mu b">localStorage</code>重新读取。</p><h2 id="4ad7" class="nd lg iq bd lh ne nf dn ll ng nh dp lp kp ni nj lt kq nk nl lx kr nm nn mb no bi translated">测试我们的钩子</h2><p id="4545" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">现在我们已经创建了我们的定制钩子，让我们来试一试。这个想法是对于任何使用我们的钩子只从它的值中读取的组件。如何存储特征标志值取决于钩子。所以钩子是对<code class="fe mr ms mt mu b">localStorage</code>的抽象。</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="0393" class="nd lg iq mu b gy nt nu l nv nw">import React from 'react'; <br/>import useFeatureFlag from './flag';</span><span id="8dc5" class="nd lg iq mu b gy nx nu l nv nw">const TestComponent = ({ flag }) =&gt; { <br/>  const [enabled] = useFeatureFlag(flag); <br/>  <br/>  return ( <br/>    &lt;React.Fragment&gt; <br/>      &lt;div&gt;Normal component&lt;/div&gt; <br/>     {enabled &amp;&amp; <br/>       &lt;div&gt;Experimental&lt;/div&gt; <br/>     } <br/>   &lt;/React.Fragment&gt; ); };</span><span id="762a" class="nd lg iq mu b gy nx nu l nv nw">export default TestComponent;</span><span id="8626" class="nd lg iq mu b gy nx nu l nv nw">// using it <br/>&lt;TestComponent flag="experiment1"&gt;</span></pre><h2 id="4ee1" class="nd lg iq bd lh ne nf dn ll ng nh dp lp kp ni nj lt kq nk nl lx kr nm nn mb no bi translated">为我们的功能标志创建一个管理页面</h2><p id="c79d" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">我们之前说过，我们对改变由<code class="fe mr ms mt mu b">useFeatureFlag</code>公开的值不感兴趣。为了控制我们的功能标志，我们选择创建一个特定的管理页面。我们指望管理页面在一个特定的页面上，而带有功能标志的组件在另一个页面上。如果是这种情况，那么在两个页面之间导航将意味着特征标志组件从<code class="fe mr ms mt mu b">localStorage</code>读取。</p><p id="e022" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">回到管理页面，如果我们可以列出所有的标志，并按照我们想要的方式切换它们，那就太好了。我们来写这样一个组件。我们的组件应该非常简单，因为它应该只呈现一个标志列表。然而，它需要能够在用户选择时更新一个标志。我们将需要以下内容:</p><ul class=""><li id="6e23" class="mi mj iq jt b ju jv jy jz kp mk kq ml kr mm ko mn mo mp mq bi translated"><strong class="jt ir">一个简单的列表组件</strong>，呈现所有的特征标志，并支持特定标志的切换</li><li id="f6fa" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir">一个钩子</strong>，它是对<code class="fe mr ms mt mu b">localStorage</code>的抽象，但是也能够更新它的状态</li></ul><p id="6d66" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">代码如下:</p><pre class="ku kv kw kx gt np mu nq nr aw ns bi"><span id="0f1c" class="nd lg iq mu b gy nt nu l nv nw">import React, { useState } from 'react';</span><span id="a64c" class="nd lg iq mu b gy nx nu l nv nw">const useFlags = () =&gt; { <br/>  let flags = localStorage.getItem("flags"); flags = flags ? JSON.parse(flags) : {};</span><span id="4836" class="nd lg iq mu b gy nx nu l nv nw">const [ flagsValue, setFlagsValue ] = useState(flags);</span><span id="63bc" class="nd lg iq mu b gy nx nu l nv nw">const updateFlags = (f) =&gt; { <br/>    localStorage.setItem("flags", JSON.stringify(f));<br/>    setFlagsValue(f); <br/>  }</span><span id="39f4" class="nd lg iq mu b gy nx nu l nv nw">return [flagsValue, updateFlags]; <br/>}</span><span id="9c47" class="nd lg iq mu b gy nx nu l nv nw">const FlagsPage = () =&gt; { <br/>  const [flags, setFlags] = useFlags(); <br/>  const toggleFlag = (f) =&gt; { <br/>    const currentValue = Boolean(flags[f]); <br/>    setFlags({...flags, flags[f]: !currentValue}); <br/>  }</span><span id="702d" class="nd lg iq mu b gy nx nu l nv nw">return ( <br/>    &lt;React.Fragment&gt; <br/>      &lt;h1&gt;Flags page&lt;/h1&gt; <br/>      {Object<br/>        .keys(flags)<br/>        .filter(key =&gt; flags[key]).map(flag =&gt; <br/>          &lt;div&gt;<br/>           &lt;button onClick={() =&gt; toggleFlag(flag)}&gt;{flag}&lt;/button<br/>          &lt;/div&gt;<br/>        )<br/>      } <br/>   &lt;/React.Fragment&gt; <br/>  ) <br/>}</span><span id="9edd" class="nd lg iq mu b gy nx nu l nv nw">export default FlagsPage;</span></pre><p id="ed5b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们在上面所做的是从<code class="fe mr ms mt mu b">localStorage</code>中读出旗帜，然后我们在组件中渲染它们。在一个接一个地呈现它们的同时，我们还在<code class="fe mr ms mt mu b">onClick</code>上挂接了一个方法(我知道我们在这里谈论的是钩子，但实际上没有双关的意思:)。这个方法是<code class="fe mr ms mt mu b">toggleFlag</code>，它让我们改变一个特定的标志。在<code class="fe mr ms mt mu b">toggleFlag</code>中，我们不仅设置了新的标志值，还通过在钩子上调用<code class="fe mr ms mt mu b">setFlags</code>来确保<code class="fe mr ms mt mu b">flags</code>拥有最新的更新值。</p><p id="ae1b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">还应该说，我们创建的<code class="fe mr ms mt mu b">useFlags</code>钩子使得<code class="fe mr ms mt mu b">FlagsPage</code>组件中的代码变得非常简单，所以钩子也很擅长清理。</p><h1 id="7c0d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="ee79" class="pw-post-body-paragraph jq jr iq jt b ju md jw jx jy me ka kb kp mf ke kf kq mg ki kj kr mh km kn ko ij bi translated">在这篇文章中，我们试图解释钩子产生的背景和原因，以及它希望解决和修复的问题。</p><p id="62cb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们已经知道钩子是一种给功能组件状态的方法，但是它们也能够消除对一些生命周期方法的需要。有很多现成的钩子给你，比如下面两个钩子:</p><ul class=""><li id="0cab" class="mi mj iq jt b ju jv jy jz kp mk kq ml kr mm ko mn mo mp mq bi translated"><strong class="jt ir"> useState </strong>，是一个钩子，我们可以用它来保持功能组件中的状态</li><li id="fae0" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><strong class="jt ir">使用效果</strong>也是一个钩子，但是有副作用</li></ul><p id="7690" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">但是还有很多很多我敦促你去探索，像这些<a class="ae ks" href="https://reactjs.org/docs/hooks-reference.html#additional-hooks" rel="noopener ugc nofollow" target="_blank">额外的钩子</a></p><p id="4fd9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">有了钩子，我们可以创建真正酷的和可重用的功能，所以出去吧，做一个自己的钩子。</p><h1 id="4343" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">进一步阅读</h1><ul class=""><li id="8995" class="mi mj iq jt b ju md jy me kp na kq nb kr nc ko mn mo mp mq bi translated"><a class="ae ks" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank">钩子文档</a></li><li id="1a76" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><a class="ae ks" href="https://reactjs.org/docs/hooks-intro.html#motivation" rel="noopener ugc nofollow" target="_blank">挂钩背后的动机</a></li><li id="38d8" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><a class="ae ks" href="https://usehooks.com/" rel="noopener ugc nofollow" target="_blank">挂钩食谱</a></li><li id="ce25" class="mi mj iq jt b ju mv jy mw kp mx kq my kr mz ko mn mo mp mq bi translated"><a class="ae ks" href="https://www.taniarascia.com/crud-app-in-react-with-hooks" rel="noopener ugc nofollow" target="_blank">使用钩子的CRUD示例</a></li></ul><p id="7c9f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><a class="ae ks" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank">我的twitter </a>我欢迎任何评论或链接到你创建的钩子:)</p><p id="db6a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在外面保持冷静！</p></div></div>    
</body>
</html>