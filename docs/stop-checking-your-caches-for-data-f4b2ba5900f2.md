# 停止检查你的缓存数据！

> 原文：<https://itnext.io/stop-checking-your-caches-for-data-f4b2ba5900f2?source=collection_archive---------5----------------------->

取而代之的是一种更聪明的方法，通过创建一个可依赖的抽象，使用 JavaScript 中内置的 Promise 对象..

![](img/06793230b85a79784e44c0f0010b7cc1.png)

你什么意思，别再把手伸到储藏室了？？

一部电影曾经开始…很久以前在一个遥远的星系…

当您的代码依赖于“很远”的数据时，换句话说，获取这些数据的成本很高，通常会使用缓存..然而，也经常会发现一些丑陋的样板代码，它们熟悉的外观和行为实际上隐藏着潜在的问题。我会解释为什么这是一个问题，以及如何写得更干净。

但是首先——让我们想象你在未来——你的宇宙飞船唯一可以使用的燃料是 Unobtainium。

你得到这个燃料，Unobtainium，通过调用一个函数，需要一些时间返回。现在，这个函数的返回值将是一个延迟值，所以我们将它实现为一个稍微延迟的承诺，对于一个随机确定的量，它然后被转换为如下所示的对象:

如你所见，这使得我们可以在未来的某个随机时间获得一些 A++级 Unobtainium 的承诺..

而且，由于延迟，1)缓存结果和 2)让一部分代码获取可能缓存的值是有意义的。

然而，最常见的天真实现有一些严重的缺陷，初级开发人员可能不会发现，但我会在下面为您展示:

![](img/21a1a40b699d806d2369ad133e8a9370.png)

回顾这段代码，我想到了几个问题。

*   如果启动船只时出现异常，会发生什么——燃料会被缓存吗？
*   开船的结果有承诺吗？示例:startShip()。然后(turnOnMusic)
*   这段代码的作者有没有在代码库中寻找更简洁的方法来完成这项工作？
*   是不是每一个接触缓存的新方法都应该添加所有这些样板文件？

最后，这是一个致命的分析。我们不能接受这个代码，将不得不拒绝 PR。解释将简短地写道:“需要更全面的错误处理；如果被接受，将会扩大代码库。惊讶吗？没看到吗？好吧，和我坐下来，我们会解决的。

让我们来看看清理后的版本会是什么样子:

这个架构清理了许多东西！从可读性的角度来看，我们把我们需要的东西——燃料——作为一个参数——这引出了代码的意图

但是我们的其他优势是:

1)我们没有关于缓存的逻辑—我们已经成功地干燥了我们的代码！
2)启动飞船时的异常绝不会不先缓存燃料！！
3)复制和粘贴这种模式几乎不会产生其他风格的膨胀
4)我们现在返回一个对已经启动的船的承诺:startShipSmartly(燃料)。然后(turnOnMusic)现在工作了——我们有旅程了！

你自己可能没有意识到第二点，但这正是为什么让你的应用程序中的“高级”代码知道缓存的操作细节是一个非常糟糕的想法。我本可以更早地指出这一点，但是我不希望作者只是简单地重新排序一些代码行，然后重新提交，结果却再次被拒绝。

但不管怎样，现在我们开始做生意了。我喜欢现在你可以简单地做以下事情，并获得一个可预测的、无错误的功能链，尽管获得宇宙中最难获得的元素是异步的..

恭喜你。你有一个自动缓存燃料系统。你驾驶着那块太空金属，在不弄乱你的代码库的情况下，踏上旅程的摇滚之旅！我知道你的下一次公关会遵循更干净的风格；)

作为附录，我相信您想知道如何获得如此清晰的语法，在最后，我将包括一种方法——尽管在这个主题上有许多变体..

这就是你要做的——用一种方式写的几行代码真的很棒，或者用另一种方式写的话会对你的代码库造成很大的拖累。如果你喜欢这个小小的代码审查课程，请分享它，并问我你下一步想做什么！你看——清理代码并成为你团队中的英雄是非常容易的……

或者至少比获得 Unobtanium 容易！

请鼓掌点赞，分享！

教长

PS 这篇文章有一个 Runkit 笔记本，你可以[玩代码](https://runkit.com/deanius/stop-checking-your-caches-for-data)。IMO Runkit 是一个未被充分利用的在线资源，但却如此神奇！