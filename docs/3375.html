<html>
<head>
<title>Event Data Pipelines with Redis Pub/Sub, Async Python and Dash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis发布/订阅、异步Python和Dash的事件数据管道</h1>
<blockquote>原文：<a href="https://itnext.io/event-data-pipelines-with-redis-pub-sub-async-python-and-dash-ab0a7bac63b0?source=collection_archive---------0-----------------------#2019-12-01">https://itnext.io/event-data-pipelines-with-redis-pub-sub-async-python-and-dash-ab0a7bac63b0?source=collection_archive---------0-----------------------#2019-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9dbc3ef99347b955610ce379c80cb1b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uti7xoTCscBvdyv0ww6yGA.png"/></div></div></figure><p id="d7df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是对由<a class="ae kw" href="https://www.meetup.com/pyporto/" rel="noopener ugc nofollow" target="_blank"> Python Porto </a>和<a class="ae kw" href="https://www.meetup.com/Redis-Portugal/" rel="noopener ugc nofollow" target="_blank"> RedisPortugal </a>组织的<a class="ae kw" href="https://www.meetup.com/pyporto/events/lfpdhryzqbcb/#" rel="noopener ugc nofollow" target="_blank"> meetup </a>的补充，旨在围绕Async Python、Dash和Redis Pub/Sub组织一整天的研讨会，可以用来熟悉成功的模型事件数据管道的技术和模式。将此视为白/黄带整体难度，但所有专业水平都可以利用它来学习或记忆重要概念。</p><p id="879a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建了一个迷你项目，让事情变得更实际。我们将简要介绍事件数据管道的概念，以及如何使用Python和Redis Pub/Sub实用地实现它。动手项目由<strong class="ka ir"> Roman Imankulov、</strong>构思，在GitHub上的以下<a class="ae kw" href="https://github.com/imankulov/wikipedia-playground" rel="noopener ugc nofollow" target="_blank">链接</a>中完全可用。</p><p id="9676" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将认为您已经启动并运行了一个Redis服务器实例，如其他meetup事件系列的前一篇文章<a class="ae kw" href="https://medium.com/@fcosta_oliveira/redis-5-x-under-the-hood-1-downloading-and-installing-redis-locally-3373fe67a154" rel="noopener">所述https://medium . com/@ fcosta _ Oliveira/Redis-5-x-under-the-hood-1-download-and-installing-Redis-locally-3373 Fe 67 a 154</a>。</p><h1 id="420b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">事件数据管道101</h1><p id="d968" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">事件数据管道遵循发布-订阅原则，如下图所示:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/167033e56c68c93f5c0da3d91279f25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zC4JrtL2QfYDxGqzNbkzCg.png"/></div></div></figure><p id="06dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在发布/订阅系统中，发送者向中间消息代理或事件总线发布消息，订阅者向中间代理注册订阅，让代理将消息分发给订阅者。每个订阅主题的订阅者都会收到自己发布的每条消息的副本。由一个发布者产生的单个消息可能被分发给数百、数千甚至数百万订阅者。</p><p id="9d17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发布者可以产生关于多个主题的各种事件，消费者将订阅他们感兴趣的主题。在市场上可用于实现事件数据管道的多种解决方案中，它们都有一个共同的最基本的设计原则:</p><blockquote class="mf"><p id="64c8" class="mg mh iq bd mi mj mk ml mm mn mo kv dk translated">发布者和接收者是分离的。</p></blockquote><h2 id="9f67" class="mp ky iq bd kz mq mr dn ld ms mt dp lh kj mu mv ll kn mw mx lp kr my mz lt na bi translated">发布-订阅高级原则</h2><p id="0635" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一些更先进的设计原则，如:</p><ul class=""><li id="7ace" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated">长期订阅</li><li id="1986" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">消息传递服务质量(最多一次、仅一次、至少一次)</li><li id="fdf9" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">高可用性</li><li id="c318" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">容错</li></ul><p id="6c18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将取决于所选择的解决方案，并且应该是决定事件数据管道主干的考虑因素之一。</p><p id="f97f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些可用的工具将使您能够结合这些重要的设计原则，包括Apache Kafka、AWS Kinesis、RabbitMQ、AWS SMS、Azure Service Bus Event Hub、Google Pub/Sub和Redis(带有Pub/Sub、Streams、Lists，甚至是排序集)。</p><p id="dc6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了每个工具的可用设计原则之外，您还应该考虑数据管道的<strong class="ka ir">总数据量</strong>——如果您打算使用持久订阅的话，以及在每个时刻预期的<strong class="ka ir">消息速率。事件数据管道需要以可靠、高效的方式处理由许多数据源产生的大量事件数据。</strong></p><h2 id="b2e0" class="mp ky iq bd kz mq np dn ld ms nq dp lh kj nr mv ll kn ns mx lp kr nt mz lt na bi translated">关于事件数据管道的发布/订阅或事件流的快速说明</h2><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/e5b1b9c8972a3f88536fc809eb202016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HSYt1pmp_2AeRUSwPYUUQ.png"/></div></div></figure><p id="c458" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然在发布/订阅中消息通常是*(见上图)<em class="nv">触发并忘记</em>并且永远不会被存储*(见上图)，但是事件<a class="ae kw" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank">流</a>以一种完全不同的方式工作。流抽象对于构建响应式应用是有用的(从开发人员的角度来看)</p><p id="e8f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">支持容错和可伸缩性的分布式系统。在决定发布/订阅还是事件流时，您应该问自己以下问题:</p><ul class=""><li id="cfd1" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated">您的应用程序需要能够检索<strong class="ka ir">历史事件</strong>吗？</li><li id="89f2" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">您的应用程序是否需要<strong class="ka ir">横向扩展接收</strong>？—这意味着添加客户端组，以协作使用同一数据流的不同部分。</li><li id="993e" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">您的应用程序是否需要<strong class="ka ir">细粒度订阅</strong>，即以比基于主题的方法更精细的粒度来选择事件？</li><li id="f368" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">根据您希望接收事件的主题，您的应用程序是否要求不同的<strong class="ka ir">服务质量</strong>？</li></ul><p id="ce84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数可用的市场工具通常使您能够安置流处理平台或消息传递/发布-订阅系统。使用上述问题和您可能需要的其他更高级的功能，您应该可以确定消息发布/订阅或事件流解决方案是否最合适。</p><h1 id="ed9a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Redis中的发布/订阅操作</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/199ed7734b8206254112b0b8505ec61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*86X0_3nR7DlhYXTa4gW5dw.gif"/></div></div></figure><p id="8c61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用本地Redis实例和<code class="fe nx ny nz oa b">redis-cli</code>实用程序来尝试发布-订阅原则。启动三个<code class="fe nx ny nz oa b">redis-cli</code>实例。</p><p id="0cdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了订阅频道<code class="fe nx ny nz oa b">meetup</code>，在两个连接的客户端中，发出<a class="ae kw" href="https://redis.io/commands/subscribe" rel="noopener ugc nofollow" target="_blank"> SUBSCRIBE </a>命令，提供频道名称:</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="070f" class="mp ky iq oa b gy of og l oh oi">SUBSCRIBE meetup</span></pre><p id="1298" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，从另一个客户端，我们对名为<code class="fe nx ny nz oa b">meetup</code>的通道发出一个<a class="ae kw" href="https://redis.io/commands/publish" rel="noopener ugc nofollow" target="_blank">发布</a>操作，其中包含您想要发送的消息:</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="fbf6" class="mp ky iq oa b gy of og l oh oi">PUBLISH meetup hello</span></pre><p id="8ad9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发送的消息将由Redis推送到所有订阅的客户端，如上面的GIF所示。</p><p id="cdce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在订阅客户端的上下文中允许的命令有<a class="ae kw" href="https://redis.io/commands/subscribe" rel="noopener ugc nofollow" target="_blank">订阅</a>、<a class="ae kw" href="https://redis.io/commands/psubscribe" rel="noopener ugc nofollow" target="_blank"> PSUBSCRIBE </a>、<a class="ae kw" href="https://redis.io/commands/unsubscribe" rel="noopener ugc nofollow" target="_blank">取消订阅</a>、<a class="ae kw" href="https://redis.io/commands/punsubscribe" rel="noopener ugc nofollow" target="_blank"> PUNSUBSCRIBE </a>、<a class="ae kw" href="https://redis.io/commands/ping" rel="noopener ugc nofollow" target="_blank"> PING </a>和<a class="ae kw" href="https://redis.io/commands/quit" rel="noopener ugc nofollow" target="_blank"> QUIT </a>。</p><h2 id="f0cb" class="mp ky iq bd kz mq np dn ld ms nq dp lh kj nr mv ll kn ns mx lp kr nt mz lt na bi translated">发布/订阅全局范围</h2><p id="f87c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如官方文档所述，Pub/Sub与Redis密钥空间无关，因此具有全局范围。因此，在db 10上发布的内容将被db 1上的订阅者听到。如果您需要某种类型的范围，请在通道前面加上环境的名称(测试、试运行、生产等)。</p><h2 id="ea6c" class="mp ky iq bd kz mq np dn ld ms nq dp lh kj nr mv ll kn ns mx lp kr nt mz lt na bi translated">最多一次Redis发布/订阅</h2><p id="6701" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">因为Redis Pub/Sub是<em class="nv">触发并忘记的，所以如果您的应用程序需要<strong class="ka ir">可靠的事件通知</strong>，也就是说，如果您的Pub/Sub客户端断开连接，并在稍后重新连接，则在客户端断开连接期间交付的所有事件都将丢失，因此无法使用该特性。</em></p><h2 id="43de" class="mp ky iq bd kz mq np dn ld ms nq dp lh kj nr mv ll kn ns mx lp kr nt mz lt na bi translated">在Redis，到处都是酒吧</h2><p id="c8be" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在Redis中，一个众所周知的特性是<a class="ae kw" href="https://redis.io/topics/notifications" rel="noopener ugc nofollow" target="_blank">键空间通知。它们允许客户端接收以某种方式影响Redis数据集的事件。事件是使用Redis的普通发布/订阅层交付的，所以即使您可能没有隐式地使用发布/订阅，它也会显式地在您的客户端上运行。</a></p><h1 id="4a83" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">微型项目——用Redis可视化维基百科更新流</h1><p id="4b04" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在我们已经熟悉了发布-订阅原则，以及如何在Redis中使用它，我们将深入研究一个更实际的例子。这个实践计划是由<strong class="ka ir">罗曼·伊曼库洛夫</strong>构思的，在GitHub上的以下<a class="ae kw" href="https://github.com/imankulov/wikipedia-playground" rel="noopener ugc nofollow" target="_blank">链接</a>中可以找到。要立即开始，只需遵循以下步骤:</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="13ba" class="mp ky iq oa b gy of og l oh oi">git clone <a class="ae kw" href="https://github.com/imankulov/wikipedia-playground.git" rel="noopener ugc nofollow" target="_blank">https://github.com/imankulov/wikipedia-playground.git</a><br/>cd <a class="ae kw" href="https://github.com/imankulov/wikipedia-playground.git" rel="noopener ugc nofollow" target="_blank">wikipedia-playground</a></span></pre><p id="9c58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了给你一个我们想要建模的项目的快速介绍，维基百科为所有维基媒体项目的更新提供了一个实时的<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events" rel="noopener ugc nofollow" target="_blank"> SSE </a> feed。你可以从维基百科的<a class="ae kw" href="https://wikitech.wikimedia.org/wiki/Event_Platform/EventStreams" rel="noopener ugc nofollow" target="_blank">https://wikitech . wikimedia . org/wiki/Event _ Platform/Event streams</a>找到关于事件流的文档。</p><p id="d4f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事件流源可在https://stream.wikimedia.org/v2/stream/recentchange<a class="ae kw" href="https://stream.wikimedia.org/v2/stream/recentchange" rel="noopener ugc nofollow" target="_blank">获得，并可方便可视化发布:</a></p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="aa38" class="mp ky iq oa b gy of og l oh oi">curl <a class="ae kw" href="https://stream.wikimedia.org/v2/stream/recentchange" rel="noopener ugc nofollow" target="_blank">https://stream.wikimedia.org/v2/stream/recentchange</a></span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/99dd8c6deffbdd46ca209d3194455e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*S8ddogJ7l_ZleiA6dNDFwQ.gif"/></div></div></figure><h2 id="de4d" class="mp ky iq bd kz mq np dn ld ms nq dp lh kj nr mv ll kn ns mx lp kr nt mz lt na bi translated">出版者</h2><p id="ec2d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">文件<a class="ae kw" href="https://github.com/imankulov/wikipedia-playground/blob/master/redis_publisher.py" rel="noopener ugc nofollow" target="_blank"> redis_publisher.py </a>使用aioredis，一个异步redis客户端库，从SSE读取消息并将其发布到通道“wiki”。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7993" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要担心复制代码的每个要点。完整的项目可以在GitHub的以下<a class="ae kw" href="https://github.com/imankulov/wikipedia-playground" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。在项目文件夹中，运行脚本:</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="66ce" class="mp ky iq oa b gy of og l oh oi">pipenv run ./redis_publisher.py</span></pre><p id="c493" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它立即开始向通道发布事件。您可以用一个简单的Redis客户机将它们可视化</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="a7d4" class="mp ky iq oa b gy of og l oh oi">redis-cli subscribe wiki</span></pre><p id="f379" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">键入Ctrl+C退出。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/a641105bc95c4c9c5dfbc135cf3036fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NbLd29xnAKFOoieCFGcHIw.gif"/></div></div></figure><h2 id="8557" class="mp ky iq bd kz mq np dn ld ms nq dp lh kj nr mv ll kn ns mx lp kr nt mz lt na bi translated">订户</h2><p id="de82" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">有一个脚本<a class="ae kw" href="https://github.com/imankulov/wikipedia-playground/blob/master/redis_subscriber.py" rel="noopener ugc nofollow" target="_blank"> redis_subscriber.py </a>使用来自发布订阅通道的事件，并使用普通的redis数据结构将它们建模为时序事件。Redis中有几种建模时间序列数据的方法，无论是使用有序集、流、使用模块(<a class="ae kw" href="https://oss.redislabs.com/redistimeseries/" rel="noopener ugc nofollow" target="_blank"> RedisTimeSeries </a>)还是使用更简单的散列方法(正如我们在本次会议中想要做的)。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="4aba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在项目文件夹中，运行脚本:</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="b850" class="mp ky iq oa b gy of og l oh oi">pipenv run ./redis_subscriber.py</span></pre><p id="2f0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为脚本工作的结果，将在Redis中创建一些关键字:</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="e9f4" class="mp ky iq oa b gy of og l oh oi">$ redis-cli<br/>127.0.0.1:6379&gt; keys *<br/>...<br/>7306) "ev:www.wikidata.org"<br/>7307) "ev:no.wikipedia.org"<br/>7308) "ev:cs.wiktionary.org"</span></pre><p id="2384" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您将进一步探索的，我们已经在subsbscriber.py脚本中使用了Redis <a class="ae kw" href="https://redis.io/commands#set" rel="noopener ugc nofollow" target="_blank">集合</a>和<a class="ae kw" href="https://redis.io/commands#hash" rel="noopener ugc nofollow" target="_blank">散列</a>。每种数据类型都提供不同的操作，每种操作都伴随着更高的复杂性和/或性能。你可以在官方文档中找到更多关于Redis不同数据类型的信息。</p><p id="8e16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">读完上面的要旨，你可以看到:</p><p id="4b28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">-特别是对于集合，我们使用<a class="ae kw" href="https://redis.io/commands/sadd" rel="noopener ugc nofollow" target="_blank"> SADD </a>命令对<strong class="ka ir">已知域名</strong>密钥和<strong class="ka ir">{域名} </strong>成员进行如下操作。我们这样做是为了跟踪每个不同的域:</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="46cf" class="mp ky iq oa b gy of og l oh oi">SADD known_domains {domain_name}</span></pre><p id="7ba0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您对<strong class="ka ir"> known_domains </strong>键使用<a class="ae kw" href="https://redis.io/commands/smembers" rel="noopener ugc nofollow" target="_blank"> SMEMBERS </a>命令，您将获得当前正在更新的不同域:</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="7b3c" class="mp ky iq oa b gy of og l oh oi">$ redis-cli<br/>127.0.0.1:6379&gt; <strong class="oa ir">SMEMBERS</strong><strong class="oa ir"> </strong><strong class="oa ir">known_domains</strong></span><span id="3e7a" class="mp ky iq oa b gy ol og l oh oi">1) "da.wikipedia.org"<br/>2) "fi.wikipedia.org"<br/>3) "zh.wikipedia.org"<br/>4) "nl.wikibooks.org"<br/>5) "he.wikipedia.org"<br/>6) "et.wiktionary.org"<br/>7) "fr.wikiversity.org"<br/>8) "es.wikibooks.org"<br/>...</span></pre><ul class=""><li id="2aa8" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated">特别是对于散列，我们使用<a class="ae kw" href="https://redis.io/commands/hincrby" rel="noopener ugc nofollow" target="_blank"> HINCRBY </a>命令来处理散列的<strong class="ka ir">{域名} </strong>和<strong class="ka ir">{时间戳} </strong>成员。对于每个不同的域，我们将时间序列数据建模为散列中的一组时间序列元素。然后，对于每个时间戳块，我们有一个相关的事件数。</li></ul><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="8dd0" class="mp ky iq oa b gy of og l oh oi">HINCRBY <!-- -->ev:www.wikidata.org<!-- --> {timestamp} 1</span></pre><p id="f6ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">得到的数据结构具有以下属性:</p><ul class=""><li id="1b35" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated">按域名聚集的事件。</li><li id="ad69" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">硬编码值<code class="fe nx ny nz oa b">expiration_timeout_sec</code>定义事件在Redis中存储多长时间</li><li id="01d2" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated">另一个硬编码值<code class="fe nx ny nz oa b">aggregation_interval_sec</code>定义了事件聚合间隔(以秒为单位)。</li></ul><p id="684c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，每个不同的域都有一个哈希，哈希包含多个字段，每个字段都是一个时间戳组。</p><p id="ca28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您使用<a class="ae kw" href="https://redis.io/commands/hkeys" rel="noopener ugc nofollow" target="_blank"> HKEYS </a>命令对其中一个编码域哈希<strong class="ka ir"> "en.wikipedia.org" </strong>进行操作，您将获得不同的时间戳组:</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="62b7" class="mp ky iq oa b gy of og l oh oi">$ redis-cli<br/>127.0.0.1:6379&gt; <!-- -->HKEYS filipe:en.wikipedia.org</span><span id="dce4" class="mp ky iq oa b gy ol og l oh oi">1) "1575199840"<br/>2) "1575199850"<br/>3) "1575199860"<br/>4) "1575199870"<br/>5) "1575199880"<br/>6) "1575199890"<br/>7) "1575199910"<br/>8) "1575199920"<br/>9) "1575199940"<br/>...</span></pre><h1 id="8bed" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用破折号可视化时间序列事件</h1><p id="2ab4" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Dash是一个开源的web框架，用于构建交互式数据驱动的应用程序，主要是数据可视化和仪表板。</p><p id="631d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文件<a class="ae kw" href="https://github.com/imankulov/wikipedia-playground/blob/master/dash_app.py" rel="noopener ugc nofollow" target="_blank"> dash_app.py </a>包含一个示例应用程序，它让您选择一个或多个域名来获取更新统计信息。</p><p id="243f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在项目文件夹中，运行脚本:</p><pre class="mb mc md me gt ob oa oc od aw oe bi"><span id="39a5" class="mp ky iq oa b gy of og l oh oi">pipenv run ./dash_app.py</span></pre><p id="f7ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，您应该会看到:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/aeb5ffab8ee20b05bbdbe4d1b00fbce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HfPUbY2hsRkpOMhjxb5lxA.gif"/></div></div></figure><h1 id="41e1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关键要点和后续步骤:</h1><p id="0a61" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们简要介绍了事件数据管道概念，以及如何使用Python和Redis Pub/Sub实际实现它，以及如何使用Dash(Plotly的一个开源可视化平台)实时可视化数据流。</p><p id="a152" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所想象的，这只是理论概念和所用工具的实践方面的冰山一角。通过钻研以下内容来跟上学习进度:</p><ul class=""><li id="f90c" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated">电子书Redis在行动。【计数器和统计】一章</li><li id="9fbd" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><a class="ae kw" href="https://wikitech.wikimedia.org/wiki/Event_Platform/EventStreams#Python" rel="noopener ugc nofollow" target="_blank">维基媒体事件流</a></li><li id="27c7" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><a class="ae kw" href="https://github.com/andymccurdy/redis-py" rel="noopener ugc nofollow" target="_blank"> Python客户端for Redis (redis-py) </a></li><li id="6f3a" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><a class="ae kw" href="https://dash.plot.ly/" rel="noopener ugc nofollow" target="_blank"> Plotly Dash文档</a></li><li id="4f3a" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><a class="ae kw" href="https://plot.ly/python/time-series/" rel="noopener ugc nofollow" target="_blank"> Plotly时间序列示例</a></li><li id="a33b" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><a class="ae kw" href="https://plot.ly/python/reference/" rel="noopener ugc nofollow" target="_blank"> Plotly Python API参考</a></li></ul><p id="667f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以参加RedisLabs的Redis大学的几门课程，这些课程将使您能够学习成功建模各种数据结构的技术和模式，以有效和高效地使用Redis，并深入研究更高级的主题，如这里描述的主题:</p><ul class=""><li id="ab5f" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated"><a class="ae kw" href="https://university.redislabs.com/courses/course-v1:redislabs+RU101+2020_01/about" rel="noopener ugc nofollow" target="_blank">Redis数据结构介绍</a></li><li id="6734" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><a class="ae kw" href="https://university.redislabs.com/courses/course-v1:redislabs+RU202+2020_01/about" rel="noopener ugc nofollow" target="_blank"> Redis流</a></li><li id="cc23" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><a class="ae kw" href="https://university.redislabs.com/courses/course-v1:redislabs+DEVELOPER-CERTIFICATION-1+2019-2020/about" rel="noopener ugc nofollow" target="_blank"> Redis认证开发者计划</a></li></ul></div></div>    
</body>
</html>