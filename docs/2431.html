<html>
<head>
<title>A JavaScript user’s First AWS Lambda function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个JavaScript用户的第一个AWS Lambda函数</h1>
<blockquote>原文：<a href="https://itnext.io/a-javascript-users-first-aws-lambda-function-ed74c0441d6?source=collection_archive---------6-----------------------#2019-05-22">https://itnext.io/a-javascript-users-first-aws-lambda-function-ed74c0441d6?source=collection_archive---------6-----------------------#2019-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d27c4b2799a718ff91ec6966c7b61d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3HSOXkeYa3c93JbHKWUvA.png"/></div></div></figure><p id="a6c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在工作中大约80%的编码时间都在使用JavaScript，主要用于前端。我喜欢这份工作和最近的JS生态系统。它不仅增强了前端开发人员的能力，也增强了后端开发人员的能力。此外，最近，无服务器技术是我的许多热门话题之一。因为我听到了很多关于AWS的好消息，我开始阅读由<a class="ae kw" href="https://twitter.com/sbarski" rel="noopener ugc nofollow" target="_blank">彼得·斯巴斯基</a>写的“<a class="ae kw" href="https://www.amazon.ca/Serverless-Architectures-AWS-examples-Lambda/dp/1617293822" rel="noopener ugc nofollow" target="_blank">AWS上的无服务器架构</a>”。它解释了如何使用AWS和Firebase从头开始部署无服务器应用程序。我刚刚完成了“只是阅读”，现在，按照说明，已经进入AWS控制台创建示例应用程序。我承认在阅读这本书之前，我在AWS控制台上并不舒服，但现在我已经习惯了，❤</p><p id="cb28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止我真的很喜欢这本书。你也可以在这个<a class="ae kw" href="https://www.manning.com/books/serverless-architectures-on-aws?a_aid=serverless-architectures-on-aws&amp;a_bid=145280de" rel="noopener ugc nofollow" target="_blank">网站</a>上阅读这本书。在第三章，他们解释了如何创建一个lambda函数。你可以在这里看到代码<a class="ae kw" href="https://github.com/sbarski/serverless-architectures-aws/tree/master/chapter-3/Listing%203.1%20-%203.4%20-%20Transcode%20Video%20Lambda" rel="noopener ugc nofollow" target="_blank"/>。因为这本书的主要焦点是关于无服务器架构的，所以没有提到其他任何东西。在这篇文章中，我想从JS用户的角度添加一些特性来改进这些步骤。</p><p id="fded" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的目标读者是那些开始学习现代JS开发工具的人，比如node、npm和git。我认为我的JS工作经验有限，所以非常感谢专家的反馈。</p><p id="2d47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前提条件是您必须设置一个正确的IAM用户和AWS CLI。如果你还没有，我推荐你阅读<a class="ae kw" href="https://livebook.manning.com/#!/book/serverless-architectures-on-aws/appendix-b" rel="noopener ugc nofollow" target="_blank">附录B </a>。</p><h1 id="42e7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">目录</h1><ol class=""><li id="c471" class="lv lw iq ka b kb lx kf ly kj lz kn ma kr mb kv mc md me mf bi translated">做一些工作(复制代码，运行简单的测试)</li><li id="69eb" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated">负责任——编写单元测试(Jest)</li><li id="dcbb" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated">整理—格式代码(ESLint，更漂亮)</li><li id="3ccb" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated">提交—让我们自动运行测试(husky，lint-staged)</li><li id="d391" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated">部署—我们不应上传开发依赖项(npm修剪)</li></ol><h1 id="bf12" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.做一些工作(复制代码，运行简单的测试)</h1><p id="9665" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><em class="mo">注意:如果你已经用node.js构建了lambda函数，你可以跳过这一步</em></p><p id="9c10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我要你从他的资料库下载一些文件。我希望你的工作目录里有<code class="fe mp mq mr ms b">package.json</code>、<code class="fe mp mq mr ms b">index.js</code>、<code class="fe mp mq mr ms b">tests/</code>和<code class="fe mp mq mr ms b">tests/event.json</code>。让我们先用这个命令安装依赖项:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="ba44" class="nb ky iq ms b gy nc nd l ne nf">$ npm install</span></pre><p id="849b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我假设您也可以运行测试命令:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="c866" class="nb ky iq ms b gy nc nd l ne nf">$ npm run test</span></pre><p id="c8e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后你可以看到来自<code class="fe mp mq mr ms b">console.log()</code>的“欢迎”作为结果。你看到了吗？厉害！对于这篇博文，我们实际上不打算使用<code class="fe mp mq mr ms b">index.js</code>。让我们复制该文件并将其命名为<code class="fe mp mq mr ms b">handler.js</code>。然后打开文件，像下面这样修改，这样我们就可以测试了！</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">handler.js</figcaption></figure><h1 id="7085" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.负责任——编写单元测试(Jest)</h1><p id="ac1b" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">编写测试的目的是保证模块总是按预期工作。如果你没有进行任何测试，然后有人改变了这个模块，没有人知道这个模块是否像改变之前那样工作。让我们使用进行单元测试。使用以下命令安装jest:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="c697" class="nb ky iq ms b gy nc nd l ne nf">$ npm install -D jest</span></pre><p id="f9ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们制作一个名为<code class="fe mp mq mr ms b">__tests__</code>的目录。Jest会自动检查目录中是否有测试文件。</p><p id="3d9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将测试文件命名为<code class="fe mp mq mr ms b">handler.spec.js</code>，并保存在<code class="fe mp mq mr ms b">__tests__</code>下。</p><p id="07f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我写的测试代码看起来像这样:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">__tests__/handler.spec.js</figcaption></figure><p id="7645" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个简单的测试代码根据输入文件(<code class="fe mp mq mr ms b">../tests/event.json</code>)检查每个键是否正确生成。我们还想在<code class="fe mp mq mr ms b">package.json</code>的<code class="fe mp mq mr ms b">scripts</code>中添加<code class="fe mp mq mr ms b">"jest": "jest"</code>来运行测试命令。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">package.json</figcaption></figure><p id="a6ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您准备好了，让我们用这个命令运行单元测试:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="8226" class="nb ky iq ms b gy nc nd l ne nf">$ npm run jest</span></pre><p id="c012" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会看到以下消息:</p><blockquote class="nm nn no"><p id="96db" class="jy jz mo ka b kb kc kd ke kf kg kh ki np kk kl km nq ko kp kq nr ks kt ku kv ij bi translated"><em class="iq">生成正确的密钥(4毫秒)</em></p></blockquote><p id="218b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">恭喜你。您的第一个测试检查所有的键。这样，即使其他人改变了<code class="fe mp mq mr ms b">handler.js</code>，键值也不会改变，因为测试会检测到其他情况。</p><h1 id="cfd9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">3.整理—格式代码(ESLint，更漂亮)</h1><p id="70d7" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">ESLint 是一个林挺工具，可以发现一些有问题的模式。它在JS社区得到了广泛的应用。<a class="ae kw" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮</a>是一个代码格式化程序，让你的代码看起来“更漂亮”。它们都是很好的工具。让我们试试吧！使用以下命令安装它们:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="5bcc" class="nb ky iq ms b gy nc nd l ne nf">$ npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier</span></pre><p id="61f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要初始化ESLint:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="3c57" class="nb ky iq ms b gy nc nd l ne nf">$ npx eslint --init</span></pre><p id="05d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它会问多个问题。让我留下我对以下问题的回答:</p><blockquote class="nm nn no"><p id="c437" class="jy jz mo ka b kb kc kd ke kf kg kh ki np kk kl km nq ko kp kq nr ks kt ku kv ij bi translated"><em class="iq">？您希望如何使用ESLint？检查语法和发现问题<br/>？你的项目使用什么类型的模块？JavaScript模块(导入/导出)<br/>？你的项目使用哪个框架？这些<br/>都没有？你的代码在哪里运行？节点<br/>？您希望您的配置文件采用什么格式？找不到JavaScript <br/>本地ESLint安装。<br/>您选择的配置需要以下依赖关系:<br/>？您想现在用npm安装它们吗？是</em></p></blockquote><p id="fb8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，用ESLint整合更漂亮。在<a class="ae kw" href="https://prettier.io/docs/en/integrating-with-linters.html#eslint" rel="noopener ugc nofollow" target="_blank">beauty的网站</a>上，他们告诉你如何整合。检查ESLint部分并尝试设置。</p><p id="9646" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们为林挺运行下面这个命令<code class="fe mp mq mr ms b">handler.js</code></p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="8f0e" class="nb ky iq ms b gy nc nd l ne nf">$ npx eslint handler.js</span></pre><p id="6a3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它会提到这样的事情:</p><blockquote class="nm nn no"><p id="5b82" class="jy jz mo ka b kb kc kd ke kf kg kh ki np kk kl km nq ko kp kq nr ks kt ku kv ij bi translated"><em class="iq"> 5:59错误将</em> <code class="fe mp mq mr ms b"><em class="iq">'·'</em></code> <em class="iq">替换为</em> <code class="fe mp mq mr ms b"><em class="iq">"·"</em></code> <em class="iq">更漂亮/更漂亮</em></p></blockquote><p id="b102" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不是很方便吗？这个过程建议在哪里修复代码，并规定您的代码应该是什么样子。你也可以通过改变<code class="fe mp mq mr ms b">.eslintrc.json</code>来自行改变规则。请查看他们的文件以获取更多信息。此外，如果您运行以下命令，它可能会自动修复问题。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="778b" class="nb ky iq ms b gy nc nd l ne nf">$ npx eslint --fix handler.js<!-- --> </span></pre><h1 id="1768" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">4.提交—让我们自动运行测试(husky，lint-staged)</h1><p id="ca16" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在前面的步骤中，您学习了如何测试，以及如何整理代码。然而，您可能会忘记运行测试，或者在git-commit更改之前运行ESLint命令。在这一步，我希望在git-commit时自动运行脚本。</p><p id="177f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">git-commit时有很多方法可以运行命令。使用<code class="fe mp mq mr ms b">.git/hooks/pre-commit.sample</code>是一种方法。这次我想用<a class="ae kw" href="https://github.com/typicode/husky" rel="noopener ugc nofollow" target="_blank">哈士奇</a>和<a class="ae kw" href="https://github.com/okonet/lint-staged" rel="noopener ugc nofollow" target="_blank">皮棉阶段</a>。使用这些工具的好处是你只需要写少量的代码。husky会为您生成实际的脚本。只有一点需要注意——如果你想在正在进行的项目中使用husky，你应该小心，因为它会与现有的git挂钩冲突。</p><p id="fd57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装这些工具时，请安装:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="a289" class="nb ky iq ms b gy nc nd l ne nf">$ npm install -D lint-staged husky</span></pre><p id="5fd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在<code class="fe mp mq mr ms b">package.json</code>中添加这个片段:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">package.json</figcaption></figure><p id="677d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">lint-staged</code>的配置适用于任何JavaScript文件，除了在<code class="fe mp mq mr ms b">__tests__</code>目录中的文件。当该工具找到一个JavaScript文件时，它会检查格式并整理它，就像我们在步骤3中所做的那样。然后如果有什么变化，用<code class="fe mp mq mr ms b">git add</code>加上。最后，运行由<code class="fe mp mq mr ms b">jest</code>支持的测试，就像我们在步骤2中所做的一样。</p><p id="a7c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<code class="fe mp mq mr ms b">husky</code>的配置，我将<code class="fe mp mq mr ms b">lint-staged</code>设置为在运行git-commit时执行。当运行git-push时，husky执行<code class="fe mp mq mr ms b">jest</code>来检查所有单元测试。</p><p id="18bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尝试运行git-commit并确保您的测试和linter都能运行。</p><h1 id="be11" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">5.部署—我们不应上传开发依赖项(npm修剪)</h1><p id="c459" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在你的<code class="fe mp mq mr ms b">package.json</code>里，应该有<code class="fe mp mq mr ms b">scripts</code>里的<code class="fe mp mq mr ms b">deploy</code>和<code class="fe mp mq mr ms b">predeploy</code>。如果没有，<a class="ae kw" href="https://github.com/sbarski/serverless-architectures-aws/blob/master/chapter-3/Listing%203.1%20-%203.4%20-%20Transcode%20Video%20Lambda/package.json#L8" rel="noopener ugc nofollow" target="_blank">查看一下图书作者的知识库</a>。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">package.json</figcaption></figure><p id="d81a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些脚本将在您运行部署命令时执行。</p><p id="82cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们简单地运行部署命令:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="0e48" class="nb ky iq ms b gy nc nd l ne nf">$ npm run deploy</span></pre><p id="8c23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该能够看到在命令完成后创建了一个zip文件“Lambda-Deployment.zip”。</p><p id="38ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，请查看日志中的<code class="fe mp mq mr ms b">CodeSize</code>。这是<code class="fe mp mq mr ms b">aws lambda update-function-code</code>命令的输出。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">标准输出</figcaption></figure><p id="325d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，代码大小是26.3 MB (26，312，199字节)。这太大了！这是因为我们正在上传工作目录中的所有内容。它可能会降低AWS Lambda的速度，同时还会花很多时间将zip文件上传到AWS。这很糟糕。</p><p id="d943" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在AWS Lambda中我们不需要的是devDependencies。在前面的步骤中，我们安装了多个模块来编写测试和格式化代码，但是它们不会在AWS Lambda中使用。让我们删除devDependencies。</p><p id="1621" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们如何从你的工作目录中删除依赖关系正在运行<code class="fe mp mq mr ms b">npm prune --production</code>。它将删除您的dev dependencies[<a class="ae kw" href="https://docs.npmjs.com/cli/prune.html" rel="noopener ugc nofollow" target="_blank">docs</a>]中指定的包。当我们在部署之前运行它时，我们必须能够减小大小。</p><p id="79ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们应该取回那些在部署后被删除的包。<code class="fe mp mq mr ms b">npm i --offline</code>看起来有用。它从缓存安装软件包，因此它不需要任何网络访问。你可以在这里阅读更多关于命令<a class="ae kw" href="https://github.com/npm/npm/issues/2568#issuecomment-331753223" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="2603" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在您的<code class="fe mp mq mr ms b">package.json</code>中使用这些npm命令:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">package.json</figcaption></figure><p id="84c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在压缩文件之前，我们将删除“预部署”中devDependencies中的所有包，然后在“后部署”中取回这些包。</p><p id="79e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，再次尝试展开！</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="129b" class="nb ky iq ms b gy nc nd l ne nf">$ npm run deploy</span></pre><p id="1116" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后看看日志中的<code class="fe mp mq mr ms b">CodeSize</code>。我的如下:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">标准输出</figcaption></figure><p id="e8d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，CodeSize变成了5.6 MB (5，665，493字节)，这是我们之前上传的20%。<strong class="ka ir">牛逼</strong>！</p><p id="7a77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这篇文章，我们学习了如何对你的代码负责，以及如何使你的代码可维护/可读，而不会对我们的代码大小产生巨大的影响。我希望你喜欢这本书的帖子。再说一遍，这本书真的很好，我强烈推荐。</p><p id="b4a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读！编码快乐！</p><h1 id="acb5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">参考</h1><ul class=""><li id="8a47" class="lv lw iq ka b kb lx kf ly kj lz kn ma kr mb kv ns md me mf bi translated"><a class="ae kw" href="https://www.orangejellyfish.com/blog/code-consistency-with-eslint-and-husky/" rel="noopener ugc nofollow" target="_blank">与ESLint和Husky的代码一致性</a></li><li id="29ea" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv ns md me mf bi translated"><a class="ae kw" href="https://benmccormick.org/2017/02/26/running-jest-tests-before-each-git-commit/" rel="noopener ugc nofollow" target="_blank">在每次Git提交之前运行Jest测试</a></li><li id="cd2b" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv ns md me mf bi translated"><a class="ae kw" href="https://github.com/apex/up/issues/603#issuecomment-476190913" rel="noopener ugc nofollow" target="_blank"> npm清理，npm i —离线</a></li></ul></div></div>    
</body>
</html>