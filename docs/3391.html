<html>
<head>
<title>Some structure data for work with API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用API的一些结构化数据</h1>
<blockquote>原文：<a href="https://itnext.io/some-structure-data-for-work-with-api-8e9f2816cd84?source=collection_archive---------5-----------------------#2019-12-03">https://itnext.io/some-structure-data-for-work-with-api-8e9f2816cd84?source=collection_archive---------5-----------------------#2019-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4fb420f6d565836a9fb4bb6b52e3b9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSGqh1fCyCqyS9lREqTwZQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯多夫·高尔在<a class="ae kc" href="https://unsplash.com/photos/m_HRfLhgABo" rel="noopener ugc nofollow" target="_blank">杂志</a>上拍摄的照片</figcaption></figure><p id="1ff1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">一个</span> RESTful API是一个应用程序接口(API)，它使用HTTP请求来获取、上传、发布和删除数据。</p><p id="d36d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">RESTful API——也称为RESTful web服务或REST API——基于表述性状态转移(REST)技术，这是一种架构风格，也是web服务开发中常用的通信方法。</span></p><p id="29d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">TTP——最初是数据传输的应用层协议——以“HTML”格式的超文本文档的形式，目前用于任意数据的传输。HTTP的基础是“客户机-服务器”技术，即存在:</p><ul class=""><li id="dc35" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">发起连接并发送请求的消费者(客户端)；</li><li id="4ce0" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">等待连接的提供者(服务器)接收请求，执行必要的操作，并返回一条包含结果的消息。</li></ul><p id="e9c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> HTTP </strong>协议是为应用程序和web服务器相互“通信”而设计的。并在网页上传递了一些信息。<br/> HTTP协议最初是Keep-Alive，是什么意思？当用户访问网站时，任何请求都不会被授权，后续的请求，如基于cookies或标题的用户授权和身份验证。该数据在GET或POST请求中发送。通常，授权是通过cookies进行的。</p><p id="10d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">cookie是由网络服务器发送并存储在用户电脑上的一小段数据。web客户端(通常是web浏览器)在每次尝试打开站点上的页面时，都会将这段数据作为HTTP请求的一部分发送到web服务器。它用于在用户端存储数据，实际上它通常用于:</p><ul class=""><li id="2733" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">认证用户；</li><li id="770e" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">个人偏好和用户设置的存储；</li><li id="eba4" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">监控用户访问会话状态；</li><li id="45d4" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">维护关于用户的统计数据。</li></ul><p id="33b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">cookie</strong>在任何请求中传输，任何服务器都可以根据一些数据，即根据cookie和GET或POST请求中的一些参数，了解您是谁以及您拥有什么访问权限。HTTP协议最常见的方法是GET和POST。其余的存在，但真正的应用程序并不经常使用它们。<br/>关于任何请求你需要知道的最基本的事情:<br/>任何请求发送时，都会产生一个包，并且会在应用层发送。<br/>每个包由一个请求行、请求头和请求体组成。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/3d895024669188ff58fff36b16f4d655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*gL3rDLeWO_ctEBmPLYWcrw.png"/></div></figure><p id="7978" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GET请求只发送一些数据的报头。发送的数据位于请求消息头中，响应的数据位于响应头中。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/cbd6c8938ba37d4115996276cf30ac12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJfA8WMLAdPYPybPG-ZKew.png"/></div></div></figure><p id="0d31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">POST请求不仅发送请求头，还发送消息正文。在主体中，可以传递任何数据格式，JSON、XML、媒体文件、数据、认证等。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/91eab95fb1427b3285d51b952c11994c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*FyUdYFJfwU4iC9wIx11ePA.png"/></div></figure><p id="4d62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">GET请求和POST有什么区别？</strong></p><p id="3520" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GET包含唯一的标题，POST包含标题和正文。主体包含一个简单的数据结构。</p><p id="6bbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你把头和体传递给GET会怎么样？什么都不会发生。GET将正确无误地工作。</p><p id="688d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">这两个问题在面试应聘者时很常见。这就是为什么我将它们包含在本文中。</strong></p><p id="7de7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> JSON模式到POJO。</strong></p><div class="mf mg gp gr mh mi"><a href="http://www.jsonschema2pojo.org/" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">jsonschema2pojo</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">从JSON或JSON-Schema生成普通的旧Java对象。对于“属性”定义中出现的每个属性，我们…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">www.jsonschema2pojo.org</p></div></div></div></a></div><p id="e2c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个资源允许您从JSON或JSON-Schema中生成普通的旧Java对象。</p><p id="7035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，从斯瓦格<a class="ae kc" href="http://petstore.swagger.io/" rel="noopener ugc nofollow" target="_blank">http://petstore.swagger.io/</a>的JSON到POST方法</p><pre class="lz ma mb mc gt mr ms mt mu aw mv bi"><span id="77d4" class="mw mx iq ms b gy my mz l na nb">{<strong class="ms ir"><br/>  </strong>"id":<strong class="ms ir"> 0</strong>,<strong class="ms ir"><br/>  </strong>"category":<strong class="ms ir"> </strong>{<strong class="ms ir"><br/>    </strong>"id":<strong class="ms ir"> 0</strong>,<strong class="ms ir"><br/>    </strong>"name":<strong class="ms ir"> </strong>"string"<strong class="ms ir"><br/>  </strong>},<strong class="ms ir"><br/>  </strong>"name":<strong class="ms ir"> </strong>"doggie",<strong class="ms ir"><br/>  </strong>"photoUrls":<strong class="ms ir"> </strong>[<strong class="ms ir"><br/>    </strong>"string"<strong class="ms ir"><br/>  </strong>],<strong class="ms ir"><br/>  </strong>"tags":<strong class="ms ir"> </strong>[<strong class="ms ir"><br/>    </strong>{<strong class="ms ir"><br/>      </strong>"id":<strong class="ms ir"> 0</strong>,<strong class="ms ir"><br/>      </strong>"name":<strong class="ms ir"> </strong>"string"<strong class="ms ir"><br/>    </strong>}<strong class="ms ir"><br/>  </strong>],<strong class="ms ir"><br/>  </strong>"status":<strong class="ms ir"> </strong>"available"<strong class="ms ir"><br/></strong>}</span></pre><p id="51e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模型生成后，在生成文件的主体中包含注释<a class="ae kc" href="http://twitter.com/JsonPropertyOrder" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">@ jsonpropertyeorder</strong></a>该注释检查响应中所有元素的顺序。<br/>这种方法是合同测试的原型。对于每个属性，为每个getter和setter插入注释<a class="ae kc" href="http://twitter.com/JsonPropertyOrder" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">@ JsonPropertyOrder</strong></a>。</p><pre class="lz ma mb mc gt mr ms mt mu aw mv bi"><span id="2c2e" class="mw mx iq ms b gy my mz l na nb"><strong class="ms ir">public class </strong>Category {</span><span id="9970" class="mw mx iq ms b gy nc mz l na nb">    @JsonProperty(<strong class="ms ir">"id"</strong>)<br/>    <strong class="ms ir">private </strong>Integer <strong class="ms ir">id</strong>;<br/>    @JsonProperty(<strong class="ms ir">"name"</strong>)<br/>    <strong class="ms ir">private </strong>String <strong class="ms ir">name</strong>;<br/>    @JsonIgnore<br/>    <strong class="ms ir">private </strong>Map&lt;String, Object&gt; <strong class="ms ir">additionalProperties </strong>= <strong class="ms ir">new </strong>HashMap&lt;String, Object&gt;();</span><span id="a4c8" class="mw mx iq ms b gy nc mz l na nb">    @JsonProperty(<strong class="ms ir">"id"</strong>)<br/>    <strong class="ms ir">public </strong>Integer getId() {<br/>        <strong class="ms ir">return id</strong>;<br/>    }</span><span id="0ef7" class="mw mx iq ms b gy nc mz l na nb">    @JsonProperty(<strong class="ms ir">"id"</strong>)<br/>    <strong class="ms ir">public void </strong>setId(Integer id) {<br/>        <strong class="ms ir">this</strong>.<strong class="ms ir">id </strong>= id;<br/>    }</span><span id="7912" class="mw mx iq ms b gy nc mz l na nb">    @JsonProperty(<strong class="ms ir">"name"</strong>)<br/>    <strong class="ms ir">public </strong>String getName() {<br/>        <strong class="ms ir">return name</strong>;<br/>    }</span><span id="792f" class="mw mx iq ms b gy nc mz l na nb">    @JsonProperty(<strong class="ms ir">"name"</strong>)<br/>    <strong class="ms ir">public void </strong>setName(String name) {<br/>        <strong class="ms ir">this</strong>.<strong class="ms ir">name </strong>= name;<br/>    }<br/>}<br/>..................................................................</span></pre><p id="bd27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的缺点是对JSON文件大小的限制。</p><p id="9e89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">插件RoboPOJOGenerator。</strong></p><p id="ba9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Intellij Idea，用于JSON到POJO转换的Android Studio插件。</p><p id="be5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从JSON: GSON，AutoValue，Logan Square，FastJSON，Jackson，Moshi，empty annotations模板生成Java和Kotlin POJO文件。支持:基本类型，多个内部JSONArrays。</p><p id="7a81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">安装</strong></p><p id="e2d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从插件库中获取并安装，或者在“首选项”-&gt;“插件”-&gt;“浏览库”-&gt;“RoboPOJOGenerator”中找到它。</p><p id="8e31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如何使用</strong></p><p id="4dca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择目标包-&gt;新建-&gt;从JSON生成POJO。</p><p id="25b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注解<a class="ae kc" href="http://twitter.com/JsonPropertyOrder" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">@ JsonPropertyOrder</strong></a>这个插件只添加字段，不添加getters和setters。</p><p id="b21a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的缺点是对JSON文件大小的限制。</p><p id="68b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">数据结构不是JSON和XML怎么办？</strong></p><p id="ee8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时响应是XML而不是JSON。</p><p id="709a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，没有方便的XML生成器。基于XML生成POJO的唯一选择主要是生成XSD (XML模式定义)。</p><p id="d691" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">XML Schema是一种描述XML文档结构的语言。XML模式规范是W3C的推荐标准。</p><p id="7af6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像大多数XML标记语言一样，XML Schema被设计用来定义文档必须遵守的规则。但是与其他语言不同，XML Schema被设计成可以在创建处理XML文档的软件时使用。</p><p id="0ece" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据XML模式验证文档后，读者可以创建一个文档数据模型，其中包括:</p><ul class=""><li id="0737" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">字典(元素和属性的名称)；</li><li id="31c6" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">内容模型(元素和属性之间的关系及其结构)；</li><li id="b9cd" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">数据类型。</li></ul><p id="a290" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似于JSON schema to POJO，首先我们需要从XML生成一个schema，然后基于这个XML生成XSD。</p><p id="f2c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从斯瓦格<a class="ae kc" href="http://petstore.swagger.io/" rel="noopener ugc nofollow" target="_blank">http://petstore.swagger.io/</a>获取XML内容以选择帖子和应用程序/XML:</p><pre class="lz ma mb mc gt mr ms mt mu aw mv bi"><span id="fe00" class="mw mx iq ms b gy my mz l na nb">&lt;?<strong class="ms ir">xml version</strong>="1.0"<strong class="ms ir"> encoding</strong>="UTF-8"?&gt;<strong class="ms ir"><br/></strong>&lt;<strong class="ms ir">Pet</strong>&gt;<strong class="ms ir"><br/>	</strong>&lt;<strong class="ms ir">id</strong>&gt;<strong class="ms ir">0</strong>&lt;/<strong class="ms ir">id</strong>&gt;<strong class="ms ir"><br/>	</strong>&lt;<strong class="ms ir">Category</strong>&gt;<strong class="ms ir"><br/>		</strong>&lt;<strong class="ms ir">id</strong>&gt;<strong class="ms ir">0</strong>&lt;/<strong class="ms ir">id</strong>&gt;<strong class="ms ir"><br/>		</strong>&lt;<strong class="ms ir">name</strong>&gt;string&lt;/<strong class="ms ir">name</strong>&gt;<strong class="ms ir"><br/>	</strong>&lt;/<strong class="ms ir">Category</strong>&gt;<strong class="ms ir"><br/>	</strong>&lt;<strong class="ms ir">name</strong>&gt;<strong class="ms ir">doggie</strong>&lt;/<strong class="ms ir">name</strong>&gt;<strong class="ms ir"><br/>	</strong>&lt;<strong class="ms ir">photoUrl</strong>&gt;<strong class="ms ir"><br/>		</strong>&lt;<strong class="ms ir">photoUrl</strong>&gt;string&lt;/<strong class="ms ir">photoUrl</strong>&gt;<strong class="ms ir"><br/>	</strong>&lt;/<strong class="ms ir">photoUrl</strong>&gt;<strong class="ms ir"><br/>	</strong>&lt;<strong class="ms ir">tag</strong>&gt;<strong class="ms ir"><br/>		</strong>&lt;<strong class="ms ir">Tag</strong>&gt;<strong class="ms ir"><br/>			</strong>&lt;<strong class="ms ir">id</strong>&gt;<strong class="ms ir">0</strong>&lt;/<strong class="ms ir">id</strong>&gt;<strong class="ms ir"><br/>			</strong>&lt;<strong class="ms ir">name</strong>&gt;string&lt;/<strong class="ms ir">name</strong>&gt;<strong class="ms ir"><br/>		</strong>&lt;/<strong class="ms ir">Tag</strong>&gt;<strong class="ms ir"><br/>	</strong>&lt;/<strong class="ms ir">tag</strong>&gt;<strong class="ms ir"><br/>	</strong>&lt;<strong class="ms ir">status</strong>&gt;<strong class="ms ir">available</strong>&lt;/<strong class="ms ir">status</strong>&gt;<strong class="ms ir"><br/></strong>&lt;/<strong class="ms ir">Pet</strong>&gt;</span></pre><p id="bd63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> XML到XSD在线生成。</strong></p><div class="mf mg gp gr mh mi"><a href="https://www.freeformatter.com/xsd-generator.html" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">XSD/XML模式生成器</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">从XML文件生成XSD (XML架构)。只需复制粘贴或上传您的XML文档，让生成器…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">www.freeformatter.com</p></div></div></div></a></div><p id="7700" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在XML的基础上，我们生成XSD，从而创建模式文件。XSD</p><p id="bde7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过调用Windows上的PowerShell控制台或Linux上的常规终端，您可以使用XJC程序。</p><p id="0a9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> XJC — </strong>将XML模式文件编译成完全带注释的Java类。</p><p id="ede7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">使用XJC。</strong></p><p id="8c68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您在下面的代码片段中看到的，XJC支持很多选项。最重要的是</p><p id="d850" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">举例:</strong></p><p id="c2a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">xjc</strong>-d src-p io . swagger . pet store schema . xsd</p><p id="46ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">-d定义生成的类应该存储在文件系统中的什么位置，</p><p id="1915" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">-p来定义要使用的包，当然</p><ul class=""><li id="a67c" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">如果你还需要什么帮助。</li></ul><p id="7154" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">XJC和JAXB的利弊。</strong></p><p id="abe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">优点</strong>:</p><ul class=""><li id="e55c" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">生成一个包含内部类的文件，该文件用于模型/第二个ObjectFactory文件仅在您拥有相同类型的模型时使用。<br/>但是它们有不同的字段，比使用ObjectFactory你可以分配一个新的不同的模型有不同的字段)。<br/>例如，PojoGenerator创建几个与响应者数量相等的类。</li><li id="8c36" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">使用了<a class="ae kc" href="http://twitter.com/XmlRootElement" rel="noopener ugc nofollow" target="_blank"> @XmlRootElement </a>和<a class="ae kc" href="http://twitter.com/XmlElement" rel="noopener ugc nofollow" target="_blank"> @XmlElement </a>注释。</li><li id="07b4" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">足够灵活，可以工作。它是基于XML的。</li><li id="1860" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">JAXB不仅适用于REST，也适用于SOAP。</li></ul><p id="1aac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">缺点</strong>:</p><p id="6ccc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在生成过程中，大量的文档以注释的形式插入。</p><p id="5ab3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">放心</strong>只支持3个日期构建库——JSON、Jackson和GSON。对于XML — JAXB。</p><p id="8396" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> JSON </strong> (JavaScript对象符号)是一种轻量级的数据交换格式。对人类来说，读和写很容易。机器很容易解析生成。JSON是一种完全独立于语言的文本格式，但是它使用了C语言系列的程序员所熟悉的约定，包括C、C++、C#、Java、JavaScript、Perl、Python和许多其他语言。这些特性使JSON成为理想的数据交换语言。</p><p id="4210" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> JSON </strong>建立在两个结构上:</p><ul class=""><li id="6247" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">名称/值对的集合。在各种语言中，这被实现为对象、记录、结构、字典、哈希表、键列表或关联数组。</li><li id="919f" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">值的有序列表。在大多数语言中，这被实现为数组、向量、列表或序列。</li></ul><p id="a448" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Jackson </strong>是一款面向Java的高性能JSON处理器。它的开发者推崇该库的快速、正确、轻量级和人体工程学属性的结合。</p><p id="f947" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Jackson </strong> —数据绑定API用于使用属性访问器或使用注释将JSON与POJO(普通旧Java对象)相互转换。它有两种类型。</p><ul class=""><li id="9d4c" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">简单数据绑定——将JSON与Java映射、列表、字符串、数字、布尔值和空对象相互转换。</li><li id="5d8c" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">完全数据绑定—将JSON与任何JAVA类型相互转换。</li></ul><p id="678f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GSON是一个Java库，可以用来将Java对象转换成它们的JSON表示。它还可以用来将JSON字符串转换成等价的Java对象。Gson可以处理任意Java对象，包括您没有源代码的预先存在的对象。</p><p id="195d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几个开源项目可以将Java对象转换成JSON。然而，大多数都要求在类中放置Java注释；如果你不能访问源代码，你就做不到。大多数也不完全支持Java泛型的使用。Gson认为这两者都是非常重要的设计目标。</p><ul class=""><li id="2940" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">提供简单的toJson()和fromJson()方法，将Java对象转换成Json，反之亦然。</li><li id="bc38" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">允许预先存在的不可修改对象与JSON相互转换。</li><li id="31ea" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">对Java泛型的广泛支持。</li><li id="234e" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">允许对象的自定义表达。</li><li id="0191" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">支持任意复杂的对象(具有深度继承层次和广泛使用泛型类型)。</li></ul><p id="e49e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java Architecture for XML Binding(JAXB)提供了一种快速便捷的方式来绑定XML模式和Java表示，使得Java开发人员可以轻松地将XML数据和处理功能集成到Java应用程序中。作为这个过程的一部分，JAXB提供了将XML实例文档解组(读取)到Java内容树中，然后将Java内容树封送(写入)回XML实例文档的方法。JAXB还提供了一种从Java对象生成XML模式的方法。</p></div></div>    
</body>
</html>