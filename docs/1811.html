<html>
<head>
<title>The Case for Standardized Error Handling in Your Web Application’s APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web应用程序API中标准化错误处理的情况</h1>
<blockquote>原文：<a href="https://itnext.io/the-case-for-standardized-error-handling-in-your-web-application-6428ff60cc31?source=collection_archive---------4-----------------------#2019-02-03">https://itnext.io/the-case-for-standardized-error-handling-in-your-web-application-6428ff60cc31?source=collection_archive---------4-----------------------#2019-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="088f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">因为坏的错误消息——或者更糟，用户看不见的错误对任何人都没有好处</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/0d9d7815e2d1d44ff668a1a088b5262f.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*V5mz1BCmxxmsCDqvvG6mYg.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">是的，这是一个真正的错误信息。不，这不是我编的。</figcaption></figure><p id="9861" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi lv translated">作为程序员，广告错误信息是我们都会犯的一种罪。在服务器端，在客户端，它们在web开发中基本上无处不在。</p><p id="ff38" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我写的。你来写。我的整个团队写的。我们都同意它们是不好的——错误消息没有告诉我们或我们的用户真正的问题是什么，只有通过深入挖掘代码库和跟踪应用程序日志，我们才能在大多数情况下找到真正的罪魁祸首。</p><p id="e62e" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这不是一个新的或不寻常的现象。它是标准的，它使每个人的生活比他们需要的痛苦无限多。但是每当我们谈论如何改进错误消息传递——更详细、更精确、更清楚地说明实际发生了什么错误，这些改进错误消息传递的努力就被任何有权力指导开发团队的人贬低，我们转向更直接、最终用户受益的特性。</p><p id="b84c" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">恶性循环还在继续。用户在应用程序的客户端遇到一个错误，当错误无法通过关闭和重新打开系统来解决时(见下面的meme ),联系开发团队，开发人员查看大量日志并尝试在本地重现错误(有时这是一个不可能的壮举),团队要么重现错误并找出导致错误的原因以及如何修复错误，要么他们无法重现错误并关闭bug而不进行修复，直到它在将来再次出现。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi me"><img src="../Images/0d7b8bd4727701482eeee9cf684b4a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*CObvZ_vCr6-NHex0v_-lvA.jpeg"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">我无法抗拒使用这个迷因的机会——它如此准确，有时甚至令人恐惧。</figcaption></figure><p id="4794" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">你觉得这是一个最佳系统吗？我也没有。这就是我今天在这里给你写信的原因。</p><blockquote class="mf"><p id="1452" class="mg mh iq bd mi mj mk ml mm mn mo lu dk translated">我正在为API的错误处理标准化做准备，这样我们就可以停止浪费这么多时间追踪bug，回到我们都想做的编码上来——构建让人们生活更好的酷东西。</p></blockquote><h1 id="735a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk bi translated">标准化误差:需求和基本规则</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/24a539ee3caec556c01ec507ab883ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXAW1Oyx0uZc-CnfPQNIYA.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">一个标准的、完全无用的API错误消息示例。</figcaption></figure><p id="a326" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果您没有阅读上面的错误消息，重要的部分是:<code class="fe mx my mz na b">Failed to execute ImportKey action in set service<em class="nb">.</em> Deleting created cart item<em class="nb">.</em> : 500 Internal Server Error</code></p><p id="f77c" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">是的，这是来自我的团队的一个实际后端web应用程序的实际错误消息。不，这没有任何意义。我完全同意你的观点。</p><p id="01cf" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在web开发中，我们非常强调“快乐之路”。当用户使用我们的工具或应用程序时，我们希望并期望他们走的路——这是我们编码的路，我们优化的路，我们最关注的路。</p><p id="6bd4" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">“不愉快的路径”是指用户没有做正确的事情，没有点击正确的按钮，或者通常不知道如何以预期目的之外的方式使用系统。这是出错的地方，如果错误消息传递不好(如上)，我们作为用户和开发人员都很难找出到底哪里出错了。总的来说，不愉快的路径(以及它们产生的错误)很少考虑如何以有效的方式处理它们。</p><p id="427b" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这需要改变。以下是我以更好的错误处理的名义提出的建议，所有这些都基于<a class="ae nc" href="http://www.odata.org/documentation/" rel="noopener ugc nofollow" target="_blank"> OData v4 JSON规范</a>。</p><h2 id="c60a" class="nd jo iq bd jp ne nf dn jt ng nh dp jx li ni nj kb lm nk nl kf lq nm nn kj no bi translated">什么是OData？</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi np"><img src="../Images/0aea2d8efc8a8ea0952fe964e6255884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBwhOjf1c6tzcALe0ztRew.jpeg"/></div></div></figure><p id="ca8d" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在我给出我的建议之前，让我先介绍一下OData的背景。</p><blockquote class="nq nr ns"><p id="df72" class="kx ky nb kz b la lb lc ld le lf lg lh nt lj lk ll nu ln lo lp nv lr ls lt lu ij bi translated">OData代表开放数据协议，它是一个开放的<a class="ae nc" href="https://en.wikipedia.org/wiki/Protocol_(computing)" rel="noopener ugc nofollow" target="_blank">协议</a>，允许以简单和标准的方式创建和使用可查询和可互操作的<a class="ae nc" href="https://en.wikipedia.org/wiki/RESTful" rel="noopener ugc nofollow" target="_blank">RESTful</a><a class="ae nc" href="https://en.wikipedia.org/wiki/Application_programming_interface" rel="noopener ugc nofollow" target="_blank">API</a>。<a class="ae nc" href="https://en.wikipedia.org/wiki/Microsoft" rel="noopener ugc nofollow" target="_blank">微软</a>于2007年发起OData。—维基百科，OData</p></blockquote><p id="9af0" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">本质上，OData定义了一组构建和使用RESTful APIs(应用程序接口)的最佳实践。这些实践帮助开发人员在构建RESTful APIs时专注于业务逻辑，而不必担心定义请求和响应头、状态代码、HTTP方法、URL约定、媒体类型、有效负载格式、查询选项等内容的各种方法。</p><p id="d15d" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">它提出了一些标准，让web开发不那么杂乱无章，更容易预测，而不管编程语言、开发方法和团队如何。</p><p id="c169" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在，我们知道了OData及其存在的合法性和原因，让我们来看看处理错误的规则。</p><h2 id="45c3" class="nd jo iq bd jp ne nf dn jt ng nh dp jx li ni nj kb lm nk nl kf lq nm nn kj no bi translated">要遵循的8条错误规则</h2><p id="e10a" class="pw-post-body-paragraph kx ky iq kz b la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu ij bi translated">下面是我的团队和更广泛的公司正在为我们的应用程序制定的标准——它们足够通用，可以广泛应用于一般的API，但也足够具体，可以消除关于如何实现这些建议的问题。</p><p id="659a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">规则1:代码一，可重用的错误处理程序</strong></p><ul class=""><li id="bc28" class="ob oc iq kz b la lb le lf li od lm oe lq of lu og oh oi oj bi translated">对于不成功的情况，开发人员<strong class="kz ir">应该</strong>能够编写一段代码，跨不同的REST API方法一致地处理错误。</li><li id="5333" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">这允许构建简单可靠的基础设施，将异常作为独立于成功响应的流程来处理。</li><li id="402e" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">请记住，这个错误处理程序非常通用，不需要特定的OData构造。API<strong class="kz ir">应该</strong>使用这种格式，即使它们没有使用其他OData构造。</li></ul><p id="3fe9" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">规则JSON错误处理程序必须有一个</strong> <code class="fe mx my mz na b"><strong class="kz ir">Error</strong></code> <strong class="kz ir">对象</strong></p><ul class=""><li id="55d3" class="ob oc iq kz b la lb le lf li od lm oe lq of lu og oh oi oj bi translated">错误响应<strong class="kz ir">必须</strong>是单个JSON对象。这个对象<strong class="kz ir">必须</strong>有一个名为<code class="fe mx my mz na b">error</code>的名称/值对。值<strong class="kz ir">必须是一个JSON对象。</strong></li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi op"><img src="../Images/ae1b7ed3240481f1d4bdb70f3ec708fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBTafP3By81NPUIya5Ue-w.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated"><code class="fe mx my mz na b">error’</code>最基本的物体的例子。</figcaption></figure><p id="b2d5" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">规则三:</strong> <code class="fe mx my mz na b"><strong class="kz ir">error</strong></code> <strong class="kz ir">必须包含</strong> <code class="fe mx my mz na b"><strong class="kz ir">code</strong></code> <strong class="kz ir">和</strong> <code class="fe mx my mz na b"><strong class="kz ir">message</strong></code> <strong class="kz ir">，并可能包含其他属性以获取更多信息</strong></p><ul class=""><li id="97ba" class="ob oc iq kz b la lb le lf li od lm oe lq of lu og oh oi oj bi translated">这个对象<strong class="kz ir">必须</strong>包含名称为<code class="fe mx my mz na b">code</code>和<code class="fe mx my mz na b">message</code>的名称/值对，并且它<strong class="kz ir">可以</strong>包含名称为<code class="fe mx my mz na b">target</code>、<code class="fe mx my mz na b">details</code>和<code class="fe mx my mz na b">innererror</code>的名称/值对。</li><li id="44b0" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe mx my mz na b">code</code>名称/值对的值是独立于语言的字符串。它的值是一个服务定义的错误代码，即<strong class="kz ir">应该</strong>可读。</li><li id="c0a3" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">与响应中指定的HTTP错误代码相比，此代码是更具体的错误指示器。</li><li id="56a2" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">API方法<strong class="kz ir">应该</strong>有相对较少的<code class="fe mx my mz na b">code</code>可能值(大约20个),并且所有客户端<strong class="kz ir">必须</strong>能够处理所有这些值。</li><li id="2339" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">大多数服务需要更多更具体的错误代码，这并不是所有客户都感兴趣的。这些错误代码<strong class="kz ir">应该在如下所述的<code class="fe mx my mz na b">innererror</code>名称/值对中暴露</strong>。</li><li id="0d61" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">为<code class="fe mx my mz na b">code</code>引入一个对现有客户端可见的新值是一个突破性的变化，需要增加版本。API方法可以通过向<code class="fe mx my mz na b">innererror</code>添加新的错误代码来避免中断更改。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oq"><img src="../Images/096596a2a2df4760a6a25aa1825a2c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJ9G_4IIcirAmYsAGBOljg.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">包含多个属性的“错误”对象的示例。</figcaption></figure><p id="a594" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">规则4:</strong><code class="fe mx my mz na b"><strong class="kz ir">message</strong></code><strong class="kz ir">应该帮助人类调试错误</strong></p><ul class=""><li id="69f6" class="ob oc iq kz b la lb le lf li od lm oe lq of lu og oh oi oj bi translated"><code class="fe mx my mz na b">message</code>名称/值对<strong class="kz ir">的值必须</strong>是人类可读的错误表示。它旨在为开发人员提供帮助，不适合向最终用户公开。</li><li id="1c36" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">想要为最终用户<strong class="kz ir">公开合适消息的API方法必须</strong>通过注释或自定义属性来实现。</li><li id="72de" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">API方法<strong class="kz ir">不应该</strong>为最终用户本地化<code class="fe mx my mz na b">message</code>,因为这样做<strong class="kz ir">可能会</strong>使可能记录该值的应用程序开发人员无法读取该值，并使该值在互联网上更难搜索。</li></ul><p id="cd55" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">规则五:</strong> <code class="fe mx my mz na b"><strong class="kz ir">target</strong></code> <strong class="kz ir">是错误的属性名称</strong></p><ul class=""><li id="566f" class="ob oc iq kz b la lb le lf li od lm oe lq of lu og oh oi oj bi translated"><code class="fe mx my mz na b">target</code>名称/值对的值是特定错误的目标(例如，出错的属性的名称)。</li></ul><p id="ad87" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">规则6: </strong> <code class="fe mx my mz na b"><strong class="kz ir">details</strong></code> <strong class="kz ir">是由</strong><code class="fe mx my mz na b"><strong class="kz ir">code</strong></code><strong class="kz ir"/><code class="fe mx my mz na b"><strong class="kz ir">message</strong></code>组成的对象数组</p><ul class=""><li id="9ac6" class="ob oc iq kz b la lb le lf li od lm oe lq of lu og oh oi oj bi translated"><code class="fe mx my mz na b">details</code>名称/值对<strong class="kz ir">的值必须</strong>是JSON对象的数组，其中<strong class="kz ir">必须</strong>包含<code class="fe mx my mz na b">code</code>和<code class="fe mx my mz na b">message</code>的名称/值对，并且<strong class="kz ir">可以</strong>包含如上所述的<code class="fe mx my mz na b">target</code>的名称/值对。<code class="fe mx my mz na b">details</code>数组中的对象通常表示在请求过程中发生的不同的相关错误。参见下面的例子。</li></ul><p id="b047" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe mx my mz na b">details</code>对象的示例:</p><pre class="km kn ko kp gt or na os ot aw ou bi"><span id="047f" class="nd jo iq na b gy ov ow l ox oy">{   <br/>  "error": {     <br/>    "code": "BadArgument",     <br/>    "message": "Multiple errors in ContactInfo data",     <br/>    "target": "ContactInfo",     <br/>    "details": [       <br/>      {         <br/>        "code": "NullValue",         <br/>        "target": "PhoneNumber",         <br/>        "message": "Phone number must not be null"       <br/>      },       <br/>      {         <br/>        "code": "NullValue",         <br/>        "target": "LastName",         <br/>        "message": "Last name must not be null"       <br/>      },       <br/>      {         <br/>        "code": "MalformedValue",         <br/>        "target": "Address",         <br/>        "message": "Address is not valid"       <br/>       }     <br/>     ]   <br/>   } <br/> }</span></pre><p id="75b8" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在本例中，请求存在多个问题，每个错误都在<code class="fe mx my mz na b">details</code>中列出。</p><p id="7d53" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">规则7: </strong> <code class="fe mx my mz na b"><strong class="kz ir">innererror</strong></code> <strong class="kz ir">是具有服务定义内容的对象</strong></p><ul class=""><li id="52ac" class="ob oc iq kz b la lb le lf li od lm oe lq of lu og oh oi oj bi translated"><code class="fe mx my mz na b">innererror</code>名称/值对<strong class="kz ir">的值必须</strong>是一个对象。</li><li id="47ac" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">这个对象的内容是服务定义的。想要返回比根级代码<strong class="kz ir">更多特定错误的API方法必须</strong>通过包含<code class="fe mx my mz na b">code</code>和嵌套<code class="fe mx my mz na b">innererror</code>的名称/值对来实现。</li><li id="06bd" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">每个嵌套的<code class="fe mx my mz na b">innererror</code>对象比其父对象表现出更高的细节层次。</li><li id="5103" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">当评估错误时，客户端<strong class="kz ir">必须</strong>遍历所有嵌套的<code class="fe mx my mz na b">innererrors</code>并选择它们理解的最深的一个。这个方案允许服务在层次结构中的任何地方引入新的错误代码，而不破坏向后兼容性，只要旧的错误代码仍然出现。</li><li id="7c62" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">服务<strong class="kz ir">可以</strong>向不同的调用者返回不同级别的深度和细节。例如，在开发环境中，最深的<code class="fe mx my mz na b">innererror</code> <strong class="kz ir">可能</strong>包含有助于调试服务的内部信息。</li><li id="9fc4" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">为了防范信息泄露的潜在安全问题，服务<strong class="kz ir">应该</strong>注意不要无意中暴露太多的细节。</li><li id="f391" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">错误对象<strong class="kz ir">可能</strong>还包括自定义的服务器定义的名称/值对，这些名称/值对<strong class="kz ir">可能</strong>特定于代码。带有自定义服务器定义属性<strong class="kz ir">的错误类型应该在服务的元数据文档中声明</strong>。参见下面的例子。</li><li id="e5c8" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">错误响应<strong class="kz ir">可能</strong>在其任何JSON对象中包含注释。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oz"><img src="../Images/937561be464b54cae951e9ca124c3b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFTQElP1PAXVKGUy3bAlmw.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">“innererror”对象的示例。</figcaption></figure><p id="d7cd" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe mx my mz na b">innererror</code>对象的例子:</p><pre class="km kn ko kp gt or na os ot aw ou bi"><span id="e5e0" class="nd jo iq na b gy ov ow l ox oy">{   <br/>  "error": {     <br/>    "code": "BadArgument",     <br/>    "message": "Previous passwords may not be reused",     <br/>    "target": "password",     <br/>    "innererror": {       <br/>      "code": "PasswordError",       <br/>      "innererror": {         <br/>        "code": "PasswordDoesNotMeetPolicy",         <br/>        "minLength": "6",         <br/>        "maxLength": "64",         <br/>        "characterTypes":   ["lowerCase","upperCase","number","symbol"],         <br/>        "minDistinctCharacterTypes": "2",         <br/>        "innererror": {           <br/>          "code": "PasswordReuseNotAllowed"         <br/>        }       <br/>      }     <br/>    }   <br/>  } <br/>}</span></pre><p id="f2ec" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在上面的例子中，最基本的错误代码是<code class="fe mx my mz na b">BadArgument</code>，但是对于感兴趣的客户来说，在<code class="fe mx my mz na b">innererror</code>中有更具体的错误代码。</p><p id="9636" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe mx my mz na b">PasswordReuseNotAllowed</code>代码可能是由服务在稍后的日期添加的，之前只返回了<code class="fe mx my mz na b">PasswordDoesNotMeetPolicy</code>。</p><p id="e145" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当添加新的错误代码时，现有客户端不会中断，但是新客户端<strong class="kz ir">可能</strong>会利用它。<code class="fe mx my mz na b">PasswordDoesNotMeetPolicy</code>错误还包括额外的名称/值对，允许客户端确定服务器的配置，以编程方式验证用户的输入，或者在客户端自己的本地化消息传递中向用户呈现服务器的约束。</p><p id="b9f1" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">规则8:重试失败代码</strong></p><ul class=""><li id="0d54" class="ob oc iq kz b la lb le lf li od lm oe lq of lu og oh oi oj bi translated">建议对于任何可能重试的暂时错误，服务<strong class="kz ir">应该</strong>包括一个<code class="fe mx my mz na b">Retry-After</code> HTTP头，指示客户端<strong class="kz ir">在再次尝试操作之前</strong>应该等待的最小秒数。</li></ul><p id="50fe" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">标准化API错误处理策略的规则到此结束。这并不过分复杂，但它推荐了一些好的指导方针，当遇到不愉快的事情时，可以试着去遵守。</p><h1 id="e0b6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="2d1a" class="pw-post-body-paragraph kx ky iq kz b la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu ij bi translated">实现错误消息并不是最有趣的事情，但是尝试调试一个令人痛苦的模糊(并且经常误导)的服务器消息就更不有趣了。标准化的错误处理是必须的——特别是如果你是大型开发团队的一员，或者为外部客户提供API服务。</p><p id="9cc0" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">像OData这样的组织已经帮助建立了围绕编写和使用API的最佳实践，这有助于开发人员专注于他们应用程序的业务逻辑。通过遵循这些最佳实践，我们已经建立了一套易于理解且可重复的错误处理规则，以简化处理不可避免的不愉快路径的整个过程。</p><p id="149e" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">过几周再来看看，我会写一些关于Reactjs或者其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="c003" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">感谢您的阅读，我希望这能帮助您更有效地处理标准化格式的错误，以便您能更好地捕捉和修复错误。非常感谢鼓掌和分享！</p><p id="b968" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他一些博客:</p><ul class=""><li id="0216" class="ob oc iq kz b la lb le lf li od lm oe lq of lu og oh oi oj bi translated"><a class="ae nc" rel="noopener ugc nofollow" target="_blank" href="/the-absolute-easiest-way-to-debug-node-js-with-vscode-2e02ef5b1bad">调试Node.js最简单的方法——用VS代码</a></li><li id="aae6" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated"><a class="ae nc" rel="noopener ugc nofollow" target="_blank" href="/keep-code-consistent-across-developers-the-easy-way-with-prettier-eslint-60bb7e91b76c">用最简单的方法保持开发人员之间的代码一致——用更漂亮的&amp; ESLint </a></li><li id="ff53" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated"><a class="ae nc" rel="noopener ugc nofollow" target="_blank" href="/password-reset-emails-in-your-react-app-made-easy-with-nodemailer-bb27968310d7">使用Nodemailer简化React应用程序中的密码重置电子邮件</a></li></ul><p id="fe77" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="kz ir">参考资料和更多资源:</strong></p><ul class=""><li id="b79d" class="ob oc iq kz b la lb le lf li od lm oe lq of lu og oh oi oj bi translated">OData V4 JSON规范:<a class="ae nc" href="https://www.odata.org/documentation/" rel="noopener ugc nofollow" target="_blank">https://www.odata.org/documentation/</a></li><li id="d78d" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">开放数据协议:<a class="ae nc" href="https://en.wikipedia.org/wiki/Open_Data_Protocol" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Open_Data_Protocol</a></li><li id="7bc1" class="ob oc iq kz b la ok le ol li om lm on lq oo lu og oh oi oj bi translated">https://www.odata.org/</li></ul></div></div>    
</body>
</html>