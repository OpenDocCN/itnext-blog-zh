<html>
<head>
<title>Creating Multi-tenant Moodle service on Kubernetes using Operator Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Operator模式在Kubernetes上创建多租户Moodle服务</h1>
<blockquote>原文：<a href="https://itnext.io/creating-multi-tenant-moodle-service-on-kubernetes-using-operator-pattern-a4fd418d47ad?source=collection_archive---------1-----------------------#2018-11-29">https://itnext.io/creating-multi-tenant-moodle-service-on-kubernetes-using-operator-pattern-a4fd418d47ad?source=collection_archive---------1-----------------------#2018-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4713" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们目前正在支持<a class="ae kl" href="https://wisdmlabs.com/" rel="noopener ugc nofollow" target="_blank"> WisdmLabs </a>在Kubernetes上建立一个基于Moodle的电子学习平台。最近，我们完成了在Kubernetes集群上创建多租户Moodle环境的早期原型。在这里，我们提出了我们所面临的挑战和我们在实施过程中所做的选择。</p><p id="600b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://moodle.org/" rel="noopener ugc nofollow" target="_blank"> Moodle </a>是一个用PHP实现的开源电子学习平台。它是通过部署在web服务器(Nginx，Apache)上来安装的。它使用关系数据库来存储其运行时状态。它的基本功能可以通过安装各种插件来扩展。这些都可以在<a class="ae kl" href="https://moodle.org/plugins/" rel="noopener ugc nofollow" target="_blank"> Moodle插件库</a>中找到。每个插件本质上都是一个zip文件，安装它相当于将插件的解压代码添加到Moodle安装目录下的一个合适的子目录中。</p><p id="725f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是运行在Kubernetes上的Moodle环境的基本要求，以满足计划中的托管电子学习平台的目标。</p><ul class=""><li id="6e7d" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">多租户:一个Kubernetes集群应该能够托管多个Moodle实例。这个需求源于这样一个事实，为每个Moodle实例创建一个新的集群是非常昂贵的(无论是价格还是时间)。此外，使用Kubernetes名称空间，可以在单个集群中实现多租户。</li><li id="b06a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">插件安装:在Moodle实例的整个生命周期中，应该可以很容易地安装插件。例如，在创建Moodle实例时，你可能想安装一些插件。然后，在已经运行的Moodle实例上，很少其他插件需要安装。此外，当Moodle版本需要更新时，应该可以在版本升级后重新安装之前安装在该实例上的所有插件。</li></ul><p id="5fb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">主要挑战</strong></p><ul class=""><li id="0b5f" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">多租户:</strong></li></ul><p id="be28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现多租户Moodle设置有两个主要挑战。首先，每个Moodle实例需要在一个单独的端口上可用，以确保不同实例之间的流量得到适当的隔离。这意味着，每个Moodle实例的web服务器配置文件(定义监听端口)需要用所选的端口号进行更新。此外，可能需要重新启动web服务器进程，以使配置更改生效。第二，为了让Moodle实例可以公开访问，它的所有资源(表单动作、链接、URL等等。)需要被创建并嵌入一个公共可访问的端点。Moodle代码定义了一个可以为此设置的配置参数(wwwroot)，但是这个参数需要在触发Moodle安装之前设置<em class="la">。</em></p><ul class=""><li id="7adf" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">插件安装:</strong></li></ul><p id="9583" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">插件安装的主要挑战是，每个插件在Moodle安装目录中都有一个唯一的子目录，它需要安装在这个目录中。当以非容器形式运行Moodle时，这个过程很简单——你下载所需插件的zip文件，并将其展开到Moodle安装目录下的适当子目录中。对于Kubernetes上的容器化设置，这变得很棘手，因为需要从外部访问正在运行的容器中的插件安装子目录。</p><p id="e3a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，作为创建每个新Moodle实例的一部分，我们需要执行以下操作:</p><p id="a45b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">a)分配端口，b)更新实例的web服务器配置文件以包括端口号，c)启动web服务器，d)为实例创建可公开访问的端点，e)设置wwwroot变量，f)触发安装，g)一旦安装完成，安装任何插件。此外，支持在已经运行的Moodle实例上安装插件。</p><p id="ee72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们意识到<a class="ae kl" href="https://coreos.com/blog/introducing-operators.html" rel="noopener ugc nofollow" target="_blank"> Kubernetes操作符模式</a>最适合这里，因为上述所有步骤本质上都是工作流动作，可以作为操作符中的Moodle实例状态协调逻辑有效地实现。一旦有了这样的操作符，管理员就可以使用简单的kubectl命令来创建Moodle实例并管理其上的插件。这也将使得上层UI层只使用一个接口与Kubernetes进行交互变得非常容易。</p><p id="e7c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> KubePlus Moodle操作员:</strong></p><p id="4c14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是这个正在进行中的Moodle操作器的链接—<a class="ae kl" href="https://github.com/cloud-ark/kubeplus-operators/tree/master/moodle" rel="noopener ugc nofollow" target="_blank">kube plus Moodle操作器</a>。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/4ccea8a874c46dfabb37c23f14c5b794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EL54RMAik737Irb9"/></div></div></figure><p id="0027" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操作员由Moodle自定义资源和相关的自定义控制器组成。每个Moodle实例都需要一个Mysql实例。目前，Mysql实例是使用标准的Kubernetes yaml定义作为单独的部署创建的。该计划是在未来使用Mysql运营商。</p><p id="6d29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Moodle操作符内部发生了什么？</p><ul class=""><li id="be00" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">Moodle定制资源的<a class="ae kl" href="https://github.com/cloud-ark/kubeplus-operators/blob/master/moodle/artifacts/moodle1.yaml" rel="noopener ugc nofollow" target="_blank">规范定义了一个字段来包含要安装在实例上的插件列表。对于每个支持的插件，运营商知道插件需要安装在Moodle安装目录上的确切位置。</a></li><li id="4700" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">当收到“kubectl create/apply”命令时，操作员首先创建Moodle实例，然后安装插件，或者如果实例已经存在，则只安装插件，从而协调Moodle实例的状态。</li><li id="c994" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">为了创建Moodle实例，操作员使用我们的自定义Docker映像，该映像由Nginx和Moodle组成。该图中Nginx的/etc/Nginx/sites-available/default . conf文件被定义为监听一个端口，该端口的值由操作员作为环境变量注入。对于每个Moodle实例创建，操作者分配一个端口，创建服务(类型NodePort)和入口对象，使用入口路径构造wwwroot，并在启动容器时注入所选端口号和wwwroot作为环境变量。为了使对Nginx的配置更改生效，它在Moodle实例的部署对象中的PostStart容器生命周期挂钩中定义了Nginx reload动作。</li></ul><p id="5861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用我们的<a class="ae kl" href="https://github.com/cloud-ark/kubeplus" rel="noopener ugc nofollow" target="_blank"> KubePlus Plaform toolkit </a>来尝试Moodle操作器。在Minikube上部署Moodle实例的步骤可以在<a class="ae kl" href="https://github.com/cloud-ark/kubeplus/blob/master/examples/moodle/steps.txt" rel="noopener ugc nofollow" target="_blank">这里</a>找到。如果您遇到任何问题，请在这里报告它们<a class="ae kl" href="https://github.com/cloud-ark/kubeplus/issues" rel="noopener ugc nofollow" target="_blank">。我们的Moodle操作系统仍在研发中。我们还希望为运营商增加Moodle实例备份/恢复功能。</a></p><p id="12a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现计划中的托管电子学习平台的最终目标，Moodle只是必需的运营商之一。它没有按照要求存在于社区中，因此我们最终自己开发了它。然而，我们将使用其他一些社区构建的运营商来构建这个端到端的应用平台。如前所述，我们将包括一个Mysql操作符。我们还想为每个Moodle实例支持https端点。为此，我们正在考虑使用Traefik或T2的证书管理器。</p><p id="97d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">总结:</strong></p><p id="2af8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们概述了在Kubernetes上开发多租户Moodle服务所面临的挑战。构建Moodle操作符使我们能够为在集群上部署和管理多个Moodle实例提供显著的易用性。</p><p id="9699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://cloudark.io/" rel="noopener ugc nofollow" target="_blank"> www.cloudark.io </a></p></div></div>    
</body>
</html>