<html>
<head>
<title>Under the hood of Kubebuilder framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubebuilder框架下</h1>
<blockquote>原文：<a href="https://itnext.io/under-the-hood-of-kubebuilder-framework-ff6b38c10796?source=collection_archive---------4-----------------------#2018-05-16">https://itnext.io/under-the-hood-of-kubebuilder-framework-ff6b38c10796?source=collection_archive---------4-----------------------#2018-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="897c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近在Kubernetes subreddit 上有一个关于应该用什么来创建定制控制器/操作器的问题。我们应该使用Kubebuilder，还是运营商SDK，还是更喜欢从头开始实现？我回答了这个问题，但想提供更详细的分析。</p><p id="31c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本帖中，我们将看到<a class="ae kl" href="https://github.com/kubernetes-sigs/kubebuilder" rel="noopener ugc nofollow" target="_blank"> Kubebuilder框架</a>的内幕，并将其与<a class="ae kl" href="https://medium.com/@cloudark/kubernetes-custom-controllers-b6c7d0668fdf" rel="noopener">从头开始的方法</a>进行比较。在随后的文章中，我们将对运营商SDK做类似的练习。</p><p id="0d5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubebuilder是一个用于创建Kubernetes定制控制器的框架，这些控制器与定制资源定义(CRD)一起工作。它目前位于“kubernetes-sigs”Github组织中，是“k8s-sig-api-machinery”特殊兴趣小组的一部分。</p><p id="0de5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们深入Kubebuilder的细节之前，这里有一些你应该熟悉的Kubernetes术语:</p><ol class=""><li id="afec" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">CRD:自定义资源定义。</li><li id="2711" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">object:Kubernetes基本类型/种类的实例或CRD的实例。</li><li id="8b13" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">对象关键字:代表对象的唯一字符串。</li><li id="69f3" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Informer:定期查询Kubernetes API服务器以监控特定类型/种类的对象变化的机制。它检索已更改的对象，并将它们存储在本地索引和队列中。这里的“本地”是指自定义控制器运行的位置。</li><li id="7e75" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">队列:在对象被处理之前存储它们的数据结构。</li><li id="c2b2" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Lister:从本地索引中查询对象的机制。</li><li id="f03e" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Client/ClientSet:直接从Kubernetes API服务器查询对象的机制。使用列表器从本地索引中查询对象比使用客户机查询Kubernetes API服务器更可取，因为它减少了API服务器上的负载。</li></ol><p id="4c19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是kubebuilder及其与自定义控制器的交互点的图形表示:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/09154a67488df8816a120216453164cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3hSTI-gSWvBxfyNkUN34Q.jpeg"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">kubebuilder和自定义控制器交互</figcaption></figure><p id="0e66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将图片分为两部分:kubebuilder(顶部)和自定义控制器(底部)。我们将首先从解释kubebuilder组件开始。</p><p id="02fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Kubebuilder组件:</strong></p><p id="2a3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1)通用控制器:kubebuilder提供了一个通用控制器，作为我们定制控制器的包装器。它基于采样控制器的<a class="ae kl" href="https://github.com/kubernetes-sigs/kubebuilder/blob/master/pkg/controller/controller.go#L52" rel="noopener ugc nofollow" target="_blank">。它定义了队列，在该队列中，对象由通知者使用事件处理程序(未示出)来传递。队列本身不向我们的定制控制器公开。通用控制器还定义了一个变量，该变量将保存对我们的自定义控制器将实现的协调函数的引用。通用控制器在调用我们的控制器中的协调函数时，将存储在队列中的对象的对象键作为参数传递。</a></p><p id="c8c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)控制器管理器:控制器管理器管理定制控制器。它维护两种数据结构:控制器引用列表和对象及其通知者的映射。它提供了以下函数来填充这两个数据结构:AddInformerProvider、AddController、RunInformersAndControllers。</p><p id="b92e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3)注入器:注入器定义了两个数据结构:一个用于存储需要注册的CRD的列表，一个用于存储启动通知器和控制器时应该调用的函数的列表。CRD列表将由我们的定制控制器将监控其对象的CRD填充。CRDs的注册在设置阶段完成。功能列表也在设置阶段填充。</p><p id="f86f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">定制控制器组件:</strong></p><p id="e4cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1) controller.go:这是我们实现控制器代码的地方。kubebuilder将生成一个基本控制器，其中包含我们控制器的类型定义。</p><p id="ddce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)自定义控制器:这是代表我们的控制器的类型。它是由kubebuilder生成的。它为CRDs的列表器和客户端定义了变量。还生成了存根协调函数。我们应该编写协调逻辑作为这个函数的一部分。它将被通用控制器调用，并被提供一个对象键。此外，还生成了一个名为“ProvideController”的函数。它将对协调函数的引用从我们的控制器添加到通用控制器，并将通用控制器实例作为返回值返回。</p><p id="eb22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3) zz_generated.kubebuilder.go:这个文件包含在控制器管理器和注入器中设置各种数据结构的步骤。它是由kubebuilder生成的。</p><p id="3b12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4) main.go:该文件包含启动通知程序和控制器的步骤。它也是由kubebuilder生成的。</p><p id="728e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">与从头开始方法的比较:</strong></p><p id="afb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是Kubebuilder方法与<a class="ae kl" href="https://medium.com/@cloudark/kubernetes-custom-controllers-b6c7d0668fdf" rel="noopener">从头开始</a>方法的一些比较。</p><p id="6a8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lq">相似之处:</em></p><ol class=""><li id="8ed4" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">这两种方法都生成基本的go文件(types.go、register.go等)。).在Kubebuilder方法中，kubebuilder cli采用命令行标志来控制文件和目录名及其位置。在从头开始的方法中，您必须使用“hack/update-codegen.sh”脚本来生成这些文件。</li><li id="2184" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">这两种方法都要求你理解Kubernetes的Lister和Client的概念(如上所述)。</li></ol><p id="c503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lq">使用Kubebuilder优于从头开始的方法:</em></p><ol class=""><li id="ff14" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">基本目录结构由kubebuilder生成。对于从头开始的方法，您必须为“客户端”和“API”创建带有占位符子目录的“pkg”目录。hack/update-codegen.sh脚本将在这些目录中生成文件。</li><li id="75a6" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">编写控制器时，不需要管理每个控制器队列。这是由kubebuilder提供的通用控制器抽象出来的。使用<a class="ae kl" href="https://medium.com/@cloudark/kubernetes-custom-controllers-b6c7d0668fdf" rel="noopener">从零开始的方法</a>，您必须创建工作队列并创建通知器和事件处理函数。然后，您必须将它们连接起来，以便从Kubernetes API服务器接收更改后的对象。此外，如果您想使用本地索引，您还必须创建一个索引器。使用kubebuilder时，您不必担心这些问题。</li><li id="4ade" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">kubebuilder为你的控制器定义了一个类型。它为您的CRD维护列表和客户端参考。这个类型定义提供了一个单一的位置，当您需要在代码中使用它们时，可以在这个位置查找列表器或客户端。在从头开始的方法中，您必须自己管理这样的引用。</li></ol><p id="1a86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lq">使用Kubebuilder超过从头开始方法的顾虑:</em></p><p id="b006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与从头开始的方法相比，使用Kubebuilder的主要问题是kubebuilder引入的新抽象——generic controller、ControllerManager、Injector、InjectorArgs、Installer、Install_strategy等。此外，还有ProvideController、AddInformerProvider、RunInformersAndControllers等新功能。您需要很好地掌握这些抽象和功能，以构建kubebuilder工作的心理模型，以及它如何与您的控制器交互。</p><p id="e485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论:</strong></p><p id="10ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然Kubebuilder肯定是有用的，但它提供足够抽象的方法是否对复杂场景中的开发人员有用，或者他们更喜欢遵循从头开始的方法从基本原则开始工作，还有待观察。</p><p id="b773" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://cloudark.io/" rel="noopener ugc nofollow" target="_blank"> www.cloudark.io </a></p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="ba98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:如果你喜欢这个帖子，你可能还想看看运营商SDK <!-- -->的封面下的<!-- -->。</p></div></div>    
</body>
</html>