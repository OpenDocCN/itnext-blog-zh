<html>
<head>
<title>Building APIs with Phoenix Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Phoenix框架构建API</h1>
<blockquote>原文：<a href="https://itnext.io/building-apis-with-phoenix-framework-a7e280b7fa4a?source=collection_archive---------0-----------------------#2021-03-12">https://itnext.io/building-apis-with-phoenix-framework-a7e280b7fa4a?source=collection_archive---------0-----------------------#2021-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fd2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多早期的Elixir开发者都有这种感觉，以避免在项目中采用Phoenix时弄脏自己的手。不出所料，不仅接受Phoenix而且支持它的开发者数量正在快速上升。</p><p id="e103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这不是白做的。Phoenix是灵活的、健壮的，并且允许您以不同的方式自由决定如何构建API。</p><h1 id="cfd9" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">但是，为什么是凤凰城？</h1><p id="1e68" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在众多原因中，让Phoenix在web框架之战中保持领先的主要原因包括:</p><ul class=""><li id="740e" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">它是在Elixir的理念下诞生的:MVC有界、简单明了、每上下文单个请求等。</li><li id="eac8" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">它非常完整:它附带了默认的ORM、路由器机制、测试工具和一个很棒的仪表盘来显示你的应用程序的健康状况(稍后会详细介绍)。</li><li id="2590" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">在撰写本文时，它已经被很好地记录下来，并且有一个强大的社区在GitHub上统计了15.9k颗星星。</li></ul><p id="43d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，每当您得到一个API调用的错误时，Phoenix希望确保您会收到尽可能多的信息，以了解问题的根源、代码行、堆栈跟踪、调用堆栈以及修复错误的可用选项。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/02ca1f2f34a675dd5144a250eb2dc473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kD686Oq9XBX13tYI"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><em class="mt">错误跟踪与凤凰号。</em></figcaption></figure><p id="b831" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，尽管Phoenix主要是为开发单片应用程序而设计的，但它确实非常适合微服务。</p><p id="de8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论你的应用程序大小如何，你都可以轻松地创建它，公开路线，并将其放在基于集群的云服务下，Phoenix将负责了解新的情况。</p><h1 id="8f1d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">我们要在这里建什么？</h1><p id="db0d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">因此，我们已经看到，Phoenix是在Elixir中开发API的绝佳选择。但是怎么做呢？</p><p id="ffd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在这里探索生成web API来管理啤酒目录的步骤。</p><p id="28a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目标是通过搭建Phoenix API结构，让您了解它的方方面面。这将展示Phoenix(及其工具)有多强大。</p><p id="71fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程结束时，这应该是GET /beers端点结果:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/1dc34daf6d81aafef6fb8a01de29011e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WpXmqgWDegUkb4R1"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><em class="mt">从凤凰城API获取啤酒列表。</em></figcaption></figure><h1 id="3da0" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">设置</h1><p id="cf71" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">首先，让我们分解一下创建这个API示例需要什么。我们需要在你的机器上安装灵药。</p><p id="0172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遵循<a class="ae mc" href="https://elixir-lang.org/install.html" rel="noopener ugc nofollow" target="_blank">官方指导方针</a>来完成任务。它就像运行下面的命令一样简单:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="af67" class="mz km iq mv b gy na nb l nc nd">brew install elixir</span></pre><p id="2992" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于本教程，我们将使用版本“<em class="ne"> Elixir 1.11.2(用Erlang/OTP 23编译)</em>”。如果你没有任何关于仙丹的知识，我建议你先去阅读官方的<a class="ae mc" href="https://elixir-lang.org/learning.html" rel="noopener ugc nofollow" target="_blank">仙丹学习</a>路径。</p><p id="ee65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们将使用MySQL作为应用程序数据库。确保安装了<a class="ae mc" href="https://dev.mysql.com/downloads/mysql/" rel="noopener ugc nofollow" target="_blank"> MySQL社区服务器</a>和一个GUI工具来管理它(我特别喜欢<a class="ae mc" href="https://dev.mysql.com/downloads/workbench/" rel="noopener ugc nofollow" target="_blank"> MySQL工作台</a>)。</p><p id="29d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Phoenix使用PostgreSQL作为任何新应用程序的默认数据库。如果你觉得更舒服的话，可以随意使用。然而，为了简单起见，我们将坚持使用MySQL。</p><p id="2cba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还需要一个IDE。<a class="ae mc" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS Code </a>是Elixir开发的最爱之一，它提供了一个名为<a class="ae mc" href="https://marketplace.visualstudio.com/items?itemName=mjmcloug.vscode-elixir" rel="noopener ugc nofollow" target="_blank"> vscode-elixir </a>的强大扩展来帮助您完成代码补全、语法着色等。</p><h1 id="d681" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">创建项目</h1><p id="2a55" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现在我们已经安装了所有的东西，让我们创建我们的Phoenix web项目。在您的计算机上选择一个文件夹，并运行以下命令:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="7e74" class="mz km iq mv b gy na nb l nc nd">mix archive.install hex phx_new</span></pre><p id="a470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦安装了Elixir，mix命令就会自动可用。mix是一个构建工具，帮助创建、管理依赖项、编译和测试Elixir项目。</p><p id="3edc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的命令将把Phoenix应用程序项目安装到当前目录。然后，运行以下命令来创建Phoenix项目:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="f8b1" class="mz km iq mv b gy na nb l nc nd">mix phx.new beer_catalog</span></pre><p id="aa2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就叫啤酒_目录吧。命令完成后，您会注意到项目中有一个名为<em class="ne"> lib/beer_catalog </em>的新文件夹。这是应用程序的主文件夹。</p><p id="290c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前一个命令的末尾，会提示您是否希望预先获取并安装所有的依赖项。选择yes，将执行以下命令:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="8ee9" class="mz km iq mv b gy na nb l nc nd">mix deps.get</span></pre><h1 id="d159" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">数据库配置</h1><p id="6d43" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现在，我们需要将默认的PostgreSQL数据库改为MySQL。为此，我们需要首先将位于根目录的<em class="ne"> mix.exs </em>文件中的Postgres依赖项更改为:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="4f5e" class="mz km iq mv b gy na nb l nc nd"># Specifies your project dependencies.<br/>#<br/># Type `mix help deps` for examples and options.<br/>defp deps do<br/>  [<br/>    ...</span><span id="d5be" class="mz km iq mv b gy nf nb l nc nd">{:myxql, "&gt;= 0.0.0"},</span><span id="8663" class="mz km iq mv b gy nf nb l nc nd">...<br/>  ]<br/>end</span></pre><p id="c7a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Elixir使用<a class="ae mc" href="https://hexdocs.pm/ecto/Ecto.html" rel="noopener ugc nofollow" target="_blank"> Ecto </a>项目作为其项目的默认ORM。它为您提供了一系列存储库包装器、变更集、模式生成，以及其他特性来简化处理数据库的过程。</p><p id="c951" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，Ecto希望接收它将用于每个特定数据库的适配器。换句话说，驱动程序Elixir需要理解如何与数据库通信。</p><p id="cd7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，对于MySQL，我们使用<a class="ae mc" href="https://github.com/elixir-ecto/myxql" rel="noopener ugc nofollow" target="_blank"> MyXQL </a>。</p><p id="093b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成设置后，我们需要运行以下命令，明确要求Elixir在物理MySQL服务器中创建所提供的数据库:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="9d0c" class="mz km iq mv b gy na nb l nc nd">mix ecto.create</span></pre><p id="803a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该命令还将验证连接URL和凭据。如果有任何问题，Pheonix会将日志错误打印到控制台。</p><p id="298e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当命令完成时，您可能会看到生成的数据库显示在Workbench中:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/e57a6914f8187e43fe76063eaf925c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/0*BLWWBql0jKI88VSA"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><em class="mt">新创建的啤酒_目录_开发数据库。</em></figcaption></figure><p id="1d8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Ecto还使用后缀来了解一次运行的环境:</p><ul class=""><li id="6f57" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated"><em class="ne"> -dev </em>用于本地开发执行</li><li id="75be" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated"><em class="ne">-测试</em>用于测试执行</li><li id="a784" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">没有后缀是当你处理生产。</li></ul><p id="2776" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要执行这个项目，你只需要运行<code class="fe nh ni nj mv b">mix phx.server</code>命令。菲尼克斯会考虑所有不最新的东西。因此，对于它要求更新的任何依赖项，比如rebar3，一定要点击“Yes”。</p><p id="67d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您在浏览器中点击<a class="ae mc" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000/ </a>时，您可能会看到以下屏幕:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nk"><img src="../Images/852da5c840a053560f205f1c857e9b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WvDhsR-NOoTHnwG0"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><em class="mt">凤凰欢迎页面。</em></figcaption></figure><h1 id="c823" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">啤酒图式</h1><p id="e2be" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">让我们继续进行模式设置。在我们的例子中，只需要一个:啤酒模式。在Phoenix中可以自动生成一个简单的模式，如下所示:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="a4ae" class="mz km iq mv b gy na nb l nc nd">mix phx.gen.schema Beer beers brand:string style:string origin:string quantity:integer</span></pre><p id="fe22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该命令将考虑每一个后续属性(及其类型)来生成模型和迁移脚本，并进一步将其保存到数据库中。</p><p id="32aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，在设计API的模型时，要确保一切都尽可能的整洁有序。</p><p id="ff73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Phoenix提供了<a class="ae mc" href="https://hexdocs.pm/phoenix/contexts.html" rel="noopener ugc nofollow" target="_blank">上下文</a>的概念，它定义了一组功能相关的模块。</p><p id="4a15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果您考虑一个名为User的实体，它通常不是单独表示的。一个用户属于一个或多个帐户。考虑到这一点，Phoenix要求您停下来思考一下您的模型，而不是直接创建用户模式。</p><p id="63ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比起单一的<code class="fe nh ni nj mv b">User</code>接口，你最好使用<code class="fe nh ni nj mv b">Account &gt; User</code>分组接口。对吗？</p><p id="7e7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的啤酒API，让我们考虑啤酒属于一个目录。也就是说，我们要将该命令更改为以下内容:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="5765" class="mz km iq mv b gy na nb l nc nd">mix phx.gen.context Catalog Beer beers brand:string style:string origin:string quantity:integer</span></pre><p id="466f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，一个全新的文件世界将以一种有组织的方式自动创建，例如:</p><p id="ac1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">-lib/beer _ catalog/catalog/beer . ex</strong>:这是beer模式定义，这是自动生成的代码:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="3976" class="mz km iq mv b gy na nb l nc nd">defmodule BeerCatalog.Catalog.Beer do<br/>  use Ecto.Schema<br/>  import Ecto.Changeset</span><span id="49b6" class="mz km iq mv b gy nf nb l nc nd">schema "beers" do<br/>    field :brand, :string<br/>    field :origin, :string<br/>    field :quantity, :integer<br/>    field :style, :string</span><span id="f171" class="mz km iq mv b gy nf nb l nc nd">timestamps()<br/>  end</span><span id="3c25" class="mz km iq mv b gy nf nb l nc nd"><a class="ae mc" href="http://twitter.com/doc" rel="noopener ugc nofollow" target="_blank">@doc</a> false<br/>  def changeset(beer, attrs) do<br/>    beer<br/>    |&gt; cast(attrs, [:brand, :style, :origin, :quantity])<br/>    |&gt; validate_required([:brand, :style, :origin, :quantity])<br/>  end<br/>end</span></pre><p id="ae6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您能发现代码清单顶部的调用链吗？等等，还有更好的…</p><p id="017e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">-lib/beer _ catalog/catalog . ex</strong><em class="ne">:</em>如果你打开这个生成的文件，你可能会看到一堆预先生成的CRUD操作处理<code class="fe nh ni nj mv b">Beer</code>域。换句话说，您的基本CRUD已经完成了！</p><p id="c4b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以随心所欲地定制它们，但是已经进行到一半了。很酷，不是吗？</p><p id="0297" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该命令还在<em class="ne">priv/repo/migrations/XXX _ create _ beers . exs</em>文件下生成了数据库迁移文件，以及一些针对模式和目录查询的CRUD测试。</p><h1 id="4c5c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">迁移和播种数据库</h1><p id="bbb5" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在运行CRUD API之前，我们需要将更改迁移到物理数据库。为此，运行以下命令:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="6310" class="mz km iq mv b gy na nb l nc nd">mix ecto.migrate</span></pre><p id="57d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，返回工作台并检查新创建的表:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nl"><img src="../Images/03ae5ca0677b6cd94bec9caa016cf135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kjC5yMTdY85zWtQN"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><em class="mt">迁移过来的啤酒桌。</em></figcaption></figure><p id="b087" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Ecto为每个表包含两列，以便在插入或更新新数据时保持跟踪。它还通过<code class="fe nh ni nj mv b">schema_migrations</code>表跟踪迁移的历史。</p><p id="a9ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想用数据库中的一些数据启动API，我们可以通过<em class="ne">播种</em>特性来实现。它允许您在启动应用程序之前插入数据。</p><p id="2cf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，转到<em class="ne"> priv/repo/seeds.exs </em>文件并添加以下内容:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="102f" class="mz km iq mv b gy na nb l nc nd">BeerCatalog.Catalog.Repo.insert!(%BeerCatalog.Catalog.Beer{<br/>    brand: "Milwaukee's Best Light",<br/>    style: "American-Style Light Lager",<br/>    origin: "USA",<br/>    quantity: 1200<br/>})</span><span id="d0b5" class="mz km iq mv b gy nf nb l nc nd">BeerCatalog.Catalog.Repo.insert!(%BeerCatalog.Catalog.Beer{<br/>    brand: "Dos Equis",<br/>    style: "Lager Especial",<br/>    origin: "Mexico",<br/>    quantity: 430<br/>})</span><span id="e026" class="mz km iq mv b gy nf nb l nc nd">BeerCatalog.Catalog.Repo.insert!(%BeerCatalog.Catalog.Beer{<br/>    brand: "Maibock",<br/>    style: "Bavarian lager",<br/>    origin: "Germany",<br/>    quantity: 4000<br/>})</span></pre><p id="aaf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，运行以下命令来执行播种:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="db54" class="mz km iq mv b gy na nb l nc nd">mix run priv/repo/seeds.exs</span></pre><p id="9932" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令完成后，您可以直接在表中看到数据:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nm"><img src="../Images/d66b4ec95da07ad37dcce66f2d4eda86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6ZBcJ3toC9H9lH49"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><em class="mt">啤酒桌上的系统初始数据。</em></figcaption></figure><h1 id="56d7" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">创建API控制器</h1><p id="2f09" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现在，我们需要生成控制器结构来连接数据库和REST端点。</p><p id="d6f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，只需运行以下命令:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="87fc" class="mz km iq mv b gy na nb l nc nd">mix phx.gen.json Catalog Beer beers brand:string style:string origin:string quantity:integer — no-context — no-schema</span></pre><p id="1bbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该命令生成基于JSON的REST资源，通过专用端点处理CRUD操作。这些标志是必要的，因为我们之前已经创建了模式和上下文。</p><p id="7c84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在<em class="ne">lib/beer _ catalog _ web/controllers/beer _ controller . ex</em>文件下找到生成的文件。继续前进并浏览它。</p><p id="6165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要将新创建的资源映射到默认的路由系统，该系统仍然不能识别它。</p><p id="006a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开<em class="ne">lib/beer _ catalog _ web/router . ex</em>文件，在<code class="fe nh ni nj mv b">:api</code>范围设置下，添加下面一行:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="1d66" class="mz km iq mv b gy na nb l nc nd">resources “/beers”, BeerController, except: [:new, :edit]</span></pre><p id="0b0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将所有HTTP CRUD操作映射到各自的函数。就是这样！我们都准备好了！</p><h1 id="b137" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">测试</h1><p id="fed8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">正如我们所说，一些集成测试已经由Phoenix创建。要运行所有测试并验证您的整个API配置是否正常，请执行以下命令:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="37a4" class="mz km iq mv b gy na nb l nc nd">mix test</span></pre><p id="cfb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切顺利，继续前进，通过<a class="ae mc" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>测试你的端点。确保检查这些表，以查看操作是否被正确地持久化。</p><h1 id="d0a1" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="aefc" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">作为奖励，Phoenix还提供了一个名为LiveDashboard的指标仪表板，在控制台点击<a class="ae mc" href="http://localhost:4000/dashboard/home" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/dashboard/home</a>:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nn"><img src="../Images/bdfc58e71eea68170002250e38e2639f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tj7wJtTkiaVDIBuX"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><em class="mt">凤凰LiveDashboard预览。</em></figcaption></figure><p id="9180" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是监控Phoenix应用程序的健康状况、进程数量、内存使用、框架版本等的一个很好的方法。</p><p id="8eae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Phoenix已经被证明足够灵活，可以让您自由地设计应用程序。自动生成工具非常适合提高您的工作效率，同时为那些现在开始工作的人提供一些很好的提示。</p><p id="6faf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇文章能帮助您为这个令人惊叹的框架铺平道路，并展示它的主要特性。祝你好运！</p></div></div>    
</body>
</html>