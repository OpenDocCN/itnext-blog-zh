<html>
<head>
<title>ES6 Destructuring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6破坏</h1>
<blockquote>原文：<a href="https://itnext.io/es6-destructuring-b8c50a20b46c?source=collection_archive---------6-----------------------#2018-03-12">https://itnext.io/es6-destructuring-b8c50a20b46c?source=collection_archive---------6-----------------------#2018-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e1d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">或者:那边那些{ }在干嘛？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8cb08e43dc0774e7d1247955cf32d6d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfLuQl4XCccghBOW4egkPA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">芬兰赫尔辛基西贝柳斯纪念碑</figcaption></figure><p id="c848" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fes6-destructuring-b8c50a20b46c" rel="noopener ugc nofollow" target="_blank"> <em class="ls">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="0f98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近在通读Eric Elliott的优秀系列:<br/> <strong class="kx ir">作曲软件</strong></p><div class="lt lu gp gr lv lw"><a href="https://medium.com/javascript-scene/a-functional-programmers-introduction-to-javascript-composing-software-d670d14ede30" rel="noopener follow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">一个函数式程序员对JavaScript(编写软件)的介绍</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">注意:这是学习函数式编程和组合软件的“组合软件”系列的一部分…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">medium.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kp lw"/></div></div></a></div><p id="eb63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">出于某种原因，下面的代码示例对我来说并不直观:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="d43e" class="mq mr iq mm b gy ms mt l mu mv">const blep = {<br/>  blop: 'blop'<br/>};</span><span id="45e1" class="mq mr iq mm b gy mw mt l mu mv">// The following is equivalent to:<br/>// const blop = blep.blop;<br/>const { blop } = blep;<br/>blop; // 'blop'</span></pre><p id="7da2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作业左边的括号看起来不对。此外，所有这些blops没有帮助。出于某种原因，我认为blop应该是一个新的对象。</p><p id="5de1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我花了一些时间想出一些例子来让我的头脑理解这个新的ES6赋值符号。</p><h1 id="586e" class="mx mr iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">运行ES6</h1><p id="f665" class="pw-post-body-paragraph kv kw iq kx b ky no jr la lb np ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">如果你需要一种简单的方法来运行ES6代码，你可以去<a class="ae lr" href="https://babeljs.io/repl" rel="noopener ugc nofollow" target="_blank"> BABEL </a>上的<a class="ae lr" href="https://babeljs.io/repl" rel="noopener ugc nofollow" target="_blank">试用</a>页面。展开<strong class="kx ir">设置</strong>并确保<strong class="kx ir">评估</strong>被选中。然后打开你的浏览器<strong class="kx ir">控制台</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/b2bba03ccc861d44c42e99d45ef1c1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P23x3sFTvWnyfgLwR7kyNQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">巴贝尔BABEL</figcaption></figure><h1 id="2c3f" class="mx mr iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">解构</h1><p id="da8f" class="pw-post-body-paragraph kv kw iq kx b ky no jr la lb np ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">所以事实证明，这种赋值:<code class="fe nu nv nw mm b">const {x} = foo();</code>被称为<a class="ae lr" href="https://babeljs.io/learn-es2015/#destructuring" rel="noopener ugc nofollow" target="_blank">析构</a>。它基本上意味着你可以把一个对象或数组的一部分赋给你自己的命名变量。</p><h2 id="3e33" class="mq mr iq bd my nx ny dn nc nz oa dp ng le ob oc ni li od oe nk lm of og nm oh bi translated">数组示例</h2><p id="de87" class="pw-post-body-paragraph kv kw iq kx b ky no jr la lb np ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">在查看对象之前，让我们先看一些简单的数组示例:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="4d6a" class="mq mr iq mm b gy ms mt l mu mv">const myArray = ['a', 'b', 'c'];<br/>const [x, y, z] = myArray;<br/>console.log('x', x); // x === 'a'<br/>console.log('y', y); // y === 'b'<br/>console.log('z', z); // z === 'c'</span></pre><p id="942a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要理解的关键是第2行中的<code class="fe nu nv nw mm b">[x, y, z]</code>并不是真正的数组。我知道。它看起来确实像一个数组。但是，它只是被用作一个模式，或者说是我的真实变量<code class="fe nu nv nw mm b">x</code>、<code class="fe nu nv nw mm b">y</code>和<code class="fe nu nv nw mm b">z</code>的<a class="ae lr" href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-destructuring-binding-patterns" rel="noopener ugc nofollow" target="_blank">绑定模式</a>。这里真的只有一个阵:<code class="fe nu nv nw mm b">myArray</code>。</p><p id="e080" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也适用于对象数组:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="c8ca" class="mq mr iq mm b gy ms mt l mu mv">const myObjectArray = [{}, {a: 1}, {a: 2, b: true}];<br/>const [small, med, large] = myObjectArray;<br/>console.log('small', small); // small === {}<br/>console.log('med', med);     // med === {a: 1}<br/>console.log('large', large); // large === {a: 2, b: true}</span></pre><p id="8730" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，如果我们不需要数组中的所有元素呢？很高兴你问了。只要省去任何你不需要的元素:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="be58" class="mq mr iq mm b gy ms mt l mu mv">const myArray = ['a', 'b', 'c'];<br/>const [x, , y] = myArray;<br/>console.log('x', x); // x === 'a'<br/>console.log('y', y); // y === 'c'</span></pre><h2 id="2514" class="mq mr iq bd my nx ny dn nc nz oa dp ng le ob oc ni li od oe nk lm of og nm oh bi translated">对象示例</h2><p id="e6db" class="pw-post-body-paragraph kv kw iq kx b ky no jr la lb np ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">对象析构会变得非常复杂。同样，我们将简单地开始。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="a934" class="mq mr iq mm b gy ms mt l mu mv">const car = {<br/>    make: 'Toyota',<br/>    model: 'Camry',<br/>    year: 2018<br/>};</span><span id="b5b2" class="mq mr iq mm b gy mw mt l mu mv">const { make, year } = car;<br/>console.log('make', make); // make === 'Toyota'<br/>console.log('year', year); // year === 2018</span></pre><p id="ff45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像上面的数组例子一样，<code class="fe nu nv nw mm b">{ make, year }</code>不是一个对象。它是一个<a class="ae lr" href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-destructuring-binding-patterns" rel="noopener ugc nofollow" target="_blank">绑定模式</a>。</p><p id="fd73" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意声明和初始化两个新变量的行<code class="fe nu nv nw mm b">const { make, year } = car;</code>。这就像是:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="899a" class="mq mr iq mm b gy ms mt l mu mv">const make = car.make;<br/>const year = car.year;</span></pre><p id="873c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，我们的变量名与对象中的属性名相匹配。但是，我们也可以使用不同的变量名:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="647b" class="mq mr iq mm b gy ms mt l mu mv">const car = {<br/>    make: 'Toyota',<br/>    model: 'Camry',<br/>    year: 2018<br/>};</span><span id="a506" class="mq mr iq mm b gy mw mt l mu mv">const { make: myMake, year: myYear } = car;<br/>console.log('myMake', myMake); // myMake === 'Toyota'<br/>console.log('myYear', myYear); // myYear === 2018</span></pre><p id="7f1a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nu nv nw mm b">const {make: myMake, year: myYear } = car;</code>的台词是这样的:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="e977" class="mq mr iq mm b gy ms mt l mu mv">const myMake = car.make;<br/>const mYear = car.year;</span></pre><p id="fe72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们来看看埃里克·埃利奥特的例子:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="c479" class="mq mr iq mm b gy ms mt l mu mv">const blep = {<br/>  blop: 'blop'<br/>};</span><span id="aad5" class="mq mr iq mm b gy mw mt l mu mv">// The following is equivalent to:<br/>// const blop = blep.blop;<br/>const { blop } = blep;<br/>blop; // 'blop'</span></pre><p id="635a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好了，现在事情开始变得更有意义了:</p><ul class=""><li id="e43e" class="oi oj iq kx b ky kz lb lc le ok li ol lm om lq on oo op oq bi translated"><code class="fe nu nv nw mm b">blep</code>是这样一个物体:<code class="fe nu nv nw mm b">{ blop: 'blop' }</code>。</li><li id="fa43" class="oi oj iq kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated"><code class="fe nu nv nw mm b">{ blop }</code>是BindingPattern。</li><li id="b706" class="oi oj iq kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">所以我们得到了一个新的变量<code class="fe nu nv nw mm b">blop</code>，它被赋予了<code class="fe nu nv nw mm b">blep.blop</code>的值，也就是“blop”。</li></ul><p id="2402" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯，还不算太糟。是吗？</p><p id="aebf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">介绍完之后，我们现在可以探索一些更复杂、更强大的例子，这些例子应该可以回答重要的问题……</p><h1 id="f829" class="mx mr iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">为什么要破坏？</h1><p id="8eb0" class="pw-post-body-paragraph kv kw iq kx b ky no jr la lb np ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">在我试验了一些代码后，我问了一个你可能会想到的问题:</p><p id="67e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">"用常规的旧点符号直接访问对象属性不是更容易、更清晰吗？"</p><p id="9d3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯，有时是，有时不是。</p><p id="1201" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个来自<strong class="kx ir"> MPJ </strong>在<a class="ae lr" href="https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q" rel="noopener ugc nofollow" target="_blank">Fun Fun Fun Function</a>的例子。(你真的需要去看看他的东西。太棒了！)首先，我们将从简单的用于赋值的点符号和老式JavaScript开始。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="4313" class="mq mr iq mm b gy ms mt l mu mv">var animal = {<br/>    weight: 23,<br/>    sound: 'woof'<br/>};</span><span id="2046" class="mq mr iq mm b gy mw mt l mu mv">function makeSound(options) {<br/>    var species = options.species || 'animal';<br/>    var sound = options.sound;<br/>    return ('The ' + species + ' says ' + sound + '!');<br/>}</span><span id="8315" class="mq mr iq mm b gy mw mt l mu mv">// output: The animal says woof!<br/>console.log(makeSound(animal));</span></pre><p id="e79e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我们有一个动物对象，它丢失了它的<code class="fe nu nv nw mm b">species</code>属性。我们的<code class="fe nu nv nw mm b">makeSound</code>函数处理这种可能性，并将<code class="fe nu nv nw mm b">species</code>默认为值:“animal”。还不错。但是，对于它所做的事情来说，它有点冗长。该函数重5行，169个字符。</p><p id="54ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ES6让我们使用<strong class="kx ir">析构函数参数</strong>。所以我们的函数可以是这样的:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="0acb" class="mq mr iq mm b gy ms mt l mu mv">function makeSound({ species, sound}) {<br/>    species = species || 'animal';<br/>    return ('The ' + species + ' says ' + sound + '!');<br/>}</span></pre><p id="5e5c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个很好的改进。我们只剩下4行和135个字符。它通过告诉我们它只使用对象的<code class="fe nu nv nw mm b">species</code>和<code class="fe nu nv nw mm b">sound</code>属性来帮助函数文档本身。此外，<code class="fe nu nv nw mm b">species</code>和<code class="fe nu nv nw mm b">sound</code>像参数一样工作，所以我们不需要在代码中声明它们。</p><p id="c3f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，如果我们利用ES6的力量<strong class="kx ir">默认参数</strong>:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="ab89" class="mq mr iq mm b gy ms mt l mu mv">function makeSound({ species = 'animal', sound}) {<br/>    return ('The ' + species + ' says ' + sound + '!');<br/>}</span></pre><p id="f464" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这变得越来越好:只有3行和110个字符！</p><p id="59c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，让我们真的全力以赴，使用ES6 <strong class="kx ir">箭头函数</strong>和<strong class="kx ir">字符串模板</strong>。现在我们的功能变成了一件艺术品:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="bb45" class="mq mr iq mm b gy ms mt l mu mv">const makeSound = ({ species = 'animal', sound}) =&gt;<br/>`The ${species} says ${sound}!`;</span></pre><p id="07cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在实际代码中，它只占一行，只有84个字符。让我们凝视它片刻，享受它的美丽。啊啊。</p><p id="0b4a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是MPJ的娱乐视频，解释了这一切:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">MPJ关于解构的优秀视频</figcaption></figure><h1 id="c96e" class="mx mr iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">更多示例</h1><p id="6468" class="pw-post-body-paragraph kv kw iq kx b ky no jr la lb np ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">既然我们理解了析构，你可能会开始注意到它无处不在。</p><p id="1f9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个使用它来获取数组长度属性的示例:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="a113" class="mq mr iq mm b gy ms mt l mu mv">const myArray = ['a', 'b', 'c'];<br/>for (let i = 0, { length } = myArray; i &lt; length; i++) {<br/>    console.log(myArray[i]);<br/>}</span></pre><p id="89e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您使用Redux时，您可能会看到类似这样的内容:</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="3518" class="mq mr iq mm b gy ms mt l mu mv">const myReducer = (state, action = {}) =&gt; {<br/>  const { type, payload } = action;<br/>  ...<br/>}</span></pre><p id="25cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您正在寻找更多的例子和对析构的深入研究，请参阅Mozilla文章:</p><div class="lt lu gp gr lv lw"><a href="https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">ES6深度:解构- Mozilla黑客-网络开发者博客</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">ES6 In Depth是一个系列，介绍JavaScript编程语言在第6版中增加的新特性…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">hacks.mozilla.org</p></div></div><div class="mf l"><div class="oy l mh mi mj mf mk kp lw"/></div></div></a></div></div></div>    
</body>
</html>