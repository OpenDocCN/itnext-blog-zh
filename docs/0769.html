<html>
<head>
<title>Sharing AES-256 encrypted data between Node.js and Python 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js和Python 3之间共享AES-256加密数据</h1>
<blockquote>原文：<a href="https://itnext.io/sharing-aes-256-encrypted-data-between-node-js-and-python-3-d0c87eae212b?source=collection_archive---------2-----------------------#2018-05-24">https://itnext.io/sharing-aes-256-encrypted-data-between-node-js-and-python-3-d0c87eae212b?source=collection_archive---------2-----------------------#2018-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8b2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天早上我开始为<a class="ae kl" href="https://nazcabot.io" rel="noopener ugc nofollow" target="_blank"> https://nazcabot.io </a>开发一个特性，它要求一些数据在Node.js中安全加密，并最终传递给Python进程，解密并使用。</p><p id="e90f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>我们正在讨论<strong class="jp ir">对称密钥认证加密</strong>。你有<em class="km">一些数据</em>，你想用<em class="km">密钥加密它。</em></p><p id="0e46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能和我一样在想。没有。不不不。</p><p id="1f9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显而易见的解决方案是使用Node的<code class="fe kn ko kp kq b">crypto</code>库，它构建在OpenSSL之上。现在，最流行的Python加密包，<a class="ae kl" href="https://github.com/dlitz/pycrypto" rel="noopener ugc nofollow" target="_blank"> PyCrypto </a>却不是。虽然底层加密算法是相同的(在我的例子中是<code class="fe kn ko kp kq b">aes-256-cbc</code>)，但是OpenSSL填充数据的方式(PKCS#5)与PyCrypto不同，导致了不必要的麻烦。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5b2236ccf32d6a0878442da5079dbd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wlf6z9nMP1xebxZD."/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">迈克·什切潘斯基在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="1258" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">输入NaCl或TweetNaCl或lib na</h1><p id="b7b3" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">为了避免不兼容问题，您可以使用<a class="ae kl" href="https://github.com/jedisct1/libsodium" rel="noopener ugc nofollow" target="_blank">libna</a>，这是一个现代的、可移植的、易于使用的加密库，用C语言编写，带有大多数语言的包装器。特别是，它有用于<a class="ae kl" href="https://github.com/dchest/tweetnacl-js" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae kl" href="https://github.com/pyca/pynacl" rel="noopener ugc nofollow" target="_blank"> Python </a>的包装器。</p><h2 id="36c2" class="mk li iq bd lj ml mm dn ln mn mo dp lr jy mp mq lv kc mr ms lz kg mt mu md mv bi translated"><strong class="ak">node . js中的加密</strong></h2><p id="6bad" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我使用了一个名为<a class="ae kl" href="https://github.com/dchest/tweetnacl-js" rel="noopener ugc nofollow" target="_blank"> tweenacl-js </a>的库和一个兄弟库tweetnacl-util，它附带了一些方便的函数，你可以用:</p><pre class="ks kt ku kv gt mw kq mx my aw mz bi"><span id="bb10" class="mk li iq kq b gy na nb l nc nd">npm install --save tweetnacl tweetnacl-util</span></pre><p id="95da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们开始吧。<em class="km">注意</em>我已经硬编码了密钥。不要那样做。把密钥放在一个<code class="fe kn ko kp kq b">.env</code>文件里，用dotenv加载。</p><pre class="ks kt ku kv gt mw kq mx my aw mz bi"><span id="4cb7" class="mk li iq kq b gy na nb l nc nd">const nacl = require('tweetnacl')<br/>const utils = require('tweetnacl-util')<br/>const encodeBase64 = utils.encodeBase64</span><span id="d4d6" class="mk li iq kq b gy ne nb l nc nd">// Our nonce must be a 24 bytes Buffer (or Uint8Array)<br/>const nonce = nacl.randomBytes(24)</span><span id="eebe" class="mk li iq kq b gy ne nb l nc nd">// Our secret key must be a 32 bytes Buffer (or Uint8Array)<br/>const secretKey = Buffer.from('_THIS_IS_MY_32_CHARS_SECRET_KEY_', 'utf8')</span><span id="6199" class="mk li iq kq b gy ne nb l nc nd">// Make sure your data is also a Buffer of Uint8Array<br/>const secretData = Buffer.from('Some Italians hate wine', 'utf8')<br/>const encrypted = nacl.secretbox(secretData, nonce, secretKey)</span><span id="a2b1" class="mk li iq kq b gy ne nb l nc nd">// We can now store our encrypted result and our nonce somewhere<br/>const result = `${encodeBase64(nonce)}:${encodeBase64(encrypted)}`</span></pre><p id="224d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kn ko kp kq b">result</code>看起来会像这样</p><pre class="ks kt ku kv gt mw kq mx my aw mz bi"><span id="0006" class="mk li iq kq b gy na nb l nc nd">6mNohLkeVCPgv6r4Jfx2cRhFHtnIa04K:rWTEbQ0GdzpXdxXZ9JRk+drr3JtEmt1I70DGNpXvPO9lKgOZbflf</span></pre><p id="c884" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用一个<code class="fe kn ko kp kq b">:</code>从我们的加密数据中分离出随机数。重要的是随机数每次都是不同的，因此我们随机生成它并保存它以备后用。</p><h2 id="3b56" class="mk li iq bd lj ml mm dn ln mn mo dp lr jy mp mq lv kc mr ms lz kg mt mu md mv bi translated">解密是Python</h2><p id="fff2" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">安装<a class="ae kl" href="https://pynacl.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">派纳尔</a>和<code class="fe kn ko kp kq b">pip</code>或者你喜欢的任何东西。</p><pre class="ks kt ku kv gt mw kq mx my aw mz bi"><span id="632d" class="mk li iq kq b gy na nb l nc nd">pip install pynacl</span></pre><p id="e65c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，假设你已经有了上面的字符串，你可以用几行代码来解密它</p><pre class="ks kt ku kv gt mw kq mx my aw mz bi"><span id="9f88" class="mk li iq kq b gy na nb l nc nd">from base64 import b64decode<br/>from nacl.secret import SecretBox</span><span id="cb46" class="mk li iq kq b gy ne nb l nc nd">secret_key = '_THIS_IS_MY_32_CHARS_SECRET_KEY_'<br/>encrypted = '6mNohLkeVCPgv6r4Jfx2cRhFHtnIa04K:rWTEbQ0GdzpXdxXZ9JRk+drr3JtEmt1I70DGNpXvPO9lKgOZbflf'</span><span id="cac8" class="mk li iq kq b gy ne nb l nc nd">encrypted = encrypted.split(':')</span><span id="1505" class="mk li iq kq b gy ne nb l nc nd"># We decode the two bits independently<br/>nonce = b64decode(encrypted[0])<br/>encrypted = b64decode(encrypted[1])</span><span id="a0b6" class="mk li iq kq b gy ne nb l nc nd"># We create a SecretBox, making sure that out secret_key is in bytes<br/>box = SecretBox(bytes(secret_key, encoding='utf8'))</span><span id="1566" class="mk li iq kq b gy ne nb l nc nd">decrypted = box.decrypt(encrypted, nonce).decode('utf-8')</span></pre><p id="2593" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你知道了</p><pre class="ks kt ku kv gt mw kq mx my aw mz bi"><span id="6533" class="mk li iq kq b gy na nb l nc nd">'Some Italians hate wine'</span></pre><p id="e44d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，请确保您的密钥不是以纯文本的形式存储在代码中。</p></div></div>    
</body>
</html>