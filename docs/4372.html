<html>
<head>
<title>UI Tests Debugging Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UI测试调试最佳实践</h1>
<blockquote>原文：<a href="https://itnext.io/ui-tests-debugging-best-practices-789c4ed4daf6?source=collection_archive---------2-----------------------#2020-06-18">https://itnext.io/ui-tests-debugging-best-practices-789c4ed4daf6?source=collection_archive---------2-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2c73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一系列最佳实践，在使用Puppeteer和其他浏览器自动化工具时简化了测试编写和调试阶段。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ca9e4e560f577fcdf5f2edb10768d662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f0L1N9n77BWcqeLjkAIsqA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@tekton_tools?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">泰克顿</a>在<a class="ae le" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="733d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我正在GitHub上做一个大的<a class="ae le" href="https://github.com/NoriSte/ui-testing-best-practices?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> UI测试最佳实践</a>项目，我分享这个帖子来传播它并有直接的反馈。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="e9f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在搬到Cypress之前，我习惯于用Puppeteer编写UI测试。理解浏览器中发生了什么，正在运行哪个测试，以及调试测试都不是容易的任务，因此我开始应用一系列的解决方案来帮助我完成整个过程。</p><p id="9a65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像<a class="ae le" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress </a>和<a class="ae le" href="https://devexpress.github.io/testcafe/" rel="noopener ugc nofollow" target="_blank"> TestCafé </a>这样的工具几乎没有用，但是你不会意识到一个专门制作的工具简化了你的生活，除非你以前有过使用像<a class="ae le" href="https://www.selenium.dev/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>或<a class="ae le" href="https://pptr.dev/" rel="noopener ugc nofollow" target="_blank">木偶师</a>这样的工具的测试经验。</p><p id="c1cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一步是以非无头模式启动浏览器，然后…</p><h2 id="75a3" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">Console.log/show测试的描述</h2><p id="8e73" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">由于您没有关于哪个测试正在浏览器中运行的视觉反馈，请记住在浏览器控制台中记录测试的名称。这在快速测试(不到1秒)的情况下毫无用处，但在更长的测试或在使用<code class="fe mk ml mm mn b">test.skip</code>和<code class="fe mk ml mm mn b">test.only</code>时对正在运行的测试进行双重检查时很有帮助。</p><p id="5075" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在木偶戏中，这可以通过以下方式实现:</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="d30e" class="lm ln it mn b gy ms mt l mu mv">test('Test description', async () =&gt; {<br/>  await page.evaluate(() =&gt; console.log('Test description'));</span><span id="dd90" class="lm ln it mn b gy mw mt l mu mv">  // ... the test code...<br/>})</span></pre><p id="5329" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您需要更深入的反馈，您甚至可以考虑在页面的左上角添加一个固定的div，每个测试都用自己的描述填充它…</p><h2 id="80a3" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">将浏览器console.log转发到Node.js</h2><p id="636c" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">用木偶师，一个简单的</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="e32b" class="lm ln it mn b gy ms mt l mu mv">page.on('console', msg =&gt; console.log('BROWSER LOG:', msg.text()));</span></pre><p id="1025" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">允许您在同一个终端窗口中读取测试日志和浏览器日志。简单有效。</p><h2 id="2a6b" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">使用已经打开的devtools启动浏览器</h2><p id="42ff" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">像在传统的前端开发中一样，在页面加载已经开始后打开devtools可能会让你错过重要的东西，尤其是在network选项卡中。调试测试时，用已经打开的devtools启动浏览器可以节省您宝贵的时间和信息。</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="f2fd" class="lm ln it mn b gy ms mt l mu mv">const browser = await puppeteer.launch({<br/> headless: false,<br/> <strong class="mn iu">devtools: true</strong><br/>});</span></pre><h2 id="1aa1" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">减慢模拟的用户动作</h2><p id="9840" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">浏览器自动化工具非常快，这让我们可以在几秒钟内运行大量测试。在调试时，这可能是一个缺点，因为你需要用眼睛关注页面上发生的事情。放慢<strong class="js iu">每一个动作</strong>可能会适得其反——因为整个测试变得缓慢——但通常，这是执行一些快速检查的最简单方法。在《木偶师》中，有一个全局设置来做这件事。</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="11a5" class="lm ln it mn b gy ms mt l mu mv">const browser = await puppeteer.launch({<br/> headless: false,<br/> slowMo: 250, // slow down every action by 250ms<br/>});</span></pre><p id="76b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有些动作，如打字，允许您添加更具体的延迟(发生在全局<code class="fe mk ml mm mn b">slowMo</code>设置之上)</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="5220" class="lm ln it mn b gy ms mt l mu mv">await page.type('.username', 'admin', {delay: 10});</span></pre><h2 id="7653" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">用调试器语句暂停测试</h2><p id="a941" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">同样，像在标准的web开发中一样，您可以在页面上运行的代码中添加一个<code class="fe mk ml mm mn b">debugger</code>语句来“暂停”JavaScript的执行。请注意:只有在受控浏览器中打开devtools时，该语句才有效。</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="44ce" class="lm ln it mn b gy ms mt l mu mv">await page.evaluate(() =&gt; {debugger;});</span></pre><p id="ff33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过点击“恢复脚本执行”或按下F8 ( <code class="fe mk ml mm mn b">debugger</code>是一个“飞行”断点)将恢复测试执行。</p><h2 id="fae6" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">增加测试超时</h2><p id="0bfd" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">试跑者如Jest、Jasmine等。有测试超时。如果出现问题并且测试没有结束，超时对于终止测试是有用的。在UI测试中，这种行为很麻烦，因为测试开始时打开浏览器，测试结束时又关闭浏览器。在正常测试的生命周期中，高超时是不起作用的，因为它会在失败的情况下导致巨大的时间损失，而低超时可能会在测试完成之前“截断”测试。</p><p id="b436" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，您需要长时间的超时，因为您不希望在测试结束时关闭浏览器。这就是为什么在调试受控浏览器时，10分钟的超时会很有帮助。</p><p id="e3de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">否则，你可以…</p><h2 id="d771" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">测试结束时避免关闭浏览器</h2><p id="4def" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">当测试开始时，您打开浏览器，然后在测试结束时关闭它。避免关闭它给你检查前端应用程序的自由，而不用担心测试超时。这仅在本地运行测试时有效，并且在CI管道上运行测试之前必须恢复自动关闭，以避免由于浏览器实例保持打开而导致内存不足。</p><h2 id="19b0" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">截图</h2><p id="aeba" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">这在无头模式下运行测试时特别有用，在这个阶段，测试被认为是稳定的，只有在回归的情况下才会失败。如果一个测试失败了，很多时候屏幕截图会让你明白你正在开发的特性是如何影响一个先前工作的特性的。最有效的解决方案是在测试失败时截屏，否则，您可以在UI测试中识别一些检查点，并在这些步骤中截屏。</p><h2 id="ea4d" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">频繁断言</h2><p id="a675" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">一个经验法则:如果一个测试失败了，它必须直接驱动你去理解哪里出错了，而不需要重新启动测试和手工调试它。尝试在你的代码库中手工引入bug(改变请求负载，删除元素，等等)。)并检查测试报告的内容。该错误与您引入的bug相关吗？谁读了失败能理解什么需要被修理？</p><p id="bcc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你需要在你的测试中添加很多断言，这完全没问题！单元测试通常只需要一个步骤和一两个断言，但是UI测试不同，它们有很多步骤，因此你需要很多断言。可以把它们想象成一系列的uni测试，其中前一个测试是为第二个测试创造基础所必需的，以此类推。</p><h2 id="f050" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">使用test.skip和test.only</h2><p id="e4b9" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">这是每个测试跑步者的基本要求之一，但是你永远不知道:如果你不习惯使用skip和only，现在就开始吧！否则，你将会浪费很多时间，即使你的测试文件仅仅由两三个测试组成。总是运行最少数量的测试，否则你需要调试！</p><h2 id="743e" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">连续运行测试</h2><p id="6240" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">如果你结合Jest使用Puppeteer，记住Jest有一个专用的<code class="fe mk ml mm mn b">runInBand</code>选项，防止它将测试的执行分散到你的CPU内核上。并行化测试对于加速执行是完美的，但是当你需要用你的眼睛跟随测试动作时，这是令人讨厌的。<code class="fe mk ml mm mn b">runInBand</code>连续运行测试。结合使用<code class="fe mk ml mm mn b">test.skip</code>、<code class="fe mk ml mm mn b">test.only</code>和<a class="ae le" href="https://github.com/jest-community/jest-watch-typeahead" rel="noopener ugc nofollow" target="_blank"> jest-watch-typeahead </a>可以让你省去很多调试的麻烦。</p><h2 id="311e" class="lm ln it bd lo lp lq dn lr ls lt dp lu kb lv lw lx kf ly lz ma kj mb mc md me bi translated">保持你的测试代码简单</h2><p id="5cbc" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">比起抽象，更喜欢复制。努力让你的测试代码简单易读。你调试UI测试越多，你就越会意识到它有多难。一旦你需要理解正在发生的事情以及哪一步没有按预期工作，你的高度抽象的、完全干燥的测试代码就变成了一种痛苦。</p><p id="b9bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更一般地说，测试是小脚本，必须比它们测试的代码简单两个数量级，让它们成为盟友，而不是一些更复杂的程序。</p><h1 id="cd39" class="mx ln it bd lo my mz na lr nb nc nd lu ne nf ng lx nh ni nj ma nk nl nm md nn bi translated">选择专门制作的工具</h1><p id="ac16" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">上面提到的都是有效的解决方案，但是它们有一个共同点:<strong class="js iu">它们是变通方法</strong>。事实上，我在示例中使用的工具Puppeteer不是为UI测试而创建的，而是为通用浏览器自动化而创建的，那么，在一些外部实用程序的帮助下并在测试中使用，Puppeteer可以用于UI测试。与自动化操作相比，测试web应用程序有不同的需求，需要不同的工具。</p><p id="0c0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您需要编写UI测试，您应该考虑迁移到Cypress或TestCafé，因为它们旨在简化您的测试工作。怎么会？拥有大量实用程序和默认行为，以及一系列一流的解决方案，允许您了解和调试浏览器中发生的事情。考虑到本文中提到的所有布袋戏演员<strong class="js iu">的最佳实践</strong>……<strong class="js iu">对Cypress或TestCafé </strong>完全没用😉</p><p id="3318" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的<a class="ae le" href="https://medium.com/@NoriSte/some-ui-testing-problems-and-the-cypress-way-22312ab986e3" rel="noopener">一些UI测试问题和Cypress方式</a>和<a class="ae le" href="https://medium.com/@NoriSte/front-end-productivity-boost-cypress-as-your-main-development-browser-f08721123498" rel="noopener">前端生产力提升:Cypress作为您的主要开发浏览器</a>文章包括Cypress一流实用程序的概述。</p><h1 id="b370" class="mx ln it bd lo my mz na lr nb nc nd lu ne nf ng lx nh ni nj ma nk nl nm md nn bi translated">你可能会对我的其他文章感兴趣</h1><ul class=""><li id="e917" class="no np it js b jt mf jx mg kb nq kf nr kj ns kn nt nu nv nw bi translated">为什么测试一个web应用程序如此困难？为什么通用浏览器自动化工具不能很好地满足用户界面/E2E测试的需求？柏木为什么出众？<a class="ae le" href="https://medium.com/@NoriSte/some-ui-testing-problems-and-the-cypress-way-22312ab986e3" rel="noopener">一些UI测试问题和柏道</a></li><li id="8d86" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn nt nu nv nw bi translated">为什么测试非常适合讲述你的代码:<a class="ae le" href="https://medium.com/@NoriSte/software-tests-as-a-documentation-tool-e1c463bad1be" rel="noopener">软件测试作为文档工具</a></li><li id="3a1b" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn nt nu nv nw bi translated">睡眠:E2E测试中最糟糕的实践和确定性事件的概念。<a class="ae le" href="https://medium.com/@NoriSte/await-do-not-sleep-your-e2e-tests-df67e051b409" rel="noopener">等待，不要让您的E2E测试休眠</a></li></ul></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="8aea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你好👋我是Stefano Magni，我是一名热情的<strong class="js iu">反应和打字开发者</strong>，一名<strong class="js iu">柏树大使</strong>和一名<strong class="js iu">讲师</strong>。我作为一名高级前端工程师为WorkWave 做远程工作。我喜欢创造高质量的产品，测试和自动化一切，学习和分享我的知识，帮助他人，在会议上发言，以及面对新的挑战。<br/>你可以在<a class="ae le" href="https://twitter.com/NoriSte?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae le" href="https://github.com/NoriSte?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae le" href="https://www.linkedin.com/in/noriste/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。你可以找到我最近所有的投稿/演讲等。关于<a class="ae le" href="https://github.com/NoriSte/all-my-contributions" rel="noopener ugc nofollow" target="_blank">我的GitHub总结</a>。</p></div></div>    
</body>
</html>