<html>
<head>
<title>Mastering Angular: Promises vs Observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握角度:承诺与观察</h1>
<blockquote>原文：<a href="https://itnext.io/angular-for-junior-developers-promises-vs-observables-618f1d26aaa5?source=collection_archive---------0-----------------------#2022-12-28">https://itnext.io/angular-for-junior-developers-promises-vs-observables-618f1d26aaa5?source=collection_archive---------0-----------------------#2022-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1de4d003573d00c152d341230d0ccfaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjxvaU3WuyR1PXE_7mLPAg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">“罗讷河上的星夜”，文森特·梵高，1888年</figcaption></figure><p id="4a5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章中，你将了解到可观察到的和承诺之间的区别。</p><h1 id="6bc1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">术语</h1><p id="88f1" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated"><em class="md">这里有意简化了一些术语。</em></p><ul class=""><li id="4ff3" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">消费者:代码，当一个承诺或一个可观察物产生一个价值时将被调用(通知)。<br/>在Promise的情况下，是“then”内部的回调函数。<br/>对于Observables，是“订阅”中的回调函数。</li><li id="adbb" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">正如我们读到的，同步代码是一行一行执行的。如果有一些繁重的计算，剩下的代码将会等待。</li><li id="eeef" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">异步代码将不会在我们阅读代码时“在下一行”执行，而是在遥远的将来。它可能会在一毫秒后或一分钟后执行——要点是:代码的其余部分不会“等待”那一刻，而是会立即执行。</li></ul><h1 id="436e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">类似</h1><ul class=""><li id="fa6e" class="me mf iq ke b kf ly kj lz kn ms kr mt kv mu kz mj mk ml mm bi translated">两者都可以用于异步操作；</li><li id="c84d" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">两者都在控制消费者何时会获得生产的价值(两者都在把价值“推”给消费者)。</li></ul><h1 id="f161" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">差异</h1><h2 id="1325" class="mv lb iq bd lc mw mx dn lg my mz dp lk kn na nb lo kr nc nd ls kv ne nf lw ng bi translated">🏃‍♀️处决</h2><p id="633a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated"><strong class="ke ir"> <em class="md">承诺</em> </strong>创建后立即执行。“那么”中是否提供了回调函数并不重要。消费者将异步获取值(如果成功)。但是承诺本身的执行将从创造的那一刻开始。</p><p id="b212" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="md">可观察的</em> </strong>只有订阅时才会执行(“懒”计算)。</p><p id="5760" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">实际上，这意味着您可以使用observables“准备”一些异步代码，并且只在需要时才执行它。例如，它可能是一些复杂的API请求(搜索、过滤)，或者一个动画链。</p><blockquote class="nh ni nj"><p id="a9f2" class="kc kd md ke b kf kg kh ki kj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky kz ij bi translated"><em class="iq">注意:可观察值可以同步或异步执行。承诺总是异步产生价值。</em></p></blockquote><h2 id="af12" class="mv lb iq bd lc mw mx dn lg my mz dp lk kn na nb lo kr nc nd ls kv ne nf lw ng bi translated">📦价值观念</h2><p id="3890" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated"><strong class="ke ir"> <em class="md">承诺</em> </strong>只能产生一个单值(或一个错误)。</p><p id="c404" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="md">可观测量</em> </strong>可以产生多个值，一个值，或者根本没有值。</p><p id="8319" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于一个web app来说，这意味着Observables可以用在很多情况下，而承诺是不能用的。一些可观察对象的行为类似于事件发射器——例如，在Angular中，您可以为<code class="fe nn no np nq b">@Output</code>事件使用EventEmitter()实例。web应用程序中有许多事件源(DOM events，XHR)。可观察性是处理事件的正确工具。</p><h2 id="a1fb" class="mv lb iq bd lc mw mx dn lg my mz dp lk kn na nb lo kr nc nd ls kv ne nf lw ng bi translated">🚧取消</h2><p id="9a3a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated"><strong class="ke ir"> <em class="md">承诺</em> </strong>不可取消。有一些技巧和第三方库可以通过承诺达到这种效果，但是请记住，承诺会立即开始执行——它不会很好地处理取消承诺的尝试。</p><p id="993e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="md">观察值</em> </strong>被设计为可取消(使用“取消订阅”电话或由操作员取消)。</p><p id="d60f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Angular应用程序中，它将帮助您创建类似“提前键入”(使用<code class="fe nn no np nq b">switchMap()</code>)的功能，并通过在组件的“销毁”生命周期(使用<code class="fe nn no np nq b">takeUntil()</code>)中处理每个可观察对象来防止内存泄漏。</p><blockquote class="nh ni nj"><p id="0b7b" class="kc kd md ke b kf kg kh ki kj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky kz ij bi translated"><em class="iq">提示:当你想添加</em> <code class="fe nn no np nq b"><em class="iq">takeUntil()</em></code> <em class="iq">运算符时，总是把它放在链表的最后一个运算符！</em></p></blockquote><h2 id="621e" class="mv lb iq bd lc mw mx dn lg my mz dp lk kn na nb lo kr nc nd ls kv ne nf lw ng bi translated">⚙️算子</h2><p id="2fb5" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated"><strong class="ke ir"> <em class="md">承诺</em> </strong>没有操作符。</p><p id="87d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="md">可观察对象</em> </strong>有不同种类的操作符:创建、转换、过滤等等。</p><p id="813e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用运算符，您可以完成仅使用承诺难以实现的事情。随着时间的推移，你会掌握这项技能。</p><blockquote class="nh ni nj"><p id="cf52" class="kc kd md ke b kf kg kh ki kj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky kz ij bi translated"><em class="iq">提示:不要创建过长的操作符链。</em></p></blockquote><p id="968f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不要被现有操作符的数量吓到:您不需要马上学习所有的操作符。有几个你永远用不到，有几个你偶尔会用到，有几个会成为你最好的帮手。</p><p id="1ecf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当你知道一组基本的操作符时，试着每周学习和练习一个新的操作符——每学一个新的操作符，就会越来越容易。</p><p id="3e54" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">作为基础集，我推荐学习:<em class="md"> map() </em>，<em class="md"> tap() </em>，<em class="md"> takeUntil() </em>，<em class="md"> finalize() </em>，<em class="md"> debounceTime() </em>，<em class="md"> switchMap() </em>，<em class="md"> filter() </em>，<em class="md"> catchError() </em>。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="9473" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="md">读入</em> <strong class="ke ir"> <em class="md">掌握角度</em></strong><em class="md">:</em></p><ul class=""><li id="427d" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">承诺与观察</li><li id="86d1" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae ny" href="https://medium.com/p/5cf94052b729" rel="noopener">冷热可观</a></li><li id="b803" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae ny" href="https://medium.com/p/5af7f7fd8e96" rel="noopener">绘制可观测量图</a></li><li id="c23f" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae ny" href="https://medium.com/p/97106873823d" rel="noopener">RxJS的危险与宝藏</a></li><li id="6a71" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae ny" href="https://medium.com/p/3daac4e75312" rel="noopener"> RxJS管道</a></li><li id="a8c1" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae ny" href="https://medium.com/p/f3084c982415" rel="noopener">储存库和文件结构</a></li><li id="c3fc" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae ny" href="https://medium.com/p/c09838dea6e2" rel="noopener">基本代码组织原则</a></li></ul></div></div>    
</body>
</html>