<html>
<head>
<title>Post safely In an uncertain Android world</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不确定的Android世界中安全发布</h1>
<blockquote>原文：<a href="https://itnext.io/post-safely-in-an-uncertain-android-world-8c0e77fa7812?source=collection_archive---------2-----------------------#2018-07-21">https://itnext.io/post-safely-in-an-uncertain-android-world-8c0e77fa7812?source=collection_archive---------2-----------------------#2018-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="461a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码看起来熟悉吗？</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="1c16" class="kx ky it kt b gy kz la l lb lc">fun onStart() {<br/>    <strong class="kt iu">val </strong>handler = Handler()<br/>    handler.postDelayed(<strong class="kt iu">object </strong>: Runnable {<br/>        <strong class="kt iu">override fun </strong>run() {<br/>            Toast.makeText(<br/>                <strong class="kt iu">this</strong>@MainActivity, <strong class="kt iu">“Look at me!”</strong>,          Toast.<em class="ld">LENGTH_SHORT</em>).show()<br/>        }<br/>    }, 1500)<br/>}</span></pre><p id="8106" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一名Android开发人员，你经常会在onCreate或onStart中遇到postDelayed。有很多StackOverflow的问题问“为什么我的动画不运行？”。答案通常建议使用postDelayed。</p><p id="8c92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是为什么延迟工作呢？要理解这一点，我们需要了解Android的内部。Android有一个主线程，用于更新用户界面。任何Android组件都在这个线程上运行——活动、广播接收器、片段、视图等。</p><p id="cfd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Android运行在Java上，默认情况下，Java线程执行一次，而且只执行一次。在Android这样的平台上，UI不断更新，为每个动作创建新线程很快就会变得非常昂贵。为了解决这个问题，Android的主线程使用HandlerThread，它是Java线程的一个子类。Android通过使用一个调度消息(Runnables)执行的循环来保持这个主线程。</p><p id="9971" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些消息是按顺序运行的，这就是为什么在主线程上执行长时间运行的任务会阻塞后续等待执行的消息。主线程的顺序性也是为什么当在一个生命周期方法中完成太多工作时，UI会滞后的原因，在这种情况下，消息队列的增长速度超过了它的执行速度。</p><p id="df42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们来看后延。通过使用post，我们将工作调度到主线程上，在某个未来的时间延迟点发生。现在，您可能已经看到了问题所在。我们在主线程上做了太多的工作，所以我们的动画不运行，为了解决这个问题，我们在将来执行动画，那时我们希望主线程是空闲的。我们正在解决问题的症状，但不是问题。</p><p id="ec29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是我们在主线上做了太多的工作。这是Android中的一个常见问题，因为代码会卡在onCreate和onStart中。所以解决这个问题的简单方法就是在使用postDelayed的地方减少主线程的工作量。</p><p id="959e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是重写一堆代码并不总是可行的。所以有时候速战速决是必要的。但是，延迟仍然带来了另一个问题。postDelayed不关心生命周期方法。假设我们在onStart中用postDelayed(1秒)开始一个动画。半秒钟过去了，用户开始在后台运行应用程序。主线程仍然执行Runnable，但是没有视图，用户看到:</p><figure class="ko kp kq kr gt lf gh gi paragraph-image"><div class="gh gi le"><img src="../Images/3c29da4d3cbfe7d4899b0dbdab58aa81.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*31MOswGAhycNBkMU0IwciQ.png"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">不不不。</figcaption></figure><p id="a9b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们如何防止这种崩溃？我们可以保留对Runnable的引用，并在onStop中清除Runnable，但这并不有趣。因此，让我们使用RxJava和Kotlin来确保BaseActivity的任何子类的发布安全:</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="67f4" class="kx ky it kt b gy kz la l lb lc"><strong class="kt iu">abstract class </strong>BaseActivity : AppCompatActivity() {</span><span id="0f7b" class="kx ky it kt b gy lm la l lb lc">    <em class="ld">// Stores RxJava calls<br/>    </em><strong class="kt iu">private val compositeDisposable </strong>= CompositeDisposable()</span><span id="7db1" class="kx ky it kt b gy lm la l lb lc"><strong class="kt iu">    override fun </strong>onStop() {<br/>        <strong class="kt iu">super</strong>.onStop()<br/>        <em class="ld">// Clear all RxJava calls that have not yet completed<br/>        </em><strong class="kt iu">compositeDisposable</strong>.clear()<br/>    }</span><span id="517d" class="kx ky it kt b gy lm la l lb lc"><em class="ld">    /**<br/>     * Creates an RxJava equivalent to post/postDelayed<br/>     * The disposable is cleared on pause<br/>     * So functions that act on the view can be safely <br/>     * invoked without causing a crash<br/>     */<br/>     </em><strong class="kt iu">protected fun </strong>postSafely(<br/>         callback: () -&gt; Unit,<br/>         delay: Long = 0,<br/>         delayTimeUnit: TimeUnit = TimeUnit.<strong class="kt iu">SECONDS<br/>     </strong>) {<br/>          // Be careful of the RxJava call ordering<br/>          // Delay must be placed before observeOn<br/>          Completable.complete()<br/>              .subscribeOn(Schedulers.newThread())<br/>              .delay(delay, delayTimeUnit)<br/>              .observeOn(AndroidSchedulers.mainThread())<br/>              .doOnComplete(callback)<br/>              .subscribe()<br/>              <em class="ld">.addToDisposables</em>()<br/>     }<br/>     <br/>     <strong class="kt iu">protected fun </strong>Disposable.addToDisposables()<br/>         <strong class="kt iu">compositeDisposable</strong>.add(<strong class="kt iu">this</strong>)<br/>     }<br/>}</span></pre><p id="5299" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，BaseActivity的任何子类都可以在不确定的Android世界中安全发布。</p><pre class="ko kp kq kr gt ks kt ku kv aw kw bi"><span id="7b49" class="kx ky it kt b gy kz la l lb lc">postSafely(<strong class="kt iu">this</strong>::animate, 1, TimeUnit.<strong class="kt iu">SECONDS</strong>)</span></pre><p id="52c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">祝发帖愉快！</p><p id="e9eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，如果你能用腐蚀液延迟完成任务，会得到额外的奖励。</p></div></div>    
</body>
</html>