<html>
<head>
<title>Swift CoreNFC as quick as possible</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">尽可能快的Swift CoreNFC</h1>
<blockquote>原文：<a href="https://itnext.io/swift-corenfc-as-quick-as-possible-79544796cd0a?source=collection_archive---------0-----------------------#2018-12-27">https://itnext.io/swift-corenfc-as-quick-as-possible-79544796cd0a?source=collection_archive---------0-----------------------#2018-12-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/217234ac406e14cb6fa987b279207595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZEkkgVHCVDtdRSD7eHtcw.png"/></div></div></figure><p id="73d8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><strong class="ke iv"> NFC </strong>代表“近场通信”。当两个电子设备相距不到4厘米时，它们可以通过NFC传输数据。NFC可用于电子支付。它是多年前发明的，但自2016年iPhone7推出以来，它刚刚被苹果引入iPhone系列。要测试具有NFC功能的应用程序，必须使用真实设备，而不是iOS模拟器。</p><p id="92df" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi la translated"><span class="l lb lc ld bm le lf lg lh li di">要</span>设置NFC项目，在苹果开发者控制台中注册应用ID时，必须在“应用服务”会话中启用“NFC标签读取”。</p><figure class="lk ll lm ln gu jv gi gj paragraph-image"><div class="gi gj lj"><img src="../Images/1d0645dcab410901624cf5433046d1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*C2g-ehoGODUYZIvJT-HOuw.png"/></div><figcaption class="lo lp gk gi gj lq lr bd b be z dk translated">在Apple Developer Console中注册应用程序ID时，应用程序服务会话的屏幕截图</figcaption></figure><p id="9206" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi la translated"><span class="l lb lc ld bm le lf lg lh li di">其次，必须在应用目标会话的“功能”选项卡中启用“近场通信标签读取”。</span></p><figure class="lk ll lm ln gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj ls"><img src="../Images/34baa7662985a4ca1e32dbb723fb0d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8ohTYUWhg0xbY70gHTm8g.png"/></div></div><figcaption class="lo lp gk gi gj lq lr bd b be z dk translated">“功能”选项卡中的“近场通信标签读取”</figcaption></figure><p id="8113" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi la translated"><span class="l lb lc ld bm le lf lg lh li di"> T </span>第三，“隐私NFC扫描使用说明”必须添加到Info.plist中。否则，<code class="fe lt lu lv lw b">libsystem_kernel.dylib __pthread_kill</code>会终止应用程序，Xcode控制台不会显示错误消息。</p><figure class="lk ll lm ln gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj lx"><img src="../Images/58f814d1885c21dace8408aa057ea12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsm41aqnJyu2s2cwGrFbbA.png"/></div></div><figcaption class="lo lp gk gi gj lq lr bd b be z dk translated">Info.plist截图</figcaption></figure><p id="39c5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi la translated"><span class="l lb lc ld bm le lf lg lh li di">如果你的应用中的</span> NFC是一个可选功能，你可能希望那些没有NFC芯片的设备运行你的应用，那么在iOS 12 <strong class="ke iv">中CoreNFC.framework <strong class="ke iv">必须</strong>设置为<strong class="ke iv">“可选”</strong>。</strong></p><figure class="lk ll lm ln gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj ly"><img src="../Images/750d0a8acd82a581b5584595b9eddfa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNKGRJ7rltLU3Mp3vXlgow.png"/></div></div></figure><p id="5260" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">否则，应用程序将在启动时崩溃，并显示以下消息，显示“<strong class="ke iv">corenfc . framework”</strong>无法加载。</p><pre class="lk ll lm ln gu lz lw ma mb aw mc bi"><span id="c81c" class="md me iu lw b gz mf mg l mh mi"><strong class="lw iv">dyld: Library not loaded: /System/Library/Frameworks/CoreNFC.framework/CoreNFC</strong></span><span id="a7a9" class="md me iu lw b gz mj mg l mh mi"><strong class="lw iv">Referenced from: /var/containers/Bundle/Application/DF6D870C-4928-40F6-A242-BAB9C07B3737/BaseProject.app/BaseProject</strong></span><span id="e800" class="md me iu lw b gz mj mg l mh mi"><strong class="lw iv">Reason: image not found</strong></span></pre><h1 id="9fc8" class="mk me iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">现在就开始编码吧！</h1><figure class="lk ll lm ln gu jv"><div class="bz fq l di"><div class="nh ni l"/></div></figure><h1 id="9085" class="mk me iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated"><span class="l lb lc ld bm le lf lg lh li di">一</span>实施<code class="fe lt lu lv lw b">NFCNDEFReaderSessionDelegate</code></h1><figure class="lk ll lm ln gu jv"><div class="bz fq l di"><div class="nh ni l"/></div></figure><h1 id="880c" class="mk me iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">如何解释来自[NFCNDEFMessage]对象的NFC信息？</h1><p id="7604" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">NFC信息存储在<code class="fe lt lu lv lw b">NFCNDEFMessage</code>对象内<code class="fe lt lu lv lw b">record </code>的<code class="fe lt lu lv lw b">payload</code>中。</p><p id="d256" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">每个<code class="fe lt lu lv lw b">NFCNDEFMessage</code>对象包含一个“记录”列表，每个记录包含:<br/> 1。NSData形式的“有效载荷”包含标记消息<br/> 2。<br/> 3。<br/> 4【类型】。"标识符"</p><h2 id="fbea" class="md me iu bd ml no np dn mp nq nr dp mt kn ns nt mx kr nu nv nb kv nw nx nf ny bi translated">示例:</h2><ul class=""><li id="d4fa" class="nz oa iu ke b kf nj kj nk kn ob kr oc kv od kz oe of og oh bi translated">NFC标签原始消息:<strong class="ke iv">“ABC”</strong></li><li id="a0c0" class="nz oa iu ke b kf oi kj oj kn ok kr ol kv om kz oe of og oh bi translated">ASCII码的原始消息:<br/>—0:97[a]<br/>—1:98[b]<br/>—2:99[c]</li><li id="40d8" class="nz oa iu ke b kf oi kj oj kn ok kr ol kv om kz oe of og oh bi translated">在ASCII表中的<code class="fe lt lu lv lw b">NFCNDEFMessage<br/></code>的<code class="fe lt lu lv lw b">record</code>中扫描到<code class="fe lt lu lv lw b">payload </code>—0:2【文本开始】。<br/>—1:101【e】<br/>—2:110【n】<br/>—3:97【a】<br/>—4:98【b】<br/>—5:99【c】</li></ul><h2 id="e8a0" class="md me iu bd ml no np dn mp nq nr dp mt kn ns nt mx kr nu nv nb kv nw nx nf ny bi translated">为什么原始消息“abc”前面有“en”？</h2><blockquote class="on oo op"><p id="7af7" class="kc kd oq ke b kf kg kh ki kj kk kl km or ko kp kq os ks kt ku ot kw kx ky kz in bi translated">“所有语言代码都必须按照RFC 3066 [RFC3066]进行。不得省略语言代码。语言代码长度编码在状态字节的六个最低有效位中。因此，通过用值0x3F屏蔽状态字节很容易找到。<br/> — NFC数据交换格式(NDEF)技术规范，NFC论坛</p></blockquote><p id="7130" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因此，在转换为字符串进行显示之前，记录的有效载荷必须前进3！</p><pre class="lk ll lm ln gu lz lw ma mb aw mc bi"><span id="966d" class="md me iu lw b gz mf mg l mh mi">record.payload.advanced(by:3)</span></pre></div><div class="ab cl ou ov hy ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="in io ip iq ir"><h1 id="75fa" class="mk me iu bd ml mm pb mo mp mq pc ms mt mu pd mw mx my pe na nb nc pf ne nf ng bi translated">didDetectNDEFs的处理结果</h1><h2 id="d3eb" class="md me iu bd ml no np dn mp nq nr dp mt kn ns nt mx kr nu nv nb kv nw nx nf ny bi translated">情况1(使用参数初始化— <code class="fe lt lu lv lw b">invalidateAfterFirstRead: true)</code>):</h2><p id="6b32" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">如果使用<code class="fe lt lu lv lw b">invalidateAfterFirstRead</code>等于true初始化NFC读取器会话，在成功检测到标签并完成蓝色标记动画(持续约3秒)后，NFC标签读取对话框将自动关闭。</p><figure class="lk ll lm ln gu jv"><div class="bz fq l di"><div class="nh ni l"/></div></figure><p id="7f2d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">由于这3秒钟的时间间隔，UIAlertController出现，但被NFC标签读取对话框完全覆盖，用户无法与任何<code class="fe lt lu lv lw b">UIAlertAction</code>交互。这导致了糟糕的用户体验。见下图gif:</p><figure class="lk ll lm ln gu jv gi gj paragraph-image"><div class="gi gj pg"><img src="../Images/c9e4d764e01c0eef86e5b8997315bd13.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*RJ8GmnbrWnpJwHI0fCc11w.gif"/></div></figure><h2 id="0408" class="md me iu bd ml no np dn mp nq nr dp mt kn ns nt mx kr nu nv nb kv nw nx nf ny bi translated">情况2(使用参数初始化— <code class="fe lt lu lv lw b">invalidateAfterFirstRead: false)</code>):</h2><p id="3095" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">如果NFCNDEFReaderSession初始化为<code class="fe lt lu lv lw b">invalidateAfterFirstRead</code>等于假，可以手动关闭NFC读取标签对话框。</p><figure class="lk ll lm ln gu jv"><div class="bz fq l di"><div class="nh ni l"/></div></figure><p id="f6d5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然而，NFC会话实际上可以在蓝勾动画完成后被取消。因此，在显示UIAlertController之前调用<code class="fe lt lu lv lw b">nfcSession.invalidate()</code>并不能保证NFC标签读取对话框实际上已经关闭。这有大约0.5秒的时间间隔。因此，UIAlertController仍然在NFC标签读取对话框后面显示很短的一段时间。用户体验并不完美。</p><figure class="lk ll lm ln gu jv gi gj paragraph-image"><div class="gi gj pg"><img src="../Images/5f250dca4848eb4bfc33d665d8a930eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*QHcvReA68asH18xBxFzNcw.gif"/></div></figure><h2 id="6c19" class="md me iu bd ml no np dn mp nq nr dp mt kn ns nt mx kr nu nv nb kv nw nx nf ny bi translated">情况3(带参数初始化— <code class="fe lt lu lv lw b">invalidateAfterFirstRead: false + 1s delay)</code>):</h2><p id="1042" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">最后，提供最佳用户体验的解决方案是给DispatchQueue大约1秒的延迟，以确保在显示UIAlertController之前完全关闭NFC标签读取对话框。</p><figure class="lk ll lm ln gu jv"><div class="bz fq l di"><div class="nh ni l"/></div></figure><figure class="lk ll lm ln gu jv gi gj paragraph-image"><div class="gi gj pg"><img src="../Images/148653258c5fa9f7c255e0f18db4f86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*vdQO2rGiTOQ4raKd2X9Wxw.gif"/></div></figure><h1 id="6751" class="mk me iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">次要提醒:</h1><ol class=""><li id="d83a" class="nz oa iu ke b kf nj kj nk kn ob kr oc kv od kz ph of og oh bi translated">NFCNDEFReaderSession读取NFC标签的默认超时时间为60秒。下面是超时的错误消息。</li></ol><pre class="lk ll lm ln gu lz lw ma mb aw mc bi"><span id="2158" class="md me iu lw b gz mf mg l mh mi"><strong class="lw iv">Session is invalidated due to maximum session timeout</strong></span></pre><p id="6f3f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">2.NFC标签读取对话框中的警告消息针对3行文字进行了优化。第四行在末尾被截断。</p><figure class="lk ll lm ln gu jv gi gj paragraph-image"><div class="gi gj pi"><img src="../Images/6946d0847c1be7d63f244c7a560d692a.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*MvA6cO0gequXkOPplqadAA.png"/></div></figure><figure class="lk ll lm ln gu jv gi gj paragraph-image"><div class="gi gj pi"><img src="../Images/200793644608a759e755500f94b2574d.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*cMcvM1Qs4HokS5f1KKn5jg.png"/></div></figure><p id="175a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">3.NFC标签读取对话框和取消按钮的标题不可定制，区域设置固定为设备区域设置。</p><h1 id="3064" class="mk me iu bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">结论:</h1><ol class=""><li id="620e" class="nz oa iu ke b kf nj kj nk kn ob kr oc kv od kz ph of og oh bi translated">确保在Apple开发人员控制台为您的应用程序启用了“NFC标签读取”。</li><li id="46ea" class="nz oa iu ke b kf oi kj oj kn ok kr ol kv om kz ph of og oh bi translated">必须在应用程序功能列表中检查“近场通信标签读取”。</li><li id="8eea" class="nz oa iu ke b kf oi kj oj kn ok kr ol kv om kz ph of og oh bi translated">确保您的真实设备具有NFC芯片或将CoreNFC.framework设置为可选框架。</li><li id="3e45" class="nz oa iu ke b kf oi kj oj kn ok kr ol kv om kz ph of og oh bi translated">必须填写“隐私-NFC扫描使用说明”以请求使用用户NFC芯片的许可。</li><li id="48e4" class="nz oa iu ke b kf oi kj oj kn ok kr ol kv om kz ph of og oh bi translated">使用<code class="fe lt lu lv lw b">invalidateAfterFirstRead: false</code>创建NFCNDEFReaderSession，并延迟一秒钟来显示任何UIAlertController或导航到任何页面。</li><li id="276f" class="nz oa iu ke b kf oi kj oj kn ok kr ol kv om kz ph of og oh bi translated"><code class="fe lt lu lv lw b">didDetectNDEFs</code>回调在后台线程中运行，从不直接更新UI。</li></ol></div><div class="ab cl ou ov hy ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="in io ip iq ir"><p id="c1c4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">欢迎您在<a class="ae pj" href="https://twitter.com/myrick_chow" rel="noopener ugc nofollow" target="_blank">Twitter @ myrik _ chow</a>关注我，了解更多信息。感谢您阅读这篇文章。祝您愉快！😄</p></div></div>    
</body>
</html>