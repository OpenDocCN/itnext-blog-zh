<html>
<head>
<title>Thinking in styled-components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在样式组件中思考</h1>
<blockquote>原文：<a href="https://itnext.io/thinking-in-styled-components-e230ea37c52c?source=collection_archive---------3-----------------------#2018-10-13">https://itnext.io/thinking-in-styled-components-e230ea37c52c?source=collection_archive---------3-----------------------#2018-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dd0e72ec0d52a10787d01518c7c38085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTx4qqQp_rV1xT2tUGU7QQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">PB，思考JS中的CSS</figcaption></figure><p id="28e4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一年多以前，我在格蕾丝·赫柏学院为我的10分钟技术演讲寻找一个主题。对我们来说，这是一种深入探讨某个话题并作为新程序员练习说话的方式。就在那时，我偶然发现了来自React Conf的<a class="ae la" href="https://www.youtube.com/watch?v=jjN2yURa_uM" rel="noopener ugc nofollow" target="_blank">麦克斯·斯托伊伯的演讲</a>；我们刚刚开始学习React，我认为这种新的样式范例听起来非常有趣。</p><p id="99c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我开始在<a class="ae la" href="http://deciphernow.com" rel="noopener ugc nofollow" target="_blank">破译</a>时，我很兴奋地发现他们即将把他们的代码库从SCSS转移到样式化组件！从那时起，我就有了专门处理样式化组件的特权。DX是一种乐趣，我认为这将是一个完美的时间来写一些我在过去一年中发现的事情。</p><p id="1292" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文假设您对样式化组件有所了解。如果你对他们不熟悉，我会听听<a class="ae la" href="https://www.youtube.com/watch?v=jjN2yURa_uM" rel="noopener ugc nofollow" target="_blank">和</a>的对话，然后<a class="ae la" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank">查看他们的文档</a>。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="10e8" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">基于组件的体系结构</h1><p id="f5a1" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">顾名思义，styled-components允许我们把样式看作…组件。🤯这就要求我们转变对待CSS的方式。这意味着我们可以从组件架构最佳实践中吸取经验并加以应用。Max已经写了一篇关于这个的很棒的文章，但是我想分享一些我最近一直在思考的关于组件的想法。</p><p id="41e4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们先举个例子。拿这个<code class="fe ml mm mn mo b">ItemDisplay</code>组件来说:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/f67615a684dad41e90faba7fbb1b286b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ad0yWYmo6YTPDR-Hldxu_Q.png"/></div></div></figure><h2 id="eb57" class="mu lj iq bd lk mv mw dn lo mx my dp ls kn mz na lw kr nb nc ma kv nd ne me nf bi translated">单一责任</h2><p id="12cd" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">这个组件的道具表明它可以有一堆不同的状态，缺点是这样的组件鼓励开发人员对它进行变异，以至于它可能无法反映组件的初衷。因此，尽管我们<em class="ng">可以</em>创建极其灵活的组件，但这并不一定意味着我们应该这样做，因为这违反了单一责任原则:</p><blockquote class="nh ni nj"><p id="49f1" class="kc kd ng ke b kf kg kh ki kj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky kz ij bi translated"><em class="iq"/><strong class="ke ir"><em class="iq">单一责任原则</em> </strong> <em class="iq">是一条计算机编程原则，该原则规定每个模块或类应该对软件提供的功能的单一部分负责，并且该责任应该完全由该类封装。它的所有服务都应严格符合这一职责。— </em> <a class="ae la" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank"> <em class="iq">维基百科</em> </a></p></blockquote><p id="291e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，我并不是说你不应该为个人风格规则编写道具，这只是我通常试图避免的一种模式，我发现我几乎总能想出一个更好的解决方案，比如<a class="ae la" href="https://www.styled-components.com/docs/basics#extending-styles" rel="noopener ugc nofollow" target="_blank">扩展组件</a>或者使用内联风格进行非常小的调整。关于样式化组件，需要知道的一件重要事情是，它们总是会通过<a class="ae la" href="https://github.com/emotion-js/emotion/blob/master/packages/is-prop-valid/src/props.js" rel="noopener ugc nofollow" target="_blank">已知的HTML属性</a>传递给呈现的标记，比如<code class="fe ml mm mn mo b">style</code>。你总是把它作为逃生出口。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/81ae7438fc431942d7d06f40c192e189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDNhtooGhYnkvpqb6W_NLw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用内嵌样式进行细微调整</figcaption></figure><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/4c1e2dcaac5a2149ed0c2e14f4fec091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qj-uQDXSaNb8nImM4LSWBg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">当您有多个规则时，扩展组件</figcaption></figure><p id="7714" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个组件应该做一件事，而且应该做好。将样式组件保持在大约50行或更少对我们来说效果很好。当它由于许多不同的状态或针对子元素而变得更大时，最好将认知复杂性保持在最低水平，并将组件分解成更小的块。</p><h2 id="922f" class="mu lj iq bd lk mv mw dn lo mx my dp ls kn mz na lw kr nb nc ma kv nd ne me nf bi translated">包装</h2><p id="a961" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">这更像是一个面向对象的概念，但我认为它在这里也有含义。一个组件代表一个接口，它允许开发者使用它的功能，而不需要知道实现的细节。它不公开内部函数、变量或状态的细节。</p><p id="fd9c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，<code class="fe ml mm mn mo b">ItemDisplay</code>组件公开了所有的实现细节。封装是一个非常强大的工具，它让我们抽象出技术上的东西来创造一个更加人性化的体验。好好利用！</p><h2 id="6715" class="mu lj iq bd lk mv mw dn lo mx my dp ls kn mz na lw kr nb nc ma kv nd ne me nf bi translated">复用性</h2><p id="68b0" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">基于组件的架构的一个潜在危险是，尽管它鼓励可重用性和单一责任，但它可能导致其他问题。如果我们设计的东西太过可重用，最终会使我们的代码不可读。我试着仔细考虑组件的可重用性，我发现问自己以下问题很有帮助:</p><ol class=""><li id="20c2" class="no np iq ke b kf kg kj kk kn nq kr nr kv ns kz nt nu nv nw bi translated">已经有我可以重用或扩展的原始组件了吗？</li><li id="75da" class="no np iq ke b kf nx kj ny kn nz kr oa kv ob kz nt nu nv nw bi translated">组件是否有非常具体的用例？是否应该硬编码来满足这种情况？</li><li id="60fd" class="no np iq ke b kf nx kj ny kn nz kr oa kv ob kz nt nu nv nw bi translated">它需要在整个应用程序中重用吗？</li><li id="5559" class="no np iq ke b kf nx kj ny kn nz kr oa kv ob kz nt nu nv nw bi translated">它需要能够在任何环境下工作吗？(比如当我在为我们的<a class="ae la" href="https://github.com/DecipherNow/gm-ui-components" rel="noopener ugc nofollow" target="_blank">组件库</a>设计东西的时候。)</li></ol><p id="496a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简而言之，不要为了好玩而默认让东西可重用，因为有权衡。把东西做得越复用不一定越好。</p><p id="5f48" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Decipher，我们倾向于将原始的UI组件放在一个单独的库中，将应用范围内的组件放在一个顶级目录中，将一次性组件放在呈现它们的容器组件附近。</p><h2 id="8ec2" class="mu lj iq bd lk mv mw dn lo mx my dp ls kn mz na lw kr nb nc ma kv nd ne me nf bi translated">识别离散的用户界面状态</h2><p id="49fa" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">最后，当创建一个组件时，开始考虑一个组件需要满足的每个状态是有帮助的。例如，可能那个<code class="fe ml mm mn mo b">ItemDisplay</code>组件有一个默认状态和一个主要状态，您需要基于这两个状态派生样式。</p><p id="0965" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以再次将此与常规ol' React组件开发进行比较，即核心状态与派生状态的概念:</p><p id="9acb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">核心状态— </strong>表示用户界面所需的最小状态表示。</p><p id="033b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">派生状态— </strong>可以从核心状态派生的任何状态</p><p id="ac96" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了说明这一点，我们来看一个<code class="fe ml mm mn mo b">TodoList</code>组件。在state中，我会保存一个包含所有todos的数组。然后假设您必须根据数组中的项目数量呈现一些不同的UI。这里有一个非常糟糕的方法:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/f4921b565b35498c6516065ba5fe6f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XaFPEk8igNidR_BHsFqdg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">👎</figcaption></figure><p id="0fd9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我很确定我们中没有人会将todo的数目保持在状态中，特别是因为<em class="ng">我们永远不会从数组</em>中独立地改变那个数目。你可以通过计算数组的长度得到todos的数量。拥有这种“重复状态”意味着您需要确保同时更新两者，并在每一步保持它们同步。</p><p id="1c51" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在样式领域，我认为类似的想法是将离散的UI状态视为核心状态(比如我们的<code class="fe ml mm mn mo b">ItemDisplay</code>的<code class="fe ml mm mn mo b">primary</code>状态)，并将组成该UI状态的所有样式声明视为派生的。换句话说，派生的状态由单独的样式规则(高度、宽度、边距等)组成。).您不应该能够直接编辑该派生状态，因为它依赖于UI的状态。作为开发人员，想要完全控制组件的每一个方面是很诱人的，抵制这种冲动！</p><p id="c952" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里有一个更“面向状态”的<code class="fe ml mm mn mo b">ItemDisplay</code>可能是什么样子的例子。实现细节(样式规则)被封装，唯一的接口是一个<code class="fe ml mm mn mo b">primary</code>道具。我更喜欢保持个人风格规则的整洁，我认为这样会产生更干净、更易读的代码。我可以确切地看到在这个组件的两个离散状态中应用了什么样式:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/62c97555bf1087664917ecbf30f9062a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPIb4U_uiHfNO3f5kNgFJQ.png"/></div></div></figure><p id="f4f2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">换句话说，样式声明应该从UI状态“派生”而来。</strong></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="bd72" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">样式组件是一个强大的工具；希望这能给你一些充分利用它们的想法！</p><p id="ee3c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下是一些资源:</p><p id="e8e9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://www.smashingmagazine.com/2017/01/styled-components-enforcing-best-practices-component-based-systems/" rel="noopener ugc nofollow" target="_blank">风格化组件:在基于组件的系统中实施最佳实践</a></p><p id="0725" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://blog.elpassion.com/styled-components-nitty-gritty-2d74b8690ef8" rel="noopener ugc nofollow" target="_blank">风格化组件的本质</a></p><p id="c253" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://medium.com/styled-components/with-styled-components-into-the-future-d1d917e7c22c" rel="noopener">以风格化的组件走向未来</a></p></div></div>    
</body>
</html>