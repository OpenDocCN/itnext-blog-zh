# 是什么让 Go 成为最好的语言

> 原文：<https://itnext.io/what-makes-go-the-best-language-159322c2206a?source=collection_archive---------1----------------------->

![](img/474601d98ce44bb96c5ca43786b1893d.png)

这是一个关于 Go 编程语言好的和坏的方面的故事，关于它是改变的时候了，以及关于必须如何小心地处理这样的改变。这是 3 篇文章系列的第一部分。在这篇文章中，我们将设置场景，并讨论为什么对于许多用例来说，Go 可能是最佳选择。💡⭐

## **本系列更多内容**

*   [是什么让围棋成为最好的语言](https://medium.com/@avivcarmis/what-makes-go-the-best-language-159322c2206a)
*   [我们需要谈谈围棋的坏处](https://medium.com/@avivcarmis/we-need-to-talk-about-the-bad-sides-of-go-568a1e5adbc6)
*   [为了更好的未来的主张](https://medium.com/@avivcarmis/a-proposition-for-a-better-future-for-go-a0d0b43d086a)

在过去的几年里，Go 编程语言正以爆炸式的速度增长。大公司和小初创公司都热情地采用它，它越来越接近成为云原生系统的标准语言。它也是连续几年最想学的语言( [HackerRank study，2020](https://www.hackerrank.com/research/developer-skills/2020) )，甚至是增长最快的语言(根据[OSS study over GitHub repositories，2022](https://ossinsight.io/blog/explore-deep-in-4.6-billion-github-events/#go-the-new-favorite-and-the-fastest-growing-programming-language) )。

我们地鼠，我们绝对热爱这种语言…但我们也不断希望改变它(🤔🤷🏽‍♂️?).GitHub 有太多公开的问题，包括语言变化的提议，太多的在线讨论，以及压轴戏是最近推出的泛型，这是迄今为止最大的语言变化。这一变化将这个社区一分为二——一部分人热烈拥护这一变化，另一部分人认为这将永远改变这种语言。

Go 社区和它的维护者倾向于在语言提议上保持一致。他们应该这样做。它与语言最基本的原则密切相关，作为一个 Gopher，你必须在某种程度上同意它——这完全是关于简单性和可读性。

# 转折点

总的来说，我们都同意简单应该受到高度重视。代码应该比写起来更容易阅读。你怎么能反驳这种逻辑呢？每个专业开发人员都知道**你写一行代码一次，然后维护它**5 年。在一种非常宽松的语言中，您可能会尝试以一种非常奇特的方式编写那一行代码，然后其他人都在挠头试图弄明白它。包括六个月大的你。

你可以说我们都同意简单是重要的。然而，简单是有规模的，在某个时候，你开始**牺牲生产力**。📈📉这就是地鼠的不同之处。一些地鼠，甚至可能是我们大多数人，认为今天的语言是它应该在的地方。甚至可能在仿制药出现之前。任何进一步的添加都会损害可读性、生产率和可维护性。😵‍💫

其他地鼠认为这种语言应该支持新的特性。对于旨在提高生产率和减少仪式和代码重复的特性，有一个庞大的语言提案列表。为了简单起见，他们中的大多数都被拒绝了。在 Go Time 播客[最近的一集](https://changelog.com/gotime/224)中， [Kris Brandow](https://twitter.com/skriptble?t=bN6LZAwuTYGaSU6k4emxlw&s=09) 提到了这个确切的转折点，说“我认为是 Go 使用叉子的时候了”，这将允许保留该语言的原始设计，同时允许该语言的扩展风格得以发展。💡

如果这样的事件真的发生了，我相信这是围棋界的一个关键时刻。我相信这样一种新方言的设计者必须足够负责任地采纳一些建议和功能，但保留 Go 的核心价值观。这将决定 Go 和这样一个 fork 能否无缝交互，能否**共享相同的运行时环境、库和生态系统**。

这种负责任的决策制定对于确保我们**仍然是一个拥有单一生态系统的单一社区**，相信相同的核心理念，同时提供另一种风格，允许牺牲一些简单性来获得可维护性和运行时安全性。🛡️👷

这种举措有众所周知的、非常成功的先例。毫无疑问，由于 Scala 和 Kotlin，JVM 生态系统将会持续更长时间，并继续受到欢迎(在过去十年中，Java 受欢迎程度的下降被 Scala 的上升所取代，而在这十年中，Kotlin 的上升也是如此— [source](https://pypl.github.io/PYPL.html) )。所有三种语言都有助于**更强大的单一社区**，并获得更强大的库和集成。得益于 Typescript，JavaScript 无疑变得更加强大，它本身也迅速成为世界上最流行的语言之一。😱

我也相信这对我们地鼠来说是正确的。但是为什么我会这么想呢？而且为什么我觉得 Go 是这样一个二级方言的完美候选呢？我们将在这篇文章和接下来的文章中慢慢找到一个完整的答案，讨论这种语言的优缺点。

# 我为什么而战？

所以第一个浮现在脑海中的问题是——如果你不喜欢 Go，为什么不换一种不同的编程语言呢？一个支持更多特性和更具表达性的语法的版本。我将从个人的角度来回答这个问题，但我相信这个答案也抓住了许多其他地鼠的情绪。

# 简单

围棋最基本的思想之一是——**做一件事不应该有一种以上的方法**。个人非常赞同这一条。我已经浪费了太多时间来讨论用 JavaScript、Python 或其他功能丰富的语言编写的函数的编码选择。这样的讨论从来不是关于代码的完整性，也不是关于性能。通常，这些讨论都是关于光学和编码风格的。对我来说，这是浪费宝贵的工程时间，令人遗憾。但更重要的是，它极大地损害了可读性。习惯于以某种方式编写代码会使以其他方式阅读代码变得不必要的困难。😱我宁愿牺牲对闪亮、花哨的小技巧和快捷方式的支持，获得可靠性和可靠性。💪

这是 Go 哲学的基础，我相信这是编码中最强大的思想之一。

关于简单性，我想说几句关于单行代码文化的话。像 Python 和 JavaScript 这样的语言为开发人员经常滥用的函数式编程提供了丰富的([甚至语法上的](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions))支持。网上有很多例子(像[这个](https://www.reddit.com/r/learnpython/comments/2au257/python_oneliners_vs_readability/)和[这个](https://rainier.io/blog/python-one-liners))。首先，您会看到这个一行程序:

one_liner.py

并声称编写更少的代码行通常应该是一个目标。我不想羞辱任何特定的开发人员，相反，我想说这是社区的编码文化的**结果。显然，这对于任何语言来说都不一定是主流，但却被广泛使用。我相信我们都同意，这种编码会很快变得可读性差、可维护性差、调试困难，有时甚至会损害性能。Go 的可读性高于可写性的文化**鼓励相反的**，你很少会在 Go 代码库中遇到这种风格，也不会有地鼠提倡在尽可能少的行中填充尽可能多的逻辑。**

我很清楚这个特殊的例子和许多其他例子只是一个有趣的练习，但是我也知道这些习惯往往会成为真正的代码库。我自己犯了罪，我也看到许多人犯了罪。有时它只是有趣，其他时候它似乎“优雅”，或者只是太诱人而无法避免。

# 并发模型

我们这些地鼠，我们喜欢把“[本地并发](https://benjiv.com/go-native-concurrency-primitives/)”抛到空中，但是 Go 除了用[指定一个语言关键字](https://go.dev/tour/concurrency/1)来产生新线程之外，没有发明任何东西。大多数其他语言支持用一行代码生成新线程，没有外部依赖性。在这方面，围棋真的更本土化吗？此外，我们喜欢嘀咕 **goroutines** 和**频道**，但那些也没那么特别。通道仅仅是阻塞队列，而 goroutines 只是协程的副产品，这个概念从 50 年代就已经存在了。😱

那么关于 Go 的并发模型有什么*特别之处呢？快速回答— ‏of 所有流行语言中，Go 拥有最一致的并发模型。事实上，它是唯一拥有完全一致的并发模型的主要语言。还记得我们之前说过的不要有一种以上的表达方式吗？好吧，以下每种语言都至少有两种表达和管理并发的方式:C、C++、C#、Rust、Python、PHP、Ruby、Java、Kotlin 和 Scala。他们都有**阻塞**和**异步**API。*

在大多数情况下，如果您使用阻塞 API，您将无法充分利用您的资源。这意味着你要么太慢，要么太贵。[或两者都有](https://www.quora.com/What-are-the-advantages-of-non-blocking-IO/answer/Peter-Nierop?ch=15&oid=21577775&share=9b066d5b&target_type=answer)。

为了避免这种情况，现代应用程序倾向于使用异步 API，但是大量的问题和警告立即加入了这个组合。首先，并不总是很清楚一个函数或一个库实际上是否是异步的。编译器在这方面帮不了你，所以你必须依靠文档。如果文档没有说清楚，您会发现自己在钻研源代码。🥴🔫

通常，如果您在异步环境中错误地调用了**阻塞函数，这将是一个巨大的问题。一个极端的例子是 [Vertx](https://vertx.io/get-started/) 。Vertx 是一个异步 Java 框架，实现了类似于 JavaScript 的单线程事件循环。在这种架构中，单个线程一个接一个地处理所有的应用程序任务。这些任务触发非阻塞操作，并快速释放线程以继续执行队列中的下一个任务。如果这个线程挂起，**整个应用程序停止响应**。想象一下，有一个运行 Vertx 的生产实例，每秒处理数千个请求，由于意外调用了这个单线程上的阻塞函数而突然冻结了几秒钟。这可能会产生连锁反应，对生产环境来说是致命的。Vertx 的设计者甚至[监控事件循环线程](https://vertx.io/docs/vertx-core/java/#golden_rule)试图检测花费太长时间返回的函数调用。我没有深入实现，但我认为，除非关闭，否则它实际上会消耗生产资源来实现。在不断考虑这种潜在的危险时，您能满怀信心地编码并真正关注业务价值吗？每次你导入一个新的库，每次你调用一个新的函数。**恐怖的东西……🤡😨🤡****

让我们转到 JavaScript。哦，心爱的 JavaScript。它为并发提供了更加一致的运行时环境。你根本**不能执行阻塞呼叫**。自信如何？当着你的面，其他语言！😎😎等等，那是什么？语法和可读性问题困扰着我们[😨](https://emojipedia.org/fearful-face/)哦不，可读性现在很糟糕。甚至不可怕，是地狱。以至于 JavaScript 社区甚至将其称为“[回调地狱](http://callbackhell.com/)”。就像在其他语言中一样，编写和读取异步代码可能非常困难。在 JavaScript 中，这是无法忍受的，以至于社区在语言规范中增加了对承诺的本地支持([承诺和未来，起源于 70 年代](https://en.m.wikipedia.org/wiki/Futures_and_promises))。承诺增加了处理异步结果的灵活性，同时也提高了可读性。尽管如此，要跟踪复杂异步流的执行流程、正确推理它们或者识别问题几乎是不可能的。所以 JavaScript 更进了一步，增加了异步/等待支持([最初是在 2010 年早期的 C#中引入的](https://en.m.wikipedia.org/wiki/Async/await))。这个真的很棒。✔️✔️它给你一个阻塞代码的可读性和异步代码的性能。然而，我们最终用三种语法模型来处理并发性— **回调、承诺和异步/等待**。后者可能会成长为一个事实上的标准，但是遗留代码甚至是由生疏的开发人员编写的新代码将始终是一个潜在的有害的不一致。🪳令人讨厌地提醒着不同的日子。😑这也并不罕见。例如，NodeJS 本地 SDK 只提供了基于回调的 API。如果你写一个现代的应用程序，你要么使用第三方来适应你的并发模型，要么自己做。大多数库提供了几种并发模型，通常在一个统一的 API 中，这使得函数签名不直观，并且更难正确使用。

JavaScript 带来的另一个乐趣是它的单线程架构。由于 JavaScript 中的一切都是非阻塞的，理论上，我们可以使用

单线程并保持高性能，同时消除多线程环境的复杂性，如**竞争条件和死锁**。听起来不错，不是吗？💡毫无疑问，这是一个美丽的理论，也是大约十年前吸引包括我自己在内的许多开发人员使用 JavaScript 的原因。然而，问题是，实际上，阻塞 I/O 只是阻塞线程的一种方式，任何消耗 CPU 的操作都是如此。换句话说，尽管 JavaScript 不允许阻塞 I/O，但是您将要执行的任何 CPU 密集型操作都有可能**破坏您的应用程序性能**。💣🧨:现在你必须小心长时间运行的循环，哈希算法，正则表达式计算，任何有朝一日可能运行太长时间的东西。否则，你就有麻烦了。再一次，这是《T4》之前的恐怖故事。🤡😨🤡在不真正消耗 CPU 的情况下，提供商业价值能走多久？只要您执行一点 JSON 解析，或者使用 Redis 集群(它的客户端在每次调用时计算散列值)，这些都是非常基本的操作示例，会很快占用大量 CPU 资源。当他们这样做的时候，我的心为你们的基础设施工程师而去。💔

好吧。其他语言说够了，来说说围棋吧。对我来说，它的运行时是迄今为止构建可伸缩并发应用程序最强大和最可靠的。我说过，Go 是上面提到的所有语言中唯一一种并发模型完全一致的语言。为什么嗯，它只提供了一个阻塞 API。或者我应该说它只提供了一个异步 API？因为语法总是阻塞的。您永远不需要暂停、等待或传递回调。你调用一个函数，它返回一个值。这就像不涉及任何 I/O 操作一样清晰易读。然而，在引擎盖下……**一切都是完全异步的**。🚀Go runtime 通过实现协程来实现这一点，或者用 Go-Go routine 的话来说。在大多数语言中，生成一个新线程会导致分配一个新的操作系统线程。OS 线程不便宜。除了消耗资源之外，它们之间的上下文切换是非常昂贵的。当您使用它们来执行阻塞操作时，您实际上消耗了大量资源来等待 I/O 响应，而什么也不做。Go runtime 的做法不同。它可以让你旋转任意多的 goroutines，在内部它们是完全独立的，就像普通的线程一样，但是在外部，Go 只分配它实际需要的操作系统线程数量，有了这些，它**只执行异步系统调用**。在其他语言中旋转成千上万个线程，你会让大多数机器窒息。旋转数百万个 goroutines，你应该没问题。尝试一下，这是一个非常简单的测试。

强大的东西，是吧？代码简单，性能优化。💪但是等等，还有更多。Go 并不是第一种使用**协程**或任何种类的**虚拟**或**轻量级线程**的语言。然而，Go 是上面提到的语言中唯一一种从一开始就有这种权利的语言，而且这种权利从来没有改变过。结果是一个单一的、完全一致的模型——无论您使用哪个库，使用什么框架，它们都共享同一个模型，而且是最强大的模型。🤯💥即使 Go 在某一点上增加了对承诺的支持——它仅仅是一种跟踪正在运行的线程的执行的新方法，它不需要以任何方式改变形状、签名或被调用函数的行为。这就是简单。这就是自信。这是强大的。

哦，与其他垃圾收集语言相比，它也非常快。

# 社区和工具

最后，关于**社区和工具**，Go 不惧怕任何其他语言。这是一个非常谨慎的声明，许多地鼠，包括这只 one☝️，认为它们的某些方面比竞争对手更优越。对**剖析、代码格式化、数据竞争检测工具和基准测试工具**的内置支持，与编译器和没有**集中式注册表**的包管理器一起提供的都是这样的例子。我故意避免美化它们，因为每种工具都有优点和缺点，而且大多数语言都有自己整洁的工具集和丰富的社区。然而，至少可以说，Go 在这方面有很强的竞争力。

# 还有什么？

Gophers 还喜欢提到 Go 易于学习，可伸缩，有活跃的社区，速度快，要求高，垃圾收集，构建时间快，生成小的单文件二进制文件，可以在许多不同的环境中运行。我非常同意这些观点中的大部分，并且有许多文章将揭示更多有趣的 Go 特性。我想把重点放在使 Go 与众不同并优于其他语言的特殊能力上。

# 摘要

在本文中，我们讨论了 Go 社区的现状和对变革的呼吁，并展示了 Go 更强大的一面——是什么使它成为一种特殊的语言，是什么使它的运行时成为编写和运行可伸缩且可靠的应用程序的独一无二的强大环境。

在接下来的文章中，我们将讨论语言的弱点——让地鼠要求改变的主要焦点领域。