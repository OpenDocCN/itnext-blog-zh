<html>
<head>
<title>Testing the parcel bundler with vue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用vue测试包裹捆扎机</h1>
<blockquote>原文：<a href="https://itnext.io/testing-the-parcel-bundler-with-vue-7aa371e5664a?source=collection_archive---------3-----------------------#2018-07-30">https://itnext.io/testing-the-parcel-bundler-with-vue-7aa371e5664a?source=collection_archive---------3-----------------------#2018-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0107266ab79586f83b69c68507c49811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i5_aFPFngl5kX3yYSaLYwQ.png"/></div></div></figure><p id="888f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个图书馆需要一个构建步骤的时代(即使你可以不用它来使用它们，来吧，这样做更好)，我想谈谈<a class="ae kw" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">package bundler</a>。</p><p id="ce68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基线是:<strong class="ka ir">超快，零配置web应用捆绑器</strong>。</p><p id="d8a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是怎么回事？</p><h1 id="6ae8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">捆绑销售的历史</h1><p id="b828" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我觉得在谈论Parcel要解决的问题之前，知道我们从哪里来是很重要的。</p><p id="0e17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我个人对如何实现这一目标的看法🤓</p><ol class=""><li id="2981" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">一开始，捆绑并不是一件事:只要在HTML中引用javascript/CSS文件就可以了(从某种意义上说，那是美好的旧时光(但该死的，我讨厌IE6))。</li><li id="f7c1" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">然后我们开始关注文件大小，我们<a class="ae kw" href="https://en.wikipedia.org/wiki/Minification_(programming)" rel="noopener ugc nofollow" target="_blank">用非JS工具</a>缩小它们(例如<a class="ae kw" href="https://developers.google.com/closure/compiler/" rel="noopener ugc nofollow" target="_blank"> Google Clojure编译器</a></li><li id="68bd" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">然后我们开始使用<a class="ae kw" href="https://drupalize.me/videos/what-css-preprocessor?p=1175" rel="noopener ugc nofollow" target="_blank"> CSS预处理器</a>，它通过非JS工具(例如<a class="ae kw" href="https://sass-lang.com/ruby-sass" rel="noopener ugc nofollow" target="_blank"> Ruby-Sass </a>)添加了许多便利的东西(主要是变量、选择器嵌套&amp; import)</li><li id="a5e6" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">然后<a class="ae kw" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> node.js </a>来了，我们使用它的无限能量⚡️来处理依赖关系&amp;工具</li><li id="df23" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">然后<a class="ae kw" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank"> Browserify </a>来了，我们开始以这种方式捆绑我们的Javascript:<br/>更好的依赖性管理和将我们的JS代码分割成多个文件的可能性</li><li id="8bc9" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">然后像<a class="ae kw" href="https://gruntjs.com/" rel="noopener ugc nofollow" target="_blank"> Grunt </a>或<a class="ae kw" href="https://gulpjs.com/" rel="noopener ugc nofollow" target="_blank"> Gulp </a>这样的构建工具让我们一起协调所有的构建步骤。<br/>好几次都是这样……</li><li id="c016" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">然后<a class="ae kw" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应过来</a>出现了。即使它只是比以前的框架更进了一步(像主干框架或组件框架)，完整的组件方式让人们想要捆绑东西，不是基于语言，而是基于组件</li><li id="c2d9" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">于是<a class="ae kw" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>出现了。<br/>完成了一项惊人的工作，同时也克服了有时很棘手的<a class="ae kw" href="https://webpack.js.org/configuration/#options" rel="noopener ugc nofollow" target="_blank">配置</a>(团队正在努力解决这个问题💪)</li><li id="7a90" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">然后出现了针对每个框架的<a class="ae kw" href="https://en.wikipedia.org/wiki/Command-line_interface" rel="noopener ugc nofollow" target="_blank"> CLI </a>来简化webpack的使用。<br/>工具配置工具使用其他工具。</li><li id="71b6" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">而最近<strong class="ka ir">包裹</strong>出现了一个<strong class="ka ir">没有配置的承诺</strong></li></ol><p id="86e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这并不是说我们不再喜欢简单的东西(没有人喜欢构建步骤)，而是我们的需求<em class="mo">与</em>浏览器本身能做的并不匹配:</p><ul class=""><li id="a4ab" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mp mg mh mi bi translated">直到最近才有Javascript模块</li><li id="4ea7" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated">直到最近才出现CSS变量</li><li id="85b0" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated">等等。</li><li id="ab2c" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated">还有一些永远不会登陆浏览器的东西，比如:<br/>–<a class="ae kw" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank">JSX</a><br/>–<a class="ae kw" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a></li></ul><p id="502e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们仍然需要支持传统的浏览器。</p><p id="f139" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我很确定使用一个<em class="mo">在任何情况下都能工作</em>的东西仍然是每个开发人员的梦想(在<a class="ae kw" href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f" rel="noopener ugc nofollow" target="_blank">JavaScript</a><a class="ae kw" href="https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4" rel="noopener">fatigue</a>帖子中经常出现<em class="mo"/>)。</p><p id="4664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，网络社区正在推动本地工具的发展。</p><p id="cbc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">毕竟:</p><ul class=""><li id="904d" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mp mg mh mi bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll" rel="noopener ugc nofollow" target="_blank">document . query selector all</a>只是<a class="ae kw" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>的思想原生实现</li><li id="2d46" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank"> JS箭头功能</a>灵感来自Coffeescript的<a class="ae kw" href="https://coffeescript.org/#functions" rel="noopener ugc nofollow" target="_blank">功能</a></li><li id="2954" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated">JS模块和CSS自定义属性⏪。</li></ul><p id="f784" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Web组件</a>将成为React/Angular/Vue的原生解决方案的等价物(即使我认为它们会坚持下去，因为它们可以提供许多其他好处)</p><h1 id="16d8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么捆绑vue</h1><p id="177a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果我们看一下<a class="ae kw" href="https://vuejs.org/v2/guide/single-file-components.html#ad" rel="noopener ugc nofollow" target="_blank"> vue的单个文件组件</a>，我们可以看到:</p><ul class=""><li id="a39b" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mp mg mh mi bi translated"><strong class="ka ir">模板</strong>可以是<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTML" rel="noopener ugc nofollow" target="_blank"> HTML </a>或<a class="ae kw" href="https://pugjs.org/api/getting-started.html" rel="noopener ugc nofollow" target="_blank"> Pug模板</a></li><li id="682f" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated"><strong class="ka ir">样式</strong>可以是<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/CSS" rel="noopener ugc nofollow" target="_blank"> CSS </a>、<a class="ae kw" href="https://postcss.org/" rel="noopener ugc nofollow" target="_blank"> PostCSS </a>、<a class="ae kw" href="http://lesscss.org/" rel="noopener ugc nofollow" target="_blank"> less </a>、<a class="ae kw" href="https://sass-lang.com/" rel="noopener ugc nofollow" target="_blank"> SASS/SCSS </a>或<a class="ae kw" href="http://stylus-lang.com/" rel="noopener ugc nofollow" target="_blank">手写笔</a>是否支持<a class="ae kw" href="https://vue-loader.vuejs.org/en/features/scoped-css.html" rel="noopener ugc nofollow" target="_blank">样式范围</a></li><li id="c006" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated"><strong class="ka ir">脚本</strong>可以是<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>(支持最新添加的语言有<a class="ae kw" href="http://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a>)或<a class="ae kw" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">类型脚本</a></li></ul><p id="870f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以它是测试package捆绑任何东西的能力的一个很好的候选😎</p><h1 id="db25" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包裹</h1><p id="4da1" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">关于包裹没什么可学的。<br/>他们说<strong class="ka ir">简单</strong>简单就是简单:看看<a class="ae kw" href="https://parceljs.org/cli.html#options" rel="noopener ugc nofollow" target="_blank">小选项</a>有多少！</p><p id="ad4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主要是(从官方文件中复制和剪裁):</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1454" class="mz ky iq mv b gy na nb l nc nd">const options = {<br/> outDir: "./dist", <br/> outFile: "index.html", <br/> publicUrl: "./", <br/> target: "browser" <br/>};</span></pre><p id="8d8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。</p><p id="acf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你不害怕空虚🌑。</p><h1 id="0492" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">主要用途</h1><p id="a731" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">只需指定一个入口文件(HTML、JS或CSS ),它就会抓取所有的依赖项并捆绑它们。<br/>就这样。</p><p id="61ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能需要安装其他的<a class="ae kw" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM软件包</a>，我发现这个软件包试图<a class="ae kw" href="https://parceljs.org/hmr.html#automagically-installed-dependencies" rel="noopener ugc nofollow" target="_blank">为你安装其中的一些</a>。这真是个好主意！</p><p id="6c85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，能够在开发中运行<a class="ae kw" href="https://parceljs.org/hmr.html" rel="noopener ugc nofollow" target="_blank">热模块替换</a>服务器是开始编写web应用程序的快捷方式。</p><h1 id="fb23" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">转换配置</h1><p id="ce9d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Parcel会将一些配置传递给它在内部使用的工具:</p><ul class=""><li id="1c84" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mp mg mh mi bi translated"><a class="ae kw" href="https://parceljs.org/transforms.html#babel" rel="noopener ugc nofollow" target="_blank">。巴别塔的babelrc </a></li><li id="2fda" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated"><a class="ae kw" href="https://parceljs.org/transforms.html#posthtml" rel="noopener ugc nofollow" target="_blank">。post html的post tmlrc</a></li><li id="4fda" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated">等等。</li></ul><p id="f479" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这有时会导致一些奇怪的问题</p><p id="793f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要注意的是，目前(2018年8月)<a class="ae kw" href="https://github.com/parcel-bundler/parcel/issues/868" rel="noopener ugc nofollow" target="_blank">package依赖于Babel 6 </a>而不是<a class="ae kw" href="https://www.npmjs.com/package/@babel/core/v/7.0.0-beta.55" rel="noopener ugc nofollow" target="_blank"> Babel 7 </a>(仍在测试中，但工作正常)</p><p id="d15d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是<em class="mo">【引擎盖下】</em>解决方案(包括CLI)中常见的一个小问题，在阅读<code class="fe ne nf ng mv b">package.json</code>(或者一些github问题)之前，你永远不知道发生了什么。</p><h1 id="283f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">代码分割</h1><p id="528f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">像每个捆扎机一样，包裹<a class="ae kw" href="https://parceljs.org/code_splitting.html" rel="noopener ugc nofollow" target="_blank">支撑着它</a>。他们依靠JS语言的未来补充<a class="ae kw" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank">来做到这一点。</a></p><p id="980e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为是在第三阶段，所以语法在将来不会改变，现在使用它是安全的，不用考虑重构，因为规范在以后会改变👌</p><h1 id="ca31" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">简单被打破的地方</h1><p id="2b41" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我能够在瞬间设置一个开发Vue应用程序。Vue支持的每样东西似乎都能无缝地工作。</p><p id="a922" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，这是一个真正的时间节省和Vue生态系统的一个很好的切入点。</p><p id="3268" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是<strong class="ka ir">承诺的<em class="mo">【简单性】</em>作为一些弊端:</strong></p><ul class=""><li id="b903" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mp mg mh mi bi translated">当你遇到问题时，很可能你需要等待一个新的版本</li><li id="34aa" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated">例如，我在生产模式下构建和缩小<code class="fe ne nf ng mv b">.vue</code>文件时遇到了一些问题…</li></ul><p id="ecb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">从html文件构建时:</strong></p><ul class=""><li id="c165" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mp mg mh mi bi translated">包裹不能简单地忽略资产:一个<code class="fe ne nf ng mv b">manifest.webmanifest</code>文件将被转换成<code class="fe ne nf ng mv b">manifest.b01ff217.js</code> …</li><li id="bb60" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated"><a class="ae kw" href="https://github.com/parcel-bundler/parcel/issues/301" rel="noopener ugc nofollow" target="_blank">不支持PWA</a>，由于每个资源都被解析，所以不能包含<a class="ae kw" href="https://developers.google.com/web/tools/workbox/" rel="noopener ugc nofollow" target="_blank">工具箱</a>生成的PWA文件(同上)</li></ul><p id="a7e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我下定决心:</p><ul class=""><li id="2d0e" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mp mg mh mi bi translated">为开发编写一个简单的<code class="fe ne nf ng mv b">html</code>文件(这是我的切入点)</li><li id="928f" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mp mg mh mi bi translated">编写另一个生产文件<code class="fe ne nf ng mv b">html</code>并将我的入口点转移到我的JS文件，这样它就不会解析我的HTML代码</li></ul><h1 id="a9f3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我没有测试的东西</h1><p id="a4c6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">将node.js应用程序与其捆绑在一起。如果您在客户机和服务器之间共享大量代码，并且希望您的服务器代码尽可能快地运行，这将非常有用。</p><p id="3a19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它有一个<a class="ae kw" href="https://parceljs.org/cli.html#target" rel="noopener ugc nofollow" target="_blank">目标</a>参数。但是我不确定我能不能用它做变量或者模块替换。</p><p id="331a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我构建我的<a class="ae kw" href="https://hiswe.github.io/2018/08-universal-application/" rel="noopener ugc nofollow" target="_blank">通用网络应用</a>(坏主意，不要在家里做，使用<a class="ae kw" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> next.js </a>或<a class="ae kw" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> nuxt </a>)时，我不得不真正改进我的构建配置。我不知道只使用包裹是否可行。</p><h1 id="8479" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="624a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka ir">包裹很有前途</strong>很年轻。<br/>❤️团队正在做一项了不起的工作，他们正朝着好的方向推进捆绑销售:简单而有效🎉。</p><p id="1ec4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于大型项目，我不会建议这样做。我认为，就目前而言，框架的CLI更可靠。</p><p id="9a1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在将来，如果我能够在我的所有项目中使用相同的简单捆绑工具，我会努力的！(我是个懒虫🐮不得不阅读另一个CLI文档不是我的专长)。</p><p id="f097" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我真的希望他们能继续努力开发这样一个雄心勃勃的开源项目。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="7c50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">原载于</em><a class="ae kw" href="https://hiswe.github.io/2018/11-parcel-with-vue/" rel="noopener ugc nofollow" target="_blank"><em class="mo">hiswe . github . io</em></a><em class="mo">。</em></p></div></div>    
</body>
</html>