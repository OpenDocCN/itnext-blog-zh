<html>
<head>
<title>Entity Framework Core: Postgres Concurrency Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体框架核心:Postgres并发检查</h1>
<blockquote>原文：<a href="https://itnext.io/entity-framework-core-postgres-concurrency-checks-aeccdf17d224?source=collection_archive---------4-----------------------#2019-01-13">https://itnext.io/entity-framework-core-postgres-concurrency-checks-aeccdf17d224?source=collection_archive---------4-----------------------#2019-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/443241215ae8b749494cb2b4a53d856e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pK0N3brZvOLAk_oPB3qhFg.png"/></div></div></figure><p id="dc04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上周关于<a class="ae kw" href="https://elanderson.net/2018/12/entity-framework-core-sqlite-concurrency-checks/" rel="noopener ugc nofollow" target="_blank"> SQLite并发检查</a>的帖子使用了<a class="ae kw" href="https://github.com/elanderson/ASP.NET-Core-Entity-Framework" rel="noopener ugc nofollow" target="_blank">这个</a> repo，它包含了使用实体框架核心与SQLite和Postgres的例子。这篇文章将使用Postgres来处理并发检查，以保持repo中的项目具有相同的功能级别。您可以在任何更改之前获取示例代码<a class="ae kw" href="https://github.com/elanderson/ASP.NET-Core-Entity-Framework/tree/d1415d23f00117e3fb727d428dbdd7664ee17a0d" rel="noopener ugc nofollow" target="_blank">这里</a>。这整个职位将只是触摸文件中发现的Postgres文件夹/项目。</p><h2 id="98c8" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">上下文变化和数据迁移</h2><p id="775a" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">与SQLite不同，Postgres对并发检查有更好的内置支持。如果您阅读关于<a class="ae kw" href="http://www.npgsql.org/efcore/misc.html#optimistic-concurrency-and-concurrency-tokens" rel="noopener ugc nofollow" target="_blank">开放式并发和并发令牌</a>的官方文档，您会发现所有的表都有一个隐式/隐藏的系统列调用<a class="ae kw" href="https://www.postgresql.org/docs/current/ddl-system-columns.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> xmin </strong> </a>，它保存最新更新事务的ID，这意味着每当一行被更改时，它都会自动更改。</p><p id="0a6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Postgres实体框架核心提供了一个扩展，使得使用xmin列作为并发令牌变得非常简单。在<strong class="ka ir"> ContactDbContext </strong>中，将以下内容添加到<strong class="ka ir"> OnModelCreating </strong>函数中，以启用指定实体上的并发检查，在本例中，是一个<strong class="ka ir">联系人</strong>。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5649" class="kx ky iq ma b gy me mf l mg mh">modelBuilder.Entity&lt;Contact&gt;().ForNpgsqlUseXminAsConcurrencyToken();</span></pre><p id="60f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，在与项目文件位于同一目录的命令提示符下，使用以下命令。NET CLI命令为上述更改生成迁移。这种迁移有点奇怪，因为从技术上来说该列已经存在，但迁移似乎是必要的。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="1c33" class="kx ky iq ma b gy me mf l mg mh">dotnet ef migrations add Concurrency --context ContactsDbContext</span></pre><p id="3eba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，使用以下命令将迁移应用到您的数据库。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="d2a9" class="kx ky iq ma b gy me mf l mg mh">dotnet ef database update --context ContactsDbContext</span></pre><h2 id="780e" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">测试它</h2><p id="dc85" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">为了快速测试，我在<strong class="ka ir">联系人</strong>目录下添加了一个<strong class="ka ir">并发测试</strong> razor页面。这个函数将确保特定的contact存在，然后从两个不同的DBContexts中提取contact，对产生的contact对象进行变异，然后尝试保存。第一次保存会成功，第二次应该会失败。请注意，这个函数不是一个应该如何做的例子，只是一个快速和肮脏的方法来证明并发检查正在发生。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="6413" class="kx ky iq ma b gy me mf l mg mh">public void OnGet()<br/>{<br/>    var context1 = <br/>        new ContactsDbContext(new DbContextOptionsBuilder&lt;ContactsDbContext&gt;()<br/>                              .UseNpgsql("yourConnectionString")<br/>                              .Options);<br/>    var contactFromContext1 = context1.Contacts<br/>                                      .FirstOrDefault(c =&gt; c.Name == "Test");<br/><br/>    if (contactFromContext1 == null)<br/>    {<br/>        contactFromContext1 = new Contact<br/>                              {<br/>                                  Name = "Test"<br/>                              };<br/><br/>        context1.Add(contactFromContext1);<br/>        context1.SaveChanges();<br/>    }<br/><br/>    var context2 = <br/>        new ContactsDbContext(new DbContextOptionsBuilder&lt;ContactsDbContext&gt;()<br/>                              .UseNpgsql("yourConnectionString")<br/>                              .Options);<br/>    var contactFromContext2 = context2.Contacts<br/>                                      .FirstOrDefault(c =&gt; c.Name == "Test");<br/><br/>    contactFromContext1.Address = DateTime.Now.ToString();<br/>    contactFromContext2.Address = DateTime.UtcNow.ToString();<br/><br/>    context1.SaveChanges();<br/>    context2.SaveChanges();<br/>}</span></pre><p id="c4e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行应用程序并点击<strong class="ka ir">concurrency test</strong>路径，对于我的测试，该路径是<a class="ae kw" href="https://localhost:44324/Contacts/ConcurrencyTest" rel="noopener ugc nofollow" target="_blank">https://localhost:44324/Contacts/concurrency test</a>。下面是产生的异常。</p><h1 id="568b" class="mi ky iq bd kz mj mk ml lc mm mn mo lf mp mq mr li ms mt mu ll mv mw mx lo my bi translated">处理请求时出现未处理的异常。</h1><blockquote class="mz na nb"><p id="e0a2" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">DbUpdateConcurrencyException:数据库操作预期影响1行，但实际影响了0行。自实体加载后，数据可能已被修改或删除。关于理解和处理开放式并发异常的信息，请参见http://go.microsoft.com/fwlink/?LinkId=527962<a class="ae kw" href="http://go.microsoft.com/fwlink/?LinkId=527962" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><h2 id="2535" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">包扎</h2><p id="4c0e" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">这个过程使用Postgres比SQLite简单得多。不是说SQLite版本很难，只是路径不那么简单。</p><p id="ee00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终状态的代码可以在这里找到<a class="ae kw" href="https://github.com/elanderson/ASP.NET-Core-Entity-Framework/tree/3ec54e6f58f81c312bd04938a4eedcf439acc22a" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="3b18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nc">最初发表于</em> <a class="ae kw" href="https://elanderson.net/2019/01/entity-framework-core-postgres-concurrency-checks/" rel="noopener ugc nofollow" target="_blank"> <em class="nc">埃里克·安德森</em> </a> <em class="nc">。</em></p></div></div>    
</body>
</html>