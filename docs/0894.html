<html>
<head>
<title>Learn the React Context API with a Practical Example You Can Bring to Your Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习React Context API，并将其应用到您的应用程序中</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-the-react-context-api-through-building-a-shared-snackbar-for-in-app-notifications-6c199446b80c?source=collection_archive---------0-----------------------#2018-06-14">https://itnext.io/understanding-the-react-context-api-through-building-a-shared-snackbar-for-in-app-notifications-6c199446b80c?source=collection_archive---------0-----------------------#2018-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dde5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为应用内通知构建共享素材UI Snackbar</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9be5f7ac8ea4a8d68d13cbf544901211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*tDxVH_WUqvu7fiNorh_EfQ.png"/></div></figure><h1 id="4c0b" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">前言</h1><p id="c35b" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">大多数应用程序需要一种方式，在通知发生时不引人注目地显示给用户。假设你正在进行八折销售，你想让你的用户一登录就知道，或者在他们提交反馈后，你想显示一条感谢信息。</p><p id="ad86" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">Material UI提供了一个snackbar组件，它非常适合这些类型的消息，所以我将在这个例子中使用它。也就是说，本文更多的是关于上下文API，而不是材料UI，用这种方法将材料UI换成任何其他组件库都非常简单。</p><p id="dea0" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">许多应用程序需要触发来自几十个不同组件的消息。React上下文API使得向所有组件提供对共享snackbar的访问变得非常简单，因此它们可以触发这些消息，而无需为每个消息实现单独的组件。以下是方法。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b564" class="kq kr it bd ks kt mq kv kw kx mr kz la jz ms ka lc kc mt kd le kf mu kg lg lh bi translated">我们正在建造的东西</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/208406b9b026554d08ed179a9b16dbfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/1*d8iHKTMYovt37-tA1pF4mQ.gif"/></div></figure><h1 id="5828" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">设置/依赖关系</h1><p id="7fb9" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章假设你已经有了一个React应用，并安装了<strong class="lk iu"> @material-ui/core 1.0.0+ </strong>和<strong class="lk iu"> @material-ui/icons 1.0.0+ </strong>作为依赖项。</p><h1 id="bd21" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">创造环境</h1><p id="4274" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们需要创建我们的上下文API <strong class="lk iu">提供者</strong>和<strong class="lk iu">消费者</strong>组件。<strong class="lk iu">提供者<em class="mw"> </em> </strong> <em class="mw">向所有<strong class="lk iu">消费者</strong>提供</em>我们的snackbar的状态，以及一些操作该状态的函数。这允许所有子组件访问和操作<strong class="lk iu">提供者</strong>的状态，不管它们在组件层次结构中有多深。不需要正确钻孔！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ce95" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">第一步是通过调用<em class="mw"> React.createContext() </em>创建一个上下文。返回的对象包含两个属性:提供者和使用者。我们使用这些来构建管理snackbar状态并与之交互的组件。</p><p id="82a9" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><em class="mw">从这里开始，当我使用术语“提供者”和“消费者”时，我指的是本节中的</em><strong class="lk iu"><em class="mw">SharedSnackbarProvider</em></strong><em class="mw">和</em><strong class="lk iu"><em class="mw">SharedSnackbarConsumer</em></strong><em class="mw">组件。</em></p><p id="6450" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">如您所见，我们的提供者是一个非常标准的组件。在它的<em class="mw">呈现</em>函数中，我们呈现了一个<strong class="lk iu"> SharedSnackbarContext。具有<em class="mw">值</em>属性的提供者</strong>组件。传递给<em class="mw"> value </em> prop的对象是消费者能够访问的对象，因此他们可以与我们的snackbar进行交互。由于缺乏更好的术语，这是我们共享的snackbar组件的<strong class="lk iu"> API </strong>。</p><p id="d305" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">注意第41行的<em class="mw"> TODO </em>。最终，我们将在中呈现实际的snackbar <em class="mw">,上下文提供者的<em class="mw">呈现</em>功能作为其子节点的兄弟。这确保了在呈现提供程序时，所有子级都将使用完全相同的snackbar组件。</em></p><h1 id="18a2" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">创建共享Snackbar组件</h1><p id="82d9" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们需要构建表示组件，负责根据提供者的状态呈现snackbar UI。该组件将使用消费者来访问呈现所需的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3f02" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">在这里，我们构建了一个组件，它在<strong class="lk iu"> SharedSnackbarConsumer </strong>组件内的函数中呈现snackbar UI。该函数的参数是我们从提供者公开的<em class="mw">值</em>属性对象。因此，当提供程序的状态更新时，它将触发snackbar组件重新呈现。</p><p id="306c" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在我们可以在提供者的<em class="mw"> render </em>函数中呈现这个组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="1c78" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">呈现提供者</h1><p id="1f33" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此时，我们几乎完成了基础设施。还有最后一件事要做，就是在我们的应用程序中呈现提供者。我将把提供者放在整个应用程序的根目录下，这样所有的孩子都可以访问snackbar。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="002d" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">从子组件打开Snackbar</h1><p id="4912" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，<strong class="lk iu"> ButtonA </strong>和<strong class="lk iu"> ButtonB </strong>可以渲染自己的UI，触发应用内消息，而不需要直接从应用的根接收道具！🤙</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="7eff" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">摘要</h1><p id="0e66" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总而言之，事情是这样的。</p><ol class=""><li id="d44a" class="mz na it lk b ll me lo mf lr nb lv nc lz nd md ne nf ng nh bi translated">首先，我们创建了一个<strong class="lk iu">上下文提供者</strong>组件，它管理snackbar的全局状态。</li><li id="be31" class="mz na it lk b ll ni lo nj lr nk lv nl lz nm md ne nf ng nh bi translated">然后，我们创建了一个组件，该组件根据提供者的状态呈现snackbar的UI。该组件通过<strong class="lk iu">上下文消费者</strong>在其呈现函数中订阅提供者状态。</li><li id="f075" class="mz na it lk b ll ni lo nj lr nk lv nl lz nm md ne nf ng nh bi translated">最后，我们呈现了两个按钮，它们用<em class="mw"> openSnackbar </em>函数更新了<strong class="lk iu">上下文提供者</strong>的状态，该函数通过<strong class="lk iu">上下文消费者</strong>传递给它们。这会导致更改向下传播到snackbar组件，从而触发重新渲染。</li></ol><p id="fbea" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">Material UI提供了许多我在这个例子中没有实现的snackbar特性，比如动作按钮和颜色定制。为了简单起见，我没有添加定制这些特性的功能。如果您真的想学习上下文API，那么自己添加该逻辑将是一个很好的下一步！</p><p id="80b6" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">非常感谢你花时间提升自己。如果你觉得这篇文章有用，我会欣然接受。在此期间，请花几秒钟时间关注我，了解更多精彩内容:</p><ul class=""><li id="014c" class="mz na it lk b ll me lo mf lr nb lv nc lz nd md nn nf ng nh bi translated"><a class="ae no" rel="noopener ugc nofollow" target="_blank" href="/a-quick-practical-use-case-for-es6-generators-building-an-infinitely-repeating-array-49d74f555666">ES6生成器的一个快速、实用的用例:构建一个无限重复的数组</a></li><li id="bf7b" class="mz na it lk b ll ni lo nj lr nk lv nl lz nm md nn nf ng nh bi translated"><a class="ae no" rel="noopener ugc nofollow" target="_blank" href="/building-a-toggled-mask-password-input-component-w-react-and-material-ui-f55e6bd73434">构建一个带有React和材质UI的“遮罩切换”密码输入组件</a></li></ul><p id="e3fb" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><strong class="lk iu">推特</strong>:<a class="ae no" href="https://twitter.com/ReisnerShawn" rel="noopener ugc nofollow" target="_blank">@ reisner Shawn</a><br/><strong class="lk iu">dev . to</strong>:<strong class="lk iu"/><a class="ae no" href="https://dev.to/sreisner" rel="noopener ugc nofollow" target="_blank">@ sreisner</a><strong class="lk iu"><br/>insta gram</strong>:<a class="ae no" href="https://www.instagram.com/shawn.webdev" rel="noopener ugc nofollow" target="_blank">@ Shawn . web dev</a></p><p id="76d5" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">编码快乐！</p></div></div>    
</body>
</html>