<html>
<head>
<title>C for JavaScript Developers. Memory Allocation. Pointers, Arrays, and Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向JavaScript开发人员的c。内存分配。指针、数组和字符串</h1>
<blockquote>原文：<a href="https://itnext.io/c-for-javascript-developers-memory-allocation-pointers-arrays-and-strings-bcf387ad7f44?source=collection_archive---------2-----------------------#2019-01-08">https://itnext.io/c-for-javascript-developers-memory-allocation-pointers-arrays-and-strings-bcf387ad7f44?source=collection_archive---------2-----------------------#2019-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5b8bef91c471b435df4a1e9949ad260f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pO0wvRzlzlsAYyC-g_yubA.jpeg"/></div></div></figure><p id="70d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有一些C语言的经验，那么你可能知道一个字符串只是一个由<code class="fe kw kx ky kz b">char</code>组成的数组，或者它可以用一个指向<code class="fe kw kx ky kz b">char</code>的指针来表示——因为指针和数组几乎是一回事，对吗？这在某种程度上是正确的，但现实稍微复杂一些。</p><p id="6c12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看几个例子(假设源文件总是叫main.c)。注意:我在Ubuntu Linux上使用gcc编译器，在不同的环境中可能会得到不同的结果。关于设置的更详细的解释，请参考我之前关于C的文章。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="a6e6" class="lj lk iq kz b gy ll lm l ln lo">#include &lt;stdio.h&gt;</span><span id="0e88" class="lj lk iq kz b gy lp lm l ln lo">int main() {<br/>  char str[3] = "cat";<br/>  puts(str);<br/>  return 0;<br/>}</span><span id="ef51" class="lj lk iq kz b gy lp lm l ln lo">&gt; gcc main.c -o out<br/>&gt; ./out<br/>cat�</span></pre><p id="d94b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里刚刚发生了什么？单词末尾的那个字符是哪里来的？</p><p id="b350" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再比如。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="6784" class="lj lk iq kz b gy ll lm l ln lo">int main(void) {<br/>  char *str = "cat";<br/>  str[0] = 'b';<br/>  return 0;<br/>}</span><span id="a2d3" class="lj lk iq kz b gy lp lm l ln lo">&gt; gcc main.c -o out<br/>&gt; ./out<br/>Segmentation fault (core dumped)</span></pre><p id="4846" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对前一个例子的修改。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="cb38" class="lj lk iq kz b gy ll lm l ln lo">int main(void) {<br/>  char str[] = "cat";<br/>  str[0] = 'b';<br/>  return 0;<br/>}</span><span id="047e" class="lj lk iq kz b gy lp lm l ln lo">&gt; gcc main.c -o out<br/>&gt; ./out</span></pre><p id="ae02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们简单地用数组替换了一个指针，它修复了分段错误。但是为什么呢？</p><p id="7aa4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三个例子。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="92dd" class="lj lk iq kz b gy ll lm l ln lo">#include &lt;string.h&gt;</span><span id="9817" class="lj lk iq kz b gy lp lm l ln lo">int main() {<br/>  char *str1 = "cat";<br/>  char *str2;<br/>  strcpy(str2, str1);<br/>  return 0;<br/>}</span><span id="012b" class="lj lk iq kz b gy lp lm l ln lo">&gt; gcc main.c -o out<br/>&gt; ./out<br/>Segmentation fault (core dumped)</span></pre><p id="f97e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于一个有经验的开发人员来说，不难看出我在上面的代码片段中犯了什么错误。但是坦率地说:如果您从更高级的语言结构(打印一个字符串、修改一个字符串、复制一个字符串)的角度来考虑这些代码，它们都是有意义的，但是输出与您所期望的相差甚远。</p><p id="285c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几个相关的问题:</p><ul class=""><li id="121d" class="lq lr iq ka b kb kc kf kg kj ls kn lt kr lu kv lv lw lx ly bi translated">为什么我们不能在函数内部声明一个未知大小的数组而不初始化它，就像这样:<code class="fe kw kx ky kz b">int arr[];</code>？</li><li id="f392" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">为什么<em class="me">可以</em>我们用未知大小的数组作为函数参数？</li><li id="252a" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">为什么数组不能作为函数返回值？</li><li id="68d2" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">如果我们比较两个字符串会发生什么:<code class="fe kw kx ky kz b">"cat" == "cat"</code>？这是真的还是假的？</li></ul><p id="a688" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用的三个概念(字符串、数组和指针)是C语言中最基本的东西，但是如果你试图用它们做任何事情而不了解它们在内存中是如何表示的，你很可能会得到我们刚刚看到的错误(或类似的错误)。当然，你可以学习一些该做的和不该做的事情来避免某些类型的错误，但是如果你学习基本原则，你会有更好的理解。</p><h1 id="62f2" class="mf lk iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">自动变量和堆栈</h1><p id="b143" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">如果任何类型的变量在函数中声明，并且没有关键字<code class="fe kw kx ky kz b">extern</code>或<code class="fe kw kx ky kz b">static</code>，那么它就是一个<em class="me">自动</em>变量。这意味着当执行进入声明该变量的块时，该变量的存储被自动<em class="me">分配</em>，当该块的执行结束时，它同样被自动<em class="me">释放。</em></p><p id="e64e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">变量作用域(源代码中变量可见的部分)和存储持续时间(内存中相应区域保持其值的时间)是相关但不同的概念，将在以后的文章中探讨。现在，让我们只关注自动存储持续时间。</p><p id="dae6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript中，我们不处理内存，所以如果我们声明一个变量，我们永远不用担心它是如何存储的或者存储在哪里。在C语言中并非如此——理解变量存储是如何组织的非常有用(也不太难)。</p><p id="704d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自动分配通常使用一个<em class="me">堆栈</em>来实现——一个保存局部变量和返回地址的特殊内存区域，也可能包含函数参数和返回值。</p><p id="417c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个详细的例子。这个程序不做任何有用的事情——我们只是通过它来理解堆栈上的内存分配是如何工作的。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="a5f6" class="lj lk iq kz b gy ll lm l ln lo">void one(void);</span><span id="044d" class="lj lk iq kz b gy lp lm l ln lo">void two(void);</span><span id="482d" class="lj lk iq kz b gy lp lm l ln lo">int main(void) {<br/>  one();<br/>  return 0;<br/>}</span><span id="7f29" class="lj lk iq kz b gy lp lm l ln lo">void one(void) {<br/>  long local1 = 1;<br/>  two();<br/>}</span><span id="9bc4" class="lj lk iq kz b gy lp lm l ln lo">void two(void) {<br/>  long local2 = 2;<br/>}</span></pre><p id="d08e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当程序在我的Linux机器上编译和链接时，它看起来是这样的:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="08c9" class="lj lk iq kz b gy ll lm l ln lo">00000000004004d6 &lt;main&gt;:<br/>  4004d6: push rbp<br/>  4004d7: mov rbp,rsp<br/>  4004da: call 4004e6 &lt;one&gt;<br/>  4004df: mov eax,0x0<br/>  4004e4: pop rbp<br/>  4004e5: ret</span><span id="f9ee" class="lj lk iq kz b gy lp lm l ln lo">00000000004004e6 &lt;one&gt;:<br/>  4004e6: push rbp<br/>  4004e7: mov rbp,rsp<br/>  4004ea: sub rsp,0x10<br/>  4004ee: mov QWORD PTR [rbp-0x8],0x1<br/>  4004f6: call 4004fe &lt;two&gt;<br/>  4004fb: nop<br/>  4004fc: leave<br/>  4004fd: ret</span><span id="7be7" class="lj lk iq kz b gy lp lm l ln lo">00000000004004fe &lt;two&gt;:<br/>  4004fe: push rbp<br/>  4004ff: mov rbp,rsp<br/>  400502: mov QWORD PTR [rbp-0x8],0x2<br/>  40050a: nop<br/>  40050b: pop rbp<br/>  40050c: ret<br/>  40050d: nop DWORD PTR [rax]</span></pre><p id="a149" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上是objdump的删节输出:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="764d" class="lj lk iq kz b gy ll lm l ln lo">&gt; gcc main.c -o out<br/>&gt; objdump -d -M intel — no-show-raw-insn out</span></pre><p id="208e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在手册页上阅读更多关于objdump及其选项的内容。</p><p id="fdcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">左边的地址是指令在执行时驻留的实际内存地址。你不必理解所有的命令，我们只看几行。</p><p id="2156" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的处理器(<a class="ae la" href="https://en.wikipedia.org/wiki/X86-64" rel="noopener ugc nofollow" target="_blank"> x86_64架构</a>)有许多寄存器，它们只是特殊的8或4字节存储单元，具有比主存储器快得多的访问时间，并使用助记符(<code class="fe kw kx ky kz b">rbp</code>、<code class="fe kw kx ky kz b">rsp</code>、<code class="fe kw kx ky kz b">eax</code>等)进行寻址。)而不是数字地址。</p><p id="3a1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">rbp</code>和<code class="fe kw kx ky kz b">rsp</code>是两个有特殊含义的8字节寄存器(分别称为基址指针和堆栈指针)。在程序执行过程中，这些寄存器的值以这样一种方式改变，即它们总是定义当前函数的<a class="ae la" href="https://en.wikipedia.org/wiki/Call_stack#Structure" rel="noopener ugc nofollow" target="_blank">堆栈帧</a>。</p><p id="ea22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，<code class="fe kw kx ky kz b">long</code>被选为源代码中的变量类型，因为它在64位机器上的大小是8字节，就像内存地址和寄存器<code class="fe kw kx ky kz b">rbp</code>和<code class="fe kw kx ky kz b">rsp</code>一样。我们可以在这里使用任何其他整数类型(如<code class="fe kw kx ky kz b">int</code>、<code class="fe kw kx ky kz b">short</code>或<code class="fe kw kx ky kz b">char</code>)，但是使用<code class="fe kw kx ky kz b">long</code>堆栈被很好地分成8字节的段，每个段保存一个值。</p><p id="42e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">4004e7: mov rbp,rsp</code>:将<code class="fe kw kx ky kz b">rsp</code>的值复制到<code class="fe kw kx ky kz b">rbp</code>。</p><p id="b0e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是执行上面一行代码后堆栈的样子(堆栈没有完整显示，只显示了相关部分):</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="0bca" class="lj lk iq kz b gy ll lm l ln lo"><strong class="kz ir">rbp == 0x7fffffffdc70<br/></strong>rsp == 0x7fffffffdc70</span><span id="6d21" class="lj lk iq kz b gy lp lm l ln lo">Address        | Value          |<br/>0x7fffffffdc78 | 0x400fdf       | &lt;- “main” function return address<br/>0x7fffffffdc70 | 0x7fffffffdc80 | &lt;- rbp and rsp both point here; the value stored at this memory location is the previous value of rbp (0x7fffffffdc80)</span></pre><p id="033f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们刚刚使<code class="fe kw kx ky kz b">rbp</code>和<code class="fe kw kx ky kz b">rsp</code>相等。<code class="fe kw kx ky kz b">rsp</code>总是指向栈顶，也就是它最小的地址(目前是0x7fffffffdc70)，因为<a class="ae la" href="https://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/" rel="noopener ugc nofollow" target="_blank">x86 _ 64上的栈向下增长</a>。</p><p id="490b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有例子中的运行时堆栈地址都是使用GNU调试器<a class="ae la" href="https://www.gnu.org/software/gdb/documentation/" rel="noopener ugc nofollow" target="_blank"> gdb </a>获得的。对其用法的解释超出了本文的范围。</p><p id="9ba0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">4004ea: sub rsp,0x10</code>:在更高级别的伪代码中，它读为<code class="fe kw kx ky kz b">rsp = rsp — 16</code>——为了在堆栈上为局部变量分配空间，<code class="fe kw kx ky kz b">rsp</code>减少了16。<code class="fe kw kx ky kz b">rbp</code>保持不变。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="9856" class="lj lk iq kz b gy ll lm l ln lo">rbp == 0x7fffffffdc70<br/><strong class="kz ir">rsp == 0x7fffffffdc60</strong></span><span id="f0cf" class="lj lk iq kz b gy lp lm l ln lo">Address        | Value          |<br/>0x7fffffffdc78 | 0x400fdf       |<br/>0x7fffffffdc70 | 0x7fffffffdc80 | &lt;- rbp still points here<br/><strong class="kz ir">0x7fffffffdc68 | cruft          |<br/>0x7fffffffdc60 | cruft          | &lt;- rsp points here</strong></span></pre><p id="7c62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“Cruft”意味着单元格可以保存任何值，但我们对它不感兴趣，因为我们不打算在写之前读取它。</p><p id="9844" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">4004ee: mov QWORD PTR [rbp-0x8],0x1</code> — <code class="fe kw kx ky kz b">rbp — 8</code>在函数<code class="fe kw kx ky kz b">one</code>的上下文中是变量<code class="fe kw kx ky kz b">local1</code>的位置。这一行是实际的<code class="fe kw kx ky kz b">long local1 = 1</code>初始化发生的地方。我们可以稍后改变变量的值——将会发生的是不同的值将被写入相同的内存位置，并且它将总是被寻址为<code class="fe kw kx ky kz b">rbp — 8</code>,因为当执行在<code class="fe kw kx ky kz b">one</code>内部时，<code class="fe kw kx ky kz b">rbp</code>的值不会改变。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="e2d6" class="lj lk iq kz b gy ll lm l ln lo">rbp == 0x7fffffffdc70<br/>rsp == 0x7fffffffdc60</span><span id="3f4a" class="lj lk iq kz b gy lp lm l ln lo">Address        | Value          |<br/>0x7fffffffdc78 | 0x400fdf       |<br/>0x7fffffffdc70 | 0x7fffffffdc80 | &lt;- rbp still points here<br/><strong class="kz ir">0x7fffffffdc68 | 1              | &lt;- local1 value<br/></strong>0x7fffffffdc60 | cruft          | &lt;- rsp points here</span></pre><p id="d93c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编译器在堆栈上分配了比我们的变量所需更多的空间，但这是由于<a class="ae la" href="https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf" rel="noopener ugc nofollow" target="_blank">堆栈对齐</a>的要求，我们不必担心这个问题。</p><p id="ed42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">4004f6: call 4004fe &lt;two&gt;</code> —我们正在进入功能<code class="fe kw kx ky kz b">two</code>。这里发生两件事:执行跳转到<code class="fe kw kx ky kz b">0x4004fe</code>(<code class="fe kw kx ky kz b">two</code>第一条指令的地址)，返回地址被压入堆栈。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="a2e4" class="lj lk iq kz b gy ll lm l ln lo">rbp == 0x7fffffffdc70<br/><strong class="kz ir">rsp == 0x7fffffffdc58</strong></span><span id="fcf7" class="lj lk iq kz b gy lp lm l ln lo">Address        | Value          |<br/>0x7fffffffdc78 | 0x400fdf       |<br/>0x7fffffffdc70 | 0x7fffffffdc80 | &lt;- rbp still points here<br/>0x7fffffffdc68 | 1              | &lt;- local1 value<br/>0x7fffffffdc60 | cruft          |<br/><strong class="kz ir">0x7fffffffdc58 | 0x400fb        | &lt;- "one" function return address; rsp points here</strong></span></pre><p id="c02a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">4004fe: push rbp</code> —将<code class="fe kw kx ky kz b">rbp</code>的当前值推送到堆栈上</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="03df" class="lj lk iq kz b gy ll lm l ln lo">rbp == 0x7fffffffdc70<br/><strong class="kz ir">rsp == 0x7fffffffdc50</strong></span><span id="2c17" class="lj lk iq kz b gy lp lm l ln lo">Address        | Value          |<br/>0x7fffffffdc78 | 0x400fdf       |<br/>0x7fffffffdc70 | 0x7fffffffdc80 | &lt;- rbp still points here<br/>0x7fffffffdc68 | 1              | &lt;- local1 value<br/>0x7fffffffdc60 | cruft          |<br/>0x7fffffffdc58 | 0x400fb        | &lt;- "one" function return address<br/><strong class="kz ir">0x7fffffffdc50 | 0x7fffffffdc70 | &lt;- rsp points here</strong></span></pre><p id="9531" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">4004ff: mov rbp,rsp</code> —将<code class="fe kw kx ky kz b">rsp</code>的值复制到<code class="fe kw kx ky kz b">rbp</code>。同样的事情发生在我们进入<code class="fe kw kx ky kz b">one</code>的时候。事实上，任何函数开始执行时都会执行该操作。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="6cb3" class="lj lk iq kz b gy ll lm l ln lo"><strong class="kz ir">rbp == 0x7fffffffdc50<br/></strong>rsp == 0x7fffffffdc50</span><span id="015b" class="lj lk iq kz b gy lp lm l ln lo">Address        | Value          |<br/>0x7fffffffdc78 | 0x400fdf       |<br/>0x7fffffffdc70 | 0x7fffffffdc80 |<br/>0x7fffffffdc68 | 1              | &lt;- local1 value<br/>0x7fffffffdc60 | cruft          |<br/>0x7fffffffdc58 | 0x400fb        | &lt;- "one" function return address<br/><strong class="kz ir">0x7fffffffdc50 | 0x7fffffffdc70 | &lt;- both rsp and rbp point here</strong></span></pre><p id="f9c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们不能再将<code class="fe kw kx ky kz b">local1</code>作为<code class="fe kw kx ky kz b">rbp — 8</code>来访问，但是没关系，因为变量超出了范围。记住源代码— <code class="fe kw kx ky kz b">local1</code>对于<code class="fe kw kx ky kz b">one</code>来说是本地的，所以当我们在<code class="fe kw kx ky kz b">two</code>内部时我们不能访问它。</p><p id="1db7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们刚刚看到的是<em class="me">自动</em>为<em class="me"> local1 </em>分配内存。在C代码中，我们只需声明它，由编译器为它留出内存(<code class="fe kw kx ky kz b">sub rsp, 0x10</code>)。</p><p id="006b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当<code class="fe kw kx ky kz b">one</code>的执行结束时，<code class="fe kw kx ky kz b">local1</code>的内存将被<em class="me">以类似的方式自动</em>释放:递增堆栈指针是<code class="fe kw kx ky kz b">leave</code>指令要做的事情之一。“解除分配”并不意味着该内存单元的值会立即改变，但从现在起它被视为cruft，可以随时更新。</p><h1 id="66ba" class="mf lk iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">两颗北极指极星</h1><p id="3775" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">配备了自动变量的知识，再来说指针。</p><p id="47a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">指针是一个固定大小为八个字节的变量(在64位机器上)。我们经常使用指针来访问向量数据(数组)，但本质上它们是标量值。我们可以将一个整型常量转换为指针类型——这是一个合理的操作。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="00f3" class="lj lk iq kz b gy ll lm l ln lo">void dummy_func(void) {<br/>  int *p = (int *) 123;<br/>}</span></pre><p id="3ab3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，如果我们将指针类型替换为“long ”,编译后的代码可能会完全相同:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="8f13" class="lj lk iq kz b gy ll lm l ln lo">void dummy_func(void) {<br/>  long p = (long) 123;<br/>}</span></pre><p id="1bdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第二个例子中，cast操作符是不必要的，我只是想指出这里的<code class="fe kw kx ky kz b">int *</code>可以直接用<code class="fe kw kx ky kz b">long</code>替换，因为这两种类型都占用了8个字节的内存。这8个字节由<em class="me">自动</em>分配，类似于上一节中的<code class="fe kw kx ky kz b">long</code>变量。</p><p id="0a0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，我们不会像那样使用指针，而是直接给它们赋值，因为如果我们试图用<code class="fe kw kx ky kz b">*</code>操作符<a class="ae la" href="https://stackoverflow.com/questions/4955198/what-does-dereferencing-a-pointer-mean" rel="noopener ugc nofollow" target="_blank">去引用</a>这样的指针，我们很可能会导致<a class="ae la" href="https://en.wikipedia.org/wiki/Segmentation_fault" rel="noopener ugc nofollow" target="_blank">分段错误</a>错误(因为地址123可能在<a class="ae la" href="https://en.wikipedia.org/wiki/Memory_protection" rel="noopener ugc nofollow" target="_blank">受保护的内存区域</a>)。</p><p id="60c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有几种方法可以让指针变得有用。例如，我们可以间接引用另一个变量。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="0ac5" class="lj lk iq kz b gy ll lm l ln lo">#include &lt;stdio.h&gt;</span><span id="8ec3" class="lj lk iq kz b gy lp lm l ln lo">void dummy_func(void) {<br/>  long i = 123;<br/>  long *p = &amp;i; // Initialize p with the address of i<br/>  printf("%ld\n", *p); // "123" will be printed<br/>}</span></pre><p id="1960" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建了两个<em class="me">自动</em>变量，第二个变量(<code class="fe kw kx ky kz b">p</code>)保存第一个变量的地址，因此堆栈可能如下所示:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="de67" class="lj lk iq kz b gy ll lm l ln lo">Address        | Value          |<br/>0x7fffffffdc70 | 0x7fffffffdc68 | &lt;- the "p" variable, holding the address of "i"<br/>0x7fffffffdc68 | 123            | &lt;- the "i" variable, holding the value 123</span></pre><p id="11ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由编译器决定自动变量在堆栈中的顺序——<code class="fe kw kx ky kz b">i</code>在源代码中排在第一位并不重要。</p><p id="0581" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，指针也可以用作数组。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="e53a" class="lj lk iq kz b gy ll lm l ln lo">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;</span><span id="48f1" class="lj lk iq kz b gy lp lm l ln lo">void dummy_func(void) {<br/>  long *p = malloc(10 * sizeof(long)); // Allocate memory for a 10-element array<br/>  p[0] = 123;<br/>  printf("%ld\n", p[0]); // "123" will be printed<br/>  free(p);<br/>}</span></pre><p id="546a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，当声明<code class="fe kw kx ky kz b">long *p</code>时，堆栈上唯一自动分配的内存<em class="me"/>是指针本身的内存。10元素数组的内存必须通过调用<code class="fe kw kx ky kz b">malloc</code>显式分配，然后通过调用<code class="fe kw kx ky kz b">free</code>释放。这两个函数由标准库提供，它们在被称为<a class="ae la" href="https://medium.com/fhinkel/confused-about-stack-and-heap-2cf3e6adb771" rel="noopener">堆</a>的内存区域上操作。操作系统通常提供从堆中请求内存和回收内存的低级原语，这些原语分别由<code class="fe kw kx ky kz b">malloc</code>和<code class="fe kw kx ky kz b">free</code>使用。</p><p id="9f3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe kw kx ky kz b">malloc</code>在堆上分配也被称为<em class="me">动态</em>分配，与<em class="me">自动</em>(如上所述)和<em class="me">静态</em>(将在字符串部分讨论)相对。</p><p id="0182" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们使用数组语法(<code class="fe kw kx ky kz b">p[0]</code>)和指针类型变量，而不是解引用操作符(<code class="fe kw kx ky kz b">*</code>)。我们将在下一节探讨为什么这是可能的。</p><p id="59cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以使用指针来访问字符串:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="d2fb" class="lj lk iq kz b gy ll lm l ln lo">#include &lt;stdio.h&gt;</span><span id="e2dc" class="lj lk iq kz b gy lp lm l ln lo">void dummy_func(void) {<br/>  int *p = "cat";<br/>  printf("%c\n", p[0]); // "c" will be printed<br/>}</span></pre><h1 id="97e7" class="mf lk iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">数组</h1><p id="8916" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">按照标准的说法，C中的数组是“一组连续分配的非空对象，具有特定的成员对象类型”。</p><p id="7d66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">又分配到哪里？如果任何变量，包括一个数组，在一个没有关键字<code class="fe kw kx ky kz b">static</code>或<code class="fe kw kx ky kz b">extern</code>的函数中被声明，它会被自动分配<em class="me"/>。</p><p id="cac9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，如果我们有一个函数:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="2c11" class="lj lk iq kz b gy ll lm l ln lo">void dummy_func(void) {<br/>  long arr[3] = {1, 2, 3};<br/>  // Use the array<br/>}</span></pre><p id="3d3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么在执行过程中，堆栈将如下所示:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="c5cb" class="lj lk iq kz b gy ll lm l ln lo">Address        | Value          |<br/>0x7fffffffdc70 | 3              | &lt;- arr[2]<br/>0x7fffffffdc68 | 2              | &lt;- arr[1]<br/>0x7fffffffdc60 | 1              | &lt;- arr[0]</span></pre><p id="34b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还记得我们之前说过，下标<code class="fe kw kx ky kz b">arr[1]</code>相当于指针解引用(<code class="fe kw kx ky kz b">*(arr + 1)</code>)？原因是，在大多数情况下，当编译器看到一个数组变量时，它会假设它正在处理一个指针变量。指针没有专用的存储，但是编译器知道它的值(它总是指向数组的第一个元素)。</p><p id="2aea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，数组下标(使用方括号语法获取数组元素的操作)根据定义<em class="me">等同于将元素索引添加到数组变量中，然后取消对它的引用(类似于<code class="fe kw kx ky kz b">*(arr + 1)</code>)。</em></p><p id="771d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了说明这一点，让我们给这个例子添加一个指针:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="ca5c" class="lj lk iq kz b gy ll lm l ln lo">void dummy_func(void) {<br/>  long arr[] = {1, 2, 3}; // We don’t need to specify the size of the array since we’re initializing it with three elements<br/>  long *ptr = arr; // We can do it since arr is implicitly substituted with a pointer that holds the address of array’s first element. We’re assigning a pointer value to a pointer variable here, so no error or warning will be generated.<br/>}</span></pre><p id="7c4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，<code class="fe kw kx ky kz b">arr[1]</code>、<code class="fe kw kx ky kz b">*(arr + 1)</code>、<code class="fe kw kx ky kz b">ptr[1]</code>和<code class="fe kw kx ky kz b">*(ptr + 1)</code>都产生相同的结果。</p><p id="0ca3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是<code class="fe kw kx ky kz b">arr[1]</code>和<code class="fe kw kx ky kz b">ptr[1]</code>等价吗？答案是<strong class="ka ir">否</strong>。为这两个操作生成的汇编代码是不同的。在第一种情况下，编译器知道数组第一个元素的地址(从技术上讲，不是绝对地址，而是它相对于基指针的偏移量)，所以在运行时我们只需获取所需的元素。</p><p id="63ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">指针就不是这样了——我们必须在运行时获取它包含的值<em class="me"/>(恰好是第一个数组元素的地址)，只有这样我们才能获得必要的数组元素。因此，使用指针变量比使用数组变量需要多一条指令来获得一个元素。</p><p id="95bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是示例的堆栈:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="21ea" class="lj lk iq kz b gy ll lm l ln lo">Address        | Value          |<br/>0x7fffffffdc70 | 3              | &lt;- arr[2] == *(arr + 2) == ptr[2] == *(ptr + 2) == 3<br/>0x7fffffffdc68 | 2              | &lt;- arr[1] == *(arr + 1) == ptr[1] == *(ptr + 1) == 2<br/>0x7fffffffdc60 | 1              | &lt;- arr[0] == *arr == ptr[0] == *ptr == 1<br/>0x7fffffffdc58 | 0x7fffffffdc60 | &lt;- ptr, holds the address of the first array element</span></pre><p id="1666" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在编译时，数组不仅产生与指针不同的汇编代码，而且还有语法差异。您可以从数组创建指针，但不能从数组创建指针。也不能赋值给数组(初始化不算)。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="359a" class="lj lk iq kz b gy ll lm l ln lo">#include &lt;stdlib.h&gt;</span><span id="91f9" class="lj lk iq kz b gy lp lm l ln lo">void dummy_func(void) {<br/>  long *ptr = malloc(3 * sizeof(long));<br/>  long arr1[] = ptr; // Wrong, the initializer should contain a number of long values in braces, but not a pointer; will cause a compile-time error</span><span id="2b64" class="lj lk iq kz b gy lp lm l ln lo">  long arr2[3];<br/>  arr2 = {1, 2, 3}; // Wrong, an array cannot be the left side of an assignment operation (except at initialization); will also cause a compile-time error<br/>}</span></pre><p id="adf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不能用一个指针的值来初始化一个数组，因为每当一个数组被声明的时候，就必须为一定数量的元素分配存储空间，就像我们之前讨论的那样。所以<code class="fe kw kx ky kz b">long arr1[] = ptr;</code>没有意义，因为不清楚分配多少内存。而且，就算写成<code class="fe kw kx ky kz b">long arr1[3] = ptr;</code>，还是会模棱两可。我们应该将<code class="fe kw kx ky kz b">ptr</code>转换为<code class="fe kw kx ky kz b">long</code>并存储在第一个数组元素中，还是应该将<code class="fe kw kx ky kz b">ptr</code>指向的一个连续内存块复制到由<code class="fe kw kx ky kz b">arr1</code>表示的内存块中？</p><p id="2f5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不能给数组赋值的原因是数组变量本身不占用任何内存(尽管数组的元素占用)。C #中的赋值操作符总是将一个值存储在内存位置中，赋值操作的左侧将计算该值。但是<code class="fe kw kx ky kz b">arr2</code>没有相关联的存储位置。所以，如果左边有一个数组，要么我们必须改变赋值操作符的语义，要么不允许数组赋值。C的创造者选择了后者，不难看出他们的推理。</p><p id="2fad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有几件事需要注意:使用数组作为函数参数，从函数中返回数组。</p><p id="2c19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个函数声明:<code class="fe kw kx ky kz b">void dummy_func(int a[]);</code>。该函数接受一个参数，这是一个数组<code class="fe kw kx ky kz b">int</code>。我们如何通过它？在关于堆栈的部分，我们讨论了如何分配局部变量的存储。事实上，参数以类似的方式传递。C语言中的所有参数都是通过值传递的(不像JavaScript中的对象是通过引用传递的)，所以每个参数在堆栈上都有一个具体的表示(在某些编译器和操作系统中，寄存器可以用于参数传递，但是为了讨论方便，我们假设总是使用堆栈)。因此，如果函数看起来像<code class="fe kw kx ky kz b">void dummy_func(long l);</code>，那么在函数执行期间，从基址指针固定偏移的堆栈上的8个字节将被参数值占用。</p><p id="3e2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">未知大小的数组(<code class="fe kw kx ky kz b">int a[]</code>)是不同的，因为不出所料，它的大小在编译时是未知的。为了解决这个问题，C在编译时将数组参数转换为指针参数，因此<code class="fe kw kx ky kz b">void dummy_func(int a[]);</code>被完全视为<code class="fe kw kx ky kz b">void dummy_func(int *a);</code>。由于在编译时必须知道参数的大小，所以传递指针是很自然的事情——在64位机器上，指针的大小固定为8个字节。</p><p id="2b22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">C #中不允许从函数中返回数组，这也不是一个奇怪的异常。相反，很可能是不愿意做出怪异的例外。返回值被放在堆栈上，就像参数一样，它们必须有固定的大小，所以我们不能只传递数组，我们必须把数组转换成指针。但是如果我们在函数中创建数组，然后试图返回它，我们将返回一个指向自动数组的指针，当创建数组的函数返回时，自动数组的存储时间结束。</p><p id="8a0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">长话短说，从函数中返回数组在C中会很笨拙，所以语言不允许这样做。</p><p id="0d2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="me">更新:</em>事实上，让函数拥有数组返回类型并不是不现实的，但是数组的大小总是必须固定的(类似于<code class="fe kw kx ky kz b">int dummy(void)[3]</code>)。但是这只会使事情变得复杂——返回值的行为将不同于参数的行为(将整个数组放在堆栈上，而不是传递一个指针)。</p><h1 id="5cf1" class="mf lk iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">用线串</h1><p id="24d9" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">C中有指针类型和数组类型，但是字符串和JavaScript不同，它不是一个独立的数据类型。根据该标准，字符串“是一个连续的字符序列，以第一个空字符结束，并包含第一个空字符。”</p><p id="a559" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，字符串是简单的<code class="fe kw kx ky kz b">char</code>数组，它的最后一个元素是它的第一个<code class="fe kw kx ky kz b">'\0'</code>字符。“第一个”这个词在这里很重要——字符串中间不能有<code class="fe kw kx ky kz b">'\0'</code>。(较新版本的C也支持多字节字符串，但是为了便于讨论，我们可以假设每个字符都用一个<code class="fe kw kx ky kz b">char</code>来表示)。</p><p id="f4d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以如果我们说的是代表单词“cat”的字符串，那就是四个字符:<code class="fe kw kx ky kz b">'c'</code>、<code class="fe kw kx ky kz b">'a'</code>、<code class="fe kw kx ky kz b">'t'</code>、<code class="fe kw kx ky kz b">'\0'</code>。它们位于内存中的连续地址，最后一个字符就是数字0。</p><p id="118e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它看起来像这样:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="5b30" class="lj lk iq kz b gy ll lm l ln lo">Address        | Value          |<br/>0x7fffffffdc73 | '\0' (0)       |<br/>0x7fffffffdc72 | 't'  (116)      |<br/>0x7fffffffdc71 | 'a'  (97)       |<br/>0x7fffffffdc70 | 'c'  (99)       |</span></pre><p id="8bf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看我们之前是如何以8个字节的步长显示地址的，而这里的步长是一个字节。与字符相关的数字来自<a class="ae la" href="https://en.wikipedia.org/wiki/ASCII" rel="noopener ugc nofollow" target="_blank"> ASCII表</a>。</p><p id="51a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="me">字符串文字</em>与<em class="me">字符串</em>相关，但这是一个不同的概念。字符串是源文件(不在内存中)中用双引号括起来的字符序列，就像<code class="fe kw kx ky kz b">"cat"</code>。</p><p id="8209" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">字符串文字不一定代表字符串。例如，<code class="fe kw kx ky kz b">"cat\0dog"</code>是一个有效的字符串文字，但是它在内存中创建的不是一个字符串，因为字符串中间不能包含空字符。</p><p id="72b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，<code class="fe kw kx ky kz b">char str[] = {'c', 'a', 't', '\0'};</code>创建一个字符串，但不使用字符串文字。</p><p id="5176" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当编译器遇到长度为N的字符串文字时，它会确保在程序运行时，在程序开始执行之前，分配(N+1)字节的静态存储，并用必要的字符填充。<em class="me">静态</em>存储，与<em class="me">自动</em>和<em class="me">动态</em>相反，在执行开始时分配，在程序终止后释放。需要(N+1)个字节来包含文字的所有字符以及结尾的空字符。</p><p id="c586" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后编译器将文字转换为指向其第一个字符的指针，因此<code class="fe kw kx ky kz b">char *ptr = "cat";</code>意味着将在内存中的某个地方创建一个字符序列，并且<code class="fe kw kx ky kz b">"cat"</code>将被隐式转换为“指向字符的指针”类型的值，然后该值将用于初始化变量<code class="fe kw kx ky kz b">ptr</code>。<code class="fe kw kx ky kz b">ptr</code>将包含存储字符<code class="fe kw kx ky kz b">'c'</code>的存储单元的地址。</p><p id="cc0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“将字符串文字转换为指针”行为有一个例外，即数组初始化。函数内部的数组是自动变量，所以如果我们使用char <code class="fe kw kx ky kz b">arr[] = "cat";</code>，那么在栈上为数组<em class="me">分配四个字节，并用文字的字符填充(加上空字符)。<code class="fe kw kx ky kz b">"cat"</code>在这个实例中没有被转换成指针。这个初始化的结果将和我们写<code class="fe kw kx ky kz b">char str[] = {'c', 'a', 't', '\0'};</code>一样。</em></p><p id="8050" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要理解为什么需要一个空字符来结束一个字符串。不是很浪费吗？其实不是。字符串只是内存中的字节序列，没有元信息存储在任何地方。每当我们希望在控制台中显示一个字符串时，我们需要知道要显示多少个字符。这就是空字符的用途—它是一种在没有显式存储长度的情况下分隔字符串的方法。</p><h1 id="8a5e" class="mf lk iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">问题的答案</h1><p id="f9cf" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">我们现在已经学到了足够多的知识，能够理解本文开头的例子中发生了什么。</p><p id="0474" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题1: </strong>为什么我们在输出中得到一个奇怪的字符？</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="4e2c" class="lj lk iq kz b gy ll lm l ln lo">#include &lt;stdio.h&gt;</span><span id="d989" class="lj lk iq kz b gy lp lm l ln lo">int main() {<br/>  char str[3] = "cat";<br/>  puts(str);<br/>  return 0;<br/>}</span><span id="7141" class="lj lk iq kz b gy lp lm l ln lo">&gt; gcc main.c -o out<br/>&gt; ./out<br/>cat�</span></pre><p id="494c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答:我们使用了一个长度不足的数组来存储字符串(应该是四个，而不是三个)。打印字符串时，遍历内存位置，直到遇到一个所有位都设置为零的字节。在这种情况下，打印的字符数取决于编译器和执行环境。</p><p id="03dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不应该做上面的事情，简单地使用一个未知大小的数组(<code class="fe kw kx ky kz b">char str[] = "cat";</code>):它将被初始化为正确的长度。</p><p id="5ad7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题2: </strong>如果我们用一个字符串初始化一个数组和一个指针，然后尝试重新分配结果数组的一个元素，为什么行为会不同？<code class="fe kw kx ky kz b">char *str = "cat"; str[0] = 'b';</code>和<code class="fe kw kx ky kz b">char str[] = "cat"; str[0] = 'b';</code>。</p><p id="c3fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答:请记住，当代码中有一个字符串文字时，编译器会为它所代表的字符数组分配静态存储空间，在编译期间，该文字会被替换为指向该内存的指针。所以当一个指针变量被初始化时(<code class="fe kw kx ky kz b">char *str = "cat";</code>)，值<em class="me">可能是</em>一个只读内存地址(由编译器决定将字符串放在哪里)。当我们试图写入那个地址(<code class="fe kw kx ky kz b">str[0] = 'b';</code>)时，进程会立即终止并出现错误。但是当你初始化一个数组时，<code class="fe kw kx ky kz b">"cat"</code>的存储被分配在堆栈上，在程序执行期间是可写的，所以它工作得很好。</p><p id="20a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题3: </strong>为什么字符串复制会失败？</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="31a9" class="lj lk iq kz b gy ll lm l ln lo">#include &lt;string.h&gt;</span><span id="c71e" class="lj lk iq kz b gy lp lm l ln lo">int main() {<br/>  char *str1 = "cat";<br/>  char *str2;<br/>  strcpy(str2, str1);<br/>  return 0;<br/>}</span></pre><p id="c72a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答:<code class="fe kw kx ky kz b">strcpy</code>函数将第二个参数指向的字符串复制到第一个参数指向的数组中。<code class="fe kw kx ky kz b">str2</code>未用值初始化，因此包含cruft。<code class="fe kw kx ky kz b">strcpy</code>仍然愉快地把那个cruft当作一个地址，并试图写入它，但是那个地址很可能不在可写的内存区域中。</p><p id="0f4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题4: </strong>为什么不初始化就不能在函数内部声明一个大小未知的数组，像这样:<code class="fe kw kx ky kz b">int arr[];</code>？</p><p id="62a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答:因为自动变量<em class="me">在声明时必须有一个已知的大小。编译代码时，变量没有符号名，所有值都是通过从堆栈帧的开始或结束的偏移量来存储和检索的。如果我们不知道一个变量的大小，我们就不知道它后面的变量的偏移量。</em></p><p id="4fbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="me">更新:</em> C99在语言中引入了<em class="me">可变长度数组</em>，它们的大小在编译时实际上是未知的，它既不是堆栈指针，也不是用于计算数组元素地址的基指针。然而，可变长度仅仅意味着长度是在运行时定义的，而不是一旦定义就可能改变。在未知大小数组的情况下，如果允许使用<code class="fe kw kx ky kz b">int arr[];</code>,该语言将不得不允许数组赋值(实际上并不允许),并且不允许进一步的赋值(以防止数组大小的改变)或者使数组可调整大小，这在堆栈上是相当低效的。</p><p id="23bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题5: </strong>为什么<em class="me">可以</em>使用大小未知的数组作为函数参数？</p><p id="03bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答:作为函数参数的数组只是简单地转换为指针，所以这样一个参数的大小总是指针变量的大小(在64位处理器架构的情况下是8个字节)。</p><p id="629d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题6: </strong>为什么数组不能作为函数返回值？</p><p id="4d1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答:参见“数组”部分。</p><p id="4c53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题7: </strong>如果我们比较两个字符串会怎么样:<code class="fe kw kx ky kz b">"cat" == "cat"</code>？这是真的还是假的？</p><p id="e558" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回答:我们首先需要理解我们在这里比较什么。一个字符串被一个指针代替，所以两个指针被比较。这与字符串的词典比较无关(就像JavaScript中的等号运算符所做的那样)。那么指针有相同的值吗？答案是，可能。编译器可以选择为代码中的每个字符串单独分配内存，或者为相同的字符串重用内存。这种行为是不确定的，所以你不应该依赖它的实现方式。基本上，永远不要编写比较运算符将字符串文字作为其操作数之一的代码，因为您无法控制它将被分配到的地址。如果你需要按字典顺序比较两个字符串，使用<code class="fe kw kx ky kz b">strcmp</code>函数。</p><h1 id="824b" class="mf lk iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">结论</h1><p id="0f53" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">希望现在能更清楚为什么数组和指针有这样的功能，以及字符串到底是什么。语言创造者的某些决定也可能开始变得有意义了——你以前可能认为是怪癖的特性实际上是基于合理的原则。</p><h1 id="f71e" class="mf lk iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">资源</h1><ul class=""><li id="d4da" class="lq lr iq ka b kb nc kf nd kj nh kn ni kr nj kv lv lw lx ly bi translated">C标准:<a class="ae la" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf" rel="noopener ugc nofollow" target="_blank">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf</a></li><li id="67cd" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">AMD64 Linux ABI:<a class="ae la" href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf" rel="noopener ugc nofollow" target="_blank">https://software . Intel . com/sites/default/files/article/402129/mpx-Linux 64-ABI . pdf</a></li><li id="7c3c" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">C语言的发展丹尼斯·里奇:<a class="ae la" href="https://www.bell-labs.com/usr/dmr/www/chist.html" rel="noopener ugc nofollow" target="_blank">https://www.bell-labs.com/usr/dmr/www/chist.html</a></li><li id="7ae1" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">C常见问题解答(特别是它的“数组和指针”部分):【http://c-faq.com/aryptr/index.html T2】</li><li id="23f2" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">伊莱·本德斯基的优秀文章:<a class="ae la" href="https://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c" rel="noopener ugc nofollow" target="_blank">https://Eli . the green place . net/2009/10/21/are-pointers-and-arrays-equivalent-in-c</a>和<a class="ae la" href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/" rel="noopener ugc nofollow" target="_blank">https://Eli . the green place . net/2011/09/06/stack-frame-layout-on-x86-64/</a></li></ul><h1 id="f6fa" class="mf lk iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">全系列</h1><ol class=""><li id="3568" class="lq lr iq ka b kb nc kf nd kj nh kn ni kr nj kv nk lw lx ly bi translated"><a class="ae la" href="https://medium.com/@pavelpomerantsev/c-for-javascript-developers-program-compilation-source-vs-header-files-1829a69a0a56" rel="noopener">程序编译。源文件与头文件</a></li><li id="2110" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv nk lw lx ly bi translated">(本文)内存分配。指针、数组和字符串</li></ol></div></div>    
</body>
</html>