<html>
<head>
<title>How I wrote the world’s fastest React memoization library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何编写世界上最快的反应记忆库</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-wrote-the-worlds-fastest-react-memoization-library-535f89fc4a17?source=collection_archive---------1-----------------------#2018-03-05">https://itnext.io/how-i-wrote-the-worlds-fastest-react-memoization-library-535f89fc4a17?source=collection_archive---------1-----------------------#2018-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/23c5c0b42389c9865c2de2d6c46592ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1hvxHDDfzlxl8l-pPnhxw.jpeg"/></div></div></figure><p id="04a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fhow-i-wrote-the-worlds-fastest-react-memoization-library-535f89fc4a17" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="4e10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，我曾经尝试过写最慢的一个，而“t <a class="ae kw" href="https://community.risingstack.com/the-worlds-fastest-javascript-memoization-library/" rel="noopener ugc nofollow" target="_blank">最快的JavaScript记忆库</a>是一年前写的。甚至没有一个——有这么多的库，一个比一个快，很难把它们都记住。</p><blockquote class="ky kz la"><p id="36db" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">为什么要多写一个？因为你不能使用或处理现有的。</p></blockquote><h2 id="b3e2" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">记忆。</h2><p id="1dc2" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">这是减少或完全跳过不必要计算的常见模式。工作非常简单——</p><blockquote class="ky kz la"><p id="6355" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">你有一个函数。你用一些参数调用than函数。下一次你做同样的事情——只是重复使用已知的结果。</p></blockquote><p id="e099" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的图书馆都这么做。唯一的区别是它们如何处理函数arity(参数的数量)，它们可以存储多少结果，它们的速度有多快。</p><p id="c829" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，lodash.memoize只“看到”第一个参数，而fast-memoize字符串化所有参数，并使用JSON作为缓存键。</p><p id="c16b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">速度也很重要。Ramda比没有记忆的代码快<strong class="ka ir"> 100倍</strong>，lodash比ramda快<strong class="ka ir"> 100倍</strong>，纳米记忆比lodash快<strong class="ka ir"> 100倍</strong>。</p><blockquote class="mc"><p id="c562" class="md me iq bd mf mg mh mi mj mk ml kv dk translated">但是你不需要速度。你需要记忆。</p></blockquote><p id="46a5" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">上面的比较是针对斐波那契数列计算的。所有这些库都很擅长基于参数来记忆函数结果，打破所有内存限制，因为长缓存大小通常是不受限制的。</p><p id="2166" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于这个问题的第一个<em class="kx">调用</em>(对我来说)是由一个名为<a class="ae kw" href="https://github.com/alexreardon/memoize-one" rel="noopener ugc nofollow" target="_blank"> memoize-one </a>的库发出的，作者是<a class="mr ms ep" href="https://medium.com/u/ea5e41121e55?source=post_page-----535f89fc4a17--------------------------------" rel="noopener" target="_blank"> Alex Reardon </a>。主要意图很清楚—<strong class="ka ir">它记忆一个结果</strong>。因为你可能不需要更多。</p><blockquote class="ky kz la"><p id="9ddf" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">这其实是React/Redux世界需要的东西。只有中断更新的能力，没有任何副作用(像内存缓存中的内存泄漏)</p></blockquote><blockquote class="mc"><p id="6d9a" class="md me iq bd mf mg mt mu mv mw mx kv dk translated">应该不会很快。应该能用。</p></blockquote><p id="76f6" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">但是，你知道，你仍然必须写一个“特殊的”代码来正确地记忆你需要的东西。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="2b71" class="le lf iq nd b gy nh ni l nj nk">const mapStateToProps = state =&gt; ({<br/>   todos: state.todos.filter(todo =&gt; todo.active)<br/>});</span></pre><p id="85f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">^:每次状态改变时，这个都会产生一个新的todos数组。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="4652" class="le lf iq nd b gy nh ni l nj nk">const filterTodos = memoize(todos =&gt; todos.filter(todo =&gt; todo.active));</span><span id="7cd8" class="le lf iq nd b gy nl ni l nj nk">const mapStateToProps = state =&gt; ({<br/>   todos: filterTodos(state.todos)<br/>});</span></pre><p id="4de5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">^这个不会。现在它只会对<code class="fe nm nn no nd b">state.todos</code>物体的变化做出反应。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="982f" class="le lf iq nd b gy nh ni l nj nk">const filterTodos = memoize(todos =&gt; todos.filter(todo =&gt; todo.active));<br/>const getTodos = todos =&gt; todos.map(todo =&gt; todo.text )</span><span id="d44f" class="le lf iq nd b gy nl ni l nj nk">const mapStateToProps = state =&gt; ({<br/>   todos: getTodos(filterTodos(state.todos))<br/>});</span></pre><p id="a1a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">^这个仍然会对<code class="fe nm nn no nd b">state.todos</code>物体的变化做出反应，但是应该只对<code class="fe nm nn no nd b">todo.text</code>的变化做出反应。</p><p id="2469" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">普通库也有一个共同的“限制”，比如一个<a class="ae kw" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank">重选</a> ( <strong class="ka ir">选择器和记忆</strong>库)，它也只能存储一个“最后”结果。并且，如果你有<strong class="ka ir">几个</strong>不同的<strong class="ka ir">连接组件</strong>，都从一个商店选择一些东西，但是具有不同的道具——你将总是禁用你的记忆功能(<a class="ae kw" href="https://github.com/reactjs/reselect#accessing-react-props-in-selectors" rel="noopener ugc nofollow" target="_blank">链接到问题</a>，<a class="ae kw" href="https://github.com/threadheap/reselect-weakmap-memoize" rel="noopener ugc nofollow" target="_blank">链接到变通办法</a>，以及<a class="ae kw" href="https://github.com/toomuchdesign/re-reselect" rel="noopener ugc nofollow" target="_blank">另一个变通办法</a>)。<strong class="ka ir">有</strong> <strong class="ka ir">可</strong> <strong class="ka ir">只有一个！</strong>他们只会一直“缓存缺失”。</p><blockquote class="mc"><p id="8db7" class="md me iq bd mf mg mh mi mj mk ml kv dk translated">编写一个适当记忆的代码——可能是一项艰巨的工作。</p></blockquote><p id="ce3a" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">你将最终获得重新选择级联和非常具体的记忆技术，这将使你能够为你的项目创建一个“更好的”记忆。</p><blockquote class="ky kz la"><p id="66d7" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">不是“更快”，而是“请尽可能多地记忆案例”</p></blockquote><h2 id="a2a3" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">MobX</h2><p id="d8fc" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">我一直喜欢MobX的一点——懒惰。我可以偷懒，写一段代码，这段代码会被偷懒执行…什么也不做。</p><p id="9358" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不需要想，“哦，当这个事件被调度时，Redux将触发所有的ConnectedComponents，mapStateToProps所有的东西，并且可能重新绘制应用程序的一半，因为我的一个选择器每次运行都产生一个唯一的值。</p><blockquote class="mc"><p id="12cb" class="md me iq bd mf mg mh mi mj mk ml kv dk translated">不是唯一的，而是不可改变的。就{…originalStateProp}</p></blockquote><p id="e1e5" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">你知道，由于这种<strong class="ka ir">低级优化</strong>你，除了你必须提供什么，<strong class="ka ir">但没有</strong>——Vue和Angular可以更快开箱。我是说React/Redux可能很烂。MobX——石头！</p><h2 id="1c3f" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">Immer.js</h2><p id="3792" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">哦。Immer是一股清新的空气。它使用现代javascript的能力来增强reducers，让您只需编写代码。让您只编写您需要编写的代码，而不考虑如何编写代码(并保持不变性)。</p><p id="e5e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Immer比" not"-immer慢得多，但是你不需要这些每秒千万次的减速器，如果没有它你可能会有的。仅仅每秒100万就已经不错了。</p><h1 id="9b5b" class="np lf iq bd lg nq nr ns lj nt nu nv lm nw nx ny lp nz oa ob ls oc od oe lv of bi translated">但是记忆化呢？</h1><p id="36e1" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">所以我建立了一个内存化库，它与MobX和Immer.js共享一些东西。它只是工作，解决你的问题。不知何故。神奇地。隐形的。</p><p id="60f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我在开始所说的——我尝试过构建最慢的记忆库，它是最快的记忆库。</p><p id="bf08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我称之为— <strong class="ka ir">记忆状态</strong>。</p><div class="og oh gp gr oi oj"><a href="https://github.com/theKashey/memoize-state" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">Kashey/memoize国家</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">memo ize-state-mapStateToProps的正确记忆</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox jw oj"/></div></div></a></div><p id="f0d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是<strong class="ka ir">慢速</strong>cos——它使用javascript <code class="fe nm nn no nd b">Proxy</code>来观察内存化的函数正在做什么。它比普通的记忆库多100倍的代码。</p><p id="1d5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是<strong class="ka ir">快速的</strong>cos——当它必须决定它应该返回被记忆的值还是必须刷新它——它可以<strong class="ka ir">只比较被使用的部分参数</strong>,使它成为…</p><blockquote class="mc"><p id="4846" class="md me iq bd mf mg mh mi mj mk ml kv dk translated">“请尽可能多地记住案例”</p></blockquote><p id="d2ea" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">只要它“经常”记忆，它在计算上花费的时间就会更少，工作速度也会更快…</p><p id="9ee0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可能应该贴两个例子。</p><p id="fab8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个很简单。它像所有记忆功能一样工作。</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="998c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是第二个…它会<strong class="ka ir">忽略第二个元素中的值变化</strong>，因为你没有读取它，甚至没有返回那个元素。你不需要它。</p><blockquote class="ky kz la"><p id="b45d" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">Memoize-state不会对参数的变化做出反应，memoized函数不会“使用”。因此，它将记忆更多的情况。</p></blockquote><p id="c9d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只需想象更常见的情况— redux的mapStateToProps。</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7cd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有特别的逻辑。没有选择器。没有“参数级”记忆。而且你不会相信我，<strong class="ka ir">这些函数是相等的</strong>！你可以在任何地方应用内存状态！它会跟踪你提供的参数的用法。</p><blockquote class="ky kz la"><p id="dfa1" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">记忆状态不是“内部”记忆，不是“功能”记忆，而是<strong class="ka ir">“外部”记忆</strong>。只要用memoize-state包装任何东西并让它被记忆。任何纯粹的功能，只要有可能，都应该被记忆！</p></blockquote><p id="0742" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过相同的机制，它解决了具有多个组件的<em class="kx">重选问题</em>——只需将整个mapStateToProps… <strong class="ka ir">包装两次</strong>。道具没有区别的情况下，每个人一次，每个组件第二次，如果他们的选择器不同。我有一个软件包，可以自动完成。</p><div class="og oh gp gr oi oj"><a href="https://github.com/theKashey/beautiful-react-redux" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">卡希/美丽反应还原</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">美丽-反应-还原-还原🚀，Redux🤘，Redux🔥</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="pa l ou ov ow os ox jw oj"/></div></div></a></div><p id="3595" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在这里只能说出不好的东西——只要你不能使用像重选级联这样的东西，你就不会使用它们(经验法则)。因此，您也将丢失缓存级联。结果是——有些东西会被计算两次。</p><blockquote class="ky kz la"><p id="4983" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">没有汽车能取代你。你是施展魔法的法师。</p></blockquote><h2 id="e3af" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">反应-记忆</h2><p id="796b" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">Memoize-state工作起来非常简单，对用户来说是不可见的，因此我在另一个库中使用了它，并考虑到了Memoize。正如丹·阿布拉莫夫所提议的。</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="pb oz l"/></div></figure><p id="21c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我构建的库不是基于这个规范，只要你的记忆函数是“外部的”就没有必要。</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="08a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它只是将所有的道具(除了<code class="fe nm nn no nd b">compute</code>)传递给<code class="fe nm nn no nd b">compute</code>函数，并通过子函数(又名renderProps)渲染结果。</p><p id="a7f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已。其他的都藏在引擎盖下。你应该相信记忆状态。检查repo——它包含一个指向codesandox示例的链接。</p><div class="og oh gp gr oi oj"><a href="https://github.com/theKashey/react-memoize" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">记忆/反应-记忆</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">反应式内存缓存(又名内存化)是一种非常强大的优化技术</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="pc l ou ov ow os ox jw oj"/></div></div></a></div><h2 id="8df2" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">记忆状态</h2><p id="9c6e" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">编写这个库不是一项简单的任务。我写了它，花了两天时间，测试它，在twitter上发布，发现这个库不工作，我的意思是完全不工作，并花了两个多星期在研发上</p><p id="3993" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我修好了它。接下来我写了这篇文章。发现我犯的错误越来越少。修好它们。发现没几个“客户”，仔细检查这次真的“搞定”了。</p><p id="2a49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它实际上是如何工作的——它只是用代理(来自<a class="ae kw" href="https://github.com/theKashey/proxyequal" rel="noopener ugc nofollow" target="_blank"> proxyequal </a>库)包装所有给定的参数，而<strong class="ka ir">监视</strong>使用情况。</p><p id="60a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在memoized函数执行后，memoize-state将从提供的参数中知道所有使用的“子键”。子键，不可能检测到有人使用(或未使用)了键(参数)本身。</p><p id="7486" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，当记忆函数被第二次调用时——它将不得不比较的不是对象本身，而是整体的一小部分。这是我犯的第一个错误。</p><p id="810d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你使用了<code class="fe nm nn no nd b">a.b.c.d</code>，你必须“重视”——只比较<code class="fe nm nn no nd b">.d</code> <strong class="ka ir">让所有其他路径都“灵活”</strong>，否则这种记忆将不起作用。我花了一周时间才明白为什么我写的简单比较函数在现实中不起作用。</p><p id="c4cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">错过的点——我们还必须<code class="fe nm nn no nd b">deproxyfy</code>结果，在被记忆的函数内确定跟踪代码的范围，不要让它泄露出去……并跟踪函数返回的键。</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="e75f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，memoize-state应该对<code class="fe nm nn no nd b">state.a.b.c</code>作出反应，只要这是所使用的“最深”键，并且只要它被返回，就对<code class="fe nm nn no nd b">state.a.b</code>作出反应。但不是<code class="fe nm nn no nd b">state.a</code>——它应该保持“灵活”。</p><p id="f277" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有代理中的代理(或两次记忆)，这在记忆中应该是非常准确的，以防止误报缓存。</p><p id="55f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前所有边缘情况都已解决并测试，<strong class="ka ir">记忆状态稳定</strong>。</p><h2 id="35bb" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">速度</h2><p id="c0db" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">Memoize-state将基准作为CI的一部分。很难理解这个库的性能——它总是在记忆功能的“成本”和记忆糖的“成本”之间取得平衡。</p><p id="0770" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是让我们试试。</p><ol class=""><li id="6b18" class="pd pe iq ka b kb kc kf kg kj pf kn pg kr ph kv pi pj pk pl bi translated">“标准”记忆。3个整数参数的函数。没有变化。</li></ol><blockquote class="ky kz la"><p id="1f1e" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">memoize-one x 6703353操作/秒<br/> lodash.memoize x 3095017操作/秒<br/> fast-memoize x 1013601操作/秒<br/> memoize-state x 4007493操作/秒</p></blockquote><p id="37f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不坏。比lodash更好。Fast-memoize有点糟糕，因为将3个旧的普通类型(int)转换成JSON来存储这些东西——成本很高。</p><p id="2342" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">这是一个悬而未决的问题，cos lodash做同样的转换。</em></p><p id="3222" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.“标准”记忆。3个整数参数的函数。所有变化。</p><blockquote class="ky kz la"><p id="30d1" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">memoize-one x 21573操作/秒<br/> lodash.memoize x 35272操作/秒<br/> fast-memoize x 19195操作/秒<br/> memoize-state x 19436操作/秒</p></blockquote><p id="10a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不是最好的。但是这是边缘情况，当你不需要任何记忆的时候。</p><p id="9e81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.“国家”案。随机改变类似状态的物体。</p><blockquote class="ky kz la"><p id="28d4" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">memo ize-one x 9921<br/>lodash . memo ize x 93547<br/>fast-memo ize x 90966<br/>memo ize-state x 1301700</p></blockquote><p id="8778" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">~ 13万vs ~9000。它只是忽略了大部分的随机状态变化，因为长记忆函数只使用了一个子集。</p><p id="3230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.“大州”案。只是提供大的状态。</p><blockquote class="ky kz la"><p id="a507" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">memo ize-one x 10523<br/>lodash . memo ize x 258<br/>快速记忆x 255 <br/>记忆状态x 81181</p></blockquote><p id="6189" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">80000对300。</p><p id="1955" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">lodash memoize和fast-meoize将状态转换为json。坏主意。memo ize-一个做浅相等，但很多值。记忆-状态执行狙击手比较。</p><h2 id="5e83" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">缓存命中</h2><p id="75a4" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">原始性能测试不仅包含每秒操作数，还包含“缓存命中”参数。这可能更重要。</p><blockquote class="mc"><p id="d39a" class="md me iq bd mf mg mh mi mj mk ml kv dk translated">你的记忆功能可以很慢，只要它比“错过的”记忆和树渲染导致的react/redux/redraw快。</p></blockquote><p id="07c3" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">正确的重选级联可以有100%的缓存命中率，但是很难编写正确的级联，调试它，使它保持最新。嗯，只是需要时间。</p><p id="cc73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">memoize-one的“缓存命中”接近理想状态。它将尽可能多地记忆案例。</p><p id="05d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它比普通的记忆库大10倍，比普通的记忆库慢10倍，但是，你知道，你的应用程序会同样快10倍。没有任何时间花在优化上。</p><blockquote class="mc"><p id="78e9" class="md me iq bd mf mg mh mi mj mk ml kv dk translated">这就是目标。没有什么“特殊”的事情需要你去做。</p></blockquote><h2 id="db9d" class="le lf iq bd lg lh pm dn lj lk pn dp lm kj po lo lp kn pp lr ls kr pq lu lv lw bi translated">浏览器支持</h2><p id="d65f" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">Memoize-state和所有基于它的库都需要ES6代理。IE11和React-Native都不支持，你得多填。不是问题。</p><div class="og oh gp gr oi oj"><a href="https://github.com/tvcutsem/harmony-reflect" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">tvcutsem/和声-反射</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">用于ES6反射和代理对象的harmony-reflect - ES5 shim</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="pr l ou ov ow os ox jw oj"/></div></div></a></div><h2 id="17e6" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">结论</h2><p id="2ec2" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">记忆状态不能代替“普通的”记忆函数，对于“普通的旧类型”——字符串和整数作为参数的情况，只要它非常复杂。请随意使用任何其他低级库。</p><p id="1aeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你传递一个对象——状态、道具，或者只是把你所有的变量放入对象中并传递那个对象，它就会发光。闪亮亮！</p><blockquote class="mc"><p id="48af" class="md me iq bd mf mg mh mi mj mk ml kv dk translated">const easy win = memoizeState(your function)</p></blockquote><p id="ba65" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这种“不可见的记忆化”帮助我构建了两个非常有用的库，并在开发周期和运行时节省了大量时间。).</p><p id="206f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你能用它建造什么？</p><div class="og oh gp gr oi oj"><a href="https://github.com/theKashey/memoize-state" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">Kashey/memoize国家</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">memo ize-state-mapStateToProps的正确记忆</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox jw oj"/></div></div></a></div><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="pb oz l"/></div></figure></div></div>    
</body>
</html>