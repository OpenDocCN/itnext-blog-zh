<html>
<head>
<title>Let’s build some blocks!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们建造一些积木吧！</h1>
<blockquote>原文：<a href="https://itnext.io/building-bits-and-pieces-375418f9b116?source=collection_archive---------6-----------------------#2019-06-06">https://itnext.io/building-bits-and-pieces-375418f9b116?source=collection_archive---------6-----------------------#2019-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9948" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">web组件和自定义元素介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/27c7fa2101232ded9b376175f9db9a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaL3SxOBXbrwXrAciJyM3Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·巴克利普在Unsplash<a class="ae ky" href="https://unsplash.com/search/photos/diy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></figcaption></figure><p id="aeca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Web组件允许创建可重用的定制元素。您可能已经使用了前端库，如React，它允许轻松地创建组件。使用可重用组件<strong class="lb iu">减少重复</strong>。它让代码更<strong class="lb iu">干</strong>(不要重复自己)，这是编程中常见的最佳做法。组件还<strong class="lb iu">封装了它的样式和功能</strong>，这使得DOM更加干净，并增加了关注点的分离。尽管可以通过React这样的库获得组件，但创建它们并不需要框架或库。大多数现代浏览器(除了Internet Explorer和Edge)都支持所谓的自定义web组件。</p><p id="7905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将逐步创建一个web组件，它包含信息框的样式、模板和功能。它将包含一个标题，一些文本和一个按钮，表明用户已经看到它。之后，我们的信息框应该可以在不同的情况下重用，比如服务通知和个人信息。</p><p id="2a61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用web组件时，您可以创建自定义的HTML元素。这些元素可以是自主的，也可以是定制的内置元素。<strong class="lb iu">自治元素</strong>是独立的，这意味着它们不扩展其他元素。<strong class="lb iu">定制的内置元素</strong>是通过扩展现有的HTML元素创建的。在本演练中，我们将使用自主定制元素。</p><p id="e3a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子的起点是一个包含两个文件的文件夹，index.html和main.js。然后，通过用浏览器打开文件来运行它。当您进行更改时，请刷新页面以查看它们的显示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1eac" class="ma mb it lw b gy mc md l me mf">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;&lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;Custom Element InfoBox&lt;/h1&gt;<br/>        &lt;info-box /&gt;<br/>        &lt;script src='./main.js'&gt;&lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h2 id="d583" class="ma mb it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">web组件的三个部分</h2><p id="d61c" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Web组件由三部分组成。</p><ol class=""><li id="419a" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">自定义元素</li><li id="8415" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">影子王国</li><li id="a47c" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">HTML模板</li></ol><p id="2e19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">定制元素</strong>是一个JavaScript API，让你定义一个定制元素及其行为。这是通过调用<code class="fe nq nr ns lw b">customElements.define("element-name", Object)</code>来完成的。以这种方式创建自定义元素后，我们可以使用它的名称作为标签将其添加到我们的HTML中。自定义HTML元素的要求是其名称必须包含连字符。有效的名称应该是主抽屉、章节按钮或信息容器。不允许使用像chapterButton或info_container这样的名称。在我们的例子中，定制元素被称为info-box。</p><p id="bdb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nq nr ns lw b">&lt;info-box /&gt;</code></p><p id="9b5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">web组件的下一部分是<strong class="lb iu">影子DOM </strong>。为了理解影子DOM是什么，您应该熟悉DOM(或文档对象模型)的概念。简单地说，DOM是一种树状结构的节点，包含了网页中的元素、样式和文本。影子DOM是一个JavaScript API，它允许为定制元素创建一个单独的DOM。这意味着自定义元素与页面的其余部分分开呈现。影子DOM通过<strong class="lb iu">影子根</strong>附加到原始DOM，在原始DOM中有一个<strong class="lb iu">影子宿主</strong>。</p><p id="fece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阴影DOM是用一种模式定义的。</p><p id="7dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nq nr ns lw b">let shadow = element.attachShadow({mode: 'open'})</code></p><p id="e88a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将模式设置为open意味着原始DOM中的JavaScript能够访问影子DOM。这也会影响样式，因为打开阴影DOM模式允许将原始DOM的样式设置为其元素。</p><p id="9fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTML模板是一种编写可以在页面上重复的标记的方式。在定义定制元素时，<code class="fe nq nr ns lw b">&lt;template&gt;</code>和<code class="fe nq nr ns lw b">&lt;slot&gt;</code>元素非常有用。模板可以被复制和重用，例如现成的表格行。例如，在使用JavaScript将其内容附加到DOM之前，下面的markdown在页面上是不可见的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="58dd" class="ma mb it lw b gy mc md l me mf">&lt;template id="large-title"&gt;<br/>    &lt;h1&gt;A text within a template&lt;/h1&gt;<br/>&lt;/template&gt;</span></pre><p id="8c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的JavaScript将标题追加到<code class="fe nq nr ns lw b">&lt;body&gt;</code>-元素。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d56c" class="ma mb it lw b gy mc md l me mf">let template = document.getElementById('large-title');<br/>let templateContent = template.content;<br/>document.body.appendChild(templateContent);</span></pre><p id="7019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们编写web组件时，我们可以通过克隆它们并将它们附加到一个影子DOM来使用HTML模板的内容。如果下面的代码让你感到困惑，不要担心！我们将在下一章中浏览一个实际的例子。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f1bc" class="ma mb it lw b gy mc md l me mf">class LargeTitle extends HTMLElement {<br/>    constructor() {</span><span id="80e4" class="ma mb it lw b gy nt md l me mf">      super();</span><span id="9e16" class="ma mb it lw b gy nt md l me mf">      // get the template element and its contents<br/>      let template = document.getElementById('large-title');<br/>      let templateContent = template.content;</span><span id="6733" class="ma mb it lw b gy nt md l me mf">      // create a shadowRoot with open mode<br/>      const shadowRoot = this.attachShadow({mode: 'open'})</span><span id="43a0" class="ma mb it lw b gy nt md l me mf">      // append the cloned content to the shadow root<br/>      shadowRoot.appendChild(templateContent.cloneNode(true));<br/>  }<br/>}</span><span id="c7d5" class="ma mb it lw b gy nt md l me mf">customElements.define('large-title', LargeTitle)</span></pre><h2 id="56e0" class="ma mb it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">编写信息框组件</h2><p id="f486" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">创建自定义元素从创建ES 2015 (Ecmascript 2015)类开始。我们创建一个扩展了<code class="fe nq nr ns lw b">HTMLElement</code>的类，这样它就可以附加到DOM上。构造函数包含设置元素的逻辑。首先，我们需要创建一个shadow root，稍后我们可以将元素附加到它上面。影子根是到原始DOM的连接点。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4669" class="ma mb it lw b gy mc md l me mf">class InfoBox extends HTMLElement {<br/>    constructor() {<br/>        super()</span><span id="cd67" class="ma mb it lw b gy nt md l me mf">        // create shadow root<br/>        const shadowRoot = this.attachShadow({mode: 'open'})<br/>        <br/>        // our code goes here --&gt;<br/>    }<br/>}<br/>// define info-box as a custom element<br/>customElements.define('info-box', InfoBox)</span></pre><p id="6419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们创建了影子根之后，让我们继续定义我们的元素。在我们的信息框中，我们需要一个标题，一个文本和一个按钮。盒子本身是一个<code class="fe nq nr ns lw b">&lt;div&gt;</code>元素。我们使用<code class="fe nq nr ns lw b">document.createElement()</code>创建这些元素。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d885" class="ma mb it lw b gy mc md l me mf">// create a div with the class 'container'<br/>const container = document.createElement('div')<br/>container.setAttribute('class', 'container')</span><span id="d678" class="ma mb it lw b gy nt md l me mf">// create a title<br/>const title = document.createElement('h2')<br/>title.setAttribute('class', 'title')</span><span id="68b5" class="ma mb it lw b gy nt md l me mf">// create the info text <br/>const info = document.createElement('span')<br/>info.setAttribute('class', 'infoText')</span><span id="0578" class="ma mb it lw b gy nt md l me mf">// create the button and add the text "Ok!" to it<br/>const button = document.createElement('button')<br/>button.setAttribute('class', 'okButton')<br/>button.textContent = "Ok!"</span><span id="810a" class="ma mb it lw b gy nt md l me mf">// set the buttons onClick attribute to hide the component<br/>function setHidden() {<br/>    container.setAttribute('hidden', 'true') <br/>}</span><span id="75bf" class="ma mb it lw b gy nt md l me mf">button.onclick = setHidden;</span></pre><p id="0e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定制组件的要点在于它们是可重用和可修改的。例如，我们希望能够在信息框中显示许多不同种类的文本。让我们将标题文本和信息文本设置为HTML中自定义元素的属性。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5fdd" class="ma mb it lw b gy mc md l me mf">&lt;info-box<br/>    title="Library book order"<br/>    info="You have some books waiting for you at the central<br/>    library. Please pick them up within a week." /&gt;</span></pre><p id="c328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以使用这些属性来设置box的文本内容。我们使用<code class="fe nq nr ns lw b">element.getAttribute()</code>-函数来检索<code class="fe nq nr ns lw b">&lt;info-box&gt;</code>元素的属性。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dc03" class="ma mb it lw b gy mc md l me mf">// get the title and info attributes and put them inside <br/>// the info box title and text</span><span id="32ba" class="ma mb it lw b gy nt md l me mf">const titleText = this.getAttribute('title')<br/>title.textContent = titleText;</span><span id="8349" class="ma mb it lw b gy nt md l me mf">const infoText = this.getAttribute('info')<br/>info.textContent = infoText;</span></pre><p id="a683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还想为自定义元素创建样式。我们可以在JavaScript中使用一个模板字符串来做到这一点。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="84db" class="ma mb it lw b gy mc md l me mf">// create styles<br/>const style = document.createElement('style')</span><span id="979c" class="ma mb it lw b gy nt md l me mf">style.textContent =<br/>`.container {<br/>    text-align: center;<br/>    background-color: #fcfc9c;<br/>    border-radius: 10px;<br/>    width: 80%;<br/>}<br/>.title {<br/>    font-size: 1.2em;<br/>    margin: 5px;<br/>}<br/>.infoText { ... }<br/>`</span></pre><p id="a626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，我们现在将已经定义的所有元素附加到影子根。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fd23" class="ma mb it lw b gy mc md l me mf">// append styles and container to the shadow root<br/>shadowRoot.appendChild(style)<br/>shadowRoot.appendChild(container)</span><span id="58b3" class="ma mb it lw b gy nt md l me mf">// append title, info and button to the container<br/>container.appendChild(title)<br/>container.appendChild(info)<br/>container.appendChild(button)</span></pre><h2 id="c2a3" class="ma mb it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">后续步骤</h2><p id="7631" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">关于web组件，我们还没有尝试的一个令人兴奋的事情是它的生命周期回调。您可以利用以下事件来修改组件的功能。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c1a5" class="ma mb it lw b gy mc md l me mf">connectedCallback() {}<br/>disconnectedCallback() {}<br/>adoptedCallback() {}<br/>attributeChangedCallback() {}</span></pre><p id="3e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之前也提到过<code class="fe nq nr ns lw b">&lt;slot&gt;</code>元素，但是我们没有在信息框组件中使用它们。插槽是在元素内部传递DOM元素的一种更方便的方式。也许你可以找到一种方法来重构信息框，这样按钮就可以通过一个槽来传递了。你可以在这里找到一些方便的提示<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="46f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="0694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续使用CodePen中的代码。👇</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="328a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">资源:</strong></p><p id="53bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> MDN: Web组件</a></p><p id="8f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/web-components/" rel="noopener ugc nofollow" target="_blank">谷歌开发者:网络组件</a></p><p id="5c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://syntax.fm/show/143/hasty-treat-the-shadow-dom" rel="noopener ugc nofollow" target="_blank">语法播客:影子DOM </a></p></div></div>    
</body>
</html>