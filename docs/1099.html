<html>
<head>
<title>Building an operator for Kubernetes with the sample-controller</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用样本控制器为Kubernetes构建一个操作符</h1>
<blockquote>原文：<a href="https://itnext.io/building-an-operator-for-kubernetes-with-the-sample-controller-b4204be9ad56?source=collection_archive---------1-----------------------#2018-07-22">https://itnext.io/building-an-operator-for-kubernetes-with-the-sample-controller-b4204be9ad56?source=collection_archive---------1-----------------------#2018-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c43be57bb1ba3febfbb77aee155f4289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLqHLanFn0gixdtJ4ahuZw.jpeg"/></div></div></figure><p id="a2b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一系列文章中，我们将探索一些工具来为Kubernetes创建一个操作符。</p><ul class=""><li id="38bd" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">这第一篇文章将探索样本控制器。</li><li id="11e8" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://medium.com/p/17cbd3f07761" rel="noopener">本系列的第二篇文章</a>将探索kubebuilder。</li><li id="57fc" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://medium.com/p/40a029ea056" rel="noopener">本系列的第三篇文章</a>将探讨operator-sdk。</li></ul><p id="09b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在我的新书中了解更多关于使用Kubernetes API和操作符的信息:<a class="ae lk" href="https://bit.ly/3vsuwI9" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3vsuwI9</a></p><h1 id="9a6f" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">样品控制器</h1><p id="06f2" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们将用来实验创建操作符的第一个工具是样本控制器，你可以在这里找到:<a class="ae lk" href="https://github.com/kubernetes/sample-controller" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes/sample-controller</a>。</p><p id="56e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个项目为<code class="fe mo mp mq mr b">Foo</code>类型实现了一个简单的操作符，当我们创建一个定制对象<code class="fe mo mp mq mr b">foo</code>时，它将创建一个带有一些公共Docker映像和特定数量副本的部署。</p><p id="9958" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要安装和构建它，一定要定义GOPATH，然后运行:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="7e55" class="na lm iq mr b gy nb nc l nd ne">go get github.com/kubernetes/sample-controller<br/>cd $GOPATH/src/k8s.io/sample-controller<br/>go build -o ctrl .</span></pre><p id="f39c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以为<code class="fe mo mp mq mr b">Foo</code>类型创建定制资源定义，文件位于<code class="fe mo mp mq mr b">artifacts/examples</code>子目录中:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="485d" class="na lm iq mr b gy nb nc l nd ne">kubectl apply -f artifacts/examples/crd-validation.yaml</span></pre><p id="ec91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后运行控制器:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="7137" class="na lm iq mr b gy nb nc l nd ne">./ctrl -kubeconfig ~/.kube/config  -logtostderr=true</span></pre><p id="985b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在从另一个终端，我们可以操纵<code class="fe mo mp mq mr b">Foo</code>对象，看看控制器会发生什么:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="25a7" class="na lm iq mr b gy nb nc l nd ne">$ kubectl apply -f artifacts/examples/example-foo.yaml<br/>$ kubectl get pods<br/>NAME                           READY  STATUS    RESTARTS   AGE<br/>example-foo-6cbc69bf5d-j8lhx   1/1    Running   0          18s</span><span id="c790" class="na lm iq mr b gy nf nc l nd ne">$ kubectl delete -f artifacts/examples/example-foo.yaml<br/>$ kubectl get pods<br/>NAME                           READY  STATUS        RESTARTS   AGE<br/>example-foo-6cbc69bf5d-j8lhx   0/1    Terminating   0          38s</span></pre><blockquote class="ng nh ni"><p id="dd44" class="jy jz nj ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated">在编写和使用Kubernetes 1.11.0时，控制器在创建部署后更新<code class="fe mo mp mq mr b">foo</code>对象的状态时将进入无限循环:在<code class="fe mo mp mq mr b">updateFooStatus</code>函数中，您必须通过调用<code class="fe mo mp mq mr b">UpdateStatus(fooCopy)</code>来更改对<code class="fe mo mp mq mr b">Update(fooCopy)</code>的调用。</p></blockquote><p id="3c99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，控制器完成了工作:当我们创建一个<code class="fe mo mp mq mr b">foo</code>对象时，它创建一个部署，当我们删除对象时，它停止部署。</p><p id="39cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以进一步修改CRD和控制器，以使用我们自己的自定义资源定义。</p><h2 id="01ec" class="na lm iq bd ln nn no dn lr np nq dp lv kj nr ns lz kn nt nu md kr nv nw mh nx bi translated">调整样品控制器</h2><p id="3e98" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">假设我们的目标是编写一个在集群节点上部署守护进程的操作符。它将使用<code class="fe mo mp mq mr b">DaemonSet</code>对象来部署这个守护进程，我们希望能够指定一个标签，以便只在用这个标签标记的节点上部署守护进程。我们还希望能够指定要部署的Docker映像，而不是像sample-controller那样的静态映像。</p><p id="8fbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先为我们的<code class="fe mo mp mq mr b">GenericDaemon</code>类型创建定制资源定义:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="fe23" class="na lm iq mr b gy nb nc l nd ne">// artifacts/generic-daemon/crd.yaml<br/>apiVersion: apiextensions.k8s.io/v1beta1<br/>kind: CustomResourceDefinition<br/>metadata:<br/>  name: genericdaemons.mydomain.com<br/>spec:<br/>  group: mydomain.com<br/>  version: v1beta1<br/>  names:<br/>    kind: Genericdaemon<br/>    plural: genericdaemons<br/>  scope: Namespaced<br/>  validation:<br/>    openAPIV3Schema:<br/>      properties:<br/>        spec:<br/>          properties:<br/>            label:<br/>              type: string<br/>            image:<br/>              type: string<br/>          required:<br/>            - image</span></pre><p id="3ecc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个要部署的守护程序示例:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="9d29" class="na lm iq mr b gy nb nc l nd ne">// artifacts/generic-daemon/syslog.yaml<br/>apiVersion: mydomain.com/v1beta1<br/>kind: Genericdaemon<br/>metadata:<br/>  name: syslog<br/>spec:<br/>  label: logs<br/>  image: mbessler/syslogdocker</span></pre><p id="6f67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在必须为API构建go文件，这是从我们的操作符访问这个新的定制资源定义所必需的。为此，让我们创建一个新的目录<code class="fe mo mp mq mr b">pkg/apis/genericdaemon</code>，在其中我们将复制在<code class="fe mo mp mq mr b">pkg/apis/samplecontroller</code>中找到的文件(但是是<code class="fe mo mp mq mr b">zz_generated.deepcopy.go</code>中的文件)</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="0049" class="na lm iq mr b gy nb nc l nd ne">$ tree pkg/apis/genericdaemon/<br/>pkg/apis/genericdaemon/<br/>├── register.go<br/>└── v1beta1<br/>    ├── doc.go<br/>    ├── register.go<br/>    └── types.go</span></pre><p id="2a71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并修改其内容(更改的部分以粗体显示):</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="e056" class="na lm iq mr b gy nb nc l nd ne">////////////////<br/>// register.go<br/>////////////////</span><span id="893c" class="na lm iq mr b gy nf nc l nd ne">package <strong class="mr ir">genericdaemon</strong></span><span id="9669" class="na lm iq mr b gy nf nc l nd ne">const (<br/> GroupName = "<strong class="mr ir">mydomain.com</strong>"<br/>)</span><span id="c56a" class="na lm iq mr b gy nf nc l nd ne">/////////////////////<br/>// v1beta1/doc.go<br/>/////////////////////</span><span id="b206" class="na lm iq mr b gy nf nc l nd ne">// +k8s:deepcopy-gen=package</span><span id="5f7c" class="na lm iq mr b gy nf nc l nd ne">// Package <strong class="mr ir">v1beta1</strong> is the <strong class="mr ir">v1beta1</strong> version of the API.<br/>// +groupName=<strong class="mr ir">mydomain.com</strong><br/>package <strong class="mr ir">v1beta1</strong></span><span id="e816" class="na lm iq mr b gy nf nc l nd ne">/////////////////////////<br/>// v1beta1/register.go<br/>/////////////////////////</span><span id="fee6" class="na lm iq mr b gy nf nc l nd ne">package <strong class="mr ir">v1beta1</strong></span><span id="c186" class="na lm iq mr b gy nf nc l nd ne">import (<br/> metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"<br/> "k8s.io/apimachinery/pkg/runtime"<br/> "k8s.io/apimachinery/pkg/runtime/schema"</span><span id="f9f6" class="na lm iq mr b gy nf nc l nd ne"><strong class="mr ir">genericdaemon</strong> "k8s.io/sample-controller/pkg/apis/<strong class="mr ir">genericdaemon</strong>"<br/>)</span><span id="6903" class="na lm iq mr b gy nf nc l nd ne">// SchemeGroupVersion is group version used to register these objects<br/>var SchemeGroupVersion = schema.GroupVersion{Group: <strong class="mr ir">genericdaemon</strong>.GroupName, Version: "<strong class="mr ir">v1beta1</strong>"}</span><span id="7672" class="na lm iq mr b gy nf nc l nd ne">// Kind takes an unqualified kind and returns back a Group qualified GroupKind<br/>func Kind(kind string) schema.GroupKind {<br/> return SchemeGroupVersion.WithKind(kind).GroupKind()<br/>}</span><span id="b8ae" class="na lm iq mr b gy nf nc l nd ne">// Resource takes an unqualified resource and returns a Group qualified GroupResource<br/>func Resource(resource string) schema.GroupResource {<br/> return SchemeGroupVersion.WithResource(resource).GroupResource()<br/>}</span><span id="b187" class="na lm iq mr b gy nf nc l nd ne">var (<br/> SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)<br/> AddToScheme   = SchemeBuilder.AddToScheme<br/>)</span><span id="6db5" class="na lm iq mr b gy nf nc l nd ne">// Adds the list of known types to Scheme.<br/>func addKnownTypes(scheme *runtime.Scheme) error {<br/> scheme.AddKnownTypes(SchemeGroupVersion,<br/>  &amp;<strong class="mr ir">Genericdaemon</strong>{},<br/>  &amp;<strong class="mr ir">GenericdaemonList</strong>{},<br/> )<br/> metav1.AddToGroupVersion(scheme, SchemeGroupVersion)<br/> return nil<br/>}</span><span id="fc84" class="na lm iq mr b gy nf nc l nd ne">//////////////////////<br/>// v1beta1/types.go<br/>//////////////////////</span><span id="18a0" class="na lm iq mr b gy nf nc l nd ne">package <strong class="mr ir">v1beta1</strong></span><span id="87b7" class="na lm iq mr b gy nf nc l nd ne">import (<br/> metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"<br/>)</span><span id="db81" class="na lm iq mr b gy nf nc l nd ne">// +genclient<br/>// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><span id="3758" class="na lm iq mr b gy nf nc l nd ne">// <strong class="mr ir">Genericdaemon</strong> is a specification for a <strong class="mr ir">Generic Daemon</strong> resource<br/>type <strong class="mr ir">Genericdaemon</strong> struct {<br/> metav1.TypeMeta   `json:",inline"`<br/> metav1.ObjectMeta `json:"metadata,omitempty"`</span><span id="7805" class="na lm iq mr b gy nf nc l nd ne"> Spec   <strong class="mr ir">GenericdaemonSpec</strong>   `json:"spec"`<br/> Status <strong class="mr ir">GenericdaemonStatus</strong> `json:"status"`<br/>}</span><span id="b11c" class="na lm iq mr b gy nf nc l nd ne">// <strong class="mr ir">GenericDaemonSpec</strong> is the spec for a <strong class="mr ir">GenericDaemon</strong> resource<br/>type <strong class="mr ir">GenericdaemonSpec</strong> struct {<br/><strong class="mr ir"> Label string `json:"label"`<br/> Image string `json:"image"`</strong><br/>}</span><span id="1646" class="na lm iq mr b gy nf nc l nd ne">// <strong class="mr ir">GenericDaemonStatus</strong> is the status for a <strong class="mr ir">GenericDaemon</strong> resource<br/>type <strong class="mr ir">GenericdaemonStatus</strong> struct {<br/><strong class="mr ir"> Installed int32 `json:"installed"`<br/></strong>}</span><span id="a396" class="na lm iq mr b gy nf nc l nd ne">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><span id="1e32" class="na lm iq mr b gy nf nc l nd ne">// <strong class="mr ir">GenericDaemonList</strong> is a list of <strong class="mr ir">GenericDaemon</strong> resources<br/>type <strong class="mr ir">GenericdaemonList</strong> struct {<br/> metav1.TypeMeta `json:",inline"`<br/> metav1.ListMeta `json:"metadata"`</span><span id="2829" class="na lm iq mr b gy nf nc l nd ne">Items []<strong class="mr ir">Genericdaemon</strong> `json:"items"`<br/>}</span></pre><p id="1056" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个脚本<code class="fe mo mp mq mr b">hack/update-codegen.sh</code>可用于围绕我们用这些先前的文件定义的新的定制资源定义生成代码。我们必须修改这个脚本来为我们的新CRD生成文件:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="3103" class="na lm iq mr b gy nb nc l nd ne">// hack/update-codegen.sh<br/>#!/usr/bin/env bash</span><span id="e400" class="na lm iq mr b gy nf nc l nd ne">set -o errexit<br/>set -o nounset<br/>set -o pipefail</span><span id="0a82" class="na lm iq mr b gy nf nc l nd ne">SCRIPT_ROOT=$(dirname ${BASH_SOURCE})/..<br/>CODEGEN_PKG=${CODEGEN_PKG:-$(cd ${SCRIPT_ROOT}; ls -d -1 ./vendor/k8s.io/code-generator 2&gt;/dev/null || echo ../code-generator)}</span><span id="2c88" class="na lm iq mr b gy nf nc l nd ne"># generate the code with:<br/># --output-base    because this script should also be able to run inside the vendor dir of<br/>#                  k8s.io/kubernetes. The output-base is needed for the generators to output into the vendor dir<br/>#                  instead of the $GOPATH directly. For normal projects this can be dropped.<br/>${CODEGEN_PKG}/generate-groups.sh "deepcopy,client,informer,lister" \<br/>  k8s.io/sample-controller/pkg/client k8s.io/sample-controller/pkg/apis \<br/>  <strong class="mr ir">genericdaemon:v1beta1</strong> \<br/>  --output-base "$(dirname ${BASH_SOURCE})/../../.." \<br/>  --go-header-file ${SCRIPT_ROOT}/hack/boilerplate.go.txt</span></pre><p id="efb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后执行它:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="6f3b" class="na lm iq mr b gy nb nc l nd ne">$ ./hack/update-codegen.sh <br/>Generating deepcopy funcs<br/>Generating clientset for genericdaemon:v1beta1 at k8s.io/sample-controller/pkg/client/clientset<br/>Generating listers for genericdaemon:v1beta1 at k8s.io/sample-controller/pkg/client/listers<br/>Generating informers for genericdaemon:v1beta1 at k8s.io/sample-controller/pkg/client/informers</span></pre><p id="48c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以调整我们的操作符。首先，我们必须用<code class="fe mo mp mq mr b">Genericdaemon</code>类型改变所有对先前<code class="fe mo mp mq mr b">Foo</code>类型的引用。其次，当创建一个新的通用守护进程时，我们必须创建一个守护进程集，而不是一个部署(这里没有显示)。</p><h2 id="1550" class="na lm iq bd ln nn no dn lr np nq dp lv kj nr ns lz kn nt nu md kr nv nw mh nx bi translated">将操作员部署到Kubernetes集群</h2><p id="a8c1" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">当我们根据需要修改完sample-controller之后，我们需要将它部署到kubernetes集群中。事实上，此时，我们已经通过使用我们的凭证从我们的开发系统运行它来测试它。</p><p id="42e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个简单的Docker文件，用于使用操作符构建Docker映像(要构建映像，您必须删除原始sample-controller中的所有代码):</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="251b" class="na lm iq mr b gy nb nc l nd ne">FROM golang</span><span id="0e93" class="na lm iq mr b gy nf nc l nd ne">RUN mkdir -p /go/src/k8s.io/sample-controller<br/>ADD . /go/src/k8s.io/sample-controller<br/>WORKDIR /go</span><span id="8166" class="na lm iq mr b gy nf nc l nd ne">RUN go get ./...<br/>RUN go install -v ./...</span><span id="1ec8" class="na lm iq mr b gy nf nc l nd ne">CMD ["/go/bin/sample-controller"]</span></pre><p id="a909" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以构建映像并将其推送到Docker Hub:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="35cf" class="na lm iq mr b gy nb nc l nd ne">docker build . -t mydockerid/genericdaemon<br/>docker push mydockerid/genericdaemon</span></pre><p id="a37b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，使用这个新映像开始部署:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="8d84" class="na lm iq mr b gy nb nc l nd ne">// deploy.yaml<br/>apiVersion: apps/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: sample-controller<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: sample<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: sample<br/>    spec:<br/>      containers:<br/>      - name: sample<br/>        image: "mydockerid/genericdaemon:latest"</span></pre><p id="2e77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和<code class="fe mo mp mq mr b">kubectl apply -f deploy.yaml</code></p><p id="8b6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">操作员现在正在运行，但是如果我们检查pod的日志，我们可以看到授权存在问题；pod没有对不同资源的访问权限:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="8c1e" class="na lm iq mr b gy nb nc l nd ne">$ kubectl logs sample-controller-66b79c7d5f-2qnft<br/>E0721 14:34:50.499584       1 reflector.go:134] k8s.io/sample-controller/pkg/client/informers/externalversions/factory.go:117: Failed to list *v1beta1.Genericdaemon: genericdaemons.mydomain.com is forbidden: User "system:serviceaccount:default:default" cannot list genericdaemons.mydomain.com at the cluster scope<br/>E0721 14:34:50.500385       1 reflector.go:134] k8s.io/client-go/informers/factory.go:131: Failed to list *v1.DaemonSet: daemonsets.apps is forbidden: User "system:serviceaccount:default:default" cannot list daemonsets.apps at the cluster scope<br/>[...]</span></pre><p id="0956" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要创建一个<code class="fe mo mp mq mr b">ClusterRole</code>和一个<code class="fe mo mp mq mr b">ClusterRoleBinding</code>来给操作员必要的特权:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="f9c4" class="na lm iq mr b gy nb nc l nd ne">// rbac_role.yaml<br/>kind: ClusterRole<br/>metadata:<br/>  name: operator-role<br/>rules:<br/>- apiGroups:<br/>  - apps<br/>  resources:<br/>  - daemonsets<br/>  verbs:<br/>  - get<br/>  - list<br/>  - watch<br/>  - create<br/>  - update<br/>  - patch<br/>  - delete<br/>- apiGroups:<br/>  - mydomain.com<br/>  resources:<br/>  - genericdaemons<br/>  verbs:<br/>  - get<br/>  - list<br/>  - watch<br/>  - create<br/>  - update<br/>  - patch<br/>  - delete</span><span id="dbbb" class="na lm iq mr b gy nf nc l nd ne">// rbac_role_binding.yaml<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>kind: ClusterRoleBinding<br/>metadata:<br/>  name: operator-rolebinding<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: ClusterRole<br/>  name: operator-role<br/>subjects:<br/>- kind: ServiceAccount<br/>  name: default<br/>  namespace: default</span></pre><p id="f980" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并部署它:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="085a" class="na lm iq mr b gy nb nc l nd ne">kubectl apply -f rbac_role.yaml<br/>kubectl delete -f deploy.yaml<br/>kubectl apply -f deploy.yaml</span></pre><p id="afb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您的操作员应该被部署到您的Kubernetes集群中并处于活动状态。</p><h1 id="8487" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">下一步是什么</h1><p id="db27" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在下一篇文章中，我们将探索kubebuilder，它将为我们提供自动化所有这些步骤的工具。</p></div></div>    
</body>
</html>