<html>
<head>
<title>Writing Redux in 15 lines of code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用15行代码编写Redux</h1>
<blockquote>原文：<a href="https://itnext.io/writing-redux-in-15-lines-of-code-6d317b521719?source=collection_archive---------5-----------------------#2018-10-11">https://itnext.io/writing-redux-in-15-lines-of-code-6d317b521719?source=collection_archive---------5-----------------------#2018-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="87e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2020年更新:</strong>你可能有兴趣学习如何从头开始构建一个商店，它使用Redux Devtools，并使用React挂钩在任何地方访问它:</p><div class="kl km gp gr kn ko"><a href="https://medium.com/@dominictobias/using-react-hooks-for-global-redux-stores-97c092afe210" rel="noopener follow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">对全局Redux存储使用React挂钩</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">当hooks问世时，有各种各样的文章暗示Redux可能不再需要，而像这样的反驳…</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">medium.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ld ko"/></div></div></a></div></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="a929" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我今天写这篇文章的灵感来自于一位新加入React的同事，他抱怨说在使用Redux(和Redux-Saga)时有太多的样板文件。所以我把这些放在一起有几个原因:</p><ol class=""><li id="5c4b" class="ll lm iq jp b jq jr ju jv jy ln kc lo kg lp kk lq lr ls lt bi translated">我们错误地认为冗长对于单向数据流是必要的。</li><li id="013c" class="ll lm iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">我们使用Redux并不了解它是如何工作的。</li></ol><p id="0c4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的简单Redux商店，我们需要以下功能:</p><ul class=""><li id="54c8" class="ll lm iq jp b jq jr ju jv jy ln kc lo kg lp kk lz lr ls lt bi translated">更新商店状态的函数(因为我们需要在状态改变时通知订户)——<strong class="jp ir"><em class="ma">更新(storeKey，updateFn) </em> </strong></li><li id="178f" class="ll lm iq jp b jq lu ju lv jy lw kc lx kg ly kk lz lr ls lt bi translated">订阅更新功能— <strong class="jp ir"> <em class="ma">【订阅(fn) </em> </strong></li><li id="a3d5" class="ll lm iq jp b jq lu ju lv jy lw kc lx kg ly kk lz lr ls lt bi translated">获取内部状态的函数(这不是必需的，但鼓励用户不要直接操作状态对象)——<strong class="jp ir"><em class="ma">getState()</em></strong></li></ul><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="d504" class="mk ml iq mg b gy mm mn l mo mp">class Store {<br/>  constructor(initialState) {<br/>    this.state = initialState;<br/>    this.subscriptions = [];<br/>  }<br/>  update(storeKey, updateFn) {<br/>    const nextStoreState = updateFn(this.state[storeKey]);<br/>    if (this.state[storeKey] !== nextStoreState) {<br/>      this.state[storeKey] = nextStoreState;<br/>      this.subscriptions.forEach(f =&gt; f(store));<br/>    }<br/>  }<br/>  subscribe = fn =&gt; this.subscriptions.push(fn)<br/>  getState = () =&gt; this.state<br/>}</span></pre><p id="8ee1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ma">注意没有换行符来保留我吸引人的标题</em></p><p id="9b38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单，对吧？现在，每次商店更新时，我们都希望调用<em class="ma"> ReactDOM.render </em>来重新呈现我们的应用程序。稍后我们可以添加一个类似于<em class="ma"> redux-connect </em>的特设组件来包装我们的根组件以处理更新，并在应用程序中的任何地方传递商店道具(第二部分有人知道吗？).</p><p id="fc7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过一个简单的演示来看看这一点。</p><figure class="mb mc md me gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能已经注意到了下面的方法:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ffe9" class="mk ml iq mg b gy mm mn l mo mp">increaseUserAge = () =&gt; {<br/>  this.props.store.update('user', state =&gt; ({<br/>    ...state,<br/>    age: state.age + 2,<br/>  }));<br/>}</span></pre><h1 id="5eb9" class="mt ml iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">听着妈妈，不要行动！</h1><p id="275b" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">然而，数据仍然是单向流动的。没有什么能阻止我们将更新提取到可重用且易于测试的功能中:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8d1f" class="mk ml iq mg b gy mm mn l mo mp">// Somewhere else.<br/>function fetchUserDetailsAction(store) {<br/>  const { user } = store.getState();</span><span id="f6b1" class="mk ml iq mg b gy nv mn l mo mp">  if (!user.fetched) {<br/>    $get('/user/123').then(user =&gt; store.update('user', user));<br/>  }<br/>}</span><span id="a0c3" class="mk ml iq mg b gy nv mn l mo mp">// In your Component<br/>componentDidMount() {<br/>  fetchUserDetailsAction(this.props.store);<br/>}</span></pre><h1 id="9045" class="mt ml iq bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">“但我喜欢减速器和行动🤬"</h1><p id="99d7" class="pw-post-body-paragraph jn jo iq jp b jq nq js jt ju nr jw jx jy ns ka kb kc nt ke kf kg nu ki kj kk ij bi translated">如上所述，可以提取复杂的状态更新，而无需采取行动。但是我也喜欢减速器。它们将每个存储节点的数据操作保存在一个地方。</p><p id="d6c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有什么能阻止我们拥有一个<code class="fe nw nx ny mg b">reducers/user.js</code>文件:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e022" class="mk ml iq mg b gy mm mn l mo mp">const userReducer = {<br/>  increaseUserAge: (state, ageIncrease) =&gt; ({<br/>    ...state,<br/>    age: state.age + ageIncrease,<br/>  }),<br/>  setUserEmail: (state, email) =&gt; ({<br/>    ...state,<br/>    email,<br/>  }),<br/>};</span></pre><p id="6747" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用这个来代替:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5201" class="mk ml iq mg b gy mm mn l mo mp">increaseUserAge = () =&gt; {<br/>  this.props.store.update('user', state =&gt;<br/>    userReducer.increaseUserAge(state, 2));<br/>}</span></pre><p id="b83b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">动作也有超出逻辑封装的目的；<strong class="jp ir">时间旅行</strong>。我们可以记录和重放动作，这对于调试来说非常方便！我们可以通过命名我们的行为来达到类似的目的</p><p id="e997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想在这里展示一些基本原则，并表明如果你愿意，你可以拥有一个非常精简的商店更新周期。</p><p id="d18d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的下一步将是添加一个<strong class="jp ir"> <em class="ma"> connect() </em> </strong>函数，这样我们就可以将我们的应用程序包装在一个特设中，这样我们就可以像<em class="ma"> redux-connect </em>那样将状态片段作为道具传递给组件。</p></div></div>    
</body>
</html>