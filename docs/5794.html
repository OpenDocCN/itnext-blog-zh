<html>
<head>
<title>Why Functional JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么选择功能性JS</h1>
<blockquote>原文：<a href="https://itnext.io/why-functional-js-4e61f5e7bb55?source=collection_archive---------6-----------------------#2021-05-26">https://itnext.io/why-functional-js-4e61f5e7bb55?source=collection_archive---------6-----------------------#2021-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b4df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于“你建议如何从FP开始？”的一些想法我在米兰Codemotion 2019演讲后的问题。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f11286b3cb347b81942d884ee3c9de72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ymwP1I5Lz1ZO__z63zmuA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">塞缪尔·费拉拉在<a class="ae le" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="caab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2019年10月24日，我在意大利米兰的<a class="ae le" href="https://events.codemotion.com/conferences/milan/2019/speaker/6205/" rel="noopener ugc nofollow" target="_blank"> Codemotion </a>大会上做了第一次演讲。我谈到了函数式编程，以及在处理复杂的现实问题(如可维护性、可伸缩性和错误处理)时，它如何使我们的生活变得更容易。</p><p id="5169" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很多人问我:“你会怎么推荐从FP开始？”答案很简单。如果在80年代问同样的问题，我的答案会完全不同。但是今天，随着前端开发变得越来越复杂，我建议从函数型脚本开始。</p><p id="6016" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么？让我们来了解一下！</p><h1 id="1c16" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不确定</h1><p id="5546" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">从本质上讲，函数式编程迫使你编写纯函数，原因很简单:我们需要从计算中得到确定性的结果。例如，如果我们正在处理一个依赖于用户输入的函数…会有多少事情出错？用户可能插入错误或不完整的输入；连接可能会失败，向服务器发送数据可能需要一个HTTP请求，这个请求可能会因为几个原因而失败…我们从来不确定一切会像我们想象的那样进行。我们究竟怎样才能从这些混乱中得到一个确定性的结果呢？到处放<code class="fe mi mj mk ml b">try/catch</code>？创建一个巨大的<code class="fe mi mj mk ml b">if/else</code>控制结构？我们知道一种更优雅的方式。在“处理try/catch和if/else hell”这篇文章中，我们看到了单子如何帮助我们改进代码流和弹性。</p><ul class=""><li id="be1d" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated">数据可能导致错误？让我们用任一单子。它将总是返回两个值:<code class="fe mi mj mk ml b">Right(&lt;desired-data&gt;)</code>和<code class="fe mi mj mk ml b">Left(&lt;error-wrapper&gt;)</code>。</li><li id="a1fb" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">数据可能因为某种原因是<code class="fe mi mj mk ml b">null</code>还是<code class="fe mi mj mk ml b">undefined</code>？也许莫纳德来救援了！我们的数据将被包装在<code class="fe mi mj mk ml b">Just(&lt;data&gt;)</code>中，如果它存在的话。否则，我们只需要处理一个<code class="fe mi mj mk ml b">Nothing</code>值。不再有<code class="fe mi mj mk ml b">null</code> / <code class="fe mi mj mk ml b">undefined</code> / <code class="fe mi mj mk ml b">void 0</code>。</li><li id="edd2" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">数据存在，但我们有它的一个或多个副本？单子单子会是你的朋友！</li><li id="87a4" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">数据依赖于状态吗？状态monad会帮到你很多！</li></ul><p id="3582" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">等等，等等，等等！</p><p id="de0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这有什么意义？在构造函数时，我们总是会从不确定的操作中得到可预测的结果。</p><h1 id="071e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">类型</h1><p id="5541" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在开始时，我说过我会推荐函数式类型脚本。但是我们真的需要类型来使我们的代码起作用吗？当然不会。Erlang、Elixir、LISP，只是动态类型函数式语言的一个简短列表。这些语言有一些很好的理由成为动态类型。他们经常提供一些分析工具，如Erlang的<a class="ae le" href="http://erlang.org/doc/man/dialyzer.html" rel="noopener ugc nofollow" target="_blank">透析器</a>，这是一种“静态分析工具，可以识别软件差异，如明确的类型错误，由于编程错误而变得无效或不可访问的代码，以及单个Erlang模块或整个(多组)应用程序中不必要的测试。”</p><p id="7c54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JavaScript没有这种现成的东西，所以我们需要采取一些预防措施。<a class="ae le" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank"> Flow </a>和<a class="ae le" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>只是JavaScript社区试图避免一些众所周知的运行时类型错误的几个例子，他们做得非常出色。它们也帮助我们更容易地阅读我们的代码。你有多少次因为类型错误而用调试器运行你的JS代码？在你的代码中找出那种讨厌的错误有多难？嗯，这可能是微不足道的，但有了Flow或TypeScript，您再也不会遇到这些错误了。</p><p id="8eb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当使用Haskell或Idris等强类型函数式语言编写时，可以更好地查看数据。</p><p id="c987" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在函数式编程中，函数描述你的数据。类型也描述了你的数据。在计算过程中，你必须始终关注数据是如何被操作的。</p><h1 id="2901" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么从功能前端开始？</h1><p id="806e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">原因很简单:你会立即看到结果。假设我们正在使用Laravel、Spring或Ruby on Rails从头开始编写一个博客平台，比如WordPress。用户正在登录，后端出现错误。没问题，我们向前端发送一个错误，用户会被警告。我们的后端流量通常是定义良好的，我们习惯于处理这些错误。</p><p id="cf30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在前端，任何事情都可能发生。我们一直在努力处理由于用户的意外行为而可能发生的许多错误。而且即使用户按预期在使用我们的前端，互联网连接也可能会瘫痪；服务器崩溃。出于某种原因，一个第三方脚本与我们的JavaScript代码库交互并使其崩溃。</p><p id="89f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过采用一种新的方式对我们的前端应用程序进行编程，以最小的努力开始处理所有这些情况。</p><p id="55f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在编写前端JavaScript应用程序时，还需要记住另一件事:脚本大小。好吧，我们是在2020年，即使在山区我们也有快速的互联网连接，但为什么我们的用户要下载一个5MB的脚本来浏览我们的网站？</p><p id="394a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">纯函数允许我们轻松地重用代码。一个更加模块化的代码库意味着我们可以一次定义我们的函数，并在我们需要的时候重用它们。我们不需要编写只在某个类内部起作用的私有类方法，也不希望仅仅因为某些方法依赖于某个隐藏状态就重写它们(这样它们就不会在某个类之外起作用)。我们希望我们的函数尽可能地可重用，这样我们的代码库将会增长，而不会向我们的包中添加千字节的重复函数。</p><h1 id="ad3d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="67dc" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当编写服务器端应用程序时，你可能不会觉得需要一个功能代码库，直到你的软件开始出现一些伸缩问题。从面向对象架构过渡到功能性架构可以极大地减少服务器数量的例子数不胜数。当然，FP的优势不仅仅在于可伸缩性，还在于代码可维护性、测试、模块化、错误处理(等等)。</p><p id="ec86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现JavaScript是前端和后端之间的通用语言。因此，将你的FP知识从前端开发转移到后端开发会更容易，反之亦然。Frontend也有一些有趣的例子(正如我们前面看到的),在这些例子中，FP实际上可以发挥作用。</p><p id="0a8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，对于那些不知道从哪里开始学习FP的人，我的回答是:从JavaScript开始。如果您不熟悉TypeScript/Flow，请尝试一下。他们将永远改变你写JS的方式！</p><p id="b143" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦你对函数式JS有了信心，切换到其他语言将会容易得多！</p></div></div>    
</body>
</html>