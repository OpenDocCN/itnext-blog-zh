<html>
<head>
<title>An update to the FragmentViewBindingDelegate: the bug we’ve inherited from AutoClearedValue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FragmentViewBindingDelegate的更新:我们从AutoClearedValue继承的错误</h1>
<blockquote>原文：<a href="https://itnext.io/an-update-to-the-fragmentviewbindingdelegate-the-bug-weve-inherited-from-autoclearedvalue-7fc0a89fcae1?source=collection_archive---------2-----------------------#2021-01-24">https://itnext.io/an-update-to-the-fragmentviewbindingdelegate-the-bug-weve-inherited-from-autoclearedvalue-7fc0a89fcae1?source=collection_archive---------2-----------------------#2021-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fd417ca046dde4492663049ab49f08a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sRpVsqc0zugRE1AALO-7mQ.png"/></div></div></figure><p id="bccb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Jetpack生命周期非常强大。我们可以提取逻辑，并使其具有生命周期意识。事实上，这让我们在之前的文章中简化了视图绑定，使之成为一行。</p><p id="9506" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我需要提供一个快速的提示:事情并不像看上去的那样。</p><p id="73ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提供的要点和代码片段假设<a class="ae kw" href="https://github.com/android/architecture-components-samples/blob/7466ae2015bb9bd9cf2c435a350070b29d71fd2b/GithubBrowserSample/app/src/main/java/com/android/example/github/util/AutoClearedValue.kt" rel="noopener ugc nofollow" target="_blank">自动清除值</a>中的代码总是正确的。在这篇文章中，我将告诉你如何打破它。</p><h1 id="e4a6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">原始来源</h1><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1671" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AutoClearedValue背后的一般思想是，这个委托隐藏的值只有在设置时才会被创建(在我们的例子中，当它被访问时)，当<code class="fe mb mc md me b">viewLifecycleOwner</code>变成<code class="fe mb mc md me b">DESTROYED</code>时，它会将该值置空。有道理，对吧？</p><p id="4103" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了访问视图生命周期，代码一直等到<code class="fe mb mc md me b">Fragment.onCreate()</code>，并在那里注册生命周期观察者。</p><p id="b49f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，使用片段作为生命周期所有者(！)，它试图在视图生命周期所有者上注册一个生命周期观察者。</p><h1 id="44f2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">隐藏在众目睽睽之下的臭虫</h1><p id="5083" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">问题是视图生命周期有可能以这样一种方式初始化，即<code class="fe mb mc md me b">fragment.onStart()</code>和<code class="fe mb mc md me b">viewLifecycleOwner.lifecycle.addObserver </code>实际上从未发生。片段直接从<code class="fe mb mc md me b">onViewCreated</code>到<code class="fe mb mc md me b">onDestroyView</code>。</p><p id="4cdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">意思，<code class="fe mb mc md me b">fragment.onStart()</code>和<code class="fe mb mc md me b">fragment.onStop()</code>永远不会发生。</p><p id="c43e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着<code class="fe mb mc md me b">fragment.viewLifecycleOwner.observe(fragment)</code>永远不会是<code class="fe mb mc md me b">ACTIVE</code>，因此<code class="fe mb mc md me b">observe</code>块永远不会被调用。viewLifecycle到达<code class="fe mb mc md me b">DESTROYED</code>而没有被观察到。</p><h1 id="b4b6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">这是什么时候发生的？</h1><p id="e6fc" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">如果一个片段被添加了<code class="fe mb mc md me b">commitNow()</code>，但随后被<code class="fe mb mc md me b">detach()</code>编辑。这意味着这可能发生在<code class="fe mb mc md me b">FragmentPagerAdapter</code>上，因为它也使用了引擎盖下的<code class="fe mb mc md me b">attach/detach</code>。</p><p id="8bb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，bug是在使用绑定和下面的构造时出现的:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">使用附加/分离创建添加了片段的底部导航视图</figcaption></figure><p id="39f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在底部导航视图的情况下，添加了片段，但是附加/分离了,<code class="fe mb mc md me b">binding</code>变量中的视图可能被卡住:因为它从未被清除。</p><p id="e8a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码应该已经开箱即用了，但显然它达到了一个相当不寻常的场景:一个片段立即破坏了它的视图，甚至没有到达<code class="fe mb mc md me b">onStart()</code>和<code class="fe mb mc md me b">onStop()</code>。</p><h1 id="49e8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">怎么修？</h1><p id="5b58" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">由于问题是由使用<code class="fe mb mc md me b">fragment</code>作为生命周期所有者以观察<code class="fe mb mc md me b">viewLifecycleOwnerLiveData</code>引起的(由于视图生命周期所有者可以到达<code class="fe mb mc md me b">DESTROYED</code>而<code class="fe mb mc md me b">fragment</code>不会到达<code class="fe mb mc md me b">STARTED</code>)，解决方案是不使用片段作为生命周期所有者。</p><p id="9c3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，使用<code class="fe mb mc md me b">observeForever</code>跳过了由生命周期所有者激活LiveData的需要。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7bdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在使用绑定，您可能需要相应地更新您的绑定。</p><h1 id="ec74" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="a9c9" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">虽然Jetpack生命周期本身看起来可靠而强大，但它的一些移动元素之间的交互——在本例中是片段生命周期和片段视图生命周期——可能会导致令人惊讶的结果。</p><p id="e6a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当视图生命周期变得与片段生命周期相同时，这方面的错误空间很有可能会减少，并且只需要担心一个生命周期——尽管这是一个关于何时会发生的好问题(片段1.4.0？)，以及它还会有什么其他的影响(导航的时候会需要<code class="fe mb mc md me b">addToBackStack()</code>让一个<code class="fe mb mc md me b">viewModelStore</code>活着吗？会如何改变<code class="fe mb mc md me b">setMaxLifecycle(CREATED)</code>的行为？)</p><p id="f6c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不管怎样，这是一个任何依赖AutoClearedValue行为的人都会继承的错误。</p><p id="2c96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在某种程度上，这是一个有趣的洞察，就像一个活动可以直接从<code class="fe mb mc md me b">onCreate</code>到<code class="fe mb mc md me b">onDestroy</code>一样，片段也可以直接从<code class="fe mb mc md me b">onViewCreated</code>到<code class="fe mb mc md me b">onDestroyView</code>。</p><p id="a78b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">你可以在</em><a class="ae kw" href="https://www.reddit.com/r/androiddev/comments/l3oon4/an_update_to_the_fragmentviewbindingdelegate_the/" rel="noopener ugc nofollow" target="_blank"><em class="mo">/r/Android dev</em></a><em class="mo">查看讨论线程。</em></p></div></div>    
</body>
</html>