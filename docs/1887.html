<html>
<head>
<title>React Hooks &amp; Context (Without Redux)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React挂钩和上下文(没有Redux)</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-context-without-redux-401235df2a68?source=collection_archive---------3-----------------------#2019-02-18">https://itnext.io/react-hooks-context-without-redux-401235df2a68?source=collection_archive---------3-----------------------#2019-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8df3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将展示React的特性、钩子和上下文是如何实现高效简单的状态管理的。以前只有在使用Redux和MobX等状态管理库时才有可能，React现在内置的支持使开发体验变得流畅简单。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/35a6b45a467a5f0a656d638e6ffc2aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZugxrkadDI-z9I874yxt3g.jpeg"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="6345" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请克隆项目以跟进:<a class="ae le" href="https://github.com/amwais/react-hooks-and-context" rel="noopener ugc nofollow" target="_blank">https://github.com/amwais/react-hooks-and-context</a>。</p><p id="67e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主分支是最终版本，每个分支代表本教程中的一个步骤。</p><h1 id="7990" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak"> <em class="md"> V01:基本挂钩用法</em> </strong></h1><p id="ecda" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我已经使用了<em class="mj"> create-react-app </em>来引导这个项目。</p><p id="f6c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我已经将App.js更改为功能组件，因为我们不再需要使用基于类的组件。</p><p id="e1ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该文件包含应用程序的基本工作版本:一个标题、一个包含文本输入字段和添加按钮的“添加待办事项”表单，以及最终呈现的待办事项列表。这些还没有封装到单独的组件文件中，现在只是混合在一起。</p><p id="badc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里使用了两个钩子:<strong class="jp ir"> useState </strong>和<strong class="jp ir"> useReducer。</strong></p><p id="19ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> useState，</strong>两者中较简单的一个，负责保持表单组件的本地状态:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="e0f4" class="mp lg iq ml b gy mq mr l ms mt">const [ textField, setTextField ] = useState('');</span></pre><p id="71cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">useState是一个钩子，您可以根据需要调用它多次，每次调用只负责存储一个状态键。我们使用数组分解从钩子中获得两个返回值:状态键的名称(<em class="mj"> textField </em>)和负责修改它的函数的名称(<em class="mj"> setTextField </em>)。</p><p id="2152" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在我们的“尚待分离的组件”表单中，我们可以很容易地使用这个本地状态来创建一个受控的输入字段:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="a852" class="mp lg iq ml b gy mq mr l ms mt">&lt;input autoFocus type="text" value={textField} onChange={(e) =&gt; setTextField(e.target.value)} /&gt;</span></pre><p id="4fc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意像<em class="mj"> this.state.textfield </em>和<em class="mj">this . setstate({ text:e . target . value })</em>这样的调用是不需要的，取而代之的是两个简洁直接的调用。</p><p id="b5f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们来看看<strong class="jp ir"> useReducer </strong>。<strong class="jp ir"> </strong>这个钩子比<strong class="jp ir"> useState、</strong>更复杂，它非常类似于Redux管理全局状态的方式。</p><p id="8216" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从创建一个缩减器开始，这不在我们的应用程序组件的范围之内:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="22d8" class="mp lg iq ml b gy mq mr l ms mt">const appReducer = (state, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'ADD_TODO':<br/>      return [...state, {<br/>        text: action.payload<br/>      }];<br/>    case 'REMOVE_TODO':<br/>      return state.filter((_, index) =&gt; index !== action.payload);<br/>    case 'TOGGLE_COMPLETED':<br/>      return state.map((item, index) =&gt; {<br/>        if (action.payload === index) {<br/>          return {<br/>            ...item,<br/>            completed: !item.completed<br/>          };<br/>        }<br/>        return item;<br/>      });<br/>    default:<br/>      return state;<br/>  }<br/>};</span></pre><p id="445c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，在使用Redux时，通常定义缩减器的方式没有什么不同。</p><p id="5720" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在我们的应用程序组件中，让我们调用<strong class="jp ir"> useReducer </strong>:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="16a3" class="mp lg iq ml b gy mq mr l ms mt">const [state, dispatch] = useReducer(appReducer, [{<br/>  text: 'Eat Dinner',<br/>  completed: false<br/>}]);</span></pre><p id="b5d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是神奇之处:不需要使用Redux的connect函数，也不需要用它包装我们的组件。相反，除了初始状态之外，我们还为钩子提供了reducer，瞧，我们可以访问状态和调度函数了。简单。干净。简单。</p><p id="ac16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们现在可以创建动作函数来调用dispatch函数，目标是我们的reducer:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="b0a7" class="mp lg iq ml b gy mq mr l ms mt">const handleDelete = (index) =&gt; {<br/>  dispatch({<br/>    type: 'REMOVE_TODO',<br/>    payload: index<br/>  });<br/>};</span></pre><p id="6550" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我们的删除按钮调用这个函数:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="440c" class="mp lg iq ml b gy mq mr l ms mt">&lt;button onClick={() =&gt; handleDelete(index)}&gt;Delete&lt;/button&gt;</span></pre><h1 id="5508" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">V02:带上下文的组件封装</h1><p id="3558" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我们应用程序的下一步将是把这三个组件中的每一个都分离到一个单独的文件中。</p><p id="1b6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是React中的一种常见模式，但是使用Redux时，它曾经是一项有些乏味的任务，因为必须创建组件，然后使用mapStateToProps(用于将状态键映射到组件的Props)和mapDispatchToProps(用于将动作函数映射到组件的props)将该组件包装在一个连接函数中。</p><p id="3958" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是现在，如果没有Redux，我们如何从封装的组件内部调用<strong class="jp ir"> dispatch </strong>或访问<strong class="jp ir">T3】reducer的(全局)状态呢？</strong></p><p id="4a73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是上下文API发挥作用的地方，它使开发React应用程序成为一种更愉快的体验。首先，看看这个版本中的App.js:现在它包含了返回的JSX、我们的钩子定义和我们的reducer定义(接下来也会分开)。此外，还会创建一个新的上下文:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="8432" class="mp lg iq ml b gy mq mr l ms mt">export const TodosDispatch = React.createContext(null);</span></pre><p id="c113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个TodosDispatch上下文是为了向其下的任何子组件提供对reducer的调度功能的访问。我们是这样提供的:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="04aa" class="mp lg iq ml b gy mq mr l ms mt">&lt;div className = "App" &gt;<br/>  &lt;TodosDispatch.Provider value = {dispatch} &gt;<br/>    &lt;Header / &gt;<br/>    &lt;AddToDoForm / &gt;<br/>    &lt;ToDoList todos = {state}/&gt; <br/>  &lt;/TodosDispatch.Provider &gt;<br/>&lt;/div&gt;</span></pre><p id="aa8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们将AddToDoForm.js作为一个需要访问该上下文的组件的示例。首先，我们导入上下文:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="5e69" class="mp lg iq ml b gy mq mr l ms mt">import { TodosDispatch } from '../App';</span></pre><p id="796a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们调用<strong class="jp ir"> useContext </strong>钩子:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="6e3f" class="mp lg iq ml b gy mq mr l ms mt">const dispatch = useContext(TodosDispatch);</span></pre><p id="e545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，我们可以访问应用程序“store ”,并且可以从我们的子组件调用调度功能:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="eef7" class="mp lg iq ml b gy mq mr l ms mt">const handleAddToDo = (e) =&gt; {<br/>  e.preventDefault();<br/>  if (textField.length &gt; 0) {<br/>    dispatch({<br/>      type: 'ADD_TODO',<br/>      payload: textField<br/>    });<br/>    setTextField('');<br/>  }<br/>};</span></pre><h1 id="9eaa" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">V03:使用多个减速器</h1><p id="279e" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">但是如果我们有多个reducers，并且一些组件需要访问它们呢？保持同样的模式应该能让我们得到我们想要的。在分支中，我添加了一个错误减少器，它将作为一种全局方式来显示不同组件中的错误。我们首先创建另一个上下文:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="c464" class="mp lg iq ml b gy mq mr l ms mt">export const ErrorsContext = React.createContext(null);</span></pre><p id="1fa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们创建减速器:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="dce0" class="mp lg iq ml b gy mq mr l ms mt">const [errors, errorDispatch] = useReducer(errorReducer, {<br/>  header: '',<br/>  form: ''<br/>};);</span></pre><p id="957a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在我们的组件树中，我们包装需要访问该上下文的组件:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="4b58" class="mp lg iq ml b gy mq mr l ms mt">&lt;div className = "App" &gt;<br/> &lt;TodosDispatch.Provider value = {todosDispatch} &gt;<br/>  &lt;ErrorsContext.Provider value = {[errors, errorDispatch]}&gt;<br/>    &lt;Header /&gt;<br/>    &lt;AddToDoForm /&gt;<br/>  &lt;/ErrorsContext.Provider&gt; <br/>  &lt;ToDoList todos = {todos}/&gt;<br/>  &lt;ErrorsContext.Provider value = {errorDispatch}&gt;<br/>    &lt;ErrorButtons /&gt;<br/>  &lt;/ErrorsContext.Provider&gt;<br/> &lt;/TodosDispatch.Provider&gt; <br/>&lt;/div&gt;</span></pre><p id="4457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们如何使用多个上下文，我们可以用任何上下文包装任何组件。</p><p id="7c38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还要注意，我们附加到这个上下文的值不一定只是调度函数，也可以是一个数组:</p><pre class="km kn ko kp gt mk ml mm mn aw mo bi"><span id="3e04" class="mp lg iq ml b gy mq mr l ms mt">&lt;ErrorsContext.Provider value = {[errors, errorDispatch]}&gt;</span></pre><p id="e4e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是Header和AddToDoForm能够访问实际错误减少器状态的方式。</p><h1 id="685d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">延伸阅读:</h1><p id="5088" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated"><a class="ae le" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html</a></p><p id="8415" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/context.html</a></p></div></div>    
</body>
</html>