<html>
<head>
<title>Javascript’s Awesome Spread Syntax[…]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript令人敬畏的扩展语法[…]</h1>
<blockquote>原文：<a href="https://itnext.io/javascripts-awesome-spread-syntax-6072cd6036a8?source=collection_archive---------4-----------------------#2019-06-28">https://itnext.io/javascripts-awesome-spread-syntax-6072cd6036a8?source=collection_archive---------4-----------------------#2019-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c2c15db0551280f23248253562790987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSXkVjWk0Q3pKS9k2ABnug.jpeg"/></div></div></figure><p id="30e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">Linux的创始人伊努斯·托沃兹(inus Torvalds)曾经说过，优秀的程序员不担心代码，而是担心数据结构和它们之间的关系(T2)。</p><p id="78b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果是这样的话，那么好的编程语言提供了很好的工具来管理数据结构和它们之间的关系——从而帮助程序员专注于重要的事情，而不是为实现的细节操心。</p><p id="80b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Javascript最近增加的<strong class="ka ir">扩展语法</strong>就是一个很好的例子。</p><p id="9b43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Spread语法是一个非常有用的声明工具，现在可以处理两种数据结构类型:<strong class="ka ir"> iterables </strong>和<strong class="ka ir"> object literals </strong>。</p><blockquote class="lf"><p id="b731" class="lg lh iq bd li lj lk ll lm ln lo kv dk translated">Spread语法允许iterable or在需要零个或多个参数(用于函数调用)或元素(用于数组文字)的地方进行扩展。</p><p id="d6b9" class="lg lh iq bd li lj lk ll lm ln lo kv dk translated">Spread语法允许一个<strong class="ak">对象文字</strong>在需要零个或多个键值对的地方被<strong class="ak">扩展</strong>。</p></blockquote><h2 id="8152" class="lp lq iq bd lr ls lt dn lu lv lw dp lx kj ly lz ma kn mb mc md kr me mf mg mh bi translated">但是什么是可重复的呢？</h2><p id="1f43" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">一个<em class="mn"> iterable </em>对象是允许你通过使用<strong class="ka ir"><em class="mn">(iterable的var值){ } </em> </strong>循环迭代其所有值的任何对象。</p><p id="da49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它通过返回一个为其<a class="ae mo" href="https://www.javascripture.com/Symbol#iterator" rel="noopener ugc nofollow" target="_blank"> Symbol.iterator </a>属性生成一个<a class="ae mo" href="https://www.javascripture.com/Iterator" rel="noopener ugc nofollow" target="_blank">迭代器</a>的<strong class="ka ir">函数</strong>来实现这一点。</p><p id="cea9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Javascript中，某些对象类型像<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">数组</strong> </a> <strong class="ka ir">，</strong> <a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">映射</strong> </a> <strong class="ka ir">，</strong> <a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">集合</strong> </a> <strong class="ka ir"> </strong>和<a class="ae mo" href="https://www.w3schools.com/jsref/jsref_obj_string.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">字符串</strong> </a>，有<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Built-in_iterables" rel="noopener ugc nofollow" target="_blank">内置的可迭代对象</a>具有默认的迭代行为。</p><p id="77d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，一个<strong class="ka ir">数组</strong>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f89c" class="lp lq iq mu b gy my mz l na nb">const arr = [‘a’, ‘b’, ‘c’];</span><span id="4fc1" class="lp lq iq mu b gy nc mz l na nb"><strong class="mu ir">for</strong> (const x <strong class="mu ir">of</strong> arr) {   // <em class="mn">here's the </em><strong class="mu ir"><em class="mn">for..of</em></strong><em class="mn"> statement</em><br/>  console.log(x);<br/>}</span></pre><p id="bf19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这会产生:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="dd4c" class="lp lq iq mu b gy my mz l na nb">a</span><span id="c8d9" class="lp lq iq mu b gy nc mz l na nb">b</span><span id="e8f3" class="lp lq iq mu b gy nc mz l na nb">c</span></pre><p id="2469" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在引擎盖下，<strong class="ka ir"><em class="mn">' for(const x of arr)'</em></strong>来自上面的片段<strong class="ka ir"> </strong>执行以下操作:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="cf56" class="lp lq iq mu b gy my mz l na nb">const iterator = arr[Symbol.iterator]();<br/>let current = iterator.next();<br/>while (!current.done) {<br/>  console.log(current.value);<br/>  current = iterator.next();<br/>}</span></pre><p id="b33e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">字符串</strong>本质上只是<a class="ae mo" href="https://en.wikipedia.org/wiki/Unicode" rel="noopener ugc nofollow" target="_blank"> Unicode </a>字符的集合，大多数数组概念都适用于它们。因此字符串也有一个内置的迭代器。字符串的<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/@@iterator" rel="noopener ugc nofollow" target="_blank">默认迭代器</a>逐个返回字符串的字符<strong class="ka ir"/>。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="79b5" class="lp lq iq mu b gy my mz l na nb">const stringExample = 'hi';<br/>typeof stringExample[Symbol.iterator]; // "function"</span><span id="d5b8" class="lp lq iq mu b gy nc mz l na nb">const iterator = stringExample[Symbol.iterator]();</span><span id="7243" class="lp lq iq mu b gy nc mz l na nb">iterator + ''; // “[object String Iterator]”<br/>iterator.next(); // { value: "h", done: false }<br/>iterator.next(); // { value: "i", done: false }<br/>iterator.next(); // { value: undefined, done: true }</span><span id="044f" class="lp lq iq mu b gy nc mz l na nb"><strong class="mu ir">for</strong>(const element <strong class="mu ir">of</strong> stringExample) {<br/>  console.log(element)   <em class="mn">// produces 'h' and 'i';</em><br/>}</span></pre><h2 id="2ebb" class="lp lq iq bd lr ls nd dn lu lv ne dp lx kj nf lz ma kn ng mc md kr nh mf mg mh bi translated">什么是对象字面量？</h2><p id="fd69" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">JavaScript对象文字是一个用逗号分隔的键-值对列表，用花括号括起来。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6916" class="lp lq iq mu b gy my mz l na nb">const myObject = {<br/>    sProp: 'some string value',<br/>    numProp: 2,<br/>    bProp: false<br/>};</span></pre><p id="7e6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">循环语法中的<strong class="ka ir">for…也可以用于对象文字，以迭代其<strong class="ka ir">可枚举属性</strong>(即键值对)。这个循环包括从原型链继承的属性。</strong></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="ef19" class="lp lq iq mu b gy my mz l na nb">let obj = {<br/>  key1: "value1",<br/>  key2: "value2",<br/>  key3: "value3"<br/>};</span><span id="eb48" class="lp lq iq mu b gy nc mz l na nb">for (const key in obj) {<br/>  console.log(`${key} = ${obj[key]}`); // 'key1 = "value1"' etc..<br/>}</span></pre><p id="fc9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在我们有了一个关于iterables和object literals的句柄。</p><p id="a163" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重申一下，扩展语法<em class="mn">扩展了</em> iterables和object literals，这里应该有零个或多个参数/元素。</p><p id="a0d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看这样的例子:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3503" class="lp lq iq mu b gy my mz l na nb">function sum(x, y, z) { <em class="mn">//expects three arguments, returns their sum</em><br/>  return x + y + z;<br/>}</span><span id="c923" class="lp lq iq mu b gy nc mz l na nb">const numbers = [1, 2, 3];<br/>console.log(sum(<strong class="mu ir">...numbers</strong>));</span></pre><p id="94c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们已经将数组传递给函数<strong class="ka ir"> <em class="mn"> sum </em> </strong>。这个函数需要三个参数。Spread语法扩展了数组的iterable元素，并将结果(三个独立的数组元素)传递给函数。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e64f" class="lp lq iq mu b gy my mz l na nb">const someString = "hi";<br/>[...someString] // ["h", "i"]</span></pre><p id="f215" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，扩展语法<strong class="ka ir">将字符串</strong>扩展成它的可迭代的组成部分(每个字符)。</p><h1 id="099c" class="ni lq iq bd lr nj nk nl lu nm nn no lx np nq nr ma ns nt nu md nv nw nx mg ny bi translated">实际使用的扩展语法示例</h1><p id="7f4a" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">让我们看一些有用的扩展语法的例子。</p><h2 id="9607" class="lp lq iq bd lr ls nd dn lu lv ne dp lx kj nf lz ma kn ng mc md kr nh mf mg mh bi translated">1.克隆阵列</h2><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a619" class="lp lq iq mu b gy my mz l na nb">const origArr = [1,2,3];</span><span id="60f5" class="lp lq iq mu b gy nc mz l na nb">// traditional ways of cloning arrays ⬇<br/>const copy = [].concat(origArray); <br/>const copy2 = origArray.slice();<br/>const copy3 = Array.from(origArr);</span><span id="4084" class="lp lq iq mu b gy nc mz l na nb">// using the spread operator ⬇<br/>const copy4 = [<strong class="mu ir">...origArr</strong>]; <em class="mn">// much more succinct!</em></span></pre><h2 id="f0e2" class="lp lq iq bd lr ls nd dn lu lv ne dp lx kj nf lz ma kn ng mc md kr nh mf mg mh bi translated">2.克隆对象文字</h2><p id="cc6e" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">使用从一个提供的对象文字到一个新对象的可枚举属性的扩展克隆<strong class="ka ir">。</strong></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="02b0" class="lp lq iq mu b gy my mz l na nb">const obj1 = { foo: 'bar', x: 42 };<br/>const obj2 = { foo: 'baz', y: 13 };</span><span id="57e9" class="lp lq iq mu b gy nc mz l na nb">const clonedObj = { <strong class="mu ir">...obj1</strong> }; <br/><em class="mn">// Object { foo: 'bar', x: 42 }</em></span><span id="ab7d" class="lp lq iq mu b gy nc mz l na nb">const mergedObj = { <strong class="mu ir">...obj1</strong>, <strong class="mu ir">...obj2</strong> }; <br/><em class="mn">// Object { foo: 'baz', x: 42, y: 13 }</em></span></pre><blockquote class="lf"><p id="15d8" class="lg lh iq bd li lj nz oa ob oc od kv dk translated"><strong class="ak">注意，通过传播进行克隆总是肤浅的！</strong></p></blockquote><p id="5329" class="pw-post-body-paragraph jy jz iq ka b kb oe kd ke kf of kh ki kj og kl km kn oh kp kq kr oi kt ku kv ij bi translated">这意味着，如果原始属性值之一是一个<strong class="ka ir">对象</strong>，那么克隆将引用同一个<strong class="ka ir">对象</strong>；<em class="mn">它不递归克隆对象内的对象</em>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="adc5" class="lp lq iq mu b gy my mz l na nb"><strong class="mu ir">const</strong> original = { prop: {} };<br/><strong class="mu ir">const</strong> clone = {...original};<br/><strong class="mu ir">console</strong>.log(original.prop === clone.prop); <br/><em class="mn">//returns true, as cloned property points to same object as original</em></span><span id="c250" class="lp lq iq mu b gy nc mz l na nb">original.prop.foo = 'abc';<br/><strong class="mu ir">console</strong>.log(clone.prop.foo); // abc <br/>// ⬆ <em class="mn">(cloned property points to same object as original!)</em></span></pre><h2 id="6a92" class="lp lq iq bd lr ls nd dn lu lv ne dp lx kj nf lz ma kn ng mc md kr nh mf mg mh bi translated">3.串联数组</h2><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7bd1" class="lp lq iq mu b gy my mz l na nb">const arr1 = [1,2,3];<br/>const arr2 = [4,5,6];</span><span id="323c" class="lp lq iq mu b gy nc mz l na nb"><em class="mn">// The old way:</em> ⬇<br/>const arr3 = arr1.concat(arr2);</span><span id="7908" class="lp lq iq mu b gy nc mz l na nb"><em class="mn">// With spread syntax this becomes:</em> ⬇<br/>const arr4 = [...arr1, ...arr2];</span><span id="3bc1" class="lp lq iq mu b gy nc mz l na nb"><em class="mn">// Merging two arrays:</em><br/>const parts = ["shoulders", "knees"];<br/>const lyrics = ["head", .<strong class="mu ir">..parts</strong>, "and", "toes"];<br/><em class="mn">// </em>lyrics = <em class="mn">["head", "shoulders", "knees", "and", "toes"]</em></span></pre><h2 id="2cc0" class="lp lq iq bd lr ls nd dn lu lv ne dp lx kj nf lz ma kn ng mc md kr nh mf mg mh bi translated">4.在另一个数组的开头插入一个数组</h2><p id="2cb7" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" rel="noopener ugc nofollow" target="_blank"><em class="mn">array . prototype . un shift()</em></a>常用于在现有数组的<strong class="ka ir">开头</strong>插入一个数组的值。如果没有扩展语法，这将按如下方式完成:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6f88" class="lp lq iq mu b gy my mz l na nb">let arr1 = [0, 1, 2];<br/>let arr2 = [3, 4, 5];<br/>Array.prototype.unshift.apply(arr1, arr2) <br/><em class="mn">// arr1 is now [3, 4, 5, 0, 1, 2]</em></span></pre><p id="ee0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用扩展语法，这变成:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="62ad" class="lp lq iq mu b gy my mz l na nb">let arr1 = [0, 1, 2];<br/>let arr2 = [3, 4, 5];<br/>arr1 = [<strong class="mu ir">...arr2, ...arr1</strong>]; <br/><em class="mn">// arr1 is now [3, 4, 5, 0, 1, 2]</em></span></pre><h2 id="decc" class="lp lq iq bd lr ls nd dn lu lv ne dp lx kj nf lz ma kn ng mc md kr nh mf mg mh bi translated">5.从基元数组中移除任何重复项</h2><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="009c" class="lp lq iq mu b gy my mz l na nb">const arr = [1, 1, 3, 4, 5, 6, 6, 7, 8, 4, 3, 5, 4, 3, 2, 8, 7, 5];<br/>const unique = [<strong class="mu ir">...new Set(arr)</strong>]; <em class="mn">// [1, 3, 4, 5, 6, 7, 8, 2]</em></span></pre><h2 id="70a6" class="lp lq iq bd lr ls nd dn lu lv ne dp lx kj nf lz ma kn ng mc md kr nh mf mg mh bi translated">6.使用数学函数和一般的函数调用</h2><p id="1a06" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">Spread可以用作参数或函数，函数<strong class="ka ir">可以接受任意数量的参数</strong>。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="aef6" class="lp lq iq mu b gy my mz l na nb">let numbers = [9, 4, 7, 1];<br/>Math.min(<strong class="mu ir">...numbers</strong>); // 1</span></pre><p id="02ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Math对象的函数集是spread操作符作为函数的唯一<strong class="ka ir">参数的完美例子。</strong></p><p id="e84a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你想使用数组的元素作为函数的参数时，通常使用<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noopener ugc nofollow" target="_blank"><em class="mn">function . prototype . apply()</em></a><em class="mn"/>。扩展语法使这变得多余。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="7938" class="lp lq iq mu b gy my mz l na nb">function myFunction(x, y, z) { }<br/>var args = [0, 1, 2];<br/><strong class="mu ir">myFunction.apply(null, args);</strong></span><span id="588f" class="lp lq iq mu b gy nc mz l na nb"><em class="mn">// With spread syntax the above can be written as:</em></span><span id="5954" class="lp lq iq mu b gy nc mz l na nb">function myFunction(x, y, z) { }<br/>var args = [0, 1, 2];<br/>myFunction(<strong class="mu ir">...args</strong>);</span></pre><h2 id="6ae1" class="lp lq iq bd lr ls nd dn lu lv ne dp lx kj nf lz ma kn ng mc md kr nh mf mg mh bi translated">7.条件对象属性</h2><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="404a" class="lp lq iq mu b gy my mz l na nb">const getUser = (emailIncluded) =&gt; {<br/>  return {<br/>    name: ‘John’,<br/>    surname: ‘Doe’,<br/>    <strong class="mu ir">...emailIncluded &amp;&amp; { email : 'john@doe.com' }</strong><br/>  }<br/>}</span><span id="e0a8" class="lp lq iq mu b gy nc mz l na nb">const user = getUser(true);<br/>console.log(user); <br/><em class="mn">// outputs { name: “John”, surname: “Doe”, email: “john@doe.com” }</em></span><span id="234b" class="lp lq iq mu b gy nc mz l na nb">const userWithoutEmail = getUser(false);<br/>console.log(userWithoutEmail); <br/><em class="mn">// outputs { name: “John”, surname: “Doe” }</em></span></pre><h2 id="5d2a" class="lp lq iq bd lr ls nd dn lu lv ne dp lx kj nf lz ma kn ng mc md kr nh mf mg mh bi translated">8.生成从0到99的数字数组</h2><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6b58" class="lp lq iq mu b gy my mz l na nb">const arr = [<strong class="mu ir">...Array(100)</strong>].map((_, i) =&gt; i);</span></pre><p id="f4c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">spread操作符循环遍历数组<em class="mn">、</em>并为每个数组元素创建一个新的<strong class="ka ir">索引键</strong>，从0开始迭代递增1，索引处的值<em class="mn">未定义</em>。</p><p id="1396" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果是<em class="mn">能够映射</em>。在示例中，array <a class="ae mo" href="https://www.w3schools.com/jsref/jsref_map.asp" rel="noopener ugc nofollow" target="_blank"> map </a>函数返回每个数组元素的索引键值，最终返回一个从0到99的整数数组。</p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><h2 id="4db5" class="lp lq iq bd lr ls nd dn lu lv ne dp lx kj nf lz ma kn ng mc md kr nh mf mg mh bi translated">参考</h2><div class="oq or gp gr os ot"><a href="https://www.javascripture.com/Iterable" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">可迭代JavaScript API</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">JavaScript Iterable对象的交互式API参考。可迭代对象是任何返回函数的对象…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">www.javascripture.com</p></div></div></div></a></div><div class="oq or gp gr os ot"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">迭代协议</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">ECMAScript 2015的几个新增内容不是新的内置或语法，而是协议。这些协议可以是…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">developer.mozilla.org</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph jw ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">扩展语法</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">Spread语法允许在零个或多个…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">developer.mozilla.org</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph jw ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://www.geeksforgeeks.org/javascript-spread-operator/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">JavaScript | Spread运算符- GeeksforGeeks</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">Spread运算符允许iterable在应该有0+个参数的地方扩展。它主要用于可变的…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="pc l"><div class="pj l pe pf pg pc ph jw ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://codeburst.io/a-simple-guide-to-destructuring-and-es6-spread-operator-e02212af5831" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">析构和ES6扩展运算符的简单指南</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">JavaScript到ES6版本的发展带来了一系列新的工具和实用程序。这些工具允许我们…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">codeburst.io</p></div></div><div class="pc l"><div class="pk l pe pf pg pc ph jw ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="http://2ality.com/2016/10/rest-spread-properties.html" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">ES2018:静止/扩散属性</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">关于|捐赠|订阅|存档|搜索|原因ML | ES2018</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">2ality.com</p></div></div><div class="pc l"><div class="pl l pe pf pg pc ph jw ot"/></div></div></a></div><div class="oq or gp gr os ot"><a rel="noopener  ugc nofollow" target="_blank" href="/heres-why-mapping-a-constructed-array-doesn-t-work-in-javascript-f1195138615a"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">这就是为什么映射一个构造的数组在JavaScript中不起作用</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">以及如何正确地去做</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">itnext.io</p></div></div><div class="pc l"><div class="pm l pe pf pg pc ph jw ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://davidwalsh.name/spread-operator" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">Spread运算符的6大用途</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">感谢ES6和Babel之类的东西，编写JavaScript已经变得非常动态，从新的语言语法到…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">davidwalsh.name</p></div></div><div class="pc l"><div class="pn l pe pf pg pc ph jw ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://medium.com/front-end-weekly/es6-magical-stuffs-spread-syntax-in-depth-afdd0118ebd0" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">ES6神奇的东西—深入传播(…)语法</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">一个经典问题</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="po l pe pf pg pc ph jw ot"/></div></div></a></div></div></div>    
</body>
</html>