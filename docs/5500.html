<html>
<head>
<title>Two proven tricks to keep your database up to date across the environments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的数据库在各种环境中保持最新的两个经验证的技巧</h1>
<blockquote>原文：<a href="https://itnext.io/two-proven-tricks-to-keep-your-database-up-to-date-across-the-environments-a9b82fc3017d?source=collection_archive---------0-----------------------#2021-03-18">https://itnext.io/two-proven-tricks-to-keep-your-database-up-to-date-across-the-environments-a9b82fc3017d?source=collection_archive---------0-----------------------#2021-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/72a8f6276c59e6fc85a68f8b773634fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ba6mFbMrASUnV5zyZ3I08A.png"/></div></div></figure><p id="99dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象一下你在一家繁忙的IT公司开发软件系统。在很多情况下，这样的系统会在后端使用某种形式的数据库。</p><p id="2d46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着您可能会在开发、测试和后续生产使用中面临一个主要问题:如何在各种环境中保持数据库的统一和最新？</p><p id="4da7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面提到的另一个大问题是，如何为开发人员提供预先加载了一些测试数据的数据库的一次性副本。</p><p id="8e98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在努力解决上述任何一个问题，那你就来对地方了。我解释了如何结合使用Liquibase和Docker这两个不太可能的工具来处理这两个问题。</p><p id="b1ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.liquibase.org/" rel="noopener ugc nofollow" target="_blank"> Liquibase </a>允许您以特定的顺序将DDL和DML语句应用于数据库实例，并确保它们只应用一次。这意味着这些脚本的组合会将目标数据库带到特定的最终状态。如果同一套脚本已经应用于许多环境，它保证这些环境将是完全相同的。</p><p id="bdc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Liquibase还允许您有选择地将特定的上下文相关脚本应用于某些环境，而不将它们应用于其他环境。这将允许我们轻松地用测试数据预加载开发数据库。因此，开发人员和测试人员可以立即使用它，而不需要自己创建测试数据。</p><p id="0bba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用下面的简单例子来看看这种方法。</p><p id="6168" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的测试数据库具有以下结构:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/9c6aafcfa8e60c6b23dc942684a6a07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LioPkKO_Gsjok2Eu9dJ39A.png"/></div></div></figure><p id="bb64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于测试目的，我们还想将以下数据插入数据库:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/8f789392bc564f4698cc76cdea1e6f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAbPRVyuX6YTA0mirP-Ucg.png"/></div></div></figure><p id="8b28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了将这两个脚本打包到Liquibase术语中称为变更集的文件中，您需要做的就是在每个文件中添加以下标题:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="c75c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要确保变更集名称和id的组合在整个项目中是唯一的。</p><p id="c95f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们希望某些脚本只应用于特定场景的情况下，liquibase使用所谓的上下文，本质上是标记变更集的另一个标识符，然后在我们调用liquibase在目标数据库中进行更改时用作参数。</p><p id="0e69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使特定的变更集只适用于特定的上下文，我们必须修改头的第二行，在它的末尾添加<code class="fe lf lg lh li b">context: &lt;context_id&gt;</code>。</p><p id="cbff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在我们的示例中，我们修改了上面的文件，使它们看起来像这样:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lj"><img src="../Images/78b3cb1368e8c4b3ba008bac13d73e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-XAPxn0bFALXJ0LzCQultg.png"/></div></div></figure><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/eb20ad174199d988a39dd98923f41f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fk99h9whmOMXF8grxN0R6w.png"/></div></div></figure><p id="54c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本质上，将始终应用第一个脚本，因为它没有指定上下文。当在liquibase更新期间指定了<code class="fe lf lg lh li b">test_data</code>上下文时，将应用第二个脚本。</p><p id="4b32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是创建引用上述变更集的Liquibase changelog文件。changelog是一个XML文件，在我们的示例中，它将如下所示:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ll"><img src="../Images/8cf363f113388b84646f391571235f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wx-hrz-QMKw2xR0S9tuiA.png"/></div></div></figure><p id="32e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，变更集将按照它们在变更日志文件中列出的顺序应用。</p><p id="2927" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，还需要两个文件:<code class="fe lf lg lh li b">liquibase.properties</code>文件和JDBC驱动程序。假设我们想将它应用到PostgreSQL数据库，那么我们需要可以从这里下载的驱动程序:<a class="ae kw" href="https://jdbc.postgresql.org/." rel="noopener ugc nofollow" target="_blank">https://jdbc.postgresql.org/.</a></p><p id="a617" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们需要创建包含以下内容的<code class="fe lf lg lh li b">liquibase.properties</code>文件:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="3010" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这假设postgres JDBC驱动程序在同一个目录中。请记住，在使用liquibase应用更改之前，必须先创建数据库和用户。还要注意，属性文件中指定的默认上下文是<code class="fe lf lg lh li b">init</code>。然而，我们定义的唯一上下文是<code class="fe lf lg lh li b">test_data</code>。这是特意做的，所以在这种情况下，liquibase将只应用那些在头文件中指定了<code class="fe lf lg lh li b">init</code>上下文或者根本没有指定上下文的变更集。</p><p id="b272" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要应用changelog，只需在命令提示符下运行以下命令:</p><p id="71cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">/&lt;path_to_liquibase&gt;/liquibase update</code></p></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="f311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们把它打包到码头集装箱里。我们将使用多阶段构建，这样我们可以从一组文件中创建两个不同的映像:一个为开发人员的数据库提供测试数据，另一个用作其他环境的数据库更新容器。</p><p id="ea04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此设置的docker文件将有三个阶段:</p><p id="2963" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一阶段<code class="fe lf lg lh li b">deploy</code>将所有必要的文件复制到映像，然后在容器中运行<code class="fe lf lg lh li b">liquibase update</code>。用作该容器默认入口点的辅助脚本将使用环境变量来设置<code class="fe lf lg lh li b">liquibase.properties</code>文件，以指向正确的环境。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="44fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二阶段<code class="fe lf lg lh li b">build</code>使用<code class="fe lf lg lh li b">deploy</code>创建的映像，启动数据库服务器，初始化数据库和用户，并将liquibase变更集应用于容器中的数据库。在这种情况下，它使用<code class="fe lf lg lh li b">test_data</code>上下文来预加载数据。然后使用pg_dumpall工具备份数据库并停止服务器。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="ed52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三阶段使用第二阶段的普通postgres映像和备份文件。然后，它再次启动服务器，并从备份中恢复数据。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="ld le l"/></div></figure><blockquote class="lt lu lv"><p id="281f" class="jy jz lw ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated"><strong class="ka ir">重要的是，当在构建期间调用所有阶段时，在启用DOCKER_BUILDKIT的情况下，</strong> <code class="fe lf lg lh li b"><strong class="ka ir">docker build</strong></code> <strong class="ka ir">命令正在运行！！否则，数据不会被恢复(无论什么原因)</strong></p></blockquote><p id="2f13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用上面的Dockerfile文件在这里构建两个映像:</p><ul class=""><li id="8bca" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">我们可以用它将数据库更改应用到其他环境中</li><li id="99e5" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">另一个是测试数据库，我们可以立即开始使用</li></ul><p id="1072" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，首先运行docker构建，在<code class="fe lf lg lh li b">deploy</code>阶段停止:</p><p id="92a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">docker build -t test-db-deployment --target deploy .</code></p><p id="b842" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后使用所有三个阶段构建映像:</p><p id="ef48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">docker build -t test-db .</code></p><p id="01f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要将数据库更改应用到特定环境，请运行<code class="fe lf lg lh li b">test-db-deployment</code>映像。它需要设置三个环境变量:</p><p id="8f84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> URL </strong> —目标数据库URL <br/> <strong class="ka ir">用户名</strong>和<strong class="ka ir">密码</strong> —目标数据库凭证</p><p id="e899" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，这两个变量都没有默认值，因此，如果不设置它们，容器将会失败。</p><p id="d667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，您可以使用以下docker命令运行数据库更新(假设数据库主机是db，数据库是testdb:</p><p id="3c71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">docker run --name database-update -e URL=jdbc:postgresql://db/testdb -e USERNAME=test -e PASSWORD=password test-db-deployment</code></p><p id="46fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">容器启动，运行liquibase更新并退出。您可以检查日志以确认更新成功。然后把容器拿走。</p><p id="384c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试数据库可以直接启动，您只需遵循供应商的说明并提供必要的环境变量(如果需要的话)。例如，要运行postgres，需要设置<code class="fe lf lg lh li b">POSTGRES_PASSWORD</code>变量来设置<code class="fe lf lg lh li b">postgres</code>用户的密码。</p><p id="5099" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要启动测试数据库，请运行以下命令:</p><p id="bd23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">docker run --name test-database -e POSTGRES_PASSWORD=password -d test-db-deployment</code></p><h1 id="ba71" class="mo mp iq bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">下一步是什么？</h1><p id="76a5" class="pw-post-body-paragraph jy jz iq ka b kb nm kd ke kf nn kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">上面的例子展示了一种使用一次性容器将数据库服务器置于特定状态的简便技术。它们可以使用scheduler手动启动，或者如果您使用Kubernetes，则可以使用上面的图像来创建一个作业pod，该作业pod将变更集应用到数据库服务器的特定实例。</p><p id="8fc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的诀窍是知道在什么环境下使用什么图像？这可以使用各种工具来实现。例如，使用GitHub动作中的工作流工件或类似于<a class="ae kw" href="https://artifactz.io" rel="noopener ugc nofollow" target="_blank"> artifactz.io </a>的工具。我们将在另一个时间讨论各种选择。</p><p id="b65f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的源代码可以在<a class="ae kw" href="https://github.com/ikolomiyets/test-database" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p></div></div>    
</body>
</html>