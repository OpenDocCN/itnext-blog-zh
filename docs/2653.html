<html>
<head>
<title>Vue SSR and external dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue SSR和外部依赖性</h1>
<blockquote>原文：<a href="https://itnext.io/vue-ssr-and-external-dependencies-bce84fbcbe6d?source=collection_archive---------2-----------------------#2019-07-04">https://itnext.io/vue-ssr-and-external-dependencies-bce84fbcbe6d?source=collection_archive---------2-----------------------#2019-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4c103a1034c901abb72f254fb261da0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnOlI4lbTSntvBsgpNSvMg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:<a class="ae kc" href="https://outcrawl.com/go-dependency-injection" rel="noopener ugc nofollow" target="_blank">引出</a></figcaption></figure><p id="00f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">2019年7月8日更新:您现在可以在VuePress文档网站上看到这些原则</em> <a class="ae kc" href="https://arckinteractive.github.io/noah-ui/extensions/ReCaptcha.html" rel="noopener ugc nofollow" target="_blank"> <em class="lb">在起作用</em> </a> <em class="lb">。</em></p><p id="5f8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你和VuePress或者Nuxt打过交道，你就知道<code class="fe lc ld le lf b">window</code>是SSR的头号敌人。调试构建错误是痛苦的，因为跟踪都会导致水合逻辑，并且确实很难查明故障的确切点，尤其是如果您正在处理第三方组件。在浪费了几个小时试图让这些组件工作起来并试图让它们对SSR友好之后，我开始为依赖于第三方脚本和依赖项的组件寻找一种通用模式。我想我可能已经找到了一个目前为止在SSR环境中运行良好的解决方案。让我用两个例子来说明这种方法:一个依赖于远程脚本的组件(ReCaptcha)和一个需要浏览器专用模块的组件(CodeMirror)。</p><p id="c862" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种模式可以概括如下:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><ol class=""><li id="ead9" class="lm ln iq kf b kg kh kk kl ko lo ks lp kw lq la lr ls lt lu bi translated">创建一个Vue插件，用一个异步加载器扩展原型并注册你的组件。</li><li id="6fc4" class="lm ln iq kf b kg lv kk lw ko lx ks ly kw lz la lr ls lt lu bi translated">在组件的<code class="fe lc ld le lf b">mounted()</code>钩子中使用异步加载器。</li></ol><p id="d963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更新您的SSR知识，<code class="fe lc ld le lf b">mounted()</code>钩子只在浏览器中被调用(不像<code class="fe lc ld le lf b">created()</code>钩子被调用两次)，所以它是一个加载外部脚本和/或依赖项的安全地方。不利的一面是，在组件对用户可见之前可能会有一点延迟，因此，如果您的组件对用户体验至关重要，您可能希望使用微调器。然而，好的一面是，你不再需要用特定于框架的标签来包装你的组件，比如<code class="fe lc ld le lf b">ClientOnly</code>或<code class="fe lc ld le lf b">no-srr</code>，或者担心在你的组件在开发中运行良好之后，在产品中会弹出随机错误。</p><p id="26ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">具有远程依赖关系的组件</strong></p><p id="a604" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建一个reCaptcha插件:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="fe5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让reCaptcha工作，我们需要从Google的服务器上加载一个脚本。我个人不喜欢在每次页面加载时加载“令人毛骨悚然”的第三方脚本(我指的是来自谷歌、脸书和其他所有人的脚本，它们带有cookie包、潜在的跟踪器和一段JS可以在你的页面上做什么的全部功能，其中包括可以捕捉每一次鼠标移动和每一次键盘敲击，包括你输入的密码)，所以把它放到我们的。html模板或通过配置扩展标题标签不是我的选择。<em class="lb">顺便提一下，我必须承认我觉得很困惑，为什么HIPAA和其他隐私保护政策不禁止使用“无害”的第三方工具，如验证码、分析工具等。当Stripe和其他人告诉我把他们的脚本放在每个页面上以防止欺诈时，我说不-谢谢，我相信你不会对我的用户做正确的事情。我个人无法审查我放入页面的每一个第三方脚本的每一次迭代，所以我把每一个这样的脚本都视为一个潜在的漏洞才是公平的。</em></p><p id="de50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的插件中，我们用一个返回承诺的加载器扩展了Vue原型，它解析为ready recaptcha的一个实例，这将使我们更容易在组件中链接我们的逻辑。如果recaptcha库已经出现在页面上，我们只需解析promise。</p><p id="53e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们创建一个recaptcha输入:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="e133" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，每当我们需要访问recaptcha的实例时，我们都将<code class="fe lc ld le lf b">this.$recaptcha.load()</code>和<code class="fe lc ld le lf b">then</code>称为承诺。</p><p id="ba45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，我们只需要注册我们的插件，就可以安全地在我们的组件中使用<code class="fe lc ld le lf b">vue-recaptcha</code>模块，而不必担心SSR。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="1d7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">具有npm依赖关系的组件</strong></p><p id="baa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们用CodeMirror做一些类似的事情，它可以从<code class="fe lc ld le lf b">npm</code>加载。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="b9f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个插件中，我们从<code class="fe lc ld le lf b">codemirror</code>节点模块加载了一些脚本和样式表。在节点模块的情况下，我们不需要担心重复的导入，就像我们对外部脚本所做的那样。</p><p id="6098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相应的Vue组件如下所示:</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="57f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们使用加载器来导入codemirror库和我们可能需要的任何其他模式脚本(通过将它们作为参数传递给加载器)。然后，一旦在浏览器中解决了所有依赖关系，就呈现组件。</p><p id="fb85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">— — — — — — — — —</p><p id="e94e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我相信这种模式适合于各种涉及对SSR不友好的外部依赖的用例。可能还有一些我没有考虑进去的注意事项，如果我发现它们，我一定会报告回来。同时，我期待您的反馈和/或批评。</p></div></div>    
</body>
</html>