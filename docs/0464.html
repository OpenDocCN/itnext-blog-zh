<html>
<head>
<title>Deep dive into JS asynchronicity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究JS异步性</h1>
<blockquote>原文：<a href="https://itnext.io/deep-dive-into-js-asynchronicity-54d06783ec0e?source=collection_archive---------5-----------------------#2018-03-13">https://itnext.io/deep-dive-into-js-asynchronicity-54d06783ec0e?source=collection_archive---------5-----------------------#2018-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3058740061a2d6b5576e49a1998aa761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7nb-owwLC4MMYZTlyFZ7w.png"/></div></div></figure><h1 id="9ba5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">单线程JavaScript</h1><p id="67d9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">JavaScript有一个基于<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">事件循环</a>的并发模型。在处理任何其他消息之前，先完全处理每条消息。在对程序进行推理时，这提供了一些很好的属性，包括这样一个事实，即无论何时函数运行，它都不能被抢占，并且将在任何其他代码运行之前完全运行(并且可以修改函数操作的数据)。</p><blockquote class="lv lw lx"><p id="931c" class="kw kx ly ky b kz lz lb lc ld ma lf lg mb mc lj lk md me ln lo mf mg lr ls lt ij bi translated"><a class="ae lu" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fdeep-dive-into-js-asynchronicity-54d06783ec0e" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d19f" class="mq jz iq mm b gy mr ms l mt mu">runYourScript(); <br/>while (atLeastOneEventIsQueued) {<br/>    fireNextQueuedEvent();<br/>};</span></pre><p id="afa2" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mc lj lk ll me ln lo lp mg lr ls lt ij bi translated">让我们用setTimeout作为一个简单的例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f660" class="mq jz iq mm b gy mr ms l mt mu">let start = +new Date;<br/>setTimeout(function Task1(){<br/>    let end = +new Date;<br/>    console.log(`Task1: Time elapsed ${end - start} ms`);<br/>}, 500); //500ms later，Task1 will be inserted into event queue</span><span id="21d0" class="mq jz iq mm b gy mv ms l mt mu">// single thread<br/>setTimeout(function Task2(){<br/>    let end = +new Date;<br/>    console.log(`Task2: Time elapsed ${end -start} ms`);<br/>    /**<br/>     * use while loop to delay the completion of the function for 3 seconds<br/>     * this will block the execution of the next function in event loop<br/>     * i.e. looping through the event queue has to happen after the main thread finishes its task<br/>     */<br/>    while(+new Date - start &lt; 3000) {}<br/>}, 300); //300ms later，Task2 will be inserted into event queue</span><span id="a8e4" class="mq jz iq mm b gy mv ms l mt mu">while(+new Date - start &lt; 1000) {} //main thread delay completion for 1 second<br/>console.log('main thread ends');<br/>//output: <br/>//main thread ends<br/>//Task2: Time elapsed 1049 ms<br/>//Task1: Time elapsed 3000 ms</span></pre><p id="da30" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mc lj lk ll me ln lo lp mg lr ls lt ij bi translated"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank"> setTimeout </a>会将第一个参数(类型函数)放入事件队列。下面是上面代码中发生的情况:</p><ul class=""><li id="df19" class="mw mx iq ky b kz lz ld ma lh my ll mz lp na lt nb nc nd ne bi translated">300毫秒后，Task2被插入事件队列。</li><li id="94ae" class="mw mx iq ky b kz nf ld ng lh nh ll ni lp nj lt nb nc nd ne bi translated">500毫秒后，Task1被插入事件队列。</li><li id="edd6" class="mw mx iq ky b kz nf ld ng lh nh ll ni lp nj lt nb nc nd ne bi translated">1秒钟后，主线程结束，控制台上显示“主线程结束”。</li><li id="b3aa" class="mw mx iq ky b kz nf ld ng lh nh ll ni lp nj lt nb nc nd ne bi translated">当主线程完成手头的工作时，它将在事件队列中循环。事件队列中的第一个函数是Task2(因为它首先被插入)。因此，获取并执行Task2，得到控制台输出“Task2: Time elapsed 1049 ms”。您看到的运行时间可能会有所不同，因为setTimeout并不完全处理函数的执行。它所做的只是将函数放入事件队列中，并有您设置的延迟。函数何时执行取决于事件队列中的排队函数，以及主线程的状态(是否有剩余的任务在运行)。</li><li id="a3f3" class="mw mx iq ky b kz nf ld ng lh nh ll ni lp nj lt nb nc nd ne bi translated">任务2完成后执行任务1。</li></ul><h1 id="d0a3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是异步函数</h1><p id="8b6d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">JavaScript中的异步函数通常可以接受函数类型的最后一个参数(通常称为<em class="ly">回调</em>)，当函数完成时，回调将被插入事件队列。由于回调在事件队列中，所以该函数是非阻塞的。异步函数可以保证下面的单元测试将总是通过:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b20d" class="mq jz iq mm b gy mr ms l mt mu">let functionHasReturned = false; <br/>asyncFunction(() =&gt; {<br/>    console.assert(functionHasReturned); <br/>}); <br/>functionHasReturned = true;</span></pre><p id="ac8f" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mc lj lk ll me ln lo lp mg lr ls lt ij bi translated">注意，并不是所有带有回调参数的函数都是异步的。例如<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank"> Array.prototype.forEach </a>是同步的。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="494f" class="mq jz iq mm b gy mr ms l mt mu">let before = false;<br/>[1].forEach(() =&gt; {<br/>    console.assert(before); <br/>}); <br/>before = true;</span></pre><h1 id="fef0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">异步函数中的异常</h1><p id="c0a1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于回调函数被放在事件队列中，并在以后用它自己的调用上下文执行，所以用try-catch机制包装异步函数将无法捕获回调中的异常。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8ed5" class="mq jz iq mm b gy mr ms l mt mu">try {<br/>    setTimeout(() =&gt; {<br/>        throw new Error('callback error'); <br/>    }, 0);<br/>} catch (e) {<br/>    console.error('caught callback error');<br/>}<br/>console.log('try-catch block ends');</span></pre><p id="cf38" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mc lj lk ll me ln lo lp mg lr ls lt ij bi translated">在这个例子中，回调中抛出的异常没有被我们自己的程序捕获到(即catch块——控制台上没有显示“捕获的回调错误”)。我们可以用浏览器中的<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror" rel="noopener ugc nofollow" target="_blank"> window.onerror </a>和节点中的<a class="ae lu" href="https://nodejs.org/api/process.html#process_event_uncaughtexception" rel="noopener ugc nofollow" target="_blank">process . uncaughtexception</a>来捕捉这些未捕捉到的异常。</p><p id="bcae" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mc lj lk ll me ln lo lp mg lr ls lt ij bi translated">如果我们想故意捕捉错误，就像我们应该一直做的那样，我们可以在回调中这样做。例如</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fde1" class="mq jz iq mm b gy mr ms l mt mu">let fs = require('fs'); <br/>fs.readFile('abc.txt', function(err, data) {<br/>    if (err) {<br/>        return console.error(err); <br/>    }; <br/>    console.log(data);<br/>});</span></pre><h1 id="3744" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">参考</h1><ul class=""><li id="abe7" class="mw mx iq ky b kz la ld le lh nk ll nl lp nm lt nb nc nd ne bi translated"><a class="ae lu" href="https://www.amazon.com/Async-JavaScript-Responsive-Pragmatic-Express-ebook/dp/B00AKM4RVG" rel="noopener ugc nofollow" target="_blank">异步JavaScript </a></li></ul><h1 id="a586" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">通知；注意</h1><ul class=""><li id="6316" class="mw mx iq ky b kz la ld le lh nk ll nl lp nm lt nb nc nd ne bi translated">如果你想了解最新的新闻/文章，请点击<a class="ae lu" href="https://github.com/n0ruSh/the-art-of-reading" rel="noopener ugc nofollow" target="_blank">【观看】</a>订阅。</li></ul></div></div>    
</body>
</html>