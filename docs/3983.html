<html>
<head>
<title>Decoding your JSON Models along with Unit Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解码JSON模型和单元测试</h1>
<blockquote>原文：<a href="https://itnext.io/decoding-your-json-models-along-with-unit-test-2285100f9499?source=collection_archive---------2-----------------------#2020-04-06">https://itnext.io/decoding-your-json-models-along-with-unit-test-2285100f9499?source=collection_archive---------2-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/4990d4b27ec97baedcb89b26af384781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*rzZYjzf0Wy4t0-PDQ3rtnA.png"/></div></figure><p id="01f8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">将你的JSON解析成<code class="fe kv kw kx ky b">Data</code>，然后解码成你的<code class="fe kv kw kx ky b">struct</code>或者<code class="fe kv kw kx ky b">class</code>模型是我们在iOS开发生活中经常做的事情。然而，如果没有单元测试的帮助，您要么重复运行模拟器来跟踪打印日志，检查您是否解码正确，要么打开一个空白的项目/操场，重新填充元数据来攻击API。程序员讨厌做重复性的工作，这就是单元测试的用处。我们可以用一个JSON文件在本地测试它，快速且专用于特定的模型。</p><p id="4ad1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在本文中，我将使用<a class="ae kz" href="https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/iTuneSearchAPI/Searching.html#//apple_ref/doc/uid/TP40017632-CH5-SW1" rel="noopener ugc nofollow" target="_blank"> iTunes API </a>向您展示我如何一步一步地将JSON数据解码为模型。</p><h2 id="8401" class="la lb it bd lc ld le dn lf lg lh dp li ki lj lk ll km lm ln lo kq lp lq lr ls bi translated">项目设置</h2><p id="18a9" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">这里我将使用<a class="ae kz" href="https://itunes.apple.com/search?media=music&amp;entity=song&amp;term=havana" rel="noopener ugc nofollow" target="_blank">搜索Havanna的歌曲</a>作为我的终点。复制JSON数据并将其粘贴到data文件夹下的JSON文件中。在这个例子中是<em class="ly"> SearchResult.json </em>。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi lz"><img src="../Images/892c1206cb15341ad4efbaa67e621bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ss7obyWAcq7OnfKMdDS99Q.png"/></div></div></figure><p id="cc45" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">从<em class="ly">中快速获取<code class="fe kv kw kx ky b">Data</code>。json </em>文件，在扩展文件夹下添加这个helper函数。</p><figure class="ma mb mc md gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9247" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我们写代码之前的最后一件事是用<a class="ae kz" href="https://app.quicktype.io/" rel="noopener ugc nofollow" target="_blank"> quicktype.io </a>准备我们的cheatsheet。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mk"><img src="../Images/cb614ce5e196eae1679269a1f56ae6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZDCslx-2t7BYxcm-b0UdVg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">【https://app.quicktype.io/】</figcaption></figure><p id="23be" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">瞥一眼quicktype.io备忘单，你会发现只有两种型号，<code class="fe kv kw kx ky b">SearchResult</code>和<code class="fe kv kw kx ky b">Result</code>。由于<a class="ae kz" href="https://developer.apple.com/documentation/swift/result" rel="noopener ugc nofollow" target="_blank"> Swift 5已经引入了</a> <code class="fe kv kw kx ky b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/result" rel="noopener ugc nofollow" target="_blank">Result</a></code> <a class="ae kz" href="https://developer.apple.com/documentation/swift/result" rel="noopener ugc nofollow" target="_blank">型</a>，为了避免歧义，我们将其命名为<code class="fe kv kw kx ky b">Song</code>。相应地为这两个模型创建测试用例。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mp"><img src="../Images/20b5ef66afda04d12fa294dd4f52fee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kp5CJBRONPEHki_RS_PnA.png"/></div></div></figure><h2 id="4823" class="la lb it bd lc ld le dn lf lg lh dp li ki lj lk ll km lm ln lo kq lp lq lr ls bi translated"><strong class="ak">解析模型</strong></h2><p id="2150" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">我们先从外模开始，<code class="fe kv kw kx ky b">SearchResult</code>。将您的<code class="fe kv kw kx ky b">sut</code>被测系统设置为<code class="fe kv kw kx ky b">SearchResult</code>，使用<em class="ly"> XCTestCase+JSON.swift. </em>中提供的helper函数加载数据</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi lz"><img src="../Images/a998276b33b7d3e3bce4804a6c19f2ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kYfozG8NjfhOR0IN5JjuZg.png"/></div></div></figure><p id="4851" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一个测试用例每次运行都会经历<code class="fe kv kw kx ky b">setupWithError()</code> →测试函数→ <code class="fe kv kw kx ky b">tearDownWithError()</code>的过程。因此，在<code class="fe kv kw kx ky b">setupWithError()</code>期间，press ⌘+U将自动为您检查解码，您将检查内容是否与提供的JSON匹配。</p><blockquote class="mq mr ms"><p id="73c7" class="jx jy ly jz b ka kb kc kd ke kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt ku im bi translated">注意:如果你没有任何测试功能，它永远不会激活<code class="fe kv kw kx ky b">setupWithError()</code>。</p></blockquote><p id="7ca2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在TDD中，<strong class="jz iu">红绿重构</strong>过程是标准的。我已经将结果计数设置为49，以确保单元测试正常运行。修改回50，测试用例就通过了。</p><p id="0944" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，我们将解析嵌套模型<code class="fe kv kw kx ky b">Song</code>。</p><p id="8315" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你和你的后端有一个单一的真相来源，那么你应该遵循它。就拿<code class="fe kv kw kx ky b">Song</code>来说吧，<a class="ae kz" href="https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/iTuneSearchAPI/UnderstandingSearchResults.html#//apple_ref/doc/uid/TP40017632-CH8-SW1" rel="noopener ugc nofollow" target="_blank">这个文件应该是it </a>。来自不同端点的响应结果可能有也可能没有某些属性，比如<code class="fe kv kw kx ky b">previewURL</code>。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mw"><img src="../Images/5dee1fe0b0f1c0bd7f463e988e1a2a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g35_xZXbdKXTayn-oK979g.png"/></div></div></figure><p id="d434" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，quicktype.io会给我们一个<code class="fe kv kw kx ky b">String</code>而不是<code class="fe kv kw kx ky b">String?</code>。我们必须小心，否则很容易撞车。幸运的是，如果您已经为其他端点编写了单元测试，您也会很快失败，并防止您将那些错误代码发送到产品中。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mx"><img src="../Images/04a622544ac72320d06486b51f51e337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFkG41_ivC_h98zeK-Q8Ag.png"/></div></div></figure><p id="81aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你仔细看文档，<code class="fe kv kw kx ky b">artworkUrl100, artworkUrl60</code>、<code class="fe kv kw kx ky b">previewUrl</code>、<code class="fe kv kw kx ky b">trackTimeMillis</code>是可选的。为简单起见，我将在本演示中简单地使用<code class="fe kv kw kx ky b">previewUrl</code>。复制<em class="ly"> SearchResult.json </em>中的前两个<code class="fe kv kw kx ky b">Song</code>，粘贴到一个新的<em class="ly"> Songs.json </em>文件中，然后删除一个<code class="fe kv kw kx ky b">previewUrl</code>。有了正确的JSON数据，我们就可以再次利用quicktype.io。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi my"><img src="../Images/8b595605f75fd5bd7b03cccc341d64e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WI2WlQVScvxhf8Cbsm2yOQ.png"/></div></div></figure><p id="e379" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们不需要所有的属性，只需要解析我们需要的属性。与我们对<code class="fe kv kw kx ky b">SearchResult</code>所做的一样，主要区别是测试第一个和第二个<code class="fe kv kw kx ky b">Song</code>是否有<code class="fe kv kw kx ky b">previewUrl</code>。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mz"><img src="../Images/a09d27cf4f3cace787f283ce063cedcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qRt71DpntogwCPYK6YaDpw.png"/></div></div></figure><p id="d3d8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">差不多就是这样！希望您已经掌握了用健壮的单元测试解码JSON模型的技巧。有需要可以看一下<a class="ae kz" href="https://github.com/ji3g4kami/ParseiTunes" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><h2 id="9840" class="la lb it bd lc ld le dn lf lg lh dp li ki lj lk ll km lm ln lo kq lp lq lr ls bi translated">从这里去哪里</h2><p id="9342" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">我建议编写一个脚本，用后端的单一来源更新JSON文件。约翰·桑德尔写了一篇关于此事的<a class="ae kz" href="https://www.swiftbysundell.com/articles/writing-end-to-end-json-mapping-tests-in-swift/" rel="noopener ugc nofollow" target="_blank">文章</a>，尽管<a class="ae kz" href="https://github.com/JohnSundell/Marathon" rel="noopener ugc nofollow" target="_blank">马拉松</a>遭到了反对。</p></div></div>    
</body>
</html>