<html>
<head>
<title>Kubernetes Logging in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes生产测井</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-logging-in-production-545ea88d9a4a?source=collection_archive---------2-----------------------#2021-10-26">https://itnext.io/kubernetes-logging-in-production-545ea88d9a4a?source=collection_archive---------2-----------------------#2021-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2f75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">了解适用于您的生产Kubernetes集群的可伸缩日志记录模式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/25685fc1161802b781b6c73b2833d916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-l8cbF45zMDnLkheDI3rnQ.png"/></div></div></figure><p id="1fc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">过去，在整体架构中，日志直接存储在裸机或虚拟机上。他们从不离开机器磁盘，操作团队会根据需要检查每个磁盘的日志。</p><p id="eb1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这在长寿的机器上有效，但是云中的机器是短暂的。随着越来越多的公司在容器上运行服务，并使用Kubernetes协调部署，日志不能再存储在机器上，实现日志管理策略至关重要。</p><p id="fed0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">日志是调试和监控应用程序的有效方法，它们需要存储在单独的后端，以便在pod或节点出现故障时可以查询和分析。这些独立的后端包括Elasticsearch、GCP的Stackdriver和AWS的Cloudwatch等系统。</p><p id="63a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将日志从集群存储到存储后端称为集群级日志记录。在本文中，我们将讨论如何在您自己的Kubernetes集群中实现这种方法。</p><h1 id="b570" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">日志架构</h1><p id="383a" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在Kubernetes集群中，有两个主要的日志源，您的应用程序和系统组件。</p><p id="b32c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的应用程序在Kubernetes集群中作为容器运行，容器运行时负责获取应用程序的日志，而Docker将这些日志重定向到stdout和stderr流。在Kubernetes集群中，这两个流都被写入集群节点上的JSON文件。</p><p id="8353" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用以下命令可以随时获取这些容器日志:</p><pre class="kp kq kr ks gt md me mf mg aw mh bi"><span id="ec91" class="mi lb it me b gy mj mk l ml mm">kubectl logs podname</span></pre><p id="9038" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">日志的另一个来源是系统组件。一些系统组件(即<code class="fe mn mo mp me b">kube-scheduler</code>和<code class="fe mn mo mp me b">kube-proxy</code>)作为容器运行，并遵循与您的应用程序相同的日志原则。</p><p id="01c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他系统组件(<code class="fe mn mo mp me b">kubelet</code>和<code class="fe mn mo mp me b">container runtime</code>本身)作为本地服务运行。如果<code class="fe mn mo mp me b">systemd</code>在机器上可用，组件在<code class="fe mn mo mp me b">journald</code>中写入日志，否则在<code class="fe mn mo mp me b">/var/log</code>目录中写入一个<code class="fe mn mo mp me b">.log</code>文件。</p><p id="5613" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们已经了解了应用程序和集群的哪些组件会生成日志以及它们存储在哪里，那么让我们来看看将这些日志卸载到单独的存储系统的一些常见模式。</p><h1 id="ce18" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">记录模式</h1><p id="e784" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">收集原木的两种最突出的模式是边车模式和DaemonSet模式。</p><h1 id="3b05" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.达蒙塞特图案</h1><p id="e83d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在DaemonSet模式中，日志代理通过Kubernetes中的DaemonSet资源作为pods部署。部署DaemonSet可以确保集群中的每个节点都有一个运行日志代理的pod。该日志代理被配置为从<code class="fe mn mo mp me b">/var/logs</code>目录中读取日志，并将它们发送到存储后端。您可以在图1中看到这种配置的示意图。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mq"><img src="../Images/1c18028db583ba84fa87373ff0a5947b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ELB5bH7QGyXb-2HM.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">图1:通过DaemonSet在每个节点上运行的日志代理</figcaption></figure><h1 id="3eb6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.边车模式</h1><p id="0994" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">或者，在sidecar模式中，一个专用容器沿着同一个pod中的每个应用程序容器运行。这种边车可以有两种类型，流式边车或测井代理边车。</p><p id="73fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您运行将日志写入文件而不是stdout/stderr流的应用程序时，或者运行以非标准格式写入日志的应用程序时，可以使用流sidecar。在这种情况下，您可以使用一个流sidecar容器将日志从文件发布到它自己的stdout/stderr流中，然后Kubernetes本身就可以获取这些日志。</p><p id="50c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将日志消息转换为标准的日志格式，流式边盘还可以为日志结构带来奇偶校验。您可以在图2中看到这种模式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mq"><img src="../Images/0dcbcc03aa5f0f28e6802c8b99608d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dGIKqOsYJDdWfc-0.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">图2:流式边车模式</figcaption></figure><p id="db60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种方法是日志代理sidecar，sidecar自己将日志发送到存储后端。每个pod都包含一个日志代理，如Fluentd或Filebeat，它从应用程序容器中捕获日志，并将它们直接发送到存储后端，如图3所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mq"><img src="../Images/8f74a3f91b90b1433c5fc8c95b1bffcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5PrrpQRox6DXRgDt.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">图3:日志代理边车模式</figcaption></figure><h1 id="4a0b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">利弊</h1><p id="9a40" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">既然我们已经讨论了DaemonSet和sidecar两种方法，让我们熟悉一下每种方法的优缺点。</p><h1 id="a5e9" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.DaemonSet(节点级)</h1><p id="5696" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">赞成的意见</p><ul class=""><li id="9e96" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">节点级日志记录更容易实现，因为它与现有的基于文件的日志记录挂钩，并且由于每个节点上运行的容器更少，因此比sidecar方法占用的资源更少。</li><li id="4bc8" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">这些日志可以通过用于调试的kubectl命令获得，因为kubelet可以获得这些日志文件，它会返回日志文件的内容。</li></ul><p id="fb5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">骗局</p><ul class=""><li id="9fdd" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">支持不同的日志结构或写入日志文件而不是流的应用程序的灵活性较低。您需要修改应用程序日志结构来实现奇偶校验，或者在您的存储后端处理差异。</li><li id="7e1b" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">因为它们是作为JSON文件存储在节点磁盘上的，所以日志不能永久保存。您需要有一个日志循环机制来回收旧的日志。如果您使用的是容器运行时接口，kubelet会负责循环日志，不需要实现显式的解决方案。</li></ul><h1 id="5a12" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.边车</h1><p id="aedb" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">赞成的意见</p><ul class=""><li id="4bb9" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">您可以灵活地为每个应用程序容器定制sidecars。例如，一个应用程序可能没有能力写入<code class="fe mn mo mp me b">stdout/stderr</code>，或者它可能有一些不同的日志格式。在这些情况下，边车集装箱可以为系统带来平等。</li><li id="1c74" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">如果您使用不带流的日志代理sidecar，则不需要旋转日志，因为节点磁盘上没有存储日志。</li></ul><p id="ace7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">骗局</p><ul class=""><li id="81f0" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">与节点级的pod相比，为每个应用程序容器运行sidecar是相当耗费资源的。</li><li id="bcc7" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">给每个部署增加一个边车会增加额外的复杂性。</li><li id="df97" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">如果你为一个把日志写到文件的应用程序使用一个流sidecar，你将为相同的日志使用双倍的存储空间，因为你将复制条目。</li><li id="decc" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">如果您使用的是不带流的日志代理sidecar，您将失去通过<code class="fe mn mo mp me b">kubectl</code>访问日志的能力。这是因为<code class="fe mn mo mp me b">kubelet</code>不再能够访问JSON日志。</li><li id="a3a6" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">对于日志代理sidecar，您还需要一个节点级代理，否则您将无法收集系统组件日志。</li></ul><h1 id="7180" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">将理论付诸实践</h1><p id="7358" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">既然我们已经了解了在Kubernetes集群中登录的可能模式，让我们将它们付诸实践。我们将部署生成日志的虚拟容器，并创建Kubernetes资源来实现我们上面讨论的日志模式。</p><p id="8daf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这个例子，我们将使用Fluentd作为日志代理，我们将安装Elasticsearch用于日志后端，安装Kibana用于可视化目的。我们将使用舵图将Elasticsearch和Kibana安装到同一个集群中。但是请注意，您的存储后端不应在同一个集群上，我们这样做只是为了演示。由于Fluentd的可插拔架构，它支持各种不同的接收器。这就是为什么Elasticsearch后端可以被任何云原生解决方案取代，包括Stackdriver或Cloudwatch。</p><h1 id="fc62" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.安装Elasticsearch和Kibana</h1><p id="4e94" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们将使用官方的舵图部署Elasticsearch和Kibana，舵图可以在这里找到(<a class="ae nj" href="https://github.com/elastic/helm-charts/blob/master/elasticsearch" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>、<a class="ae nj" href="https://github.com/elastic/helm-charts/blob/master/kibana" rel="noopener ugc nofollow" target="_blank"> Kibana </a>)。对于通过helm安装，你需要一个Helm二进制文件，但是Helm的安装超出了这篇文章的范围。</p><p id="268a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从添加helm repos开始。</p><pre class="kp kq kr ks gt md me mf mg aw mh bi"><span id="2f5c" class="mi lb it me b gy mj mk l ml mm">helm repo add elastic <a class="ae nj" href="https://helm.elastic.co" rel="noopener ugc nofollow" target="_blank">https://helm.elastic.co</a></span></pre><p id="334f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将在集群中安装Elasticsearch和Kibana图表。</p><pre class="kp kq kr ks gt md me mf mg aw mh bi"><span id="a2a6" class="mi lb it me b gy mj mk l ml mm">helm install elasticsearch elastic/elasticsearch<br/>helm install kibana elastic/kibana</span></pre><p id="bbc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将在您的集群中安装最新版本的Elasticsearch和Kibana，然后可以用作您的日志的存储后端。</p><p id="87d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在图表中使用了默认值，但是在生产中安装时，您可以根据需要更改任何参数。</p><h1 id="6f6a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.达蒙塞特</h1><p id="e571" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们将把Fluentd部署为恶魔集。为了保持较低的详细度，我们不会创建单独的ServiceAccount和ClusterRole。但是在生产环境中，Fluentd pods应该使用一个单独的服务帐户运行，并限制访问权限。</p><p id="e60e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用以下Kubernetes资源将Fluentd部署为DaemonSet:</p><pre class="kp kq kr ks gt md me mf mg aw mh bi"><span id="35ce" class="mi lb it me b gy mj mk l ml mm">apiVersion: extensions/v1beta1<br/>kind: DaemonSet<br/>metadata:<br/>  name: fluentd<br/>  namespace: kube-system<br/>  labels:<br/>    k8s-app: fluentd-logger<br/>spec:<br/>  template:<br/>    metadata:<br/>      labels:<br/>        k8s-app: fluentd-logger<br/>    spec:<br/>      containers:<br/>      - name: fluentd<br/>        image: fluent/fluentd-kubernetes-daemonset:elasticsearch<br/>        env:<br/>        - name:  FLUENT\_ELASTICSEARCH\_HOST<br/>          value: "elasticsearch-master"<br/>        - name:  FLUENT\_ELASTICSEARCH\_PORT<br/>          value: "9200"<br/>        volumeMounts:<br/>        - name: varlog<br/>          mountPath: /var/log<br/>        - name: dockerlogs<br/>          mountPath: /var/lib/docker/containers<br/>          readOnly: true<br/>      volumes:<br/>      - name: varlog<br/>        hostPath:<br/>          path: /var/log<br/>      - name: dockerlogs<br/>        hostPath:<br/>          path: /var/lib/docker/containers</span></pre><p id="a0dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，我们安装了两个卷:一个在<code class="fe mn mo mp me b">/var/log</code>处，另一个在<code class="fe mn mo mp me b">/var/log/docker/containers</code>处，系统组件和Docker运行时分别将日志放在这里。</p><p id="fb07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们正在使用的映像已经配置了智能默认值，可用于DaemonSet，但您可以更改配置<a class="ae nj" href="https://hub.docker.com/r/fluent/fluentd-kubernetes-daemonset" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将上述YAML资源保存在名为<code class="fe mn mo mp me b">fluentd-ds.yaml</code>的文件中，并通过以下命令应用该资源:</p><pre class="kp kq kr ks gt md me mf mg aw mh bi"><span id="f24a" class="mi lb it me b gy mj mk l ml mm">kubectl apply -f fluentd-ds.yaml</span></pre><p id="b851" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将在Kubernetes集群中的每个节点上启动一个Fluentd pod。</p><p id="ca75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将看到如何实现流和日志代理sidecar模式。</p><h1 id="a7f1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.边车</h1><p id="c9e1" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">首先，让我们看看当我们的应用程序将日志写入文件而不是流时的流sidecar模式。我们运行一个sidecar来读取这些日志，并将其写回到stdout/stderr流中。</p><pre class="kp kq kr ks gt md me mf mg aw mh bi"><span id="1402" class="mi lb it me b gy mj mk l ml mm">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: my-app<br/>spec:<br/>  containers:<br/>  - name: legacy-app<br/>    image: busybox<br/>    args:<br/>    - /bin/sh<br/>    - -c<br/>    - &gt;<br/>      i=0;<br/>      while true;<br/>      do<br/>        echo "$i: $(date)" &gt;&gt; /var/log/output.log;<br/>        i=$((i+1));<br/>        sleep 1;<br/>      done      <br/>    volumeMounts:<br/>    - name: varlog<br/>      mountPath: /var/log<br/>  - name: streaming-sidecar<br/>    image: busybox<br/>    args: \[/bin/sh, -c, 'tail -n+1 -f /var/log/output.log'\]<br/>    volumeMounts:<br/>    - name: varlog<br/>      mountPath: /var/log<br/>  volumes:<br/>  - name: varlog<br/>    emptyDir: {}</span></pre><p id="78bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，我们有一个虚拟容器，它将日志写入容器的<code class="fe mn mo mp me b">/var/log</code>目录中的文件。现在这些日志不能被容器运行时获取，这就是为什么我们实现了一个流sidecar来跟踪来自<code class="fe mn mo mp me b">/var/log</code>位置的日志，并将其重定向到<code class="fe mn mo mp me b">stdout</code>流。</p><p id="1a25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个日志流将由容器运行时获取，并作为JSON文件存储在节点上的<code class="fe mn mo mp me b">/var/log</code>目录中，然后由节点级日志代理获取。</p><p id="daff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们看看日志代理sidecar。在这个模式中，我们将把Fluentd部署为sidecar，它将直接写入我们的Elasticsearch存储后端。</p><p id="04dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，没有安装Elasticsearch插件的预构建映像，创建自定义Docker映像超出了本文的范围。相反，我们将使用在DaemonSet示例中使用的相同Fluentd图像。</p><pre class="kp kq kr ks gt md me mf mg aw mh bi"><span id="23b4" class="mi lb it me b gy mj mk l ml mm">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: my-app<br/>spec:<br/>  containers:<br/>  - name: count<br/>    image: busybox<br/>    args:<br/>    - /bin/sh<br/>    - -c<br/>    - &gt;<br/>      i=0;<br/>      while true;<br/>      do<br/>        echo "$i: $(date)" &gt;&gt; /var/log/output.log;<br/>        i=$((i+1));<br/>        sleep 1;<br/>      done      <br/>    volumeMounts:<br/>    - name: varlog<br/>      mountPath: /var/log<br/>  - name: logging-agent<br/>    image: fluent/fluentd-kubernetes-daemonset:elasticsearch<br/>     env:<br/>      - name:  FLUENT\_ELASTICSEARCH\_HOST<br/>        value: "elastisearch-master"<br/>      - name:  FLUENT\_ELASTICSEARCH\_PORT<br/>        value: "9200"<br/>    volumeMounts:<br/>    - name: varlog<br/>      mountPath: /var/log<br/>  volumes:<br/>  - name: varlog<br/>    emptyDir: {}</span></pre><h1 id="9e1f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="20a6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">鉴于pod和节点的短暂性，将Kubernetes集群中的日志存储在单独的存储后端非常重要。您可以使用多种模式来设置我们在本文中讨论的日志架构。</p><p id="60d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我们建议您的生产系统混合使用sidecar和节点级模式。这包括使用DaemonSet模式设置集群范围的节点级日志记录，并为不支持将日志写入流(<code class="fe mn mo mp me b">stdout/stderr</code>)或不以标准日志格式写入的应用程序实现流sidecar容器。这个流容器将自动显示要拾取的节点级代理的日志。</p><p id="10db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于存储后端的选择，您可以选择自我托管的开源解决方案，如Elasticsearch，或者您可以选择托管服务路线，如云托管的Elasticsearch、Stackdriver或Cloudwatch。选择适合您的后端将取决于您希望用您的体系结构实现的成本、查询和日志分析要求。</p><p id="c658" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关我们的最新见解和更新，<a class="ae nj" href="https://www.linkedin.com/company/codersociety" rel="noopener ugc nofollow" target="_blank">在LinkedIn上关注我们</a></p></div></div>    
</body>
</html>