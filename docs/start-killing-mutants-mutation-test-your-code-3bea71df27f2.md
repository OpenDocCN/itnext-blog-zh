# 开始杀死变种人:突变测试你的代码

> 原文：<https://itnext.io/start-killing-mutants-mutation-test-your-code-3bea71df27f2?source=collection_archive---------1----------------------->

## 测试你的测试，测试他们测试你认为他们测试的东西。

![](img/d3ea59285dcafefad16cc4dd5204ddd6.png)

我曾经遇到过这样的情况，我“忘记”为某个功能写一个测试——在一次面试的技术测试中——因为模仿一个依赖项实在是太尴尬了。我被我没有做正确的事情的知识所困扰，在现实生活中，这可能会在代码审查中被发现，伴随着随之而来的公众羞辱，而不仅仅是在采访中，在采访中，我可以指出我*写的所有其他测试，并解释说，在花了整个周末在这该死的事情上之后，我已经到了不再关心的地步。*

这不是一篇关于面试技巧的文章。

它是关于如何识别测试覆盖中的微小裂缝。差距比我跳过整个函数要小——更像是半测试的语句和半模仿的模仿。审查单元测试时，您不一定会注意到的漏洞(这种情况发生的频率有多高？)但是这仍然意味着您可以破坏您系统，并被您应该信任的测试套件欺骗。单元测试现在是标准的实践，但是你只能依靠你的套件，如果你确保它覆盖了足够的应用程序的功能。

一个很好的方法是使用突变测试框架，但是为了理解它的真正价值，让我们首先考虑一下为什么我们实际上要编写测试。

# 为什么我们要写单元测试？

我们写测试有很多原因。一些是:

*   如果代码不按预期运行，快速反馈:这有利于调试，并减少缺陷的成本。
*   它们可以是文档的一种形式，因为没有人会更新实际的文档。
*   他们经常鼓励更好的设计原则，因为不可测试的代码通常是糟糕的代码。

但是我的第一个原因，至少就本文的目的而言，是:

> **确保我们所做的任何更改不会意外改变现有代码库的功能。**

为了确保我们的更改不会 ***改变*** 任何现有的功能，我们需要确保我们的测试是 ***测试*** 现有的功能。

这就是突变测试可以帮助解决的问题。

# 什么是突变测试？

![](img/23dea044e9d4a68f7e536b79d3fa86b2.png)

突变测试框架将经历这个过程:

**1。以一种非常小的方式改变源代码**

**2。运行单元测试**

**3。记录是否有任何测试失败**

变化真的很小，通常只是翻转一个操作数或返回值。一个可能的变化(“突变”)如下所示:

`const isPositive = (num) => num > 0`

成为

`const isPositive = (num) => num **>=** 0`

如果你的测试都通过了，那就意味着你没有检查`isPositive(0)`的边界条件。首先编写变异代码是一个容易犯的错误:任何人都可能编写错误的操作数，或者复制/粘贴错误的内容。对于测试来说，测试`isPositive(5)`和`isPositive(-5)`并结束它是很容易的。

但是通过变异测试的魔力，我们可以发现并不是每个相关的案例都被测试过。因此，当我们编写源代码以及将来编辑它时，我们可以防止像这样的小错误，以及更大的错误。

该框架将创建大量的突变体，对于每个突变，会发生以下三种情况之一:

*   至少有一项测试失败。这意味着突变体已经被“杀死”,因此已经被改变的代码部分被适当地覆盖。
*   所有单元测试都通过。这意味着突变体已经“存活”,并且改变的功能不包括在测试中。
*   无限循环/运行时错误。这通常意味着这种变异实际上是不可能发生的——或者是当你实际尝试运行你的应用程序时会被捕捉到的——并且被认为是致命的。

一些其他可能的突变:

`**if (x === 3)**`

成为

*   `if (x >= 3)`
*   `if (x <=3)`
*   `if (x !== 3)`
*   `if (true)`
*   `if (false)`

```
**if (x === 3) {
    k++
}**
```

成为

*   `if (x === 3) {}`
*   `if (x === 3) k--`

```
**return {token: "c38bf32"}**
```

成为

`return {}`

`return null`

`return {token: ""}`

注意:如下所述，创建大量这些突变体并测试它们可能需要很长时间，这限制了突变测试在连续集成管道中的使用。如果在本地运行，您可以精确定位要变更的特定文件(例如，您正在处理的文件)，并将整个代码库运行留给远程通宵作业。

# 例子

这里有一个真实的例子:一段代码和它的伪测试(它们是真实的测试，我只是缩短了它们，使它们可读):

```
**SOURCE CODE**function handleLogin(request, response) {
    const {username, password} = request.body;
    if (!username) {
        return response.status(400)
            .json({reason: ‘ERR_NO_USERNAME’})
    }
    if (!password) {
        return response.status(400)
            .json({reason: ‘ERR_NO_PASSWORD’})
    }
}**PSEUDO-UNIT TESTS**const testRequest = {
    body: {} // no username or password fields
}
const mockResponse = () => ...testNoUsername() {
    handleLogin(testRequest, mockResponse);
    expect(mockResponse.calls.single.toBe(400));
}
testNoPassword() {
    handleLogin(testRequest, mockResponse);
    expect(mockResponse.calls.single.toBe(400));
}
```

让我们看看突变框架做了什么:

```
**MUTATED SOURCE CODE**function handleLogin(request, response) {
    const {username, password} = request.body;
    if (!username) {
        return response.status(400)
            .json({reason: ‘ERR_NO_USERNAME’})
    }
    if (**false**) {  **// formerly if(!password)**
        return response.status(400)
            .json({reason: ‘ERR_NO_PASSWORD’})
    }
}
```

现在，第二个“if”语句永远不会运行。但是两项测试都通过了——突变体存活了下来。我们有`testNoPassword()`来确保在没有密码的情况下处理响应，那么这是怎么回事呢？

因为测试`request.body`不包含用户名或密码，所以两个测试都被`if(!username)`语句捕获并返回。`if(!password)`根本不会被击中！当然，从语法上来说，我们传递给它的是一个没有密码的对象，但是如果没有用户名字段，测试将永远不会执行预期的逻辑。

您可能已经发现了这个问题，但是这只是一个大型代码库的很小一部分，并且这个部分是一个大型拉请求的一部分，所以团队中的任何人都没有注意到测试覆盖中的差距。解决方案是为每个测试创建一个`testRequest`:

```
**UPDATED TEST**const mockResponse = () => ...
testNoPassword() {
    const testRequest = {
        body: {
            username: "somethingNotStupid"
        }
    }
    handleLogin(testRequest, mockResponse);
    expect(mockResponse.calls.single.toBe(400));
}
```

然后那个变种人就被杀了！

通过在应用程序中识别和修复这样的情况，我们可以确保我们有一个可靠的测试套件，它将检查通过我们系统的大量逻辑流。如果我们需要做一个大的重构，或者只是一个小的改变，这是非常有用的。我们将知道我们的测试是可靠的，并将捕捉到系统逻辑的任何不想要的变化。

# 优点和缺点

![](img/e859f33fdbb6ab56239019dac51fa16d.png)

让我们回到我自己认为的编写单元测试的首要原因:

> **确保我们所做的任何更改不会意外改变现有代码库的功能。**

很难确保我们创建的测试足够可靠来实现这个目标。出现这种情况有很多原因，从复杂的应用程序逻辑到人们没有发现足够有趣的测试来适当地回顾它们。我已经展示了许多例子中的一个，在这些例子中，依靠人工代码审查是不够的，使用任何可用的工具来编写一个像样的测试套件是有意义的。

更多优点和缺点:

**优点**

存活与死亡的突变体是比线覆盖率更可靠的指标。这是我没有涉及到的东西，但它是一个非常有价值的观点。变异测试实际上确保了你的单元测试是在测试它们应该是什么，并且它们测试了大部分的逻辑(大部分圈复杂度)。线路覆盖只关心线路是否在沿途的某个地方被击中。行覆盖是有时间和地点的，但是变异测试是一种有价值的方法，可以确保你真正测试的是你想要的。

它捕捉许多小的、容易遗漏的编程错误，以及单元测试中的漏洞，否则这些都不会被注意到。突变测试是基于“合格程序员假设”的。这是程序员基本上擅长他们所做的事情的想法，所以错误是由小失误引起的(比如`>=`而不是`>`)，而不是由程序的大规模设计引起的。不管你是否同意这个理论，很明显我们很多时候都会犯很多小错误，而且它们并不总是容易被发现。

**劣势**

针对所有重要的代码库运行突变测试框架在计算上极其昂贵。运行可能需要几个小时，这使得它们不适合快速发布过程，尽管许多工具都有缩短所需时间的巧妙方法。当然，您可以整夜运行一个框架，然后检查报告——就像线覆盖率一样，您可以从一般趋势以及特定故障中获得价值。你可以留出时间详细阅读一份报告，并开始补充测试中的一些明显缺陷。

突变测试需要脑力从有用的捕获物中挑选出“垃圾”突变。并不是每一个幸存的突变体都是合法的，对于某些语言/框架，你可能会得到一个不利的信噪比。在这些情况下，比较一段时间内的趋势可能仍然有用，以确保幸存的突变不会继续增加。

很明显，与人工分析和行覆盖相比，突变测试让我们更清楚地看到我们的测试实际上在测试什么。我建议你试一试——你可能会惊讶于你的测试遗漏了什么。

# 建议的工具

我使用的几个开源工具是:

*   JavaScript:Stryker([Stryker-mutator . io](https://stryker-mutator.io/))
*   爪哇和科特林:坑([pitest.org](http://pitest.org/))

*注意:PIT 直接变异字节码，许多在 Java 中有效的变异在 Kotlin 中无效，因为它们会被 Kotlin 编译器捕获(例如，变异抛出空指针异常，或者与非穷举 when 语句相关)。更全面地支持 Kotlin 的工作正在进行中，但要小心这些垃圾突变导致的信噪比。*

# 进一步阅读

*   [我关于这个主题的原始演示文稿](https://www.slideshare.net/StephenLeigh4/mutation-testing-testing-your-tests)，其中包含了更全面的示例。
*   谷歌突变测试的状态——决定要突变什么和运行什么测试是一个巨大的挑战，本文将介绍谷歌是如何做到这一点的。
*   [这些幻灯片](https://www.st.cs.uni-saarland.de/edu/testingdebugging10/slides/10-MutationTesting.pdf)更详细地介绍了不同类型的变异，以及针对变异代码运行的测试实例。
*   [模式中的变异测试](https://github.com/atodorov/mutation-testing-in-patterns) : readme 有一个针对不同语言的工具列表，以及更多不同变异的例子。