<html>
<head>
<title>Server Side Hydration — SSR with Vue and webpack from scratch (3/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端水化—从零开始使用Vue和webpack的SSR(3/3)</h1>
<blockquote>原文：<a href="https://itnext.io/server-side-hydration-ssr-with-vue-and-webpack-from-scratch-3-3-8ed228655b0c?source=collection_archive---------2-----------------------#2018-06-22">https://itnext.io/server-side-hydration-ssr-with-vue-and-webpack-from-scratch-3-3-8ed228655b0c?source=collection_archive---------2-----------------------#2018-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9d1168ed9abe7d1c13f77e4cfc8cce1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFwa2s9rNO04SL2xzGm-MQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">vue+web pack | npmjs.com</figcaption></figure><p id="da20" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这篇文章将继续我的<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/setting-up-webpack-for-ssr-with-vue-b6ff9125d359">上一篇文章</a>，在那里我们实现了基本的服务器端渲染。现在我们将添加水合作用。如果应用程序依赖于外部资源，例如从外部端点检索的数据，则需要在我们调用<code class="fe lb lc ld le b">renderer.renderToString</code>的之前提取并解析<strong class="ke ir">数据。</strong></p><p id="4c92" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">源代码可以在<a class="ae la" href="https://github.com/lmiller1990/webpack-simple-vue" rel="noopener ugc nofollow" target="_blank">这里找到。</a></p><p id="964c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于这个例子，我们将从<a class="ae la" href="https://jsonplaceholder.typicode.com/posts/1" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>获取一个帖子。数据看起来像这样:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="2a99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">策略是这样的:</p><p id="b1bc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">客户端渲染:</p><ul class=""><li id="0567" class="ll lm iq ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated">在应用的<code class="fe lb lc ld le b">mounted</code>生命周期钩子中，<code class="fe lb lc ld le b">dispatch</code>一个Vuex <code class="fe lb lc ld le b">action</code></li><li id="3054" class="ll lm iq ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated"><code class="fe lb lc ld le b">commit</code>回应</li><li id="76f1" class="ll lm iq ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">照常渲染</li></ul><p id="8c90" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">服务器端渲染:</p><ul class=""><li id="2434" class="ll lm iq ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated">检查我们将要创建的静态<code class="fe lb lc ld le b">asyncData</code>函数</li><li id="1248" class="ll lm iq ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">将存储传递给<code class="fe lb lc ld le b">asyncData</code>，并调用<code class="fe lb lc ld le b">dispatch(action)</code></li><li id="d463" class="ll lm iq ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">提交结果</li><li id="1b1c" class="ll lm iq ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">现在我们有了所需的数据，调用<code class="fe lb lc ld le b">renderer.renderToString</code></li></ul></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><figure class="lf lg lh li gt jr gh gi paragraph-image"><a href="http://vuejs-course.com/"><div class="gh gi mg"><img src="../Images/8860e8ef1f39967845929ca6a9e3821a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_RGGAoqizZjbVse93Z4TQ.png"/></div></a><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来看看我的<a class="ae la" href="https://vuejs-course.com/" rel="noopener ugc nofollow" target="_blank"> Vue.js 3课程</a>！我们涵盖了组合API、类型脚本、单元测试、Vuex和Vue路由器。</figcaption></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="8e3a" class="mh mi iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">设置</h1><p id="cedf" class="pw-post-body-paragraph kc kd iq ke b kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz ij bi translated">我们需要一些新模块。即:</p><ul class=""><li id="1e59" class="ll lm iq ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated"><code class="fe lb lc ld le b">axios</code> -在浏览器和节点环境中工作的HTTP客户端</li><li id="e2e0" class="ll lm iq ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated"><code class="fe lb lc ld le b">vuex</code> -存储数据</li></ul><p id="4956" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将它们安装在:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><h1 id="cff8" class="mh mi iq bd mj mk nk mm mn mo nl mq mr ms nm mu mv mw nn my mz na no nc nd ne bi translated">创建商店</h1><p id="bbf8" class="pw-post-body-paragraph kc kd iq ke b kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz ij bi translated">让我们创建一个商店，首先让它在开发服务器上工作。通过运行<code class="fe lb lc ld le b">touch src/store.js</code>创建一个商店。在其中，添加以下内容:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="e5f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">标准Vuex，没什么特别的，就不赘述了。</p><p id="5296" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在需要使用商店。更新<code class="fe lb lc ld le b">create-app</code>:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="0609" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在返回<code class="fe lb lc ld le b">{ app, store, App }</code>。这是因为我们稍后将需要访问<code class="fe lb lc ld le b">src/server.js</code>中的<code class="fe lb lc ld le b">App</code>和<code class="fe lb lc ld le b">store</code>。</p><p id="9750" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你运行<code class="fe lb lc ld le b">npm run dev</code>，并访问<code class="fe lb lc ld le b">localhost:8080</code>，一切应该还在工作。更新<code class="fe lb lc ld le b">src/Hello.vue</code>，调度<code class="fe lb lc ld le b">mounted</code>中的动作，并使用<code class="fe lb lc ld le b">computed</code>属性检索它:</p><pre class="lf lg lh li gt np le nq nr aw ns bi"><span id="3d07" class="nt mi iq le b gy nu nv l nw nx">computed: {    <br/>  post() {      <br/>    return this.$store.state.post    <br/>  }   <br/>}</span></pre><p id="8b68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lb lc ld le b">localhost:8080</code>现在应该显示<code class="fe lb lc ld le b">title</code>和<code class="fe lb lc ld le b">Hello</code>。</p><h1 id="7cd3" class="mh mi iq bd mj mk nk mm mn mo nl mq mr ms nm mu mv mw nn my mz na no nc nd ne bi translated">获取服务器上的资源</h1><p id="acc8" class="pw-post-body-paragraph kc kd iq ke b kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz ij bi translated">运行<code class="fe lb lc ld le b">npm run build &amp;&amp; node src/server.js</code>，然后访问<code class="fe lb lc ld le b">localhost:8000</code>。你会注意到<code class="fe lb lc ld le b">Hello</code>被渲染了，但是<code class="fe lb lc ld le b">post.title</code>没有。这是因为<code class="fe lb lc ld le b">mounted</code>只在浏览器中运行。使用SSR时没有动态更新，只有<code class="fe lb lc ld le b">created</code>和<code class="fe lb lc ld le b">beforeCreate</code>执行。更多信息见<a class="ae la" href="https://ssr.vuejs.org/guide/universal.html#component-lifecycle-hooks" rel="noopener ugc nofollow" target="_blank">此处</a>。我们需要另一种方式来调度行动。</p><p id="e178" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe lb lc ld le b">Hello.vue</code>中，增加一个<code class="fe lb lc ld le b">asyncData</code>功能。这不是Vue的一部分，只是一个普通的JavaScript函数。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="0b83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们必须通过<code class="fe lb lc ld le b">store</code>作为一个参数。这是因为<code class="fe lb lc ld le b">asyncData</code>不是Vue的一部分，所以它没有访问<code class="fe lb lc ld le b">this</code>的权限，所以我们无法访问商店——事实上，因为我们会在调用<code class="fe lb lc ld le b">renderer.renderToString</code>之前调用这个函数，<code class="fe lb lc ld le b">this</code>甚至还不存在。</p><p id="3969" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在将<code class="fe lb lc ld le b">src/server.js</code>更新为调用<code class="fe lb lc ld le b">asyncData</code>:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="b160" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们在渲染<code class="fe lb lc ld le b">app</code>的时候，<code class="fe lb lc ld le b">store.state</code>应该已经包含<code class="fe lb lc ld le b">post</code>了！让我们试一试:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="d5e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">浏览<code class="fe lb lc ld le b">localhost:8000</code>导致终端显示错误:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="51c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lb lc ld le b">XMLHttpRequest</code>是Web API，不存在于节点环境中。但是为什么会这样呢？是指在客户端和服务器上都可以工作，对吗？</p><p id="de3e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们来看看<code class="fe lb lc ld le b">axios</code>:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="1bed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有一堆东西。感兴趣的字段是<code class="fe lb lc ld le b">browser</code>和<code class="fe lb lc ld le b">main</code>:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="7f6d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lb lc ld le b">browser</code>是问题的来源。查看关于npm上的<a class="ae la" href="https://docs.npmjs.com/files/package.json#browser" rel="noopener ugc nofollow" target="_blank">浏览器</a>的更多信息。基本上，如果有一个<code class="fe lb lc ld le b">browser</code>字段，并且webpack build的<code class="fe lb lc ld le b">target</code>是<code class="fe lb lc ld le b">web</code>，它将使用<code class="fe lb lc ld le b">browser</code>字段而不是<code class="fe lb lc ld le b">main</code>。让我们回顾一下我们的<code class="fe lb lc ld le b">config/server.js</code>:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="e641" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们没有指定<code class="fe lb lc ld le b">target</code>。如果我们检查文档<a class="ae la" href="https://webpack.js.org/concepts/targets/#multiple-targets" rel="noopener ugc nofollow" target="_blank">这里的</a>，我们可以看到<code class="fe lb lc ld le b">target</code>的默认值是web。这意味着我们正在使用面向客户端的<code class="fe lb lc ld le b">axios</code>构建，而不是Node.js构建。更新<code class="fe lb lc ld le b">config.server.js</code>:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="d914" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在快跑</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="d89e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并访问<code class="fe lb lc ld le b">localhost:8000</code>。<code class="fe lb lc ld le b">title</code>渲染完毕！将它与使用dev服务器的<code class="fe lb lc ld le b">localhost:8080</code>进行比较——您可以看到，当我们进行客户端获取时，标题暂时是空白的，直到请求完成。访问<code class="fe lb lc ld le b">localhost:8000</code>没有这个问题，因为数据甚至在应用程序呈现之前就被获取了。</p><h1 id="165b" class="mh mi iq bd mj mk nk mm mn mo nl mq mr ms nm mu mv mw nn my mz na no nc nd ne bi translated">结论</h1><p id="3b5d" class="pw-post-body-paragraph kc kd iq ke b kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz ij bi translated">我们看到了如何编写同时在服务器和客户机上运行的代码。这个配置一点也不健壮，也不适合在严肃的应用程序中使用，但是说明了如何为客户端和服务器设置不同的webpack配置。</p><p id="2427" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章中，我们了解到:</p><ul class=""><li id="757e" class="ll lm iq ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated">关于<code class="fe lb lc ld le b">package.json</code>，具体是<code class="fe lb lc ld le b">browser</code>房产</li><li id="f034" class="ll lm iq ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">webpack的<code class="fe lb lc ld le b">target</code>属性</li><li id="f2f2" class="ll lm iq ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">如何在客户机和服务器上执行ajax请求</li></ul><h1 id="d2f3" class="mh mi iq bd mj mk nk mm mn mo nl mq mr ms nm mu mv mw nn my mz na no nc nd ne bi translated">丰富</h1><p id="89b5" class="pw-post-body-paragraph kc kd iq ke b kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz ij bi translated">许多改进仍然存在:</p><ul class=""><li id="456e" class="ll lm iq ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated">使用Vue路由器(服务器端和客户端)</li><li id="4e61" class="ll lm iq ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">更强大的数据提取</li><li id="0f79" class="ll lm iq ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">添加一些单元测试</li></ul><p id="6074" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">源代码可在此处<a class="ae la" href="https://github.com/lmiller1990/webpack-simple-vue" rel="noopener ugc nofollow" target="_blank">获得。</a></p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="046f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ny">原载于</em> <a class="ae la" href="https://lmiller1990.github.io/electic/posts/server_side_hydration_with_vue_and_webpack.html" rel="noopener ugc nofollow" target="_blank"> <em class="ny">拉克伦的博客</em> </a> <em class="ny">。</em></p></div></div>    
</body>
</html>