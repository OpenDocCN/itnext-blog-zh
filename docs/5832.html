<html>
<head>
<title>Understanding RegEx in JavaScript (the easy way)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的正则表达式(简单的方法)</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-regex-in-javascript-the-easy-way-ad0e5888a3ec?source=collection_archive---------0-----------------------#2021-06-05">https://itnext.io/understanding-regex-in-javascript-the-easy-way-ad0e5888a3ec?source=collection_archive---------0-----------------------#2021-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a9bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要被RegEx吓到！他们比你想象的要容易！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/306b22db665bacaeaa11543178f06d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FliGAfao5oqDtejRJuvCig.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@calebminear" rel="noopener ugc nofollow" target="_blank"> Caleb Minear </a>在<a class="ae le" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d6bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在计算机科学中，有些话题听起来可能比其他的更可怕。详细地说，正则表达式一开始可能听起来令人难以置信地可怕…但是一旦你学会了，你会发现它们非常容易和有用！</p><h1 id="9d28" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么我需要正则表达式？</h1><p id="3482" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先:什么是正则表达式？正则表达式是定义搜索模式的字符序列。</p><p id="0a4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">举个例子:我们有一个既包含数字又包含字母的字符串，我们想删除每一个非字母字符。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9336" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何删除这个字符串中的所有数字？这看起来不是一个好的解决方案:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="af38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，上面的代码可以工作…但是我认为我们可以使用一个简单的正则表达式做得更好:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b603" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这更容易实现、阅读和测试！但是它是如何工作的呢？在JavaScript中，正则表达式有两种定义方式:</p><ul class=""><li id="e985" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated">在两个斜线之间书写正则表达式:<code class="fe mt mu mv mw b">/myregex/g</code></li><li id="bfe4" class="mk ml it js b jt mx jx my kb mz kf na kj nb kn mp mq mr ms bi translated">使用<code class="fe mt mu mv mw b">RegExp</code>类:<code class="fe mt mu mv mw b">const re = new Regexp("myregex", "g");</code></li></ul><p id="1137" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们写下几个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8628" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你能看出不同之处吗？</p><ul class=""><li id="aea3" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated">使用<code class="fe mt mu mv mw b">RegExp</code>类，我们可以传递一个字符串作为第一个参数。这意味着我们可以编写更多的动态正则表达式！</li><li id="fc90" class="mk ml it js b jt mx jx my kb mz kf na kj nb kn mp mq mr ms bi translated">在<code class="fe mt mu mv mw b">RegExp</code>类中，反斜杠(<code class="fe mt mu mv mw b">\</code>)字符被用作转义字符。所以，如果你想使用(例如)“全数字”字符(<code class="fe mt mu mv mw b">\d</code>)，你必须对它进行转义(<code class="fe mt mu mv mw b">\\d</code>)。</li></ul><h1 id="dd5f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">正则表达式方法</h1><p id="27a6" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">一旦我们编写了正则表达式，我们就可以使用它们，这要感谢四种不同的内置方法:</p><p id="676b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">exec<code class="fe mt mu mv mw b">exec</code>方法在字符串中的正则表达式之后执行匹配搜索:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0ad2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，即使我们使用了全局标志(<code class="fe mt mu mv mw b">g</code>)，它也会在第一次出现后停止。</p><p id="71e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与<code class="fe mt mu mv mw b">exec</code>方法类似，<code class="fe mt mu mv mw b">match</code>将根据您的正则表达式返回一个匹配数组:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5215" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">toString <code class="fe mt mu mv mw b">toString</code>返回正则表达式的字符串表示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="592d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">test <code class="fe mt mu mv mw b">test</code>将只对一个字符串运行正则表达式，并根据匹配返回一个布尔值:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="e306" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">编写正则表达式</h1><p id="7b07" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">正如我以前说过的，RegEx一开始听起来可能很吓人，但是信不信由你，一旦你习惯了，它们会变得非常容易！让我们从基础开始，看一些正则表达式的例子:</p><p id="bf13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以编写一个匹配任何字符的正则表达式，只需在正则表达式中写入所需的字符:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/91ab3e10991af09dbfeb5eaf60f48624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MvmF8rsX_dz3YZD-LBlywQ.png"/></div></div></figure><p id="bcc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，这个正则表达式只匹配第一个小写的<code class="fe mt mu mv mw b">a</code>字符。如果我们想匹配小写和大写字符呢？</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/6afab997faca53c5516fc7be69ddc0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBiCjHz0V64dI_PRyMH9RA.png"/></div></div></figure><p id="4519" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以在正则表达式后面加上<code class="fe mt mu mv mw b">i</code>(不敏感)标志！但现在我们有一个问题，我们只是匹配第一次出现！让我们通过添加<code class="fe mt mu mv mw b">g</code>(全球)标志来解决这个问题:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/ad7c3fb1acffa9b3ae39b2e56dcfcc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJzg-SzP9-_a8aBeH1DeZw.png"/></div></div></figure><p id="47d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们要匹配以下任何一个字符:<code class="fe mt mu mv mw b">a, b, c</code></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/e36720872257d1d786d3af89b3768d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hyovl_D2M8OxU98IMA80lQ.png"/></div></div></figure><p id="7ec8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">厉害！我们只需要把我们想要的字符放在两个方括号内，RegEx引擎就会匹配每个字符！如果我们想匹配所有不等于下列字符的东西怎么办:<code class="fe mt mu mv mw b">b, c</code>？</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/7e8db32e10ce17b5c63db69fa92a3e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ETJFnMBNDgXl0oLttK6qDA.png"/></div></div></figure><p id="4a50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如此简单！只需在两个括号内添加<code class="fe mt mu mv mw b">^</code>字符，RegEx引擎就会阻止这些字符匹配！</p><p id="c2c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，假设我们想要检测以下面的字符串开始的每一行:<code class="fe mt mu mv mw b">"I love regex"</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/91e6492004f77fd50870d782a9ed7a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_8uagmFgHh0CNB2bRAoaOg.png"/></div></div></figure><p id="eaa8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当写在正则表达式的开头时(在两个方括号之外)，<code class="fe mt mu mv mw b">^</code> char的意思是“开始于”。注意，我们还使用了<code class="fe mt mu mv mw b">m</code> (multiline flag)来在多行上运行我们的正则表达式！但它是如何匹配整个系列的呢？我们用<code class="fe mt mu mv mw b">.+</code>结束了正则表达式，意思是“匹配所有内容直到最后”。其实点char ( <code class="fe mt mu mv mw b">.</code>)的意思是“任意char”，<code class="fe mt mu mv mw b">+</code>的意思是“无限重复前面的匹配”。所以，这两个字符将匹配所有内容，直到字符串结束！</p><p id="1274" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果我们想要停止“无限”匹配呢？</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/973dbcd15f27ee2fd4311bf948fb9955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5AR06dPNxu2derOLAka6Vg.png"/></div></div></figure><p id="2b5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">超级容易！我们的正则表达式引擎从左到右读取正则表达式，因此上面的正则表达式将被解释为“匹配双引号字符，然后匹配所有内容，直到下一个双引号字符”。</p><h1 id="6587" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">正则表达式引用</h1><p id="7c88" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们只是触及了正则表达式的皮毛…不可能有一篇文章可以教你如何编写超级强大的正则表达式！但是我们必须从某个地方开始</p></div></div>    
</body>
</html>