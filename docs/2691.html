<html>
<head>
<title>Adding security layers to your App on OpenShift — Part 5: Mutual TLS with Istio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在OpenShift上为您的应用添加安全层—第5部分:使用Istio的Mutual TLS</h1>
<blockquote>原文：<a href="https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-5-mutual-tls-with-istio-a8800c2e4df4?source=collection_archive---------2-----------------------#2019-07-12">https://itnext.io/adding-security-layers-to-your-app-on-openshift-part-5-mutual-tls-with-istio-a8800c2e4df4?source=collection_archive---------2-----------------------#2019-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0c62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，保护你的应用程序是必须的，但是如果你没有在一开始就考虑它，那么在不修改代码的情况下引入它是很困难的。幸运的是，像<a class="ae kl" href="http://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>这样的容器和平台带来的新的云原生模式提供了简单的方法来解决安全问题，而无需接触代码。</p><p id="843b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在保护我们的<code class="fe km kn ko kp b">fruits-catalog</code>应用程序的过程中，我们经历了许多主题:隔离和隔离、外部暴露、用户认证和授权、机密管理、数据库动态凭证生命周期，以及谈论容器云本机模式。但是等等…云原生模式不仅仅是关于容器的！</p><p id="cef2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">云原生模式来自于应用程序固有的高度分布式特性，这些应用程序可能托管在混合基础架构(不同的云提供商或内部)和架构风格上，如面向服务的架构及其称为<a class="ae kl" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank">微服务</a>的新演进步骤。然而，高度分布意味着众所周知的分布式计算的谬误<a class="ae kl" href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" rel="noopener ugc nofollow" target="_blank">我们通常在应用程序中添加弹性和安全策略…</a></p><p id="1beb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从安全的角度来看，云的原生采用也意味着要应用的安全模式发生了转变:从分离不可信和可信区域的外围安全-这种模式也称为城堡和壕沟-到<strong class="jp ir">零信任网络</strong>。这种转变是必要的，因为以下事实加剧了明显的中间人脆弱性:</p><ul class=""><li id="e188" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated">越来越多的公司将数据分散在混合基础架构中，这使得很难建立单一的安全控制区域，</li><li id="58f4" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">财务优化问题意味着应用程序资源的整合、共享和弹性，这使得持续调整和监控安全区域变得更加困难。</li></ul><p id="ad42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，我们有一些新的工具来解决这个问题！一个<a class="ae kl" href="https://enterprisersproject.com/article/2019/6/service-mesh-plain-english" rel="noopener ugc nofollow" target="_blank">服务网格</a>是容器和分布式架构的关键组件，因为它完全是为了解决这个问题和实现零信任网络策略。在高层次上，服务网格确保应用程序服务之间的通信。它提供诸如流量路由、负载平衡以及服务发现、加密、认证和授权等功能。这篇文章将使用<a class="ae kl" href="https://istio.io" rel="noopener ugc nofollow" target="_blank"> Istio服务网格</a>，并展示它如何保护并大大提高我们的<code class="fe km kn ko kp b">fruits-catalog</code>应用程序的加固水平。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/9ab331b0af94a18a3ebcaea638242409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6XteOS5alTNfHJ--kiOvFw.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">第5部分—使用Istio服务网格通过MTLS保护集群内部传输</figcaption></figure><p id="8492" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lu">这篇文章是一个更大的系列文章的一部分，讲述了如何给现有的应用增加安全层。目前公布的其他部分有:</em></p><ul class=""><li id="f3c8" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-1-deployment-and-tls-ingress-9ef752835599" rel="noopener"> <em class="lu">第1部分—部署和TLS入口</em> </a></li><li id="0a37" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-2-8320018bcdd1" rel="noopener"> <em class="lu">第二部分——使用Keycloak的认证和授权</em> </a></li><li id="5b40" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-3-secret-management-with-vault-8efd4ec29ec4" rel="noopener"> <em class="lu">第三部分——金库秘密管理</em> </a></li><li id="bc3f" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-4-dynamic-secrets-with-vault-b5fe1fc7709b" rel="noopener"> <em class="lu">第四部分——带金库的动态秘密</em> </a></li><li id="8a71" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><em class="lu">第5部分——与Istio的共同TLS(此职位)</em></li><li id="0512" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-6-pki-as-a-service-with-vault-and-cert-e6dbbe7028c7" rel="noopener"> <em class="lu">第6部分— PKI即服务，带保险库和证书管理器</em> </a></li></ul><h1 id="cca1" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">我们想在这部分实现什么？</h1><p id="6fd6" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">在这一部分中，我们将把Istio服务网格特性应用到我们的pod<code class="fe km kn ko kp b">fruits-catalog</code>和<code class="fe km kn ko kp b">mongodb</code>中。虽然Istio提供了大量与<a class="ae kl" href="https://istio.io/docs/tasks/traffic-management/request-routing/" rel="noopener ugc nofollow" target="_blank">请求路由</a>、<a class="ae kl" href="https://istio.io/docs/tasks/traffic-management/circuit-breaking/" rel="noopener ugc nofollow" target="_blank">弹性</a>或<a class="ae kl" href="https://istio.io/docs/tasks/telemetry/" rel="noopener ugc nofollow" target="_blank">可观察性</a>相关的特性，但我们在这里将重点关注与<a class="ae kl" href="https://istio.io/docs/tasks/security/" rel="noopener ugc nofollow" target="_blank">安全性</a>相关的特性。</p><p id="b6e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里特别关注启用<a class="ae kl" href="https://istio.io/docs/concepts/security/#mutual-tls-authentication" rel="noopener ugc nofollow" target="_blank"> Mutual TLS </a>功能，以便在我们的pod之间进行通信。通过使用此功能，我们将实现两个要点:</p><ul class=""><li id="c4cc" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated"><strong class="jp ir">服务到服务认证</strong> : Istio为每个服务提供一个强身份，代表其角色，以实现跨集群和云的互操作性。因此，服务到服务的通信经受服务命名验证，防止恶意程序冒充目标服务(例如用于检查或窃取发送到数据库的数据)，</li><li id="fcf8" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><strong class="jp ir">服务到服务加密</strong>:Istio基础设施提供了一个PKI，以及密钥和证书的自动生成、分发和在不同单元之间的轮换。如果通过身份验证，则使用分发到通信端的密钥对服务到服务的通信进行加密。</li></ul><p id="7aae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Istio使用<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#understanding-pods" rel="noopener ugc nofollow" target="_blank">边车容器</a>模式在我们的pod上操作，这个模式我们已经在本系列的第3部分和第4部分中遇到过。<code class="fe km kn ko kp b">istio-proxy</code>容器可以被注入到每个pod中，并充当TCP代理，拦截pod中的所有入站和出站流量。它将处理自定义证书，并负责应用我们为pod配置的不同策略。这就是下图所示的内容:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi my"><img src="../Images/a8d1cd380ab13904abc493d9f8985423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeCGeuwV6YmPmyGH06ad0w.png"/></div></div></figure><p id="d74a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了应用策略，我们将不得不切换到Istio带来的新概念，并用Istio中所谓的<code class="fe km kn ko kp b">VirtualService</code>取代之前的<code class="fe km kn ko kp b">mongodb</code> Kubernetes服务。这样，在不对代码做任何修改的情况下，我们将把Mutual TLS引入我们的应用程序。</p><p id="480f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何轻松地应用这一点；-)</p><h1 id="13b5" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">如何应用？</h1><p id="3550" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">如果您已经阅读了本系列的第一部分，那么您可能已经克隆了包含所有资源和资产的<a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s" rel="noopener ugc nofollow" target="_blank"> my GitHub repository </a>。如果没有，我敦促你这样做；-)从笔记本电脑上的克隆中，切换到<code class="fe km kn ko kp b">master</code>分支。</p><p id="60df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要在OpenShift集群上安装并激活Istio。当使用OpenShift容器平台时，Istio被称为OpenShift服务网格，关于如何部署它的说明可以在这里找到<a class="ae kl" href="https://docs.openshift.com/container-platform/3.11/servicemesh-install/servicemesh-install.html" rel="noopener ugc nofollow" target="_blank">。安装非常简单，因为它使用了一个</a><a class="ae kl" href="https://blog.openshift.com/introducing-the-operator-framework/" rel="noopener ugc nofollow" target="_blank">操作器</a>，但是请注意<a class="ae kl" href="https://docs.openshift.com/container-platform/3.11/servicemesh-install/servicemesh-install.html#updating-master-configuration" rel="noopener ugc nofollow" target="_blank">更新您的主配置，以允许我们正在使用的自动边车注射</a>。</p><p id="b6dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当将应用程序部署到在OpenShift环境中运行的Istio中时，当前有必要放松其服务帐户对应用程序的安全约束，以确保应用程序能够正确运行。让我们开始授予<code class="fe km kn ko kp b">anyuid</code>和<code class="fe km kn ko kp b">privileged</code>安全上下文约束，以使边车能够正确运行:</p><pre class="lf lg lh li gt mz kp na nb aw nc bi"><span id="9b11" class="nd lw iq kp b gy ne nf l ng nh">$ oc adm policy add-scc-to-user anyuid -z fruits-catalog-vault -n fruits-catalog<br/>$ oc adm policy add-scc-to-user privileged -z fruits-catalog-vault -n fruits-catalog</span></pre><p id="82dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将简单地向现有部署添加注释<code class="fe km kn ko kp b">sidecar.istio.io/inject</code>。这是我们在OpenShift中添加的细粒度选择加入机制:Istio在默认情况下不启用，也不针对特定项目，我们必须为每个部署启用它。以下是命令:</p><pre class="lf lg lh li gt mz kp na nb aw nc bi"><span id="ba01" class="nd lw iq kp b gy ne nf l ng nh">$ oc patch dc/mongodb --type=json -p '[{"op":"add", "path":"/spec/template/metadata/annotations/sidecar.istio.io~1inject ", "value":"true"}]' -n fruits-catalog</span><span id="84ec" class="nd lw iq kp b gy ni nf l ng nh">$ oc patch dc/fruits-catalog --type=json -p '[{"op":"add", "path":"/spec/template/metadata/annotations/sidecar.istio.io~1inject", "value":"true"}]' -n fruits-catalog</span></pre><p id="10f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修补这两个部署会触发新的部署部署，因为它被视为配置更改。一旦准备好，新的豆荚现在应该嵌入<code class="fe km kn ko kp b">istio-proxy</code>容器。我们还必须向<code class="fe km kn ko kp b">mongodb</code>部署添加一个新的<code class="fe km kn ko kp b">version</code>标签，以便稍后定义一些策略:</p><pre class="lf lg lh li gt mz kp na nb aw nc bi"><span id="a28b" class="nd lw iq kp b gy ne nf l ng nh">$ oc patch dc/mongodb --type=json -p '[{"op":"add", "path":"/spec/template/metadata/labels/version", "value":"v1"}]' -n fruits-catalog</span></pre><p id="99f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们只需创建两个新的Istio定制资源(或<a class="ae kl" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank"> CRD </a>),名为<code class="fe km kn ko kp b">DestinationRule</code>和<code class="fe km kn ko kp b">VirtualService</code>。简而言之:一个虚拟服务允许定义一个抽象，其他多个工作负载托管在豆荚上，一个目的地规则允许定义流量或访问虚拟服务的策略。我们必须为<code class="fe km kn ko kp b">mongodb</code>应用服务创建两者:</p><pre class="lf lg lh li gt mz kp na nb aw nc bi"><span id="c9c9" class="nd lw iq kp b gy ne nf l ng nh">$ oc apply -f k8s/mongodb-istio-destinationrule.yml -n fruits-catalog</span><span id="1001" class="nd lw iq kp b gy ni nf l ng nh">$ oc apply -f k8s/mongodb-istio-virtualservice.yml -n fruits-catalog</span></pre><p id="cff1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！我们刚刚启用了Mutual TLS来保护我们的应用程序的两个pod之间的通信；只需注释/标记我们的部署并创建Istio配置。不错！</p><h1 id="f395" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">检查它是否按预期工作</h1><p id="fc86" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">像所有以前的帖子一样，首先要做的显然是使用<code class="fe km kn ko kp b">fruits-catalog</code>路线的URL打开浏览器，并检查应用程序是否仍在工作。但是如果你想/需要深潜，这里有一些其他的检查。</p><p id="3cdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务网格通常由两部分组成:数据流动的数据平面(它由我们应用程序中的<code class="fe km kn ko kp b">istio-proxy</code>集合组成)和我们定义/应用/监控策略的控制平面。Istio控制平面带有<a class="ae kl" href="https://www.kiali.io/" rel="noopener ugc nofollow" target="_blank"> Kiali </a>，这是一个控制台，用于观察、测量和控制Istio服务网格中发生的事情。这样我们就能检索出Kiali进入控制台的路线:</p><pre class="lf lg lh li gt mz kp na nb aw nc bi"><span id="39ae" class="nd lw iq kp b gy ne nf l ng nh">$ oc get route/kiali -n istio-system                                                                     NAME      HOST/PORT                                     PATH      SERVICES   PORT      TERMINATION   WILDCARD<br/>kiali     kiali-istio-system.apps.144.76.24.92.nip.io             kiali      20001     reencrypt     None</span></pre><p id="e429" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从之前的命令结果中获取URL并打开浏览器选项卡。您应该在访问控制台之前验证自己的身份。凭证依赖于你的安装，但是默认的只是<code class="fe km kn ko kp b">admin</code>/<code class="fe km kn ko kp b">admin</code>——我们也应该加强这个凭证的秘密管理；-)</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nj"><img src="../Images/177fb58b90d6ad2fb60b92d186e246f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdTon3GXE-_xzjalKBFi9Q.png"/></div></div></figure><p id="56dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kiali的控制台允许我们通过只选择来自<code class="fe km kn ko kp b">fruits-catalog</code>名称空间的元素来发现我们的应用程序。调整图形选项可以让我们看到通过服务网格的实时网络流量。您可以访问大量信息，如响应时间、吞吐量、错误率、分布式跟踪和Istio定制资源配置(稍后将详细介绍)。</p><p id="e981" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以看看<code class="fe km kn ko kp b">fruits-catalog</code>吊舱部署，并检查我们是否一切就绪。以下是OpenShift web控制台的屏幕截图，显示了:</p><ul class=""><li id="3fac" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated">我们已经成功完成了一个初始化容器。我们还可以访问这个<code class="fe km kn ko kp b">vault-init</code>容器发出的命令，</li><li id="728a" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">我们有了名为<code class="fe km kn ko kp b">vault-lease-refresher</code>的第一个容器，并且仍然可以访问后一个容器发出的命令，</li><li id="d422" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">我们有第二个也是主要的容器，它是我们的应用程序，使用由Init容器编写的<code class="fe km kn ko kp b">application.properties</code>配置，</li><li id="1de3" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">我们最终得到了第三个容器，即应用流量路由和安全策略的<code class="fe km kn ko kp b">istio-proxy</code>。</li><li id="b37c" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">我们实际上还得到了一个<code class="fe km kn ko kp b">istio-init</code> Init容器，它在启动时获取代理配置，并确保一切就绪，可以运行代理。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nk"><img src="../Images/7b10f588da8e4e6577327969760a1322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgzGKC6H9ouuHz62PPuxxA.png"/></div></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nl"><img src="../Images/7eafa877410294393b618863e9d701ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-X3FKACmw5QLWtC0vlC5g.png"/></div></div></figure><p id="ac8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得我们最近谈到的<code class="fe km kn ko kp b">DestinationRule</code>吗？您可以使用CLI或通过Kiali控制台来访问<code class="fe km kn ko kp b">mongodb</code>服务的规则定义。您可以在这里简单地检查在到达mongodb / v1目的地时是否启用了<code class="fe km kn ko kp b">ISTIO_MUTUAL</code> TLS策略:</p><pre class="lf lg lh li gt mz kp na nb aw nc bi"><span id="0be5" class="nd lw iq kp b gy ne nf l ng nh">apiVersion: networking.istio.io/v1alpha3<br/>kind: DestinationRule<br/>metadata:<br/>  name: mongodb<br/>spec:<br/>  host: mongodb<br/>  trafficPolicy:<br/>    tls:<br/>      mode: ISTIO_MUTUAL<br/>  subsets:<br/>  - name: v1<br/>    labels:<br/>      version: v1</span></pre><p id="2503" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，您还可以使用<code class="fe km kn ko kp b">istioctl</code> CLI工具检查配置。通过执行以下命令，当数据从连接到<code class="fe km kn ko kp b">fruits-catalog</code>部署配置的pod流出时，我们将获得与<code class="fe km kn ko kp b">mongod.fruits-catalog.svc.cluster.local</code>通信的真实状态:</p><pre class="lf lg lh li gt mz kp na nb aw nc bi"><span id="ef4d" class="nd lw iq kp b gy ne nf l ng nh">$ istioctl authn tls-check $(oc get pod -l deploymentconfig=fruits-catalog -o jsonpath={.items..metadata.name}) mongodb.fruits-catalog.svc.cluster.local</span><span id="e172" class="nd lw iq kp b gy ni nf l ng nh">HOST:PORT                                          STATUS     SERVER        CLIENT     AUTHN POLICY     DESTINATION RULE<br/>mongodb.fruits-catalog.svc.cluster.local:27017     OK         HTTP/mTLS     mTLS       default/         mongodb/fruits-catalog</span></pre><h1 id="d400" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论</h1><p id="8b1f" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">在这第五部分中，我们已经看到了服务网格对于将安全特性引入其他现有应用程序是多么的强大。<a class="ae kl" href="http://www.istio.io" rel="noopener ugc nofollow" target="_blank"> Istio </a>提供了一个服务网格实现，该实现现已嵌入并完全支持<a class="ae kl" href="https://access.redhat.com/announcements/4180011" rel="noopener ugc nofollow" target="_blank"> OpenShift容器平台版本4.1 </a>。我们已经看到，使用它的Mutual TLS特性只需要向我们的部署添加一个注释，就可以选择进入网格并声明一个目的地规则！</p><p id="a179" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这个系列，我们已经在现有的<code class="fe km kn ko kp b">fruits-catalog</code>应用程序中增加了许多安全层，这些应用程序在开发时没有考虑到安全问题。现在，让我总结一下:</p><ul class=""><li id="363c" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated">首先，我们通过将组件打包并部署在<a class="ae kl" href="http://www.openshift.com" rel="noopener ugc nofollow" target="_blank"> OpenShift </a>上，将组件与外界隔离开来。我们还使用TLS路由来保护他们的暴露，</li><li id="ef9d" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">然后，在第二部分中，我们添加了IAM层，在UI和API端点上添加了身份验证和授权，在OpenShift上部署和配置了<a class="ae kl" href="http://www.keycloak.org" rel="noopener ugc nofollow" target="_blank"> Keycloak </a>，</li><li id="fde6" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">在第三和第四部分中，我们解决了秘密管理的问题，使用<a class="ae kl" href="http://www.vaultproject.io" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>实现了一个健壮的、动态的和短暂的凭证生成过程。该过程防止了凭证泄露，</li><li id="f00d" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">最后，我们展示了如何使用服务网格的概念来实现安全问题，如服务之间的认证和加密通信，从而实现真正的零信任网络，能够跨越其他混合基础架构。</li></ul><p id="09e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为一个小图片比一个长的演讲更有意义，下面的图表代表了我们实现的所有架构，在不接触代码库的情况下完成了我们的应用程序的新部署！</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nm"><img src="../Images/440bcc69dda4acf6ae44c17526c4fe2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mYw2d2G3N7pWo4FJL7pAg.png"/></div></div></figure><p id="d553" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望您喜欢和我一起阅读这个系列，并学习或发现一些增强应用程序安全性的技术。通过评论或鼓掌反馈是非常受欢迎的！</p></div></div>    
</body>
</html>