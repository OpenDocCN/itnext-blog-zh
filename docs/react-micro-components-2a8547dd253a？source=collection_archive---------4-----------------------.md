# React —微型组件

> 原文：<https://itnext.io/react-micro-components-2a8547dd253a?source=collection_archive---------4----------------------->

## 重新考虑你的 JSX——停止使用 div 和类名

![](img/6b03c805fd01a58d65919daf7ac5b8c7.png)

在这篇文章中，我将提出一种用 React 创建 UI 组件的思路，包括删除 div 和类名。这种思维方式的目标是简化创建 UI 组件的生产线(特别是使 CSS-in-JS 之类的事情变得更容易)。简而言之，这种思维方式包括将 UI 组件看作是具有 name 属性的微组件的集合，而不是具有 classname 属性的 div 的集合。

这个概念并不是全新的；BEM CSS 命名惯例还包括将 UI 组件(*块*)视为*元素*的集合。事实上，我将采用 BEM 提供的许多理念，并将它们应用到 React 工作流中。

在我继续之前，我想解决我认为创建 UI 模块时最重要的问题:

*   相互作用
*   式样
*   配置
*   主题

React 并没有提供任何现成的解决方案来处理最后三个问题，但是使用[状态和钩子](https://reactjs.org/docs/hooks-state.html)可以很容易地处理*交互*。尽管如此，在创建 UI 组件时，我只剩下我认为的三个最高级别的关注点(如果不是*三个最高关注点的话)，没有标准的方法来大规模处理它们。如果你对什么是最重要的关注点有不同的看法，那么不管怎样，继续读下去，在很大程度上你可以把这些关注点去掉，这篇文章的前提仍然适用。但是对于这篇文章来说，在讨论样式时，我们将使用反应 JSS。*

让我们考虑一个基本的功能组件示例，然后考虑我们可能希望如何向它公开样式、配置和我们项目的主题。

BEM 告诉我们，每个 UI 组件都是作为一个抽象的*块*存在的，然后它可以有一些可选的子*元素*。通过以类似的方式观察我们的 React 组件，我们可以重新塑造我们的 JSX，将常见的重复行为转移到引擎盖下。在探索*微型元件*的概念之前，让我们先来看看为什么我们可能需要它们。将我们的主题、风格和配置与上面的`MyComponent`例子挂钩，可能会给我们留下类似下面的代码:

你可以在 CodeSandbox 上查看上述代码[的工作演示。让我们看看发生了什么…](https://codesandbox.io/s/rough-feather-fb8z1)

*   该组件有一个元配置对象，作为一个需要评估的功能存在(并且需要项目的主题)
*   该项目的主题来自 React-JSS 的`useTheme`钩子(我们必须导入)
*   我们的 styles 对象作为一个需要被传递以作出反应的函数存在——JSS 的`createUseStyles`实用程序(我们必须导入)——我们将其分配给一个`useStyles`引用
*   除了组件的道具之外，我们还想将组件的配置暴露给样式，所以我们将它们都传递给了`useStyles`实例

这就是我可能期望看到的没有*微组件*或某种*包装组件*或第三方库的 React UI 组件的存在方式。虽然我们目前所拥有的并没有什么本质上的错误，但我认为这涉及到了相当多的设置(考虑对你所有的 UI 组件重复这个设置)。我想提出以下建议更好，我会解释为什么:

当我们限制自己将 UI 组件的 JSX 编写为最终要呈现的原始 HTML 标签(例如`div`)时，我们每次都必须处理任何设置来预先获得它们相应的道具/参数(我们通常谈论的是`className`或`style`)。事实证明，对于您创建的每个 UI 组件来说，很多这样的设置通常是相同的，会产生重复，从而导致臃肿的 JSX。

在 React 思维中，您经常会遇到利用`<Provider>`组件将数据传递给孩子的概念，通常是以 [*上下文*](https://reactjs.org/docs/context.html) 的形式(例如当使用主题或某些 CSS-in-JS 解决方案时)。我们可以同时使用类似于`<Block>`组件的东西来*为后代组件提供*样式和配置之类的东西，同时还可以从同一个组件呈现一个 DOM 元素(这样就不需要每个 UI 组件都有一个单独的、专用的 *Provider* 元素来提供样式之类的东西)。我们提供给`<Block>`的值也可以在呈现父 DOM 元素时使用(*块*)。在引擎盖下，`<Block>`和`<Component>`组件自动执行我们之前手动执行的操作。如果我们使用一个原始的`div`(或者一些其他的 HTML 元素)，我们将没有办法利用它的幕后道具。

不管你如何区分 UI 组件的优先级，样式毫无疑问是最重要的。因此，当我们考虑 React 中样式化`div`的实际需要时，当我们将主题化和配置之类的东西混合在一起，没有任何构造它们的约定，你最终会在你的 UI 组件中重复许多平凡的设置。通过将 UI 组件中的元素视为微组件(或任何您喜欢的词)而不是 divs/HTML 标签，我们可以将许多这种平凡的重复移到幕后，留下我们的源代码清洁器和 JSX 干燥器。我们所需要的就是创建我们的`Block` / `Component`组件来处理行为。

## `<Block>` & `<Component>`

我试图传达这些包装组件的具体性质是不相关的；重点是，通过以这种方式查看您的 UI 组件，您可以将您最终为每个 UI 组件及其子元素重复的任何工作/设置抽象到这些包装器中(每个包装器对应于一个呈现的 DOM 节点)。我提出样式、主题和配置是重要的关注点，并展示了在没有包装器的情况下，与它们相关的某些东西在多大程度上是容易重复的。以我们之前的例子为例，我将向您展示在这种情况下包装`Block` / `Component`组件可能是什么样子(尽管取决于您自己的关注点，可能会有所不同):

…以及:

您可以在 [CodeSandbox](https://codesandbox.io/s/btm1l) 上观看现场演示:

## 结论

通过将 UI 组件视为带有子*组件*的*块*，而不是 HTML 元素的集合，并为它们创建适当的包装器，您可以通过抽象与高度关注的事情相关的设置代码来简化创建 UI 组件的过程，例如主题化、样式化、上下文和配置，否则这些会在 UI 组件之间重复。

## 进一步的想法

查看我就类似主题撰写的其他文章:

*   [道具，状态，配置&基于主题的造型，带反应 JSS](https://medium.com/@ESR360/props-state-config-theming-based-styling-with-react-jss-ce06f70985de)
*   [提升道具—使用 React 的上下文 API 访问父道具](https://levelup.gitconnected.com/lifting-props-up-f1be43a1d7a4)
*   [创建可伸缩的 ui:主题化&配置](https://medium.com/valtech-design/creating-scalable-uis-theming-configuration-d49d6c22654c)

![](img/0f4eaa82f76695a20f09ba4fa9fd37ba.png)

[推特](https://twitter.com/esr360) | [Github](https://github.com/esr360)