<html>
<head>
<title>Next step to avoid backing properties for StateFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免支持StateFlow属性的下一步</h1>
<blockquote>原文：<a href="https://itnext.io/next-step-to-avoid-backing-properties-for-stateflow-5107f7fd3dc4?source=collection_archive---------2-----------------------#2021-01-21">https://itnext.io/next-step-to-avoid-backing-properties-for-stateflow-5107f7fd3dc4?source=collection_archive---------2-----------------------#2021-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c524a9e0fd6d3b6128e17d81e6cbeb2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRLXfWbNwlUq8FX0i-bmdw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/photos/Zj8JwP3M3Do" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/Zj8JwP3M3Do</a></figcaption></figure><p id="7dee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文灵感来源于<a class="ae kc" href="https://medium.com/google-developer-experts/avoid-backing-properties-for-livedata-and-stateflow-706006c9867e" rel="noopener">这篇原帖</a>和<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/re-avoid-backing-properties-for-livedata-and-stateflow-2160cab96b56">这篇回复</a>。这里我要讲一下我对提到的问题的观察。</p><p id="919f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把问题重新表述为“<em class="lb">让值getter在所有地方可见，而值setter只在</em> <code class="fe lc ld le lf b"><em class="lb">ViewModel</em></code>内部可见”。让我们从这句话开始，尝试使用Kotlin的可见性结构来解决它。</p><h1 id="84dc" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">保护</strong>流的可变性</h1><p id="09e3" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">让<em class="lb"> value getter在所有地方</em>可见很容易——它只是<code class="fe lc ld le lf b">public</code>(在Kotlin中默认)。为了让<em class="lb">让值设置器只在</em> <code class="fe lc ld le lf b"><em class="lb">ViewModel</em></code>内部可见，我们需要让它<code class="fe lc ld le lf b">private</code>并放在<code class="fe lc ld le lf b">ViewModel</code>内部。但是<code class="fe lc ld le lf b">ViewModel</code>很多。因此，我们可以创建<code class="fe lc ld le lf b">class BaseViewModel</code>，将值setter放入该类，并使其成为<code class="fe lc ld le lf b">protected</code>。有趣的事情从这里开始。</p><p id="fda9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">MutableStateFlow</code>中的值设置者是<code class="fe lc ld le lf b">public</code>，我们对此无能为力。这就是为什么我们定义<code class="fe lc ld le lf b">ViewModelStateFlow</code>来包装“真实的”<code class="fe lc ld le lf b">StateFlow&lt;T&gt;</code>:</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="bc56" class="mr lh iq lf b gy ms mt l mu mv">sealed class ViewModelStateFlow&lt;T&gt;(stateFlow: StateFlow&lt;T&gt;) : StateFlow&lt;T&gt; by stateFlow</span></pre><p id="cebf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个类是<code class="fe lc ld le lf b">public</code>并且打算在所有地方使用。但是<code class="fe lc ld le lf b">ViewModelStateFlow</code>的值设置器将是<code class="fe lc ld le lf b">class BaseViewModel</code>中的<code class="fe lc ld le lf b">protected</code>，所以它只能在<code class="fe lc ld le lf b">BaseViewModel</code>的子类中使用。</p><p id="afb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在只剩下为<code class="fe lc ld le lf b">ViewModelStateFlow</code>提供子类了。这个实现将在<code class="fe lc ld le lf b">BaseViewModel.kt</code>内部<code class="fe lc ld le lf b">private</code>以避免其泄露。</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="7e8f" class="mr lh iq lf b gy ms mt l mu mv">private class ViewModelStateFlowImpl&lt;T&gt;(<br/>        initial: T,<br/>        val wrapped: MutableStateFlow&lt;T&gt; = <em class="lb">MutableStateFlow</em>(initial)<br/>) : ViewModelStateFlow&lt;T&gt;(wrapped)</span></pre><p id="240f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lc ld le lf b">ViewModelStateFlowImpl</code>中，我们创建了用于<code class="fe lc ld le lf b">ViewModelStateFlow</code>中委托的<code class="fe lc ld le lf b">MutableStateFlow</code>。</p><p id="f52d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们需要在<code class="fe lc ld le lf b">class BaseViewModel</code>中提供一个工厂方法来创建<code class="fe lc ld le lf b">ViewModelStateFlow</code>。我们不能只使用<code class="fe lc ld le lf b">ViewModelStateFlowImpl</code>的构造函数，否则<code class="fe lc ld le lf b">private</code>类型的<code class="fe lc ld le lf b">ViewModelStateFlowImpl</code>会在<code class="fe lc ld le lf b">ViewModel</code>中通过<code class="fe lc ld le lf b">public val someFlow</code>暴露出来。</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="d6b9" class="mr lh iq lf b gy ms mt l mu mv">protected fun &lt;T&gt; createViewModelStateFlow(initial: T): ViewModelStateFlow&lt;T&gt; = ViewModelStateFlowImpl(initial)</span></pre><p id="13e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是<code class="fe lc ld le lf b">ViewModelStateFlow</code>的值设置器。是<code class="fe lc ld le lf b">class BaseViewModel</code>内部的<code class="fe lc ld le lf b">protected</code>函数知道<code class="fe lc ld le lf b">ViewModelStateFlowImpl</code>的实现细节。</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="de66" class="mr lh iq lf b gy ms mt l mu mv">protected fun &lt;T&gt; ViewModelStateFlow&lt;T&gt;.setValue(value: T): Unit = when (this) {<br/>    is ViewModelStateFlowImpl -&gt; wrapped.value = value<br/>}</span></pre><h1 id="a9e9" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">使用视图模型状态流</h1><p id="1db6" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">有了这些定义，我们可以轻松地在任何视图模型中创建状态流，并在那里访问它的值getter和setter:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f05c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在“视图”类(<code class="fe lc ld le lf b">SomeActivity</code>、<code class="fe lc ld le lf b">SomeFragment</code>等)中，我们只能访问值getter:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b6eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们实现了我们想要的。但是总有改进的空间。例如，我们需要使用<code class="fe lc ld le lf b">setValue</code>方法，而不是仅仅给flow分配一个新值(正如在<code class="fe lc ld le lf b">MutableStateFlow</code>中所做的)。到目前为止，我还没有找到为<code class="fe lc ld le lf b">ViewModelStateFlow</code>定义属性setter的方法。</p><p id="8d07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Btw，C++里有<code class="fe lc ld le lf b">friend</code>关键字，在这里会很有帮助。但是，Kotlin中的这个关键字可能不合适，并会给Kotlin的可见性结构带来更多的复杂性。</p><p id="25be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整代码概括如下:</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>