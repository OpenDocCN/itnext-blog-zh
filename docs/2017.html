<html>
<head>
<title>Generators and Iterators in Julia and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia和Python中的生成器和迭代器</h1>
<blockquote>原文：<a href="https://itnext.io/generators-and-iterators-in-julia-and-python-6c9ace18fa93?source=collection_archive---------3-----------------------#2019-03-17">https://itnext.io/generators-and-iterators-in-julia-and-python-6c9ace18fa93?source=collection_archive---------3-----------------------#2019-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8da8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">比较了迭代器在Julia和Python中是如何实现的，以及生成器在迭代器中扮演的不同角色</h2></div><p id="22b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python中经常使用生成器来实现迭代器。Julia和Python都使用生成器实现列表理解。与其写say <code class="fe lb lc ld le b">[x*x for x in 1:4]</code>，我们可以把表达式列表里面的理解力放在一个单独的对象里面:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="00bd" class="ln lo iq le b gy lp lq l lr ls">julia&gt; g = (x*x for x in 1:4)<br/>Base.Generator{UnitRange{Int64},getfield(Main, Symbol("##27#28"))}(getfield(Main, Symbol("##27#28"))(), 1:4)</span></pre><p id="0fdb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在Julia中看到一个<code class="fe lb lc ld le b">Generator</code>对象，在python中看到一个<code class="fe lb lc ld le b">generator</code>对象:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9645" class="ln lo iq le b gy lp lq l lr ls">python&gt; g = (x*x for x in range(1,5))<br/>python&gt; g<br/>&lt;generator object &lt;genexpr&gt; at 0x10bdeef48&gt;</span></pre><p id="b0c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然看起来很相似，但它们有很大的不同。Python生成器是基于协程的，而Julia生成器是建立在迭代器之上的。</p><p id="5131" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就把我们带到了迭代器。我们需要理解它们在两种语言中的作用和实现。</p><h2 id="752e" class="ln lo iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">Python迭代器</h2><p id="0536" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我将做一个有点傻的例子，向你展示如何迭代一个点类的坐标。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="33af" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">class</strong> Point:<br/>    <strong class="le ir">def</strong> __init__(self, x, y, z):<br/>        self.x = x<br/>        self.y = y<br/>        self.z = z</span></pre><p id="cac4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码将允许我们编写:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c3d4" class="ln lo iq le b gy lp lq l lr ls">python&gt; p = Point(3, 8, 2)</span></pre><p id="3f0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果我们想为它创建一个迭代器，我们也需要添加这个方法:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="fada" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">def</strong> __iter__(self):<br/>        return PointIterator(self)</span></pre><p id="882c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">允许我们在for循环中迭代我们的点。为了方便起见，我们也将添加这个方法。它给出了REPL中点的字符串表示。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="7a7f" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">def</strong> __repr__(self):<br/>        return f"Point({self.x}, {self.y}, {self.z})"</span></pre><p id="345c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在构建的功能的实质是在我们返回的迭代器类中。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="bab5" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">class</strong> PointIterator:<br/>    <strong class="le ir">def</strong> __init__(self, point):<br/>        self.point = point<br/>        self.coords = ['z', 'y', 'x']<br/><br/>    <strong class="le ir">def</strong> __next__(self):<br/>        <strong class="le ir">if</strong> self.coords:<br/>            return getattr(self.point, self.coords.pop())<br/>        <strong class="le ir">else</strong>:<br/>            <strong class="le ir">raise</strong> StopIteration</span></pre><p id="3e96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其工作方式是，我们保存一个坐标x，y和z的列表，当我们迭代该点时，我们要依次访问这些坐标。</p><p id="a21a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">__next__</code>在每次迭代时被调用，我们从坐标列表中弹出一个坐标来获取。使用<code class="fe lb lc ld le b">getattr</code>,我们可以通过名字获得Python对象的属性。</p><p id="e19a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这个实现，我们可以使用迭代器:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0a9e" class="ln lo iq le b gy lp lq l lr ls">python&gt; p = Point(2, 3, 8)<br/>python&gt; for a in p: <br/>   print(a)<br/><br/>2<br/>3<br/>8<br/><br/>python&gt; it = iter(p)<br/>python&gt; next(it)<br/>2<br/>python&gt; next(it)<br/>3<br/>python&gt; next(it)<br/>8</span></pre><p id="d438" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们比较一下在进入生成器之前，迭代器是如何在Julia中产生的。</p><h2 id="4798" class="ln lo iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">朱莉娅迭代器</h2><p id="e775" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">Julia有一种完全不同的方法来实现迭代器。抽象地说，人们可以说，两种语言都需要实现某种协议来使某些东西可迭代。然而，Julia并不是以面向对象的方式来做的。没有可以子类化的类，取而代之的是必须实现新版本的<code class="fe lb lc ld le b">iterate</code>函数。</p><p id="a44d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先让我们制作<code class="fe lb lc ld le b">Point</code>型。不需要实现<code class="fe lb lc ld le b">repr</code>函数来显示类型。它有一个自动表示。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6e51" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">struct</strong> Point<br/>    x::Int<br/>    y::Int<br/>    z::Int<br/><strong class="le ir">end</strong></span></pre><p id="527e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还有一个默认的构造函数，所以我们也不需要实现它。Julia中的for循环如下所示:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a563" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">for</strong> i <strong class="le ir">in</strong> iter   # or  "for i = iter"<br/>    # body<br/><strong class="le ir">end</strong></span></pre><p id="5dbb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Julia将其翻译成以下代码:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0dc9" class="ln lo iq le b gy lp lq l lr ls">next = iterate(iter)<br/><strong class="le ir">while</strong> next !== <strong class="le ir">nothing</strong><br/>    (i, state) = next<br/>    # body<br/>    next = iterate(iter, state)<br/><strong class="le ir">end</strong></span></pre><p id="7ae7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以要迭代一个点的坐标，我们需要实现两个版本的<code class="fe lb lc ld le b">iterate</code>。在Julia的术语中，这些是方法，但是对于具有面向对象背景的人来说，这可能会令人困惑。方法是函数在Julia中的所有具体实现。所以在Julia术语中，我们实现了<code class="fe lb lc ld le b">iterate</code>函数的两个方法。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="07dc" class="ln lo iq le b gy lp lq l lr ls">iterate(p::Point) = p.x, [:y, :z]<br/><br/><strong class="le ir">function</strong> iterate(p::Point, coords)<br/>   <strong class="le ir">if</strong> isempty(coords)<br/>       nothing<br/>   <strong class="le ir">else</strong><br/>       getfield(p, coords[1]), coords[2:end]<br/>   <strong class="le ir">end</strong><br/><strong class="le ir">end</strong></span></pre><p id="75b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以和Python中的<code class="fe lb lc ld le b">__next__</code>有一些相似之处。Python谈论对象的属性，而Julia谈论对象的字段。因此<code class="fe lb lc ld le b">getattr</code>和<code class="fe lb lc ld le b">getfield</code>基本上做同样的事情。<code class="fe lb lc ld le b">getattr</code>用字符串名指代属性，Julia用符号。符号与字符串非常相似。如果你想更好地理解为什么Julia经常使用符号而不是字符串，这里有一个很好的答案<a class="ae mp" href="https://stackoverflow.com/questions/23480722/what-is-a-symbol-in-julia" rel="noopener ugc nofollow" target="_blank"/>。<code class="fe lb lc ld le b">"foobar"</code>是字符串，而<code class="fe lb lc ld le b">:foobar</code>是符号。</p><p id="b968" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个重要的区别是，Julia在迭代时不会对任何数据进行突变。看看这个在Python中使用<code class="fe lb lc ld le b">enumerate</code>的例子:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6242" class="ln lo iq le b gy lp lq l lr ls">python&gt; it = enumerate(["one", "two"])<br/>python&gt; list(it)<br/>[(0, 'one'), (1, 'two')]<br/>python&gt; list(it)<br/>[]</span></pre><p id="3d30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以看到迭代器被耗尽了。你不能一直从迭代器中创建列表。但是在Julia中可以，因为迭代的状态与迭代器本身是分开的:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="43ee" class="ln lo iq le b gy lp lq l lr ls">julia&gt; it = enumerate(["one", "two"])<br/>Base.Iterators.Enumerate{Array{String,1}}(["one", "two"])<br/><br/>julia&gt; collect(it)<br/>2-element Array{Tuple{Int64,String},1}:<br/> (1, "one")<br/> (2, "two")<br/><br/>julia&gt; collect(it)<br/>2-element Array{Tuple{Int64,String},1}:<br/> (1, "one")<br/> (2, "two")</span></pre><h2 id="bba1" class="ln lo iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">使用Python生成器实现迭代器</h2><p id="6fbb" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如你所见，在Python中实现迭代器相当冗长，这就是为什么在Python中实现迭代器的首选方法是使用生成器。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="18f6" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">class</strong> Point:<br/>    <strong class="le ir">def</strong> __init__(self, x, y, z):<br/>        self.x = x<br/>        self.y = y<br/>        self.z = z<br/>    <br/>    <strong class="le ir">def</strong> __repr__(self):<br/>        <strong class="le ir">return</strong> f"({self.x}, {self.y}, {self.z})"<br/>        <br/>    <strong class="le ir">def</strong> __iter__(self):<br/>        <strong class="le ir">def</strong> gen():<br/>            <strong class="le ir">yield</strong> self.x<br/>            <strong class="le ir">yield</strong> self.y<br/>            <strong class="le ir">yield</strong> self.z<br/>        <strong class="le ir">return</strong> gen()</span></pre><p id="2111" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你看，使用这种方法，我们根本不需要实现一个<code class="fe lb lc ld le b">PointIterator</code>类。<code class="fe lb lc ld le b">yield</code>与return的不同之处在于，当在协程的上下文中运行时，它会“记住”退出时它在函数中的位置。协程将从它停止的地方重新进入该函数。这在处理迭代时非常实用。让我再举一个例子来说明这一点。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="fad3" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">def</strong> generator():<br/>    <strong class="le ir">for</strong> i <strong class="le ir">in</strong> range(0, 6):<br/>        <strong class="le ir">yield</strong> chr(ord('A') + i)</span></pre><p id="b858" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我告诉你如何在REPL中使用它来产生从A到f的字母</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0b57" class="ln lo iq le b gy lp lq l lr ls">python&gt; g = generator()<br/>python&gt; list(g)<br/>['A', 'B', 'C', 'D', 'E', 'F']<br/>python&gt; g = generator()<br/>python&gt; next(g)<br/>'A'<br/>python&gt; next(g)<br/>'B'<br/>python&gt; next(g)<br/>'C'</span></pre><p id="34f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的巧妙之处在于，你不需要编写代码来维护关于<em class="mq">在for循环中的位置的信息。生成器会帮你记录下来。</em></p><h2 id="f8dd" class="ln lo iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">Julia中的Python风格生成器</h2><p id="b49f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如果您想创建一个功能类似Python生成器的生成器，您必须利用Julia中的通道。这可能看起来有点神秘，但是不要担心，我会在最后详细说明这是如何工作的。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="bb6f" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">function</strong> generator()<br/>    Channel() <strong class="le ir">do</strong> channel<br/>        <strong class="le ir">for</strong> i in 0:5<br/>            put!(channel, Char('A' + i))<br/>        <strong class="le ir">end</strong><br/>    <strong class="le ir">end</strong><br/><strong class="le ir">end</strong></span></pre><p id="ebee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不会像理解一样返回一个<code class="fe lb lc ld le b">Generator</code>对象，而是一个<code class="fe lb lc ld le b">Channel</code>对象:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e2fc" class="ln lo iq le b gy lp lq l lr ls">julia&gt; g = generator()<br/>Channel{Any}(sz_max:0,sz_curr:1)</span></pre><p id="16b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以像使用常规迭代器一样使用这个通道。例如，我们可以收集值并组成一个数组，就像迭代器一样。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="edbf" class="ln lo iq le b gy lp lq l lr ls">julia&gt; collect(g)<br/>6-element Array{Any,1}:<br/> 'A'<br/> 'B'<br/> 'C'<br/> 'D'<br/> 'E'<br/> 'F'</span></pre><p id="c014" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以使用unpack语法来创建一个数组。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="8a69" class="ln lo iq le b gy lp lq l lr ls">julia&gt; g = generator()<br/>julia&gt; [g...]<br/>6-element Array{Char,1}:<br/> 'A'<br/> 'B'<br/> 'C'<br/> 'D'<br/> 'E'<br/> 'F'</span></pre><p id="0518" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将作为参数返回的字符解包为string，用于将所有汽车连接成一个字符串。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="3381" class="ln lo iq le b gy lp lq l lr ls">julia&gt; g = generator()<br/>julia&gt; string(g...)<br/>"ABCDEF"</span></pre><h2 id="191e" class="ln lo iq bd lt lu lv dn lw lx ly dp lz ko ma mb mc ks md me mf kw mg mh mi mj bi translated">了解任务和渠道的详细信息</h2><p id="48a0" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们在代码示例中使用的<code class="fe lb lc ld le b">Channel</code>构造函数实际上做了很多事情，所以你看不到它如何工作的所有细节。</p><p id="14a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里更详细地说明了正在发生的事情:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="482b" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">function</strong> generator()<br/>   channel = Channel(2)<br/>   <strong class="le ir">function</strong> make_letters()<br/>       <strong class="le ir">for</strong> i <strong class="le ir">in</strong> 0:5<br/>           put!(channel, Char('A' + i))<br/>       <strong class="le ir">end</strong><br/>   <strong class="le ir">end</strong><br/>   task = Task(make_letters)<br/>   schedule(task)<br/>   channel<br/><strong class="le ir">end</strong></span></pre><p id="2aad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以把协程想成有点像线程。像线程一样，您可以拥有许多线程，并且可以使用不同的数据结构在它们之间进行通信。通道用于在协同程序之间发送数据。然而，与线程不同的是，只有一个协程运行。不能在不同的CPU内核上运行多个协同程序。他们像合作的多任务处理一样工作。调度程序切换到另一个协程，因为当前的协程明确放弃控制权。</p><p id="fdc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，当我写道:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a8e4" class="ln lo iq le b gy lp lq l lr ls">put!(channel, Char('A' + i))</span></pre><p id="ea9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个字母将被放入通道，如果通道有缓冲区，函数将立即返回。我们指定通道的缓冲区为2。</p><p id="4c8f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦缓冲区耗尽，我们当前的协同程序将阻塞，调度程序将选择一个协同程序(任务)等待来自这个特定通道的数据。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="b2b6" class="ln lo iq le b gy lp lq l lr ls">task = Task(make_letters)</span></pre><p id="2563" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将创建一个任务，这就是我们如何跟踪不同的协程。每个协程都需要一个任务。该任务跟踪执行状态。</p><p id="8c6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而此时，我们的协程实际上并没有运行。for循环没有将字母放入通道。为了让它运行，我们需要<code class="fe lb lc ld le b">schedule</code>这个任务。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e169" class="ln lo iq le b gy lp lq l lr ls">schedule(task)</span></pre><p id="baa2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会将任务放入调度程序队列中。每当系统空闲时，它将在其调度器队列中查找要运行的任务。这样做的直接结果是我们的任务开始运行，这导致‘A’和‘B’被放入通道。但是当循环试图放入“C”时，它已经用完了缓冲区并阻塞了。</p><p id="0431" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，调度程序将寻找另一个任务来运行。我相信我们可以把REPL本身看作是调度程序可以切换到的一个主协程。所以说我救了从<code class="fe lb lc ld le b">generator</code>回来的<code class="fe lb lc ld le b">channel</code>，我们可以这样做:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="aaeb" class="ln lo iq le b gy lp lq l lr ls">julia&gt; channel = generator()<br/>julia&gt; take!(ch)<br/>'A'</span></pre><p id="f54f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，REPL进入空闲状态，等待您的输入。然后调度程序有机会捡起我们的旧任务并继续运行它。一个字母已从缓冲区中移除，因此它现在有机会将“C”放入通道中。</p><p id="f866" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免设置和运行协程任务的样板文件，有许多快捷方式和宏来帮助我们。这里有一个选择:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="521d" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">function</strong> generator()<br/>   channel = Channel(2)<br/>   @async begin<br/>       <strong class="le ir">for</strong> i <strong class="le ir">in</strong> 0:5<br/>           put!(channel, Char('A' + i))<br/>       <strong class="le ir">end</strong><br/>   <strong class="le ir">end</strong><br/>   channel<br/><strong class="le ir">end</strong></span></pre><p id="b2d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">@async</code>宏负责创建一个函数，将其封装在<code class="fe lb lc ld le b">Task</code>中，并调度该任务。它将返回任务对象，但我们不需要为任何事情存储它。</p><p id="7b5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Channel</code>构造函数既可以接受一个给出其容量的整数，也可以接受一个函数对象。在后一种情况下，它将把提供的函数对象包装在一个<code class="fe lb lc ld le b">Task</code>中并调度它。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c484" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">function</strong> generator()<br/>   <strong class="le ir">function</strong> make_letters(channel::Channel)<br/>       <strong class="le ir">for</strong> i <strong class="le ir">in</strong> 0:5<br/>           put!(channel, Char('A' + i))<br/>       <strong class="le ir">end</strong><br/>   <strong class="le ir">end<br/></strong>   Channel(make_letters)<br/><strong class="le ir">end</strong></span></pre><p id="3eee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能会让我们更清楚最初的例子是如何工作的，在那里我们使用了<code class="fe lb lc ld le b">do</code>语法。记住<code class="fe lb lc ld le b">do</code>的语法类似于:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e89e" class="ln lo iq le b gy lp lq l lr ls">foobar(x -&gt; stuff(x), y, z)<br/>foobar(y, z) <strong class="le ir">do</strong> x<br/> stuff(x)<br/><strong class="le ir">end</strong></span></pre><p id="a12c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是Python生成器中隐藏的东西。实际上，在Python中可以做类似的事情来处理并发性。我将在后面的故事中探讨这个问题。</p></div></div>    
</body>
</html>