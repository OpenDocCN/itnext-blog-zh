<html>
<head>
<title>How to create a file by file custom SCSS build including dependencies, using postcss and optional css vars</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用postcss和可选的CSS变量创建一个包含依赖项的文件自定义SCSS版本</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-a-file-by-file-custom-scss-build-including-dependencies-using-postcss-and-optional-c83f8e5677d8?source=collection_archive---------2-----------------------#2021-05-04">https://itnext.io/how-to-create-a-file-by-file-custom-scss-build-including-dependencies-using-postcss-and-optional-c83f8e5677d8?source=collection_archive---------2-----------------------#2021-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a0a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这听起来像是一个常见的问题，但我无法在网上找到一个好的解决方案。所以我认为写一篇关于它的文章来节省别人的时间是一个好主意。</p><p id="46a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然有许多使用案例可以让你依靠webpack来创建合适的CSS分割块，但是也有一些场景需要你从头开始创建一个基于1输入→ 1输出的解决方案。</p><p id="0f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我强烈建议先阅读文章，但对于那些想马上深入代码的好奇者:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/buildScripts/buildThemes.js#L91" rel="noopener ugc nofollow" target="_blank">build scripts/build themes . js</a>(可以跳过前90行)</p><h1 id="527e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">内容</h1><ol class=""><li id="e259" class="lk ll iq jp b jq lm ju ln jy lo kc lp kg lq kk lr ls lt lu bi translated">动机:JS相关跨app拆分组块</li><li id="a5cb" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">为什么我们不能使用webpack进行主题构建？</li><li id="4715" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">SCSS结构</li><li id="5e5f" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">使用css变量的期望输出</li><li id="db83" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">没有css变量的期望输出</li><li id="ff32" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">如何建造SCSS？</li><li id="2cce" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">核心算法</li><li id="cd48" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">构建需要多长时间？</li><li id="498d" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">我们能在neo.mjs中增加对JS中CSS的支持吗？</li><li id="5b53" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">接下来是什么？</li><li id="9445" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">最后的想法</li></ol><h1 id="8122" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">1.动机:JS相关跨app拆分组块</h1><p id="3f0b" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我绝对是<a class="ae kl" href="https://github.com/webpack/webpack" rel="noopener ugc nofollow" target="_blank">网络包</a>的粉丝。cross应用程序在worker范围内分割块工作得非常好。浏览器本身也是如此:动态导入文件永远不会多次加载同一个JS模块。</p><p id="dcf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在app worker控制台日志中看到它(如果您仔细观察:当将现有组件树移动到新窗口中时，您可以看到空视口&amp; app.mjs的模块并行加载到下一个主窗口选项卡主体中):</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5892" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">跨应用程序分割意味着，我们也可以将多个应用程序放在一个页面上。在这种情况下，webpack使我们能够为共享的JS模块创建块，所以我们不会根据需要加载更多的代码。</p><p id="d0d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不久前，我写了一篇关于这个问题的深度文章:</p><div class="mk ml gp gr mm mn"><a href="https://medium.com/swlh/cross-app-bundling-a-different-approach-for-micro-frontends-e4f212b6a9a" rel="noopener follow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">跨应用捆绑——微前端的一种不同方法</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">捆绑分布式版本的应用程序代码一直是一个挑战，尤其是在您想要共享代码的情况下…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">medium.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb nc mn"/></div></div></a></div><p id="7f7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">neo.mjs 仍然使用单片CSS输出，这并没有做到项目公正。足够的动力去创造一个和JS一个水平的新版本！</p><h1 id="6eaa" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2.为什么我们不能使用webpack进行主题构建？</h1><p id="8d08" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">原因有二。</p><p id="ade0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我们可以生成与JS相匹配的CSS分割块，但这对于使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" rel="noopener ugc nofollow" target="_blank"> SharedWorkers </a>的多窗口上下文来说是不够的。如果您仔细观看了上一个视频，您会看到我们可以将整个组件树移动到不同的窗口中。</p><p id="07e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组件树可以包含任何可能的组件组合，这使得基于组件文件的输出是强制性的。如果我们移动一棵树，我们希望在目标窗口中加载所需的CSS文件，而不是其他文件。</p><p id="1f76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因2是我们正在将组件加载到应用程序工作器中。我们需要定制webpack来匹配将JS块加载到worker中，并将相关的CSS分割块添加到匹配的主线程中。我们还需要调整大块构建本身，以便了解应用程序工作线程——主线程连接。</p><p id="ff24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，原因1不适用于非共享工人范围。用neo.mjs编写的单页应用程序可以利用这种方法。不幸的是，我的路线图已经太紧张，无法尝试。不过，欢迎你开罚单！</p><p id="14c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于一致性原因，我的目标是创建一个新的解决方案来适应这两个范围。</p><h1 id="1dc2" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">3.SCSS结构</h1><p id="a6f5" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">为了了解我们在处理什么:<br/> <a class="ae kl" href="https://github.com/neomjs/neo/tree/dev/resources/scss" rel="noopener ugc nofollow" target="_blank">资源/scss </a></p><pre class="md me mf mg gt nd ne nf ng aw nh bi"><span id="25f2" class="ni kn iq ne b gy nj nk l nl nm">find mixins      -type f | wc -l //   1 file<br/>find src         -type f | wc -l // 125 files<br/>find theme-dark  -type f | wc -l //  72 files<br/>find theme-light -type f | wc -l //  72 files</span></pre><p id="c448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">旧版本有能力选择使用css变量，这肯定是我们想要保留的。为了实现这一点，我们需要几个函数。</p><p id="d3b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">mixins/_all.scss:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nn mj l"/></div></figure><p id="b997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看一个相当简单的组件:按钮</p><p id="3746" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[Side node]增强内容在我的待办事项列表中，例如仅使用。基于em的尺寸使组件可扩展。请保持开放的心态。</p><p id="db9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">scss/theme-深色/button/_Base.scss:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nn mj l"/></div></figure><p id="5a00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在一个映射中定义scss变量，然后检查我们是否想使用css变量。如果是这样，neo()调用将为我们提供匹配的scss变量的值。</p><p id="42e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">scss/src/button/_Base.scss:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nn mj l"/></div></figure><p id="1712" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">v()函数将返回css变量的名称或匹配的scss变量的值。</p><h1 id="f0e4" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">4.使用css变量的期望输出</h1><p id="1f0e" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">dist/development/CSS/theme-dark/button/base . CSS:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nn mj l"/></div></figure><p id="243e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dist/development/CSS/src/button。Base.css:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nn mj l"/></div></figure><p id="093c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里好的一面是主题的文件非常小。如果你想在你的应用程序中动态地切换主题，或者为你的视图结构的不同部分使用不同的主题，这种方法非常适合。</p><p id="7ffc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在虚拟DOM的任何级别上应用主题。</p><p id="34d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在运行时更改css变量，这也很好。</p><p id="c2a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，这需要维持一个适合所有主题的src结构。如果你想创建一个自己的主题，并需要更多的变量，随时打开门票或发送PRs。</p><p id="1657" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您也可以创建扩展框架基类的定制组件，并按照您喜欢的任何方式设计它们。</p><p id="4e97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分布/生产输出不使用源贴图，并且被缩小。</p><h1 id="b985" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">5.没有css变量的期望输出</h1><p id="bb87" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">dist/development/CSS-no-vars/theme-dark/button/base . CSS:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nn mj l"/></div></figure><p id="e143" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个场景中，我们只得到一个包含scss变量值的文件。</p><p id="49b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不想在运行时改变css变量，只使用一个主题，文件大小会小一点。一旦你使用第二个或更多的主题，这个版本就不再有意义了。</p><h1 id="f2d2" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">6.如何建造SCSS？</h1><p id="645e" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们正在使用dart-sass npm包(已重命名为sass)。</p><div class="mk ml gp gr mm mn"><a href="https://www.npmjs.com/package/sass" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">厚颜无耻</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">Sass的纯JavaScript实现。</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">www.npmjs.com</p></div></div><div class="mw l"><div class="no l my mz na mw nb nc mn"/></div></div></a></div><p id="4737" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将使用<a class="ae kl" href="https://www.npmjs.com/package/postcss" rel="noopener ugc nofollow" target="_blank"> postcss </a>，包括<a class="ae kl" href="https://www.npmjs.com/package/autoprefixer" rel="noopener ugc nofollow" target="_blank"> autoprefixer </a>和<a class="ae kl" href="https://www.npmjs.com/package/cssnano" rel="noopener ugc nofollow" target="_blank"> cssnano </a>插件。</p><p id="5b25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在深入研究代码之前，让我们考虑一下我遇到的两个问题。</p><p id="e2ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">旧单体建筑有特定的入口点。举几个例子:</p><p id="e059" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">scss _ structure.scss</p><pre class="md me mf mg gt nd ne nf ng aw nh bi"><span id="abd5" class="ni kn iq ne b gy nj nk l nl nm">@use "sass:map";<br/>$neoMap: ();<br/><br/>$useCssVars: true;<br/><br/>@import "../../../../resources/scss/mixins/all";<br/>@import "../../../../resources/scss/src/all";</span></pre><p id="baac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主题_黑暗. scss</p><pre class="md me mf mg gt nd ne nf ng aw nh bi"><span id="45c4" class="ni kn iq ne b gy nj nk l nl nm">@use "sass:map";<br/>$neoMap: ();<br/><br/>$useCssVars: true;<br/><br/>@import "../../../../resources/scss/mixins/all";<br/>@import "../../../../resources/scss/theme-dark/all";</span></pre><p id="54d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">theme_dark.noCssVars.scss</p><pre class="md me mf mg gt nd ne nf ng aw nh bi"><span id="587d" class="ni kn iq ne b gy nj nk l nl nm">@use "sass:map";<br/>$neoMap: ();<br/><br/>$useCssVars: false;<br/><br/>@import "../../../../resources/scss/mixins/all";<br/>@import "../../../../resources/scss/theme-dark/all";<br/>@import "../../../../resources/scss/src/all";</span></pre><p id="bfb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们绝对不希望为每个scss文件创建多个新的入口点，所以从一个<strong class="jp ir">文件</strong>开始使用<code class="fe np nq nr ne b">sass.render()</code>是行不通的。</p><p id="86ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看JS API: <br/>【旁注】它有点过时了，因为纤程不能在node v16+中工作</p><div class="mk ml gp gr mm mn"><a href="https://sass-lang.com/documentation/js-api#render" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">JavaScript API</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">Sass模块提供了两个具有相似API的函数。这个函数将一个Sass文件同步编译成CSS。如果…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">sass-lang.com</p></div></div></div></a></div><p id="868a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们很幸运，因为我们可以使用一个接受文件缓冲区(stdin)的<code class="fe np nq nr ne b">data</code>属性。</p><p id="9b9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只想为每个目标导入一次mixins文件。</p><p id="a2b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真正的问题是，<code class="fe np nq nr ne b">src</code>文件不能只依赖于导入父类。例如，SplitButton可以使用按钮变量。</p><p id="4a73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经典的例子:一个<code class="fe np nq nr ne b">container.Toolbar</code>文件也使用了按钮变量，这与按钮类的层次结构无关。</p><p id="e533" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了做到这一点，每个<code class="fe np nq nr ne b">var</code>文件需要导入所有组件的<strong class="jp ir">变量文件。现在，如果我们想要构建72个<code class="fe np nq nr ne b">var</code>文件，每个文件导入theme-dark/all文件，该文件使用<code class="fe np nq nr ne b">@import</code> sass导入来获取其他71个主题变量文件，我们最终得到72 * 72个sass导入。</strong></p><p id="0599" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它实际上没有我想象的那么慢，但是我们肯定可以用<strong class="jp ir">而不是</strong>来减少几秒钟的构建时间。</p><p id="a624" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们动态地创建一次所有主题变量文件的合并版本。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nn mj l"/></div></figure><p id="107a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用递归函数就可以做到这一点。</p><pre class="md me mf mg gt nd ne nf ng aw nh bi"><span id="245f" class="ni kn iq ne b gy nj nk l nl nm">sassImportRegex = /@import[^'"]+?['"](.+?)['"];?/g</span></pre><p id="24c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用文件的内容替换导入语句。</p><p id="528e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不会将结果保存到文件中。一个局部变量就足够了。</p><p id="34a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">程序本身支持命令行选项。如果未设置，我们将使用查询程序</p><ol class=""><li id="7715" class="lk ll iq jp b jq jr ju jv jy ns kc nt kg nu kk lr ls lt lu bi translated">要求主题(所有、暗、亮)</li><li id="a299" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">环境(所有、开发、生产)</li><li id="e048" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">使用CSS变量？(全部，是，否)<code class="fe np nq nr ne b">// you will most likely never use "all”</code></li></ol><p id="ea71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦设置了选项，我们就会遇到:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nn mj l"/></div></figure><p id="965d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这导致了buildEnv()函数:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nn mj l"/></div></figure><p id="4b31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有css变量→不需要src构建，我们正在使用<code class="fe np nq nr ne b">getAllScssFiles()</code>收集所有入口点。</p><p id="f764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我将resources/scss文件夹复制到scss_new中。</p><p id="7e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个想法是，非入口点文件以下划线<br/>(像<code class="fe np nq nr ne b">_all.scss</code>)开始，入口点文件则不是(像<code class="fe np nq nr ne b">Button.scss</code>)。</p><p id="feaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们可以很容易地解析一个嵌套的文件夹结构，递归地获取所有的入口点文件。</p><p id="97de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们拿到文件，我们会打电话给<code class="fe np nq nr ne b">parseScssFiles()</code></p><h1 id="de5c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">7.核心算法</h1><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="nn mj l"/></div></figure><p id="46c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用前面提到的<code class="fe np nq nr ne b">scssCombine()</code>方法，对每个我们想要构建的主题使用一次。</p><p id="68fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以把它放到数据构建属性中，这很好。</p><p id="0d3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以在那里添加所需的变量和混合。</p><p id="9023" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">剩下的就很简单了:</p><p id="9d8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只对开发环境使用了<code class="fe np nq nr ne b">sourceMap</code>选项。</p><p id="23c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦<code class="fe np nq nr ne b">sass.render()</code>完成，我们将使用autoprefixer为两种环境触发<code class="fe np nq nr ne b">postcss().process()</code>，而<code class="fe np nq nr ne b">cssnano</code>仅用于生产输出。</p><p id="8c0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，我们保存输出的CSS文件，就这样。</p><h1 id="084f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">8.构建需要多长时间？</h1><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><pre class="md me mf mg gt nd ne nf ng aw nh bi"><span id="24ac" class="ni kn iq ne b gy nj nk l nl nm">theme-dark dev     vars: 2.09s<br/>theme-dark prod    vars: 2.85s<br/>theme-dark dev  no vars: 2.76s<br/>theme-dark prod no vars: 3.36s</span><span id="5489" class="ni kn iq ne b gy nv nk l nl nm">theme-dark all     vars: 4.47s<br/>theme-dark all  no vars: 5.39s</span><span id="8154" class="ni kn iq ne b gy nv nk l nl nm">all        all     vars: 6.28s</span></pre><h1 id="c0ee" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">9.我们能在neo.mjs中增加对JS中CSS的支持吗？</h1><p id="0f5f" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我一直在思考这个话题，因为像<a class="ae kl" href="https://github.com/emotion-js/emotion" rel="noopener ugc nofollow" target="_blank">情感</a>这样的项目越来越受欢迎。</p><p id="6ca9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>的设计目标是，开发模式在浏览器内部运行，无需在js端进行任何构建或编译。</p><p id="fa63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们肯定也想为此使用<a class="ae kl" href="https://www.npmjs.com/package/postcss" rel="noopener ugc nofollow" target="_blank"> postcss </a>和<a class="ae kl" href="https://www.npmjs.com/package/autoprefixer" rel="noopener ugc nofollow" target="_blank"> autoprefixer </a>插件。因此，为了让它工作，我们需要一个像<a class="ae kl" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank"> browserify </a>这样的工具来直接在浏览器中进行编译。这将导致一些开销(更大的文件)。</p><p id="cbe4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在dist/development环境中，这肯定更容易。</p><p id="1cb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的路线图相当紧凑，所以我不确定我是否会很快找到时间投入其中。我主要关注框架基础(核心和生态系统),以使其他人更容易在其上构建东西。</p><p id="e333" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想看到这种情况发生，一定要开一张票:<br/><a class="ae kl" href="https://github.com/neomjs/neo/issues" rel="noopener ugc nofollow" target="_blank">https://github.com/neomjs/neo/issues</a></p><p id="0f36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你愿意的话，也非常欢迎你来做这件事。我唯一的要求是它是可选的。可行，因为我们已经有了可选的主线程插件。</p><h1 id="7104" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">10.接下来是什么？</h1><p id="613e" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我想我在过去的3天里花了大约40个小时让新版本运行起来。虽然结果代码变得很短，但问题在于细节:)</p><p id="78ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，下一步是将新的输出包含到框架中。我在这里为此创建了一个项目:<a class="ae kl" href="https://github.com/neomjs/neo/projects/25" rel="noopener ugc nofollow" target="_blank"> neomjs/neo/projects/25 </a>。</p><p id="f6a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它应该是简单明了的:我们像<code class="fe np nq nr ne b">Neo.cssMap[appName][className]</code>一样在应用程序工作器内部创建一个映射。如果每个类有一个主题src和/或var文件，那么每个类都需要标志。<code class="fe np nq nr ne b">component.Base</code>有一个appName配置(也匹配主线程→浏览器窗口)，所以我们可以使用<code class="fe np nq nr ne b">afterSetAppName()</code>来检查映射并触发主线程样式表插件来加载所需的新文件。构造新实例将触发appName更改。向容器中添加一个组件也是一样的。<code class="fe np nq nr ne b">container.Base</code>如果有变化，也会调整直接子项appName配置，所以这部分感觉很容易。</p><p id="fe98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦完成，我将把它部署到网上的例子，并写一篇快速跟进文章。</p><p id="6a55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要将新的构建和输出添加到由<code class="fe np nq nr ne b">npx neo-app</code>创建的工作空间中。工作区有自己的resources文件夹，使您能够在那里为自己的组件创建主题文件。这些文件需要包含在内(就像它在当前构建中工作一样)，并且构建输出必须保存到workspace dist文件夹中。</p><p id="19e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦完成，我们就达到了2.1版本。经过更多的测试后，我会将这个版本添加到create-app repo中，然后移除(替换)旧的整体版本。在这个转换过程中，我保留了旧的版本，以确保在您现有的工作空间中工作时不会出现问题。</p><h1 id="8f1a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">11.最后的想法</h1><p id="752b" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">如果你还没有研究过neo.mjs项目，我强烈建议你去做。这个项目非常具有破坏性，可能太超前了，但是在今天的浏览器中运行良好。</p><p id="d4b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设计目标:</p><ol class=""><li id="4998" class="lk ll iq jp b jq jr ju jv jy ns kc nt kg nu kk lr ls lt lu bi translated">专注或共享的员工是主要参与者</li><li id="e902" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">您可以在dev模式下运行JS代码(使用JS模块不需要编译或编译)</li><li id="a667" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">基于JSON的虚拟dom创造了极快的性能</li><li id="2598" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">可选的多浏览器窗口模式支持独特的特性，比如跨窗口共享应用程序状态，或者跨窗口动态移动组件树，同时保持相同的JS实例。</li></ol><div class="mk ml gp gr mm mn"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">近地天体</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序，而无需使用…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="nw l my mz na mw nb nc mn"/></div></div></a></div><p id="d8ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个项目需要更多的捐助者和赞助者。</p><p id="0dc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问候&amp;快乐编码，<br/>托拜厄斯</p><p id="3fdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预览图像:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi nx"><img src="../Images/9a7a6d646d501ce85828b8c5468f7c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lx-bPYfTPvzSHBlpfuzmZA.png"/></div></div></figure></div></div>    
</body>
</html>