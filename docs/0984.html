<html>
<head>
<title>React with(out) MobX (part 2 of 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与(out) MobX反应(第2部分，共2部分)</h1>
<blockquote>原文：<a href="https://itnext.io/react-with-out-mobx-part-2-of-2-a927d87fcd2?source=collection_archive---------6-----------------------#2018-06-27">https://itnext.io/react-with-out-mobx-part-2-of-2-a927d87fcd2?source=collection_archive---------6-----------------------#2018-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1709" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在不“污染”您的存储和组件的情况下获得MobX的所有好处</h2></div><p id="5de9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">这篇文章展示了我在开发</em><a class="ae lc" href="https://www.timefic.com" rel="noopener ugc nofollow" target="_blank"><em class="lb">【timefic.com】</em></a><em class="lb">的过程中的另一段旅程，从React components with explicit MobX inside components and stores，到React components and stores where</em><strong class="kh ir"><em class="lb">根本没有单独引用MobX</em></strong><em class="lb">，但仍然在幕后使用MobX。</em></p><blockquote class="ld le lf"><p id="b8ce" class="kf kg lb kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">注:这是本文中<a class="ae lc" href="https://medium.com/@jmaguirrei/react-with-out-mobx-part-1-of-2-b540a7e631a9" rel="noopener">的第二部分。</a></p></blockquote><p id="ef4e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上一篇文章中，我告诉了您为所有应用程序定义单个<strong class="kh ir">特设</strong>(高阶组件)的好处。这个组件并不是真正的React组件，而是返回一个<strong class="kh ir">增强组件</strong>的函数。</p><p id="2465" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的建议是让你的应用程序的每个组件都成为增强组件。因此，如果您的应用程序有250个组件，您需要增强250个组件:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/a066c584e61a8e8913b652575e3427ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVPCJ6pmlsGzgtT0T6ZjcA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">无状态组件(命名导出)和增强组件(默认导出)</figcaption></figure><p id="c0f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会停止思考:</p><ul class=""><li id="8254" class="lz ma iq kh b ki kj kl km ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kh ir">数据和函数</strong>如何进入组件的道具中。</li><li id="82a4" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">如果组件<strong class="kh ir">在假设不</strong>时被重新渲染。</li><li id="ca9e" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">并且不再需要生命周期方法的类。</li></ul><p id="88ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的组件不再对这些“小细节”负责:<strong class="kh ir">特设负责！</strong></p><p id="3c8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，场景1是标准方法(在组件和商店中使用MobX ),场景2没有使用显式MobX，还记得吗？现在回到故事上来👇</p><h2 id="b74b" class="mn mo iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">场景2:“独立于MobX”的方法</h2><blockquote class="ng"><p id="c703" class="nh ni iq bd nj nk nl nm nn no np la dk translated">简而言之:想法是使用MobX，但不引用它。</p></blockquote><p id="2f7d" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated"><strong class="kh ir">商店级别</strong></p><p id="e5ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在商店级别，“照常”使用MobX让我有点不舒服，因为:</p><ul class=""><li id="6570" class="lz ma iq kh b ki kj kl km ko mb ks mc kw md la me mf mg mh bi translated">我的每一家商店(在会议模块中有17家)都变得越来越大。因此，我在一个单独的文件中为每个字段创建了一个函数，将存储转换得更像一个索引文件。</li><li id="c9a9" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kh ir">这个</strong>这个词到处都是。我需要用他们需要的输入来填充任何计算出的值，因为它们现在在一个单独的文件中。</li><li id="1c46" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">我没有<strong class="kh ir">依赖注入机制</strong>，所以测试商店很困难(周围的装饰者也没有帮助)。</li></ul><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nv"><img src="../Images/7baa388f55aff4bac6928ea350c437ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6oP7-ke69JR4mpAVERI3Q.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">一个典型的MobX存储，将计算字段作为函数，没有依赖注入</figcaption></figure><p id="a89b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如图所示，这个ActionsStore有<strong class="kh ir"> 1个可观察的</strong>和<strong class="kh ir"> 4个计算字段</strong>。每个计算字段都是一个从商店本身和其他商店获取输入的函数，在本例中:<strong class="kh ir"> PeopleStore </strong>、<strong class="kh ir">meetingstore</strong>、<strong class="kh ir"> MembersStore </strong>和<strong class="kh ir"> State </strong>。</p><p id="1607" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试这个文件，我需要上述存储中的数据，但是我如何将数据放入其中呢？</p><blockquote class="ld le lf"><p id="aacb" class="kf kg lb kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">您正在查看的商店是我拥有的简单商店之一，因此，当您想要查看不太好用的东西时，请想象一个通常有200行的文件……<em class="iq">😧</em></p></blockquote><p id="30da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我需要做点什么。</p><p id="fecb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不记得具体是怎么做的(我总是阅读一些函数式编程技术)，但它提出了一个curried函数，指明了方向。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/24044428f96199818c90c2910c7f4e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*h0OMBKg69vUe6B4ObSdzEA.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">两种口味的计算字段:咖喱和非咖喱</figcaption></figure><p id="ec3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如图所示，curried版本不需要<strong class="kh ir"> <em class="lb">这个</em> </strong>和<strong class="kh ir">状态</strong>存储在函数范围内。现在<strong class="kh ir"> <em class="lb">自我</em> </strong>正在定义这个范围(这个范围就是我们将要看到的商店本身)。这里有商店中每个字段可能需要的所有信息(其他商店和同一商店中的其他字段)。</p><p id="3c90" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，因为函数是可定制的，如果你调用<strong class="kh ir"><em class="lb">【getMeetingActions(this)</em></strong>你会得到一个函数，它正好有计算值所需的数据。</p><p id="0b80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">战略出现了:</p><blockquote class="ng"><p id="3a59" class="nh ni iq bd nj nk nl nm nn no np la dk translated">每个计算字段将通过调用一个函数(curried function)获得，以存储本身(this)作为上下文。</p></blockquote><p id="d1a6" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">但是，我们将隐藏这个实现细节，使商店看起来像这样:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nx"><img src="../Images/b699684c35d6f506806311c64025ed35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULQ7Gih-JiGjeqC8cpLpjg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">新版商店:MobX在哪里？</figcaption></figure><p id="9f72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看图像:MobX在哪里？</p><blockquote class="ld le lf"><p id="6b21" class="kf kg lb kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">想想看:如果每个计算值都有相同的签名，在这种情况下，是以<strong class="kh ir"> <em class="iq"> this </em> </strong>作为参数调用函数的结果，那么可以将它们定义为一个对象内的字段列表，如图所示。</p></blockquote><p id="d50f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似的东西也用于<strong class="kh ir">动作</strong>、<strong class="kh ir">可观察到的</strong>和<strong class="kh ir">反应</strong>:大多数MobX商店的基本构件。</p><p id="034b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，计算值是这样实现的:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ny"><img src="../Images/502ca52e6058e6b217578a05f085dcc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EwRVlyG6ihWdS7_xFABqeg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">通用计算值的实现(使用MobX)</figcaption></figure><p id="0a8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再者，如果想使用另一个类似MobX的反应式状态库，只需要接触这段代码就可以了！</p><p id="80ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好处:</p><ul class=""><li id="29a5" class="lz ma iq kh b ki kj kl km ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kh ir">标准存储创建</strong>:存储用(工厂)功能创建的。需要让每家店都可以调试？只需将<strong class="kh ir"> <em class="lb">窗口</em>【商店名称】= <em class="lb">这个</em> </strong>添加到那个工厂函数中。<strong class="kh ir"> </strong>现在你可以在控制台中检查你创建的任何商店(这非常有用)。</li><li id="2990" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kh ir">缩减样板</strong>:对比前后店铺。后者不仅更小，而且有8个计算字段，而不是4个。</li><li id="e093" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kh ir">易读性</strong>:阅读它难道不是一种享受吗？</li><li id="7443" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kh ir">框架不可知论者</strong>:厌倦了MobX(我爱它！)?只要以其他方式实现它的原语，就可以开始了！</li><li id="668b" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kh ir"> Testability </strong>:您将测试从curried函数返回的函数，这意味着它的所有依赖项都已经作为参数传递了。此外，<strong class="kh ir">您可以创建一组新的一致性测试，将createStoreDefinition中的对象与商店</strong>(组件或其他商店)之外实际使用的对象进行比较。这可能是以后的文章，但是请记住，定义不仅可以用来“生成代码”，还可以用来测试它。</li></ul><p id="c23e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使商店更加完整，只缺少一个细节:</p><blockquote class="ld le lf"><p id="b17a" class="kf kg lb kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">每个存储需要知道其他存储的最小集合，因为在<strong class="kh ir">内部，这个</strong>必须是计算字段需要的上下文的引用。</p></blockquote><p id="3c2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说:</p><ul class=""><li id="f088" class="lz ma iq kh b ki kj kl km ko mb ks mc kw md la me mf mg mh bi translated">如果<strong class="kh ir"><em class="lb">myMeetingActions</em></strong>需要<strong class="kh ir"><em class="lb">State[' App _ meeting _ id ']</em>【T19]的值，那么<strong class="kh ir"> <em class="lb"> State </em> </strong> store必须用来构造ActionsStore。</strong></li></ul><p id="da29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着不可能是循环依赖。</p><blockquote class="ld le lf"><p id="ac19" class="kf kg lb kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">如果<strong class="kh ir">店C </strong>需要<strong class="kh ir">店A </strong>和<strong class="kh ir">店B </strong>，那么<strong class="kh ir">店B </strong>就不能依赖<strong class="kh ir">店C </strong>。在这种情况下(确实如此)，你需要打破<strong class="kh ir">商店C </strong>，例如，在两个商店。当你被迫这样做时，这是有意义的，因为你意识到有些事情是交错的(没有良好的设计)。</p></blockquote><p id="3d19" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，以下是timefic中的商店列表:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/8bb031d3c803af8e3ebd91b9edeed1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*0okuldeulmnyI0688PHc9g.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">存储的创建:顺序很重要——存储不能有循环依赖</figcaption></figure><p id="c86e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后的好处？</p><p id="89b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看着这些文件，很容易想到<strong class="kh ir">数据是如何组成的</strong>。</p><p id="74a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。希望这有意义，能有帮助！</p></div></div>    
</body>
</html>