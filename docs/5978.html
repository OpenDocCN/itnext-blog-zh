<html>
<head>
<title>How to deploy a cross-cloud Kubernetes cluster with built-in disaster recovery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何部署内置灾难恢复的跨云Kubernetes集群</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-deploy-a-cross-cloud-kubernetes-cluster-with-built-in-disaster-recovery-bbce27fcc9d7?source=collection_archive---------0-----------------------#2021-07-18">https://itnext.io/how-to-deploy-a-cross-cloud-kubernetes-cluster-with-built-in-disaster-recovery-bbce27fcc9d7?source=collection_archive---------0-----------------------#2021-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/38e0583662646f09bc75f50da1792f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_H7KPp4ZWajPZr6RMPX0oA.png"/></div></div></figure><p id="cd3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文解释了如何运行跨越混合云环境的单个Kubernetes集群，使其具有故障恢复能力。它将解释为什么这是必要的，以及如何使用MicroK8s、WireGuard和Netmaker实现这种架构。好了，准备好了吗？</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="4eeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes很难，但你知道什么更难吗？多云、多集群的Kubernetes，这是在生产中运行Kubernetes时不可避免要面对的问题。</p><p id="62f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，对于任何生产设置，您都将部署两个集群，最少需要<strong class="ka ir">个集群:一个作为实时环境，另一个用于故障转移(灾难恢复)。这可能会让你怀疑:</strong></p><p id="6fdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“为什么我需要两个集群来处理灾难恢复？我还以为Kubernetes有分布式架构呢？”</p><p id="0871" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正确！Kubernetes分发！它分布在单个数据中心/区域内。除此之外……没有那么多。</p><p id="66b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，为了拥有“高度可用”的基础设施，您最终会部署两个(或更多)集群，此外，您还必须部署自动化工具来在集群之间移动和复制应用程序，以及某种机制来处理集群停机时的故障转移。听起来很有趣，对吧？</p><p id="efd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请继续关注我，我们将通过一种不那么痛苦的方式来处理灾难恢复(以及混合工作负载)，这种方法不需要额外的工具，并且可以通过<strong class="ka ir">单集群</strong>来执行。</p><h1 id="0d43" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">分布式集群——MicroK8s和Netmaker</h1><p id="5bb7" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">有三个限制通常会阻止您跨环境使用单个集群:</p><ol class=""><li id="2f53" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir"> Etcd: </strong>它是你的集群的大脑，不能容忍延迟。在地理位置分散的环境中运行它是有问题的。</li><li id="81df" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">联网:</strong>集群节点需要能够直接且安全地相互通信。</li><li id="6a9f" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">延迟:</strong>高延迟对于企业应用来说是不可接受的。如果基于微服务的应用程序跨越多个环境，您最终可能会获得次优的性能。</li></ol><p id="bfc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们可以用MicroK8s和Netmaker解决这三个问题:</strong></p><ol class=""><li id="0472" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir"> Etcd: </strong> Etcd是Kubernetes的默认数据存储，但不是唯一的选项。MicroK8s默认运行Dqlite。Dqlite是延迟容忍的，允许您在不中断集群的情况下运行相距很远的主节点。</li><li id="08f5" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">联网:</strong> Netmaker易于与Kubernetes集成，并通过WireGuard创建扁平、安全的网络，供节点进行通话。</li><li id="c4f2" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">延迟:</strong> Netmaker是目前最快的虚拟网络平台之一，因为它使用内核WireGuard，对网络性能的影响可以忽略不计(与OpenVPN等选项不同)。此外，我们可以使用Kubernetes的内置放置策略将应用程序分组到同一数据中心的节点上，从而消除跨云延迟问题。</li></ol><p id="575a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，现在我们有了答案。通过运行MicroK8s和Netmaker，您可以消除复杂的传统多集群部署。您可以用更少的工作和更简单的架构获得相同的结果。</p><p id="7c44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">说够了，让我们付诸行动吧！</p><h1 id="5952" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">设置我们的环境</h1><p id="b3e6" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们将使用三种环境。这确保了如果任何一个环境发生故障，我们的主人仍然可以形成共识。</p><p id="9ddb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mu">你会注意到，未来我们不会区分大师和工人。这是因为在MicroK8s中，每个节点都有一个控制平面的副本，所以真的没有区别。</em></p><p id="70e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们的集群布局</strong></p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cce5" class="ne le iq na b gy nf ng l nh ni">Data Center: <strong class="na ir">2 Nodes</strong> (datacenter1, datacenter2)</span><span id="8eca" class="ne le iq na b gy nj ng l nh ni">DigitalOcean (region 1): <strong class="na ir">1 Node</strong> (do1)</span><span id="6b06" class="ne le iq na b gy nj ng l nh ni">DigitalOcean (region 2): <strong class="na ir">1 Node</strong> (do2)</span></pre><p id="d271" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有两个数据中心节点和两个云节点，可用于故障转移。</p><p id="301d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用DigitalOcean作为云节点，因为它们的带宽成本最低。根据云提供商的不同，数据传输成本会快速增加。DigitalOcean的带宽价格非常合理，您应该能够运行您的集群，而不会产生额外的成本。</p><p id="fb05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们所有的节点都在运行Ubuntu 20.04，每个节点都应该在运行本教程之前安装WireGuard </strong> <strong class="ka ir">。</strong></p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="edaf" class="ne le iq na b gy nf ng l nh ni">apt install wireguard wireguard-tools</span></pre><h1 id="7c05" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">节点1:种子</h1><p id="3c0d" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">SSH到您的第一个节点，它将充当您的集群的“种子”,因为它将设置Netmaker并建立将在其他节点上运行的网络。这个节点应该是<strong class="ka ir">可公开访问的。</strong>我们使用的是<strong class="ka ir"> do1 </strong>:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ed43" class="ne le iq na b gy nf ng l nh ni">ssh root@do1<br/>snap install microk8s --classic<br/>microk8s enable dns ingress storage</span></pre><p id="e542" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mu">*你会注意到我们使用的是内置的MicroK8s存储。对于生产设置，您可能需要更健壮的东西，比如openebs，另一个MicroK8s插件。</em></p><p id="5bf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，确保您设置了通配符DNS来指向这台机器。例如，在Route53中，您可以为*.kube.mydomain.com创建一条记录，指向这台机器的公共IP。</p><p id="3254" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，让我们设置一些证书:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="806f" class="ne le iq na b gy nf ng l nh ni">microk8s kubectl create namespace cert-manager</span><span id="ae2c" class="ne le iq na b gy nj ng l nh ni">microk8s kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.14.2/cert-manager.yaml</span></pre><p id="ca37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后创建并应用以下clusterissuer.yaml，用您的电子邮件替换EMAIL_ADDRESS占位符:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="353a" class="ne le iq na b gy nf ng l nh ni">apiVersion: cert-manager.io/v1alpha2<br/>kind: ClusterIssuer<br/>metadata:<br/>  name: letsencrypt-prod<br/>  namespace: cert-manager<br/>spec:<br/>  acme:<br/>    # The ACME server URL<br/>    server: <a class="ae nk" href="https://acme-v02.api.letsencrypt.org/directory" rel="noopener ugc nofollow" target="_blank">https://acme-v02.api.letsencrypt.org/directory</a><br/>    # Email address used for ACME registration<br/>    email: EMAIL_ADDRESS<br/>    # Name of a secret used to store the ACME account private key<br/>    privateKeySecretRef:<br/>      name: letsencrypt-prod<br/>    # Enable the HTTP-01 challenge provider<br/>    solvers:<br/>    - http01:<br/>        ingress:<br/>          class: public<br/></span></pre><p id="6c7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">证书管理器将需要几分钟的时间变得可用，因此在完成上述步骤后，此命令不会立即成功:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="aa33" class="ne le iq na b gy nf ng l nh ni">microk8s kubectl apply -f clusterissuer.yaml</span></pre><p id="ae14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们准备部署Netmaker。首先，获取模板:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3941" class="ne le iq na b gy nf ng l nh ni">wget <a class="ae nk" href="https://raw.githubusercontent.com/gravitl/netmaker/develop/kube/netmaker-template.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/gravitl/netmaker/develop/kube/netmaker-template.yaml</a></span></pre><p id="6ba4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，插入您希望Netmaker拥有的域。这必须是您在上面设置的DNS的子域，例如，如果您的外部负载平衡器指向*.kube.mydomain.com，您可以选择nm.kube.mydomain.com。该模板将在顶部添加以下子域:dashboard.nm.kube.mydomain.com，api.nm.kube.mydomain.com和grpc.nm.kube.mydomain.com。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e45a" class="ne le iq na b gy nf ng l nh ni">sed -i ‘s/NETMAKER_BASE_DOMAIN/&lt;your base domain&gt;/g’ netmaker-template.yaml</span></pre><p id="29ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，安装Netmaker！</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1e3d" class="ne le iq na b gy nf ng l nh ni">microk8s kubectl create ns nm</span><span id="0949" class="ne le iq na b gy nj ng l nh ni">microk8s kubectl config set-context --current --namespace=nm</span><span id="3f7d" class="ne le iq na b gy nj ng l nh ni">microk8s kubectl apply -f netmaker-template.yaml -n nm</span></pre><p id="1b1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大约需要3分钟，所有的豆荚才会出现。一旦它们启动，就转到仪表板(“microk8s kubectl get ingress”以找到域):</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a685" class="ne le iq na b gy nf ng l nh ni">microk8s kubectl get ingress nm-ui-ingress-nginx</span></pre><p id="d99c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建用户并登录。您将看到一个默认网络:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/956c019e591c75afbf14f7618a4b9810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SJKRtdCUm1u7tDJ8XveXhQ.png"/></div></div></figure><p id="e07e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">删除这个(进入编辑→删除)创建一个新的，我们称之为microk8s。确保IP范围不与microk8s重叠。我们给我们的10.101.0.0/16:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/791c7fe28c604c738fd472df594b3f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qNuJF2simvqwTUR08Xds8w.png"/></div></div></figure><p id="9f8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要一个密钥来让我们的节点安全地连接到这个网络。单击“访问密钥”，生成一个新密钥(给它一个高的使用次数，例如1000)，然后单击“创建”。确保将该值复制并保存在您的访问令牌下。这只会出现一次。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/6ac33db30b4667219c2d9788595fca93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mhmrwjcYlfFJtHuVx2gjzA.png"/></div></div></figure><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/e545195ed783bd71685912fcf6ee28f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhcQmfCSDk-JFwx2ETvk7g.png"/></div></div></figure><p id="10b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们在Netmaker服务器中需要做的所有事情。现在我们可以用<strong class="ka ir"> netclient </strong>设置我们的节点，这个代理处理每台机器上的网络。</p><p id="bcc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">但是首先，一个MicroK8s警告！</strong>为了正常运行，MicroK8s要求节点主机名可以互相访问。例如，如果您登录到您的机器并看到root@mymachine，那么mymachine应该是一个可从其他机器解析的地址。如果我们正确设置了主机名，Netmaker会处理这个问题。</p><p id="5ed9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">节点主机名的格式应该是nodename.networkname。因为我们的节点在microk8s网络上，所以每个<strong class="ka ir">主机名的格式都必须是&lt;节点名&gt; .microk8s </strong>。</p><p id="7c85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的“种子节点”上，让我们将主机名设置为<strong class="ka ir"> do1.microk8s </strong>。这样我们就知道它是一个数字海洋节点。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f871" class="ne le iq na b gy nf ng l nh ni">hostnamectl set-hostname do1.microk8s</span></pre><p id="669e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">好了，现在我们准备部署网络客户端:</strong></p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="4651" class="ne le iq na b gy nf ng l nh ni">wget <a class="ae nk" href="https://github.com/gravitl/netmaker/releases/download/v0.5.5/netclient" rel="noopener ugc nofollow" target="_blank">https://github.com/gravitl/netmaker/releases/download/v0.5.11/netclient</a> &amp;&amp; chmod +x netclient</span><span id="b304" class="ne le iq na b gy nj ng l nh ni">./netclient join -t &lt;YOUR_TOKEN&gt; --dns off --daemon off --name $(hostname | sed -e s/.microk8s//)</span></pre><p id="f605" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您现在应该有了<strong class="ka ir"> nm-microk8s </strong>接口:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="8424" class="ne le iq na b gy nf ng l nh ni">wg show</span><span id="42d1" class="ne le iq na b gy nj ng l nh ni"><strong class="na ir">#example output</strong><br/>#interface: nm-microk8s<br/>#  public key: AQViVk8J7JZkjlzsV/xFZKqmrQfNGkUygnJ/lU=<br/>#  private key: (hidden)<br/>#  listening port: 51821</span></pre><p id="1062" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以将netclient部署为systemd守护进程，但是我们将使用集群守护进程来管理我们的netclient。这使我们能够使用Kubernetes处理网络变更和升级。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7b9f" class="ne le iq na b gy nf ng l nh ni">wget <a class="ae nk" href="https://raw.githubusercontent.com/gravitl/netmaker/develop/kube/netclient-template.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/gravitl/netmaker/develop/kube/netclient-template.yaml</a></span><span id="9d8b" class="ne le iq na b gy nj ng l nh ni">sed -i ‘s/ACCESS_TOKEN_VALUE/&lt; your access token value&gt;/g’ netclient-template.yaml</span><span id="62e1" class="ne le iq na b gy nj ng l nh ni">microk8s kubectl apply -f netclient-template.yaml</span></pre><p id="3800" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个守护进程接管网络客户端的管理，并执行“登记”。</p><p id="c908" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切顺利，您应该会看到类似如下的日志:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ec75" class="ne le iq na b gy nf ng l nh ni">root@do1:~# microk8s kubectl logs netclient-&lt;id&gt;<br/>2021/07/13 17:11:16 attempting to join microk8s at grpc.nm.k8s.gravitl.com:443<br/>2021/07/13 17:11:16 node created on remote server...updating configs<br/>2021/07/13 17:11:16 retrieving remote peers<br/>2021/07/13 17:11:16 starting wireguard<br/>2021/07/13 17:11:16 joined microk8s<br/>Checking into server at grpc.nm.k8s.gravitl.com:443<br/>Checking to see if public addresses have changed<br/>Local Address has changed from  to 210.97.150.30<br/>Updating address<br/>2021/07/13 17:11:16 using SSL<br/>Authenticating with GRPC Server<br/>Authenticated<br/>Checking In.<br/>Checked in.</span></pre><p id="4edf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该节点现在也应该在UI中可见。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/1f1e53f1f1299ca52dce3fcce9cd2ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHXPPdFzR1sVjP0sI8xuGw.png"/></div></div></figure><h1 id="6788" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">节点2到X</h1><p id="c665" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">对于所有后续节点，我们的任务很简单。在每个节点上运行这些步骤(一次一个，不要并行)，并保持耐心:您不希望在任何前面的步骤有时间完成处理之前就匆忙完成这些步骤。</p><p id="0a3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 0。更改主机名</strong></p><p id="e374" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在加入节点上，运行:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="32ea" class="ne le iq na b gy nf ng l nh ni">hostnamectl set-hostname &lt;nodename&gt;.microk8s</span></pre><ol class=""><li id="4c8e" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir">加入网络</strong></li></ol><p id="5a31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用在种子节点上使用的<strong class="ka ir">相同命令和键</strong>安装netclient并加入网络:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a763" class="ne le iq na b gy nf ng l nh ni">wget <a class="ae nk" href="https://github.com/gravitl/netmaker/releases/download/v0.5.5/netclient" rel="noopener ugc nofollow" target="_blank">https://github.com/gravitl/netmaker/releases/download/v0.5.11/netclient</a> &amp;&amp; chmod +x netclient</span><span id="58a1" class="ne le iq na b gy nj ng l nh ni">./netclient join -t &lt;YOUR_TOKEN&gt; --daemon off --dns off --name $(hostname | sed -e s/.microk8s//)</span></pre><p id="da5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用<strong class="ka ir"> wg show </strong>确认节点已经加入网络:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a36b" class="ne le iq na b gy nf ng l nh ni"><strong class="na ir">root@datacenter2:~# wg show</strong><br/>interface: nm-microk8s<br/>  public key: 2xUDmCohypHcCD5dZukhhA8r6BGWN879J8vIhrcwSHg=<br/>  private key: (hidden)<br/>  listening port: 51821</span><span id="15e6" class="ne le iq na b gy nj ng l nh ni">peer: lrZkcSzWdgasgegaimEYnrr5CgopcEAIP8m3Q1M7+hiM=<br/>  endpoint: 192.168.88.151:51821<br/>  allowed ips: 10.101.0.3/32<br/>  latest handshake: 41 seconds ago<br/>  transfer: 736 B received, 2.53 KiB sent<br/>  persistent keepalive: every 20 seconds</span><span id="6eb5" class="ne le iq na b gy nj ng l nh ni">peer: IUobp84wipq44aFGP0SLuRhdSsDWvcxvBFefeRCE=<br/>  endpoint: 210.97.150.30:51821<br/>  allowed ips: 10.101.0.1/32<br/>  latest handshake: 57 seconds ago<br/>  transfer: 128.45 MiB received, 9.03 MiB sent<br/>  persistent keepalive: every 20 seconds</span></pre><p id="88bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。生成加入命令</strong></p><p id="035d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在“种子”节点上，运行<strong class="ka ir"> microk8s add-node。</strong>复制包含Netmaker创建的私有IP地址的命令:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0316" class="ne le iq na b gy nf ng l nh ni">root@do1:~# microk8s add-node<br/>From the node you wish to join to this cluster, run the following:<br/>microk8s join 209.97.147.27:25000/14e3a77f1584cb42323f39ce8ece0852/be5e4c7be0c6</span><span id="acd1" class="ne le iq na b gy nj ng l nh ni">If the node you are adding is not reachable through the default interface you can use one of the following:<strong class="na ir"><br/> </strong>microk8s join 210.97.150.27:25000/14e3a77f1584bc42323f39ce8ece0852/be5e4c7eb0c6<strong class="na ir"><br/></strong> microk8s join 10.17.0.5:25000/14e3a77f1584bc42323f39ce8ece0852/be5e4c7eb0c6<br/> microk8s join 10.108.0.2:25000/14e3a77f1584bc42323f39ce8ece0852/be5e4c7eb0c6<br/><strong class="na ir"> microk8s join 10.101.0.1:25000/14e3a77f1584bc42323f39ce8ece0852/be5e4c7eb0c6</strong></span></pre><p id="d89f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。加入集群</strong></p><p id="c7b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在加入节点上:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="13cb" class="ne le iq na b gy nf ng l nh ni">microk8s join 10.101.0.1:25000/14e3a77f1584bc42323f39ce8ece0852/be5e4c7eb0c6</span></pre><p id="8cb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">等待节点加入网络。下面是一些要运行的命令，它们将帮助您确定节点是否正常:</p><p id="dd14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> microk8s kubectl get节点:</strong>应该显示处于就绪状态的节点</p><p id="3926" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">micro k8s ku bectl get pods-A:</strong>所有的pods都应该在运行</p><p id="e23d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">micro k8s logs netclient-&lt;id&gt;:</strong>获取本节点上net client的日志</p><h1 id="e2d4" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">对要添加到集群中的每个节点重复步骤0到3。耐心点。等待每个节点加入网络和集群，然后继续下一步/机器。</strong></h1><p id="eab3" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在此过程结束时，您的集群和Netmaker实例应该如下所示:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2138" class="ne le iq na b gy nf ng l nh ni">root@do1:~/kube# microk8s kubectl get nodes -o wide<br/>NAME                   STATUS    VERSION   INTERNAL-IP   EXTERNAL-IP <br/>do2.microk8s           Ready     v1.21.1-3+ba   10.101.0.2   &lt;none&gt;        <br/>datacenter1.microk8s   Ready     v1.21.1-3+ba   10.101.0.3    &lt;none&gt;        <br/>do1.microk8s           Ready     v1.21.1-3+ba   10.101.0.1    &lt;none&gt;        <br/>datacenter2.microk8s   Ready     v1.21.1-3+ba   10.101.0.4    &lt;none&gt;        </span></pre><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/cf07e66b7d55cdbcff0cafe216bc1fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79YOOs4y13Kz_D_2GYOd0Q.png"/></div></div></figure><p id="fc20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">恭喜你！您有一个跨云Kubernetes集群，如果环境出现故障，它将转移工作负载。</p><h1 id="9069" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">灾难恢复测试</h1><p id="1311" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">现在我们已经设置好了集群，我们可以测试一个灾难恢复场景，看看它是如何运行的。让我们设置一个在数据中心运行的应用程序。首先，添加一些节点标签，以便我们知道哪个节点是哪个节点:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3fa6" class="ne le iq na b gy nf ng l nh ni">microk8s kubectl label nodes do1.microk8s do2.microk8s location=cloud</span><span id="72a0" class="ne le iq na b gy nj ng l nh ni">microk8s kubectl label nodes datacenter1.microk8s datacenter2.microk8s location=onprem</span></pre><p id="2e01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将在数据中心部署一个Nginx应用程序:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ad63" class="ne le iq na b gy nf ng l nh ni">wget <a class="ae nk" href="https://raw.githubusercontent.com/gravitl/netmaker/develop/kube/example/nginx-example.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/gravitl/netmaker/develop/kube/example/nginx-example.yaml</a></span><span id="33db" class="ne le iq na b gy nj ng l nh ni">#BASE_DOMAIN should be your wildcard, ex: app.example.com</span><span id="bd5b" class="ne le iq na b gy nj ng l nh ni">#template will add a subdomain, ex: nginx.app.example.com</span><span id="6a06" class="ne le iq na b gy nj ng l nh ni">sed -i ‘s/BASE_DOMAIN/&lt;your base domain&gt;/g’ nginx-example.yaml</span><span id="6921" class="ne le iq na b gy nj ng l nh ni">microk8s kubectl apply -f nginx-example.yaml</span></pre><p id="5d96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行“get pods”以查看数据中心中的所有实例都在运行。这是由于部署中的“节点关联性”标签。它与标签为<strong class="ka ir"> location=onprem </strong>的节点有密切关系。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2a12" class="ne le iq na b gy nf ng l nh ni">root@do1:~# k get po -o wide | grep nginx<br/>nginx-deployment-cb796dbc7-h72s8    1/1     Running   0          2m53s   10.1.99.68       datacenter1.microk8s   &lt;none&gt;           &lt;none&gt;<br/>nginx-deployment-cb796dbc7-p5bhr    1/1     Running   0          2m53s   10.1.99.67       datacenter1.microk8s   &lt;none&gt;           &lt;none&gt;<br/>nginx-deployment-cb796dbc7-pxpvw    1/1     Running   0          2m53s   10.1.247.3       datacenter2.microk8s   &lt;none&gt;           &lt;none&gt;<br/>nginx-deployment-cb796dbc7-7vbwz    1/1     Running   0          2m53s   10.1.247.4       datacenter2.microk8s   &lt;none&gt;           &lt;none&gt;<br/>nginx-deployment-cb796dbc7-x862w    1/1     Running   0          2m53s   10.1.247.5       datacenter2.microk8s   &lt;none&gt;           &lt;none&gt;</span></pre><p id="f059" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">转到入口的域，您应该会看到Nginx欢迎屏幕:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/4937eef45051300f5fb31fe611a34c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*YGD0WXqb6ij1tpYVacHPHw.png"/></div></figure><h1 id="52b5" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">模拟故障</h1><p id="3a7e" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在这种情况下，模拟失败相当容易。让我们关闭数据中心节点:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="208e" class="ne le iq na b gy nf ng l nh ni">root@datacenter2:~# microk8s stop</span><span id="c854" class="ne le iq na b gy nj ng l nh ni">root@datacenter1:~# microk8s stop</span></pre><p id="161d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">群集需要一段时间才能意识到节点缺失。默认情况下，Kubernetes会在节点处于“未就绪”状态后等待5分钟，然后才开始重新调度pod。</p><p id="1417" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于正常运行时间至关重要的场景，您可以更改参数以使其更快地发生。</p><p id="6a7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查节点状态:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0666" class="ne le iq na b gy nf ng l nh ni">root@do2:~# k get nodes<br/>NAME                   STATUS     ROLES    AGE    VERSION<br/>do2.microk8s           Ready      &lt;none&gt;   77m    v1.21.1-3+ba118484dd39df<br/>do1.microk8s           Ready      &lt;none&gt;   106m   v1.21.1-3+ba118484dd39df<br/>datacenter1.microk8s   NotReady   &lt;none&gt;   62m    v1.21.1-3+ba118484dd39df<br/>datacenter2.microk8s   NotReady   &lt;none&gt;   40m    v1.21.1-3+ba118484dd39df</span></pre><p id="2ef0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，您应该看到旧的pod终止，新的pod在云节点上调度:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/2aa32d3951a5a9fc419f21bccf7c8305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpcMEDOn-7inSv3-qVdQfA.png"/></div></div></figure><p id="51d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和以前一样，我们的网页完好无损:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/4937eef45051300f5fb31fe611a34c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*YGD0WXqb6ij1tpYVacHPHw.png"/></div></figure><p id="08a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在没有多个集群或自定义自动化的情况下，我们成功地设置了一个能够为我们处理灾难恢复的集群！</p><h1 id="d592" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="db77" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们在这里学到了什么？</p><ol class=""><li id="0a9e" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">像灾难恢复这样的场景过去需要多集群部署</li><li id="70c9" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">多集群模型不是绝对必要的</li><li id="f523" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">您可以使用单个集群启用多集群模式</li><li id="1264" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">启用这些模式需要像MicroK8s和Netmaker这样的工具</li></ol><p id="62ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法支持许多其他用例。例如，您可以将应用程序突发到云中，将节点部署到边缘，或者使用单个节点访问云环境中的资源。我们在这里展示了其中一些模式<a class="ae nk" rel="noopener ugc nofollow" target="_blank" href="/8-use-cases-for-kubernetes-over-vpn-unlocking-multicloud-flexibility-3958dab2219f">。</a></p><p id="ff53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在部署这种系统时，还需要考虑许多陷阱。网络可能会变得很复杂，我们没有讨论什么会出错，如何修复它，或者如何优化这个系统。</p><p id="0f85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有兴趣了解更多，查看下面的一些资源，或者发邮件给info@gravitl.com<a class="ae nk" href="mailto:info@gravitl.com" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="7075" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">资源</strong></h1><div class="nt nu gp gr nv nw"><a href="https://github.com/gravitl/netmaker" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">gravitl/netmaker</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">通过安全、快速的专用网络将任何计算机连接在一起，并从一个中心管理多个网络…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok jw nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://microk8s.io" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">MicroK8s -面向开发人员、edge和物联网的零运营Kubernetes | MicroK8s</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">面向开发人员、云、集群、工作站、边缘和物联网的低运营成本、最小生产量Kubernetes。为…选择平台</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">microk8s.io</p></div></div><div class="of l"><div class="ol l oh oi oj of ok jw nw"/></div></div></a></div><p id="c8d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nk" href="https://gravitl.com/netmaker" rel="noopener ugc nofollow" target="_blank">https://gravitl.com/netmaker</a></p><p id="dadf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nk" href="https://www.wireguard.com/" rel="noopener ugc nofollow" target="_blank">https://www.wireguard.com</a></p><p id="a286" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mu"> WireGuard和WireGuard徽标是Jason A. Donenfeld的注册商标。</em></p></div></div>    
</body>
</html>