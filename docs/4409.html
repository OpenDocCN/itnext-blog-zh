<html>
<head>
<title>Docker and Kubernetes — root vs. privileged</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker和Kubernetes —根用户与特权用户</h1>
<blockquote>原文：<a href="https://itnext.io/docker-and-kubernetes-root-vs-privileged-9d2a37453dec?source=collection_archive---------0-----------------------#2020-06-25">https://itnext.io/docker-and-kubernetes-root-vs-privileged-9d2a37453dec?source=collection_archive---------0-----------------------#2020-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="51a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们中的大多数人熟悉Unix系统，如macOS或Linux，习惯于通过使用<code class="fe ko kp kq kr b">sudo</code>随意提升我们的特权给<code class="fe ko kp kq kr b">root</code>用户。这通常发生在调试开发工具或试图编辑受保护目录中的文件时。对于很多人(包括我)来说，在第一次尝试后尝试一个不成功的命令就像<code class="fe ko kp kq kr b">sudo</code>一样几乎是默认的行为。).</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/909b26ac06cebed5ea9297c7ea863116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Ouvnp4QvbTVDIxb"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">理解Docker安全性的基础是理解容器实际上是什么(提示:不是VM的！)</figcaption></figure><p id="3ab8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker提供了一个看似相似的<code class="fe ko kp kq kr b">--privileged</code>标志，实际上与普通的<code class="fe ko kp kq kr b">sudo</code>用法有很大的不同，这可能会让你的应用程序面临不必要的风险。我将向您展示这与以<code class="fe ko kp kq kr b">root</code>身份运行有多大的不同(以及如何避免以root身份运行！)以及特权的实际含义。</p><h1 id="606b" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><strong class="ak">以根用户身份运行</strong></h1><p id="d2ba" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">Docker允许隔离其主机操作系统上的进程、功能和文件系统，出于实际原因，大多数容器实际上默认作为<code class="fe ko kp kq kr b">root</code>运行。举例来说，我将在撰写本文时选取DockerHub上最受欢迎的三张图片，以防您好奇，寻找指定的用户以及用户ID:</p><p id="30e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mm" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Postgres: </strong> </a></p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="c613" class="mr lk it kr b gy ms mt l mu mv">$ docker run -it postgres<br/># whoami<br/>root<br/># id -u<br/>0</span></pre><p id="94a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mm" href="https://hub.docker.com/_/couchbase" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"/></a></p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="7286" class="mr lk it kr b gy ms mt l mu mv">$ docker run -it couchbase sh<br/># whoami<br/>root<br/># id -u<br/>0</span></pre><p id="ecf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mm" href="https://hub.docker.com/_/alpine" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">高山:</strong> </a></p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="e5a7" class="mr lk it kr b gy ms mt l mu mv">$ docker run -it alpine sh<br/># whoami<br/>root<br/># id -u<br/>0</span></pre><p id="7765" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，默认情况下，大多数映像都以root用户身份运行。这通常允许更容易的调试，特别是如果你打算<code class="fe ko kp kq kr b">exec</code>进入容器。虽然<code class="fe ko kp kq kr b">root</code>用户附带了<a class="ae mm" href="https://docs.docker.com/engine/security/security/#linux-kernel-capabilities" rel="noopener ugc nofollow" target="_blank">非常有限的Linux功能</a>，但是最好避免以root身份运行。</p><h1 id="cc55" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><strong class="ak">避免以Root身份运行</strong></h1><p id="9647" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">虽然在容器内部运行<code class="fe ko kp kq kr b">root</code>实际上很正常，但是如果你试图强化你的容器，还是应该避免。首先，它违反了最小特权原则。其次，从技术上讲，容器将是运行Docker命令的同一个用户名称空间的一部分，如果容器能够转义，它将可以访问相同的资源，如卷和套接字。</p><p id="c39b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有两种方法可以避免以root用户身份运行:</p><p id="6d56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过调整<a class="ae mm" href="https://docs.docker.com/engine/reference/builder/#user" rel="noopener ugc nofollow" target="_blank">docker文件以使用特定用户</a>:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="9b26" class="mr lk it kr b gy ms mt l mu mv">// Dockerfile</span><span id="435b" class="mr lk it kr b gy mw mt l mu mv">FROM microsoft/windowsservercore<br/># Create Windows user in the container<br/>RUN net user /add patrick<br/># Set it for subsequent commands<br/>USER patrick</span></pre><p id="ff20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者<a class="ae mm" href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" rel="noopener ugc nofollow" target="_blank">在运行时覆盖用户ID:</a></p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="1d1d" class="mr lk it kr b gy ms mt l mu mv">$ docker run -it --user 4000 postgres sh<br/># whoami<br/>whoami: cannot find name for user ID 4000<br/># id -u<br/>4000</span></pre><h1 id="44e3" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><strong class="ak">特权阶层怎么样？</strong></h1><p id="1338" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated"><code class="fe ko kp kq kr b">—-privileged</code>标志将我们前面看到的用户ID 0直接映射到主机的用户ID 0，并允许它自由访问它选择的任何系统调用。你看，在正常操作中，即使容器内有<code class="fe ko kp kq kr b">root</code>，Docker也会限制容器的<a class="ae mm" href="https://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener ugc nofollow" target="_blank"> Linux功能</a>。例如，这种限制包括像<strong class="js iu"> CAP_AUDIT_WRITE </strong>这样的东西，它允许覆盖内核的审计日志——这是您的容器化工作负载极不可能需要的能力。实际上，特权应该只在你真正需要它的特定设置中使用，简而言之，它让容器访问主机(作为root)可以做的几乎所有事情。本质上，这是一张逃脱容器所包含的文件系统、进程、套接字和其他包含项目的免费通行证。它有特定的用例，比如Docker 中的<a class="ae mm" href="https://www.docker.com/blog/docker-can-now-run-within-docker/#:~:text=One%20of%20the%20(many!),kernel%20features%20and%20device%20access." rel="noopener ugc nofollow" target="_blank"> Docker，其他CI/CD工具需求(Docker容器内部需要Docker守护进程)，以及需要极端联网的地方。即便如此，还是有办法避免它——例如，GitLab提出了一种由谷歌容器工具创建的名为</a><a class="ae mm" href="https://docs.gitlab.com/ee/ci/docker/using_kaniko.html" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>的特权pod的替代方案。此外，<a class="ae mm" href="https://www.nestybox.com/" rel="noopener ugc nofollow" target="_blank"> NestyBox </a>产品为用户提供了<a class="ae mm" href="https://medium.com/@ctalledo/secure-docker-in-docker-with-nestybox-529c5c419582" rel="noopener">安全高效的Docker体验。</a></p><p id="f610" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个使用Ubuntu映像的例子(在VM内部，所以我们不能破坏任何东西):</p><p id="c379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有特权:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="6091" class="mr lk it kr b gy ms mt l mu mv">$ docker run -it ubuntu sh<br/># whoami<br/>root <strong class="kr iu"><em class="li"># Notice here, we are still root!</em></strong><br/># id -u<br/>0<br/># hostname<br/>382f1c400bd<br/># sysctl kernel.hostname=Attacker<br/>sysctl: setting key "kernel.hostname": Read-only file system  <strong class="kr iu"><em class="li"># Yet we can't do this</em></strong></span></pre><p id="724f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">拥有特权:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="3771" class="mr lk it kr b gy ms mt l mu mv">$ docker run -it --privileged ubuntu sh<br/># whoami<br/>root. <strong class="kr iu"><em class="li"># Root again</em></strong><br/># id -u<br/>0<br/># hostname<br/>86c62e9bba5e<br/># sysctl kernel.hostname=Attacker<br/>kernel.hostname = Attacker <strong class="kr iu"><em class="li"># Except now we are privileged</em></strong><br/># hostname<br/>Attacker </span></pre><p id="b225" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes通过<a class="ae mm" href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" rel="noopener ugc nofollow" target="_blank">安全上下文</a>提供相同的功能:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="3394" class="mr lk it kr b gy ms mt l mu mv">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: nginx<br/>spec:<br/>  containers:<br/>  - name: nginx<br/>    image: nginx<br/>    <strong class="kr iu">securityContext:<br/>      privileged: true</strong></span></pre><p id="3de9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，Kubernetes包含一个名为<a class="ae mm" href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/" rel="noopener ugc nofollow" target="_blank"> PodSecurityPolicies </a>的强制机制，它是一个准入控制器(也就是Kubernetes在允许容器进入集群之前检查的东西)。一个强烈推荐的政策是不允许特权舱:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="b551" class="mr lk it kr b gy ms mt l mu mv">apiVersion: policy/v1beta1<br/>kind: PodSecurityPolicy<br/>metadata:<br/>  name: example<br/>spec:<br/>  <strong class="kr iu">privileged: false </strong> <em class="li"># Don't allow privileged pods!</em></span></pre><h1 id="d1fe" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><strong class="ak">总结</strong></h1><p id="5fd4" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">希望在本文结束时，您对<code class="fe ko kp kq kr b">root</code>和<code class="fe ko kp kq kr b">--privileged</code>标志有了更多的了解，以及它们与“主机”操作系统的关系，并且无论您是试图加强容器的安全性还是调试某个问题，您都知道足够多的信息来保护您的应用程序的安全。防御性安全完全是关于深度防御(像洋葱一样的层)和减少您的攻击面——通过不以root身份运行、不以特权身份运行，以及添加SecurityContext和PodSecurityPolicies是实现更高容器安全性的四个重要层。如果你喜欢阅读这类东西，请一定要关注我。如果你想问任何问题、评论或其他任何事情，请给我发电子邮件到bryant.hagadorn@gmail.com。谢谢！同样，请在推特上关注我:<a class="ae mm" href="https://twitter.com/BryantHagadorn" rel="noopener ugc nofollow" target="_blank">https://twitter.com/BryantHagadorn</a></p></div></div>    
</body>
</html>