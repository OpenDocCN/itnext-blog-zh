<html>
<head>
<title>Clean architecture - making Node.js API shine!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净的架构——让Node.js API大放异彩！</h1>
<blockquote>原文：<a href="https://itnext.io/clean-architecture-making-node-js-api-shine-38134b8f9b5c?source=collection_archive---------2-----------------------#2021-09-06">https://itnext.io/clean-architecture-making-node-js-api-shine-38134b8f9b5c?source=collection_archive---------2-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/35dc78471fe522b4de0f6c5acfb83f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-CKN91ACp-tsJupwkUi9Q.jpeg"/></div></div></figure><p id="030a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我作为一名原生Android开发人员工作时，我第一次遇到了<a class="ae kw" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净架构</a>的主题，在那里我们花了很多时间思考架构和设计模式。当我过渡到JavaScript堆栈时，我注意到许多生产项目没有对代码架构投入太多的思考。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="f064" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">想做关于Clean architecture和Node.js的实践培训？</strong> <br/>邀请你来看看我创建的课程，在我的指导下，你将在Node.js中基于干净架构原则编写一个完整的系统。<br/> <a class="ae kw" href="https://www.udemy.com/course/nodejs-api-with-clean-architecture/?referralCode=B0B06E239941EF0916A2" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="le">为Node.js API Bootcamp使用干净的架构</em> </strong> </a></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="fd74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">那么，我们为什么要考虑代码架构呢？</strong></p><p id="27d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">代码可伸缩性:</strong>如果你没有正确地构建代码，那么添加一个新特性是具有挑战性的——为了做出改变，你会发现自己违反了许多坚实的原则。</p><p id="fccb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可维护性:</strong>让我们假设一些系统需求改变了，或者你决定改变你的一个框架或者库。当所有的系统组件都相互分离时，这种转换会很简单，很少发生重大变化。</p><p id="894c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可测试性:</strong>我们需要使用不同类型的测试来测试我们的应用程序，其中包括单元、集成、功能、冒烟和e2e测试。元素的分离有助于更容易的测试，我们可以用特定的注入属性独立地测试每个模块。</p><p id="13fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可读性:开发人员对代码的可读性有不同的看法，但是每个人都会同意，当你的代码与单一的明确定义的职责分离时，可读性会增加。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="6614" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看下面的例子，在许多生产项目中都能找到，让我们分析一下这段代码有问题的地方。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="17c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">代码可伸缩性:</strong>假设我们想要在模型执行之前添加ID参数的验证，我们将需要在请求处理程序中添加验证逻辑，这将打破单一责任原则，因为控制器的责任是解析请求数据并回复相关结果。<br/> <strong class="ka ir">解决方案:</strong>调用负责处理这个请求的服务层。</p><p id="40dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可维护性:</strong>假设出于某种原因，您决定将数据库层更改为Azure Cosmos DB而不是Mongo DB，在这种情况下，除了许多数据迁移之外，您还需要更改许多代码库。<br/> <strong class="ka ir">解决方案:</strong>准备一个并行存储库层，它将执行Cosmos DB而不是Mongo DB，当它准备好并经过测试后，只需用一些依赖注入机制来替换它。该解决方案将允许您使用某种切换机制在类似生产的环境中安全地并行测试解决方案。</p><p id="c5d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可测试性:</strong>为了测试这个函数，您需要使用某种形式的模拟数据库，并使用chai-http之类的东西发出一个假请求。这里的问题是这个测试很难初始化，并且需要很长时间来执行。<br/>这里的第二个问题是，你不能独立测试这段代码的每一部分。<br/> <strong class="ka ir">解决方案:</strong>这个控制器应该调用一个负责处理请求的服务层。一旦你做到了这一点，测试应该很容易:只要用你期望的数据响应创建一个模拟服务，并独立地测试服务逻辑——这样你就把业务逻辑从繁琐的测试获取技术(在本例中是HTTP)中分离出来了。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="22ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，我们如何在代码中使用干净的架构呢？</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ll"><img src="../Images/ff36f4e528c95bd9a6a9d32eeb1569a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phecRia6It8AnwlFjhjx2w.jpeg"/></div></div></figure><p id="f644" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">干净架构是一种软件设计哲学，提倡代码层的分离。对于一个基本的Node.js API项目，我们将使用上图中形象化的层作为环的隐喻概念来快速检查这一原理。</p><p id="0d46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">黄色层:</strong>Web服务器层——包括路由，将执行控制器。</p><p id="e9fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">红色层:</strong>控制器层，将接收用户的数据，执行相关的用例，并编译结构化的响应。</p><p id="5a1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">绿色层:</strong>用例层，将接收用户数据并处理该请求，包括验证和外部系统报告(如Kafka或Kibana)，它将从实体存储库层接收数据作为事实的来源。</p><p id="40aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">蓝色层:</strong>实体层，将包括实体和实体存储库——只有这一层将进行数据库查询，并访问其他服务或第三方以获取数据。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lm"><img src="../Images/4f5989caffe0f68fccabf437c8785641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvAJXmzr2LtjH-N5dwS2hw.jpeg"/></div></div></figure><p id="8493" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">代码依赖规则:</strong>代码依赖只能从外层向内移动。内层的代码可能不知道外层的功能。外层中的变量、函数和类不能在更内部的级别中提及。</p><p id="5db9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">依赖注入:</strong>为了灵活地处理项目依赖，使用任何依赖注入机制，它可以基于特定的配置注入您的层。</p><p id="b569" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">响应契约:</strong>为了让你的API可预测，使用响应契约层，这意味着每一个响应都要结构化，包括错误。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="eb4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想了解如何在实践中使用响应契约层，请加入我的udemy.com课程</p><p id="b229" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.udemy.com/course/nodejs-api-with-clean-architecture/?referralCode=B0B06E239941EF0916A2" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="le">对Node.js API Bootcamp使用干净的架构</em> </strong> </a></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="57d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住——干净的架构是一个建议，而不是规则！</p><p id="4f05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于程序员来说，干净的架构第一次遇到这种哲学可能是困难和耗时的，如果你没有时间做你的项目，就使用一个基本的关注点逻辑分离。</p><p id="1bb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">控制器</strong>将接收用户的请求，并用结构化的响应进行回复。</p><p id="1984" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">服务</strong>将处理用户的请求，包括验证和第三方报告，并将使用存储库层作为事实来源接收数据。</p><p id="0c46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">存储库</strong>将作为应用程序的事实来源，包括数据库和外部服务查询。</p><blockquote class="ln lo lp"><p id="9363" class="jy jz le ka b kb kc kd ke kf kg kh ki lq kk kl km lr ko kp kq ls ks kt ku kv ij bi translated">“你的架构应该告诉读者关于系统的信息，而不是你在系统中使用的框架。”——Robert c . Martin。</p></blockquote></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="82f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">结论</strong></p><p id="95f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">良好的架构是构建模块化、可伸缩、可维护和可测试的应用程序的关键。最流行的架构之一是干净的架构，但是每个项目都有特定的需求。只要开始考虑关注点的分离，以及如何不把你的代码写成一个大块，你就会得到一个好的项目，它维护起来并不可怕，而且易于测试。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="b5d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">想了解更多信息？邀请你看一下我创建的课程，在我的指导下，你将基于干净架构原则用Node.js编写一个完整的系统</strong></p><p id="bc25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.udemy.com/course/nodejs-api-with-clean-architecture/?referralCode=B0B06E239941EF0916A2" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="le">使用干净的架构进行node . js API boot camp</em></strong></a></p><p id="8c79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">黑客快乐！:)</p></div></div>    
</body>
</html>