<html>
<head>
<title>Content Management with Gatsby, Contentful &amp; Netlify</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gatsby、Contentful &amp; Netlify的内容管理</h1>
<blockquote>原文：<a href="https://itnext.io/content-management-with-gatsby-netlify-and-contentful-70f03de41602?source=collection_archive---------2-----------------------#2019-02-18">https://itnext.io/content-management-with-gatsby-netlify-and-contentful-70f03de41602?source=collection_archive---------2-----------------------#2019-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="57de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Gatsby、Contentful、Netlify——内容管理成功的三重威胁</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/89c9cb816b6e28c5271f0634ff307628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c43gxz1HaCgmGaF58FJg5w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">盖茨比，心满意足，胜利在望！</figcaption></figure><p id="fdb5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我已经使用Gatsby个月了，它很快成为我构建静态站点的首选。优势是巨大的。您将获得:</p><ul class=""><li id="50cd" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">许多现成的配置和样板文件。</li><li id="be28" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">速度，搜索引擎优化和性能优化。</li><li id="901a" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">一个伟大的社区，伟大的文档和一个成长中的插件生态系统。</li><li id="4051" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">我个人最喜欢的是——编写所有我想要的React &amp; GraphQL代码。</li></ul><p id="2622" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">至少可以说，这是一次很棒的开发体验。然而，在构建静态站点时，选择工具的一个主要考虑因素是站点上的内容如何更新。许多老的平台已经以这样或那样的方式解决了这个问题，Wordpress是其中最受欢迎的，但是使用Gatsby、Netlify和Contentful的三重威胁，我们可以建立一个很好的替代传统CMS工具的工具，同时保留我们的SEO兼容性。</p><p id="0cff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文将向您展示如何建立一个系统来管理Gatsby站点任何页面上的内容。在我们的例子中，我们将使用Gatsby强大的<code class="fe mf mg mh mi b">gatsby-node</code> API从Contentful获取内容并动态生成页面。您还可以通过提供的<code class="fe mf mg mh mi b">graphql</code>查询在任何现有页面上使用内容丰富的数据。</p><p id="5d00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将是一个漫长的过程，所以伸展你的双腿，喝杯咖啡或你选择的提神饮料，让我们开始吧。</p><p id="2155" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你需要<code class="fe mf mg mh mi b">gatsby-cli</code>工具来开始。在您的终端中运行<code class="fe mf mg mh mi b">npm i -g gatsby</code>,一旦运行完毕，使用</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="7971" class="mn mo iq mi b gy mp mq l mr ms">$ gatsby new gatsby-contentul-blog</span></pre><p id="dd55" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将在名为<code class="fe mf mg mh mi b">gatsby-contentful-blog</code>的文件夹中创建一个新的Gatsby项目。<code class="fe mf mg mh mi b">cd</code>进入新项目并运行<code class="fe mf mg mh mi b">gatsby develop</code>。现在你有了默认的Gatsby starter主页:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/ef58b97222ead7b6bab159502c825ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbgvljiIhmEl8MfiyW1Vhw.png"/></div></div></figure><p id="9c70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在您最喜欢的文本编辑器中打开项目，并导航至<code class="fe mf mg mh mi b">pages</code>文件夹。让我们调整一下<code class="fe mf mg mh mi b">index.js</code>中的一些内容:(你可以复制并粘贴进来)</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="3dd5" class="mn mo iq mi b gy mp mq l mr ms">import React from "react";<br/>import { Link } from "gatsby";</span><span id="3ded" class="mn mo iq mi b gy mu mq l mr ms">import Layout from "../components/layout";<br/>import Image from "../components/image";<br/>import SEO from "../components/seo";<br/>import "./index.css";</span><span id="21e3" class="mn mo iq mi b gy mu mq l mr ms">const IndexPage = () =&gt; (<br/>  &lt;Layout&gt;<br/>    &lt;SEO title="Home" keywords={[`gatsby`, `application`, `react`]} /&gt;<br/>    &lt;div className="home"&gt;<br/>      &lt;h1&gt;Hello There&lt;/h1&gt;<br/>      &lt;p&gt;Welcome my awesome blog&lt;/p&gt;<br/>      &lt;div&gt;<br/>        &lt;div<br/>          style={{<br/>            maxWidth: `300px`,<br/>            margin: "0 auto 1.45rem"<br/>          }}<br/>        &gt;<br/>          &lt;Image /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>      &lt;Link to="/blogposts/"&gt;View all posts&lt;/Link&gt;<br/>    &lt;/div&gt;<br/>  &lt;/Layout&gt;<br/>);</span><span id="4004" class="mn mo iq mi b gy mu mq l mr ms">export default IndexPage;</span></pre><p id="06dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，找到<code class="fe mf mg mh mi b">page-2.js</code>，将文件名改为<code class="fe mf mg mh mi b">blogposts.js</code>。Gatsby使用<code class="fe mf mg mh mi b">pages</code>文件夹中任何文件的名称作为路由名称，并将使导出的React组件在所述路由上可用。这意味着我们现在有了一条<code class="fe mf mg mh mi b">/blogposts</code>路线。我们稍后将回到这个文件，但同时，让我们也改变<code class="fe mf mg mh mi b">gatsby-config.js</code>文件中的几个值。该文件位于项目<code class="fe mf mg mh mi b">root</code>中。</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="e88e" class="mn mo iq mi b gy mp mq l mr ms">siteMetadata: {<br/>    title: `My Awesome Blog`,<br/>    description: `An awesome blog displaying my awesome posts.`,<br/>    author: `YOUR_NAME`,<br/>},</span></pre><p id="2402" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了！我们现在已经建立了基本的站点。因此，我们将转到<a class="ae mv" href="https://www.contentful.com/" rel="noopener ugc nofollow" target="_blank"> Contentful </a>网站并创建一个新帐户。这是相当无痛的，你应该在任何时间设置。默认情况下，它们提供了一个示例空间，但是让我们为项目创建一个新的空间。</p><p id="6b06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">打开工具条，点击<strong class="kx ir">创建空间</strong>。选择免费选项，给你的共享空间起一个名字。我会把我的名字叫做<strong class="kx ir">盖茨比博客</strong>。选择空白空间选项，点击<strong class="kx ir">进行确认，</strong>确认您的选项。</p><p id="e26f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">确认后，在仪表板上，单击标题中的“创建内容类型”按钮或“内容模型”按钮，并填写出现的表单。让我们调用内容类型<strong class="kx ir"> Blog Post </strong>并保持API标识符不变。输入您想要的任何描述。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1d2bc5f555bc54290f26063dc2956e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*9tNdtBPtBqcsG5rpyHKYbw.png"/></div></figure><p id="56e3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建内容类型后，我们将开始向它添加一些字段，字段是我们内容的构建块。例如，如果你有一篇博客文章，一些字段可以是标题<em class="mx"/>、<em class="mx">正文</em>、<em class="mx">标签</em>和<em class="mx">图片</em>。这将生成一个表单，稍后当我们开始创建实际的博客帖子时，您可以填写该表单。按照下面的步骤创建一个<em class="mx">标题</em>字段。</p><ul class=""><li id="efb8" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">点击仪表板右侧的<strong class="kx ir">添加字段</strong>按钮。</li><li id="1c16" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">选择<strong class="kx ir">文本</strong>作为您想要的字段类型。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/d8cb12a0352b90acccad40d581c1ca55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*fU0B6MH0_eA05Rx_8dNYJw.png"/></div></figure><ul class=""><li id="d5c1" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">在下一个屏幕的表单中，输入<strong class="kx ir"> title </strong>作为名称，然后点击create。</li><li id="b6bd" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">添加另一个名为<strong class="kx ir">正文</strong>的文本字段，但是在选择<strong class="kx ir">文本</strong>之后，从下面屏幕上的单选按钮中选择<strong class="kx ir">长扩展</strong>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/73436210497cbc5e346075345df33c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qP8DGKHvp7iF_ChmANiJcg.png"/></div></div></figure><ul class=""><li id="21f0" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">添加另一个字段。选择媒体作为类型，而不是文本，并将其命名为图像。</li><li id="39ad" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">通过选择文本作为类型，添加一个<em class="mx">标签</em>字段。给它标签作为名称，然后选择下面屏幕上的列表选项，因为我们将在该字段中存储一个<em class="mx">标签</em>的列表。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/e5f7b2e80ed065054198e5420536aab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0wpzih4KYqg0E0pC32VPA.png"/></div></div></figure><ul class=""><li id="0c1a" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">最后，创建一个<em class="mx"> slug </em>字段。首先选择文本作为类型，并将其命名为slug。这一次，不是像上面那样单击Create，而是单击Create and Configure。在下一个屏幕上，转到Appearance选项卡，选择slug作为字段应该显示的方式。此外，在验证选项卡中选择唯一字段，以确保没有两个博客帖子具有相同的slugs</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/19f3b68ac7760d93f4af3117e704ff68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWOc-abYP2qkdEFBx9tuXA.png"/></div></div></figure><p id="2089" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您的内容模型现在应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/967e19927d153eb3fe8853883f6e841f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wep8DqyueFPu1ThhUFOJg.png"/></div></div></figure><p id="6ec2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">内容模型就像我们的实际内容将遵循的模式。您可以创建所有类型的模型，例如案例研究、博客文章、产品数据、页面内容等等。</p><p id="318b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">保存您的更改，点击页面顶部的<strong class="kx ir">内容</strong>按钮，并选择<strong class="kx ir">添加博客文章</strong>。我将添加三个带有占位符数据的帖子，您可以随意添加。对于图片，你可以从unsplash.com获得一些免费的、开放的许可。注意当您输入标题时，<code class="fe mf mg mh mi b">slug</code>字段是如何自动生成的？这个以后会派上用场的。</p><p id="24e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">厉害！这是很多，但我们已经走了一半了…</p><p id="7621" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了第一批博客文章，是时候把它们放到我们的盖茨比网站上了。为此，我们将依靠Gatsby出色的GraphQL API来获取数据。接下来让我们继续。</p><p id="ee0b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Contentful中进入您的设置，点击下拉菜单中的<strong class="kx ir"> API键</strong>选项。创建一个新的API密钥，并将详细信息保存在附近。</p><p id="9109" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回到你的终端，安装Gatsby插件，我们需要开始拉我们的内容数据。</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="8f33" class="mn mo iq mi b gy mp mq l mr ms">$ yarn add gatsby-source-contentful</span></pre><p id="8b88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用Contentful的<em class="mx">内容交付API </em>，因为我们只想检索已发布的数据，所以一定要获取<em class="mx">内容交付API </em>键，而不是<em class="mx">内容预览API键</em>。</p><p id="9e2a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在您的<code class="fe mf mg mh mi b">gatsby-config.js</code>文件中，将配置对象添加到<code class="fe mf mg mh mi b">plugins</code>数组中:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="c16b" class="mn mo iq mi b gy mp mq l mr ms">plugins: [<br/>    ...<br/>    {<br/>      resolve: `gatsby-source-contentful`,<br/>      options: {<br/>        spaceId: `YOUR_SPACE_ID`,<br/>        accessToken: `YOUR_CONTENT_DELIVERY_API_KEY`<br/>      }<br/>    }<br/>],</span></pre><p id="6380" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，您应该重新启动开发服务器，让新的配置生效。当服务器重启时，<code class="fe mf mg mh mi b">gatsby-source-contentful</code>的GraphQL查询将可以使用。</p><p id="6fee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过使用Gatsby为我们提供的GraphiQL playground，我们可以很容易地测试一切是否正常。在浏览器中打开<a class="ae mv" href="http://localhost:8000/___graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/_ _ _ graph QL</a>并运行下面的查询，将其粘贴到页面的左侧窗口中。查询名为<code class="fe mf mg mh mi b">allContentfulBlogPost</code>，因为我们的内容模型名为<strong class="kx ir"> Blog Pos </strong> t。如果我们将其命名为<strong class="kx ir"> Product </strong>或<strong class="kx ir"> Case Study </strong>，那么提供给我们的查询将是<code class="fe mf mg mh mi b">allContentfulProduct</code>或<code class="fe mf mg mh mi b">allContentfulCaseStudy</code>。</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="9db7" class="mn mo iq mi b gy mp mq l mr ms">{<br/>  allContentfulBlogPost {<br/>    edges {<br/>      node {<br/>        id<br/>	slug<br/>        title<br/>	tags<br/>        image {<br/>          file {<br/>            url<br/>          }         <br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="f56e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mf mg mh mi b">gatsby-source-contentful</code>插件使用我们在<code class="fe mf mg mh mi b">gatsby-config</code>文件中提供的键来处理从Contentful API获取的所有幕后操作。然后，它使我们可以使用语义命名的GraphQL查询。</p><p id="d8ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一切正常，您应该可以在GraphiQL窗口右侧的结果窗口中看到JSON格式的内容。</p><p id="699c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们已经将Gatsby博客与内容丰富的数据连接起来，我们就可以开始为博客构建页面了。盖茨比给我们提供了一个叫做<code class="fe mf mg mh mi b">gatsby-node.js</code>的文件。该文件可用于向您的站点动态添加页面。当Gatsby运行时，它会查看这里的代码，并创建您让它创建的任何页面。在<code class="fe mf mg mh mi b">gatsby-node.js</code>文件中，我们放置以下代码:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="3379" class="mn mo iq mi b gy mp mq l mr ms">const path = require(`path`);<br/>const slash = require(`slash`);</span><span id="15e3" class="mn mo iq mi b gy mu mq l mr ms">exports.createPages = ({ graphql, actions }) =&gt; {<br/>  const { createPage } = actions;<br/>  // we use the provided allContentfulBlogPost query to fetch the data from Contentful<br/>  return graphql(<br/>    `<br/>      {<br/>        allContentfulBlogPost {<br/>          edges {<br/>            node {<br/>              id<br/>              slug<br/>            }<br/>          }<br/>        }<br/>      }<br/>    `<br/>  ).then(result =&gt; {<br/>      if (result.errors) {<br/>        console.log("Error retrieving contentful data",      result.errors);<br/>      }</span><span id="cbd6" class="mn mo iq mi b gy mu mq l mr ms">      // Resolve the paths to our template<br/>      const blogPostTemplate = path.resolve("./src/templates/blogpost.js");</span><span id="e122" class="mn mo iq mi b gy mu mq l mr ms">      // Then for each result we create a page.<br/>      result.data.allContentfulBlogPost.edges.forEach(edge =&gt; {<br/>        createPage({<br/>          path: `/blogpost/${edge.node.slug}/`,<br/>          component: slash(blogPostTemplate),<br/>          context: {<br/>	    slug: edge.node.slug,<br/>            id: edge.node.id<br/>          }<br/>        });<br/>      });<br/>    })<br/>    .catch(error =&gt; {<br/>      console.log("Error retrieving contentful data", error);<br/>    });<br/>};</span></pre><p id="ba22" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该模块导出一个名为<code class="fe mf mg mh mi b">createPages</code>的函数。这个函数有两个参数graphql和一个actions对象。我们提取<code class="fe mf mg mh mi b">createPage</code>动作，然后调用我们之前在GraphiQL playground中运行的相同Graphql查询。我们获取这个结果，并为每个结果(每篇博文)调用<code class="fe mf mg mh mi b">createPage</code>函数。这个函数接受一个config对象，Gatsby在呈现页面时会读取这个对象。我们将路径设置为连接的字符串<code class="fe mf mg mh mi b">"/blogpost"</code>加上<code class="fe mf mg mh mi b">slug</code>。注意，我们还在<code class="fe mf mg mh mi b">./src/templates/blogpost.js</code>引用了一个模板文件，不用担心，我们很快就会创建那个文件。</p><p id="d941" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，关闭您的服务器并再次启动它。如果你进入一条像<code class="fe mf mg mh mi b"><a class="ae mv" href="http://localhost:8000/dskl;sfd/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/some-non-existent-route/</a></code>这样的无用路线，你会看到盖茨比的发展404页。这个页面有一个所有路线的列表，你可以看到新创建的页面已经设置好了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/75d67bf23c52c28a8c619c3002c27034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MDsb5QfV9Zix8NIXSjgpsw.png"/></div></div></figure><p id="84d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">明白我们为什么选择一个独特的废料场了吗？每个帖子必须有一个独特的路线，使用slugs看起来比在URL中使用无意义的ID字符串好得多。此外，由于Gatsby生成了一个静态网站，可以有一个网站地图，这是更好的搜索引擎优化有你的路线名称匹配你想排名的内容类型。</p><p id="cbeb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以专注于构建实际的页面了。</p><p id="cc7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在您的<code class="fe mf mg mh mi b">src</code>文件夹中创建一个<code class="fe mf mg mh mi b">templates</code>文件夹，并添加一个名为<code class="fe mf mg mh mi b">blogpost.js</code>的文件。这将是我们的模板组件，每次Gatsby调用<code class="fe mf mg mh mi b">gatsby-node.js</code>文件中的<code class="fe mf mg mh mi b">createPage</code>函数时都会用到它。</p><p id="ebaf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意</strong>:如果出现任何错误，请务必在此时重启服务器。我们正在做大量的配置工作，Gatsby可能需要重启才能正常运行。</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="8c6d" class="mn mo iq mi b gy mp mq l mr ms">import React from "react";<br/>import { Link, graphql } from "gatsby";<br/>import Layout from "../components/layout";<br/>import SEO from "../components/seo";</span><span id="aad9" class="mn mo iq mi b gy mu mq l mr ms">const BlogPost = ({ data }) =&gt; {<br/>  const { title, body, image, tags } = data.contentfulBlogPost;<br/>  return (<br/>    &lt;Layout&gt;<br/>      &lt;SEO title={title} /&gt;<br/>      &lt;div className="blogpost"&gt;<br/>        &lt;h1&gt;{title}&lt;/h1&gt;<br/>        &lt;img alt={title} src={image.file.url} /&gt;<br/>        &lt;div className="tags"&gt;<br/>          {tags.map(tag =&gt; (<br/>            &lt;span className="tag" key={tag}&gt;<br/>              {tag}<br/>            &lt;/span&gt;<br/>          ))}<br/>        &lt;/div&gt;<br/>        &lt;p className="body-text"&gt;{body.body}&lt;/p&gt;<br/>        &lt;Link to="/blogposts"&gt;View more posts&lt;/Link&gt;<br/>        &lt;Link to="/"&gt;Back to Home&lt;/Link&gt;<br/>      &lt;/div&gt;<br/>    &lt;/Layout&gt;<br/>  );<br/>};</span><span id="f5b5" class="mn mo iq mi b gy mu mq l mr ms">export default BlogPost;</span><span id="c76d" class="mn mo iq mi b gy mu mq l mr ms">export const pageQuery = graphql`<br/>  query($slug: String!) {<br/>    contentfulBlogPost(slug: { eq: $slug }) {<br/>      title<br/>      slug<br/>      body {<br/>        body<br/>      }<br/>      image {<br/>        file {<br/>          url<br/>        }<br/>      }<br/>      tags<br/>    }<br/>  }<br/>`;</span></pre><p id="4cb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在页面底部，我们导出一个Graphql查询。Gatsby将在运行时运行这个查询，并将一个<strong class="kx ir">数据</strong>属性传递给包含内容丰富的数据的<strong class="kx ir"> BlogPost </strong>。注意，在这种情况下，我们查询的是一个帖子，并将该段文字作为过滤器参数传递。我们基本上是在请求与slug ( <code class="fe mf mg mh mi b">contentfulBlogPost(slug: { eq: $slug })</code>)中传递的帖子相匹配的帖子。这段代码对我们来说是可用的，因为我们在<code class="fe mf mg mh mi b">gatsby-config.js</code>中将它作为页面上下文传入。</p><p id="4060" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">剩下的就是直截了当的反应。我们创建一个组件，并使用数据属性填充页面内容。我们还没有造型，但我们会得到一点。</p><p id="47ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在需要的是一个列出所有可用博客文章页面的页面。我们不能每次需要阅读博客文章的时候都去404页面！</p><p id="0997" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们回到这个项目开始时创建的<code class="fe mf mg mh mi b">pages</code>文件夹中的<code class="fe mf mg mh mi b">blogposts.js</code>文件，并对其进行调整。</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="2fdf" class="mn mo iq mi b gy mp mq l mr ms">import React from "react";<br/>import { Link, graphql } from "gatsby";</span><span id="2e47" class="mn mo iq mi b gy mu mq l mr ms">import Layout from "../components/layout";<br/>import SEO from "../components/seo";</span><span id="4f20" class="mn mo iq mi b gy mu mq l mr ms">const BlogPosts = ({ data }) =&gt; {<br/>  const blogPosts = data.allContentfulBlogPost.edges;<br/>  return (<br/>    &lt;Layout&gt;<br/>      &lt;SEO title="Blog posts" /&gt;<br/>      &lt;h1&gt;{"Here's a list of all blogposts!"}&lt;/h1&gt;<br/>      &lt;div className="blogposts"&gt;<br/>        {blogPosts.map(({ node: post }) =&gt; (<br/>          &lt;div key={post.id}&gt;<br/>            &lt;Link to={`/blogpost/${post.slug}`}&gt;{post.title}&lt;/Link&gt;<br/>          &lt;/div&gt;<br/>        ))}<br/>        &lt;span className="mgBtm__24" /&gt;<br/>        &lt;Link to="/"&gt;Go back to the homepage&lt;/Link&gt;<br/>      &lt;/div&gt;<br/>    &lt;/Layout&gt;<br/>  );<br/>};</span><span id="bb4e" class="mn mo iq mi b gy mu mq l mr ms">export default BlogPosts;</span><span id="a2dd" class="mn mo iq mi b gy mu mq l mr ms">export const query = graphql`<br/>  query BlogPostsPageQuery {<br/>    allContentfulBlogPost(limit: 1000) {<br/>      edges {<br/>        node {<br/>          id<br/>          title<br/>          slug<br/>          body {<br/>            body<br/>          }<br/>          image {<br/>            file {<br/>              url<br/>            }<br/>          }<br/>          tags<br/>        }<br/>      }<br/>    }<br/>  }<br/>`;</span></pre><p id="f10d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">模式现在应该很熟悉了。</p><p id="5279" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在页面底部，我们导出一个GraphQL查询。该查询与我们在<code class="fe mf mg mh mi b">gatsby-node.js</code>中用来生成blogpost页面的查询相同。它提取所有<strong class="kx ir"> BlogPost </strong>类型的内容数据。Gatsby在数据对象中向我们提供查询结果，就像使用单个blogpost页面一样。但是对于这个页面，我们只需要<code class="fe mf mg mh mi b">id</code>、<code class="fe mf mg mh mi b">title</code>、<code class="fe mf mg mh mi b">slug</code>和<code class="fe mf mg mh mi b">tags</code>字段。</p><p id="0845" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这一点上，让我们添加一些非常基本的造型。为了这个例子，我们将只在<code class="fe mf mg mh mi b">layout.css</code>文件的末尾添加几行，但是在现实世界的项目中，您可能不希望这样做。用你觉得舒服的任何方法。</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="7f23" class="mn mo iq mi b gy mp mq l mr ms">/* Add these lines to the end of the layout.css file */<br/>@import url("&lt;https://fonts.googleapis.com/css?family=Open+Sans:300,400,600&gt;");<br/>html {<br/>  font-family: "Open Sans";<br/>}</span><span id="895f" class="mn mo iq mi b gy mu mq l mr ms">header {<br/>  /* We use !important here to override<br/>  the inline styles just for this example.<br/>  in production code, avoid using it where<br/>  possible*/<br/>  background-color: cadetblue !important;<br/>}</span><span id="ee47" class="mn mo iq mi b gy mu mq l mr ms">header div {<br/>  text-align: center;<br/>}</span><span id="d94d" class="mn mo iq mi b gy mu mq l mr ms">header div h1 {<br/>  font-weight: 600;<br/>}</span><span id="2da7" class="mn mo iq mi b gy mu mq l mr ms">.home {<br/>  text-align: center;<br/>}</span><span id="c23b" class="mn mo iq mi b gy mu mq l mr ms">.home img {<br/>  margin: auto;<br/>}</span><span id="1720" class="mn mo iq mi b gy mu mq l mr ms">.blogpost {<br/>  font-size: 18px;<br/>  width: 35em;<br/>}</span><span id="45e2" class="mn mo iq mi b gy mu mq l mr ms">h1 {<br/>  font-weight: 400;<br/>  margin-top: 48px;<br/>  font-family: "Open Sans";<br/>}</span><span id="cd3e" class="mn mo iq mi b gy mu mq l mr ms">img {<br/>  margin-bottom: 8px;<br/>}</span><span id="be30" class="mn mo iq mi b gy mu mq l mr ms">.tags {<br/>  margin-bottom: 24px;<br/>}</span><span id="ccc4" class="mn mo iq mi b gy mu mq l mr ms">.tags span.tag {<br/>  font-weight: bold;<br/>  margin-right: 8px;<br/>  background: cadetblue;<br/>  padding: 2px 12px;<br/>  border-radius: 4px;<br/>  color: white;<br/>  font-size: 12px;<br/>}</span><span id="d3ca" class="mn mo iq mi b gy mu mq l mr ms">.blogpost p.body-text {<br/>  margin-bottom: 32px;<br/>}</span><span id="d953" class="mn mo iq mi b gy mu mq l mr ms">p {<br/>  line-height: 1.8;<br/>  color: #929191;<br/>  font-weight: 300;<br/>}</span><span id="1268" class="mn mo iq mi b gy mu mq l mr ms">.blogpost a {<br/>  display: block;<br/>  margin-bottom: 8px;<br/>}</span><span id="5dfd" class="mn mo iq mi b gy mu mq l mr ms">.blogposts a {<br/>  display: block;<br/>  margin-bottom: 8px;<br/>}</span><span id="7231" class="mn mo iq mi b gy mu mq l mr ms">footer {<br/>  margin-top: 120px;<br/>}</span><span id="ca29" class="mn mo iq mi b gy mu mq l mr ms">.mgBtm__24 {<br/>  display: inline-block;<br/>  margin-bottom: 24px;<br/>}</span></pre><p id="98ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了自己的博客，下一步就是部署它，让全世界都能看到它。有了Netlify，这变得超级简单。Netlify与GitHub整合得非常好。在您的终端中，运行:</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="b9b1" class="mn mo iq mi b gy mp mq l mr ms">$ git init</span></pre><p id="27ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">转到您的GitHub并创建一个名为<code class="fe mf mg mh mi b">gatsby-contentful-blog-starter</code>的新repo，然后按照命令推送至一个现有的存储库。</p><pre class="kg kh ki kj gt mj mi mk ml aw mm bi"><span id="9c03" class="mn mo iq mi b gy mp mq l mr ms">$ git add .<br/>$ git commit -m 'initial commit'<br/>$ git remote add origin git@github.com:YOUR_GITUHB_USERNAME/gatsby-contentful-blog-starter.git<br/>$ git push -u origin master</span></pre><p id="ae40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">把你的代码推送到GitHub，然后去<a class="ae mv" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank"> Netlify </a>创建一个账户。在您的仪表板中，点击Git 中的“<strong class="kx ir">新网站”，选择<strong class="kx ir"> GitHub </strong>作为提供商，并通过授权流程选择您觉得合适的选项。</strong></p><p id="2112" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，从提供的列表中选择一个回购。如果您找不到我们刚刚创建的回购，请选择<strong class="kx ir">在GitHub </strong>上配置Netlify应用程序。这将打开一个弹出窗口，允许您选择要授权用于Netlify的回购。按照提示，直到你找到回购。选择我们的博客项目后，您将被重定向到Netlify deploy屏幕，现在您应该能够选择<code class="fe mf mg mh mi b">gatsby-contentful-blog-starter</code> repo。如你所见，Netlify知道如何建立Gatsby站点，所以你只需点击页面末端的<strong class="kx ir">部署站点</strong>按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/2d0f336ea691f10935298f948fcc7fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCCihyxDW2u7YHqqYnpUzQ.png"/></div></div></figure><p id="4694" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Netlify用最少的配置就能轻松运行Gatsby站点。您的新网站应该在几分钟内准备就绪。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/a63a5a4beb12f15b0c38c239f931ecfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZgyGNpt1_gAunFTpCF4eQ.png"/></div></div></figure><p id="06f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还记得我们不得不关闭服务器并重启它来获取新数据吗？我们不希望每次有人添加或更改内容时都必须手动触发重新部署。解决方案是使用Contentful的钩子来触发我们站点的自动网络重新部署(是的，这个三重标签团队考虑到了一切)。</p><p id="0798" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着你添加的每篇博客文章都会自动添加新的页面。此外，如果您使用Gatsby sitemap插件，新页面将在部署时重新生成并包含在sitemap中，这使得关键字排名更加容易，并有助于您的SEO工作。</p><p id="7aed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Netify上点击<strong class="kx ir">站点设置</strong>，然后在左侧菜单中选择<strong class="kx ir">构建&amp;部署</strong>。找到<strong class="kx ir">添加构建钩子</strong>按钮并点击它，给构建钩子起一个名字(我用的是“<strong class="kx ir"> contentful </strong>”)，然后点击<strong class="kx ir"> Save </strong>。</p><p id="9a4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在复制<strong class="kx ir"> buildhook </strong> url并返回到您的内容丰富的仪表板。点击设置下拉并选择<strong class="kx ir"> Webhooks </strong>。Webhooks屏幕的右下角已经有一个Netlify的模板。点击这个。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/1fdead77ac357aa5790987ce79fa1f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XoT3vHclyt7RjAGyp9eJQQ.png"/></div></div></figure><p id="ef95" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在出现的表单中，添加Netlify构建钩子url并点击<strong class="kx ir"> Create Webhook </strong>。</p><p id="a532" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在回到<strong class="kx ir">内容</strong>页面，添加一篇新的博客文章。只要点击publish，Contentful就会对您提供的构建挂钩进行API调用。这又会导致Netlify重新部署您的站点。Gatsby将再次引入内容丰富的数据，现在包括您添加的新文章，并基于新的博客文章创建一个新页面。</p><p id="5ed0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！这是一个漫长的旅程，但是现在我们有了一个可以使用的博客，它使用了三个很棒的工具，它们可以很好地协同工作。从这里，您可以添加更多的内容类型和页面，扩展网站或从头开始一个新项目。黑客快乐！</p><p id="157c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">页（page的缩写）s:我知道这是一个很长的问题，如果你卡住了，我很乐意回答你的任何问题。如果你这样做了，请在下面的评论中给我留言，或者在Twitter上给我打电话，我总是很乐意一起学习。</p></div></div>    
</body>
</html>