<html>
<head>
<title>Separation of concerns: example with a Nodejs-Fastify-MongoDB stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关注点分离:Nodejs-Fastify-MongoDB栈的例子</h1>
<blockquote>原文：<a href="https://itnext.io/separation-of-concerns-example-with-a-nodejs-fastify-mongodb-stack-2158577a8875?source=collection_archive---------2-----------------------#2021-04-11">https://itnext.io/separation-of-concerns-example-with-a-nodejs-fastify-mongodb-stack-2158577a8875?source=collection_archive---------2-----------------------#2021-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/722c81ba0df7c24fa39d84980fd033a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3I25BxGM_1-2B9Uw87pt1A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@daanmooij?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">金奎大·穆伊吉</a>在<a class="ae kc" href="https://unsplash.com/s/photos/leak?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ef3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建有效的软件是一回事，构建<strong class="kf ir">持续</strong>的软件是另一回事，尤其是当代码规模和参与开发的人数一起快速增长的时候。</p><p id="481f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将讨论一些可维护性问题和避免这些问题的技术，以使用<a class="ae kc" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"> Fastify </a> (web框架)和<a class="ae kc" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> Mongodb </a>(数据库)构建的<a class="ae kc" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> nodejs </a> web服务器为例。</p><h2 id="895e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">web服务的定义。</h2><p id="28aa" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这个特定的服务是一个简单的电影存储库，但是对于许多web服务来说，你可以用同样的方式将它们的各种组件分布在一条线上的某个地方:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/2c203de6294873d2429be65be5903be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-SEszHK8eOk0Glx3EUSig.jpeg"/></div></div></figure><p id="5b57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">左边的位很常见，对于您的特定应用可能没有什么附加值。你的服务的相对价值在于你拥有/收集的数据以及你用这些数据做了什么(业务逻辑)。</p><p id="a049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的是，各层之间的边界并不严格，可能会因不同的项目而异。<br/>例如，一个在<a class="ae kc" href="https://en.wikipedia.org/wiki/Relational_database#RDBMS" rel="noopener ugc nofollow" target="_blank"> RDMS </a>拥有高技能的团队可以在一个SQL查询/函数中进行数据聚合和统计计算，而另一个团队会选择在应用程序代码中做同样的事情，发现这样更容易维护和测试。</p><p id="1321" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，分离不同的关注点会减轻代码库的可维护性，这就是我们在这里要讨论的。</p><h2 id="79e0" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">Fastify简介。</h2><p id="a40e" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><em class="me">如果您已经熟悉该框架，您可以跳过这一部分。</em></p><p id="cdaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Fastify是一个web框架，它可以为您处理几乎所有开箱即用的事情(日志、解析、验证等)。然后，在定义路由的请求处理程序之前，您可以插入代码来<em class="me">修饰</em>服务器实例，并<em class="me">将</em>自己挂接到各种请求/响应生命周期中。<br/>有趣的是，你可以将你的<em class="me">插件</em>限制在服务器路由的一个子树中，提供了一种基于<a class="ae kc" href="https://levelup.gitconnected.com/ui-composition-and-inversion-of-control-d65e04eaddf9" rel="noopener ugc nofollow" target="_blank">控制反转</a>原则实现模式的简洁方法:</p><p id="a662" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果您定义一个插件来注册一个Fastify路由，如下所示:</p><pre class="ma mb mc md gt mf mg mh mi aw mj bi"><span id="1ebb" class="lb lc iq mg b gy mk ml l mm mn">const routes = async (instance) =&gt; {<br/>    const {greet} = instance;</span><span id="7fa1" class="lb lc iq mg b gy mo ml l mm mn">    instance.route({<br/>        method: 'GET',<br/>        <em class="me">// validation with JSONSchema<br/>        </em>schema: {<br/>            querystring: {<br/>                type: 'object',<br/>                properties: {<br/>                    name: {<br/>                        type: 'string'<br/>                    }<br/>                },<br/>                required: ['name']<br/>            }<br/>        },<br/>        url:'/greetings',<br/>        async handler(req, res){<br/>            const {name} = req.query<br/>            return greet(name);<br/>        }<br/>    });<br/>};</span></pre><p id="0bca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="me">注意处理程序依赖于实例提供的问候函数。</em></p><p id="4351" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，您可以在不同的地方安装路线，同时提供不同的<em class="me"> greet </em>实现:</p><pre class="ma mb mc md gt mf mg mh mi aw mj bi"><span id="f420" class="lb lc iq mg b gy mk ml l mm mn">const app = <em class="me">fastify</em>();<br/><br/>app.register(async (instance) =&gt;{<br/>    instance.decorate('greet', (name) =&gt; `Hello ${name}`);<br/>    instance.register(routes, {<br/>        prefix:'/en'<br/>    })<br/>});<br/><br/>app.register(async (instance) =&gt;{<br/>    instance.decorate('greet', (name) =&gt; `Salut ${name}`);<br/>    instance.register(routes, {<br/>        prefix:'/fr'<br/>    })<br/>});<br/><br/>app.listen();</span></pre><p id="c0e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打<em class="me">/en/问候语？name=laurent </em>将返回"<em class="me"> Hello laurent" </em>而点击<em class="me"> /fr/greetings？name=laurent </em>，你会得到“<em class="me">Salut Laurent”</em>。</p><h2 id="f666" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">Mongoose作为Mongodb的ODM</h2><p id="139b" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Mongodb是一个<a class="ae kc" href="https://en.wikipedia.org/wiki/NoSQL" rel="noopener ugc nofollow" target="_blank"> nosql </a>数据库，它以类似JSON的格式存储<em class="me">文档</em>。这看起来很方便，因为与如何将业务领域的对象存储在数据库中相比，不需要过多考虑如何在代码中建模这些对象。在关系数据库中，表的设计与您将在代码中操作的对象相比可能会有很大的不同，但在mongodb这样的文档存储中，起初似乎没有这种差异。<br/>但这不是真的，存储层缺乏抽象实际上可能会成为负担并失去控制。</p><h2 id="3855" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">模型模式</h2><p id="f733" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">尽管您可以在数据库级别获得<a class="ae kc" href="https://www.mongodb.com/blog/post/json-schema-validation--locking-down-your-model-the-smart-way" rel="noopener ugc nofollow" target="_blank">验证模式</a>，但通常使用像<a class="ae kc" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>这样的对象文档映射器库(ODM)来在应用程序代码级别添加一些约束(以及其他特性)，而数据库不一定能保证这些约束。</p><p id="a1e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果对象关系映射器库对于关系数据库来说是有争议的，那么ODM似乎更适合具有一对一关系的nosql范例。</p><p id="9517" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的电影商店，我们为电影集合定义了一个基本模式:</p><pre class="ma mb mc md gt mf mg mh mi aw mj bi"><span id="b69e" class="lb lc iq mg b gy mk ml l mm mn">import <em class="me">slug </em>from 'slug';<br/>import mongoose from 'mongoose';<br/><br/>export const MovieSchema = new mongoose.Schema({<br/>    title: {<br/>        type: String,<br/>        required: true<br/>    },<br/>    slug: {<br/>        type: String,<br/>        unique: true,<br/>        required: true,<br/>        default: function () {<br/>            return <em class="me">slug</em>(this.title);<br/>        }<br/>    },<br/>    likes: {<br/>        type: Number,<br/>        default: 0<br/>    },<br/>    description:{<br/>        type:String<br/>    },<br/>    // etc<br/>}, {<br/>    versionKey: false<br/>});</span></pre><h2 id="929d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">网络服务</h2><p id="6ba8" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在我们的应用是:</p><pre class="ma mb mc md gt mf mg mh mi aw mj bi"><span id="0742" class="lb lc iq mg b gy mk ml l mm mn">import fastify from 'fastify';<br/>import fastifySensible from 'fastify-sensible';<br/>import mongoose from 'mongoose';<br/>import {<em class="me">createDBPlugin</em>} from './db-plugin.js';<br/>import conf from './conf.js';<br/>import <em class="me">api </em>from './api.js';</span><span id="e5ec" class="lb lc iq mg b gy mo ml l mm mn">// create a connection pool<br/>const db = new mongoose.Mongoose();</span><span id="2af6" class="lb lc iq mg b gy mo ml l mm mn">// create the server<br/>const app = <em class="me">fastify</em>({<br/>    logger: true<br/>});</span><span id="f702" class="lb lc iq mg b gy mo ml l mm mn">// start adding middleware and plugins<br/>app.register(fastifySensible);<br/><br/><em class="me">// ... eventually other middleware: auth, etc</em></span><span id="e2ce" class="lb lc iq mg b gy mo ml l mm mn">// this one will establish the db connection and decorate the instance with the mongoose models<br/>app.register(<em class="me">createDBPlugin</em>({db}), conf);</span><span id="470e" class="lb lc iq mg b gy mo ml l mm mn">// our API routes<br/>app.register(<em class="me">api</em>, {...conf, prefix:'/movies'})<br/><br/>app.listen(conf.server.port);</span></pre><p id="d6e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">API插件将保存我们的业务逻辑:</p><pre class="ma mb mc md gt mf mg mh mi aw mj bi"><span id="985d" class="lb lc iq mg b gy mk ml l mm mn">// api.js<br/>export default async (instance) =&gt; {</span><span id="2147" class="lb lc iq mg b gy mo ml l mm mn">    const {Movie} = instance; // mongoose model provided by the db plugin<br/>     <br/>    // CREATE</span><span id="4395" class="lb lc iq mg b gy mo ml l mm mn">    instance.route({<br/>        method:'POST',<br/>        url:'/',<br/>        schema:{ /* ... */ } // validation schema<br/>        async handler(req, res){<br/>            const newMovie = new Movie(req.body);<br/>            const existingMovie = await Movie.findOne({<br/>                title:newMovie.title<br/>            });<br/>            instance.<em class="me">assert</em>(!existingMovie, 409, 'Movie already exists');<br/>            res.statusCode = 201;<br/>            return newMovie.save();<br/>        }<br/>    });</span><span id="f4cd" class="lb lc iq mg b gy mo ml l mm mn">    // FETCH ONE</span><span id="05bc" class="lb lc iq mg b gy mo ml l mm mn">    instance.route({<br/>        method: 'GET',<br/>        url: '/:movieSlug',<br/>        async handler(req, res) {<br/>            const movie = await Movie.findOne({<br/>                slug: req.params.movieSlug<br/>            });<br/>            instance.<em class="me">assert</em>(movie, 404);<br/>            return movie;<br/>        }<br/>    });<br/>    <br/>    // DELETE ONE<br/>    <br/>    instance.route({<br/>        method: 'DELETE',<br/>        url: '/:movieSlug',<br/>        async handler(req, res) {<br/>            const movie = await Movie.findOne({<br/>                slug: req.params.movieSlug<br/>            });<br/>            instance.<em class="me">assert</em>(movie, 404);<br/>            await movie.delete();<br/>        }<br/>    });</span><span id="82dc" class="lb lc iq mg b gy mo ml l mm mn">    // ETC</span><span id="4c40" class="lb lc iq mg b gy mo ml l mm mn">}</span></pre><p id="5524" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是非常简单的代码，但是我们已经通过混合请求处理器的逻辑和数据库<em class="me">低级</em>访问引入了一些技术债务。</p><p id="f134" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果Mongoose模型抽象了一点数据库，它仍然非常接近mongodb查询语言，允许业务层在数据库上做几乎任何事情。这也意味着业务层知道我们决定如何存储文档。</p><h2 id="dc7b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">当实施细节泄露时</h2><p id="ee7e" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在让我们说，不是在<em class="me">删除</em>操作中从DB中删除文档，我们想用一个标志<em class="me"> isDeleted </em>来标记文档，以确保文档不会永远消失。</p><p id="c64f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">删除路由的新处理程序如下所示:</p><pre class="ma mb mc md gt mf mg mh mi aw mj bi"><span id="3515" class="lb lc iq mg b gy mk ml l mm mn">instance.route({<br/>    method: 'DELETE',<br/>    url: '/:movieSlug',<br/>    async handler(req, res) {<br/>        const movie = await Movie.findOne({<br/>            slug: req.params.movieSlug,<br/>            isDeleted: false<br/>        });<br/>        instance.<em class="me">assert</em>(movie, 404);<br/>        movie.isDeleted = true;<br/>        await movie.save();<br/>        res.statusCode = 204;<br/>    }<br/>});</span></pre><p id="cac3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是，处理程序现在有了一个<em class="me">保存</em>语义。我们还必须确保<em class="me"> findOne </em>过滤掉已经被标记为删除的文档，这是有问题的。我们不仅要更新这个路径的处理程序，还要更新几乎所有处理<em class="me">电影</em>模型的代码:例如，我们必须更新所有的路径，以过滤掉已经标记为删除的文档。</p><p id="0eea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那是因为关于<strong class="kf ir">如何</strong>存储文档的<strong class="kf ir">技术细节</strong>已经泄露给了应用程序代码。想象一下，稍后我们想要使用时间戳而不是布尔标志:然而我们又不得不更新整个<strong class="kf ir">代码库。</strong></p><h2 id="6981" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">在数据库和应用程序代码之间添加一个抽象层</h2><p id="6fd5" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们考虑以下组件:</p><pre class="ma mb mc md gt mf mg mh mi aw mj bi"><span id="b2a4" class="lb lc iq mg b gy mk ml l mm mn">export const <em class="me">createService </em>= ({model}) =&gt; {<br/>    return {<br/>        getOneBySlug(slug) {<br/>            return model.findOne({<br/>                slug,<br/>                isDeleted: {$ne: true}<br/>            }).select({<br/>                isDeleted: 0<br/>            });<br/>        },<br/>        getOneByTitle(title) {<br/>            return model.findOne({<br/>                title,<br/>                isDeleted: {$ne: true}<br/>            }).select({<br/>                isDeleted: 0<br/>            });<br/>        },<br/>        listAll() {<br/>            return model.find({<br/>                isDeleted: {$ne: true}<br/>            }).select({<br/>                isDeleted: 0<br/>            });<br/>        },<br/>        async create(movie) {<br/>            return new model(movie).save();<br/>        },<br/>        async delete(slug) {<br/>            await model.findOneAndUpdate({<br/>                slug<br/>            }, {<br/>                $set: {<br/>                    isDeleted: true<br/>                }<br/>            });<br/>        }<br/>    };<br/>};</span></pre><p id="de88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该服务为调用者包装和隐藏数据库细节。</p><ol class=""><li id="fc33" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">如果你看看它的API和参数，一切都要简单得多:大多数时候参数都是简单的文字。</li><li id="8f0c" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">调用代码没有办法超越它所调用的函数的范围:我们有一个更高级别的API。</li><li id="b24c" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated"><em class="me"> isDeleted </em>标志(一个技术键)没有暴露。</li><li id="41bb" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">只看接口，根本看不出底层数据库引擎是mongodb。</li></ol><p id="04a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以将服务注入路由处理程序，而不是注入电影模型:</p><pre class="ma mb mc md gt mf mg mh mi aw mj bi"><span id="b46f" class="lb lc iq mg b gy mk ml l mm mn">import {<em class="me">createService</em>} from './movies-service.js';<br/><br/>export default async (instance) =&gt; {<br/>    const {Movie} = instance; <em class="me">// mongoose model injected<br/>    </em>instance.register(async (instance) =&gt; {<br/>        <em class="me">// (1) we overwrite Movie for the current scope <br/>        </em>instance.decorate('Movie', <em class="me">createService</em>({model: Movie}));<br/>        instance.register(<em class="me">routesPlugin</em>);<br/>    });<br/>}<br/><br/>export const <em class="me">routesPlugin </em>= async (instance) =&gt; {<br/>    const {Movie} = instance; <em class="me">// this one will then be the service <br/>    <br/>    </em>instance.route({<br/>        method: 'GET',<br/>        url: '/:movieSlug',<br/>        async handler(req, res) {<br/>            const {params} = req;<br/>            const movie = await Movie.getOneBySlug(params.movieSlug);<br/>            instance.<em class="me">assert</em>(movie, 404);<br/>            return movie;<br/>        }<br/>    });<br/>    <br/>    instance.route({<br/>        method: 'DELETE',<br/>        url: '/:movieSlug',<br/>        async handler(req, res) {<br/>            const slug = req.params.movieSlug;<br/>            const movie = await Movie.getOneBySlug(slug);<br/>            instance.<em class="me">assert</em>(movie, 404);<br/>            await Movie.delete(slug);<br/>            res.statusCode = 204;<br/>        }<br/>    });</span><span id="acb1" class="lb lc iq mg b gy mo ml l mm mn">    // etc    </span><span id="d3df" class="lb lc iq mg b gy mo ml l mm mn">};</span></pre><p id="4fef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(1)由于Fastify插件封装，我们能够为routes作用域覆盖注入的<em class="me"> Movie </em>名称空间，防止业务层直接访问数据库！</p><p id="53d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，处理程序现在必须使用服务API，但是这种契约更紧密，更不容易中断更改。如果我们决定将布尔标志换成时间戳，就不再需要修改处理程序代码，从而使代码库更容易维护。</p><h2 id="7f92" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">测试不同的堆栈组件</h2><p id="1c1f" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">正如我前面说过的，从处理程序的角度来看，没有任何线索表明我们在服务接口后面使用了mongodb。我们可以用任何其他DB引擎来代替它，只要服务API接口不变，这在处理程序代码中不会被注意到。因此，为了测试，我们实际上可以使用服务的模拟实现，以便孤立地测试处理程序。</p><pre class="ma mb mc md gt mf mg mh mi aw mj bi"><span id="0e12" class="lb lc iq mg b gy mk ml l mm mn">import fastify from 'fastify';<br/>import fastifySensible from 'fastify-sensible';<br/>import {<em class="me">routesPlugin</em>} from './api.js';<br/>import stub from 'sbuts';<br/><br/>export default (t) =&gt; {<br/>    const createTestApp = ({getOneBySlug}) =&gt; {<br/>        const app = <em class="me">fastify</em>();<br/>        app.register(fastifySensible);<br/>        <em class="me">// inject mock<br/>        </em>app.decorate('Movie', {<br/>            getOneBySlug<br/>        });<br/>        app.register(<em class="me">routesPlugin</em>);<br/>        return app;<br/>    };<br/>    <br/>    t.test(`GET /:movieSlug should return 200 with the matching movie`, async (t) =&gt; {<br/>        const forestGump = {<br/>            likes: 0,<br/>            _id: '6071d76a0d5f31cb3e7e8a31',<br/>            title: 'Forest Gump',<br/>            description: 'foo bar bim',<br/>            slug: 'forest-gump'<br/>        };<br/>        const getOneBySlug = <em class="me">stub</em>().resolve(forestGump);<br/>        const app = createTestApp({getOneBySlug});<br/>        const response = await app.inject({<br/>            method: 'GET',<br/>            url: '/forest-gump'<br/>        });<br/>        <br/>        t.eq(response.statusCode, 200);<br/>        const json = await response.json();<br/>        t.eq(json, forestGump);<br/>        t.eq(getOneBySlug.calls, [['forest-gump']])<br/>    });<br/>    <br/>    t.test(`GET /:movieSlug should return 404 if no movie matches`, async (t) =&gt; {<br/>        const getOneBySlug = <em class="me">stub</em>().resolve(null);<br/>        const app = createTestApp({getOneBySlug});<br/>        const response = await app.inject({<br/>            method: 'GET',<br/>            url: '/forest-gump'<br/>        });<br/>        <br/>        t.eq(response.statusCode, 404);<br/>        t.eq(getOneBySlug.calls, [['forest-gump']])<br/>    });<br/>}</span></pre><p id="f1c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试服务本身没有多大意义，除非您针对真实的数据库进行测试(集成测试)，以实际评估数据库查询的相关性。它的唯一目的是对应用程序堆栈的其余部分隐藏技术细节。</p><p id="a33d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，上面的测试套件通过对服务API的高级调用，在测试我们的业务代码及其与数据库的交互方面非常有效。</p><h2 id="1b23" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="24b3" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在本文中，我们已经看到了泄漏存储细节如何损害软件的可维护性。然后，我们概述了正确的抽象如何能够减少堆栈的各个组件之间的耦合。</p><p id="418f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在后面的<a class="ae kc" href="https://gist.github.com/lorenzofox3/ca79210d8cf49d44473e89db4616f4e4" rel="noopener ugc nofollow" target="_blank">中找到代码。</a></p></div></div>    
</body>
</html>