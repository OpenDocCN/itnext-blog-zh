<html>
<head>
<title>AWS Lambda Custom Runtimes with Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Haskell的AWS Lambda自定义运行时</h1>
<blockquote>原文：<a href="https://itnext.io/aws-lambda-custom-runtimes-with-haskell-791a6d3fb9?source=collection_archive---------4-----------------------#2019-01-31">https://itnext.io/aws-lambda-custom-runtimes-with-haskell-791a6d3fb9?source=collection_archive---------4-----------------------#2019-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/afcd45cb767e47bdf0dc16009808acf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k5J7-F521xSd5cSH.jpg"/></div></div></figure><h2 id="1a87" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">自定义运行时</h2><p id="27e4" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">AWS在2018年11月的年度re:Invent大会上为我们带来的重大消息是为Lambda引入了自定义运行时。这确实很重要，因为它允许我们用任何编程语言编写Lambda函数，而不需要将二进制代码作为已经支持的运行时(node、python、go等)的子进程来运行。).有一个关于如何在bash中编写runtime/lambda的官方教程，以及一些现成的C++和Rust的运行时。</p><p id="2231" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">让我们重复一下运行时实际上做了什么，以及它如何适应像Haskell这样的编译语言。bash教程以及可能所有动态/解释语言的运行时都利用了这样一个事实，即运行时可以加载并运行处理程序的代码。虽然这很好，因为开发人员可以专注于只编写处理程序代码，并让运行时在某个地方，但这可能会导致冷启动的一部分。我想大部分时间花在了实例化所有需要的基础设施上，但也有一部分时间花在了启动和运行运行时上，尤其是如果处理程序本身使用了一些动态加载的库。</p><p id="53ee" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">Rust和C++的官方运行时采用的方法是将整个运行时放入一个库中，并将其与处理程序一起编译成一个二进制文件。</p><p id="cd1b" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">对于已经有一些编写lambdas的经验的人来说，这可能有点令人困惑，但这是完全有意义的。在这种方法中，我们只需将运行lambda所需的所有东西打包到二进制文件中(实际上是所有东西，但我们将在后面探讨)。</p><p id="754c" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">因此，让我们看看是否可以一步一步地用Haskell创建一个可以在lambda上本地运行的Lambda运行时🙂</p><h2 id="75cf" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">环境设置</h2><p id="89cf" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">为了解决这个问题，让我们创建一个本地开发环境。为了运行我们想要的一切，我们需要:</p><p id="b612" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">- <code class="fe lx ly lz ma b">stack</code>(可从<a class="ae mb" href="https://docs.haskellstack.org/en/stable/README/#how-to-install" rel="noopener ugc nofollow" target="_blank">此处</a> ) <br/> - <code class="fe lx ly lz ma b">docker</code> <br/> - <code class="fe lx ly lz ma b">aws</code> cli工具(仅当我们实际想要在Lambda上运行代码时)</p><p id="984a" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">第一步是创建一个堆栈项目并对其进行配置。</p><pre class="mc md me mf gt mg ma mh mi aw mj bi"><span id="c23d" class="kb kc it ma b gy mk ml l mm mn"><em class="mo">$ stack new hs-lambda<br/>$ cd hs-lambda<br/>$ stack config set resolver lts-12.14</em></span></pre><p id="3285" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">现在进入适当的拉姆达的东西。我们将从执行环境开始，它是:</p><ul class=""><li id="597d" class="mp mq it kz b la ls le lt kk mr ko ms ks mt lr mu mv mw mx bi translated">操作系统—亚马逊Linux</li><li id="a098" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">AMI-amzn-AMI-hvm-2017 . 03 . 1 . 2017 08 12-x86 _ 64-GP2</li><li id="f17f" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">Linux内核—4 . 14 . 77–70.59 . amzn 1 . x86 _ 64</li><li id="8b97" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">用于JavaScript的AWS SDK—2 . 290 . 0</li><li id="6281" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">Python的SDK(Boto 3)-3–1 . 7 . 74 Boto core-1 . 10 . 74</li></ul><p id="cf27" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">对我们来说，重要的是我们编译的代码将在<strong class="kz iu">Amazon Linux v 2017 . 03 . 1 . 2017 08 12</strong>上运行，因为我们希望它成为我们的编译环境，以实现最大的二进制兼容性。</p><p id="342b" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">因此，让我们基于AWS映像构建一个容器:</p><pre class="mc md me mf gt mg ma mh mi aw mj bi"><span id="b187" class="kb kc it ma b gy mk ml l mm mn"><em class="mo">$ docker run -rm -name $(basename $(pwd)) -v $(pwd):/mnt -ti amazonlinux:2017.03.1.20170812 /bin/bash</em></span></pre><p id="3b65" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">这将启动一个bash会话，并将我们的当前目录挂载到容器内的<code class="fe lx ly lz ma b">/mnt</code>目录中。我们也想在这里使用<code class="fe lx ly lz ma b">stack</code>,所以让我们安装它和一些依赖项:</p><pre class="mc md me mf gt mg ma mh mi aw mj bi"><span id="e511" class="kb kc it ma b gy mk ml l mm mn"><em class="mo">bash-4.2# cd /mnt<br/>bash-4.2# curl -sSL </em><a class="ae mb" href="https://get.haskellstack.org/" rel="noopener ugc nofollow" target="_blank"><em class="mo">https://get.haskellstack.org/</em></a><em class="mo"> | sh<br/>bash-4.2# yum install -y gcc make xz libffi zlib zlib-devel gmp gmp-devel — suggested by stack install script</em></span></pre><p id="77e3" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">到目前为止，我们已经部分建立了编译和开发环境。现在，让我们完成开发环境的设置。我们将只使用我们的容器进行最终编译，并在我们的dev box上做其他事情。让容器保持运行，打开另一个终端窗口，将<code class="fe lx ly lz ma b">cd</code>指向我们的<code class="fe lx ly lz ma b">hs-lambda</code>目录。</p><h2 id="c8ea" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">履行</h2><p id="709e" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated"><code class="fe lx ly lz ma b">stack new</code>创建了一个基本的项目框架，我们准备写一些代码。让我们打开<code class="fe lx ly lz ma b">app/Main.hs</code>文件，回到文档中，看看我们的运行时应该做什么。出于本文的目的，我们将创建一个基本的无服务器echo服务器🙂</p><p id="d3c2" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">首先，引用AWS文档告诉我们如何让我们的定制运行时工作:</p><blockquote class="nd ne nf"><p id="aff5" class="kx ky mo kz b la ls lc ld le lt lg lh ng lu lj lk nh lv lm ln ni lw lp lq lr im bi translated"><em class="it">你可以用任何编程语言实现AWS Lambda运行时。</em></p><p id="bb11" class="kx ky mo kz b la ls lc ld le lt lg lh ng lu lj lk nh lv lm ln ni lw lp lq lr im bi translated"><em class="it">运行时是在调用函数时运行Lambda函数处理程序方法的程序。您可以将运行时以名为bootstrap的可执行文件的形式包含在您的函数部署包中。</em></p></blockquote><p id="f137" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">从上面我们知道，我们需要一个名为<code class="fe lx ly lz ma b">bootstrap</code>的二进制文件放在我们的lambda zip包中，这个文件应该包含运行时。让我们更进一步，检查我们的运行时必须经历的所有步骤。</p><ol class=""><li id="c856" class="mp mq it kz b la ls le lt kk mr ko ms ks mt lr nj mv mw mx bi translated"><strong class="kz iu">检索设置</strong> —读取环境变量以获取关于功能和环境的详细信息。</li></ol><ul class=""><li id="5609" class="mp mq it kz b la ls le lt kk mr ko ms ks mt lr mu mv mw mx bi translated"><code class="fe lx ly lz ma b">_HANDLER</code> -处理器的位置，来自功能配置。标准格式是<code class="fe lx ly lz ma b">file.method</code>，其中<code class="fe lx ly lz ma b">file</code>是不带扩展名的文件名，<code class="fe lx ly lz ma b">method</code>是文件中定义的方法或函数的名称。</li><li id="363a" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated"><code class="fe lx ly lz ma b">LAMBDA_TASK_ROOT</code> -包含功能代码的目录。</li><li id="de97" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated"><code class="fe lx ly lz ma b">AWS_LAMBDA_RUNTIME_API</code> -运行时API的主机和端口</li></ul><p id="b07b" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">有关可用变量的完整列表，请参见Lambda函数可用的环境变量</p><p id="889e" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">2.<strong class="kz iu">初始化函数</strong> —加载处理程序文件并运行它包含的任何全局或静态代码。函数应该一次性创建像SDK客户端和数据库连接这样的静态资源，并在多次调用中重用它们。</p><p id="fe30" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">3.<strong class="kz iu">处理错误</strong> —如果出现错误，调用初始化错误API并立即退出。</p><p id="4d55" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">我们将查看这些要点，看看它们是否都适用。</p><ol class=""><li id="4b44" class="mp mq it kz b la ls le lt kk mr ko ms ks mt lr nj mv mw mx bi translated">我们的计划是创建一个带有自定义运行时的基本的最小lambda函数，所以我们将把所有东西放入我们的<code class="fe lx ly lz ma b">bootstrap</code>二进制文件中。在这种情况下，我们不需要加载任何处理程序，所以我们真的不需要读取<code class="fe lx ly lz ma b">_HANDLER</code>和<code class="fe lx ly lz ma b">LAMBDA_TASK_ROOT</code>变量。我们唯一需要的是<code class="fe lx ly lz ma b">AWS_LAMBDA_RUNTIME_API</code>的值。</li><li id="5c44" class="mp mq it kz b la my le mz kk na ko nb ks nc lr nj mv mw mx bi translated">同样，我们不会加载任何处理程序，所以初始化SDK等。可以在我们的<code class="fe lx ly lz ma b">bootstrap</code>代码中完成。</li><li id="c019" class="mp mq it kz b la my le mz kk na ko nb ks nc lr nj mv mw mx bi translated">我们可能应该做一些错误处理，但由于这只是一个玩具例子，我们将跳过它。为了简单起见。</li></ol><p id="67e1" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">好了，到目前为止，我们只需要读取一个环境变量并运行一些代码来初始化昂贵的东西，如数据库连接、SDK等。没什么难的。</p><p id="b291" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">完成初始化后，我们可以进入处理任务的主循环。像往常一样，让我们后退一步，阅读文档:</p><ol class=""><li id="27ad" class="mp mq it kz b la ls le lt kk mr ko ms ks mt lr nj mv mw mx bi translated"><strong class="kz iu">获取事件</strong> —调用下一个调用API来获取下一个事件。响应正文包含事件数据。响应头包含请求ID和其他信息。</li><li id="b591" class="mp mq it kz b la my le mz kk na ko nb ks nc lr nj mv mw mx bi translated"><strong class="kz iu">传播跟踪头</strong> —从API响应中的<code class="fe lx ly lz ma b">Lambda-Runtime-Trace-Id</code>头获取X射线跟踪头。为X-Ray SDK使用的环境变量设置相同的值。</li><li id="065b" class="mp mq it kz b la my le mz kk na ko nb ks nc lr nj mv mw mx bi translated"><strong class="kz iu">创建一个上下文对象</strong> —使用环境变量和API响应头中的上下文信息创建一个对象。</li><li id="3fed" class="mp mq it kz b la my le mz kk na ko nb ks nc lr nj mv mw mx bi translated"><strong class="kz iu">调用函数处理程序</strong> —将事件和上下文对象传递给处理程序。</li><li id="bd62" class="mp mq it kz b la my le mz kk na ko nb ks nc lr nj mv mw mx bi translated"><strong class="kz iu">处理响应</strong> —调用调用响应API来发布来自处理程序的响应。</li><li id="3af7" class="mp mq it kz b la my le mz kk na ko nb ks nc lr nj mv mw mx bi translated"><strong class="kz iu">处理错误</strong> —如果出现错误，调用调用错误API。</li><li id="d2e2" class="mp mq it kz b la my le mz kk na ko nb ks nc lr nj mv mw mx bi translated"><strong class="kz iu">清理</strong> —释放未使用的资源，向其他服务发送数据，或者在获取下一个事件之前执行额外的任务。</li></ol><p id="77a3" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">现在，这很容易。我们只是:</p><ul class=""><li id="e2b3" class="mp mq it kz b la ls le lt kk mr ko ms ks mt lr mu mv mw mx bi translated">向一个端点发出HTTP请求并接收一个事件</li><li id="0dfb" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">读取一些头文件并设置一些环境变量</li><li id="8778" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">创建一些额外的上下文</li><li id="44f0" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">处理事件时考虑(或不考虑)上下文</li><li id="8f9a" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">生成一个输出，并通过另一个HTTP请求发布它，无论它是一个正确的响应还是一个错误(尽管端点不同)</li><li id="2b11" class="mp mq it kz b la my le mz kk na ko nb ks nc lr mu mv mw mx bi translated">必要时清理</li></ul><p id="fb8f" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">关于API的一些细节可以在<a class="ae mb" href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。在我们的例子中，我们制作了一个echo服务器，所以我们只需要简单地获取事件并发回它。代码很简单:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="1b28" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">汇编</h2><p id="1338" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">除了错误处理(我们跳过它，因为它只是一个玩具)之外，我们几乎拥有了我们需要的一切。现在这还不能编译，因为我们使用了一些外部库。我们需要将它们添加到我们的<code class="fe lx ly lz ma b">package.yaml</code>文件中。我们需要做的另一个小改变是重命名我们的可执行文件。我们可以稍后手动完成，但是让我们自动完成。<code class="fe lx ly lz ma b">package.yaml</code>的相关部分现在应该看起来像这样:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f5c0" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">现在我们已经准备好在本地编译和运行了(这可能需要一些时间)。</p><pre class="mc md me mf gt mg ma mh mi aw mj bi"><span id="7310" class="kb kc it ma b gy mk ml l mm mn"><em class="mo">$ stack build<br/>$ stack exec bootstrap<br/>bootstrap: AWS_LAMBDA_RUNTIME_API: getEnv: does not exist (no  environment variable)</em></span></pre><p id="1f58" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">有用！我们有一个错误，我们丢失了一个环境变量，但现在没问题。让我们尝试在我们的容器中编译它(这也可能需要一段时间)。</p><pre class="mc md me mf gt mg ma mh mi aw mj bi"><span id="c627" class="kb kc it ma b gy mk ml l mm mn"><em class="mo">bash-4.2# stack setup<br/>bash-4.2# stack build<br/>bash-4.2# ldd .stack-work/install/x86_64-linux/lts-12.14/8.4.3/bin/bootstrap<br/> linux-vdso.so.1 =&gt; (0x00007ffe14dae000)<br/> libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fca5f2f1000)<br/> libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007fca5f0d5000)<br/> libz.so.1 =&gt; /lib64/libz.so.1 (0x00007fca5eebf000)<br/> librt.so.1 =&gt; /lib64/librt.so.1 (0x00007fca5ecb7000)<br/> libutil.so.1 =&gt; /lib64/libutil.so.1 (0x00007fca5eab4000)<br/> libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fca5e8b0000)<br/> libgmp.so.10 =&gt; /usr/lib64/libgmp.so.10 (0x00007fca5e63a000)<br/> libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fca5e26d000)<br/> /lib64/ld-linux-x86–64.so.2 (0x00007fca5f5f3000)</em></span></pre><p id="7d72" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">一切正常，但是我们的二进制文件有一个问题,<code class="fe lx ly lz ma b">ldd</code>命令强调了这个问题。我们的二进制是动态链接的。这很好，因为它降低了文件大小，但在我们无法控制的系统上，不能安装任何库或任何东西，这是一个问题。还记得我们如何安装<code class="fe lx ly lz ma b">zlib</code>和<code class="fe lx ly lz ma b">gmp</code>吗？在AWS上运行我们的lambda的VM上将缺少这两个。有两种选择。我们可以捆绑缺失的库，将我们的二进制文件与那些库链接起来，或者编译一个静态链接的二进制文件。虽然第二种方法会产生一个更大的文件，但我们将继续使用它，因为它使整个事情更加健壮。</p><p id="bc43" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">为了让它工作，我们将不得不安装一些库的静态版本，而不仅仅是丢失的那些。经过反复试验，我发现我们只需要三个。</p><pre class="mc md me mf gt mg ma mh mi aw mj bi"><span id="9b99" class="kb kc it ma b gy mk ml l mm mn"><em class="mo">bash-4.2# yum install -y glibc-static gmp-static zlib-static</em></span></pre><p id="5f05" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">现在网上有很多关于如何用ghc/cabal/stack编译一个静态二进制的<a class="ae mb" href="https://vadosware.io/post/static-binaries-for-haskell-a-convoluted-approach/" rel="noopener ugc nofollow" target="_blank">资源</a>。我选择了一个看起来很干净的，并且有一天可能会被用在工具上的。当我们运行<code class="fe lx ly lz ma b">stack build</code>时，它根据我们<code class="fe lx ly lz ma b">package.yaml</code>和<code class="fe lx ly lz ma b">stack.yaml</code>中的内容为我们生成了一个<code class="fe lx ly lz ma b">hs-lambda.cabal</code>文件。Stack会警告我们不要乱动<code class="fe lx ly lz ma b">.cabal</code>文件。事实上，自从它进入由<code class="fe lx ly lz ma b">stack new</code>创建的<code class="fe lx ly lz ma b">.gitignore</code>文件后，git甚至没有跟踪它。然而，就目前而言，使静态链接工作的最好方法是在<code class="fe lx ly lz ma b">executable</code>部分的<code class="fe lx ly lz ma b">.cabal</code>文件中添加一行。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5809" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">现在我们将重新编译。</p><pre class="mc md me mf gt mg ma mh mi aw mj bi"><span id="c635" class="kb kc it ma b gy mk ml l mm mn"><em class="mo">bash-4.2# stack clean<br/>bash-4.2# stack build -ghc-options=’-fPIC’ — this will create a statically linked binary<br/>bash-4.2# ldd .stack-work/install/x86_64-linux/lts-12.14/8.4.3/bin/bootstrap<br/> not a dynamic executable</em></span></pre><p id="2c23" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">我们完了。如你所见，我们的二进制文件是独立的，可以在任何linux发行版上运行。</p><h2 id="b62c" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">部署</h2><p id="11aa" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">现在，我们可以回到我们的开发箱，将整个东西打包并部署它。</p><pre class="mc md me mf gt mg ma mh mi aw mj bi"><span id="559a" class="kb kc it ma b gy mk ml l mm mn"><em class="mo">$ zip function.zip .stack-work/install/x86_64-linux/lts-12.14/8.4.3/bin/bootstrap<br/> adding: bootstrap (deflated 73%)<br/>$ aws lambda create-function -function-name test-custom-runtime -zip-file fileb://function.zip -handler function.handler -runtime provided -role arn:aws:iam::123456789:role/aws-lambda-role<br/> {<br/> “FunctionName”: “test-custom-runtime”,<br/> “FunctionArn”: “arn:aws:lambda:eu-central-1:123456789:function:test-custom-runtime”,<br/> “Runtime”: “provided”,<br/> “Role”: “arn:aws:iam::123456789:role/aws-lambda-role”,<br/> “Handler”: “function.handler”,<br/> “CodeSize”: 4667617,<br/> “Description”: “”,<br/> “Timeout”: 3,<br/> “MemorySize”: 128,<br/> “LastModified”: “2019–01–15T21:40:01.625+0000”,<br/> “CodeSha256”: “TMVO8YwRTW3tu9CKpT5ShPe+iVVemrq9xKW2iDdS9Lc=”,<br/> “Version”: “$LATEST”,<br/> “TracingConfig”: {<br/> “Mode”: “PassThrough”<br/> },<br/> “RevisionId”: “d8579e6e-bc80–4951-be5f-cabb5d93f0b6”<br/> }</em></span></pre><p id="15bd" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">我们准备好测试它了。</p><pre class="mc md me mf gt mg ma mh mi aw mj bi"><span id="609c" class="kb kc it ma b gy mk ml l mm mn"><em class="mo">$ aws lambda invoke -function-name ‘test-custom-runtime’ -payload ‘{“text”:”Hello”}’ response.txt<br/> {<br/> “StatusCode”: 200,<br/> “ExecutedVersion”: “$LATEST”<br/> }$ cat response.txt<br/> {“text”:”Hello”}</em></span></pre><p id="9b69" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">有用！如您所见，我们的lambda运行成功，并将我们的有效负载反馈给了我们。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="96e5" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated"><em class="mo">原载于2019年1月31日</em><a class="ae mb" href="https://www.tooploox.com/blog/aws-lambda-custom-runtimes-with-haskell" rel="noopener ugc nofollow" target="_blank"><em class="mo">【https://www.tooploox.com】</em></a><em class="mo">。</em></p></div></div>    
</body>
</html>