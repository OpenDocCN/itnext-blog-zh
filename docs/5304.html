<html>
<head>
<title>Streaming data with gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用gRPC流式传输数据</h1>
<blockquote>原文：<a href="https://itnext.io/streaming-data-with-grpc-2eb983fdee11?source=collection_archive---------1-----------------------#2021-02-05">https://itnext.io/streaming-data-with-grpc-2eb983fdee11?source=collection_archive---------1-----------------------#2021-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3fde" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当沮丧的机器接管世界时，如何生存的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87045f6f574999a107899afe930d2be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ygXZ3MN_DSiaX16VRcWww.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">亚历杭德罗·门多萨在<a class="ae ky" href="https://unsplash.com/s/photos/murder-robot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你开过后座有小孩的车吗？<br/>不断的追问。</p><blockquote class="lv"><p id="9b6a" class="lw lx it bd ly lz ma mb mc md me lu dk translated">我们到了吗？我们到了吗？烦人的后座小孩</p></blockquote><p id="bfa7" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">这可能会让人发疯，而且很可能已经这样做了。</p><p id="38bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很奇怪，因为即使我们知道这有多令人沮丧，<strong class="lb iu">软件也倾向于这样设计</strong>。您有一个作为客户端运行的前端或服务，它从服务器加载数据。在许多情况下，这种加载是通过频繁地<strong class="lb iu">轮询</strong>新数据来完成的。想象一下，作为一个拥有大量客户端的HTTP API，所有客户端都问你“嘿，有没有新的闪亮数据给我？”大约每10秒钟。这种模式通常被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Polling_(computer_science)" rel="noopener ugc nofollow" target="_blank">轮询</a>。</p><p id="7681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">轮询是一种关于客户机如何从服务器检索数据的设计模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/db18ec57ac8e995bdc3f6bf973ab6af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVFzNUUs_mc-r3lj5ttFdw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">轮询设计模式的示例，在一段时间内重复请求</figcaption></figure><p id="1ac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很高兴计算机还没有形成自己的思想，因为当它们形成自己的思想时，哦，天哪，我们软件开发人员就完蛋了。所有那些服务器肯定都很沮丧。谢天谢地，你正在阅读这篇博文，当机器接管世界时，这篇博文将拯救你的生命。他们甚至会原谅你在这篇文章之后重新设计你的交流模式。</p><p id="f782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究使用gRPC流的流架构。流数据的现代解决方案有很多，<a class="ae ky" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank"> WebSocket，</a> <a class="ae ky" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank"> WebRTC </a>。我选择gRPC的原因是它<strong class="lb iu">允许我们在微服务之间传输数据，而不仅仅是web应用</strong>。(也因为我喜欢使用Go) <br/>在本文中，我们将创建一个用Go编写的gRPC服务器、一个用Go编写的客户机和一个用React编写的客户机。您将看到两个客户端如何使用同一个服务器。</p><p id="0ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该设计将看起来像下面的图片，而不是投票。我们将用一个请求建立一个连接，然后等待来自服务器的数据。因此，不是客户端请求新数据，而是服务器将新数据推送到客户端，这被称为<strong class="lb iu">服务器端流</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/d5b49f030d37194d19fe9263a7ef4072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJYjD79uDuxJ8C2mq97qzQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">流设计利用已建立的通信通道从服务器传送数据，无需重复请求。</figcaption></figure><p id="6ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gRPC还有另外两种流式传输数据的方式，称为<strong class="lb iu">客户端流式传输和双向流式传输。</strong>在本文中，我们将只使用<strong class="lb iu">服务器端流。</strong></p><p id="925f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端流是指客户端将数据推送到服务器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/d1dbb34707c0053125ad7a7de17490f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJrEZ4dT6OyxYP5X6n4d-g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">客户端流示例，其中客户端将更新推送到服务器</figcaption></figure><p id="9d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">双向流是指客户端和服务器都可以在彼此之间推送数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/4c47eaeeb0667febb03c8ab4c9867c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPnu5a2E41ABqGlJahVVng.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">双向流，客户端和服务器都可以传输数据</figcaption></figure><p id="5861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始在Go后端实现设计。我们还将在react应用程序中实现一个客户端。因此，阅读完本文后，您应该有一个Go服务器、一个Go客户端和一个React客户端，它们与同一个服务器进行对话。</p><h2 id="277d" class="mo mp it bd mq mr ms dn mt mu mv dp mw li mx my mz lm na nb nc lq nd ne nf ng bi translated">项目设置和所需软件</h2><p id="c453" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">让我们从建立项目结构开始。我已经开始为我们想要的每个客户端和后端代码创建一个文件夹。在我的例子中，我把这个项目命名为<strong class="lb iu"> grpcstreams，</strong>，里面有3个空文件夹和2个空文件夹。去文件。完整的代码示例可以在这里找到<a class="ae ky" href="https://github.com/percybolmer/grpcstreams" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/bb3c67bd5383ef5344f96ba3559d6865.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*dkHMnrnC_n04EWXxxpkniw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我的项目设置。</figcaption></figure><p id="bca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉gRPC，我建议你先阅读我的另一篇关于它的文章。如果你想在没有先验知识的情况下继续，<strong class="lb iu">你需要安装</strong> <a class="ae ky" href="https://grpc.io/docs/protoc-installation/" rel="noopener ugc nofollow" target="_blank">协议</a>。Protoc是一个编译器，用于将我们的protobuf和gRPC服务组装成go代码。</p><p id="e28c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要go gRPC插件，以便我们可以为go后端生成gRPC代码。如果你必须安装(我假设)或<a class="ae ky" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">获取它</a>，这可以通过go get命令获取。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="ee0c" class="mo mp it no b gy ns nt l nu nv">go get -u google.golang.org/protobuf/cmd/protoc-gen-go<br/>go install google.golang.org/protobuf/cmd/protoc-gen-go<br/><br/>go get -u google.golang.org/grpc/cmd/protoc-gen-go-grpc<br/>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc</span></pre><p id="c451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前还有一件事，我们还需要为web应用程序生成一个客户机。你可以在这里找到它的安装说明<a class="ae ky" href="https://github.com/grpc/grpc-web#code-generator-plugin" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，为了确保你拥有一切，这里列出了你应该拥有的东西。</p><ul class=""><li id="4d63" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">协议</li><li id="a1dc" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">通用协议和通用协议</li><li id="96a2" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">grpc-web</li></ul><h2 id="933b" class="mo mp it bd mq mr ms dn mt mu mv dp mw li mx my mz lm na nb nc lq nd ne nf ng bi translated">设置gRPC服务</h2><p id="c840" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们将首先创建一个名为<strong class="lb iu"> service.proto </strong>的文件，它将位于proto文件夹中。这个文件是一个protobuf文件，它将定义我们的后端服务的样子。我们将创建一个硬件监控服务，向客户端发布硬件统计信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">service.proto将如下所示。</figcaption></figure><p id="c836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在gRPC中，创建protobuf文件并基于该文件生成代码。service.proto文件是生成的代码外观的模板。</p><p id="290b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经创建了一个HardwareMonitor服务，它将公开一个名为Monitor的方法。Monitor方法将返回由(stream HardwareStats)指示的流。</p><p id="7965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用protoc来生成基于service.proto所需的代码</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="7f57" class="mo mp it no b gy ns nt l nu nv">protoc service.proto --js_out=import_style=commonjs,binary:. --grpc-web_out=import_style=commonjs,mode=grpcwebtext:. --go-grpc_out=. --go_out=.</span></pre><p id="5c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个命令可能看起来很可怕，但它非常简单。我们在service.proto上调用protocol，然后添加标志(js_out，grpc-web_out，go-grpc_out，go_out ),这些标志是我们安装的代码生成器。然后我们说=。这意味着输出当前目录中的代码。这意味着protoc将为我们生成四个文件。我们很快就会用到它们。因此，如果您想添加另一种类型的客户机，比如Java客户机，您可以添加java_out选项。</p><h2 id="6bc8" class="mo mp it bd mq mr ms dn mt mu mv dp mw li mx my mz lm na nb nc lq nd ne nf ng bi translated">Go gRPC服务器</h2><p id="21c7" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如果我们看一下protoc生成的<strong class="lb iu"> service_grpc.pb.go </strong>文件，我们会发现它为我们创建了一个接口。它为我们生成了很多代码，但是它不知道Monitor方法会做什么，所以这取决于开发人员。生成的代码都是关于建立一个连接和使gRPC工作所需的一切，这是我们将保持原样的东西。</p><p id="faa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对界面不是很熟悉，你可以阅读<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/interfaces-in-go-5c6e38b81b41">我的关于界面的文章</a>。生成的界面如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">生成的gRPC接口。</figcaption></figure><p id="826c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的是打开<strong class="lb iu"> server.go </strong>并编辑它，使它成为HardwareMonitorServer接口的一部分。这意味着我们需要实现Monitor方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">每秒输出统计数据的服务器。</figcaption></figure><p id="d1a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当server.go设置好后，我们还需要一些运行服务器的方法。这在<strong class="lb iu"> main.go </strong>中完成。主服务器将只监听到端口7777的TCP连接，并在该端口上托管我们的gRPC硬件监控服务器。这将允许来自web客户端或go客户端的客户端执行Monitor方法。记住，这是<strong class="lb iu"> RPC，</strong>所以任何请求都只是在服务器上执行方法的指令。这就是为什么我们可以拥有多种语言的客户端。注意，这个gRPC API将在不安全的连接上运行。生产中要加TLS，见我关于<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/using-grpc-with-tls-golang-and-react-no-envoy-92e898bf8463"> gRPC和TLS </a>的文章。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这是我们运行服务器的简单Main</figcaption></figure><h2 id="e2d7" class="mo mp it bd mq mr ms dn mt mu mv dp mw li mx my mz lm na nb nc lq nd ne nf ng bi translated">Go中的客户端</h2><p id="2d2c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">既然服务器已经启动并运行，我们需要创建一个客户机来测试它。我先从用Go写的客户端开始。</p><p id="80c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端将非常简单，它将连接到gRPC服务器并建立一个流，监听7秒钟，然后终止。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">客户端设置一个流并监听7秒钟。</figcaption></figure><p id="83e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您填写完client.go后，是时候进行测试了。只需在服务器上运行<strong class="lb iu">，然后在客户端运行</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/988b786dd9b067df7e656eb27bc8bd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5p8oZm8zMRAgGaR_9RdmQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">显示客户端和服务器运行的示例。</figcaption></figure><h2 id="9ba3" class="mo mp it bd mq mr ms dn mt mu mv dp mw li mx my mz lm na nb nc lq nd ne nf ng bi translated">web应用程序中的客户端</h2><p id="b2c8" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">对于web应用程序，我将使用react和<a class="ae ky" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>。</p><p id="1191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以创建网络应用程序需要安装更多的软件，我很抱歉！:)</p><p id="3267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://www.npmjs.com/get-npm" rel="noopener ugc nofollow" target="_blank"> NPM，所以从得到那个</a>开始。</p><p id="6181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要一些protobuf和gRPC库，以便我们可以使用客户端。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="9ba8" class="mo mp it no b gy ns nt l nu nv">npm install -g npx<br/>npm install grpc-web<br/>npm install google-protobuf</span></pre><p id="aa2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建名为hwmonitor的react应用程序。所以首先你需要进入<strong class="lb iu"> webapp </strong>文件夹，运行以下命令生成react应用。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f7c5" class="mo mp it no b gy ns nt l nu nv">npx create-react-app hwmonitor</span></pre><p id="2a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦命令运行完毕，我们将需要创建一个新的目录，并将生成的protobuf文件复制到其中。我将在<strong class="lb iu">grpc streams/web app/HW monitor/src/proto中创建proto文件夹。</strong></p><p id="0629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要忘记将<strong class="lb iu"> service_pb.js </strong>和<strong class="lb iu"> service_grpc_web_pb.js </strong>都复制到新的proto文件夹中。</p><p id="0285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是打开<strong class="lb iu"> service_pb.js的好时机</strong>在这个文件中，我们可以看到生成的protobuf对象，这在我们想要到达数据的时候很重要。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">显示的toObject函数，用于查看哪些字段可用。</figcaption></figure><p id="d223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到该对象包含3个字段，cpu，memoryFree，memoryUsed。所以我们的字段是小写的。知道这一点很好，因为我们需要这些字段来显示数据。</p><p id="017e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将在react应用程序中打开名为<strong class="lb iu"> App.js </strong>的文件并对其进行修改。它将与go中的客户端相同，它将启动一个流并打印出数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">要点显示了我们如何使用流来更新统计数据。</figcaption></figure><p id="4df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用上面的代码修改App.js之后，执行<strong class="lb iu"> npm run build </strong>命令来构建应用程序。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="5533" class="mo mp it no b gy ns nt l nu nv">npm run build</span></pre><p id="b715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的构建由于PROTO未知而失败，请访问这篇文章，我在文章的底部描述了如何<strong class="lb iu">修复它。</strong></p><div class="on oo gp gr op oq"><a href="https://programmingpercy.tech/blog/using-grpc-tls-go-react-no-reverse-proxy/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">将gRPC与TLS、Golang、React一起使用，无需反向代理(Envoy)</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">一篇关于如何在Go后端服务器和React客户端之间实现gRPC而不使用反向代理的文章…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">编程percy.tech</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div><p id="e65b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的NPM构建命令有效，您应该会看到一个名为build的新目录。我们需要更新main.go来作为文件服务器托管这个目录，并更新它来托管HTTP上的gRPC API。</p><h2 id="1caa" class="mo mp it bd mq mr ms dn mt mu mv dp mw li mx my mz lm na nb nc lq nd ne nf ng bi translated">更新main.go</h2><p id="df5f" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们将更新main.go来托管gRPC和React应用程序。我们将添加一些通过HTTP服务于react应用程序的代码，并在HTTP连接上复用gRPC。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">main.go现在通过HTTP和TCP托管gRPC服务器，</figcaption></figure><p id="5029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们为golang客户端和web客户端托管API。访问<a class="ae ky" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> localhost:8080 </a>，你应该会看到服务器的硬件统计。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/95daa37eb9db39dd3e026071b5455ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*2A5nTOf4UMP48h4JRy9SWQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">每次服务器推送更新时，统计数据都会更新</figcaption></figure><p id="df0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章大概就是这样。您已经了解了如何让您的服务器更满意，而不是让它将数据推送到客户端。而不是所有这些客户端频繁地向您的服务器请求更新。只希望机器统治的时候能饶你一命就够了。</p><p id="a1ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有任何想法、问题、批评或反馈，请随时联系我。</p><p id="0323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记得去<strong class="lb iu">顺流而下。</strong></p></div></div>    
</body>
</html>