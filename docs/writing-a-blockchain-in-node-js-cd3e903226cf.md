# 在 Node.js 中编写区块链

> 原文：<https://itnext.io/writing-a-blockchain-in-node-js-cd3e903226cf?source=collection_archive---------0----------------------->

## 从头开始编写功能性区块链从未如此容易

![](img/4fe3fabcb192e026b841cd1de8ae86fe.png)

照片由[思想目录](https://unsplash.com/@thoughtcatalog)上的 [Unsplash](https://unsplash.com)

区块链是目前计算机科学领域的热门话题。它在 2008 年因比特币加密货币而闻名，比特币加密货币(你可能知道)使用区块链将每笔交易记录到公共分布式账本中。但是……我们对区块链了解多少？我的意思是，如果我们想了解区块链是如何工作的，是什么让它如此强大？应该如何开始？让我们从基础开始吧！

# 什么是区块链？

区块链的字面意思是区块链，其中区块是存储在公共数据库链中的一条信息。在 JavaScript 中，我们可以将块视为一个对象:

现在，让我们来分析上面的块:

*   时间戳:块创建的时间戳。
*   数据:包含在块中的数据。它可以是任何东西:对象、字符串、数字……我们通常将事务数据存储在块的这一部分中。
*   哈希:当前块哈希。表示块中包含的数据。如果我们编辑这个块中的任何内容，我们的散列将会改变。
*   previousHash:表示前一个块的哈希。

等等，等等，等等！上一个街区？是啊！事实上，区块链的关键特征是，链中的每个区块都必须包含代表前一个区块的数据。这样，如果您想要修改一个块，您必须重新计算整个链，这(我们将在后面看到)可能非常困难(如果不是不可能的话)。出于这个原因，我们可以说区块链是一个不可改变的结构。

> 以后想看这个故事吗？将它保存在日志中。

# 构建极简区块链

那么，我们如何开始写我们的区块链呢？首先，让我们定义一下区块链最重要的功能:计算区块散列的功能。

如您所见，为了计算我们块的 hash，我们需要四个参数:`previousHash`、`timestamp`、`data`和`nonce`。我们已经看到了前三个参数是什么，但是为什么我们需要一个 nonce？出于安全考虑。我们不想让潜在的恶意开发者改变一个块的内容，然后重新计算整个链使其有效。出于这个原因，我们需要定义一些关于如何将散列格式化为有效的约束。

例如，假设我们有以下块:

它的散列将在几毫秒内计算出来，看起来像这样:

那么，这有什么错呢？想象一下，我们有一台每秒钟能够执行数千次散列计算的超级计算机。重新计算整个链条需要多长时间？我们可以通过设置一些约束，让他的日子更难过。例如，我们可以决定一个散列只有在以四个 0 和四个 9 开始时才有效:

但是散列依赖于块的内容…我们如何尊重这个约束呢？随机数来了！nonce 是在我们的哈希计算过程中插入的一个随机值，它使我们更有可能得到一个格式良好的哈希。我们的哈希不尊重强加的规则？让我们用不同的随机数再计算一次。

现在让我们测试一些不同的约束，看看计算散列需要多长时间:

*   哈希必须以两个零开头:`211ms`
*   哈希必须以三个零开头:`297ms`
*   哈希必须以五个零开头:`5966ms`
*   哈希必须以`f5` : `174ms`开头
*   哈希必须以`0990` : `196ms`结尾
*   哈希必须以`f918`结尾:`4436ms`

现在想象一下，如果我们定义一个非常耗时的规则…如果计算一个块需要大约四个小时，那么计算(或“挖掘”)整个链需要多少时间？

# 创世街区

区块链的第一块被称为“创世块”。它不能有“前一个散列”值，所以编写一个生成它的函数非常简单:

太好了！所以现在我们可以尝试运行`generateGenesisBlock`函数，让我们看看会发生什么:

厉害！

# 开采新区块

现在我们需要一个为区块链计算新区块的函数。但是首先，我们需要定义我们的散列约束:

在上面的函数(`checkDifficulty`)中，我们可以传递两个参数:`difficulty`和`hash`。我们希望事情超级简单，所以(对于那个实现)，我们决定我们的散列必须以 4 个零开始。如果传递的散列符合约束条件，则该函数返回`true`。否则将返回`false`，所以我们需要改变 nonce 再次计算它(如前所述)。

你可能已经注意到了，为了保证更易测试和模块化的代码库，我们采用了函数式范例。因此，为了计算下一个 nonce，我们需要一个函数来获取这个块并返回它的修改版本，包含一个新的 nonce。我们想避免副作用，所以我们不会直接编辑我们的`nonce`值:

如你所见，我们正在返回`updateHash`的结果，它基本上接受了这个块，并返回一个带有新散列的新版本:

最后但同样重要的是，我们需要一个递归函数来计算我们的块的散列，直到它遵守强加的约束。但这里就出现了一个问题:如何让 JavaScript 中的递归变得安全？谢天谢地，我写了一篇关于 JavaScript 中递归以及如何使其内存安全的文章。让我们实现一个蹦床([在这里了解更多](https://medium.com/openmindonline/js-monday-06-adopting-memory-safe-recursion-d26dcee409c9)):

这将是我们代码库中唯一不纯的部分，但是为了防止一些[内存相关的错误](https://medium.com/openmindonline/js-monday-06-adopting-memory-safe-recursion-d26dcee409c9)，这是绝对必要的。

现在让我们把它们放在一起:

不要害怕！我们来分析一下上面的代码:

*   我们定义了一个新的函数，它将`difficulty`和`block`作为参数。`difficulty`只是一个数字，表示我们的哈希应该从多少个零开始，`block`只是我们想要挖掘的块。
*   我们定义一个函数`mine`，它将`block`作为参数。
*   在这个函数中，我们用一个新的 nonce 创建了一个新的块。
*   然后我们需要检查散列是否遵守我们的规则。如果是，让我们返回我们的`newBlock`块作为结果。否则，我们需要改变它的 nonce 并再次挖掘它。
*   现在我们有了`mine`函数，我们将它包装在`trampoline`中。它将递归地运行这个函数，直到我们为我们的块得到一个正确的散列。

我们现在需要最后一个函数:

如您所见，`addBlock`函数将整个链作为它的第一个参数，新的块数据作为它的第二个参数。然后，它挖掘新的块，并返回包含新创建的块的新链。

# 验证链

到目前为止，我们已经做了很多工作！我们现在需要实现一个函数，在插入新块后验证整个链:

这个函数非常简单明了:

*   我们创建一个新的函数，将整个链作为它的参数。
*   我们定义了一个名为`tce`(代表[尾调用消除](https://www.jsmonday.dev/articles/6/adopting-memory-safe-recursion))的新函数，它将链和块索引作为其参数。
*   如果我们正在查看我们的链的第一个索引(Genesis 块)，我们将返回`true`。
*   否则，我们需要检查一些条件:当前块的散列是否有效？前一个块的哈希是否有效？那么链条有效吗(直到现在)？

这非常简单，但却非常强大！

# 把所有东西放在一起

现在我们终于准备好测试我们的区块链了！首先，我们来初始化一下:

现在，让我们创建一个新的块:

我们现在准备开采这个新区块！

让我们记录新创建的链:

我们现在可以向区块链添加任意多的块了！

# 一些考虑

我们刚刚建立了一个功能性的区块链，完全没有副作用。我们可以轻松地编写测试并获得 100%的覆盖率，当我们想要编写一个可以处理大量数据的应用程序时，这是一件需要记住的重要事情。

使用类而不是纯函数，使用 for 循环而不是递归可以带来更简单和更高的性能…但是我们并不太关心性能(我的意思是，我们花了几天时间来挖掘块，这些毫秒级的 for 循环性能真的很重要吗？)而且我们不希望它太简单:我们希望它是坚实的。函数式编程可以帮助你编写更可靠的代码，具有可重用的函数和优秀的测试。

# 后续步骤

我们只是触及了区块链如何工作以及如何构建区块链的表面，还有很多工作要做！

*   尝试改进哈希约束。试着找到一个规则，使得挖掘一个新的区块变得困难。
*   Node.js 和浏览器上没有实现尾调用递归(即使 EcmaScript 语言规范中有描述)。试着把`validateChain`里面的`tce`功能转换成蹦床！
*   我们说过，我们不希望我们的区块链中有可变的值。那么我们如何处理更新现有链的新块创建呢？

# 「矿工」是怎么拿到钱的？

如你所见，开采新区块需要大量的时间，这可以转化为电能成本。出于这个原因，开采新区块的人可以在开采后获得“奖励”。钱就是这么来的！

📝把这个故事保存在[杂志](https://usejournal.com/?utm_source=medium.com&utm_medium=noteworthy_blog&utm_campaign=tech&utm_content=guest_post_read_later_text)上。