<html>
<head>
<title>How to Cache Aggregated Data with Redis and Lua Scripts for a Scaled Microservice Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Redis和Lua脚本为扩展的微服务架构缓存聚合数据</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-cache-aggregated-data-with-redis-and-lua-scripts-for-a-scaled-microservice-architecture-2b791289e911?source=collection_archive---------1-----------------------#2021-06-30">https://itnext.io/how-to-cache-aggregated-data-with-redis-and-lua-scripts-for-a-scaled-microservice-architecture-2b791289e911?source=collection_archive---------1-----------------------#2021-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/76b2e7e6b5da7b6bac204cee9cce0623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U66Fz7DyCj9TBzJWSL6LTw.png"/></div></div></figure><p id="7178" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个基于微服务的扩展应用程序拥有<strong class="ka ir">大量不断增长的数据</strong>，它面临着<strong class="ka ir">挑战，要有效地交付像top lists这样的聚合数据</strong>。</p><p id="3bbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，<strong class="ka ir">我将向您展示如何使用Redis来缓存聚合数据</strong>。而数据库将项目/行数据存储为“真实的来源”,并使用分片进行缩放。</p><blockquote class="kw kx ky"><p id="3ee5" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">一个Redis实例每秒可以处理大约100，000次操作</p></blockquote><p id="a33f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的带有用户、帖子和类别的示例数据模型可以作为您自己的用例的基础。</p><h2 id="4c1b" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">内容</h2><ol class=""><li id="125a" class="lw lx iq ka b kb ly kf lz kj ma kn mb kr mc kv md me mf mg bi translated">示例用例及数据模型</li><li id="91a3" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv md me mf mg bi translated">设置Redis并实现顶级类别</li><li id="964b" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv md me mf mg bi translated">顶级用户、最新用户帖子和收件箱模式</li><li id="80e6" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv md me mf mg bi translated">原子性的Lua脚本</li><li id="ca6a" class="lw lx iq ka b kb mh kf mi kj mj kn mk kr ml kv md me mf mg bi translated">最后的想法和展望</li></ol></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="5a88" class="mt le iq bd lf mu mv mw li mx my mz ll na nb nc lo nd ne nf lr ng nh ni lu nj bi translated">1.示例用例及数据模型</h1><p id="808f" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">在示例中，微服务应用程序用户可以按类别写帖子。他们也可以按类别阅读文章，包括作者姓名。最新的帖子在最上面。类别是固定的，很少改变。</p><blockquote class="kw kx ky"><p id="6d35" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">如果您对示例应用程序的源代码和更多细节感兴趣，请参见我之前的帖子“如何使用数据库分片和扩展ASP.NET核心微服务架构”。</p></blockquote><p id="95a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">逻辑数据模型:</strong></p><figure class="np nq nr ns gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/ac8acad6284b1be70e83d0ea33e0ac47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CyQDNhXl1RpHv14c.png"/></div></div></figure><p id="a02c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，有100万用户。每个用户每天大约写十篇文章。</p><h2 id="1c8c" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">十大类别</h2><p id="44f3" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">前10个类别将显示在主页上。对于MySql来说，这需要一个这样的语句:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="648f" class="ld le iq nu b gy ny nz l oa ob">SELECT CategoryId, COUNT(PostId) FROM Post GROUP BY CategoryId ORDER BY COUNT(PostId) LIMIT 10;</span></pre><p id="abc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对数百万行执行这条语句会非常慢。而且每一次页面访问，都是<strong class="ka ir">不可能</strong>的。</p><p id="6850" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为数据量大，我也决定按类别分片。因此，这将需要<strong class="ka ir">合并来自多个数据库的顶部列表</strong>:</p><figure class="np nq nr ns gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/522e1e70453ed73c9936bfae1539343f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rp_9Zd0-TZyU1zE1.png"/></div></div></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="712f" class="mt le iq bd lf mu mv mw li mx my mz ll na nb nc lo nd ne nf lr ng nh ni lu nj bi translated">2.设置Redis并实现顶级类别</h1><p id="db9d" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated"><strong class="ka ir">安装</strong> <a class="ae nn" href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Docker桌面</strong>T21】</a></p><p id="6b07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建Redis容器:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="cb58" class="ld le iq nu b gy ny nz l oa ob">C:\dev&gt;docker run --name redis -d redis</span></pre><p id="f635" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">连接到容器并启动redis-cli:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="ef6e" class="ld le iq nu b gy ny nz l oa ob">C:\dev&gt;docker exec -it redis redis-cli</span></pre><h2 id="a4d2" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">添加热门类别</h2><p id="4634" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">顶层类别("<em class="kz"> CategoriesByPostCount </em>")使用一个<a class="ae nn" href="https://redislabs.com/ebook/part-2-core-concepts/chapter-3-commands-in-redis/3-5-sorted-sets/" rel="noopener ugc nofollow" target="_blank"> Redis排序集</a> (ZSET)。</p><p id="6e9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">增加第一个条目</strong>，为类别“<em class="kz">类别5 </em>”增加<a class="ae nn" href="https://redis.io/commands/ZADD" rel="noopener ugc nofollow" target="_blank">和</a>以及99个员额:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="ac64" class="ld le iq nu b gy ny nz l oa ob">127.0.0.1:6379&gt; ZADD CategoriesByPostCount GT 99 "Category5"</span></pre><p id="10ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它添加了一个条目:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="1a89" class="ld le iq nu b gy ny nz l oa ob">(integer) 1</span></pre><p id="0244" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">再添加一些条目:</strong></p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="2b53" class="ld le iq nu b gy ny nz l oa ob">&gt; ZADD CategoriesByPostCount GT 1 "Category1"</span><span id="607a" class="ld le iq nu b gy od nz l oa ob">(integer) 1</span><span id="2d8d" class="ld le iq nu b gy od nz l oa ob">&gt; ZADD CategoriesByPostCount GT 10 "Category2"</span><span id="6e5f" class="ld le iq nu b gy od nz l oa ob">(integer) 1</span></pre><p id="e88b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新<em class="kz">类别5: </em></p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="5543" class="ld le iq nu b gy ny nz l oa ob">&gt; ZADD CategoriesByPostCount GT 100 "Category5"</span><span id="eb0f" class="ld le iq nu b gy od nz l oa ob">(integer) 1</span><span id="0bd4" class="ld le iq nu b gy od nz l oa ob">&gt; ZADD CategoriesByPostCount GT 98 "Category5"</span><span id="cf78" class="ld le iq nu b gy od nz l oa ob">(integer) 0</span></pre><p id="8c69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个命令给出的结果为零。这是由于<em class="kz"> GT </em>参数造成的。该参数有助于处理更新无序到达的情况(post计数不会减少)。</p><h2 id="a324" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated"><strong class="ak">阅读热门类别</strong></h2><p id="e582" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">使用<a class="ae nn" href="https://redis.io/commands/zrange" rel="noopener ugc nofollow" target="_blank"> ZRANGE </a>并读取帖子数量最多的10个类别:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="adbe" class="ld le iq nu b gy ny nz l oa ob">&gt; ZRANGE CategoriesByPostCount 0 9 WITHSCORES REV</span><span id="32ef" class="ld le iq nu b gy od nz l oa ob">1) "Category5"<br/>2) "100"<br/>3) "Category2"<br/>4) "10"<br/>5) "Category1"<br/>6) "1"</span></pre><p id="c7a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">轻松检索第二页(第11-20项)等:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="4c05" class="ld le iq nu b gy ny nz l oa ob">ZRANGE CategoriesByPostCount 10 19 WITHSCORES REV</span></pre><h2 id="ebad" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">先决条件</h2><p id="5d93" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">创建新帖子时，可以在SQL中计算每个类别的帖子:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="bfbc" class="ld le iq nu b gy ny nz l oa ob">BEGIN TRANSACTION<br/>INSERT INTO Post (...)<br/>UPDATE Categories SET PostCount = PostCount + 1<br/>COMMIT TRANSACTION</span></pre><p id="376f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是可能的，因为数据库是按类别划分的。一个类别的所有文章都在同一个数据库中。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="add7" class="mt le iq bd lf mu mv mw li mx my mz ll na nb nc lo nd ne nf lr ng nh ni lu nj bi translated">3.顶级用户、最新用户帖子和收件箱模式</h1><p id="6c69" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated"><strong class="ka ir">用户的帖子分散在所有碎片上</strong>。不能使用<code class="fe oe of og nu b">UPDATE User SET PostCount = PostCount + 1</code>然后更新Redis。</p><p id="e907" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">Redis中的运算必须是“幂等的”。收件箱模式使这成为可能。</strong></p><p id="ed43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kz">延伸阅读:</em> <a class="ae nn" href="https://event-driven.io/en/outbox_inbox_patterns_and_delivery_guarantees_explained/" rel="noopener ugc nofollow" target="_blank"> <em class="kz">发件箱、收件箱模式和交付保证解释</em> </a></p><h2 id="54ba" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">添加帖子(带有竞争条件)</h2><p id="064a" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">在每个新的帖子上添加一个条目到用户的<em class="kz"> PostsByTimestamp </em>排序集合中:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="a3c8" class="ld le iq nu b gy ny nz l oa ob">&gt; ZADD {User:5}:PostsByTimestamp 3455667878 '{Title: "MyPostTitle", Category: "Category5", PostId: 13}'</span><span id="6c2e" class="ld le iq nu b gy od nz l oa ob">(integer) 1</span></pre><p id="5da5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后增加<em class="kz"> UsersByPostCount </em>中的帖子计数:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="62b8" class="ld le iq nu b gy ny nz l oa ob">&gt; ZINCRBY UsersByPostCount 1 "5"</span></pre><p id="e540" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使它幂等，检查将文章添加到收件箱的结果。再次发出该命令得到的结果为零(条目已经存在):</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="e77d" class="ld le iq nu b gy ny nz l oa ob">&gt; ZADD {User:5}:PostsByTimestamp 3455667878 '{Title: "MyPostTitle", Category: "Category5", PostId: 13}'</span><span id="faa1" class="ld le iq nu b gy od nz l oa ob">(integer) 0</span></pre><p id="17e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后不要递增<em class="kz"> UsersByPostCount。</em></p><p id="8915" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">命令ZADD到PostsByTimestamp和命令ZINCRBY到UsersByPostCount必须是原子的</strong>。我将向您展示如何使用Redis Lua脚本使其原子化。但首先，让我们来看看排名靠前的用户和最新的用户帖子。</p><h2 id="8af7" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">阅读热门用户和最新用户帖子</h2><p id="b625" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated"><strong class="ka ir">前10名用户:</strong></p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="2130" class="ld le iq nu b gy ny nz l oa ob">&gt; ZRANGE UsersByPostCount 0 9 WITHSCORES REV</span><span id="1212" class="ld le iq nu b gy od nz l oa ob">1) "6"<br/>2) "10"<br/>3) "5"<br/>4) "8"<br/>5) "3"<br/>6) "4"<br/>7) "1"<br/>8) "3"</span></pre><p id="c465" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ID为6的用户有10篇帖子，ID为5的用户有8篇帖子，依此类推。</p><p id="210a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">ID为5的用户的热门帖子:</strong></p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="86fb" class="ld le iq nu b gy ny nz l oa ob">&gt; ZRANGE {User:5}:PostsByTimestamp 0 9 WITHSCORES REV</span><span id="69df" class="ld le iq nu b gy od nz l oa ob">1) "{Title: \"MyPostTitle2\", Category: \"Category1\", PostId: 14}"<br/>2) "3455667999"<br/>3) "{Title: \"MyPostTitle\", Category: \"Category5\", PostId: 13}"<br/>4) "3455667878"</span></pre><h1 id="0ebd" class="mt le iq bd lf mu oh mw li mx oi mz ll na oj nc lo nd ok nf lr ng ol ni lu nj bi translated">4.原子性的Lua脚本</h1><h2 id="af27" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">使用Lua脚本自动添加帖子</h2><p id="a0e6" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">一个<a class="ae nn" href="https://redislabs.com/ebook/part-3-next-steps/chapter-11-scripting-redis-with-lua/" rel="noopener ugc nofollow" target="_blank"> Redis Lua脚本</a>可以使命令ZADD到PostsByTimestamp和命令ZINCRBY到UsersByPostCount原子化。但是每个用户需要一个额外的计数器，以便所有的关键参数映射到同一个<a class="ae nn" href="https://redislabs.com/blog/redis-clustering-best-practices-with-keys/" rel="noopener ugc nofollow" target="_blank"> Redis散列标签</a>。</p><blockquote class="kw kx ky"><p id="c98e" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">键“{User:5}:PostsByTimestamp”中的花括号是Redis散列标签的符号。</p></blockquote><p id="bf12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个Lua脚本试图向一个有序集合添加一个键。如果它可以添加密钥，它还会增加一个计数器。如果该键已经存在，它将返回该键的值:</p><figure class="np nq nr ns gt jr"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9be6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<a class="ae nn" href="https://redis.io/commands/eval" rel="noopener ugc nofollow" target="_blank"> EVAL </a>调用Lua脚本并传递“<em class="kz">{ User:8 }:PostsByTimestamp</em>”和“<em class="kz"> {User:8}:PostCount </em>”作为键(命令行一行)；</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="703f" class="ld le iq nu b gy ny nz l oa ob">&gt; EVAL "if tonumber(redis.call('ZADD', KEYS[1], ARGV[1], ARGV[2])) == 1 then return redis.call('INCR', KEYS[2]) else return redis.call('GET', KEYS[2]) end" 2 {User:8}:PostsByTimestamp {User:8}:PostCount 3455667999 "{Title: \"MyPostTitle2\", Category: \"Category1\", PostId: 14}"</span><span id="f267" class="ld le iq nu b gy od nz l oa ob">(integer) 1</span></pre><p id="df40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在<em class="kz"> UsersByPostCount </em>中设置用户8的计数:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="f4f5" class="ld le iq nu b gy ny nz l oa ob">ZADD UsersByPostCount GT 1 "8"</span></pre><h2 id="188b" class="ld le iq bd lf lg lh dn li lj lk dp ll kj lm ln lo kn lp lq lr kr ls lt lu lv bi translated">将脚本存储在Redis中</h2><p id="46a9" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">出于性能原因，您可以将sript存储在Redis中:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="5aa6" class="ld le iq nu b gy ny nz l oa ob">&gt; SCRIPT LOAD "if tonumber(redis.call('ZADD', KEYS[1], ARGV[1], ARGV[2])) == 1 then return redis.call('INCR', KEYS[2]) else return redis.call('GET', KEYS[2]) end"</span><span id="2790" class="ld le iq nu b gy od nz l oa ob">"cd9222afab5eb8d579942016a8c22427eff99429"</span></pre><p id="6fc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用散列来调用脚本:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="dca2" class="ld le iq nu b gy ny nz l oa ob">&gt; EVALSHA "cd9222afab5eb8d579942016a8c22427eff99429" 2 {User:8}:PostsByTimestamp {User:8}:PostCount 4455667999 "{Title: \"MyPostTitle3\", Category: \"Category1\", PostId: 20}"</span><span id="f8a5" class="ld le iq nu b gy od nz l oa ob">(integer) 2</span></pre></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="4cdd" class="mt le iq bd lf mu mv mw li mx my mz ll na nb nc lo nd ne nf lr ng nh ni lu nj bi translated">5.最后的想法和展望</h1><p id="24d0" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj nk kl km kn nl kp kq kr nm kt ku kv ij bi translated">在本文中，您<strong class="ka ir">设置了Redis </strong>，并从一个简单的用例开始<strong class="ka ir">缓存聚合数据</strong>。然后使用<strong class="ka ir">收件箱模式</strong>和<strong class="ka ir"> Lua脚本</strong>来实现原子性。</p><p id="ef52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的下一篇文章中，我将向你展示如何在一个C # ASP.NET核心微服务应用中实现它。</p><p id="9a3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redis提供了比我在这篇文章中展示的更多的T21。您可以<strong class="ka ir">探索其他命令和</strong> <a class="ae nn" href="https://redislabs.com/blog/5-industry-use-cases-for-redis-developers/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">用例</strong> </a>它们如何解决您应用中的问题。在实际应用中，您可能不得不使用TTL来自动终止条目,这样缓存就不会无限制地增长。也许你还需要<strong class="ka ir">缩放Redis </strong>。</p><p id="f5b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您有任何问题、想法或建议，请联系我。</p></div></div>    
</body>
</html>