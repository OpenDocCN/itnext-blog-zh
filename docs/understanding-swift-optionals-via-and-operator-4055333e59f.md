# 了解 Swift 可选 Via？还有！操作员

> 原文：<https://itnext.io/understanding-swift-optionals-via-and-operator-4055333e59f?source=collection_archive---------0----------------------->

## 初学者概述；专业版快速参考。

![](img/36ebc041df93e03275a3072c75244633.png)

【swiftsenpai.com】*更新注* *:本文更新版本已发布至*[](https://swiftsenpai.com/swift/making-sense-of-swift-operators/)**。**

*在选择 Swift 时，挑战之一是了解可选方案的工作方式。新学习者在处理可选项目时，通常会弄不清是应该使用`?`还是`!`。*

*在本文中，我将通过探索`?`和`!`操作符的用法来帮助您理解 optional 背后的概念。如果您是 Swift 的初学者，这篇文章应该能让您很好地了解 optional 是如何工作的。*

*对于有经验的 Swift 开发人员来说，当您在处理可选操作员时有疑问时，可以将此作为快速参考。*

*话虽如此，我们还是开始吧！🚀*

# *申报*

```
*var myVariable: MyType*
```

*   *声明`myVariable`为非可选类型`MyType`。*
*   *`myVariable`不会是`nil`的整个生命周期。*

```
*var myVariable: MyType**?***
```

*   *将`myVariable`声明为可选`MyType`。*
*   *`myVariable`可以是`nil`在其生命周期的某个点。*
*   *通过使用可选绑定或强制解包，只能访问**的`myVariable`值。*(继续阅读关于可选绑定和强制解包的更多信息)****

```
*var myVariable: MyType**!***
```

*   *将`myVariable`声明为隐式展开的可选`MyType`。*
*   *`myVariable`可以是`nil`在其生命周期的某个点。*
*   *使用可选绑定，有或没有都可以访问`myVariable`的值。*
*   *如果`myVariable`为`nil`并且是在没有使用可选绑定的情况下被访问，**运行时错误** **将触发**。*

## *重要注意事项*

*   *始终将变量声明为非可选类型。*
*   *仅当您不能在变量的类或结构初始化期间初始化变量时，使用可选类型，和/或它可能在初始化后的某个时间点变成`nil`。*
*   *尽量避免使用隐式展开的可选类型，因为这可能会导致运行时错误**。仅当我们无法在变量的类或结构初始化期间初始化变量，但我们确信变量在初始化后的整个生命周期内不会被初始化时，才使用隐式展开的可选类型。隐式展开可选类型的最好例子是为视图控制器创建的 IBOutlets。***

# ***打开***

***在这里，我们将研究访问可选类型值的基本概念和方法，主要是可选绑定和强制解包。***

## ***可选绑定***

*   ***当试图访问带有`nil`值可选变量时，代码将正常失败，不会触发运行时错误。***
*   ***下面的代码片段演示了可选绑定是如何工作的。***

***可选绑定***

*   ***请注意，可选绑定也可以用于隐式取消包装的可选类型。然而，这是相当罕见的，相当多余的。***

## ***强制展开***

*   ***使用`!`运算符强制访问可选类型的值。***
*   ***当可选变量为`nil`时，将触发**运行时错误**。***
*   ***下面是如何使用`!`操作符来强制展开一个可选变量。***

```
***let myString: String? = “test”
let value = myString**!** // Forced unwrapping***
```

## ***重要注意事项***

*   ***与强制解包相比，可选绑定是一种更优雅的解包可选变量的方式，总是使用可选绑定来解包可选值。***
*   ***强制解包使用起来很危险，如果可能的话尽量避免使用。***

# ***向下铸造***

***在 Swift 中处理向下转换时，`?`和`!`操作符都非常重要。然而，开发人员有时可能会搞不清楚在执行向下转换时，他或她应该使用`as`、`as!`还是`as?`。***

```
***as***
```

*   ***`as`当编译器保证强制转换成功时，运算符用于将一种类型转换为另一种类型。***
*   ***常见的用例是从`String`到`NSString`、`NSDate`到`Date`的造型，或者将对象造型回其父类类型。***

```
***as?***
```

*   ***当铸造操作可能失败时，使用`as?`操作符。我们称之为条件强制转换。***
*   ***条件强制转换将产生所需类型的可选形式。***
*   ***强制转换操作失败时返回`nil`。***
*   ***由于转换结果是可选类型，我们可以使用可选绑定来访问转换结果的值。***

```
***as!***
```

*   ***`as!`是强制强制转换运算符。***
*   ***强制转换将生成所需类型的非可选形式。***
*   ***当 cast 操作失败时，**运行时错误**将被触发。***
*   ***由于转换结果是非可选类型，我们可以在不使用可选绑定的情况下访问转换结果值。***

***如果你发现上面的解释有点难以理解。让我们看看下面的代码片段，它演示了如何使用每个`as`操作符执行向下转换，以及每种情况下的结果是什么，这应该会让你明白一些事情…***

***向下投射演示***

***请随意将上面的代码复制到您的 Xcode playground 中，并亲自尝试一下。***

## ***向下转换为可选类型***

***基于上面讨论，我们可以通过尝试向下转换到可选类型来探索更多。***

***向下转换为可选类型***

***不要被每个造型末尾的`?`和`!`符号弄糊涂了，如果你仔细观察，它们都有与前面例子相同的行为，即使期望的造型类型是可选类型。***

***请注意，向下转换为隐式取消包装的可选类型已被否决，并将在未来的版本中被移除。这确实有意义，因为向下转换为隐式展开的可选类型与向下转换为可选类型是一样的，它们都产生相同的结果。*(可以查看*`*chicken4*`*`*chicken5*`*`*chicken8*`*`*chicken9*`*)*******

## ****重要注意事项****

*   ****总是使用可选绑定来检查条件转换结果。****
*   ****避免使用可能触发**运行时错误**的强制绑定。****

# ****初始化****

****接下来，我们将研究故障初始化器。当对象初始化可能失败时，我们需要一个失败的初始化器。如果初始化失败，可失败的初始化器将返回`nil`。我们使用`?`操作符将初始化器标记为故障。****

****希望这篇文章能帮助你更清楚地了解如何以及何时使用`?`和`!`操作符。如果你有任何意见或问题，请写在下面的评论区。请随意点击👏按钮或分享这篇文章如果你喜欢它。****

****如果你想在以后读到更多这样的文章，请在**媒体**或[推特](https://twitter.com/Lee_Kah_Seng) 上关注我。****

****有兴趣的，下面是我的 [**LinkedIn**](https://www.linkedin.com/in/lee-kah-seng-55720645/) 和**[**Github**](https://github.com/LeeKahSeng)**。********

******![](img/ac1700eaa9da7ccdc090ca65d354f4aa.png)******

******[kahseng.lee123@gmail.com](http://kahseng.lee123@gmail.com)******