<html>
<head>
<title>C for JavaScript Developers. Program Compilation. Source vs Header Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向JavaScript开发人员的c。程序编译。源文件和头文件</h1>
<blockquote>原文：<a href="https://itnext.io/c-for-javascript-developers-program-compilation-source-vs-header-files-1829a69a0a56?source=collection_archive---------2-----------------------#2018-11-29">https://itnext.io/c-for-javascript-developers-program-compilation-source-vs-header-files-1829a69a0a56?source=collection_archive---------2-----------------------#2018-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a93b4d35352b87d69a83b26777caa2ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QG4a-uHE6EROTidQ71LI5w.jpeg"/></div></div></figure><p id="5e0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个hello-world应用程序。</p><p id="bea8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">main.c</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="97fe" class="li lj iq kz b gy lk ll l lm ln">#include &lt;stdio.h&gt;</span><span id="2f2f" class="li lj iq kz b gy lo ll l lm ln">int main(void) {<br/>  puts("Hello World!");<br/>  return 0;<br/>}</span></pre><p id="993c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个普通的c语言工作程序。如果你来自一个更高级的语言背景(比如说JavaScript)，这段代码似乎很有意义。我们定义一个函数，这个函数又调用另一个函数并返回值。</p><p id="8c50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是C和JavaScript是非常不同的语言。前者是编译的，相对低级，它的原语很好地映射到计算机在硬件层面上的工作方式。后者处理更高级的结构，需要一个复杂的引擎来运行代码，并抽象出大量机器级的细节(如何管理内存，如何存储某些数据结构，等等)。).</p><p id="6d45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来的一系列文章意在解释C语言的一些领域，如果你只有高级解释语言的经验，这些领域可能并不明显。</p><p id="f35c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是第一个问题:让这段代码运行需要什么(它是如何编译的)？而<code class="fe kw kx ky kz b">puts</code>函数到底从何而来？</p><p id="f170" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:我在Ubuntu Linux上运行下面所有的命令。在Mac上，您应该能够不加修改地运行这些命令。在Windows上，查看你的编译器的文档，或者试试<a class="ae lp" href="https://www.cygwin.com/" rel="noopener ugc nofollow" target="_blank"> Cygwin </a>。这里提出的想法是独立于操作系统的。</p><h2 id="01ed" class="li lj iq bd lq lr ls dn lt lu lv dp lw kj lx ly lz kn ma mb mc kr md me mf mg bi translated">编译过程</h2><p id="94d8" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">为了理解文章开头的例子，我们来看看C程序是如何编译的(以及编译成什么样子)。</p><p id="5f2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，解释语言和编译语言的主要区别是什么？前者依赖于语言引擎——一个独立的软件，它将JavaScript(或Python，或其他什么)代码作为输入并运行它。后者使用编译器生成机器指令，处理器稍后直接执行这些指令，无需额外软件层的帮助。所以在这两种情况下，都有一个将人类可读代码翻译成机器代码的过程，区别在于它是发生在编译时还是运行时。</p><p id="dbb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了编译C代码，你需要什么？初学者可能认为用C做任何事情都需要一个大而复杂的IDE，比如MS Visual Studio。事实上，你唯一需要的就是一个编译器。诚然，现代编译器也往往很大很复杂，但它们可以在命令行上运行，它们唯一需要的是一个输入文件，可以在任何文本编辑器中编写。流行的编译器有Mac和Linux版的gcc和clang，或者Windows版的Visual C++(没错，命令行上也有)。</p><p id="ee47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果我们从本文开始就有了<code class="fe kw kx ky kz b">main.c</code>源文件，编译它就像调用如下代码一样简单:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="c523" class="li lj iq kz b gy lk ll l lm ln">&gt; gcc main.c -o out</span></pre><p id="1423" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">-o out</code>代表“将输出写入文件<code class="fe kw kx ky kz b">out</code>”(将成为可执行文件)。当您运行可执行文件时，您会看到预期的输出:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4861" class="li lj iq kz b gy lk ll l lm ln">&gt; ./out<br/>Hello World!</span></pre><p id="d3c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上,“编译”这个词用得太多了。它可以是指将一个源文件(或几个源文件)转换成可执行文件的整个过程，也可以只是这个过程的一部分，即为每个源文件创建一个对应的<a class="ae lp" href="https://en.wikipedia.org/wiki/Assembly_language" rel="noopener ugc nofollow" target="_blank">汇编</a>文件(这也称为“适当编译”)。整个过程是这样的:</p><ol class=""><li id="d7d5" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">预处理。编译开始前，执行预处理指令(<code class="fe kw kx ky kz b">#include</code>、<code class="fe kw kx ky kz b">#define</code>、<code class="fe kw kx ky kz b">#if</code>等)。在这一步的最后，我们得到了没有预处理指令的文件。这些文件(编译器的输入)被称为<a class="ae lp" href="https://en.wikipedia.org/wiki/Translation_unit_(programming)" rel="noopener ugc nofollow" target="_blank"> <em class="mv">翻译单元</em> </a>。</li><li id="9aff" class="mm mn iq ka b kb mw kf mx kj my kn mz kr na kv mr ms mt mu bi translated">编译(正确)和汇编。每个翻译单元被单独转换成一个目标文件，其中包含机器代码和链接器指令。这些文件还不能执行。</li><li id="5612" class="mm mn iq ka b kb mw kf mx kj my kn mz kr na kv mr ms mt mu bi translated">链接。所有的目标文件最终被组合起来产生一个可执行文件。</li></ol><h2 id="a9aa" class="li lj iq bd lq lr ls dn lt lu lv dp lw kj lx ly lz kn ma mb mc kr md me mf mg bi translated">依赖性解析</h2><p id="307f" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><code class="fe kw kx ky kz b">puts</code>功能从何而来？如果你认为它是通过包含<code class="fe kw kx ky kz b">stdio.h</code>以某种方式引入的，你只对了一部分。</p><p id="8034" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们去掉<code class="fe kw kx ky kz b">#include</code>看看会发生什么。</p><p id="83fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">main.c</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9beb" class="li lj iq kz b gy lk ll l lm ln">int main(void) {<br/>  puts("Hello World!");<br/>  return 0;<br/>}</span><span id="1448" class="li lj iq kz b gy lo ll l lm ln">&gt; gcc main.c -o out<br/>main.c: In function ‘main’:<br/>main.c:2:3: warning: implicit declaration of function ‘puts’ [-Wimplicit-function-declaration]<br/>   puts(“Hello World!”);<br/>   ^</span></pre><p id="1762" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们得到一个警告，但没有错误。让我们试着运行<code class="fe kw kx ky kz b">out</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="e1e0" class="li lj iq kz b gy lk ll l lm ln">&gt; ./out<br/>Hello World!</span></pre><p id="b92f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">成功！这是怎么回事？我们没有在<code class="fe kw kx ky kz b">main.c</code>中导入或包含任何包含函数名<code class="fe kw kx ky kz b">puts</code>的东西，所以它怎么知道要调用什么函数呢？</p><p id="48d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解它是如何工作的，让我们来看看<code class="fe kw kx ky kz b">main.c</code>被编译成的汇编代码。使用<code class="fe kw kx ky kz b">gcc</code>，您可以传递一个<code class="fe kw kx ky kz b">-S</code>选项，使其在预处理和适当编译后停止。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4fd5" class="li lj iq kz b gy lk ll l lm ln">&gt; gcc -S main.c -o main.s -masm=intel -fno-asynchronous-unwind-tables<br/>main.c: In function ‘main’:<br/>main.c:2:3: warning: implicit declaration of function ‘puts’ [-Wimplicit-function-declaration]<br/>   puts(“Hello World!”);<br/>   ^</span></pre><p id="5d58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里得到了同样的警告(这是意料之中的)，但是让我们来看看结果汇编文件。</p><p id="7fb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">main.s</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="d5b2" class="li lj iq kz b gy lk ll l lm ln">  .file "main.c"<br/>  .intel_syntax noprefix<br/>  .section .rodata<br/>.LC0:<br/>  .string "Hello World!"<br/>  .text<br/>  .globl main<br/>  .type main, @function<br/>main:<br/>  push rbp<br/>  mov rbp, rsp<br/>  mov edi, OFFSET FLAT:.LC0<br/>  call puts<br/>  mov eax, 0<br/>  pop rbp<br/>  ret<br/>  .size main, .-main<br/>  .ident “GCC: (Ubuntu 5.4.0–6ubuntu1~16.04.10) 5.4.0 20160609”<br/>  .section .note.GNU-stack,””,@progbits</span></pre><p id="9cd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确切的输出取决于编译器、<a class="ae lp" href="https://en.wikipedia.org/wiki/Instruction_set_architecture" rel="noopener ugc nofollow" target="_blank">处理器架构</a>和您正在编译的选项(在上面的例子中省略<code class="fe kw kx ky kz b">-masm=intel -fno-asynchronous-unwind-tables</code>会稍微改变输出，但是相关的位保持相似)。我们应该寻找某种<code class="fe kw kx ky kz b">call</code>或<code class="fe kw kx ky kz b">jump</code>命令。</p><p id="90be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">call puts</code> —即将<a class="ae lp" href="https://en.wikipedia.org/wiki/Program_counter" rel="noopener ugc nofollow" target="_blank">指令指针</a>设置为标签<code class="fe kw kx ky kz b">puts</code>的值。或者，更简单地说，“让处理器执行的下一个命令是由<code class="fe kw kx ky kz b">puts</code>标记的命令”。之前的命令(<code class="fe kw kx ky kz b">mov edi, OFFSET FLAT:.LC0</code>)将<code class="fe kw kx ky kz b">"Hello World!"</code>字符串的地址放在<code class="fe kw kx ky kz b">edi</code>寄存器中x64 Linux中的任何函数都会在那里寻找它。这两个命令是我们从<code class="fe kw kx ky kz b">puts</code>函数调用中得到的全部内容。</p><p id="c882" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">公平地说，C标准的现代版本(从C99开始)要求，如果要调用一个函数，必须事先声明它(因此出现了警告)。如果我们想解决这个问题，我们实际上不需要包含<code class="fe kw kx ky kz b">stdio.h</code>。我们需要做的就是为<code class="fe kw kx ky kz b">puts</code>添加一个声明。</p><p id="f792" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">main.c</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="76ab" class="li lj iq kz b gy lk ll l lm ln"><strong class="kz ir">int puts (const char *);</strong></span><span id="de24" class="li lj iq kz b gy lo ll l lm ln">int main(void) {<br/>  puts("Hello World!");<br/>  return 0;<br/>}</span></pre><p id="60e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们尝试编译上面的代码，就会很顺利。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="27ca" class="li lj iq kz b gy lk ll l lm ln">&gt; gcc main.c -o out<br/>&gt; ./out<br/>Hello World!</span></pre><p id="6373" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道了函数的签名(编译器通过不发出警告来确认)，但是仍然没有指示在哪里可以找到函数体。</p><p id="0c6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，编译器和汇编器并不关心函数的位置。当编译器看到函数调用时，它所做的就是添加汇编指令，用于将参数放置在它们各自的位置(由相关的<a class="ae lp" href="https://en.wikipedia.org/wiki/Application_binary_interface" rel="noopener ugc nofollow" target="_blank">应用二进制接口</a>指定)并用于调用函数。</p><p id="ce00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">能够调用一个函数而不声明它是以前类型不太严格的c语言版本的残余。gcc允许出于兼容性原因编译这样的代码——它只是通过传递给它的参数来推断函数参数的数量和类型，并假设它的类型是<code class="fe kw kx ky kz b">int</code>。我们没有使用<code class="fe kw kx ky kz b">puts</code>的返回值(即使我们使用了，它的实际类型恰好是<code class="fe kw kx ky kz b">int</code>，就像编译器的默认一样)，我们传递给它一个字符串，实际函数期望得到这个字符串，这就是为什么即使没有声明，一切都可以工作。</p><p id="2157" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么在什么时候我们最终解决了函数调用和它的定义之间的联系呢？定义在哪里？</p><p id="252f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是链接器负责的事情之一。正如我们前面讨论的，链接器处理不可执行的目标文件——它接受一个或多个目标文件作为输入，并生成一个可执行文件。在这个过程中，它确保如果某个地方调用了某个东西，那么在其他地方就存在相应的标签。如果它确实存在，标签被转换成一个具体的内存地址。否则—链接器会产生错误。</p><p id="bb18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看<em class="mv">如何调用</em>链接器(下面的<code class="fe kw kx ky kz b">-v</code>标志用于详细输出)。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="c078" class="li lj iq kz b gy lk ll l lm ln">&gt; gcc -v main.c -o out<br/>... (output omitted)<br/>/usr/lib/gcc/x86_64-linux-gnu/5/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/5/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper -plugin-opt=-fresolution=/tmp/ccz0r2qe.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s — sysroot=/ — build-id — eh-frame-hdr -m elf_x86_64 — hash-style=gnu — as-needed -dynamic-linker /lib64/ld-linux-x86–64.so.2 -z relro -o out /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/5/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/5 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/5/../../.. /tmp/ccAjWoyV.o -lgcc — as-needed -lgcc_s — no-as-needed -lc -lgcc — as-needed -lgcc_s — no-as-needed /usr/lib/gcc/x86_64-linux-gnu/5/crtend.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crtn.o</span></pre><p id="a96e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的最后一个命令——我们感兴趣的一个——是完整呈现的。它是自动生成的，并不打算特别可读，但我们仍然可以看到发生了什么。用几个选项调用<code class="fe kw kx ky kz b">collect2</code>实用程序(它是gcc链接器)，一堆目标文件(<code class="fe kw kx ky kz b">*.o</code>)被传递给它(包括<code class="fe kw kx ky kz b">/tmp/ccAjWoyV.o</code>，它是从<code class="fe kw kx ky kz b">main.c</code>生成的临时目标文件)。我们感兴趣的选项是<code class="fe kw kx ky kz b">-lc</code>，它告诉链接器与<a class="ae lp" href="https://en.wikipedia.org/wiki/Library_(computing)#Shared_libraries" rel="noopener ugc nofollow" target="_blank">共享库</a> <code class="fe kw kx ky kz b">libc.so</code>链接，共享库可以在预定义的系统位置找到。这实际上是您系统中的一个文件，其中存放了包括<code class="fe kw kx ky kz b">puts</code>在内的<a class="ae lp" href="https://en.wikipedia.org/wiki/C_standard_library" rel="noopener ugc nofollow" target="_blank"> C标准库</a>函数的实现。</p><p id="3540" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想知道这个函数在C中是如何实现的，你可以在网上<a class="ae lp" href="https://chromium.googlesource.com/native_client/nacl-newlib/+/master/newlib/libc/stdio/puts.c" rel="noopener ugc nofollow" target="_blank">找到</a> <a class="ae lp" href="https://opensource.apple.com/source/Libc/Libc-825.26/stdio/FreeBSD/puts.c.auto.html" rel="noopener ugc nofollow" target="_blank">例子</a><a class="ae lp" href="https://github.com/lattera/glibc/blob/82dbf555a4d41690f63b94ccb4db4bf43d873aa0/libio/ioputs.c" rel="noopener ugc nofollow" target="_blank"/>。但是源代码不一定要安装在您的机器上——编译的库版本就足够了。</p><h2 id="5a81" class="li lj iq bd lq lr ls dn lt lu lv dp lw kj lx ly lz kn ma mb mc kr md me mf mg bi translated">头文件</h2><p id="23fd" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">让我们回到最初的例子。</p><p id="6950" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">main.c</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="aba7" class="li lj iq kz b gy lk ll l lm ln">#include &lt;stdio.h&gt;</span><span id="ec31" class="li lj iq kz b gy lo ll l lm ln">int main(void) {<br/>  puts("Hello World!");<br/>  return 0;<br/>}</span></pre><p id="a7b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经展示了上面的<code class="fe kw kx ky kz b">#include</code>指令对于编译来说是不必要的，可以用一个声明来代替。但是为什么我们通常包含头文件，当我们这样做时会发生什么呢？头文件和源文件在本质上有什么不同？</p><p id="fff8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在同一个目录中创建另一个文件。</p><p id="2297" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">misc.c</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="ec67" class="li lj iq kz b gy lk ll l lm ln">#include &lt;stdio.h&gt;</span><span id="b6c7" class="li lj iq kz b gy lo ll l lm ln">void say_hi(void) {<br/>  puts("Hi!");<br/>}</span><span id="7ccf" class="li lj iq kz b gy lo ll l lm ln">void say_thanks(void) {<br/>  puts("Thanks!");<br/>}</span><span id="8fc3" class="li lj iq kz b gy lo ll l lm ln">void say_bye(void) {<br/>  puts("Bye!");<br/>}</span></pre><p id="c207" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们想在<code class="fe kw kx ky kz b">main.c</code>中使用源文件中的函数:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="42b4" class="li lj iq kz b gy lk ll l lm ln">int main(void) {<br/>  say_hi();<br/>  say_thanks();<br/>  say_bye();<br/>  return 0;<br/>}</span></pre><p id="7167" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们试着编译一下。多个源文件可以被编译成一个可执行文件，成功编译的条件之一是，在所有这些源文件中，有且只有一个名为<code class="fe kw kx ky kz b">main</code>的函数，它是应用程序的入口点(我将在后面的文章中详细阐述<code class="fe kw kx ky kz b">main</code>的语义及其在不同环境中的用法)。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="759a" class="li lj iq kz b gy lk ll l lm ln">&gt; gcc main.c misc.c -o out<br/>main.c: In function ‘main’:<br/>main.c:2:3: warning: implicit declaration of function ‘say_hi’ [-Wimplicit-function-declaration]<br/>   say_hi();<br/>   ^<br/>main.c:3:3: warning: implicit declaration of function ‘say_thanks’ [-Wimplicit-function-declaration]<br/>   say_thanks();<br/>   ^<br/>main.c:4:3: warning: implicit declaration of function ‘say_bye’ [-Wimplicit-function-declaration]<br/>   say_bye();<br/>   ^<br/>&gt; ./out<br/>Hi!<br/>Thanks!<br/>Bye!</span></pre><p id="4a21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们得到了预期的警告，但是程序确实按计划编译并运行了。我们可以像前面的例子一样，通过在使用之前声明<code class="fe kw kx ky kz b">main.c</code>中的函数来消除警告。</p><p id="2deb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">main.c</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="40e7" class="li lj iq kz b gy lk ll l lm ln"><strong class="kz ir">void say_hi(void);<br/>void say_thanks(void);<br/>void say_bye(void);</strong></span><span id="d490" class="li lj iq kz b gy lo ll l lm ln">int main(void) {<br/>  say_hi();<br/>  say_thanks();<br/>  say_bye();<br/>  return 0;<br/>}</span></pre><p id="68c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们尝试运行相同的编译命令，将不会有警告。</p><p id="7185" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，在定义之前，通常的做法是在<code class="fe kw kx ky kz b">misc.c</code>的顶部声明所有的<code class="fe kw kx ky kz b">misc.c</code>函数。</p><p id="c5db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">misc.c</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="8d82" class="li lj iq kz b gy lk ll l lm ln">#include &lt;stdio.h&gt;</span><span id="6e48" class="li lj iq kz b gy lo ll l lm ln"><strong class="kz ir">void say_hi(void);<br/>void say_thanks(void);<br/>void say_bye(void);</strong></span><span id="f834" class="li lj iq kz b gy lo ll l lm ln">void say_hi(void) {<br/>  puts("Hi!");<br/>}</span><span id="af6f" class="li lj iq kz b gy lo ll l lm ln">void say_thanks(void) {<br/>  puts("Thanks!");<br/>}</span><span id="9c89" class="li lj iq kz b gy lo ll l lm ln">void say_bye(void) {<br/>  puts("Bye!");<br/>}</span></pre><p id="fb6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">头文件是避免这种重复的一种方法。</p><p id="8e2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">misc.h</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="5b45" class="li lj iq kz b gy lk ll l lm ln">void say_hi(void);<br/>void say_thanks(void);<br/>void say_bye(void);</span></pre><p id="2d72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">misc.c</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="c3f1" class="li lj iq kz b gy lk ll l lm ln">#include &lt;stdio.h&gt;</span><span id="3b15" class="li lj iq kz b gy lo ll l lm ln"><strong class="kz ir">#include "misc.h"</strong></span><span id="2275" class="li lj iq kz b gy lo ll l lm ln">void say_hi(void) {<br/>  puts("Hi!");<br/>}</span><span id="f039" class="li lj iq kz b gy lo ll l lm ln">void say_thanks(void) {<br/>  puts("Thanks!");<br/>}</span><span id="470b" class="li lj iq kz b gy lo ll l lm ln">void say_bye(void) {<br/>  puts("Bye!");<br/>}</span></pre><p id="868f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">main.c</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="d994" class="li lj iq kz b gy lk ll l lm ln"><strong class="kz ir">#include "misc.h"</strong></span><span id="689a" class="li lj iq kz b gy lo ll l lm ln">int main(void) {<br/>  say_hi();<br/>  say_thanks();<br/>  say_bye();<br/>  return 0;<br/>}</span></pre><p id="a377" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只需将重复的代码提取到一个专用文件中，并用一个<code class="fe kw kx ky kz b">#include</code>指令替换它。</p><p id="1f5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在预处理过程中发生相反的情况——该指令被替换为头文件的全部内容。我们可以这样试一下(<code class="fe kw kx ky kz b">-E</code>选项是为了在预处理后停止编译，<code class="fe kw kx ky kz b">*.i</code>文件扩展名是gcc约定的不需要预处理的源代码)。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4805" class="li lj iq kz b gy lk ll l lm ln">&gt; gcc -E main.c -o main.i</span></pre><p id="c4bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">main.i</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="aa8a" class="li lj iq kz b gy lk ll l lm ln"># 1 "main.c"<br/># 1 "&lt;built-in&gt;"<br/># 1 "&lt;command-line&gt;"<br/># 1 "/usr/include/stdc-predef.h" 1 3 4<br/># 1 "&lt;command-line&gt;" 2<br/># 1 "main.c"<br/># 1 "misc.h" 1<br/>void say_hi(void);<br/>void say_thanks(void);<br/>void say_bye(void);<br/># 2 "main.c" 2</span><span id="ee20" class="li lj iq kz b gy lo ll l lm ln">int main(void) {<br/>  say_hi();<br/>  say_thanks();<br/>  say_bye();<br/>  return 0;<br/>}</span></pre><p id="4a31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以忽略<a class="ae lp" href="https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html" rel="noopener ugc nofollow" target="_blank">行标</a>(以<code class="fe kw kx ky kz b">#</code>开头的行)——剩下的就是原来<code class="fe kw kx ky kz b">main.c</code>的内容加上<code class="fe kw kx ky kz b">misc.h</code>的全部内容。</p><p id="afdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。头文件并不代表模块系统——预处理程序只是进行文本替换。头文件可以包含任何东西，不仅仅是函数声明(只要它在编译时有意义)。使它成为头文件的不是它的扩展名或它的内容。事实上，我们没有将它作为源文件列表的一部分传递给编译器，而是通过<code class="fe kw kx ky kz b">#include</code>指令将其内容粘贴到其他源文件中。它最终会被编译，而且会被多次编译——每次一次<code class="fe kw kx ky kz b">#include</code>。</p><p id="0665" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，头文件也可能有<code class="fe kw kx ky kz b">#include</code>指令，所以预处理程序必须递归地执行替换。两个不同的头文件可能独立地包含<code class="fe kw kx ky kz b">stdio.h</code>，并且它们都包含在一个源文件中。我们最终得到的是一个包含了两次的头文件，因为没有什么可以阻止我们这样做。这并不一定会破坏任何东西，因为允许双重声明，但是它会降低编译速度。一种常见的解决方法是手动检查是否包含了某个标头。</p><p id="7af4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">misc.h</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4df9" class="li lj iq kz b gy lk ll l lm ln"><strong class="kz ir">#ifndef _MISC_H_<br/>#define _MISC_H_</strong></span><span id="702c" class="li lj iq kz b gy lo ll l lm ln">void say_hi(void);<br/>void say_thanks(void);<br/>void say_bye(void);</span><span id="2ba6" class="li lj iq kz b gy lo ll l lm ln"><strong class="kz ir">#endif</strong></span></pre><p id="8463" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码定义了一个名为<code class="fe kw kx ky kz b">_MISC_H_</code>的预处理宏，但是如果预处理程序再次遇到相同的块，它会删除它，因为<code class="fe kw kx ky kz b">_MISC_H_</code>已经被定义了。通过这种方式，我们可以确保预处理后的任何给定文件中只有一个上述头文件的副本，不管它被直接或间接包含了多少次。</p><p id="3200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，<code class="fe kw kx ky kz b">#include</code>指令中的引号(<code class="fe kw kx ky kz b">""</code>)对尖括号(<code class="fe kw kx ky kz b">&lt;&gt;</code>)符号指定了将在哪些目录中搜索该文件。该标准没有规定这一点，但所有主要编译器的行为方式都是一样的:尖括号版本只是在一组预定义的系统目录中进行搜索，对于引号，搜索从源文件所在的目录开始，如果没有找到，就退回到系统目录。简单点说，尖括号是系统头文件，引号是自定义头文件。</p><p id="48d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以在本文开头的例子中使用<code class="fe kw kx ky kz b">-E</code>选项运行gcc输出应该有几百行长，但是应该有<code class="fe kw kx ky kz b">puts</code>声明。</p><h2 id="5482" class="li lj iq bd lq lr ls dn lt lu lv dp lw kj lx ly lz kn ma mb mc kr md me mf mg bi translated">结论</h2><p id="7dd1" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">c不是一种可以取代JavaScript或Python的语言——用它写高级软件就没那么愉快了。但学习它仍然很有意义，因为它让你更好地理解计算机是如何工作的。理解程序是如何编译和运行的，对于编写比hello-world应用程序更严肃的东西是必不可少的。</p><h1 id="c527" class="nb lj iq bd lq nc nd ne lt nf ng nh lw ni nj nk lz nl nm nn mc no np nq mf nr bi translated">全系列</h1><ol class=""><li id="3568" class="mm mn iq ka b kb mh kf mi kj ns kn nt kr nu kv mr ms mt mu bi translated">(本文)程序编译。源文件和头文件</li><li id="2110" class="mm mn iq ka b kb mw kf mx kj my kn mz kr na kv mr ms mt mu bi translated"><a class="ae lp" href="https://medium.com/@pavelpomerantsev/c-for-javascript-developers-memory-allocation-pointers-arrays-and-strings-bcf387ad7f44" rel="noopener">内存分配。指针、数组和字符串</a></li></ol></div></div>    
</body>
</html>