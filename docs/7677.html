<html>
<head>
<title>Kubernetes Tips | Using scripts inside configmaps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes提示|在配置图中使用脚本</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-tips-using-scripts-inside-configmaps-9df03e17ac35?source=collection_archive---------0-----------------------#2022-12-16">https://itnext.io/kubernetes-tips-using-scripts-inside-configmaps-9df03e17ac35?source=collection_archive---------0-----------------------#2022-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d8100e3fe169f140dcfd69abd050c981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HtxSH_ULwguHGYnGWWD4g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://cncf-branding.netlify.app/projects/kubernetes/" rel="noopener ugc nofollow" target="_blank">https://cncf-branding.netlify.app/projects/kubernetes/</a></figcaption></figure><p id="7193" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去十年的大部分时间里，我在德沃普斯/SRE世界工作，我学到的一件事是，快速行动是生存的唯一途径。在一个行业、一个组织中，事情会在一瞬间发生变化，而你的工作量永远不会减少。显然，我们都是为了效率和质量而建设，但我们也必须牢记速度。在这个领域，脚本就是生命。没有脚本，自动化就无法成功。在我的整个职业生涯中，我真的想不出有哪一周我没有编写一些脚本来实现一些自动化。在你意识到之前，你已经有成百上千的东西要维护了。</p><p id="320b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当使用包含Kubernetes的架构时，我们如何管理和维护所有这些脚本来做所有这些美妙的事情？一种方法是创建一个完整的专用回购协议，然后构建一个包含所有这些脚本的容器映像，称为类似“自动化”的东西。这并不完全是个坏主意，因为我们都应该遵循GitOps实践，我永远不会反对这一点(GitOps always。一直都是。一直都是。).</p><p id="ef02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的几年里，我发现一个非常有用的方法是将这些脚本存储为<em class="lb">配置图</em>。这使我能够更轻松地管理自动化所需的所有这些定制脚本，并更快地进行部署。在接下来的文章中，我将演示一些在<em class="lb">配置图</em>中放置脚本的场景，来演示如何做到这一点。</p><p id="2023" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">对于我们的K8s环境，我们将使用</em> <a class="ae kc" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lb">种类</em> </a> <em class="lb">。有关KiND入门的更多信息，请参见文档。这是我比较喜欢的本土开发K8s。</em></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="e27d" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">场景1:用Bash执行一个简单的任务</h2><pre class="mc md me mf gt mg mh mi bn mj mk bi"><span id="5531" class="ml lk iq mh b be mm mn l mo mp">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: slim-shady-configmap<br/>data:<br/>  slim-shady.sh: |<br/>    #!/bin/bash<br/><br/>    echo "Hi!"<br/>    echo "My name is"<br/>    echo "What?"<br/>    echo "My name is"<br/>    echo "Who?"<br/>    echo "My name is"<br/>    echo "Chika-chika"<br/>    echo "Slim Shady"</span></pre><p id="9077" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的<em class="lb"> configmap </em>中，我们创建了一个名为“slim-shady.sh”的bash脚本，它模仿了Eminem的歌词<a class="ae kc" href="https://youtu.be/sNPnbI1arSE" rel="noopener ugc nofollow" target="_blank">“我的名字是”</a>(<strong class="kf ir">请注意</strong>这不是一个真实的用例🙂但却是我最喜欢的歌曲之一)。要使用<em class="lb">配置图</em>运行这个脚本，让我们看一下下面的例子<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" rel="noopener ugc nofollow" target="_blank"> Kubernetes Job </a>并浏览一下。</p><pre class="mc md me mf gt mg mh mi bn mj mk bi"><span id="0de0" class="ml lk iq mh b be mm mn l mo mp">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: chicka-chicka-slim-shady<br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - name: shady<br/>          image: centos<br/>          command: ["/script/slim-shady.sh"]<br/>          volumeMounts:<br/>            - name: script<br/>              mountPath: "/script"<br/>      volumes:<br/>        - name: script<br/>          configMap:<br/>            name: slim-shady-configmap<br/>            defaultMode: 0500<br/>      restartPolicy: Never</span></pre><p id="0db4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的作业清单中，您可以看到我们为配置图创建了一个新的<a class="ae kc" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" rel="noopener ugc nofollow" target="_blank">卷。然后，我们将该卷安装在位于<em class="lb"> "/script" </em>的shady容器下，然后执行脚本文件<em class="lb"> slim-shady.sh </em>，这是我们的<em class="lb">配置图</em>中的文件名。</a></p><p id="2275" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想在这里指出两件事:</p><p id="d5bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">a)在卷内，我们必须指定一个至少为<em class="lb"> 0500 </em>的<em class="lb"> defaultMode </em>(读取+执行给用户)。这定义了当pod运行时容器内的文件权限。如果我们不设置这个，我们会得到权限被拒绝的错误。这是因为默认情况下，configmap将与<em class="lb"> 0644 </em>一起挂载，您将会看到如下错误。</p><pre class="mc md me mf gt mg mh mi bn mj mk bi"><span id="0aa3" class="ml lk iq mh b be mm mn l mo mp"> Warning  Failed     7s    kubelet            Error: failed to create containerd task: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: "/script/slim-shady.sh": permission denied: unknown</span></pre><p id="75b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">b)在这里，我们还能够使用现有的众所周知的容器映像，而不是创建我们自己的映像。这对我们来说更容易，因为我们不需要用新代码等构建新的映像，而是只需要部署<em class="lb">配置图</em>和<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" rel="noopener ugc nofollow" target="_blank"> <em class="lb">作业</em> </a>。</p><p id="9c32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们应用工作清单之后，让我们看一下日志。</p><pre class="mc md me mf gt mg mh mi bn mj mk bi"><span id="4914" class="ml lk iq mh b be mm mn l mo mp">&gt; kubectl logs -f chicka-chicka-slim-shady-h7j5m<br/>Hi!<br/>My name is<br/>What?<br/>My name is<br/>Who?<br/>My name is<br/>Chika-chika<br/>Slim Shady</span></pre><h2 id="04bb" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">场景2:在MLflow中推广最新的ML模型</h2><p id="2df3" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">现在是一个更真实的例子，但仍然是一个非常简单的设置。以下内容遵循与上述相同的方法，但该脚本的目的是从MLflow Registry中获取最新的ML模型，并将其升级到“生产”。</p><pre class="mc md me mf gt mg mh mi bn mj mk bi"><span id="16fb" class="ml lk iq mh b be mm mn l mo mp">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: promote-model<br/>data:<br/>  promote_model.py: |<br/>    """<br/>    This file is used to demonstrate how to promote the latest version of a Model to "Production" stage so that it can be<br/>    served out of the Model Registry.<br/>    """<br/>    import os<br/>    import mlflow<br/>    from mlflow.tracking import MlflowClient<br/><br/>    # Set the Remote Tracking Server Information<br/>    mlflow.set_tracking_uri("http://mlflow")<br/><br/>    # Promote the latest Version of Staging to Production<br/>    client = MlflowClient()<br/>    model_name = os.getenv("MODEL_NAME")<br/><br/>    # Get the latest version in Stage "Staging" and promote to "Production"<br/>    models = client.get_latest_versions(model_name, stages=["Staging"])<br/>    for model in models:<br/>        name = model.name<br/>        latest_version = int(model.version)<br/>        run_id = model.run_id<br/>        current_stage = model.current_stage<br/>        print(name, latest_version)<br/>        # Transition<br/>        client.transition_model_version_stage(<br/>            name=name,<br/>            version=latest_version,<br/>            stage="Production"<br/>        )</span></pre><p id="d5a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码接受一个<em class="lb">环境变量</em>作为模型名(<strong class="kf ir"><em class="lb">MODEL _ NAME = OS . getenv(" MODEL _ NAME ")</em></strong>)来指定要提升哪个模型。要定义模型名，我们可以简单地将带有模型名的<a class="ae kc" href="https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> env </em> </a>传递给作业中的容器:</p><pre class="mc md me mf gt mg mh mi bn mj mk bi"><span id="5484" class="ml lk iq mh b be mm mn l mo mp">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: promote-model-a<br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - name: promote<br/>          image: wbassler/mlflow-utils:0.0.1<br/>          command:<br/>            - python<br/>          args:<br/>            - /mlflow/promote.py<br/>          env: <br/>            - name: MODEL_NAME<br/>              value: model-a<br/>          volumeMounts:<br/>            - name: promote<br/>              mountPath: "/mlflow"<br/>      volumes:<br/>        - name: promote<br/>          configMap:<br/>            name: promote-model<br/>            defaultMode: 0500<br/>      restartPolicy: Never</span></pre><p id="f450" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你在上面看到的，我们使用“模型-a”作为我们的环境变量。当我们的代码被执行时，它将在MLflow模型注册表中找到“模型-a”的最新版本，并将其提升到“生产”。</p><p id="f5d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里要指出两件事:</p><p id="7d30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">a)通过使用现有的容器映像，我们又一次节省了大量时间，并且不必构建自己的映像来添加新代码。也许您在这里所需要的只是通过GitOps来部署您的<em class="lb"> configmap </em>。</p><p id="04c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">b)我们编写脚本的方式也可以很简单地被其他作业重用<em class="lb">。</em>在我们的例子中，其他团队/用户/管道等可以非常容易地重用脚本来升级他们自己的<em class="lb"> MODEL_NAME </em>，只需简单地改变<em class="lb"> Job </em> manifest <em class="lb">中的<em class="lb"> env </em>。</em></p><h2 id="35b3" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">场景3:为新用户创建新目录</h2><p id="2c81" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">在最后一个场景中，我将演示如何执行存储在<em class="lb">配置图</em>中的脚本，该脚本从存储在<em class="lb">配置图</em>中的配置文件中读取。在解释这样做的目的之前，让我们看一下下面的<em class="lb">配置图</em>:</p><pre class="mc md me mf gt mg mh mi bn mj mk bi"><span id="aa28" class="ml lk iq mh b be mm mn l mo mp">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: create-users-dir<br/>data:<br/>  users.ini: |<br/>    user1<br/>    user2<br/>    user3<br/>    user5<br/>  create-dir.sh: |<br/>    #!/bin/bash<br/>    set -ex<br/>    cat /scripts/users.ini | while read line<br/>    do<br/>       mkdir -pv /nfs/folder/$line<br/>    done</span></pre><p id="59e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的<em class="lb">配置图</em>中，我们正在创建两个文件。<em class="lb"> users.ini </em>用于定义用户目录列表的配置文件。<em class="lb"> create-dir.sh </em>是一个bash脚本，用于为<em class="lb"> users.ini </em>文件中的每个条目创建一个文件夹。</p><pre class="mc md me mf gt mg mh mi bn mj mk bi"><span id="a9be" class="ml lk iq mh b be mm mn l mo mp">---<br/>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  generateName: create-users-dirs<br/>spec:<br/>  containers:<br/>  - name: create-users<br/>    image: centos<br/>    command: ["/scripts/create-dir.sh"]<br/>    volumeMounts:<br/>    - name: script<br/>      mountPath: "/scripts"<br/>  volumes:<br/>    - name: script<br/>      configMap:<br/>        name: create-users-dir<br/>        defaultMode: 0500<br/>        items:<br/>          - key: create-dir.sh<br/>            path: create-dir.sh<br/>          - key: users.ini<br/>            path: users.ini</span></pre><p id="8c29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行时:</p><pre class="mc md me mf gt mg mh mi bn mj mk bi"><span id="6d42" class="ml lk iq mh b be mm mn l mo mp">+ cat /scripts/users.ini<br/>+ read line<br/>+ mkdir -pv /nfs/folder/user1<br/>mkdir: created directory '/nfs'<br/>mkdir: created directory '/nfs/folder'<br/>mkdir: created directory '/nfs/folder/user1'<br/>+ read line<br/>+ mkdir -pv /nfs/folder/user2<br/>mkdir: created directory '/nfs/folder/user2'<br/>+ read line<br/>+ mkdir -pv /nfs/folder/user3<br/>mkdir: created directory '/nfs/folder/user3'<br/>+ read line<br/>+ mkdir -pv /nfs/folder/user5<br/>mkdir: created directory '/nfs/folder/user5'<br/>+ read line</span></pre><p id="78fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子需要指出两点:</p><p id="d276" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">a)我们再次利用现有的容器映像，而不必创建自己的映像。</p><p id="8ad9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">b)在上面的例子中，我们可以通过使用类似Kustomize<a class="ae kc" href="https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/#configmapgenerator" rel="noopener ugc nofollow" target="_blank"><em class="lb">configMapGenerator</em></a><em class="lb"/>的东西，在几个不同的K8s环境中重用相同的代码(如果您想获得真正的乐趣，请将其集成到您的GitOps系统中😺).</p><p id="9d29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<em class="lb"> Pod </em>资源运行在这里显然不是一个好的选择，但是我真的很喜欢上面的场景，因为它可以以许多不同的方式被利用，比如作为<em class="lb">作业</em>或者作为<a class="ae kc" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank">init container</a>。作为CI管道的一部分，可以在每次向<em class="lb"> config.ini </em>添加新用户时运行新的<em class="lb">作业</em>，或者可以在每次pod启动时运行<em class="lb"> initContainer </em>以确保所有目录已经存在。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="2fcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将脚本甚至代码存储为<em class="lb"> configmaps </em>并不是什么新鲜事，也不是我自己想出来的。我多年来安装和使用的几个Kubernetes应用程序和操作程序也遵循这种方法。这种方法有许多优点和缺点，但是希望我已经给了那里的一些人一个想法，可以节省他们一些时间，并且给自动化带来一些方便。</p></div></div>    
</body>
</html>