<html>
<head>
<title>Building Side Effects in NGRX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在NGRX中构建副作用</h1>
<blockquote>原文：<a href="https://itnext.io/building-side-effects-in-ngrx-deb0d856096d?source=collection_archive---------3-----------------------#2019-05-12">https://itnext.io/building-side-effects-in-ngrx-deb0d856096d?source=collection_archive---------3-----------------------#2019-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b343" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">效果是NGRX中最强大的特性之一。让我们来看一些实际的例子，比如调用API或实时数据流</h2></div><p id="ab0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个系列的第三篇文章，旨在详细解释用NGRX构建Angular应用程序的一步一步的方法。</p><ul class=""><li id="f57c" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">在本系列的第一篇文章中，我写了一篇关于NGRX平台所有概念的概述。</li><li id="aa62" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">在本系列的第二篇文章中，我开始编写应用程序的存储和状态的实体。</li></ul><p id="58e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您从未使用过NGRX，或者从未深入研究过，我真的建议您阅读它。</p><h2 id="354f" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">摘要</h2><p id="ab5b" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">总结一下我在以前的文章中介绍的内容，我们有一个应用程序，旨在显示一个带有加密货币价格的仪表板。</p><p id="c694" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序的逻辑是使用三个服务模块构建的，每个模块管理我们商店的不同功能。</p><p id="1e29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些是:</p><ul class=""><li id="5c62" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kh ir"> dashboard </strong>，管理仪表板及其平铺的逻辑</li><li id="4f90" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated"><strong class="kh ir">资产，</strong>从<a class="ae lk" href="https://coincap.io" rel="noopener ugc nofollow" target="_blank"> Coincap的</a> API获取的资产列表</li><li id="ed11" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated"><strong class="kh ir">价格，</strong>来自Coincap的WebSocket API的价格流</li></ul><p id="7475" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">应用程序的外观:</strong></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/5271496f780c68798b6622c4ffc1a775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*R3-0VFvXB2rq-rAtWyNwxA.gif"/></div></div></figure><h2 id="fc3e" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">在本文中，我们将学习:</h2><ul class=""><li id="e9c1" class="lb lc iq kh b ki mj kl mk ko na ks nb kw nc la lg lh li lj bi translated">如何在NGRX 8中构建效果</li><li id="7715" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">如何构建一个从API获取资产列表的效果</li><li id="8873" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">如何构建一个连接到WebSocket并监听存储在应用程序状态中的消息的效果</li></ul><h1 id="c382" class="nd lr iq bd ls ne nf ng lv nh ni nj ly jw nk jx mb jz nl ka me kc nm kd mh nn bi translated">Coincap的API服务</h1><p id="5463" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">为了从Coincap获取数据，我们创建了一个服务，将在我们的效果类中使用:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="de08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，我们只有一种方法:</p><ul class=""><li id="9ab9" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kh ir">获取资产</strong>，默认情况下将获取前5个资产</li></ul><p id="f525" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个方法将返回<code class="fe nq nr ns nt b">GetAssetsResponseDto</code>,简单来说就是:</p><pre class="mp mq mr ms gt nu nt nv nw aw nx bi"><span id="15b6" class="lq lr iq nt b gy ny nz l oa ob">interface GetAssetsResponseDto {<br/>    data: Asset[];<br/>    timestamp: number;<br/>}</span></pre><h1 id="ba2e" class="nd lr iq bd ls ne nf ng lv nh ni nj ly jw nk jx mb jz nl ka me kc nm kd mh nn bi translated">资产影响</h1><p id="4d22" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">现在让我们为<em class="oc">资产</em>商店创建效果。正如我们在上一篇文章中看到的，我们已经创建了三个操作:</p><ul class=""><li id="b08b" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">getAssetsRequestStarted</li><li id="2317" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">getAssetsRequestSuccess</li><li id="1256" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">添加资产</li></ul><h2 id="f07e" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">私有API</h2><p id="116d" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">让我们总结一下我们的行动将会做些什么:</p><ul class=""><li id="c156" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">我们想要对一个<em class="oc">getAssetsRequestStarted</em>动作做出反应，并分派一个<em class="oc">getAssetsRequestSuccess</em>动作</li><li id="a219" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">一旦<em class="oc">getAssetsRequestSuccess</em>动作被接收，我们将分派<em class="oc"> addAssets </em>由reducer函数获取，并将资产添加到存储中</li></ul><p id="25d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们首先创建负责获取资产的效果:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="374a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来分解一下这种影响</p><ul class=""><li id="cf74" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">我们不使用装饰器<code class="fe nq nr ns nt b">@Effect</code>，而是简单地从<code class="fe nq nr ns nt b">@ngrx/effects</code>导入函数<code class="fe nq nr ns nt b">createEffect</code></li><li id="b46d" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">我们收到一个动作<code class="fe nq nr ns nt b">getAssetsRequestStarted</code></li><li id="4348" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">我们调用之前在Coincap服务中定义的<code class="fe nq nr ns nt b">getAssets</code>方法，并将流映射到该请求的结果</li><li id="5425" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">如果有错误，我们简单地返回<code class="fe nq nr ns nt b">undefined</code>，由于<code class="fe nq nr ns nt b">filter(Boolean)</code>，它将在流中被过滤</li><li id="198b" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">然后，我们将流映射到动作<code class="fe nq nr ns nt b">getAssetsRequestSuccess</code></li></ul><p id="5e40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个效果将负责截取<code class="fe nq nr ns nt b">getAssetsRequestSuccess</code>并简单映射到<code class="fe nq nr ns nt b">addAssets</code></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="5bae" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">公共API</h2><p id="42cb" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">最后，我们公开公共API:</p><pre class="mp mq mr ms gt nu nt nv nw aw nx bi"><span id="3abb" class="lq lr iq nt b gy ny nz l oa ob">public getAllAssets$ = this.getAllAssets();    <br/>public addAssets$ = this.addAssets();</span></pre><p id="0833" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是完整的片段:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="20a8" class="nd lr iq bd ls ne nf ng lv nh ni nj ly jw nk jx mb jz nl ka me kc nm kd mh nn bi translated">价格效应</h1><p id="88b2" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">为了从Coincap的WebSocket API获取价格，我们扩展了之前创建的Coincap服务，并添加了一个新方法，负责连接到价格流并返回一个发出价格点的可观察对象。</p><h2 id="dff0" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">WebSocket连接</h2><p id="33de" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">为此，我们:</p><ul class=""><li id="18a6" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">通过调用<code class="fe nq nr ns nt b">WebSocket(url)</code>创建一个连接</li><li id="3779" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">我们创建了一个新的可观察对象，在这个对象中，每当WebSocket连接使用<code class="fe nq nr ns nt b">onmessage</code>钩子接收到一条消息时，我们都会发出一个事件</li><li id="a344" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">我们定义了<code class="fe nq nr ns nt b">unsubscribe</code>方法，它将简单地关闭WebSocket连接</li><li id="f781" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">如果连接已经打开，我们在打开新的连接之前关闭它，因为我们只需要一个WebSocket订阅来传输所有资产的价格</li></ul><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="42de" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">应用程序接口</h2><p id="2869" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我们创建了三个操作:</p><ul class=""><li id="396b" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">createPriceSubscription</li><li id="c43d" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">close price订阅</li><li id="a79c" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">添加价格</li></ul><p id="2064" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是效果的样子:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0dd1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来分解一下<code class="fe nq nr ns nt b">createPriceSubscription$</code>效果:</p><ul class=""><li id="afb8" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">我们收到一个动作<code class="fe nq nr ns nt b">createPriceSubscription</code>,其中一个资产作为有效负载</li><li id="0795" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">我们将有效负载与订阅的资产合并，因此我们可以关闭当前订阅并重新订阅所有资产</li><li id="fbf0" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">我们通过Coincap服务连接到流，该服务将返回一个可观察的来显示价格</li><li id="5845" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">每一个价格都会产生一个动作<code class="fe nq nr ns nt b">priceReceived</code></li><li id="59f1" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">我们向价格流可观察对象添加了一个<code class="fe nq nr ns nt b">takeUntil</code>操作符，这样每次收到动作<code class="fe nq nr ns nt b">closePriceSubscription</code>时，可观察对象就会自动退订</li></ul><p id="d312" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nq nr ns nt b">prices$</code>效果相当简单:</p><ul class=""><li id="e67f" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">我们接收到一个动作<code class="fe nq nr ns nt b">priceReceived</code>,并将它映射到一个动作<code class="fe nq nr ns nt b">addPrice</code>,该动作将由reducer处理，并将价格添加到商店中</li></ul><h2 id="1c28" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">更新商店模块</h2><p id="db5d" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">最后，我们需要通过使用<code class="fe nq nr ns nt b">EffectsModule.forFeature([EffectsClass])</code>方法添加效果来更新两个商店服务模块。</p><p id="4583" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">价格商店模块如下所示:</p><pre class="mp mq mr ms gt nu nt nv nw aw nx bi"><span id="2a88" class="lq lr iq nt b gy ny nz l oa ob">@NgModule({<br/>    imports: [<br/>        StoreModule.forFeature('prices', pricesReducer),<br/>        EffectsModule.forFeature([PricesEffects])<br/>    ],<br/>    providers: [<br/>        // still empty!<br/>    ]<br/>})<br/><em class="oc">export class </em>PricesStoreModule {}</span></pre><h1 id="4fd5" class="nd lr iq bd ls ne nf ng lv nh ni nj ly jw nk jx mb jz nl ka me kc nm kd mh nn bi translated">最后的话</h1><p id="852d" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在本演练中，我们创建了几个非常简单的效果来完成一些非常常见的任务，如与API端点对话、从实时消息系统创建可观察流，以及作为调度操作的结果更新reducer。</p><p id="911b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一篇文章中，我们将最终构建一些组件，并使用Facade服务将商店连接到UI。</p><p id="f12c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望你喜欢这篇文章，如果你同意，不同意，或者如果你想做任何不同的事情，请留言！</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="291b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oc">如果你喜欢这篇文章，请关注我的</em> <a class="ae lk" href="https://medium.com/@.gc" rel="noopener"> <em class="oc"> Medium </em> </a> <em class="oc">或</em><a class="ae lk" href="https://twitter.com/home" rel="noopener ugc nofollow" target="_blank"><em class="oc">Twitter</em></a><em class="oc">以获取更多关于Angular、RxJS、Typescript等的文章！</em></p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="29d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oc">最初发布于</em><a class="ae lk" href="https://frontend.consulting/building-side-effects-in-ngrx" rel="noopener ugc nofollow" target="_blank"><em class="oc">https://frontend . consulting</em></a><em class="oc">。</em></p></div></div>    
</body>
</html>