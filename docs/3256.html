<html>
<head>
<title>Using a CDN for your static assets served by Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Kubernetes服务的静态资产使用CDN</h1>
<blockquote>原文：<a href="https://itnext.io/using-a-cdn-for-your-static-assets-served-by-kubernetes-2445e1ff75f?source=collection_archive---------1-----------------------#2019-11-06">https://itnext.io/using-a-cdn-for-your-static-assets-served-by-kubernetes-2445e1ff75f?source=collection_archive---------1-----------------------#2019-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ac4eda4b8970f80d58aacc27993679d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PWkv7E0IYOaM7YaRJCFCJQ.png"/></div></div></figure><div class=""/><p id="4886" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://missena.com/" rel="noopener ugc nofollow" target="_blank"> Missena </a>经营并建立对话广告。我们现在已经投入生产几个月了，我们每月处理大约1亿个请求。只是一个开始。快速和可扩展是我们产品的精髓。我们使用由服务REST和GraphQL APIs的<a class="ae kw" href="https://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>前端和<a class="ae kw" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>后端组成的堆栈。</p><h1 id="ed50" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">TL；博士；医生</h1><p id="d36d" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">使用Kubernetes服务而不是静态文件(例如s3上托管的文件),使我们能够跨环境共享文件，优化我们的构建和部署时间，并在配置发生变化时轻松快速地更新我们的Kubernetes应用，而不必经历整个CI/CD流程。</p><h1 id="e94f" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">当今的Javascript应用</h1><p id="a01f" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">生成javascript应用程序需要时间。这是因为测试的数量，有时是因为代码，也因为环境之间的差异。这涉及到许多转换、编译、精简、优化……许多语言已经被转换成javascript: Typescript、Elm、reason ml……像React这样的库依赖于像JSX这样的抽象，它们必须被转换成JavaScript；诸如babeljs这样的编译器库转换代码以优化它并支持旧的浏览器；缩小器、混淆器……每一个转变都需要时间。</p><h1 id="1a3c" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">库伯内特斯</h1><p id="dc94" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在Missena，我们经常使用Docker和Kubernetes。它帮助我们轻松扩展我们的服务，并处理我们不同的环境:开发、试运行、生产——你能想到的……我们的web服务器和管道基于Kubernetes中运行的docker映像。我们喜欢这个工作流程。我们甚至为Kubernetes的工作重写了一些AWS lambda函数，因为简化部署模型对我们来说更简单。我们发现它很容易监控和调试。我们测试和制造容器。完成后，我们将它们部署到适当的环境中。</p><p id="48c9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的前端过去有不同的管理工作流程。我们曾经生成一组专用于每个环境的静态文件，并将它们部署到s3。我们希望在任何地方运行相同的代码，并且不希望我们的测试和部署管道依赖于相关的环境变量。然而，我们需要我们的应用程序根据环境访问不同的端点地址，比如<code class="fe ma mb mc md b">my.api.dev</code>或<code class="fe ma mb mc md b">my.api.com</code>。</p><p id="0a74" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们一直在努力优化测试和构建时间。为了改进它们，我们必须将配置与代码分开。我的意思是，什么依赖于环境，必须从<a class="ae kw" href="https://www.12factor.net/codebase" rel="noopener ugc nofollow" target="_blank">代码库</a>中分离出来。请记住:我们希望像管理后端一样管理前端，这样我们就可以共享相同的工作流程。那样的话，我们可以将同样的人工制品部署到不同的环境中，并简单地调整其配置使其工作。</p><p id="902b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它<em class="me">仅仅</em>意味着将<a class="ae kw" href="https://www.12factor.net/" rel="noopener ugc nofollow" target="_blank">的<a class="ae kw" href="https://www.12factor.net/config" rel="noopener ugc nofollow" target="_blank">规则三</a>的十二因素应用</a>方法应用到我们的单页面应用程序中，我们将该方法用于我们的后端服务</p><blockquote class="mf mg mh"><p id="f748" class="jy jz me ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated"><em class="jb">一个应用程序的/config/ is </em> <a class="ae kw" href="https://www.12factor.net/config" rel="noopener ugc nofollow" target="_blank"> <em class="jb">在环境之间变化</em> </a> <em class="jb">的一切:登台、生产、开发、测试……下一节解释我们如何解决这个问题。</em></p></blockquote><h1 id="0f1a" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">概念和生产</h1><p id="3d79" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">快速浏览一下我们的堆栈，现在是这样的:</p><p id="69d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">Client</code> → <code class="fe ma mb mc md b">CDN</code> → <code class="fe ma mb mc md b">Webserver</code> → <code class="fe ma mb mc md b">Static assets</code></p><ul class=""><li id="a2da" class="ml mm jb ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated"><code class="fe ma mb mc md b">Client</code>提出请求，</li><li id="f5dd" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe ma mb mc md b">CDN</code>让我们能够轻松扩展和加速页面交付，</li><li id="75f4" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe ma mb mc md b">Webserver</code>了解我们的缓存策略，</li><li id="cb3c" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe ma mb mc md b">Static assets</code>是生成的代码。</li></ul><p id="5b88" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">Webserver</code>和<code class="fe ma mb mc md b">Static assets</code>都包含在我们的docker图像中。我们的配置不是。此外，我们从不更新静态文件，因为我们不想改变基于文件内容的静态资产修订，以便进行长时间缓存。这就是为什么我们在文件名中包含一个内容散列键并重写它们；例如，<code class="fe ma mb mc md b">missena.js</code>保存为<code class="fe ma mb mc md b">missena.d41d8cd98f.js</code>。</p><p id="3320" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的工作解决方案如下所示:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/50814d06279af42fa9a906d83fc9d86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M4J1XLijvhTDESbN.jpg"/></div></div></figure><p id="ce9c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用AWS Cloudfront作为CDN，使用<a class="ae kw" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> nginx </a>或者更具体地说<a class="ae kw" href="https://openresty.org/en/" rel="noopener ugc nofollow" target="_blank"> OpenResty </a>，因为它的<a class="ae kw" href="https://www.lua.org/" rel="noopener ugc nofollow" target="_blank"> Lua </a>功能可以作为我们的网络服务器。</p><p id="7e68" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>的帮助下管理部署和交付。正如我之前所说的，我们希望我们的静态资产在不同的环境中是相同的。为了管理它，我们用OpenResty创建了一个Lua脚本，生成一个依赖于环境的<code class="fe ma mb mc md b">config.json</code>文件。其内容取决于配置设置。该文件由<code class="fe ma mb mc md b">/config.json</code>路由提供服务，相关的缓存算法基于<a class="ae kw" href="https://en.wikipedia.org/wiki/HTTP_ETag" rel="noopener ugc nofollow" target="_blank"> ETag </a>。因此，缓存依赖于文件的内容，并集成到CDN中。</p><p id="5c9d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了工作，前端使用如下所示的脚本调用配置文件:</p><pre class="na nb nc nd gt ne md nf ng aw nh bi"><span id="4fbe" class="ni ky jb md b gy nj nk l nl nm">fetch("/config.json")<br/>  .then(res =&gt; res.json())<br/>  .then(config =&gt; { /* initialise elm application with config */ })<br/>  .catch(err =&gt; { /* do something with error */ });</span></pre><h1 id="e38b" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="47b3" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在设计这个工作流程时，我们学到了很多东西，也发现了这种工作方式的很多优势。我们已经能够以同样的方式管理我们所有的应用程序；后端和前端，我们已经优化了我们的构建和部署时间。</p><p id="92cb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢讨论或分享你自己的设计，欢迎留下评论或联系我们。</p><p id="fcc3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://twitter.com/jney" rel="noopener ugc nofollow" target="_blank"> @jney </a>关注我。</p><p id="c593" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢<a class="ae kw" href="https://twitter.com/gregoryguillou" rel="noopener ugc nofollow" target="_blank"> Gregory Guillou </a>和<a class="ae kw" href="https://twitter.com/CedricSoulas" rel="noopener ugc nofollow" target="_blank"> Cédric Soulas </a>对本文的贡献。</p></div></div>    
</body>
</html>