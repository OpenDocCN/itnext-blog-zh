<html>
<head>
<title>Reactive programming in Angular: Reactive components (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度无功编程:无功分量(第1部分)</h1>
<blockquote>原文：<a href="https://itnext.io/reactive-programming-in-angular-reactive-components-part-1-7291882e352c?source=collection_archive---------5-----------------------#2018-06-26">https://itnext.io/reactive-programming-in-angular-reactive-components-part-1-7291882e352c?source=collection_archive---------5-----------------------#2018-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6190478c2c8af606d109257055bf4a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HKXSyBqRN8Guh_SHBEGJzQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="a833" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">这是关于Angular中反应式编程的第二篇文章。我在Angular开始分享我和rxjs的想法和经验的一系列文章。第一篇文章是Angular中的反应式编程:关于推送通信，你可以在下一个<a class="ae kq" rel="noopener ugc nofollow" target="_blank" href="/reactive-programming-in-angular-on-push-communication-af44de553c18">链接</a>中阅读</h2></div><h1 id="d87e" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">该表:</h1><p id="04c8" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们想象一下，我们需要用Angular来编码一个表。非常简单的事情。我们有两个输入；一个用于配置，另一个用于数据。该表必须分页，所以它必须有一个按钮返回到第一页，一个按钮的前一页和两个以上的下一页和最后一页。选择改变表格的大小也很方便。</p><p id="16eb" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">表格的元素必须是可选择的。如果用户单击表中的某一行，该表将返回所选项的索引。</p><p id="8ba1" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">另一个要求是使表尽可能可重用。一旦我们完成了这项工作，我们就不想再重复了。</p><p id="5bca" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">或多或少像这样:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2c81" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如你所见，没什么特别的。然而，让我们详细检查一下它是如何工作的，以确保每个人都在同一页上。</p><p id="fd9e" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当用户单击其中一个分页按钮时，过程如下:</p><ol class=""><li id="c6c8" class="mq mr jb ll b lm mf lp mg ls ms lw mt ma mu me mv mw mx my bi translated">从表中运行一个newPage事件(src/app/table/table . componet . ts第44行)</li><li id="6783" class="mq mr jb ll b lm mz lp na ls nb lw nc ma nd me mv mw mx my bi translated">此事件运行主页中的方法update table(src/app/home/home . component . html第4行)</li><li id="23d9" class="mq mr jb ll b lm mz lp na ls nb lw nc ma nd me mv mw mx my bi translated">方法updateTable在ApiService请求新页面，该页面返回一个新的可观察实例(src/app/home/home.component.ts第47行)</li><li id="81de" class="mq mr jb ll b lm mz lp na ls nb lw nc ma nd me mv mw mx my bi translated">观察对象被异步管道订阅，从结果中，我们获取新的数据数组，作为表中的输入传递(src/app/home/home . component . html第3行)</li><li id="2268" class="mq mr jb ll b lm mz lp na ls nb lw nc ma nd me mv mw mx my bi translated">该表获取新数据并更新视图</li></ol><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/44e4cd947eddfa574256df2de6e0f959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gtyP82pxfTn71AaC5hNcUQ.gif"/></div></div></figure><p id="eb7c" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果用户单击表格中的某一行，会发生以下情况:</p><ol class=""><li id="897d" class="mq mr jb ll b lm mf lp mg ls ms lw mt ma mu me mv mw mx my bi translated">名为“选择”的输出事件从表开始(src/app/table/table . component . ts第51行)</li><li id="4058" class="mq mr jb ll b lm mz lp na ls nb lw nc ma nd me mv mw mx my bi translated">前面的事件在主页上执行goDetails方法(src/app/home/home.component.html第5行)</li><li id="ea50" class="mq mr jb ll b lm mz lp na ls nb lw nc ma nd me mv mw mx my bi translated">goDeatils方法获取点击数据的索引作为输入。导航到详细信息网页，并将索引放在url的末尾(src / home / home.component.ts第54行)</li><li id="9dba" class="mq mr jb ll b lm mz lp na ls nb lw nc ma nd me mv mw mx my bi translated">详细信息web页面调用ApiService来获取从url检索的索引所指向的信息(src/app/details/details . component . ts第19行)</li><li id="9ba2" class="mq mr jb ll b lm mz lp na ls nb lw nc ma nd me mv mw mx my bi translated">ApiService返回一个由异步管道订阅的可观察对象，以检索个人信息(src/app/details/details.component.html第5–7行)</li></ol><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/710eae87c42c42e9c188017fd6604b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*d64tWmxsFnfc6hfYx2Z-eA.gif"/></div></div></figure><p id="12df" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这个应用程序非常简单。易于阅读和理解。问题是软件有想增长的坏习惯。</p><h1 id="bb9f" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">软件总是想进化</h1><p id="8d2d" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">您可能已经注意到，表格的示例非常简单，很可能在生产几天后，客户开始要求我们改进它。毫无疑问，他/她想要的新特性之一是对行进行排序。最后，表的标签将有另一个事件来获取用户点击订购的列:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="0965" class="nk ks jb ng b gy nl nm l nn no"><em class="np">&lt;my-table<br/>[config]="config$ | async"<br/>[data]="data$ | async"<br/>(newPage)="updateTable($event)"<br/>(selection)="goDetails($event)"<br/></em><strong class="ng jc"><em class="np">(sortRow)=”sort($event)”</em></strong><em class="np"><br/>&gt;&lt;/my-table&gt;</em></span></pre><p id="d7be" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这是一个进步，但我们的桌子仍然太有限。另一个应该很常见的特征是，可以通过在表中拖放一个项目来添加新元素:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="7424" class="nk ks jb ng b gy nl nm l nn no"><em class="np">&lt;my-table<br/>[config]="config$ | async"<br/>[data]="data$ | async"<br/>(newPage)="updateTable($event)"<br/>(selection)="goDetails($event)"<br/></em><strong class="ng jc"><em class="np">(sortRow)=”sort($event)”<br/>(drop)=”dropElement($event)”</em></strong><em class="np"><br/>&gt;&lt;/my-table&gt;</em></span></pre><p id="5cb5" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当然，如果我们可以从表中删除元素，我们应该允许它们被拖出:</p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="b37c" class="nk ks jb ng b gy nl nm l nn no"><em class="np">&lt;my-table<br/>[config]="config$ | async"<br/>[data]="data$ | async"<br/>(newPage)="updateTable($event)"<br/>(selection)="goDetails($event)"<br/></em><strong class="ng jc"><em class="np">(sortRow)=”sort($event)”<br/>(drop)=”dropElement($event)”<br/>(drag)=”dragElement($event)”</em></strong><em class="np"><br/>&gt;&lt;/my-table&gt;</em></span></pre><p id="7c85" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我不知道你是否意识到问题出在哪里。问题是，对于我们想要添加的每个新动作，我们必须创建一个新事件。这会影响组件本身(我们必须为事件创建新的函数)和放置组件的网页(组件必须创建一个函数在事件发生时执行)。最后，每次我们改进组件时，都必须对组件和所有使用组件的地方进行修改…这不太容易维护…</p><h1 id="dd74" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">大约NGRX。</h1><p id="f112" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我第一次尝试解决这个问题的时候，我想到了redux架构(如果你不知道redux架构是什么，你可以从<a class="ae kq" href="http://blog.ng-book.com/introduction-to-redux-with-typescript-and-angular-2/" rel="noopener ugc nofollow" target="_blank">这篇ng-book博客文章</a>中了解)。原因很简单；redux中的所有动作都有相同的接口；动作类型和有效载荷。无论可以在组件上执行多少操作，界面总是相同的。Angular中最流行的redux实现是ngrx，所以…我们来试试。</p><p id="d7d4" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果你对ngrx一无所知，我建议你看一下<a class="ae kq" href="https://www.youtube.com/channel/UCNtFk-g4CCmXMYL4pYNmoEA" rel="noopener ugc nofollow" target="_blank">托德座右铭</a>的视频，看看他的<a class="ae kq" href="https://github.com/UltimateAngular/ngrx-store-effects-app" rel="noopener ugc nofollow" target="_blank">披萨应用</a>的例子。我作弊是因为我的一个最好的朋友，Andres Gesteira，是一个在ngrx项目中有丰富经验的开发人员。他解释了ngrx是如何工作的，我节省了很多阅读时间；).谢谢安德烈斯。</p><p id="34ed" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这是我们的ngrx版本的表格:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7443" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">和以前一样，我将解释每次用户更改表格页面或单击其中一行时会发生什么。我建议您在另一个选项卡中打开stackblitz编辑器，以便遵循代码中的步骤。这个例子没有第一个容易。</p><p id="4a8e" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当用户更改页面时，流程如下:</p><p id="5d03" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">1-在表组件中运行输出事件new page(src/table-list/component/table . component . ts第42行)</p><p id="a18a" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">2-此方法运行表容器的函数request new page(src/table-list/container/table-container . component . html第4行)</p><p id="7d0d" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">requestNewPage分派一个名为LoadRows的新动作，该动作获取所请求的页面及其大小作为输入(src/table-list/container/table-container . component . ts第31行)</p><p id="b9d1" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">4-调度被reducerss拦截，reducer改变表的状态，将加载标志设置为true。这只是表明我们正在运行一个异步任务，这可能需要一些时间(src/table-list/reducers/table-reducers . ts第25行)</p><p id="f46c" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">5-动作被桌子的效果抓住。他们运行ApiService来获取新页面(src/table-list/effects/table-effects . service . ts第22行)</p><p id="8ebf" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">6-当我们从ApiService获得答案时，效果会调度其他动作，这一次是LoadRowsSuccess，它获取新页面、页面的索引和表格最后一页的索引作为输入(src/table-list/effects/table-effects . service . ts第23行)</p><p id="6376" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">7-这个新动作再次被reducers截获，并用新数据更新存储的状态(src/table-list/table-reducers . ts第42–46行)</p><p id="4cbf" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">8-表格容器有一个可观察对象来观察表格状态的变化。它是使用一个选择器(src/table-list/selectors/table-selectors . ts第8行)创建的，该选择器只检索带有表数据的存储的状态(src/table-list/containers/table-container . component . ts第24行)</p><p id="b666" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">9-通过异步管道订阅可观察对象。每当表的状态改变时，值作为输入被传递给组件，视图被更新(src/table-list/containers/table-container . component . html第3行)</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/c39566d5f5cf3e48de7e0489b5f38b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6tvepCy7d0NCSJJCpGidKA.gif"/></div></div></figure><p id="bf0e" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当用户点击一行时，下一行发生:</p><p id="b049" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">1-从表中启动一个名为“选择”的输出事件(src/table-list/components/table . component . ts第49行)</p><p id="a9e6" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">2-此事件运行容器的getSelection方法(src/table-list/container/table . container . html第5行)</p><p id="4588" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">3- getSelection调度一个名为Navigate的新动作，该动作获取细节网页的url和所选行的索引作为输入(src/table-list/container/table . container . ts第36行)</p><p id="72d0" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">4-前一个动作被路由器的效果拦截(是的，ngrx正在包装angular- router ),并且它运行到详细信息网站的导航。(src/app/store/effects/router-effects . service . ts 22行)</p><p id="266f" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">5-细节网页具有在商店上发生变化时订阅的卡容器(src/card/containers/card-container . component . ts行19)</p><p id="a6ca" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">6-要获取所选行的信息，使用getPerson选择器。它是一个自定义选择器，用于获取表的最后状态和路由器的最后状态。路由器从状态中获取所选行的索引，并从表的状态中获取所选行。没有必要再次调用ApiService，因为该行的信息已经在应用程序存储中，这是我们的真实来源(src/card/selectors/selector-card . ts第11行)</p><p id="06a0" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">7-卡容器的可观察对象由异步管道订阅，异步管道获取行的信息并将其作为输入传递给卡组件(src/card/container/card-container . component . html line 1)</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/02e90ee228abec0d85e4e5b0d082790e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nlDCoNFSB9zHSBBJVznjbg.gif"/></div></div></figure><p id="e59b" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">很抱歉解释得这么无聊，但重要的是我们要理解这里发生了什么，看看ngrx是否真的解决了我们最初的问题。</p><h1 id="da84" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">反思:单片vs组件</h1><p id="f28d" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在继续之前，我想思考一下编写整体应用程序或组件应用程序意味着什么。我愿意这样做是因为，很多时候，当我试图向某人解释他/她所做的是一个单片应用程序时，就好像我在质疑他/她母亲的荣誉。每个人都被冒犯了，技术上的争论变成了一场争斗……在公司的会议室里发现枪支并不常见，这真是一件幸事。因此，由于我的意图不是冒犯任何人，我邀请您冷静和平地思考一个非常简单的例子，单片应用程序到底意味着什么。</p><p id="1634" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">想象一下，你需要写一个函数把4和6相加。两种可能的解决方案是:</p><p id="b18f" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll jc">解决方案1: </strong></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="c7c4" class="nk ks jb ng b gy nl nm l nn no"><em class="np">function add () {<br/>  let leng = arguments.length;<br/>  let result = 0;<br/>  for (let i = 0; i &lt; leng; i++){<br/>   result = result + arguments[i];<br/>  }<br/>  return result;<br/>}</em></span></pre><p id="1ba6" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll jc">解</strong> <strong class="ll jc"> 2: </strong></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="726f" class="nk ks jb ng b gy nl nm l nn no"><em class="np">function add () {<br/>  return 4 + 6;<br/>}</em></span></pre><p id="e03c" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">也许你们大多数人会选择第一种解决方案…也许你们大多数人不会考虑第二种解决方案的优势。首先，第二种解决方案易于测试和阅读，满足所有要求(只需将4和6相加)，并且性能优于第一种解决方案。然而，解决方案2创建了一个上下文。我想说的是，其他每一个使用方案2的函数，结果都只能等10。需要另一个结果的函数不能与解决方案2一起工作，所以我们用值10链接我们所有的开发。如果将来我们的应用程序需要一个不是10的值，我们将不得不重构，然后我们将意识到我们的应用程序是单一的。</p><p id="154e" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">然而，尽管如此，解决方案2仍然比解决方案1更容易阅读，更容易测试，也更快。这是第一个伟大的真理；没有什么灵丹妙药，没有什么完美的解决方案。单片应用程序具有我们在解决方案2中指出的相同优势(如果它是用一点常识编码的话……)，是一个完美而有效的解决方案。然而，必须明确的是，未来它将不得不重构。</p><p id="914a" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果最终我们选择一个整体解决方案:</p><p id="b23b" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">1.我们必须意识到我们正在编写一个单一的应用程序。</p><p id="3c60" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">2.我们必须无所畏惧、无所懈怠地规划重构任务。</p><h1 id="6d32" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">但是NGRX解决了我们最初的问题吗？</h1><p id="3f3f" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">回到我们的主要问题，NGRX似乎解决了我们应用程序的初始问题。主页使用表格的方式如下:</p><p id="aab7" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll jc"> home.component.html: </strong></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="4c5d" class="nk ks jb ng b gy nl nm l nn no"><em class="np">&lt;table-container&gt;&lt;/table-container&gt;</em></span></pre><p id="3546" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll jc"> home.component.ts </strong></p><pre class="mk ml mm mn gt nf ng nh ni aw nj bi"><span id="dfac" class="nk ks jb ng b gy nl nm l nn no"><em class="np">import { Component } from '@angular/core';<br/><br/>@Component({<br/></em> <em class="np">selector: 'my-home',<br/></em> <em class="np">templateUrl: 'home.component.html'<br/>})<br/>export class HomeComponent {}</em></span></pre><p id="e089" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">因此，组件如何发展并不重要，因为与组件相关的一切都在组件内部，所以它的用途总是相同的。嗯，我不得不说，这只是表面上的真实。table组件被依赖关系所包围，这些依赖关系导致它的发展导致了对其他组件的重构。我们面对的是一个单一的应用程序。</p><p id="3a93" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">请这样看:表的作用是接收错误消息。错误的解决方案如何属于应用程序(想法是应用程序为其所有组件显示一致的外观)我们不能在表中创建错误处理的逻辑…我们必须创建其他组件(我们可以称为“通知”)来处理这一点。此时，我们的表和通知组件之间有很强的依赖性。如果我们改变表格发送错误动作的方式，通知将会受到影响。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/17627104df952f4aa9beb10e01a26dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uV35F0nEKpYkjghUJyb9GA.png"/></div></div></figure><p id="8cb9" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">现在让我们换到卡组件。卡的组件获得它的表的状态的信息，没有表，它不能工作的原因。这没多大关系，因为卡必须处理自己的错误状态，为此我们必须使用已经链接到表的通知组件。卡片的组件通过两侧与桌子相连。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/f1e7b0ce234861446f0757e8d80dec3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bVrtKRNaDINTiT2NnqMmQ.png"/></div></div></figure><p id="12e6" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">因为请求中的数据也在表的组件内，所以数据的输入必须符合表的API。这意味着ApiService方法必须将back的结果转换成表(只有表)能够理解的对象。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/992344fc05211906a40b1e372d5b79c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lmG7mNR0jriDV6iYFLGilA.png"/></div></div></figure><p id="02e2" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">最后一个依赖项来自角度路由器，因为表需要发送导航事件，卡需要检索所选元素的索引。</p><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/e2a4d0160ab0f97371cea099a974c07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7t4kgoKKJlKlMuaniZHYLA.png"/></div></div></figure><p id="2521" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">正如你所看到的，我们必须在应用程序中有很多的依赖性，以考虑表中的变化不会有副作用。</p><h1 id="91c4" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">虚拟组件不是组件</h1><p id="75d6" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们把只有一个模板的组件称为可视组件或虚拟组件，它的功能是促进用户对容器的操作。我的意思是看一下src/table-list/components/table . component . ts这个组件只是渲染模板，观察用户的交互。它不做任何其他事情。这样，table.component.ts不依赖于应用程序的任何元素，完全可以重用。然而，打破应用程序的整体性是不够的。原因是这种类型的组件不太符合软件组件的定义。</p><p id="52ca" class="pw-post-body-paragraph lj lk jb ll b lm mf kc lo lp mg kf lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">基于组件的体系结构是由道格拉斯·麦克洛伊于1968年在德国的加米施首次提出的。他用Unix命令的例子来解释什么是软件组件。如果你看看Unix命令，像' ls '或' grep ',它们是完整的软件。我的意思是，每个Unix命令本身都有意义。你可以单独使用它们……或者你可以通过管道运营商将它们结合起来。这就是视觉组件所缺乏的。可视化组件本身不能执行任何任务。你能想象一个只有table.component.ts及其模板的网页吗？这很简单，它需要存储、选择器和缩减器来管理自己状态的数据，如果组件的这些部分创建了一个应用程序上下文，那么组件的概念就会被淡化，最终成为一个整体的应用程序。我再说一遍，如果我们清楚自己在做什么，这不一定是一件坏事。</p><h1 id="6d85" class="kr ks jb bd kt ku kv kw kx ky kz la lb kh lc ki ld kk le kl lf kn lg ko lh li bi translated">下一集</h1><p id="2b4d" class="pw-post-body-paragraph lj lk jb ll b lm ln kc lo lp lq kf lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">有趣的是，当我开始写这篇文章时，我没有想到它会这么大，但事实就是如此。我还有很多事情要告诉你。当然，我实现了一个替代版本的表格应用程序，打破了整体。这个版本解决了我们的第一个问题，创建了一个基于组件的架构，但是也带来了ngrx没有的缺点。我想分享这些想法和更多，但今天已经足够了。我认为，通过这篇文章，我已经修改了关于这个月的争议范围。下个月我们将继续辩论。</p></div></div>    
</body>
</html>