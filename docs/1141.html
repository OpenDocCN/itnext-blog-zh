<html>
<head>
<title>Detecting and Outlining Lakes with Python3 and OpenCV 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python3和OpenCV 3探测和勾画湖泊</h1>
<blockquote>原文：<a href="https://itnext.io/detecting-and-outlining-lakes-with-python3-and-opencv-3-9156bdeacbf0?source=collection_archive---------3-----------------------#2018-07-28">https://itnext.io/detecting-and-outlining-lakes-with-python3-and-opencv-3-9156bdeacbf0?source=collection_archive---------3-----------------------#2018-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b307" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将使用Python3和OpenCV检查一些基本的形状和轮廓检测。</p><p id="c012" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的源代码可以在<a class="ae kl" href="https://github.com/lmiller1990/python-opencv-lake-recognition" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="5048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">原贴于</em> <a class="ae kl" href="https://lmiller1990.github.io/electic/" rel="noopener ugc nofollow" target="_blank"> <em class="km">拉克伦·米勒的博客</em> </a> <em class="km">。</em></p><h1 id="d419" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">目标</h1><p id="7cfb" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">目标是检测最大的水体，并根据谷歌地图的屏幕截图计算半径和大致面积。本文介绍了一些代码，这些代码在给定一个屏幕截图的情况下，检测最大的水体，并在边缘周围画一条线:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/dedee4df4ed2a18e5395f3074b83222f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EBVKHRAsSVGWm7R-"/></div></div></figure><h1 id="eb5b" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">设置</h1><p id="0311" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我会用Python3和OpenCV3。安装Python3的方法有很多，我用的是<a class="ae kl" href="https://anaconda.org/anaconda/python" rel="noopener ugc nofollow" target="_blank">康达</a>。我通过运行<code class="fe mc md me mf b">brew install opencv</code>用自制软件安装了OpenCV。</p><p id="d0bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要检查是否安装了opencv，创建一个<code class="fe mc md me mf b">detector.py</code>脚本并添加以下内容:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9234" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和<code class="fe mc md me mf b">python3 detector.py</code>一起跑。我的输出是:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="06a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的输出之前，我得到了一个关于numpy的错误。修复方法是使用自制软件重新安装numpy。</p><h1 id="f08b" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">使用范围内的基本阈值</h1><p id="7cab" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">下一步是应用一个阈值，去掉我们不感兴趣的数据。因为我们使用谷歌地图，所以湖泊总是同样的蓝色，这让事情变得简单。</p><p id="00bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">湖泊的RGB颜色为<code class="fe mc md me mf b">[170, 218, 255]</code>。OpenCV使用不同的排序，BGR。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/4231c9a1499de78850bed6e6b9f3c952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iXPCIt0qFPHhb1nv"/></div></div></figure><p id="1cc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<code class="fe mc md me mf b">cv.inRange</code>函数，它有三个参数:一个图像、一个较低的颜色范围和一个较高的颜色范围。这里的文档是<a class="ae kl" href="https://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#inrange" rel="noopener ugc nofollow" target="_blank">这里是</a>。基于反复试验，我发现±10的范围效果很好。</p><p id="7361" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新脚本:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在添加两个函数:<code class="fe mc md me mf b">read_image</code>，获取我们将要操作的图像，和<code class="fe mc md me mf b">find_mask</code>，用<code class="fe mc md me mf b">inRange</code>应用阈值。</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c40d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在显示阈值图像之前，最好理解一下<code class="fe mc md me mf b">cv.imread</code>返回的是什么。添加以下代码:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="cdb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将我的截屏保存为“pond.png”。用<code class="fe mc md me mf b">python3 detector.py</code>运行上述代码会打印出以下内容:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="eb22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">596是图像的高度或行数。数组中的每一行包含697个值，其中每个值是包含[B，G，R]个值的1×3矩阵。所以图像只是BGR像素的集合。</p><p id="a10d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mc md me mf b">inRange</code>是相似的，然而不是每个像素被映射到一个BGR值，而是它被简单地分配一个值0或1 -无论它是否在阈值之间。</p><p id="76f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试使用以下代码呈现遮罩:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="19ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行脚本会显示掩码:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/46a0ac5e0abcdcaa98423f7735c7ea87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hms9133-fY2w55Cv"/></div></div></figure><p id="3a43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">终端中的输出确认<code class="fe mc md me mf b">inRange</code>为每个像素返回0或1的数组:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h1 id="b134" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">用<code class="fe mc md me mf b">findContours</code>寻找轮廓</h1><p id="5918" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">OpenCV有一个<code class="fe mc md me mf b">findContours</code>函数，可以在二值图像中找到边缘。我们有一个二元图像——这就是为什么我们创造了面具。在的文档<a class="ae kl" href="https://docs.opencv.org/2.4/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html?#findcontours" rel="noopener ugc nofollow" target="_blank">中阅读关于<code class="fe mc md me mf b">findContours</code>的内容。这些论点是:</a></p><ul class=""><li id="5643" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated"><code class="fe mc md me mf b">image</code>:要使用的二进制图像。修改图像，所以我们应该传入一个副本</li><li id="9614" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe mc md me mf b">mode</code>:轮廓检索模式。文档中描述了这些模式。我们关注的是最大的区域，所以最适合这个问题的是<code class="fe mc md me mf b">CV_RETR_EXTERNAL</code></li><li id="f991" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe mc md me mf b">method</code>:轮廓逼近法。同样，在文档中有描述。我不太明白哪个最适合这个问题，所以我用了<code class="fe mc md me mf b">CHAIN_APPROX_SIMPLE</code>,因为这是一个简单的问题，而且这个方法的名字中有simple。<code class="fe mc md me mf b">¯\_(ツ)_/¯</code></li></ul><p id="e4dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道了<code class="fe mc md me mf b">findContours</code>，我们可以编写下面的函数:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="2d7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mc md me mf b">findContours</code>返回三个值。第一个似乎是被<code class="fe mc md me mf b">findContours</code>修改过的图像，我们其实并不需要。第二个是找到的轮廓。最后是层次结构，它包含关于图像拓扑的信息。我还不完全明白这个能用来做什么。我们只需要第二个值，<code class="fe mc md me mf b">cnts</code>。</p><p id="e60b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行<code class="fe mc md me mf b">find_contours</code>功能，并传入先前打印的<code class="fe mc md me mf b">mask</code><code class="fe mc md me mf b">Found 93 black shapes</code>。这是计算图像中所有的小水体，或其他蓝色像素。暂时不理想。我们会尽快解决这个问题。</p><h1 id="4900" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">使用<code class="fe mc md me mf b">drawContours</code>绘制轮廓</h1><p id="0477" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">让我们继续创建一个<code class="fe mc md me mf b">show_contours</code>函数来可视化93个轮廓，使用OpenCV的<code class="fe mc md me mf b">drawContours</code>函数，这里描述的<a class="ae kl" href="https://docs.opencv.org/2.4/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html?#drawcontours" rel="noopener ugc nofollow" target="_blank"/>。这些论点是:</p><ul class=""><li id="3b99" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">图像:要绘制的图像</li><li id="6515" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">轮廓:要绘制的轮廓数组。轮廓是点的阵列</li><li id="d84c" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">contour_index:要绘制的轮廓的索引。现在我们将传递-1，它绘制所有的轮廓</li><li id="b42b" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">颜色:绘制轮廓的颜色。我会用红色:<code class="fe mc md me mf b">0, 0, 255</code></li><li id="96db" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">厚度:绘制轮廓的厚度。我发现2是个好数字</li></ul><p id="1cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道了参数，我们可以实现<code class="fe mc md me mf b">show_contours</code>:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8f2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将这个与<code class="fe mc md me mf b">find_contours</code>一起使用，我们得到如下结果:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mw"><img src="../Images/decd193290f11c9af93bed15495bfd96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*znyaY7qGi4KABxvz"/></div></div></figure><h1 id="e1d6" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">提取最大的水体</h1><p id="1d5d" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们有93个轮廓，如上图所示。我们只想要最大的那个，也就是点数最多的那个。添加一个<code class="fe mc md me mf b">main_contour</code>功能:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9792" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们简单地按照长度对<code class="fe mc md me mf b">contours</code>进行排序，并返回最长的一个。将所有这些整合在一起:</p><figure class="lr ls lt lu gt lv"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9ab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且，它有效:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mw"><img src="../Images/85c6a1f3e0c826531e57e9c7e8233145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8tRPBaUA92jEoBRe"/></div></div></figure><p id="3609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！</p><h1 id="fdfc" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="3df8" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">这篇文章描述了:</p><ul class=""><li id="ba35" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">如何使用<code class="fe mc md me mf b">inRange</code>进行阈值处理并制作蒙版</li><li id="4455" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">使用<code class="fe mc md me mf b">findContours</code>及其参数寻找轮廓</li><li id="fd4c" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">用<code class="fe mc md me mf b">drawContours</code>显示轮廓</li></ul><p id="17c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我很久以来第一次做图像识别。我以前的经验是在C++中使用OpenCV，使用Python绑定后，它变得更加容易和易于使用，这让我印象深刻。我通过阅读<a class="ae kl" href="https://www.pyimagesearch.com/2014/10/20/finding-shapes-images-using-python-opencv/" rel="noopener ugc nofollow" target="_blank"> Py图片搜索</a>学到了很多东西，这是希望尝试Python和图片识别的web开发人员的绝佳资源。</p><p id="e18f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的源代码可以在<a class="ae kl" href="https://github.com/lmiller1990/python-opencv-lake-recognition" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="f7eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">原贴于</em> <a class="ae kl" href="https://lmiller1990.github.io/electic/" rel="noopener ugc nofollow" target="_blank"> <em class="km">拉克伦·米勒的博客</em> </a> <em class="km">。</em></p></div></div>    
</body>
</html>