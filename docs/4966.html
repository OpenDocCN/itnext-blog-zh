<html>
<head>
<title>Enabling docker builds with BuildKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BuildKit启用docker构建</h1>
<blockquote>原文：<a href="https://itnext.io/enabling-docker-builds-with-buildkit-a931c6f9aa91?source=collection_archive---------1-----------------------#2020-11-04">https://itnext.io/enabling-docker-builds-with-buildkit-a931c6f9aa91?source=collection_archive---------1-----------------------#2020-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="56ad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍Docker BuildKit</h2></div><p id="ef76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我是一名SRE，我做的很多工作都与码头集装箱有关。围绕docker容器的大量工作都是在构建它们。有些docker文件非常简单，比如在alpine/scratch映像中添加一个Go二进制文件，而有些文件非常复杂，尤其是在使用多阶段构建时。在后一种情况下，除了创建映像之外，通常还会用docker构建二进制文件。有时，在这种情况下，运行docker构建命令可能需要几分钟以上的时间(例如<a class="ae lb" href="https://github.com/argoproj/argo-cd/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Argo-CD </a>大约需要12-15分钟，尽管并不只是创建一个映像)。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/4566cf6fdb00eb0376ae0abd1813d820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ReyHydAQoMTVnUT252KUwQ.png"/></div></div></figure><p id="0ce2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从Docker 18.09开始，有一种新的构建图像的方式叫做<a class="ae lb" href="https://docs.docker.com/develop/develop-images/build_enhancements/" rel="noopener ugc nofollow" target="_blank"> BuildKit </a>。这被认为是docker版本的V2，目前它甚至不是Docker 19.03的默认方式，你需要启用它。激活它最简单的方法是设置一个环境变量:<em class="lo"> DOCKER_BUILKIT=1 </em>。这个V2增加了许多有趣的功能，其中一些是开箱即用。此外，生成的docker映像类似于用普通构建创建的映像，因此运行该映像或将其推送到注册表应该不会有任何问题。</p><h2 id="da26" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">BuildKit性能改进</h2><p id="8333" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在正常的docker构建中，每一层都是按顺序构建的，您需要等待第n层构建n+1。这个限制最初并不明显，但是随着多阶段构建的引入，它变成了一个更大的问题，因为您可以并行地开始更多的步骤，直到它们相互依赖。因此，通过引入一些并行性，可以节省宝贵的时间。</p><p id="4a16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了找出哪些步骤可以并行构建，哪些步骤需要相互等待，BuildKit将构建一个依赖关系图，并使用它来提高构建效率。docker构建命令的输出将与您之前使用的完全不同，其中一些步骤并行运行，类似于下面的内容(您可以看到#4与#10并行运行):</p><pre class="ld le lf lg gt mn mo mp mq aw mr bi"><span id="adec" class="lp lq iq mo b gy ms mt l mu mv">#2 [internal] load build definition from Dockerfile<br/>#2 transferring dockerfile: 1.15kB done<br/>#2 DONE 0.0s<br/><br/>#1 [internal] load .dockerignore<br/>#1 transferring context: 2B done<br/>#1 DONE 0.0s<br/><br/>#3 [internal] load metadata for docker.io/library/openjdk:8<br/>#3 DONE 1.7s<br/><br/>#4 [1/8] FROM docker.io/library/openjdk:8@sha256:291ef47999c4ee7160cc1208ff...<br/>#4 resolve docker.io/library/openjdk:8@sha256:291ef47999c4ee7160cc1208ff49244bf93a43b7eca1c31842615fc529efc24e done<br/>#4 ...<br/><br/>#10 [internal] load build context<br/>#10 transferring context: 10.60kB done<br/>#10 DONE 0.0s<br/><br/>#4 [1/8] FROM docker.io/library/openjdk:8@sha256:291ef47999c4ee7160cc1208ff...</span></pre><p id="a6a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">性能并不是BuildKit提供的唯一改进，但是我们可以在不对Dockerfile文件进行任何更改的情况下就获得它。这是我接下来想要检查的，如何在多阶段docker构建上启用BuildKit，以及它是否真的是一个显著的改进。</p><h2 id="93d7" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">使用BuildKit构建ArgoCD</h2><p id="fe04" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">因此，让我们通过将BuildKit引入到一个真实的项目中，并将其与普通的构建进行比较，来看看我们是否真的能从中受益。一个很好的候选是ArgoCD，因为它有一个复杂的docker文件和构建图像所花费的时间(他们通过使用多个目标从一个docker文件构建多个图像)。我的计划是在本地克隆它，将其推送到我的帐户(不是fork，因为我不打算创建PR)，禁用现有的GitHub工作流，添加两个简单的新工作流，只以标准方式和BuildKit方式构建图像，然后比较运行它5次的结果。</p><p id="f722" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以首先我在github上创建了一个名为argocd-buidkit的空的新项目。然后我把原来的argo-cd项目，克隆到本地，去掉遥控器，把这个argocd-buldkit作为一个新的遥控器添加进去，推送给它。最后我以<a class="ae lb" href="https://github.com/lcostea/argocd-buildkit" rel="noopener ugc nofollow" target="_blank"> argocd-buildkit repo </a>结束。</p><p id="665c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我创建了两个新的GitHub动作，一个以正常方式构建图像，另一个使用额外的env变量来启用BuildKit。这是增加了变量的第二个例子，与第一个例子的唯一区别是增加了最后两行(28 &amp; 29)。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e8f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以查看我在argocd-buildkit项目的<a class="ae lb" href="https://github.com/lcostea/argocd-buildkit/actions" rel="noopener ugc nofollow" target="_blank">动作部分执行的运行。</a></p><p id="6942" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一轮:</p><ul class=""><li id="30d6" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated"><a class="ae lb" href="https://github.com/lcostea/argocd-buildkit/actions/runs/340202242" rel="noopener ugc nofollow" target="_blank">Docker-Image-Standard</a>:13m 27s</li><li id="cf5d" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated">Docker-Image-build kit:12米13秒</li></ul><p id="d8d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二轮:</p><ul class=""><li id="55df" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated"><a class="ae lb" href="https://github.com/lcostea/argocd-buildkit/actions/runs/340424391" rel="noopener ugc nofollow" target="_blank">Docker-Image-Standard</a>:14m 11s</li><li id="eb72" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae lb" href="https://github.com/lcostea/argocd-buildkit/actions/runs/340424392" rel="noopener ugc nofollow" target="_blank">Docker-Image-build kit</a>:10m 56s</li></ul><p id="4834" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三次运行:</p><ul class=""><li id="333a" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated"><a class="ae lb" href="https://github.com/lcostea/argocd-buildkit/actions/runs/340568618" rel="noopener ugc nofollow" target="_blank">Docker-Image-Standard</a>:12m 43s</li><li id="6ed8" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae lb" href="https://github.com/lcostea/argocd-buildkit/actions/runs/340568617" rel="noopener ugc nofollow" target="_blank">Docker-Image-build kit</a>:11m 19s</li></ul><p id="09da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第四轮:</p><ul class=""><li id="d6a4" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated"><a class="ae lb" href="https://github.com/lcostea/argocd-buildkit/actions/runs/340591871" rel="noopener ugc nofollow" target="_blank">Docker-Image-Standard</a>:13m 49s</li><li id="2cef" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated">Docker-Image-build kit:12米29秒</li></ul><p id="5f1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第五次运行:</p><ul class=""><li id="03cf" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated"><a class="ae lb" href="https://github.com/lcostea/argocd-buildkit/actions/runs/341238041" rel="noopener ugc nofollow" target="_blank">Docker-Image-Standard</a>:12m 59s</li><li id="b82e" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><a class="ae lb" href="https://github.com/lcostea/argocd-buildkit/actions/runs/341238096" rel="noopener ugc nofollow" target="_blank">Docker-Image-build kit</a>:12m 59s</li></ul><p id="6be1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然存在一些差异，与标准运行相比，BuildKit版本花费的时间少了3.5分钟，但一次花费的时间完全相同。需要特别说明的是，这不是docker build的一个实验性特性，因为实验性特性不建议在生产中使用。相反，这是一个选择加入的。</p><p id="834b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是有任何已知的项目实际上使用BuildKit来创建它们的docker映像吗？在CNCF空间，我发现了<a class="ae lb" href="https://github.com/dexidp/dex" rel="noopener ugc nofollow" target="_blank"> dex </a>，这是一个身份服务，它使用<a class="ae lb" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> OpenID Connect </a>来驱动其他应用的认证。而dex是ArgoCD内部使用的。如果你去看看它的工作流程，在docker部分你会看到它使用了<a class="ae lb" href="https://docs.docker.com/buildx/working-with-buildx/" rel="noopener ugc nofollow" target="_blank"> buildx </a>(这实际上是一个实验性的特性，但是在<a class="ae lb" href="https://github.com/moby/moby/milestone/76" rel="noopener ugc nofollow" target="_blank"> 20.10 </a>版本中它可能会停止实验)，它在下面使用BuildKit来创建docker图像。</p><p id="eccc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以使用BuildKit应该没有问题，除了性能之外，它还有许多其他特性。但是，如果您仍然有疑问，您可以首先尝试使用您的内部映像，如CI/CD中使用的映像或您的内部工具，在您建立更多信心后，您可以使用您的生产映像。</p></div></div>    
</body>
</html>