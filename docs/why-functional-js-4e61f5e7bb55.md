# 为什么选择功能性 JS

> 原文：<https://itnext.io/why-functional-js-4e61f5e7bb55?source=collection_archive---------6----------------------->

关于“你建议如何从 FP 开始？”的一些想法我在米兰 Codemotion 2019 演讲后的问题。

![](img/f11286b3cb347b81942d884ee3c9de72.png)

塞缪尔·费拉拉在 [Unsplash](https://unsplash.com) 上拍摄的照片

2019 年 10 月 24 日，我在意大利米兰的 [Codemotion](https://events.codemotion.com/conferences/milan/2019/speaker/6205/) 大会上做了第一次演讲。我谈到了函数式编程，以及在处理复杂的现实问题(如可维护性、可伸缩性和错误处理)时，它如何使我们的生活变得更容易。

很多人问我:“你会怎么推荐从 FP 开始？”答案很简单。如果在 80 年代问同样的问题，我的答案会完全不同。但是今天，随着前端开发变得越来越复杂，我建议从函数型脚本开始。

为什么？让我们来了解一下！

# 不确定

从本质上讲，函数式编程迫使你编写纯函数，原因很简单:我们需要从计算中得到确定性的结果。例如，如果我们正在处理一个依赖于用户输入的函数…会有多少事情出错？用户可能插入错误或不完整的输入；连接可能会失败，向服务器发送数据可能需要一个 HTTP 请求，这个请求可能会因为几个原因而失败…我们从来不确定一切会像我们想象的那样进行。我们究竟怎样才能从这些混乱中得到一个确定性的结果呢？到处放`try/catch`？创建一个巨大的`if/else`控制结构？我们知道一种更优雅的方式。在“处理 try/catch 和 if/else hell”这篇文章中，我们看到了单子如何帮助我们改进代码流和弹性。

*   数据可能导致错误？让我们用任一单子。它将总是返回两个值:`Right(<desired-data>)`和`Left(<error-wrapper>)`。
*   数据可能因为某种原因是`null`还是`undefined`？也许莫纳德来救援了！我们的数据将被包装在`Just(<data>)`中，如果它存在的话。否则，我们只需要处理一个`Nothing`值。不再有`null` / `undefined` / `void 0`。
*   数据存在，但我们有它的一个或多个副本？单子单子会是你的朋友！
*   数据依赖于状态吗？状态 monad 会帮到你很多！

等等，等等，等等！

这有什么意义？在构造函数时，我们总是会从不确定的操作中得到可预测的结果。

# 类型

在开始时，我说过我会推荐函数式类型脚本。但是我们真的需要类型来使我们的代码起作用吗？当然不会。Erlang、Elixir、LISP，只是动态类型函数式语言的一个简短列表。这些语言有一些很好的理由成为动态类型。他们经常提供一些分析工具，如 Erlang 的[透析器](http://erlang.org/doc/man/dialyzer.html)，这是一种“静态分析工具，可以识别软件差异，如明确的类型错误，由于编程错误而变得无效或不可访问的代码，以及单个 Erlang 模块或整个(多组)应用程序中不必要的测试。”

JavaScript 没有这种现成的东西，所以我们需要采取一些预防措施。 [Flow](https://flow.org/) 和 [TypeScript](https://www.typescriptlang.org/) 只是 JavaScript 社区试图避免一些众所周知的运行时类型错误的几个例子，他们做得非常出色。它们也帮助我们更容易地阅读我们的代码。你有多少次因为类型错误而用调试器运行你的 JS 代码？在你的代码中找出那种讨厌的错误有多难？嗯，这可能是微不足道的，但有了 Flow 或 TypeScript，您再也不会遇到这些错误了。

当使用 Haskell 或 Idris 等强类型函数式语言编写时，可以更好地查看数据。

在函数式编程中，函数描述你的数据。类型也描述了你的数据。在计算过程中，你必须始终关注数据是如何被操作的。

# 为什么从功能前端开始？

原因很简单:你会立即看到结果。假设我们正在使用 Laravel、Spring 或 Ruby on Rails 从头开始编写一个博客平台，比如 WordPress。用户正在登录，后端出现错误。没问题，我们向前端发送一个错误，用户会被警告。我们的后端流量通常是定义良好的，我们习惯于处理这些错误。

但是在前端，任何事情都可能发生。我们一直在努力处理由于用户的意外行为而可能发生的许多错误。而且即使用户按预期在使用我们的前端，互联网连接也可能会瘫痪；服务器崩溃。出于某种原因，一个第三方脚本与我们的 JavaScript 代码库交互并使其崩溃。

我们可以通过采用一种新的方式对我们的前端应用程序进行编程，以最小的努力开始处理所有这些情况。

在编写前端 JavaScript 应用程序时，还需要记住另一件事:脚本大小。好吧，我们是在 2020 年，即使在山区我们也有快速的互联网连接，但为什么我们的用户要下载一个 5MB 的脚本来浏览我们的网站？

纯函数允许我们轻松地重用代码。一个更加模块化的代码库意味着我们可以一次定义我们的函数，并在我们需要的时候重用它们。我们不需要编写只在某个类内部起作用的私有类方法，也不希望仅仅因为某些方法依赖于某个隐藏状态就重写它们(这样它们就不会在某个类之外起作用)。我们希望我们的函数尽可能地可重用，这样我们的代码库将会增长，而不会向我们的包中添加千字节的重复函数。

# 结论

当编写服务器端应用程序时，你可能不会觉得需要一个功能代码库，直到你的软件开始出现一些伸缩问题。从面向对象架构过渡到功能性架构可以极大地减少服务器数量的例子数不胜数。当然，FP 的优势不仅仅在于可伸缩性，还在于代码可维护性、测试、模块化、错误处理(等等)。

我发现 JavaScript 是前端和后端之间的通用语言。因此，将你的 FP 知识从前端开发转移到后端开发会更容易，反之亦然。Frontend 也有一些有趣的例子(正如我们前面看到的),在这些例子中，FP 实际上可以发挥作用。

所以，对于那些不知道从哪里开始学习 FP 的人，我的回答是:从 JavaScript 开始。如果您不熟悉 TypeScript/Flow，请尝试一下。他们将永远改变你写 JS 的方式！

一旦你对函数式 JS 有了信心，切换到其他语言将会容易得多！