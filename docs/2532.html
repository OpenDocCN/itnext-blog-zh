<html>
<head>
<title>Testing APIs using advanced REST client — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用高级REST客户端测试APIs第二部分</h1>
<blockquote>原文：<a href="https://itnext.io/testing-apis-using-advanced-rest-client-part-ii-4ff1b1d37960?source=collection_archive---------1-----------------------#2019-06-10">https://itnext.io/testing-apis-using-advanced-rest-client-part-ii-4ff1b1d37960?source=collection_archive---------1-----------------------#2019-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2bc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的第一部分中，我写了关于rest客户端的测试。在本文中，我们将深入探讨REST API测试。如何使用放心创建自动化脚本？</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/44f90704cb825fb3101b5acf9093a35f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*7nqOm0RU-qrwTl7o4m7N1g.jpeg"/></div></div></figure><p id="de0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">请放心</strong>是一个很棒的Java库，完全涵盖了自动化工程师需要的一切。放心编写自动化脚本非常舒服。</p><p id="852d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">放心可以有两种连接方式:Maven或者Gradle。</p><p id="1d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Maven:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="24cc" class="ld le iq kz b gy lf lg l lh li">&lt;dependency&gt;<br/>      &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;<br/>      &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;<br/>      &lt;version&gt;4.0.0&lt;/version&gt;<br/>      &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="0dad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">格拉德:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="430f" class="ld le iq kz b gy lf lg l lh li">testCompile 'io.rest-assured:rest-assured:4.0.0'</span></pre><p id="fb67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最简单的放心工作的例子如下:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="bd40" class="ld le iq kz b gy lf lg l lh li"><strong class="kz ir">public class </strong>CheckData {<br/>    @Test<br/>    <strong class="kz ir">public void </strong>getUserData() {<br/>        given.get(<strong class="kz ir">"https://jsonplaceholder.typicode.com/posts"</strong>)<br/>                .then()<br/>                .statusCode(200)<br/>                .and()<br/>                .assertThat()<br/>                .body(<strong class="kz ir">"userId"</strong>, equalTo(1))<br/>                .body(<strong class="kz ir">"Id"</strong>, equalTo(5))<br/>                .body(<strong class="kz ir">"title"</strong>, equalTo(<strong class="kz ir">"nesciunt quas odio"</strong>));<br/>    }<br/>}</span></pre><p id="b933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个“标准”方法实现的例子。</p><p id="fbcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就我个人而言，我更喜欢将来自服务器的JSON响应转换成Java对象的正确方法。</p><p id="5ccc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这种方法有一个缺点:您需要将JSON结构描述为Java POJO形式。</p><p id="0a50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，这是一项相当耗时的任务，尤其是当您需要处理大量响应时。</p><p id="a66f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，底部的服务器响应应该是这样的:</p><p id="315f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">{<br/>【id】:1、<br/>【姓名】:【符晓薇·格拉汉姆】、<br/>【用户名】:【布雷特】、<br/>【电子邮件】:<a class="ae kl" href="mailto:Sincere@april.biz" rel="noopener ugc nofollow" target="_blank">真诚@april.biz </a>”、<br/>【地址】:{ <br/>【街道】:【库拉斯之光】、<br/>【组曲】:“Apt。556 "、<br/> "city": "Gwenborough "、<br/>" zip code ":" 92998–3874 "、<br/>" geo ":{<br/>" lat ":"-37.3159 "、<br/>" LNG ":" 81.1496 "<br/>}<br/>}、<br/>" phone ":" 1–770–736–8031 x 56442 "</p><p id="0cbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你需要花一些时间用Java来描述这个结构。使用<strong class="jp ir"> RoboPojoGenerator </strong>插件，你可以走一条更好的路，形成想要的类。必须在IDE设置中添加它。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lj"><img src="../Images/f923d26c2d6afd9a13ec2006a3dd14bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bjttqivrj0NsngdG"/></div></div></figure><p id="a001" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操作原理相当简单:复制JSON数据，粘贴到文本字段，选择库，点击生成按钮。生成的类将立即显示在项目中。</p><p id="f2e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法有一个主要缺点——您需要做大量的手工工作来复制JSON数据。这个过程可以而且应该自动化。你可以找到非常有用的插件让Gradle和Maven来做这件事。</p><p id="70d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Maven插件的连接示例:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="c78f" class="ld le iq kz b gy lf lg l lh li">&lt;plugin&gt;<br/>    &lt;groupId&gt;org.jsonschema2pojo&lt;/groupId&gt;<br/>    &lt;artifactId&gt;jsonschema2pojo-maven-plugin&lt;/artifactId&gt;<br/>    &lt;version&gt;1.0.1&lt;/version&gt;<br/>    &lt;configuration&gt;<br/>       &lt;sourceDirectory&gt;${basedir}/src/main/resources/schema&lt;/sourceDirectory&gt;<br/>        &lt;targetPackage&gt;com.example.types&lt;/targetPackage&gt;<br/>    &lt;/configuration&gt;<br/>    &lt;executions&gt;<br/>        &lt;execution&gt;<br/>            &lt;goals&gt;<br/>                &lt;goal&gt;generate&lt;/goal&gt;<br/>            &lt;/goals&gt;<br/>        &lt;/execution&gt;<br/>    &lt;/executions&gt;<br/>&lt;/plugin&gt;</span></pre><p id="88f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于格雷尔:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="8bbc" class="ld le iq kz b gy lf lg l lh li">// Use the java plugin <br/>apply plugin: 'java' <br/>// In Android Projects use <br/>apply plugin: 'com.android.application'<br/><br/>apply plugin: 'jsonschema2pojo'<br/><br/>buildscript {<br/>  repositories {<br/>    mavenCentral()<br/>  }<br/><br/>  dependencies {<br/>    // this plugin<br/>    classpath 'org.jsonschema2pojo:jsonschema2pojo-gradle-plugin:${js2p.version}'<br/>    // add additional dependencies here if you wish to reference instead of generate them (see example directory)<br/>  }<br/>}<br/><br/>repositories {<br/>  mavenCentral()<br/>}<br/><br/>dependencies {<br/>  // Required if generating JSR-303 annotations<br/>  compile 'javax.validation:validation-api:1.1.0.CR2'<br/>  // Required if generating Jackson 2 annotations<br/>  compile 'com.fasterxml.jackson.core:jackson-databind:2.9.7'<br/>  // Required if generating JodaTime data types<br/>  compile 'joda-time:joda-time:2.2'<br/>}<br/><br/>// Each configuration is set to the default value<br/>jsonSchema2Pojo {<br/><br/>  // Location of the JSON Schema file(s). This may refer to a single file or a directory of files.<br/>  source = files("${sourceSets.main.output.resourcesDir}/json")<br/><br/>  // Target directory for generated Java source files. The plugin will add this directory to the<br/>  // java source set so the compiler will find and compile the newly generated source files.<br/>  targetDirectory = file("${project.buildDir}/generated-sources/js2p")<br/><br/>  // Package name used for generated Java classes (for types where a fully qualified name has not<br/>  // been supplied in the schema using the 'javaType' property).<br/>  targetPackage = ''<br/><br/>  // The type of input documents that will be read. Supported values:<br/>  //  - jsonschema (schema documents, containing formal rules that describe the structure of JSON data)<br/>  //  - json (documents that represent an example of the kind of JSON data that the generated Java types<br/>  //          will be mapped to)<br/>  //  - yamlschema (JSON schema documents, represented as YAML)<br/>  //  - yaml (documents that represent an example of the kind of YAML (or JSON) data that the generated Java types<br/>  //          will be mapped to)<br/>  sourceType = 'json'</span></pre><p id="88ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="lk"> src/java/resources/json文件夹</em>中，添加您需要的json文件，并在控制台中运行该命令:</p><p id="e2dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">。/grad Lew generatejsonschema 2 POJO</strong></p><p id="f9f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在build/generated-sources文件夹中，生成的类将显示所有必要的属性。现在您可以安全地将类转移到包中，并在您的测试中使用它们:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="569e" class="ld le iq kz b gy lf lg l lh li">@Test<br/><strong class="kz ir">public void </strong>getCorrectData() {<br/>    Post = when()<br/>            .get(<strong class="kz ir">"https://jsonplaceholder.typicode.com/posts/1"</strong>)<br/>            .then().extract().body().as(Post.<strong class="kz ir">class</strong>);<br/>}</span></pre><p id="c60c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果，您得到了一个完全成熟的Java对象，其中充满了可以执行任何操作的数据。</p><p id="a5cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你学会了“如何获取数据”,你就必须检查存储这些对象的数据。为此，你可以使用一个很棒的库，Hamcrest Matchers，来编写检查断言。</p><p id="fa9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例如，如果您的HTTP服务器在</strong>【https://jsonplaceholder.typicode.com/users/1】返回以下JSON:</p><p id="2059" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">{ <br/> "id": 1、<br/>"姓名": "符晓薇·格拉汉姆"、<br/>"用户名":"布雷特"、<br/>"电子邮件":"<a class="ae kl" href="mailto:Sincere@april.biz" rel="noopener ugc nofollow" target="_blank">真诚@april.biz </a> " <br/> }</p><p id="e4d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在基于JSON的响应上，让我们创建一个简单的Java类:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="4d3c" class="ld le iq kz b gy lf lg l lh li"><strong class="kz ir">public class </strong>User {<br/>    String <strong class="kz ir">id</strong>;<br/>    String <strong class="kz ir">name</strong>;<br/>    String <strong class="kz ir">username</strong>;<br/>    String <strong class="kz ir">email</strong>;<br/>}</span></pre><p id="2d11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用Hamcrest，您可以编写assert check:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="c1b6" class="ld le iq kz b gy lf lg l lh li">@Test<br/><strong class="kz ir">public void </strong>testUserInformation() {<br/>    User user = when()<br/>            .get(<strong class="kz ir">"https://jsonplaceholder.typicode.com/users/1"</strong>)<br/>            .then()<br/>            .extract()<br/>            .response()<br/>            .as(User.<strong class="kz ir">class</strong>);<br/>    assertThat(user.<strong class="kz ir">id</strong>, equalTo(<strong class="kz ir">"1"</strong>));<br/>    assertThat(user.<strong class="kz ir">name</strong>, equalTo(<strong class="kz ir">"Leanne Graham"</strong>));<br/>    assertThat(user.<strong class="kz ir">username</strong>, equalTo(<strong class="kz ir">"Bret"</strong>));<br/>    assertThat(user.<strong class="kz ir">email</strong>, equalTo(<strong class="kz ir">"Sincere@april.biz"</strong>));<br/>}</span></pre><p id="5d39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Hamcrest最大的优势就是可以让你写自定义支票。</p><p id="6a72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Yandex团队在AnnotationProcessor的帮助下为Pojo创建了项目自动生成Java Hamcrest匹配器。你可以在<a class="ae kl" href="https://github.com/yandex-qatools/hamcrest-pojo-matcher-generator" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Github </strong> </a>上找到这个工具</p><p id="ed26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是简单的工作原理:(为了让它工作)在Java类中，你必须在测试方法之前写@GenerateMatcher注释。</p><p id="c970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在使用@GenerateMatcher testUserInfo方法生成检查后，检查结果将如下所示:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="225d" class="ld le iq kz b gy lf lg l lh li">@Test<br/><strong class="kz ir">public void </strong>testUserInfo() {<br/>    User user = when().get(<strong class="kz ir">"https://jsonplaceholder.typicode.com/users/1"</strong>)<br/>            .then()<br/>            .extract()<br/>            .response()<br/>            .as(User.<strong class="kz ir">class</strong>);<br/>    assertThat(user, hasId(<strong class="kz ir">"1"</strong>));<br/>    assertThat(user, hasName(<strong class="kz ir">"Leanne Graham"</strong>));<br/>    assertThat(user, hasUserName(<strong class="kz ir">"Bret"</strong>));<br/>    assertThat(user, hasEmail(<strong class="kz ir">"Sincere@april.biz"</strong>));<br/>}</span></pre><p id="524a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您需要为一个对象编写一两个测试，这种方法对您来说是最佳的。然而，您将再次花费大量时间进行手动编辑。完成所有这些之后，您需要手动指定每个注释。这是一个非常劳动密集型的过程。</p><p id="b108" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免手工操作，你可以从Hamcrest转换到Assertj库。</p><p id="9a38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，Assertj库的语法与Hamcrest使用的语法完全不同。所以，如果你决定使用Assertj，你将需要重写大量的代码。</p><p id="33ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该库还允许您为Java类生成检查。它为Gradle和Maven提供了集成，这非常有用。</p><p id="fee3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此库的连接示例:</p><p id="2b29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Maven:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="82b8" class="ld le iq kz b gy lf lg l lh li">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.assertj&lt;/groupId&gt;<br/>  &lt;artifactId&gt;assertj-core&lt;/artifactId&gt;<br/>  &lt;version&gt;3.11.1&lt;/version&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="36f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">格拉德:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="a42b" class="ld le iq kz b gy lf lg l lh li">testCompile("org.assertj:assertj-core:3.11.1")</span></pre><p id="89b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Assertj，您可以简单地为任何类生成断言检查——只需指定包的路径，无需添加额外的注释。</p><p id="eb33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看Assertj库是如何改变testUserInformaion方法的:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="3c7d" class="ld le iq kz b gy lf lg l lh li">@Test<br/><strong class="kz ir">public void </strong>testUserInformation() {<br/>    User user = when().get(<strong class="kz ir">"https://jsonplaceholder.typicode.com/users/1 "</strong>)<br/>            .then()<br/>            .extract()<br/>            .response()<br/>            .as(User.<strong class="kz ir">class</strong>);<br/>    UserAssert.assertThat(user)<br/>            .hasId(<strong class="kz ir">"1"</strong>)<br/>            .hasName(<strong class="kz ir">"Leanne Graham"</strong>)<br/>            .hasUserName(<strong class="kz ir">"Bret"</strong>)<br/>            .hasEmail(<strong class="kz ir">"Sincere@april.biz"</strong>);<br/>}</span></pre><p id="dffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong></p><ol class=""><li id="3b9f" class="ll lm iq jp b jq jr ju jv jy ln kc lo kg lp kk lq lr ls lt bi translated">在代码编写过程中，我们80%的代码是通过库自动生成的。</li><li id="c358" class="ll lm iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">如果域模型已经改变，有人删除了一个字段或者改变了数据类型，您可以很容易地重新生成方法。为此，只需在终端中运行命令。该库将自动更新代码。</li></ol><p id="c0c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><ol class=""><li id="ea32" class="ll lm iq jp b jq jr ju jv jy ln kc lo kg lp kk lq lr ls lt bi translated">这是一种灰箱测试方法。用户必须知道两种方法，黑盒和白盒测试方法。</li><li id="2022" class="ll lm iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">这种方法需要所谓的编码技能。换句话说，你必须能够编写代码。当然，自动代码生成可以让你简化这个过程，但是要编写正确的调用，必须把所有的东西联系起来。</li><li id="40fc" class="ll lm iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">有必要花一些时间阅读将Assertj库集成到项目中的文档。</li></ol><p id="e739" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想向你稍微描述一下我对REST <strong class="jp ir"> </strong>放心库的缺点的观点。我非常积极地使用这个库，我下面写的一切都是基于我的实践经验。正式文档告诉我们，放心的自动化脚本很容易以BDD风格编写:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="60e4" class="ld le iq kz b gy lf lg l lh li"><strong class="kz ir">public class </strong>CheckData {<br/>    @Test<br/>    <strong class="kz ir">public void </strong>getUserData() {<br/>        given.get(<strong class="kz ir">"https://jsonplaceholder.typicode.com/posts"</strong>)<br/>                .then().statusCode(200)<br/>                .and()<br/>                .assertThat()<br/>                .body(<strong class="kz ir">"userId"</strong>, equalTo(1))<br/>                .body(<strong class="kz ir">"Id"</strong>, equalTo(5))<br/>                .body(<strong class="kz ir">"title"</strong>, equalTo(<strong class="kz ir">"nesciunt quas odio"</strong>));<br/>    }<br/>}</span></pre><p id="65d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个问题是，随着自动测试数量的增加，问题开始出现。在您的自动化项目中，您需要考虑的主要事情是正确的架构和项目的分层。</p><p id="26c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您没有正确地构建架构，并按照官方教程提供的方式编写自动化脚本，您无疑会遇到代码复制和日志记录的问题。</p><p id="a4c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个问题是工作慢。因为它是一个由Java/Groovy代码组成的包装器，所以比它的竞争对手慢得多。对于自动化脚本，这可能不是很关键，但这里有一个JSON方案的检查，它内置在放心，我建议不要这样做:它将工作非常慢。</p><p id="2fa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您决定在项目中使用放心，请仔细考虑您希望如何查看您的测试、报告，以及您希望花费多少时间来支持这些测试。</p><p id="08c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三个问题是缺乏明智的例子和令人放心的良好做法。</p><p id="44d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在下一部分详细解释改造。</p></div></div>    
</body>
</html>