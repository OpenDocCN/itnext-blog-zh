<html>
<head>
<title>Using Redux Reducers in React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在反应组分中使用Redux还原剂</h1>
<blockquote>原文：<a href="https://itnext.io/using-redux-reducers-in-react-components-4e92985dd9cb?source=collection_archive---------1-----------------------#2018-10-08">https://itnext.io/using-redux-reducers-in-react-components-4e92985dd9cb?source=collection_archive---------1-----------------------#2018-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ea3ba7b3f63f9ac1b7c108b0ec72d375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lroIWyUFwi1gigce"/></div></div></figure><div class=""/><div class=""><h2 id="3f21" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">脑子，炸了。</h2></div><p id="e867" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">丹·阿布拉莫夫最近发了一条让我震惊的微博！</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="lq lr l"/></div></figure><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="e34e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你可以在你的组件中使用减速器？不围！</p><p id="dff9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这让我想起了去年一位同事的挑战。他问我是否可以让无状态的功能组件有状态。长话短说，不是真的，但我最终创建了一个非常简单的Redux库，您可以在每个组件的基础上使用。</p><p id="4356" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">无状态的功能组件不可能是有状态的，因为如果不传递新的属性，就无法更新功能性的无状态组件。这意味着，在某些时候，您必须在链的某个位置拥有一个有状态的react组件。即使使用React的上下文API，您也需要一个有状态的组件来修改它自己的状态，以便将新数据传递给<code class="fe ls lt lu lv b">Provider</code>的值属性。</p><p id="7966" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我完全忘记了那段代码，并且很难找到它。它被隐藏在一长串名为<em class="lw">Redux-like State Components</em>的“撰写关于这些主题的文章”中。本文将涵盖我所写的概念，以及它如何允许您在React组件中使用Redux reducers。</p><p id="7dc9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您对<strong class="ks jc">组件状态</strong>和<strong class="ks jc">状态组件</strong>和<strong class="ks jc">表示组件</strong>(想想上下文API)的分离感兴趣，这个解决方案可能值得一试。该架构与我今年早些时候编写的<a class="ae lx" href="https://medium.com/@Sawtaytoes/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e" rel="noopener"> ReduxConnection组件</a>非常相似。</p><h1 id="9406" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">类冗余状态分量</h1><p id="d96b" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated"><em class="lw">免责声明:我去年用了大约1-2个小时编写了这个解决方案，从未在生产中使用过。虽然它的功能和工作方式与您预期的一样，但它是一个非常简单的最小依赖性解决方案。</em></p><h2 id="2621" class="mv lz jb bd ma mw mx dn me my mz dp mi kz na nb mk ld nc nd mm lh ne nf mo ng bi translated">使用状态组件</h2><p id="5618" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">这个看起来怎么样？让我们从最简单的组件开始，加载状态缩减器:</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="nh lr l"/></div></figure><p id="7b07" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个<code class="fe ls lt lu lv b">App</code>组件在第一次渲染时会显示“正在加载…”。2秒钟后，它会切换到显示“已加载”。</p><p id="dc4c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当你查看<code class="fe ls lt lu lv b">LoadingState</code>时，你真的无法知道这是一个ReduxConnection组件、上下文API消费者、状态组件还是有状态容器组件。它遵循与其他所有东西相同的渲染道具模式，并且使得弄清楚发生了什么变得更加容易。</p><p id="ddd6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe ls lt lu lv b">setLoading</code>和<code class="fe ls lt lu lv b">setLoaded</code>功能是预调度的。通常您导入您的动作，然后接收一个<code class="fe ls lt lu lv b">dispatch</code>函数，但是因为所有的功能都包含在这个状态组件中，所以您可以直接调用那些命名的函数，而不管底层的API。</p><h2 id="b86a" class="mv lz jb bd ma mw mx dn me my mz dp mi kz na nb mk ld nc nd mm lh ne nf mo ng bi translated">“加载状态”组件</h2><p id="ee06" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">由于我们无法说出<code class="fe ls lt lu lv b">LoadingState</code>到底是什么，我们需要更深入:</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="nh lr l"/></div></figure><p id="0a76" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">哇，看起来像Redux对不对？一个主要的区别是没有中间件(至少在这个版本中没有)，但是无论如何看起来都很相似。您创建一些渲染道具，并将它们传递给一个<code class="fe ls lt lu lv b">createStateSubscriber</code>函数。我导出了reducers和actions，因为您可以分别对它们进行单元测试。</p><p id="335c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">与Redux相比，这在引擎盖下做了很多固执己见的事情。你不直接创建一个reducer，你创建一个<code class="fe ls lt lu lv b">namespacedReducers</code>的对象，类似于<code class="fe ls lt lu lv b">createReducers</code>，<code class="fe ls lt lu lv b">createRenderProps</code>把你所有的动作包装在一个调度函数里，为你管理状态。</p><p id="7e89" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我甚至认为一个组件可以同时处理多个reducers。我可以预见到一种情况，您可能希望使用不同Redux的组合来实现类似Redux的功能。</p><h2 id="660f" class="mv lz jb bd ma mw mx dn me my mz dp mi kz na nb mk ld nc nd mm lh ne nf mo ng bi translated">“FormValidationState”组件</h2><p id="5e33" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">在另一个例子中，我们有这个超级简单的<code class="fe ls lt lu lv b">FormValidationState</code>组件。它通过检查表单域是否不是空字符串来告诉您是否所有表单域都是有效的。</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="nh lr l"/></div></figure><p id="3edf" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通常，我会使用像<a class="ae lx" href="https://redux-form.com" rel="noopener ugc nofollow" target="_blank"> Redux-Form </a>这样的表单库，但是为了展示一些更复杂的功能，我们将使用我们自己的状态组件。</p><p id="efec" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在<code class="fe ls lt lu lv b">FormValidationState</code>中，我们有一个单一的动作:<code class="fe ls lt lu lv b">VALIDATE_FIELDS</code>和一个单一的状态值:<code class="fe ls lt lu lv b">isValid</code>。</p><p id="2e5d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">光是看，就能看到API。使用<code class="fe ls lt lu lv b">isValid</code>属性检查表单是否有效，并通过传入一个数组<code class="fe ls lt lu lv b">fieldNames</code>和<code class="fe ls lt lu lv b">formElement</code>本身来调用验证函数。</p><p id="8c95" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是你食用时的样子:</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="nh lr l"/></div></figure><p id="b040" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当您提交表单时，它会进行验证检查，并触发显示或隐藏错误消息。非常简单，可能你永远也不会自己写。</p><h2 id="d1cd" class="mv lz jb bd ma mw mx dn me my mz dp mi kz na nb mk ld nc nd mm lh ne nf mo ng bi translated">真正的魔法</h2><p id="7f1e" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">看完<code class="fe ls lt lu lv b">LoadingState</code>组件后，您可能会对这两个神奇的实用程序感到疑惑:<code class="fe ls lt lu lv b">createRenderProps</code>和<code class="fe ls lt lu lv b">createStateSubscriber</code>。</p><p id="8bde" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe ls lt lu lv b">createRenderProps</code>本质上是Redux，但是它对你隐藏了大部分API。如果我愿意，我可以把它换成Redux或RxJS，而你甚至不会知道。</p><p id="0cf1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">是我对挑战的一个让步。我不得不使用有状态React组件。这个函数的行为就像一个更高阶的组件，但是不包装另一个组件来提供它的状态，它是组件。</p><p id="8cdb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您调用<code class="fe ls lt lu lv b">createStateSubscriber</code>，它会创建一个您可以命名和导出的组件。这消除了大量的样板文件，因此您的Redux式状态组件甚至不需要了解底层的视图模型。这意味着你可以得到一个React、Vue或WebComponent，而根本不用改变你的状态组件！</p><p id="9b3e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为这两个函数背后的功能并不重要，所以我将让您自己探索它们:</p><div class="ip iq gp gr ir ni"><a href="https://snippets.cacher.io/snippet/f3db575bd1f8134ce511" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jc gy z fp nn fr fs no fu fw ja bi translated">类似Redux的状态组件-缓存器片段</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">使用Redux-like状态组件和表单验证器以及加载状态组件的完整示例。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">snippets.cacher.io</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ix ni"/></div></div></a></div><h1 id="1e52" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">在反应组分中使用Redux还原剂</h1><p id="17f3" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">现在，让我们来看看令人兴奋的丹的推特杰作。您可以使用<code class="fe ls lt lu lv b">createRenderProps</code>和<code class="fe ls lt lu lv b">createStateSubscriber</code>在React组件中使用Redux reducers。</p><p id="0056" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我将参考<a class="ae lx" href="https://medium.com/@Sawtaytoes/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a" rel="noopener"> <em class="lw">中的<code class="fe ls lt lu lv b">payloadReducer</code>使用Redux:createNamespaceReducer</em></a>的秘诀:</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="nh lr l"/></div></figure><p id="ddc3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们要把这个缩减器变成一个状态容器:</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="nh lr l"/></div></figure><p id="c0b7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">简单明了。同样，您不需要担心React、Redux或其他任何东西。只需使用通用的reducers和动作创建一个通用组件，就可以得到一个非常非常简单的Redux式状态组件。</p><h1 id="5131" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">基于React的有状态容器组件</h1><p id="f026" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">丹在他最初的推文中说了些什么？如果我们试图做同样的事情，但比他说的更多，那会是什么样子？这就是<code class="fe ls lt lu lv b">createStateSubscriber</code>的作用。</p><p id="a37d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我的代码看起来与他的有点不同，但这是我们两个实现的要点:</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="nh lr l"/></div></figure><p id="0e86" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">他的版本需要传递一个<code class="fe ls lt lu lv b">dispatch</code>函数，而我的版本将它抽象出来。通常我会发现传递一个类似于<code class="fe ls lt lu lv b">ReduxConnection</code>的<code class="fe ls lt lu lv b">dispatch</code>函数，但是在这种情况下，我希望这些状态组件与底层架构完全分离。他们内部已经有了完整的API，所以你应该只调用他们允许的动作。</p><p id="79c3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通过向组件类添加动作并从这些组件中调用dispatch，您也可以在他的示例中轻松地复制自动分派的函数:</p><pre class="lm ln lo lp gt nx lv ny nz aw oa bi"><span id="e52b" class="mv lz jb lv b gy ob oc l od oe">someAction(payload) {<br/>  this<br/>  .dispatch({<br/>    payload,<br/>    type: 'SOME_ACTION',<br/>  })<br/>}</span></pre><p id="844e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我的解决方案更复杂，因为它做了很多事情，比如抽象出底层架构，甚至没有React或Redux的概念。我最初编写这段代码时没有考虑Redux，最终在处理它时使用了相同的action-reducer-dispatch概念。通量概念简化了我想要完成的事情。</p><p id="c6bd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果我有困难，我会照丹的方法去做。当React已经处理它时，没有理由写我自己的。如果我需要独立于底层架构的东西，我会使用已经写好的东西。关于<code class="fe ls lt lu lv b">createStateSubscriber</code>最好的一点是，在引擎盖下发生什么并不重要。你可以使用任何你想要的:Dan的tweetable模型或者一个更复杂的类似Redux的订阅者模型，或者两者都用。您应该真正构建最符合您需求的解决方案。</p><h1 id="35a5" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">尝试它，使用它，打破它</h1><p id="0cd7" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">用这个CodeSandbox自己尝试类似Redux的状态组件:</p><figure class="lm ln lo lp gt is"><div class="bz fp l di"><div class="of lr l"/></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">CodeSandbox中类似Redux的有状态容器组件</figcaption></figure><p id="8b99" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lw">免责声明:我试图关闭appeller的自动格式化，但当我将代码粘贴到CodeSandbox时，它仍然格式化它。</em></p><h1 id="0bde" class="ly lz jb bd ma mb mc md me mf mg mh mi kh mj ki mk kk ml kl mm kn mn ko mo mp bi translated">更多阅读</h1><p id="94c3" class="pw-post-body-paragraph kq kr jb ks b kt mq kc kv kw mr kf ky kz ms lb lc ld mt lf lg lh mu lj lk ll ij bi translated">如果你喜欢你所读的，你也应该检查我的其他文章；尤其是关于Redux的任何事情:</p><ul class=""><li id="d972" class="ok ol jb ks b kt ku kw kx kz om ld on lh oo ll op oq or os bi translated"><a class="ae lx" href="https://medium.com/@Sawtaytoes/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a" rel="noopener">使用Redux的秘密:createNamespaceReducer </a></li><li id="7284" class="ok ol jb ks b kt ot kw ou kz ov ld ow lh ox ll op oq or os bi translated"><a class="ae lx" href="https://medium.com/@Sawtaytoes/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e" rel="noopener">为什么不需要React-Redux的“连接”</a></li><li id="c881" class="ok ol jb ks b kt ot kw ou kz ov ld ow lh ox ll op oq or os bi translated"><a class="ae lx" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="c569" class="ok ol jb ks b kt ot kw ou kz ov ld ow lh ox ll op oq or os bi translated">函数式编程的表情爱好者指南:第1部分</li><li id="efc2" class="ok ol jb ks b kt ot kw ou kz ov ld ow lh ox ll op oq or os bi translated"><a class="ae lx" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li></ul></div></div>    
</body>
</html>