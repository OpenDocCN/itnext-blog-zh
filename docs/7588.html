<html>
<head>
<title>Hardening Monitoring: a step-by-step guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强化监控:逐步指南</h1>
<blockquote>原文：<a href="https://itnext.io/hardening-monitoring-a-step-by-step-guide-7a18007c915?source=collection_archive---------3-----------------------#2022-11-16">https://itnext.io/hardening-monitoring-a-step-by-step-guide-7a18007c915?source=collection_archive---------3-----------------------#2022-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0444" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内部的Kubernetes服务如果不向外界公开的话，已经在一个私有网络上了。但是有必要强化内部服务吗？甚至在Kubernetes成为主流之前，只有当数据进出数据中心时，数据中心的敏感数据才会应用于外围安全层。然而，当内部网络受到威胁时，事情就会出错。在Kubernetes，想象一个脆弱的豆荚成为一个目标，并最终妥协。这可能会对群集中所有未加密的流量造成威胁。证书主要用于加密，可以缓解这一问题。但是，如果没有正确的身份验证，这些pod可能会被用来从网络中的其他pod获取敏感信息。为此，证书还为内部网络中的身份识别和身份验证提供了基础设施。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/042172a38b142564e58949d88ac3b921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UU6MYoqgF9rC5RCqBk-67Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">普罗米修斯标志:<a class="ae lb" href="https://cncf-branding.netlify.app/projects/prometheus/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="db1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将介绍如何安全地为<em class="lc"> metrics-server </em>、<em class="lc"> prometheus-server </em>和<em class="lc"> prometheus-adapter </em>提供服务。</p><h1 id="1410" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">无聊的部分</h1><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">资料来源:giphy.com</figcaption></figure><p id="38a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要为每个组件生成三个证书。</p><p id="3155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes为提供TLS证书提供了API，这些证书由内置的Kubernetes签名者或自定义证书颁发机构签名。</p><p id="3ef0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了请求证书，我们使用类似于官方指南的Cloudflare命令行工具<code class="fe md me mf mg b">cfssl</code> <a class="ae lb" href="https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/#requesting-a-certificate" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e1a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装是通过获得它</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="4ff8" class="ml le iq mg b be mm mn l mo mp">$ go get github.com/cloudflare/cfssl/cmd/cfssl</span></pre><p id="6c63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者通过自制</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="805c" class="ml le iq mg b be mm mn l mo mp">$ brew install cfssl</span></pre><h1 id="921a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">正在生成私钥</h1><p id="d5d3" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">下一步是通过在JSON文件中定义<code class="fe md me mf mg b">certificate signing request</code>为我们的每个服务生成一个私钥:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="2781" class="ml le iq mg b be mm mn l mo mp">{<br/>  "hosts": [<br/>    "&lt;service name&gt;.&lt;namespace&gt;",<br/>    "&lt;service name&gt;.&lt;namespace&gt;.svc.cluster.local",<br/>    "&lt;service name&gt;.&lt;namespace&gt;.pod.cluster.local",<br/>    "&lt;service IP&gt;",<br/>    "&lt;Pod IP&gt;"<br/>  ],<br/>  "CN": "&lt;service name&gt;.&lt;namespace&gt;.pod.cluster.local",<br/>  "key": {<br/>    "algo": "ecdsa",<br/>    "size": 256<br/>  },<br/>}</span></pre><p id="e21c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，对于<code class="fe md me mf mg b">kube-system</code>名称空间内的<code class="fe md me mf mg b">metrics-server</code>，文件看起来像这样:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="346f" class="ml le iq mg b be mm mn l mo mp">// csr-metrics-server.json<br/>{<br/>  "hosts": [<br/>    "metrics-server.kube-system",<br/>    "metrics-server.kube-system.svc.cluster.local",<br/>    "metrics-server.kube-system.pod.cluster.local",<br/>    "&lt;service IP&gt;",<br/>    "&lt;Pod IP&gt;"<br/>  ],<br/>  "CN": "&lt;service name&gt;.&lt;namespace&gt;.pod.cluster.local",<br/>  "key": {<br/>    "algo": "ecdsa",<br/>    "size": 256<br/>  },<br/>}</span></pre><p id="e72a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后使用以下命令应用该文件:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="9ff2" class="ml le iq mg b be mm mn l mo mp">$ cfssl genkey &lt;csr filename&gt;.json | cfssljson -bare server</span></pre><h1 id="bbb3" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">创建签名请求</h1><p id="caae" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">现在，它已经生成了<code class="fe md me mf mg b">server.csr</code>、<code class="fe md me mf mg b">server-key.pem</code>。前者包含认证请求，后者包含编码的私钥。</p><p id="0c5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们利用Kubernetes API来创建一个<code class="fe md me mf mg b">CertificateSigningRequest</code>对象。</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="0852" class="ml le iq mg b be mm mn l mo mp"># csr.yaml<br/>apiVersion: certificates.k8s.io/v1<br/>kind: CertificateSigningRequest<br/>metadata:<br/>  name: &lt;Your CSR Name&gt;<br/>spec:<br/>  request: &lt;base64-encoded server.csr&gt;<br/>  signerName: &lt;Your signer name&gt;<br/>  usages:<br/>  - digital signature<br/>  - key encipherment<br/>  - server auth</span></pre><p id="ad3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，对于<code class="fe md me mf mg b">signer</code>，您可以选择使用自定义签名器或者<a class="ae lb" href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers" rel="noopener ugc nofollow" target="_blank"> Kubernetes签名器</a>。</p><p id="cd9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后使用以下命令创建并批准请求:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="d5f8" class="ml le iq mg b be mm mn l mo mp">$ kubectl apply -f csr.yaml<br/>$ kubectl approve certificate approve &lt;Your CSR Name&gt;</span></pre><p id="3347" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您已经将<code class="fe md me mf mg b">Condition</code>字段设为<code class="fe md me mf mg b">Approved</code>，那么您已经准备好签署证书了:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="6d74" class="ml le iq mg b be mm mn l mo mp">$ kubectl get csr<br/>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION<br/>metrics-server-csr    10m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved</span></pre><h1 id="d296" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">通过CA签署请求</h1><p id="cb2e" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">如果您在上一步中使用了Kubernetes signer，您可以跳过这一步，下载对象状态的签名证书，如下所示:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="df28" class="ml le iq mg b be mm mn l mo mp">$ kubectl get csr &lt;csr request name&gt; -o json | \\<br/>  jq '.status.certificate = "'$(base64 ca-signed-server.pem | tr -d '\\n')'"' | \\<br/>  kubectl replace --raw /apis/certificates.k8s.io/v1/certificatesigningrequests/&lt;csr request name&gt;/status -f -<br/>$ kubectl get csr &lt;csr request name&gt; -o jsonpath='{.status.certificate}' \\<br/>    | base64 --decode &gt; server.crt</span></pre><p id="5f21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后直接创建证书机密:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="fe17" class="ml le iq mg b be mm mn l mo mp">$ kubectl create secret tls &lt;secret name&gt; --cert server.crt --key server-key.pem</span></pre><p id="29a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您需要创建自己的CA，首先创建CA JSON配置:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="01f7" class="ml le iq mg b be mm mn l mo mp">// ca.json<br/>{<br/>  "CN": "My Example Signer",<br/>  "key": {<br/>    "algo": "rsa",<br/>    "size": 2048<br/>  }<br/>}</span></pre><pre class="mv mh mg mi bn mj mk bi"><span id="3159" class="ml le iq mg b be mm mn l mo mp">$ cfssl gencert -initca ca.json |  cfssljson -bare ca<br/>$ kubectl create configmap &lt;CA configmap name&gt; --from-file ca.crt=ca.pem</span></pre><p id="c608" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让<code class="fe md me mf mg b">ca-key.pem</code>和<code class="fe md me mf mg b">ca.pem</code>使用签名配置对其进行签名:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="00f1" class="ml le iq mg b be mm mn l mo mp">// server-signing-config.json<br/>{<br/>    "signing": {<br/>        "default": {<br/>            "usages": [<br/>                "digital signature",<br/>                "key encipherment",<br/>                "server auth"<br/>            ],<br/>            "expiry": "876000h",<br/>            "ca_constraint": {<br/>                "is_ca": false<br/>            }<br/>        }<br/>    }<br/>}</span></pre><pre class="mv mh mg mi bn mj mk bi"><span id="36b9" class="ml le iq mg b be mm mn l mo mp">$ kubectl get csr &lt;csr request name&gt; -o jsonpath='{.spec.request}' | \\<br/>  base64 --decode | \\<br/>  cfssl sign -ca ca.pem -ca-key ca-key.pem -config server-signing-config.json - | \\<br/>  cfssljson -bare ca-signed-server</span></pre><p id="90b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">终于，你完成了！如前所述，下载证书并在此基础上创建一个秘密。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="f607" class="ld le iq bd lf lg nd li lj lk ne lm ln lo nf lq lr ls ng lu lv lw nh ly lz ma bi translated">将证书附加到服务</h1><p id="5f86" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">既然我们已经创建了TLS秘密，我们只需要将它附加到目标资源文件中。我将用普罗米修斯和普罗米修斯适配器的头盔文件来连接它们。</p><h1 id="1dab" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">附加证书</h1><h1 id="cbda" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">普罗米修斯适配器</h1><p id="35cb" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">让我们从普罗米修斯适配器开始</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="9020" class="ml le iq mg b be mm mn l mo mp"># prometheus-adapter-values.yaml<br/>namespaceOverride: &lt;namespace&gt;<br/>logLevel: 10<br/>runAsUser: 12100<br/>podSecurityContext:<br/>  fsGroup: 11000<br/>prometheus:<br/>  url: https://&lt;prometheus service name&gt;.&lt;prometheus namespace&gt;<br/>extraArguments:<br/>  - --tls-cert-file=/var/run/serving-cert/tls.crt<br/>  - --tls-private-key-file=/var/run/serving-cert/tls.key<br/>  - --client-ca-file=/etc/ssl/certs/ca.crt<br/>extraVolumes:<br/>  - name: volume-serving-cert<br/>    secret:<br/>      secretName: &lt;prometheus-adapter certificate secret name&gt;<br/>  - name: ssl-certs<br/>    configMap:<br/>      name: &lt;CA configmap Name&gt;<br/>extraVolumeMounts:<br/>  - mountPath: /var/run/serving-cert<br/>    name: volume-serving-cert<br/>    readOnly: true<br/>  - name: ssl-certs<br/>    mountPath: /etc/ssl/certs<br/>    readOnly: true<br/>resources:<br/>  limits:<br/>    cpu: 100m<br/>    memory: 128Mi<br/>    ephemeral-storage: 1Gi<br/>rules:<br/>  default: false<br/>  custom:<br/>    - seriesQuery: 'container_network_receive_packets_total{namespace!="",pod!=""}'<br/>      resources:<br/>        template: "&lt;&lt;.Resource&gt;&gt;"<br/>      name:<br/>        matches: "^(.*)"<br/>        as: "packets-per-minutes"<br/>      metricsQuery: sum(rate(&lt;&lt;.Series&gt;&gt;{&lt;&lt;.LabelMatchers&gt;&gt;}[1m])) by (&lt;&lt;.GroupBy&gt;&gt;)</span></pre><h1 id="acd9" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">普罗米修斯</h1><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="91b1" class="ml le iq mg b be mm mn l mo mp"># prometheus-values.yaml<br/>server:<br/>  extraSecretMounts:<br/>  - mountPath: /var/run/serving-cert<br/>    name: volume-serving-cert<br/>    secretName: &lt;prometheus certificate secret name&gt;<br/>		readOnly: true<br/>	extraConfigmapMounts:<br/>  - name: ssl-certs<br/>    mountPath: /etc/ssl/certs<br/>    configMap: &lt;CA configmap Name&gt;<br/>		readOnly: true<br/>extraScrapeConfigs: |<br/>  - job_name: myjob<br/>    scrape_interval: 15s<br/>    metrics_path: /metrics<br/>    scheme: https<br/>    static_configs:<br/>      - targets:<br/>          - ###.##.###.###:#####<br/>    tls_config:<br/>      ca_file: /etc/ssl/certs/ca.pem<br/>      key_file: /var/run/serving-cert/key.pem<br/>      cert_file: /var/run/serving-cert/cert.pem<br/>      insecure_skip_verify: true</span></pre><h1 id="6adc" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">度量-服务器</h1><p id="2321" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">度量服务器可能默认来自您的Kubernetes发行版。编辑资源清单，并将以下参数添加到容器中:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="7d66" class="ml le iq mg b be mm mn l mo mp">spec:                                                                                                                                                                                     <br/>    containers:                                                                                                                                                                             <br/>    - args:                                                                                                                                                                                 <br/>      - --client-ca-file=/etc/ssl/certs/ca.pem<br/>      - --tls-cert-file=/var/run/serving-cert/cert.pem<br/>      - --tls-private-key-file=/var/run/serving-cert/key.pem</span></pre><p id="d756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了参数之外，将卷附加到资源，这样它就可以访问<code class="fe md me mf mg b">secret</code>和<code class="fe md me mf mg b">configmap</code>:</p><pre class="km kn ko kp gt mh mg mi bn mj mk bi"><span id="b25c" class="ml le iq mg b be mm mn l mo mp">volumeMounts:<br/>  - mountPath: /var/run/serving-cert<br/>    name: volume-serving-cert<br/>    readOnly: true<br/>  - mountPath: /etc/ssl/certs<br/>    name: ssl-certs<br/>    readOnly: true<br/>volumes:<br/>  - name: volume-serving-cert<br/>    secret:<br/>      secretName: &lt;metrics-server TLS secret name&gt;<br/>  - configMap:<br/>      name: &lt;CA configmap name&gt;<br/>    name: ssl-certs</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni mc l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">资料来源:giphy.com</figcaption></figure><p id="eba7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">精彩！现在您已经安全地成功部署了您的监控服务，您可以看一下本指南<a class="ae lb" href="https://github.com/kubernetes-sigs/prometheus-adapter/blob/master/docs/config-walkthrough.md" rel="noopener ugc nofollow" target="_blank">中关于为Prometheus-Adapter配置一些自定义指标的内容。然后，您可以使用</a><a class="ae lb" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#autoscaling-on-multiple-metrics-and-custom-metrics" rel="noopener ugc nofollow" target="_blank"> HPA </a>使用指标来扩展您的工作负载。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="845d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会多写CS的文章；因此，如果你觉得有趣和有帮助，请跟随我的媒介。另外，请随时通过<a class="ae lb" href="https://www.linkedin.com/in/ali--moezzi/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>直接联系我。</p></div></div>    
</body>
</html>