<html>
<head>
<title>The Case for C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++的案例</h1>
<blockquote>原文：<a href="https://itnext.io/the-case-for-c-4122a5b47130?source=collection_archive---------1-----------------------#2019-10-26">https://itnext.io/the-case-for-c-4122a5b47130?source=collection_archive---------1-----------------------#2019-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d862" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么你应该现在就开始学习</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d7652401adbaf9d7c7103dbcbfd6bf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IfmER4BcX9Jq2KeZkwbDoA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">(来源:<a class="ae kv" href="https://pixabay.com/photos/architecture-skyscraper-urban-city-768432/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>)</figcaption></figure><p id="879d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">C++是你在2019年应该认真考虑学习的一门语言(或者当你碰巧看到这篇文章的时候)。快速的语言现代化、更好的工具、不断增长的包容性社区和繁荣的就业市场只是C++应该成为你下一门学习语言的部分原因。</p><p id="b558" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">哇，这家伙喝了太多的™️️苦艾酒，我出局了。</em></p><p id="b064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，我明白了。至少在我多年来参与的社区中，C++的名声一直不好。</p><blockquote class="lt lu lv"><p id="dcaa" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">代码是可怕的。</p><p id="4b8e" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">一堆难以维护的范例。</p><p id="eeb4" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">非托管代码？不，谢谢，我喜欢我的脚——没有洞的。</p></blockquote><p id="dcd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">但是请听我说完</strong>——如果我们谈论的是C++11之前的版本，那么这些评论有一定的道理。<strong class="ky ir">现代C++(版本≥ 11) </strong>是完全不同的野兽，应该单独考虑。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="e932" class="me mf iq ma b gy mg mh l mi mj">auto genYNames = people | filter(younger_than(39))<br/>                        | filter(older_than(19))<br/>                        | transform(names)<br/>                        | sort()<br/>                        | unique();</span><span id="4d2e" class="me mf iq ma b gy mk mh l mi mj">for_each(genYNames, [](auto name) {<br/>    cout &lt;&lt; name &lt;&lt; "\n";<br/>});</span></pre><p id="d44f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不认为这段代码是现代的C++，那么我鼓励你继续读下去，并且我会列出一些你应该重新考虑你在C++上的位置并且现在就开始学习的理由。</p><h1 id="fb23" class="ml mf iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">TL；DR；</h1><p id="10ff" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated"><em class="ls">——对于那些需要对不读书感觉良好的人来说。</em></p><p id="07e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">C++在语言、社区和工具方面正在重塑自己。创新和语言进化的速度令人震惊。现在是进入高性能和系统级编程并利用所有最新进展的大好时机。学习C++，做一些很酷的事情，甚至可能因此找到一份新工作。</p><p id="6651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="http://shop.oreilly.com/product/0636920033707.do" rel="noopener ugc nofollow" target="_blank">现在</a>，<a class="ae kv" href="https://www.manning.com/books/functional-programming-in-c-plus-plus?query=functional%20c++" rel="noopener ugc nofollow" target="_blank">走</a>，<a class="ae kv" href="https://www.udemy.com/course/advanced-c-programming/" rel="noopener ugc nofollow" target="_blank">学</a> <a class="ae kv" href="https://www.udemy.com/course/free-learn-c-tutorial-beginners/" rel="noopener ugc nofollow" target="_blank">东西</a>。</p><h1 id="5642" class="ml mf iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">快速的语言现代化</h1><p id="149c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">大家又爱又恨的C++很可能是C++11之前的。随着版本11的出现，出现了许多迟到的特性，这些特性可能解决了人们指出的关于该语言的许多“问题”。11中登陆的内容包括:</p><ul class=""><li id="b616" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><strong class="ky ir">智能指针</strong>——当你用完它时，自动清理你的内存。内存泄漏的可能性更小。增加了三个变体:<code class="fe nq nr ns ma b">unique_ptr</code>、<code class="fe nq nr ns ma b">shared_ptr</code>和<code class="fe nq nr ns ma b">weak_ptr</code>。最近，我们看到Rust等语言试图将智能指针嵌入到语言中。</li><li id="0013" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns ma b"><strong class="ky ir">nullptr</strong></code><strong class="ky ir"/>——比<code class="fe nq nr ns ma b">NULL</code>更安全的替代方案，它消除了隐式转换</li><li id="0be7" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns ma b"><strong class="ky ir">auto</strong></code> <strong class="ky ir"> </strong> —自动推导变量类型</li><li id="b7a7" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><strong class="ky ir">基于范围的</strong> <code class="fe nq nr ns ma b"><strong class="ky ir">for</strong></code> <strong class="ky ir">循环</strong>——基于集合的迭代的现代方法(想想<code class="fe nq nr ns ma b">for x in xs: do ...</code>风格)</li><li id="5fdd" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns ma b"><strong class="ky ir">override</strong></code> <strong class="ky ir">和</strong> <code class="fe nq nr ns ma b"><strong class="ky ir">final</strong></code> <strong class="ky ir">关键词</strong> —填补那些缺失的OOP空白</li><li id="2a78" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><strong class="ky ir">强类型</strong> <code class="fe nq nr ns ma b"><strong class="ky ir">enums</strong></code> —远离C风格的全局枚举(从<code class="fe nq nr ns ma b">LIB_OPTIONS_A</code>到<code class="fe nq nr ns ma b">LibOptions::A</code>)</li><li id="2ebd" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated">这对于读者来说是不言自明的，但也是C++现代化的另一个例子</li><li id="512f" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns ma b"><strong class="ky ir">static_assert</strong></code> <strong class="ky ir"> </strong> —允许编译时检查，作为增加程序安全性的一种方式</li><li id="6771" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><strong class="ky ir">移动语义</strong> —允许在C++中表示适当的“所有权模型”。我们再次看到Rust等语言试图将这一点融入语言本身。</li><li id="636c" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns ma b"><strong class="ky ir">noexcept</strong></code> <strong class="ky ir"> </strong> —指示函数不会抛出异常的说明符(与Java的<code class="fe nq nr ns ma b">throws</code>说明符相反)</li><li id="6106" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns ma b"><strong class="ky ir">std::thread</strong></code> — C++是一种面向许多不同平台的低级语言，因此为线程提供<em class="ls">标准</em>支持不仅是一项重大成就，也是语言现代化和减少新来者障碍的一大进步。</li><li id="e9eb" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns ma b"><strong class="ky ir">constexpr</strong></code> <strong class="ky ir"> </strong> —允许编译器在编译时完全评估一个函数/表达式。还有一个很好的副作用，就是不允许未定义的行为。</li></ul><p id="58cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你把这些特性加起来，你就可以开始理解为什么C++11应该被当作一种独立的语言。它代表了语言、标准库和<a class="ae kv" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md" rel="noopener ugc nofollow" target="_blank">首选的代码编写风格</a>的一次重大飞跃。</p><p id="e950" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，我同意这是很大的进步。但是C++已经有很长时间了，我们现在不应该有更大的进步吗？</p><p id="faf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很公平，但是，我应该提到C++11是在2011年问世的。从那时起，C++委员会就设定了目标，每3年发布一个新的主要语言版本。对于一种成熟、稳定、拥有国际标准机构的语言来说，这是一件大事。如果你在2019年看到这篇文章，那意味着从那以后又有2个版本发布了——分别是14个和17个。该语言最值得注意的新增内容是:</p><ul class=""><li id="41d6" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><strong class="ky ir">通用Lambdas </strong> —允许使用<code class="fe nq nr ns ma b">auto</code>作为Lambdas参数，以便更灵活地(重新)使用。</li><li id="8095" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><code class="fe nq nr ns ma b"><strong class="ky ir">[[deprecated]]</strong></code> <strong class="ky ir">属性</strong> —供API作者将函数标记为已弃用，这将导致编译器警告(可选地带有用户定义的帮助消息)</li><li id="39e1" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><strong class="ky ir">标准用户定义的文字</strong>——类似于Scala中的<code class="fe nq nr ns ma b">s</code>字符串插值:<code class="fe nq nr ns ma b">"hello"s</code>是一个<code class="fe nq nr ns ma b">std::string</code>，而<code class="fe nq nr ns ma b">60s</code>是一个<code class="fe nq nr ns ma b">chrono::seconds</code>(许多其他文字可用)</li><li id="c143" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><strong class="ky ir"> Constexpr扩展</strong> —使用use <code class="fe nq nr ns ma b">if constexpr (...)</code>对<code class="fe nq nr ns ma b">if</code>块进行编译时评估的能力。这个特性极大地简化和改进了C++中的元编程(<a class="ae kv" href="https://hackernoon.com/a-tour-of-c-17-if-constexpr-3ea62f62ff65" rel="noopener ugc nofollow" target="_blank">阅读更多</a>)。</li><li id="ce51" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated">结构化绑定声明(Structured Binding Declarations)——在其他语言中通常被称为析构赋值或模式匹配赋值，C++现在支持像<code class="fe nq nr ns ma b">auto [a, b] = getTwoReturnValues();</code>这样的语句</li><li id="2f31" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><strong class="ky ir">类模板参数演绎</strong> —现在可以使用模板(<em class="ls">泛型，</em> sort-of)并允许编译器确定类型，比如<code class="fe nq nr ns ma b">std::pair p(32.5, false)</code>。</li><li id="fc40" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><strong class="ky ir">文件系统库</strong>——和C++11中的<code class="fe nq nr ns ma b">std::thread</code>一样，FS lib代表了语言现代化和减少新手障碍的一个重大进步。</li><li id="4e98" class="nh ni iq ky b kz nt lc nu lf nv lj nw ln nx lr nm nn no np bi translated"><strong class="ky ir">标准库优点</strong> —标准库经历了许多改进，包括增加了<code class="fe nq nr ns ma b">std::optional</code>、<code class="fe nq nr ns ma b">std::string_view</code>、<code class="fe nq nr ns ma b">std::any</code>、并行容器算法、<code class="fe nq nr ns ma b">std::variant</code>、<code class="fe nq nr ns ma b">std::byte</code>等。</li></ul><p id="8ee3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，你的确指出了过去几年发生了很多变化。但是我听说如果我今天想写C++，我真的应该去学Rust。它更现代，而且有Mozilla的支持。</p><p id="05ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">诚然，Rust是一种值得关注的伟大语言。但是它还很年轻，收养还不是我个人会考虑投入时间(除了我的爱好/娱乐时间之外)的问题😃).然而，Rust确实给了C++社区一个很好的推动力来改进语言并采用越来越新的特性。LLVM开发者甚至已经开始开发一个<a class="ae kv" href="https://www.youtube.com/watch?v=VynWyOIb6Bk" rel="noopener ugc nofollow" target="_blank">实验性借用检查器</a>(生命周期分析器)，这是Rust相对于C++的主要卖点之一。随着C++20的到来，我相信我们会看到Rust和C++之间更多的特性差距正在缩小。</p><p id="e552" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还要记住，C++是由许多大公司开发的，包括4/5 FAANG公司、微软和许多其他公司。也就是说，只要企业有强烈的兴趣，它的发展就不太可能放缓。</p><h1 id="4ad7" class="ml mf iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">社区</h1><p id="0e67" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">如果您在过去的20年里在C或C++社区呆过，您可能会对我提出这个问题感到惊讶。近年来这里有了一些惊人的改进。特别是会议大大改善了他们的社会行为准则，增加了演讲者和与会者的多样性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/f1671e769923751b2d14a78168a6b47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgCXpC7z6Jo0Ywz88os9Uw.png"/></div></div></figure><p id="2b29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种变化很大程度上是由<a class="ae kv" href="https://www.includecpp.org/" rel="noopener ugc nofollow" target="_blank"> #include &lt; C++ &gt; </a>小组推动的，该小组还管理着一个欢迎和邀请<a class="ae kv" href="https://discord.gg/ZPErMGW" rel="noopener ugc nofollow" target="_blank"> Discord </a>(你应该完全加入)。随着SG-20的引入，我们甚至在委员会层面也见证了文化的改变，SG-20是一个专注于C++的“可学性”或“可教性”的研究小组。这个小组的目标是向初学者推荐教授C++的最佳实践，并为可能增加语言复杂性的语言特性提供输入。</p><p id="8ed9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">C++社区也是一个<a class="ae kv" href="https://cppcast.com/" rel="noopener ugc nofollow" target="_blank">惊人的每周播客</a>和<a class="ae kv" href="https://www.embo.io/" rel="noopener ugc nofollow" target="_blank">一个</a> <a class="ae kv" href="https://meetingcpp.com/" rel="noopener ugc nofollow" target="_blank">可笑的</a> <a class="ae kv" href="https://cppcon.org/" rel="noopener ugc nofollow" target="_blank">数字</a> <a class="ae kv" href="http://cppnow.org/" rel="noopener ugc nofollow" target="_blank">的</a> <a class="ae kv" href="https://conference.accu.org/" rel="noopener ugc nofollow" target="_blank">年度</a> <a class="ae kv" href="https://cpponsea.uk/" rel="noopener ugc nofollow" target="_blank">会议</a>的所在地，其中大多数使<a class="ae kv" href="https://www.youtube.com/channel/UCAczr0j6ZuiVaiGFZ4qxApw" rel="noopener ugc nofollow" target="_blank">他们的</a> <a class="ae kv" href="https://www.youtube.com/user/MeetingCPP" rel="noopener ugc nofollow" target="_blank">演讲</a> <a class="ae kv" href="https://www.youtube.com/user/CppCon" rel="noopener ugc nofollow" target="_blank">自由</a> <a class="ae kv" href="https://www.youtube.com/user/BoostCon" rel="noopener ugc nofollow" target="_blank">在<a class="ae kv" href="https://www.youtube.com/channel/UCg2JbpJ-PGdFUEZEiNr0GWg" rel="noopener ugc nofollow" target="_blank"> YouTube </a>上</a>可用。</p><h1 id="f09b" class="ml mf iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">工具作业</h1><h2 id="2bea" class="me mf iq bd mm nz oa dn mq ob oc dp mu lf od oe mw lj of og my ln oh oi na oj bi translated">依赖性管理</h2><p id="3394" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">一个主要的，也是合理的抱怨是，在C++应用程序中管理你的依赖关系是一件非常令人头疼的事情。令人欣慰的是，近年来两个C++包管理器越来越受欢迎；来自微软的<a class="ae kv" href="https://github.com/microsoft/vcpkg" rel="noopener ugc nofollow" target="_blank"> vcpkg </a>(最初只针对Windows，现在运行在Mac + Linux上)和来自JFrog的<a class="ae kv" href="https://conan.io/" rel="noopener ugc nofollow" target="_blank">柯南</a>(arti factory和BinTray的制造商)。这两个工具都是通过挂钩到CMake来工作的，CMake是构建C++应用程序几乎无处不在的选择。</p><p id="1370" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就我个人而言，我是柯南的粉丝，每个新项目都是从把它插入我的CMake文件开始的。它使得管理我的依赖关系像任何其他流行的依赖关系管理系统(NPM、Bundler、Cargo等)一样简单。</p><h2 id="7601" class="me mf iq bd mm nz oa dn mq ob oc dp mu lf od oe mw lj of og my ln oh oi na oj bi translated">代码分析器</h2><p id="4e40" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">对该语言的一个常见批评是，代码安全和资源管理可能是一个挑战，但重要的是要记住，空指针异常和内存泄漏(仅举几个例子)在“安全”和垃圾收集语言中仍然是可能的。真正的问题是，存在什么类型的工具来帮助您跟踪那些难以诊断的错误？</p><p id="0c9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://clang.llvm.org/docs/" rel="noopener ugc nofollow" target="_blank">Clang</a>(T2】LLVM项目的一部分)提供了许多不同的被称为“杀毒程序”的工具，这些工具可以追踪各种各样的<a class="ae kv" href="https://clang.llvm.org/docs/AddressSanitizer.html" rel="noopener ugc nofollow" target="_blank">内存错误</a> / <a class="ae kv" href="https://clang.llvm.org/docs/LeakSanitizer.html" rel="noopener ugc nofollow" target="_blank">泄漏</a>、<a class="ae kv" href="https://clang.llvm.org/docs/ThreadSanitizer.html" rel="noopener ugc nofollow" target="_blank">检测数据竞争</a>、发现<a class="ae kv" href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html" rel="noopener ugc nofollow" target="_blank">未定义行为</a>、以及<a class="ae kv" href="https://clang.llvm.org/docs/analyzer/checkers.html" rel="noopener ugc nofollow" target="_blank">许多其他种类的错误</a>。一个类似的项目，<a class="ae kv" href="http://valgrind.org/" rel="noopener ugc nofollow" target="_blank"> Valgrind </a>，提供了类似的工具，但是使用了一种不同的方法，这种方法对于捕捉不同类别的错误可能是有用的。这些工具非常非常强大，是我在专业工作过的相当多的语言中使用过的最好的工具。</p><p id="96ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然编写C++可能是一种“脱离训练”的体验，但有许多世界级的工具可以确保您不会崩溃。😉</p><h2 id="e1f0" class="me mf iq bd mm nz oa dn mq ob oc dp mu lf od oe mw lj of og my ln oh oi na oj bi translated">在线工具</h2><p id="29f8" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我不知道还能把这些叫做什么，但是有两个工具是不可或缺的。首先是<a class="ae kv" href="https://godbolt.org/" rel="noopener ugc nofollow" target="_blank">编译器资源管理器</a>——一个查看编译器输出的在线工具。如果您想了解编译器在为您做什么，或者想对似乎没有按照您的预期运行的代码进行故障排除，这是非常有用的。</p><p id="fc87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个是<a class="ae kv" href="http://quick-bench.com/" rel="noopener ugc nofollow" target="_blank">快速工作台</a>——一个在线基准测试工具。写下你的C++并按下<em class="ls">运行</em>，看看它的表现如何。该工具还将向您显示程序集级别的热点。与编译器资源管理器一起，您可以努力找出每一点的性能。</p><h1 id="862f" class="ml mf iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">需要更多吗？</h1><p id="67d1" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">如果我到目前为止所说的还不足以说服你，让我快速提醒你，FAANG和其他主要的技术公司大量使用C++，更不用说几乎整个游戏社区了。C++已经在编程世界中根深蒂固，创新和社区的重生只会巩固这一地位。</p><p id="1c03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着C++20的出现，现在是深入了解和学习更多知识的好时机。驾驭创新的浪潮；扩展你的技能；并加入一个由热情的开发人员组成的不断发展、友好、安全的社区。</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h1 id="528a" class="ml mf iq bd mm mn or mp mq mr os mt mu jw ot jx mw jz ou ka my kc ov kd na nb bi translated">约翰·默里的其他职位</h1><div class="ow ox gp gr oy oz"><a href="https://medium.com/@john.m.murray786/your-softwares-carbon-footprint-98d6dc2ff6d6" rel="noopener follow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd ir gy z fp pe fr fs pf fu fw ip bi translated">你的软件的碳足迹</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">你的技术对环境负责吗？</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">medium.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn kp oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://medium.com/@john.m.murray786/systems-programming-d5917e41353f" rel="noopener follow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd ir gy z fp pe fr fs pf fu fw ip bi translated">系统编程</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">用无术语的探索揭开神秘面纱。</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">medium.com</p></div></div><div class="pi l"><div class="po l pk pl pm pi pn kp oz"/></div></div></a></div></div></div>    
</body>
</html>