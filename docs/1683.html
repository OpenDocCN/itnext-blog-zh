<html>
<head>
<title>Building your first GraphQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您的第一个GraphQL服务器</h1>
<blockquote>原文：<a href="https://itnext.io/building-your-first-graphql-server-d5c4f88f5e82?source=collection_archive---------4-----------------------#2019-01-01">https://itnext.io/building-your-first-graphql-server-d5c4f88f5e82?source=collection_archive---------4-----------------------#2019-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="968b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，您将学习像<code class="fe kl km kn ko b">schema</code>和<code class="fe kl km kn ko b">resolver</code>这样的概念，最后您将学习如何创建一个GraphQL服务器并查询它。这涵盖了必要的基础知识。如果你已经知道了基础知识，看看<a class="ae kp" href="https://medium.com/@noringc/building-a-graphql-server-with-node-js-and-express-f8ea78e831f9" rel="noopener">用nodejs + express开发一个GraphQL服务器</a></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/2558d91fd0e9d11ebe723812547a3aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuNrt3UwQSiuLiD8sw5Hcg.jpeg"/></div></div></figure><p id="26b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义模式有不同的方式。使用适合你的方法</p><ul class=""><li id="a9c2" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir"> Raw方法</strong>，这使用了由<code class="fe kl km kn ko b">graphql</code>库公开的原语</li><li id="70ed" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir"> GraphQL查询语言定义</strong>，这里我们将使用方法<code class="fe kl km kn ko b">buildSchema()</code>，这是更容易使用的方法</li></ul><p id="6848" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原始方法旨在向您展示引擎盖下发生了什么。如果您只想知道如何用查询语言定义构建您的模式，那么请跳到本文的<code class="fe kl km kn ko b">buildSchema</code>部分</p><h1 id="10a3" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">模式内容</h1><p id="3ae1" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">该模式可以说由两部分组成:</p><ul class=""><li id="dacc" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir">模式定义</strong>，通过定义一个模式，我们定义了存在的实体以及可能进行的不同查询和变化</li><li id="4e0a" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">解析器</strong>，解析器是用户进行查询或变异时调用的函数。解析器与第三方API或数据库对话以执行操作，并最终向调用用户返回一个答案</li></ul><h2 id="8147" class="mt lr iq bd ls mu mv dn lw mw mx dp ma jy my mz me kc na nb mi kg nc nd mm ne bi translated">模式定义</h2><p id="e184" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">模式几乎包含以下概念:</p><ul class=""><li id="418e" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir">查询</strong>，这是可查询的数据，可以是无参数的，也可以是带参数的</li><li id="6cc2" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">自定义类型</strong>，如果您对提供的基本类型不满意，您可以构建自己的类型</li><li id="7d23" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">突变</strong>，这些是应该改变数据的“方法”，比如创建、更新或删除</li><li id="c291" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">解析器</strong>，这些是将数据返回给用户的函数</li><li id="e697" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">片段，这是一个可重用的模式，你可以在你的定义中的很多地方使用它</li><li id="7d03" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">别名</strong>，这是一个重命名机制，允许我们重命名一个列</li><li id="69e9" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">指令，可以把它想象成<code class="fe kl km kn ko b">if/else</code>，它允许你决定在你的查询中包含/排除哪些列</li></ul><h2 id="0369" class="mt lr iq bd ls mu mv dn lw mw mx dp ma jy my mz me kc na nb mi kg nc nd mm ne bi translated">下决心者</h2><p id="5c41" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">解析程序是架构实例的一部分，但不是架构定义的一部分。解析器只是在您尝试调用查询或变异时做出响应的函数。解析函数要么直接用数据响应，要么用承诺响应。</p><h1 id="f5b9" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">原始的方法</h1><p id="e5cb" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在我们下面将要描述的<em class="nf">原始方法</em>中，模式定义和解析器是结合在一起的。我们将在一个定义中定义一个可以调用的资源及其对应的解析器。</p><p id="20f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要创建一个模式，您需要创建一个类型为<code class="fe kl km kn ko b">GraphQLSchema</code>的实例。创建这个实例有不同的方法，但是让我们先看看最原始的方法。在这种方法中，我们有以下类型<code class="fe kl km kn ko b">GraphQLSchema</code>:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="d794" class="mt lr iq ko b gy nk nl l nm nn">new GraphQLSchema(options)</span></pre><p id="7db3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">options</code>属于<code class="fe kl km kn ko b">GraphQLSchemaConfig</code>类型，如下图所示:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="9dcb" class="mt lr iq ko b gy nk nl l nm nn">export interface GraphQLSchemaConfig extends GraphQLSchemaValidationOptions {</span><span id="0d15" class="mt lr iq ko b gy no nl l nm nn">  query: Maybe&lt;GraphQLObjectType&gt;;</span><span id="d476" class="mt lr iq ko b gy no nl l nm nn">  mutation?: Maybe&lt;GraphQLObjectType&gt;;</span><span id="c6ac" class="mt lr iq ko b gy no nl l nm nn">  subscription?: Maybe&lt;GraphQLObjectType&gt;;</span><span id="3ef3" class="mt lr iq ko b gy no nl l nm nn">  types?: Maybe&lt;GraphQLNamedType[]&gt;;</span><span id="39cf" class="mt lr iq ko b gy no nl l nm nn">  directives?: Maybe&lt;GraphQLDirective[]&gt;;</span><span id="850b" class="mt lr iq ko b gy no nl l nm nn">  astNode?: Maybe&lt;SchemaDefinitionNode&gt;;</span><span id="1286" class="mt lr iq ko b gy no nl l nm nn">  extensionASTNodes?: Maybe&lt;ReadonlyArray&lt;SchemaExtensionNode&gt;&gt;;</span><span id="f4e3" class="mt lr iq ko b gy no nl l nm nn">}</span></pre><p id="0482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在上面看到的，我们现在唯一需要给它的强制字段是<code class="fe kl km kn ko b">query</code>。这是简单的询问/问题，我们可以看到它们属于<code class="fe kl km kn ko b">GraphQLObjectType</code>类型。所以让我们开始构建这样一个实例:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="d7ce" class="mt lr iq ko b gy nk nl l nm nn">import {</span><span id="22e7" class="mt lr iq ko b gy no nl l nm nn">  graphql,</span><span id="7e96" class="mt lr iq ko b gy no nl l nm nn">  GraphQLSchema,</span><span id="51a8" class="mt lr iq ko b gy no nl l nm nn">  GraphQLObjectType,</span><span id="f7a2" class="mt lr iq ko b gy no nl l nm nn">  GraphQLString,</span><span id="06c4" class="mt lr iq ko b gy no nl l nm nn">} from “graphql”;</span><span id="81bf" class="mt lr iq ko b gy no nl l nm nn">const schema = new GraphQLObjectType({</span><span id="a3e6" class="mt lr iq ko b gy no nl l nm nn">  name: “RootQueryType”,</span><span id="63a0" class="mt lr iq ko b gy no nl l nm nn">  fields: {</span><span id="c7b2" class="mt lr iq ko b gy no nl l nm nn">    hello: {</span><span id="4ec8" class="mt lr iq ko b gy no nl l nm nn">      type: GraphQLString,</span><span id="3cb0" class="mt lr iq ko b gy no nl l nm nn">      resolve() {</span><span id="648a" class="mt lr iq ko b gy no nl l nm nn">        return “world”;</span><span id="a0ac" class="mt lr iq ko b gy no nl l nm nn">      }</span><span id="e875" class="mt lr iq ko b gy no nl l nm nn">    }</span><span id="47a5" class="mt lr iq ko b gy no nl l nm nn">  }</span><span id="5cea" class="mt lr iq ko b gy no nl l nm nn">});</span></pre><p id="515c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们可以看到我们已经创建了查询<code class="fe kl km kn ko b">hello</code>。<code class="fe kl km kn ko b">hello</code>被分配了一个对象，所以我们来分解这个对象:</p><ul class=""><li id="8cd7" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir">类型</strong>，这是数据类型，要么是原始类型，要么是自定义类型</li><li id="2629" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">这是一个解析函数，简单地说，如果有人调用我，我应该用什么来回答</li></ul><p id="7901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以像<code class="fe kl km kn ko b">description</code>一样声明更多的字段，但这两个是最重要的。</p><h2 id="b810" class="mt lr iq bd ls mu mv dn lw mw mx dp ma jy my mz me kc na nb mi kg nc nd mm ne bi translated">查询我们的模式</h2><p id="5325" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">下一步是告诉graphql这个模式，以便我们可以使用它:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="d6d3" class="mt lr iq ko b gy nk nl l nm nn">let query = `{ hello }`;</span><span id="5c92" class="mt lr iq ko b gy no nl l nm nn">graphql(schema, query).then(result =&gt; {</span><span id="1afa" class="mt lr iq ko b gy no nl l nm nn">  res.json(result);</span><span id="eade" class="mt lr iq ko b gy no nl l nm nn">});</span></pre><p id="fda1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面你可以看到我们用两个不同的参数调用了<code class="fe kl km kn ko b">graphql</code>:</p><ul class=""><li id="2a3e" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir">模式</strong>，我们刚刚定义的模式</li><li id="db36" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">查询</strong>，这是一个我们刚刚初始化的变量，它包含了GraphQL查询语言</li></ul><p id="abd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们放大<code class="fe kl km kn ko b">query</code>看看它做了什么:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="6b25" class="mt lr iq ko b gy nk nl l nm nn">{<br/>  hello<br/>}</span></pre><p id="1e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们简单地查询了一个已知的查询<code class="fe kl km kn ko b">hello</code>，它会用<code class="fe kl km kn ko b">world</code>响应，因为查询它会调用<code class="fe kl km kn ko b">resolve()</code>方法。很好，我们刚刚在GraphQL中创建了一个<code class="fe kl km kn ko b">hello world</code>。暂停以获得效果:)</p><h2 id="0fa9" class="mt lr iq bd ls mu mv dn lw mw mx dp ma jy my mz me kc na nb mi kg nc nd mm ne bi translated">引入自定义类型</h2><p id="74e4" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">现在我们可以在GraphQL中使用很多原语，我们刚刚看到了一个<code class="fe kl km kn ko b">String</code>类型。有时候，这真的很有限，我们想要构造自己的类型。接下来让我们开始吧:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="9244" class="mt lr iq ko b gy nk nl l nm nn">let humanType = new GraphQLObjectType({</span><span id="51ef" class="mt lr iq ko b gy no nl l nm nn">  name: "Human",</span><span id="ee9b" class="mt lr iq ko b gy no nl l nm nn">  fields: () =&gt; ({</span><span id="52d9" class="mt lr iq ko b gy no nl l nm nn">    id: { type: GraphQLString },</span><span id="d989" class="mt lr iq ko b gy no nl l nm nn">    description: { type: GraphQLString },</span><span id="57fe" class="mt lr iq ko b gy no nl l nm nn">    name: { type: GraphQLString }</span><span id="bf11" class="mt lr iq ko b gy no nl l nm nn">  })</span><span id="b505" class="mt lr iq ko b gy no nl l nm nn">});</span></pre><p id="2a06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们使用<code class="fe kl km kn ko b">GraphQLObjectType</code>来创建我们的自定义类型。属性<code class="fe kl km kn ko b">fields</code>允许我们列出我们的类型应该具有的所有不同属性，如<code class="fe kl km kn ko b">id</code>、<code class="fe kl km kn ko b">description</code>和<code class="fe kl km kn ko b">name</code>。</p><p id="c21d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们有了一个自定义类型，让我们通过在我们的模式中使用它来使用它，如下所示:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="881a" class="mt lr iq ko b gy nk nl l nm nn">let schema = new GraphQLSchema({</span><span id="ddd5" class="mt lr iq ko b gy no nl l nm nn">  query: new GraphQLObjectType({</span><span id="213d" class="mt lr iq ko b gy no nl l nm nn">    name: “RootQueryType”,</span><span id="acb5" class="mt lr iq ko b gy no nl l nm nn">    fields: {</span><span id="a988" class="mt lr iq ko b gy no nl l nm nn">      hello: {</span><span id="0c1b" class="mt lr iq ko b gy no nl l nm nn">        type: GraphQLString,</span><span id="ffd5" class="mt lr iq ko b gy no nl l nm nn">        resolve() {</span><span id="11c5" class="mt lr iq ko b gy no nl l nm nn">          return “world”;</span><span id="b0b9" class="mt lr iq ko b gy no nl l nm nn">        }</span><span id="1705" class="mt lr iq ko b gy no nl l nm nn">      },</span><span id="b038" class="mt lr iq ko b gy no nl l nm nn">      person: {</span><span id="6215" class="mt lr iq ko b gy no nl l nm nn">        type: humanType,</span><span id="4274" class="mt lr iq ko b gy no nl l nm nn">        resolve() {</span><span id="4ec9" class="mt lr iq ko b gy no nl l nm nn">          return people[0];</span><span id="c9df" class="mt lr iq ko b gy no nl l nm nn">        }</span><span id="689c" class="mt lr iq ko b gy no nl l nm nn">      }</span><span id="0438" class="mt lr iq ko b gy no nl l nm nn">    }</span><span id="081e" class="mt lr iq ko b gy no nl l nm nn">  })</span><span id="8286" class="mt lr iq ko b gy no nl l nm nn">});</span></pre><p id="7a08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们添加了类型为<code class="fe kl km kn ko b">humanType</code>的<code class="fe kl km kn ko b">person</code>，因此使用了我们的自定义类型。因为我们添加了<code class="fe kl km kn ko b">person</code>作为可查询项，所以我们现在可以用这种类型扩展我们的查询，就像这样:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="4b7d" class="mt lr iq ko b gy nk nl l nm nn">let query = `{ hello, person { name, description } }`;</span><span id="7a1d" class="mt lr iq ko b gy no nl l nm nn">graphql(schema, query).then(result =&gt; {</span><span id="54b2" class="mt lr iq ko b gy no nl l nm nn">  res.json(result);</span><span id="1df6" class="mt lr iq ko b gy no nl l nm nn">});</span></pre><p id="9404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在上面看到的，我们现在添加了以下内容:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="6181" class="mt lr iq ko b gy nk nl l nm nn">{</span><span id="23c6" class="mt lr iq ko b gy no nl l nm nn">  person {</span><span id="ce88" class="mt lr iq ko b gy no nl l nm nn">    name, description</span><span id="af2b" class="mt lr iq ko b gy no nl l nm nn">  }</span><span id="9dc0" class="mt lr iq ko b gy no nl l nm nn">}</span></pre><p id="a8b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在查询<code class="fe kl km kn ko b">person</code>，我们知道person的类型是<code class="fe kl km kn ko b">humanType</code>，而<code class="fe kl km kn ko b">humanType</code>有字段<code class="fe kl km kn ko b">id</code>、<code class="fe kl km kn ko b">name</code>和<code class="fe kl km kn ko b">description</code>，我们选择选择其中的一个子集，即<code class="fe kl km kn ko b">name</code>和<code class="fe kl km kn ko b">description</code>。</p><p id="e6a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，完整的代码如下所示:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="67bd" class="mt lr iq ko b gy nk nl l nm nn">const people = [</span><span id="fe4a" class="mt lr iq ko b gy no nl l nm nn">  {</span><span id="9d06" class="mt lr iq ko b gy no nl l nm nn">    id: 1,</span><span id="def5" class="mt lr iq ko b gy no nl l nm nn">    name: “chris”,</span><span id="e901" class="mt lr iq ko b gy no nl l nm nn">    description: “viking”</span><span id="25c2" class="mt lr iq ko b gy no nl l nm nn">  },</span><span id="82b5" class="mt lr iq ko b gy no nl l nm nn">  {</span><span id="b287" class="mt lr iq ko b gy no nl l nm nn">    id: 2,</span><span id="0449" class="mt lr iq ko b gy no nl l nm nn">    name: “maxim”,</span><span id="6301" class="mt lr iq ko b gy no nl l nm nn">    description: “viking”</span><span id="6d0d" class="mt lr iq ko b gy no nl l nm nn">  },</span><span id="8aa2" class="mt lr iq ko b gy no nl l nm nn">  {</span><span id="5221" class="mt lr iq ko b gy no nl l nm nn">    id: 3,</span><span id="adc3" class="mt lr iq ko b gy no nl l nm nn">    name: “sherry”,</span><span id="acbe" class="mt lr iq ko b gy no nl l nm nn">    description: “viking”</span><span id="4614" class="mt lr iq ko b gy no nl l nm nn">  },</span><span id="27d0" class="mt lr iq ko b gy no nl l nm nn">  {</span><span id="6242" class="mt lr iq ko b gy no nl l nm nn">    id: 4,</span><span id="deb5" class="mt lr iq ko b gy no nl l nm nn">    name: “ana”,</span><span id="97ca" class="mt lr iq ko b gy no nl l nm nn">    description: “viking”</span><span id="bd4e" class="mt lr iq ko b gy no nl l nm nn">  }</span><span id="f8d3" class="mt lr iq ko b gy no nl l nm nn">];</span><span id="7fc6" class="mt lr iq ko b gy no nl l nm nn">let humanType = new GraphQLObjectType({</span><span id="a6fd" class="mt lr iq ko b gy no nl l nm nn">  name: "Human",</span><span id="fc30" class="mt lr iq ko b gy no nl l nm nn">  fields: () =&gt; ({</span><span id="e483" class="mt lr iq ko b gy no nl l nm nn">    id: { type: GraphQLString },</span><span id="1007" class="mt lr iq ko b gy no nl l nm nn">    description: { type: GraphQLString },</span><span id="9c44" class="mt lr iq ko b gy no nl l nm nn">    name: { type: GraphQLString }</span><span id="c6db" class="mt lr iq ko b gy no nl l nm nn">  })</span><span id="8ac8" class="mt lr iq ko b gy no nl l nm nn">});</span><span id="2dd0" class="mt lr iq ko b gy no nl l nm nn">let schema = new GraphQLSchema({</span><span id="d6ba" class="mt lr iq ko b gy no nl l nm nn">  query: new GraphQLObjectType({</span><span id="c78f" class="mt lr iq ko b gy no nl l nm nn">    name: "RootQueryType",</span><span id="5c16" class="mt lr iq ko b gy no nl l nm nn">    fields: {</span><span id="a866" class="mt lr iq ko b gy no nl l nm nn">      hello: {</span><span id="eb91" class="mt lr iq ko b gy no nl l nm nn">        type: GraphQLString,</span><span id="65ed" class="mt lr iq ko b gy no nl l nm nn">        resolve() {</span><span id="f116" class="mt lr iq ko b gy no nl l nm nn">          return "world";</span><span id="2151" class="mt lr iq ko b gy no nl l nm nn">        }</span><span id="94f8" class="mt lr iq ko b gy no nl l nm nn">      },</span><span id="d53e" class="mt lr iq ko b gy no nl l nm nn">      person: {</span><span id="4b80" class="mt lr iq ko b gy no nl l nm nn">        type: humanType,</span><span id="104f" class="mt lr iq ko b gy no nl l nm nn">        resolve() {</span><span id="3bc1" class="mt lr iq ko b gy no nl l nm nn">          return people[0];</span><span id="98a7" class="mt lr iq ko b gy no nl l nm nn">        }</span><span id="a643" class="mt lr iq ko b gy no nl l nm nn">      }</span><span id="27a3" class="mt lr iq ko b gy no nl l nm nn">    }</span><span id="ff30" class="mt lr iq ko b gy no nl l nm nn">})</span><span id="1922" class="mt lr iq ko b gy no nl l nm nn">});</span><span id="4d79" class="mt lr iq ko b gy no nl l nm nn">let query = `{ hello, person { name, description } }`;</span><span id="c69b" class="mt lr iq ko b gy no nl l nm nn">graphql(schema, query).then(result =&gt; {</span><span id="9319" class="mt lr iq ko b gy no nl l nm nn">  res.json(result);</span><span id="11c7" class="mt lr iq ko b gy no nl l nm nn">});</span></pre><h2 id="2c73" class="mt lr iq bd ls mu mv dn lw mw mx dp ma jy my mz me kc na nb mi kg nc nd mm ne bi translated">引入列表类型</h2><p id="3a3e" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">到目前为止，我们已经描述了如何使用像<code class="fe kl km kn ko b">String</code>这样的原语，以及如何创建自定义类型<code class="fe kl km kn ko b">humanKind</code>。让我们看看如何使用列表类型。要使用列表类型，我们需要创建类型为<code class="fe kl km kn ko b">GraphQLList</code>的东西。让我们将它添加到现有的模式中，就像这样:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="2aca" class="mt lr iq ko b gy nk nl l nm nn">let schema = new GraphQLSchema({</span><span id="8010" class="mt lr iq ko b gy no nl l nm nn">  query: new GraphQLObjectType({</span><span id="92ab" class="mt lr iq ko b gy no nl l nm nn">    name: "RootQueryType",</span><span id="a969" class="mt lr iq ko b gy no nl l nm nn">    fields: {</span><span id="5fa4" class="mt lr iq ko b gy no nl l nm nn">      hello: {</span><span id="b04f" class="mt lr iq ko b gy no nl l nm nn">        type: GraphQLString,</span><span id="0f45" class="mt lr iq ko b gy no nl l nm nn">        resolve() {</span><span id="020a" class="mt lr iq ko b gy no nl l nm nn">          return "world";</span><span id="d97f" class="mt lr iq ko b gy no nl l nm nn">        }</span><span id="8dea" class="mt lr iq ko b gy no nl l nm nn">      },</span><span id="0f25" class="mt lr iq ko b gy no nl l nm nn">      person: {</span><span id="f97c" class="mt lr iq ko b gy no nl l nm nn">        type: humanType,</span><span id="eb13" class="mt lr iq ko b gy no nl l nm nn">        resolve() {</span><span id="7b4c" class="mt lr iq ko b gy no nl l nm nn">          return people[0];</span><span id="b79c" class="mt lr iq ko b gy no nl l nm nn">        }</span><span id="cdc8" class="mt lr iq ko b gy no nl l nm nn">      },</span><span id="974d" class="mt lr iq ko b gy no nl l nm nn">      people: {</span><span id="c5d6" class="mt lr iq ko b gy no nl l nm nn">        type: new GraphQLList(humanType),</span><span id="85c7" class="mt lr iq ko b gy no nl l nm nn">        resolve() {</span><span id="e4fc" class="mt lr iq ko b gy no nl l nm nn">          return people;</span><span id="519c" class="mt lr iq ko b gy no nl l nm nn">        }</span><span id="c1d7" class="mt lr iq ko b gy no nl l nm nn">      }</span><span id="ddca" class="mt lr iq ko b gy no nl l nm nn">    }</span><span id="9f1e" class="mt lr iq ko b gy no nl l nm nn">})</span><span id="0836" class="mt lr iq ko b gy no nl l nm nn">});</span></pre><p id="ecd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们添加了使用<code class="fe kl km kn ko b">GraphQLList</code>的<code class="fe kl km kn ko b">people</code>，你可以看到我们像调用方法一样调用它，并向它传递我们的自定义类型<code class="fe kl km kn ko b">humanType</code>来说明这是什么类型的列表。这就是事情的全部。</p><h1 id="83e1" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">buildSchema —使用查询语言定义</h1><p id="b2c5" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">到目前为止，我们一直在以最痛苦的方式定义一个模式，使用像<code class="fe kl km kn ko b">GraphQLObjectType</code>、<code class="fe kl km kn ko b">GraphQLList</code>等类型，低级类型迫使我们写很多来产生我们的模式。</p><p id="bd82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这种方法，我们将把模式定义从解析器中分离出来，所以我们需要单独创建它们</p><p id="7624" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，这有些可读性，但有一个更好的方法。更好的方法是使用一个名为<code class="fe kl km kn ko b">buildSchema()</code>的方法，它将产生一个<code class="fe kl km kn ko b">GraphQLSchema</code>的实例，并使我们能够以一种可读性更好的方式定义模式。让我展示给你看:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="37ee" class="mt lr iq ko b gy nk nl l nm nn">import { buildSchema } from ‘graphql’;</span><span id="d791" class="mt lr iq ko b gy no nl l nm nn">var schema = buildSchema(`</span><span id="4311" class="mt lr iq ko b gy no nl l nm nn">  type Query {</span><span id="c965" class="mt lr iq ko b gy no nl l nm nn">    hello: String,</span><span id="c3d4" class="mt lr iq ko b gy no nl l nm nn">  }</span><span id="c326" class="mt lr iq ko b gy no nl l nm nn">`);</span><span id="5126" class="mt lr iq ko b gy no nl l nm nn">var root = {</span><span id="48c2" class="mt lr iq ko b gy no nl l nm nn">  hello: () =&gt; { return 'world' }</span><span id="2c20" class="mt lr iq ko b gy no nl l nm nn">}</span><span id="2e2a" class="mt lr iq ko b gy no nl l nm nn">let query = `{ hello, person { name }, people { name, description } }`;</span><span id="87ff" class="mt lr iq ko b gy no nl l nm nn">graphql({</span><span id="5f48" class="mt lr iq ko b gy no nl l nm nn">  schema,</span><span id="96d4" class="mt lr iq ko b gy no nl l nm nn">  source: query,</span><span id="3695" class="mt lr iq ko b gy no nl l nm nn">  rootValue: root</span><span id="eeb4" class="mt lr iq ko b gy no nl l nm nn">}).then(result =&gt; {</span><span id="dc57" class="mt lr iq ko b gy no nl l nm nn">  console.log(result);</span><span id="fb27" class="mt lr iq ko b gy no nl l nm nn">});</span></pre><h2 id="635d" class="mt lr iq bd ls mu mv dn lw mw mx dp ma jy my mz me kc na nb mi kg nc nd mm ne bi translated"><strong class="ak">自定义类型</strong></h2><p id="f92a" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">要创建自定义类型，我们只需使用<code class="fe kl km kn ko b">type</code>关键字，并为我们的类型选择一个名称，就像这样:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="b275" class="mt lr iq ko b gy nk nl l nm nn">var schema = buildSchema(`</span><span id="92f7" class="mt lr iq ko b gy no nl l nm nn">  type Person {</span><span id="9a5f" class="mt lr iq ko b gy no nl l nm nn">    id: Int,</span><span id="4b17" class="mt lr iq ko b gy no nl l nm nn">    name: String</span><span id="2df4" class="mt lr iq ko b gy no nl l nm nn">  },</span><span id="3a9e" class="mt lr iq ko b gy no nl l nm nn">  type Query {</span><span id="2327" class="mt lr iq ko b gy no nl l nm nn">    hello: String,</span><span id="b1e9" class="mt lr iq ko b gy no nl l nm nn">    person: Person</span><span id="e53e" class="mt lr iq ko b gy no nl l nm nn">  }</span><span id="321d" class="mt lr iq ko b gy no nl l nm nn">`);</span></pre><p id="990a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在上面看到我们做了两件事:</p><ul class=""><li id="f078" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir">创建</strong>我们的类型<code class="fe kl km kn ko b">Person</code></li><li id="4ee0" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">用<code class="fe kl km kn ko b">Person</code>型的<code class="fe kl km kn ko b">person</code>延长</strong>型的<code class="fe kl km kn ko b">Query</code></li></ul><p id="4f48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们现在需要为<code class="fe kl km kn ko b">person</code>添加一个解析函数，这样如果有人试图查询它，他们就不会得到错误，所以接下来让我们这样做:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="2198" class="mt lr iq ko b gy nk nl l nm nn">const people = [{</span><span id="c0ea" class="mt lr iq ko b gy no nl l nm nn">  id: 1, name: ‘chris’</span><span id="c001" class="mt lr iq ko b gy no nl l nm nn">},</span><span id="ccc2" class="mt lr iq ko b gy no nl l nm nn">{</span><span id="fdb1" class="mt lr iq ko b gy no nl l nm nn">  id: 2, name: ‘maxim’</span><span id="b7cf" class="mt lr iq ko b gy no nl l nm nn">}]</span><span id="390d" class="mt lr iq ko b gy no nl l nm nn">var root = {</span><span id="7f75" class="mt lr iq ko b gy no nl l nm nn">  hello: () =&gt; { return ‘world’ },</span><span id="a776" class="mt lr iq ko b gy no nl l nm nn">  person: () =&gt; people[0]</span><span id="dd0b" class="mt lr iq ko b gy no nl l nm nn">}</span></pre><p id="4459" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面你可以看到我们创建了<code class="fe kl km kn ko b">people</code>数组，并且我们还扩展了我们的<code class="fe kl km kn ko b">root</code>，我们的解析器具有属性<code class="fe kl km kn ko b">person</code>。这里的最终结果是，现在有人可以查询<code class="fe kl km kn ko b">person</code>，它会工作</p><h2 id="18bf" class="mt lr iq bd ls mu mv dn lw mw mx dp ma jy my mz me kc na nb mi kg nc nd mm ne bi translated"><strong class="ak">列表类型</strong></h2><p id="221e" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">让我们在模式定义中添加另一个列表类型:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="3d99" class="mt lr iq ko b gy nk nl l nm nn">var schema = buildSchema(`</span><span id="c80d" class="mt lr iq ko b gy no nl l nm nn">  type Person {</span><span id="7ed6" class="mt lr iq ko b gy no nl l nm nn">    id: Int,</span><span id="97ff" class="mt lr iq ko b gy no nl l nm nn">    name: String</span><span id="d28e" class="mt lr iq ko b gy no nl l nm nn">  },</span><span id="47a6" class="mt lr iq ko b gy no nl l nm nn">  type Query {</span><span id="245b" class="mt lr iq ko b gy no nl l nm nn">    hello: String,</span><span id="ef6a" class="mt lr iq ko b gy no nl l nm nn">    person: Person,</span><span id="8dcf" class="mt lr iq ko b gy no nl l nm nn">    people: [Person]</span><span id="f990" class="mt lr iq ko b gy no nl l nm nn">  }</span><span id="5943" class="mt lr iq ko b gy no nl l nm nn">`);</span></pre><p id="dc71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们已经添加了可查询的<code class="fe kl km kn ko b">people</code>，我们可以看到它是列表类型的，因为它使用了方括号<code class="fe kl km kn ko b">[Person]</code>。此后，我们需要为<code class="fe kl km kn ko b">person</code>添加一个我们现在已经习惯的解析器函数:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="9666" class="mt lr iq ko b gy nk nl l nm nn">var root = {</span><span id="ccd1" class="mt lr iq ko b gy no nl l nm nn">  hello: () =&gt; { return 'world' },</span><span id="1d13" class="mt lr iq ko b gy no nl l nm nn">  person: (id) =&gt; people.find(p =&gt; p.id === id),</span><span id="cc42" class="mt lr iq ko b gy no nl l nm nn">  people: () =&gt; people</span><span id="a426" class="mt lr iq ko b gy no nl l nm nn">}</span></pre><h2 id="9ad6" class="mt lr iq bd ls mu mv dn lw mw mx dp ma jy my mz me kc na nb mi kg nc nd mm ne bi translated"><strong class="ak">参数化查询</strong></h2><p id="fb5c" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">到目前为止，我们已经看到了没有参数的简单查询，但是很可能我们需要向查询发送一些参数来过滤我们的响应。通过首先正确定义我们的模式，我们很容易做到这一点。我们已经有了一个现有的<code class="fe kl km kn ko b">person</code>属性，所以让我们更新那个属性以获取一个参数，就像这样:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="3f87" class="mt lr iq ko b gy nk nl l nm nn">var schema = buildSchema(`</span><span id="d88c" class="mt lr iq ko b gy no nl l nm nn">  type Person {</span><span id="ab75" class="mt lr iq ko b gy no nl l nm nn">    id: Int,</span><span id="377a" class="mt lr iq ko b gy no nl l nm nn">    name: String</span><span id="ac78" class="mt lr iq ko b gy no nl l nm nn">  },</span><span id="bfa2" class="mt lr iq ko b gy no nl l nm nn">  type Query {</span><span id="5736" class="mt lr iq ko b gy no nl l nm nn">    hello: String,</span><span id="1c2e" class="mt lr iq ko b gy no nl l nm nn">    person( id: Int!): Person,</span><span id="58bf" class="mt lr iq ko b gy no nl l nm nn">    people: [Person]</span><span id="8db8" class="mt lr iq ko b gy no nl l nm nn">  }</span><span id="db44" class="mt lr iq ko b gy no nl l nm nn">`);</span></pre><p id="fe31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">person</code>现在看起来如下:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="04c8" class="mt lr iq ko b gy nk nl l nm nn">person( id: Int!): Person</span></pre><p id="9d16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来像是方法调用的签名。</p><h2 id="2bc0" class="mt lr iq bd ls mu mv dn lw mw mx dp ma jy my mz me kc na nb mi kg nc nd mm ne bi translated"><strong class="ak">突变</strong></h2><p id="2b92" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">突变是我们改变应用程序中数据的方式，因此我们可以对资源执行创建、更新或删除等操作。要定义一个变异，我们只需要创建保留类型<code class="fe kl km kn ko b">Mutation</code>，就像这样:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="8ab5" class="mt lr iq ko b gy nk nl l nm nn">type Mutation {</span><span id="0249" class="mt lr iq ko b gy no nl l nm nn">  // mutation</span><span id="c36b" class="mt lr iq ko b gy no nl l nm nn">  // another mutation</span><span id="8b62" class="mt lr iq ko b gy no nl l nm nn">}</span></pre><p id="a9ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们有了以上这些，我们就可以开始考虑我们想做什么了。考虑到上面关于人员列表的叙述，能够向该列表添加人员是有意义的，因此让我们创建这样一个变体，因此我们将模式更新为:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="49a8" class="mt lr iq ko b gy nk nl l nm nn">input PersonInput {</span><span id="0002" class="mt lr iq ko b gy no nl l nm nn">  name: String!</span><span id="3a4f" class="mt lr iq ko b gy no nl l nm nn">},</span><span id="ded3" class="mt lr iq ko b gy no nl l nm nn">type Mutation {</span><span id="217c" class="mt lr iq ko b gy no nl l nm nn">  addPerson(person: PersonInput!): String</span><span id="24da" class="mt lr iq ko b gy no nl l nm nn">}</span></pre><p id="b0fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的内容告诉我们，我们能够调用一个名为<code class="fe kl km kn ko b">addPerson()</code>的方法/变异，它将一个<code class="fe kl km kn ko b">person</code>作为输入参数，并以一个字符串结束响应。我们在这里添加了一个新的类型<code class="fe kl km kn ko b">input</code>的构造。当处理突变时，如果我们想发送比原语更复杂的东西(字符串、布尔等)，我们需要构造类型<code class="fe kl km kn ko b">input</code>的东西。是的，我们的<code class="fe kl km kn ko b">PersonInput</code>看起来有点简单，在这种情况下一个原语可能就足够了，但是我选择向您展示如何发送一个更复杂的输入，如果您愿意的话。</p><p id="af62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是为此定义一个解析器，这样如果有人调用<code class="fe kl km kn ko b">addPerson()</code>，我们就知道该怎么做:</p><pre class="kr ks kt ku gt ng ko nh ni aw nj bi"><span id="657b" class="mt lr iq ko b gy nk nl l nm nn">const people = [{</span><span id="8ec2" class="mt lr iq ko b gy no nl l nm nn">  id: 1,</span><span id="84b4" class="mt lr iq ko b gy no nl l nm nn">  name: 'chris'</span><span id="a469" class="mt lr iq ko b gy no nl l nm nn">}]</span><span id="6ae6" class="mt lr iq ko b gy no nl l nm nn">const addPerson = (person) =&gt; {</span><span id="9596" class="mt lr iq ko b gy no nl l nm nn">const nextId = people.length === 0 ? 1 : people[people.length -1].id + 1</span><span id="e127" class="mt lr iq ko b gy no nl l nm nn">people = […people, {…person, { id : nextId } }]</span><span id="8783" class="mt lr iq ko b gy no nl l nm nn">}</span><span id="9591" class="mt lr iq ko b gy no nl l nm nn">var root = {</span><span id="f6d7" class="mt lr iq ko b gy no nl l nm nn">  hello: () =&gt; { return 'world' },</span><span id="94e1" class="mt lr iq ko b gy no nl l nm nn">  person: (id) =&gt; people.find(p =&gt; p.id === id),</span><span id="ae9e" class="mt lr iq ko b gy no nl l nm nn">  people: () =&gt; people,</span><span id="68a3" class="mt lr iq ko b gy no nl l nm nn">  addPerson: (args) =&gt; {</span><span id="09ca" class="mt lr iq ko b gy no nl l nm nn">    const { person } = args;</span><span id="c332" class="mt lr iq ko b gy no nl l nm nn">    addPerson(person);</span><span id="973c" class="mt lr iq ko b gy no nl l nm nn">    return 'success'</span><span id="18c0" class="mt lr iq ko b gy no nl l nm nn">  }</span><span id="2ab6" class="mt lr iq ko b gy no nl l nm nn">}</span></pre><p id="b8b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加上这一点，我们已经创建了一个特定的突变<code class="fe kl km kn ko b">addPerson()</code>，我们已经定义了一个解析器。</p><p id="19f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道了创建GraphQL服务器的基础。</p><h1 id="994e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">总结</strong></h1><p id="f7b9" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我们已经知道有两种主要的方法来声明一个模式:</p><ul class=""><li id="a373" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir">生法</strong>，多向式</li><li id="b488" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">使用<code class="fe kl km kn ko b">buildSchema()</code>的GraphQL模式定义</strong>方法</li></ul><p id="f264" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还介绍了如何通过调用<code class="fe kl km kn ko b">resolvers</code>来回答查询，这些函数需要从某个地方获取数据。</p><p id="7eac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们学会了如何创造突变。</p><p id="72d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将介绍如何创建一个模式，编写一些解析器，并启动和运行一个GraphQL服务器</p><p id="1d23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kp" href="https://medium.com/@noringc/building-a-graphql-server-with-node-js-and-express-f8ea78e831f9" rel="noopener"> GraphQL + Node.js Express </a></p></div></div>    
</body>
</html>