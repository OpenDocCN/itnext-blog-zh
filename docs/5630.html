<html>
<head>
<title>Common async / Task mistakes, and how to avoid them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的异步/任务错误，以及如何避免它们</h1>
<blockquote>原文：<a href="https://itnext.io/common-async-task-mistakes-and-how-to-avoid-them-fe61e2c587f?source=collection_archive---------1-----------------------#2021-04-20">https://itnext.io/common-async-task-mistakes-and-how-to-avoid-them-fe61e2c587f?source=collection_archive---------1-----------------------#2021-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/0a13b31d876795c911a7d0f585072634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*NpTH4QGIftRYDKqOHYpOaA.jpeg"/></div></figure><div class=""/><p id="2c99" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">的。Net async / await机制是使异步代码可访问的天赐之物，但是尽管它是一个极好的抽象，许多开发人员仍然会陷入许多微妙的陷阱。</p><p id="ff7a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，对于我的异步主题故事系列中的这篇文章，我真的想引入一些有趣的(也是重要的)陷阱，许多开发人员(包括我)经常会陷入这些陷阱，因为它们往往很难介绍，但又很难发现。</p><h1 id="44fd" class="kv kw ja bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">异步任务方法中的未观察任务异常</h1><p id="11af" class="pw-post-body-paragraph jx jy ja jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">开发人员在使用异步代码时要学的第一件事就是避免使用<em class="ly">异步void </em>方法，因为它们在抛出异常时可能会产生灾难性的影响。对于<em class="ly">异步任务</em>方法，异常被放在任务上(正如我在<a class="ae lz" href="https://stefansch.medium.com/what-the-async-keyword-actually-does-bb10d54ce31c" rel="noopener">https://Stefan sch . medium . com/what-the-async-keyword-actually-does-bb 10d 54 ce 31 c</a>中解释的)。</p><p id="e07f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以，这是安全的使用，对不对？答案是:大部分情况下是这样，但根据使用情况，也可能不是这样。</p><p id="b331" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">想象一下这段代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4ad7" class="mj kw ja mf b gy mk ml l mm mn">async Task Main()<br/>{<br/>    await DoStuff();<br/>}</span><span id="af85" class="mj kw ja mf b gy mo ml l mm mn">async Task DoStuff()<br/>{<br/>    await Task.Delay(100);<br/>    throw new Exception();<br/>}</span></pre><p id="37a1" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当按原样运行代码时，一切正常。该异常被正确抛出，因为我们<em class="ly">等待DoStuff() </em>，这反过来意味着我们正在消耗放置在<em class="ly">任务</em>上的<em class="ly">异常</em>。</p><p id="2063" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，看看这段代码</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="171f" class="mj kw ja mf b gy mk ml l mm mn">async Task Main()<br/>{<br/>    DoStuff();<br/>}</span><span id="fc9e" class="mj kw ja mf b gy mo ml l mm mn">async Task DoStuff()<br/>{<br/>    await Task.Delay(100);<br/>    throw new Exception();<br/>}</span></pre><p id="2d3d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它看起来很温顺，但问题在于缺少了等待的<em class="ly">。一个<em class="ly">任务</em>，就像任何其他引用类型一样，驻留在堆上，并且在某个时候也会被垃圾收集。</em></p><p id="8eee" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当GC收集到一个<em class="ly">任务</em>，并且<em class="ly">任务</em>仍然有一个<em class="ly">异常</em>附加在它上面，因为它从未被等待过而从未被重新抛出，那么CLR将抛出一个<em class="ly">UnobservedTaskException</em>。相信我，你不会想在你的生产日志中看到这些，因为调试它们通常是非常痛苦的。</p><p id="1e46" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">实际上，我们可以通过以下调整来展示这种行为:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8820" class="mj kw ja mf b gy mk ml l mm mn">async Task Main()<br/>{<br/>    TaskScheduler.UnobservedTaskException += (sender, args) =&gt;<br/>    {<br/>        Console.WriteLine("Whoopsie");<br/>    };</span><span id="000a" class="mj kw ja mf b gy mo ml l mm mn">    DoStuff();<br/>    GC.Collect();<br/>}</span><span id="6c36" class="mj kw ja mf b gy mo ml l mm mn">async Task DoStuff()<br/>{<br/>    await Task.Delay(100);<br/>    throw new Exception();<br/>}</span><span id="3fdf" class="mj kw ja mf b gy mo ml l mm mn">// Output:<br/>Whoopsie</span></pre><p id="53c2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们手动触发GC收集，并为事件处理程序附加一个监听器，该事件处理程序在发生<em class="ly">UnobservedTaskException</em>时引发。</p><p id="3ad6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以，确保你正确地等待<em class="ly">你的<em class="ly">任务</em>，或者正确地在内部捕获<em class="ly">异常</em>，这样它们就不会向外泄露！</em></p><h1 id="5e91" class="kv kw ja bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">正确等待并发任务</h1><p id="6e55" class="pw-post-body-paragraph jx jy ja jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">下面是利用并发异步执行的一个很好的例子。想象一下这段代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0297" class="mj kw ja mf b gy mk ml l mm mn">async Task Main()<br/>{<br/>    await DoStuff(1);<br/>    await DoStuff(2);<br/>}</span><span id="95d1" class="mj kw ja mf b gy mo ml l mm mn">async Task DoStuff(int number)<br/>{<br/>    // Imagine a Network call here.<br/>    await Task.Delay(500);<br/>    Console.WriteLine($"{number} done!");<br/>}</span></pre><p id="1b18" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这看起来很好，但是整个<em class="ly"> Main() </em>方法在这里将花费大约1秒钟，因为执行仍然是顺序发生的。我们可以做得更好！</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d81d" class="mj kw ja mf b gy mk ml l mm mn">async Task Main()<br/>{<br/>    var t1 = DoStuff(1);<br/>    var t2 = DoStuff(2);<br/>    await t1;<br/>    await t2;<br/>}</span><span id="04bb" class="mj kw ja mf b gy mo ml l mm mn">async Task DoStuff(int number)<br/>{<br/>    // Imagine a Network call here.<br/>    await Task.Delay(500);<br/>    Console.WriteLine($"{number} done!");<br/>}</span></pre><p id="080e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">太好了！我们在这里成功地利用了并发性。我们同时启动了两个单元的工作，尽管做了同样多的工作，方法只执行了0.5秒！我们<em class="ly">等待t1 </em>，但是等到<em class="ly"> t1 </em>完成，我们<em class="ly">等待t2 </em>，<em class="ly"> t2 </em>也已经完成！</p><p id="8bcf" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是，如果您注意了上一节，就很容易想到这里的问题。如果<em class="ly"> DoStuff() </em>在两次调用中都抛出异常怎么办？我们会正确地<em class="ly">等待T1 </em>，t1会引发它的<em class="ly">异常</em>，它会冒泡，因为我们没有在<em class="ly"> Main() </em>中捕捉到<em class="ly">异常</em>。</p><p id="cf12" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是<em class="ly"> t2 </em>呢？我们从来没有达到等待t2 的地步！这最终会再次被发现为<em class="ly">未观察到的任务异常</em>。</p><p id="7a4d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">相反，应该使用以下内容:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="36bb" class="mj kw ja mf b gy mk ml l mm mn">async Task Main()<br/>{<br/>    var t1 = DoStuff(1);<br/>    var t2 = DoStuff(2);<br/>    await Task.WhenAll(t1, t2);<br/>}</span><span id="4b65" class="mj kw ja mf b gy mo ml l mm mn">async Task DoStuff(int number)<br/>{<br/>    // Imagine a Network call here.<br/>    await Task.Delay(500);<br/>    Console.WriteLine($"{number} done!");<br/>}</span></pre><p id="fc63" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="ly">任务。WhenAll </em>是任务并行库的一个实用函数，本质上是将一组awaitables捆绑成一个单独的。这就是我们正确修正上面的例子所需要的。如果没有修改，这将只抛出第一个<em class="ly">异常</em>，但是其他<em class="ly">异常</em>仍然可以被正确观察到。</p><h1 id="d930" class="kv kw ja bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">异步方法同步运行，直到第一个await</h1><p id="4fd9" class="pw-post-body-paragraph jx jy ja jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">大概我最喜欢的异步方法的缺陷是它们在方法开始时用同步代码表现出来的行为。请参见以下示例:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0c8d" class="mj kw ja mf b gy mk ml l mm mn">async Task Main()<br/>{<br/>    var t1 = DoStuff();<br/>    var t2 = DoStuff();<br/>    await Task.WhenAll(t1, t2);<br/>}</span><span id="b78f" class="mj kw ja mf b gy mo ml l mm mn">async Task DoStuff()<br/>{<br/>    Thread.Sleep(500);<br/>    await Task.Delay(500);<br/>}</span></pre><p id="0103" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">看这段代码，<em class="ly">do stuf()</em>方法整体等待1秒。因为我们没有直接等待它，而是同时开始两个任务<em class="ly">和</em>，所以总处理时间需要1秒，因为两个方法都是独立运行的，对吗？</p><p id="39cc" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">实际上，执行需要1.5秒——这是怎么发生的？</p><p id="7a3a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="ly">异步</em>方法的行为在逻辑上类似于非<em class="ly">异步</em>方法，至少直到第一个<em class="ly">等待</em>，因此第一个上下文切换发生。到目前为止，一切都将同步执行。所以在我们的例子中:</p><ol class=""><li id="56f4" class="mp mq ja jz b ka kb ke kf ki mr km ms kq mt ku mu mv mw mx bi translated">对<em class="ly"> DoStuff() </em>的第一次调用开始，休眠500毫秒。</li><li id="fc44" class="mp mq ja jz b ka my ke mz ki na km nb kq nc ku mu mv mw mx bi translated">睡眠结束后，执行<em class="ly">任务。Delay(500) </em>开始运行，进一步的执行被推迟，我们返回到<em class="ly"> Main() </em>方法。</li><li id="f5c2" class="mp mq ja jz b ka my ke mz ki na km nb kq nc ku mu mv mw mx bi translated">现在，第二个<em class="ly"> DoStuff() </em>启动，再次休眠500ms。</li><li id="c44a" class="mp mq ja jz b ka my ke mz ki na km nb kq nc ku mu mv mw mx bi translated">现在，第二个延迟也被触发，我们到达<em class="ly"> Main() </em>方法中的点，在那里我们等待两个<em class="ly">任务</em>完成。<em class="ly"> t1 </em>此时将已经完成，因为延迟同时发生在第二个<em class="ly">线程上。Sleep() </em>跑了，所以现在我们实质上是在等待第二次延迟剩余的500ms。</li><li id="6c39" class="mp mq ja jz b ka my ke mz ki na km nb kq nc ku mu mv mw mx bi translated">1.5秒后，一切完成。</li></ol><p id="1cf6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">只需稍加修改，我们就可以将执行时间缩短到1秒钟:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2932" class="mj kw ja mf b gy mk ml l mm mn">async Task Main()<br/>{<br/>    var t1 = DoStuff();<br/>    var t2 = DoStuff();<br/>    await Task.WhenAll(t1, t2);<br/>}</span><span id="c247" class="mj kw ja mf b gy mo ml l mm mn">async Task DoStuff()<br/>{<br/>    await Task.Delay(500);<br/>    Thread.Sleep(500);<br/>}</span></pre><p id="40ee" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，<em class="ly"> DoStuff() </em>调用将延迟并立即返回，而延续将发生在随机的<em class="ly">线程池</em>线程上，这次不会阻塞主线程。</p><p id="0e51" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，解决这个问题的更常见的方法是使用<em class="ly">任务。Run() </em>来(在我们的例子中)启动<em class="ly"> DoStuff() </em>方法，作为<em class="ly">任务。Run() </em>确保我们传递给它的委托直接在Threadpool上启动，同时保持主线程空闲。</p><p id="068b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">记住这一点很重要，因为结构以及<em class="ly"> async </em>方法的工作单元各自的CPU或IO性质可能意味着整个执行过程中的宝贵时间。</p><p id="7135" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">暂时就这样吧！如果这篇文章很受欢迎，我将继续讨论另一组常见的陷阱。</p></div></div>    
</body>
</html>