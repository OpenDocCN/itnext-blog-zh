<html>
<head>
<title>Redux ruins your React app performance? You are doing something wrong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux毁了你的React app性能？你在做错事</h1>
<blockquote>原文：<a href="https://itnext.io/redux-ruins-you-react-app-performance-you-are-doing-something-wrong-82e28ec96cf5?source=collection_archive---------0-----------------------#2018-02-23">https://itnext.io/redux-ruins-you-react-app-performance-you-are-doing-something-wrong-82e28ec96cf5?source=collection_archive---------0-----------------------#2018-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/84131a2280fc5ce21162223373637967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQsCksXdSVvWH1I8A4-ntw.png"/></div></div></figure><p id="f0b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我经常听到人们说Redux很慢，并且可能是不必要的重新渲染的根本原因。在本文中，我将尝试解释在使用react-redux绑定时如何避免常见错误。</p><p id="49ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">假设你已经了解了避免和解的基本技巧，否则，你可以在一本</em> <a class="ae la" href="https://reactjs.org/docs/optimizing-performance.html#avoid-reconciliation" rel="noopener ugc nofollow" target="_blank"> <em class="kz">官方反应指南</em> </a> <em class="kz">中读到。</em></p><p id="ff3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有很多<a class="ae la" href="https://github.com/reactjs/redux/blob/master/docs/faq/Performance.md" rel="noopener ugc nofollow" target="_blank">通用技术</a>，比如使用PureComponent、<a class="ae la" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>和内存化，但是当涉及到复杂的应用程序时，即使遵循所有的规则仍然会导致性能问题。</p><h1 id="6932" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">定义根本原因</h1><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lz"><img src="../Images/2e853944010d3ec0019bdd9a408e58fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRIB7qt-EgUt3k16mj6g_g.png"/></div></div></figure><p id="fa64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用react perf工具，很容易看到应用程序的哪一部分被重新渲染。但主要问题是为什么它会被重新渲染。要快速识别，您可以使用以下代码片段:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="040e" class="mj lc it mf b gy mk ml l mm mn">import { PureComponent } from 'react';</span><span id="f606" class="mj lc it mf b gy mo ml l mm mn">PureComponent.componentDidUpdate = prevProps =&gt; {<br/>    const name =<br/>        this.constructor.displayName || this.constructor.name || 'Component';<br/>    console.group(name);<br/>    Object.keys(prevProps).forEach(key =&gt; {<br/>        if (prevProps[key] !== this.props[key]) {<br/>            console.log(<br/>                `property ${key} changed from ${prevProps[key]} to ${<br/>                    this.props[key]<br/>                }`<br/>            );<br/>        }<br/>    });<br/>    console.groupEnd(name);<br/>};</span></pre><p id="ed87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它将漂亮的打印属性，导致您的组件重新呈现。尝试将这个代码片段放到应用程序的根模块中，然后调度redux操作，这在您的系统中是不存在的。我打赌你会发现很多有趣的东西。</p><h1 id="be67" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">常见陷阱</h1><p id="b465" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">我将试着列出破坏等式检查的最常见错误，并强制您的组件总是重新呈现。</p><h2 id="81ec" class="mj lc it bd ld mu mv dn lh mw mx dp ll km my mz lp kq na nb lt ku nc nd lx ne bi translated">无记忆选择器。</h2><p id="d9bc" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">最明显的一个。选择器喜欢</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="16ee" class="mj lc it mf b gy mk ml l mm mn">const getList = (state, filter) =&gt; state.list.filter(filter);</span><span id="115f" class="mj lc it mf b gy mo ml l mm mn">const getConfig = (state) =&gt; {<br/>    return {foo: state.foo}<br/>};</span></pre><p id="f93a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将总是导致重新渲染。尝试使用<a class="ae la" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>或其他记忆技术来修复它。</p><h2 id="fdda" class="mj lc it bd ld mu mv dn lh mw mx dp ll km my mz lp kq na nb lt ku nc nd lx ne bi translated">边缘案例处理</h2><p id="d858" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">如果默认值不存在，返回默认值的选择器也会导致性能下降:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0e0e" class="mj lc it mf b gy mk ml l mm mn">const getList = (state) =&gt; state.list || [];</span></pre><p id="0467" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在每次redux store更改时，它将返回一个新的数组实例，但是您可以通过定义默认常量来轻松修复它:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4251" class="mj lc it mf b gy mk ml l mm mn">const defaultList = [];</span><span id="027d" class="mj lc it mf b gy mo ml l mm mn">const getList = (state) =&gt; state.list || defaultList;</span></pre><h2 id="f64c" class="mj lc it bd ld mu mv dn lh mw mx dp ll km my mz lp kq na nb lt ku nc nd lx ne bi translated">连接组件中的逻辑</h2><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b09f" class="mj lc it mf b gy mk ml l mm mn">import {connect} from 'react-redux';</span><span id="d475" class="mj lc it mf b gy mo ml l mm mn">...</span><span id="47c6" class="mj lc it mf b gy mo ml l mm mn">export default connect((state) =&gt; ({<br/>    filter: {foo: state.filter}<br/>}))(MyComponent);</span></pre><p id="d0f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样的逻辑应该被移到选择器中并被适当地记忆。</p><h2 id="cbe2" class="mj lc it bd ld mu mv dn lh mw mx dp ll km my mz lp kq na nb lt ku nc nd lx ne bi translated">反应道具中的元素</h2><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="308e" class="mj lc it mf b gy mk ml l mm mn">import {connect} from 'react-redux';</span><span id="a235" class="mj lc it mf b gy mo ml l mm mn">...</span><span id="8081" class="mj lc it mf b gy mo ml l mm mn">export default connect((state) =&gt; ({<br/>    element: &lt;List /&gt;<br/>}));</span></pre><p id="025a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nf ng nh mf b">element</code>将总是一个新的实例，所以它也打破了相等检查。但是，通过将它移动到一个常量(在模块中定义),很容易解决这个问题:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="883d" class="mj lc it mf b gy mk ml l mm mn">import {connect} from 'react-redux';</span><span id="0639" class="mj lc it mf b gy mo ml l mm mn">...</span><span id="1d0d" class="mj lc it mf b gy mo ml l mm mn">const element = &lt;List /&gt;;</span><span id="dcef" class="mj lc it mf b gy mo ml l mm mn">export default connect((state) =&gt; ({<br/>    element<br/>}));</span></pre><p id="b7a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一种方法是传递组件而不是实例，并将渲染委托给父级:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="cccb" class="mj lc it mf b gy mk ml l mm mn">import {connect} from 'react-redux';</span><span id="17a4" class="mj lc it mf b gy mo ml l mm mn">...</span><span id="882c" class="mj lc it mf b gy mo ml l mm mn">export default connect((state) =&gt; ({<br/>    Element: List<br/>}));</span><span id="cecd" class="mj lc it mf b gy mo ml l mm mn">...</span><span id="c313" class="mj lc it mf b gy mo ml l mm mn">{<br/>    render() {<br/>        const {Element} = this.props;</span><span id="5c89" class="mj lc it mf b gy mo ml l mm mn">        return (&lt;div&gt;{&lt;Element /&gt;}&lt;/div&gt;);<br/>    }<br/>}</span></pre><h2 id="d7f0" class="mj lc it bd ld mu mv dn lh mw mx dp ll km my mz lp kq na nb lt ku nc nd lx ne bi translated">动态处理程序</h2><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="638f" class="mj lc it mf b gy mk ml l mm mn">class MyComponent extends PureComponent {<br/>    render() {<br/>        const {title, onClick} = this.props;<br/>        <br/>        return (<br/>            &lt;InnerComponent title={title} onClick={() =&gt; onClick()} /&gt;<br/>        )<br/>    }<br/>}</span></pre><p id="af04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">InnerComponent将总是被重新呈现，因为它总是获得onClick处理程序的新实例。您可以通过将handler移动到组件类属性来简单地修复它:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8d65" class="mj lc it mf b gy mk ml l mm mn">class MyComponent extends PureComponent {<br/>    onClick = () =&gt; {<br/>        this.props.onClick();<br/>    }<br/>    <br/>    render() {<br/>        const {title, onClick} = this.props;<br/>        <br/>        return (<br/>            &lt;InnerComponent onClick={this.onClick}&gt;<br/>                &lt;span&gt;{title}&lt;/span&gt;<br/>            &lt;/InnerComponent&gt;<br/>        )<br/>    }<br/>}</span></pre><h1 id="799e" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">提示和技巧</h1><p id="0122" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">现在让我们来详细说明你如何能在将来更容易地避免这样的错误。</p><h2 id="dac6" class="mj lc it bd ld mu mv dn lh mw mx dp ll km my mz lp kq na nb lt ku nc nd lx ne bi translated">使元件更小</h2><p id="100c" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">将一个容器组件订阅到一堆状态，然后通过props将它传递下去，这是一个非常糟糕的想法，例如:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a484" class="mj lc it mf b gy mk ml l mm mn">class MyBeastComponent extends PureComponent {<br/>    render() {<br/>        const {a, b, c} = this.props;<br/>        <br/>        return (<br/>            &lt;div&gt;<br/>                &lt;ComponentA a={a} /&gt;<br/>                &lt;ComponentB b={b} /&gt;<br/>                &lt;ComponentC c={c} /&gt;<br/>            &lt;/div&gt;<br/>        );<br/>    }<br/>}</span></pre><p id="3dd9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次a、b或c中有什么变化，都会导致所有的块重新呈现。相反，您可以将其拆分为更小的连接组件:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="41ab" class="mj lc it mf b gy mk ml l mm mn">class MyBeastComponent extends PureComponent {<br/>    render() {<br/>        return (<br/>            &lt;div&gt;<br/>                &lt;ComponentA /&gt;<br/>                &lt;ComponentB /&gt;<br/>                &lt;ComponentC /&gt;<br/>            &lt;/div&gt;<br/>        );<br/>    }<br/>}</span><span id="7216" class="mj lc it mf b gy mo ml l mm mn">... ComponentA, ComponentB or ComponentC</span><span id="0a16" class="mj lc it mf b gy mo ml l mm mn">import {connect} from 'react-redux';</span><span id="288b" class="mj lc it mf b gy mo ml l mm mn">export default connect(state =&gt; ({<br/>    a: getA(state)<br/>}))(ComponentA);</span></pre><h2 id="60b1" class="mj lc it bd ld mu mv dn lh mw mx dp ll km my mz lp kq na nb lt ku nc nd lx ne bi translated">缩小数据范围</h2><p id="e4f8" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">只传递组件需要的数据。例如，要呈现集合，通常不需要传递整个列表，只需传递项目的id。然后将孩子连接到商店，并使用ID检索数据:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5e90" class="mj lc it mf b gy mk ml l mm mn">class MyList extends PureComponent {<br/>    render() {<br/>        const {itemIds} = this.props;<br/>        <br/>        return (<br/>            &lt;div&gt;<br/>                {itemIds.map(id =&gt; (<br/>                    &lt;Item key={id} id={id} /&gt;<br/>                ))}<br/>            &lt;/div&gt;<br/>        );<br/>    }<br/>}</span><span id="ca90" class="mj lc it mf b gy mo ml l mm mn">... Item component</span><span id="8dd8" class="mj lc it mf b gy mo ml l mm mn">import {connect} from 'react-redux';</span><span id="e693" class="mj lc it mf b gy mo ml l mm mn">export default connect((state, {id}) =&gt; ({<br/>    title: getItemTitle(state, id),<br/>    foo: getItemFoo(state, id),<br/>    bar: getItemBar(state, id)<br/>}))(Item);</span></pre><p id="5a32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，即使集合中的id集发生变化，它也不会重新呈现包括子项在内的所有列表。</p><h2 id="aac3" class="mj lc it bd ld mu mv dn lh mw mx dp ll km my mz lp kq na nb lt ku nc nd lx ne bi translated">仔细检查你自己</h2><p id="87fb" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">一定要确保你的记忆是有效的，并且不会产生任何倒退。您可以使用下面的代码片段在单元测试中包装您的选择器，并仔细检查它是否为相同的参数集返回相同的结果:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f5c0" class="mj lc it mf b gy mk ml l mm mn">const wrapMemoizedSelector = (selector) =&gt; {<br/>    returns (...args) =&gt; {<br/>        const result = selector(...args);</span><span id="c647" class="mj lc it mf b gy mo ml l mm mn">        if (selector(...args) !== result) {<br/>            throw new Error('Memoization check failed.');<br/>        }</span><span id="6765" class="mj lc it mf b gy mo ml l mm mn">        return result;<br/>    }<br/>}</span><span id="bc08" class="mj lc it mf b gy mo ml l mm mn">...</span><span id="0834" class="mj lc it mf b gy mo ml l mm mn">const examine = wrapMemoizedSelector(selector);</span><span id="e5f7" class="mj lc it mf b gy mo ml l mm mn">test('check return value', () =&gt; {<br/>    expect(examine({...})).toEqual({...});<br/>});</span></pre><h1 id="4081" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">就是这样！</h1><p id="f4e1" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">我希望这将有助于你快速反应应用程序。</p><p id="5de8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果有帮助就鼓掌，并在评论中分享你的建议。</p></div></div>    
</body>
</html>