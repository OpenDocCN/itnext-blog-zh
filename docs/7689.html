<html>
<head>
<title>Mocking TypeScript objects in legacy projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模仿旧项目中的TypeScript对象</h1>
<blockquote>原文：<a href="https://itnext.io/mocking-typescript-objects-in-legacy-projects-773b38b9b4f7?source=collection_archive---------5-----------------------#2022-12-20">https://itnext.io/mocking-typescript-objects-in-legacy-projects-773b38b9b4f7?source=collection_archive---------5-----------------------#2022-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="35ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用jest-mock-extended(或vite-mock-extended) 🛠</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2a661c118437e0d2c84ea618b3724d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7GWsFcasVQ_GJCWw"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">约尔根·哈兰在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c5af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模仿对象并不困难，但是在特定的环境中，比如遗留环境中，就很有挑战性。在这篇文章中，<strong class="jp ir">我们将学习如何毫无痛苦地模仿复杂的打字稿对象</strong>。</p><blockquote class="lc ld le"><p id="174e" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">Y <!-- -->你可以查看<a class="ae lb" href="https://github.com/agualis/mock-extended-demo" rel="noopener ugc nofollow" target="_blank">这个回购</a>或者玩<a class="ae lb" href="https://stackblitz.com/github/agualis/mock-extended-demo/tree/main?file=src%2Fpool.spec.ts" rel="noopener ugc nofollow" target="_blank">这个交互示例</a>用真实代码了解示例。</p></blockquote></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="5429" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">语境</h1><p id="ceb1" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">想象一下，你开始在一家新公司工作，并且<strong class="jp ir">你加入了一个没有单元测试的打字稿项目</strong>。团队给了你第一个小任务，你发现<strong class="jp ir">你必须使用像这样的大类型/接口</strong>:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="db2d" class="my lr iq mu b be mz na l nb nc">export interface TimeMachine {<br/>  id: string;<br/>  name: string;<br/>  address: string;<br/>  modelId: number;<br/>  timeTravelType: TimeTravelType;<br/>  timeTravelVersion: number;<br/>  fluxCapacitorFee: string;<br/>  temporalDisplacementFeeCache: string;<br/>  owner?: string;<br/>  factory?: string;<br/>  destinations: TimeMachineDestination[];<br/>  destinationsList: string[];<br/>  destinationAddresses?: string[];<br/>  totalPower: string;<br/>  totalBoost: string;<br/>  totalFluxCapacitorFee?: string;<br/>  totalTimeTravelVolume?: string;<br/>  onchain?: OnchainTimeMachineData;<br/>  createTime?: number;<br/>  mainDestinations?: string[];<br/>  alternateDestinations?: string[];<br/>  nonExistentDestinations?: string[];<br/>  isNew?: boolean;<br/>  energySnapshot?: string;<br/>  feesSnapshot?: string;<br/>  thrust?: string;<br/>  model?: string;<br/>  timeTravelEnabled: boolean;<br/>  temporalDisplacement?: string;<br/>  alternateIndex?: number;<br/>  mainIndex?: number;<br/>  efficiency?: EfficiencyBreakdown;<br/>  power?: string;<br/>  maxSpeed: string;<br/>  lowerTarget: string;<br/>  upperTarget: string;<br/>  temporalRateProviders?: TemporalRateProvider[];<br/>  userSpeed: number;<br/>}</span></pre><p id="8d1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，作为团队中的新开发人员，你不熟悉这个新的业务领域，所以你不知道什么是<em class="lf">时间机器</em>。你也不知道<em class="lf"> TimeMachine </em>的相关类型，如<em class="lf"> OnchainTimeMachineData </em>、<em class="lf"> EfficiencyBreakdown </em>或<em class="lf">temporaltrateprovider</em>。</p><h1 id="8ffc" class="lq lr iq bd ls lt nd lv lw lx ne lz ma mb nf md me mf ng mh mi mj nh ml mm mn bi translated">你的任务</h1><p id="f9c5" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">你的任务真的很简单:你要用两个<em class="lf"> TimeMachine </em>属性(<em class="lf"> maxSpeed </em>和<em class="lf"> userSpeed </em>)来计算<em class="lf"> maxSpeed </em>是<em class="lf"> userSpeed </em>的百分之几。简单易行:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="6d38" class="my lr iq mu b be mz na l nb nc">import { TimeMachine } from './types';<br/><br/>export function calculateSpeedometerPercentage(machine: TimeMachine): string {<br/>  const speedometerPercentage =<br/>    (machine.userSpeed / Number(machine.maxSpeed)) * 100;<br/>  return `${speedometerPercentage}%`;<br/>}</span></pre><p id="640c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，测试呢？</p><p id="0109" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要创建一个有效的<em class="lf"> TimeMachine </em>接口实例来编写您的测试，但是，<strong class="jp ir">您不希望花费大量时间(现在)来创建一个看起来干净简单、满足所有域TimeMachine不变量并对给定测试有意义的真实对象</strong>，因为您喜欢循序渐进。🛠 <em class="lf">模拟展开</em>营救🛠</p><h1 id="4a6d" class="lq lr iq bd ls lt nd lv lw lx ne lz ma mb nf md me mf ng mh mi mj nh ml mm mn bi translated">介绍jest-mock-extended</h1><p id="9025" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">jest-mock-extended 是一个库，让你能够模仿任何类型脚本接口或对象。</p><blockquote class="lc ld le"><p id="f594" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">我首选的TS测试工具是<a class="ae lb" href="https://vitest.dev/" rel="noopener ugc nofollow" target="_blank"> vitest </a>，所以我将使用<a class="ae lb" href="https://www.npmjs.com/package/vitest-mock-extended" rel="noopener ugc nofollow" target="_blank"> vitest-mock-extended </a>，它具有完全相同的API。</p></blockquote><p id="6c93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装了这个库之后，为我们的示例(<em class="lf"> TimeMachine interface </em>)创建一个模拟实例就像下面这样简单:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="19b6" class="my lr iq mu b be mz na l nb nc">import { TimeMachine } from './types';<br/>import { mock } from 'jest-mock-extended';<br/> <br/>const machineMock = mock&lt;TimeMachine&gt;();</span></pre><p id="a36c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试我们的场景，我们只需要使用两个属性(<em class="lf"> maxSpeed </em>和<em class="lf"> userSpeed </em>)，所以我们可以像这样模拟它们:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="2b8b" class="my lr iq mu b be mz na l nb nc"> const machineMock = mock&lt;TimeMachine&gt;();<br/> machineMock.maxSpeed = '100';<br/> machineMock.userSpeed = 25;</span></pre><p id="da6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，最终的测试将是:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="f09a" class="my lr iq mu b be mz na l nb nc">import { mock } from 'vitest-mock-extended'; //jest-mock-extended for jest<br/>import { TimeMachine } from './types';<br/>import { calculateSpeedometerPercentage } from './timeMachine';<br/><br/>it('calculates speed percentage (using builder)', () =&gt; {<br/>  const machineMock = mock&lt;TimeMachine&gt;();<br/>  machineMock.maxSpeed = '100';<br/>  machineMock.userSpeed = 25;<br/><br/>  expect(calculateSpeedometerPercentage(machineMock)).toBe('25%');<br/>});</span></pre><h1 id="4daf" class="lq lr iq bd ls lt nd lv lw lx ne lz ma mb nf md me mf ng mh mi mj nh ml mm mn bi translated">使用构建器</h1><p id="455f" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">但是有些事情我们可以改进。在实例创建之后修改属性并不是最好的主意，因为这很危险(如果对象有一个构造函数，而我们必须在这个构造函数中检查业务不变量怎么办？)而且意图不像做什么都一脉相承那么明确。让我们使用一个简单的构建器函数，它接受任何<em class="lf"> TimeMachine </em>属性(由于<a class="ae lb" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype" rel="noopener ugc nofollow" target="_blank">部分</a>):</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="e5f1" class="my lr iq mu b be mz na l nb nc">function aTimeMachine(overridden: Partial&lt;TimeMachine&gt;): TimeMachine {<br/>  return Object.assign(mock&lt;TimeMachine&gt;(), overridden);<br/>}</span></pre><p id="4915" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用下面的构建器，我们的测试将如下所示:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="e308" class="my lr iq mu b be mz na l nb nc">it('calculates speed percentage (using builder)', () =&gt; {<br/>  const machineMock = aTimeMachine({ maxSpeed: '100', userSpeed: 25 });<br/>  expect(calculateSpeedometerPercentage(machineMock)).toBe('25%');<br/>});</span></pre><p id="f645" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们在自动完成和类型检查方面有很好的TypeScript开发人员体验:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/b76afb3b5034d145488fc93dbb4ecc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*w1X_lDRnk8PVXFwgAWmjVA.gif"/></div></div></figure><h1 id="7abb" class="lq lr iq bd ls lt nd lv lw lx ne lz ma mb nf md me mf ng mh mi mj nh ml mm mn bi translated">带有默认值的生成器</h1><p id="6fbd" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我们能进一步改进它吗？也许是的。我们当前测试的函数需要<em class="lf"> maxSpeed </em>和<em class="lf"> userSpeed </em>来执行它的计算，所以我们希望在构建实例时非常明确地传递这些值。但是在未来的测试中，当我们将重点放在其他属性上时，拥有<em class="lf"> maxSpeed </em>和<em class="lf"> userSpeed </em>的默认值而不需要在测试中明确引用<em class="lf"/><em class="lf"/>可能会很酷。<strong class="jp ir">我们可以在构建器中包含默认值</strong>:</p><pre class="km kn ko kp gt mt mu mv bn mw mx bi"><span id="5c97" class="my lr iq mu b be mz na l nb nc">function aTimeMachineWithDefaults(<br/>  overridden: Partial&lt;TimeMachine&gt;<br/>): TimeMachine {<br/><br/>  const defaults: Partial&lt;TimeMachine&gt; = {<br/>    maxSpeed: '100',<br/>    userSpeed: 0,<br/>  };<br/><br/>  return Object.assign(mock&lt;TimeMachine&gt;(), defaults, overridden);<br/>}</span></pre><h1 id="1d4d" class="lq lr iq bd ls lt nd lv lw lx ne lz ma mb nf md me mf ng mh mi mj nh ml mm mn bi translated">其他上下文</h1><p id="90d7" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我认为自己是一个固执己见的开发者，但是如果环境改变了，我可能会改变我的观点😊。</p><p id="7782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于复杂类型的遗留项目，我喜欢使用<em class="lf"> jest-mock-extended </em>方法，但是对于绿地项目，我可能会建议手动创建模拟。花时间理解你的领域并创建语义“子构建器”将帮助你更好地理解你的业务，你甚至会发现有趣的规则和代码，这些规则和代码可以从测试构建器转移到产品中，使你的项目更简单、更干净、更易于维护。</p><p id="bec3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还建议使用生成器工具，如<a class="ae lb" href="https://fakerjs.dev/" rel="noopener ugc nofollow" target="_blank"> Faker </a>来创建更真实和随机的数据，以使您的测试更好。为什么不在原型中或在<a class="ae lb" href="https://mswjs.io/" rel="noopener ugc nofollow" target="_blank"> MSW处理器</a>中重用这个构建器。但是像往常一样，一步一步来。</p><p id="4ab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀<strong class="jp ir">快乐测试</strong>🚀</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="c5b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，您在<a class="ae lb" href="https://github.com/agualis/mock-extended-demo" rel="noopener ugc nofollow" target="_blank">这个回购</a>中有以下示例，您也可以与<a class="ae lb" href="https://stackblitz.com/github/agualis/mock-extended-demo/tree/main?file=src%2FtimeMachine.spec.ts" rel="noopener ugc nofollow" target="_blank">一起玩这个互动示例</a>。</p><p id="3dbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也请查看我的<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/driving-your-testing-efforts-with-code-coverage-tools-616eadc7c2ca">下一篇文章</a>，在那里我使用了之前的技术来增加一个更复杂例子的覆盖范围。</p></div></div>    
</body>
</html>