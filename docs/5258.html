<html>
<head>
<title>Interfaces in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go界面</h1>
<blockquote>原文：<a href="https://itnext.io/interfaces-in-go-5c6e38b81b41?source=collection_archive---------1-----------------------#2021-01-25">https://itnext.io/interfaces-in-go-5c6e38b81b41?source=collection_archive---------1-----------------------#2021-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们剖析接口，成为交易高手</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/93e68b41a76d77885d411dbda884f163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EEr8_m0y4jSBAxqTyfu5nw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@d_mccullough?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·麦卡洛</a>在<a class="ae ky" href="https://unsplash.com/s/photos/blueprint?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="c10e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我觉得有必要写一篇关于接口的文章，因为它是Go中最让我惊讶的特性之一。我不想说谎，我花了一段时间来适应使用它们，但当我通过学习门槛时，我开始喜欢它们。</p><p id="d2ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不是说界面很难或者很复杂，而是学习使用它们的习惯和思维方式似乎让很多人感到困惑。在这篇文章中，我将尝试使用大量的例子，这样我们不仅可以学习如何使用它们，还可以学习何时使用它们。</p><h2 id="94eb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">国际——现在怎么办？</h2><p id="95c0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们从头开始，在继续之前回顾一下基础知识。</p><p id="43db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口是方法接收者的<strong class="lb iu">集合。这意味着我们定义了一个规则，任何描述了所有方法的类型都是接口的一部分。提醒人们什么是<strong class="lb iu">方法接收器</strong>也是值得的。当我们将一个方法应用于一个类型时。下面的要点显示了一个例子，这适用于指针和非指针。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">方法接收器举例说明，<a class="ae ky" href="https://play.golang.org/p/H4RJa8HEHG7" rel="noopener ugc nofollow" target="_blank">在这里试试</a></figcaption></figure><p id="89ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">声明一个接口只是创建了一个蓝图，告诉我们需要什么方法来成为它的一部分。你不需要描述每个方法做什么，只需要描述它们将如何表现。您声明任何具有输出字符串的名为<code class="fe mv mw mx my b">String()</code>的方法的类型都是<code class="fe mv mw mx my b">Stringer</code>接口的一部分。但是输出什么字符串的实际实现取决于开发人员。如果使用得当，这将变得非常强大，因为我们可以编写一个接受特定接口的函数，而不是重写许多不同的函数。</p><p id="45f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个类型在接口中有所有描述的方法，<strong class="lb iu">它自动被认为是接口的一部分，不需要定义它！</strong></p><p id="95d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标准库定义了一些可用的接口。我们用其中的一个例子来更好的理解。我们将看看<code class="fe mv mw mx my b">Error</code>界面<strong class="lb iu">。如果你从来不知道这个错误是一个接口，不要感到羞愧，我花了很长时间才意识到。</strong></p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="7207" class="lv lw it my b gy nd ne l nf ng">type error interface {<br/>  Error() string<br/>}</span></pre><p id="6448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于error，标准库声明<strong class="lb iu">任何具有名为Error </strong>的方法、没有输入参数、输出字符串的类型都是Error接口的一部分。这意味着如果我们实现了<code class="fe mv mw mx my b">Error() string</code>方法，我们可以让我们的任何结构像一个错误一样工作。如果我们想要扩展在错误中发送的信息，这可能是有用的。当人们想要在HTTP等中的错误中添加额外的信息时，我经常看到这样做。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在同一个PrintError方法中使用DateError和regular error的展示，<a class="ae ky" href="https://play.golang.org/p/VDA22pEqBMk" rel="noopener ugc nofollow" target="_blank">在这里试试</a></figcaption></figure><p id="d6c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在要点中，我创建了一个<code class="fe mv mw mx my b">DateError</code>类型，这是一个非常简单的结构，在调用<code class="fe mv mw mx my b">Error()</code>方法时会附加当前日期。这个<code class="fe mv mw mx my b">DateError</code>可以作为一个<code class="fe mv mw mx my b">error</code>传入传出函数，因为它有Error()字符串方法，使它成为错误接口的一部分。</p><p id="2fa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想是时候提一下在定义<strong class="lb iu">方法接收方</strong>时<strong class="lb iu">指针</strong>和<strong class="lb iu">非指针</strong>之间的区别了。当声明方法时，我们必须声明它是用于常规结构还是仅仅指向它们的指针将接收该方法。如果我们将<code class="fe mv mw mx my b">Error</code>方法更新为只应用于指针，我们应该会看到构建失败。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">更新了示例，用指针接收器代替。在这里尝试一下</figcaption></figure><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="823a" class="lv lw it my b gy nd ne l nf ng">./prog.go:32:12: cannot use de (type DateError) as type error in argument to PrintError:<br/>	DateError does not implement error (Error method has pointer receiver)</span></pre><p id="d39d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个常见的事情，我看到是错过了。所以重要的是要记住，你总是要考虑它是否应该适用于指针。通常，当您的方法将直接修改对象而不是返回值时，应该使用指针。它还可以用来避免传递对象的副本，以节省所使用的内存量。</p><p id="a085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要记住的一点是，接口总是作为指针传递，即使你的结构不是。我将在一个例子中展示这一点，使它更清楚。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我已经修改了NewError来返回一个指针，它仍然可以工作。<a class="ae ky" href="https://play.golang.org/p/G4w2qEcWpq8" rel="noopener ugc nofollow" target="_blank">试试这里</a></figcaption></figure><p id="28ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的要点中，我修改了<code class="fe mv mw mx my b">NewError</code>来输出一个指向<code class="fe mv mw mx my b">DateError</code>的指针。它仍然可以工作，因为当把我们的<code class="fe mv mw mx my b">DateError</code>传递给<code class="fe mv mw mx my b">PrintError</code>时，它将作为一个指针被传递。接口总是作为指针传递。</p><h2 id="999b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">为什么有用</h2><p id="0989" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当我开始使用Go的时候，我已经很长时间没有使用接口了，至少我没有意识到使用它们是一个错误。</p><p id="8184" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从学会更频繁地使用它们，我已经使我的代码更加模块化，更容易重构和简化测试。这就是为什么我觉得讨论它们为什么有用很重要。我将用例子来说明和加强我的论点。</p><p id="91a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想说的第一点是<strong class="lb iu">模块化</strong>。我喜欢能够轻松地切换出我的代码片段。在较小的应用程序中，这通常不意味着大量的重构，但在大型项目中，这可能很苛刻，会破坏很多东西。</p><p id="116e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口让我们跳过重构的痛苦，非常顺畅地交换业务逻辑。那么我们来看一个<code class="fe mv mw mx my b">UserDatabase</code>的例子。这里我们将创建一个处理用户的小界面。在展示期间，它将使用内存作为存储，并使用一个界面来展示我们如何在不破坏应用程序的情况下轻松替换它。这个例子是下面这个超级简单的命令行工具，它将打印出用户信息。在现实生活中，这可能是一个HTTP API等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">例子的基础，一个内存数据库。在这里试试吧。</figcaption></figure><p id="932d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用上述要点作为我们重构的基础。我们将通过修改它并添加一个<code class="fe mv mw mx my b">UserDatabase</code>接口。这将允许我们在稍后阶段轻松地交换整个内存数据库，而不会中断依赖它的其他进程。首先，我们将实现接口，以及一个名为<code class="fe mv mw mx my b">API</code>的结构，它将保存一个<code class="fe mv mw mx my b">UserDatabase</code>。API结构的要点是显示事物如何不中断，我们的示例将只打印到stdout，但是在实际情况下，它可以是服务于HTTP端点的API，或者任何东西。</p><p id="f5e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当创建一个接口时，试着思考什么方法必须是它的一部分是一个好习惯，<strong class="lb iu">有人曾经说过我的接口应该包含最多5-6个方法。</strong>使用较小的接口要容易得多，如果它变得太大，就把它分成多个接口。</p><p id="b879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将需要<code class="fe mv mw mx my b">AddUser</code>和<code class="fe mv mw mx my b">GetUser</code>作为我们创建的界面。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">下面的要点说明了我们如何使用一个接口来访问内存数据库。<a class="ae ky" href="https://play.golang.org/p/pKIY_A3H-7r" rel="noopener ugc nofollow" target="_blank">试试这里</a></figcaption></figure><p id="8e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经添加了一个API使用的接口。让我们试着用别的东西代替数据库，看看我们的例子变得多么模块化。<br/>我将交换到的数据库是一个测试数据库，它总是返回错误，这是因为我想把你引入我的下一个论点，为什么要使用接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">为了交换整个API的逻辑，我只需要将数据库字段更改为测试DB。<a class="ae ky" href="https://play.golang.org/p/CcujWp8nANf" rel="noopener ugc nofollow" target="_blank">试试这里</a></figcaption></figure><h2 id="72d0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">测试变得更加容易</h2><p id="da6e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接口的另一个真正好的部分是它们可以帮助测试。有些方法很容易测试，但有些方法很难测试，因为它们运行的方法依赖于其他方法和服务。这时接口可以帮助测试。我们可以用我们的结构来替换服务，在测试过程中我们需要它来表现。比方说，如果有一个HTTP处理程序，我们想要测试用户不存在时的行为，我们可以应用我们创建的<code class="fe mv mw mx my b">TestDatabase</code>。</p><h2 id="d48d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">干(不重复)</h2><p id="ee94" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接口允许我们不重复代码。我们可以使用接口将多个结构传递给同一个函数，在这个函数中我们需要相同的行为。我有一个很好的例子，在我的一个数据处理项目中。</p><p id="aa6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我正在构建一个<a class="ae ky" href="https://github.com/percybolmer/workflow/" rel="noopener ugc nofollow" target="_blank">数据处理工具</a>，它执行某些操作并在许多处理器之间传输数据，比如读取文件、解析csv或记录它。我通过在每个处理器之间传递一个常规的<code class="fe mv mw mx my b">[]byte</code>来开始这个项目。这被证明是行不通的，你看，我希望处理器是无缝的。传递一个<code class="fe mv mw mx my b">[]byte</code>需要下一个处理器知道如何将<code class="fe mv mw mx my b">[]byte</code>分解成可用的数据。</p><p id="ffa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是接口。我创建了一个名为<code class="fe mv mw mx my b">Payload</code>的界面。Payload是一个简单的接口，包含一个<code class="fe mv mw mx my b">GetPayload() []byte</code>方法。乍一看，这似乎没有任何帮助，但是它允许处理器无缝地传递数据，不管是CsvPayload、JsonPayload等等。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="a1e6" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">提示和技巧</h1><p id="c0cd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">文章的这一部分将介绍一些可以用于接口的技巧和窍门。我将从最常见的技巧开始，空界面。</p><h2 id="f9e0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">空界面</h2><p id="d65a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我看来，就界面而言，空界面是迄今为止最强大的工具。那是什么呢？<strong class="lb iu">这是一个接口，应用了0个方法，使每个类型都成为它的一部分。</strong>这允许你发送<strong class="lb iu">任何类型到一个方法中。</strong></p><p id="c6cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在Go代码库中很常见。一个例子是当我们解组JSON时。如果我们看一下<a class="ae ky" href="https://golang.org/pkg/encoding/json/#Unmarshal" rel="noopener ugc nofollow" target="_blank"> JSON。解组，</a>你可以看到它是一个如下定义的方法。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="302d" class="lv lw it my b gy nd ne l nf ng">func Unmarshal(data []<a class="ae ky" href="https://golang.org/pkg/builtin/#byte" rel="noopener ugc nofollow" target="_blank">byte</a>, v interface{}) <a class="ae ky" href="https://golang.org/pkg/builtin/#error" rel="noopener ugc nofollow" target="_blank">error</a></span></pre><p id="561f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到<strong class="lb iu">界面了吗？这就是你如何使用一个空的界面。我们在那里做的是说“任何有这0个方法的类型都可以被传入”。</strong></p><p id="db55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以将任何类型的数据传递给这个方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">空接口的用途示例。<a class="ae ky" href="https://play.golang.org/p/92sg7JkPmk1" rel="noopener ugc nofollow" target="_blank">试试这里</a></figcaption></figure><p id="745f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在工作和使用空界面时要记住的一件事是</p><blockquote class="nz"><p id="cf9c" class="oa ob it bd oc od oe of og oh oi lu dk translated">能力越大，责任越大</p></blockquote><p id="6dcc" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">仅仅因为一个方法可以接受每一种类型，并不意味着它可以正确地处理任何类型。</p><h2 id="7f9a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">类型断言</h2><p id="f8e1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您可以在接口上执行类型断言。当您希望一个函数接受两种类型的数据，但仍然希望根据输入来区分所做的事情时，这很有用。一个例子是我前面提到的数据处理工具，一些处理器需要网络负载。在那里，我必须接受payload接口，因为它有助于框架标准化，但我仍然需要验证正确的输入类型。</p><p id="cc0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我的框架将使用<code class="fe mv mw mx my b">Payload</code>作为输入(这是一个接口)，但是这些特定的处理器需要将有效载荷转换成<code class="fe mv mw mx my b">NetworkPayloads</code>。此时，您可以使用类似下面要点的类型断言。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在网络有效负载中键入断言有效负载。</figcaption></figure><p id="a990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe mv mw mx my b">pay.(*NetworkPayload)</code>，这就是Go中类型断言的样子。</p><p id="7434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">YourType.(WantedType)</code></p><p id="59f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型断言将返回两件事，一个是所需类型的类型，另一个是指示是否可以成功转换类型的布尔值。</p><p id="4c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要访问接口本身没有公开的底层数据时，这非常有用。参见类型切换中的下一个例子我如何使用结果。名称来访问未由空接口公开的数据字段。</p><h2 id="5a59" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">类型转换</h2><p id="f74e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">因此，也许我们希望有一个方法，它接受一个空接口，但根据它的类型来决定采用哪种方法。您可以使用类型断言来转换类型，但是类型切换允许您测试多种类型。</p><p id="6f6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它通常用于避免重复代码，比如你的应用程序应该记录不同的事件。我们可以编写一个标准化的日志方法，它接受任何类型，并根据类型进行不同的日志记录。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">如何使用类型开关的示例。<a class="ae ky" href="https://play.golang.org/p/AWQ3BRBweo3" rel="noopener ugc nofollow" target="_blank">试试这里</a></figcaption></figure><h2 id="2880" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">嵌入接口</h2><p id="6afd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Go中，你也可以将接口嵌入到其他接口或结构中。将一个接口嵌入另一个接口意味着嵌入另一个接口的接口也需要继承的方法。举个例子可能更简单。我将在我们之前创建的<code class="fe mv mw mx my b">UserDatabase</code>界面上展示这一点。嵌入背后的原因(至少对我来说)是我们可以保持代码更简单，同样，模块化。想象一下，我们现在也想通过电子邮件获取用户，所以我们需要添加。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="0602" class="lv lw it my b gy nd ne l nf ng">type UserDatabase interface {<br/> GetUser(username string) (*User, error)<br/> GetUser(email string) (*User, error)<br/> AddUser(username, email string) error<br/>}</span></pre><p id="b863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有两个方法做同样的事情，但是在实际应用中，可能会更多。让我们把它分解成自己的接口并嵌入其中。</p><p id="52b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">警告，打起精神，大要点来了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个我们现在如何嵌入UserRetriever接口的例子。<a class="ae ky" href="https://play.golang.org/p/Rky8g73GxYa" rel="noopener ugc nofollow" target="_blank">试试这里</a></figcaption></figure><p id="0e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不得不提，但是不喜欢。将接口嵌入结构是可能的，但是我不得不<strong class="lb iu">警告</strong>你，这很容易出错。</p><p id="00c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将举一个简短的例子，向你们展示它是如何工作的，以及它的危险性。将接口嵌入到结构中会告诉编译器，是的，这个类型满足接口<strong class="lb iu">。即使没有</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">要点显示嵌入有多危险。<a class="ae ky" href="https://play.golang.org/p/2yQ0zP3VUft" rel="noopener ugc nofollow" target="_blank">试试这里</a></figcaption></figure><p id="1433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试取消操场上第20行的注释，看看会发生什么。它会编译，但是由于<code class="fe mv mw mx my b">User</code>结构不是<code class="fe mv mw mx my b">Printer</code>，它会死机。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="c469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可悲的是，我们已经到达了旅程的终点。希望你已经学到了更多关于接口的知识。如果你有什么想讨论的，或者想让我写的，一定要联系我。<br/>如果您想要一些额外的练习，我建议以内存数据库为例，尝试用PostgreSQL数据库来代替它进行测试。那可能会是一次很好的训练。<br/>您可以轻松设置PostgreSQL以在Docker开发中使用，请阅读我关于Docker的文章。</p><div class="oo op gp gr oq or"><a href="https://programmingpercy.tech/blog/learn-docker-basics/" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">学习Docker的基础知识</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">大约两年前，我开始听到越来越多关于Docker的消息。最终，我…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">编程percy.tech</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>