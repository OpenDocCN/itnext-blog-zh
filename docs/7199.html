<html>
<head>
<title>Utilizing In-memory Data Caching to Enhance the Performance of Data Lake-based Applications on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用内存数据缓存提高AWS上基于数据湖的应用程序的性能</h1>
<blockquote>原文：<a href="https://itnext.io/utilizing-in-memory-data-caching-to-substantially-enhance-performance-of-data-lake-based-1e6afe04fe35?source=collection_archive---------4-----------------------#2022-07-12">https://itnext.io/utilizing-in-memory-data-caching-to-substantially-enhance-performance-of-data-lake-based-1e6afe04fe35?source=collection_archive---------4-----------------------#2022-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a02b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Amazon ElastiCache for Redis显著提高基于数据湖的分析应用程序的性能并降低其成本</h2></div><h1 id="1d1f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="d54e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最近的帖子<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/developing-spring-boot-applications-for-querying-data-lakes-on-aws-eeefa298741">使用Amazon Athena </a>开发用于在AWS上查询数据湖的Spring Boot应用，演示了如何使用Spring Boot开发云原生分析应用。该应用程序利用Amazon Athena API，通过AWS Glue数据目录查询基于Amazon S3的数据湖中的数据。</p><div class="lx ly gp gr lz ma"><a rel="noopener  ugc nofollow" target="_blank" href="/developing-spring-boot-applications-for-querying-data-lakes-on-aws-eeefa298741"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iu gy z fp mf fr fs mg fu fw is bi translated">开发用于在AWS上查询数据湖的Spring Boot应用程序</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">学习开发云原生的RESTful Java服务，使用Amazon Athena在基于AWS的数据湖中查询数据…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">itnext.io</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo mp ma"/></div></div></a></div><p id="ecfe" class="pw-post-body-paragraph la lb it lc b ld mq ju lf lg mr jx li lj ms ll lm ln mt lp lq lr mu lt lu lv im bi translated">使用RESTful APIs安全地公开数据湖中的数据可以满足许多数据消费者的需求。但是，访问这些数据可能比从数据库或数据仓库访问要慢得多。例如，在之前的帖子中，我们将来自Spring Boot服务的<a class="ae lw" href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md" rel="noopener ugc nofollow" target="_blank"> OpenAPI v3规范</a>导入到了<a class="ae lw" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>中。API规范包含大约17个端点。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/5dd59e5b50dd5ef2f2abda7f549e6ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGyryoMnwo7qbkTFNZah_w.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">使用Postman对Spring Boot服务运行一套集成测试</figcaption></figure><p id="f9ae" class="pw-post-body-paragraph la lb it lc b ld mq ju lf lg mr jx li lj ms ll lm ln mt lp lq lr mu lt lu lv im bi translated">在我的本地开发笔记本电脑上，所有服务端点的Postman API测试运行时间平均为32.4秒。Spring Boot服务在AWS美国东部(N. Virginia)地区的亚马逊EKS上运行三个Kubernetes pod副本。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nk"><img src="../Images/b5906cc3dfac126f5f6c0323916cb863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6j7WW-gFBwM0pDkVUbDxxQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">从服务运行的测试结果示例(无Redis缓存)</figcaption></figure><p id="e5ad" class="pw-post-body-paragraph la lb it lc b ld mq ju lf lg mr jx li lj ms ll lm ln mt lp lq lr mu lt lu lv im bi translated">将数据湖查询结果时间与针对包含相同数据的最小规模的<a class="ae lw" href="https://aws.amazon.com/rds/postgresql/" rel="noopener ugc nofollow" target="_blank"> Amazon RDS for PostgreSQL </a>数据库实例进行的等效查询进行比较。类似的Spring Boot服务中，所有PostgreSQL查询的平均运行时间为10.8秒。虽然不是一个精确的基准，但我们可以清楚地看到，访问亚马逊S3数据湖中的数据要慢得多，大约比PostgreSQL数据库慢3倍。优化数据库很容易造成更大的差异。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nl"><img src="../Images/d5420894a7f8ca12a28493450c8e0383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kX97BzFPpvfmXUyonDqB5w.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">针对Athena和PostgreSQL从服务运行查询的测试结果示例(越快越好)</figcaption></figure><h1 id="0340" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">数据湖的缓存</h1><p id="5a62" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">据AWS称，数据库的速度和吞吐量可能是对整体应用程序性能影响最大的因素。因此，内存数据缓存可能是提高应用程序整体性能和降低数据库成本的最有效策略之一。同样的缓存策略也可以应用于构建在数据湖之上的分析应用程序，正如本文将要展示的。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nm"><img src="../Images/9315d435019973a1207c5417010f4a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iht81y1NUqbR-He8bAwY6w.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">这篇文章展示了高级AWS架构</figcaption></figure><h2 id="d147" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">内存缓存</h2><p id="5244" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">根据<a class="ae lw" href="https://hazelcast.com/glossary/memory-caching" rel="noopener ugc nofollow" target="_blank"> Hazelcast </a>的说法，内存缓存(<em class="nz">又名内存缓存</em>)，通常简称为缓存，是一种计算机应用程序将数据临时存储在计算机主内存(如RAM)中以实现数据快速检索的技术。用于临时存储的RAM被称为<em class="nz">缓存</em>。当应用程序试图读取数据(通常是从数据库等数据存储系统中)时，它会检查所需的记录是否已经存在于缓存中。如果是这样，应用程序将从缓存中读取数据，从而消除对数据库的较慢访问。如果所需的记录不在缓存中，则应用程序从源中读取记录。当它检索该数据时，它会将其写入缓存，以便当应用程序将来需要相同的数据时，它可以从缓存中快速检索该数据。</p><h2 id="ef24" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">Redis内存数据存储</h2><p id="5dc0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">根据他们的<a class="ae lw" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank">网站</a>，Redis是开源的内存数据存储，被数百万开发者用作数据库、缓存、流媒体引擎和消息代理。Redis提供了数据结构，如<a class="ae lw" href="https://redis.io/topics/data-types-intro#strings" rel="noopener ugc nofollow" target="_blank">字符串</a>、<a class="ae lw" href="https://redis.io/topics/data-types-intro#hashes" rel="noopener ugc nofollow" target="_blank">哈希</a>、<a class="ae lw" href="https://redis.io/topics/data-types-intro#lists" rel="noopener ugc nofollow" target="_blank">列表</a>、<a class="ae lw" href="https://redis.io/topics/data-types-intro#sets" rel="noopener ugc nofollow" target="_blank">集合</a>、<a class="ae lw" href="https://redis.io/topics/data-types-intro#sorted-sets" rel="noopener ugc nofollow" target="_blank">排序集合</a>、位图、<a class="ae lw" href="https://redis.io/topics/data-types-intro#hyperloglogs" rel="noopener ugc nofollow" target="_blank">超级日志</a>、<a class="ae lw" href="https://redis.io/commands/geoadd" rel="noopener ugc nofollow" target="_blank">地理空间索引</a>和<a class="ae lw" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank">流</a>。此外，Redis还内置了<a class="ae lw" href="https://redis.io/topics/replication" rel="noopener ugc nofollow" target="_blank">复制</a>、<a class="ae lw" href="https://redis.io/commands/eval" rel="noopener ugc nofollow" target="_blank"> Lua脚本</a>、<a class="ae lw" href="https://redis.io/topics/lru-cache" rel="noopener ugc nofollow" target="_blank"> LRU驱逐</a>、<a class="ae lw" href="https://redis.io/topics/transactions" rel="noopener ugc nofollow" target="_blank">事务</a>和不同级别的<a class="ae lw" href="https://redis.io/topics/persistence" rel="noopener ugc nofollow" target="_blank">磁盘持久性</a>，并通过<a class="ae lw" href="https://redis.io/topics/sentinel" rel="noopener ugc nofollow" target="_blank"> Redis Sentinel </a>和<a class="ae lw" href="https://redis.io/topics/cluster-tutorial" rel="noopener ugc nofollow" target="_blank"> Redis Cluster </a>自动分区提供高可用性。</p><h2 id="2c68" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">Redis的Amazon ElastiCache</h2><p id="ec44" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">根据<a class="ae lw" href="https://aws.amazon.com/elasticache/redis/" rel="noopener ugc nofollow" target="_blank"> AWS </a>的说法，Amazon ElastiCache for Redis，Redis的完全管理版本，是一个极快的内存数据存储，为互联网规模的实时应用提供亚毫秒级延迟。Redis应用程序可以与ElastiCache for Redis无缝协作，无需任何代码更改。ElastiCache for Redis将开源Redis的速度、简单性和多功能性与AWS的可管理性、安全性和可伸缩性相结合。因此，Redis是实现高可用性内存缓存以减少数据访问延迟、增加吞吐量并减轻关系数据库和NoSQL数据库负载的绝佳选择。</p><h2 id="6209" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">ElastiCache性能结果</h2><p id="c17c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在接下来的文章中，我们将把内存缓存添加到上一篇文章中介绍的Spring Boot服务中。在亚马逊ElastiCache for Redis的初步测试中，Spring Boot服务的平均响应时间提高了34倍。例如，在Redis <a class="ae lw" href="https://www.cloudflare.com/learning/cdn/what-is-a-cache-hit-ratio" rel="noopener ugc nofollow" target="_blank">缓存命中率</a>为100%的最佳情况下，测试运行的平均时间为0.95秒，而没有Redis时为32.4秒。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oa"><img src="../Images/fc0fcc1b165a2b07a9926ef5c195927e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1g-w3-aO0mOTV9ezpoFyfA.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">未缓存与缓存测试结果的比较示例(越快越好)</figcaption></figure><h1 id="91f6" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">源代码</h1><p id="ae75" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所有的源代码以及Docker和Kubernetes资源都是开源的，可以在<a class="ae lw" href="https://github.com/garystafford/athena-spring-app/tree/redis" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><pre class="mw mx my mz gt ob oc od oe aw of bi"><span id="5f03" class="nn kj it oc b gy og oh l oi oj">git clone --depth 1 -b redis \<br/>    <a class="ae lw" href="https://github.com/garystafford/tickit-srv.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/athena-spring-app.git</a></span></pre><p id="b45a" class="pw-post-body-paragraph la lb it lc b ld mq ju lf lg mr jx li lj ms ll lm ln mt lp lq lr mu lt lu lv im bi translated">此外，Redis-base Spring Boot服务的Docker图像可在<a class="ae lw" href="https://hub.docker.com/r/garystafford/athena-spring-app/tags" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>上获得。对于这篇文章，使用带有<code class="fe ok ol om oc b">.redis</code>后缀的最新标签。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi on"><img src="../Images/b783b0a081f0d609ab2975834992e9ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6siQPJ6R75DSLefyHGpU7g.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">Spring Boot服务图片可在Docker Hub上找到</figcaption></figure><h1 id="c5d3" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">代码更改</h1><p id="75f6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要使用Redis实现Spring Boot缓存，需要对Spring Boot服务进行以下代码更改。</p><h2 id="04f2" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">Gradle Build</h2><p id="907d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe ok ol om oc b">gradle.build</code>文件现在实现了两个额外的依赖项，Spring Boot的<code class="fe ok ol om oc b"><a class="ae lw" href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-cache/2.7.1" rel="noopener ugc nofollow" target="_blank">spring-boot-starter-cache</a></code>和<code class="fe ok ol om oc b"><a class="ae lw" href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis/2.7.1" rel="noopener ugc nofollow" target="_blank">spring-boot-starter-data-redis</a></code> ( <em class="nz">第45–46行</em>)。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="c373" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">应用程序属性</h2><p id="52f0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">应用程序属性文件<code class="fe ok ol om oc b">application.yml</code>已经针对<code class="fe ok ol om oc b">dev</code>和<code class="fe ok ol om oc b">prod</code> Spring概要文件进行了修改。<code class="fe ok ol om oc b">dev</code> Spring Profile预计Redis将在<code class="fe ok ol om oc b">localhost</code>上运行。相应地，项目的<code class="fe ok ol om oc b"><a class="ae lw" href="https://github.com/garystafford/athena-spring-app/blob/redis/docker/docker-compose.yml" rel="noopener ugc nofollow" target="_blank">docker-compose.yml</a></code>文件现在包含了一个用于本地开发的Redis容器。所有Redis缓存的<a class="ae lw" href="https://redis.io/commands/ttl/" rel="noopener ugc nofollow" target="_blank">生存时间</a> (TTL)被任意设置为<code class="fe ok ol om oc b">dev</code>的一分钟和<code class="fe ok ol om oc b">prod</code>的五分钟。为了提高应用程序性能并降低使用Athena查询数据湖的成本，可以增加Redis的TTL。请注意，增加TTL会降低数据的新鲜度。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="7242" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">雅典娜应用程序类</h2><p id="7c2d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe ok ol om oc b">AthenaApplication</code>类声明现在用Spring Framework的<code class="fe ok ol om oc b"><a class="ae lw" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/EnableCaching.html" rel="noopener ugc nofollow" target="_blank">EnableCaching</a></code>注释(<em class="nz">第22行</em>)修饰。此外，还添加了两个新bean(<em class="nz">第58–68行</em>)。Spring Redis通过<code class="fe ok ol om oc b">org.springframework.data.redis.cache</code>包为Spring <a class="ae lw" href="https://docs.spring.io/spring-framework/docs/5.3.21/reference/html/integration.html#cache" rel="noopener ugc nofollow" target="_blank">缓存抽象</a>提供了一个实现。第一次写入时，<code class="fe ok ol om oc b"><a class="ae lw" href="https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/cache/RedisCacheManager.html" rel="noopener ugc nofollow" target="_blank">RedisCacheManager</a></code>缓存管理器默认创建缓存。<code class="fe ok ol om oc b"><a class="ae lw" href="https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/cache/RedisCacheConfiguration.html" rel="noopener ugc nofollow" target="_blank">RedisCacheConfiguration</a></code>缓存配置有助于定制<code class="fe ok ol om oc b">RedisCache</code>行为，例如缓存空值、缓存键前缀和二进制序列化。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="17a6" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">POJO数据模型类</h2><p id="7967" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Spring Boot Redis缓存使用<a class="ae lw" href="https://www.baeldung.com/java-serialization" rel="noopener ugc nofollow" target="_blank"> Java序列化和反序列化</a>。因此，所有的POJO数据模型类都必须实现<code class="fe ok ol om oc b">Serializable</code> ( <em class="nz">第14行</em>)。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="66d8" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">服务类别</h2><p id="dffb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">服务类中的每个公共方法现在都用Spring Framework的<code class="fe ok ol om oc b"><a class="ae lw" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html" rel="noopener ugc nofollow" target="_blank">Cachable</a></code>注释进行了修饰(<em class="nz">第42行和第66行</em>)。例如，<code class="fe ok ol om oc b">CategoryServiceImp</code>类中的<code class="fe ok ol om oc b">findById(int id)</code>方法被注释为<code class="fe ok ol om oc b"><a class="ae lw" href="http://twitter.com/Cacheable" rel="noopener ugc nofollow" target="_blank">@Cacheable</a>(value = "categories", key = "#id")</code>。该方法的<code class="fe ok ol om oc b">key</code>参数使用<a class="ae lw" href="https://docs.spring.io/spring-framework/docs/3.0.x/reference/expressions.html" rel="noopener ugc nofollow" target="_blank"> Spring表达式语言</a> (SpEL)表达式来动态计算密钥。默认值为null，意味着所有方法参数都被视为一个键，除非已经配置了自定义的<code class="fe ok ol om oc b"><a class="ae lw" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/interceptor/KeyGenerator.html" rel="noopener ugc nofollow" target="_blank">keyGenerator</a></code>。如果在Redis缓存中找不到计算键的值，将调用目标方法，返回值将存储在关联的缓存中。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="b76c" class="nn kj it bd kk no np dn ko nq nr dp ks lj ns nt ku ln nu nv kw lr nw nx ky ny bi translated">控制器类别</h2><p id="2776" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">不需要对控制器类进行任何更改。</p><h1 id="9b3c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">Redis的Amazon ElastiCache</h1><p id="f5dd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为Redis集群创建Amazon ElastiCache有多个选项，包括集群模式、多AZ选项、自动故障转移选项、节点类型、副本数量、分片数量、每个分片的副本数量、可用性区域放置以及静态加密和传输中加密选项。本文中的结果基于最低配置的Redis版本6.2.6集群，其中一个shard、两个<code class="fe ok ol om oc b"><a class="ae lw" href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html" rel="noopener ugc nofollow" target="_blank">cache.r6g.large</a></code>节点、集群模式、多AZ选项和自动故障转移都被禁用。此外，静态加密和传输中加密也被禁用。这种集群配置对于开发和测试是足够的，但是对于生产来说就不够了。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi on"><img src="../Images/5ebc85b244dae6663276fbe47dc933c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YWdPj75SPXk3Nz4ShdAHsw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">亚马逊弹性缓存Redis集群用于这篇文章</figcaption></figure><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi on"><img src="../Images/62fcbac2b4a7ec02c807d8047c294cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zWlH8skYyPApDTya7UBqQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">Amazon ElastiCache for Redis集群监控控制台显示缓存活动</figcaption></figure><h1 id="7bc0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">测试缓存</h1><p id="4227" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了测试Amazon ElastiCache for Redis，我们将再次使用Postman和导入的<a class="ae lw" href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md" rel="noopener ugc nofollow" target="_blank"> OpenAPI v3规范</a>。由于所有数据都从现有的Redis缓存中清除，第一次运行Postman测试时，它们会调用服务的目标方法，并将返回的数据存储在相关的缓存中。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/5dd59e5b50dd5ef2f2abda7f549e6ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGyryoMnwo7qbkTFNZah_w.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">使用Postman对Spring Boot服务运行一套集成测试</figcaption></figure><p id="5bb3" class="pw-post-body-paragraph la lb it lc b ld mq ju lf lg mr jx li lj ms ll lm ln mt lp lq lr mu lt lu lv im bi translated">要确认这种缓存行为，请使用Redis CLI的<code class="fe ok ol om oc b"><a class="ae lw" href="https://redis.io/docs/manual/cli/#getting-a-list-of-keys" rel="noopener ugc nofollow" target="_blank">--scan</a></code>选项。为了访问<code class="fe ok ol om oc b">redis-cli</code>，我在亚马逊EKS部署了一个<a class="ae lw" href="https://github.com/garystafford/athena-spring-app/blob/redis/kubernetes/redis.yml" rel="noopener ugc nofollow" target="_blank">单Redis pod </a>。第一次运行<code class="fe ok ol om oc b">--scan</code>命令时，我们应该得到一个空的键列表。在第一次Postman测试运行之后，同一个<code class="fe ok ol om oc b">--scan</code>命令应该返回一个缓存键列表。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oq"><img src="../Images/7301259a0bc7fdeaa1c47d56c65638e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSEwbN8F60cD50SE9xJhfw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">Redis中的缓存键列表</figcaption></figure><p id="1ae8" class="pw-post-body-paragraph la lb it lc b ld mq ju lf lg mr jx li lj ms ll lm ln mt lp lq lr mu lt lu lv im bi translated">使用Redis CLI的<code class="fe ok ol om oc b">MONITOR</code>选项进一步确认数据正在被缓存，如<code class="fe ok ol om oc b">set</code>命令所示。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oq"><img src="../Images/dba345cb4d3e505fc047063c549b37b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mQtdL31o0wQBe6PBiR17w.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">Athena查询结果缓存在Redis中</figcaption></figure><p id="592c" class="pw-post-body-paragraph la lb it lc b ld mq ju lf lg mr jx li lj ms ll lm ln mt lp lq lr mu lt lu lv im bi translated">在对数据进行初始缓存之后，再次使用Redis CLI的<code class="fe ok ol om oc b">MONITOR</code>选项来确认缓存被命中，而不是调用目标方法，后者将调用Athena API。重新运行Postman测试，我们应该看到与<code class="fe ok ol om oc b">set</code>命令相对的<code class="fe ok ol om oc b">get</code>命令。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oq"><img src="../Images/e12df890855c55362f5d2394a9e963eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkaqHo7UkAGrcRRtXsZqEw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">监控Redis中的缓存命中</figcaption></figure><p id="937e" class="pw-post-body-paragraph la lb it lc b ld mq ju lf lg mr jx li lj ms ll lm ln mt lp lq lr mu lt lu lv im bi translated">最后，为了确认Spring Boot服务有效地使用Redis缓存数据，我们还可以在AWS管理控制台中检查Amazon Athena的最近查询选项卡。在TTL窗口中重复顺序测试运行后，我们应该只看到每个端点一个Athena查询。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi or"><img src="../Images/ad2ebb5bc7c5f748aaafb2511c129a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMzICQ872DpujUsEUNey8g.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">AWS管理控制台中的Amazon Athena最近查询选项卡</figcaption></figure><h1 id="6f41" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="c555" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在最近的帖子<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/developing-spring-boot-applications-for-querying-data-lakes-on-aws-eeefa298741">使用Amazon Athena开发用于在AWS上查询数据湖的Spring Boot应用</a>的后续文章中，我们看到了如何使用Amazon ElastiCache for Redis大幅提高数据湖应用的性能。尽管这种缓存技术通常与数据库相关联，但它也可以有效地应用于基于数据湖的应用程序，如本文中所示。</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="ebbc" class="pw-post-body-paragraph la lb it lc b ld mq ju lf lg mr jx li lj ms ll lm ln mt lp lq lr mu lt lu lv im bi translated">这篇博客代表我的观点，而不是我的雇主亚马逊网络服务公司(AWS)的观点。所有产品名称、徽标和品牌都是其各自所有者的财产。除非另有说明，所有图表和插图都是作者的财产。</p></div></div>    
</body>
</html>