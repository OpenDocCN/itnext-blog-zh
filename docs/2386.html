<html>
<head>
<title>Building a practical Web Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建实用的Web组件</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-practical-web-component-9e84f5e4d63a?source=collection_archive---------1-----------------------#2019-05-16">https://itnext.io/building-a-practical-web-component-9e84f5e4d63a?source=collection_archive---------1-----------------------#2019-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a63289d2d7d99f2bf2f87d75c4ccd6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjvQ8XV65JcxIETD53CNDg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">web组件是未来Web的构建模块吗？Iker Urteaga 在<a class="ae kc" href="https://unsplash.com/search/photos/lego?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="9fd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我发表了一篇关于如何在pure React 中创建电子邮件芯片的<a class="ae kc" href="https://medium.freecodecamp.org/how-to-create-email-chips-in-pure-react-ad1cc3ecea16" rel="noopener ugc nofollow" target="_blank">教程。我的目标是向您展示在React中不使用任何第三方脚本或依赖项来构建这样的组件是多么容易。</a></p><p id="fd54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我想通过将React从桌面上移除来进一步加强游戏。是的，你没听错，没有反应！牵着我的手，放松，冒险进入一个没有任何依赖的无框架世界，构建管道或NPM脚本。你准备好了吗？</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">成品组件。去试试吧。</figcaption></figure><h1 id="613b" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">你为什么要这么做？</h1><p id="de36" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">当您提到普通JavaScript时，许多开发人员会感到紧张。在2019年，在没有框架或库的情况下构建大型web应用似乎几乎不可能，或者至少是乏味的。老实说，React、Vue.js和所有这些工具的存在都有很好的理由:它们让开发数据驱动的ui变得更加容易。一旦你理解了一个框架或库是如何工作的，你就可以构建令人惊奇的应用程序，而不用担心数据绑定、状态或其他复杂的概念。</p><p id="fa83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做的坏处是web开发变得越来越复杂(有人可能会说臃肿)。在您考虑在React中编写一行代码之前，您需要准备好Webpack或package之类的构建工具。别忘了Babel可以为老版本的浏览器移植你的代码。多亏了这个社区，像<code class="fe mk ml mm mn b">create-react-app</code>这样的东西才得以存在，并使项目搭建变得轻而易举。尽管如此，你必须首先安装数百个依赖项，它们并不总是相处得很好。</p><p id="20df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，近年来我注意到了一个变化。许多新的原生ECMAScript特性和API已经问世，网络平台也有了巨大的发展。今天，与5年前相比，我们可以在普通JavaScript上走得更远，而且事情还在继续改善。在本教程中，我们将使用其中一个新特性:<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Web组件</a>。</p><h1 id="cbdb" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">什么是Web组件？</h1><p id="01da" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">Web组件背后的理念与让React或Vue.js如此出名的理念是一样的:整个应用程序的可重用组件。</p><blockquote class="mo"><p id="05fc" class="mp mq iq bd mr ms mt mu mv mw mx la dk translated">“web组件是一套不同的技术，允许您创建可重用的自定义元素(其功能封装在代码的其余部分之外)，并在您的Web应用程序中使用它们。”<br/> - MDN</p></blockquote><p id="2353" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">Web组件是API和技术的集合，如<strong class="kf ir">影子DOM </strong>、<strong class="kf ir">自定义元素</strong>或<strong class="kf ir"> HTML元素</strong>。它们彼此独立，但可以顺畅地协同工作，给开发者带来良好的体验。</p><p id="3535" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程不是对Web组件的介绍，它的目的是给出一个例子，说明如何从头开始实现一个实用的组件。如果你对整个事情都不熟悉，有一个关于CSS上的Web组件的很棒的系列<a class="ae kc" href="https://css-tricks.com/an-introduction-to-web-components/" rel="noopener ugc nofollow" target="_blank">—</a>。如果你仍然对整件事感到困惑，我建议你先读一下。</p><h1 id="a9de" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">搭建项目</h1><p id="b862" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">让我们亲自动手，为这个项目打下基础。振作起来:我们只需要3个文件！</p><ul class=""><li id="0657" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated"><code class="fe mk ml mm mn b">index.html</code></li><li id="7763" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated"><code class="fe mk ml mm mn b">badge-input.js</code></li><li id="1a5c" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated"><code class="fe mk ml mm mn b">styles.css</code></li></ul><p id="4fae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续在一个空文件夹中创建这些文件，您可以将其命名为<code class="fe mk ml mm mn b">chips</code>或任何您喜欢的名称。就是这样。没有<code class="fe mk ml mm mn b">create-react-app</code>，没有<code class="fe mk ml mm mn b">npm install</code>，什么都没有。你上次这么轻松是什么时候？</p><p id="918a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>我们将使用旧浏览器中没有的JavaScript特性。如果你想跟进，确保使用最新的浏览器，如Chrome或Firefox。</p><h1 id="d297" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">HTML标记</h1><p id="f4c7" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">下一步是在我们的<code class="fe mk ml mm mn b">index.html</code>文件中创建HTML标记。这将是非常直接的。我们首先需要基本的框架:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="a03a" class="nv li iq mn b gy nw nx l ny nz">&lt;!DOCTYPE html&gt;</span><span id="18d1" class="nv li iq mn b gy oa nx l ny nz">&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;</span><span id="c54f" class="nv li iq mn b gy oa nx l ny nz">    &lt;title&gt;Email Chips&lt;/title&gt;</span><span id="febc" class="nv li iq mn b gy oa nx l ny nz">    &lt;link rel="stylesheet" href="styles.css"&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;</span><span id="92dd" class="nv li iq mn b gy oa nx l ny nz">    &lt;script src="badge-input.js" defer&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="44b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，一切顺利。如果我们在浏览器中打开它，除了标题之外，什么也不会出现。注意头部<code class="fe mk ml mm mn b">styles.css</code>和身体<code class="fe mk ml mm mn b">badge-input.js</code>的链接。这两个文件当前都是空的。<code class="fe mk ml mm mn b">script</code>标签具有属性<code class="fe mk ml mm mn b">defer</code>，该属性告诉浏览器该文件可以异步加载，因此它提高了加载性能(尽管在这个小项目中很难注意到)。仍然是最佳实践。</p><p id="1a32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将下面的代码片段放在HTML的主体中，就在<code class="fe mk ml mm mn b">script</code>标签之前:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="94b4" class="nv li iq mn b gy nw nx l ny nz">&lt;div class="wrapper"&gt;<br/>  &lt;badge-input&gt;&lt;/badge-input&gt;<br/>&lt;/div&gt;</span></pre><p id="0136" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其实就是这样。继续重新加载浏览器——它仍然是空的。这是因为我们正在“使用”我们的Web组件<code class="fe mk ml mm mn b">badge-input</code>，但是它仍然是<strong class="kf ir">而不是</strong>在任何地方定义的，所以浏览器只是看到了标签并忽略了它。<code class="fe mk ml mm mn b">div</code>仅用于造型目的。</p><h1 id="4ed5" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">基本造型</h1><p id="b698" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">CSS将与之前教程<a class="ae kc" href="https://medium.freecodecamp.org/how-to-create-email-chips-in-pure-react-ad1cc3ecea16" rel="noopener ugc nofollow" target="_blank">中的一样，略有不同。这一次，我们不把我们CSS规则的<strong class="kf ir">全部</strong>放入<code class="fe mk ml mm mn b">styles.css</code>，只放这三个:</a></p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="bb17" class="nv li iq mn b gy nw nx l ny nz">@import url("https://fonts.googleapis.com/css?family=Open+Sans");</span><span id="12b3" class="nv li iq mn b gy oa nx l ny nz">:root {<br/>  color: #565656;<br/>  font-family: "Open Sans", sans-serif;<br/>  font-size: 14px;<br/>  line-height: 1.7;<br/>}</span><span id="d8af" class="nv li iq mn b gy oa nx l ny nz">body {<br/>  background-color: #eaeaea;<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: center;<br/>  height: 100vh;<br/>}</span><span id="336e" class="nv li iq mn b gy oa nx l ny nz">.wrapper {<br/>  background-color: white;<br/>  width: 400px;<br/>  padding: 2rem;<br/>  box-shadow: 0 1.5rem 1rem -1rem rgba(0, 0, 0, .1);<br/>  border-radius: .3rem;<br/>}</span></pre><p id="af1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我之前的React教程中，所有DOM元素(包括输入和芯片)都在同一层，即<a class="ae kc" href="https://stackoverflow.com/questions/42093610/difference-between-light-dom-and-shadow-dom" rel="noopener ugc nofollow" target="_blank"> Light DOM </a>。然而，在本教程中，我们将使用<a class="ae kc" href="https://glazkov.com/2011/01/14/what-the-heck-is-shadow-dom/" rel="noopener ugc nofollow" target="_blank"> Shadow DOM </a>，它作为组件标记的封装。因此，<code class="fe mk ml mm mn b">styles.css</code>中的CSS将无法访问我们组件的标记，使它没有任何样式。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/90626665ad5e2efd9cb99412e12b63c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nk9YVx7fsZqqTje7XPaBfw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">光影。Martino Pietropoli 在<a class="ae kc" href="https://unsplash.com/search/photos/shadow-light?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1d01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“哇，等一下。这是怎么回事？”，看完这一段你可能会问自己。看起来很困惑，对吧？</p><p id="b1d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我再分解一下:传统上，我们有一个叫做<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" rel="noopener ugc nofollow" target="_blank"> DOM </a>的东西，所有的HTML元素都在里面。只有一个DOM，如果你写了任何CSS或者JavaScript，你可以使用<code class="fe mk ml mm mn b">document.getElementById()</code>等等来访问你的元素(比如段落或者标题)。</p><p id="d49d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几年前，DOM的兄弟Shadow DOM被引入web平台。它的工作方式基本上和我们通常的DOM(现在称之为Light DOM，说的是平衡)一样，但是不能使用JavaScript或CSS访问。</p><p id="e9af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设在Shadow DOM中有一个元素<code class="fe mk ml mm mn b">&lt;p id="text"&gt;&lt;/p&gt;</code>。如果你尝试使用<code class="fe mk ml mm mn b">document.getElementById("text")</code>访问它，它将找不到任何东西，甚至我们的CSS也无法对它进行样式化，因为它基本上对我们是隐藏的。就像床下的怪物，我们知道它在那里，却看不见。</p><p id="691d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">"到目前为止一切顺利，但这对我有什么用？"我知道你在问。封装就是答案。你曾经使用过HTML 5的<code class="fe mk ml mm mn b">&lt;video&gt;</code>或者<code class="fe mk ml mm mn b">&lt;audio&gt;</code>元素吗？如果你在你的标记中添加了<code class="fe mk ml mm mn b">&lt;video&gt;</code>标签，然后重新加载，你会看到一个带有样式化控件的视频播放器，但是你没有添加这些，对吗？他们也生活在阴影世界里。你不能设计它们的样式，你不能操纵它们，它们基本上不在你的能力范围内，由浏览器提供。最大的优势是它们不会与你在应用程序中设置的任何风格或逻辑相冲突。这也是我们想要的组件。</p><h1 id="67b5" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Web组件</h1><p id="0dc4" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">现在，让我们进入项目有趣的部分，组件本身。在<code class="fe mk ml mm mn b">badge-input.js</code>里面，我们将从简单的<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">生活</a>开始:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="ed0e" class="nv li iq mn b gy nw nx l ny nz">(function() {<br/>  "use strict";</span><span id="7fc2" class="nv li iq mn b gy oa nx l ny nz">  // Code will be here...</span><span id="6945" class="nv li iq mn b gy oa nx l ny nz">})();</span></pre><p id="d4c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在生活中包装整个事物的原因是<a class="ae kc" href="https://stackoverflow.com/questions/3597087/encapsulation-in-javascript" rel="noopener ugc nofollow" target="_blank">封装</a>。除了Web组件本身，我可能还想定义其他函数或变量，它们不应该污染我的全局名称空间。通过将所有东西包装在一个生命中，我获得了自己的名称空间，并且不必担心应用程序其他部分的副作用。</p><p id="907d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们创建组件的基础:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="b370" class="nv li iq mn b gy nw nx l ny nz">class BadgeInput extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>  }<br/>}</span><span id="388a" class="nv li iq mn b gy oa nx l ny nz">customElements.define("badge-input", BadgeInput);</span></pre><p id="2679" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来有点像React吧？Web组件基本上是扩展<code class="fe mk ml mm mn b">HTMLElement</code>的类，它们可以有属性和方法。像在React中一样，如果你定义了一个构造函数(比如初始化变量)，你需要调用<code class="fe mk ml mm mn b">super()</code>函数来继承<code class="fe mk ml mm mn b">HTMLElement</code>的逻辑和行为。这使得它最终表现得像一个Web组件。</p><p id="50ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你保存并刷新你的浏览器，你仍然不会看到任何东西。不奇怪，因为我们的组件是空的。让我们添加一些标记:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="28e5" class="nv li iq mn b gy nw nx l ny nz">constructor() {<br/>  super();</span><span id="f7d8" class="nv li iq mn b gy oa nx l ny nz">  this._shadow = this.attachShadow({ mode: "open" });<br/>  this._shadow.innerHTML = "&lt;h1&gt;Hello from the Shadows!&lt;/h1&gt;";<br/>}</span></pre><p id="91bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在影子DOM中插入东西，我们需要调用<code class="fe mk ml mm mn b">this.attachShadow({ mode: "open" })</code>。<code class="fe mk ml mm mn b"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow" rel="noopener ugc nofollow" target="_blank">attachShadow</a></code>是我们开箱即用的方法，因为我们的类<code class="fe mk ml mm mn b">BadgeInput</code>扩展了<code class="fe mk ml mm mn b">HTMLElement</code>。</p><p id="13fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">稍后，我们将需要再次访问Shadow DOM，所以我们保存了一个对<code class="fe mk ml mm mn b">this._shadow</code>的引用(如果您愿意，可以用不同的方式命名这个变量)。将<code class="fe mk ml mm mn b">mode</code>设置为<code class="fe mk ml mm mn b">open</code>，这允许JavaScript访问其中的元素。在大多数情况下，你希望它是开放的。</p><p id="0e34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一行，您将看到一个您应该很熟悉的DOM属性:<code class="fe mk ml mm mn b">innerHTML</code>。像在Light DOM中一样，我们可以使用<code class="fe mk ml mm mn b">appendChild</code>、<code class="fe mk ml mm mn b">insertBefore</code>、<code class="fe mk ml mm mn b">textContent</code>和所有其他DOM方法和属性来操作元素。</p><p id="2386" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看浏览器，我们终于可以看到发生了什么，如果你检查源代码，你会注意到我们的<code class="fe mk ml mm mn b">h1</code>标签在影子DOM中:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/54a9362f1dcc3de77a10856b68be08b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*_2Pb_JyiBGM6Q624aB6Bow.png"/></div></figure><p id="2cac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我们不想打印出一个简单的标题，所以再次删除第4行。下一步我们将添加真正的标记。</p><h1 id="8aee" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">使用HTML定义标记<code class="fe mk ml mm mn b">templates</code></h1><p id="d7dd" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在我的<a class="ae kc" href="https://medium.freecodecamp.org/how-to-create-email-chips-in-pure-react-ad1cc3ecea16" rel="noopener ugc nofollow" target="_blank">之前的React教程</a>中，我们使用JSX在组件的<code class="fe mk ml mm mn b">render</code>函数中定义了我们的标记结构。由于这不再是React，我们需要一种不同的方式来构建HTML。</p><p id="08fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就在我们定义<code class="fe mk ml mm mn b">BadgeInput</code>类之前(但仍在生命中)，粘贴以下代码:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="a3c2" class="nv li iq mn b gy nw nx l ny nz">var template = document.createElement("template");<br/>template.innerHTML = `<br/>  &lt;style&gt;<br/>    /* paste the styles here */<br/>  &lt;/style&gt;</span><span id="414b" class="nv li iq mn b gy oa nx l ny nz">  &lt;ul&gt;&lt;/ul&gt;<br/>  &lt;input type="email" placeholder="Type or paste email addresses and press 'Enter'..."&gt;<br/>  &lt;p hidden&gt;&lt;/p&gt;<br/>`;</span></pre><p id="83f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我们在这里做的是创建一个新的<code class="fe mk ml mm mn b"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template" rel="noopener ugc nofollow" target="_blank">template</a></code>元素。然后，我们将<code class="fe mk ml mm mn b">innerHTML</code>设置为我们稍后需要的结构。这几乎与React示例相同。</p><p id="c55e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在第3行定义了一个当前为空的<code class="fe mk ml mm mn b">style</code>块。在这里，我们需要粘贴<code class="fe mk ml mm mn b">styles.css</code>中缺少的CSS规则。请继续操作，并从成品中自己粘贴它们，因为我把它们留了下来，以免不必要地夸大这篇文章。</p><p id="8c9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在我们有了一个带有标记的模板，我们需要在组件中使用它:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="90b9" class="nv li iq mn b gy nw nx l ny nz">constructor() {<br/>  super();</span><span id="1d1f" class="nv li iq mn b gy oa nx l ny nz">  this._shadow = this.attachShadow({ mode: "open" });<br/>  this._shadow.appendChild(template.content.cloneNode(true);<br/>}</span></pre><p id="6751" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">瞧，你应该看到文本字段出现在你的浏览器中。<br/>我们已经使用了<code class="fe mk ml mm mn b">template</code>的<code class="fe mk ml mm mn b">content</code>属性(它是一个<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment" rel="noopener ugc nofollow" target="_blank">文档片段</a>)和<code class="fe mk ml mm mn b"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode" rel="noopener ugc nofollow" target="_blank">cloneNode</a></code>方法将模板的HTML结构的副本附加到组件本身中。<code class="fe mk ml mm mn b">cloneNode</code>接收<code class="fe mk ml mm mn b">true</code>作为参数进行深度克隆，这意味着所有子节点也被克隆。</p><blockquote class="od oe of"><p id="4b71" class="kd ke og kf b kg kh ki kj kk kl km kn oh kp kq kr oi kt ku kv oj kx ky kz la ij bi translated">“但是这个模板是什么东西？”，你可能会问。</p></blockquote><p id="f09b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它用于存储我们的标记，这些标记可以在我们的代码库中重用。与通常的HTML元素相反，默认情况下，它不在浏览器中呈现，这提高了性能。模板的目的就是克隆它们的内容，并在需要的时候和地方重用它们。</p><p id="e61e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以将它添加到我们的<code class="fe mk ml mm mn b">index.html</code>中，而不是用JavaScript以编程方式创建<code class="fe mk ml mm mn b">template</code>:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="20a7" class="nv li iq mn b gy nw nx l ny nz">&lt;template id="badges"&gt;<br/>  &lt;style&gt;<br/>    /* paste the styles here */<br/>  &lt;/style&gt;</span><span id="8795" class="nv li iq mn b gy oa nx l ny nz">  &lt;ul&gt;&lt;/ul&gt;<br/>  &lt;input type="email" placeholder="Type or paste email addresses and press 'Enter'..."&gt;<br/>  &lt;p hidden&gt;&lt;/p&gt;<br/>&lt;/template&gt;</span></pre><p id="efca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以使用<code class="fe mk ml mm mn b">document.getElementById</code>在JavaScript中获得一个引用:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="dc31" class="nv li iq mn b gy nw nx l ny nz">constructor() {<br/>  super();</span><span id="58df" class="nv li iq mn b gy oa nx l ny nz">  var template = document.getElementById("badges");<br/>  <br/>  this._shadow = this.attachShadow({ mode: "open" });<br/>  this._shadow.appendChild(template.content.cloneNode(true);<br/>}</span></pre><p id="29c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对您来说可能看起来更清晰，因为HTML不再是在我们的JavaScript中定义的了。然而，我更喜欢第一种方式，原因如下:</p><ul class=""><li id="935e" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated"><strong class="kf ir">可删除性:</strong>通过将我们的整个组件(即HTML、CSS和JavaScript)保存在一个文件中，它可以很容易地被移动或删除，而不会留下任何死代码。</li><li id="cd23" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated"><strong class="kf ir">组织:</strong>像React或Vue.js一样，将所有代码放在一起会使开发更容易，因为您不必在不同的文件之间切换来做更改或理解它们的逻辑。和这个组件相关的东西都在同一个地方。</li><li id="1ebe" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">干净的HTML页面:如果你只有一个组件，而有很多组件，这可能不适用。如果你把所有的模板放入，比如说<code class="fe mk ml mm mn b">index.html</code>，这个文件将会被模板弄得杂乱无章。可能很难区分浏览器实际呈现的代码和组件使用的代码。</li></ul><p id="00d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于某种原因，模板是Web组件规范的一部分，因为它们使得在组件中重用代码块变得容易。</p><h1 id="0bc8" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">生命周期和事件监听器</h1><p id="a741" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">那么，下一步是什么？与React非常相似，我们需要注册事件，例如当用户按tab键添加新的电子邮件地址时。我们还需要一个数组来保存这些电子邮件地址。让我们向组件实例添加一些属性:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="cf0a" class="nv li iq mn b gy nw nx l ny nz">constructor() {<br/>  super();</span><span id="174a" class="nv li iq mn b gy oa nx l ny nz">  this._shadow = this.attachShadow({ mode: "open" });<br/>  this._shadow.appendChild(template.content.cloneNode(true));</span><span id="ad80" class="nv li iq mn b gy oa nx l ny nz">  this._items = [];<br/>  <br/>  this._input = this._shadow.querySelector("input");<br/>  this._error = this._shadow.querySelector("p");<br/>  this._list = this._shadow.querySelector("ul");<br/>}</span></pre><p id="3235" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们仍然在构造函数中。在第5行下面，您现在可以看到我们有4个新变量(或者说属性):</p><ul class=""><li id="e0b5" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated"><code class="fe mk ml mm mn b">_items</code>将存储我们的电子邮件地址。它被初始化为一个空数组。</li><li id="0e56" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated"><code class="fe mk ml mm mn b">_input</code>是对<code class="fe mk ml mm mn b">input</code>元素的引用，稍后我们将需要为其添加错误类。</li><li id="54e5" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated"><code class="fe mk ml mm mn b">_error</code>再次是对一个DOM元素的引用。我们将需要这个引用来切换错误消息本身。</li><li id="03af" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">最后，<code class="fe mk ml mm mn b">_list</code>是对<code class="fe mk ml mm mn b">ul</code>元素的引用。每次添加或删除电子邮件地址时，我们都会更新。</li></ul><p id="8dee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你注意到我放在变量名前面的<code class="fe mk ml mm mn b">_</code>了吗？这不是强制性的，但被认为是“私有”类属性的一种模式。当然，JavaScript <a class="ae kc" href="https://github.com/tc39/proposal-class-fields#private-fields" rel="noopener ugc nofollow" target="_blank">没有<strong class="kf ir">也没有</strong>像PHP或Java那样有私有/公共</a>属性。尽管如此，我还是用下划线将这些变量标记为私有变量(尽管这不会影响它们的行为或名称空间)。这是一件相当有组织性的事情。</p><p id="bce4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了，我们有了对HTML元素的引用，但是仍然缺少事件侦听器。让我们添加它们:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="4fd3" class="nv li iq mn b gy nw nx l ny nz">constructor() {...}</span><span id="2fa8" class="nv li iq mn b gy oa nx l ny nz">connectedCallback() {<br/>  this._input.addEventListener("keydown", this.handleKeyDown);<br/>  this._input.addEventListener("paste", this.handlePaste);<br/>  this._list.addEventListener("click", this.handleDelete);<br/>}</span><span id="fcf6" class="nv li iq mn b gy oa nx l ny nz">disconnectedCallback() {<br/>  this._input.removeEventListener("keydown", this.handleKeyDown);<br/>  this._input.removeEventListener("paste", this.handlePaste);<br/>  this._list.removeEventListener("click", this.handleDelete);<br/>}</span></pre><p id="bb87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我向组件的类中添加了两个新方法。它们被称为<a class="ae kc" href="https://developers.google.com/web/fundamentals/web-components/customelements#reactions" rel="noopener ugc nofollow" target="_blank">生命周期方法</a>，你可能听起来很熟悉。在React中可以看到相同的概念:<code class="fe mk ml mm mn b">componentDidMount</code>和<code class="fe mk ml mm mn b">componentWillUnmount</code>是框架提供给我们的两个生命周期方法的例子。</p><p id="eaca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与React中完全一样，一旦Web组件连接(或者说:安装)到我们的网站，就会调用<code class="fe mk ml mm mn b">connectedCallback</code>。</p><p id="aae0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mk ml mm mn b">index.html</code>中，我们通过使用<code class="fe mk ml mm mn b">&lt;badge-input&gt;&lt;/badge-input&gt;</code>来“连接”组件。所以一旦浏览器遇到这段代码，它就会实例化我们的类并调用<code class="fe mk ml mm mn b">connectedCallback</code>。</p><p id="750a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe mk ml mm mn b">disconnectedCallback</code>来说也是一样，但是一旦一个Web组件从DOM中被移除，这个就会被调用，例如通过<code class="fe mk ml mm mn b">document.removeChild</code>。很整洁，不是吗？</p><p id="84dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mk ml mm mn b">connectedCallback</code>中，我们注册了三个事件监听器。与React不同，我们需要清理<code class="fe mk ml mm mn b">disconnectedCallback</code>中的事件监听器，以避免内存泄漏。为什么？</p><p id="e8c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下在你的页面上添加和删除许多组件；如果您没有每次都删除事件侦听器，它们可能会继续存在，并通过消耗内存来降低整个应用程序的速度。在React中，这是为你处理的，然而，在这里我们必须自己清理，以保持应用程序的性能和干净。</p><h1 id="6881" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">处理输入</h1><p id="bba9" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">我们的事件监听器是注册的，但是我们还没有任何函数来实际做一些事情。我们来添加第一个，<code class="fe mk ml mm mn b">handleKeyDown</code>:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="99a0" class="nv li iq mn b gy nw nx l ny nz">constructor() {...}</span><span id="f089" class="nv li iq mn b gy oa nx l ny nz">connectedCallback() {...}</span><span id="ee31" class="nv li iq mn b gy oa nx l ny nz">disconnectedCallback() {...}</span><span id="4506" class="nv li iq mn b gy oa nx l ny nz">handleKeyDown = (evt) =&gt; {<br/>  if (TRIGGER_KEYS.includes(evt.key)) {<br/>    evt.preventDefault();</span><span id="c098" class="nv li iq mn b gy oa nx l ny nz">    var value = evt.target.value.trim();</span><span id="56b2" class="nv li iq mn b gy oa nx l ny nz">    if (value &amp;&amp; this.validate(value)) {<br/>      evt.target.value = "";</span><span id="1297" class="nv li iq mn b gy oa nx l ny nz">      this._items.push(value);<br/>      this.update();<br/>    }<br/>  }<br/>};</span></pre><p id="c55d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你首先会注意到的是<code class="fe mk ml mm mn b">TRIGGER_KEYS</code>，我们还没有定义它。</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="c4ff" class="nv li iq mn b gy nw nx l ny nz">const TRIGGER_KEYS = ["Enter", "Tab", ","];</span></pre><p id="98ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我把这个代码放在生命的顶端，但是你可以选择任何其他的位置。然而，我建议将它放在IIFE中，因为它是我们组件的一部分，不应该污染全局名称空间。</p><p id="8ae5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果按下的键是<em class="og"> Enter、Tab键</em>或逗号，我们将在第5行获得输入值，并在第7行执行验证。<code class="fe mk ml mm mn b">this.validate()</code>还不存在，所以我们来补充一下:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="7711" class="nv li iq mn b gy nw nx l ny nz">validate(email) {<br/>  var error = null;</span><span id="7d19" class="nv li iq mn b gy oa nx l ny nz">  if (this.isInList(email)) {<br/>    error = `${email} has already been added.`;<br/>  }</span><span id="3944" class="nv li iq mn b gy oa nx l ny nz">  if (!this.isEmail(email)) {<br/>    error = `${email} is not a valid email address.`;<br/>  }</span><span id="b265" class="nv li iq mn b gy oa nx l ny nz">  if (error) {<br/>    this._error.textContent = error;<br/>    this._error.removeAttribute("hidden");<br/>    this._input.classList.add("has-error");</span><span id="4750" class="nv li iq mn b gy oa nx l ny nz">    return false;<br/>  }</span><span id="9d78" class="nv li iq mn b gy oa nx l ny nz">  return true;<br/>}</span><span id="4885" class="nv li iq mn b gy oa nx l ny nz">isInList(email) {<br/>  return this._items.includes(email);<br/>}</span><span id="df3d" class="nv li iq mn b gy oa nx l ny nz">isEmail(email) {<br/>  return /[\w\d\.-]+@[\w\d\.-]+\.[\w\d\.-]+/.test(email);<br/>}</span></pre><p id="fe8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有错误，我们将使用我们的<code class="fe mk ml mm mn b">this._error</code>引用来设置错误消息和可见性。此外，输入字段(<code class="fe mk ml mm mn b">this._input</code>)将获得一个添加红色边框的类。</p><p id="b202" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到<code class="fe mk ml mm mn b">handleKeyDown</code>，一旦验证通过(与我之前的React教程相同)，我们将输入的值重置为空字符串，并将电子邮件地址添加到<code class="fe mk ml mm mn b">this._items</code>。最后一步是重新呈现我们的组件，在输入的顶部显示更新的电子邮件列表。</p><p id="9ce8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是<code class="fe mk ml mm mn b">this.update()</code>的作用:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="c26f" class="nv li iq mn b gy nw nx l ny nz">update() {<br/>  this._list.innerHTML = this._items<br/>    .map(function(item) {<br/>      return `<br/>      &lt;li&gt;<br/>        ${item}<br/>        &lt;button type="button" data-value="${item}"&gt;&amp;times;&lt;/button&gt;<br/>     &lt;/li&gt;<br/>     `;<br/>   }).join("");<br/>}</span></pre><p id="fcb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是<em class="og">数据驱动的，</em>意味着UI是基于状态和道具呈现的。在JSX，通过允许我们使用条件、循环等等来控制什么元素在什么状态下应该是可见的，这变得非常简单。</p><p id="e51d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，使用Web组件，我们没有JSX那样的奢侈，尽管我们试图实现同样的事情。相反，我们使用更传统的DOM操作方法，正如您在上面的方法中看到的。</p><p id="8595" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次调用<code class="fe mk ml mm mn b">this.update</code>时，我们都会覆盖<code class="fe mk ml mm mn b">ul</code>中的整个HTML(如果您还记得，我们在模板中定义了它)。使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板文字</a>，我们可以很容易地将数据“注入”到HTML中，最后使用<code class="fe mk ml mm mn b">innerHTML</code>追加数据。</p><p id="a9b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结尾的<code class="fe mk ml mm mn b">.join("")</code>很重要，因为<code class="fe mk ml mm mn b"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">.map()</a></code>返回一个数组，而我们不能用数组来使用<code class="fe mk ml mm mn b">innerHTML</code>，只能用字符串。<code class="fe mk ml mm mn b">.join("")</code>获取数组中的所有项，将它们连接在一起(不用任何东西分隔，因此称为<code class="fe mk ml mm mn b">""</code>)并返回一个字符串。</p><p id="ff0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以重新加载你的浏览器并检查它，它应该工作正常。然而，有一个小小的错误:错误状态不会被重置，这意味着如果你输入一个无效的电子邮件，错误将会显示并永远存在。</p><p id="6bad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在我们的<code class="fe mk ml mm mn b">handleKeyDown</code>方法中解决这个问题:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="6545" class="nv li iq mn b gy nw nx l ny nz">handleKeyDown = (evt) =&gt; {<br/>  this._error.setAttribute("hidden", true);<br/>  this._input.classList.remove("has-error");</span><span id="de5c" class="nv li iq mn b gy oa nx l ny nz">  // ...<br/>}</span></pre><p id="7873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次按键时，这个方法都会隐藏我们的错误元素，并从输入中删除相关的类。这工作得很好！</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/9790350a2185c93695bd759d196da6f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/1*TgZSiK9ct6obXTGWytlkLA.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">到目前为止，情况看起来不错。</figcaption></figure><p id="520d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，现在深呼吸，放松，看看你已经走了多远。只少了两个功能:删除和粘贴邮件。</p><h1 id="b4e2" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">删除电子邮件</h1><p id="bf0c" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">删除电子邮件芯片的逻辑与React示例非常相似:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="aecf" class="nv li iq mn b gy nw nx l ny nz">handleDelete = (evt) =&gt; {<br/>  if (evt.target.tagName === "BUTTON") {<br/>    this._items = this._items.filter(<br/>      item =&gt; item !== evt.target.dataset.value<br/>    );</span><span id="ae47" class="nv li iq mn b gy oa nx l ny nz">    this.update();<br/>  }<br/>};</span></pre><p id="d0b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这么简单。由于我们所有的电子邮件都存储在<code class="fe mk ml mm mn b">this._items</code>中，我们可以轻松地<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">通过它过滤</a>并删除已删除的电子邮件。<br/> <code class="fe mk ml mm mn b">evt.target.dataset.value</code>会包含我们想要处理掉的邮件。</p><p id="9c36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得两分钟前我给你展示的<code class="fe mk ml mm mn b">update</code>方法吗？在这里，我们定义了一个删除按钮:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="7f06" class="nv li iq mn b gy nw nx l ny nz">&lt;button type="button" data-value="${item}"&gt;&amp;times;&lt;/button&gt;</span></pre><p id="25f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这个原因，<code class="fe mk ml mm mn b">data-value</code>将始终是电子邮件地址，因此我们可以很容易地在<code class="fe mk ml mm mn b">handleDelete</code>中使用这个值。<code class="fe mk ml mm mn b">evt.target</code>是指按钮本身。但是等等！<em class="og">“那第二行这个奇怪的if条件呢？”</em>，我听到你问。<em class="og">“我们也没有为按钮设置任何事件监听器，那么这到底是怎么做到的呢？?"</em></p><p id="819b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你也想知道这个，给自己一个标签。</p><p id="e960" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用一种叫做<a class="ae kc" href="https://medium.com/@bretdoucette/part-4-what-is-event-delegation-in-javascript-f5c8c0de2983" rel="noopener">事件委托</a>的东西。事实上，按钮上没有事件监听器(永远也不会有)，而是在<code class="fe mk ml mm mn b">ul</code>上。还记得生命周期回调，更确切地说是<code class="fe mk ml mm mn b">connectedCallback</code>吗？</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="228d" class="nv li iq mn b gy nw nx l ny nz">this._list.addEventListener("click", this.handleDelete);</span></pre><p id="ea67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">神奇的是。我们的<code class="fe mk ml mm mn b">ul</code>接收事件监听器，所以我们可以点击中的所有<em class="og">来触发这个事件。里面有电子邮件文本和每个项目的按钮。可以点击按钮，触发事件处理程序。但是我们也可以点击文本，它将触发完全相同的处理程序<code class="fe mk ml mm mn b">handleDelete</code>。</em></p><p id="c8c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我们不希望这样。只有当用户单击按钮时，才会触发删除。这就是这个奇怪的if条件的作用。它检查被点击的元素是否确实是按钮(<code class="fe mk ml mm mn b">event.target.tagName</code>)，然后才运行逻辑。</p><h1 id="4320" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">粘贴电子邮件</h1><p id="21df" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">我们终于到了最后一步，只差一个特性:粘贴电子邮件地址。代码如下:</p><pre class="lb lc ld le gt nr mn ns nt aw nu bi"><span id="3471" class="nv li iq mn b gy nw nx l ny nz">handlePaste = evt =&gt; {<br/>  evt.preventDefault();<br/>  <br/>  var paste = evt.clipboardData.getData("text");<br/>  var emails = paste.match(/[\w\d\.-]+@[\w\d\.-]+\.[\w\d\.-]+/g);</span><span id="9c64" class="nv li iq mn b gy oa nx l ny nz">  if (emails) {<br/>    var toBeAdded = emails.filter(email =&gt; !this.isInList(email));</span><span id="062f" class="nv li iq mn b gy oa nx l ny nz">    this._items = [...this._items, ...toBeAdded];<br/>    this.update();<br/>  }<br/>};</span></pre><p id="37c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码与React中的代码非常相似。</p><ol class=""><li id="d021" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ol nj nk nl bi translated">我们首先防止第2行的默认浏览器行为，即输入中的复制文本。</li><li id="f6cd" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ol nj nk nl bi translated">我们将第4行的剪贴板内容作为一个字符串。</li><li id="61fd" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ol nj nk nl bi translated">使用一个正则表达式和<code class="fe mk ml mm mn b"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match" rel="noopener ugc nofollow" target="_blank">match()</a></code>，我们从字符串中提取所有有效的电子邮件到数组<code class="fe mk ml mm mn b">emails</code>。</li><li id="438f" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ol nj nk nl bi translated">如果数组中有任何电子邮件，我们运行一个过滤函数，只获取不在我们的<code class="fe mk ml mm mn b">this._items</code>数组中的电子邮件。</li><li id="37e8" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ol nj nk nl bi translated">然后我们将<code class="fe mk ml mm mn b">this._items</code>与第10行的新条目合并。</li><li id="f1cd" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ol nj nk nl bi translated">最后一步是再次重新呈现列表，以便我们新粘贴的电子邮件可见。</li></ol><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d66e1ec96905625d48ebb9752cc9b53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/1*4ZVyEBp_G9OL1dyoNERBQQ.gif"/></div></figure><h1 id="b586" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="a857" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在这里，我们刚刚将一个React组件转换为一个Web组件，没有任何构建过程或依赖关系。普通的旧JavaScript，被最新的API和标准所丰富。下面是最终结果:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的最终结果看起来和行为完全像我们在React中构建的结果。</figcaption></figure><p id="f991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的目标是向您展示从头构建一个实用的Web组件是多么容易。当然，我们还没有涵盖所有的内容，更多的主题还在前面，等待我们去发现:</p><ul class=""><li id="7bf0" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated"><a class="ae kc" href="https://developers.google.com/web/fundamentals/web-components/customelements#properties_and_attributes" rel="noopener ugc nofollow" target="_blank">属性和属性</a>将数据传递到Web组件中。</li><li id="e9ae" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">真正的数据绑定，使用<a class="ae kc" href="https://lit-html.polymer-project.org/" rel="noopener ugc nofollow" target="_blank">库</a>或JavaScript <a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理对象</a>。</li><li id="4f52" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">使用<a class="ae kc" href="https://developers.google.com/web/updates/2019/02/constructable-stylesheets" rel="noopener ugc nofollow" target="_blank">可构造的样式表</a>轻松应用全局CSS，而不必对抗光影DOM之间的边界。</li><li id="13a4" class="nd ne iq kf b kg nm kk nn ko no ks np kw nq la ni nj nk nl bi translated">组件之间的交互，就像在React中一样。在整个应用程序中共享状态。</li></ul><p id="2c01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这个教程，随时告诉我你的建议或反馈。编码快乐！</p></div></div>    
</body>
</html>