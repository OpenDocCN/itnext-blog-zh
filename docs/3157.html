<html>
<head>
<title>Completing the circle (K8s)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完成循环(K8s)</h1>
<blockquote>原文：<a href="https://itnext.io/completing-the-kubernetes-setup-7462383ab3c?source=collection_archive---------7-----------------------#2019-10-13">https://itnext.io/completing-the-kubernetes-setup-7462383ab3c?source=collection_archive---------7-----------------------#2019-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e7be" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过一些额外的附加组件使Kubernetes集群发挥作用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/30661624e6714d8ee1d9c0f18b5725b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJ6nQZWE085xF9Xl5GKGCQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">JR Korpa 在<a class="ae kv" href="https://unsplash.com/s/photos/monitoring?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1622" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上一篇文章中，我解释了如何设置HA K8s集群。</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/@anisinanaj/on-premise-ha-kubernetes-cluster-15e41f18bd12" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">内部HA Kubernetes集群</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">那么为什么是9台服务器呢？到目前为止，我们可以把构成星团的部分分成3个部分。我们有存储，控制…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><p id="a6c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这只是Kubernetes的裸装。</p><h1 id="1b23" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">少了什么</h1><p id="2309" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">设置好集群后，除了K8s，上面不会有太多。为了让它工作，我们需要部署一些额外的应用程序。</p><h2 id="0eb9" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">CNI(集装箱网络接口)</h2><p id="b651" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">第一个也是最重要的一个是CNI。我们将Kubernetes配置为使用法兰绒，所以现在我们必须将它添加到集群中，否则什么都不会起作用。事实上，检查节点将导致“未就绪”。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="0b46" class="nh ml iq nu b gy ny nz l oa ob">kubectl get nodes -o wide</span></pre><p id="956d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加法兰绒的命令非常简单。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="3576" class="nh ml iq nu b gy ny nz l oa ob">kubectl apply -f <a class="ae kv" href="https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</a></span></pre><blockquote class="oc od oe"><p id="b2ee" class="kw kx of ky b kz la jr lb lc ld ju le og lg lh li oh lk ll lm oi lo lp lq lr ij bi translated">要从您自己的计算机使用<code class="fe oj ok ol nu b"><em class="iq">kubectl</em></code>，请从第一个控制平面将<em class="iq">/etc/kubernetes/admin . conf</em>复制到<em class="iq"> ~/。kube/配置</em></p></blockquote><h2 id="9913" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">集装箱存储接口</h2><p id="8c52" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">现在我们已经配置了网络，我们可以添加存储资源调配器了。</p><p id="5dd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/@anisinanaj/on-premise-ha-kubernetes-cluster-15e41f18bd12" rel="noopener">上一篇文章</a>中，我假设有一个Ceph集群，因此我将为此部署provisioners，记住它已经为K8s进行了配置。</p><p id="9691" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将从克隆存储扩展的官方存储库开始。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="912d" class="nh ml iq nu b gy ny nz l oa ob">git clone git@github.com:kubernetes-incubator/external-storage.git</span></pre><p id="c986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将重点关注<em class="of"> ceph </em>文件夹，其中有两个不同的资源调配器，一个用于RBD，代表数据块存储，另一个是FS，只是iSCSI。</p><p id="fe00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢两者都有，因为它们以不同的方式工作，并且在不同的情况下都很有用。</p><p id="9756" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> RBD <br/> </strong>首先要做的是创建两个秘密资源，它们将保存访问Ceph集群的密钥。文件已经存在，我们只需要填写<code class="fe oj ok ol nu b">./ceph/rbd/examples/secrets.yaml</code>中的信息</p><p id="b62b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该文件应该如下所示。默认情况下，名称空间是<code class="fe oj ok ol nu b">kube-system</code>，但是我把它改成了<code class="fe oj ok ol nu b">storage</code>，如果你按照我的例子做，请确保也改变了<code class="fe oj ok ol nu b">./ceph/rbd/deploy/rbac/rolebinding.yaml</code>和<code class="fe oj ok ol nu b">./ceph/rbd/deploy/rbac/clusterrolebinding.yaml</code>上的名称空间</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="1200" class="nh ml iq nu b gy ny nz l oa ob">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: ceph-admin-secret<br/>  namespace: <strong class="nu ir">storage</strong><br/>type: "kubernetes.io/rbd"<br/>data:<br/>  key: <strong class="nu ir">QVFDMHFJWmNSay9ZSnhBQXlhSFhTOFo5a3hKODE1ZUdQWVRYYmc9PQ==</strong><br/>---<br/>apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: ceph-secret<br/>  namespace: <strong class="nu ir">storage</strong><br/>type: "kubernetes.io/rbd"<br/>data:<br/>  key: <strong class="nu ir">QVFCakxMNWNlcUI4QmhBQTd2UUNDNFNSaTk0ZDgvMTNXOUdMemc9PQ==</strong></span></pre><p id="cd94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要从Ceph集群获取密钥，请在它的一个节点上运行这些命令。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="86da" class="nh ml iq nu b gy ny nz l oa ob">ceph auth get-key client.admin | base64</span><span id="1429" class="nh ml iq nu b gy om nz l oa ob">ceph auth add client.kube mon 'allow r' osd 'allow rwx pool=kube'<br/>ceph auth get-key client.kube | base64</span></pre><p id="7c2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后要编辑的是<code class="fe oj ok ol nu b">./ceph/examples/class.yaml</code>，应该是下图这样。在监视器下设置您的Ceph集群IP地址，并引用上面创建的秘密。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="8a26" class="nh ml iq nu b gy ny nz l oa ob">kind: StorageClass<br/>apiVersion: storage.k8s.io/v1<br/>metadata:<br/>  name: rbd<br/>provisioner: ceph.com/rbd<br/>parameters:<br/>  monitors: <strong class="nu ir">116.202.35.140:6789,116.202.35.141:6789,116.202.35.142:6789</strong><br/>  pool: <strong class="nu ir">kube</strong><br/>  adminId: admin<br/>  adminSecretNamespace: <strong class="nu ir">storage</strong><br/>  adminSecretName: <strong class="nu ir">ceph-admin-secret</strong><br/>  userId: kube<br/>  userSecretNamespace: <strong class="nu ir">storage</strong><br/>  userSecretName: <strong class="nu ir">ceph-secret</strong><br/>  imageFormat: "2"<br/>  imageFeatures: layering</span></pre><p id="b241" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要将配置文件应用到集群。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="7227" class="nh ml iq nu b gy ny nz l oa ob">kubectl apply -f ./ceph/deploy/rbac<br/>kubectl apply -f ./ceph/examples/secrets.yaml<br/>kubectl apply -f ./ceph/examples/class.yaml</span></pre><p id="dae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用示例下的<code class="fe oj ok ol nu b">claim.yaml</code>和<code class="fe oj ok ol nu b">test-pod.yaml</code>文件来测试RBD。</p><p id="a139" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> CephFS <br/> </strong>现在设置CephFS的步骤是相似的。首先，我们将创建这个秘密，或者使用上面创建的秘密，并将其复制到<code class="fe oj ok ol nu b">cephfs</code>名称空间中。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="1862" class="nh ml iq nu b gy ny nz l oa ob">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: ceph-admin-secret<br/>  namespace: <strong class="nu ir">cephfs</strong><br/>type: "kubernetes.io/rbd"<br/>data:<br/>  key: <strong class="nu ir">QVFDMHFJWmNSay9ZSnhBQXlhSFhTOFo5a3hKODE1ZUdQWVRYYmc9PQ==</strong></span></pre><p id="cce6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于CephFS，admin-secret是唯一需要的。</p><p id="ee41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在来创建角色并应用这个秘密。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="ad31" class="nh ml iq nu b gy ny nz l oa ob">kubectl apply -f ./cephfs/deploy/rbac<br/>kubectl apply -f ./cephfs/example/secret.yaml</span></pre><p id="b962" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后要编辑的是在<code class="fe oj ok ol nu b">./cephfs/example/class.yaml</code>中找到的存储类配置，方法是将正确的IP地址添加到Ceph集群中，并引用上面创建的秘密。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="9856" class="nh ml iq nu b gy ny nz l oa ob">kind: StorageClass<br/>apiVersion: storage.k8s.io/v1<br/>metadata:<br/>  name: cephfs<br/>provisioner: ceph.com/cephfs<br/>parameters:<br/>    monitors: <strong class="nu ir">116.202.35.140:6789,116.202.35.141:6789,116.202.35.142:6789</strong><br/>    adminId: <strong class="nu ir">admin</strong><br/>    adminSecretName: <strong class="nu ir">ceph-secret-admin</strong><br/>    adminSecretNamespace: <strong class="nu ir">cephfs</strong><br/>    claimRoot: /pvc-volumes</span></pre><p id="8844" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们就可以应用它了。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="d836" class="nh ml iq nu b gy ny nz l oa ob">kubectl apply -f ./cephfs/example/class.yaml</span></pre><p id="12d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。</p><h2 id="dffb" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">入口和证书管理器</h2><p id="e237" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">开箱即用，K8s集群不处理HTTP(s)请求。我们需要配置一个<em class="of">反向代理</em>和/或<em class="of">负载平衡器</em>。这些资源被称为<em class="of">入口控制器</em>。</p><p id="402e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">入口控制器的工作是根据相关的入口规则将流量路由到所需的Pod。</p><p id="23bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有不同的解决方案可用作入口控制器，<a class="ae kv" href="https://www.nginx.com/products/nginx/kubernetes-ingress-controller" rel="noopener ugc nofollow" target="_blank"> Nginx </a>，<a class="ae kv" href="https://github.com/haproxytech/kubernetes-ingress" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>，<a class="ae kv" href="https://istio.io/docs/tasks/traffic-management/ingress/" rel="noopener ugc nofollow" target="_blank"> Istio </a>，<a class="ae kv" href="https://github.com/containous/traefik" rel="noopener ugc nofollow" target="_blank"> Traefik </a>。Traefik附带了Let's Encrypt incorporated。您也可以使用多个控制器。</p><p id="0163" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Nginx <br/> </strong>我是Nginx的粉丝，所以我要跟它走。按照以下步骤安装Nginx</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="0f2f" class="nh ml iq nu b gy ny nz l oa ob">helm install stable/nginx-ingress --name nginx-ingress-controller</span></pre><p id="36e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在部署一个示例项目来检查入口控制器是否在工作</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="f2ae" class="nh ml iq nu b gy ny nz l oa ob">kubectl apply -f <a class="ae kv" href="https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/deployment.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/deployment.yaml</a></span><span id="cd39" class="nh ml iq nu b gy om nz l oa ob">kubectl apply -f <a class="ae kv" href="https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/service.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/service.yaml</a></span></pre><p id="bfd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将为上述内容部署入口，记住将主机名编辑为我们自己的主机名。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="e415" class="nh ml iq nu b gy ny nz l oa ob">kubectl create --edit -f <a class="ae kv" href="https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/ingress.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/ingress.yaml</a></span></pre><p id="b20b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在转到这个领域，您应该会看到<strong class="ky ir"> Kuard </strong>。</p><blockquote class="oc od oe"><p id="6475" class="kw kx of ky b kz la jr lb lc ld ju le og lg lh li oh lk ll lm oi lo lp lq lr ij bi translated">如果你在使它工作上有困难，那可能是因为入口控制器不知道它是否有可用的公共IP以及如何使用它们。尝试将“外部IP”添加到包含集群所有公共IP阵列的入口控制器中。MetalLB会自动处理这些问题。</p></blockquote><p id="4476" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Let's Encrypt <br/> </strong>据我所知，Kubernetes使用最多的Let's Encrypt实现是<a class="ae kv" href="https://docs.cert-manager.io/en/latest/getting-started/install/kubernetes.html#installing-with-helm" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> cert-manager </strong> </a>。</p><p id="de64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它由<a class="ae kv" href="https://www.jetstack.io" rel="noopener ugc nofollow" target="_blank"> JetStack </a>维护和开发。该安装在许多网站和<a class="ae kv" href="https://github.com/jetstack/cert-manager" rel="noopener ugc nofollow" target="_blank"> Github </a>上被广泛记录。</p><p id="d326" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先要做的是创建自定义资源定义。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="5696" class="nh ml iq nu b gy ny nz l oa ob">kubectl apply -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.9/deploy/manifests/00-crds.yaml</span></pre><p id="954b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们将创建一个专用的名称空间。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="4f06" class="nh ml iq nu b gy ny nz l oa ob">kubectl create namespace cert-manager</span></pre><p id="59d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下命令将禁用资源验证。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="4f7e" class="nh ml iq nu b gy ny nz l oa ob">kubectl label namespace cert-manager certmanager.k8s.io/disable-validation=true</span></pre><p id="fca9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后安装它，我们需要添加Helm repo并继续安装。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="3e18" class="nh ml iq nu b gy ny nz l oa ob">helm repo add jetstack <a class="ae kv" href="https://charts.jetstack.io" rel="noopener ugc nofollow" target="_blank">https://charts.jetstack.io</a><br/>helm repo update<br/>helm install \<br/>  --name cert-manager \<br/>  --namespace cert-manager \<br/>  --version v0.9.1 \<br/>  jetstack/cert-manager</span></pre><p id="7db1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要创建2个证书颁发者，一个用于暂存，一个用于生产。唯一需要更新的是邮件。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="618c" class="nh ml iq nu b gy ny nz l oa ob">kubectl create --edit -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/staging-issuer.yaml</span><span id="6e09" class="nh ml iq nu b gy om nz l oa ob">kubectl create --edit -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/production-issuer.yaml</span></pre><p id="1f60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这应该给我们一个工作环境。</p><p id="67c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了让我们的<strong class="ky ir"> Kuard </strong>例子使用Let's Encrypt，我们应该重新部署它的<strong class="ky ir">入口</strong>。下面的文件包含配置中的<code class="fe oj ok ol nu b">tls</code>键，它指定了证书应该工作的域。还要注意决定使用哪个发行者的注释。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="b4b3" class="nh ml iq nu b gy ny nz l oa ob">kubectl create --edit -f <a class="ae kv" href="https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/ingress-tls-final.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/ingress-tls-final.yaml</a></span></pre><h2 id="938f" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">包管理器</h2><p id="e3af" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">幸运的是，Kubernetes世界已经发展到有了一个包管理器。事实上，<a class="ae kv" href="https://helm.sh" rel="noopener ugc nofollow" target="_blank"> Helm </a>正是如此，设置起来非常简单直接。</p><p id="2e85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的系统上安装<code class="fe oj ok ol nu b">helm</code></p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="4079" class="nh ml iq nu b gy ny nz l oa ob">brew install kubernetes-helm</span></pre><p id="373f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过创建并应用该文件，授予它访问群集的权限</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="9673" class="nh ml iq nu b gy ny nz l oa ob">apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>  name: tiller<br/>  namespace: kube-system<br/>---<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>kind: ClusterRoleBinding<br/>metadata:<br/>  name: tiller<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: ClusterRole<br/>  name: cluster-admin<br/>subjects:<br/>  - kind: ServiceAccount<br/>    name: tiller<br/>    namespace: kube-system</span></pre><p id="88c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们称之为<em class="of"> rbac-config.yml </em></p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="c6c2" class="nh ml iq nu b gy ny nz l oa ob">kubectl create -f rbac-config.yaml<br/>helm init --service-account tiller --history-max 200</span></pre><p id="2e97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以走了！</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><h1 id="ed6e" class="mk ml iq bd mm mn ou mp mq mr ov mt mu jw ow jx mw jz ox ka my kc oy kd na nb bi translated">问题</h1><h2 id="3adb" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">Resolve.conf</h2><p id="6033" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">有时，根据云提供商的不同，你的<code class="fe oj ok ol nu b">resolve.conf</code>文件可能有3条以上的记录。这可能是一个问题，因为在这种情况下，<strong class="ky ir"> kube-dns </strong>和<strong class="ky ir"> coredns </strong>都无法解析域名。这不是这两个服务本身的问题，但它与Linux的libc有关，正如这里所说的<a class="ae kv" href="https://kubernetes.io/docs/tasks/administer-cluster/dns-debugging-resolution/#known-issues" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="7619" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">限制</h2><p id="0bda" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">创建本地集群有不同的限制，首先是可伸缩性。扩展这些服务器要困难得多，您必须购买硬件或额外的节点等等。</p><p id="3da6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着可扩展性而来的是<strong class="ky ir">成本</strong>，因为你有物理机器，你不能按需缩减。这意味着即使您只使用了基础设施的一小部分，您也要为整个基础设施付费。</p><p id="5f73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">负载均衡</strong>是另一个极限。配置MetalLB或类似的东西并不总是可行的。它可以在实际的K8s节点上配置，但是这会增加网络和集群本身的开销。如果要在K8s群集之外进行管理(就像我们对存储所做的那样)，我们至少还需要3台服务器来保持高可用性。对于控制平面请求和应用请求，需要分别在控制平面和工作节点上进行负载平衡。解决这个问题的另一种方法是使用DNS级别的负载均衡器，它可以工作，但是没有那么快。</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><h1 id="31d6" class="mk ml iq bd mm mn ou mp mq mr ov mt mu jw ow jx mw jz ox ka my kc oy kd na nb bi translated">监控和管理</h1><p id="cb70" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这里有很多部分，事情可能会失败。这就是为什么我们需要持续监控系统，以便在出现问题时快速采取行动。除了监控工具，我们还需要让自己更容易管理一切。</p><h2 id="3e92" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">舵</h2><p id="7ac4" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">帮助我们安装和更新完成群集所需的工具和软件。</p><p id="0d31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述进行安装。</p><h2 id="fdad" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">大牧场主</h2><p id="c75e" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated"><a class="ae kv" href="https://rancher.com/products/rancher" rel="noopener ugc nofollow" target="_blank"> Rancher </a>是在同一个地方管理一个或多个Kubernetes集群的工具。</p><p id="fd97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可以安装在任何地方，不一定要安装在集群上。如果您在群集上安装它，它会识别它，并进行自我配置，使您可以管理该群集。</p><p id="3465" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以像下面这样把它安装成docker容器</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="51d5" class="nh ml iq nu b gy ny nz l oa ob">docker run -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher</span></pre><p id="9a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者在K8s集群上安装它。更新主机名和电子邮件，以便正确创建证书。(这假设您正在使用证书管理器)</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="b8f3" class="nh ml iq nu b gy ny nz l oa ob">helm repo add rancher-latest <a class="ae kv" href="https://releases.rancher.com/server-charts/latest" rel="noopener ugc nofollow" target="_blank">https://releases.rancher.com/server-charts/latest</a></span><span id="5907" class="nh ml iq nu b gy om nz l oa ob">helm install rancher-latest/rancher \<br/>  --name rancher \<br/>  --namespace cattle-system \<br/>  --set hostname=rancher.my.org \<br/>  --set ingress.tls.source=letsEncrypt \<br/>  --set letsEncrypt.email=me@example.org</span></pre><p id="5351" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">部署完成后你就可以走了。</p><h2 id="972a" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">普罗米修斯/格拉法纳</h2><p id="0595" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">现在我们有了牧场主，我们可以安装普罗米修斯和格拉夫纳。这两种工具都可以监控群集的硬件资源，并且可以配置为在出现问题时发送警报。</p><p id="b492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些也可以通过头盔安装。这正是牧场主所做的。它内置了Helm，因此我们可以在通过Rancher管理的所有集群上安装软件包。</p><p id="1f83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过Rancher部署它们，将指标集成到Rancher的面板中。</p><h2 id="6efb" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">发信号</h2><p id="f61f" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">从集群进行监控和警报是好的，但这还不够。如果由于某种原因，整个集群不可访问，可能是巨大的网络故障，会发生什么？因此，我们也需要外部监控。</p><p id="2830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我使用了<a class="ae kv" href="https://nodequery.com" rel="noopener ugc nofollow" target="_blank">节点查询</a>和<a class="ae kv" href="http://statuscake.com" rel="noopener ugc nofollow" target="_blank">状态蛋糕</a>。在监控服务器资源方面，两者是相似的。您在主机中安装一个代理，它会定期发送系统状态。</p><p id="8304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Status Cake还可以用于ping不同的服务，并将其配置为在它们没有响应时发送警报。可以配置各种错误，40x、50x等，以及<em class="of">超时</em>。</p><h2 id="ec70" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">管理</h2><p id="7187" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">其他值得注意的管理工具当然是<a class="ae kv" href="https://github.com/kubernetes/dashboard" rel="noopener ugc nofollow" target="_blank"> Kubernetes仪表盘</a>和<a class="ae kv" href="https://k9ss.io" rel="noopener ugc nofollow" target="_blank"> K9s </a></p><p id="b5f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要安装<strong class="ky ir">仪表板</strong>，请将其配置应用到集群，然后创建凭证，如下所示</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="9dab" class="nh ml iq nu b gy ny nz l oa ob">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><span id="4012" class="nh ml iq nu b gy om nz l oa ob">kubectl create clusterrolebinding kubernetes-dashboard \<br/>  --clusterrole=cluster-admin \<br/>  --serviceaccount=kube-system:kubernetes-dashboard</span></pre><p id="0717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用它，首先要获得访问令牌</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="15c5" class="nh ml iq nu b gy ny nz l oa ob">kubectl get secrets --namespace kube-system <strong class="nu ir">#to find how it's called</strong></span><span id="ad25" class="nh ml iq nu b gy om nz l oa ob">kubectl describe secrets --namespace kube-system <strong class="nu ir">kubernetes-<br/>dashboard-token-9gz66</strong></span></pre><p id="fa92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为默认情况下它不会通过入口暴露，所以您可以只使用<code class="fe oj ok ol nu b">kubectl proxy</code>然后打开这个<a class="ae kv" href="http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=default" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="43d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">K9s 安装非常简单，在Mac上如下</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="9a69" class="nh ml iq nu b gy ny nz l oa ob">brew install derailed/k9s/k9s</span></pre><p id="6850" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用它，只需从终端运行<code class="fe oj ok ol nu b">k9s</code>。</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="63a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系列文章</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/@anisinanaj/on-premise-ha-kubernetes-cluster-15e41f18bd12" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">本地HA Kubernetes集群</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在建立生产Kubernetes集群时克服基础设施限制</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="oz l mg mh mi me mj kp lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://medium.com/@anisinanaj/storage-on-kubernetes-efa0a5b4f858" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Kubernetes上的存储</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">了解存储在分布式系统和Kubernetes中的工作原理。内部存储解决方案</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="pa l mg mh mi me mj kp lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://medium.com/@anisinanaj/kubernetes-cluster-networking-ad77eb4f826b" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Kubernetes集群网络</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">构建本地K8s和Ceph集群时处理网络的方法</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="pb l mg mh mi me mj kp lv"/></div></div></a></div></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="5f76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望我涵盖了一切。感谢你有耐心读到这里。<br/>敬请关注更多:)</p></div></div>    
</body>
</html>