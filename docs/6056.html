<html>
<head>
<title>Build your own Recoil</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建立你自己的后座力</h1>
<blockquote>原文：<a href="https://itnext.io/build-your-own-recoil-6d3ab91eee16?source=collection_archive---------0-----------------------#2021-08-04">https://itnext.io/build-your-own-recoil-6d3ab91eee16?source=collection_archive---------0-----------------------#2021-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a135322e32c3e8bc2aa9939a6479b4d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnY5y0xmgN52use4y_xJ8A.png"/></div></div></figure><p id="688c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>是脸书为React提供的一个新的实验状态管理库。它的核心概念是原子和选择器:</p><h2 id="9fd5" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">原子</h2><p id="fc92" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">原子是状态的单位。它的一个例子可以是表示用户输入的一些文本状态:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="8786" class="kx ky iq ma b gy me mf l mg mh">const textState = atom({<br/>  key: 'textState',<br/>  default: '',<br/>});</span></pre><p id="237b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">借助<code class="fe mi mj mk ma b">useRecoilValue</code>或<code class="fe mi mj mk ma b">useRecoilState</code>钩子，可以在React组件中使用原子:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="484e" class="kx ky iq ma b gy me mf l mg mh">function TextInput() {<br/>  const [text, setText] = useRecoilState(textState);<br/>  const onChange = (event) =&gt; {<br/>    setText(event.target.value);<br/>  };</span><span id="638d" class="kx ky iq ma b gy ml mf l mg mh">  return &lt;input type="text" value={text} onChange={onChange} /&gt;;<br/>}</span></pre><h2 id="8803" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">选择器</h2><p id="6134" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">选择器是一个纯粹的函数，它接受原子并代表一个派生状态:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5359" class="kx ky iq ma b gy me mf l mg mh">const charCountState = selector({<br/>  key: 'charCountState',<br/>  get: ({get}) =&gt; {<br/>    const text = get(textState);</span><span id="de46" class="kx ky iq ma b gy ml mf l mg mh">    return text.length;<br/>  },<br/>});</span></pre><p id="eb85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与atom <code class="fe mi mj mk ma b">useRecoilValue</code>或<code class="fe mi mj mk ma b">useRecoilState</code>相同，必须使用挂钩:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="aef6" class="kx ky iq ma b gy me mf l mg mh">function CharacterCount() {<br/>  const count = useRecoilValue(charCountState);</span><span id="f8b9" class="kx ky iq ma b gy ml mf l mg mh">  return &lt;&gt;Character Count: {count}&lt;/&gt;;<br/>}</span></pre><p id="189b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">反冲越来越受欢迎，今天它已经超过<a class="ae kw" href="https://star-history.t9t.io/#facebookexperimental/Recoil" rel="noopener ugc nofollow" target="_blank"> 13k星</a>。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/3002d8a3b58f09b273499834d06acfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ep5TtzItmmx35vmnhy94rQ.png"/></div></div></figure><p id="28ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得它有望在工程中使用。唯一的缺点是反冲工程仍然是实验性的。这可能会给未来带来一些风险。</p><p id="ef1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从另一方面来说，你可能习惯于另一种状态的管理。可以是<a class="ae kw" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>、<a class="ae kw" href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>、<a class="ae kw" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"> MobX </a>、来自<a class="ae kw" href="https://github.com/Leaflet/Leaflet/blob/master/src/core/Events.js" rel="noopener ugc nofollow" target="_blank">小叶</a>的事件等等。所以你能坚持下去，让项目为迁移做好准备吗？或者你能有一个B计划来应对反冲无法释放的情况吗？这两个问题的答案都是肯定的，让我们看看如何在MobX上实现它。</p><h1 id="af28" class="mn ky iq bd kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na nb nc lo nd bi translated">MobX</h1><p id="c87b" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated"><a class="ae kw" href="https://mobx.js.org/getting-started" rel="noopener ugc nofollow" target="_blank"> MobX </a>是一个简单、可扩展且经过测试的状态管理解决方案，它有自己的概念:</p><blockquote class="ne"><p id="137e" class="nf ng iq bd nh ni nj nk nl nm nn kv dk translated"><em class="no">确保可以从应用程序状态派生的所有内容都将被派生。自动地。</em></p></blockquote><p id="dcf7" class="pw-post-body-paragraph jy jz iq ka b kb np kd ke kf nq kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">该库拥有超过<a class="ae kw" href="https://star-history.t9t.io/#facebookexperimental/Recoil" rel="noopener ugc nofollow" target="_blank"> 24k颗恒星</a>，并且只有<a class="ae kw" href="https://github.com/mobxjs/mobx/issues" rel="noopener ugc nofollow" target="_blank"> 5期</a>，这表明它的稳定性非常好。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/ce6bbb83ec515f957c06dfe4681939bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWnkwq7aIOZQCDhupDzvAQ.png"/></div></div></figure><p id="3531" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要用MobX实现<code class="fe mi mj mk ma b">textState</code>,你唯一需要做的就是使用类，并使其具有反应性:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="0acf" class="kx ky iq ma b gy me mf l mg mh">class TextState = {<br/>  text = "";</span><span id="f509" class="kx ky iq ma b gy ml mf l mg mh">  constructor() {<br/>    constructor() {<br/>      makeAutoObservable(this);<br/>    }<br/>  }</span><span id="6493" class="kx ky iq ma b gy ml mf l mg mh">  setText(nextText) {<br/>    this.text = nextText;<br/>  }<br/>}</span></pre><p id="d5a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，可以在任何React组件中使用它:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="caff" class="kx ky iq ma b gy me mf l mg mh">const textState = new TextStat();<br/>function TextInput() {<br/>  const {text, setText} = textState;<br/>  const onChange = (event) =&gt; {<br/>    setText(event.target.value);<br/>  };</span><span id="c88c" class="kx ky iq ma b gy ml mf l mg mh">  return &lt;input type="text" value={text} onChange={onChange} /&gt;;<br/>}</span></pre><p id="5b92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该解决方案的缺点可能是，您需要引入一个新的依赖关系<a class="ae kw" href="https://github.com/mobxjs/mobx/tree/main/packages/mobx-react" rel="noopener ugc nofollow" target="_blank"> mobx-react </a>并使用<code class="fe mi mj mk ma b">observer</code>，这样组件将对变化做出反应。</p><p id="1d59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要解决上面提到的问题，可以在MobX上构建您自己的“反冲包装器”,并实现您需要的确切功能。</p><h1 id="4a11" class="mn ky iq bd kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na nb nc lo nd bi translated">MobX-反冲</h1><p id="f6d0" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">让我们从<code class="fe mi mj mk ma b">atom</code>的实现开始。看看它的反冲实现，我们需要了解两件事:</p><h1 id="f165" class="mn ky iq bd kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na nb nc lo nd bi translated">选择</h1><p id="03e1" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">接受<code class="fe mi mj mk ma b">key</code>和<code class="fe mi mj mk ma b">default</code>值的选项参数(<em class="nv">我们不打算涵盖所有反冲功能</em>):</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4dca" class="kx ky iq ma b gy me mf l mg mh">interface Config&lt;T&gt; {<br/>  key: string;<br/>  default: T;<br/>}</span></pre><h1 id="6f1d" class="mn ky iq bd kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na nb nc lo nd bi translated">原子</h1><p id="e9ac" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">要实现Atom，我们需要:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9893" class="kx ky iq ma b gy me mf l mg mh">interface AtomType&lt;T&gt; {<br/>  key: string;<br/>  value: T;<br/>  update: (nextValue: T) =&gt; void;<br/>}</span></pre><p id="6ab4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">知道可以创建一个接受<code class="fe mi mj mk ma b">Config</code>并构建<code class="fe mi mj mk ma b">AtomType</code>的函数:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="43b0" class="kx ky iq ma b gy me mf l mg mh">export function atom&lt;T&gt;(config: Config&lt;T&gt;): AtomType&lt;T&gt; {<br/>  class AtomImpl implements AtomType&lt;T&gt; {<br/>    key: string = config.key;</span><span id="1649" class="kx ky iq ma b gy ml mf l mg mh">    value: T = config.default;</span><span id="63f2" class="kx ky iq ma b gy ml mf l mg mh">    constructor() {<br/>      makeAutoObservable(this);<br/>    }</span><span id="1fc4" class="kx ky iq ma b gy ml mf l mg mh">    update(nextValue: T) {<br/>      this.value = nextValue;<br/>    }<br/>  }</span><span id="764e" class="kx ky iq ma b gy ml mf l mg mh">  return new AtomImpl();<br/>}</span></pre><p id="8cb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这允许创建一个mobx可观察类，它可以作为一个独立的类使用，或者传递给<code class="fe mi mj mk ma b">useRecoilValue</code>或<code class="fe mi mj mk ma b">useRecoilState</code>钩子。</p><h1 id="452c" class="mn ky iq bd kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na nb nc lo nd bi translated">useRecoilState</h1><p id="34b7" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">这将是一个接受原子并返回其值的React钩子。该值也将在<code class="fe mi mj mk ma b">useState</code>挂钩的帮助下存储，该挂钩也提供了对变化做出反应的可能性:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="ab2a" class="kx ky iq ma b gy me mf l mg mh">export function useRecoilState&lt;T&gt;(atom: AtomType&lt;T&gt;): [T, (value: T) =&gt; void] {<br/>  const [value, setValue] = useState&lt;T&gt;(atom.value);<br/>  useEffect(() =&gt; {<br/>    const disposer = autorun(() =&gt; {<br/>      setValue(atom.value);<br/>    });<br/>    return disposer;<br/>  }, [atom]);<br/>  return [<br/>    value,<br/>    (value: T) =&gt; {<br/>      atom.update(value);<br/>    }<br/>  ];<br/>}</span></pre><h1 id="4b0f" class="mn ky iq bd kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na nb nc lo nd bi translated">useRecoilValue</h1><p id="73d5" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">使用<code class="fe mi mj mk ma b">useRecoilState</code>并获得结果数组的第一个值，这个反冲钩子很容易实现:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5fb0" class="kx ky iq ma b gy me mf l mg mh">export function useRecoilValue&lt;T&gt;(atom: AtomType&lt;T&gt;): T {<br/>  return useRecoilState(atom)[0];<br/>}</span></pre><h1 id="a2f9" class="mn ky iq bd kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na nb nc lo nd bi translated">选择器</h1><p id="a5f7" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">接下来需要实现的是一个<code class="fe mi mj mk ma b">selector</code>。每个选择器应该对<code class="fe mi mj mk ma b">get</code>和<code class="fe mi mj mk ma b">set</code>原子实现一种可能性。我们将关注<code class="fe mi mj mk ma b">get</code>功能。和<code class="fe mi mj mk ma b">atoms</code>一样，每个选择器都应该有一个<code class="fe mi mj mk ma b">key</code>属性。了解这一点后，我们需要实现以下功能:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="714c" class="kx ky iq ma b gy me mf l mg mh">export function selector&lt;T&gt;(options: {<br/>  key: string;<br/>  get: (util: { get: &lt;V&gt;(atom: AtomType&lt;V&gt;) =&gt; V }) =&gt; T;<br/>}): AtomType&lt;T&gt; {<br/>  ...<br/>}</span></pre><p id="ab53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要获得原子的实际值，可以使用<code class="fe mi mj mk ma b">options.get</code>。这使我们有可能使用MobX中的<code class="fe mi mj mk ma b">autorun</code>来定义新的局部<code class="fe mi mj mk ma b">atom</code>，它将表示值并对变化做出反应。在这种情况下，<code class="fe mi mj mk ma b">selector</code>的最终实现可以是:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="da1c" class="kx ky iq ma b gy me mf l mg mh">export function selector&lt;T&gt;(options: {<br/>  key: string;<br/>  get: (util: { get: &lt;V&gt;(atom: AtomType&lt;V&gt;) =&gt; V }) =&gt; T;<br/>}): AtomType&lt;T&gt; {<br/>  const get = (atom: AtomType&lt;any&gt;) =&gt; {<br/>    return atom.value;<br/>  };</span><span id="7691" class="kx ky iq ma b gy ml mf l mg mh">  const getActualValue = () =&gt; options.get({ get });</span><span id="2114" class="kx ky iq ma b gy ml mf l mg mh">  const resultAtom = atom({<br/>    key: options.key,<br/>    default: getActualValue()<br/>  });</span><span id="1676" class="kx ky iq ma b gy ml mf l mg mh">  autorun(() =&gt; {<br/>    resultAtom.update(getActualValue());<br/>  });</span><span id="d22d" class="kx ky iq ma b gy ml mf l mg mh">  return resultAtom;<br/>}</span></pre><p id="05da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这基本上是我们需要的一切，现在我们已经可以开始在项目中使用“反冲”了。</p><h1 id="80a5" class="mn ky iq bd kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na nb nc lo nd bi translated">实施的好处</h1><p id="5749" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">好处之一就是可以用新的方式使用自己喜欢的状态管理库。另一件事是定义自定义原子的可能性。例如，假设当<code class="fe mi mj mk ma b">textState</code> atom改变时，您需要触发一些动作(可能是一个API调用来触发搜索)。要用后座力来做，你需要使用<code class="fe mi mj mk ma b">effects_UNSTABLE</code>。使用MobX，您可以提供定制的atom实现:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="81b2" class="kx ky iq ma b gy me mf l mg mh">const textState = atom(textStateMobx);</span></pre><p id="0821" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<code class="fe mi mj mk ma b">textStateMobx</code>是带有附加功能的<code class="fe mi mj mk ma b">AtomType</code>的一些实现:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="2d46" class="kx ky iq ma b gy me mf l mg mh">class TextState implements implements AtomType&lt;string&gt; {<br/>  key: string = 'textState';</span><span id="86f0" class="kx ky iq ma b gy ml mf l mg mh">  value: string = '';</span><span id="0d15" class="kx ky iq ma b gy ml mf l mg mh">  constructor() {<br/>    makeAutoObservable(this);<br/>    this.debouncedApiCall = debounce(this.doApiCall, DEBOUNCE_TIME);<br/>  }</span><span id="b25a" class="kx ky iq ma b gy ml mf l mg mh">  update(nextValue: string) {<br/>    this.value = nextValue;<br/>    debouncedApiCall();<br/>  }</span><span id="7e61" class="kx ky iq ma b gy ml mf l mg mh">  doApiCall() {<br/>    if (this.value.length &gt; MIN_LENGTH) {<br/>      // some api call<br/>    }<br/>  }<br/>}</span></pre><h1 id="86bb" class="mn ky iq bd kz mo mp mq lc mr ms mt lf mu mv mw li mx my mz ll na nb nc lo nd bi translated">构建“mobx-反冲”应用程序</h1><p id="52ad" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">反冲为<a class="ae kw" href="https://recoiljs.org/docs/introduction/getting-started" rel="noopener ugc nofollow" target="_blank">示例</a>提供了文本输入和输入符号计数器。几乎不需要对其进行调整，整个示例如下:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="d87e" class="kx ky iq ma b gy me mf l mg mh">function TextInput() {<br/>  const [text, setText] = useRecoilState(textState);</span><span id="976e" class="kx ky iq ma b gy ml mf l mg mh">  const onChange = (event) =&gt; {<br/>    setText(event.target.value);<br/>  };</span><span id="7dea" class="kx ky iq ma b gy ml mf l mg mh">  return (<br/>    &lt;div&gt;<br/>      &lt;input type="text" value={text} onChange={onChange} /&gt;<br/>      &lt;br /&gt;<br/>      Echo: {text}<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="e8ed" class="kx ky iq ma b gy ml mf l mg mh">function CharacterCount() {<br/>  const count = useRecoilValue(charCountState);</span><span id="325d" class="kx ky iq ma b gy ml mf l mg mh">  return &lt;&gt;Character Count: {count}&lt;/&gt;;<br/>}</span><span id="55e5" class="kx ky iq ma b gy ml mf l mg mh">function CharacterCounter() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;TextInput /&gt;<br/>      &lt;CharacterCount /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="a70c" class="kx ky iq ma b gy ml mf l mg mh">export default function App() {<br/>  return &lt;CharacterCounter /&gt;;<br/>}</span></pre><p id="779a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">唯一的区别是<code class="fe mi mj mk ma b">atom</code>、<code class="fe mi mj mk ma b">selector</code>、<code class="fe mi mj mk ma b">useRecoilState</code>和<code class="fe mi mj mk ma b">useRecoilValue</code>必须从本地定义的“反冲”实现中导入，而不是从<code class="fe mi mj mk ma b">'recoil'</code>中导入:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="a9dd" class="kx ky iq ma b gy me mf l mg mh">import React from 'react';<br/>import {<br/>  atom,<br/>  selector,<br/>  useRecoilState,<br/>  useRecoilValue,<br/>} from './mobx2recoil';</span></pre></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="51cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读，我希望你喜欢这个想法。在<a class="ae kw" href="https://codesandbox.io/s/throbbing-glitter-4zrcg?file=/src/App.tsx" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>中有一个工作示例。祝你编码好运！</p></div></div>    
</body>
</html>