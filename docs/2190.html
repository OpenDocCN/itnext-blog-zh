<html>
<head>
<title>Managing Application Side-Effects: An Introduction to Redux-Saga</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理应用程序副作用:Redux-Saga简介</h1>
<blockquote>原文：<a href="https://itnext.io/managing-application-side-effects-4863ef234f4e?source=collection_archive---------8-----------------------#2019-04-13">https://itnext.io/managing-application-side-effects-4863ef234f4e?source=collection_archive---------8-----------------------#2019-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9b49bd96eb8dca464deb77872282b0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QxiC0sSQJS2NYHug.png"/></div></div></figure><h2 id="efed" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">开始之前…</h2><p id="47d6" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">本文由两部分组成:首先了解副作用以及它们与Redux的关系，然后深入研究Redux-Saga的基本原理。如果你只是对快速理解Redux-Saga感兴趣，请随意跳到Redux-Saga部分。但是如果你仍然不确定Redux-Saga是否适合你，那么本文的第一部分可能会帮助你做出决定。</p><h2 id="e41d" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么是副作用？</h2><p id="02a5" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">Redux作为UI web应用程序中处理状态管理的主要方法越来越受欢迎。在一个项目中采用Redux通常会得到这样的结果(尤其是对于第一次使用Redux的开发人员):</p><ol class=""><li id="9d83" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo lw lx ly lz bi translated">阅读并浏览<a class="ae ma" href="https://redux.js.org/basics/basic-tutorial" rel="noopener ugc nofollow" target="_blank"> Redux教程</a></li><li id="356b" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo lw lx ly lz bi translated">为应用程序的一小部分写一些动作创建者和缩减者</li><li id="86c7" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo lw lx ly lz bi translated">尝试发出一个AJAX请求，并将结果数据存储在Redux中</li><li id="e986" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo lw lx ly lz bi translated">开始搜索堆栈溢出，找出为什么这个简单的任务会如此混乱</li><li id="b760" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo lw lx ly lz bi translated">质疑人生选择</li></ol><p id="6e96" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">他们将会发现，Redux对于什么是“核心”功能的概念非常有限。在纯Redux应用程序中，应用程序遵循以下顺序:</p><ol class=""><li id="0ebe" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo lw lx ly lz bi translated">调度一个动作</li><li id="cd7c" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo lw lx ly lz bi translated">减压器改变商店</li><li id="3ccf" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo lw lx ly lz bi translated">重复</li></ol><p id="ae7f" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">这个应用程序流是同步和确定性的(因为reducers被限制为同步和确定性的)。通常，这个流程也完全不足以处理现代UI web应用程序执行的所有可能的任务。</p><p id="aaa5" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">从Redux的角度来看，任何发生在正常流程之外的事情都被认为是一个<strong class="kw ir">副作用</strong>，因此完全由开发人员来决定他们应该如何建模和实现这些任务，以及他们应该如何与Redux的准系统应用程序流程进行交互。这包括以下内容:</p><ul class=""><li id="71b1" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo mj lx ly lz bi translated">与异步API的交互</li><li id="a3dc" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">通过AJAX请求获取/发布数据</li><li id="ec35" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">设置超时和间隔</li><li id="7c35" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">调度操作以响应其他操作</li></ul><p id="cb63" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">例如，假设我们有一个带有<code class="fe mk ml mm mn b">getUser(id)</code>方法的API客户端，它将调用一个REST API <code class="fe mk ml mm mn b">/users/:id</code>来返回一个用户配置文件。我们希望将这些数据存储到Redux中，这样就可以跨应用程序访问这些数据。</p><p id="62dc" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">让我们为此设计动作和状态。第一反应可能是创建一个动作，<code class="fe mk ml mm mn b">GET_USER</code>，然后用一个reducer处理这个动作。然而，用户数据将被异步检索(因为它是一个AJAX请求)，所以我们将遵循<a class="ae ma" href="https://redux.js.org/advanced/async-actions#async-actions" rel="noopener ugc nofollow" target="_blank"> Redux关于设计异步动作和状态的建议</a>:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2045" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">现在我们有了一组基本的动作创建者，我们想实际上把它们连接起来并发出API请求(这是Redux的副作用)。让我们探索几个选项，使用这个Redux设置作为我们的基础。</p><h1 id="39db" class="mu jz iq bd ka mv mw mx kd my mz na kg nb nc nd kk ne nf ng ko nh ni nj ks nk bi translated">使用Redux时如何实现副作用？</h1><p id="c5ae" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">由于<a class="ae ma" href="https://redux.js.org/faq/actions#how-can-i-represent-side-effects-such-as-ajax-calls-why-do-we-need-things-like-action-creators-thunks-and-middleware-to-do-async-behavior" rel="noopener ugc nofollow" target="_blank"> Redux对如何实现副作用并不固执己见</a>，因此出现了许多管理它们的模式。我喜欢将这些分为两类:完全在Redux生命周期之外运行的模式(<strong class="kw ir">Redux-外部</strong>)，以及与Redux生命周期交错的模式(<strong class="kw ir">以Redux为中心的</strong>)。</p><h1 id="fb90" class="mu jz iq bd ka mv mw mx kd my mz na kg nb nc nd kk ne nf ng ko nh ni nj ks nk bi translated">冗余外部模式</h1><p id="3c20" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">实现副作用最直接的方法(也是大多数开发人员首先会采用的方法)是独立于Redux编写和触发它们，并让这个独立的代码<a class="ae ma" href="https://redux.js.org/api/store#store-methods" rel="noopener ugc nofollow" target="_blank">调用Redux </a>(通过<code class="fe mk ml mm mn b">dispatch</code>或<code class="fe mk ml mm mn b">getState</code>)。</p><h2 id="1afa" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">redux-外部模式:视图框架</h2><p id="e77b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">假设您正在使用一个框架来呈现或控制应用程序，将副作用实现作为代码的一部分存在似乎是很自然的。例如，如果您使用React，常见的方法是在挂载组件时触发副作用，并通过绑定的动作创建器将副作用的不同异步转换绑定到Redux:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="eaf8" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">通过将Redux绑定到各自的视图或服务层，可以使用其他常见的JS框架编写类似的模式。如果没有框架，这种模式看起来就像让DOM事件处理程序触发副作用代码。</p><p id="36c1" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">好处</strong></p><ul class=""><li id="3325" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo mj lx ly lz bi translated">通过将副作用逻辑与副作用结果的主要消费者联系起来，会更容易理解</li><li id="c7fc" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">不涉及添加新的库/依赖项</li></ul><p id="c043" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">不利方面</strong></p><ul class=""><li id="46ad" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo mj lx ly lz bi translated">更难测试和重用代码(有时；这可以通过仔细的预见和计划来避免)</li><li id="e0d1" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">通常通过给先前的纯逻辑增加副作用来增加部件/控制器逻辑的长度和复杂性</li><li id="93b5" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">强制将副作用绑定到组件生命周期，而不是独立运行</li><li id="679d" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">不容易对应用程序流中发生的事件做出反应，例如被分派的操作</li></ul><blockquote class="nl nm nn"><p id="e9d3" class="ku kv no kw b kx lr kz la lb ls ld le np mg lg lh nq mh lj lk nr mi lm ln lo ij bi translated"><strong class="kw ir"> <em class="iq">注:</em> </strong> <em class="iq">在撰写本文时，</em><a class="ae ma" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw ir"><em class="iq">React Hooks API</em></strong></a><em class="iq">仍处于alpha开发阶段。这似乎是一种很有前途的方法，可以使这种模式更容易在React中测试和重用，并最小化组件代码的复杂性。然而，它仍然会受到副作用与组件生命周期相关的不利影响。</em></p></blockquote><h1 id="90d1" class="mu jz iq bd ka mv mw mx kd my mz na kg nb nc nd kk ne nf ng ko nh ni nj ks nk bi translated">以冗余为中心的模式</h1><p id="f8e2" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">虽然使用Redux-External模式更容易实现，但是它缺乏触发更复杂副作用的能力，比如调度动作来响应其他动作(是的，您可以使用<code class="fe mk ml mm mn b"><a class="ae ma" href="https://redux.js.org/api/store#a-id-subscribe-a-subscribelistener-subscribe" rel="noopener ugc nofollow" target="_blank">subscribe</a></code>方法，但是Dan Abramov说<a class="ae ma" href="https://github.com/reduxjs/redux/issues/303#issuecomment-125184409" rel="noopener ugc nofollow" target="_blank">您可能不应该使用</a>)。对于像这样的副作用，我们应该使用一种通过某种中间件将其自身绑定到Redux的模式。</p><p id="3b61" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">以下对以Redux为中心的副作用模式的描述很大程度上是受Gosha Arinich的文章<a class="ae ma" href="https://goshakkk.name/redux-side-effect-approaches/" rel="noopener ugc nofollow" target="_blank"><strong class="kw ir">3 Redux应用</strong> </a>中常见的副作用处理方法的启发，为了方便起见，在此重新描述。</p><h2 id="5e70" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">以Redux为中心的模式#1:智能动作创建者</h2><p id="48d9" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">在标准的Redux实现中，动作创建者是纯粹的<strong class="kw ir"/>，这意味着他们将简单地创建并返回一个对象，可选地基于传递给动作创建者的一些参数。在这种模式中，我们可以决定让动作创建者也执行期望的副作用。这通常是通过让动作创建者返回简单对象之外的内容，并使用中间件来处理这些非对象动作来实现的:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d6d3" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><a class="ae ma" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> Redux-Thunk </strong> </a>是这种模式的常用实现。</p><p id="0644" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">好处</strong></p><ul class=""><li id="9e04" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo mj lx ly lz bi translated">不需要学习标准JavaScript之外的任何新概念或心理模型</li></ul><p id="c505" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">不利方面</strong></p><ul class=""><li id="e455" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo mj lx ly lz bi translated">动作创作者不再纯粹，使他们更难理解和测试</li><li id="2114" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">除了简单的副作用之外，经常会导致回调地狱(尽管async-await可以帮助解决这个问题)</li><li id="e69e" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">智能动作创建者只能在被调用时运行，而不是对任意动作做出反应</li></ul><h2 id="53c9" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">以冗余为中心的模式#2:智能中间件+专门的动作</h2><p id="f87e" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我们可以将工作转移到中间件中，让我们的动作为中间件提供特殊的指令，而不是在动作创建器中运行副作用。这类似于<strong class="kw ir">智能动作创建者</strong>模式，除了动作创建者仍然是纯粹的，现在中间件将拦截动作并处理执行中的副作用:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="57ed" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><a class="ae ma" href="https://github.com/redux-utilities/redux-promise" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> Redux-Promise </strong> </a>是这种模式的常用实现。</p><p id="3530" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">好处</strong></p><ul class=""><li id="ca82" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo mj lx ly lz bi translated">动作创作者保持纯洁，所以更容易测试</li></ul><p id="4c33" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">缺点</strong></p><ul class=""><li id="9c5a" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo mj lx ly lz bi translated">更难概括来处理任何期望的副作用；每种副作用通常都需要自己特定的中间件来处理</li></ul><h2 id="1bad" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">以Redux为中心的模式#3: Redux挂钩/监听器</h2><p id="20b9" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我们可以采用前面的模式，并通过完全去除动作的任何特殊化来进一步推广它。如果我们编写定制的中间件来监听被调度的通用动作，并独立于Redux生命周期执行副作用，那么我们的动作创建者和动作将保持简单和纯粹，副作用将完全由该中间件描述:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6346" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">实际上，这种模式的实现很少让开发人员直接编写每个中间件；他们通常会创建一些抽象的模型来进行开发。<a class="ae ma" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> Redux-Saga </strong> </a>是这种模式的常用实现。</p><p id="88f9" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">好处</strong></p><ul class=""><li id="2e1c" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo mj lx ly lz bi translated">动作很简单，不包含副作用的业务逻辑</li><li id="cec8" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">允许许多听众对一个动作做出反应</li><li id="5da2" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">包含副作用逻辑，如果实现正确，很容易测试</li></ul><p id="a024" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">不利方面</strong></p><ul class=""><li id="f4e6" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo mj lx ly lz bi translated">这种模式的实现在复杂性和有用性方面有很大的不同</li><li id="804c" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">会有一个陡峭的学习曲线</li></ul><h1 id="0b7e" class="mu jz iq bd ka mv mw mx kd my mz na kg nb nc nd kk ne nf ng ko nh ni nj ks nk bi translated">我应该选择哪种模式？</h1><p id="c172" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">一如既往，这将取决于你的项目的需求和目标。这些模式按照它们的伸缩方式大致排序(不幸的是，也按照复杂性排序)。对于小而简单的项目，使用Redux-External方法通常就足够了。随着应用程序的增长，越来越多的部分变得相互依赖，您可能希望切换到能够更好地管理代码的模式。</p><p id="8a6a" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">如果你还在读这篇文章(很高兴你还在这里！)，那么您可能对您当前使用的模式不满意，并且有兴趣看看还有什么。在<a class="ae ma" href="https://www.expanse.co/join-us/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir">广阔</strong> </a>这里，我们已经将<a class="ae ma" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> Redux-Saga </strong> </a>用于我们的应用程序，它帮助我们组织我们的代码库并简化我们实现副作用的方式。不过，离开地面可能会很困难；本文的其余部分致力于使学习曲线变得更容易接近。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="0ca3" class="mu jz iq bd ka mv nz mx kd my oa na kg nb ob nd kk ne oc ng ko nh od nj ks nk bi translated">还原传奇</h1><p id="c2c1" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">Redux-Saga是<strong class="kw ir"> Redux Hooks/Listeners </strong>模式的一个实现，定义了一个“Saga”编程模型来处理副作用。</p><p id="e519" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">Sagas是与应用程序一起运行的“线程”或“子例程”。像线程一样，它们可以在任何上下文中暂停、启动或取消(通常使用Redux操作)。此外，因为Redux-Saga是建立在<strong class="kw ir"> Redux Hooks/Listeners </strong>模式之上的，所以Saga也可以完全访问Redux状态，可以“阻塞”或“等待”Redux动作，并且可以调度它们自己的动作。</p><h2 id="b0ab" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">ES6发电机</h2><p id="5377" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">使用Redux-Saga的最大学习曲线之一是它依赖于<a class="ae ma" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*#Description" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> ES6生成器</strong></a>:React/Redux开发人员不常用的语言特性。</p><blockquote class="nl nm nn"><p id="42b1" class="ku kv no kw b kx lr kz la lb ls ld le np mg lg lh nq mh lj lk nr mi lm ln lo ij bi translated">"为什么我不能用普通代码写传奇？"</p></blockquote><p id="9cdd" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">生成器有一些好处，比如允许以同步方式编写异步流(类似于async/await)。但主要的特点是，它们允许传奇“持续运行”，而不会阻塞主执行线程。与在sagas中直接编写阻塞调用不同，阻塞调用用一个<strong class="kw ir">效果</strong>来描述，并用一个<code class="fe mk ml mm mn b">yield</code>来“包装”，这将执行控制返回给Redux-Saga。这允许Redux-Saga以增量方式运行Saga，将执行与主应用程序交错(在了解了更多关于生成器的知识后，这将更有意义)。</p><blockquote class="nl nm nn"><p id="a0cc" class="ku kv no kw b kx lr kz la lb ls ld le np mg lg lh nq mh lj lk nr mi lm ln lo ij bi translated">"那么ES6发电机是如何工作的呢？"</p></blockquote><p id="da23" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">生成器是可以自行暂停并将执行控制返回给“控制”函数(从这一点开始称为“控制器”)的函数。他们还在生成器和控制器之间使用<strong class="kw ir">双向消息传递</strong>来共享两个函数之间的上下文。</p><p id="aa3a" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">下面的幻灯片演示了这种控制器/发电机关系的一个简单示例，以<a class="ae ma" href="https://youtu.be/0obMRztklqU" rel="noopener ugc nofollow" target="_blank"> NumberWang </a>为调:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="oe mt l"/></div></figure><blockquote class="nl nm nn"><p id="5e15" class="ku kv no kw b kx lr kz la lb ls ld le np mg lg lh nq mh lj lk nr mi lm ln lo ij bi translated">" Redux-Saga如何使用ES6发电机？"</p></blockquote><p id="6d70" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">在上面的关系中，<strong class="kw ir"> Redux-Saga中间件充当控制器，</strong>和<strong class="kw ir">应用的Saga是生成器</strong>。无论saga产生什么，都将被Redux-Saga中间件解释为指令，并在指令完成时将控制权归还给Saga:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="oe mt l"/></div></figure><h2 id="850c" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">还原传奇效应</h2><p id="1aa3" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">在前面的例子中，saga向Redux-Saga传递了一个承诺，Redux-Saga将其解释为“解析这个承诺，然后提取并发回结果”的指令。与async/await不同，这不是ES6生成器内置的功能。这是因为Redux-Saga的中间件实现(控制器)决定对所有promise类型的消息遵循这些指令。</p><p id="696e" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir"> Redux-Saga将从Saga生成的所有消息视为指令。</strong>事实上，它在库中有一整套内置指令，你可以传递给它，这些被称为<a class="ae ma" href="https://redux-saga.js.org/docs/basics/DeclarativeEffects.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir">效果</strong> </a>。这些效果允许发送Redux-Saga的各种自定义指令，例如等待或调度Redux操作，等待解决的承诺，或者组合多个效果。</p><p id="84e1" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">这是之前的Redux-Saga示例，现在使用效果作为指示，而不是承诺:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="oe mt l"/></div></figure></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><blockquote class="nl nm nn"><p id="f0d3" class="ku kv no kw b kx lr kz la lb ls ld le np mg lg lh nq mh lj lk nr mi lm ln lo ij bi translated">"我如何开始使用Redux-Saga？"</p></blockquote><p id="d74f" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">当然，学习编写生成器函数和使用Redux-Saga的最好方法是自己编写一些Saga。如果你犹豫要不要马上运行<code class="fe mk ml mm mn b">npm i redux-saga</code>,我已经整理了一个包含一系列任务的教学资源库，这些任务将向你介绍生成器函数、应用程序副作用以及使用Redux-Saga效果和API。这个repo还包含每个任务的“无sagas”实现(使用Redux-External模式),以便您可以比较这种方法将如何改变您的代码的外观和组织方式。</p><div class="of og gp gr oh oi"><a href="https://github.com/jlmart88/introduction-to-redux-saga" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">JL mart 88/redux-saga简介</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">通过动手实施任务介绍Redux-Saga—JL mart 88/Redux-Saga简介</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow jw oi"/></div></div></a></div><blockquote class="nl nm nn"><p id="b781" class="ku kv no kw b kx lr kz la lb ls ld le np mg lg lh nq mh lj lk nr mi lm ln lo ij bi translated"><strong class="kw ir"> <em class="iq">注:</em> </strong> <em class="iq">以上资源库使用的是</em><a class="ae ma" href="https://www.typescriptlang.org/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw ir"><em class="iq">TypeScript</em></strong></a><strong class="kw ir"><em class="iq">，</em> </strong> <em class="iq">但是即使你不认识TypeScript也还是可以用！按照</em> <code class="fe mk ml mm mn b"><em class="iq">README.md</em></code> <em class="iq">中的说明运行项目，不进行类型检查，这样您就可以编写普通的ES6 JavaScript，而不会受到transpiler的影响。或者，你也可以以此为契机，</em> <a class="ae ma" href="https://medium.com/@jtomaszewski/why-typescript-is-the-best-way-to-write-front-end-in-2019-feb855f9b164" rel="noopener"> <em class="iq">跳上打字列车</em> </a> <em class="iq">😉。</em></p></blockquote></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="8eda" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">其他资源:</strong></p><ul class=""><li id="8cc0" class="lp lq iq kw b kx lr lb ls kh lt kl lu kp lv lo mj lx ly lz bi translated"><a class="ae ma" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Saga文档</a></li><li id="ed22" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated"><a class="ae ma" href="https://goshakkk.name/redux-side-effect-approaches/" rel="noopener ugc nofollow" target="_blank">redux应用中3种常见的副作用处理方法</a> — Gosha Arinich</li><li id="3ee0" class="lp lq iq kw b kx mb lb mc kh md kl me kp mf lo mj lx ly lz bi translated">什么时候应该使用传奇？ —菲利克斯·克拉克</li></ul><p id="3fb0" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">想展示你新磨练出来的还原传奇技能吗？<a class="ae ma" href="https://www.expanse.co/join-us/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir">广阔天地正在招人</strong> </a>！我们通过为世界上最大的组织提供实时、全面的全球互联网优势视图，来帮助保护这些组织。如果你有学习和成长的欲望，喜欢解决有挑战性的问题，给我们写封短信吧！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="b543" class="pw-post-body-paragraph ku kv iq kw b kx lr kz la lb ls ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><em class="no">原载于2019年4月13日https://www.expanse.co</em><em class="no">的</em> <a class="ae ma" href="https://www.expanse.co/managing-application-side-effects-an-introduction-to-redux-saga/" rel="noopener ugc nofollow" target="_blank"> <em class="no">。</em></a></p></div></div>    
</body>
</html>