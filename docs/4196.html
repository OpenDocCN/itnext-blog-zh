<html>
<head>
<title>Android: Intro Slider with state management using Arch components. (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:使用Arch组件进行状态管理的介绍滑块。(第二部分)</h1>
<blockquote>原文：<a href="https://itnext.io/android-intro-slider-with-state-management-using-androidx-architecture-components-part-2-2e927211b9a5?source=collection_archive---------2-----------------------#2020-05-13">https://itnext.io/android-intro-slider-with-state-management-using-androidx-architecture-components-part-2-2e927211b9a5?source=collection_archive---------2-----------------------#2020-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="070c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是第1部分的延续，在第1部分中，我们已经熟悉了一些架构组件，并使用<code class="fe km kn ko kp b">ViewPager</code>和<code class="fe km kn ko kp b">Fragments</code>实现了基本的intro slider。</p><p id="136c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想直接进入，你可以简单地在GitHub 上检查<a class="ae kl" href="https://github.com/xzhorikx/slider-intro/tree/part-2-base" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kq">part-2-base</em></strong>分支。</a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/590e5e33e04596d44045751b4a9251aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*H5ooAKeqJxgsL4Vs01Wtgg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">简介滑块结构的高级概述</figcaption></figure><p id="efe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一部分将使用<code class="fe km kn ko kp b"><a class="ae kl" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>和<code class="fe km kn ko kp b"><a class="ae kl" href="https://developer.android.com/reference/androidx/lifecycle/Transformations" rel="noopener ugc nofollow" target="_blank">Transformations</a></code>来仔细观察状态管理。让我们看看在这一部分结束时将会实现什么:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">简介滑块的最终结果</figcaption></figure><p id="42da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们分析当用户滑动片段时，屏幕上发生了什么变化:</p><ul class=""><li id="a94e" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">背景颜色</li><li id="196a" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">中央导航点</li><li id="b985" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">文本元素的可见性</li></ul><p id="91ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，每个部分都有一个<strong class="jp ir"/><strong class="jp ir">状态</strong>，这取决于在任何给定时间的<code class="fe km kn ko kp b">ViewPager</code> <strong class="jp ir">转换</strong> <strong class="jp ir">状态</strong>。但是我们如何知道<em class="kq">过渡状态</em>？幸运的是<code class="fe km kn ko kp b">ViewPager</code>有<code class="fe km kn ko kp b"><a class="ae kl" href="https://developer.android.com/reference/kotlin/androidx/viewpager/widget/ViewPager.OnPageChangeListener" rel="noopener ugc nofollow" target="_blank">OnPageChangeListene</a>r</code>允许在每次页面改变时接收回调。每当过渡正在进行时，<em class="kq">onpagesulved(position:Int，positionOffset: Float，positionOffsetPixels: Int) </em>被调用，我们对<em class="kq"> position </em>和<em class="kq"> positionOffset </em>的值感兴趣。</p><blockquote class="lt lu lv"><p id="f1f3" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated"><strong class="jp ir">快速提示:了解页面过渡是如何表现的</strong></p><p id="734e" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated">如果我们有N个片段，那么<strong class="jp ir">位置</strong>的值将是一个在[0，N - 1]范围内的整数。</p><p id="4135" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated"><strong class="jp ir">位置偏移</strong>始终是一个在[0，1]范围内的浮点数</p><p id="d7c5" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated"><strong class="jp ir">位置及其偏移量的总和</strong>代表一个<strong class="jp ir">过渡状态</strong>。</p><p id="5d6d" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated">因此，如果位置1上的片段滚动50%到位置2上的片段，转换状态等于1.5000:相对于位置1的偏移量是0.5000。如果位置1上的片段被滚动50%到片段位置0，则转换状态等于0.5000:相对于位置0的偏移是0.5000。</p></blockquote><p id="fa51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">ViewPager</code>转换的状态可以用一个字段来表示:位置和它的偏移量。让我们创建一个新的<code class="fe km kn ko kp b">ViewHolderScrollState</code>类来表示滑块中的转换状态:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">过渡状态的类</figcaption></figure><p id="9770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候创建包含转换状态的LiveData了，这样我们可以在以后将这个状态转换成有用的东西，比如计算的背景颜色或文本元素的可见性。导航到<code class="fe km kn ko kp b">MainAppActivityViewModel</code>并添加以下代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">将转换状态保存到视图模型</figcaption></figure><blockquote class="lt lu lv"><p id="09dc" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated">注意:我们预先知道mViewHolderScrollStateLiveData不会在Activity中被观察到，这就是为什么它有一个' private '修饰符和一个public setter。</p></blockquote><p id="9d31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要活动也需要修改:</p><ul class=""><li id="8372" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated"><code class="fe km kn ko kp b">ViewPager</code>必须有一个页面更改监听器</li><li id="dec6" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">每次转换进行时，页面更改监听器必须更新转换状态</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">将页面更改侦听器添加到视图寻呼机</figcaption></figure><p id="f448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已成功将页面更改监听器添加到<code class="fe km kn ko kp b">ViewPager</code>！从现在开始，每次转换开始时，其状态(<em class="kq">位置和其偏移量</em>)保存在<code class="fe km kn ko kp b">mViewHolderScrollStateLiveData</code>中。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="1a1f" class="mh mi iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated"><strong class="ak">让我们动态改变背景颜色</strong><strong class="ak">！</strong></h1><p id="5ba1" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">我们需要保持事情简单，所以我们的活动只需要知道一件事——设置什么背景颜色。它不应该知道这个颜色是如何计算的，也不应该知道它的值取决于什么。<code class="fe km kn ko kp b">LiveData</code>非常适合这种情况:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">向MainActivity添加背景色LiveData</figcaption></figure><p id="d6da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，出于美观的原因，我们也改变了状态栏的颜色。到目前为止,<code class="fe km kn ko kp b">ViewModel</code>还没有<code class="fe km kn ko kp b">backgroundColorLiveData</code>,我们将很快创建它，但首先让我们看看它背后的想法:</p><ul class=""><li id="e712" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">每个片段类型都有自己的背景颜色</li><li id="f4d0" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">我们知道当前的转换状态，这意味着我们知道两个片段的位置，在这两个片段之间发生转换</li><li id="76c8" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">根据位置偏移([0，1]范围中的<em class="kq">值)，我们可以在两种颜色之间进行插值，其中一部分由偏移表示</em></li></ul><p id="3c6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://developer.android.com/reference/android/animation/ArgbEvaluator" rel="noopener ugc nofollow" target="_blank"><em class="kq">ArgbEvaluator</em></a><em class="kq">。evaluate()</em>派上了用场，因为它能够做到这一点！From docs: <em class="kq">该函数返回给定整数和给定分数的颜色的中间值[…] </em>。</p><pre class="ks kt ku kv gt nk kp nl nm aw nn bi"><span id="c5a9" class="no mi iq kp b gy np nq l nr ns">ArgbEvaluator.evaluate(offset, color1, color2)</span></pre><p id="0ce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们一切就绪:<em class="kq">偏移量</em>从<em class="kq">viewmolderscrollstate中已知，颜色1 </em>和<em class="kq">颜色2 </em>可以从片段中获得，这些片段的位置也是从<em class="kq">viewmolderscrollstate</em>中计算出来的。</p><p id="0fb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何在视图模型中获得当前的<code class="fe km kn ko kp b">ViewHolderScrollState</code>?答:<a class="ae kl" href="https://developer.android.com/reference/androidx/lifecycle/Transformations" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> LiveData转换</strong> </a>。<em class="kq"> </em>简单来说，变换允许观察其他<code class="fe km kn ko kp b">LiveData</code>的变化，并将其值映射到所需的对象。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">视图保持器状态到背景颜色的转换</figcaption></figure><p id="b217" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从现在开始，每次<code class="fe km kn ko kp b">mViewHolderScrollStateLiveData</code>中的值被改变，它都会将新的<code class="fe km kn ko kp b">ViewHolderScrollState</code> <em class="kq"> </em>值传递给<code class="fe km kn ko kp b">backgroundColorLiveData</code> <em class="kq"> </em>转换函数。知道了过渡态，就有可能得到两个片段的位置、偏移量和颜色。</p><p id="9970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查点:运行应用程序，你将会看到变化的魔力！</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="1d13" class="mh mi iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">是时候创建导航点了！</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">用户在屏幕间导航时的点动画</figcaption></figure><p id="a7d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望此时你已经对<code class="fe km kn ko kp b">LiveData</code>和<code class="fe km kn ko kp b">Transforamtions</code>如何协同工作有了基本的了解，因为我们将再次使用这种组合！让我们定义一些需要考虑的要点:</p><ul class=""><li id="4d7a" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">一旦知道需要在<code class="fe km kn ko kp b">ViewPager</code>中显示多少片段，就必须动态生成点</li><li id="ae88" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">点数等于滑动屏幕的数量</li><li id="7c20" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">过渡只发生在两个片段之间。这意味着<strong class="jp ir">只需要在任何给定的时间制作两个点的动画</strong>，所有其他的必须保持不变</li><li id="e453" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">在过渡期间改变的属性:<em class="kq"> alpha </em>和<em class="kq"> scale </em></li><li id="0a32" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">每个点都有一个定义其在屏幕上外观的状态</li></ul><p id="a6a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">定义导航点的状态</strong></p><p id="2901" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个点在任何给定时间都有一个状态，在我们的情况下，该状态应该定义<em class="kq">位置</em>、<em class="kq">α</em>和<em class="kq">比例</em>值。在我看来，最好在一个单独的类中显式定义这样的状态，因为这种方法是可伸缩的，并且易于维护。让我们创建<code class="fe km kn ko kp b">NavigationDotState</code>类</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">定义导航点视图状态的类</figcaption></figure><p id="e7db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">动态生成导航点</strong></p><p id="28e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了生成点，我们需要知道创建视图的数量。我们还需要保存对已创建视图的引用，以便以后操作它们的属性。考虑到这一点，我们可以在<code class="fe km kn ko kp b">MainActivity</code>中创建一个助手<code class="fe km kn ko kp b">initNavigationDots</code>函数，手动创建视图并将它们添加到<code class="fe km kn ko kp b">containerIntroDots</code>线性布局中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">将导航点初始化为视图并将它们添加到线性布局容器的函数</figcaption></figure><p id="5f92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们一收到要显示的片段列表就需要调用这个函数，所以最好是调用<code class="fe km kn ko kp b">fragmentTypeListLiveData</code>观察者</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">调用导航点初始化</figcaption></figure><p id="e971" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！现在，每当我们收到片段列表时，我们将在主活动中显示相同数量的导航点。</p><p id="c40a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">检查点:</strong>运行您的应用程序，查看导航点是否正确显示在屏幕底部。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="bf95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">向导航点添加动画</strong></p><p id="1b31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从顶部开始——为了在任何给定时间显示导航点，activity需要知道什么？答:列出导航点状态和视图引用。通过在主活动中观察<code class="fe km kn ko kp b">LiveData</code>来实现这种方法非常简单——一旦接收到具有新状态的列表，我们就在<em class="kq">位置</em>获得视图，并对其应用<em class="kq"> alpha </em>和<em class="kq"> scale </em>值。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">观察导航点的状态并将其应用于视图</figcaption></figure><p id="c66a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这么简单。现在是时候到<code class="fe km kn ko kp b">navigationDotStateLiveData</code>的幕后看看导航点状态是如何定义的了。转到<code class="fe km kn ko kp b">MainAppActivityViewModel</code>并创建以下字段</p><pre class="ks kt ku kv gt nk kp nl nm aw nn bi"><span id="4137" class="no mi iq kp b gy np nq l nr ns">val navigationDotStateLiveData: LiveData&lt;List&lt;NavigationDotState&gt;?&gt;</span></pre><p id="fc36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来思考一下，改变导航点的状态需要考虑什么:</p><ol class=""><li id="b668" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk nu ll lm ln bi translated">点的状态取决于<code class="fe km kn ko kp b">mViewHolderScrollStateLiveData</code>中的转换状态。如果没有过渡状态，则返回默认导航点状态。</li><li id="4142" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk nu ll lm ln bi translated">在任何给定的过渡时间，只有2个点可以被激活。这意味着我们需要知道需要改变状态的点的位置</li></ol><p id="96a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步，需要将<code class="fe km kn ko kp b">Transformation</code>加到<code class="fe km kn ko kp b">mViewHolerScrollStateLiveData</code>上，并检查当前值是否不为空。这将为我们初始化<code class="fe km kn ko kp b">List&lt;NavigationState&gt;</code>打下基础</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">将过渡状态转换成具有导航点状态列表</figcaption></figure><p id="bfd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至于第二步，需要找到参与转换的两个点的位置。会涉及到一些数学知识，所以要做好准备！</p><p id="9719" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要从<code class="fe km kn ko kp b">offsetSum</code>开始计算碎片的位置及其偏移值。这样我们就知道哪两个片段参与了转换，以及转换完成的百分比(偏移量)。每个片段可以处于以下状态之一:</p><ol class=""><li id="e475" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk nu ll lm ln bi translated">片段占据整个屏幕，意味着没有过渡。</li><li id="ee5c" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk nu ll lm ln bi translated">用户正在向片段导航。它对用户来说是完全不可见的，现在开始从屏幕的任何一部分出现。</li><li id="4685" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk nu ll lm ln bi translated">用户正在离开片段。它占据了整个屏幕，现在正被移动到屏幕的任何一部分。</li><li id="4b11" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk nu ll lm ln bi translated">片段不参与转换，这意味着它对用户是不可见的</li></ol><blockquote class="lt lu lv"><p id="4184" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated"><strong class="jp ir">例题</strong></p><p id="457f" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated">1.用户从位置0的片段向片段1滑动了30%。<code class="fe km kn ko kp b"><em class="iq">offsetSum</em></code>将会是<code class="fe km kn ko kp b"><em class="iq">0.30</em></code>。意味着<strong class="jp ir">片段0 </strong>向<strong class="jp ir">片段1 </strong>移动了<strong class="jp ir"> 30% </strong>。<strong class="jp ir">片段2 </strong>不参与转场。</p><p id="5366" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated">2.用户从位置2的片段刷回到位置1 75%。在这种情况下，<code class="fe km kn ko kp b"><em class="iq">offsetSum</em></code>将会是<code class="fe km kn ko kp b"><em class="iq">1.25</em></code>。这意味着<strong class="jp ir">片段1 </strong>向<strong class="jp ir">片段2 </strong>移动了25%。<strong class="jp ir">片段0 </strong>不参与转场。</p></blockquote><p id="b011" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">知道了<code class="fe km kn ko kp b">offsetSum</code>的值和片段的位置，我们就可以计算它的导航点的可见性和比例。我们可以迭代<code class="fe km kn ko kp b">fragmentTypeList</code>来计算每个片段的状态。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">计算每个片段的状态</figcaption></figure><p id="7a6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从简单的部分开始，我们可以肯定地说，当fragment完全可见时，那么它的导航点应该有max <em class="kq"> alpha </em>和<em class="kq"> scale </em>，当fragment不参与过渡时则相反。</p><pre class="ks kt ku kv gt nk kp nl nm aw nn bi"><span id="5cfa" class="no mi iq kp b gy np nq l nr ns">when(offsetSum - fragmentIndex){<br/>    0.0f -&gt; {<br/>        // Dot of the fragment that occupies the whole screen  <br/>        newAlpha = NavigationDotState.ALPHA_MAX<br/>        newScale = NavigationDotState.SCALE_MAX<br/>    },<br/>    ...<br/>    else -&gt; {<br/>        // Fragment does not participate in transition<br/>        newAlpha = NavigationDotState.ALPHA_MIN<br/>        newScale = NavigationDotState.SCALE_MIN<br/>    }<br/>}</span></pre><p id="6905" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在有必要引入两个新的属性:<code class="fe km kn ko kp b">alphaDelta</code>和<code class="fe km kn ko kp b">scaleDelta</code>。简单来说我们假设<code class="fe km kn ko kp b">ALPHA_MAX</code>、<code class="fe km kn ko kp b">SCALE_MAX</code>、<code class="fe km kn ko kp b">ALPHA_MIN</code>和<code class="fe km kn ko kp b">SCALE_MIN</code>不会分别高于<code class="fe km kn ko kp b">1.0</code>和低于<code class="fe km kn ko kp b">0.0</code>，deltas就是最大值和最小值之差。</p><pre class="ks kt ku kv gt nk kp nl nm aw nn bi"><span id="01fd" class="no mi iq kp b gy np nq l nr ns">val alphaDelta = ALPHA_MAX - ALPHA_MIN<br/>val scaleDelta = SCALE_MAX - SCALE_MIN</span></pre><p id="03d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">offset</code>的范围为<code class="fe km kn ko kp b">[0.0, 1.0]</code>，可以作为过渡完成的百分比。因此，现在我们已经做好了计算所需规模和可见性的一切准备。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">导航点的比例和可见度状态计算的完整代码</figcaption></figure><p id="ebfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有代码就绪后，让我们看看如何计算我们的<code class="fe km kn ko kp b">navigationStateLiveData</code>值:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">航行状态计算的最终代码</figcaption></figure><p id="ce86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">检查点</strong>:运行你的应用程序来看看导航点的动画效果！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">导航点动画的最终结果</figcaption></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="bcca" class="mh mi iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated"><strong class="ak">最后一章:动态导航文本可见性</strong></h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv le l"/></div></figure><p id="1345" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们定义文本元素的可见性规则:</p><ul class=""><li id="c18f" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated"><em class="kq">跳过</em>和<em class="kq">下一个</em>按钮应在除最后一个屏幕之外的所有屏幕上可见</li><li id="3389" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><em class="kq">完成</em>按钮应该只在最后一个屏幕上可见</li><li id="b55e" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">过渡期间文本元素的可见性取决于<em class="kq">偏移</em></li></ul><p id="aba5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们已经预定义了按钮的数量，所以让我们在单个<code class="fe km kn ko kp b">NavigationTextState</code>类中定义它们的可见性</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">保持导航文本元素可见性状态的类</figcaption></figure><p id="4ae8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主活动应该使用<code class="fe km kn ko kp b">LiveData</code>接收状态，并对相应的元素应用可见性</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">根据状态设置导航文本元素的可见性</figcaption></figure><p id="7144" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，<code class="fe km kn ko kp b">navigationTextStateLiveData</code>依赖于<code class="fe km kn ko kp b">mViewHolderScrollStateLiveData</code>中的状态，这意味着我们需要应用<code class="fe km kn ko kp b">Transformations.map(...){ ... }</code>功能。我们需要检查的事项:</p><ol class=""><li id="7d98" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk nu ll lm ln bi translated">如果<code class="fe km kn ko kp b">viewHolderScrollState</code>为空，<em class="kq">跳过</em>和<em class="kq">下一个</em>按钮应该可见，<em class="kq">完成</em>应该不可见。</li><li id="fa52" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk nu ll lm ln bi translated">如果显示最后一个片段(<code class="fe km kn ko kp b">floor(offsetSum) == (fragmentTypeList.size - 1)</code>，那么<em class="kq">跳过</em>和<em class="kq">下一个</em>按钮应该不可见，<em class="kq">结束</em>应该可见。</li><li id="268a" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk nu ll lm ln bi translated">如果<code class="fe km kn ko kp b">(fragmentTypeList.size - 1) - offsetSum</code>在<code class="fe km kn ko kp b">[0.0, 1.0]</code>的范围内，那么到/从最后一个片段的过渡正在进行。</li><li id="3986" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk nu ll lm ln bi translated">任何其他情况下，<em class="kq">跳过</em>和<em class="kq">下一个</em>按钮应该可见，<em class="kq">结束</em>应该不可见。</li></ol><p id="403e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候将我们的知识转化为代码了！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">导航文本状态的计算</figcaption></figure><blockquote class="lt lu lv"><p id="6c92" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>:视图类中的getAlpha()和getVisibility()互不依赖。这意味着即使getAlpha()可能返回0.0，如果它的getVisibility()返回View.VISIBLE，视图仍然会呈现在屏幕上。</p><p id="0575" class="jn jo kq jp b jq jr js jt ju jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj kk ij bi translated">如果视图的alpha = 0.0，可见性= View。VISIBLE呈现在任何其他元素之上，那么它将阻止click listeners在底层元素中触发。</p></blockquote><p id="77f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了防止文本元素彼此“重叠”,有必要改变<code class="fe km kn ko kp b">navigationTextStateLiveData</code>观察点——一旦alpha低于或高于某个阈值，相应地改变元素的可见性。这就是<code class="fe km kn ko kp b">navigationTextStateLiveData</code>观察者现在的样子</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">根据alpha值改变文本元素的可见性</figcaption></figure><h2 id="9545" class="no mi iq bd mj nw nx dn mn ny nz dp mr jy oa ob mv kc oc od mz kg oe of nd og bi translated"><strong class="ak">向文本导航元素添加点击监听器</strong></h2><p id="3eb1" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">一旦在主活动中收到片段列表，就必须初始化文本点击监听器。让我们在主活动中创建<code class="fe km kn ko kp b">initListeners</code>函数来初始化点击监听器。<code class="fe km kn ko kp b">IntroFinishedActivity</code>此时还没有创建，所以你可以简单地<a class="ae kl" href="https://github.com/xzhorikx/slider-intro/blob/master/app/src/main/java/alexz/sliderintro/activity/IntroFinishedActivity.kt" rel="noopener ugc nofollow" target="_blank">从GitHub </a>获取它。别忘了在<code class="fe km kn ko kp b">AndroidManifest.xml</code>申报</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">导航按钮点击监听器的初始化</figcaption></figure><p id="3ee1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，从<code class="fe km kn ko kp b">fragmentTypeListLiveData</code>观察器调用<code class="fe km kn ko kp b">initListeners</code></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">从片段实时数据观察器调用点击监听器初始化</figcaption></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="2b09" class="mh mi iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">结束🎇</h1><p id="24bc" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">恭喜你！您已经使用架构组件实现了一个非常棒的可伸缩的intro slider，并且可能学到了一些关于状态表示和管理的新知识！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">最终简介滑块结果</figcaption></figure><p id="1499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">源代码可在<a class="ae kl" href="https://github.com/xzhorikx/slider-intro" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>