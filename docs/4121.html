<html>
<head>
<title>Lets take Prisma 2 for a test drive on AWS Lambda with GraphQL 🏎️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用GraphQL在AWS Lambda上测试一下Prisma 2🏎️</h1>
<blockquote>原文：<a href="https://itnext.io/lets-take-prisma-2-for-a-test-drive-on-aws-lambda-with-graphql-%EF%B8%8F-f4be711e93cc?source=collection_archive---------1-----------------------#2020-05-01">https://itnext.io/lets-take-prisma-2-for-a-test-drive-on-aws-lambda-with-graphql-%EF%B8%8F-f4be711e93cc?source=collection_archive---------1-----------------------#2020-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8b45dd0ee0c65a159fbfd7dd0926a941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuh7wGixOnBkP04LmfN4PQ.png"/></div></div></figure><p id="cd6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"> Prisma </a>是针对<a class="ae kw" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">节点</a>的开源数据库工具包。意在取代<a class="ae kw" href="https://blog.bitsrc.io/what-is-an-orm-and-why-you-should-use-it-b2b6f75f5e2a" rel="noopener ugc nofollow" target="_blank"> ORMs </a>像<a class="ae kw" href="https://typeorm.io/" rel="noopener ugc nofollow" target="_blank">type ORMs</a>、<a class="ae kw" href="https://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex.js </a>等。Prisma也是在后端API中编写原始SQL的一种选择。最初它是用<a class="ae kw" href="http://graphql.org" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>来吹捧的，然而，你也可以用<a class="ae kw" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a>来使用它。Prisma通过创建与数据库模型相匹配的查询，使您更容易使用数据库。</p><blockquote class="kx ky kz"><p id="d374" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">注意Prisma目前只支持<a class="ae kw" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>、<a class="ae kw" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>和<a class="ae kw" href="https://www.sqlite.org/" rel="noopener ugc nofollow" target="_blank"> SQLite </a>。</p></blockquote><p id="9a63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我以前在一个项目<a class="ae kw" href="https://github.com/AmoDinho/formulaone-graphql" rel="noopener ugc nofollow" target="_blank">中使用过Prisma 1，并经历了一段糟糕的部署时间。这一次，有关于如何部署它的清晰文档。因此，我将在这篇文章的剩余部分回顾我在</a><a class="ae kw" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>上试驾Prisma 2时的经历。</p><p id="f64b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub 上有一个回购协议，其中的最终代码将在本文中使用，在我看来，你可以开始运行并构建一些重要的东西。</p><p id="0662" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我假设你以前使用过<a class="ae kw" href="https://www.serverless.com/framework/docs/providers/aws/guide/credentials/" rel="noopener ugc nofollow" target="_blank"> AWS </a>和<a class="ae kw" href="https://www.serverless.com/framework/docs/providers/aws/guide/installation/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>。🤰如果不是的话，<a class="ae kw" href="https://serverless-stack.com/" rel="noopener ugc nofollow" target="_blank">无服务器堆栈</a>教程是一个很棒的免费资源！🌠</p><h1 id="d622" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何着手设置一切？</h1><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="1184" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Prisma CLI 将是你用来建立你的Prisma项目，并告诉它你正在使用什么数据库。</p><p id="5fe7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而Prisma客户端将查看您的数据库并为您进行所有查询。在这个特殊的例子中，我使用的是GraphQL，Prisma通常提倡在制作GraphQL模式时使用<a class="ae kw" href="https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3" rel="noopener ugc nofollow" target="_blank">代码优先的方法</a>。这将要求你使用他们的<a class="ae kw" href="https://nexus.js.org/" rel="noopener ugc nofollow" target="_blank"> Nexus库</a>。在这个特别的项目中，我打算采用<a class="ae kw" href="https://www.apollographql.com/docs/graphql-tools/generate-schema/" rel="noopener ugc nofollow" target="_blank"> SDL优先</a>的方法。🤠</p><p id="7188" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我首先用<a class="ae kw" href="https://github.com/pimp-my-book/serverless-graphql-nodejs-starter" rel="noopener ugc nofollow" target="_blank">无服务器GraphQL节点启动器</a>搭建了一个<a class="ae kw" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>项目。然后，我在我的本地机器上用MySQL创建了一个数据库，模式如下:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/29a8bfa70e0506c649c5b452fbe86c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52YQFCnY4MiMJs4SvVhExg.png"/></div></div></figure><p id="489c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用<a class="ae kw" href="https://dev.mysql.com/downloads/workbench/" rel="noopener ugc nofollow" target="_blank"> MySQL workbench </a>来创建表格。</p><p id="ca03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我安装了Prisma CLI并初始化了项目。完成后，我将我的本地数据库URL添加到<code class="fe mj mk ml mm b">schema.prisma</code>文件中:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/c97d16f6bbcf52b4e7b17a7ef9c6ab31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKD5b6bMS3NHiqa7hkhSOQ.png"/></div></div></figure><p id="ea41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这之后，我们需要自省数据库，这样Prisma就可以用下面的命令为我们生成模型:</p><pre class="mc md me mf gt mo mm mp mq aw mr bi"><span id="eabb" class="ms lf iq mm b gy mt mu l mv mw">$ prisma introspect</span></pre><p id="1b77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将为您创建一个数据模型，如下所示:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/92711969be6e1c1a264df9c287ad3e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mg5v4XWkxHA2MozoasYPBw.png"/></div></div></figure><p id="a236" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在请记住，我们需要使用<code class="fe mj mk ml mm b"><a class="ae kw" href="https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/api" rel="noopener ugc nofollow" target="_blank">@prisma/client</a></code>来允许我们连接到数据模型，以便能够针对我们的数据库运行查询。如果您在您的终端中运行<code class="fe mj mk ml mm b"><strong class="ka ir"><em class="la">yarn prisma generate</em></strong></code>,您应该得到以下内容:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/e93e4696ee2dd9f2baad8cf3c22628fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lis6L4F9inHqU0-hUYGg7Q.png"/></div></div></figure><p id="2d82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了所有的设置，您应该能够针对您的数据库编写查询。因为我使用的是GraphQL，所以我设置了一个简单的模式:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/1a398ca24f9e16905e27c4efb14debae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dL-W7dQ2Mhuoe7RqLNGsYQ.png"/></div></div></figure><p id="a01f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以在我的例子中，我只是写了一个突变来创建一个F1车队:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/d963f5128de716e87e654120f1df113c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S2NCAUC6gY5ndit7hJ339Q.png"/></div></div></figure><p id="4a9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单吧？如果我在Playgroud中执行这个，在运行<code class="fe mj mk ml mm b">sls offline</code>之后，它会从新创建的变异中返回数据:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/7fdbb91e96e1ea8d24ab6f6a71bbffe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QIILKGIyicoNpWQUCN6oqA.png"/></div></div></figure><p id="d075" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在一切都在本地工作，但是如果你在云中开发应用足够长的时间，你就会知道它在云上工作之前是不工作的。</p><p id="3770" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关键是确保您的<code class="fe mj mk ml mm b">package.json</code>中有必要的Prisma命令，并且正确配置了您的<a class="ae kw" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>。很多功劳都要归功于<a class="ae kw" href="https://dested.com/" rel="noopener ugc nofollow" target="_blank"> Salvatore </a>(查看他的<a class="ae kw" href="https://github.com/dested/OrbitalGa.me" rel="noopener ugc nofollow" target="_blank"> fullstack项目</a>的类似堆栈)，他在部署到AWS时遇到了类似的问题。CloudWatch给出以下错误:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/73aeaeb493d291f6986d36868f05e4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TS0Y9US0rxdAwq8T0aUlvQ.png"/></div></div></figure><p id="c8cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了避免这个错误，请确保这些命令在您的<code class="fe mj mk ml mm b"><strong class="ka ir"><em class="la">package.json:</em></strong></code>中</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/6083c118a56b40a749dbaf361701df97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyKD9tPqsoe5grctN26LwA.png"/></div></div></figure><p id="8348" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您需要添加<a class="ae kw" href="https://webpack.js.org/plugins/copy-webpack-plugin/" rel="noopener ugc nofollow" target="_blank"> copy-webpack-plugin </a>，它将使webpack能够访问我们的代码绑定后所需的二进制文件。</p><p id="0bd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，确保您在Webpack部分下的<code class="fe mj mk ml mm b"><strong class="ka ir"><em class="la">serverless.yml</em></strong></code>的定制部分引用了<code class="fe mj mk ml mm b">prisma generate </code>命令。这样做是为了确保您的Prisma客户端库是在<code class="fe mj mk ml mm b"><strong class="ka ir"><em class="la">node_modules:</em></strong></code>中创建的</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/3ae3006368b8791e1481ce6c539d8e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BHwKZwpGMF42xc555yKpZw.png"/></div></div></figure><p id="2eb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们只需要相应地更新我们的Webpack配置，告诉插件在哪里可以找到二进制文件(<code class="fe mj mk ml mm b"><strong class="ka ir"><em class="la">schema.prisma</em></strong></code>)并将其复制到我们的构建中:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/019fe236f1d37e45908a7c033157f5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYlsMU0HrAOoWsQPUJIjvw.png"/></div></div></figure><p id="7fbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切都应该在代码方面完成🚀。</p><p id="4586" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要一个<a class="ae kw" href="https://aws.amazon.com/rds/aurora/serverless/" rel="noopener ugc nofollow" target="_blank">无服务器RDS Aurora集群</a>的基础设施。确保你有一个AWS账户，并为你的Lambda配置了一个<a class="ae kw" href="https://aws.amazon.com/vpc/" rel="noopener ugc nofollow" target="_blank"> VPC </a>。你可以按照这篇<a class="ae kw" href="https://hackernoon.com/a-crash-course-on-serverless-with-aws-building-apis-with-lambda-and-aurora-serverless-49885c46e37a" rel="noopener ugc nofollow" target="_blank">文章</a>的第一部分在RDS上配置Aurora Serverless。如果您有时间，您可以通过查看来自无服务器框架团队的这个<a class="ae kw" href="https://github.com/serverless/examples/tree/master/aws-node-graphql-and-rds" rel="noopener ugc nofollow" target="_blank">示例报告</a>来尝试将其配置为<a class="ae kw" href="https://en.wikipedia.org/wiki/Infrastructure_as_code" rel="noopener ugc nofollow" target="_blank"> IaaS </a>。</p><p id="169e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成所有这些后，确保您在<code class="fe mj mk ml mm b">serverless.yml.</code>中引用了您的VPC，然后确保您已经将连接URL添加到您的<em class="la"> </em> <code class="fe mj mk ml mm b"><strong class="ka ir">.env</strong></code>文件中，以便Prisma能够连接到云中的数据库。</p><p id="be96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个<code class="fe mj mk ml mm b">.env</code>文件的例子(由Prisma提供):</p><pre class="mc md me mf gt mo mm mp mq aw mr bi"><span id="f22d" class="ms lf iq mm b gy mt mu l mv mw">DATABASE_URL="mysql://johndoe:randompassword@localhost:3306/mydb"</span></pre><p id="7154" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是带有VPC端点的<code class="fe mj mk ml mm b"><strong class="ka ir"><em class="la">serverless.yml</em></strong></code>的样子:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/98fb152c6b0262a1328257f82090a20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XoCBan9YyoHA9KXAXZVXAQ.png"/></div></div></figure><p id="ceb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以部署这个功能:</p><pre class="mc md me mf gt mo mm mp mq aw mr bi"><span id="d6e2" class="ms lf iq mm b gy mt mu l mv mw">$ sls deploy</span></pre><p id="66e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切顺利，您的控制台输出应该如下所示:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/682a9417386e7daff44dd1ea558df853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1jXLR8ceohFy8r4YWwHcQ.png"/></div></div></figure><p id="950a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该能够在点击提供的端点后创建一个突变:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/4adc03233476c7468fec3608e0bb69b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HwILsBaDYBi6msGbwHmZQ.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">请确保“/dev/”位于Lambda终结点和“graphql”之间</figcaption></figure><p id="9edd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例子没有考虑到<code class="fe mj mk ml mm b">NODE_ENV</code>阶段中的变化，在这个阶段中，基于您的环境(开发、暂存等)，您会有不同的数据库URL。为此，我会尝试以下方法:</p><pre class="mc md me mf gt mo mm mp mq aw mr bi"><span id="b73c" class="ms lf iq mm b gy mt mu l mv mw"> process.env.database_url = process.env.NODE_ENV = DEVELOPEMENT ? ‘dev_url’ : ‘prod_url’</span></pre><h1 id="4eff" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">太酷了，那么我们为什么要在目前的野外使用这个呢🤷‍♂️?</h1><h2 id="f006" class="ms lf iq bd lg nj nk dn lk nl nm dp lo kj nn no ls kn np nq lw kr nr ns ma nt bi translated">原始SQL</h2><p id="6fe5" class="pw-post-body-paragraph jy jz iq ka b kb nu kd ke kf nv kh ki kj nw kl km kn nx kp kq kr ny kt ku kv ij bi translated">就我个人而言，我不想再写原始SQL，这是我在之前的项目中写的:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/077a06a5483662f7bbd74e77b01fd2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFETMM3snEA7tmeVLwhxeg.png"/></div></div></figure><p id="bd56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为Knex和<a class="ae kw" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>对Lambda不起作用，这最终让我别无选择，只能编写原始SQL。</p><p id="765a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Prisma的开发者体验是无缝的！一个小时后，我有了一些在本地运行的东西，这将使它成为向您的CTO/技术主管宣传它的有力案例。</p><h2 id="c352" class="ms lf iq bd lg nj nk dn lk nl nm dp lo kj nn no ls kn np nq lw kr nr ns ma nt bi translated">Prisma工作室</h2><p id="7bf3" class="pw-post-body-paragraph jy jz iq ka b kb nu kd ke kf nv kh ki kj nw kl km kn nx kp kq kr ny kt ku kv ij bi translated">如果您在终端中运行以下程序:</p><pre class="mc md me mf gt mo mm mp mq aw mr bi"><span id="d1a7" class="ms lf iq mm b gy mt mu l mv mw">$ prisma studio --experimental</span></pre><p id="66b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它会在你的浏览器中打开一个新窗口😯：</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/1b8918d48048bf4342d77ac8262cdd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Xv4s4o_081d_Q9QZzQDcg.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">Prisma工作室</figcaption></figure><p id="e321" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Prisma Studio允许我在一个漂亮的GUI中查看与我创建的模型相关的所有数据，并可以进行基本的CRUD操作。这完全消除了为这些类型的工作流安装其他第三方工具的需要。🎉</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="7a67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，Prisma 2仍处于测试阶段，因此您可能希望不要将其用于生产工作负载。一旦它普遍可用，并且有了这篇文章的内容，你应该能够用GraphQL在Lambda上制造一个领先的、生产就绪的API！💰</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">现在你已经有了一个前沿的开发者体验，去取悦你的用户吧！</figcaption></figure></div></div>    
</body>
</html>