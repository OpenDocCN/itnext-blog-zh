<html>
<head>
<title>Three Ways to Use Linkerd with Kubernetes Jobs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes作业中使用Linkerd的三种方式</h1>
<blockquote>原文：<a href="https://itnext.io/three-ways-to-use-linkerd-with-kubernetes-jobs-c12ccc6d4c7c?source=collection_archive---------2-----------------------#2021-10-12">https://itnext.io/three-ways-to-use-linkerd-with-kubernetes-jobs-c12ccc6d4c7c?source=collection_archive---------2-----------------------#2021-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/47c2337f8f05b544872cbf2584b87199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RIP70HX1FOLDYEwNVbjciw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@angelyviviana55?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">王嘉卉·阿塞维多</a>在<a class="ae kc" href="https://unsplash.com/s/photos/infinite?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="6b51" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">问题是</h1><p id="45fe" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">将资源定义为Linkerd网格的常用方法有两种:</p><ul class=""><li id="d694" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">显式:为每个资源添加linkerd.io/inject注释<strong class="ld ir"/></li><li id="f510" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">隐式:为名称空间添加<strong class="ld ir">linkerd.io/inject</strong>注释</li></ul><p id="2d89" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">直截了当的方式比含蓄的方式更彻底。但是如果你不得不使用Kubernetes的作业，你会对其中任何一个有问题。工作是最棘手的资源。和CronJobs，因为它们也可以运行作业。</p><p id="28a5" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">用<strong class="ld ir"><em class="ms">linkerd.io/inject:启用</em> </strong>注释作业完成后不会终止。你可能会问——为什么？答案很简单。注入的<strong class="ld ir"> linkerd-proxy </strong>在作业容器完成其工作后继续运行。</p><p id="adc8" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">而且，如果使用隐式的方式，你会惊讶于cron和jobs开始无限运行。你可以在下图中看到这一点。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/16606516ae158f93324b3b1cf24753eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnEUFuxpGqcxHUgsqKG3lw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">问题的典型情况</figcaption></figure><h1 id="14a1" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">解决方案</h1><p id="beb6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有三种方法可以解决这个问题:</p><ul class=""><li id="ad1f" class="lz ma iq ld b le mb li mc lm md lq me lu mf ly mg mh mi mj bi translated">不要对作业使用linkerd</li><li id="a1c2" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">手动调用linkerd代理关闭挂钩</li><li id="b3de" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">使用<a class="ae kc" href="https://github.com/linkerd/linkerd-await" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir">linkerd-await</strong></a></li></ul><p id="a444" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">让我们逐一看看。</p><h2 id="1c5c" class="my ke iq bd kf mz na dn kj nb nc dp kn lm nd ne kr lq nf ng kv lu nh ni kz nj bi translated">解决方案1:不要啮合</h2><p id="4605" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果你不想要网状作业，这是最简单的解决方案。</p><p id="6fa2" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">因此，如果明确定义了网格资源，就不应该为任务资源添加注释。很简单！</p><p id="4f8e" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">在隐式变体的情况下，您应该为每个作业禁用linkerd代理注入，例如，对于某些cronjob:</p><pre class="mu mv mw mx gt nk nl nm nn aw no bi"><span id="4f67" class="my ke iq nl b gy np nq l nr ns">jobTemplate:<br/>  spec:<br/>    template:<br/>      metadata:<br/><strong class="nl ir">        annotations:<br/>          linkerd.io/inject: disabled</strong></span></pre><p id="f038" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir"><em class="ms"/></strong>这里的主要缺点是，有时你需要网格来完成工作。例如，从2.11.0开始，Linkerd支持授权策略。如果策略要求mTLS身份验证，则不可能请求其他pod，但是作业不在网格中。</p><h2 id="b97b" class="my ke iq bd kf mz na dn kj nb nc dp kn lm nd ne kr lq nf ng kv lu nh ni kz nj bi translated">解决方案2:手动调用关机挂钩</h2><p id="cc89" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Linkerd代理有一个关闭挂钩<a class="ae kc" href="https://github.com/linkerd/linkerd2-proxy/commit/24bee8cbc5413b4587a14bea1e2714ce1f1f919a" rel="noopener ugc nofollow" target="_blank">可以从同一个POD的另一个容器中调用。</a></p><p id="5c6a" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">实现它有几种选择。例如，可以在作业结束时调用它，只需从代码中调用。但是这需要额外的工作。我们应该将此功能添加到每项工作或中间件中，重新构建所有功能，然后推出。<em class="ms">痛苦的</em>。</p><p id="edf4" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">当我们模板化每个作业时，我们可以尝试在主要流程结束后添加额外的步骤:</p><pre class="mu mv mw mx gt nk nl nm nn aw no bi"><span id="b38a" class="my ke iq nl b gy np nq l nr ns">command: ["/bin/sh"]<br/>args: ["-c", <br/>       "&lt;job_run_command_here&gt;",<br/>       "; <strong class="nl ir">CODE=$?; wget --post-data hello=shutdown </strong><a class="ae kc" href="http://localhost:4191/shutdown" rel="noopener ugc nofollow" target="_blank"><strong class="nl ir">http://localhost:4191/shutdown</strong></a><strong class="nl ir">; exit $CODE</strong>;"]</span></pre><p id="2922" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">很丑，但是很管用！</p><p id="d302" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir"> <em class="ms">这里的</em> </strong>主要缺点是容器可能还没有<strong class="ld ir">卷曲</strong>或<strong class="ld ir"> wget </strong>，或者有些容器有一个而有些有另一个。还有，真的不好看。</p><h2 id="85e9" class="my ke iq bd kf mz na dn kj nb nc dp kn lm nd ne kr lq nf ng kv lu nh ni kz nj bi translated">解决方案3:使用linkerd-await</h2><p id="eed0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">linkerd-await 是一个命令包装器，它轮询linkerd是否准备就绪，并可以在命令结束后调用shutdown hook。</p><p id="9ed7" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">GitHub上的官方例子建议在构建阶段将其添加到容器中。这再次意味着，我们需要为所有作业重建所有docker映像，以支持如下命令:</p><pre class="mu mv mw mx gt nk nl nm nn aw no bi"><span id="0945" class="my ke iq nl b gy np nq l nr ns">command: ["/linkerd-await"]<br/>args: ["--shutdown", "--", "/coolcommand"]</span></pre><p id="3c98" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir"><em class="ms"/></strong>这里的主要缺点是，我们应该在构建阶段添加一个第三方组件，将它保存在docker映像中，并在每次包装器升级时都这样做。这需要时间和努力。</p><h2 id="7506" class="my ke iq bd kf mz na dn kj nb nc dp kn lm nd ne kr lq nf ng kv lu nh ni kz nj bi translated">解决方案#3.1:使用linkerd-以另一种方式等待</h2><p id="e043" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">但是，如果我们尝试使用解决方案2中的方法和解决方案3中的包装器呢？</p><blockquote class="nt nu nv"><p id="3e0f" class="lb lc ms ld b le mb lg lh li mc lk ll nw mp lo lp nx mq ls lt ny mr lw lx ly ij bi translated">我们不想为作业重建映像，但我们希望使用包装器，因为它非常好。</p></blockquote><p id="361d" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">因此，我们需要以某种方式将包装器注入到作业容器中，并直接调用它。欢迎来到豆荚卷。</p><p id="2631" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">首先，将空目录卷添加到POD定义中:</p><pre class="mu mv mw mx gt nk nl nm nn aw no bi"><span id="19e2" class="my ke iq nl b gy np nq l nr ns"><strong class="nl ir">volumes:<br/>- name: linkerd-await<br/>  emptyDir: {}</strong></span></pre><p id="2faf" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">其次，添加一个init容器，该容器带有一个将<strong class="ld ir"> linkerd-await </strong>复制到卷的包装器:</p><pre class="mu mv mw mx gt nk nl nm nn aw no bi"><span id="5fb4" class="my ke iq nl b gy np nq l nr ns"># Dockerfile<br/>FROM alpine:latest<br/>ARG LINKERD_AWAIT_VERSION=v0.2.4</span><span id="9557" class="my ke iq nl b gy nz nq l nr ns">RUN apk add curl<br/>RUN curl -sSLo /tmp/linkerd-await <a class="ae kc" href="https://github.com/linkerd/linkerd-await/releases/download/release%2F${LINKERD_AWAIT_VERSION}/linkerd-await-${LINKERD_AWAIT_VERSION}-amd64" rel="noopener ugc nofollow" target="_blank">https://github.com/linkerd/linkerd-await/releases/download/release%2F${LINKERD_AWAIT_VERSION}/linkerd-await-${LINKERD_AWAIT_VERSION}-amd64</a> &amp;&amp; chmod 755 /tmp/linkerd-await</span><span id="a083" class="my ke iq nl b gy nz nq l nr ns"># Kubernetes POD definition<br/>initContainers:<br/>- name: linkerd-await<br/>  image: "&lt;image&gt;/linkerd-await:0.2.4"<br/><strong class="nl ir">  command: ["cp"]<br/>  args: ["/tmp/linkerd-await", "/linkerd-await"]<br/>  volumeMounts:<br/>  - mountPath: /linkerd<br/>    name: linkerd-await</strong></span></pre><p id="bdb8" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">第三，将卷附加到主容器，并用<strong class="ld ir"> linkerd-await </strong>包装基本命令:</p><pre class="mu mv mw mx gt nk nl nm nn aw no bi"><span id="4001" class="my ke iq nl b gy np nq l nr ns"><strong class="nl ir">volumeMounts:<br/>- mountPath: /linkerd<br/>  name: linkerd-await</strong><br/>command: ["/linkerd-await"]<br/>args: ["--shutdown", "--", "/coolcommand"]</span></pre><p id="366c" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated">就是这样！</p><p id="6cb3" class="pw-post-body-paragraph lb lc iq ld b le mb lg lh li mc lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ij bi translated"><strong class="ld ir"> <em class="ms">这里的主要缺点是</em> </strong>增加了一个init容器，使得POD定义更加复杂。但是这里的优点是有益的。我们不需要重新构建，只需要一个控制点就可以控制舵图，并使用推荐的方法在作业使用的情况下关闭linkerd代理。</p><h1 id="545a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h1><ul class=""><li id="c534" class="lz ma iq ld b le lf li lj lm oa lq ob lu oc ly mg mh mi mj bi translated">请记住，如果没有额外的工作，linkerd不会与Kubernetes Jobs或CronJobs一起工作</li><li id="c8fc" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">如果作业不需要网格，则禁用代理注入</li><li id="9bf9" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">在另一种情况下，建议使用linkerd-await包装器</li><li id="e601" class="lz ma iq ld b le mk li ml lm mm lq mn lu mo ly mg mh mi mj bi translated">在规模上，如果你有几十个工作，尝试使用POD volume注入包装到基础容器</li></ul></div></div>    
</body>
</html>