<html>
<head>
<title>Reflecting business logic rules into the domain models using typescript — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用typescript将业务逻辑规则反映到域模型中—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/reflecting-business-logic-rules-into-the-domain-models-using-typescript-part-2-61a19fba069d?source=collection_archive---------3-----------------------#2020-08-02">https://itnext.io/reflecting-business-logic-rules-into-the-domain-models-using-typescript-part-2-61a19fba069d?source=collection_archive---------3-----------------------#2020-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a86e0f73d52fa2b9de709cf5d33b222f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-d4vOE2IRgxqMEM1VJSciw.jpeg"/></div></div></figure><p id="d425" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在之前的文章中，我们学习了如何创建自文档化的类型和模型。但是它们只是类型，没有任何功能。</p><p id="4bb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将编写一些代码来创建和验证这些类型。</p><p id="8f06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文的最后，我们的类型可以用于现实生活中的项目。</p><p id="0c40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">项目源代码可从以下网址获得:</p><div class="la lb gp gr lc ld"><a href="https://github.com/mohsensaremi/reflecting-business-logic-rules-into-the-domain-models" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">mohsensaremi/将业务逻辑规则反映到领域模型中</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">为mohsensaremi/reflecting-business-logic-rules-into-domain-models开发作出贡献，方法是创建一个关于…的帐户</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">github.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jz ld"/></div></div></a></div><h1 id="98c8" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">引导程序</h1><p id="131e" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">首先，我们需要一个typescript项目。所以让我们来创造它。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="32e7" class="ne lt it na b gy nf ng l nh ni">yarn init -y<br/>yarn add --dev <!-- -->typescript ts-node<br/>./node_modules/.bin/tsc --init</span></pre><p id="ef68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们创造我们的类型。</p><h1 id="ad72" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">字符串50</h1><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1638" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在顶部，有类型声明。之后就是<code class="fe nl nm nn na b">makeString50</code>功能了。这个函数接受<code class="fe nl nm nn na b">any</code>参数并试图创建<code class="fe nl nm nn na b">String50</code>。</p><p id="dcf7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它检查参数类型是否是一个<code class="fe nl nm nn na b">string</code>并且它的长度是否小于50。</p><p id="baca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果参数不满足规则和约束，它将抛出一个<code class="fe nl nm nn na b">CustomTypeError</code>异常。</p><p id="5a05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是<code class="fe nl nm nn na b">CustomTypeError</code></p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4010" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这只是一个简单的显示错误的类。</p><p id="f287" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在<code class="fe nl nm nn na b">try catch</code>块中使用它来处理我们的自定义类型错误。</p><p id="f0f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们继续定义其他类型。</p><h1 id="1086" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">电子邮件</h1><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4ae9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用一个正则表达式来验证该参数确实是一封电子邮件。</p><h1 id="844a" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">邮政编码</h1><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="cb33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像那封邮件一样。使用正则表达式验证。</p><h1 id="b4d1" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">电子邮件和邮政编码</h1><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="467c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们检查是否提供了参数。然后我们使用<code class="fe nl nm nn na b">Email</code>和<code class="fe nl nm nn na b">PostalCode</code>类型来进行验证。</p><h1 id="8f53" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">ContactInfo</h1><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6208" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nl nm nn na b">ContactInfo</code>类型是一种联合类型。可能是<code class="fe nl nm nn na b">Email</code>或<code class="fe nl nm nn na b">PostalCode</code>或两者都是。</p><p id="470b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe nl nm nn na b">makeContactInfo</code>函数中，我们首先尝试创建一个<code class="fe nl nm nn na b">Email</code>，然后尝试创建一个<code class="fe nl nm nn na b">PostalCode</code>，最后尝试创建<code class="fe nl nm nn na b">EmailAndPostalCode</code>。</p><p id="bfea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果它们都失败了，那么异常将抛出。</p><p id="5321" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了所有想要的类型，可以创建<code class="fe nl nm nn na b">Person</code>模型了。</p><h1 id="6c5d" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">人</h1><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f6cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe nl nm nn na b">makePerson</code>函数中，我们需要做的就是调用类型生成器函数。</p><p id="e983" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果它们都返回一个有效的值，我们就创建了我们的人模型。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="5031" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用<code class="fe nl nm nn na b">makePerson</code>功能创建人员，并测试我们创建的内容。</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="992d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nl nm nn na b">createAndLogPerson</code>函数只尝试创建一个人并打印其值。如果失败，它将打印错误。</p><p id="f21e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看输出:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="77d7" class="nv nw it kd b ke kf ki kj km nx kq ny ku nz ky oa ob oc od bi translated">人员1有效，并有联系信息的电子邮件</li><li id="d9c6" class="nv nw it kd b ke oe ki of km og kq oh ku oi ky oa ob oc od bi translated">人员2有效，并且有联系信息的邮政编码</li><li id="f642" class="nv nw it kd b ke oe ki of km og kq oh ku oi ky oa ob oc od bi translated">人员3是有效的，并且具有用于联系信息的电子邮件和邮政编码</li><li id="ca78" class="nv nw it kd b ke oe ki of km og kq oh ku oi ky oa ob oc od bi translated">人员4无效，因为它没有任何联系信息。所以它会抛出一个错误</li><li id="3216" class="nv nw it kd b ke oe ki of km og kq oh ku oi ky oa ob oc od bi translated">人员5无效，因为它有联系信息的电子邮件，但它不是正确的电子邮件格式。所以它会抛出一个错误</li></ul></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="ad75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们让我们的类型实际工作并验证输入数据。</p><p id="75b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是正如你所看到的，这是一个很无聊的工作。</p><p id="de2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们需要声明类型，然后我们应该编写一些函数来创建和验证它。这种类型的模型结构只在我们的领域和项目中有意义。如果我们需要将这些数据发送给其他人。例如，如果我们需要将这些数据作为rest API调用的响应返回，该怎么办？</p><p id="6e07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要另一个函数将<code class="fe nl nm nn na b">Person</code>作为参数，并返回一个正常的结构，如下所示:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1e9b" class="ne lt it na b gy nf ng l nh ni">{<br/>    "firstName": "pf1",<br/>    "lastName": "pl1",<br/>    "email": "pf1@gmail.com",<br/>    "postalCode": "3483848392",<br/>}</span></pre><p id="bc45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要定义类似于<code class="fe nl nm nn na b">encodePerson</code>函数的东西。</p><p id="644f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所做的，我们必须为每种类型创建<code class="fe nl nm nn na b">make...</code>和<code class="fe nl nm nn na b">encode...</code>函数。</p><p id="a14f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要一些方法来自动化这些功能。</p><p id="95fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幸运的是，有一个typescript库可以做到这一点。你可以在这里阅读:</p><div class="la lb gp gr lc ld"><a href="https://github.com/gcanti/io-ts" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">gcanti/io-ts</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">为了安装稳定版，发布了实验性特性(*)，以便从…获得早期反馈</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">github.com</p></div></div><div class="lm l"><div class="oj l lo lp lq lm lr jz ld"/></div></div></a></div></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="e2f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下一篇文章中，我们将使用<code class="fe nl nm nn na b">io-ts</code>库来创建和验证我们的模型。</p><p id="7428" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://medium.com/@mohsen.sareminia/reflecting-business-logic-rules-into-the-domain-models-using-typescript-part-3-aa8998bc6d29" rel="noopener">继续下一篇。</a></p></div></div>    
</body>
</html>