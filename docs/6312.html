<html>
<head>
<title>Understanding Solidity by example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过示例了解可靠性</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-solidity-by-example-b2394f7cea8f?source=collection_archive---------0-----------------------#2021-10-15">https://itnext.io/understanding-solidity-by-example-b2394f7cea8f?source=collection_archive---------0-----------------------#2021-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7fc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">在这篇短文中，我将带您浏览一些用Remix IDE编写的Solidity代码示例，以便让您对它的工作原理和一些常见用例有一个总体的了解。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/b0555698c673977851edf76350d4c686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGnm1mHbCRgxTUsZ4EGyQw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">来源:<a class="ae lc" href="http://ethereum.org" rel="noopener ugc nofollow" target="_blank">ethereum.org</a></figcaption></figure><h1 id="3c99" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">介绍</h1><p id="b5fa" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">这篇文章是为那些已经了解一些编程语言和面向对象编程的程序员而写的。</p><p id="b9d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将涉及的例子目前在<a class="ae lc" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>介绍例子中可用，我将在本文中复制/粘贴一些代码块，以防他们更新或删除它。</p><p id="b46e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">涵盖了3种用例，按复杂性递增排序:</p><ul class=""><li id="cc69" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><strong class="jp ir">存储:</strong>非常简单的智能契约，将一个值存储在一个整数变量中。</li><li id="a207" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir"> Owner: </strong>类似于storage，但在这种情况下，契约存储一个名为<em class="kl">“Owner”的<strong class="jp ir">地址</strong>类型变量。</em></li><li id="968d" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">投票:</strong>在最后一个例子中，我们有一个更有用的“真实世界”用例，契约实现了投票过程和投票委托。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0410e376ac05e18f9826dcf84f4237bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*-IiwOTPTrRS5vBwk4WkMfg.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">来源:<a class="ae lc" href="http://ethereum.org" rel="noopener ugc nofollow" target="_blank">ethereum.org</a></figcaption></figure><h1 id="a55b" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">示例1:存储</h1><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="8819" class="mx le iq bd lf my mz dn lj na nb dp ln jy nc nd lr kc ne nf lv kg ng nh lz ni bi translated">意义</h2><p id="3e59" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated"><code class="fe nj nk nl nm b">store</code>函数将使用给定的参数更新number变量的值。<code class="fe nj nk nl nm b">retrieve</code>函数将返回数字函数的当前值。</p><h2 id="6e0e" class="mx le iq bd lf my mz dn lj na nb dp ln jy nc nd lr kc ne nf lv kg ng nh lz ni bi translated">概念</h2><ul class=""><li id="5834" class="mg mh iq jp b jq mb ju mc jy nn kc no kg np kk ml mm mn mo bi translated"><code class="fe nj nk nl nm b">pragma</code>:该关键字用于启用某些编译器特性或检查。一个<code class="fe nj nk nl nm b">pragma</code>指令总是在一个源文件的本地，所以如果你想在你所有的项目中启用它，你必须把编译指令添加到你所有的文件中。</li><li id="5282" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe nj nk nl nm b">contract</code>:通常与OOP编程语言的类比是<em class="kl">契约</em>就像<em class="kl">类</em>，其中包含属性和方法。</li><li id="6eca" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe nj nk nl nm b">public view returns</code>:它们是<em class="kl">修饰符</em>，本质上它们可以为包含它们的函数提供一些限制或验证。在这种情况下，<code class="fe nj nk nl nm b">public</code>意味着函数可以从契约外部调用，<code class="fe nj nk nl nm b">view</code>意味着函数不能改变契约的状态，<code class="fe nj nk nl nm b">returns</code>仅仅意味着函数的返回类型，注意，您可以像在<code class="fe nj nk nl nm b">returns</code>示例中那样为修饰符设置参数。</li></ul><h1 id="018f" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">示例2:所有者</h1><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="345e" class="mx le iq bd lf my mz dn lj na nb dp ln jy nc nd lr kc ne nf lv kg ng nh lz ni bi translated">意义</h2><p id="168d" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">这段代码做的事情与第一个示例类似，在智能合约中存储和更新一个变量。但是在这种情况下，我们有一个<strong class="jp ir"> <em class="kl">地址</em> </strong>数据类型，而不是一个简单的整数。</p><p id="c91a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个<strong class="jp ir">地址</strong>(账户标识符)代表一个拥有者，该拥有者对契约具有一些特定的特权，例如调用一些函数或访问一些值。</p><h2 id="0ed3" class="mx le iq bd lf my mz dn lj na nb dp ln jy nc nd lr kc ne nf lv kg ng nh lz ni bi translated">概念</h2><ul class=""><li id="a2de" class="mg mh iq jp b jq mb ju mc jy nn kc no kg np kk ml mm mn mo bi translated"><code class="fe nj nk nl nm b">private</code>:就像在契约函数中一样，属性有<em class="kl">访问修饰符，</em>这些修饰符限制代码从“哪里”可以读取或改变属性的状态。在这种情况下是<code class="fe nj nk nl nm b">private</code>，这意味着该变量只能从契约函数中访问。如果你想把变量保持为只读，那么你可以把它声明为私有，然后用一个只返回值的<code class="fe nj nk nl nm b">view</code>修饰符创建一个getter函数。</li><li id="0a99" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe nj nk nl nm b">event</code>:是合同的可继承成员。发出一个事件，它存储在事务日志中传递的参数。这些日志存储在区块链上，可以使用合同地址进行访问。在本例中，我们创建了一个事件，每次在<code class="fe nj nk nl nm b">changeOwner</code>函数中更改所有者时都会发出该事件。</li><li id="30d4" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe nj nk nl nm b">constructor &amp; msg.sender</code>:部署智能合约时调用<code class="fe nj nk nl nm b">constructor</code>函数，由于智能合约<strong class="jp ir">不可变</strong>，只能部署一次，因此<code class="fe nj nk nl nm b">constructor</code>函数也只调用一次。<code class="fe nj nk nl nm b">msg.sender</code>是当前(外部)函数调用的来源地址。在这种情况下，我们用部署者的地址初始化owner变量。</li><li id="4d02" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">Solidity提供了这个关键字来创建你自己的带有自定义逻辑的修改器。如果<code class="fe nj nk nl nm b">require</code>的第一个参数评估为<code class="fe nj nk nl nm b">false</code>，那么函数内部的操作被恢复，这对于检查函数是否被正确调用也是有用的。作为第二个论点，你也可以提供一个关于哪里出错的解释。</li></ul><h1 id="8879" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">示例3:投票</h1><blockquote class="nq nr ns"><p id="9eb9" class="jn jo kl jp b jq jr js jt ju jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj kk ij bi translated">代码相当长，没有必要全部阅读，我将在<strong class="jp ir">含义</strong>块中用几句话解释它，然后如果您想阅读和分析某些特定片段，由您决定。</p></blockquote><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="e0a0" class="mx le iq bd lf my mz dn lj na nb dp ln jy nc nd lr kc ne nf lv kg ng nh lz ni bi translated">意义</h2><p id="a080" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">实施投票流程以及投票授权，这意味着有一些提案需要投票(可以是人员、计划、想法等。)而且每个选民一票。</p><p id="3c38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个投票者也可以"<em class="kl">委托</em>"它的投票给另一个投票者，这增加了接收者的投票权重<em class="kl"/>(最初权重是每个投票者1)。不能有委托循环，这意味着如果<strong class="jp ir"> Jon </strong>将他的选票委托给<strong class="jp ir"> Rose </strong>，那么<strong class="jp ir"> Rose </strong>将她的选票委托给<strong class="jp ir"> Tom </strong>，<strong class="jp ir"> Tom </strong>不能再将他的选票委托给<strong class="jp ir"> Jon </strong>，这个循环就被阻止了2到<em class="kl"> K </em>人，其中<em class="kl"> K </em>是投票人的总数。</p><p id="715e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，主席<em class="kl">可以将投票权分配给已经委托投票的投票人。</em></p><h2 id="3f4d" class="mx le iq bd lf my mz dn lj na nb dp ln jy nc nd lr kc ne nf lv kg ng nh lz ni bi translated">概念</h2><ul class=""><li id="a1d7" class="mg mh iq jp b jq mb ju mc jy nn kc no kg np kk ml mm mn mo bi translated"><code class="fe nj nk nl nm b">struct</code>:它们是用来表示一条记录的类型，就像在c中一样，由于不存在<em class="kl">类</em>的概念(一个<em class="kl">契约</em>是一个<em class="kl">类</em>的类比)，所以在Solidity中被广泛使用。在这个例子中，我们有两个不同的结构:<code class="fe nj nk nl nm b">Voter</code>和<code class="fe nj nk nl nm b">Proposal</code>。</li><li id="a24f" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe nj nk nl nm b">bytes32</code>:是一个有32字节内存的<code class="fe nj nk nl nm b">string</code>，它在值永远不会超过大小的情况下很有用，它使用较少的<a class="ae lc" href="https://ethereum.org/en/developers/docs/gas/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">气体</strong> </a> <strong class="jp ir"> </strong>因为它适合<a class="ae lc" href="https://ethereum.org/en/developers/docs/evm/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> EVM </strong> </a> <strong class="jp ir">的一个单词。</strong>另一方面，<code class="fe nj nk nl nm b">string</code>是一个动态调整大小的类型，它在可靠性方面有当前的限制(比如不能从函数返回到契约)。</li><li id="1f72" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe nj nk nl nm b">mapping</code>:它们可以被视为<a class="ae lc" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">散列表</strong> </a>，这些散列表被虚拟地初始化，使得每个可能的关键字都存在并且被映射到一个字节表示全为零的值。它们没有长度，也没有设置键或值的概念。</li><li id="3574" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe nj nk nl nm b">memory</code>:Solidity中的<code class="fe nj nk nl nm b">memory</code>变量只能在方法中声明，它们是短期变量，不能保存在区块链中。它只在函数执行期间保存值，在执行后它的值被销毁。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/fc9c4b9448a19a831c2abe917ea9b8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYpsbTdVyNZewLJLDZxB9A.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">来源:<a class="ae lc" href="http://ethereum.org" rel="noopener ugc nofollow" target="_blank">ethereum.org</a></figcaption></figure><h1 id="4304" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="503b" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">混音版上的介绍性例子对那些想理解基本和不太基本的坚实概念的人来说是非常好的。</p><p id="08f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我确信这些例子是经过深思熟虑的，我相信它们值得一个彻底的解释，甚至更多，因为像我这样的人倾向于删除代码并开始在编辑器中编写<code class="fe nj nk nl nm b">console.log(“Hello world!”)</code>而不用想太多。</p><p id="7a81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想在开始编写智能合同之前更深入地研究这种编程语言，我诚挚地邀请你阅读以太坊<a class="ae lc" href="https://ethereum.org/en/developers/docs/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中的文档。🤓。</p></div></div>    
</body>
</html>