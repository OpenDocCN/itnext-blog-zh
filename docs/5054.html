<html>
<head>
<title>React: Using React-Spring To Animate Crossfading Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React:使用React-Spring制作交叉渐变图像的动画</h1>
<blockquote>原文：<a href="https://itnext.io/react-using-react-spring-to-animate-crossfading-images-1fee000e310d?source=collection_archive---------0-----------------------#2020-11-28">https://itnext.io/react-using-react-spring-to-animate-crossfading-images-1fee000e310d?source=collection_archive---------0-----------------------#2020-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4c41fec23705a7942854004dd83e540a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uBfclHr26HNuplpY6dR3mQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="41d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Streetball Mecca从仅使用D3的版本到利用D3的辅助功能和React实现所有其他功能的版本的重构过程中，我用<strong class="ke ir"> React-Spring </strong>替换了<strong class="ke ir"> d3.transition </strong>以制作地图上圆圈的淡入/淡出动画。你可以在上一篇文章中了解我是如何实现这个解决方案的:<a class="ae la" href="https://jkeohan.medium.com/react-d3-rendering-circles-on-a-map-b7746600502" rel="noopener"> React &amp; D3:使用React-Spring转换在地图上渲染圆形</a>。</p><p id="9b99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我将公园图像重构为它自己的组件时，我再次发现需要用一个替代解决方案来替换<strong class="ke ir"> d3.transition </strong>，并决定再试一次React-Spring。</p><h1 id="b8b8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React-Spring文档和更多研究</h1><p id="8db8" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">过去在公园图像中逐渐消失的过渡感觉有些起伏。原因是它首先替换了先前的背景图像，然后使用不透明度来创建淡入效果。下面是原始代码。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/f4c0dbbad9894d3f600b5bbf4c06b30c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08tD2r6kmSsp-u8vO4EP7Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="8f1d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我对UX的实现一直不太满意，总是想在输入/输出图像之间应用平滑的交叉渐变。我也知道这需要对原始的D3代码进行重构，但是我已经在那个项目中达到了足够好的程度，需要转移到下一个D3项目。</p><p id="c37a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，我现在有了实现交叉渐变的机会，同时也有了使用React-Spring的另一个理由。</p><h2 id="4c18" class="mj lc iq bd ld mk ml dn lh mm mn dp ll kn mo mp lp kr mq mr lt kv ms mt lx mu bi translated">工作示例</h2><p id="7bdc" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我做的第一件事是查看文档，希望找到一个交叉渐变图像的工作示例。React-Spring提供了几个方法，在浏览完文档后，useTransition钩子吸引了我的注意，所以我从那里开始。</p><p id="062e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我浏览了提供的演示样本，在不到30秒的时间里，我找到了一个工作示例，即<a class="ae la" href="https://codesandbox.io/embed/morr206pv8" rel="noopener ugc nofollow" target="_blank">以连续循环的方式循环过渡4个图像</a>。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/08ff99029d6150bed1fa2a2506f42095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NmFC_Wc7br7zCbHGkRqGWA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自React-Spring演示</figcaption></figure><p id="1de4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">审查代码后，很明显<strong class="ke ir"> useTransition </strong>被用来控制过渡，但我觉得我需要做一些额外的研究，以更好地了解它与<strong class="ke ir"> useSpring </strong>的不同之处。</p><h2 id="277b" class="mj lc iq bd ld mk ml dn lh mm mn dp ll kn mo mp lp kr mq mr lt kv ms mt lx mu bi translated">额外研究</h2><p id="40d4" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">所以我在谷歌上搜索了一下<strong class="ke ir">‘use transition vs use spring’</strong>，偶然看到了约书亚·霍尔写的文章<a class="ae la" href="https://alligator.io/react/advanced-react-spring/" rel="noopener ugc nofollow" target="_blank">“使用react-spring在React中创建复杂动画”</a>。在这篇文章中，他讨论了<strong class="ke ir"> useSpring </strong>、<strong class="ke ir"> useSprings </strong>、<strong class="ke ir"> useTrail、</strong>和<strong class="ke ir"> useTransition </strong>的用例，我觉得这篇文章确实提供了我正在寻找的额外背景。</p><p id="69f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于<strong class="ke ir">使用弹簧</strong>和<strong class="ke ir">使用过渡</strong>之间的比较，他声明:</p><blockquote class="mw mx my"><p id="71ed" class="kc kd mz ke b kf kg kh ki kj kk kl km na ko kp kq nb ks kt ku nc kw kx ky kz ij bi translated"><code class="fe nd ne nf ng b">useSpring</code>的一个问题是它没有给我们任何对组件生命周期的控制</p></blockquote><p id="c9f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并且进一步接着是:</p><blockquote class="mw mx my"><p id="fb5e" class="kc kd mz ke b kf kg kh ki kj kk kl km na ko kp kq nb ks kt ku nc kw kx ky kz ij bi translated">相反，我们可以使用<code class="fe nd ne nf ng b">useTransition</code>来控制动画在视图中的安装和卸载。</p></blockquote><p id="bd86" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然这是我第一次尝试使用<strong class="ke ir"> useTransition </strong>来实现动画，但我确实记得以前曾经使用过几个类生命周期方法来实现动画。因此，在搜索了我多年来写的数百支代码笔后，我遇到了制作字母表(2018年1月)的<a class="ae la" href="https://codepen.io/jkeohan/pen/VyGLOM?editors=0010" rel="noopener ugc nofollow" target="_blank">，它使用</a><a class="ae la" href="https://reactcommunity.org/react-transition-group/transition" rel="noopener ugc nofollow" target="_blank"> React-Transition-Group </a>库实现了动画。</p><p id="8be2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它是使用类组件编写的，并利用了生命周期方法<strong class="ke ir"> componentWillEnter </strong>和<strong class="ke ir"> componentWillLeave </strong>，这是我之前从未见过的，而<strong class="ke ir"> componentWillReceiveProps。</strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0a5fb54fdc601760f25e1c561a203380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*vjS3CZDwpatE21O74MjJNA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="3b77" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在工作示例中，<strong class="ke ir"> useTransition </strong>也被配置为使用关键字<strong class="ke ir">‘enter’</strong>和<strong class="ke ir">‘leave’</strong>，因此现在很清楚它将如何触发动画以符合上述生命周期方法。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/3f2e2ad2ce1d2637bf475e7780391576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TrFa03hyCtSgpDoGJAgVeQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="e584" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样在这个例子中，我可以看到<strong class="ke ir"> setInterval </strong>每5秒更新一次索引状态值，在重新渲染期间，一个新的<strong class="ke ir"> useTransition </strong>将被实例化并被赋予新的值。</p><p id="f1bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> useTransition </strong>返回一个数组，该数组随后被映射并在每次迭代中返回一个新的<strong class="ke ir"> animated.div </strong>。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/3c54d3bf10e498357b7b88984d9b5303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0B8_tJYpxbtwj7K-zgZjvg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><h2 id="a476" class="mj lc iq bd ld mk ml dn lh mm mn dp ll kn mo mp lp kr mq mr lt kv ms mt lx mu bi translated">需要更多的理解</h2><p id="9d19" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我不太确定transitions数组中包含了什么，我仍然很想了解整个过程，所以我添加了控制台日志来查看。</p><p id="8c5c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我让它运行了几次，注意到了一个模式。当将要显示下一个图像时，该数组将包含3个元素，2个表示离开，1个表示进入。一旦图像淡入，数组将删除第一个位置的树叶，并更新最后一个位置的<strong class="ke ir">回车</strong>到<strong class="ke ir">更新</strong>。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/9399500b36665064b605608ed63b4ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYeLn7teJRjSq0mxnRQUrQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="64c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，一旦转换完成并且元素从DOM中移除，似乎<strong class="ke ir"> useTransition </strong>就会从数组中移除该元素。我还注意到<strong class="ke ir">键</strong>的值会不断增加，并与React跟踪通过地图呈现的元素的标准方式相关联。</p><p id="84bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是工作示例的完整代码示例，因此您可以看到它们是如何结合在一起的。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/19542b9fc634082ae17d4fc2194ce6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlLfr1wNb7KuQZ57V76UeA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="09b4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我现在觉得我对正在发生的事情有所了解，并决定是时候将这种理解应用到公园图像的转换中了。</p><h2 id="c7a2" class="mj lc iq bd ld mk ml dn lh mm mn dp ll kn mo mp lp kr mq mr lt kv ms mt lx mu bi translated">实施过渡</h2><p id="d2d5" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">第一步是从React Spring导入<strong class="ke ir"> useTransition </strong>和<strong class="ke ir">动画</strong>方法。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/f7fafed31dde5422caa9e00f90a8f2c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gN1sxjLQZv6145xECu_H5g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="bfec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在工作示例中，<strong class="ke ir"> useTransition </strong>基于更新的索引值被重新分配了新图像。然而，在我的配置中，图像是作为道具传递的。</p><p id="c986" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于每次传递新道具时组件都被重新渲染，因此将当前道具值分配给<strong class="ke ir"> useTransition </strong>是有意义的，在本例中是<strong class="ke ir"> activePark </strong>对象。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/4f6c7b0606d673bc402d682f9bf140e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tpfTW8nsCQb3R87F1msyw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="8501" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我还添加了一个控制台日志，以查看转换是否会遵循与以前相同的模式。尽管数组中少了一个元素，但模式是相似的。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/68278bfa6c6d24d5687ead52dafa8dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gztrMjU2FBl8NtmtxCa0g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="0677" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不太清楚为什么会有这样的变化，但是我确信如果这让我的开发人员良心不安的时间够长，我会在以后重新审视它，并试图弄清楚它。</p><h2 id="c018" class="mj lc iq bd ld mk ml dn lh mm mn dp ll kn mo mp lp kr mq mr lt kv ms mt lx mu bi translated">渲染图像</h2><p id="b105" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">至于渲染图像，我能够重用工作示例中的所有代码，只做了一些编辑。其中一个编辑是需要包含一些条件逻辑，以便在<strong class="ke ir"> activePark </strong>对象存在时运行。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/ba4f911c7d57e9b1a0a035110ae5e29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5WCML7tIYPuE5W4lFDoBw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="20e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我还添加了一个控制台日志来查看地图内部的内容。这些元素与我预期的一致。<strong class="ke ir">项</strong>是<strong class="ke ir"> activePark对象，</strong>道具<strong class="ke ir">道具</strong>是<strong class="ke ir">过渡，</strong>和<strong class="ke ir">键</strong>对应于元素，这就是<strong class="ke ir">如何使用过渡</strong>在渲染时跟踪它们。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/904ff84e62653d042e16b7922f0818f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynYtxm5vi0-SpITBE62ouQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="6bba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，每次渲染新图像时，键值都会增加。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/d01e56afc97f53aa02b0a653695995c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4ZQHSE3UuoRVrKTyRoFMw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><h1 id="7001" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="fd4b" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">这种从<strong class="ke ir"> d3.transition </strong>到React-Spring<strong class="ke ir">use transition</strong>的重构相当容易。一路走来，我有了一些发现，觉得自己现在对幕后发生的事情有了更好的理解。正是在这样的时刻，我意识到当我的学生想知道为什么时，他们的感受是怎样的，但我们只有时间教他们如何做。</p><p id="03f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我确实研究过另一个解决方案，它最初稍微复杂一点，利用了useState和useEffect以及在一个数组中交替放置图像。</p><p id="b862" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">直到我开始写这篇文章并记录我的想法，我才决定重构那个解决方案。我有一种直觉，这太复杂了，可以找到一种更简单的方法。</p><p id="6af5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无论如何，如果你想进一步了解，这里是<a class="ae la" href="https://codesandbox.io/s/d3-streetball-mecca-react-using-react-spring-to-crossfade-images-medium-jkzmc?file=/src/components/ParkInfo/ParkImage/image-spring.js" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>。</p><h1 id="aec9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">附加文章</h1><p id="fdcc" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">这里是我根据D3 =&gt; React的代码重构写的一些附加文章。如果你有任何想法、建议或评论，我很乐意倾听。</p><ul class=""><li id="bf69" class="ns nt iq ke b kf kg kj kk kn nu kr nv kv nw kz nx ny nz oa bi translated"><a class="ae la" href="https://jkeohan.medium.com/the-used3-custom-hook-889ddbd30f18" rel="noopener">使用useD3自定义挂钩进行试验</a></li><li id="5db8" class="ns nt iq ke b kf ob kj oc kn od kr oe kv of kz nx ny nz oa bi translated"><a class="ae la" href="https://levelup.gitconnected.com/react-d3-rendering-a-map-5e006b2f4895" rel="noopener ugc nofollow" target="_blank">反应&amp; D3:渲染贴图</a></li><li id="e47a" class="ns nt iq ke b kf ob kj oc kn od kr oe kv of kz nx ny nz oa bi translated"><a class="ae la" href="https://medium.com/swlh/react-managing-complex-state-transitions-with-usereducer-e37536b12944" rel="noopener"> React:使用useReducer管理复杂的状态转换</a></li></ul></div></div>    
</body>
</html>