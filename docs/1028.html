<html>
<head>
<title>Real store’is: Local stores (part 2 of 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“真正的商店”是:本地商店(第2部分，共3部分)</h1>
<blockquote>原文：<a href="https://itnext.io/real-storeis-local-stores-part-2-of-3-b9628e830e08?source=collection_archive---------2-----------------------#2018-07-08">https://itnext.io/real-storeis-local-stores-part-2-of-3-b9628e830e08?source=collection_archive---------2-----------------------#2018-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aaea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">MobX将定义存储在现实应用中</h2></div><blockquote class="kf kg kh"><p id="1579" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这篇文章展示了<a class="ae lf" href="https://www.timefic.com" rel="noopener ugc nofollow" target="_blank">timefic.com</a>的“状态管理”方面，这意味着我们在这里不是在谈论React组件，渲染到dom或处理用户事件。它将讲述如何组织数据(状态)以及如何对基于3种或3类商店的任何应用进行建模:</p></blockquote><ul class=""><li id="2f0d" class="lg lh iq kl b km kn kp kq li lj lk ll lm ln le lo lp lq lr bi translated"><strong class="kl ir">实用商店</strong>:对应用程序(很可能是你现在正在构建的应用程序)来说是“架构性的”商店，因此它们可以被你的“大图”中定义的所有模块或服务使用。<a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/real-storeis-utility-stores-part-1-of-3-1277a0d76720">见此文</a>。</li><li id="667a" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">本地存储</strong>:本地持久化或者根本不持久化的存储。它们保存临时数据，但对用户的客户端体验至关重要。</li><li id="d9c1" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">域存储</strong>:与特定域或服务相关的存储，业务规则位于其中。</li></ul><p id="d182" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">所以，在本文中，我们将着眼于<strong class="kl ir"> <em class="kk">本地商店</em> </strong>！但是首先，让我们定义什么时候有必要拥有它们。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/a745bfd9815b72ada4fa88cb6a61eab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OK7jWVYuzhBdiAIy"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">照片由<a class="ae lf" href="https://unsplash.com/@daniel840528?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·曾</a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="b4a7" class="mn mo iq bd mp mq mr dn ms mt mu dp mv li mw mx my lk mz na nb lm nc nd ne nf bi translated"><strong class="ak">如何知道一段数据是否应该在自己的存储中？</strong></h2><p id="9a30" class="pw-post-body-paragraph ki kj iq kl b km ng jr ko kp nh ju kr li ni ku kv lk nj ky kz lm nk lc ld le ij bi translated">虽然我们还没有看到域存储，但是很明显这些存储是必要的:<em class="kk">您的数据库中有一个表，需要在客户端访问它的数据？</em>然后你定义一家店。这是一对一的关系。比如:‘agreements’(MongoDB中的表)在客户端会有‘agreements store’。</p><p id="9b83" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">但是，本地商店在你的后端没有桌子，那么如何知道他们什么时候需要呢？</p><ul class=""><li id="caf4" class="lg lh iq kl b km kn kp kq li lj lk ll lm ln le lo lp lq lr bi translated"><strong class="kl ir"> UI状态管理</strong>:你的UI没有一次全部显示出来。有隐藏的菜单，弹出窗口，标签。有元素列表，您选择了一个。对于所有这些数据，最好有一个存储(并且只有一个),并且能够从您的UI和其他存储中访问它。</li><li id="adf3" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated">实用商店的实例:我们在本文第一部分看到的通用商店需要实例化。例如，您将使用您正在开发的特定模块所需的定义(警报)在本地定义一个<em class="kk">alertstore</em>。</li><li id="b7cc" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">跨域业务规则</strong>:业务规则遍布店铺。每个商店都可以像<em class="kk">协议商店</em>或<em class="kk">评论商店</em>一样有自己的规则。但是，在某些情况下，有些规则会跨越特定商店的界限，并在您的应用程序中扮演相关角色。例如，在timefic中，有一个<em class="kk"> ChecklistStore </em>保存召开会议的规则，如会议日期的最小预期、有时间的议程和目的等。</li><li id="7093" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated">UI复杂性封装:有时你需要定义一个“整体商店”来隐藏组件的复杂性。例如，在timefic中，有一个<em class="kk"> SyslidesStore </em>(系统生成的幻灯片)，需要在满足某些条件时显示，比如需要投票的新协议，或者当前主题的时间到了。</li></ul><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nl"><img src="../Images/f0fc6258a5e3219045e34662d09a7879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*caO5u8O8xOgE7vv9ex3GFA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">Dashboard应用程序中控制商店的片段。</figcaption></figure><h2 id="8a78" class="mn mo iq bd mp mq mr dn ms mt mu dp mv li mw mx my lk mz na nb lm nc nd ne nf bi translated">一些具体的用例</h2><p id="8201" class="pw-post-body-paragraph ki kj iq kl b km ng jr ko kp nh ju kr li ni ku kv lk nj ky kz lm nk lc ld le ij bi translated">本地商店可能有很多可能的使用案例，所以我给你一个我正在使用的例子:</p><ul class=""><li id="7eeb" class="lg lh iq kl b km kn kp kq li lj lk ll lm ln le lo lp lq lr bi translated"><strong class="kl ir"> State </strong>:一个存储简单值(通常是布尔值和字符串)的商店，这些值在你的应用程序中必不可少。就像React状态处于组件级别一样，这也是应用程序级别的状态。“真理的唯一来源”。</li><li id="71df" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir"> Alerts </strong>:这里存储元数据(需要的警报类型的定义)、实际数据(生成的警报)以及添加或删除它们的方法。这是一家本地商店，因为在这里你不会碰到你的后端。</li><li id="ce55" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">时钟</strong>:本地商店，每隔<em class="kk"> X </em> <em class="kk">秒</em>与你后端的时钟同步，负责向你基于时间的业务规则和其他对该数据感兴趣的商店通知当前时间。</li><li id="5184" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir"> Streams </strong>:保存来自外部来源的值的存储，如<em class="kk"> api </em>或流服务。例如，当用户在聊天中键入内容时，其他用户会看到通知。您可以在此发布和订阅此通知。</li><li id="d9a7" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">系统幻灯片</strong>:“系统幻灯片”或系统生成的幻灯片的缩写。这个存储库从域存储库和<em class="kk">时钟存储库</em>的子集获取输入，以创建一些React组件将知道的事件。这种复杂性被封装在这里，以避免复杂的组件。</li><li id="eaab" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">控件</strong>:本地存储，也是为了封装UI复杂度。在这种情况下，会议有一个侧边栏菜单，显示您可以执行的一些操作:打开会议室、打开会议规划器、下载PDF格式的会议记录、删除会议等。这些选项取决于会议状态、会议中的用户角色和帐户状态。所以这个逻辑在这里比直接在UI中更好。</li><li id="a073" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">授权</strong>:与上面的商店类似，在这种情况下，有一个多步骤流程，用户可以使用(或不可以使用)选项，这取决于会议状态、用户角色、时钟等。</li><li id="fb9f" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">清单</strong>:与上面类似的另一种情况，在这种情况下，这是100%的业务规则，允许或拒绝用户发送邀请、确认会议或发送更新。</li></ul><blockquote class="kf kg kh"><p id="72ff" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我认为这篇文章可能非常具体地针对我在meetings应用程序中发现的用例，但它可能会帮助你思考你的用例，并找到与我的用例的一些相似之处。</p></blockquote><p id="c7af" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">本文的下一部分，也是最后一部分，我们将关注<strong class="kl ir">域存储</strong>，或者保存应用程序主要数据的存储，正因为如此，它们被保存在你的后端。</p></div></div>    
</body>
</html>