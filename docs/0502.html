<html>
<head>
<title>Scraping Data from Reddit with Cheerio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Cheerio从Reddit抓取数据</h1>
<blockquote>原文：<a href="https://itnext.io/scraping-data-from-reddit-with-cheerio-be97cde63470?source=collection_archive---------6-----------------------#2018-03-20">https://itnext.io/scraping-data-from-reddit-with-cheerio-be97cde63470?source=collection_archive---------6-----------------------#2018-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d760" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Reddit代表了当今最大的，也许是最著名的在线社区之一。Reddit在全球读者总数中一直排名前十，已经成为无数讨论领域的基石，从参与政治辩论到分享小猫照片，以及其他一切。每个Reddit页面都通过帖子、评论、karma分数和其他标识符表示大量数据，通过一个简单的Javascript程序，我们可以提取这些信息，并按照我们想要的方式处理数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/8949b87f7c64e322c0e608a44a434ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Uu3i0qPNB5W_isIb9qvgTw.gif"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">资料来源:knowyourmeme.com</figcaption></figure><p id="199d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将展示一种使用web抓取来获取给定子编辑的顶部帖子的标题和karma分数的技术。我希望读者能够对使用Cheerio执行抓取功能有一个基本的了解。</p><p id="83f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将使用Cheerio，一种用于搜索和管理HTML标记结构的轻量级灵活API。Cheerio建立在核心jQuery的子集上，让用户可以简单地直接进入web抓取。</p><p id="cfbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用2个包，Cheerio(当然)和request，这是一个用于进行HTTP调用的简单模块。请求可以从给定的URL快速返回原始的HTML正文。</p><p id="b46a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将任何URL传入请求调用。请求还可以接受一个回调函数来处理结果体。在这个回调中，我们将标记加载到cheerio:</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="3520" class="lg lh iq lc b gy li lj l lk ll">const request = require('request');<br/>const cheerio = require('cheerio');</span><span id="5d72" class="lg lh iq lc b gy lm lj l lk ll">request('<a class="ae ln" href="https://www.reddit.com/r/javascript/" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/javascript/</a>', (err, res, body) =&gt; {<br/>//Load HTML body into cheerio<br/>const $ = cheerio.load(body);</span><span id="c25d" class="lg lh iq lc b gy lm lj l lk ll">//Cheerio functions</span><span id="46b7" class="lg lh iq lc b gy lm lj l lk ll">})</span></pre><p id="7cdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在有趣的部分来了:刮！我们的目标是分析我们站点的HTML主体，并推断出哪些元素和属性与我们正在寻找的数据相对应。从这里开始，我们使用Cheerio的类似jQuery的语法来定位所需的元素，并将它们解析回我们的Javascript程序。</p><p id="f06d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个例子，我们将深入到<strong class="jp ir">Javascript</strong>subred dit(【https://www.reddit.com/r/javascript/】T2)。我将使用Chrome的inspect工具(快捷键Cmd + Shift + C)来查找哪些元素代表我们希望检索的数据。例如，为了定位表示给定帖子分数的元素，我们发现每个分数都用一个包含类<strong class="jp ir"> score </strong>和<strong class="jp ir"> unvoted </strong>的<strong class="jp ir"> div </strong>元素来表示。此外，我们看到我们正在寻找的分数存储在属性<strong class="jp ir"> title </strong>下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lo"><img src="../Images/6f9f10c6e63685b99d034e5ee5032b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0ikr6Gd5HoEsiVxn893Gg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">注意左边的黑色注释气泡和右边突出显示的div元素。div包括一个带有相应分数的title属性。</figcaption></figure><p id="2a27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些信息，我们通过称为<strong class="jp ir">提取器</strong>的函数告诉Cheerio遍历HTML主体并获取某些元素。继续我们的例子，我们添加一个提取器来提取每一个具有类<strong class="jp ir">分数</strong>的元素(我们不需要<strong class="jp ir">未保存的</strong>，<strong class="jp ir">分数</strong>足够具体)。从这里开始，我们将另一种称为<strong class="jp ir">属性函数</strong>的函数连接在一起，以提取标题属性的值，并将每个值放入预定义的数组中:</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="dbee" class="lg lh iq lc b gy li lj l lk ll">const request = require('request');<br/>const cheerio = require('cheerio');</span><span id="c5da" class="lg lh iq lc b gy lm lj l lk ll">let scoreArr = titleArr = [];</span><span id="a57c" class="lg lh iq lc b gy lm lj l lk ll">request('<a class="ae ln" href="https://www.reddit.com/r/javascript/" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/javascript/</a>', (err, res, body) =&gt; {<br/>  //Load HTML body into cheerio<br/>  const $ = cheerio.load(body);</span><span id="34fc" class="lg lh iq lc b gy lm lj l lk ll">  //Scrape karma scores<br/>  $(`.score`).attr(`title`, (i, val) =&gt; {<br/>    scoreArr.push(val);<br/>  });<br/>});</span><span id="aa38" class="lg lh iq lc b gy lm lj l lk ll">console.log(scoreArr)<br/>//[12, 134, ...] Scores of top posts of r/Javascript at time of writing</span></pre><p id="b49a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续提取标题。从下面的图片中，我们看到每个标题都是一个包含4个类的<strong class="jp ir">和</strong>(超链接)元素。这一次，我们寻找的标题不在属性中，而是在元素的内部HTML中:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lp"><img src="../Images/21e47208e50ce10dc6a03a2b107d3ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_OI0AIg141Ap070_6Z3IA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在这里，我们看到标题是具有4个类的“a”元素</figcaption></figure><p id="d8f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了提取内部HTML，我们使用。text()函数。我们不能使用回调函数，所以我们使用。forEach()添加给定的标题，如下所示:</p><pre class="km kn ko kp gt lb lc ld le aw lf bi"><span id="db75" class="lg lh iq lc b gy li lj l lk ll">const request = require('request');<br/>const cheerio = require('cheerio');</span><span id="7b42" class="lg lh iq lc b gy lm lj l lk ll">let scoreArr = titleArr = [];</span><span id="e134" class="lg lh iq lc b gy lm lj l lk ll">request('<a class="ae ln" href="https://www.reddit.com/r/javascript/" rel="noopener ugc nofollow" target="_blank">https://www.reddit.com/r/javascript/</a>', (err, res, body) =&gt; {<br/>  //Load HTML body into cheerio<br/>  const $ = cheerio.load(body);</span><span id="a7b5" class="lg lh iq lc b gy lm lj l lk ll">  //Scrape karma scores<br/>  $(`.score`).attr(`title`, (i, val) =&gt; {<br/>    scoreArr.push(val);<br/>  });</span><span id="fe61" class="lg lh iq lc b gy lm lj l lk ll">  //Scrape post titles<br/>  $(`a.title`).forEach((el) =&gt; {<br/>    titleArr.push(el.text());<br/>  });</span><span id="c060" class="lg lh iq lc b gy lm lj l lk ll">});</span><span id="5322" class="lg lh iq lc b gy lm lj l lk ll">console.log(scoreArr);<br/>//[12, 134, ...] Scores of top posts of r/movies at time of writing<br/>console.log(titleArr);<br/>//["Showoff Saturday...", "Making the globe...", ...]</span></pre><p id="a06e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人把刮痧比作侦探工作。因为没有两个页面是相同的，所以我们需要使用不同的提取器和属性函数来解析我们想要的信息。这通常需要反复试验来获得你想要的准确信息。</p><p id="1f72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子提供了一个简单的结构来实现基本的Cheerio函数。Cheerio包含了大量更复杂的遍历DOM的方法。继续尝试网络抓取您最喜爱的网站！</p></div></div>    
</body>
</html>