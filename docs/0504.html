<html>
<head>
<title>Escaping the Twilight Zone: Building Forms The Easy Way With Vue Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逃离阴阳魔界:用Vue组件建造简单的形式</h1>
<blockquote>原文：<a href="https://itnext.io/escaping-the-twilight-zone-building-forms-the-easy-way-with-vue-components-53ee41d66ec3?source=collection_archive---------8-----------------------#2018-03-20">https://itnext.io/escaping-the-twilight-zone-building-forms-the-easy-way-with-vue-components-53ee41d66ec3?source=collection_archive---------8-----------------------#2018-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9562" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不需要Vuex！</p><p id="07f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">西班牙的传统是什么？哈斯梅洛·萨伯！如果有足够的时间，可以在最后一节用西班牙语翻译。</em></p><p id="3ecb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我发现自己需要在Laravel应用程序中构建一个Vue支持的表单。将Vue和Laravel一起使用通常是两全其美，将Vue的反应式前端功能与Laravel提供的直观后端搭建结合起来。然而，正如其他地方关于<a class="ae km" href="https://stimulusjs.org/handbook/origin#how-stimulus-differs-from-mainstream-javascript-frameworks" rel="noopener ugc nofollow" target="_blank">的文章所写的</a>，使用前端Javascript库和后端框架——无论是Laravel、Ruby on Rails，甚至是Node——总是会导致一个小而不可避免的边缘地带，在那里你遇到的挑战可以通过两个框架解决，但是没有一个像你希望的那样干净利落。亲爱的读者，如果你发现自己陷入了这个开发者的困境，不要担心:一点独创性和一点Google-fu可以解决甚至最令人困惑的困境。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/7dcca1ba54f0e83d440b54c359c51931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y_r4-67TsZ8QwwNW."/></div></figure><p id="eb8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的例子中，当我使用Vue和Laravel构建一个复杂的表单时，我进入了技术的边缘地带。因为Vue需要控制你提供给它的任何HTML，所以我决定依赖传统的Laravel表单不是处理事情的最佳方式——一旦进入Vue，最好使用完整的Vue。</p><p id="5e01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所料，这导致了另一个问题。在Laravel中，实际上在一般的PHP中，通过HTML表单提交<a class="ae km" href="http://php.net/manual/en/faq.html.php#faq.html.arrays" rel="noopener ugc nofollow" target="_blank">数组是相对简单的。我很快了解到，如果您希望通过基于JavaScript的AJAX将表单提交发送到后端，这种基于HTML的方法并不适用。在这种情况下，除非您安装一个定制库来模拟PHP的表单数组，否则您只能在将数据发送到服务器之前手动集中数据。</a></p><p id="2923" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用JavaScript发送AJAX请求的最快方式是利用Axios之类的HTTP库将请求发送到后端。事实上，我毫不费力地在更简单的形式上采用了这种精确的策略；对于更复杂的表单，我很快发现需要一种不同的方法。因为表单有多个自定义输入——图像上传、自动完成等。—我知道我必须使用子组件来存储一些表单数据。</p><p id="f37b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对Vue有一定经验的人大概能预料到我的问题。传统上，Vue中的数据从上到下，从父组件到子组件单向流动。在许多情况下，这种方法使开发变得轻而易举——只需将数据插入顶层组件，就万事大吉了。在这个特殊的例子中，这样的数据流并不完全符合我的需求。因为我需要将我的数据集中起来发出一个AJAX请求，所以我的父组件需要访问在子组件中创建的数据。</p><p id="54c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这又是一个转折点，阴阳魔界挫败了我最初寻求简单解决方案的努力。如果我正在构建一个Vue专用的前端，那么使用Vue的状态管理库Vuex将是显而易见的方法。然而，因为我利用Laravel来处理一些本来属于Vuex领域的状态管理，所以我很快决定设置Vuex所需的额外样板文件会给我的应用程序添加大量代码来完成一个相对较小的问题。虽然有时这种额外的开销是合理的，因为我知道我会在完成后将这个项目交给其他开发人员，但我决定采用一种更简单的方法来减少理解应用程序所需的代码量，使每个人在未来的生活更轻松。</p><p id="fa01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我来了。如果不使用Vuex，我需要某种方法来维护Vue表单中的父子数据，以简化和集中AJAX请求。在尝试了几种要么不起作用要么使我的代码库规模翻倍的方法之后，我发现了两个不太为人知的Vue特性的组合，它们用不到10行代码就实现了我的目标。</p><p id="3768" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我如何在不使用专用状态管理库的情况下在Vue中构建基于组件的表单的内幕。</p><p id="ff56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个特殊的例子，我假设我们正在构建一个表单，向后端添加一组作者。我不会过多地讨论后端——如果有足够的需求，我会把它留给另一个专栏。</p><p id="157e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们假设这就是我们希望我们的顶级Vue组件最终看起来的样子:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="6f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想把所有东西都放在我们的顶级组件中，这种方法可以很好地工作。然而，随着表单复杂性的增加，这种方法很快变得混乱，我们的目标是尽可能保持代码简单。</p><p id="53ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，将每个作者输入提取到它自己的组件中，并根据需要在顶层组件中添加/删除作者是有意义的。</p><p id="f082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们的代码如下所示:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="5947" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们开始遇到问题的地方。我们正在修改我们的<code class="fe kx ky kz la b">AddSingleAuthor</code>组件中的数据，我们需要这些数据在我们的顶级组件中可用。这违背了Vue最佳实践...<strong class="jp ir">然而</strong>，Vue 1中有一个特性，在Vue 2.3中重新引入，它对帮助我解决这个难题至关重要:<code class="fe kx ky kz la b">[.sync](https://vuejs.org/v2/guide/components.html#sync-Modifier)</code>。使用vue的<code class="fe kx ky kz la b">v-bind</code>指令和<code class="fe kx ky kz la b">.sync</code>，我们能够将数据传递给我们的子组件，并自动添加一个事件监听器，该监听器将修改父组件的数据以匹配子组件的数据。</p><p id="c507" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将<code class="fe kx ky kz la b">v-model</code>指令切换到<code class="fe kx ky kz la b">v-bind</code>，我们得到如下所示的结果:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="8c12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们将一个<code class="fe kx ky kz la b">author</code>属性传递给每个子<code class="fe kx ky kz la b">AddSingleAuthor</code>组件，该子组件与父组件中<code class="fe kx ky kz la b">authors</code>数组中的相应元素同步。</p><p id="03c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们看看这个<code class="fe kx ky kz la b">AddSingleAuthor</code>组件可能是什么样子:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="2132" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我给表单增加了一点复杂性，并在这个过程中引入了一个问题。你可能已经注意到，即使我们接受了<code class="fe kx ky kz la b">author</code>道具，我们实际上并没有用它做任何事情。</p><p id="aefa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们实际上如何触发父组件对<code class="fe kx ky kz la b">AddSingleAuthor</code>组件中变化的数据做出反应并不明显。我们可以向每个输入字段添加侦听器，并编写单独更新每个属性的方法——但是，这样很快就会变得笨拙，并导致大量重复代码。不好玩。</p><p id="b36a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我所做的是将所有数据属性嵌套在一个单独的<code class="fe kx ky kz la b">author</code>属性下，得到如下所示的代码:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="534b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，酷，我们已经在一个中央<code class="fe kx ky kz la b">author</code>对象中获得了所有数据。现在怎么办？</p><p id="6079" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我尝试的第一种方法涉及计算属性，但我很快意识到这不是我需要的。我不仅想监听每一个变化，还需要根据数据变化执行一些其他代码，而不是创建一个新的属性。</p><p id="e562" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个显而易见的解决方案是使用<code class="fe kx ky kz la b">watch</code>属性。然而，当我发现默认情况下<code class="fe kx ky kz la b">watch</code>并不监听子属性的变化时，我很快就失望了。所以监视<code class="fe kx ky kz la b">author</code>属性是行不通的——我需要独立地监听每个子属性。</p><p id="74d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者我会吗？</p><p id="ffc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实证明我不会，这要感谢<code class="fe kx ky kz la b">watch</code>属性的一个便利特性，在我发现它隐藏在文档中之前，我并不知道这个特性:<strong class="jp ir">深度观察</strong>。</p><p id="97f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管深度监视听起来像是胡佛时代FBI的战术，但这正是我们现在需要的。原来，通过将另一个属性传递给我们在<code class="fe kx ky kz la b">watch</code>中的<code class="fe kx ky kz la b">author</code>属性，我们可以在任何子属性被更新时触发回调。很酷的东西！</p><p id="e6a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将它应用到我们的<code class="fe kx ky kz la b">AddSingleAuthor</code>组件看起来像这样:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="37b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe kx ky kz la b">this.$emit</code>，我们将整个<code class="fe kx ky kz la b">newAuthor</code>对象发送到父组件，在那里使用<code class="fe kx ky kz la b">.sync</code>它将替换我们作为<code class="fe kx ky kz la b">author</code>道具传入的空字符串。</p><p id="d84c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！这种设置是在表单中使用子组件所需要的，同时仍然保持用发送AJAX请求所需的所有数据填充顶级元素。您可以随意向子组件添加属性，而无需为每个子组件编写定制的<code class="fe kx ky kz la b">update</code>事件。只要您添加的属性附加到<code class="fe kx ky kz la b">newAuthor</code>对象，它们就会自动添加到父组件中。</p><p id="2bc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">观察力敏锐的人可能已经注意到，我们仍然没有在我们的子组件中使用<code class="fe kx ky kz la b">author</code> prop做任何事情——你是完全正确的。事实上，我们可以完全删除<code class="fe kx ky kz la b">props</code>属性，但一切仍按预期工作。</p><p id="8d2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就我个人而言，我喜欢传入空的prop并利用<code class="fe kx ky kz la b">.sync</code>指令——这样我就不用在父组件中编写<code class="fe kx ky kz la b">update</code>方法，而且对我来说，它使事情更具可读性。如果传递一个未使用的道具让您感到困扰，那么您可以随意移除它，并编写一个自定义的事件侦听器来完成同样的事情。我在这里不打算这样做，因为我尽量不写任何不必要的代码，但是如果你愿意的话，这是一个100%的选择。</p><p id="3f74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次你发现自己处于边缘地带，也许同步或深度观察是解决办法！</p></div></div>    
</body>
</html>