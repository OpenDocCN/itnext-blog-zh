<html>
<head>
<title>Let’s Migrate Symfony Project to Kubernetes! Part 2: Publishing the Application with Helm.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们将Symfony项目迁移到Kubernetes！第2部分:用Helm发布应用程序。</h1>
<blockquote>原文：<a href="https://itnext.io/publishing-symfony-application-with-helm-ecb525b34289?source=collection_archive---------0-----------------------#2019-06-05">https://itnext.io/publishing-symfony-application-with-helm-ecb525b34289?source=collection_archive---------0-----------------------#2019-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3afd1644a5b3c32925de19cee9d1d3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCTan3vyVV8gsZj4d2Mpug.jpeg"/></div></div></figure><h1 id="0bb6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">关于这个系列</h1><p id="f15c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这个系列中，我们将讨论现有Symfony项目到Kubernetes (K8s)的迁移。无论您当前在何处以及如何发布您的应用程序:裸机、VM或容器编排平台，通过遵循本指南，您将能够将其部署到K8s集群。</p><p id="cdcb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这些<strong class="ky ir"> how to </strong>文章的目标读者是那些已经了解Kubernetes、Docker和持续集成(CI)的一些基础知识、想要学习新技巧或者只想完成工作的人。</p><p id="67cd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">本系列的每一部分都致力于一个特定的主题:<a class="ae lz" rel="noopener ugc nofollow" target="_blank" href="/containerizing-symfony-application-a2a5a3bd5edc">构建Docker环境</a>，<a class="ae lz" href="https://medium.com/@babenko.i.a/testing-symfony-application-d02317d4018a" rel="noopener">在不同的级别上测试应用程序</a>，使用Helm将应用程序部署到Kubernetes，<a class="ae lz" href="https://medium.com/@babenko.i.a/building-continuous-delivery-pipeline-2cc05e213935" rel="noopener">构建CI管道</a>。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="e847" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">关于第2部分</h1><p id="b5a8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Kubernetes提供了许多对象来管理您的应用程序:部署、服务、入口、CronJob等。由于每个对象都必须在一个YAML文件中描述，所以在一个大项目中管理配置文件可能会让人不知所措。您最终可能会对相同的资源类型进行大量的复制粘贴。这可能会导致一种感觉，事情不再受控制。维护成为一项艰巨的任务。</p><p id="de07" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就这样，直到赫尔姆出现。它提供了图表，有助于定义您的应用程序并将其发布到Kubernetes。</p><p id="ace7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在本文中，我们将创建一个Helm图表，利用Helm模板的强大功能，并讨论不同环境下的应用程序配置。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="c9c6" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">关于虚拟项目</h1><p id="acf3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我为这个系列准备了一个简单的Symfony 4应用程序。它需要PHP-FPM，Nginx和MySQL来运行。更多详情，请参考<a class="ae lz" rel="noopener ugc nofollow" target="_blank" href="/containerizing-symfony-application-a2a5a3bd5edc">第1部分</a>。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="5c99" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">创建舵图</h1><p id="e702" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可以将Chart视为一个包，而Helm本身则是一个包管理器。每个图表描述了相关的Kubernetes资源，其结构如下:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="bd20" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们从在虚拟项目的根目录中创建<strong class="ky ir"> helm </strong>文件夹并在<strong class="ky ir"> Chart.yaml </strong>文件中描述我们的包开始:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7779" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以使用<strong class="ky ir">。helmignore </strong>文件通知Helm，我们不想处理某些特定的文件:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7e10" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在集群中运行我们的项目所需的Kubernetes资源在<strong class="ky ir"> templates </strong>文件夹中描述。在我们的例子中，我们只需要3种类型的对象:</p><ul class=""><li id="456a" class="ms mt iq ky b kz lu ld lv lh mu ll mv lp mw lt mx my mz na bi translated"><strong class="ky ir">部署</strong>描述了要在集群中创建的pod。尽管每个pod可能由几个容器组成，但更常见的方法是每个pod有一个容器。这就是为什么在本教程中，您可以将pod视为一个容器。</li><li id="dbc3" class="ms mt iq ky b kz nb ld nc lh nd ll ne lp nf lt mx my mz na bi translated"><strong class="ky ir">服务</strong>实现吊舱之间的通信。</li><li id="6aa6" class="ms mt iq ky b kz nb ld nc lh nd ll ne lp nf lt mx my mz na bi translated"><strong class="ky ir">入口</strong>向外部客户端公开服务。</li></ul><h1 id="3763" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">模板</h1><p id="0b32" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">而不是分别描述每个资源(即Nginx部署、PHP-FPM部署等。)，我们将为每种对象类型创建可配置的模板，然后将它们应用于相关服务:Nginx、PHP-FPM、MySQL。</p><h2 id="3e6f" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated"><strong class="ak">部署模板</strong></h2><p id="aaac" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们从部署模板开始，因为它是我们的应用程序中最重要的对象。通过遵循最佳实践，我创建了包含以下内容的<strong class="ky ir"> deployment.tpl </strong>文件:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8308" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">每个模板都包裹在<strong class="ky ir">定义</strong>块中:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b0e5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">实际模板以对象类型和名称开始:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e40b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">注意，我们在这里和那里使用变量:<strong class="ky ir"> .service.name </strong>，<strong class="ky ir"> .service.replicas </strong>等等。在YAML文件中包含模板时，可以向include命令传递字典。<strong class="ky ir">、</strong>的点字符，即前缀<strong class="ky ir">、</strong>的变量名是对该字典的引用。</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="65b4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在上一节中，我们指示集群用容器形成一个pod，这些容器标有服务名，并定义所需的副本数量。</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ad07" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在<strong class="ky ir">模板</strong>部分，我们定义了如何创建和标记容器。让我们仔细看看容器的定义:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="04dc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们为每个容器提供名称、要使用的图像和从注册表中提取图像的条件。在<strong class="ky ir"> resources </strong>部分中，如果配置的资源可用，我们指示集群启动容器，如果容器超出CPU和内存限制，则指示集群终止容器。至于环境变量，我们有两个可能的配置选项:使用普通值，使用Kubernetes secrets。</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="de58" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">完成模板后，我们可以为我们的服务创建部署YAML文件:</p><ul class=""><li id="4a53" class="ms mt iq ky b kz lu ld lv lh mu ll mv lp mw lt mx my mz na bi translated"><strong class="ky ir">PHP-fpm . deployment . YAML</strong>:</li></ul><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><ul class=""><li id="389d" class="ms mt iq ky b kz lu ld lv lh mu ll mv lp mw lt mx my mz na bi translated">mysql.deployment.yaml :</li></ul><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><ul class=""><li id="f0dd" class="ms mt iq ky b kz lu ld lv lh mu ll mv lp mw lt mx my mz na bi translated"><strong class="ky ir"> nginx.deployment.yaml </strong>:</li></ul><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="bde5" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">服务模板</h2><p id="7dcc" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">既然我们创建了pod，下一步就是实现它们之间的通信。但是在我们实际定义服务之前，让我们在<strong class="ky ir"> service.tpl </strong>文件中创建一个新模板:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0ddb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">它与我们已经在部署模板中看到的非常相似:资源类型和元数据。在<strong class="ky ir"> spec </strong>部分，我们为一个pod分配了一个内部集群IP地址，该地址标有服务名，并公开了它的一个端口。</p><p id="6096" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">事不宜迟，让我们来定义应用服务:</p><ul class=""><li id="2cc3" class="ms mt iq ky b kz lu ld lv lh mu ll mv lp mw lt mx my mz na bi translated"><strong class="ky ir"> php-fpm.service.yaml </strong>:</li></ul><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><ul class=""><li id="c21c" class="ms mt iq ky b kz lu ld lv lh mu ll mv lp mw lt mx my mz na bi translated"><strong class="ky ir"> mysql.service.yaml </strong>:</li></ul><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><ul class=""><li id="3815" class="ms mt iq ky b kz lu ld lv lh mu ll mv lp mw lt mx my mz na bi translated">nginx.service.yaml :</li></ul><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="47da" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">入口模板</h2><p id="0003" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因为我们的应用程序必须可以从外部访问，所以我们需要创建一个入口对象。下面是<strong class="ky ir"> ingress.tpl </strong>文件内容:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f590" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">根据路径，每个入口规则将主机映射到一个或多个服务。在我们的例子中，我们将所有请求转发给一个服务。</p><p id="122f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们通过在<strong class="ky ir"> nginx.ingress.yaml </strong>文件中创建一个Ingress资源来使Nginx服务从外部可用:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="6854" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">配置</h2><p id="65fe" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你可能会想，那些是什么<strong class="ky ir">。值</strong>变量，我们在YAML文件中使用的那个？嗯，<strong class="ky ir">点字符</strong>是主图表字典，<strong class="ky ir">值</strong>是配置，在<strong class="ky ir"> values.yaml </strong>文件中定义:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="629c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我相信这个配置是不言自明的，但是如果你非常细心，你可能已经注意到，我们在模板中使用的一些变量(例如<strong class="ky ir"> nginx.host </strong>和<strong class="ky ir"> imageTag </strong>)并没有出现在<strong class="ky ir"> values.yaml </strong>文件中。我们希望某些配置是动态的，因为它可能因环境而异。这些动态值可以直接传递给Helm upgrade命令，我们将使用它来发布图表。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="155a" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">发布图表</h1><p id="8ae4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们完成了图表，并准备将其发布到K8s集群。如果您尚未在Docker Desktop中启用Kubernetes，请转到<strong class="ky ir">首选项- &gt; Kubernetes </strong>并标记<strong class="ky ir">启用Kubernetes </strong>选项。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/cde470e61c5a3a2a0368409c916270dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lneZcc5Ims_AMH6c0jLfCQ.jpeg"/></div></div></figure><p id="32ba" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您使用的是Mac OS，可以使用Homebrew安装Kubernetes CLI (kubectl)和Helm:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ff67" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，让我们通过为我们的项目创建一个新的名称空间来配置集群:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="113d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">添加数据库机密:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="01cb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">启动入口控制器，如这里所述<a class="ae lz" href="https://kubernetes.github.io/ingress-nginx/deploy/#docker-for-mac" rel="noopener ugc nofollow" target="_blank"/>:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5dd1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在我们最终发布图表之前，我想提一下，我们在本系列的<a class="ae lz" rel="noopener ugc nofollow" target="_blank" href="/containerizing-symfony-application-a2a5a3bd5edc">前一部分</a>中构建的图像已经用最后一个提交散列进行了标记，并被推送到Docker Hub。记住这一点，让我们安装图表:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6a4b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">注意，我们在Helm命令中指定了一些环境变量、主机名和图像标签。当您想要在多个集群上安装具有不同配置的相同图表时(例如，转移和生产)，这很有用。</p><p id="ee87" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要访问本地机器上的应用程序，我们需要将域记录添加到<strong class="ky ir"> hosts </strong>文件中:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b381" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，您可以在浏览器中打开http://symfony-dummy-project.io/products/1的<a class="ae lz" href="http://symfony-dummy-project.io/products/1" rel="noopener ugc nofollow" target="_blank">并查看产品页面:</a></p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/4f376b7e3f573b3810e0bbb918505d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSun_CqACV7BB2_Jimx4SQ.png"/></div></div></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="e5c4" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">下一步是什么？</h1><p id="57cd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们已经成功地将虚拟项目部署到K8s集群，并准备好处理持续集成(CI)主题。但是在我们开始建造管道之前，<a class="ae lz" href="https://medium.com/@babenko.i.a/testing-symfony-application-d02317d4018a" rel="noopener">让我们在下一部分</a>谈论测试。</p><p id="d7f0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">感谢您的阅读，下次再见！</p></div></div>    
</body>
</html>