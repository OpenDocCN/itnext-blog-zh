<html>
<head>
<title>How we do GitOps @ Mettle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何尽最大努力</h1>
<blockquote>原文：<a href="https://itnext.io/how-we-do-gitops-mettle-4cc771a6c029?source=collection_archive---------0-----------------------#2020-04-08">https://itnext.io/how-we-do-gitops-mettle-4cc771a6c029?source=collection_archive---------0-----------------------#2020-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/934c80ca0fce79e19def3c028a18e30b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upVhMxd5c97RfMAoPNs8nQ.png"/></div></div></figure><blockquote class="jy jz ka"><p id="6349" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">平台团队的最大原则之一是让我们的平台为工程师提供自助服务。GitOps让我们有可能做到这一点。</p></blockquote><p id="ca21" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在Mettle，我们充分利用GitOps将一切部署到我们的集群中，我们选择使用Flux CD(【https://github.com/fluxcd/flux】)作为我们的GitOps控制器。</p><p id="3088" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Flux是一个工具，可以自动确保集群的状态与git中的配置相匹配。它使用集群中的一个操作符来触发Kubernetes内部的部署，这意味着您不需要单独的CD工具。Flux监控所有相关的映像存储库，检测新的映像，触发部署，并基于此更新所需的运行配置(以及可配置的策略)。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/e15f59df210276bfc55eb892483b94ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bk5AyCKIUDNhisg-hKrgeA.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">焊剂工作原理概述(参考<a class="ae ld" href="https://github.com/fluxcd/helm-operator-get-started" rel="noopener ugc nofollow" target="_blank">https://github.com/fluxcd/helm-operator-get-started</a></figcaption></figure><h1 id="4146" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">我们如何使用Flux @ Mettle</h1><p id="a0a5" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">我们的集群中运行着许多flux实例，每个实例都与GitHub中的一个特定存储库相协调。具体来说，关于工作负载，整个过程使用三个主要的存储库，我将在下面详细解释。</p><h2 id="44c3" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw mb lb mx my mf lc mz na mj nb bi translated">k8s-舵-图表</h2><p id="59ff" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">这是我们所有的自定义舵图表所在的地方，在合并到<code class="fe nc nd ne nf b">master</code>分支时，我们创建一个新的图像标签容器，包含现有的图表以及作为拉请求的一部分而创建的任何新版本。</p><p id="12f8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们从运行在集群内部的Helm注册表中提供这些图表，该注册表可通过<code class="fe nc nd ne nf b"><a class="ae ld" href="http://k8s-helm-charts.flux.svc.cluster.local" rel="noopener ugc nofollow" target="_blank">http://k8s-helm-charts.flux.svc.cluster.local</a>.</code>访问</p><p id="e8c0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们的helm registry的部署规范有以下注释，以便Flux自动部署新创建的images标签。</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="ea25" class="mq lo iq nf b gy nk nl l nm nn">annotations:    <br/>  flux.weave.works/automated: "true"    <br/>  flux.weave.works/tag.k8s-helm-charts: semver:~1.1</span></pre><p id="4d91" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">现在我们在集群中有了helm注册表，但是我们如何部署呢？</p><h2 id="0048" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw mb lb mx my mf lc mz na mj nb bi translated">kubernetes-资源</h2><p id="05c2" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">这个存储库混合了原始的Kubernetes清单(<code class="fe nc nd ne nf b">yaml</code>文件)和<code class="fe nc nd ne nf b">HelmReleases</code>。资源包括RBAC策略和PodSecurityPolicy清单，以及NGINX入口控制器和Istio等实用程序的HelmReleases。</p><p id="8b93" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我想花一点时间来深入了解利用我们的自定义图表之一的HelmRelease的构成(参见下面的Prometheus):</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="2eee" class="mq lo iq nf b gy nk nl l nm nn">spec:<br/>  chart:<br/>    name: prometheus<br/>    repository: http://k8s-helm-charts.flux.svc.cluster.local<br/>    version: 2.6.43<br/>  releaseName: prometheus</span></pre><p id="3822" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">您可以从上面看到指定的helm图表版本，位置是在集群内部本地运行的helm注册表。显然有一个竞争条件，我将在这篇文章的后面介绍。</p><p id="cce1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们将为每个环境创建一个目录，其中包含该环境部署我们定义的“普通集群”所需的所有资源。过去的目录结构看起来像下面这样:</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="8b13" class="mq lo iq nf b gy nk nl l nm nn">.<br/>├── environments<br/>│   ├── sbx<br/>│   ├── dev<br/>│   └── stg<br/>│   ├── prd</span></pre><p id="07bd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们使用bootkube(<a class="ae ld" href="https://github.com/kubernetes-sigs/bootkube" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-sigs/bootkube</a>)引导我们的集群，并且作为我们boot kube资产的一部分，我们部署了一个Flux实例，在特定的环境路径中查看这个存储库(见下文)。</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="4ca6" class="mq lo iq nf b gy nk nl l nm nn">- --<a class="ae ld" href="mailto:git-url=git@github.com" rel="noopener ugc nofollow" target="_blank">git-url=git@github.com</a>:example/kubernetes-resources<br/>- --git-branch=master<br/>- --git-path=environment/prd<br/>- --git-sync-tag=flux-sync-prd</span></pre><p id="1dfc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">一旦一个完整的协调循环完成,“普通集群”就可以接收定制工作负载了。</p><h2 id="30fa" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw mb lb mx my mf lc mz na mj nb bi translated">k8s-发布-勇气</h2><p id="835b" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">存储库只包含构成Mettle的每个微服务的<code class="fe nc nd ne nf b">HelmRelease</code>定义，每个环境一个。目前，我们在每个环境中部署了大约100个微服务。下面可以看到其中一个HelmReleases的片段:</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="6e3d" class="mq lo iq nf b gy nk nl l nm nn">apiVersion: helm.fluxcd.io/v1<br/>kind: HelmRelease<br/>metadata:  <br/>  annotations:    <br/>    flux.weave.works/automated: "true"  <br/>  name: account-balance  <br/>  namespace: eevee<br/>spec:  <br/>  chart:    <br/>    name: backend    <br/>    repository: http://k8s-helm-charts.flux.svc.cluster.local <br/>    version: 2.0.43 <br/>  releaseName: account-balance</span></pre><p id="d0eb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">为了保持一致性，我们所有的后端微服务都是从两个<code class="fe nc nd ne nf b">backend</code>特定导航图中的一个派生出来的，以确保标签分类等方面的一致性。同样，与<code class="fe nc nd ne nf b">kubernetes-resources</code>一样，我们将为每个环境创建一个包含所有<code class="fe nc nd ne nf b">HelmRelease</code>定义的目录。</p><h1 id="3b82" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">加入Kustomize</h1><p id="a4a5" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">在早期，我们在<code class="fe nc nd ne nf b">kubernetes-resources</code>和<code class="fe nc nd ne nf b">k8s-releases-mettle</code>的环境中有很多重复，这是我们开始密切关注Kustomize(<a class="ae ld" href="https://github.com/kubernetes-sigs/kustomize" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-sigs/kustomize</a>)的时候。</p><p id="6095" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">平台团队从<code class="fe nc nd ne nf b">kubernetes-resources</code>开始，因为我们想在这里证明Kustomize我们自己，并且不影响工程自助服务工作流。此外，我们没有看到对基础资源的很多更改，所以我们觉得使用这个存储库作为测试平台很舒服。</p><p id="03cf" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们从创建以下目录开始</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="b0f3" class="mq lo iq nf b gy nk nl l nm nn">.<br/>└── kustomize<br/>    ├── base<br/>    ├── dev<br/>    ├── prd<br/>    ├── sbx<br/>    ├── stg</span></pre><h2 id="a2eb" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw mb lb mx my mf lc mz na mj nb bi translated">基本目录</h2><p id="1249" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated"><code class="fe nc nd ne nf b">kustomize/base</code>中包含的所有内容都是非特定于环境的配置，并围绕集群的各个区域进行调整(例如入口或单点登录)。这方面的一个例子如下:</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="8033" class="mq lo iq nf b gy nk nl l nm nn">cluster<br/>├── helmreleases<br/>├── namespaces<br/>├── priorityclasses<br/>├── psps<br/>├── rbac<br/>└── storageclasses</span></pre><p id="66b8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><code class="fe nc nd ne nf b">kustomize/base</code>中的示例<code class="fe nc nd ne nf b">HelmRelease</code>如下所示:</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="cbf6" class="mq lo iq nf b gy nk nl l nm nn">---<br/>apiVersion: helm.fluxcd.io/v1<br/>kind: HelmRelease<br/>metadata:<br/>  annotations:<br/>    flux.weave.works/automated: "false"<br/>    flux.weave.works/tag.chart-image: semver:~1.17<br/>  name: cluster-autoscaler<br/>  namespace: kube-system<br/>spec:<br/>  chart:<br/>    name: cluster-autoscaler<br/>    repository: https://kubernetes-charts.storage.googleapis.com/<br/>    version: 6.3.0<br/>  releaseName: cluster-autoscaler<br/>  values:<br/>    autoDiscovery:<br/>      tags:<br/>        - k8s.io/cluster-autoscaler/enabled<br/>    awsRegion: eu-west-2<br/>    image:<br/>      repository: k8s.gcr.io/cluster-autoscaler<br/>      tag: "v1.17.0"<br/>    nodeSelector:<br/>      node.kubernetes.io/role: critical<br/>    podAnnotations:<br/>      iam.amazonaws.com/role: cluster-autoscaler<br/>    priorityClassName: system-cluster-critical<br/>    tolerations:<br/>      - key: node.kubernetes.io/role<br/>        value: critical<br/>        operator: Equal<br/>        effect: NoSchedule</span></pre><p id="a610" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">注意这里没有应用特定于环境的入口注释。</p><h2 id="2fde" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw mb lb mx my mf lc mz na mj nb bi translated">“特定于环境”的目录</h2><p id="d3a2" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">特定于环境的目录结构与<code class="fe nc nd ne nf b">base</code>目录中的目录结构一致。但是，它只包含其环境所需的目录。例如，每个环境都继承<code class="fe nc nd ne nf b">base/cluster</code>目录，但不一定继承<code class="fe nc nd ne nf b">tools</code>目录。让我们深入了解一下环境目录的构成…</p><p id="481c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在顶层，我们有一个单独的<code class="fe nc nd ne nf b">kustomization.yaml</code>文件，它引用其中的子目录(见下文)</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="1d65" class="mq lo iq nf b gy nk nl l nm nn">apiVersion: kustomize.config.k8s.io/v1beta1<br/>kind: Kustomization<br/>bases:<br/>  - cert-manager<br/>  - cluster</span></pre><p id="cc83" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这些子目录中包含以下目录和文件:</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="1fc6" class="mq lo iq nf b gy nk nl l nm nn">cluster<br/>├── helmreleases<br/>└── kustomization.yaml</span></pre><p id="a823" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这个<code class="fe nc nd ne nf b">kustomization.yaml</code>略有不同，它继承自<code class="fe nc nd ne nf b">base</code>中的相应目录，但这里是我们修补特定于环境的配置的地方。</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="9c31" class="mq lo iq nf b gy nk nl l nm nn">apiVersion: kustomize.config.k8s.io/v1beta1<br/>kind: Kustomization<br/>bases:<br/>  - ../../base/cluster<br/>patches:<br/>  - helmreleases/cluster-autoscaler.yaml<br/>  - helmreleases/kiam.yaml</span></pre><p id="b077" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><code class="fe nc nd ne nf b">cluster-autoscaler</code>的补丁如下所示:</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="7256" class="mq lo iq nf b gy nk nl l nm nn">apiVersion: helm.fluxcd.io/v1<br/>kind: HelmRelease<br/>metadata:<br/>  name: cluster-autoscaler<br/>  namespace: kube-system<br/>spec:<br/>  values:<br/>    autoDiscovery:<br/>      clusterName: dev</span></pre><h2 id="1f72" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw mb lb mx my mf lc mz na mj nb bi translated">“kustomize build”的使用</h2><p id="0a63" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">要查看哪个Flux将进行协调，我们可以执行以下命令:</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="013e" class="mq lo iq nf b gy nk nl l nm nn">kustomize build kustomize/dev &gt; dev.yaml</span></pre><p id="6970" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">上述操作将创建一个文件，其中包含要部署到集群的所有资源，并且还应用了特定于环境的补丁。</p><h2 id="8a8f" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw mb lb mx my mf lc mz na mj nb bi translated">这给了我们什么？</h2><p id="89b1" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">这为我们提供了<code class="fe nc nd ne nf b">kustomize/base</code>中95%的资源定义，并允许我们轻松地看到环境之间的差异。</p><p id="2da5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">此外，这意味着直接对<code class="fe nc nd ne nf b">base</code>进行的更改会在所有环境中传播(例如，在<code class="fe nc nd ne nf b">HelmRelease)</code>中升级到新的图表版本)。</p><p id="cf1e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">相反，我们可以很容易地对单个环境进行更改以进行测试，例如升级所用图表的版本。</p><p id="f16f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">重要的是，它允许我们通过CI在应用到集群的资源到达集群之前执行验证，以确保这些资源符合规范。我们利用了rego策略和使用Kubeval的严格模式林挺。</p><p id="78a1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">有关这方面的更多信息，请参见下面的链接</p><ul class=""><li id="b6c3" class="no np iq ke b kf kg kj kk la nq lb nr lc ns kz nt nu nv nw bi translated">参见<a class="ae ld" href="https://github.com/swade1987/deprek8ion" rel="noopener ugc nofollow" target="_blank">https://github.com/swade1987/deprek8ion</a></li><li id="9663" class="no np iq ke b kf nx kj ny la nz lb oa lc ob kz nt nu nv nw bi translated"><a class="ae ld" href="https://bit.ly/2RjyvCU" rel="noopener ugc nofollow" target="_blank">https://bit.ly/2RjyvCU</a></li></ul><h2 id="56aa" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw mb lb mx my mf lc mz na mj nb bi translated">k8s-发布-勇气</h2><p id="d285" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">平台团队随后与工程团队合作，将<code class="fe nc nd ne nf b">k8s-releases-mettle</code>移到<code class="fe nc nd ne nf b">Kustomize</code>，因为我们已经吸取了教训。他们与我们的顶级目录结构保持一致:</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="d8db" class="mq lo iq nf b gy nk nl l nm nn">.<br/>└── kustomize<br/>    ├── base<br/>    ├── dev<br/>    ├── prd<br/>    ├── sbx<br/>    ├── stg</span></pre><p id="66aa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">他们的子目录结构类似于<code class="fe nc nd ne nf b">kubernetes-resources</code>，但是范围在<code class="fe nc nd ne nf b">namespace</code>级别。工程师定义了这种结构，因为他们是负责存储库的人，所以它需要对他们有意义。</p><h1 id="da0a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">应用推广</h1><p id="de9e" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">我觉得很重要的一点就是要讲一下微服版本是如何通过我们的环境来推广的。</p><p id="4df5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">让我们从查看<code class="fe nc nd ne nf b">k8s-releases-mettle:</code>的<code class="fe nc nd ne nf b">base</code>目录中的一个<code class="fe nc nd ne nf b">HelmRelease</code>开始</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="d8dc" class="mq lo iq nf b gy nk nl l nm nn">apiVersion: helm.fluxcd.io/v1<br/>kind: HelmRelease<br/>metadata:<br/>  annotations:<br/>    flux.weave.works/automated: "true"<br/>  name: account-balance<br/>  namespace: eevee<br/>spec:<br/>  chart:<br/>    name: backend<br/>    repository: http://k8s-helm-charts.flux.svc.cluster.local<br/>  releaseName: account-balance<br/>  values:<br/>    application:<br/>      replicaCount: 3<br/>      image:<br/>        repository: quay.io/example/account-balance</span></pre><p id="ff74" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">上面要注意的关键点是图表版本和图像标签没有指定，因为它们是特定于环境的配置。</p><p id="48b8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">现在我们来看看<code class="fe nc nd ne nf b">dev</code>目录中对应的<code class="fe nc nd ne nf b">HelmRelease</code>:</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="39ea" class="mq lo iq nf b gy nk nl l nm nn">apiVersion: helm.fluxcd.io/v1<br/>kind: HelmRelease<br/>metadata:<br/>  annotations:<br/>    flux.weave.works/tag.application: 'glob:dev-*'<br/>  name: account-balance<br/>  namespace: eevee<br/>spec:<br/>  values:<br/>    dependsOn:<br/>      schemaRegistry:<br/>        enabled: true<br/>    application:<br/>      image:<br/>        tag: dev-305a3cf56ef6d9505838bdf779e4173f0bad25jg<br/>  chart:<br/>    version: 2.0.34</span></pre><p id="b173" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这里重要的部分是从<code class="fe nc nd ne nf b">dev-</code>开始专门寻找图像标签的<code class="fe nc nd ne nf b">flux.weave.works/tag.application</code>注释。这是我们向环境推广新形象的方式。在提交SHA之前，我们用环境前缀重新标记图像。</p><p id="c6f9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">工程师们在Concourse中有一个脚本，它使用<code class="fe nc nd ne nf b">kubectl</code>来等待发布成功，如下所示:</p><pre class="lf lg lh li gt ng nf nh ni aw nj bi"><span id="b6ef" class="mq lo iq nf b gy nk nl l nm nn">echo "Testing kubeconfig works against environment";<br/>echo "Checking for replica set creation"</span><span id="7404" class="mq lo iq nf b gy oc nl l nm nn">attempt_counter=1;<br/>max_attempts=60;<br/><br/>until [[ $(kubectl get replicaset -n "${NAMESPACE}" -l app_name="${SERVICE}",app_version="${APP_VERSION}" | wc -l) -gt 1 ]]; do</span><span id="fde5" class="mq lo iq nf b gy oc nl l nm nn">if [ ${attempt_counter} -eq ${max_attempts} ]; then<br/>  echo "Max attempts reached";<br/>  exit 1;<br/>fi<br/>  attempt_counter=$(($attempt_counter+1));<br/>  sleep 10;<br/>done;</span><span id="3ba0" class="mq lo iq nf b gy oc nl l nm nn">echo 'Replica OK';<br/><br/>echo 'Waiting for deployment to rollout';<br/>kubectl rollout status -n "$NAMESPACE" deployment/"$SERVICE" --watch=true --timeout=10m;</span></pre><h1 id="3ab3" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">摘要</h1><p id="c851" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">总之，利用GitOps，我们为工程师创建了一个自助服务平台，使他们能够专注于交付业务价值，而不完全需要平台团队的帮助。他们专注于构建容器映像和管理其微服务的测试，Flux处理部署。</p><h1 id="8691" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">还能做什么？</h1><p id="e650" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">这一旅程尚未结束，我们需要做出一些改变:</p><h2 id="2e46" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw mb lb mx my mf lc mz na mj nb bi translated">集群helm注册表外</h2><p id="233e" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">目前，当对我们的自定义helm图表进行更改时，我们必须等待新的注册表映像在我们的集群中部署，这需要时间，并最终导致HelmReleases失败，因为指定的图表版本没有出现在注册表容器映像中。</p><p id="d321" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">因此，我们将把我们的helm注册表存储在一个Google云平台桶中。这对我们有两个好处:</p><ul class=""><li id="e7ac" class="no np iq ke b kf kg kj kk la nq lb nr lc ns kz nt nu nv nw bi translated">以相对低廉的成本实现无限存储</li><li id="2974" class="no np iq ke b kf nx kj ny la nz lb oa lc ob kz nt nu nv nw bi translated">在所有环境中立即提供新的舵图版本。</li></ul><p id="fd9a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">最后，在集群重建时，这意味着HelmReleases不会因为尚未部署helm注册表映像而进入挂起或失败状态。</p><h2 id="7436" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw mb lb mx my mf lc mz na mj nb bi translated">头盔v3</h2><p id="5ba0" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">我们仍然需要升级到头盔3，我们将在未来一两周内完成。幸运的是<code class="fe nc nd ne nf b">HelmRelease</code>让这变得微不足道，我会确保再写一篇关于我们如何管理它的博文。</p><h1 id="673a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">寿师爷</strong></h1><p id="a9e7" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">首先，我个人要感谢斯蒂芬·普罗丹(<a class="ae ld" href="https://twitter.com/stefanprodan" rel="noopener ugc nofollow" target="_blank">https://twitter.com/stefanprodan</a>)过去和将来的帮助，他总是愿意听取我的想法和建议，这是我的荣幸！</p><p id="4248" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">更广泛地说，我要感谢Flux社区在整个旅程中的持续帮助，我希望我们在Mettle，特别是我自己，能够继续回馈社区我们已经学到的教训，并在未来继续学习。</p><h1 id="9388" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">现在是你自己尝试的时候了😊</h1><p id="db9c" class="pw-post-body-paragraph kb kc iq ke b kf ml kh ki kj mm kl km la mn kp kq lb mo kt ku lc mp kx ky kz ij bi translated">在问了很多关于如何构建GitOps库的问题后，我实际上创建了一个例子，可以在<a class="ae ld" href="https://github.com/swade1987/gitops-with-kustomize" rel="noopener ugc nofollow" target="_blank">https://github.com/swade1987/gitops-with-kustomize</a>找到。</p><p id="64fc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">另外，我强烈推荐去https://github.com/fluxcd/multi-tenancy的<a class="ae ld" href="https://github.com/fluxcd/multi-tenancy" rel="noopener ugc nofollow" target="_blank">看看。</a></p></div></div>    
</body>
</html>