<html>
<head>
<title>Transformations: The 114 C++ algorithms series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">转换:114 C++算法系列</h1>
<blockquote>原文：<a href="https://itnext.io/transformations-the-114-c-algorithms-series-deacdbd4c373?source=collection_archive---------2-----------------------#2022-03-27">https://itnext.io/transformations-the-114-c-algorithms-series-deacdbd4c373?source=collection_archive---------2-----------------------#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6130" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎阅读114 C++标准算法系列的第四篇文章。转换算法通过更改元素的值、更改元素的顺序或删除元素来改变范围的状态。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b60c6a48d93ac84eff1f04fe3ffc4b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1BHvCDirjGruw6qJrc9fBA.png"/></div></div></figure><p id="6489" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们今天要讨论的几个转换算法也有惰性视图变体。视图是作为C++20 中<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/c-20-ranges-complete-guide-4d26e3511db0"> ranges功能的一部分引入的标准算法的延迟评估和可组合变体。</a></p><h2 id="cc9e" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">该系列:</h2><ul class=""><li id="fe08" class="lr ls iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lz ma mb bi translated"><a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/the-114-standard-c-algorithms-introduction-2a75a2df4300">简介</a></li><li id="4b30" class="lr ls iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/sorting-partitioning-the-114-c-algorithms-series-6503ad41cede">排序和划分算法</a></li><li id="8f1e" class="lr ls iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/divide-conquer-and-sets-the-114-c-algorithms-series-d0085a38046e">对排序或分区范围进行操作的算法</a></li><li id="f7c1" class="lr ls iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">转换算法</li><li id="5f59" class="lr ls iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/left-folds-and-other-reductions-the-114-c-algorithms-series-6195724d324">左侧折叠和其他缩减</a></li><li id="dddd" class="lr ls iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/generators-copies-and-moves-the-114-c-algorithms-series-1d0774472877">生成器、复制和移动</a></li><li id="6c9c" class="lr ls iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/heap-and-heap-the-114-c-algorithms-series-1d4215ae9f0d">堆和堆</a></li><li id="a7f8" class="lr ls iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><a class="ae kx" href="https://medium.com/@simontoth/8a6ed951ad40" rel="noopener">搜索和最小值-最大值</a></li><li id="e5ab" class="lr ls iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">结论(即将发布)</li></ul><h1 id="a712" class="mh kz iq bd la mi mj mk ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx bi translated">改变</h1><p id="4d94" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">最直接的转换可能是对每个元素应用一个转换函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/4df4714129cb47793587f84bd1f537ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWpELp9o7IQqdOtB0Z9Ryw.png"/></div></div></figure><p id="3856" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">标准库提供了一元和二元std::transform。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="59f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为输出范围是使用迭代器指定的，所以两种转换算法都可以内联操作或输出到另一个范围。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="6b2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这两个变量，所提供的函子不能使迭代器无效，也不能修改任何一个范围的元素。最重要的是，这两种转换都不能保证所提供的仿函数严格地从左到右应用(这只对有状态仿函数有影响)。</p><p id="d3fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正是这些限制将一元std::transform与std::for_each区分开来。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该示例利用可变lambdas(第6行和第10行)和来自C++14的通用lambda捕获，它允许在lambda的捕获部分创建和初始化变量。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="eb14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Transform也是我们谈到的第一个带有惰性变体的算法。C++20引入了视图的概念作为范围功能的一部分。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="eb50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我有一篇关于C++20范围的独立文章，也包含了视图。这里的主要要点是:</p><ul class=""><li id="7810" class="lr ls iq jp b jq jr ju jv jy nl kc nm kg nn kk ly lz ma mb bi translated">组合视图发生在编译时；第5行没有运行时操作</li><li id="9752" class="lr ls iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">even_squares对象本身就是一个视图；复制和移动的成本很低，并且不拥有它所查看的数据</li><li id="259c" class="lr ls iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">视图的每个组件都被延迟评估；如果我们只从even_squares视图中读取一个元素，那么views::filter将被计算两次，而views::transform只被计算一次</li></ul><h1 id="082e" class="mh kz iq bd la mi mj mk ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx bi translated">相邻_差异</h1><p id="6d37" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">尽管如此命名，但adjacent_difference是二进制转换的一种变体，对单个范围内的相邻元素进行操作。</p><p id="3d8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与transform不同，adjacent_difference保证从左到右应用。此外，因为输入范围允许每个元素仅被读取一次，所以该算法在内部存储最后读取值的副本(用作左操作数)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi no"><img src="../Images/8a474db1c235ae7f6d81bbf10ad5b793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GgC_U9F4vxD13xR8x_W-nA.png"/></div></div></figure><p id="ad53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认版本将计算相邻元素的差异，复制第一个元素。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7cbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，由于我们可以选择不同的函子(而不是std::minus)，我们也可以使用std::adjacent_difference来生成序列:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7ced" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，输出范围的std::next(data.begin())在这里很关键。adjacent_difference算法将每个元素只读取一次，并记住左参数的前一次读取值。std::next确保我们在任一参数之前生成一个元素。</p><h1 id="c586" class="mh kz iq bd la mi mj mk ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx bi translated">移除，移除_如果</h1><p id="a470" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">remove的命名有点误导。删除将移动范围中的元素，这样前导子范围将不包含指定的元素。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/688c5914b92c839687a39af2a4e12aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MoSGpAOYBzHMXCO7oAqe2g.png"/></div></div></figure><p id="7273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于std::unique，该算法不能调整范围的大小，所以它返回一个迭代器来指定新的结束位置。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="63c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种命名模式将在几种算法中重复。基本版本总是基于提供的值进行操作的变量(第2行)，_if变量依赖于提供的谓词(第7行)。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="cb43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然remove没有直接的惰性版本，但我们通常可以用std::views::filter替换它。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9db2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个显著的区别是，views::filter改变了范围的迭代方式，但不修改范围的实际内容。</p><h1 id="c56b" class="mh kz iq bd la mi mj mk ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx bi translated">替换，替换_如果</h1><p id="0ef5" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">我们可以使用替换算法来替换值，而不是删除它们。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/ca160ee5bbf0d110d28524b38630ae6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsfrzy9ak_yjRbPKDEv6bA.png"/></div></div></figure><p id="a4d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遵循相同的命名模式，std::replace替换匹配给定值的元素，而std::replace_if基于谓词替换元素。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="b900" class="mh kz iq bd la mi mj mk ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx bi translated">反转、旋转、洗牌</h1><p id="f71b" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">反向算法提供了给定双向范围的直接基于交换的反向。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/7ff8a158ecad5f6c7a63dfbf5234cfd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HjANOcaAjdqmrYkb3M8zA.png"/></div></div></figure><p id="a863" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然只有C++20引入了reverse的视图版本，但是每个双向范围本身都支持通过begin()和end()迭代器的rbegin()和rend()变体进行反向迭代。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="32df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当处理C数组或字符串等遗留类型时，反向迭代可能会很笨拙。然而，我们可以依靠std::span(从C++20开始)和std::string_view(从C++17开始)，它们都提供双向支持。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a2d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反向算法也为我们展示更高级的视图组合提供了一个极好的地方。例如，以下是跳过前导和尾随空白的修剪视图:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="cf80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和前面的例子一样，第4–7行没有运行时计算，处理是按需完成的，因为std::copy算法在组合视图上迭代(第10行)。</p><p id="8911" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从一个为空白字符返回true的谓词开始(第4行)。然后我们使用drop_while视图，该视图跳过元素，直到谓词返回false(第5行)。这已经是我们的单向修剪了。</p><p id="3913" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了构造反向修剪，我们反转范围，修剪现在的前导空白，然后再次反转范围(第6行)。最后，完全微调是两个部分微调操作的简单组合。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="2b30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">rotate算法正是这样做的，它旋转该范围内的元素，使得指定的元素现在是该范围的第一个元素。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/deb857300afbe4beb22fa2a319f02cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iaU-tToBymSEQLVnneiSGw.png"/></div></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="3ee5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">shuffle算法是现已失效的random_shuffle算法(在C++14中已弃用，在C++17中已删除)的后续算法，并依赖于C++11中添加的新随机工具。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/b8c96e4c541839fcd8acee784da575a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDAGMbImkHKi4LNXXXM5dw.png"/></div></div></figure><p id="776f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随机设施超出了本文的范围。然而，混洗将与任何统一随机位发生器一起工作。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5c96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用std::generate算法(我们将在下一篇文章中讨论)来生成52个唯一的卡片(第21行)。生成后，卡片将按顺序排列。</p><p id="4a28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们使用Mersenne Twister引擎统一位生成器(在其32位预定义别名中)，我们将它传递给洗牌算法，从而产生随机洗牌范围。</p><p id="9437" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第4–17行的输出流操作符重载提供了从索引到文本表示的转换，例如“梅花j”。</p><h1 id="b293" class="mh kz iq bd la mi mj mk ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx bi translated">下一个置换，上一个置换，下一个置换</h1><p id="1f73" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">置换算法将按字典顺序生成下一个或前一个置换。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/d084b788a741a5388a4b32b8c98f960f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GY0qQAJI_-YyJFjVmPRjSQ.png"/></div></div></figure><p id="a539" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">严格地说，调用next_permutation将调整元素的顺序，使其成为下一个更高的值(使用相同的仿函数)。如果没有这样的范围，next_permutation将循环回到最低值并返回false。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="a8e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当与一系列布尔值一起使用时，next_permutation可以用来迭代特定大小的所有集合。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="16e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从一个用假值填充的范围开始，将前三个元素设置为真(第6行)。然后我们打印出对应于真实值的元素(第10行)。最后，一旦我们将前三个元素设置为true(第14行)，循环回到初始范围，prev_permutation将返回false。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="a069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，为了检查一个范围是否是另一个范围的排列，我们可以使用is_permutation算法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nu"><img src="../Images/fc3831e0bf75306669da0eec5fee58b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukKCDGIUvc5nQB2Sq4ra_Q.png"/></div></div></figure><p id="d010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">is_permutation的效用主要在测试中弹出，我们经常需要测试两个值域是否分段相等但不一定同阶。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="1760" class="mh kz iq bd la mi mj mk ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx bi translated">感谢您的阅读</h1><p id="cecb" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">不要忘记关注，这样你就不会错过本系列的其他文章。例如，下一篇文章将讨论归约，即把一个范围归约为单个值的算法。</p><p id="3c31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在<a class="ae kx" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae kx" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>