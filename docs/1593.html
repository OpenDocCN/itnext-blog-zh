<html>
<head>
<title>Request Id Tracing in Node.js Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js应用程序中的请求Id跟踪</h1>
<blockquote>原文：<a href="https://itnext.io/request-id-tracing-in-node-js-applications-c517c7dab62d?source=collection_archive---------0-----------------------#2018-12-06">https://itnext.io/request-id-tracing-in-node-js-applications-c517c7dab62d?source=collection_archive---------0-----------------------#2018-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/649c183a76b9895ceed81a6ae66170ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sduEjXj8BCMSMYU1"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@nebirdsplus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲利普·布朗</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><p id="3a5f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您曾经在Node.js中编写过后端应用程序，您就会知道通过日志条目跟踪相同的HTTP请求是一个问题。通常您的日志看起来像这样:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f249" class="lk ll jg lg b gy lm ln l lo lp">[07/Nov/2018:15:48:11 +0000] User sign-up: starting request validation</span><span id="535a" class="lk ll jg lg b gy lq ln l lo lp">[07/Nov/2018:15:48:11 +0000] User sign-up: starting request validation</span><span id="6957" class="lk ll jg lg b gy lq ln l lo lp">[07/Nov/2018:15:48:12 +0000] User sign-up: request validation success</span><span id="da28" class="lk ll jg lg b gy lq ln l lo lp">[07/Nov/2018:15:48:13 +0000] User sign-up: request validation failed. Reason:<br/>...</span></pre><p id="400f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，日志条目混在一起，没有办法确定它们中的哪一个属于同一个请求。虽然您可能更喜欢看到这样的内容:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="bf8d" class="lk ll jg lg b gy lm ln l lo lp">[07/Nov/2018:15:48:11 +0000] [request-id:550e8400-e29b-41d4-a716-446655440000] User sign-up: starting request validation</span><span id="7432" class="lk ll jg lg b gy lq ln l lo lp">[07/Nov/2018:15:48:11 +0000] [request-id:340b4357-c11d-31d4-b439-329584783999] User sign-up: starting request validation</span><span id="5845" class="lk ll jg lg b gy lq ln l lo lp">[07/Nov/2018:15:48:12 +0000] [request-id:550e8400-e29b-41d4-a716-446655440000] User sign-up: request validation success</span><span id="21cb" class="lk ll jg lg b gy lq ln l lo lp">[07/Nov/2018:15:48:13 +0000] [request-id:340b4357-c11d-31d4-b439-329584783999] User sign-up: request validation failed. Reason:<br/>...</span></pre><p id="15a4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意这里包含请求标识符的<code class="fe lr ls lt lg b">[request-id:*]</code>部分。这些标识符将允许您过滤属于同一请求的日志条目。此外，如果您的应用程序由通过HTTP相互通信的微服务组成，请求标识符可以在HTTP头中发送，并用于跟踪链上所有微服务生成的日志中的请求链。对于诊断和监控目的来说，很难过高估计这个特性的价值。</p><p id="7139" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一名开发人员，您可能希望在一个地方配置web框架和/或日志库，并自动生成请求id并打印到日志中。但很遗憾，可能是Node.js世界的问题。</p><p id="3d55" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将讨论这个问题和一个可能的解决方案。</p><h1 id="7754" class="lu ll jg bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">好吧，但这是个问题吗？</h1><p id="caab" class="pw-post-body-paragraph kd ke jg kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在许多其他语言和平台中，如JVM和Java Servlet容器，HTTP服务器是围绕多线程架构和阻塞I/O构建的，这不是问题。如果我们将处理HTTP请求的线程的标识符放入日志中，它已经可以作为跟踪特定请求的自然过滤参数。这个解决方案远非理想，但是可以通过使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Thread-local_storage" rel="noopener ugc nofollow" target="_blank">线程本地存储</a> (TLS)来进一步增强。TLS基本上是一种在与当前线程相关的上下文中存储和检索键值对的方法。在我们的例子中，它可以用来存储为每个新请求生成的id(和任何其他诊断数据)。许多日志库都有围绕TLS构建的特性。作为一个例子，查看文档了解<a class="ae jd" href="https://logback.qos.ch/manual/mdc.html" rel="noopener ugc nofollow" target="_blank"> SLF4J的映射诊断上下文</a>。</p><p id="c7f0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于Node.js基于<a class="ae jd" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">事件循环</a>的异步特性，根本没有线程本地存储，因为js代码是在单线程上处理的。如果没有这个或类似的API，您将不得不在整个请求处理调用中拖动一个包含请求id的上下文对象。</p><p id="e1d1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看它在一个简单的Express应用程序中是什么样子的:</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ae20" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个假想的应用程序中，我们必须将<code class="fe lr ls lt lg b">req</code>对象传递给<code class="fe lr ls lt lg b">fakeDbAccess</code>函数，这样我们就能够将请求id输出到日志中。想想这种方法在实际应用中是多么的多余和容易出错，因为实际应用通常有更多的路径和模块。</p><p id="01f1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，Node.js社区的人们很久以前就在考虑TLS的替代方案。其中最流行的一种方法叫做连续本地存储(CLS)。</p><h1 id="fa90" class="lu ll jg bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">CLS来救援了！</h1><p id="8a07" class="pw-post-body-paragraph kd ke jg kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">CLS的第一个实现是<a class="ae jd" href="https://github.com/othiym23/node-continuation-local-storage" rel="noopener ugc nofollow" target="_blank">延续本地存储</a>库。它对CLS有如下定义:</p><blockquote class="my mz na"><p id="4c7e" class="kd ke nb kf b kg kh ki kj kk kl km kn nc kp kq kr nd kt ku kv ne kx ky kz la ij bi translated">延续本地存储的工作方式类似于线程编程中的线程本地存储，但它基于节点样式的回调链，而不是线程。</p></blockquote><p id="4cd3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你检查这个库的API，你可能会发现它比Java的TLS要复杂一些。但核心上，还是挺像的。它允许您将上下文对象与一系列调用相关联，并在以后获取它。</p><p id="55ba" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初的库是基于使用在Node.js v0.12之前可用的<code class="fe lr ls lt lg b">process.addAsyncListener</code> API及其用于node v0.12+的<a class="ae jd" href="https://github.com/othiym23/async-listener" rel="noopener ugc nofollow" target="_blank"> polyfill </a>。polyfill做了大量的猴子补丁，旨在包装内置的节点API。这就是为什么不应该考虑在Node.js的现代版本中使用原始库的主要原因。</p><p id="fb16" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，CLS库还有一个后续版本(或者更准确地说是一个分叉)，叫做<a class="ae jd" href="https://github.com/jeff-lewis/cls-hooked" rel="noopener ugc nofollow" target="_blank"> cls-hooked </a>。在Node.js &gt; = 8.2.1中，它使用了<a class="ae jd" href="https://nodejs.org/api/async_hooks.html" rel="noopener ugc nofollow" target="_blank"> async_hooks </a>，一个节点的内置API。尽管API仍处于试验阶段，但这种方法比使用polyfill的方法要好得多。如果你想了解更多关于异步钩子API的知识，可以看看这篇文章。</p><p id="2db2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们有了合适的工具，我们知道如何处理我们最初的问题，即跟踪应用程序日志中的请求id。</p><h1 id="3f7e" class="lu ll jg bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">为我的Express/Koa/other-web-framework提供现成的解决方案怎么样？</h1><p id="46da" class="pw-post-body-paragraph kd ke jg kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">正如您已经知道的，如果您希望在Node.js应用程序中包含请求id，您可以使用cls-hooked并将其与您正在使用的web框架集成。但是可能你会想用一个库来做这些事情。</p><p id="96df" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我在寻找这样的库，但没有找到一个好的任务匹配。是的，有几个集成了web框架的库，比如Express和CLS。另一方面，有些库提供请求id生成中间件。但是我没有找到一个库可以结合CLS和请求id来解决请求id跟踪问题。</p><p id="679c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，女士们先生们，请认识一下<a class="ae jd" href="https://github.com/puzpuzpuz/cls-rtracer" rel="noopener ugc nofollow" target="_blank"> cls-rtracer </a>，一个解决一个不那么小的问题的小库。它为Express和Koa提供了中间件，实现了基于CLS的请求id生成，并允许在您的调用链上的任何地方获取请求id。</p><p id="a30a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与cls-rtracer的集成基本上需要两步。第一个——将中间件连接到适当的位置。第二步—配置您的日志库。</p><p id="fccd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是基于Express的应用程序的外观:</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="154b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行时，此应用程序会生成类似于以下内容的控制台输出:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4d91" class="lk ll jg lg b gy lm ln l lo lp">2018-12-06T10:49:41.564Z: The app is listening on 3000</span><span id="874c" class="lk ll jg lg b gy lq ln l lo lp">2018-12-06T10:49:49.018Z [request-id:f2fe1a9e-f107-4271-9e7a-e163f87cb2a5]: Starting request handling</span><span id="8cdb" class="lk ll jg lg b gy lq ln l lo lp">2018-12-06T10:49:49.020Z [request-id:f2fe1a9e-f107-4271-9e7a-e163f87cb2a5]: Logs from fakeDbAccess</span><span id="3f0b" class="lk ll jg lg b gy lq ln l lo lp">2018-12-06T10:49:53.773Z [request-id:cd3a33a9-32cb-453b-a0f0-e36c65ff411e]: Starting request handling</span><span id="167f" class="lk ll jg lg b gy lq ln l lo lp">2018-12-06T10:49:53.774Z [request-id:cd3a33a9-32cb-453b-a0f0-e36c65ff411e]: Logs from fakeDbAccess</span><span id="09f3" class="lk ll jg lg b gy lq ln l lo lp">2018-12-06T10:49:54.908Z [request-id:8b352536-d714-4838-a372-a8e2cfcb4f53]: Starting request handling</span><span id="d097" class="lk ll jg lg b gy lq ln l lo lp">2018-12-06T10:49:54.910Z [request-id:8b352536-d714-4838-a372-a8e2cfcb4f53]: Logs from fakeDbAccess</span></pre><p id="ddc1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，集成本身包括附加由<code class="fe lr ls lt lg b">rTracer.expressMiddleware()</code>函数调用生成的Express中间件，并通过<code class="fe lr ls lt lg b">rTracer.id()</code>调用获得请求id。所以，再简单不过了。你也可以在这里找到Koa应用<a class="ae jd" href="https://github.com/puzpuzpuz/cls-rtracer/tree/master/examples" rel="noopener ugc nofollow" target="_blank">的例子。</a></p><p id="4233" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望cls-rtracer将帮助您解决请求id跟踪问题，并使诊断Node.js应用程序变得更加容易。</p><p id="edcf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我必须注意到使用异步钩子会对性能产生一定的影响。但是，对于大多数应用程序来说，这并不重要。查看<a class="ae jd" href="https://medium.com/@marek.kajda/hi-andrey-e3d04ec1a87e" rel="noopener">此评论</a>和后续(感谢<a class="nf ng ep" href="https://medium.com/u/a5985fe05072?source=post_page-----c517c7dab62d--------------------------------" rel="noopener" target="_blank">马雷克·卡伊达</a>！).</p><p id="6c74" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">P.P.S .随时请求对其他web框架的支持并报告发现的问题。</p></div></div>    
</body>
</html>