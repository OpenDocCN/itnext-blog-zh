<html>
<head>
<title>Building a Social Network: Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建立社会网络:第三部分</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-social-network-part-iii-9f9d215a624?source=collection_archive---------5-----------------------#2021-02-09">https://itnext.io/building-a-social-network-part-iii-9f9d215a624?source=collection_archive---------5-----------------------#2021-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1381" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Dart和PostgreSQL创建REST API框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/03ddd402c5f9c8fc9e8a3ff47cbaaafd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aQX33XYMR9v32WvmybE-NA.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">软件设计框图的动画插图</figcaption></figure><h2 id="5bed" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h2><p id="300d" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> T </span>本文详述了本系列的<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/building-a-social-network-part-i-25856fc693e1">第一部分</a>和<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/building-a-social-network-part-ii-1e6883ba27f6">第二部分</a>(涵盖了模式、安全性和类型定义)，创建了一个<a class="ae mw" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a> <a class="ae mw" href="https://en.wikipedia.org/wiki/Application_programming_interface" rel="noopener ugc nofollow" target="_blank"> API </a>框架，这将有助于REST端点的开发。</p><p id="fde8" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">该框架旨在减少<a class="ae mw" href="https://en.wikipedia.org/wiki/Boilerplate_code" rel="noopener ugc nofollow" target="_blank">样板代码</a>，便于维护和特性开发，并与在<a class="ae mw" href="https://en.wikipedia.org/wiki/PL/pgSQL" rel="noopener ugc nofollow" target="_blank"> PL/pgSQL </a>中开发的底层特性集成。诸如<a class="ae mw" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a> URL解析、<a class="ae mw" href="https://en.wikipedia.org/wiki/Serialization" rel="noopener ugc nofollow" target="_blank">序列化</a>和<a class="ae mw" href="https://en.wikipedia.org/wiki/Authentication" rel="noopener ugc nofollow" target="_blank">认证</a>等常见需求被构建到类中，这些类既可以被扩展以利用功能，也可以应用于其他类的方法，以使用<a class="ae mw" href="https://dart.dev/guides/language/language-tour#metadata" rel="noopener ugc nofollow" target="_blank">注释</a>来改变输入、输出或其他行为。</p><p id="b42f" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这种方法利用<a class="ae mw" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> OOP </a>、<a class="ae mw" href="https://en.wikipedia.org/wiki/Attribute-oriented_programming" rel="noopener ugc nofollow" target="_blank"> @OP </a>、<a class="ae mw" href="https://en.wikipedia.org/wiki/Metaprogramming" rel="noopener ugc nofollow" target="_blank">元编程</a>和<a class="ae mw" href="https://en.wikipedia.org/wiki/Reflective_programming" rel="noopener ugc nofollow" target="_blank">反射</a>中的概念来创建易于描述和维护的软件，并利用<a class="ae mw" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a>来确保高质量的结果。</p><p id="acc3" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">对于这个项目的源代码副本，克隆这个repo 。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="b175" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">包装定义</h2><p id="e330" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">服务器端SDK包文件为<strong class="lw iu"> api_sdk/pubspec.yaml: </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="52ce" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这个SDK使用了上一篇文章中的<code class="fe nl nm nn no b"><strong class="lw iu">core</strong> </code>，还使用了<a class="ae mw" href="https://pub.dev/packages/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>、<a class="ae mw" href="https://pub.dev/packages/jaguar_jwt" rel="noopener ugc nofollow" target="_blank"> jaguar_jwt </a>以及其他一些标准包。</p><p id="8d5a" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">SDK的组件从<strong class="lw iu"> api_sdk/api-sdk.dart </strong>中导出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="748a" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">API服务器</h2><p id="503d" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">服务API的基类在<code class="fe nl nm nn no b"><strong class="lw iu">lib/api-server.dart</strong></code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fb6f" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">这实现了一个使用API框架的基本服务器，我们将在整篇文章中研究这个框架。环境变量用于配置和初始化身份验证和数据库提供程序。请求被转发到APIService类，每十分钟调用一次刷新操作来清除超过24小时的内容。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="e720" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">API方法注释</h2><p id="0524" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">接下来让我们看看<code class="fe nl nm nn no b"><strong class="lw iu">lib/framework/api-method.dart</strong></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7160" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">当实现一个API时，这些类被用作注释:</p><ul class=""><li id="36d6" class="np nq it lw b lx mx ma my lh nr ll ns lp nt mm nu nv nw nx bi translated">使用RoutePath在服务上设置根URL</li><li id="fe47" class="np nq it lw b lx ny ma nz lh oa ll ob lp oc mm nu nv nw nx bi translated">指定<code class="fe nl nm nn no b">REST</code>和<code class="fe nl nm nn no b">WebSocket</code>端点</li><li id="18fb" class="np nq it lw b lx ny ma nz lh oa ll ob lp oc mm nu nv nw nx bi translated">在<code class="fe nl nm nn no b">REST</code>端点上使用<code class="fe nl nm nn no b">JSON</code>序列化</li></ul><p id="eb55" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">注意，<code class="fe nl nm nn no b">RoutePath</code>上提供了<code class="fe nl nm nn no b">+</code>操作符的实现，以简化URL路径的连接。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="e533" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">API路线</h2><p id="3fc5" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">内部路由处理的类在<code class="fe nl nm nn no b"><strong class="lw iu">lib/framework/api-route.dart</strong></code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2e6d" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><code class="fe nl nm nn no b">RoutePoint</code>和<code class="fe nl nm nn no b">RouteParameter</code>类扩展了<code class="fe nl nm nn no b">RouteComponent</code>来从每个方法上的REST路径构建URL解析逻辑(即<code class="fe nl nm nn no b">/users/:id</code>，其中URL中<code class="fe nl nm nn no b">:id</code>的值变成了<code class="fe nl nm nn no b">id</code>变量的值)。</p><p id="74fd" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">服务创建<code class="fe nl nm nn no b">APIRoute</code>的实例来包装用上面列出的API方法之一注释的方法——例如<code class="fe nl nm nn no b">GET</code>或<code class="fe nl nm nn no b">POST</code>——并且用每个路由的<code class="fe nl nm nn no b">check</code>函数测试传入的请求，直到找到正确的路由。一旦服务为请求找到了匹配的<code class="fe nl nm nn no b">APIRoute</code>，就使用<code class="fe nl nm nn no b">MethodMirror</code>以及方法的位置和命名参数(使用<code class="fe nl nm nn no b">_args</code>和<code class="fe nl nm nn no b">_parse</code>函数从传入的请求中提取)调用服务上相应的类方法。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="1c84" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">API服务</h2><p id="00b3" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">服务基类在<code class="fe nl nm nn no b"><strong class="lw iu">lib/framework/api-service.dart</strong></code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3d97" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">当使用这个框架实现一个API时，会为每个服务创建一个扩展<code class="fe nl nm nn no b">APIService</code>的类，包括对<code class="fe nl nm nn no b">RoutePath</code>基本URL和<code class="fe nl nm nn no b">APIRoute</code> REST谓词的注释，URL将被附加到基本URL。</p><p id="d534" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">当一个扩展了<code class="fe nl nm nn no b">APIService</code>的服务实例被创建时，反射被用来从<code class="fe nl nm nn no b">RoutePath</code>和<code class="fe nl nm nn no b">APIRoute</code> REST动词和路径中检索基本URL等信息。对于类中每个被指定为REST或WS操作的方法，都会创建一个APIRoute实例并存储在<code class="fe nl nm nn no b">_routes</code>属性中。对于传入的请求，根据URL模式检查每个路由，直到找到并调用正确的路由。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="a778" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">反射镜</h2><p id="70b4" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">位于<code class="fe nl nm nn no b"><strong class="lw iu"> lib/types/reflector.dart</strong></code>中的抽象反射器类有助于SDK对数据模型的自动序列化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f5bb" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><code class="fe nl nm nn no b">Reflector</code>包含一组实用方法，用于处理对序列化对象的检查，以及将<code class="fe nl nm nn no b">JSON</code>解码的<code class="fe nl nm nn no b">Map&lt;String, dynamic&gt;</code>对象转换为<code class="fe nl nm nn no b">T</code>类型的实例，这允许API从<code class="fe nl nm nn no b">JSON POST</code>数据创建任何<code class="fe nl nm nn no b">Serializable</code>对象的实例。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="c55d" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">认证提供者</h2><p id="e896" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">认证在<code class="fe nl nm nn no b"><strong class="lw iu">lib/services/auth-provider.dart</strong></code>内处理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5c15" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">任何用<code class="fe nl nm nn no b">Authenticate</code> decorator标注的端点都将通过标准的<code class="fe nl nm nn no b">JWT</code>认证方案得到保护。任何需要登录和认证的API都可以使用<code class="fe nl nm nn no b">AuthProvider</code>来标记一个<code class="fe nl nm nn no b">AuthenticatedUser</code>，并使用这个标记来授权后续的API调用。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="bc08" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">数据提供器</strong></h2><p id="efd7" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">数据库连接在<code class="fe nl nm nn no b"><strong class="lw iu">lib/framework/data-provider.dart</strong></code>处理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6ffd" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><code class="fe nl nm nn no b">DataProvider</code>类包装了<code class="fe nl nm nn no b">DB</code>的一个实例，该实例反过来又包装了数据库连接本身，该数据库连接是根据从控制服务器传入的环境变量配置的。提供便利的方法<code class="fe nl nm nn no b">findOne</code>是为了从预期的结果集中返回单个项目。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="2047" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">测试服务</h2><p id="e16f" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">在<code class="fe nl nm nn no b"><strong class="lw iu">lib/services/test-service.dart</strong></code>中，包含了一个示例服务来演示如何使用SDK定义REST服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8799" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><code class="fe nl nm nn no b">@RoutePath</code>注释将该服务的根URI路径定义为<code class="fe nl nm nn no b">'/'</code>，而<code class="fe nl nm nn no b">@GET</code>为每个方法定义了URI，并将用于自动连接这些端点以响应HTTP <code class="fe nl nm nn no b">GET</code>动词。<code class="fe nl nm nn no b">@JSON</code>注释指示SDK使用JSON序列化，并在响应头上设置适当的内容类型。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="ed7a" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">SDK测试基地</h2><p id="2b5b" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">SDK的测试框架内置于SDK本身，并与库的其余部分一起导出，以支持代码在后续API测试中重用。</p><p id="8d04" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">其基类可在<code class="fe nl nm nn no b"><strong class="lw iu">lib/test/sdk-test-base.dart</strong></code>中找到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="276f" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated"><code class="fe nl nm nn no b">SDKTestBase</code>类包括一些创建和启动服务器实例的方法，除此之外，测试用例将使用这些方法向服务器发出请求并验证正确的输出。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="6da6" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">测试跑步者</h2><p id="54eb" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">在<code class="fe nl nm nn no b"><strong class="lw iu">test/test-runner.dart</strong></code>中可以找到一个基本的测试实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2a18" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">测试运行人员建立一个<code class="fe nl nm nn no b">SDKTest</code>来测试配置和服务。URL解析和对象序列化等基本操作已经过验证，可以正常工作，未来使用该库构建的API将实现基于该框架构建的类似测试，从而确保连续性和可靠性。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="bffc" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h2><p id="da28" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">这个API框架将作为实现演示社交网络所需的各种API的基础，例如移动和/或web客户端、管理工具和其他服务。反射和注释的使用极大地减少了每个服务所需的样板文件，如上面的<code class="fe nl nm nn no b">TestService</code>类所示。</p><p id="c5c7" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">请继续关注第四部分，在这一部分中，我们将构建一个API来创建用户并与系统中的其他用户进行交互。</p><p id="b10c" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">感谢阅读！</p><p id="bd43" class="pw-post-body-paragraph lu lv it lw b lx mx ju lz ma my jx mc lh mz me mf ll na mh mi lp nb mk ml mm im bi translated">~ <a class="ae mw" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a></p></div></div>    
</body>
</html>