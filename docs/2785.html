<html>
<head>
<title>Demystifying React Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开React上下文的神秘面纱</h1>
<blockquote>原文：<a href="https://itnext.io/demystifying-react-context-beba679e3de1?source=collection_archive---------2-----------------------#2019-08-01">https://itnext.io/demystifying-react-context-beba679e3de1?source=collection_archive---------2-----------------------#2019-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/194ceff07d55c9d255a336559676b75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E0CdUNcaS_SsYPaa.png"/></div></div></figure><div class=""/><p id="5fd3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">昨天，我花了一些时间学习如何使用上下文，当我阅读文档时，我想，“对于做简单事情的东西来说，这听起来非常复杂”。一开始我确实有这种感觉:</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/8a9d44e94395a2345324607e8af1eaae.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/0*QrSFPEERGqMAL-tr.gif"/></div></figure><p id="e571" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在研究了代码并了解了更多使用它的不同方法之后。我想与和我有同样感受的人分享会很好。</p><h1 id="94d5" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是反应上下文？</h1><p id="c226" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在这个特性出现之前，我们必须将道具传递到每个组件中，然后在组件中一次又一次地重复同样的过程。随着时间的推移，这变得非常糟糕，最终可能会导致道具在组件中嵌套过深的问题。</p><p id="401a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React上下文是为了解决我们所有的问题而构建的，因为它消除了我们将道具传递到组件中的需要。相反，当嵌套在上下文提供者中时，组件将继承props。</p><h1 id="c6d8" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">少说话，多编码！</h1><p id="6d6d" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">现在让我们实际运行一些代码，这样我们就可以看到上下文在做什么。</p><h2 id="e54b" class="me lc jb bd ld mf mg dn lh mh mi dp ll kj mj mk lp kn ml mm lt kr mn mo lx mp bi translated">步骤1 —创建我们的上下文对象</h2><p id="975f" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我们要做的第一件事是我们需要创造我们的环境。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/c33a9105d0075cabb05a29413b3cb4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEgrjeI0OVaguHGZUgp8QQ.png"/></div></div></figure><p id="c2bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在代码中看到的，在<code class="fe mr ms mt mu b">React</code>模块上有一个名为<code class="fe mr ms mt mu b">createContext</code>的方法。现在这已经就绪，我们可以继续创建我们的提供者，或者我们可以在<code class="fe mr ms mt mu b">createContext</code>方法中设置一个<code class="fe mr ms mt mu b">defaultValue</code>作为参数。</p><p id="bd66" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有当提供者没有包装消费者时，默认值才会应用这些值。我将在<code class="fe mr ms mt mu b">defaultValue </code>部分更详细地介绍这一点。</p><h2 id="7bfd" class="me lc jb bd ld mf mg dn lh mh mi dp ll kj mj mk lp kn ml mm lt kr mn mo lx mp bi translated">步骤2 —应用提供者</h2><p id="bc71" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated"><code class="fe mr ms mt mu b">createContext</code>方法提供了使用绑定到方法的两个组件的能力，这两个组件是<code class="fe mr ms mt mu b">Provider</code> &amp; <code class="fe mr ms mt mu b">Consumer</code>。提供者是一种组件，它提供设置数据的能力，消费者组件无需传递任何属性就可以访问这些数据。</p><p id="7156" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件只带一个道具，叫做<code class="fe mr ms mt mu b">value</code>。值可以是字符串、数字或对象。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/766c056c4dda1c5b90e36fd22d4d1f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRslcG6Eyu753lsgqwnnuA.png"/></div></div></figure><h2 id="4aa1" class="me lc jb bd ld mf mg dn lh mh mi dp ll kj mj mk lp kn ml mm lt kr mn mo lx mp bi translated">步骤3 —设置消费者</h2><p id="8020" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated"><code class="fe mr ms mt mu b">Consumer</code>组件用于从<code class="fe mr ms mt mu b">Provider</code>获取数据，然后将数据传递给嵌套在<code class="fe mr ms mt mu b">Consumer</code>中的组件。有3种方法可以实现<code class="fe mr ms mt mu b">Consumer</code>。</p><p id="4586" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">方法一——使用消费者组件</strong></p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/6b25dcdab1a64307423feee37e0c7fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psxojIcORkheRxwDkB1WWw.png"/></div></div></figure><p id="7fe7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在添加了一个段落组件，其中包含了<code class="fe mr ms mt mu b">DataContext.Consumer</code>。这将返回一个函数，让我们可以访问在<code class="fe mr ms mt mu b">Provider</code>中设置的属性。这种方式对于不需要任何逻辑的组件非常有用。那么我们如何用一个有逻辑的组件来做这件事呢？</p><p id="6ab7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">方法编号2 —使用</strong> <code class="fe mr ms mt mu b">this.context</code> &amp; <code class="fe mr ms mt mu b">contextType</code></p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/22c030f389ba4fe271864b30b55606c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QohLBMU-sHrE13xBsHA-9A.png"/></div></div></figure><p id="14f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在使用类的组件中，有另一种方法可以访问上下文数据。正如你所看到的，当我们创建我们的类时，我们在它下面有了<code class="fe mr ms mt mu b">Paragraph.contextType = DataContext;</code>，它将做的是给类一个属性调用<code class="fe mr ms mt mu b">context</code>，这是我们如何访问我们的提供者传递下来的值。</p><p id="6668" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">方法3 —使用上下文方法</strong></p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/5379287c8fed85a2509fb0a4a31fbcbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZV-OcWdTObXy0wQu2JmMzQ.png"/></div></div></figure><p id="593d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的两种解决方案都可以工作，这很好，但是我们必须用两种不同的方法来让它为每个组件工作。方法用来从上下文中获取道具，方法和上面两个方法一样，但是看起来简单多了。它看起来非常类似于你从<code class="fe mr ms mt mu b">this.props</code>获得道具的方式，但是语法有点不同，因为你调用的是<code class="fe mr ms mt mu b">useContext</code>。</p><h1 id="b28d" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">等等马特，那<code class="fe mr ms mt mu b">defaultValue</code>呢？</h1><p id="727a" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">如前所述，我简要介绍了如何为我们的上下文设置默认值，如果我们没有包装组件的提供者，那么我们的消费者将使用在<code class="fe mr ms mt mu b">createContext</code>中设置的默认值作为后备。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/6fc4986d3f82ce8fa0b7a6e7dc3cb6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5VyMblFPEScv6_9JDDG2A.png"/></div></div></figure><p id="c004" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经从我们的段落中移除了<code class="fe mr ms mt mu b">Provider</code>,并在<code class="fe mr ms mt mu b">createContext </code>函数中设置了以前在value prop中的值。我花了很长时间才明白。</p><h1 id="751b" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d93d" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我希望这让每个人都更加清楚！就像我说的，我是几天前学的，所以上下文方法可能有更多的内容。我希望这已经澄清了一些关于这个话题的困惑，因为它一开始确实让我感到困惑。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/5bcddc00fe30ced0b53af7499b03a4cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*-rslossT7cZo89mU.gif"/></div></figure></div></div>    
</body>
</html>