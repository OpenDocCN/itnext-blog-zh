<html>
<head>
<title>API mocking in unit test and storybook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试和故事书中的API模拟</h1>
<blockquote>原文：<a href="https://itnext.io/api-mocking-in-unit-test-and-storybook-a0e774f7296?source=collection_archive---------1-----------------------#2021-04-29">https://itnext.io/api-mocking-in-unit-test-and-storybook-a0e774f7296?source=collection_archive---------1-----------------------#2021-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e75a3220e087889db782b8c5b51e6aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jy_jPWjkLnzOAGaf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@wocintechchat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜@ wocintechchat.com</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="77b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章探讨了API模仿的三个层次，以及我们如何让模仿在故事书和单元测试中同样有效。我也会分享我在调试为什么嘲讽<code class="fe lb lc ld le b">XMLHttpRequest</code>不起作用的过程中的学习。如果您想继续查看最佳解决方案，请检查选项三:<code class="fe lb lc ld le b">msw</code>。</p><h1 id="13c4" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么</h1><p id="77d4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在Web开发中，我们不想依赖后端API，原因有几个:</p><ul class=""><li id="7415" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">后端未准备好；</li><li id="81a7" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">加快UI开发节奏</li></ul><p id="ec20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常我们会在故事书和单元测试中模拟API响应来进行开发。故事书(<a class="ae kc" href="https://storybook.js.org/docs/react/workflows/build-pages-with-storybook#mocking-connected-components" rel="noopener ugc nofollow" target="_blank">示例</a>)和单元测试(<a class="ae kc" href="https://kentcdodds.com/blog/stop-mocking-fetch" rel="noopener ugc nofollow" target="_blank">示例</a>)的解决方案分别存在。我的目标是有一个一致的API来模拟故事书和单元测试，并在测试中重用故事书故事。</p><h1 id="4d27" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">选项一:模仿XMLHttpRequest</h1><p id="10fd" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我的项目使用<code class="fe lb lc ld le b">superagent</code>作为API客户端，它在幕后使用<code class="fe lb lc ld le b">XMLHttpRequest</code>。我从用<a class="ae kc" href="https://www.npmjs.com/package/xhr-mock" rel="noopener ugc nofollow" target="_blank"> xhr-mock </a>嘲讽出<code class="fe lb lc ld le b">XMLHttpRequest</code>开始(或者你也可以<a class="ae kc" href="https://stackoverflow.com/questions/28584773/xmlhttprequest-testing-in-jest" rel="noopener ugc nofollow" target="_blank">不借助第三方库</a>嘲讽)。我创建了一个React组件包装</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9df9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在故事书里使用它</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5eef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一件很酷的事情是我们可以在测试中导入这个故事</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="8d41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<strong class="kf ir">我们只定义了一次服务器模拟响应<em class="mw"/>，并在测试</strong>中重用它们。本质上，我们在各种场景中为组件创建故事(作为可视化测试)，并以编程方式对每个故事进行单元测试。很酷，不是吗？</p><p id="7f78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…直到测试真正中断</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3742" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个错误表明我们的单元测试仍然试图发出一个真实的http请求，即使我们使用了mock。到底怎么回事？</p><p id="2350" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原来<code class="fe lb lc ld le b">superagent</code>在浏览器中使用<code class="fe lb lc ld le b">XMLHttpRequest</code>，在nodejs环境中使用<code class="fe lb lc ld le b">node:http</code>。在<code class="fe lb lc ld le b">superagent</code> package.json中，你可以看到浏览器和nodejs加载了不同的文件。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f8ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不仅<code class="fe lb lc ld le b">superagent</code>而且其他API客户端(例如<code class="fe lb lc ld le b">axios</code>)也做同样的事情。原因是<code class="fe lb lc ld le b">XMLHttpRequest</code>是一个浏览器对象(通过<code class="fe lb lc ld le b">window.XMLHttpRequest</code>访问)。它不是nodejs中的对象；相反，nodejs使用<code class="fe lb lc ld le b">node:http</code>进行API请求。</p><p id="1534" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在应该可以理解为什么我们的测试失败并带有<code class="fe lb lc ld le b">XMLHttpRequest</code>嘲讽了:单元测试在nodejs环境中运行，而<code class="fe lb lc ld le b">superagent</code>根本没有调用<code class="fe lb lc ld le b">XMLHttpRequest</code>！</p><h1 id="426d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">选项二:模仿超级代理</h1><p id="a1a7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">第二种选择是在更高的层次上进行模拟:我们的API客户端(在我的例子中是<code class="fe lb lc ld le b">superagent</code>，对于<code class="fe lb lc ld le b">axios</code>或其他的例子也是如此)。与<code class="fe lb lc ld le b">xhr-mock</code>类似，人们为嘲讽<code class="fe lb lc ld le b">superagent</code>做了库(如<a class="ae kc" href="https://www.npmjs.com/package/superagent-mock" rel="noopener ugc nofollow" target="_blank"> superagent-mock </a>)。让我们替换我们的React包装器:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e49c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似地，我们可以在组件故事中使用这个包装器来模拟服务器响应，并在单元测试中重用它。这对两者都适用🎉</p><p id="4e76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但还可以更好。</p><h1 id="8843" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">方案三:都市固体废物</h1><p id="bd75" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">msw 在不创建服务器的情况下提供了最高级别的模拟。这个想法是<strong class="kf ir">使用服务工作者来<em class="mw">拦截</em>所有请求，我们可以决定如何处理每个请求</strong>。这个解决方案更好，因为</p><ul class=""><li id="3f5c" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">真正的http请求正在发生。这意味着您可以在浏览器的<code class="fe lb lc ld le b">network</code>选项卡中看到网络呼叫。这与模仿API客户端形成了对比:没有进行网络调用，这可能会使开发人员感到困惑，并误导他们相信组件本身没有发出任何请求。</li><li id="b1db" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">更接近真实的用户体验。API客户端的工作方式与生产环境中的相同。它带来了更多的信心，事情真的在工作。</li><li id="f54d" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">您可以在处理请求时进行类似的服务器检查，例如</li></ul><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4d1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个挑战是<code class="fe lb lc ld le b">msw</code>为浏览器和nodejs使用稍微不同的API。让我们创建一个React包装器来提供一致的API:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="21b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">msw对浏览器使用service worker，对nodejs使用monkey补丁<code class="fe lb lc ld le b">http:node</code>。React包装器使用适当的msw集成来返回模拟响应，而不管运行环境如何。现在你可以在故事书和单元测试中重用你的嘲讽，就像选项一中描述的那样。</p><p id="2d76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一点关于<code class="fe lb lc ld le b">msw</code>的设置:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f10c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在单元测试设置中(<code class="fe lb lc ld le b">setupFilesAfterEnv</code>用于jest)</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0589" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">.storybook/preview.js</code>中，启动服务人员</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7964" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，使用msw cli创建一个服务工作者脚本</p><p id="f45e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">$ npx msw init public</code></p><p id="7291" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将在<code class="fe lb lc ld le b">public</code>文件夹中生成一个脚本(服务工人拦截实现)。我们应该将这个文件包含在Git中，并用它开始storybook:</p><p id="07b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">$ start-storybook -s public</code></p><p id="0b6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你可以走了！</p><h1 id="c50e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="2369" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">这篇文章描述了模仿API的三个选项，从低级到高级。我建议高水平嘲讽，以获得最接近的生产经验。另外，在故事书和单元测试之间重用代码是对开发人员体验的真正提升！</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="9cc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">请给出你最大的声音👏(s)如果你觉得这个帖子有帮助，就关注我的</em> <a class="ae kc" href="https://twitter.com/imDongCHEN" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> twitter </em> </a> <em class="mw">！</em></p></div></div>    
</body>
</html>