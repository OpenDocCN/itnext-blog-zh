# 坚实的原则:解释和例子

> 原文：<https://itnext.io/solid-principles-explanation-and-examples-715b975dcad4?source=collection_archive---------0----------------------->

![](img/8505b45ec53b7b58b78ad3f74b011bd9.png)

**固体**是进行 OOP(面向对象编程)时 5 个重要设计原则的首字母缩写。

这 5 条原则是罗伯特·c·马丁(鲍勃大叔)在他 2000 年的论文 [*设计原则和设计模式*](https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf) *中介绍的。然而，真正的首字母缩略词是后来由迈克尔·费哲发现的。*

这些原则的目的是使软件设计更容易理解，更容易维护，更容易扩展。作为一名软件工程师，这 5 条原则是必须知道的！

在本文中，我将介绍这些原则，举例说明它们是如何被违反的，以及如何纠正它们以符合 **SOLID** 。
c#中会给出例子，但是适用于任何 OOP 语言。

# s——单一责任原则

在编程中，[单一责任原则](https://en.wikipedia.org/wiki/Single_responsibility_principle)规定每个模块或类都应该对软件提供的功能的单一部分负责。

你可能听过这句名言:“*做一件事，把它做好*”。
这是指单一责任原则。
在文章*面向对象设计的原则中，* Robert C. Martin 将责任定义为“改变的原因”，并得出结论，一个类或模块应该有且只有一个改变的原因。

让我们做一个例子，看看如何写一段违反这个原则的代码。

我们注意到`CreatePost()`方法有太多的责任，因为它既可以创建一个新的 post，在数据库中记录一个错误，又可以在本地文件中记录一个错误。这违反了单一责任原则。

让我们试着改正它。

通过抽象处理错误日志的功能，我们不再违反单一责任原则。现在我们有两个类，每个类有一个职责；分别创建帖子和记录错误。

# O —开启/关闭原则

在编程中，[开/关原则](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)规定软件实体(类、模块、函数等。)应该对扩展开放，但对修改关闭。

如果你对 OOP 有一个大致的了解，你可能已经知道了多态性。我们可以通过利用继承和/或实现接口来确保我们的代码符合开放/封闭原则，这些接口使类能够多态地相互替换。

这听起来可能令人困惑，所以让我们做一个例子，将非常清楚我的意思。

在这段代码中，每当帖子以字符' # '开头时，我们都需要做一些特定的事情。
然而，上面的实现违反了开放/封闭原则，因为这段代码不同于起始字母上的行为。
如果我们后来想包含以“@”开头的提及，我们必须在`CreatePost()`方法中用额外的‘else If’来修改这个类。

让我们通过简单地使用继承来尝试使这个代码符合开放/封闭原则。

通过使用继承，现在更容易通过覆盖`CreatePost()`方法来创建 Post 对象的扩展行为。
对第一个字符' # '的评估现在将在我们软件的其他地方(可能在更高的层次上)处理，最酷的事情是，如果我们想改变 postMessage 的评估方式，我们可以在那里改变代码，而不会影响这些底层的行为。

# 李斯科夫替代原理

这一条可能是第一次被介绍时最难理解的一条。

在编程中， [Liskov 替换原则](https://en.wikipedia.org/wiki/Liskov_substitution_principle)规定，如果 ***S*** 是 ***T*** 的子类型，那么 ***T*** 类型的对象可以被 ***S*** 类型的对象替换(或替代)。这可以用数学公式表示为

*设****【ϕ(x】****是关于类型***的对象* ***x*** *的一个性质可证。
那么****【ϕ(y】****对于类型****y****s**，其中* ***S*** *是****t*的一个子类型*****

*更一般地说，它认为程序中的对象应该可以用其子类型的实例来替换，而不改变程序的正确性。*

*让我们来看一个如何违反这一原则的例子*

*观察在子类型`MentionPost`的情况下`CreatePost()`的调用如何不做它应该做的事情；通知用户并覆盖现有提及。
因为`CreatePost()`方法在`MentionPost`中没有被覆盖，所以`CreatePost()`调用将简单地在类层次结构中向上委托，并从其父类调用`CreatePost()`。*

*让我们纠正这一点*

*通过重构`MentionPost`类，我们覆盖了`CreatePost()`方法，而不是在它的基类上调用它，我们不再违反 Liskov 替换原则。*

*这只是如何纠正违反这一原则的一个简单例子，然而，这种情况可能以各种各样的方式出现，并不总是容易识别。*

# *I——界面分离原则*

*这个原则相当容易理解。事实上，如果你习惯于使用接口，很可能你已经在应用这个原则了。
如果没有，是时候开始做了！*

*在编程中，[接口分离原则](https://en.wikipedia.org/wiki/Interface_segregation_principle)声明，不应该强迫任何客户端依赖它不使用的方法。
更简单地说:不要通过添加新方法来给现有的接口添加额外的功能。相反，创建一个新的接口，如果需要的话，让你的类实现多个接口。*

*让我们看一个如何违反接口隔离原则的例子。*

*在这个例子中，假设我首先有一个带有`CreatePost()`方法签名的`IPost`接口。
后来，我通过添加一个新方法`ReadPost()`来修改这个接口，所以它变得像`IPostNew`接口。*

*这就是我们违反接口分离原则的地方。相反，只需创建一个新界面。*

*如果任何一个类可能同时需要`CreatePost()`和`ReadPost()`方法，它将实现这两个接口。*

# *D -依赖倒置原理*

*最后，我们到了 D，5 个原则中的最后一个。*

*在编程中，[依赖倒置原则](https://en.wikipedia.org/wiki/Dependency_inversion_principle)是一种解耦软件模块的方法。这一原则表明*

*   *高层模块不应该依赖低层模块。两者都应该依赖于抽象。*
*   *抽象不应该依赖于细节。细节应该依赖于抽象。*

*为了遵守这个原则，我们需要使用一种被称为*依赖倒置模式*的设计模式，通常通过使用 [*依赖注入*](https://en.wikipedia.org/wiki/Dependency_injection) *来解决。依赖注入是一个巨大的话题，可以是复杂的，也可以是简单的。**

*通常，依赖注入只是通过类的构造函数作为输入参数“注入”类的任何依赖来使用。*

*让我们看一个例子。*

*观察我们如何从`Post`类中创建`ErrorLogger`实例。
这违反了依赖倒置原则。
如果我们想使用不同种类的日志记录器，我们必须修改 Post 类。*

*让我们通过使用依赖注入来解决这个问题。*

*通过使用依赖注入，我们不再依赖`Post`类来定义特定类型的记录器。*

# *结论*

*通过应用使**成为可靠的**首字母缩略词的这 5 个原则，我们可以从可重用、可维护、可扩展和易测试的代码库中获益。
这是全球专业软件工程师使用的 5 个基本原则，如果你真的想创建“可靠”的软件，你应该从今天开始应用这些原则！*

***就是这样！
如果您有任何问题或反馈，请随时在下方评论。***