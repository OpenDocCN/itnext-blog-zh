<html>
<head>
<title>Kotlin: Constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林:构造函数</h1>
<blockquote>原文：<a href="https://itnext.io/kotlin-constructors-6233e810a5bd?source=collection_archive---------2-----------------------#2019-08-20">https://itnext.io/kotlin-constructors-6233e810a5bd?source=collection_archive---------2-----------------------#2019-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4ba1" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">通过实例学习</h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/52ba5f4a2157e3e489fc9ecdf17f6cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tHuRdM1CZ77CINCQ"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">兰迪·法特在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="f0e2" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">像许多其他使用Android的开发人员一样，我开始用Java编写应用程序，后来随着它被Google和Android开发人员社区更广泛地接受，我转移到了Kotlin。</p><p id="99e8" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当从Java过渡到Kotlin时，我遇到的第一个差异是构造函数的定义方式。</p><p id="b8a7" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在Java中，你有零个或多个显式定义的构造函数。如果没有定义构造函数，则会为您创建一个默认的无参数构造函数。构造函数在Java类的主体中定义，每个定义的构造函数都通过重载其参数列表来与其他构造函数区分开来。</p><p id="d170" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">相反，在Kotlin中，你有所谓的主构造函数，它可以在类的签名中随意定义。除了主构造函数之外，您还可以定义零个或多个辅助构造函数。</p><p id="ba82" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面是Kotlin中一个简单的主构造函数的例子:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="bfd4" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls jd">class </strong>Dog <strong class="ls jd">constructor</strong>(<strong class="ls jd">val name</strong>: String) {}</span></pre><p id="7f80" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里有几件事需要注意:</p><ul class=""><li id="5a73" class="mc md it kr b ks kt kw kx la me le mf li mg lm mh mi mj mk bi translated">在定义主体之前，<strong class="kr jd">构造函数</strong> <em class="ml"> </em>关键字的使用以及它如何出现在类的签名中。这个关键字在这个例子中是可选的，只有在使用注释(如<code class="fe mm mn mo ls b">@Inject</code>)或可见性修饰符(如使构造函数私有)时才需要</li><li id="02d1" class="mc md it kr b ks mp kw mq la mr le ms li mt lm mh mi mj mk bi translated">主构造函数不能包含任何代码。通常出现在该构造函数中的初始化代码应该驻留在一个或多个初始化(<strong class="kr jd"> init </strong>)块中。</li></ul><p id="9051" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果提供了这些信息，上面的例子可以重写以省略<strong class="kr jd">构造函数</strong>关键字，结果将是相同的:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="b869" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls jd">class </strong>Dog (<strong class="ls jd">val name</strong>: String)</span></pre><p id="67bf" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">主构造函数的一个例子是一个你不希望从类代码之外实例化的类，其中<strong class="kr jd">构造函数</strong>关键字确实是必需的。例如，您可能希望从工厂方法中创建<strong class="kr jd"> Dog </strong>类的所有新实例:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="16a3" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls jd">class </strong>Dog <strong class="ls jd">private constructor</strong>(<strong class="ls jd">val name</strong>: String) {<br/><br/>    <strong class="ls jd">companion object </strong>{<br/>        <strong class="ls jd">fun </strong>newDog(name: String) = Dog(name)<br/>    }<br/>}</span></pre><p id="0b42" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">与Java相比，Kotlin中构造函数工作方式的另一个区别是它们是如何被调用的，换句话说就是如何创建新的实例。在Kotlin中没有新的关键字。相反，类的新实例也同样被创建:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="f1d0" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls jd">val dog01 </strong>= Dog(name = <strong class="ls jd">"Sparky"</strong>)</span></pre><p id="a59d" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在Kotlin中，如果您没有显式定义主构造函数，那么将会为您创建一个。例如，下面的代码是完全可以接受的:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="995a" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls jd">class </strong>EmptyDog</span></pre><p id="2b1e" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通过调用生成的无参数主构造函数，可以创建<strong class="kr jd"> EmptyDog </strong>的新实例，如下所示:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="bf99" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls jd">val emptyDog </strong>= EmptyDog()</span></pre><p id="5a80" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果您希望在实例化您的类时运行某种初始化类型的代码，那么您可以使用一个或多个初始化块来实现这一点:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="0efa" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls jd">class </strong>Dog <strong class="ls jd">constructor</strong>(<strong class="ls jd">val name</strong>: String) {<br/><br/>    <strong class="ls jd">init </strong>{<br/>        <em class="ml">println</em>(<strong class="ls jd">"Registering $name with the AKC"</strong>)<br/>        registerDogWithAKC()<br/>    }<br/><br/>    <strong class="ls jd">private fun </strong>registerDogWithAKC() {<br/>        <em class="ml">// TODO: perform registration tasks<br/>    </em>}<br/>}</span></pre><p id="7618" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">关于初始化块的一些快速注释:</p><ul class=""><li id="e786" class="mc md it kr b ks kt kw kx la me le mf li mg lm mh mi mj mk bi translated">初始化块与主构造函数相关联</li><li id="1d35" class="mc md it kr b ks mp kw mq la mr le ms li mt lm mh mi mj mk bi translated">无论是否显式定义主构造函数，每个定义的初始化块都将在类被实例化时运行</li><li id="b5ab" class="mc md it kr b ks mp kw mq la mr le ms li mt lm mh mi mj mk bi translated">如果定义了一个以上的初始化块，那么它们将按照在类体中出现的顺序执行</li><li id="dafa" class="mc md it kr b ks mp kw mq la mr le ms li mt lm mh mi mj mk bi translated">出现在主构造函数中的字段可以从初始化块中引用(在上面的例子中，可以看到初始化块中引用了<strong class="kr jd"> name </strong>字段)</li><li id="0c0a" class="mc md it kr b ks mp kw mq la mr le ms li mt lm mh mi mj mk bi translated">如果已经定义了任何二级构造函数，那么请注意，所定义的初始化块将在任何二级构造函数体执行之前执行</li></ul><p id="875d" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">说到二级构造函数，现在来说说那些:)</p><p id="a2bb" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">由于Java中缺少默认参数，你会经常看到一种被称为<em class="ml">伸缩构造函数</em>的反模式，其中构造函数被一次又一次地重载，在编辑器或类图中给它一种伸缩的外观。下面是这种反模式的一个简短示例:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="43df" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls jd">private </strong>String <strong class="ls jd">name</strong>;<br/><strong class="ls jd">private </strong>String <strong class="ls jd">breed</strong>;<br/><strong class="ls jd">private boolean registered</strong>;<br/><br/><strong class="ls jd">public </strong>Dog() {<br/>    <strong class="ls jd">this</strong>(<strong class="ls jd">"Scruffy"</strong>);<br/>}<br/><strong class="ls jd">public </strong>Dog(String name) {<br/>    <strong class="ls jd">this</strong>(name, <strong class="ls jd">"Terrier"</strong>);<br/>}<br/><strong class="ls jd">public </strong>Dog(String name, String breed) {<br/>    <strong class="ls jd">this</strong>(name, breed, <strong class="ls jd">false</strong>);<br/>}<br/><strong class="ls jd">public </strong>Dog(String name, String breed, <strong class="ls jd">boolean </strong>registered) {<br/>    <strong class="ls jd">this</strong>.<strong class="ls jd">name </strong>= name;<br/>    <strong class="ls jd">this</strong>.<strong class="ls jd">breed </strong>= breed;<br/>    <strong class="ls jd">this</strong>.<strong class="ls jd">registered </strong>= registered;<br/>}</span></pre><p id="4085" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这种反模式可以通过使用<a class="ae ko" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">构建器模式</a>来避免，但是在Kotlin中这几乎是不必要的，因为使用Kotlin您可以声明构造器参数的默认值:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="9733" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls jd">class </strong>Dog (<strong class="ls jd">val name</strong>: String, <br/>           <strong class="ls jd">val breed</strong>: String = <strong class="ls jd">"Terrier"</strong>, <br/>           <strong class="ls jd">val registered</strong>: Boolean = <strong class="ls jd">false</strong>)</span></pre><p id="70ab" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">尽管如此，在很多情况下，您可能会发现需要定义第二个(或第二个)构造函数。</p><p id="f026" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，假设一个复制构造函数将现有的<strong class="kr jd"> Dog </strong>实例的值复制到一个新的<strong class="kr jd"> Dog </strong>实例中:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="e2fe" class="lw lx it ls b gy ly lz l ma mb"><strong class="ls jd">class </strong>Dog (<strong class="ls jd">val name</strong>: String) {<br/>    <strong class="ls jd">constructor</strong>(dog: Dog) : <strong class="ls jd">this</strong>(dog.<strong class="ls jd">name</strong>)<br/>}<br/><br/><strong class="ls jd">val dog01 </strong>= Dog(name = <strong class="ls jd">"Sparky"</strong>)<br/><strong class="ls jd">val dog02 </strong>= Dog(<strong class="ls jd">dog01</strong>)</span></pre><p id="266b" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">关于二级构造函数的几点注意事项:</p><ul class=""><li id="7988" class="mc md it kr b ks kt kw kx la me le mf li mg lm mh mi mj mk bi translated">它们必须以关键字<strong class="kr jd">构造函数</strong>为前缀</li><li id="18ff" class="mc md it kr b ks mp kw mq la mr le ms li mt lm mh mi mj mk bi translated">它们必须直接调用主构造函数，或者通过另一个辅助构造函数间接调用。如上例所示，调用主构造函数是用<strong class="kr jd"> this </strong>关键字完成的。</li><li id="2d0d" class="mc md it kr b ks mp kw mq la mr le ms li mt lm mh mi mj mk bi translated">初始值设定项块总是在任何二级构造函数体之前执行</li><li id="0203" class="mc md it kr b ks mp kw mq la mr le ms li mt lm mh mi mj mk bi translated">次级构造函数中指定的参数不会成为该类的属性或字段。它们不能以<strong class="kr jd"> var </strong>或<strong class="kr jd"> val为前缀。</strong>换句话说，你需要将那些传入的值赋给字段，或者在二级构造函数体中对它们做些什么。</li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="e172" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jd">结论<br/> </strong>如果你来自Java背景，那么你可能会发现Kotlin中的构造函数一开始可能会令人生畏。希望这篇文章能帮助你走出学习曲线。一如既往，如果你想了解更多，请查看官方Kotlin文档并练习、练习、再练习。</p><p id="6492" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">编码快乐！托马斯·桑德兰</p><div class="nb nc gp gr nd ne"><a href="https://www.linkedin.com/in/thomas-sunderland/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">托马斯·桑德兰-安卓开发者| LinkedIn</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">加入LinkedIn我叫Thomas Sunderland，是一名软件工程师，专注于原生Android开发。我…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">www.linkedin.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ki ne"/></div></div></a></div></div></div>    
</body>
</html>