<html>
<head>
<title>2nd gen Cloud Functions Local Testing &amp; Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第二代云功能本地测试和开发</h1>
<blockquote>原文：<a href="https://itnext.io/2nd-gen-cloud-functions-local-testing-development-7c518f7bd0b1?source=collection_archive---------0-----------------------#2022-03-25">https://itnext.io/2nd-gen-cloud-functions-local-testing-development-7c518f7bd0b1?source=collection_archive---------0-----------------------#2022-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/3c69bf3bc8750df01661a4669a979b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*NR-aMClrHABrLQOWgj9q5Q.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">Nx WorkSpace + GCP云功能(第二代)</figcaption></figure><blockquote class="kb kc kd"><p id="e861" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:第二代包含在谷歌云服务条款的<a class="ae ld" href="https://cloud.google.com/terms/service-terms#1" rel="noopener ugc nofollow" target="_blank">预发布条款</a>中。请避免在产品中使用它，直到它完全发布。</p></blockquote><p id="7082" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/deploy-2nd-gen-gcp-cloud-functions-with-nx-workspace-5d75fcf21566">快速浏览:部署第二代GCP云函数与Nx Workspace</a><strong class="kh iu"><br/></strong><a class="ae ld" href="https://dalenguyen.medium.com/2nd-gen-cloud-functions-local-testing-development-7c518f7bd0b1" rel="noopener"><strong class="kh iu">云函数本地测试&amp;开发</strong> </a> <strong class="kh iu"> <br/> </strong> <a class="ae ld" href="https://dalenguyen.medium.com/create-rest-apis-with-express-2nd-gen-gcp-cloud-functions-d244dd9a4717" rel="noopener">创建REST APIs与Express &amp;第二代GCP云函数</a> <br/> <a class="ae ld" href="https://dalenguyen.medium.com/a-perfect-match-nestjs-cloud-functions-2nd-gen-nx-workspace-f13fb044e9a4" rel="noopener">完美匹配:NestJs &amp;云函数(第二代)&amp;Nx Workspace</a><br/><a class="ae ld" href="https://dalenguyen.medium.com/gcp-cloud-functions-gen-2nd-pub-sub-development-testing-2c498fa4464e" rel="noopener">GCP云函数(第二代)发布/订阅</a></p><p id="17bb" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在之前的<a class="ae ld" href="https://medium.com/p/5d75fcf21566" rel="noopener">快速浏览</a>中，我向您介绍了如何使用Nx WorkSpace创建&amp;部署第二代云功能。在本文中，我将发现如何进行本地开发&amp;测试第二代云功能。请注意，这只是我在Nx WorkSpace中如何做的实验。</p><p id="e326" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在<a class="ae ld" href="https://github.com/GoogleCloudPlatform/functions-framework-nodejs#configure-the-functions-framework" rel="noopener ugc nofollow" target="_blank">官方文档</a>中，我们有一个本地提供云功能的脚本。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="9417" class="lq lr it lm b gy ls lt l lu lv">"scripts": {<br/>    "start": "functions-framework --target=helloWorld"<br/> }</span></pre><p id="4a27" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">它将在端口8080上查找<code class="fe lw lx ly lm b">index.js</code>文件&amp;服务本地函数。它在TypeScript项目中不能很好地工作。让我们对脚本进行一些修改，以便在Nx WorkSpace中支持第二代云函数的本地开发。</p><p id="52ab" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这是一个简单的入门功能。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="214e" class="lq lr it lm b gy ls lt l lu lv">// main.ts</span><span id="5f6c" class="lq lr it lm b gy lz lt l lu lv">import { http } from '<a class="ae ld" href="http://twitter.com/google" rel="noopener ugc nofollow" target="_blank">@google</a>-cloud/functions-framework'<br/>import 'tslib' // needed until importHelpers is set to false</span><span id="a5a1" class="lq lr it lm b gy lz lt l lu lv">http('helloGET', (req, res) =&gt; {<br/>  res.send(`Hello ${req.query.name || req.body.name || 'World'}!`)<br/>})</span></pre><p id="4f09" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><strong class="kh iu">观看&amp;本地提供云功能</strong></p><p id="793f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们的目标是在本地提供云功能&amp;每次更新文件时都要注意变化。</p><p id="d27e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我将使用<a class="ae ld" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank"> nodemon </a>来监控更改&amp;重新运行脚本。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="00e9" class="lq lr it lm b gy ls lt l lu lv">yarn add -D nodemon</span></pre><p id="a9dc" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">然后，我将向package.json添加一些自定义脚本</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="d05b" class="lq lr it lm b gy ls lt l lu lv">"watch:scraper": "nodemon --watch ./dist/apps/scraper --exec yarn serve:scraper",</span><span id="0ef7" class="lq lr it lm b gy lz lt l lu lv">"serve:scraper": "functions-framework --target=helloGET --source ./dist/apps/scraper/",</span></pre><p id="2675" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这个脚本的作用是观察<code class="fe lw lx ly lm b">./dist/apps/scraper</code>文件夹下的变化，然后执行<code class="fe lw lx ly lm b">yarn serve:scraper</code>命令。</p><p id="153c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">然后，当您在另一个终端中使用Nx命令查看构建时</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="4289" class="lq lr it lm b gy ls lt l lu lv">yarn build scraper --watch</span></pre><p id="f5b0" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">现在您有了一个可以观察文件变化的环境&amp;动态地服务它们。</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ma"><img src="../Images/9356d00a88c859ad9c675c32fc3562f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GpRw8exHkDebJgUrKb-PJQ.png"/></div></div></figure><p id="f535" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在这个阶段，您要么使用Postman，要么在浏览器上测试HTTP功能，而不需要每次做一些更改时都重新运行脚本。</p><p id="f231" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">额外收获:如果你更新了你的<code class="fe lw lx ly lm b">serve</code>目标，那么在调试你的代码时，你会有一个更好的命令。之后，您可以运行<code class="fe lw lx ly lm b">npx run sraper serve</code>，而不是向package.json添加定制命令。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="307f" class="lq lr it lm b gy ls lt l lu lv">// project.json</span><span id="7875" class="lq lr it lm b gy lz lt l lu lv">"serve": {<br/>    "executor": "<a class="ae ld" href="http://twitter.com/nrwl/workspace" rel="noopener ugc nofollow" target="_blank">@nrwl/workspace</a>:run-commands",<br/>    "options": {<br/>      "buildTarget": "scraper:build",<br/>      "commands": [<br/>        {<br/>          "command": "nodemon --watch ./dist/apps/scraper --exec functions-framework --target=helloGET --source ./dist/apps/scraper/"<br/>        }<br/>      ]<br/>    }<br/> },</span></pre><p id="fb8d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><strong class="kh iu">利用单元测试</strong></p><p id="5ea6" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">本地开发和测试的另一种方法是利用单元测试。Nx为使用Jest进行测试提供了一个非常好的结构。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="f565" class="lq lr it lm b gy ls lt l lu lv">// main.spec.ts</span><span id="8087" class="lq lr it lm b gy lz lt l lu lv">import { getFunction } from '<a class="ae ld" href="http://twitter.com/google" rel="noopener ugc nofollow" target="_blank">@google</a>-cloud/functions-framework/build/src/testing'</span><span id="a45e" class="lq lr it lm b gy lz lt l lu lv">describe('Hello Tests', () =&gt; {<br/>  beforeAll(async () =&gt; {<br/>    // load the module and get the function<br/>    await import('./main')<br/>  })</span><span id="fd6f" class="lq lr it lm b gy lz lt l lu lv">it('test helloGET', () =&gt; {<br/>    // call the function<br/>    const helloGET = getFunction('helloGET')</span><span id="2544" class="lq lr it lm b gy lz lt l lu lv">   const req = {<br/>      query: {<br/>        name: 'Dale',<br/>      },<br/>    } as any</span><span id="4bf0" class="lq lr it lm b gy lz lt l lu lv">    let result<br/>    const res = {<br/>      send: (x) =&gt; {<br/>        result = x<br/>      },<br/>    } as any</span><span id="d478" class="lq lr it lm b gy lz lt l lu lv">    // invoke the function<br/>    helloGET(req, res, () =&gt; {})</span><span id="0eb5" class="lq lr it lm b gy lz lt l lu lv">    // check the response<br/>    expect(result).toEqual('Hello Dale!')<br/>  })<br/>})</span></pre><p id="2d3e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果你在测试脚本的末尾添加<code class="fe lw lx ly lm b">--watch</code>。每次更新代码时，测试都会重新运行。</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/43a071a3f5b049fd96583c85a8510425.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*ShcHj-92qK82kwmDJte91g.png"/></div></figure></div></div>    
</body>
</html>