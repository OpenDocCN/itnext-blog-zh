<html>
<head>
<title>Deploying a Rails App to ECS with an Nginx Sidecar Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nginx Sidecar容器将Rails应用程序部署到ECS</h1>
<blockquote>原文：<a href="https://itnext.io/deploying-a-rails-app-with-an-nginx-sidecar-container-to-ecs-cbc3b0a2c690?source=collection_archive---------1-----------------------#2019-04-05">https://itnext.io/deploying-a-rails-app-with-an-nginx-sidecar-container-to-ecs-cbc3b0a2c690?source=collection_archive---------1-----------------------#2019-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c247c90f26613de8b484b0f9380c52dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ZxRsoCfJyv-O1Y4JAPraA.png"/></div></div></figure><p id="4900" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的任务是为ECS部署一个rails应用程序，itnext.io上的这篇文章让我完成了80%。</p><p id="c9a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想我会分享我用nginx sidecar在ECS上运行这个rails应用程序的最后步骤。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="ec41" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">(一些)差异</h1><p id="32ae" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">我没有使用Docker Compose。Docker Compose不能很好地与ECS一起运行，至少不能以我使用它的方式运行。</p><p id="bc0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">NGINX和我的Rails应用程序从一个共享目录加载文件需要卷。</p><h2 id="9362" class="mk li it bd lj ml mm dn ln mn mo dp lr km mp mq lv kq mr ms lz ku mt mu md mv bi translated">Rails应用程序设置</h2><p id="a7ec" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">首先，向rails应用程序添加一个docker文件。这里有一个例子:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="f446" class="mk li it nb b gy nf ng l nh ni">FROM ruby:2.6.1-alpine</span><span id="795d" class="mk li it nb b gy nj ng l nh ni">RUN apk add --update \<br/>    make \<br/>    g++ \<br/>    musl-dev \<br/>    gcc \<br/>    libc-dev \<br/>    file \<br/>    git \<br/>    postgresql-dev \<br/>    tzdata</span><span id="e31e" class="mk li it nb b gy nj ng l nh ni">#Install rails_application</span><span id="0904" class="mk li it nb b gy nj ng l nh ni">ENV APPLICATION_NAME rails_application</span><span id="b543" class="mk li it nb b gy nj ng l nh ni">RUN mkdir -p /var/www/rails_application</span><span id="e661" class="mk li it nb b gy nj ng l nh ni">WORKDIR /var/www/rails_application</span><span id="4750" class="mk li it nb b gy nj ng l nh ni">COPY Gemfile Gemfile.lock /var/www/rails_application/</span><span id="52bc" class="mk li it nb b gy nj ng l nh ni">RUN gem install bundler</span><span id="56f6" class="mk li it nb b gy nj ng l nh ni">RUN bundle install</span><span id="0db9" class="mk li it nb b gy nj ng l nh ni">COPY . .</span><span id="9d86" class="mk li it nb b gy nj ng l nh ni">VOLUME /var/www/rails_application/</span><span id="f743" class="mk li it nb b gy nj ng l nh ni">VOLUME /etc/nginx/</span><span id="47ec" class="mk li it nb b gy nj ng l nh ni">RUN apk del make \<br/>    g++ \<br/>    musl-dev \<br/>    gcc \<br/>    libc-dev \<br/>    file \<br/>    git</span><span id="ca7e" class="mk li it nb b gy nj ng l nh ni">EXPOSE 8080</span><span id="6398" class="mk li it nb b gy nj ng l nh ni">RUN chmod +x app_start.sh</span><span id="6d0b" class="mk li it nb b gy nj ng l nh ni">ENTRYPOINT ["sh", "app_start.sh"]</span></pre><p id="c54c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用了alpine并移除了编译器以节省空间。此外，您会注意到我使用了一个shell脚本来启动应用程序——稍后会详细介绍。</p><h2 id="0d16" class="mk li it bd lj ml mm dn ln mn mo dp lr km mp mq lv kq mr ms lz ku mt mu md mv bi translated">NGINX设置</h2><p id="b2c6" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">我在一个单独的repo中设置了我的nginx sidecar应用程序。nginx repo的文件结构如下所示:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="8a8c" class="mk li it nb b gy nf ng l nh ni">-rails_application-nginx<br/>    -dockerfile<br/>    -nginx.conf<br/>    -nginx (directory)<br/>        -application.conf</span></pre><p id="4b04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我的nginx dockerfile文件的样子:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d93e" class="mk li it nb b gy nf ng l nh ni"># Base image<br/>FROM nginx</span><span id="adbb" class="mk li it nb b gy nj ng l nh ni">RUN apt-get update -qq &amp;&amp; apt-get -y install apache2-utils &amp;&amp; apt-get install -y vim</span><span id="3990" class="mk li it nb b gy nj ng l nh ni"># Copy Nginx config template<br/>COPY nginx/application.conf /etc/nginx/conf.d/default.conf<br/>VOLUME /var/www/rails_application/<br/></span></pre><p id="b31d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是nginx.conf:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="5bbf" class="mk li it nb b gy nf ng l nh ni">worker_processes  auto;</span><span id="f915" class="mk li it nb b gy nj ng l nh ni">error_log  /var/log/nginx/error.log warn;<br/>pid        /var/run/nginx.pid;</span><span id="511a" class="mk li it nb b gy nj ng l nh ni">events {<br/>    worker_connections  1024;<br/>}</span><span id="a709" class="mk li it nb b gy nj ng l nh ni">http {<br/>    include       /etc/nginx/mime.types;<br/>    default_type  application/octet-stream;</span><span id="e68a" class="mk li it nb b gy nj ng l nh ni">log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '<br/>                      '$status $body_bytes_sent "$http_referer" '<br/>                      '"$http_user_agent" "$http_x_forwarded_for"';</span><span id="0ec3" class="mk li it nb b gy nj ng l nh ni">access_log /var/log/nginx/access.log  main;</span><span id="7f3f" class="mk li it nb b gy nj ng l nh ni">sendfile        on;</span><span id="b6fc" class="mk li it nb b gy nj ng l nh ni">keepalive_timeout  14;</span><span id="9a8c" class="mk li it nb b gy nj ng l nh ni">proxy_http_version 1.1;</span><span id="7dbd" class="mk li it nb b gy nj ng l nh ni">include conf.d/*.conf;<br/>}</span></pre><p id="5cc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我的申请。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="eea7" class="mk li it nb b gy nf ng l nh ni">server {<br/>    listen       80;</span><span id="af9c" class="mk li it nb b gy nj ng l nh ni">    add_header X-Cache-Status $upstream_cache_status;</span><span id="f9d4" class="mk li it nb b gy nj ng l nh ni">    underscores_in_headers on;</span><span id="9155" class="mk li it nb b gy nj ng l nh ni">    error_page  404              /404.html;<br/>    error_page  403              /403.html;<br/>    error_page  500 502 503 504  /500.html;</span><span id="1300" class="mk li it nb b gy nj ng l nh ni">    location /health-czech {<br/>         return 200 'ok';<br/>        }</span><span id="6e1d" class="mk li it nb b gy nj ng l nh ni">    include  /etc/nginx/mime.types;</span><span id="5e9c" class="mk li it nb b gy nj ng l nh ni">    root  /var/www/rails_application/public;</span><span id="a24d" class="mk li it nb b gy nj ng l nh ni">    location / {<br/>          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br/>          proxy_set_header Host $http_host;</span><span id="49a9" class="mk li it nb b gy nj ng l nh ni">    if (-f $request_filename) {<br/>            break;<br/>         }</span><span id="180c" class="mk li it nb b gy nj ng l nh ni">    if ( !-f $request_filename ) {<br/>        proxy_pass <a class="ae kz" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080</a>;<br/>        break;<br/>       }<br/>    }<br/> }</span></pre><h1 id="174b" class="lh li it bd lj lk nk lm ln lo nl lq lr ls nm lu lv lw nn ly lz ma no mc md me bi translated">设置ECS</h1><p id="a6a8" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">第一件事是将应用程序推送到ECR(弹性容器注册中心)。在您的AWS帐户中，导航到ECR，或者只需点击此链接并仔细检查您是否在正确的地区:【https://us-west-2.console.aws.amazon.com/ecr/repositories T2】</p><p id="c816" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦您创建了新的回购协议，如果您安装了AWS CLI，通过“<strong class="kd iu">查看推送命令</strong>”按钮上传是一个简单的选项。我有一个用于更新我的回购的小脚本(注意:我通过配置文件命令设置我的地区):</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="dd48" class="mk li it nb b gy nf ng l nh ni">#!/bin/bash</span><span id="bf7b" class="mk li it nb b gy nj ng l nh ni">if (( "$#" != 1 ))<br/>then<br/>    echo "Usage:<br/>./ecr_push [environment]"<br/>exit 1<br/>fi</span><span id="175d" class="mk li it nb b gy nj ng l nh ni">if [[ $@ != acceptance &amp;&amp; $@ != staging &amp;&amp; $@ != production ]] ;<br/>then<br/>  echo "Environment must be either Acceptance, Staging or Production."<br/>  exit 1<br/>elif [[ $@ = staging || acceptance ]] ;<br/>then<br/> AWS_ACCOUNT=XXXXXXXXXXXX<br/>elif [[ $@ = production ]] ;<br/>then<br/>  AWS_ACCOUNT=XXXXXXXXXXXX<br/>fi</span><span id="1e6c" class="mk li it nb b gy nj ng l nh ni">REPO="$AWS_ACCOUNT.dkr.ecr.us-west-2.amazonaws.com/rails_application-$@"<br/>IMAGE=$REPO:latest-$@</span><span id="7527" class="mk li it nb b gy nj ng l nh ni">$(aws ecr get-login --no-include-email --region $AWS_REGION)<br/>docker build -t $IMAGE .<br/>docker push $IMAGE</span></pre><p id="262e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦您的NGINX和Rails应用程序repos被添加到ECR，您就可以设置<strong class="kd iu">任务定义</strong>。您将面临的第一个选择是FARGATE或EC2。我必须满足的一个要求是能够ssh到运行我的rails和nginx应用的容器中，所以我用EC2，因为你不能ssh到fargate。</p><p id="393b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您以前使用过ECS，您可能已经有了一个可供选择的任务角色。AWS自动生成的那个叫做“<strong class="kd iu">ecstaxecutionrole</strong>”。</p><p id="c5cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让您的容器在同一实例上相互通信，您必须选择“<strong class="kd iu">主机</strong>”作为<strong class="kd iu">网络模式</strong>。</p><p id="189d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，在底部，点击“添加音量”按钮。给该卷起一个<strong class="kd iu">名</strong>，但是添加<strong class="kd iu">路径</strong>是不必要的。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/992a0953c141a646c0fbdc958b00bdfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SD6OPCz_uVeWZX1Hz8qUXw.png"/></div></div></figure><p id="814c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将设置我们的容器。我打算使用“t3.micro”实例来运行容器，因此我相应地指定了CPU单元和内存分配。我会让截图做大部分的解释。</p><h2 id="5670" class="mk li it bd lj ml mm dn ln mn mo dp lr km mp mq lv kq mr ms lz ku mt mu md mv bi translated">Rails _应用程序容器</h2><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/39d008e45f00be9d6f3caae9da6d1513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgSrqnE5q4_SuyRfg2Q4tg.png"/></div></div></figure><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/4e4b36f276c3403a8e200f72336f4f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kn5o3AZj-SG-d0E0Pd1-jQ.png"/></div></div></figure><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/b73e4d14fdd9339839827fd360dbb837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TyGyOSWikjKczRwoSxWFtw.png"/></div></div></figure><h2 id="bcf2" class="mk li it bd lj ml mm dn ln mn mo dp lr km mp mq lv kq mr ms lz ku mt mu md mv bi translated">NGINX容器</h2><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/6a998441e8dcf8a9c000d7115b1753c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZLKTh7t3upch9UfG_hv6g.png"/></div></div></figure><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/038bdfa4b366316918cd3a35bf870aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFxUeJkxuUy5UB5s_B8gLQ.png"/></div></div></figure><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/c8131dc55c288539de7ce9fc238bc96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Gva0Au2CdYpxtkexnth1Q.png"/></div></div></figure><p id="a7fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一些大的要点如下:<br/>rails _ application容器将使用端口8080，nginx容器被分配了端口80。<br/>两个容器都将共享rails_application卷，并将/var/www/rails_application作为挂载路径。</p><p id="42e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另外，请注意起始压边。Nginx用途:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0536" class="mk li it nb b gy nf ng l nh ni">nginx,-g,daemon off;</span></pre><p id="0e03" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当rails应用程序使用入口点选项并运行这个脚本时:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="80b9" class="mk li it nb b gy nf ng l nh ni">sh,app_start.sh</span></pre><p id="dceb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个脚本是rails_application repo的一部分，非常简单:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="5d47" class="mk li it nb b gy nf ng l nh ni">#!/bin/sh<br/>bundle exec rake assets:precompile<br/>bundle exec puma -C config/puma.rb</span></pre><p id="453e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个特殊的rails应用程序需要预编译静态资产，然后通过puma启动应用程序。其他不需要资产预编译的rails应用程序可以在任务定义的环境部分使用命令字段，而不是入口点，命令如下:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="6973" class="mk li it nb b gy nf ng l nh ni">bundle,exec,puma,-t,0:5,-w,4,-b,tcp://127.0.0.1:8080</span></pre><p id="0663" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您不想通过puma.rb文件设置线程和工作线程，这是一个不错的选择。</p><h2 id="a392" class="mk li it bd lj ml mm dn ln mn mo dp lr km mp mq lv kq mr ms lz ku mt mu md mv bi translated">集群部署</h2><p id="58b6" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">当设置您的集群时，您将选择<strong class="kd iu"> EC2 Linux +网络</strong>模板选项。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/45f12ca1b219824907b2b9eb0540fec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDnyvlpeczjiLlLD35YlMA.png"/></div></div></figure><p id="eb66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦您配置了您的集群，您应该能够启动一个新的任务。(注意:对于本教程，我使用的是<strong class="kd iu">任务</strong>选项，而不是设置<strong class="kd iu">服务</strong>，这非常有用，特别是对于自动缩放，但需要额外的解释)。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/935e9bb10cafafc2a7a0fe96661ccfd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HBXpT6WU5x__g5-MtXV3lQ.png"/></div></div></figure><p id="6710" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<strong class="kd iu">运行任务</strong>配置页面，选择<strong class="kd iu"> EC2 </strong>作为启动类型，然后选择您刚刚创建的任务定义。集群应该是预先选择的，并且是正确的，因此您只需点击页面右下角的运行任务按钮。如果您得到一个“Run tasks failed”错误，很可能是您的任务定义的CPU/RAM分配和EC2实例类型选项之间的问题。</p><p id="4db5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望您不会遇到任何阻碍，并且您的任务的“最后状态”是<strong class="kd iu">正在运行</strong>！</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c6e2b68c955467d419a55440d9da9568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*z6ZRamVS924Bf17ZNtfsFQ.png"/></div></figure><p id="b84d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您已经设置了负载平衡器和目标组，向该目标组添加了新的ECS容器实例，正确设置了该目标组的健康检查路径(在可能的情况下是“/health-czech”)，并正确配置了您的安全组，那么您的应用程序应该已经启动并可访问。</p><p id="5086" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">行动愉快😊</p></div></div>    
</body>
</html>