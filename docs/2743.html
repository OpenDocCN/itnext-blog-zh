<html>
<head>
<title>What are Primitive and Reference Types in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的原语和引用类型是什么？</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-interview-prep-primitive-vs-reference-types-62eef165bec8?source=collection_archive---------4-----------------------#2019-07-25">https://itnext.io/javascript-interview-prep-primitive-vs-reference-types-62eef165bec8?source=collection_archive---------4-----------------------#2019-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ed4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解JavaScript如何处理不同的数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f1ec087f2995d820f81fc45cb0b68172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GaGsGlBnetFLAVt9OwzzvQ.png"/></div></div></figure><p id="7bbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在JavaScript面试中，他们可能会问你是否理解<em class="lq">原语</em>和<em class="lq">引用</em>数据类型之间的区别。幸运的是，这个主题是计算机科学中少数几个名字可以解释一切的主题之一。数据类型存储信息有两种方式:作为内存中的一个槽，或者作为对内存中某个位置的一个槽的引用。你能猜出哪个是哪个吗？</p><h1 id="babd" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">首先:原始类型</h1><p id="0f4a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">原始数据类型有:数字、字符串、布尔、未定义和null(还有<a class="ae mo" href="https://www.keithcirkel.co.uk/metaprogramming-in-es6-symbols/" rel="noopener ugc nofollow" target="_blank">符号</a>，所以检查一下这些)。基本上，如果它存储一个简单的数据，它就被简单地存储了。当你用这种类型设置一个变量时，这个变量就是那个精确的值，仅此而已。如果你改变了这个值，这个变量就会变成一个新值。</p><h1 id="4a0e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">下一步:引用类型</h1><p id="224e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这意味着两个引用类型是对象和数组(技术上来说是一个，<a class="ae mo" href="https://stackoverflow.com/questions/5048371/are-javascript-arrays-primitives-strings-objects" rel="noopener ugc nofollow" target="_blank">，因为数组是对象</a>)。创建对象时，该值不会直接赋给变量。相反，对该值的引用<em class="lq">被设置。变量所知道的只是对象在内存中的位置，而不是对象本身。</em></p><h1 id="f10d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">用家务隐喻来解释它</h1><p id="488b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">假设你需要提醒自己去洗碗。如果你要原始地储存它，你会拿一张纸，写下“洗碗”但是如果你的室友已经做过了呢？现在你的任务是倒垃圾。因为它是原始储存的，你只要拿起那张纸，擦掉“洗碗”并写下“倒垃圾”</p><p id="6434" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了通过参考来保存你的杂务，你的室友会保留一份所有杂务的清单。当你需要知道还剩下什么或者划掉一个的时候，你问他们，然后<em class="lq">他们</em>访问列表。你自己没有名单，你只是知道去哪里找。隐喻说够了，让我们看一些代码。</p><h1 id="6b33" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">复制值的代码才是最重要的</h1><p id="679d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当复制或传递值时，这些都会真正发挥作用。看看这段复制原始值的代码:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="3624" class="mu ls it mq b gy mv mw l mx my">let <strong class="mq iu">color1</strong> = <em class="lq">'green'</em>;<br/>let <strong class="mq iu">color2</strong> = <strong class="mq iu">color1</strong>;<br/><strong class="mq iu">color1</strong> = '<em class="lq">purple'</em>;</span><span id="883b" class="mu ls it mq b gy mz mw l mx my"><strong class="mq iu">console</strong>.log(<strong class="mq iu">color1</strong>);<br/><em class="lq">// 'purple'</em><br/><strong class="mq iu">console</strong>.log(<strong class="mq iu">color2</strong>);<br/><em class="lq">// 'green'</em></span></pre><p id="ce89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe na nb nc mq b">color1</code>被赋予字符串值<code class="fe na nb nc mq b">‘green’</code>，这意味着变量<code class="fe na nb nc mq b">color1</code>本质上与字符串<code class="fe na nb nc mq b">'green'</code>相同。当我们用<code class="fe na nb nc mq b">color1</code>给<code class="fe na nb nc mq b">color2</code>赋值时，就好像我们真的给它赋值了一个字符串值。所以当我们重新分配<code class="fe na nb nc mq b">color1</code>的值时，它对<code class="fe na nb nc mq b">color2</code>完全没有影响。这两种价值观永远只是储蓄字符串，它们之间没有持久的债券。引用类型不是这种情况。看:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="e99f" class="mu ls it mq b gy mv mw l mx my">let <strong class="mq iu">car1</strong> = {<br/>  <em class="lq">wheels</em>: 4,<br/>  <em class="lq">seats</em>: 2,<br/>};<br/>let <strong class="mq iu">car2</strong> = <strong class="mq iu">car1</strong>;<br/><strong class="mq iu">car1</strong>.<em class="lq">brand</em> = <em class="lq">'ford'</em>;</span><span id="dcb0" class="mu ls it mq b gy mz mw l mx my"><strong class="mq iu">console.</strong>log(<strong class="mq iu">car1</strong>.brand);<br/><em class="lq">// 'ford'</em><br/><strong class="mq iu">console</strong>.log(<strong class="mq iu">car2</strong>.brand);<br/><em class="lq">// 'ford'</em></span></pre><p id="c1b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哼。我们从未给<code class="fe na nb nc mq b">car2</code>分配品牌资产，但它有一个。尽管情况看起来与我们的原始示例相同，但行为是相反的。那是因为<code class="fe na nb nc mq b">car1</code>从未被赋予对象的<em class="lq">值</em>，只有<em class="lq">引用</em>到它。因此，如果您更改<code class="fe na nb nc mq b">car1</code>，将会改变内存中<code class="fe na nb nc mq b">car2</code>正在查看的同一个位置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c463ecc785c5df8167154c47465621b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8i-f2AqE01X-9utn4hPNA.png"/></div></div></figure><h1 id="346b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">解决参考问题</h1><p id="f8f3" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">通过添加那个<code class="fe na nb nc mq b">brand</code>属性，我们永久地改变了原始对象。这就是所谓的突变，当我们不小心超过预期目标时，这并不好。为了解决这个问题，我们只需要创建一个对<em class="lq">新</em>对象的<em class="lq">新</em>引用。这样，每个变量都将指向自己的对象，不会有任何重叠。最常见的方法是使用<a class="ae mo" href="https://thecodebarbarian.com/object-assign-vs-object-spread.html" rel="noopener ugc nofollow" target="_blank"> Object.assign或spread操作符</a>。为简洁起见，我们使用一个跨页:</p><pre class="kj kk kl km gt mp mq mr ms aw mt bi"><span id="c2be" class="mu ls it mq b gy mv mw l mx my">let <strong class="mq iu">car1</strong> = {<br/>  <em class="lq">wheels</em>: 4,<br/>  <em class="lq">seats</em>: 2,<br/>};<br/>let <strong class="mq iu">car2</strong> = {...<strong class="mq iu">car1</strong>};<br/><strong class="mq iu">car1</strong>.brand = <em class="lq">'ford'</em>;</span><span id="7159" class="mu ls it mq b gy mz mw l mx my"><strong class="mq iu">console.</strong>log(<strong class="mq iu">car1</strong>.brand);<br/><em class="lq">// 'ford'</em><br/><strong class="mq iu">console</strong>.log(<strong class="mq iu">car2</strong>.brand);<br/><em class="lq">// undefined</em></span></pre><h1 id="a8ef" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">最后一件事</h1><p id="7949" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">对象是可变的，意味着它们可以改变(<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank">除非你冻结它</a>)。然而，原始类型是不可变的。看，你实际上不能把数字<code class="fe na nb nc mq b">1</code>变成<code class="fe na nb nc mq b">2</code>，你只是替换了这个值。这意味着我们没有改变我们的“绿色”字符串，我们只是直接用新字符串“紫色”替换它这是一个偷偷摸摸的小技术问题，但现在你知道了！祝你面试顺利，一如既往，</p><p id="97a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家编码快乐，</p><p id="1b0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">麦克风</p><p id="d253" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">最新文章:</em> <a class="ae mo" href="https://medium.com/@mikecronin92/how-to-build-a-dynamic-controlled-form-with-react-hooks-2019-b39840f75c4f" rel="noopener">如何用React钩子构建一个动态的、可控的表单</a></p></div></div>    
</body>
</html>