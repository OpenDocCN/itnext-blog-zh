<html>
<head>
<title>Easy patterns: Interpreter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单模式:解释器</h1>
<blockquote>原文：<a href="https://itnext.io/easy-patterns-interpreter-58434c94304d?source=collection_archive---------1-----------------------#2019-06-09">https://itnext.io/easy-patterns-interpreter-58434c94304d?source=collection_archive---------1-----------------------#2019-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6b8b71d0358472a2230fd5c668ccc068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ekq8Rbia0-lyBE-M2RBnRw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">解释器模式的结构</figcaption></figure><p id="6acb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文是easy patterns系列描述的延续，介绍了一个名为解释器的行为模式，它有助于获得某种语言的适当表示(代码分析、解析、处理等)。</p><p id="4011" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也请参考其他模式文章:</p><h2 id="bf5d" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">创作模式:</h2><blockquote class="lt lu lv"><p id="fa0f" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-simple-factory-b946a086fd7e"> <strong class="ke ir">简易工厂</strong> </a></p><p id="2004" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-factory-method-5f27385ac5c"> <strong class="ke ir">工厂法</strong> </a></p><p id="8fab" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-builder-d85655bcf8aa"> <strong class="ke ir">建造者</strong> </a></p><p id="0e6b" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-singleton-283356fb29bf"> <strong class="ke ir">单个</strong> </a></p><p id="73db" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-abstract-factory-2325cb398fc6"> <strong class="ke ir">抽象工厂</strong> </a></p><p id="9d90" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-prototype-e03ec6962f89"> <strong class="ke ir">原型</strong> </a></p></blockquote><h2 id="b2ad" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">结构模式:</h2><blockquote class="lt lu lv"><p id="4425" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-adapter-9b5806cb346f"> <strong class="ke ir">适配器</strong> </a></p><p id="5343" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-decorator-eaa96c0550ea"> <strong class="ke ir">装饰者</strong> </a></p><p id="a7f3" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-bridge-28d50dc25f9f"> <strong class="ke ir">桥</strong> </a></p><p id="2353" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158"> <strong class="ke ir">复合</strong> </a></p><p id="2cca" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-facade-8cb185f4f44f"> <strong class="ke ir">立面</strong> </a></p><p id="9d1e" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-flyweight-dab4c018f7f5"> <strong class="ke ir">飞锤</strong> </a></p><p id="797a" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-proxy-45fc3a648020"> <strong class="ke ir">代理</strong> </a></p></blockquote><h2 id="c975" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">行为模式:</h2><blockquote class="lt lu lv"><p id="052a" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-visitor-b8ef57eb957"> <strong class="ke ir">来访者</strong> </a></p><p id="8f4d" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-mediator-e0bf18fefdf9"> <strong class="ke ir">调解员</strong> </a></p><p id="ee43" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-observer-63c832d41ffd"> <strong class="ke ir">观察者</strong> </a></p><p id="2da6" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-memento-ce966cec7478"> <strong class="ke ir">纪念品</strong> </a></p><p id="e199" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-iterator-f5c0dd85957"> <strong class="ke ir">迭代器</strong> </a></p><p id="f257" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-chain-of-responsibility-9a84307ad837"> <strong class="ke ir">责任链</strong> </a></p><p id="e67d" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-strategy-ecb6f6fc0ef3"> <strong class="ke ir">策略</strong> </a></p><p id="f43d" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-state-ec87a1a487b4">状态<strong class="ke ir">状态</strong>状态</a></p><p id="1ff3" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-command-15733a2b56f0"> <strong class="ke ir">命令</strong> </a></p><p id="f6c6" class="kc kd lw ke b kf kg kh ki kj kk kl km lx ko kp kq ly ks kt ku lz kw kx ky kz ij bi translated"><strong class="ke ir">解释器</strong> <em class="iq">(当前文章)</em></p></blockquote><h1 id="783f" class="mb lb iq bd lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo mp mq lr mr bi translated">主要本质</h1><p id="3ee4" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">搜索与模式匹配的字符串是一个常见问题。正则表达式是指定字符串模式的标准语言。搜索算法可以解释指定一组匹配字符串的正则表达式，而不是构建自定义算法来匹配每个模式和字符串。</p><p id="465f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">解释器模式描述了如何为简单的语言定义语法，用语言表示句子并解释这些句子。</p><p id="ff70" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该模式包括4个主要角色:</p><ul class=""><li id="4945" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated"><strong class="ke ir"> TerminalExpression </strong>(文字表达式)——声明语法树中与语法中的终止符号相关联的所有节点共有的解释操作。</li><li id="e1ba" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><strong class="ke ir"> NonTerminalExpression </strong>(交替表达式、重复表达式、序列表达式)——声明语法树中与语法中的非终结符号相关联的所有节点共有的解释操作。</li><li id="3012" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><strong class="ke ir">上下文</strong> —包含解释器的全局信息。</li><li id="b043" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><strong class="ke ir">客户端</strong> —构建抽象语法树，以语法定义的语言表示特定句子。</li></ul><p id="c69f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于这些角色协作的几句话。</p><ol class=""><li id="549b" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nl nd ne nf bi translated">客户端将句子构建为抽象语法树。</li><li id="3274" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nl nd ne nf bi translated">客户端初始化上下文并调用解释操作。</li><li id="5917" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nl nd ne nf bi translated">每个非终结符表达式节点在每个子表达式上定义解释器。每个终端表达式的解释操作定义了递归中的基本情况。</li><li id="579f" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nl nd ne nf bi translated">每个节点上的解释操作使用上下文来存储和访问解释器的状态。</li></ol><h1 id="001e" class="mb lb iq bd lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo mp mq lr mr bi translated">使用示例</h1><p id="c278" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">在这个例子中，我们将创建一个咖啡机，它可以通过内置键盘(或某种语音到文本分析器)的书面文本来分析命令。</p><p id="9fd2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">会保存我们需要的全局数据:输入和输出值。</p><p id="3b46" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">类将在语言语法和要执行的特定命令之间提供一座桥梁。每个表达式都有自己的解释逻辑定义。</p><p id="e3db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">函数将从许多已定义的表达式中收集抽象语法树，并通过它们来分析传递的输入句子。这个函数将结果写回上下文。</p><figure class="nq nr ns nt gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="8056" class="mb lb iq bd lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo mp mq lr mr bi translated">利润</h1><p id="f2f5" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">有了许多表达式，改变和扩展语法就很容易了。该模式使用类来表示语法规则，因此可以通过类扩展来扩展功能。</p><p id="a0fd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">定义抽象语法树中节点的类。这样的类很容易编写，并且通常这样的过程被委托给编译器或解析器生成器。</p><p id="462b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">解释器模式使得以一种新的方式计算表达式变得更加容易。例如，您可以通过在表达式类上定义一个新的操作来支持表达式的漂亮打印或类型检查。</p><h1 id="2298" class="mb lb iq bd lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo mp mq lr mr bi translated">薄弱的地方</h1><p id="36d1" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">解释器模式为语法中的每个规则定义了至少一个类。因此，包含许多规则的语法可能很难管理和维护。</p><p id="6f3f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当语法非常复杂时，您可能也需要一个更复杂的解决方案。像解析器或编译器生成器这样的工具将有助于你不用自己维护大量的类。</p><h1 id="58e7" class="mb lb iq bd lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo mp mq lr mr bi translated">结论</h1><p id="ee07" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">解释器模式广泛应用于用面向对象语言实现的编译器中。在JavaScript中，有很多分析器都有这个核心概念。它们都使用抽象语法树来管理语法分析(Babel、EsLint、StyleLint)。</p><p id="a16f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有一些相关的模式使得解释器的工作变得有效和复杂:</p><ul class=""><li id="0730" class="mx my iq ke b kf kg kj kk kn mz kr na kv nb kz nc nd ne nf bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158"> <strong class="ke ir">复合</strong> </a> <strong class="ke ir"> </strong> —抽象语法树是复合模式本身的一个实例。</li><li id="e221" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-flyweight-dab4c018f7f5"> <strong class="ke ir"> Flyweight </strong> </a> —展示如何在抽象语法树中共享终端符号。</li><li id="6ddc" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-iterator-f5c0dd85957"> <strong class="ke ir">迭代器</strong> </a> —帮助遍历抽象语法树的结构。</li><li id="ba45" class="mx my iq ke b kf ng kj nh kn ni kr nj kv nk kz nc nd ne nf bi translated"><a class="ae ma" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-visitor-b8ef57eb957"> <strong class="ke ir"> Visitor </strong> </a> —可以用来维护一个类中抽象语法树中每个节点的行为。</li></ul><p id="5631" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您觉得这篇文章有帮助，请点击👏按钮并在下面随意评论！</p></div></div>    
</body>
</html>