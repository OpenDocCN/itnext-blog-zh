<html>
<head>
<title>Microservices architecture: an implementation of Saga pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构:Saga模式的实现</h1>
<blockquote>原文：<a href="https://itnext.io/microservices-architecture-an-implementation-of-saga-pattern-dbbe5d881c78?source=collection_archive---------1-----------------------#2019-10-07">https://itnext.io/microservices-architecture-an-implementation-of-saga-pattern-dbbe5d881c78?source=collection_archive---------1-----------------------#2019-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/42d4c07dd94b18bef3d634e140f4b503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CjIUmjQWOf5ISm3Y"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的科坦·拉杰普特<a class="ae jd" href="https://unsplash.com/@ketan_rajput?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></figcaption></figure><div class=""/><p id="4d0f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的几年中，微服务是目前行业中的热门话题之一，在不需要微服务的情况下也是如此。通常，架构设计是错误的，可能它更像是一个微型整体服务。如果你对这些基本问题中的一个回答“是”，那么你的架构是错误的，很可能是:-D</p><ul class=""><li id="27e3" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">你有你的服务的单一实例吗？</li><li id="1833" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">您有单一的数据库(或模式)吗？</li><li id="fa76" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">服务之间的通信是同步的吗？</li><li id="45c2" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi">…</li></ul><p id="3b03" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有很多问题需要回答，但在这篇文章中，我将向您展示一个简单的符合模式的微服务架构，该架构基于由<strong class="kf jh"> Chris Richardson </strong>所著的“<em class="lp">微服务模式</em>”一书。</p><p id="945b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的例子中，主要的想法是为“McPaspao”，我假设的快餐，构建一个管理软件:-D .下面是基于域的初步分析:</p><ul class=""><li id="0aa9" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">订单管理</li><li id="e651" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">厨房管理</li><li id="31d3" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">交付管理</li></ul><p id="7961" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lp">订单管理</em>管理汉堡订单，<em class="lp">厨房管理</em>管理厨房工作(例如:烹饪汉堡或冰箱管理)，<em class="lp">配送管理</em>管理汉堡的配送。所以我至少需要三个不同的服务，每个都有自己的数据库，然后每个服务都需要相互通信。在这种情况下，还需要其他五个组件:</p><ul class=""><li id="50f9" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">订单数据库</li><li id="ff19" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">厨房数据库</li><li id="85f3" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">交付数据库</li><li id="b7d7" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">消息服务</li><li id="e8a4" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">API网关</li></ul><p id="78da" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在微服务架构API网关中，消息服务和每服务数据库是用于解决许多问题的常见模式，例如:</p><ul class=""><li id="f51c" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf jh">消息服务</strong>:服务经常协作处理许多请求，因此它们必须使用进程间通信协议。更具体地说是异步消息传递系统。</li><li id="e123" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf jh">每个服务的数据库</strong>:服务的数据库必须是实现的一部分，以确保良好的耦合，从而可以独立开发、部署和扩展。</li><li id="f68d" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf jh"> API网关</strong>:在微服务架构中，有大量的服务、协议、地址、端口、安全策略、冗余策略等。API网关模式试图解决这个问题，它为客户端提供了一个单一的入口点来管理所有列出的方面等等。</li></ul><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lq"><img src="../Images/a8fbce6a9663d497603c48b1bb45bb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQ-cTOQsXYUgvyfBSJHZuA.png"/></div></div></figure><p id="9141" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是架构的大图，<em class="lp"> API网关</em>是<a class="ae jd" href="https://konghq.com/kong" rel="noopener ugc nofollow" target="_blank">孔</a>，<em class="lp">消息服务</em> <a class="ae jd" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>和<em class="lp">每个服务的数据库</em> <a class="ae jd" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>。这个项目在Github上的<a class="ae jd" href="https://github.com/paspao/McPaspaoTakeAway" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="553a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个微服务都是按照<em class="lp">六边形</em>架构风格实现的:核心逻辑嵌入在六边形内部，六边形的边被视为输入和输出。目标是以一种将核心逻辑与外部元素隔离的方式对对象进行分层:核心逻辑位于画面的中心，所有其他元素都被视为集成点(DB、API、消息传递)。我们讨论通过调用业务逻辑处理来自外部的请求的<em class="lp">入站适配器</em>，以及由业务逻辑调用的<em class="lp">出站适配器</em>(以调用外部应用程序)。一个<em class="lp">端口</em>定义了一组操作，即业务逻辑如何与外部交互。</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lv"><img src="../Images/49e2004b9aaf3c3e6a69d1310b3b558f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4XCFM7ZuiATDLFsvHutbA.png"/></div></div></figure><p id="40cc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图中<em class="lp">控制器</em>和<em class="lp">消费者</em>为入站适配器，<em class="lp">服务</em>为入站端口，<em class="lp">消息接口</em>和<em class="lp"> DB接口</em>为出站端口，<em class="lp">道</em>和<em class="lp">生产者</em>为出站适配器。</p><p id="1610" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解释所使用的内部架构，我将展示单个微服务的细节，即<em class="lp">交付服务</em>。它有一个单独的api来监控交付的状态，它定义了一个<em class="lp">入站端口IDeliveryAPI </em>:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c99f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类<em class="lp"> DeliveryApi </em>是一个<em class="lp">入站适配器</em>:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1634" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类别<em class="lp"> DeliveryService </em>代表<em class="lp">业务逻辑</em>:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4f64" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接口<em class="lp"> IDeliveryPublisher </em>是一个<em class="lp">出站端口</em>:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ac36" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类<em class="lp"> DeliveryPublisher </em>是一个<em class="lp">出站适配器</em>:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="56f6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个微服务(在我的例子中)内部都有这种风格的架构，以确保软件层之间的高度耦合。但这只是单个微服务的内部架构，例如，其他微服务也可能使用<em class="lp">分层</em>架构风格。</p><p id="e70c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，一个涉及每个微服务的简单用例是<em class="lp">订单管理</em>，即:一个浏览器请求一个汉堡，<em class="lp">订单服务</em>接收订单并将其写入数据库，订单管理工作完成，但要完成订单，它需要联系<em class="lp">厨房服务</em>，因此它发送一个主题消息(以确保异步的进程间通信)， <em class="lp">厨房服务</em>正在监听这个主题，它使用消息并处理订单，通过另一个主题向<em class="lp">订单服务</em>提供反馈。 当<em class="lp">厨房服务</em>做好汉堡后，它向<em class="lp">递送服务</em>发送一条消息，而<em class="lp">递送服务</em>处理该消息，递送汉堡并发送反馈。微服务之间的每个通信都通过消息代理，在我的例子<em class="lp"> Kafka </em>中，我应用了一个<em class="lp">编排传奇模式</em>，即:</p><blockquote class="ly"><p id="77a7" class="lz ma jg bd mb mc md me mf mg mh la dk translated">传奇是一系列本地事务。每个本地事务更新数据库并发布消息或事件来触发saga中的下一个本地事务。如果本地事务由于违反业务规则而失败，则saga会执行一系列补偿事务，以撤销之前的本地事务所做的更改。有两种协调传奇的方式:</p><p id="f1ec" class="lz ma jg bd mb mc md me mf mg mh la dk translated">-编排-每个本地事务发布触发其他服务中的本地事务的域事件</p><p id="5d68" class="lz ma jg bd mb mc md me mf mg mh la dk translated">-编排—编排器(对象)告诉参与者要执行哪些本地事务</p><p id="adff" class="lz ma jg bd mb mc md me mf mg mh la dk translated">克里斯·理查森</p></blockquote><p id="139a" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">为了查看整个架构，我使用了下面列出的docker-compose.yml (docker应用程序):</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="a909" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像上面的大图一样，有三个服务和三个数据库，然后是Kafka broker，这是一个个性化的图像，在borad上已经有了所有需要的主题:</p><ul class=""><li id="a93e" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">订单服务</li><li id="11e4" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">订单服务回调</li><li id="deb6" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">厨房服务</li><li id="16d3" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">送货服务</li></ul><p id="8724" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Kafka容器中还有一个Zookeeper的实例，需要启动Kafka，你可以在这里阅读如何创建它。</p><p id="f4f9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个组件是API网关，<em class="lp"> Kong </em>:经典安装使用类似于<em class="lp"> Postgresql </em>的数据库，但是也可以通过声明的方式启动Kong，遵循Kong <em class="lp"> kong.yml </em>的简单配置:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7712" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我以最简单的方式使用API网关，没有任何认证和授权服务或服务副本或服务发现等。为了避免在主要方面混淆:实现<em class="lp">编排传奇模式</em>。</p><p id="49c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要构建项目，您可以使用<em class="lp"> maven </em>然后手动启动每个服务，或者您可以使用多级Docker文件构建所有内容(您必须在Docker 19.x上启用<em class="lp">实验特性</em>):</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8916" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后用命令开始:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6d4e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考验的时候到了！</p><p id="b74a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用Swagger用户界面验证每个微服务都在运行:</p><ul class=""><li id="fb42" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">订单服务:<a class="ae jd" href="http://localhost:8000/kitchen-service/swagger-ui.html" rel="noopener ugc nofollow" target="_blank"><em class="lp">http://localhost:8000/kitchen-Service/swagger-ui . html</em></a></li><li id="e559" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">厨房服务<a class="ae jd" href="http://localhost:8000/order-service/swagger-ui.html" rel="noopener ugc nofollow" target="_blank"><em class="lp">http://localhost:8000/order-service/swagger-ui . html</em></a></li><li id="a4e4" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">交付服务<a class="ae jd" href="http://localhost:8000/delivery-service/swagger-ui.html" rel="noopener ugc nofollow" target="_blank"><em class="lp">http://localhost:8000/delivery-service/swagger-ui . html</em></a></li></ul><p id="1e7b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我想要一个汉堡！！！厨房需要一些汉堡，冰箱是空的，所以(你必须安装<a class="ae jd" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>):</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1469" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我添加了两个汉堡，现在我请求订购两个汉堡:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7ab0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一步中，订单进入<em class="lp">等待</em>状态，然后<em class="lp">烹饪</em>、<em class="lp">包装</em>和<em class="lp">交付</em>状态。如果再次运行脚本，系统没有足够的汉堡，下一个订单将处于<em class="lp">等待</em>状态，然后<em class="lp">中止</em>。</p><p id="4f4f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望本指南将帮助您阐明微服务架构的强大和复杂性，这只是一个使用简单和基本组件实现的实际示例，但您可以猜测何时使用或不使用它。感谢您的阅读。</p></div></div>    
</body>
</html>