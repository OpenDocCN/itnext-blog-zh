<html>
<head>
<title>Build a Redis Compatible Cluster based on TiKV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于TiKV构建Redis兼容集群</h1>
<blockquote>原文：<a href="https://itnext.io/build-a-redis-compatible-cluster-based-on-tikv-6ef03d26528?source=collection_archive---------1-----------------------#2018-06-18">https://itnext.io/build-a-redis-compatible-cluster-based-on-tikv-6ef03d26528?source=collection_archive---------1-----------------------#2018-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0788" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Redis是什么？</h2></div><p id="5b27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://redis.io" rel="noopener ugc nofollow" target="_blank"> Redis </a>，一个快速、开源、内存中的键值数据存储，可以用作数据库、缓存和消息代理。它提供了丰富的数据结构，如字符串、哈希、集合和有序集合，可以帮助用户轻松地构建自己的产品。这是一个高性能的，也许是世界上最快的数据库之一。虽然它将数据保存在内存中，但它支持可以保证数据安全的持久和异步复制。</p><h2 id="2405" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">Redis的局限性</h2><p id="ae04" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Redis很酷，但它仍然存在一些问题:</p><ol class=""><li id="646d" class="ma mb iq kh b ki kj kl km ko mc ks md kw me la mf mg mh mi bi translated">内存是昂贵的，而且不是无限的。你不能在一台机器上保存大量数据。</li><li id="9eb2" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">异步复制无法保持数据一致。</li><li id="0c5e" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">交易模式不能保证ACID合规。</li><li id="a2a8" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">虽然支持集群化，但是不能支持跨节点分布式事务。</li></ol><p id="1cbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，我们需要一个更强大的数据库来支持:</p><ol class=""><li id="6658" class="ma mb iq kh b ki kj kl km ko mc ks md kw me la mf mg mh mi bi translated">丰富的数据结构，如字符串、散列、集合、有序集合等。</li><li id="2370" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">高性能</li><li id="175d" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">数据强一致性</li><li id="2451" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">水平可扩展性</li><li id="2fc5" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">分布式事务</li></ol><h2 id="86a9" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">为什么是TiKV？</h2><p id="f132" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">大约4年前，我开始解决Redis的问题。为了保持数据的持久性，直观的方法是将数据保存在磁盘中，而不是内存中。于是我开发了<a class="ae lb" href="https://github.com/siddontang/ledisdb" rel="noopener ugc nofollow" target="_blank"> LedisDB </a>，一个使用RocksDB保存数据，支持Redis协议，提供Redis数据结构的数据库。LedisDB工作得很好，但是它不完全兼容Redis。所以后来，我创建了<a class="ae lb" href="https://github.com/reborndb/reborn" rel="noopener ugc nofollow" target="_blank"> RebornDB </a>，一个完全兼容redis的数据库。</p><p id="a7de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">LedisDB和RebornDB都将数据保存在磁盘中，克服了内存限制。但是它们不支持ACID事务。虽然我们可以使用<a class="ae lb" href="https://github.com/CodisLabs/codis" rel="noopener ugc nofollow" target="_blank"> codis </a>来扩展它们以支持集群，但还是不方便，也不能支持分布式事务。</p><p id="b3d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们需要一种新的方法。好在现在对我们来说不难，因为我们有<a class="ae lb" href="https://github.com/pingcap/tikv" rel="noopener ugc nofollow" target="_blank"> TiKV </a>。</p><p id="7774" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TiKV是一个高性能的分布式事务键值存储。虽然它只是提供了一个简单的键值API，但是您可以在它的基础上构建自己的逻辑。例如，我们已经构建了<a class="ae lb" href="https://github.com/pingcap/tidb" rel="noopener ugc nofollow" target="_blank">TiDB</a>——一个基于TiKV的分布式关系数据库。TiDB支持MySQL协议，它在内部将数据库模式映射到键值。所以对于Redis，我们也可以构建一个支持Redis协议的服务，并将Redis数据结构映射到键值格式。</p><h2 id="30a0" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">怎么</h2><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="ab gu cl mt"><img src="../Images/8215ce3025444ee6b3e1cc83f913a939.png" data-original-src="https://miro.medium.com/v2/format:webp/1*q73rU6L5Sd66HRF9UcUM-A.png"/></div></figure><p id="2b30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整个架构很简单。我们只需要构建一个Redis代理，它解析Redis协议，并将Redis数据结构转换为TiKV键值结构。</p><h2 id="921c" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">Redis协议</h2><p id="91f0" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Redis协议被称为<a class="ae lb" href="https://redis.io/topics/protocol" rel="noopener ugc nofollow" target="_blank"> RESP </a> (Redis序列化协议)，它是基于文本的，人类可读的，并且易于解析。它使用“\r\n”作为终止，并对不同的类型使用不同的前缀。例如，对于简单的字符串，第一个字节是“+”，因此字符串可能像“+OK\r\n”。</p><p id="3921" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数情况下，客户端使用请求-响应模式进行通信。客户端向服务器发送请求(数组类型由批量字符串组成),服务器返回任何RESP类型作为回复。Redis也有两种扩展模式:</p><ol class=""><li id="4655" class="ma mb iq kh b ki kj kl km ko mc ks md kw me la mf mg mh mi bi translated">管道:客户端向服务器发送多个请求并接收回复</li><li id="e862" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">推送:在客户端订阅一个频道后，客户端将只接收来自服务器的回复。</li></ol><p id="4f6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个简单的例子，当客户端向服务器发送<code class="fe mw mx my mz b">LLEN mylist</code>命令时:</p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="c687" class="lc ld iq mz b gy ne nf l ng nh">C: *2\r\n<br/>C: $4\r\n<br/>C: LLEN\r\n<br/>C: $6\r\n<br/>C: mylist\r\n<br/><br/>S: :48293\r\n</span></pre><p id="ad39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">客户端向服务器发送一个包含两个批量字符串的数组，第一个批量字符串长度为4，第二个批量字符串长度为6。服务器返回一个整数48293。如您所见，RESP很简单，编写RESP解析器非常容易。</p><p id="bc70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我刚刚创建了一个Go库<a class="ae lb" href="http://github.com/siddontang/goredis" rel="noopener ugc nofollow" target="_blank"> goredis </a>，使用它我们可以很容易地从连接中解析RESP。举个例子，</p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="343c" class="lc ld iq mz b gy ne nf l ng nh">// Create a buffer IO from the connection.<br/>br := bufio.NewReaderSize(conn, 4096)<br/>// Create a RESP reader.<br/>r := goredis.NewRespReader(br)<br/>// Parse the Request<br/>req := r.ParseRequest()</span></pre><p id="0fc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ParseRequest返回一个解析后的请求，是Go中的一个<code class="fe mw mx my mz b">[][]byte</code>，第一项是类似“LLEN”的命令名，其余项是这个命令的参数。</p><h2 id="e8db" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">TiKV交易API</h2><p id="b250" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在开始之前，我将展示一个如何使用TiKV事务API的简单示例。</p><p id="43f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每一笔交易，我们将从一个<code class="fe mw mx my mz b">Begin</code>函数开始，比如:</p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="a46c" class="lc ld iq mz b gy ne nf l ng nh">txn, err := db.Begin()</span></pre><p id="6f08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my mz b">Begin</code>创建一个函数。如果出现问题，我们需要在这里检查错误。</p><p id="0df3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建事务后，我们可以进行一些操作，比如:</p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="7c74" class="lc ld iq mz b gy ne nf l ng nh">value, err := txn.Get([]byte(“key”))<br/>// Do something with value and then update the newValue to the key.<br/>txn.Put([]byte(“key”), newValue)</span></pre><p id="8dd4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TiKV使用乐观提交模型，因此所有的更改都缓存在客户机中，然后在提交时提交给服务器。</p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="c30c" class="lc ld iq mz b gy ne nf l ng nh">// Commit the transaction<br/>txn.Commit(context.TODO())</span></pre><p id="0237" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像普通交易一样，我们也可以取消交易:</p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="2bb2" class="lc ld iq mz b gy ne nf l ng nh">txn.Rollback()</span></pre><p id="5a69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果两个事务操作同一个密钥，它们会遇到密钥冲突。在这种情况下，只有一个事务可以成功提交，另一个事务将返回冲突错误并中止。</p><h2 id="a505" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">将数据结构映射到TiKV</h2><p id="f145" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">现在我们知道了如何解析Redis协议，在事务中执行键值操作。接下来就是支持Redis数据结构。Redis有四种主要的数据结构:字符串、散列、集合和有序集合。但是对于TiKV，它只支持key-value，所以我们需要将这些不同的数据结构映射到key-value。</p><p id="3ac6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要区分TiKV中不同的数据结构。一种简单的方法是在键的末尾附加一个类型标志。例如，我们可以为字符串添加“s ”,因此字符串“abc”将在TiKV中保存为“abcs”。</p><p id="6299" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于其他类型，我们需要考虑更多，不能只用一个类型标志。例如，对于哈希类型，我们需要支持以下操作:</p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="2948" class="lc ld iq mz b gy ne nf l ng nh">HSET key field1 value1<br/>HSET key field2 value2<br/>HLEN key</span></pre><p id="5c4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个散列有许多字段，我们也想容易地得到散列的长度。所以在TiKV中，我们将把散列键和字段组合在一起作为TiKV键，并使用另一个键来保存长度。布局可能看起来:</p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="e81e" class="lc ld iq mz b gy ne nf l ng nh">key + ‘h’ -&gt; length<br/>key + ‘f’ + field1 -&gt; value<br/>key + ‘f’ + field2 -&gt; value</span></pre><p id="cf1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不将长度保存为另一个键，那么每次如果我们想要获得Hash的长度，我们需要扫描所有带有前缀“key”的数据，这是无效的。但是如果我们对长度使用另一个键，那么每次我们为Hash添加一个新的字段，我们都必须更新长度值。这是一个设计权衡，这里我更喜欢使用另一个长度键，因为<code class="fe mw mx my mz b">HLEN</code>是一个频繁的操作。</p><p id="16fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">演示</p><p id="84a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我构建了一个非常简单的<a class="ae lb" href="https://github.com/siddontang/redis-tikv-example" rel="noopener ugc nofollow" target="_blank">例子</a>，它只支持字符串和哈希以及一些操作。您可以运行:</p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="dfaf" class="lc ld iq mz b gy ne nf l ng nh">git clone https://github.com/siddontang/redis-tikv-example.git $GOPATH/src/github.com/siddontang/redis-tikv-example<br/><br/>cd $GOPATH/src/github.com/siddontang/redis-tikv-example<br/>go build</span></pre><p id="b2cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在运行这个例子之前，你需要启动TiKV，你可以按照这里的<a class="ae lb" href="https://github.com/pingcap/tikv#deploying-to-production" rel="noopener ugc nofollow" target="_blank">指令，然后运行:</a></p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="2586" class="lc ld iq mz b gy ne nf l ng nh">./redis-tikv-example</span></pre><p id="0f2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例服务器将监听端口6380，您可以使用任何redis客户端(如redis-cli)与其通信:</p><pre class="mo mp mq mr gt na mz nb nc aw nd bi"><span id="fd37" class="lc ld iq mz b gy ne nf l ng nh">redis-cli -p 6380<br/>127.0.0.1:6380&gt; set k1 a<br/>OK<br/>127.0.0.1:6380&gt; get k1<br/>"a"<br/>127.0.0.1:6380&gt; hset k2 f1 a<br/>(integer) 1<br/>127.0.0.1:6380&gt; hget k2 f1<br/>"a"</span></pre><h2 id="5535" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">收场白</h2><p id="a193" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">现在，一些公司已经基于TiKV构建了他们的Redis协议服务器，有一个名为<a class="ae lb" href="https://github.com/yongman/tidis" rel="noopener ugc nofollow" target="_blank"> tidis </a>的开源项目也在做同样的事情。如果你想找一个替代你的Redis服务器的解决方案，你可以试试。</p><p id="51e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，TiKV是一个构建模块，我们可以基于它轻松构建许多其他系统。如果你想加入我们开发这个美妙的项目，给我在tl@pingcap.com留言！</p></div></div>    
</body>
</html>