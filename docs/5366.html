<html>
<head>
<title>Yes, here are 4 ways to handle SEO with Vue (even without Node SSR)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是的，这里有4种用Vue处理SEO的方法(即使没有节点SSR)</h1>
<blockquote>原文：<a href="https://itnext.io/yes-here-are-4-ways-to-handle-seo-with-vue-even-without-node-ssr-719f7d8b02bb?source=collection_archive---------0-----------------------#2021-02-18">https://itnext.io/yes-here-are-4-ways-to-handle-seo-with-vue-even-without-node-ssr-719f7d8b02bb?source=collection_archive---------0-----------------------#2021-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5841" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当涉及到前端框架的SEO时，为什么每个人都认为带节点的SSR是唯一的解决方案？</p><p id="365c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">早在2014年SSR还不存在的时候，人们就已经在问"<strong class="jp ir">如何用AngularJS处理SEO？</strong>”。</p><p id="ac29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我经常看到的是“<strong class="jp ir">如何用Vue处理SEO？</strong>”，答案永远是:“用Nuxt”或者“用SSR”。</p><p id="7fdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不是每个人都能为他们的项目拥有一个节点服务器。可能有很多原因:共享网站主机，没有根访问权限…</p><p id="7162" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是更好的问题是“<strong class="jp ir">如何在一个SPA </strong>(单页应用)中处理SEO”，我的回答是:<strong class="jp ir"> SSR不是唯一的解决方案</strong>。</p><p id="2eac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这里有4种方法可以在2021年用SPA来处理SEO。</p><p id="0afb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:我用Vue举例，但是<strong class="jp ir">它们都适用于大多数框架</strong>。</p><h1 id="f592" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.在客户端搜索引擎优化与谷歌爬虫</h1><p id="d136" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">React、Vue、Svelte…所有这些都是最初用于创建spa的前端框架，也称为<strong class="jp ir">带有CSR(客户端渲染)</strong>的网站/web app。</p><p id="5bbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是什么意思？这意味着渲染是在浏览器中完成的。因此，发送到浏览器&amp;搜索引擎爬虫的HTML是空的！</p><blockquote class="lo"><p id="e879" class="lp lq iq bd lr ls lt lu lv lw lx kk dk translated">没有HTML内容=没有SEO。</p></blockquote><p id="c2b7" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">通常，你有一个基本的<strong class="jp ir">index.html</strong>文件，带有硬编码的标题和元标签。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/536f8cb6077b2e81e045aafdf3fa02cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RONb5RNkPe4N-u9wd3Vl6Q.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">基本SPA入口点(index.html文件)</figcaption></figure><p id="0627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">SPA/CSR通常是这样运作的:</strong></p><ol class=""><li id="9d52" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">向任何服务器发出初始请求以获取上面的HTML文件</li><li id="9198" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">服务器返回静态HTML文件</li><li id="10cf" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">浏览器加载、执行和呈现CSS和JS</li><li id="932d" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">在客户端导航期间，AJAX请求是向API服务器发出的</li><li id="947b" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">API服务器返回数据(通常是JSON)</li><li id="ba30" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><strong class="jp ir">浏览器更新当前页面</strong></li></ol><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nh"><img src="../Images/37adc4dd3b80ed7884bc954ff09b9af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZDAj8CIzMEwqbthWp3uvhw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">SPA/CSR渲染生命周期</figcaption></figure><p id="d7fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">2015年</strong>谷歌称<strong class="jp ir">他们可以解析JS </strong>，<strong class="jp ir"> </strong>霍雷🎉(或者不是)。<strong class="jp ir"/><a class="ae ni" href="https://developers.google.com/search/blog/2015/10/deprecating-our-ajax-crawling-scheme" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/search/blog/2015/10/depreciated-our-Ajax-crawling-scheme</a>。</p><p id="2aaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">客户端渲染的SEO有它的缺点:</strong></p><ul class=""><li id="8ee8" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk nj mz na nb bi translated">目前看来，只有谷歌做得对</li><li id="e52b" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">不适用于社交媒体爬虫(脸书、Twitter、LinkedIn……)</li><li id="4117" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">UX:对用户来说渲染速度较慢，因为初始数据是在客户端获取的</li><li id="1e2f" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">基于一些“严格”的规则</li></ul><p id="3f5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是谷歌对此的说法:<a class="ae ni" href="https://developers.google.com/search/docs/guides/javascript-seo-basics" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/search/docs/guides/JavaScript-SEO-basics</a></p><p id="2f72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住，你需要在客户端处理SEO标签(标题，meta…)！你可以用<a class="ae ni" href="https://vue-meta.nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> vue-meta </a>或者<a class="ae ni" href="https://github.com/ktquez/vue-head" rel="noopener ugc nofollow" target="_blank"> vue-head <em class="nk"> </em> </a>来做那个(个人比较喜欢<a class="ae ni" href="https://vue-meta.nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> vue-meta </a>)。</p><p id="c7e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，<strong class="jp ir">很容易设置</strong>。</p><p id="5441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你不需要特定的服务器或任何东西，但这不是最好的方式，也不是针对社交媒体优化的(SMO)。</p><p id="cec0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">尤其是如果你的内容必须是可共享的</strong>。所以才发明了SSR！</p><h1 id="9fcb" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">2.基于节点的服务器端渲染(SSR)SEO</h1><p id="3290" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">所以SSR也叫服务器端渲染，是前端框架带来的一个“新”概念。它基于同构编程，这意味着<strong class="jp ir">相同的应用和代码在后端上下文和前端上下文上执行</strong>。</p><p id="d993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是流星JS带来的。这是唯一可能的，因为Node使用JS。</p><blockquote class="lo"><p id="205b" class="lp lq iq bd lr ls lt lu lv lw lx kk dk translated">但是SSR并不新鲜。</p></blockquote><p id="5a80" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">这实际上是一个糟糕的名字，因为服务器端渲染是经典后端语言从第一天开始做的。</p><p id="ac78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何呈现HTML以响应浏览器请求的后端语言<strong class="jp ir">都是服务器端呈现</strong>。</p><p id="f5b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这种“新”SSR是基于水合作用，这就是它的特别之处:<a class="ae ni" href="https://ssr.vuejs.org/guide/hydration.html" rel="noopener ugc nofollow" target="_blank">https://ssr.vuejs.org/guide/hydration.html</a>。</p><p id="b661" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论如何，在这个方法中，我们将讨论为前端框架创建的“新”SSR。</p><p id="a223" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为您的应用程序是在后端执行的，所以服务器会将您的组件树作为HTML字符串返回给浏览器。</p><p id="b216" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这只发生在第一次装载时</strong>。加载后，SPA进入，导航将像往常一样只在客户端进行。</p><p id="fd6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是什么意思？由于每个初始请求都是由发送HTML的节点服务器完成的，这甚至适用于社交媒体爬虫或任何其他爬虫。</p><p id="6d81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像一个普通的带有PHP/Python/Ruby On Rails等的单片应用程序。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nh"><img src="../Images/90d96661db411fec56b4f9aaee5a91c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHYiReGOd3cepDAtfCAeKw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">对基于节点的SSR服务器的初始浏览器请求</figcaption></figure><p id="0a76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在那之后，它就像我之前提到的水合作用后的常规SPA一样工作。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nh"><img src="../Images/f3ae50ff98374d594360c6196321ef39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_iYkxxxzk3fS6NdbaYaGg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">初始加载后，所有请求都直接从客户端发送到API服务器，无需再次通过渲染服务器</figcaption></figure><p id="a30b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Vue的SSR可以通过两种方式完成，DIY或使用Vue上的框架:</p><ul class=""><li id="f9bc" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk nj mz na nb bi translated">DIY:<a class="ae ni" href="https://ssr.vuejs.org/" rel="noopener ugc nofollow" target="_blank">https://ssr.vuejs.org</a></li><li id="ff23" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">同Nuxt:<a class="ae ni" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank">https://nuxtjs.org</a></li><li id="7f45" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">与Vapper:<a class="ae ni" href="https://vapperjs.org/" rel="noopener ugc nofollow" target="_blank">https://vapperjs.org</a></li><li id="b7cc" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">有了Quasar:<a class="ae ni" href="https://quasar.dev/" rel="noopener ugc nofollow" target="_blank">https://Quasar . dev</a></li><li id="3361" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">带UVue:【https://universal-vue.github.io/docs】T4</li><li id="1543" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">带Ream(实验用):<a class="ae ni" href="https://ream.dev/" rel="noopener ugc nofollow" target="_blank"> https://ream.de </a> v</li></ul><blockquote class="lo"><p id="23a0" class="lp lq iq bd lr ls nl nm nn no np kk dk translated">React &amp; Svelte上也有类似的东西。</p></blockquote><h2 id="7922" class="nq km iq bd kn nr ns dn kr nt nu dp kv jy nv nw kz kc nx ny ld kg nz oa lh ob bi translated">当然，基于节点的SSR SEO也有它的缺点:</h2><p id="f543" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">你需要…一个节点服务器！不要担心，您只需要在最初的HTML呈现中使用它，而不是在您的API中使用它。</p><p id="7649" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的API可以由任何其他服务器/后端语言处理。</p><p id="5952" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果我告诉你<strong class="jp ir">你可以使用“常规”服务器端渲染(使用PHP/Python/Ruby on Rails等)获得类似的结果</strong>会怎么样呢？</p><p id="6b3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">是的，有可能，我们看看如何！</strong></p><h1 id="c6d6" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3.使用“经典”服务器端渲染(SSR)的SEO</h1><p id="c900" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">因此，基于我们在1 &amp; 2中学到的，我们可以用任何后端语言获得类似的东西。</p><p id="9424" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们学到了什么？</strong></p><ul class=""><li id="0ba5" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk nj mz na nb bi translated">谷歌爬虫可以解析JavaScript</li><li id="711a" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">社交媒体爬虫不能，因此它们不能读取标题和元标签</li><li id="f68c" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">我们在初始请求中需要数据以加快渲染速度</li></ul><p id="c3b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为了解决这个问题，我们需要对任何类型的后端执行4个操作:</strong></p><ol class=""><li id="b276" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">使用镜像前端路由器的后端路由器，以便初始响应可以基于所请求的url呈现内容</li><li id="e991" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">在后端响应中，我们将只生成标题和元标签，因为我们的后端不能执行前端代码</li><li id="c3e2" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">我们将把一些初始数据存储在window对象的一个变量中，以便SPA可以在客户机上运行时访问它</li><li id="a289" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">在客户机上，检查窗口对象上是否有数据。如果有，你也没事干。如果没有，就向API服务器发出请求。</li></ol><p id="7207" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例如:假设我有一个Vue应用程序，有4条路线:</strong></p><ul class=""><li id="88e2" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk nj mz na nb bi translated">首页:/</li><li id="12a9" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">关于:/关于</li><li id="fbf1" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">帖子:/帖子/:id</li><li id="7678" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">私人页面:/private/:page</li></ul><p id="fe27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的后端(本例中是Laravel)，我将拥有相同的路由。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oc"><img src="../Images/3f86408cf10cf66a10930cf6998ff67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4A8cgtjAXyGZ4iBiELzHA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">后端路由镜像</figcaption></figure><p id="4ae4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">记住，这只是一个例子。在现实生活中，我当然会有控制器😅<strong class="jp ir">，这只是给大家展示一下概念。</strong></strong></p><p id="6700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看视图“seoView”包含了什么。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi od"><img src="../Images/19905feb2734d59da18b72bb391ba60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dpEeNR3BKL_ArS8KA2TQjA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">用作初始请求响应的后端视图</figcaption></figure><p id="059d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">后端就这么多了，仅此而已。你只需要一个单一的“查看”文件，标题，元，初始数据或任何参数，你需要搜索引擎优化/SMO，就是这样。</p><p id="88d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的“<strong class="jp ir">window . initial data = @ JSON($ state)</strong>也很重要，但是<strong class="jp ir">对于SEO </strong>来说并不是强制的。这是为了性能/UX的目的。它只是让你在前端有初始数据，以避免对你的API服务器的初始AJAX请求。</p><p id="e1c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面以<strong class="jp ir"> /posts/:id </strong>路线为例介绍如何使用:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oe"><img src="../Images/b5479cc64362d6860f5465a067bb3bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7zXzvK0o3s_xhL7VR84hCA.png"/></div></div></figure><p id="5894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之:检查initialData是否存在，如果存在就使用它，如果不存在就从API服务器获取它。</p><p id="5966" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以在任何其他生命周期挂钩或方法中完成。使用它的另一种方法是将初始数据存储在Vuex状态中。</p><p id="3ccb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在大多数情况下，<strong class="jp ir">标题和meta标签是从后端</strong>呈现的最重要的内容，至于其他的，Google可以解析和抓取您的JavaScript。</p><h2 id="f3c9" class="nq km iq bd kn nr of dn kr nt og dp kv jy oh nw kz kc oi ny ld kg oj oa lh ob bi translated">当然，经典SSR的SEO也有它的缺点:</h2><ul class=""><li id="8674" class="mt mu iq jp b jq lj ju lk jy ok kc ol kg om kk nj mz na nb bi translated">你必须镜像每条路线，你需要在后端搜索引擎优化</li><li id="df16" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">你必须将“相同的数据”传递给前端和API，有时感觉像是复制东西</li></ul><p id="a2ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">但是考虑到所有的事情</strong>，这项技术非常有效，我在一个非常大的应用程序的生产中使用了它。实际上，法国一家财富40强的公司carrefour.fr也在Vue JS和symfony(PHP)中使用了这种技术。</p><p id="64d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在某些情况下，您不需要为每个请求从服务器进行“动态”呈现。这就是詹姆斯塔克的用武之地。</strong></p><h1 id="cbb1" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">4.JAMStack又名静态站点生成又名预呈现</h1><p id="90ea" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这是我最喜欢的<strong class="jp ir">方法，但它并不适合所有情况。</strong></p><p id="cb05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么什么是JAMStack呢？这是一个奇特的词，指的是我们之前称之为<strong class="jp ir">静态网站</strong>的东西。</p><p id="044f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当网站创建时，我们只做纯HTML文件，这些文件总是返回相同的内容。这就是我们所说的<strong class="jp ir">静态内容</strong>。</p><p id="e3da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这有点麻烦，那时他们发明了“<strong class="jp ir">动态网站</strong>”，也就是我们之前所说的:服务器端渲染。</p><p id="b431" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">但是！在2008/2009年的某个时候，一些东西出现了，并在2011/2012年流行起来:Jekyll，静态站点生成器。</strong></p><p id="6e3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，它是一个Ruby应用程序，可以从你在<strong class="jp ir">构建时给它的路径定义和数据中生成静态文件。</strong></p><p id="0d2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们所说的:预渲染。</p><blockquote class="lo"><p id="fca9" class="lp lq iq bd lr ls lt lu lv lw lx kk dk translated">它只是静态文件，所以…它很快。非常快。</p></blockquote><p id="e811" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">这意味着，每次你需要用新的内容更新你的网站时，你必须重新下载网站。</p><blockquote class="lo"><p id="d6a0" class="lp lq iq bd lr ls lt lu lv lw lx kk dk translated">没什么大不了的。CI/CD是你的朋友。</p></blockquote><p id="cbc8" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">那JAMStack是什么？<strong class="jp ir"> JavaScript API标记</strong>。</p><p id="5970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JAMStack是预渲染的概念，但是是自动化和现代化的。</p><p id="99eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这是一个架构</strong>完全基于这样一个事实，即<strong class="jp ir">你将预呈现带有初始数据的标记</strong>，该标记将<strong class="jp ir">使用JavaScript带来交互，并最终从API</strong>(你的和/或其他的)获得更多数据。</p><p id="a603" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JAMStack架构中，您通常会使用一个前端框架来预呈现静态文件，这些文件随后会转到SPA。</p><p id="faeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这主要是基于这样一个事实，即通过带有CI/CD的webhooks，您可以在API中的任何数据变化时动态地重建页面。</p><p id="2c08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这真的很好，但是对于每天都有很多页面更新的网站/应用来说就不太好了。</p><p id="a819" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么？因为每次都会重新生成所有页面。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi on"><img src="../Images/0e225bc5e3a45f678712d14030d22295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*rlr6Ur0le7zrC4WH.png"/></div></div></figure><blockquote class="lo"><p id="807f" class="lp lq iq bd lr ls nl nm nn no np kk dk translated">这是最快的，最友好的搜索引擎优化和“最便宜”的方法。</p></blockquote><p id="8f28" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">您只需要您的API服务器、一个静态主机(Netlify、Vercel、S3、Firebase Hosting等)和一个用于重建的CI/CD系统，您很可能已经处理了测试或部署。</p><h2 id="f676" class="nq km iq bd kn nr of dn kr nt og dp kv jy oh nw kz kc oi ny ld kg oj oa lh ob bi translated">预渲染工具</h2><ul class=""><li id="6c88" class="mt mu iq jp b jq lj ju lk jy ok kc ol kg om kk nj mz na nb bi translated">Nuxt(是的，他们有一个选项):<a class="ae ni" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank">https://nuxtjs.org</a></li><li id="3d52" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">Gridesome(纯静态IMO最佳):<a class="ae ni" href="https://gridsome.org/" rel="noopener ugc nofollow" target="_blank">https://gridsome.org</a></li><li id="e332" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">vue press/vite press:<a class="ae ni" href="https://vuepress.vuejs.org/" rel="noopener ugc nofollow" target="_blank">vuepress.vuejs.org</a>/<a class="ae ni" href="https://vitepress.vuejs.org/" rel="noopener ugc nofollow" target="_blank">vitepress.vuejs.org</a></li><li id="8755" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">Poi +静态插件:<a class="ae ni" href="https://poi.js.org/guide/plugin-vue-static.html" rel="noopener ugc nofollow" target="_blank">https://poi.js.org/guide/plugin-vue-static.html</a></li></ul><p id="c78c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何其他SSG(静态网站生成器)将是好的，但是，你不会与那些不是Vue驱动的水化。</p><p id="e1d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">API:你可以创建你自己的API，但是，通常当你做JAMStack的时候，是为内容驱动的网站/webapps。这就是为什么我们经常使用我们所说的:<strong class="jp ir">无头CMSs。</strong></p><p id="e12d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">headless CMS是一个可以将HTTP APIs呈现为响应的CMS。</p><p id="8d90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多:Strapi，Directus (Node)，WordPress (yep it can)，Cockpit CMS (PHP)，Contentful，Dato，Prismic (hosted)…</p><p id="2ceb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到更多:<a class="ae ni" href="https://jamstack.org/headless-cms/" rel="noopener ugc nofollow" target="_blank">https://jamstack.org/headless-cms</a></p><h1 id="4688" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论:那么什么是最好的SEO方法呢？</h1><p id="b79f" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">没有灵丹妙药。这取决于你的堆栈，预算，团队，应用程序的类型和其他一些参数。</p><p id="7046" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，我会说:</p><ul class=""><li id="640f" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk nj mz na nb bi translated">如果你不太在乎:一个优化的水疗中心和Vue meta就可以了</li><li id="28ef" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">如果可以使用Node:做基于节点的SSR</li><li id="c78f" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">如果你不能使用Node:用初始数据渲染做经典SSR</li><li id="82e2" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nj mz na nb bi translated">如果你没有每日页面更新或者页面太多:JAMStack</li></ul><p id="c7a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。记住:做一件事从来没有唯一的方法。</p><p id="8e33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">坦克阅读。</p><p id="bc99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:如果你想要一些实时的Vue/前端新闻，注册我的时事通讯:<a class="ae ni" href="https://courses.maisonfutari.com" rel="noopener ugc nofollow" target="_blank">https://courses.maisonfutari.com</a></p></div></div>    
</body>
</html>