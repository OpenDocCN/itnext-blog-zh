<html>
<head>
<title>How to retry fails automation tests.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何重试失败的自动化测试。</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-retry-fails-automation-tests-af4884c47712?source=collection_archive---------1-----------------------#2021-06-08">https://itnext.io/how-to-retry-fails-automation-tests-af4884c47712?source=collection_archive---------1-----------------------#2021-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1266949dd31bdf6b9f53ac618c271b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TN5O6hrn1KC8UuojNrG0xg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">帕特里克·沃德的照片</figcaption></figure><p id="9b81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试自动化的最大问题是不断变化的定位器和不稳定的测试。一般来说，不稳定的测试仍然通常被称为俚语表达。有很多使用定位器的信息和方法。<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/the-concept-of-the-right-locator-for-selenium-webdriver-automated-scripts-5b8c6bf528e5">我在我的文章</a>中详细讨论了这一点。在本文中，我们将尝试处理不稳定测试的问题。</p><p id="715b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">福</span>湖泊试验。</p><p id="0941" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你没有古怪的测试，那么你正在做一些不真实的事情。古怪的测试是邪恶的。古怪的测试是一种痛苦。这是你必须奋斗几天，有时甚至几周的事情。</p><p id="afe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是最具体的例子:您在Selenium WebDriver中编写了一个自动化测试。我们运行了几次。已修复和调试。从你的角度来看，一切都很好。</p><p id="aec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将它添加到主测试中。运行完所有测试的第二天，它是绿色的。“很好，”你想。</p><p id="f607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">过了一段时间，这个测试失败了(不知什么原因)。<br/>代码没有改变，应用程序运行良好。您重新开始这个测试，它运行没有错误，一切正常。在几次构建之后，您会注意到这个测试的行为就像圣诞树上的灯泡一样——闪烁:<strong class="kf ir">失败，通过，失败，通过</strong> …</p><p id="0500" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">又该如何应对？答案一如既往地非常简单——你需要理解。正如他们所说，任何问题都有一个名、姓和父名。最糟糕的测试有时可能是由于注意力不集中。有些很容易找到。但有些，你必须处理相当长的时间。</p><p id="bef6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但有时我们的测试可能会因为我们无法控制的原因而失败。</p><p id="0d26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自动化测试失败的原因有很多:</p><ul class=""><li id="0d1a" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">不稳定的测试。</li><li id="f566" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">运行环境尚未准备好。</li><li id="d46d" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">一些框架问题。</li><li id="abae" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">环境绩效问题。</li><li id="38cc" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">诸如此类…</li></ul><p id="3381" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，很难理解根本原因。有时为了理解测试是绝对正确的，我们需要重新开始。而且只有在连续两次测试失败的情况下才能断定它是有故障的。</p><p id="31c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种情况通常会令人沮丧，并导致浪费时间不断查看错误。自动化结果中可能会出现误导的情况。当我们在所有这些之前添加重试机制时，我们可以通过使它们更加稳定来通过我们的测试。我知道实现这种方法的四种方法提供了一个极好的特性，使用它你可以在声明失败之前重试测试用例多次。这意味着，如果您发现失败，可以自动重新运行测试，以确保测试持续失败。这样可以减少由于随机问题导致的错误失败，并且您可以花更多的时间来调试真正的失败。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/e684ed720dbe8b32158e7f914ff3a884.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*YYk3rqn1ViYMoppjUCrhqg.png"/></div></figure><p id="ade6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> I </span> RetryAnalyzer。在文章的这一部分，我们将讨论如何使用<a class="ae kc" href="https://testng.org/doc/" rel="noopener ugc nofollow" target="_blank"> TestNG框架</a>。这个框架里有几个接口:IRetryAnalyzer，ITestListener，IReporter。为了实现失败测试的重启，TestNG允许您使用IRetryAnalyzer接口。这个接口提供了布尔方法retry，如果retry返回true，或者如果retry不返回false，那么retry负责重新启动测试。将测试结果(ITestResult result)传递给此方法。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="799e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是将您的测试用例与IRetryAnalyzer关联起来。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="9a1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">第四单元RetryRule。在本文的这一部分，我们将讨论JUnit 4规则的使用。该规则将重试几次失败的测试，这些测试是在测试之上的注释中提供的。这条规则背后的想法是减轻不可靠测试的影响。在JUnit测试框架中，允许您执行重试失败测试的类称为TestRule。该类将在不中断测试流的情况下重新运行失败的测试。</p><p id="b7cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个JUnit规则的真实例子。此规则将重试失败的测试:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d0dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要创建Junit规则来根据规则运行:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ecc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们需要规则中的一个整数值来计算我们需要重试测试的次数:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="00b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> J </span>单元5—<em class="mf">@重复测试</em>。在本文的这一部分，我们将看看JUnit 5中引入的<a class="ae kc" href="http://twitter.com/RepeatedTest" rel="noopener ugc nofollow" target="_blank"> @RepeatedTest </a>注释。它为我们提供了一个强大的方法来编写任何我们想要重复几次的测试。</p><p id="e531" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建重复测试很简单——只需在测试方法上添加<a class="ae kc" href="http://twitter.com/RepeatedTest" rel="noopener ugc nofollow" target="_blank"> @RepeatedTest </a>注释:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="47e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，您可能会使用额外的功能。除了指定重复次数之外，您还可以为每个重复提供一个自定义的显示名称。该自定义显示名称可以是静态文本+动态占位符的组合。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="c5ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">测试重试梯度插件</strong>。在文章的这一部分，我们将讨论Gradle插件。Gradle有一个很棒的插件<a class="ae kc" href="https://github.com/gradle/test-retry-gradle-plugin" rel="noopener ugc nofollow" target="_blank">可以帮助你处理不稳定的测试。它看起来很有趣，制作也很聪明。你不需要改变测试代码，只需将插件添加到Gradle并运行测试。</a></p><p id="7c84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用这种梯度配置来重试测试，并且可以选择使构建失败:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="b77e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个插件有4个特别好的方面:</p><ol class=""><li id="f0a5" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la mg lq lr ls bi translated">不需要改变测试源。这允许<em class="mf">主动检测</em>新的片状测试！</li><li id="0ea8" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la mg lq lr ls bi translated">您可以使用<code class="fe mh mi mj mk b">failOnPassedAfterRetry</code>控制当遇到剥落时您的构建是失败还是通过。这意味着您可以采用这个插件来检测不稳定的测试，而不会使它们静音。</li><li id="00ba" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la mg lq lr ls bi translated">您可以使用<code class="fe mh mi mj mk b">maxFailures</code>来防止在离散数量的测试失败后在测试运行中重试。如果您的构建遇到许多失败，很可能是有一个主要问题导致许多测试失败，重试是对资源的浪费。</li><li id="ecd0" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la mg lq lr ls bi translated">尽可能在方法级别或更精细的级别重试测试——无需重新运行整个测试类。</li></ol><h1 id="ee20" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">结论。</h1><p id="3d3c" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">新的重试特性非常适合开发一组测试包或场景，在这些测试包或场景中，预期的结果是全部通过。通过定期执行所有的通过测试包，如果在最终结果中有任何失败，可以快速和容易地识别问题。重试功能可以通过最大限度地减少由于随机数据包丢失而可能发生的间歇性故障来增强这一过程。当重试特性被启用时，最终结果中的任何失败都表明一个特定的测试用例或功能块一直失败，可能需要进一步的调查。</p><p id="ef87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们研究了JUnit和TestNg提供的用于重复测试的注释，并了解了配置它们的不同方法。如果你问我你更喜欢在你的框架中使用什么，我毫无疑问地推荐你使用来自gradle的<strong class="kf ir">测试-重试-Gradle-插件</strong>。我每天都在我的项目中使用这个插件。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/37405c6bd9906e7572c1b5d0f490ca04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Lu3G8OVrxTr-BOSOHvP5Gw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">【https://test-engineer.site/ T4】</figcaption></figure><h1 id="dafb" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">作者<a class="ae kc" href="https://www.linkedin.com/in/vaskocuturilo/" rel="noopener ugc nofollow" target="_blank">安东·斯米尔诺夫</a></h1></div></div>    
</body>
</html>