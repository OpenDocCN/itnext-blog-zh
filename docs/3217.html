<html>
<head>
<title>Classes and Inheritance: JavaScript ES6 Feature Series (Pt 8)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类和继承:JavaScript ES6特性系列(第8部分)</h1>
<blockquote>原文：<a href="https://itnext.io/classes-and-inheritance-javascript-es6-feature-series-part-8-4a81fa3adf0f?source=collection_archive---------0-----------------------#2019-10-27">https://itnext.io/classes-and-inheritance-javascript-es6-feature-series-part-8-4a81fa3adf0f?source=collection_archive---------0-----------------------#2019-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="5f31" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">原型还在…引擎盖下</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/38cc522e25fc8586140b88cc63b47849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8oizSt7FN1cx4W0j43CFw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">埃里克·麦克林在<a class="ae lb" href="https://unsplash.com/s/photos/open-hood-of-car?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="ead6" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">介绍</h1><p id="db1f" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi mm translated">这些作品背后的灵感很简单:仍然有很多开发人员对JavaScript感到有点困惑——或者至少在行为上有些古怪。</p><p id="8c39" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">尽管如此，根据维基百科<a class="ae lb" href="https://en.wikipedia.org/wiki/JavaScript" rel="noopener ugc nofollow" target="_blank">的数据，JavaScript为1000万个最受欢迎的网页中的95%提供了动力。</a></p><p id="3c8a" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">由于它的使用量和受欢迎程度不断增加，我想提供一些我经常使用的ES6+特性的文章和例子，供其他开发人员参考。</p><p id="6282" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">我们的目标是让这些文章简短、深入地解释对该语言的各种改进，我希望它们能启发您使用JS编写一些真正酷的东西。谁知道呢？在这个过程中，你甚至可能会学到一些新东西。😄</p><blockquote class="na"><p id="86c6" class="nb nc iq bd nd ne nf ng nh ni nj ml dk translated">在我的第八篇博文中，我将深入探讨JavaScript类和基于类的继承，这是处理JavaScript现有的基于原型的继承系统的更简洁、更直接的方法。</p></blockquote></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="b071" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">在有类之前，就有了原型</h1><p id="926b" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">在谈到JavaScript类之前，我必须先谈谈<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">原型</a>——JavaScript对象相互继承特性的原始机制。</p><p id="8544" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">深入研究prototype对象和基于原型的继承如何工作已经超出了这篇博客的范围，但是我会给你一个简要的概述。</p><p id="b516" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">JavaScript中的每个对象都有一个<strong class="lq ir">原型对象</strong>，它作为一个模板继承方法和属性。同一个原型对象也可能有一个它继承的原型对象，等等。这有时被称为<strong class="lq ir">原型链</strong>。</p><p id="5f75" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">当在对象上调用属性或方法时，浏览器首先检查实际对象上是否有该方法，如果没有，则通过原型对象检查该方法是否可用。如果该方法没有在对象的个人构造器上定义(它的原型对象来自那里)，浏览器检查另一个级别，看看<em class="nk">构造器的</em>原型对象是否有可用的方法。浏览器将一直这样做，直到到达以<code class="fe nl nm nn no b">null</code>为原型的顶部对象。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="51a3" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">嗯…？</p><p id="e742" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">看看这个例子，这应该有助于说明我所说的。</p><p id="02fd" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">传统的基于原型的继承的例子</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="21bb" class="nv jo iq no b gy nw nx l ny nz">function Superhero(superName, realName, powers){<br/>  this.superName = superName,<br/>  this.realName = realName,<br/>  this.powers = powers<br/>}</span><span id="125f" class="nv jo iq no b gy oa nx l ny nz">const wonderWoman = new Superhero('Wonder Woman', 'Diana Prince', 'Strength and flight');</span><span id="75a3" class="nv jo iq no b gy oa nx l ny nz">console.log(wonderWoman); /* Superhero {<br/>  superName: 'Wonder Woman',<br/>  realName: 'Diana Prince',<br/>  powers: 'Strength and flight' } */</span><span id="2ff2" class="nv jo iq no b gy oa nx l ny nz">Superhero.prototype.equipment = 'Lasso of truth';</span><span id="03ae" class="nv jo iq no b gy oa nx l ny nz">console.log(wonderWoman.realName); // Diana Prince</span><span id="1a37" class="nv jo iq no b gy oa nx l ny nz">console.log(wonderWoman.equipment); // Lasso of truth</span><span id="609e" class="nv jo iq no b gy oa nx l ny nz">console.log(wonderWoman.catchPhrase); // undefined</span><span id="d4dd" class="nv jo iq no b gy oa nx l ny nz">console.log(wonderWoman.hasOwnProperty('equipment')); // false</span><span id="a434" class="nv jo iq no b gy oa nx l ny nz">console.log(Superhero.hasOwnProperty('equipment')); // false</span><span id="b49d" class="nv jo iq no b gy oa nx l ny nz">console.log(Superhero.prototype.hasOwnProperty('equipment')); // true</span></pre><p id="5214" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">上面的例子是一个名为<code class="fe nl nm nn no b">Superhero</code>的构造函数，它定义了一个新的超级犯罪斗士。</p><p id="8f5a" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">我创造了<code class="fe nl nm nn no b">wonderWoman</code>，给了她<code class="fe nl nm nn no b">superName</code>、<code class="fe nl nm nn no b">realName</code>、<code class="fe nl nm nn no b">powers</code>的属性。然后，我给<code class="fe nl nm nn no b">Superhero</code>的原型对象添加了一个名为<code class="fe nl nm nn no b">equipment</code>的属性，值为<code class="fe nl nm nn no b">'Lasso of truth'</code>。</p><p id="f4b4" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">当我调用对象的<code class="fe nl nm nn no b">realName</code>属性时，在对象本身上发现了<code class="fe nl nm nn no b">"Diana Prince”</code>。当我调用<code class="fe nl nm nn no b">equipment</code>时，<code class="fe nl nm nn no b">"Lasso of truth”</code>是在对象构造器的原型上找到的。当我试图调用属性<code class="fe nl nm nn no b">catchPhrase</code>时，它返回为<code class="fe nl nm nn no b">undefined</code>，因为在原型链中不存在该属性。</p><p id="b8f2" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">我检查<code class="fe nl nm nn no b">'equipment'</code>的<code class="fe nl nm nn no b">wonderWoman.hasOwnProperty()</code>和<code class="fe nl nm nn no b">Superhero.hasOwnProperty()</code>是否都返回<code class="fe nl nm nn no b">false</code>，但是<code class="fe nl nm nn no b">Superhero.<em class="nk">prototype</em>.hasOwnProperty('equipment')</code>返回true，这一行证明了这一点。</p><p id="61ac" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">简而言之，这就是JavaScript基于原型的继承。请记住，当我们使用基于类的语法时，这是在后台发生的事情。</p><p id="e0b1" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">现在让我们开始新的ES6课程。</p><h1 id="446a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">然后上课了</h1><p id="e2eb" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">与其他面向对象编程(OOP)语言(如Java)不同，Java一直是基于类的，JavaScript选择原型作为其处理继承的方式，但随着ECMAScript 2015的发布，类被引入到语言的语法中。</p><p id="96c8" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">不过让我绝对明确地说:<strong class="lq ir">类只是JavaScript现有的基于原型的继承</strong>的语法糖衣。它们不是新的面向对象继承模型。</p><p id="04c1" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank">类</a>可能被定义为“特殊函数”，就像我在这里写的关于<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/arrow-functions-javascript-es6-feature-series-pt-2-e8c31c823392">的所有函数一样，它们可以用两种方式定义:类表达式和类声明。</a></p><h2 id="da71" class="nv jo iq bd jp ob oc dn jt od oe dp jx lz of og kb md oh oi kf mh oj ok kj ol bi translated">类声明</h2><p id="a6df" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">定义类的第一种方法是使用<strong class="lq ir">类声明</strong>。要声明一个类，可以在类名中使用<code class="fe nl nm nn no b">class</code>关键字。</p><p id="7889" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">类声明的例子</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="ee64" class="nv jo iq no b gy nw nx l ny nz">class Book {<br/>  constructor(title, author) {<br/>    this.title = title;<br/>    this.author = author;<br/>  }<br/>}</span><span id="10a2" class="nv jo iq no b gy oa nx l ny nz">const novel = new Book('Moby Dick', 'Herman Melville');</span><span id="af43" class="nv jo iq no b gy oa nx l ny nz">console.log(novel); // Book { title: 'Moby Dick', author: 'Herman Melville' }</span></pre><p id="3d66" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">需要注意的一点是，与函数声明不同的是，<strong class="lq ir">类声明没有被悬挂</strong>。你必须首先声明你的类，然后访问它，否则你会得到一个<code class="fe nl nm nn no b">ReferenceError</code>抛出。</p><h2 id="11f4" class="nv jo iq bd jp ob oc dn jt od oe dp jx lz of og kb md oh oi kf mh oj ok kj ol bi translated">类别表达式</h2><p id="650d" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">另一种定义类的方法是使用<strong class="lq ir">类表达式</strong>。类表达式可以是命名的，也可以是未命名的。如果一个类表达式是命名的，那么命名的类表达式的名字是局部的。</p><p id="51e1" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">未命名和已命名的类表达式示例</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="2d28" class="nv jo iq no b gy nw nx l ny nz">// unnamed class expression<br/>let Drama = class {<br/>  constructor(title, author){<br/>    this.title = title;<br/>    this.author = author;<br/>  }<br/>};</span><span id="86c3" class="nv jo iq no b gy oa nx l ny nz">console.log(Drama.name); // Drama</span><span id="6ad1" class="nv jo iq no b gy oa nx l ny nz">// named class expression<br/>let Comedy = class Book2 {<br/>  constructor(title, author){<br/>    this.title = title;<br/>    this.author = author;<br/>  }<br/>};</span><span id="a7e5" class="nv jo iq no b gy oa nx l ny nz">console.log(Comedy.name); // Book2</span></pre><p id="f63a" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">好了，创建类的基础已经介绍完毕，是时候深入到本质细节了。</p><h1 id="6af7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">类体和方法定义</h1><p id="2eed" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">再次类似于函数，类的主体是包含在<code class="fe nl nm nn no b">{}</code>中的部分。这里是定义类成员如构造函数和方法的地方。</p><h2 id="b50b" class="nv jo iq bd jp ob oc dn jt od oe dp jx lz of og kb md oh oi kf mh oj ok kj ol bi translated">严格模式</h2><p id="0845" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">你需要知道的第一件事是，类的主体总是在<code class="fe nl nm nn no b">strict mode</code>中执行。</p><p id="4c01" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">这意味着，为了提高性能，这里编写的代码需要遵循更严格的语法，一些原本不引人注意的错误将被抛出，某些关键字被保留给ECMAScript的未来版本。</p><p id="56a8" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">如果您一直在使用任何较新的React、Angular或Vue框架，那么您可能已经在默认的严格模式下进行开发了，所以这不会对您的开发方式造成太大的改变。</p><h2 id="b943" class="nv jo iq bd jp ob oc dn jt od oe dp jx lz of og kb md oh oi kf mh oj ok kj ol bi translated">构造函数</h2><p id="2cd7" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">在类的剖析中，下一步可能是构造函数。<code class="fe nl nm nn no b">constructor</code>方法是创建和初始化用<code class="fe nl nm nn no b">class</code>创建的对象的特殊方法。每个类中只能有一个名为“constructor”的特殊方法。如果一个类包含不止一次出现的<code class="fe nl nm nn no b">constructor</code>方法，将抛出一个<code class="fe nl nm nn no b">SyntaxError</code>。</p><p id="c358" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">构造函数也可以使用<code class="fe nl nm nn no b">super</code>关键字来调用超类的构造函数，但是我将在这篇文章的后面更详细地讨论这一点。</p><h2 id="b4b4" class="nv jo iq bd jp ob oc dn jt od oe dp jx lz of og kb md oh oi kf mh oj ok kj ol bi translated">原型方法</h2><p id="ac1c" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">原型方法也被称为<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" rel="noopener ugc nofollow" target="_blank">方法定义</a>，它们是分配给方法名称的函数的简写。这些往往构成了班级的主体。</p><p id="9967" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">一个类的原型方法的例子</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="8e01" class="nv jo iq no b gy nw nx l ny nz">class Book {<br/>  constructor(title, author){<br/>    this.title = title;<br/>    this.author = author;<br/>  }</span><span id="e778" class="nv jo iq no b gy oa nx l ny nz">  publicizeBook() {<br/>    return `This book ${this.title} is written by renowned author ${this.author}.`;<br/>  }<br/>}</span><span id="3c50" class="nv jo iq no b gy oa nx l ny nz">const novel = new Book('Harry Potter', 'J.K. Rowling');</span><span id="70bb" class="nv jo iq no b gy oa nx l ny nz">console.log(novel.publicizeBook()); // This book Harry Potter is written by renowned author J.K. Rowling.</span><span id="c8d4" class="nv jo iq no b gy oa nx l ny nz">console.log(Book.prototype.hasOwnProperty('publicizeBook')); // true</span></pre><p id="f7d0" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">对于这个类<code class="fe nl nm nn no b">Book</code>，方法<code class="fe nl nm nn no b">publicizeBook()</code>被定义在它上面，所以任何用类<code class="fe nl nm nn no b">Book</code>创建的对象，也将自动拥有对它们可用的原型方法<code class="fe nl nm nn no b">publicizeBook()</code>。</p><p id="926c" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">并检查示例中的最后一行。我通过测试<code class="fe nl nm nn no b">Book</code>的原型对象<code class="fe nl nm nn no b">.hasOwnProperty('publicizeBook')</code>来检查<code class="fe nl nm nn no b">Book</code>类是否拥有<code class="fe nl nm nn no b">publicizeBook()</code>方法，它返回<code class="fe nl nm nn no b">true</code>。这表明它实际上是基于原型的继承发生在底层。</p><p id="2f72" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">开始有意义了吗？</p><h2 id="d7cf" class="nv jo iq bd jp ob oc dn jt od oe dp jx lz of og kb md oh oi kf mh oj ok kj ol bi translated">静态方法</h2><p id="8bfe" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">当您使用<code class="fe nl nm nn no b">static</code>关键字时，它既可以应用于一个方法，也可以应用于一个类。静态方法在没有实例化它们的类的情况下被调用，并且<strong class="lq ir">不能通过类实例被调用。这些类型的方法通常用于为应用程序创建实用函数。</strong></p><p id="72d6" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">一个类的静态方法的例子</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="249e" class="nv jo iq no b gy nw nx l ny nz">class Book {<br/>  constructor(title, author){<br/>    this.title = title;<br/>    this.author = author;<br/>  }</span><span id="ba64" class="nv jo iq no b gy oa nx l ny nz">  static youMightLike(title, similarTitle) {<br/>    return `If you like ${title}, you might also like ${similarTitle}.`<br/>  }<br/>}</span><span id="6d73" class="nv jo iq no b gy oa nx l ny nz">const novel = new Book('Moby Dick', 'Herman Melville');</span><span id="4e8e" class="nv jo iq no b gy oa nx l ny nz">console.log(novel.youMightLike); // undefined</span><span id="01e5" class="nv jo iq no b gy oa nx l ny nz">console.log(Book.youMightLike(novel.title, "A Midsummer Night's Dream")); // If you like Moby Dick, you might also like A Midsummer Night's Dream.</span></pre><p id="c70d" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">在这个例子中，如果您试图在实际的基于类的对象<code class="fe nl nm nn no b">novel</code>上调用静态方法<code class="fe nl nm nn no b">youMightLike()</code>，您只能得到一个<code class="fe nl nm nn no b">undefined</code>值。然而，如果你在类<code class="fe nl nm nn no b">Book</code>上用两个参数调用它，你将得到一个基于另一本书推荐一本书的响应。</p><h2 id="0574" class="nv jo iq bd jp ob oc dn jt od oe dp jx lz of og kb md oh oi kf mh oj ok kj ol bi translated">当心用原型和静态方法装箱</h2><p id="65f0" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">当一个方法，不管是静态的还是非静态的，在没有分配给它的<code class="fe nl nm nn no b">this</code>值的情况下被调用时，在该方法中的<code class="fe nl nm nn no b">this</code>值将是<code class="fe nl nm nn no b">undefined</code>。这是因为类的主体总是在<code class="fe nl nm nn no b">strict mode</code>中运行，不管它是否被显式设置。</p><p id="330a" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">类内未定义“this”的示例</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="5b56" class="nv jo iq no b gy nw nx l ny nz">class Dog {<br/>  eat() {<br/>    return this;<br/>  }<br/>  <br/>  static speak() {<br/>    return this;<br/>  }<br/>}</span><span id="b7df" class="nv jo iq no b gy oa nx l ny nz">let shibaInu = new Dog();<br/>console.log(shibaInu.eat()); // Dog {}</span><span id="94e5" class="nv jo iq no b gy oa nx l ny nz">let chowDown = shibaInu.eat;<br/>console.log(chowDown); // undefined</span><span id="e6aa" class="nv jo iq no b gy oa nx l ny nz">console.log(Dog.speak.toString()); // Class Dog<br/>let greet = Dog.speak;<br/>console.log(greet); // undefined</span></pre><p id="47b9" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">如果用传统的基于函数的语法编写上面的类，那么方法调用中的自动装箱将基于初始的<code class="fe nl nm nn no b">this</code>值以非严格模式发生。如果初始值是<code class="fe nl nm nn no b">undefined</code>，<code class="fe nl nm nn no b">this</code>将被设置为全局对象。</p><p id="4c77" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">示例</em> <code class="fe nl nm nn no b"><em class="nk">this</em></code> <em class="nk">如果没有分配函数</em>则取全局范围</p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="74f4" class="nv jo iq no b gy nw nx l ny nz">function Dog() { };</span><span id="c6f9" class="nv jo iq no b gy oa nx l ny nz">Dog.prototype.eat = function() {<br/>  return this;<br/>}</span><span id="868f" class="nv jo iq no b gy oa nx l ny nz">Dog.speak = function() {<br/>  return this;<br/>}</span><span id="5847" class="nv jo iq no b gy oa nx l ny nz">let husky = new Dog();<br/>console.log(husky.eat()); // Dog {}</span><span id="9745" class="nv jo iq no b gy oa nx l ny nz">let munch = husky.eat;<br/>console.log(munch()); // global object (long list of available options)</span><span id="9ef7" class="nv jo iq no b gy oa nx l ny nz">let bark = Dog.speak;<br/>console.log(bark()); // global object again (long list of available options)</span></pre><p id="dd43" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">只是要意识到类和函数之间的这一点点差别，这样它就不会在几个小时内不知不觉地绊倒你。</p><h2 id="becd" class="nv jo iq bd jp ob oc dn jt od oe dp jx lz of og kb md oh oi kf mh oj ok kj ol bi translated">实例属性</h2><p id="9f64" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">实例属性必须在类方法内部定义。</p><p id="a19c" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">类</em>中定义的实例属性示例</p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="6e43" class="nv jo iq no b gy nw nx l ny nz">class Cat {<br/>  constructor(eats, sleeps){<br/>    this.eats = eats;<br/>    this.sleeps = sleeps;<br/>  }<br/>  <br/>  knocksThingsOver(obj) {<br/>    return `Woops, the cat just knocked ${obj} over...`<br/>  }<br/>}</span></pre><p id="dc5f" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">虽然静态数据属性和原型数据属性必须在类体声明之外定义:</p><p id="164e" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">定义静态数据的示例&amp;原型数据属性</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="882f" class="nv jo iq no b gy nw nx l ny nz">Cat.plays = true;</span><span id="6bb6" class="nv jo iq no b gy oa nx l ny nz">Cat.prototype.eatsCatnip = 'Goes nuts for it';</span></pre><h2 id="1aaa" class="nv jo iq bd jp ob oc dn jt od oe dp jx lz of og kb md oh oi kf mh oj ok kj ol bi translated">字段声明(仍处于试验阶段)</h2><p id="aaf5" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">这些下一个特性:公共和私有字段声明仍处于试验阶段(第3阶段)，由JavaScript标准委员会在TC39上提出。但是它们仍然值得了解，因为它们可能很快就会成为标准语法。</p><p id="016b" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">到目前为止，浏览器中的原生支持是有限的，但是这个特性可以通过一个构建步骤用于像Babel这样的系统，这要归功于您的Webpack配置。</p><p id="1057" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><strong class="lq ir">公开声明</strong></p><p id="ed36" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">使用JavaScript字段声明语法，前面的<code class="fe nl nm nn no b">Cat</code>示例可以写成这样。</p><p id="985a" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">类中公共声明的例子</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="20f2" class="nv jo iq no b gy nw nx l ny nz">class Cat {<br/>  eats = 'mice';<br/>  sleeps;</span><span id="91ca" class="nv jo iq no b gy oa nx l ny nz">  constructor(eats, sleeps){<br/>    this.eats = eats;<br/>    this.sleeps = sleeps;<br/>  }</span><span id="cc44" class="nv jo iq no b gy oa nx l ny nz">  knocksThingsOver(obj) {<br/>    return `Woops, the cat just knocked ${obj} over...`<br/>  }<br/>}</span></pre><p id="f155" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">通过预先声明字段，类定义变得更加自文档化，并且字段总是存在的。同样酷的是，字段可以声明有或没有默认值，就像函数中的默认值一样，我在这里写了关于<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/default-function-parameter-values-javascript-es6-feature-series-pt-3-bd8392a88a12">的内容。</a></p><p id="5f24" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><strong class="lq ir">私下声明</strong></p><p id="64f6" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">私有声明与公共声明在语法上没有太大的不同。但它们在用法和执行上略有不同。</p><p id="79ab" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">私有字段只能在字段声明中预先声明。它们不能像普通属性那样在以后通过赋值来创建。</p><p id="2fcf" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">从类外部引用私有字段也是错误的；它们只能在类体内读取或写入。通过定义在类外部不可见的东西，你可以确保你的类的用户不能依赖于内部，这可能会改变版本。</p><p id="9fb0" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">类中私有声明的例子</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="de95" class="nv jo iq no b gy nw nx l ny nz">class Cat {<br/>  #eats = 'mice';<br/>  #sleeps;</span><span id="e18e" class="nv jo iq no b gy oa nx l ny nz">constructor(eats, sleeps){<br/>    this.#eats = eats;<br/>    this.#sleeps = sleeps;<br/>  }</span><span id="bbc5" class="nv jo iq no b gy oa nx l ny nz">knocksThingsOver(obj) {<br/>    return `Woops, the cat just knocked ${obj} over...`<br/>  }<br/>}</span></pre><p id="28b4" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">就像我之前说的，还没有广泛使用，我可能不会把它投入生产，但在未来的ES版本中要注意这些。</p><h1 id="6efa" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">带有“扩展”的子类</h1><p id="5f13" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">在<em class="nk">类声明</em>或<em class="nk">类表达式</em>中使用<code class="fe nl nm nn no b">extends</code>关键字来创建一个类作为另一个类的子类。</p><p id="5576" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">将一个类扩展为子类的例子</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="34c3" class="nv jo iq no b gy nw nx l ny nz">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="8a10" class="nv jo iq no b gy oa nx l ny nz">  speak() {<br/>    console.log(`${this.name} makes a noise`);<br/>  }<br/>}</span><span id="b037" class="nv jo iq no b gy oa nx l ny nz">class Horse extends Animal {<br/>  constructor(name) {<br/>    super(name);<br/>  }</span><span id="c8ed" class="nv jo iq no b gy oa nx l ny nz">  speak() {<br/>    console.log(`${this.name} whinnies.`)<br/>  }<br/>}</span><span id="6a1b" class="nv jo iq no b gy oa nx l ny nz">let thoroughbred = new Horse('Seabiscuit');<br/>console.log(thoroughbred.speak()); // Seabiscuit whinnies.</span></pre><p id="6c20" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">类<code class="fe nl nm nn no b">Horse</code>扩展了另一个类<code class="fe nl nm nn no b">Animal</code>，以接受它的方法，由于<code class="fe nl nm nn no b">Horse</code>也有自己的构造函数，它需要在引用<code class="fe nl nm nn no b">this</code>之前调用<code class="fe nl nm nn no b">super()</code>。</p><p id="9b16" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">如果你曾经使用过React的基于类的组件，那么<code class="fe nl nm nn no b">extends</code>的语法非常类似于React的基于类的组件。</p><p id="89a3" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk"> React基于类的组件语法</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="5d72" class="nv jo iq no b gy nw nx l ny nz">import React, { Component } from 'react';</span><span id="c217" class="nv jo iq no b gy oa nx l ny nz">class Nav extends Component {<br/>  // ...do something<br/>}</span></pre><p id="7c80" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">同样值得注意的是，当父类和子类的方法命名相似时，子类的方法在调用时优先于父类的方法。</p><h1 id="2c5c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用“Super”的超级类调用</h1><p id="619a" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">现在我们回到上面提到过几次的那个<code class="fe nl nm nn no b">super</code>关键词。<code class="fe nl nm nn no b">super</code>关键字用于调用超类的相应方法。与基于原型的继承相比，这是一个明显的优势，因为从技术上来说，父类和子类的两个方法都可以通过使用<code class="fe nl nm nn no b">super</code>而不是一个或另一个来调用。</p><p id="e8e9" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated"><em class="nk">从子类访问父类方法的例子</em></p><pre class="km kn ko kp gt nr no ns nt aw nu bi"><span id="f186" class="nv jo iq no b gy nw nx l ny nz">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="35a8" class="nv jo iq no b gy oa nx l ny nz">  speak() {<br/>    console.log(`${this.name} makes a noise`);<br/>  }<br/>}</span><span id="41dd" class="nv jo iq no b gy oa nx l ny nz">class Hippo extends Animal {<br/>  speak() {<br/>    super.speak();<br/>    console.log(`${this.name} roars.`);<br/>  }<br/>}</span><span id="649b" class="nv jo iq no b gy oa nx l ny nz">let hippo = new Hippo('Bertha');<br/>console.log(hippo.speak()); // Bertha makes a noise.<br/>// Bertha roars.</span></pre><p id="60fe" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">在这个例子中，<code class="fe nl nm nn no b">Hippo</code>的<code class="fe nl nm nn no b">speak()</code>方法实际上调用了<code class="fe nl nm nn no b">Animal</code>的<code class="fe nl nm nn no b">speak()</code>方法以及它自己唯一的方法，只需在<code class="fe nl nm nn no b">Hippo</code>的<code class="fe nl nm nn no b">speak()</code>中使用<code class="fe nl nm nn no b">super.speak()</code>即可。</p><p id="6ba5" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">这就是<code class="fe nl nm nn no b">super</code>的全部内容，一旦展示了一些例子，事情就没那么复杂了。对吗？</p><p id="3728" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">这是用JavaScript开发时，你需要知道的关于类的最重要的部分。干得好，坚持到了这篇文章的结尾！😃</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="98cf" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">结论</h1><p id="4350" class="pw-post-body-paragraph lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">类在其他编程语言中已经存在了几十年，JavaScript最终(在某种程度上)随着ES 2015的发布而出现。尽管JavaScript中的类在语法上看起来和其他OOP语言一样，但它仍然是真正基于原型的继承。</p><p id="0c65" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">对于我们所有熟悉传统原型对象的人来说，这种思考方法和属性的新方式可能需要一点时间来适应，但是类提供了一些非常棒的改进，使我们的开发生活变得更加容易，我希望您能亲自尝试一下。</p><p id="c8c1" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">我这个系列的目的是深入解释您每天使用的ES6语法，以便您可以使用它们来获得最大的影响并避免常见的陷阱。</p><p id="80e6" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">过几周再来看看，我会写更多关于JavaScript和ES6或其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="7c88" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">感谢您的阅读，我希望您能在JavaScript中给ES6 class-syntax一个机会，让原型继承更容易。</p><p id="5334" class="pw-post-body-paragraph lo lp iq lq b lr mv lt lu lv mw lx ly lz mx mb mc md my mf mg mh mz mj mk ml ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我在这个系列中的其他一些博客:</p><ul class=""><li id="ff26" class="om on iq lq b lr mv lv mw lz oo md op mh oq ml or os ot ou bi translated"><a class="ae lb" href="https://medium.com/better-programming/built-in-module-imports-and-exports-javascript-es6-feature-series-part-7-5f0864049e1f" rel="noopener">内置模块导入导出:JavaScript ES6特性系列(第七部分)</a></li><li id="3d57" class="om on iq lq b lr ov lv ow lz ox md oy mh oz ml or os ot ou bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/enhanced-object-literal-value-shorthand-javascript-es6-feature-series-pt-6-e00dfdc24f64">增强的对象文字值速记:JavaScript ES6特性系列(Pt 6) </a></li><li id="f91a" class="om on iq lq b lr ov lv ow lz ox md oy mh oz ml or os ot ou bi translated"><a class="ae lb" href="https://medium.com/better-programming/string-template-literals-javascript-es6-feature-series-pt-5-a40e55a5485b" rel="noopener">字符串模板文字:JavaScript ES6特性系列(Pt 5) </a></li><li id="4efb" class="om on iq lq b lr ov lv ow lz ox md oy mh oz ml or os ot ou bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/spread-rest-parameters-javascript-es6-feature-series-pt-4-c9e9f0c0228f"> Spread &amp; Rest参数:JavaScript ES6特性系列(Pt 4) </a></li><li id="24b1" class="om on iq lq b lr ov lv ow lz ox md oy mh oz ml or os ot ou bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/default-function-parameter-values-javascript-es6-feature-series-pt-3-bd8392a88a12">默认函数参数值:JavaScript ES6特性系列(Pt 3) </a></li><li id="720f" class="om on iq lq b lr ov lv ow lz ox md oy mh oz ml or os ot ou bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/arrow-functions-javascript-es6-feature-series-pt-2-e8c31c823392">箭头功能:JavaScript ES6特性系列(第二部分)</a></li><li id="f183" class="om on iq lq b lr ov lv ow lz ox md oy mh oz ml or os ot ou bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/var-let-const-javascript-es6-feature-series-pt-1-fa603567809e"> Var，Let &amp; Const: JavaScript ES6特性系列(Pt 1) </a></li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="7551" class="jn jo iq bd jp jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk bi translated">参考资料和更多资源</h1><ul class=""><li id="fd81" class="om on iq lq b lr ls lv lw lz pa md pb mh pc ml or os ot ou bi translated">对象原型，MDN文档:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Learn/JavaScript/Objects/Object _ prototypes</a></li><li id="af9e" class="om on iq lq b lr ov lv ow lz ox md oy mh oz ml or os ot ou bi translated">类，MDN文档:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Classes</a></li></ul></div></div>    
</body>
</html>