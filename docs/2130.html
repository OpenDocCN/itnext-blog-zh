<html>
<head>
<title>React Hooks — designing a simple forms API — part 4 — scaling to other input types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react Hooks——设计简单的表单API——第4部分——扩展到其他输入类型</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-designing-a-simple-forms-api-part-4-scaling-to-other-input-types-e738db0a3fc3?source=collection_archive---------2-----------------------#2019-04-05">https://itnext.io/react-hooks-designing-a-simple-forms-api-part-4-scaling-to-other-input-types-e738db0a3fc3?source=collection_archive---------2-----------------------#2019-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5c097df4430f936fba4d29ae3221e6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*heeHCiebxY3rC44y-q6wWA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">下面是我们将在第4部分中构建的表单元素</figcaption></figure><p id="e6d7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本文中，我们将回过头来回答这个问题“我们的表单API会支持今天的大多数标准表单吗？”而这个问题的答案是，绝对不行！单选按钮、复选框、多选等。将无法正常工作。我们有一个很好的设计，但我们需要验证它是否可以扩展到支持其他输入类型。所以这将是我们这篇文章的目标。</p><p id="534b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本系列的第1部分中，我们研究了如何使用React钩子来设计一个React表单库。第1部分介绍了这个库的动机和一些总体设计目标。</p><p id="b83f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本系列的第2部分<a class="ae ld" href="https://medium.com/@shanplourde/react-hooks-designing-a-simple-forms-api-part-2-1fe5d12f23d9" rel="noopener">中，我们创建了一个<code class="fe le lf lg lh b">useInput</code>钩子，将其集成到我们的<code class="fe le lf lg lh b">useForm</code>钩子中，回顾了我们的解决方案的状态管理，合并了一些额外的测试，并且更详细地回顾了测试策略。</a></p><p id="f5a1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在第3部分中，我们讨论了验证、异步验证和异步表单提交。它为我们提供了基于React hooks的表单API的关键元素。</p><h1 id="4af7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">工作示例</h1><p id="6098" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">让我们来看看这一部分将包含的所有内容的演示。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">示例表单展示了我们将在第4部分中开发的所有表单特性</figcaption></figure><p id="26f6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae ld" href="https://github.com/shanplourde/react-hooks-form-util" rel="noopener ugc nofollow" target="_blank">完整的解决方案可以在我的github </a>中找到。演示中有很多样板文件，但我希望在这一点上有非常明确的例子。请注意，由于CodeSandbox设计决定不支持从<code class="fe le lf lg lh b">package.json</code>加载<code class="fe le lf lg lh b">devDependencies</code>，测试在此时没有通过CodeSandbox。</p><h1 id="22cb" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">设计公共API以支持其他输入类型</h1><p id="8217" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">此时，<code class="fe le lf lg lh b">useForm</code>只支持基于文本的输入。我认为以下是最关键的后续步骤:</p><ul class=""><li id="b379" class="mr ms it kh b ki kj km kn kq mt ku mu ky mv lc mw mx my mz bi translated">支持单选按钮组(<code class="fe le lf lg lh b">&lt;input type=’radio’/&gt;</code>)</li><li id="f576" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">支持复选框(<code class="fe le lf lg lh b">&lt;input type=’checkbox’/&gt;</code>)</li><li id="1148" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">支持多值选择(<code class="fe le lf lg lh b">&lt;select multiple=’true’/&gt;</code>)</li><li id="f115" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">支持自定义输入，如日期选择器</li><li id="c1ca" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">允许自定义组件基于类或基于函数</li><li id="d9ec" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">确保验证支持库存HTML输入类型和定制组件</li><li id="cb24" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">确保我们的库允许定制组件挂钩到<code class="fe le lf lg lh b">onBlur</code>和<code class="fe le lf lg lh b">onFocus</code>，以便可以跟踪验证、访问状态和原始状态</li></ul><p id="5e6c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">表单创建者不应该做任何特殊的事情来让标准的HTML输入工作，只需要在需要的时候做一些HTML特定的实现细节。但是他们不应该担心那些实现细节。我们将在本文中回顾实现示例。</p><h2 id="25b9" class="nf lj it bd lk ng nh dn lo ni nj dp ls kq nk nl lw ku nm nn ma ky no np me nq bi translated">定制输入设计要求</h2><p id="59a0" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">自定义输入应该遵循一致的API。<code class="fe le lf lg lh b">useForm.addInput</code>用于配置一个新的输入，无论是标准的HTML输入还是自定义输入。<code class="fe le lf lg lh b">useForm.addInput</code>返回定制组件应该支持的一堆输入属性。下面是输入属性<code class="fe le lf lg lh b">useForm.addInput</code>的返回结果:</p><ul class=""><li id="d4c1" class="mr ms it kh b ki kj km kn kq mt ku mu ky mv lc mw mx my mz bi translated"><code class="fe le lf lg lh b">id</code>:输入id允许<code class="fe le lf lg lh b">useForm</code>跟踪表单字段(必填)</li><li id="19ed" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated"><code class="fe le lf lg lh b">value</code>:输入值(必输项)</li><li id="b789" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated"><code class="fe le lf lg lh b">onFocus</code>:允许<code class="fe le lf lg lh b">useInput</code>跟踪输入是否被访问过</li><li id="a7b8" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated"><code class="fe le lf lg lh b">onBlur</code>:允许<code class="fe le lf lg lh b">useForm</code>在模糊时验证组件</li><li id="634c" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated"><code class="fe le lf lg lh b">onChange</code>:允许<code class="fe le lf lg lh b">useInput</code>跟踪输入值是否已经改变(<code class="fe le lf lg lh b">pristine</code>)(必需)</li></ul><p id="500e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所有这些属性都是标准的React属性和事件。这使得API与React的模型保持一致。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/bf3b3da741f86d2ee68953cdb4f8b39e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icQrv9J3KvGkCSiUXt8ixA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图1 —定制组件和输入道具</figcaption></figure><p id="fe1c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如图1所示，要添加一个定制组件:</p><ol class=""><li id="cdbe" class="mr ms it kh b ki kj km kn kq mt ku mu ky mv lc ns mx my mz bi translated">定义您的React自定义组件</li><li id="d5f4" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc ns mx my mz bi translated">在自定义组件中实现从<code class="fe le lf lg lh b">addInput</code>返回的<code class="fe le lf lg lh b">id </code>和<code class="fe le lf lg lh b">value</code>属性</li><li id="5bd8" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc ns mx my mz bi translated">在自定义组件中调用从<code class="fe le lf lg lh b">addInput</code>返回的<code class="fe le lf lg lh b">onChange</code>事件。<code class="fe le lf lg lh b">onChange</code>需要传递两个值，事件值和输入值。<code class="fe le lf lg lh b">useForm</code>不知道<code class="fe le lf lg lh b">value</code>属性在定制组件的事件对象中的位置，所以明确该值可以简化事情</li><li id="abda" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc ns mx my mz bi translated">可选地在您的定制组件中实现从<code class="fe le lf lg lh b">addInput</code>调用返回的<code class="fe le lf lg lh b">onFocus</code>和<code class="fe le lf lg lh b">onBlur</code>函数。这允许<code class="fe le lf lg lh b">useInput</code>跟踪访问过的和原始的状态，也允许对模糊进行表单验证</li></ol><h2 id="4954" class="nf lj it bd lk ng nh dn lo ni nj dp ls kq nk nl lw ku nm nn ma ky no np me nq bi translated">支持<code class="fe le lf lg lh b">useForm</code>的定制组件示例</h2><p id="0e87" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">让我们创建一个使用<a class="ae ld" href="https://github.com/gpbl/react-day-picker" rel="noopener ugc nofollow" target="_blank"> react-day-picker </a>组件的样本日期选择器组件。我们的组件支持所有<code class="fe le lf lg lh b">useForm</code>支持的属性。例如，有自定义模糊和对焦功能。请注意，我们的组件是一个类组件。使用<code class="fe le lf lg lh b">useForm</code>的组件可以是基于类或函数的，没有限制。</p><p id="b7ae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的定制组件没有任何显式的<code class="fe le lf lg lh b">useForm</code>依赖关系。这使得定制组件很好地与<code class="fe le lf lg lh b">useForm</code>库解耦，而不是调用<code class="fe le lf lg lh b">props.onChange</code>、<code class="fe le lf lg lh b">props.onBlur</code>和<code class="fe le lf lg lh b">props.onFocus</code>(如果它们存在的话)。这些是<code class="fe le lf lg lh b">useForm</code>库使用的事件。</p><p id="a6a7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<code class="fe le lf lg lh b">render</code>中，<code class="fe le lf lg lh b">&lt;DayPicker {…this.props} /&gt;</code>展开传递给组件的所有<code class="fe le lf lg lh b">useForm</code>属性。</p><pre class="ml mm mn mo gt nt lh nu nv aw nw bi"><span id="1f4f" class="nf lj it lh b gy nx ny l nz oa">import React from "react";<br/>import DayPicker from "react-day-picker";<br/>import "react-day-picker/lib/style.css";</span><span id="c2d1" class="nf lj it lh b gy ob ny l nz oa">export class DatePicker extends React.Component {<br/>  handleOnDayClick = (value, modifiers, event) =&gt; {<br/>    console.log("custom change code...");<br/>    this.props.onChange &amp;&amp; this.props.onChange(event, value);<br/>  };<br/>  handleOnBlur = event =&gt; {<br/>    console.log("custom blur code...");<br/>    this.props.onBlur &amp;&amp; this.props.onBlur(event, this.props.value);<br/>  };<br/>  handleOnFocus = event =&gt; {<br/>    console.log("custom focus code...");<br/>    this.props.onFocus &amp;&amp; this.props.onFocus(event);<br/>  };</span><span id="3b00" class="nf lj it lh b gy ob ny l nz oa">render() {<br/>    const { value } = this.props;</span><span id="36b6" class="nf lj it lh b gy ob ny l nz oa">return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;DayPicker<br/>          onDayClick={this.handleOnDayClick}<br/>          {...this.props}<br/>          onBlur={this.handleOnBlur}<br/>          onFocus={this.handleOnFocus}<br/>        /&gt;<br/>        {value &amp;&amp; &lt;p&gt;You clicked {value.toLocaleDateString()}&lt;/p&gt;}<br/>      &lt;/React.Fragment&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="909a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">使用自定义组件和使用表单</strong></p><p id="646a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用定制组件与使用普通HTML组件是一样的。在下面的示例表单代码中，我们创建了一个定制验证，并使用<code class="fe le lf lg lh b">api.addInput</code>函数来配置我们的定制组件并连接验证。</p><p id="6014" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们看到从表单的<code class="fe le lf lg lh b">useForm</code>调用中返回了<code class="fe le lf lg lh b">api</code>。这个API允许表单创建者为他们的表单定义输入。代码然后调用<code class="fe le lf lg lh b">api.addInput</code>来注册新的<code class="fe le lf lg lh b">preferredDate</code>日期字段。当调用<code class="fe le lf lg lh b">api.addInput</code>时，新的<code class="fe le lf lg lh b">dateRangeValidator</code>被传递，这允许<code class="fe le lf lg lh b">useForm</code>使用验证器，并使用其余的标准<code class="fe le lf lg lh b">useForm</code>验证错误来跟踪验证错误。这应该使表单验证更容易推理和维护。</p><p id="6101" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们有了<code class="fe le lf lg lh b">&lt;DatePicker {…preferredDate.getInputProps()} /&gt;</code>,这就是我们如何将所有的<code class="fe le lf lg lh b">api.addInput</code>属性传递给我们的定制组件。就是这样！</p><pre class="ml mm mn mo gt nt lh nu nv aw nw bi"><span id="4708" class="nf lj it lh b gy nx ny l nz oa">import { DatePicker } from "./date-picker";</span><span id="5ee0" class="nf lj it lh b gy ob ny l nz oa">...</span><span id="f543" class="nf lj it lh b gy ob ny l nz oa">function KitchenSink(props) {<br/>  const { getFormProps, formValues, uiState, <strong class="lh iu">api</strong>, formValidity } = useForm(<br/>    "settingsForm",<br/>    {<br/>      firstName: "George",<br/>      lastName: "OfTheJungle",<br/>      email: "<a class="ae ld" href="mailto:george@thejungle.com" rel="noopener ugc nofollow" target="_blank">george@thejungle.com</a>",<br/>      custom: "custom",<br/>      agreeToTerms: false,<br/>      comments: "",<br/>      favouriteFlavour: "",<br/>      favouriteColours: ["red", "green"],<br/>      cookiesPerDay: null,<br/><strong class="lh iu">      preferredDate: null</strong><br/>    }<br/>  );</span><span id="6129" class="nf lj it lh b gy ob ny l nz oa">...</span><span id="bf61" class="nf lj it lh b gy ob ny l nz oa">// Not a real reference example of how to validate dates :)<br/>  const dateRangeValidator = createValidator({<br/>    validateFn: date =&gt; {<br/>      const startDate = new Date(2018, 1, 1);<br/>      const endDate = new Date(2018, 12, 33);<br/>      return date &amp;&amp; date &gt;= startDate &amp;&amp; date &lt;= endDate;<br/>    },<br/>    error: "DATE_RANGE_ERROR"<br/>  });</span><span id="6a57" class="nf lj it lh b gy ob ny l nz oa">const preferredDate = api.addInput({<br/>    id: "preferredDate",<br/>    value: formValues.preferredDate,<br/>    validators: [<br/>      { ...required, when: ["onBlur", "onSubmit"] },<br/>      { ...dateRangeValidator, when: ["onBlur", "onSubmit"] }<br/>    ]<br/>  });</span><span id="8cec" class="nf lj it lh b gy ob ny l nz oa">&lt;fieldset className="field-group"&gt;<br/>          &lt;legend&gt;Select a date from 2018&lt;/legend&gt;<br/><strong class="lh iu">          &lt;DatePicker {...preferredDate.getInputProps()} /&gt;</strong><br/>          &lt;div&gt;<br/>            {JSON.stringify(preferredDate.uiState)} --{" "}<br/>            {JSON.stringify(formValidity.preferredDate)}<br/>          &lt;/div&gt;<br/>&lt;/fieldset&gt;</span></pre><h1 id="f02b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">实现股票HTML输入</strong></h1><h2 id="e328" class="nf lj it bd lk ng nh dn lo ni nj dp ls kq nk nl lw ku nm nn ma ky no np me nq bi translated"><strong class="ak">复选框</strong></h2><p id="6fc8" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">复选框期望<code class="fe le lf lg lh b">value</code>为布尔值。在下面的代码示例中，表单代码添加了一个<code class="fe le lf lg lh b">agreeToTerms</code>输入。输入使用股票<code class="fe le lf lg lh b">mustBeTrue</code>验证器，它期望给定输入的<code class="fe le lf lg lh b">value</code>等于true。我们设置验证运行<code class="fe le lf lg lh b">onBlur</code>和<code class="fe le lf lg lh b">onSubmit</code>。我们用代码<code class="fe le lf lg lh b">&lt;input type=”checkbox” <strong class="kh iu">{…agreeToTerms.getCheckProps()}</strong> /&gt;</code>扩展从<code class="fe le lf lg lh b">api.addInput</code>返回的输入属性。<code class="fe le lf lg lh b">mustBeTrue</code>是一个新的股票验证器，用于验证复选框是否被选中。</p><p id="4a0d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">与复选框相关的表单代码示例:</strong></p><pre class="ml mm mn mo gt nt lh nu nv aw nw bi"><span id="d4ba" class="nf lj it lh b gy nx ny l nz oa">///<br/>const agreeToTerms = api.addInput({<br/>    id: "agreeToTerms",<br/>    value: formValues.agreeToTerms,<br/>    validators: [{ ...mustBeTrue, when: ["onBlur", "onSubmit"] }]<br/>  });</span><span id="e1bf" class="nf lj it lh b gy ob ny l nz oa">///<br/>&lt;input type="checkbox" {...agreeToTerms.getCheckProps()} /&gt;<br/>          &lt;label htmlFor={agreeToTerms.id}&gt;<br/>            Checkbox that must be checked *<br/>          &lt;/label&gt;</span></pre><p id="50ca" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">与复选框相关的use-input.js代码:</strong></p><pre class="ml mm mn mo gt nt lh nu nv aw nw bi"><span id="b337" class="nf lj it lh b gy nx ny l nz oa">const getCheckProps = inputProps =&gt; ({<br/>    ...getSharedProps(),<br/><strong class="lh iu">    checked: value,</strong><br/>    ...(typeof inputProps === "function" ? inputProps(props) : inputProps)<br/>  });</span></pre><p id="4b66" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">与复选框相关的validators.js代码</strong></p><pre class="ml mm mn mo gt nt lh nu nv aw nw bi"><span id="4753" class="nf lj it lh b gy nx ny l nz oa">validators.mustBeTrue = createValidator({<br/>  validateFn: value =&gt; value !== null &amp;&amp; value !== undefined &amp;&amp; value === true,<br/>  error: "MUST_BE_TRUE"<br/>});</span></pre><h2 id="230a" class="nf lj it bd lk ng nh dn lo ni nj dp ls kq nk nl lw ku nm nn ma ky no np me nq bi translated"><strong class="ak">单选按钮</strong></h2><p id="a1c6" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">单选按钮需要跟踪<code class="fe le lf lg lh b">value</code>和<code class="fe le lf lg lh b">checked</code>。这与文本输入和复选框不同，前者只跟踪值，后者只跟踪选中的值。要添加一组单选按钮，调用<code class="fe le lf lg lh b">api.addRadioGroup</code>。没有必要传递单选选项。对于每个<code class="fe le lf lg lh b">&lt;input type=”radio” /&gt;</code>，我们调用<code class="fe le lf lg lh b">getInputProps</code>并传递一个唯一的单选按钮<code class="fe le lf lg lh b">id</code>。但是每个单选按钮都获得相同的<code class="fe le lf lg lh b">name</code>值。这是配置单选按钮组的标准HTML方式。</p><p id="741c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">与单选按钮相关的表单代码示例:</p><pre class="ml mm mn mo gt nt lh nu nv aw nw bi"><span id="6e02" class="nf lj it lh b gy nx ny l nz oa">///</span><span id="e222" class="nf lj it lh b gy ob ny l nz oa">const cookieOptions = [<br/>    { id: "1", value: "1" },<br/>    { id: "10", value: "10" },<br/>    { id: "20", value: "20" }<br/>  ];<br/>const cookiesPerDay = api.addRadioGroup({<br/>    id: "cookiesPerDay",<br/>    value: formValues.cookiesPerDay,<br/>    validators: [{ ...required, when: ["onBlur", "onSubmit"] }]<br/>  });</span><span id="8765" class="nf lj it lh b gy ob ny l nz oa">///</span><span id="2071" class="nf lj it lh b gy ob ny l nz oa">&lt;fieldset className="field-group"&gt;<br/>          &lt;legend&gt;<br/>            How many cookies per day *<br/>            &lt;br /&gt;<br/>            {JSON.stringify(cookiesPerDay.uiState)} --{" "}<br/>            {JSON.stringify(formValidity.cookiesPerDay)}<br/>          &lt;/legend&gt;<br/>          {cookieOptions.map(cookie =&gt; (<br/>            &lt;React.Fragment key={cookie.id}&gt;<br/><strong class="lh iu">              &lt;input<br/>                {...cookiesPerDay.getInputProps({<br/>                  name: "cookiesPerDay",<br/>                  id: `cookiesPerDay_${cookie.id}`,<br/>                  value: cookie.value<br/>                })}<br/>                type="radio"<br/>                checked={cookie.value === formValues.cookiesPerDay}<br/>              /&gt;<br/></strong>              &lt;label htmlFor={`cookiesPerDay_${cookie.id}`}&gt;<br/>                {cookie.value}<br/>              &lt;/label&gt;<br/>            &lt;/React.Fragment&gt;<br/>          ))}<br/>&lt;/fieldset&gt;</span></pre><p id="c381" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">与单选按钮相关的use-form.js代码</strong></p><p id="2d74" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">每当单个单选按钮模糊时，就会触发<code class="fe le lf lg lh b">onRadioGroupBlur</code>功能。然而，当用户在同一个组中的单选按钮之间移动时，我们不希望引发onBlur事件。因此<code class="fe le lf lg lh b">onRadioGroupBlur</code>调用<code class="fe le lf lg lh b">isBlurWithinRadioGroup</code>来查看模糊是否到达同一个组中的单选按钮，或者其他什么地方。这要求表单创建者确保组中的每个单选按钮都有相同的<code class="fe le lf lg lh b">name</code>属性值。</p><pre class="ml mm mn mo gt nt lh nu nv aw nw bi"><span id="8ffb" class="nf lj it lh b gy nx ny l nz oa">const isBlurWithinRadioGroup = (event, id) =&gt;<br/>    event.relatedTarget &amp;&amp; event.relatedTarget.getAttribute("name") === id;</span><span id="f882" class="nf lj it lh b gy ob ny l nz oa">const onRadioGroupBlur = async ({ id, value, event }) =&gt; {<br/>    if (isBlurWithinRadioGroup(event, id)) return;</span><span id="ceac" class="nf lj it lh b gy ob ny l nz oa">if (validators[id]) {<br/>      if (isValidatorAlreadyRunning(id, value)) {<br/>        // No need to do anything at this point since validator is already running<br/>        return;<br/>      }</span><span id="9a6e" class="nf lj it lh b gy ob ny l nz oa">setFormValidity({<br/>        ...formValidity,<br/>        [id]: { ...formValidity[id], isValidating: true, value }<br/>      });<br/>      const validationResults = await runValidators({<br/>        field: id,<br/>        validators: validators[id],<br/>        eventType: "onBlur",<br/>        value<br/>      });<br/>      setFormValidity({ ...formValidity, [id]: validationResults });<br/>    }<br/>  };</span></pre><h2 id="7637" class="nf lj it bd lk ng nh dn lo ni nj dp ls kq nk nl lw ku nm nn ma ky no np me nq bi translated"><strong class="ak">多选</strong></h2><p id="182f" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">多重选择使用字符串值数组。在下面的表单代码中，我们将<code class="fe le lf lg lh b">favouriteColours</code>初始化为<code class="fe le lf lg lh b">[“red”, “green”]</code>。然后我们用<code class="fe le lf lg lh b">api.addInput</code>初始化<code class="fe le lf lg lh b">favouriteColours</code>。与单选按钮组一样，我们不传递值的集合。最后，我们使用带有<code class="fe le lf lg lh b">&lt;select {…favouriteColours.getInputProps()} multiple={true}&gt;</code>的输入，这与文本输入的用法相同。</p><p id="df20" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们扩展<code class="fe le lf lg lh b">favouriteColours.getInputProps()</code>时，我们得到一个<code class="fe le lf lg lh b">value=[“red”, “green”]</code>属性，该属性扩展到<code class="fe le lf lg lh b">&lt;select /&gt;</code>标签中。这就是React期望将多选值传递给选择输入的方式。</p><pre class="ml mm mn mo gt nt lh nu nv aw nw bi"><span id="683e" class="nf lj it lh b gy nx ny l nz oa">const { getFormProps, formValues, uiState, api, formValidity } = useForm(<br/>    "settingsForm",<br/>    {<br/>      firstName: "George",<br/>      lastName: "OfTheJungle",<br/>      email: "<a class="ae ld" href="mailto:george@thejungle.com" rel="noopener ugc nofollow" target="_blank">george@thejungle.com</a>",<br/>      custom: "custom",<br/>      agreeToTerms: false,<br/>      comments: "",<br/>      favouriteFlavour: "",<br/><strong class="lh iu">      favouriteColours: ["red", "green"],</strong><br/>      cookiesPerDay: null,<br/>      preferredDate: null<br/>    }<br/>  );</span><span id="c9df" class="nf lj it lh b gy ob ny l nz oa">///</span><span id="6e46" class="nf lj it lh b gy ob ny l nz oa">  const favouriteColours = api.addInput({<br/>    id: "favouriteColours",<br/>    value: formValues.favouriteColours,<br/>    validators: [{ ...required, when: ["onBlur", "onSubmit"] }]<br/>  });</span><span id="eaba" class="nf lj it lh b gy ob ny l nz oa">///</span><span id="5af5" class="nf lj it lh b gy ob ny l nz oa">&lt;div className="field-group"&gt;<br/>          &lt;label htmlFor={favouriteColours.id}&gt;Your favourite colours *&lt;/label&gt;<br/>          {JSON.stringify(favouriteColours.uiState)} --{" "}<br/>          {JSON.stringify(formValidity.favouriteColours)}<br/>          &lt;select {...favouriteColours.getInputProps()} multiple={true}&gt;<br/>            &lt;option value="red"&gt;Red&lt;/option&gt;<br/>            &lt;option value="green"&gt;Green&lt;/option&gt;<br/>            &lt;option value="blue"&gt;Blue&lt;/option&gt;<br/>            &lt;option value="yellow"&gt;Yellow&lt;/option&gt;<br/>          &lt;/select&gt;<br/>        &lt;/div&gt;</span></pre><p id="847c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">多选相关的use-input.js代码</strong></p><p id="7276" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">getInputValue</code>是生成多选值的地方。对于多重选择(<code class="fe le lf lg lh b">type === “select-multiple”</code>)，我们迭代选择的选项，找到被选择的选项，并基于被选择的选项创建一个值数组。选择选项作为React合成事件的一部分传递，用于更改、模糊和聚焦。因此表单创建者不必将选择选项传递给<code class="fe le lf lg lh b">addInput</code>。</p><pre class="ml mm mn mo gt nt lh nu nv aw nw bi"><span id="891c" class="nf lj it lh b gy nx ny l nz oa">const getInputValue = ({ type, checked, value, options }) =&gt; {<br/>  if (type === "checkbox") return checked;<br/>  if (type === "select-multiple")<br/>    return [...options]<br/>      .map(option =&gt; ({<br/>        value: option.value,<br/>        selected: option.selected<br/>      }))<br/>      .filter(option =&gt; option.selected)<br/>      .map(option =&gt; option.value);<br/>  if (type === "radio") {<br/>    if (checked) return value;<br/>    return undefined;<br/>  }<br/>  return value;<br/>};</span></pre><h1 id="293a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用表单代码更改来支持自定义输入</h1><p id="a48c" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">在这一点上，支持定制输入不需要进行大的改变。为库存HTML输入奠定的基础支持定制输入。</p><h1 id="f86f" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第3部分的错误修复</h1><p id="64a0" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">第3部分中的一些错误已经得到了修复:</p><ul class=""><li id="5bc5" class="mr ms it kh b ki kj km kn kq mt ku mu ky mv lc mw mx my mz bi translated">必需的验证器现在可以处理空值或未定义的值</li><li id="451a" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">即使第一个输入产生了验证错误，对单个输入的所有验证都会运行。我倾向于在出现第一个验证错误后停止处理，以避免不必要的验证逻辑检查、网络往返等。验证码会更新以反映这一点</li><li id="3d5c" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">我几乎在所有地方都将<code class="fe le lf lg lh b">name</code>重命名为<code class="fe le lf lg lh b">id</code>,因为这个库并没有真正将id扩展为<code class="fe le lf lg lh b">name</code>属性，而<code class="fe le lf lg lh b">id</code>是一个更为一致的术语，用于描述事物的唯一ID</li><li id="1444" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">在表单提交期间，<code class="fe le lf lg lh b">useForm</code>没有验证<code class="fe le lf lg lh b">onSubmit</code>验证器。它之前正在验证<code class="fe le lf lg lh b">onBlur</code>验证器</li><li id="b269" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated"><code class="fe le lf lg lh b">useForm</code>通过异步验证以不正确的方式改变验证状态。它现在使用更加一致的方法来改变验证状态，与<a class="ae ld" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> useRef React hook </a>同时运行验证。我计划写一篇关于这个的文章，因为这是使用<code class="fe le lf lg lh b">setState</code>管理共享状态时可能遇到的常见问题，共享状态可能会以不确定的顺序异步更新。在这种情况下，<code class="fe le lf lg lh b">useRef</code>可以帮助解决这些问题，因为<code class="fe le lf lg lh b">useState</code>保证了一个钩子的完整功能执行的状态的一致拷贝</li></ul><h1 id="2bce" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">单元测试和代码覆盖率—💯% ?</h1><p id="92fb" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">到目前为止，我只是在编写单元测试，而没有检查代码覆盖率。我们的单元测试覆盖了很多标准路径，但是它们没有提供100%的覆盖率。不过话说回来，我们可能不需要100%的覆盖率。我们甚至可能不需要90%的覆盖率，但我们可能应该有超过40%或50%的覆盖率。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/8498221064d60a2634bdc0e9f82542a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAlQw6AJSbYnV2pnQ4W93Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">不错，但是测试覆盖率需要提高</figcaption></figure><p id="800c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Martin Fowler关于测试覆盖率的文章有一些值得考虑的问题:</p><blockquote class="od oe of"><p id="fc47" class="kf kg og kh b ki kj kk kl km kn ko kp oh kr ks kt oi kv kw kx oj kz la lb lc im bi translated">如果你把一定程度的覆盖率作为一个目标，人们会努力去实现它。问题是高覆盖率的数字太容易被低质量的测试所达到。</p><p id="f58c" class="kf kg og kh b ki kj kk kl km kn ko kp oh kr ks kt oi kv kw kx oj kz la lb lc im bi translated">如果以下是真的，我会说你做了足够的测试:</p><p id="7246" class="kf kg og kh b ki kj kk kl km kn ko kp oh kr ks kt oi kv kw kx oj kz la lb lc im bi translated">-你很少会遇到逃脱到产品中的bug，并且<br/> -你很少会因为担心会导致产品bug而犹豫改变一些代码。</p></blockquote><p id="6719" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我认识的大多数人都和福勒先生有相似的观点。我目睹过测试覆盖率低得可怕的生产代码库，以及测试覆盖率高的生产代码库。出于输入库的目的，我倾向于确保所有代码路径都经过了所有级别的测试，因为可以独立于其他部分使用API的各个方面。</p><p id="a39d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用Jest，只需添加<code class="fe le lf lg lh b">--coverage</code> <a class="ae ld" href="https://jestjs.io/docs/en/cli#coverage" rel="noopener ugc nofollow" target="_blank">就可以自动获得代码覆盖报告</a>。然后，这些报告可以在持续构建/持续集成环境中使用，但是目前测试将在开发期间从终端窗口运行。</p><h1 id="7b9d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">放大演示表单</h1><p id="d8bf" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">演示表单现在演示了以下内容:</p><ul class=""><li id="aa2e" class="mr ms it kh b ki kj km kn kq mt ku mu ky mv lc mw mx my mz bi translated">模糊和提交时的复选框和“必须选中”验证</li><li id="1a36" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">模糊和提交时的单选按钮组和验证</li><li id="233f" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">模糊时选择输入和验证并提交</li><li id="54f0" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">模糊和提交时的多选输入和验证</li><li id="dd8b" class="mr ms it kh b ki na km nb kq nc ku nd ky ne lc mw mx my mz bi translated">自定义组件(即日期选择器)和模糊和提交时的验证</li></ul><p id="8caa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">查看在线演示和github资源库中的代码，了解一切如何协同工作。</p><h1 id="2978" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">摘要</h1><p id="f5bb" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">在这篇文章中，我们扩展了表单库以支持大多数标准的HTML输入，以及自定义输入。我们修复了第3部分中存在的一些错误，讨论了测试覆盖范围，并扩展了我们的表单示例。</p><p id="0f09" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在后面的部分中，我们将讨论其他主题，比如减少样板文件、从JSON模式添加验证、承诺取消、去抖动、钩子性能考虑和其他设计优化。</p><p id="64df" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此时，该库可能已经“足够好”可以用于生产了😃。在开始自己制作表单库之前，请记住制作一个“足够好”的表单库需要付出的努力和思考！</p><p id="2455" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">除非您有一个不需要验证逻辑的极其简单的表单，是的，您可以用React拼凑一个表单，但是它会非常有限。一旦你需要越过简单的表单，使用表单库。否则你可能没有充分利用你的时间。除非你是出于自己的学习目的，当然，我总是建议通过开发你感兴趣的东西来学习。</p><p id="a8b3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您有任何问题、反馈或建议，或者您希望我介绍本系列中的其他内容，请告诉我。</p></div></div>    
</body>
</html>