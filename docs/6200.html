<html>
<head>
<title>Software development in containers — a cookbook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器中的软件开发——一本食谱</h1>
<blockquote>原文：<a href="https://itnext.io/software-development-in-containers-a-cookbook-2ba14d07e535?source=collection_archive---------0-----------------------#2021-09-18">https://itnext.io/software-development-in-containers-a-cookbook-2ba14d07e535?source=collection_archive---------0-----------------------#2021-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/229abd2326cbb33cb3c1547cd273f219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ZeFM_IKT7GemI7EVkiQeA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">布雷特·乔丹在<a class="ae jd" href="https://unsplash.com/s/photos/seafood-cookbook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><div class=""><h2 id="04f5" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">开发容器化软件指南</h2></div><h2 id="eb95" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">介绍</h2><p id="a605" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">本文描述了在容器化工作负载的整个生命周期中的容器化最佳实践；重点是<strong class="lt jh">发展</strong>和<strong class="lt jh">安全。</strong>我们来看看:</p><ul class=""><li id="c0a6" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">容器图像设计指南</li><li id="98cd" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">开发、调试和测试</li><li id="bdff" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">安全最佳实践</li><li id="a8e9" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">CI/CD管道</li><li id="3d25" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">操作和维护</li></ul><p id="f652" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">如果您是一名软件开发人员<strong class="lt jh">开始您的容器开发之旅，您会发现它非常有用。即使是高级开发人员也可能到处学到一些技巧。</strong></p><p id="4141" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">此外，还有针对安全专业人员<strong class="lt jh">以及自动化工程师<strong class="lt jh">或SREs (Ops)的内容。</strong></strong></p><blockquote class="nd ne nf"><p id="5000" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated">一点免责声明，如果你的头衔是DevOps工程师，请不要觉得被冷落了。你一定会从这篇文章的内容中受益。只是DevOps不是一个头衔既不是一个角色也不是一个团队，而是一种哲学和文化。不幸的是，在大多数公司中，DevOps实际上意味着自动化工程和软操作(主要是配置和处理Kubernetes和其他复杂的软件)。因此，如果你在某处读到“自动化工程师”，那意味着DevOps工程师。</p></blockquote><p id="829c" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">本文档旨在作为开发和运行容器化软件的框架和指南。这篇文章仅仅是关于容器的，如果你对容器编排感兴趣，看看我之前的两篇博客，<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/how-to-be-a-devops-maestro-containers-orchestration-guide-b2cf884eaed1">用Kubernetes编排容器</a>和<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/best-practices-for-developing-on-kubernetes-8fbdbba12538">在Kubernetes </a>上开发。</p><p id="95f9" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">有很多内容需要讨论，所以让我们开始吧！</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="dabb" class="nr kw jg bd kx ns nt nu la nv nw nx ld km ny kn lh kp nz kq ll ks oa kt lp ob bi translated">基本原则</h1><h2 id="5622" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">基本定义和概念</h2><blockquote class="oc"><p id="083c" class="od oe jg bd of og oh oi oj ok ol mj dk translated">容器</p></blockquote><p id="edd6" class="pw-post-body-paragraph lr ls jg lt b lu om kh lw lx on kk lz le oo mb mc li op me mf lm oq mh mi mj ij bi translated">容器是容器映像的运行时实例。容器是一个标准的Linux进程，通常通过使用cgroups和名称空间来进一步隔离。</p><blockquote class="oc"><p id="e35e" class="od oe jg bd of og oh oi oj ok ol mj dk translated">容器图像</p></blockquote><p id="b57c" class="pw-post-body-paragraph lr ls jg lt b lu om kh lw lx on kk lz le oo mb mc li op me mf lm oq mh mi mj ij bi translated">从最简单的定义来看，容器映像是一个从注册服务器下载的文件，在启动容器时用作本地挂载点。</p><blockquote class="oc"><p id="6a4f" class="od oe jg bd of og oh oi oj ok ol mj dk translated">容器主机</p></blockquote><p id="8afc" class="pw-post-body-paragraph lr ls jg lt b lu om kh lw lx on kk lz le oo mb mc li op me mf lm oq mh mi mj ij bi translated">容器主机是运行容器化流程的系统，通常简称为容器。</p><blockquote class="oc"><p id="e31b" class="od oe jg bd of og oh oi oj ok ol mj dk translated">集装箱发动机</p></blockquote><p id="2407" class="pw-post-body-paragraph lr ls jg lt b lu om kh lw lx on kk lz le oo mb mc li op me mf lm oq mh mi mj ij bi translated">容器引擎是一个软件，它接受用户请求，包括命令行选项，提取图像，并从最终用户的角度运行容器。集装箱引擎有很多，包括docker、RKT、CRI-O、LXD等。</p><blockquote class="oc"><p id="1066" class="od oe jg bd of og oh oi oj ok ol mj dk translated">图像注册表</p></blockquote><p id="0a2d" class="pw-post-body-paragraph lr ls jg lt b lu om kh lw lx on kk lz le oo mb mc li op me mf lm oq mh mi mj ij bi translated">注册服务器本质上是一个奇特的文件服务器，用于存储docker存储库。通常，注册服务器被指定为一个普通的DNS名称和一个可选的要连接的端口号</p><h2 id="f7c6" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">概观</h2><p id="1fe7" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">本文档假定您对Docker和Docker CLI有基本的了解。要学习或复习与容器相关的概念，请参考官方文档:</p><ul class=""><li id="0abf" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated"><a class="ae jd" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker文档</a></li><li id="f4ce" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><a class="ae jd" href="https://docs.mirantis.com/welcome/" rel="noopener ugc nofollow" target="_blank">米兰蒂斯文件</a></li></ul><blockquote class="nd ne nf"><p id="c62a" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><a class="ae jd" href="https://techcrunch.com/2019/11/13/mirantis-acquires-docker-enterprise/?guce_referrer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8&amp;guce_referrer_sig=AQAAAChqDhj765aUpAQfg-rkCWE0kB-4eAJn0VdTGsf35u6hGrL6scvqoLar-_xYPJazylmp15VqXquNq69HWpYx3cepSnXSSUTirYLSMJEbPuBhQOfS4blsGLwsULwWzxK8iaH3zb2KplXRwnpdfMu9iz5Azc2czZr9T5bFwq0AIeN3&amp;guccounter=2" rel="noopener ugc nofollow" target="_blank"> <em class="jg">米兰蒂斯2019年11月收购Docker Enterprise</em></a></p></blockquote><p id="9823" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">请注意，由于大多数开发活动将从“docker stack”(docker CLI、docker CE、docker desktop等)开始，所以大多数时候我们将参考docker工具。每个提到的组件都有很多替代方案。例如，podman、buildah、buildpacks和许多其他技术都不是来自Docker公司。</p><p id="bc39" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">容器操作系统也是如此，一些windows容器超出了本文的范围。</p><h2 id="9f1e" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Docker架构概述</h2><p id="e3fe" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">有关docker架构的详细信息，请参考Docker或Mirantis文档。这里有一个解释高级docker架构及其组件的方便的图表。</p><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi or"><img src="../Images/9c8c67a9309d7a49d32c59fec8614972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2fYm6FswNHTrd079.png"/></div></div></figure><p id="e485" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><em class="ng">来源</em>:</p><ul class=""><li id="8be2" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated"><a class="ae jd" href="https://docs.docker.com/engine/reference/commandline/dockerd/" rel="noopener ugc nofollow" target="_blank">案卷号</a></li><li id="9912" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><a class="ae jd" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank">集装箱</a></li><li id="1453" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><a class="ae jd" href="https://github.com/opencontainers/runc" rel="noopener ugc nofollow" target="_blank"> runc </a></li><li id="9747" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><a class="ae jd" href="http://jancorg.github.io/blog/2015/01/03/libcontainer-overview/" rel="noopener ugc nofollow" target="_blank"> libcontainer </a></li><li id="8165" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><a class="ae jd" href="https://medium.com/faun/docker-containerd-standalone-runtimes-heres-what-you-should-know-b834ef155426" rel="noopener">集装箱垫片</a></li></ul><h2 id="c0d9" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">容器生命周期</h2><p id="2e9a" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">当您开始开发容器化的工作负载时，与开发常规软件有很多相似之处，但也有一些关键的区别。下图提供了容器化工作负载生命周期各个阶段的简化视图。</p><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ow"><img src="../Images/8175f4a92cfb0b963ce8c6fc205dfd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b6HQRjJSjY18M_-2.png"/></div></div></figure><h2 id="6634" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Docker CLI语法</h2><p id="46af" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">Docker CLI具有以下语法:</p><p id="9caf" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">语法:<code class="fe ox oy oz pa b">docker &lt;docker-object&gt; &lt;sub-command&gt; &lt;-options&gt; &lt;arguments/commands&gt;</code></p><p id="c2d9" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><strong class="lt jh">示例</strong> : <code class="fe ox oy oz pa b">docker container run -it ubuntu</code></p><h2 id="6611" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">容器层</h2><p id="b102" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">默认情况下，所有docker图像层都是不可变的(只读)。当使用<code class="fe ox oy oz pa b">docker run</code>命令创建一个容器时，会创建一个额外的可变(读写)层。<strong class="lt jh">该层仅在容器寿命期间存在，一旦容器退出</strong>将被移除。当修改正在运行的容器中的任何文件时，docker会创建文件的副本，并在保存更改之前将其移动到容器层(写入时复制)。作为图像一部分的原始文件永远不会改变。</p><h2 id="fae6" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">从CLI访问远程Docker主机</h2><p id="0561" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">在您想要访问docker主机的机器表单上，设置变量:</p><pre class="os ot ou ov gt pb pa pc pd aw pe bi"><span id="2f55" class="kv kw jg pa b gy pf pg l ph pi">export DOCKER_HOST="tcp://&lt;docker-host-ip&gt;:2375"</span></pre><blockquote class="nd ne nf"><p id="a949" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg"> Docker默认端口:</em></p><p id="d41b" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated">2375 —未加密的流量</p><p id="d79e" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated">2376 —加密流量。</p><p id="7cd6" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><strong class="lt jh"> <em class="jg">重要</em> </strong> <em class="jg">:此设置仅用于测试/游乐场目的。它将使docker主机在网络上可用，默认情况下没有认证。</em></p></blockquote><h2 id="77e2" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">以非超级用户身份使用docker CLI</h2><ol class=""><li id="d610" class="mk ml jg lt b lu lv lx ly le pj li pk lm pl mj pm ms mt mu bi translated">创建码头工人组:<code class="fe ox oy oz pa b">sudo groupadd docker</code></li><li id="32b8" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated">创建一个你想使用docker的非根用户:<code class="fe ox oy oz pa b">sudo useradd -G docker &lt;user-name&gt;</code></li><li id="81aa" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated">更改该用户主组:<code class="fe ox oy oz pa b">sudo usermod -aG docker &lt;non-root user&gt;</code></li><li id="6bf5" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated">注销并使用docker用户登录。</li><li id="360c" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated">可选—重新启动docker服务:<code class="fe ox oy oz pa b">sudo systemctl restart docker</code></li></ol></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="c68f" class="nr kw jg bd kx ns nt nu la nv nw nx ld km ny kn lh kp nz kq ll ks oa kt lp ob bi translated">发展</h1><p id="4b3d" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">强烈推荐使用带有Docker插件的VS代码进行容器开发。</p><blockquote class="nd ne nf"><p id="ec1b" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><a class="ae jd" href="https://www.digitalocean.com/community/tutorials/how-to-use-the-docker-plugin-for-visual-studio-code" rel="noopener ugc nofollow" target="_blank"> <em class="jg">这里的</em> </a> <em class="jg">是一个很好的关于热设置和使用Docker扩展与VS代码</em>的写法</p><p id="2159" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><a class="ae jd" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank"> <em class="jg">阅读构建Dockerfiles的最佳实践</em> </a></p></blockquote><h2 id="f022" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">快速创建Dockerfile文件存根</h2><p id="5046" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">如果您使用带有Docker扩展的VS代码，您可以为您的项目快速创建一个<em class="ng"> Dockerfile </em>存根。</p><ul class=""><li id="8a3c" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">用VS代码打开包含项目的文件夹</li><li id="0d84" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">转到命令面板Ctrl+Shift+P并键入<code class="fe ox oy oz pa b">Docker: Add Docker Files to Workspace</code></li><li id="6d10" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">从下拉框中选择您的语言，并回答几个问题</li><li id="a91f" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">您的docker文件将在您当前所在的目录中生成</li><li id="985c" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">确保调整文件，但是模板已经很好了</li></ul><h2 id="bb92" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何调试映像构建过程</h2><p id="91c8" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">要构建映像，您可以使用docker CLI <code class="fe ox oy oz pa b">docker build --progress=plain -t imagename:tag -f Dockerfile .</code>或使用VS Code Docker扩展来完成同样的工作</p><blockquote class="nd ne nf"><p id="7c3c" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg"/><code class="fe ox oy oz pa b"><em class="jg">--progress=plain</em></code><em class="jg">标志创建到stdout的详细输出，并且在使用Docker扩展时默认启用。</em></p></blockquote><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pn"><img src="../Images/11d7db45dd1475aecafce8af0b76a4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aFNUUaOeITPF4fWd.png"/></div></div></figure><p id="1439" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">当创建一个<em class="ng"> Dockerfile </em>时，每个新的命令，如RUN、ADD、COPY等，都会创建一个新的中间容器，您可以在其中执行和调试。</p><blockquote class="nd ne nf"><p id="6ade" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">如果docker主机支持使用</em> <code class="fe ox oy oz pa b"><em class="jg">buildkit</em></code> <em class="jg">(从1.18版本起)的新构建机制或使用docker build的旧构建机制，调试步骤会有所不同。Buildkit调试相对复杂，因此在运行docker build命令之前，使用</em> <code class="fe ox oy oz pa b"><em class="jg">DOCKER_BUILDKIT=0</em></code> <em class="jg">更容易切换到docker构建方式。此设置将临时将内部版本切换到旧版本。</em></p></blockquote><h2 id="b172" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用旧版本调试Dockefile构建过程的步骤</h2><ul class=""><li id="2cef" class="mk ml jg lt b lu lv lx ly le pj li pk lm pl mj mr ms mt mu bi translated">克隆测试存储库，或者使用Dockerfile创建一个包含您想要调试的错误的新存储库</li><li id="fd68" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">运行遗留构建命令<code class="fe ox oy oz pa b">DOCKER_BUILDKIT=0 docker build --rm=false -t wrongimage -f Dockerfile.bad .</code></li><li id="9658" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">这个Dockefile产生一个错误，文件夹丢失</li></ul><pre class="os ot ou ov gt pb pa pc pd aw pe bi"><span id="3623" class="kv kw jg pa b gy pf pg l ph pi">Step 17/19 : WORKDIR /app ---&gt; Running in 21b793c569f4 ---&gt; 0d5d0c9d52a3 <br/>Step 18/19 : COPY --from=publish /app/publish1 . <br/>COPY failed: stat app/publish1: file does not exist</span></pre><ul class=""><li id="499a" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">请注意，在错误的正上方有一条消息，中间图像ID为0d5d0c9d52a3</li><li id="01f1" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">由于我们使用了标志<code class="fe ox oy oz pa b">--rm=false</code>，中间图像不会被删除，我们可以使用<code class="fe ox oy oz pa b">docker image ls</code>将其列出</li><li id="5407" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">让我们以交互模式从这个图像开始一个新的容器<code class="fe ox oy oz pa b">docker run -it 0d5d0c9d52a3 sh</code></li><li id="d834" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">在容器内部，我们可以看到没有创建所需的文件夹</li></ul><h2 id="77df" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何调试运行在容器中的应用程序</h2><p id="7e70" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">当一个<code class="fe ox oy oz pa b">launch.json</code>文件存在并且包含关于如何启动和调试docker容器的指令时，在容器中运行的应用程序可以直接从IDE中调试。</p><blockquote class="nd ne nf"><p id="c367" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">强烈建议使用</em> <a class="ae jd" href="https://github.com/microsoft/vscode-docker" rel="noopener ugc nofollow" target="_blank"> <em class="jg">带Docker扩展名</em> </a> <em class="jg">的VS代码，轻松将</em> <a class="ae jd" href="https://code.visualstudio.com/docs/containers/debug-netcore" rel="noopener ugc nofollow" target="_blank"> <em class="jg"> Dockerfile和调试设置添加到项目</em> </a> <em class="jg">中。</em></p></blockquote><ul class=""><li id="d07a" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated"><a class="ae jd" href="https://dev.azure.com/GRD-EMEA/Cloud%20Native%20Platform/_git/debug-containers-dotnet" rel="noopener ugc nofollow" target="_blank">点击此处</a>查看已经设置好的ASP.NET核心WebAPI项目示例</li><li id="602b" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">克隆项目</li><li id="0b71" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><code class="fe ox oy oz pa b">cd</code>进入项目目录</li><li id="5b2f" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><code class="fe ox oy oz pa b">code .</code>打开VS代码</li><li id="68fa" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">选择<code class="fe ox oy oz pa b">docker: initialize for debugging</code>并按照向导进行操作</li><li id="4d16" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">切换到<code class="fe ox oy oz pa b">Run and Debug</code>视图Ctrl+Shift+D</li><li id="7093" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">选择<code class="fe ox oy oz pa b">Docker .NET Launch</code></li><li id="a4ab" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">在控制器中设置断点</li></ul><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pn"><img src="../Images/c062fb6b1fbcb47014231b4453b196fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eagxGtCYWpIYJRr7.png"/></div></div></figure><h2 id="c132" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用多阶段构件</h2><p id="e80c" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">在多阶段构建中，您创建一个中间容器——或阶段——带有所有必需的工具来编译或生成您的最终工件(即最终的可执行文件)。然后，您只需要将结果复制到最终的映像中，而不需要额外的开发依赖、临时构建文件等等。</p><p id="9dc3" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">精心制作的多阶段构建只包括最终映像中最少的所需二进制文件和依赖项，而不构建工具或中间文件。这减少了攻击面，减少了漏洞。</p><p id="52ea" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">它更安全，而且还减小了图像尺寸。</p><p id="b835" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">考虑下面Dockerfile构建一个go API。文件注释中解释了多阶段构建的使用。你自己试试！</p><figure class="os ot ou ov gt is"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="6528" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用发行版图像</h2><p id="7174" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">使用最低要求的基本容器来遵循Dockerfile最佳实践。</p><p id="365e" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">理想情况下，我们会从头开始创建容器，但是只有100%静态的二进制文件才有效。</p><p id="d44d" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">发行版是一个不错的选择。它们被设计成只包含运行Go、Python或其他框架所需的最小库集。</p><h2 id="545f" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用docker-slim来确保你的形象尽可能的瘦</h2><p id="1273" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">容器映像应该很小，并且只包含容器化的工作负载正确工作所需的组件/包。这很重要，有两个主要原因:</p><ul class=""><li id="1c4b" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">安全性:通过删除不必要的包使图像变小，大大减少了攻击面</li><li id="89d7" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">性能:较小的图像启动速度更快</li></ul><blockquote class="nd ne nf"><p id="a029" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><a class="ae jd" href="https://github.com/docker-slim/docker-slim" rel="noopener ugc nofollow" target="_blank"><em class="jg">docker-slim</em></a><em class="jg">自带多种选项。它支持瘦身图像，扫描docker文件等。最好的方法是按照</em> <a class="ae jd" href="https://github.com/docker-slim/docker-slim#demo-steps" rel="noopener ugc nofollow" target="_blank"> <em class="jg">演示设置</em> </a> <em class="jg">中的步骤开始。</em></p></blockquote><h2 id="d37a" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">机密信息和秘密</h2><p id="4512" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">使用<code class="fe ox oy oz pa b">.dockerignore</code>将不必要的文件排除在构建容器之外。它们可能包含机密信息。</p><p id="b8cd" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">Docker默认使用<a class="ae jd" href="https://github.com/moby/buildkit" rel="noopener ugc nofollow" target="_blank"> biuildkit </a>来构建图像。buildkit的特性之一是能够使用<code class="fe ox oy oz pa b">RUN --mount=type=secret</code>将秘密装载到docker映像中。这适用于在映像构建过程中需要使用秘密的场景，例如从git获取凭证等。</p><p id="e624" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">以下是如何检索和使用机密的示例:</p><ul class=""><li id="cb12" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">创建一个秘密文件或环境变量:<code class="fe ox oy oz pa b">export SUPERSECRET=secret</code></li><li id="46b2" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">在docker文件中添加<code class="fe ox oy oz pa b">RUN --mount=type=secret,id=supersecret</code>，这将使<code class="fe ox oy oz pa b">/run/secrets/supersecret</code>下的图像中的秘密可用</li><li id="a79f" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">像这样用你的秘密建立形象:</li></ul><pre class="os ot ou ov gt pb pa pc pd aw pe bi"><span id="fba6" class="kv kw jg pa b gy pf pg l ph pi">export DOCKER_BUILDKIT=1</span><span id="d8b6" class="kv kw jg pa b gy pq pg l ph pi">docker build --secret id=supersecret,env=SUPERSECRET .</span></pre><p id="7b8b" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这将从环境变量SUPERSECRET安全地添加到容器中。检查图像历史或分解图层不会揭示这个秘密。</p><h2 id="6360" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用多个docker文件</h2><p id="7d8b" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">考虑为不同的目的创建单独的docker文件。例如，您可以拥有一个预先安装了测试和扫描工具的专用docker文件，并在本地开发阶段运行它。</p><blockquote class="nd ne nf"><p id="664e" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">记住，你可以通过传递</em> <code class="fe ox oy oz pa b"><em class="jg">-f</em></code> <em class="jg">标志从不同的docker文件建立镜像，例如</em></p></blockquote><pre class="os ot ou ov gt pb pa pc pd aw pe bi"><span id="cb6f" class="kv kw jg pa b gy pf pg l ph pi"><em class="ng">docker build -t -f Dockerfile.test my-docker-image:v1.0 .</em></span></pre><h2 id="2b23" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用docker-compose旋转多个容器</h2><p id="0082" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated"><a class="ae jd" href="https://compose-spec.io/" rel="noopener ugc nofollow" target="_blank"> Docker-compose规范</a>是一个以开发人员为中心的标准，用于定义云和平台无关的基于容器的应用程序。不要使用<code class="fe ox oy oz pa b">docker CLI</code>直接从命令行运行容器，考虑创建一个<code class="fe ox oy oz pa b">docker-compose.yaml</code>来描述组成应用程序的所有容器。</p><blockquote class="nd ne nf"><p id="243f" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">请注意，用docker compose规范描述的应用程序是完全可移植的，所以你可以在本地或Azure容器实例中运行它</em></p></blockquote><h2 id="a6f9" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用Kompose将docker-compose文件转换为Kubernetes清单</h2><p id="de5d" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">如果你已经有一个docker-compose文件，并且需要一个生成Kubernetes YAML文件的启动，使用kompose。</p><p id="2720" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><code class="fe ox oy oz pa b">kompose</code>允许从<code class="fe ox oy oz pa b">docker-compose.yaml</code>文件到本地Kubernetes清单文件的快速转换。</p><blockquote class="nd ne nf"><p id="88f0" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">你可以从</em> <a class="ae jd" href="https://kompose.io/" rel="noopener ugc nofollow" target="_blank"> <em class="jg">首页</em> </a>下载Kompose二进制文件</p></blockquote><h2 id="c523" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用composerize从docker运行命令快速创建docker合成文件</h2><p id="437a" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">Docker run命令可以快速表示与容器交互的命令式风格。另一方面，Docker-compose文件是一种提供的声明式风格。</p><p id="2d0e" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><a class="ae jd" href="https://github.com/magicmark/composerize" rel="noopener ugc nofollow" target="_blank">compose</a>是一个简洁的小工具，可以快速地将一个冗长的<code class="fe ox oy oz pa b">docker run</code>命令转换成一个<code class="fe ox oy oz pa b">docker-compose.yaml</code>文件。</p><blockquote class="nd ne nf"><p id="891e" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">compose可以从CLI或基于网络的界面</em><a class="ae jd" href="https://www.composerize.com/" rel="noopener ugc nofollow" target="_blank"><em class="jg"/></a><em class="jg">生成docker-compose文件。</em></p></blockquote><p id="7c0c" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">下面是一个从我的一个图像转换docker运行命令的例子:</p><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pr"><img src="../Images/68d7a44cccb2508249c62ca611f5f79c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fvt6pzPJGjvzakFi.png"/></div></div></figure><h2 id="2288" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">通过容器控制资源利用</h2><p id="47ae" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated"><strong class="lt jh"> CPU </strong></p><p id="b071" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">每个容器的默认CPU份额是1024</p><p id="c589" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><strong class="lt jh">选项1: </strong>如果主机有多个CPU，可以给每个容器分配一个特定的CPU。</p><p id="3635" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><strong class="lt jh">选项2: </strong>如果主机有多个CPU，可以限制容器可以使用多少CPU。</p><p id="d342" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">值得注意的是，容器编排器(如Kubernetes)提供了声明性的方法来限制每个运行时单元的资源使用(在Kubernetes中是pod)。</p><p id="ec72" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><strong class="lt jh">记忆</strong></p><p id="109c" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><strong class="lt jh">选项1: </strong>运行带有<code class="fe ox oy oz pa b">--memory=limit</code>标志的容器来限制内存的使用。如果一个容器试图消耗比它的限制更多的内存，系统将杀死它，并以内存不足异常(OOM)退出进程。默认情况下，容器将被允许使用与内存限制相同的交换空间，实际上是内存限制的两倍。当然前提是交换空间在主机上没有被禁用。</p><h2 id="dec3" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">仅映射您想要打开的端口</h2><p id="2bfb" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">端口映射总是从主机到容器，因此<code class="fe ox oy oz pa b">-p 8080:80</code>将是主机上端口8080到容器上端口80的映射。</p><blockquote class="nd ne nf"><p id="9572" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">提示:在生产中运行容器时，最好使用带有静态端口的“-p”选项。</em></p></blockquote><h2 id="a7cf" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用trivy扫描图像漏洞</h2><p id="7e1b" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">使用开源图像时，扫描安全漏洞至关重要。幸运的是，有很多商业和开源工具可以帮助完成这项任务。</p><blockquote class="nd ne nf"><p id="9e1b" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><a class="ae jd" href="https://www.aquasec.com/products/trivy/" rel="noopener ugc nofollow" target="_blank">来自Aquasecurity的trivy】</a></p></blockquote><p id="5032" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">使用trivy是琐碎的；)<code class="fe ox oy oz pa b">trivy image nginx</code>揭示了一个带有CVEs链接的漏洞列表</p><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ps"><img src="../Images/c603d0d180cd93e85a030716f5d7b0be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xT83u_6S3XhRnxOF.png"/></div></div></figure><p id="b9f6" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">此外，除了扫描图像，trivy还可以搜索other文件和其他配置中的错误配置和漏洞。</p><p id="c3dd" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">下面是对一个示例项目的简单扫描结果:</p><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pt"><img src="../Images/87a8bc3f00fcdc709788c925a457a8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OJpYg2P2zAmRTOos.png"/></div></div></figure><h2 id="4fdc" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在Dockerfile上使用棉绒</h2><p id="585c" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">作为开发过程的一部分，确保你的docker文件有良好的林挺规则。</p><p id="a42f" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">一个很好的例子是Replicated开发的一个叫做<a class="ae jd" href="https://www.fromlatest.io/#/" rel="noopener ugc nofollow" target="_blank">的简单工具。</a></p><p id="e953" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">以下是该工具的屏幕截图及建议:</p><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pu"><img src="../Images/0d8392838d61ad8dee2fe37b4227da65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QQPCsGFSQm6gP3HK.png"/></div></div></figure><blockquote class="nd ne nf"><p id="98fc" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">考虑在你选择的编辑器中安装林挺插件，并在你的CI流程中运行林挺。</em></p></blockquote><h2 id="ccf9" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用潜水检查图像</h2><p id="5505" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">Docker和类似的工具提供了检查图像的选项。</p><p id="a806" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><code class="fe ox oy oz pa b">docker inspect [image name] --format</code> -该命令将以JSON格式显示图像信息。</p><blockquote class="nd ne nf"><p id="3734" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">您可以通过管道将命令输出到</em> <code class="fe ox oy oz pa b"><em class="jg">jq</em></code> <em class="jg">并查询结果。例如，如果你有一个nginx图像，你可以很容易地查询像这样的环境变量</em>T2】</p></blockquote><p id="47a6" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">然而，这种信息是相当初步的。要更深入地检查图像，使用<a class="ae jd" href="https://github.com/wagoodman/dive" rel="noopener ugc nofollow" target="_blank">潜水</a></p><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pv"><img src="../Images/cc8149b6daf3a8e96339812d353d6c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JwZSc5L1lXQOBJRVRjOg5w.png"/></div></div></figure><p id="d9ed" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">遵循您的系统的安装说明。Dive显示了用于创建图层的图像内容和命令的详细信息。</p><h2 id="95ab" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">分解图像</h2><p id="e327" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">如果您不能安装像dive这样的工具，可以使用这个简单的方法来分解容器映像。</p><p id="7018" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">容器图像只是包含其他文件作为层的<a class="ae jd" href="https://en.wikipedia.org/wiki/Tar_(computing)" rel="noopener ugc nofollow" target="_blank"> tar文件</a>。</p><p id="3627" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">以下是如何提取和保存Nginx图像并检查其内容:</p><pre class="os ot ou ov gt pb pa pc pd aw pe bi"><span id="b15f" class="kv kw jg pa b gy pf pg l ph pi">docker save nginx &gt; nginx_image.tar </span><span id="4d8b" class="kv kw jg pa b gy pq pg l ph pi">mkdir nginx_image cd nginx_image </span><span id="2801" class="kv kw jg pa b gy pq pg l ph pi">tar -xvf ../nginx_image.tar tree -C</span></pre><p id="600c" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">每一层对应Dockerfile中的命令。提取一个<code class="fe ox oy oz pa b">layer.tar</code>文件将显示该层的文件和设置。</p><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pw"><img src="../Images/18d20f55f76ea77acd767b855dc03dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Buit4d7I1VECCuNy407-yQ.png"/></div></div></figure><h2 id="5945" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">考虑签名和验证图像</h2><p id="4458" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">供应链攻击最近越来越频繁。可信且可验证的源代码和可追溯的<a class="ae jd" href="https://en.wikipedia.org/wiki/Software_bill_of_materials" rel="noopener ugc nofollow" target="_blank">软件材料清单</a>对于整个生态系统的安全性和完整性至关重要。</p><p id="0adc" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">您可以使用来自<a class="ae jd" href="https://www.sigstore.dev/" rel="noopener ugc nofollow" target="_blank"> SigStore项目</a>的工具为您的图像签名</p><blockquote class="nd ne nf"><p id="18ef" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg"> Sigstore是</em> <a class="ae jd" href="https://www.linuxfoundation.org/" rel="noopener ugc nofollow" target="_blank"> <em class="jg"> Linux基金会</em> </a> <em class="jg">的一部分，将自己定义为“软件签名、验证和保护的新标准”。</em></p></blockquote><p id="0e84" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">SigStore旗下有很多工具，但我们感兴趣的是<a class="ae jd" href="https://github.com/sigstore/cosign" rel="noopener ugc nofollow" target="_blank"> Cosign </a>。遵循Cosign repo中的安装步骤。</p><p id="f0e3" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">以下是如何签名您的图像并将其推送到Docker hub:</p><pre class="os ot ou ov gt pb pa pc pd aw pe bi"><span id="4730" class="kv kw jg pa b gy pf pg l ph pi">cosign generate-key-pair #this will generate 2 files, one with private and one with public key </span><span id="cba3" class="kv kw jg pa b gy pq pg l ph pi">cosign sign -key cosign.key &lt;dockeruser/image:tag&gt;</span></pre></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="0660" class="nr kw jg bd kx ns nt nu la nv nw nx ld km ny kn lh kp nz kq ll ks oa kt lp ob bi translated">建造和运输</h1><p id="fea5" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">由于标准化的打包(映像)和运行时(容器)，运送容器化的软件变得更加容易和更加简化。CI/CD和系统自动化工具极大地受益于此。</p><p id="c479" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">如今，管道遵循<strong class="lt jh">“X-As Code”</strong>运动，被表示为YAML文件，并与源代码文件一起托管在git存储库中。</p><p id="9d14" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这些YAML文件的确切语法因提供商而异。Azure DevOps、GitHub、GitLab等都会有它们的变种。</p><p id="1cc8" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">然而，有几个关键的组成部分。以下是Azure DevOps的YAML管道文件示例，包含最重要的定义:</p><ul class=""><li id="d687" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated"><strong class="lt jh">资源</strong>:管道运行所需的额外资源。可以是其他管道、图像存储库等</li><li id="d0ec" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">触发</strong>:如何触发流水线，只能针对特定的分支，拉取请求等</li><li id="a9e2" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">路径</strong>:对于触发器分支/PR，源代码工作的路径是什么</li><li id="0f77" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">变量</strong>:为了方便起见，大多数管道运行程序会提供一种将变量注入管道的方法</li><li id="64b0" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">池</strong>:运行管道作业的虚拟机或容器</li><li id="600e" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">阶段</strong>:流水线的连续阶段，阶段是作业的逻辑分组</li><li id="f424" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">作业</strong>:阶段内的另一个分组级别</li><li id="c564" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">任务</strong>:对工件/源代码执行的实际活动</li></ul><figure class="os ot ou ov gt is"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="c03a" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">一般来说，CI/CD管道还有更多的内容，这里的重点是实际上从项目的开始就包含一个管道。</p><h2 id="a920" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用Kaniko或Buildah构建图像</h2><p id="3673" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">为了增加安全性，考虑使用<a class="ae jd" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>或<a class="ae jd" href="https://buildah.io/" rel="noopener ugc nofollow" target="_blank"> Buildah </a>代替Docker在管道中构建图像。</p><p id="c942" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这两个工具都不依赖于Docker守护进程，并且完全在用户空间中执行Docker文件中的每个命令。这使得在不能轻松或安全地运行Docker守护进程的环境中构建容器映像成为可能，比如标准的Kubernetes集群。Kaniko更倾向于在Kubernetes集群中构建图像，而Buildah只处理docker图像就可以了。</p><h2 id="6dae" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在构建过程中实现图像扫描</h2><p id="4e58" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">图像扫描是指分析内容的过程和容器图像的构建过程，以便检测安全问题、漏洞或不良行为。</p><blockquote class="nd ne nf"><p id="5016" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">推荐:目前有三种主要的图像扫描工具</em></p><p id="69fc" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><strong class="lt jh"> Snyk </strong></p><p id="db8a" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated">Sysdig</p><p id="87fe" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated">Aqua我推荐使用Snyk，更详细的对比请看<a class="ae jd" href="https://codefresh.io/security-testing/comparison-snyk-aqua-security-sysdig/" rel="noopener ugc nofollow" target="_blank">这个博客</a></p></blockquote><p id="81dc" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">将图像扫描与CI/CD管道集成时，请遵循以下最佳实践:</p><ol class=""><li id="57be" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj pm ms mt mu bi translated">扫描来自构建管道(CI)的图像</li><li id="1b6c" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated">在从存储库中创建容器之前，扫描存储库中的图像(CI)</li><li id="2513" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated">扫描运行中的容器(CD)</li><li id="d6c4" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated">始终明确固定映像版本(不要使用“最新”或“暂存”标签)</li></ol><blockquote class="nd ne nf"><p id="b57b" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">关于如何使用Synk与Azure Pipelines集成图像扫描的详细说明，例如，请参见Snyk文档</em> <a class="ae jd" href="https://support.snyk.io/hc/en-us/articles/360004127677-Azure-Pipelines-integration" rel="noopener ugc nofollow" target="_blank"> <em class="jg"/></a></p></blockquote></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="04f6" class="nr kw jg bd kx ns nt nu la nv nw nx ld km ny kn lh kp nz kq ll ks oa kt lp ob bi translated">操作</h1><p id="3414" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">如今，在原始容器上的操作(没有orchestrator)主要发生在简单的工作负载或非生产环境中。物联网或边缘设备是一个例外，但即使在这些领域，Kubernetes也迅速占据了主导地位。</p><h2 id="677c" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">装置</h2><p id="1fd3" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">在Linux发行版上安装docker引擎非常简单。请遵循Docker文档中的<a class="ae jd" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">安装步骤</a>。</p><p id="2e14" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">在Windows Server上安装docker engine有点困难，按照本教程<a class="ae jd" href="https://computingforgeeks.com/how-to-run-docker-containers-on-windows-server-2019/" rel="noopener ugc nofollow" target="_blank">安装和配置所有的先决条件。</a></p><blockquote class="nd ne nf"><p id="bc99" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">默认情况下，只有windows容器才会在Windows服务器上运行。Linux容器必须额外打开(以上文档的一部分)</em></p></blockquote><p id="6126" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">一旦docker主机安装完毕，您就可以使用<a class="ae jd" href="https://www.portainer.io/" rel="noopener ugc nofollow" target="_blank"> Portainer </a>与显示器交互并排除故障。</p><p id="6c82" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">根据您所处的环境选择<a class="ae jd" href="https://documentation.portainer.io/v2.0/deploy/ceinstalldocker/" rel="noopener ugc nofollow" target="_blank">安装选项</a>。</p><figure class="os ot ou ov gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pn"><img src="../Images/e10c4e51f44c7c8c1269092d36ba6d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HU5jxLzE_MNzOhul.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><em class="px">样本便携式仪表板</em></figcaption></figure><blockquote class="nd ne nf"><p id="79bc" class="lr ls ng lt b lu mm kh lw lx mn kk lz nh na mb mc ni nb me mf nj nc mh mi mj ij bi translated"><em class="jg">安装完成后，docker会在</em> <code class="fe ox oy oz pa b"><em class="jg">/var/lib/docker/</em></code> <em class="jg">下创建一个文件夹，存储所有的容器、映像、卷和配置。Kubernetes和Docker Swarm将集群状态和相关信息存储在</em><a class="ae jd" href="https://etcd.io/" rel="noopener ugc nofollow" target="_blank"><em class="jg">etcd</em></a><em class="jg">中。默认情况下，etcd在端口</em> <code class="fe ox oy oz pa b"><em class="jg">2380</em></code> <em class="jg">上监听客户端连接。</em></p></blockquote><h2 id="ff2e" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用瞭望塔更新图像</h2><p id="b816" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">由于docker主机不提供自动图像更新，当图像被推送到您的图像注册表时，您可以使用<a class="ae jd" href="https://containrrr.dev/watchtower/" rel="noopener ugc nofollow" target="_blank">了望塔</a>自动更新图像。</p><pre class="os ot ou ov gt pb pa pc pd aw pe bi"><span id="6234" class="kv kw jg pa b gy pf pg l ph pi">docker run -d \ <br/>--name watchtower \ <br/>-e REPO_USER=username \ <br/>-e REPO_PASS=password \ <br/>-v /var/run/docker.sock:/var/run/docker.sock \ <br/>containrrr/watchtower container_to_watch --debug</span></pre></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="48d3" class="nr kw jg bd kx ns nt nu la nv nw nx ld km ny kn lh kp nz kq ll ks oa kt lp ob bi translated">摘要</h1><p id="b34b" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">如今，开发容器化的工作负载是服务器端软件开发的主要模式。无论您是在处理web应用程序、API、批处理作业还是服务，都有可能在某个时候将“Dockerfile”添加到项目中。</p><p id="eaac" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">当这种情况发生时，希望你已经收藏了这篇文章，并会在这里找到从一开始就做事情的灵感和指导。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="a42e" class="nr kw jg bd kx ns nt nu la nv nw nx ld km ny kn lh kp nz kq ll ks oa kt lp ob bi translated">链接和资源</h1><ol class=""><li id="64d3" class="mk ml jg lt b lu lv lx ly le pj li pk lm pl mj pm ms mt mu bi translated"><a class="ae jd" href="https://github.com/wsargent/docker-cheat-sheet" rel="noopener ugc nofollow" target="_blank"> Docker Cheatsheet </a></li><li id="7044" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated"><a class="ae jd" href="https://www.compose-spec.io/" rel="noopener ugc nofollow" target="_blank">作曲规范</a></li><li id="07e7" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated"><a class="ae jd" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">码头文件</a></li><li id="73a5" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated"><a class="ae jd" href="https://docs.mirantis.com/welcome/" rel="noopener ugc nofollow" target="_blank">米兰蒂斯文件</a></li><li id="9939" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated"><a class="ae jd" href="https://www.freecodecamp.org/news/the-docker-handbook/" rel="noopener ugc nofollow" target="_blank">码头工人手册</a></li><li id="ca01" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj pm ms mt mu bi translated"><a class="ae jd" href="https://nigelpoulton.com/" rel="noopener ugc nofollow" target="_blank">Docker Deep Dive——奈杰尔·波尔顿著</a></li></ol></div></div>    
</body>
</html>