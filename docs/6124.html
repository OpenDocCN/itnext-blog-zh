<html>
<head>
<title>How To Make An Android Runner Tracking App?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何做一个安卓跑步者追踪App？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-make-an-android-runner-tracking-app-bde9f2b676a4?source=collection_archive---------0-----------------------#2021-08-29">https://itnext.io/how-to-make-an-android-runner-tracking-app-bde9f2b676a4?source=collection_archive---------0-----------------------#2021-08-29</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="16b4" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用Google Map SDK来显示路线，空间来保存用户的数据，步数计数器来获得步数</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/b6deb0e65dfe9f1b5371f0c2977c91ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iEgxHItbNcpzVRhb"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://unsplash.com/photos/d3bYmnZ0ank" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的封面照片</figcaption></figure><p id="1890" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi lw translated">跑步是所有人的健康习惯。对于用户来说，在地图上查看他们的跑步路线和步数是一个很大的好处。Android提供了很多工具来实现这些功能。在本教程中，您将使用以下工具构建这种追踪应用程序:</p><ol class=""><li id="9831" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b"><a class="ae kz" href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient" rel="noopener ugc nofollow" target="_blank">FusedLocationProviderClient</a></code> : <br/>该提供商客户端可以以一定的时间间隔重复检索用户的当前位置。用户必须向应用授予<a class="ae kz" href="https://developer.android.com/training/location/permissions" rel="noopener ugc nofollow" target="_blank">位置权限</a>。</li><li id="60bc" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b"><a class="ae kz" href="https://developer.android.com/reference/android/hardware/SensorManager" rel="noopener ugc nofollow" target="_blank">SensorManager</a></code> : <br/>这个管理器是app和计步器之间的桥梁。</li><li id="6ed2" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b"><a class="ae kz" href="https://developers.google.com/maps/documentation/android-sdk/overview" rel="noopener ugc nofollow" target="_blank">Google Map SDK</a></code> : <br/>这个SDK让开发者将<a class="ae kz" href="https://developers.google.com/android/reference/com/google/android/gms/maps/MapFragment" rel="noopener ugc nofollow" target="_blank">谷歌地图片段</a>嵌入到他/她的应用中。在与Google服务器连接时，它需要一个API密钥进行身份验证。开发者还可以在地图上添加一条路线来显示用户以前的位置。</li><li id="137b" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b"><a class="ae kz" href="https://developer.android.com/topic/libraries/architecture/room" rel="noopener ugc nofollow" target="_blank">Room</a></code> : <br/> <em class="mx">房间</em>是Google的SQLite数据库抽象库。开发人员可以通过使用SQL命令轻松执行CRUD。</li></ol></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="4c0e" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">入门指南</h1><p id="bf68" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">要开始，请在此处或本教程末尾下载<a class="ae kz" href="https://github.com/myrickchow32/RunnerTrackingAppStarter" rel="noopener ugc nofollow" target="_blank">启动项目</a>。在starter项目中，您会发现一个简单的应用程序<code class="fe mo mp mq mr b">Activity</code>，包含以下组件:</p><ol class=""><li id="7bab" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated"><strong class="lc iv">开始按钮</strong>:开始读取用户的位置和步数。</li><li id="e11f" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><strong class="lc iv">结束按钮</strong>:终止跟踪。</li><li id="7df0" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">一组<strong class="lc iv">文本视图</strong>:显示步数、总行驶距离和平均速度。</li><li id="1602" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">一个<strong class="lc iv">谷歌地图片段</strong>:显示用户走过的路线。</li></ol><p id="8f97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构建并运行。您会看到类似这样的内容:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/0b232c7c4b7f91e163d4eb4d76ce5cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*7bGPeMHN0Z9LzG5SGIJ2vg.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">starter项目的屏幕截图</figcaption></figure><p id="50d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你会看到谷歌地图片段现在什么也没有显示。是因为<code class="fe mo mp mq mr b">google_maps_api.xml</code> <strong class="lc iv"> </strong>文件缺少Google地图SDK API key，地图碎片无法连接Google服务器。您将在下一节学习如何获得一个。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="4579" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">获取谷歌地图API密钥</h1><p id="599a" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">谷歌根据使用的数据量向开发者收费，并为使用任何云工具验证每个应用程序生成API密钥。因此，你必须尽可能保证API密匙<strong class="lc iv">的安全，以防止任何意外的账单和费用。</strong></p><ol class=""><li id="d260" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">在<a class="ae kz" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云控制台</a>创建一个账户和一个项目</li></ol><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj od"><img src="../Images/d8406bf68dd3c1840f73440a5fe08bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/0*iFROh57bYe34QcxK.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">谷歌云控制台图标</figcaption></figure><p id="ae98" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">2.进入<strong class="lc iv">侧菜单</strong> &gt; <strong class="lc iv">“仪表板”</strong>&gt;<strong class="lc iv">“API&amp;服务”</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oe"><img src="../Images/bab90b0c11c1519652a271b0cd858db7.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/0*dWkDxcdNxaqLpWn7.png"/></div></figure><p id="4aef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">3.点击页面顶部的<strong class="lc iv">“启用API和服务”</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/21b5eb8bd71fbd32c6ef6c4ea4eb0b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*LaeB8hN2oYdS2-G0.png"/></div></figure><p id="1f00" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">4.搜索或点击<strong class="lc iv">Android版地图SDK</strong>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/c9c89c4d2c21ea1a6b26cbda71354135.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*EDlZe0NX3rORQnUd.png"/></div></figure><p id="1cbc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">5.点击<strong class="lc iv">启用</strong>激活API</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/1aae1ef20a73fde8cab7acb06d909f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*Nj4sYhbsLcoWjSBd.png"/></div></figure><p id="6323" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">6.转到侧面菜单中的“<strong class="lc iv">凭据</strong>选项卡，然后单击页面顶部的“<strong class="lc iv">创建凭据</strong>”。在弹出的对话框中点击<strong class="lc iv"> API键</strong>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/de382fe0d3379081dc42224e6303a65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*pl1DSj7SKFws7CSt.png"/></div></figure><p id="c82c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">7.复制生成的API密钥</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/f7df623eeba42f1d5977d39a0badc9dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*tUWp_h9j0r6rgzA3.png"/></div></figure><p id="94d4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">8.将生成的API密匙粘贴到<strong class="lc iv"> google_maps_api.xml </strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/3b3da61a0830f27fe446f9ba50d961a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*fyh6A3kypLDAYQ-2.png"/></div></figure><p id="e5f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">9.构建并运行。您将在地图片段处看到地图，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/d42c92bc55e069bb941fe596bbd05a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*q0o6ZcfKBbvMox97hpgQJA.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">谷歌地图使用API键可以正常工作</figcaption></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="2bfc" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">限制您的API密钥</h1><p id="6077" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">上一节生成的API key是一个<strong class="lc iv">无限制的key </strong>，这意味着每一个拥有这个key的开发者都可以使用所有的云工具，包括Firebase ML API、Firebase Remote Config API、Cloud Trace API等。你应该限制钥匙，以防止使用任何不必要的工具，招致额外的账单。</p><ol class=""><li id="8c7d" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">转到“<strong class="lc iv">API&amp;服务</strong>”的“<strong class="lc iv">凭证</strong>”选项卡，并选择您的API密钥。</li></ol><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/26eb60c92daf38bf58ac66d8bcf33635.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*HSKYRiALqBP6jT9m.png"/></div></figure><p id="9050" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">2.在“<strong class="lc iv">应用限制</strong>”部分选择<strong class="lc iv">“Android apps”</strong>，输入包名和SHA-1，包含在下一步中。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj og"><img src="../Images/e44abe9383e5b04833f019d4c7c5fca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*qF3mbG2FkwdoHJoY7bq2QA.png"/></div></figure><p id="f83c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">3.用<code class="fe mo mp mq mr b"><strong class="lc iv">debug.keystore</strong></code>生成调试SHA-1证书指纹</p><p id="32af" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">调试指纹是根据开发时给app签名的<code class="fe mo mp mq mr b">debug.keystore</code>生成的。通过在Android Studio终端运行以下命令，您将很容易获得调试SHA-1证书指纹。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/71b5e3e0982b386058e36018a914871a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*hZDFIGU-oXChybOG.png"/></div></figure><p id="90d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">4.用<code class="fe mo mp mq mr b"><strong class="lc iv">release.keystore</strong></code>生成发行SHA-1证书指纹</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="d781" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，您还需要生成一个发布指纹，因为您将使用不同的密钥库(例如<code class="fe mo mp mq mr b">release.keystore</code>)将应用程序签名到Google Play。用自己的值替换下面的<code class="fe mo mp mq mr b">fooReleaseKeystorePath</code>、<code class="fe mo mp mq mr b">fooAliasName</code>、<code class="fe mo mp mq mr b">fooStorePassword</code>、<code class="fe mo mp mq mr b">fooKeyPassword</code>。在Android Studio终端运行它，您将获得您的发布指纹。</p><p id="c98b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">5.在<strong class="lc iv">“API限制”</strong>部分选择<strong class="lc iv">“Android版地图SDK”</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/f3a31d7ecaad66c0d592e3e70f6b6521.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*YTlp5O927QbB8DfT.png"/></div></figure><p id="bbe7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">6.你现在只能使用Android谷歌地图SDK的API键。如果您在其他Google Cloud工具中使用它，例如Firebase ML API，您应该会看到错误。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="8f0e" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">开始跑步</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oj"><img src="../Images/bc590cc52a6d78cfc6d6e70226113f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/0*3wPrLb7hvSfV1P0T.png"/></div></figure><p id="6fe1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Android设备可以有许多不同的传感器，例如计步器、加速度计和陀螺仪等。计步传感器可以获得自上次启动时间以来用户已经走了<strong class="lc iv">的步数。你可以用这个传感器来计算平均速度。然而，步数计数器有一个限制——感应到的事件和报告的事件之间的时间差最多可达<a class="ae kz" href="https://developer.android.com/guide/topics/sensors/sensors_motion#sensors-motion-stepcounter" rel="noopener ugc nofollow" target="_blank"> 10秒</a>。因此，不能保证实时向用户显示步数。</strong></p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="e876" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">请求体育活动许可</h1><p id="fbf4" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">在从<code class="fe mo mp mq mr b">SensorManager</code>中获取步数之前，你还必须考虑到Google已经从API 29开始限制步数传感器的可用性。<code class="fe mo mp mq mr b"><strong class="lc iv">ACTIVITY_RECOGNITION</strong></code>必须获得许可才能获得用户的步数。如果您的目标只是API 28或更低版本，您可以跳过以下三个步骤。</p><h2 id="fc55" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">1)添加使用用户计步器的许可请求</h2><p id="fc4a" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">从谷歌的角度来看，用户的隐私是最重要的。从API 29开始，<a class="ae kz" href="https://developer.android.com/about/versions/10/privacy/changes#physical-activity-recognition" rel="noopener ugc nofollow" target="_blank">谷歌将用户身体活动的使用归类为敏感隐私，并要求所有应用程序在运行时请求此许可</a>。如果您的目标用户是运行Android API 29或更新版本的用户，您必须在<code class="fe mo mp mq mr b">AndroidManifest.xml</code>标签下粘贴以下代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><h2 id="2bd4" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">2)添加权限请求库</h2><p id="fafd" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">Android中请求运行时权限和处理用户响应的过程包含一些样板代码。你可以利用一些公共图书馆以更简单的方式来完成这项任务。其中一个有用的库是基于Google工程师编写的<code class="fe mo mp mq mr b"><a class="ae kz" href="https://github.com/googlesamples/easypermissions" rel="noopener ugc nofollow" target="_blank">EasyPermissions</a></code>构建的<code class="fe mo mp mq mr b"><a class="ae kz" href="https://github.com/VMadalin/easypermissions-ktx" rel="noopener ugc nofollow" target="_blank">EasyPermissions-ktx</a></code>。将以下代码添加到app/build.gradle中，以将<code class="fe mo mp mq mr b"><a class="ae kz" href="https://github.com/VMadalin/easypermissions-ktx" rel="noopener ugc nofollow" target="_blank">EasyPermissions-ktx</a></code>添加到您的项目中:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><h2 id="2195" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">3)请求<strong class="ak">活动识别</strong>权限</h2><p id="3fee" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">请求<code class="fe mo mp mq mr b">ACTIVITY_RECOGNITION</code>很简单。当用户的设备API等级为29或以上时，只需要在下面的代码处调用一个单独的函数<code class="fe mo mp mq mr b">EasyPermissions.requestPermissions()</code>。在<code class="fe mo mp mq mr b">MapsActivity</code>处的<code class="fe mo mp mq mr b"> startTracking()</code>函数上放置以下代码。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><h2 id="3e6e" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">4)构建并运行</h2><p id="e327" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">单击开始按钮，您将看到以下弹出对话框，用于请求体育活动许可。授予许可后，您将在Android Studio日志中看到结果。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/22d9813d1c8ef2112a1c96146a190008.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/0*3B9KBUjXqZJ3_lxw.png"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ox"><img src="../Images/7c5d0fdd7ed2a62bc01005c2daed5757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ad-eAerWEHS0C0pziJLD2g.png"/></div></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="178d" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">设置步骤计数器监听器</h1><p id="a0e4" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">在获得用户访问计步传感器的权限后，您现在将设置一个监听器来观察它的变化。</p><h2 id="02dd" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">1)设置计步监听器</h2><p id="bc56" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">每次有更新时，Android设备中的步数计数器都会发回步数。您必须注册一个监听器，并在<code class="fe mo mp mq mr b">Activity</code>级别处理新数据。在<code class="fe mo mp mq mr b">MapsActivity.kt</code>处添加以下代码</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><ol class=""><li id="cd13" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">首先，你得到了<code class="fe mo mp mq mr b">SensorManager</code>系统服务。</li><li id="981b" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">然后，您可以访问设备的计步传感器。</li><li id="1cb0" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">由于这个传感器在Android环境中是一个可选的硬件，所以您必须添加一个<code class="fe mo mp mq mr b">null</code>检查来确保设备中有一个。</li><li id="95ad" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">您会在<code class="fe mo mp mq mr b">registerListener</code>函数中看到一个错误，因为您还没有实现下一步中包含的<code class="fe mo mp mq mr b">SensorEventListener</code>。</li></ol><p id="842d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mo mp mq mr b">registerListener</code>功能的第三个参数是以微秒为单位的采样周期率。请注意，这只是对系统的一个提示。接收事件的速度可能比指定的速度快或慢。您可以使用4种不同的选项:</p><ol class=""><li id="27cc" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b">SENSOR_DELAY_FASTEST</code> : 0us</li><li id="9e90" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b">SENSOR_DELAY_UI</code>:1美国</li><li id="2ebf" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b">SENSOR_DELAY_GAME</code> : 2us</li><li id="e051" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b">SENSOR_DELAY_NORMAL</code> : 3us</li></ol><p id="f21e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为你正在开发一个追踪应用程序，你应该选择较低的采样率，以尽可能快地获得步数。因此，使用<code class="fe mo mp mq mr b">SENSOR_DELAY_FASTEST</code>。当用户授予<code class="fe mo mp mq mr b">ACTIVITY_RECOGNITION</code>权限时，调用函数<code class="fe mo mp mq mr b">setupStepCounterListener()</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><h2 id="0c77" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">2)处理来自步数计数器的数据</h2><p id="9df6" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">这时，Android Studio会警告你缺少<code class="fe mo mp mq mr b">SensorEventListener</code>接口的实现。现在，更新<code class="fe mo mp mq mr b">MapsActivity</code>类声明，并将下面的代码粘贴到body部分。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><h2 id="0c68" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">3)构建并运行。</h2><p id="4eca" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">尝试摇动你的设备，你可以看到日志<code class="fe mo mp mq mr b">onSensorChanged</code>连续记录。回拨可能会有短暂的延迟。根据<a class="ae kz" href="https://developer.android.com/guide/topics/sensors/sensors_motion#sensors-motion-stepcounter" rel="noopener ugc nofollow" target="_blank">官方文档</a>，延时最多10秒。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/26f00d1fec056006ab82733085e5ea20.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*r7WU6na3dClhpsd5.png"/></div></figure><h2 id="6d4f" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">4)从<code class="fe mo mp mq mr b">SensorEvent</code>中检索步数</h2><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/0712feca97088edbfcdbc36ee9989a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*F-fAGPAGyJO8TXyu.png"/></div></figure><p id="6394" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据官方文档，<code class="fe mo mp mq mr b">values</code>属性的第一个元素是自上次引导以来的步数。用以下内容替换<code class="fe mo mp mq mr b">onSensorChanged</code>功能:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><ol class=""><li id="ae70" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">如果<code class="fe mo mp mq mr b">sensorEvent</code>不是<code class="fe mo mp mq mr b">null</code>，则继续函数的剩余部分，否则返回。</li><li id="b77c" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">因为这个回调可能被其他传感器触发，而这些传感器不能返回任何值，所以您还必须向第一个元素添加一个<code class="fe mo mp mq mr b">null</code>检查。</li></ol><h2 id="5759" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">5)构建并再次运行</h2><p id="91b6" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">摇动你的设备，你可以看到下面的日志</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/613cd76eb890763bcfdac9d2be19b67b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*7VGwANLHoZYzksSf.png"/></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="6715" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">计步器的技巧</h1><p id="9367" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">如本节开头所述，返回的步数指的是从上次设备启动开始的总步数。因此，当用户开始跑步或按下开始跑步按钮时，您需要保存初始步数以跟踪当前步数。在<code class="fe mo mp mq mr b">MapsActivity</code>中添加实例变量:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="6c9b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe mo mp mq mr b">onSensorChanged</code>函数的<code class="fe mo mp mq mr b">firstOrNull()?.let</code>回调中添加以下代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="e589" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构建并运行。您将在这里看到标准化的步数:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/03d8a9ba2c74193f9e11ba2af931f0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*lDMgNGOx3tp6q0Y-.png"/></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="a94a" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">使用FusedLocationManager获取位置数据</h1><p id="2750" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">从用户的角度来看，位置信息是敏感的。您必须首先向用户请求位置权限。</p><h2 id="af98" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">1)请求位置许可</h2><p id="e19d" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">您可以使用两种类型的位置权限:— <code class="fe mo mp mq mr b">ACCESS_FINE_LOCATION</code>:让应用程序访问精确的位置。— <code class="fe mo mp mq mr b">ACCESS_COARSE_LOCATION</code>:让一个应用程序访问一个大概的位置。在这种情况下，你应该选择<code class="fe mo mp mq mr b">ACCESS_FINE_LOCATION</code>。您不必明确请求位置权限，因为Google Maps SDK会为您完成。在清单标签下面的<code class="fe mo mp mq mr b">AndroidManifest.xml</code>中添加以下代码。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><h2 id="5441" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">2)添加播放服务位置依赖性</h2><p id="1d55" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated"><code class="fe mo mp mq mr b">FusedLocationManager</code>使用Google Play服务来检测和计算用户的当前位置。将下面的依赖关系添加到依赖关系块内的<code class="fe mo mp mq mr b">app/build.gradle</code>文件中</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><h2 id="df55" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">3)在<code class="fe mo mp mq mr b">MapsActivity</code>的顶部声明<code class="fe mo mp mq mr b">FusedLocationProviderClient</code>实例</h2><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><h2 id="d5fc" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">4)初始化<code class="fe mo mp mq mr b">MapsActivity</code>的<code class="fe mo mp mq mr b">onCreate()</code>回调函数中的<code class="fe mo mp mq mr b">FusedLocationProviderClient</code>对象</h2><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><h2 id="9da1" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">5)注册位置变更监听器</h2><p id="21b0" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">一旦Android操作系统检测到任何位置变化，它就会将数据发送回注册的监听器。将以下代码粘贴到<code class="fe mo mp mq mr b">MapsActivity</code>中，以注册位置回调:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="966a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里，您使用先前创建的<code class="fe mo mp mq mr b">fusedLocationProviderClient</code>实例来请求带有特定<code class="fe mo mp mq mr b">LocationRequest</code>的位置更新。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/b0327164f71660e6bb55c07262484465.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*4P3FKssAjxoqiA_o.png"/></div></figure><p id="b9d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">位置请求的间隔设置为5000毫秒。这意味着应用程序将每5秒请求用户的位置。这个间隔足够小以平衡跟踪特征和电池消耗。</p><h2 id="2d5b" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated">6)在<code class="fe mo mp mq mr b">startTracking</code>功能处调用<code class="fe mo mp mq mr b">setupLocationChangeListener</code>功能</h2><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="ca07" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构建您的应用程序。点击开始，四处走动一分钟。您会发现如下位置更新日志:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/6c0ef60fe93c03ee9b6253ebcc6a849f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*NVCtdTQc4J_o8kqD.png"/></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="4349" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">模拟位置变化</h1><p id="ca5c" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">走很长时间去调试一个app，在现实情况下是不可行的。在开发阶段，在Android中模拟一个位置有两种选择。</p><h2 id="853b" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated"><strong class="ak">1)Android Studio中的Android模拟器</strong></h2><p id="5a0b" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">您可以将GPX/KML文件导入Android模拟器来模拟位置路线。这里有一个GitHub上的<a class="ae kz" href="https://github.com/gps-touring/sample-gpx/blob/master/RoscoffCoastal/1_Roscoff_Morlaix_A_parcours.gpx" rel="noopener ugc nofollow" target="_blank"> GPX文件</a>的例子。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oy"><img src="../Images/fefa691b9c03fecfeecaf137ff46f226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*lyk9qnpPXZ89jXwA.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">Android模拟器截图</figcaption></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oz"><img src="../Images/4324d2537a010cd294956e7047bd4db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/0*GrqoSYB7WxsS4ECU.jpg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">用于导入GPX文件的Android模拟器截图</figcaption></figure><h2 id="8836" class="ok ng iu bd nh ol om dn nl on oo dp np lj op oq nr ln or os nt lr ot ou nv ov bi translated"><strong class="ak"> 2)真实装置</strong></h2><p id="17c4" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">在Play Store中，你可以找到多个可以模仿设备GPS的应用程序。你可以下载其中一个来模拟GPS进行调试。一个例子是<a class="ae kz" href="https://play.google.com/store/apps/details?id=net.marlove.mockgps&amp;hl=en&amp;gl=US" rel="noopener ugc nofollow" target="_blank">“模拟GPS”</a>app。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="e19e" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">显示用户的当前位置</h1><p id="4fef" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">将以下功能<code class="fe mo mp mq mr b"> showUserLocation</code>添加到<code class="fe mo mp mq mr b">MapsActivity</code>中，并在<code class="fe mo mp mq mr b">mMap = googleMap</code>之后的<code class="fe mo mp mq mr b">onMapReady</code>功能处触发，以确保<code class="fe mo mp mq mr b">mMap</code>在被访问之前被初始化。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="9f38" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过启用<code class="fe mo mp mq mr b">isMyLocationEnabled</code>属性，用户的当前位置可以显示在地图上。构建并运行。你会看到:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pa"><img src="../Images/d92072f406b93b733e4e1705e3938e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/0*fgOr2_IhokUX7nev.png"/></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="73b2" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">在地图上显示路线</h1><p id="3144" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">该应用程序应该能够显示用户从起点到当前位置的路线。您将使用谷歌地图的API <code class="fe mo mp mq mr b">Polyline</code>在地图上画一条线。将以下代码添加到<code class="fe mo mp mq mr b">MapsActivity</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="4604" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">代码接收从<code class="fe mo mp mq mr b">onLocationResult</code>中检索的新位置列表，并用这些位置构造一个<code class="fe mo mp mq mr b">LatLng</code>列表。该列表作为<code class="fe mo mp mq mr b">PolylineOptions</code>附加到地图上。在<code class="fe mo mp mq mr b">MapsActivity</code>中的<code class="fe mo mp mq mr b">onLocationResult</code>回调处调用<code class="fe mo mp mq mr b">addLocationToRoute</code>函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="20ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构建并运行。当用户的位置改变时，你会看到一条线被画出来。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pb"><img src="../Images/b24c4faa1053b8b1743722d1eda98037.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*vQ0vmtGnWSk5fNil.png"/></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="a4ba" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">房间数据库大纲</h1><p id="8b2a" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">此刻，如果你重启应用程序，地图上的路线就会消失。要解决这个问题，需要保存路线数据。这可以使用<code class="fe mo mp mq mr b"><strong class="lc iv">Room</strong></code>持久数据库来完成。<code class="fe mo mp mq mr b"><strong class="lc iv">Room</strong></code>是<code class="fe mo mp mq mr b">SQLite</code>之上的抽象层。您只需要创建三个文件来访问房间数据库:</p><ol class=""><li id="15ef" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated"><strong class="lc iv">实体文件</strong>:包含一个用<code class="fe mo mp mq mr b">@Entity</code>注释标注的类。如果批注中没有指定，则类的每个实例用类名表示表中的一行</li><li id="8bd5" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><strong class="lc iv"> DAO </strong>:提供方法(CRUD ),应用程序的其余部分使用这些方法与特定表中的数据进行交互</li><li id="a031" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><strong class="lc iv">数据库</strong>:扩展<code class="fe mo mp mq mr b">RoomDatabase</code>，定义数据库配置，并作为应用程序对持久化数据的主要访问点</li></ol><p id="89a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请记住，数据库操作应该<strong class="lc iv">而不是</strong>从主UI线程调用，以防止应用程序被冻结。您需要添加协程依赖来调用另一个线程中的作业。在<code class="fe mo mp mq mr b">app/build.gradle</code>文件中添加<code class="fe mo mp mq mr b">Room</code>和<code class="fe mo mp mq mr b">Coroutines</code>的依赖关系。在文件顶部添加以下代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="316a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe mo mp mq mr b">dependencies</code>块中添加依赖关系:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="bcf5" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">定义实体</h1><p id="f774" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated"><code class="fe mo mp mq mr b">Entity</code>是一个数据库表的记录结构。通常，有一个唯一标识记录和其他信息列的主键。您现在可以用下面的代码创建一个数据类— <code class="fe mo mp mq mr b">TrackingEntity</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="c266" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有几个重要的注释:</p><ol class=""><li id="d534" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b"><strong class="lc iv">@Entity</strong></code>:声明该数据类是可被<code class="fe mo mp mq mr b"><strong class="lc iv">Room</strong></code>库识别的实体</li><li id="ff7d" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b"><strong class="lc iv">@PrimaryKey</strong></code>:表示这是该实体的唯一标识符</li><li id="bfce" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b"><strong class="lc iv">@ColumnInfo</strong></code>:表示这是该实体的数据列</li></ol><p id="b74e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mo mp mq mr b">TrackingEntity</code>实体中有四个属性:</p><ol class=""><li id="68b4" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b">timestamp</code>:表示本次位置更新的时间，是该实体唯一标识各记录的主键。</li><li id="b63d" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b">latitude</code> &amp; <code class="fe mo mp mq mr b">longitude</code>:表示跟踪记录的地理细节。</li><li id="40fb" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b">distanceTravelled</code>:表示当前地理点与上一条记录中的地理点之间的距离。对于第一条记录，它是0。</li></ol><p id="61b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有两个有用的实例函数:</p><ol class=""><li id="1dbe" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b">asLatLng()</code>是一个转换器函数，用于将<code class="fe mo mp mq mr b">TrackingEntity</code>转换为<code class="fe mo mp mq mr b">LatLng</code>，以便在谷歌地图片段上绘制折线。</li><li id="7a30" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b">distanceTo()</code>用于计算两个<code class="fe mo mp mq mr b">TrackingEntity</code>之间的距离。<code class="fe mo mp mq mr b">Location</code>类已经考虑到地球曲率并精确计算距离。</li></ol><p id="f97e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">切记经纬度的单位是<strong class="lc iv">度</strong>而不是<strong class="lc iv">长</strong>，不能用勾股定理计算距离。</p><h1 id="28e4" class="nf ng iu bd nh ni pc nk nl nm pd no np ka pe kb nr kd pf ke nt kg pg kh nv nw bi translated">定义一个道</h1><p id="c56d" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">DAO的意思是<strong class="lc iv">数据访问对象</strong>，它包含访问数据库的CRUD函数。用以下代码创建一个<code class="fe mo mp mq mr b">TrackingDao</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="f437" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您用SQL命令创建了上述七个函数。一个一个看细节:</p><ol class=""><li id="fe5f" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">您从没有过滤的<code class="fe mo mp mq mr b">trackingentity</code>表中查询所有实体。在房间数据库中，默认情况下，表名是小写的类名。返回值在<code class="fe mo mp mq mr b">LiveData</code>的类中，当这个SQL命令的结果改变时，它会通知其他类。该功能的结果将被转换为<code class="fe mo mp mq mr b">LiveData</code>，并在<code class="fe mo mp mq mr b">Activity</code>级别观察是否有任何变化。</li><li id="f065" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">这与前面的函数相同，但是返回类型是<code class="fe mo mp mq mr b">List</code>而不是<code class="fe mo mp mq mr b">LiveData</code>。</li><li id="7036" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">您可以在所有追踪实体中查询行进距离的总和。</li><li id="5903" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">您按照时间戳对实体进行降序排序，并获得第一个实体。确保返回的<code class="fe mo mp mq mr b">TrackingEntity</code>是可选值，因为当数据库中没有记录时<code class="fe mo mp mq mr b">Room</code>数据库返回<code class="fe mo mp mq mr b">null</code>。</li><li id="f3ba" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">SQL命令与第四个函数相同，但它是一个挂起函数，只能在<code class="fe mo mp mq mr b">Coroutines</code>中调用，不会阻塞UI线程。</li><li id="2c50" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">将记录插入到<code class="fe mo mp mq mr b">Room</code>数据库中可以像注释<code class="fe mo mp mq mr b">@Insert</code>一样简单。</li><li id="1e02" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">该功能从<code class="fe mo mp mq mr b">trackingentity</code>表中删除所有实体。</li></ol></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="e8ba" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">定义数据库</h1><p id="18c3" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated"><code class="fe mo mp mq mr b">database</code>是一个抽象类，用于处理本地持久存储的操作。例如，定义数据库的当前版本以及在不同版本之间迁移数据的规则。用以下代码创建一个<code class="fe mo mp mq mr b">TrackingDatabase</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><ol class=""><li id="1f67" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">您需要用注释<code class="fe mo mp mq mr b">@Database</code>对数据库类进行注释，并定义数据库中涉及的实体列表。当数据库结构更新时，版本号用于数据迁移。</li><li id="a7e9" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">您需要从<code class="fe mo mp mq mr b">RoomDatabase</code>类扩展数据库类，并使其成为<code class="fe mo mp mq mr b">abstract</code>类。</li><li id="eaca" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">该函数向数据存储库公开DAO，这将在下一节中定义。</li><li id="e9c7" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">您通常只希望在一个应用程序中有一个数据库，因此您在这里采用了singleton模式。</li></ol></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="8203" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">定义存储库</h1><p id="a6f5" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">储存库可以被认为是从不同来源(例如本地持久存储、远程服务器存储和本地缓存)检索数据的数据管理器。其他类不需要知道数据来自哪里。这些类只需要立即处理数据。创建一个<code class="fe mo mp mq mr b">TrackingRepository</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><ol class=""><li id="ada3" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">您需要将您在上一节中定义的数据库中的DAO对象传递给这个存储库，以触发对数据库的SQL命令。不要将数据库实例传递到存储库中，因为不应该让存储库拥有对数据库的完全访问权限，而只能访问特定的DAO。建议将DAO标记为<code class="fe mo mp mq mr b">private</code>,因为您不应该将DAO直接暴露给这个项目中的其他对象或其他开发人员。</li><li id="77d0" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">这三个属性都属于<code class="fe mo mp mq mr b">LiveData</code>类型，然后可以在<code class="fe mo mp mq mr b">ViewModel</code>级别转换为<code class="fe mo mp mq mr b">LiveData</code>。</li><li id="d41b" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">这些是可以在协程中调用的挂起函数。</li></ol><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/85c2acfb23bce855703b6c4fe22b1d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*nxNGlTBWOMRjRAqe.png"/></div></figure><p id="940c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可能对这个项目是否需要存储库层有疑问，为什么不在ViewModel级别直接使用DAO。以下是一些评论:</p><ol class=""><li id="2fea" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">在一个真实的应用程序中，可以有多个数据源。例如，房间数据库、云Firestore本地缓存和云Firestore远程数据库等。存储库层可以将所有数据源分组到一个类中，并处理所有情况，以便在正确的时间选择正确的数据源。</li><li id="b7f8" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">你可以利用分工的优势。一个开发人员可以专注于SQL命令和数据管理。其他UI开发人员可以通过直接调用存储库中的函数来处理UI，而不用担心底层的数据管理。</li></ol></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="5066" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">初始化数据库和存储库</h1><p id="41d4" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">创建一个新的扩展<code class="fe mo mp mq mr b">Application</code>的<code class="fe mo mp mq mr b">TrackingApplication</code>文件:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="b6bd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe mo mp mq mr b">AndroidManifest.xml</code>处设置自定义<code class="fe mo mp mq mr b">Application</code>文件:</p><p id="6935" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于在一个app生命周期中应该只有一个<code class="fe mo mp mq mr b">TrackingRepository</code>的实例，所以可以把初始化过程放在app的应用文件中。</p><ol class=""><li id="1a0e" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">您必须扩展一个自定义类到<code class="fe mo mp mq mr b">Application</code>并在<code class="fe mo mp mq mr b">AndroidManifest.xml</code>中的<code class="fe mo mp mq mr b">application</code>处的<code class="fe mo mp mq mr b">name</code>标签处设置自定义类<code class="fe mo mp mq mr b">TrackingApplication</code>。</li><li id="79b6" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">您必须将数据库和存储库的初始化过程设置为<code class="fe mo mp mq mr b">lazy</code>，因为它们在初始化期间需要大量时间。</li></ol></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="5cdc" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">创建视图模型</h1><p id="af09" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">A <code class="fe mo mp mq mr b">ViewModel</code>是现代Android开发中一个特殊的架构组件。它存储可观察的实例，当它们的值改变时，可以通知观察者。观察者通常是有自己生命周期的<code class="fe mo mp mq mr b">Activity</code>、<code class="fe mo mp mq mr b">Fragment</code>和<code class="fe mo mp mq mr b">Application</code>。<code class="fe mo mp mq mr b">ViewModel</code>仍然存在，即使<code class="fe mo mp mq mr b">Activity</code>和<code class="fe mo mp mq mr b">Fragment</code>在方向改变后被重新创建。在<code class="fe mo mp mq mr b">build.gradle (app)</code>文件中添加以下依赖关系:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><ol class=""><li id="3e6a" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">您需要从Android <code class="fe mo mp mq mr b">ViewModel</code>类扩展您的<code class="fe mo mp mq mr b">MapsActivityViewModel</code>，并且<code class="fe mo mp mq mr b">MapsActivityViewModel</code>必须接受一个<code class="fe mo mp mq mr b">TrackingRepository</code>实例来访问可观察数据库<code class="fe mo mp mq mr b">LiveData</code>实例。</li><li id="9142" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">您可以将可观察的数据库<code class="fe mo mp mq mr b">LiveData</code>实例转换成<code class="fe mo mp mq mr b">LiveData</code>类型，让<code class="fe mo mp mq mr b">MapsActivity</code>观察它。</li><li id="1a93" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><code class="fe mo mp mq mr b">ViewModel</code>中有一个默认的实例属性<code class="fe mo mp mq mr b">viewModelScope</code>。您可以在这里启动一个<code class="fe mo mp mq mr b">Coroutine</code>并调用<code class="fe mo mp mq mr b">TrackingRepository</code>中的任何暂停函数。</li></ol></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="1550" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">创建视图模型工厂</h1><p id="f293" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">Android系统将在<code class="fe mo mp mq mr b">Activity</code>的整个生命周期中存储<code class="fe mo mp mq mr b">ViewModel</code>实例，即使它是在配置更改后重新创建的，例如方向更改。因此，您不应该自己初始化<code class="fe mo mp mq mr b">ViewModel</code>，而应该使用<code class="fe mo mp mq mr b">ViewModelProvider.Factory</code>来检索先前存储的<code class="fe mo mp mq mr b">ViewModel</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="eaeb" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">在活动级别观察LiveData</h1><p id="d3a4" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated"><code class="fe mo mp mq mr b">LiveData</code>是一个可观察类，<code class="fe mo mp mq mr b">Activity</code>可以设置相应的观察器对<code class="fe mo mp mq mr b">LiveData</code>中的数据变化做出反应。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><ol class=""><li id="e15a" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">您想要观察<code class="fe mo mp mq mr b">TrackingEntity</code>表中的所有数据。一旦表被清除，您需要相应地重置UI。</li><li id="b357" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">一旦最新的追踪实体(按<code class="fe mo mp mq mr b">timestamp</code>排序)被更新，你必须在谷歌地图片段上画出新的路线。</li><li id="2512" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">当有新记录插入到<code class="fe mo mp mq mr b">TrackingEntity</code>表中时，总行驶距离的值也会更新。然后，您可以用最新的数据更新UI。</li><li id="9642" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">因为步数的变化并不意味着用户位置的变化，所以您需要单独处理数据变化。</li><li id="a124" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">您需要更新<code class="fe mo mp mq mr b">MapsActivityViewModel</code>中<code class="fe mo mp mq mr b">currentNumberOfStepCount</code>的值来触发前一点的监听器。</li><li id="5971" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">为了实现ViewModel模式，向数据库中插入一条新记录，Android系统将触发对<code class="fe mo mp mq mr b">LiveData</code>的更新。最后，<code class="fe mo mp mq mr b">Activity</code>将得到通知并相应地更新UI。</li><li id="2341" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">一旦数据库中有更新，您将更新地图片段处的折线。因此，<code class="fe mo mp mq mr b">addLocationToRoute</code>的输入参数应更新为<code class="fe mo mp mq mr b">TrackingEntity</code>。</li></ol><p id="19ce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">构建并运行。现在，一旦<code class="fe mo mp mq mr b">TrackingEntity</code>记录被插入到<code class="fe mo mp mq mr b">Room</code>数据库中，您将看到路线被更新。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="e205" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">应用程序重启时重绘路线</h1><p id="ccfa" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">您是否注意到在应用程序重新启动后，路由就丢失了？这是因为您尚未在地图上重新绘制路线。因为您已经设置了一个观察器来监听跟踪实体的数据变化，所以您可以简单地从数据库中获取所有的实体，观察器中的函数将为您绘制路线。将以下代码添加到<code class="fe mo mp mq mr b">onMapReady()</code>函数中:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="e095" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">谷歌地图在SDK中异步初始化，你不应该在<code class="fe mo mp mq mr b">onCreate</code>回调时重新绘制路线。您应该等到地图在<code class="fe mo mp mq mr b">onMapReady</code>回调时完全初始化。构建应用程序，你可以发现重新启动应用程序后，路线被重新绘制。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="cd3e" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">停止奔跑</h1><p id="219f" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">用户停止跟踪后，您必须在<code class="fe mo mp mq mr b">Activity</code>和数据库级别重置配置。将上述代码放到<code class="fe mo mp mq mr b">MapsActivity</code>中，当用户想要停止跟踪时运行该代码。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="d3ed" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您需要:</p><ol class=""><li id="8c40" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">重置存储在实例变量中的路线。</li><li id="3dc2" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">清除<code class="fe mo mp mq mr b">MapsActivityViewModel</code>中存储的所有数据，包括房间数据库中的记录。</li><li id="4d80" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">移除任何未来位置更新的处理程序。</li><li id="9f6d" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">移除任何未来新步骤计数的处理程序。</li></ol></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h1 id="a66a" class="nf ng iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">从这里去哪里？</h1><p id="31ef" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">你可以在这里下载<a class="ae kz" href="https://github.com/myrickchow32/RunnerTrackingAppFinal" rel="noopener ugc nofollow" target="_blank">最终项目</a>。学完这个教程，你就做了一个追踪app，恭喜你！然而，你总是可以改善或改变一些事情，比如:</p><ol class=""><li id="479d" class="mf mg iu lc b ld le lg lh lj mh ln mi lr mj lv mk ml mm mn bi translated">当你用looper请求位置更新时，只有当应用在前台时，它才能正常工作。如果想在后台跟踪用户的信息，用<code class="fe mo mp mq mr b">ForegroundService</code>和<code class="fe mo mp mq mr b">PendingIntent</code>代替。</li><li id="669b" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">你可能会在不同的应用版本中更新<code class="fe mo mp mq mr b">TrackingEntity</code>。必须完成数据库迁移。</li><li id="2f5b" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated">从<code class="fe mo mp mq mr b">FusedLocationProviderClient</code>检索的位置具有不同的精度。您可以过滤到更准确的数据，以便为用户提供更好的UX。</li><li id="ab32" class="mf mg iu lc b ld ms lg mt lj mu ln mv lr mw lv mk ml mm mn bi translated"><strong class="lc iv"> Realm </strong>是<code class="fe mo mp mq mr b">Room</code>的替代数据库实现。</li></ol></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ph"><img src="../Images/65a742cd0a3cfa51a4e64412e7c84bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*NtKXPVdFq2jlSJL8.png"/></div></figure><p id="efe7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">欢迎您通过<a class="ae kz" href="https://twitter.com/myrick_chow" rel="noopener ugc nofollow" target="_blank">Twitter @ my rik _ chow</a>关注我，了解更多信息和文章。感谢您阅读这篇文章。祝您愉快！😄</p></div></div>    
</body>
</html>