<html>
<head>
<title>GraphQL using .NET Boxed: Subscriptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL。网络盒装:订阅</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-using-net-boxed-subscriptions-eac6a9dabcdd?source=collection_archive---------4-----------------------#2018-08-05">https://itnext.io/graphql-using-net-boxed-subscriptions-eac6a9dabcdd?source=collection_archive---------4-----------------------#2018-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ec0b04437a7edcd3e26a43b7f02b0450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OiPzHlnFphzdQ1nNI5YEhQ.png"/></div></div></figure><p id="29f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将继续我使用<a class="ae kw" href="https://github.com/Dotnet-Boxed/Templates" rel="noopener ugc nofollow" target="_blank">对<a class="ae kw" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>的探索。NET Boxed </a>模板作为跳开点。我开始写的代码可以在<a class="ae kw" href="https://github.com/elanderson/ASP.NET-Core-GraphQl/tree/f8a353800ab5006c78b5445cc0204cb66f367147" rel="noopener ugc nofollow" target="_blank">这里</a>找到。使用查看<a class="ae kw" href="https://elanderson.net/2018/07/graphql-using-net-boxed-mutations/" rel="noopener ugc nofollow" target="_blank"> GraphQL。NET Boxed: Mutations </a>从上周开始探索突变。</p><p id="bde0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">订阅是GraphQL允许客户端请求数据更改通知的方式。</p><h2 id="86ff" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">出发点</h2><p id="d26b" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">正如几周前发现的，MainSchema是发现GraphQL如何在这个模板中设置的中心点。作为参考，这里是完整的类。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="1848" class="kx ky iq ma b gy me mf l mg mh">public class MainSchema : Schema<br/>{<br/>    public MainSchema(<br/>        QueryObject query,<br/>        MutationObject mutation,<br/>        SubscriptionObject subscription,<br/>        IDependencyResolver resolver)<br/>        : base(resolver)<br/>    {<br/>        this.Query = resolver.Resolve&lt;QueryObject&gt;();<br/>        this.Mutation = mutation;<br/>        this.Subscription = subscription;<br/>    }<br/>}</span></pre><p id="9204" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我们对被分配了SubscriptionObject的Subscription属性感兴趣。</p><h2 id="10ac" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">订阅对象</h2><p id="7017" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">以下是完整的SubscriptionObject，供参考。我会在代码后指出几个细节。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9521" class="kx ky iq ma b gy me mf l mg mh">public class SubscriptionObject : ObjectGraphType&lt;object&gt;<br/>{<br/>    public SubscriptionObject(IHumanRepository humanRepository)<br/>    {<br/>        this.Name = "Subscription";<br/>        this.Description = "The subscription type, represents all updates can be pushed to the client in real time over web sockets.";<br/><br/>        this.AddField(<br/>            new EventStreamFieldType()<br/>            {<br/>                Name = "humanCreated",<br/>                Description = "Subscribe to human created events.",<br/>                Arguments = new QueryArguments(<br/>                    new QueryArgument&lt;ListGraphType&lt;StringGraphType&gt;&gt;()<br/>                    {<br/>                        Name = "homePlanets",<br/>                    }),<br/>                Type = typeof(HumanCreatedEvent),<br/>                Resolver = new FuncFieldResolver&lt;Human&gt;(context =&gt; <br/>                                  context.Source as Human),<br/>                Subscriber = new EventStreamResolver&lt;Human&gt;(context =&gt;<br/>                {<br/>                    var homePlanets = <br/>                           context.GetArgument&lt;List&lt;string&gt;&gt;("homePlanets");<br/>                    return humanRepository<br/>                        .WhenHumanCreated<br/>                        .Where(x =&gt; homePlanets == null || <br/>                                    homePlanets.Contains(x.HomePlanet));<br/>                }),<br/>            });<br/>    }<br/>}</span></pre><p id="4064" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多这种类型看起来与我们已经讨论过的其他类型的查询和变异非常相似。例如，类型是HumanCreatedEvent，它派生自HumanObject，后者是Human类周围的ObjectGraphType。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4f4f" class="kx ky iq ma b gy me mf l mg mh">Type = typeof(HumanCreatedEvent)</span></pre><p id="0871" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">探索GraphQL最困难的事情之一是很好地处理对象图。我强烈建议你花一些时间在这些课程上，让这种联系在你的脑海中变得牢固。</p><p id="65c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个看起来和我们在另一篇文章中提到的非常相似的例子是解析器，它处理基本的人类类型。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="7fe9" class="kx ky iq ma b gy me mf l mg mh">Resolver = new FuncFieldResolver&lt;Human&gt;(context =&gt; context.Source as Human)</span></pre><p id="d3a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一位是新的，它处理当HumanRepository创建一个新的人时GraphQL的实际通知。为了清楚起见，下面的代码删除了与地球相关的内容。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="2f15" class="kx ky iq ma b gy me mf l mg mh">Subscriber = new EventStreamResolver&lt;Human&gt;(context =&gt;<br/>{<br/>    return humanRepository<br/>        .WhenHumanCreated;<br/>})</span></pre><p id="917e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么是人类创造的时间？看起来它是由人类博物馆提供的一个可观测的。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="7192" class="kx ky iq ma b gy me mf l mg mh">public IObservable&lt;Human&gt; WhenHumanCreated =&gt; <br/>                          this.whenHumanCreated.AsObservable();</span></pre><p id="cddf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看AddHuman函数，您会看到每次创建一个人时，这个可观察对象都会被提供一个新值，这反过来会通知我们的GraphQL设置，以通知任何订阅的客户端添加了一个新的人。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="d5ba" class="kx ky iq ma b gy me mf l mg mh">public Task&lt;Human&gt; AddHuman(Human human, CancellationToken cancellationToken)<br/>{<br/>    human.Id = Guid.NewGuid();<br/>    Database.Humans.Add(human);<br/>    this.whenHumanCreated.OnNext(human);<br/>    return Task.FromResult(human);<br/>}</span></pre><h2 id="2288" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">包扎</h2><p id="5afa" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">这涵盖了我对订阅的探索。对我来说，这是我在GraphQL中见过的最酷的部分。</p><p id="b5e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我知道这是一个有点奇怪的系列，因为我们只是看了由模板生成的代码。希望你觉得有用。我知道它帮助我更好地理解GraphQL背后的思想，以及如何在。网芯。</p><p id="69ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相关的示例代码可以在<a class="ae kw" href="https://github.com/elanderson/ASP.NET-Core-GraphQl/tree/59792e870382dba7c6c40d444cfe573577b2569b" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="1de1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mp">原载于</em><a class="ae kw" href="https://elanderson.net/2018/08/graphql-using-net-boxed-subscriptions/" rel="noopener ugc nofollow" target="_blank"><em class="mp"/></a><em class="mp">。</em></p></div></div>    
</body>
</html>