<html>
<head>
<title>Kubernetes Essential Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes基本工具</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-essential-tools-2021-def12e84c572?source=collection_archive---------0-----------------------#2021-07-07">https://itnext.io/kubernetes-essential-tools-2021-def12e84c572?source=collection_archive---------0-----------------------#2021-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1a5036b420b4b65aec3a186dee8dbc04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LPdzDYVh1DUs3z0y"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">本杰明·戴维斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="888d" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="7566" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这篇文章中，我将尝试总结我最喜欢的<a class="ae kf" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Kubernetes </strong> </a>工具，特别强调最新的<strong class="lg iu"/>和鲜为人知的工具，我认为它们会变得非常流行。</p><p id="70ba" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这只是我根据我的经验列出的个人清单，但是为了避免偏见，我会试着提及每种工具的替代方案，这样你就可以根据你的需求进行比较和决定。我会尽可能保持这篇文章的简短，我会尽量提供链接，这样你可以自己探索更多。我的目标是回答这个问题:<em class="mh">“我在Kubernetes怎么做X？”</em>通过描述工具来完成不同的软件开发任务。</p><h1 id="2cad" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">K3D</h1><p id="bd7d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://k3d.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> K3D </strong> </a>是我最喜欢的在笔记本电脑上运行<strong class="lg iu"> Kubernetes </strong> (K8s)集群的方式。它非常轻便，速度也非常快。使用<strong class="lg iu"> Docker </strong>对<a class="ae kf" href="https://k3s.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> K3S </strong> </a>进行包装。所以，你只需要Docker来运行它，它有一个非常低的资源使用率。唯一的问题是<strong class="lg iu">它并不完全符合K8s</strong>，但是这对于本地开发来说应该不是问题。对于测试环境，您可以使用其他解决方案。K3D比Kind快，但是Kind完全兼容。</p><h2 id="f01c" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="3e1e" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://k3s.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> K3S </strong> </a>为物联网或边缘</li><li id="82b9" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">类</strong> </a> <strong class="lg iu"> </strong>作为完全兼容的替代</li><li id="7d8d" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://microk8s.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> MicroK8s </strong> </a></li><li id="a5d7" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">MiniKube</strong>T45】</a></li></ul><h1 id="0b20" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">克鲁</h1><p id="028c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://krew.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Krew </strong> </a>是管理<strong class="lg iu"> Kubectl </strong> <strong class="lg iu">插件</strong>的必备工具，这是任何K8s用户都必须具备的<strong class="lg iu"/>。超过145个可用的<a class="ae kf" href="https://krew.sigs.k8s.io/plugins/" rel="noopener ugc nofollow" target="_blank">插件</a>我就不赘述了但是至少要安装<a class="ae kf" href="https://github.com/ahmetb/kubectx" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"><em class="mh">kubens</em></strong></a>和<a class="ae kf" href="https://github.com/ahmetb/kubectx" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"><em class="mh">kubectx</em></strong></a>。</p><h1 id="42ba" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">镜头</h1><p id="029d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://k8slens.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">镜头</strong> </a>是K8s的<strong class="lg iu"> IDE </strong>给SREs，op，开发者。它适用于任何Kubernetes发行版:本地或云中。这是快速，易于使用，并提供实时观察。有了Lens，管理多个集群变得非常容易。如果你是集群操作员，这是必须的。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/7d6c46336a36874b29e88012898d7f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CjPHHChChMWophOQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">镜头</figcaption></figure><h2 id="9da8" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="bb03" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://k9scli.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">K9s</strong></a><strong class="lg iu"/>对于喜欢轻量化<strong class="lg iu">终端</strong>替代的人来说是一个绝佳的选择。K9s不断观察Kubernetes的变化，并提供后续命令来与您观察到的资源进行交互。</li></ul><h1 id="03f7" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">舵</h1><p id="d708" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">掌舵人</strong> </a>应该不需要介绍，对于Kubernetes来说最著名的<strong class="lg iu">包经理</strong>。是的，你应该在K8s中使用包管理器，就像你在编程语言中使用它一样。Helm允许您将应用打包在<a class="ae kf" href="https://artifacthub.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">图表</strong> </a>中，这些图表将复杂的应用抽象为可重用的简单组件，易于定义、安装和更新。</p><p id="30f3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">它还提供了一个强大的<strong class="lg iu">模板引擎</strong>。<a class="ae kf" href="https://helm.sh/docs/" rel="noopener ugc nofollow" target="_blank"> Helm </a>比较成熟，有很多预定义的图表，很大的支持，很容易使用。</p><h2 id="f3b1" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="4add" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated">Kustomize  是helm的一个更新更好的替代品，它不使用模板引擎，而是使用一个覆盖引擎，在上面有基本定义和覆盖。</li></ul><h1 id="94fd" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">ArgoCD</h1><p id="63f5" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我相信<a class="ae kf" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> GitOps </strong> </a>是过去十年中最好的想法之一。在软件开发中，我们应该使用<strong class="lg iu">单一来源的真相</strong>来跟踪构建软件所需的所有移动部分，而<strong class="lg iu"> Git </strong>是完成这一任务的完美工具。其想法是建立一个Git存储库，其中包含应用程序代码以及基础设施的声明性描述(<a class="ae kf" href="https://en.wikipedia.org/wiki/Infrastructure_as_Code" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"/></a>)，这些描述代表了所需的生产环境状态；以及一个<strong class="lg iu">自动化过程</strong>来使期望的环境与存储库中描述的状态相匹配。</p><blockquote class="nn no np"><p id="c5e1" class="le lf mh lg b lh mc lj lk ll md ln lo nq me lr ls nr mf lv lw ns mg lz ma mb im bi translated"><strong class="lg iu"> GitOps </strong>:声明性基础设施之上的版本化CI/CD。停止编写脚本，开始发货。</p><p id="257d" class="le lf mh lg b lh mc lj lk ll md ln lo nq me lr ls nr mf lv lw ns mg lz ma mb im bi translated">— <a class="ae kf" href="https://twitter.com/kelseyhightower/status/953638870888849408" rel="noopener ugc nofollow" target="_blank">凯尔西·海托华</a></p></blockquote><p id="6aa8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">虽然使用<a class="ae kf" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Terraform </strong> </a>或类似的工具，你可以将你的基础设施作为代码(<a class="ae kf" href="https://en.wikipedia.org/wiki/Infrastructure_as_code" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> IaC </strong> </a>)，但这还不足以将你在Git中想要的状态与生产同步。我们需要一种方法来持续监控环境，并确保没有配置偏差。使用Terraform，你必须编写运行<code class="fe nt nu nv nw b">terraform apply</code>的脚本，并检查状态是否与Terraform的状态相匹配，但这很繁琐，也很难维护。</p><p id="7d9d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Kubernetes是按照自下而上的控制循环的思想构建的，这意味着Kubernetes总是在监视集群的状态，以确保它与所需的状态相匹配，例如，运行的副本数量与所需的副本数量相匹配。GitOps的想法是将这一点扩展到应用程序，因此您可以将您的服务定义为代码，例如，通过定义Helm Charts，并使用一个利用K8s功能的工具来监控您的应用程序的状态并相应地调整集群。也就是说，如果更新您的代码报告，或您的掌舵图表，生产集群也将更新。这才是真正的<a class="ae kf" href="https://en.wikipedia.org/wiki/Continuous_deployment" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">连续部署</strong> </a>。核心原则是应用程序部署和生命周期管理应该是自动化的、可审计的和易于理解的。</p><p id="fac7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">对我来说，这个想法是革命性的，如果做得好，将使组织更多地关注特性，而不是为自动化编写脚本。这个概念可以扩展到软件开发的其他领域，例如，您可以在代码中存储您的文档，以跟踪更改的历史，并确保文档是最新的；或者使用<a class="ae kf" href="https://github.com/jamesmh/architecture_decision_record" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> ADRs </strong> </a>跟踪架构决策。</p><p id="ca43" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在我看来，<strong class="lg iu"> Kubernetes </strong>中最好的GitOps工具是<a class="ae kf" href="https://argoproj.github.io/argo-cd/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">argod</strong></a>。你可以在这里阅读更多关于它的<a class="ae kf" href="https://argoproj.github.io/argo-cd/core_concepts/" rel="noopener ugc nofollow" target="_blank">。ArgoCD是Argo生态系统的一部分，该生态系统还包括一些其他优秀的工具，其中一些我们将在后面讨论。</a></p><p id="e61d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">使用<strong class="lg iu"> ArgoCD </strong>你可以在一个代码库中拥有每个<strong class="lg iu">环境</strong>，在那里你可以为那个环境定义所有的配置。Argo CD在指定的目标环境中自动部署所需的应用程序状态。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/8d455e5f8c1806c0cb46a10678098557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nf9z_-8Um9nCbzKU.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">ArgoCD建筑</figcaption></figure><p id="23e9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Argo CD是作为一个<strong class="lg iu"> kubernetes控制器</strong>实现的，该控制器持续监控运行的应用程序，并将当前的实时状态与所需的目标状态进行比较(如Git报告中所述)。Argo CD报告并可视化这些差异，并且可以自动或手动将实时状态同步回所需的目标状态。</p><h2 id="7812" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="bdf9" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://fluxcd.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">通量</strong> </a>其中刚刚发布了一个有很多改进的新版本。它提供了非常相似的功能。</li></ul><h1 id="c782" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Argo工作流和Argo事件</h1><p id="fccb" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在Kubernetes中，您可能还需要运行<strong class="lg iu">批处理作业或复杂的工作流</strong>。这可能是您的数据管道、异步流程甚至CI/CD的一部分。除此之外，您甚至可能需要运行驱动的微服务，对某些事件做出反应，如文件上传或消息发送到队列。对于这一切，我们有<a class="ae kf" href="https://argoproj.github.io/argo-workflows/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">蓉城工作流程</strong> </a>和<a class="ae kf" href="https://argoproj.github.io/argo-events/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">蓉城事件</strong> </a>。</p><p id="3128" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">尽管它们是独立的项目，但它们往往会一起部署。</p><p id="47b1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Argo Workflows是一个<strong class="lg iu">编排</strong> <strong class="lg iu">引擎</strong>，类似于<a class="ae kf" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇气流</a>，但原生于Kubernetes。它使用自定义的<strong class="lg iu"> CRDs </strong>来定义复杂的工作流程，使用K8s中感觉更自然的<a class="ae kf" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Dag</strong></a>来定义复杂的工作流程。它有一个很好的用户界面，重试机制，基于cron的工作，输入和输出跟踪等等。您可以使用它来编排数据管道、批处理作业等等。</p><p id="228e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">有时，您可能希望将您的管道与异步服务集成，如流引擎(如<a class="ae kf" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Kafka</strong></a><strong class="lg iu">)</strong>、队列、webhooks或深度存储服务。例如，您可能希望对上传到S3的文件等事件做出反应。为此，你要用<a class="ae kf" href="https://argoproj.github.io/argo-events/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">蓉城事件</strong> </a>。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/931abbe7d90e073bf6ba7a1580986eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1b1dP4v618GJhyjF"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">阿尔戈事件</figcaption></figure><p id="305a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这两个工具结合起来为您的所有管道需求提供了一个简单而强大的解决方案，包括<strong class="lg iu"> CI/CD </strong>管道，它将允许您在Kubernetes中本地运行CI/CD管道。</p><h2 id="845b" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="a86c" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated">对于ML管道，您可以使用为此目的而构建的<a class="ae kf" href="https://www.kubeflow.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">kube flow</strong></a><strong class="lg iu"/>。</li><li id="0855" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">对于CI/CD管线，您可以使用<a class="ae kf" href="https://tekton.dev/docs/pipelines/pipelines/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Tekton </strong> </a>。</li></ul><h1 id="0df6" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">卡尼科</h1><p id="53fd" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们刚刚看到了如何使用Argo工作流运行Kubernetes native <strong class="lg iu"> CI/CD </strong>管道。一个常见的任务是<strong class="lg iu">构建Docker映像</strong>，这在Kubernetes中通常很繁琐，因为构建过程实际上是在容器本身上运行的，您需要使用变通办法来使用主机的Docker引擎。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/fd0ba896945bd273c85d00d5c758e4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*13m0UCaxq4mTrGT1.png"/></div></div></figure><p id="9cf0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">底线是<strong class="lg iu">你不应该使用Docker建立你的图像</strong>:使用<a class="ae kf" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Kaniko </strong> </a>代替。Kaniko不依赖Docker守护进程，完全在用户空间中执行Docker文件中的每个命令。这使得在不能轻松或安全地运行Docker守护进程的环境中构建容器映像成为可能，比如标准的Kubernetes集群。这消除了关于在K8s集群中构建映像的所有问题。</p><h1 id="7e5d" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">伊斯迪奥</h1><p id="4d21" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Istio </strong> </a>是市面上最著名的<a class="ae kf" href="https://en.wikipedia.org/wiki/Service_mesh" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">服务网</strong> </a>，它是开源的，非常受欢迎。我不会详细讨论什么是服务网格，因为这是一个很大的话题，但是如果您正在构建<a class="ae kf" href="https://microservices.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">微服务</strong> </a>，并且很可能您应该这样做，那么您将需要一个服务网格来管理通信、可观察性、错误处理、安全性以及作为<strong class="lg iu">微服务架构</strong>一部分的所有其他交叉方面。与其用重复的逻辑污染每个微服务的代码，不如利用服务网格来为您做这件事。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/a2ec9e471b19907436e5c028ac0bfa8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RE4XLT5ZNg6idsiK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Istio建筑</figcaption></figure><p id="0d1b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">简而言之，服务网格是一个可以添加到应用程序中的专用基础设施层。它允许您透明地添加诸如可观察性、流量管理和安全性等功能，而无需将它们添加到您自己的代码中。</p><p id="5991" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Istio用于运行微服务，虽然你可以在任何地方运行Istio和使用微服务，但Kubernetes已经一次又一次地被证明是运行它们的最佳平台。<strong class="lg iu"> Istio </strong>还可以将您的K8s集群扩展到其他服务，如虚拟机，让您拥有混合环境，这在迁移到Kubernetes时非常有用。</p><h2 id="81e0" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="63f7" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://linkerd.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Linkerd </strong> </a>是一个<strong class="lg iu">更轻</strong>并且可能<strong class="lg iu">更快</strong>的发球网。Linkerd完全是为了安全而构建的，它的功能包括<a class="ae kf" href="https://linkerd.io/2.10/features/automatic-mtls/" rel="noopener ugc nofollow" target="_blank">默认开启的mTLS </a>、用Rust构建的数据平面<a class="ae kf" href="https://github.com/linkerd/linkerd2-proxy" rel="noopener ugc nofollow" target="_blank">、内存安全语言</a>以及<a class="ae kf" href="https://github.com/linkerd/linkerd2/blob/main/SECURITY_AUDIT.pdf" rel="noopener ugc nofollow" target="_blank">定期安全审计</a></li><li id="cce2" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Consul </strong> </a>是为任何运行时和云提供商构建的服务网格，因此它非常适合跨k8和云提供商的混合部署。如果不是所有的工作负载都在Kubernetes上运行，这是一个很好的选择。</li></ul><h1 id="ecb1" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">阿尔戈推出</h1><p id="bcbc" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们已经提到，您可以使用Kubernetes来运行您的CI/CD管道，使用Argo工作流或类似的工具使用Kaniko来构建您的图像。下一个合乎逻辑的步骤是继续进行<strong class="lg iu">连续部署</strong>。由于涉及的高风险，这在现实场景中非常具有挑战性，这就是为什么大多数公司只做<strong class="lg iu">连续交付</strong>，这意味着他们有自动化，但他们仍然有人工批准和验证，这种人工步骤是由于团队<strong class="lg iu">不能完全信任他们的自动化。</strong></p><p id="fa11" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">那么，如何建立这种信任，以便能够摆脱所有的脚本，从源代码到生产全自动化呢？答案是:<strong class="lg iu">可观测性</strong>。您需要将资源更多地集中在指标上，并收集准确表示应用程序状态所需的所有数据。目标是使用一组指标来建立信任。如果您在<a class="ae kf" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Prometheus </strong> </a>中拥有所有数据，那么您就可以自动化部署，因为您可以基于这些指标自动化应用程序的逐步推出。</p><p id="877a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">简而言之，你需要比K8s现成提供的<a class="ae kf" href="https://www.educative.io/blog/kubernetes-deployments-strategies" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">滚动更新</strong> </a>更高级的部署技术。我们需要使用<a class="ae kf" href="https://semaphoreci.com/blog/what-is-canary-deployment" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">金丝雀</strong>部署</a>的渐进式交付。目标是逐步将流量路由到新版本的应用程序，等待收集指标，分析这些指标，并将其与预定义的规则进行匹配。如果一切正常，我们增加流量；如果有任何问题，我们将回滚部署。</p><p id="c417" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">要在Kubernetes中做到这一点，你可以使用<a class="ae kf" href="https://argoproj.github.io/argo-rollouts/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Argo Rollouts </strong> </a>提供金丝雀发布和更多。</p><blockquote class="nn no np"><p id="1064" class="le lf mh lg b lh mc lj lk ll md ln lo nq me lr ls nr mf lv lw ns mg lz ma mb im bi translated">Argo Rollouts是一个<a class="ae kf" href="https://kubernetes.io/docs/concepts/architecture/controller/" rel="noopener ugc nofollow" target="_blank"> Kubernetes控制器</a>和一组<a class="ae kf" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">CRD</a>，它们向Kubernetes提供高级部署功能，如蓝绿色、金丝雀、金丝雀分析、实验和渐进交付功能。</p></blockquote><p id="2d19" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">虽然像<a class="ae kf" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Istio </strong> </a>这样的服务网格提供金丝雀版本，但Argo Rollouts使这个过程变得更加容易，并且以开发者为中心，因为它是专门为此目的而构建的。最重要的是，<strong class="lg iu"> Argo部署</strong>可以与任何服务网络集成。</p><p id="5b53" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">逃离德黑兰功能:</strong></p><ul class=""><li id="3c41" class="mu mv it lg b lh mc ll md lp ob lt oc lx od mb mz na nb nc bi translated">蓝绿更新策略</li><li id="c2f2" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">金丝雀更新策略</li><li id="e7c8" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">细粒度的加权流量转移</li><li id="3631" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">自动回滚和升级或人工判断</li><li id="5e7e" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">可定制的指标查询和业务KPI分析</li><li id="62ed" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">入口控制器集成:NGINX、ALB</li><li id="851d" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">服务网格集成:Istio、Linkerd、SMI</li><li id="603f" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">指标提供商集成:Prometheus、Wavefront、<strong class="lg iu"> Kayenta </strong>、Web、Kubernetes Jobs</li></ul><h2 id="0069" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="567b" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Istio</strong></a><strong class="lg iu"/>作为金丝雀发布的服务网格。Istio不仅仅是一个渐进式交付工具，它是一个完整的<a class="ae kf" href="https://en.wikipedia.org/wiki/Service_mesh" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">服务网</strong> </a>。Istio不自动部署，Argo Rollouts可以与Istio集成来实现这一点。</li><li id="32be" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://flagger.app/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Flagger </strong> </a>非常类似于Argo的推出，它与<a class="ae kf" href="https://fluxcd.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Flux </strong> </a>非常好地集成在一起，所以如果你的ar使用Flux的话可以考虑<a class="ae kf" href="https://flagger.app/" rel="noopener ugc nofollow" target="_blank"> Flagger </a>。</li><li id="da94" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://spinnaker.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Spinnaker </strong> </a>是Kubernetes的第一个连续交付工具，它有很多特性，但是使用和设置起来有点复杂。</li></ul><h1 id="f153" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">交叉平面</h1><p id="b090" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://crossplane.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Crossplane </strong> </a>是我的新宠<strong class="lg iu"> K8s </strong>工具，我对这个项目非常兴奋，因为它为Kubernetes带来了一个关键的缺失部分:<strong class="lg iu">管理第三方服务，就像它们是K8s资源一样</strong>。这意味着，您可以供应云提供商数据库，如<strong class="lg iu">AWS</strong><a class="ae kf" href="https://aws.amazon.com/rds/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">RDS</strong></a>或<strong class="lg iu"> GCP </strong> <strong class="lg iu">云SQL </strong>，就像您在K8s中供应数据库一样，使用在<strong class="lg iu"> YAML </strong>中定义的K8s资源。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/11b4d6136655971f5009e595262de5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*g1DTVdRJJ6gtUmkl.png"/></div></figure><p id="4ebf" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">有了<strong class="lg iu">交叉平面</strong>，就不需要使用不同的工具和方法来分离基础设施和代码。<strong class="lg iu">你可以用K8s资源定义一切。</strong>这样就不需要学习<a class="ae kf" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Terraform </strong> </a>之类的新工具，单独保存。</p><blockquote class="nn no np"><p id="7129" class="le lf mh lg b lh mc lj lk ll md ln lo nq me lr ls nr mf lv lw ns mg lz ma mb im bi translated">Crossplane是一个开源的Kubernetes插件，使平台团队能够组装来自多个供应商的基础设施，并为应用团队提供更高级别的自助服务API，而无需编写任何代码。</p></blockquote><p id="d5e6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> Crossplane </strong>扩展您的Kubernetes集群，为您提供适用于任何基础设施或托管云服务的<strong class="lg iu"> CRDs </strong>。此外，它允许您完全实施<strong class="lg iu">连续部署</strong>，因为与其他工具(如Terraform)相反，Crossplane使用现有的K8s功能(如控制循环)来持续监视您的集群，并自动检测对其起作用的任何配置漂移。例如，如果您定义了一个托管数据库实例，而有人手动更改了它，Crossplane将自动检测到该问题，并将其设置回以前的值。这将基础设施作为代码和<a class="ae kf" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> GitOps </strong> </a>原则来实施。<strong class="lg iu"> Crossplane </strong>与Argo CD配合使用非常好，它可以查看源代码，并确保您的代码报告是真实的单一来源，并且代码中的任何更改都会传播到集群和外部云服务。如果没有Crossplane，您只能在K8s服务中实现<a class="ae kf" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> GitOps </strong> </a>，而不能在不使用单独流程的情况下实现云服务，现在您可以这样做了，这太棒了。</p><h2 id="fc65" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="f7b1" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Terraform </strong> </a>这是最著名的IaC工具，但不是K8s原生的，需要新技能，不会自动观察配置漂移。</li><li id="b881" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://www.pulumi.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Pulumi </strong> </a>这是一个Terraform的替代品，它使用开发者可以测试和理解的编程语言工作。</li></ul><h1 id="2673" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Knative</h1><p id="ea21" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你在云中开发你的应用程序，你可能已经使用了一些<strong class="lg iu">无服务器</strong>技术，比如<a class="ae kf" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">AWSλ</strong></a><strong class="lg iu"/>，这是一个事件驱动的范例，被称为<a class="ae kf" href="https://en.wikipedia.org/wiki/Function_as_a_service" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"/></a>。</p><p id="0ac9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我过去已经讲过<a class="ae kf" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">无服务器</strong> </a>，所以检查我的<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/scaling-my-app-serverless-vs-kubernetes-cdb8adf446e1"> <strong class="lg iu">以前的文章</strong> </a>来了解更多关于这方面的内容。无服务器的问题是它与云提供商紧密耦合，因为提供商可以为事件驱动的应用程序创建一个伟大的生态系统。</p><p id="1b14" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">对于Kubernetes来说，如果你想将函数作为代码运行，并使用事件驱动架构，你最好的选择是<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/scaling-my-app-serverless-vs-kubernetes-cdb8adf446e1"> <strong class="lg iu"> Knative </strong> </a>。Knative是为了在Kubernetes上运行功能而构建的，它在Pod上创建了一个抽象。</p><p id="325a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">特点</strong>:</p><ul class=""><li id="5b82" class="mu mv it lg b lh mc ll md lp ob lt oc lx od mb mz na nb nc bi translated">针对常见应用程序用例的具有更高级抽象的集中API。</li><li id="6d85" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">在几秒钟内建立一个可扩展的、安全的、无状态的服务。</li><li id="48df" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">松散耦合的特性允许您使用您需要的部分。</li><li id="8e0d" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">可插拔组件让您可以拥有自己的日志记录和监控、网络和服务网格。</li><li id="f6e6" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">Knative是可移植的:在Kubernetes运行的任何地方运行它，永远不用担心被供应商锁定。</li><li id="4fe2" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">惯用的开发人员体验，支持常见模式，如GitOps、DockerOps、ManualOps。</li><li id="1459" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">Knative可以与常见的工具和框架一起使用，比如Django、Ruby on Rails、Spring等等。</li></ul><h2 id="b7eb" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="c539" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://argoproj.github.io/argo-events/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Argo Events </strong> </a>为Kubernetes提供事件驱动的工作流引擎，可以与AWS Lambda等云引擎集成。它不是FaaS，而是为Kubernetes提供了一个事件驱动的架构。</li><li id="0412" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://www.openfaas.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> OpenFaas </strong> </a></li></ul><h1 id="26fb" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">kyverno</h1><p id="8443" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Kubernetes提供了很大的灵活性，以增强敏捷自治团队的能力，但是能力越大，责任越大。必须有一套<strong class="lg iu">最佳实践和规则</strong>来确保以一致和连贯的方式部署和管理符合公司政策和安全要求的工作负载。</p><p id="870e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">有几个工具可以做到这一点，但没有一个是Kubernetes自带的…直到现在。<a class="ae kf" href="https://kyverno.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Kyverno </strong> </a>是一款专为Kubernetes设计的策略引擎，策略作为Kubernetes资源进行管理，无需新语言编写策略。Kyverno策略可以验证、变异和生成Kubernetes资源。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/4f7cffb28ef108c264c30c81ad1f2cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BB0Qfwe_iCmry9hL.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Kyverno政策是一系列规则的集合。每个规则由一个<code class="fe nt nu nv nw b"><a class="ae kf" href="https://kyverno.io/docs/writing-policies/match-exclude/" rel="noopener ugc nofollow" target="_blank">match</a></code>子句、一个可选的<code class="fe nt nu nv nw b"><a class="ae kf" href="https://kyverno.io/docs/writing-policies/match-exclude/" rel="noopener ugc nofollow" target="_blank">exclude</a></code>子句以及一个<code class="fe nt nu nv nw b"><a class="ae kf" href="https://kyverno.io/docs/writing-policies/validate/" rel="noopener ugc nofollow" target="_blank">validate</a></code>、<code class="fe nt nu nv nw b"><a class="ae kf" href="https://kyverno.io/docs/writing-policies/mutate/" rel="noopener ugc nofollow" target="_blank">mutate</a></code>或<code class="fe nt nu nv nw b"><a class="ae kf" href="https://kyverno.io/docs/writing-policies/generate" rel="noopener ugc nofollow" target="_blank">generate</a></code>子句组成。一个规则定义只能包含一个<code class="fe nt nu nv nw b">validate</code>、<code class="fe nt nu nv nw b">mutate</code>或<code class="fe nt nu nv nw b">generate</code>子节点。</figcaption></figure><p id="275a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您可以应用任何一种关于最佳实践、网络或安全性的策略。例如，您可以强制所有服务都有标签，或者所有容器都作为非根运行。您可以在此查看一些政策示例<a class="ae kf" href="https://github.com/kyverno/policies/" rel="noopener ugc nofollow" target="_blank">。策略可以应用于整个集群或给定的命名空间。您还可以选择是否只想<strong class="lg iu">审核</strong>策略或强制执行这些策略来阻止用户部署资源。</a></p><h2 id="8507" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="a6a3" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">开放策略代理</strong> </a>是著名的云原生基于策略的控制引擎。它使用自己的声明性语言，可以在许多环境下工作，不仅仅是在Kubernetes上。它比<a class="ae kf" href="https://kyverno.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">更难管理</strong> </a> <strong class="lg iu"> </strong>却更强大。</li></ul><h1 id="1e9b" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">库伯韦拉</h1><p id="6b6f" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Kubernetes的一个问题是，开发人员需要非常了解平台和集群配置。许多人会认为K8s的抽象层次太低，这给那些只想专注于编写和发布应用程序的开发人员造成了很多摩擦。</p><p id="2b9e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">开放应用模型</strong> ( <a class="ae kf" href="https://oam.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> OAM </strong> </a>)就是为了克服这个问题而产生的。这个想法是围绕独立于底层运行时的应用程序创建一个更高层次的抽象。你可以在这里阅读规格<a class="ae kf" href="https://github.com/oam-dev/spec" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="nn no np"><p id="4644" class="le lf mh lg b lh mc lj lk ll md ln lo nq me lr ls nr mf lv lw ns mg lz ma mb im bi translated">关注于<em class="it">应用</em>而不是容器或流程编排器，开放应用模型【OAM】带来了模块化、可扩展和可移植的设计，用于使用更高级但一致的API来建模应用部署。</p></blockquote><p id="f3e3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://kubevela.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Kubevela </strong> </a>是OAM模型的一种实现。KubeVela是运行时不可知的，本机可扩展，但最重要的是，<em class="mh">以应用为中心</em>。在Kubevela中，应用程序是作为Kubernetes资源实现的一等公民。<strong class="lg iu">集群运营者(平台团队)和开发者(应用团队)是有区别的。</strong>集群操作员通过定义<strong class="lg iu">组件</strong>(组成您的应用程序的可部署/可临时提供的实体，如舵图)和<a class="ae kf" href="https://kubevela.io/docs/platform-engineers/cue/trait/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">特征</strong> </a> <strong class="lg iu">来管理集群和不同的环境。开发人员通过组装组件和特征来定义应用程序。</strong></p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/3ca08113309c9479234a1ecf368e146d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Av9k55vHrB2pjOaO.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><strong class="bd ki">平台团队</strong>:将平台功能建模和管理为组件或特征，以及目标环境规范。<strong class="bd ki">应用程序团队</strong>:选择一个环境，根据需要用组件和特征组装应用程序，并将其部署到目标环境。</figcaption></figure><p id="29bd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> KubeVela </strong>是一个<a class="ae kf" href="https://cncf.io/" rel="noopener ugc nofollow" target="_blank">云本地计算基金会</a>沙盒项目，尽管它仍处于起步阶段，但它可以在不久的将来改变我们使用Kubernetes的方式，允许开发人员专注于应用程序，而无需成为Kubernetes专家。然而，我确实有些担心<strong class="lg iu"> OAM </strong>在现实世界中的适用性，因为一些服务，如系统应用程序、ML或大数据流程，在很大程度上依赖于底层细节，这些细节可能很难纳入OAM模型。</p><h2 id="d13d" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="ff6a" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://www.shipa.io/getting-started/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Shipa </strong> </a>遵循类似的方法，使平台和开发者团队能够一起工作，轻松地将应用部署到Kubernetes。</li><li id="9b69" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://learn.theketch.io/docs" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Ketch </strong> </a>还试图通过使用非常简单的命令行界面来部署应用程序，从而简化开发人员的生活。问题是它没有遵循GitOps原则，而是使用了一种命令式的方法，这种方法更容易开始，但是对于更大的项目来说更复杂。我真的推荐Ketch用于简单的应用程序或小团队，而不是大项目。</li></ul><h1 id="55ce" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Snyk</h1><p id="0cc1" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在任何开发过程中，一个非常重要的方面是<strong class="lg iu">安全性</strong>，这一直是Kubernetes的一个问题，因为想要迁移到Kubernetes的公司无法轻松实现他们当前的安全原则。</p><p id="a9e3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Snyk试图通过提供一个可以轻松与Kubernetes集成的安全框架来缓解这一问题。它可以检测容器图像、您的代码、开源项目等等中的漏洞。</p><h2 id="ed50" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="2c1e" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><strong class="lg iu">更新</strong> : <a class="ae kf" href="https://falco.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Falco </strong> </a>是一款针对Kubernetes的运行时安全线程检测工具。</li></ul><h1 id="a70f" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">发展空间</h1><p id="cb5a" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://devspace.sh/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> DevSpace </strong> </a>对于Kubernetes来说是一个很棒的<strong class="lg iu">开发工具</strong>，它提供了许多特性，但最重要的一个是能够在本地集群中部署应用，并启用<strong class="lg iu">热重装</strong>。这意味着您可以打开您的IDE，任何更改都将被复制到您的本地环境中部署的pod。这个工具填补了Kubernetes生态系统中的一个空白，改善了开发体验。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/6677d7b7cf1039bbd192d8a84263bcf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FVsF8kU3u9KClDLQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">开发空间功能</figcaption></figure><p id="7f88" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果没有DevSpace，开发人员将不得不依赖于应用程序语言的特定工具来启用带有热重载的快速开发环境。这意味着，安装您的操作系统所需的所有工具，这不仅繁琐，而且容易出错，因为您的笔记本电脑操作系统和目标基础架构之间可能存在不匹配。<strong class="lg iu"> DevSpace </strong>将为您提供相同的开发人员体验，让您确信正在运行的程序使用的是与生产相同的平台。</p><h1 id="a171" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">韦莱罗</h1><p id="b796" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果您在Kubernetes中运行工作负载，并且使用卷来存储数据，那么您需要<strong class="lg iu">创建和管理备份</strong>。<a class="ae kf" href="https://velero.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Velero </strong> </a>提供了简单的备份/恢复流程、灾难恢复机制和数据迁移。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/b17170a1541eb415623709c3df0ffd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0evtEA3e1p-yIifGOhiYzg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Velero功能</figcaption></figure><p id="8b04" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">与其他直接访问Kubernetes <em class="mh"> etcd </em>数据库来执行备份和恢复的工具不同，Velero使用Kubernetes API来捕获集群资源的状态，并在必要时进行恢复。此外，Velero使您能够在配置的同时备份和恢复您的应用程序持久数据。</p><h1 id="217f" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">模式英雄</h1><p id="987e" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">软件开发中的另一个常见过程是在使用关系数据库时管理<strong class="lg iu">模式演变</strong>。</p><p id="4259" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://schemahero.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> SchemaHero </strong> </a>是一个开源数据库<strong class="lg iu">模式迁移</strong>工具，它将模式定义转换成可以在任何环境中应用的迁移脚本。它使用Kubernetes的声明性来管理数据库模式迁移。您只需指定所需的状态，剩下的由SchemaHero管理。</p><h2 id="f572" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="1ca7" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://www.liquibase.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">液基</strong> </a>是最著名的替代品。它更难使用，也不是Kubernetes本地的，但它有更多的功能。</li></ul><h1 id="8b33" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">比特纳米密封的秘密</h1><p id="0077" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们已经介绍了许多<strong class="lg iu"> GitOps </strong>工具，例如<a class="ae kf" href="https://argoproj.github.io/argo-cd/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> ArgoCD </strong> </a>。我们的目标是将一切都保存在Git中，并使用Kubernetes的声明性来保持环境同步。我们刚刚看到了我们如何能够(也应该)在Git中保留我们的真实来源，并让自动化流程处理配置更改。</p><p id="ee53" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在Git中通常很难保存的一件事是秘密，比如数据库密码或API密匙，这是因为<strong class="lg iu">你不应该在你的代码库中保存秘密。</strong>一种常见的解决方案是使用外部保险库，如<a class="ae kf" href="https://aws.amazon.com/secrets-manager/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">AWS Secret Manager</strong></a><strong class="lg iu"/>或HashiCorp <strong class="lg iu"> </strong> <a class="ae kf" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">保险库</strong> </a> <strong class="lg iu"> </strong>来存储秘密，但这造成了很多摩擦，因为你需要有一个单独的进程来处理秘密。理想情况下，我们希望能够像其他资源一样，在Git中安全地存储秘密。</p><p id="991e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://github.com/bitnami-labs/sealed-secrets" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">密封秘密</strong> </a>就是为了克服这个问题而产生的，它允许你通过使用强加密将你的敏感数据存储在Git中。Bitnami <strong class="lg iu"> Sealed Secrets </strong>原生集成在Kubernetes中，允许您只能通过运行在Kubernetes中的Kubernetes控制器来解密秘密，而不能通过其他人。控制器将解密数据并创建安全存储的本地K8s秘密。这使我们能够将所有内容作为代码存储在我们的repo中，使我们能够安全地执行连续部署，而无需任何外部依赖。</p><p id="d3c7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">密封的秘密由<strong class="lg iu">和</strong>两部分组成:</p><ul class=""><li id="5636" class="mu mv it lg b lh mc ll md lp ob lt oc lx od mb mz na nb nc bi translated">集群侧控制器</li><li id="24c1" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">客户端实用程序:<code class="fe nt nu nv nw b">kubeseal</code></li></ul><p id="11e7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe nt nu nv nw b">kubeseal</code>实用程序使用非对称加密来加密只有控制器才能解密的秘密。这些加密的秘密被编码在一个<code class="fe nt nu nv nw b">SealedSecret</code> K8s资源中，可以存储在Git中。</p><h2 id="f9d9" class="mi kh it bd ki mj mk dn km ml mm dp kq lp mn mo ku lt mp mq ky lx mr ms lc mt bi translated">可供选择的事物</h2><ul class=""><li id="9396" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://github.com/mozilla/sops" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> SOPS </strong> </a>，非常类似于封印的秘密。</li><li id="b2f2" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://aws.amazon.com/secrets-manager/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> AWS秘密管理器</strong> </a></li><li id="e906" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">跳马</strong> </a></li></ul><h1 id="ca54" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">胶囊</h1><p id="e0e1" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">许多公司使用多租户来管理不同的客户。这在软件开发中很常见，但在Kubernetes中很难实现。<strong class="lg iu">名称空间</strong>是将集群的逻辑分区创建为隔离的<em class="mh">片</em>的好方法，但是这还不够，为了安全地隔离客户，我们需要实施网络策略、配额等等。您可以为每个名称空间创建网络策略和规则，但这是一个很难扩展的繁琐过程。此外，租户将不能使用一个以上的名称空间，这是一个很大的限制。</p><p id="24d1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://kubernetes.io/blog/2020/08/14/introducing-hierarchical-namespaces/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">分层名称空间</strong> </a>就是为了克服这些问题而产生的。这个想法是为每个租户提供一个父名称空间，并为租户提供通用的网络策略和配额，同时允许创建子名称空间。这是一个很大的改进，但是它在安全性和治理方面没有对租户的本地支持。此外，它还没有达到生产状态，但版本1.0预计将在未来几个月内发布。</p><p id="d327" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">目前解决这一问题的一种常见方法是为每个客户创建一个群集，这是安全的，可以提供租户所需的一切，但这很难管理，而且非常昂贵。</p><p id="a0a0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://github.com/clastix/capsule" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Capsule </strong> </a>是一个为单个集群中的多个租户提供本地Kubernetes <strong class="lg iu">支持的工具。</strong>借助Capsule，您可以拥有一个适用于所有租户的集群。Capsule将为租户提供“几乎”本地的体验(有一些小的限制)，租户将能够创建多个名称空间并使用集群，因为集群对他们来说是完全可用的，从而隐藏了集群实际上是共享的这一事实。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/c4074fbef001b3fe44c86a43407870ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbSz-GMOW10-3KkrwhsZ_Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">胶囊建筑</figcaption></figure><p id="b1ce" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在单个集群中，Capsule控制器将多个名称空间聚合在一个名为<strong class="lg iu"> <em class="mh"> Tenant </em> </strong>的轻量级Kubernetes抽象中，这是一组Kubernetes名称空间。在每个租户内，用户可以自由创建他们的命名空间并共享所有分配的资源，而策略引擎会将不同的租户相互隔离。</p><p id="e84b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><em class="mh">网络和安全策略</em>、<em class="mh">资源配额</em>、<em class="mh">限制范围</em>、<em class="mh"> RBAC </em>以及在租户级定义的其他策略被租户中的所有命名空间自动继承，类似于分层命名空间。然后，用户可以自由自主地操作他们的租户，而无需集群管理员的干预。Capsule已经准备好GitOps，因为它是声明性的，所有的配置都可以存储在Git中。</p><h1 id="76c2" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">vCluster</h1><p id="794c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://www.vcluster.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> VCluster </strong> </a>在多租户方面更进一步，它在Kubernetes集群内提供了<strong class="lg iu">虚拟集群</strong>。每个集群运行在一个常规的名称空间上，并且是完全隔离的。虚拟集群有自己的API服务器和独立的数据存储，因此您在vcluster中创建的每个Kubernetes对象只存在于vcluster内部。此外，您可以将kube context与虚拟集群一起使用，就像使用常规集群一样。</p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/49cb2051efb33b49c960f33971daccf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmhhMFBmliv8C6h1n-Sd2g.png"/></div></div></figure><p id="586f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">只要您可以在单个名称空间内创建部署，您就能够创建虚拟集群并成为该虚拟集群的管理员，租户可以创建名称空间、安装CRD、配置权限等等。</p><p id="5342" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> vCluster </strong>使用<a class="ae kf" href="https://k3s.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> k3s </strong> </a>作为其API服务器，使虚拟集群超轻量级，性价比高；由于k3s群集100%兼容，虚拟群集也100%兼容。<strong class="lg iu"> vclusters </strong>是超级轻量级的(1 pod)，消耗很少的资源，可以在任何Kubernetes集群上运行，而不需要对底层集群的特权访问。与<strong class="lg iu"> Capsule </strong>相比，它确实使用了更多的资源，但它提供了更多的灵活性<strong class="lg iu">因为多租户只是其中一个用例。</strong></p><figure class="nj nk nl nm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/6f7427003d829a0bcde19a26935f306f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7zanezkkRt9vJnn76PnuQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">vCluster使用案例</figcaption></figure><h1 id="ba43" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">其他工具</h1><ul class=""><li id="6ee3" class="mu mv it lg b lh li ll lm lp mw lt mx lx my mb mz na nb nc bi translated"><a class="ae kf" href="https://kubeapps.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> KubeApps </strong> </a>是一个基于web的UI，用于在Kubernetes集群中部署和管理应用程序。它提供了一个很好的用户界面，你可以浏览和安装公共或私人应用程序(舵图)。</li><li id="3bbe" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated">KubeSphere  是一个巨大的项目，它提供了<strong class="lg iu">许多</strong>的特色。它有一个很好的用户界面，允许你管理K8s集群，用户和应用程序。它还有一个类似KubeApps的应用商店。它有许多集成。我可以就此写一篇单独的文章，但在我看来，KubeSphere有一些缺点。第一个是它有点过时，而且没有遵循最新的Kubernetes最佳实践，比如GitOps。第二，它非常需要资源。我建议你检查这个项目，特别是如果你更喜欢使用UI和/或你是使用更传统工具的组织的一部分。</li><li id="5ef7" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://troubleshoot.sh/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">trouble shooting . sh</strong></a>是对运行在Kubernetes上的<strong class="lg iu">应用进行</strong>故障排除的必备工具。它有许多检查，分析器和收集器，以获得您需要的所有信息。这对于解决在客户实例中运行的应用程序的问题非常有用。您可以设置检查，客户可以运行这些检查来帮助解决问题，还可以设置收集器来获取所需的所有数据，以便客户可以向您发送包含所有详细信息的zip文件。</li><li id="faa3" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://github.com/cloud-bulldozer/kube-burner" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> kube-burner </strong> </a>用于<strong class="lg iu">压力测试</strong>。它提供指标和警报。</li><li id="afac" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://github.com/litmuschaos/litmus" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">石蕊</strong> </a>为混沌工程。</li><li id="dd4b" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://github.com/bitnami-labs/kubewatch" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> kubewatch </strong> </a>用于监控，但主要集中在基于Kubernetes事件的<strong class="lg iu">推送通知</strong>，如资源创建或删除。它可以集成许多工具，如<strong class="lg iu"> Slack </strong>。</li><li id="20dc" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://www.botkube.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> BotKube </strong> </a>是一个用于监控和调试Kubernetes集群的消息传递机器人。类似于kubewatch，但更新和更多的功能。</li><li id="5a5e" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://getmizu.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Mizu </strong> </a>是一个API流量查看器和调试器。</li><li id="d705" class="mu mv it lg b lh nd ll ne lp nf lt ng lx nh mb mz na nb nc bi translated"><a class="ae kf" href="https://github.com/senthilrch/kube-fledged" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"/></a>是一个Kubernetes插件，用于直接在Kubernetes集群的worker节点上创建和管理容器图像的缓存。结果，<strong class="lg iu">应用程序几乎立即启动</strong>，因为图像不需要从注册表中取出。</li></ul><h1 id="6888" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="21fb" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在本文中，我们回顾了我最喜欢的Kubernetes工具。我关注的是可以包含在任何Kubernetes发行版中的开源项目。我没有介绍商业解决方案，如<a class="ae kf" href="https://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> OpenShift </strong> </a>或云提供商插件，因为我想保持它的通用性，但我鼓励你探索一下如果你在云上运行Kubernetes或使用商业工具，你的云提供商能为你提供什么。</p><p id="44a6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我的目标是向你展示在Kubernetes 你可以做任何你在现场做的事情。我还更关注那些我认为可能有很大潜力的不太为人知的工具，如<a class="ae kf" href="https://crossplane.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"/></a><strong class="lg iu">Argo Rollouts或</strong><a class="ae kf" href="https://kubevela.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Kubevela</strong></a>。让我比较兴奋的工具有<a class="ae kf" href="https://www.vcluster.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">v cluster</strong></a><a class="ae kf" href="https://crossplane.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">cross plane</strong></a>和<strong class="lg iu"> ArgoCD/Workflows </strong>。</p><p id="afc9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><em class="mh">记得来</em> <strong class="lg iu"> <em class="mh">拍拍</em> </strong> <em class="mh">如果你喜欢这篇文章还有</em> <a class="ae kf" href="https://javier-ramos.medium.com/subscribe" rel="noopener"> <em class="mh"> </em> <strong class="lg iu"> <em class="mh">关注</em> </strong> <em class="mh"> </em> <strong class="lg iu"> <em class="mh">我</em> </strong> </a> <em class="mh">或</em> <a class="ae kf" href="https://javier-ramos.medium.com/membership" rel="noopener"> <strong class="lg iu"> <em class="mh">订阅</em> </strong> </a> <em class="mh">获取更多更新！</em></p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="1154" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">更新</strong>:我目前在坦桑尼亚帮助当地的一所学校，我创建了一个<a class="ae kf" href="https://www.gofundme.com/f/help-the-mango-school-children-in-tanzania" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> GoFundMe活动</strong> </a>来帮助孩子们，通过这个<a class="ae kf" href="https://www.gofundme.com/f/help-the-mango-school-children-in-tanzania" rel="noopener ugc nofollow" target="_blank">链接</a>来捐款，每一点帮助！</p><p id="065a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://javier-ramos.medium.com/subscribe" rel="noopener"> <strong class="lg iu">订阅</strong> </a>获得<strong class="lg iu">通知</strong>当我发表一篇文章和<a class="ae kf" href="https://javier-ramos.medium.com/membership" rel="noopener"> <strong class="lg iu">加入Medium.com</strong></a>访问百万或文章！</p></div></div>    
</body>
</html>