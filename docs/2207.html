<html>
<head>
<title>Introduction to Multi-dimensional Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多维动态规划简介</h1>
<blockquote>原文：<a href="https://itnext.io/introduction-to-multi-dimensional-dynamic-programming-666b095b2e7b?source=collection_archive---------5-----------------------#2019-04-16">https://itnext.io/introduction-to-multi-dimensional-dynamic-programming-666b095b2e7b?source=collection_archive---------5-----------------------#2019-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2df2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解解决微型依赖问题的技术背后的直觉，以最终解释正在讨论的问题。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/c622f331952a58c952c4b4d43651ccda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qk3DcExU96FH6dVzuOAONw.jpeg"/></div></figure><h2 id="d2fd" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是动态编程？</h2><p id="bb29" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">这是一种解决特殊类型问题的技术，这些问题可以分解成许多相互依赖的子问题。所谓依赖，我的意思是要解决一个子问题，你需要其他子问题的答案。这将动态编程(dp)与其他方法(如分而治之)区分开来，在其他方法中，我们通常创建独立的子问题。对dp最直观的解释之一是将其定义为一个有向图，其中节点是子问题，两个节点之间的边表示一个问题对另一个问题的依赖性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/16ace8715df4f6e1bd0bb596f6500e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*EudacVfB__pOyev1g8DbpA.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">图1:有向图，节点是子问题，边是依赖关系。</figcaption></figure><p id="3ebd" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">举一个例子，我们必须找到从S到D的最短路径(参考图1)。仔细看，你可以通过B或C到达D，因此逻辑上最短的路径应该通过其中一个。为此，我们定义dist(x) =从S到任何节点‘x’的最短距离。我们必须求解dist(D ),它也可以写成，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/bc917508116b67fa8a36dbc9e4f98763.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*xZJoG6bcFBGU8yxlOor07g.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">到D的最短路径是到B和c的最短路径的函数。</figcaption></figure><p id="84a0" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">同样，dist(B)可以用A来表示，dist(C)可以用s来表示。通过求解它们中的每一个，我们得到dist(D ),即预期的解。总的来说，我们正在寻找可以分解为相关子问题的问题，这些问题将成为dp应用的候选问题。</p><h2 id="62a4" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">可能的方法</h2><p id="b29a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">概括地说，有两种方法可以解决dp问题，</p><ol class=""><li id="74a6" class="mn mo iq ll b lm mh lp mi kw mp la mq le mr mb ms mt mu mv bi translated"><strong class="ll ir">自上而下的方法</strong>:在这种方法中，我们应用递归技术向下钻取解决主问题所需的所有相关子问题。在这里，我们从顶部即最终问题开始，但要找到它，我们必须解决所有子问题，因此要解决所有子问题。把它们都结合起来，我们就有了最终的解决方案。例如，在上一节中，我们从dist(D)开始，即主要问题，并求解dist(B)、dist(C)、dist(A)等来找到它。</li><li id="7366" class="mn mo iq ll b lm mw lp mx kw my la mz le na mb ms mt mu mv bi translated"><strong class="ll ir">自底向上的方法</strong>:这里我们从基础案例开始，即最低可能的子问题，向前迭代直到我们遇到最终问题。例如，如果我们从S开始，然后遍历到C，A，然后继续向上，直到到达D，这将是自底向上的方法。</li></ol><h2 id="094a" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">尺寸是怎么回事？</h2><p id="dc61" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">我们定义了子问题及其依赖关系，dp中的其他重要实体是依赖元素或变量。这些变量的数量决定了问题的规模。如果一个问题依赖于一个变量，这是一个1D dp问题，同样，在两个变量的情况下，这是一个2D dp问题。让我们看一下每个例子，</p><h2 id="7cd0" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">一维DP问题</h2><p id="6b2c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">假设我们想要在序列的特定索引处找到<a class="ae nb" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波那契</a>数。所以fib(n) =斐波那契数列中的第n个元素。那么，我们应该如何使用dp来解决这个问题呢？让我们首先尝试识别子问题，fib(n)是否与fib(n-1)，fib(n-2)…fib(0)等任何前辈有任何相关性？当然，根据定义，fib(n) = fib(n-1) + fib(n-2)。对于fib(n-1)和fib(n-2)也是如此，直到我们遇到fib(0) = 0或fib(1) = 1的基本情况。来制定，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e452bb69d7a3047cee16cbb76e6a2013.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*wplcS0uiDwXe661QC4og-g.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">斐波那契递归公式</figcaption></figure><p id="081e" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">很明显，我们使用的是自上而下的方法(我们也可以使用自下而上的方法)，因变量只有1，即“n ”,它是索引号。利用这个我们可以解决斐波纳契问题。让我们编码吧，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="72f5" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">在继续之前，有一点很重要，递归方法一个基本问题是它多次解决同一个问题。在我们的例子中，在绘制n = 5的函数调用时，我们得到</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/d6dd8be2b191fec3ce089146e50599c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*p3K5JT9gdMqTz-S-Wpa4Ww.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">递归函数调用fib(5)</figcaption></figure><p id="bd59" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">在这里，我们想解决调用一次的fib(5)，但其他子问题有不同的调用，如fib(4) — 1、fib(3) — 2、fib(2) — 3、fib(1) — 5、fib(0) — 3。多次解决同一个问题是很不直观的，如果我们存储一个问题的解决方案，下次调用时只需传递存储的答案，我们就可以处理这个问题。这叫做记忆化。修改前面的代码使其更加优化，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="0875" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">二维动态规划问题</h2><p id="9762" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">这类问题有两个因变量。让我们以编辑距离为例。在这个问题中，我们有两个字符串，我们必须找到这两个字符串之间不相似的度量。这是通过将一个字符串(视觉上)放置在另一个字符串的顶部并试图找到最佳拟合点来计算的，这样通过应用最小编辑，我们可以将一个字符串转换为另一个字符串。因此命名为编辑距离。支持的编辑包括插入、删除和替换。由于主要任务之一需要找到最佳拟合点，具有不同对齐或拟合的同一对弦将给出不同的编辑距离。举个例子，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/42c36dd980e69b273b660590823f2dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*tW7MgozQeA9A8qwXrm83pg.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">成本不同的两种不同路线</figcaption></figure><p id="9659" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">考虑“下雪”和“晴天”，上图显示了两种可能的匹配。现在，成本或编辑距离是如何计算的？以左侧对齐为例，我们需要执行3次编辑(因此成本= 3)来将snowy转换为sunny，即(1)在索引1处插入U，(2)在索引3处用N替换O，以及(3)在索引4处删除W。</p><p id="7e89" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">现在，让我们看看是否可以应用dp来解决这个问题，因为我们需要识别相关的子问题。我们的主要问题是找到两个字符串之间的编辑距离x[1..m](长度为m)和y[1…n](长度为n)。如果我们尝试解决x的某个前缀即x[1…i]和y即y[1…j]的问题呢？我们能在此基础上解决下一个问题吗？以前面的例子为例，如果我们知道“sno”和“sun”的编辑距离，我们可以用它来求解“SnO”和“sunn”吗？取这些字符串的最后一个字符，即“w”和“n”，形式上我们只能执行三个操作，(1)删除“w”(2)插入“n”，或(3)将“o”与“w”匹配，在这种情况下，它们可以相同或不同(这导致替换)，这里它们是不同的。一般来说，我们可以对任意一对x[i]和y[j]执行这些操作。在(1)的情况下，我们删除x[i]并且我们必须求解剩余的x[1...i-1]和y[1…j]，对于(2)我们插入y[i]，我们求解x[1…i]和y[1…j-1]或者(3)我们求解x[1…i-1]和y[1…j-1]。不错！在所有这些情况下，我们只需解决较小的问题，并不断增加可能的编辑操作的成本，现在让它们都等于1。我们的公式现在变成了，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/713f6c9e7c844a11ce0a27f634ba6fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*XvsbSXkNyMp6LbDUMLg9Og.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">如果x[i] = y[j]，编辑距离，其中diff(i，j) = 0，否则为1</figcaption></figure><p id="d717" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">由于问题是二维的——每个字符串的索引——我们需要维护一个2d表来存储所有处理过的编辑距离。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e2d4d2e95eff8010124b85a82bb7be6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*w1DROoQGjTyYIbkRpf2Xjw.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">列用于大小为n的字符串2，行用于大小为m的字符串1</figcaption></figure><p id="2769" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">这里，单元格(I，j)定义了从string_1到索引I再到string_2到索引j所需的编辑距离，我们的目标是找到单元格(m，n)的值。此外，由于(I，j)处的编辑距离需要3个不同单元格的值，我们需要以这样的方式遍历表格，即当我们在(I，j)处时，我们已经求解了(i-1，j)、(I，j-1)和(i-1，j-1)。最后定义基本情况，当i =0或j =0时，因此(0，5)意味着将空白字符串转换为5长度的字符串，这只是5次插入，因此成本为5，对于(5，0)也是如此。为了考虑到这一点，我们在表中添加了具有这些默认值的附加列和行。因此伪代码是，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8e8863dc55d64706ac5c38551d4245de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*AihXkk6kmkR7faqvXfoA3w.png"/></div></figure><p id="bec1" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">让我们编码吧，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="94e0" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">解决“指数”和“多项式”的问题，我们的表格转换为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2e70c1c004bf789b31f5641b00959422.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*Gl8P_Br8aOiKa7X4Z78jTg.png"/></div></figure><p id="ddb2" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">所以两个字符串之间的最终编辑距离是6。</p><h2 id="85a9" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h2><p id="e20e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">我们只是触及了技术的表面，并试图解决一些经典问题。dp中最重要也可能是最困难的部分是正确识别子问题，这个过程有时需要大量的剔除。这篇文章背后的想法是为读者提供一个简短的介绍和识别维度和子问题的逻辑背后的直觉。一旦完成，我们就基本上解决了问题，剩下的就是将子问题组合成一个好的公式，剩下的就完美地分解了。悬浮物</p><h2 id="fa5a" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">参考</h2><p id="d110" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">[1]算法，由Christos Papadimitriou、Sanjoy Dasgupta和Umesh Vazirani合著</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="3f87" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated"><em class="ns">喜欢帖子请鼓掌分享，有问题请评论。还可以访问我的</em> <a class="ae nb" href="http://mohitmayank.com" rel="noopener ugc nofollow" target="_blank"> <em class="ns">个人博客</em> </a> <em class="ns">获取更多此类帖子。</em></p><p id="3083" class="pw-post-body-paragraph lj lk iq ll b lm mh jr lo lp mi ju lr kw mj lt lu la mk lw lx le ml lz ma mb ij bi translated">干杯。</p></div></div>    
</body>
</html>