<html>
<head>
<title>Rollback for microservices with Ansible and Jenkins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ansible和Jenkins的微服务回滚</h1>
<blockquote>原文：<a href="https://itnext.io/rollback-for-microservices-with-ansible-and-jenkins-9bf84e36a694?source=collection_archive---------4-----------------------#2019-06-18">https://itnext.io/rollback-for-microservices-with-ansible-and-jenkins-9bf84e36a694?source=collection_archive---------4-----------------------#2019-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="21d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您的项目由4个微服务组成(3个后端，1个前端)。昨天，您介绍了几个新功能并发布了一个版本。不幸的是，您的用户刚刚报告了一个错误。一些旧的重要功能不起作用了。您需要对所有服务进行回滚。啊，如果可以一键搞定。</p><p id="dd75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其实可以。在这篇文章中，我将向您展示如何。</p><p id="cae4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">技术堆栈:</p><ul class=""><li id="9911" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">Jenkins支持回滚自动化</li><li id="9e43" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">用于回滚脚本的Ansible + Python</li><li id="8838" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">用于存储发布映像的Docker注册表</li><li id="6530" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">运行应用程序的DC/操作系统</li></ul><h1 id="c45a" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">概观</h1><p id="f7e2" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们将有一个python脚本，叫做via Ansible from Jenkins，如本文<a class="ae mf" href="https://justtech.blog/2019/04/27/ansible-and-jenkins-automate-your-scritps/" rel="noopener ugc nofollow" target="_blank">中所述。唯一的区别是—我们应该运行两个不同的标签。第一个收集所有可用的映像，第二个运行回滚。</a></p><p id="17a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mg mh mi mj b">get</code>算法:</p><ol class=""><li id="f3e7" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn mk ku kv kw bi translated">从docker注册表中请求所有图像。按环境过滤，按日期排序，并为每个存储库取最后10个。</li><li id="aa57" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mk ku kv kw bi translated">用存储库、图像和日期形成json，并写入文件系统</li></ol><p id="0669" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mg mh mi mj b">run</code>算法:</p><ol class=""><li id="2f89" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn mk ku kv kw bi translated">从get second step中读取json并创建一个Jenkins输入</li><li id="99ac" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mk ku kv kw bi translated">获取选定日期的所有可用映像并执行回滚</li></ol><p id="77f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回滚本身:</p><ol class=""><li id="777c" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn mk ku kv kw bi translated">修改marathon json配置中的docker图像部分</li><li id="170c" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn mk ku kv kw bi translated">使用修改后的配置开始部署</li></ol><h2 id="297b" class="ml ld it bd le mm mn dn li mo mp dp lm kb mq mr lq kf ms mt lu kj mu mv ly mw bi translated">特例</h2><p id="d5ce" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">想象一个服务，它在这个版本中没有改变。这意味着它将没有任何可用的回滚映像。但是由于兼容性问题，您仍然需要回滚它。请在下图中找到这种情况的例子。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/04bc24b7e3929bab02867c9146220803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/0*OB09gfZoMuFdBrRe.png"/></div></figure><p id="8a84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果选择<code class="fe mg mh mi mj b">Today-1</code>，只有<code class="fe mg mh mi mj b">Repo1</code>和<code class="fe mg mh mi mj b">Repo3</code>会被回滚，因为<code class="fe mg mh mi mj b">Repo2</code>没有图像。也许它没有被改变。</p><p id="87bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的问题是<code class="fe mg mh mi mj b">Repo1</code>或<code class="fe mg mh mi mj b">Repo3</code> N-1版本可能与<code class="fe mg mh mi mj b">Repo2</code>最新版本不兼容。所以你需要在回滚日期之前找到<code class="fe mg mh mi mj b">Repo2</code>的下一个版本。是<code class="fe mg mh mi mj b">Today-2</code>版本。</p><h1 id="5777" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">获得回滚</h1><p id="7016" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们将有两个回滚操作:</p><ul class=""><li id="872e" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">我们收集当前环境可用的所有回滚日期和映像。</li><li id="f3f4" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">用户选择数据，我们执行回滚。</li></ul><h2 id="165d" class="ml ld it bd le mm mn dn li mo mp dp lm kb mq mr lq kf ms mt lu kj mu mv ly mw bi translated">易弯曲侧</h2><p id="a7e0" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">可能的变化很小。只需为常见步骤添加两个标签(如需求安装):</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="0648" class="ml ld it mj b gy nj nk l nl nm">- name: "Copy requirements.txt"<br/>  copy:<br/>      src: "requirements.txt"<br/>      dest: "/tmp/{{ role_name }}/"<br/>  tags:<br/>    - get<br/>    - run</span></pre><p id="7c68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要忘记在<code class="fe mg mh mi mj b">always</code>步骤中添加标记，否则您的清理将被忽略。最好只使用<code class="fe mg mh mi mj b">run</code>标签。</p><p id="d06f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mg mh mi mj b">get</code>输出中注册回滚并调试它们会很有用。在这种情况下，即使没有Jenkins，您也可以使用Ansible。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="22d3" class="ml ld it mj b gy nj nk l nl nm">- name: "Get rollbacks"<br/>  shell: "source activate /tmp/{{ role_name }}/{{ conda_env }} ; {{ item }}"<br/>  with_items:<br/>     - pip install -r /tmp/{{ role_name }}/requirements.txt <br/>     - "python /tmp/{{ role_name }}/rollback.py get --repo={{ repo }} --dump={{ dump_path }} --env={{ env }}"<br/>  args:<br/>  executable: /bin/bash<br/>  tags:<br/>     - get<br/>  register: rollbacks</span><span id="81c0" class="ml ld it mj b gy nn nk l nl nm"> - debug:<br/>     var: rollbacks.results[1].stdout<br/>   tags:<br/>      - get</span></pre><h2 id="caa1" class="ml ld it bd le mm mn dn li mo mp dp lm kb mq mr lq kf ms mt lu kj mu mv ly mw bi translated">Python端</h2><p id="59ba" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">使用<a class="ae mf" href="http://docopt.org/" rel="noopener ugc nofollow" target="_blank"> docopt </a>你可以使用一个带有两个选项的入口点，一个用于<code class="fe mg mh mi mj b">get</code>，一个用于<code class="fe mg mh mi mj b">run</code>。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="4e0a" class="ml ld it mj b gy nj nk l nl nm">Usage:<br/>  rollback.py get --repo=&lt;r&gt; --env=&lt;e&gt; [--dump=&lt;dr&gt;]<br/>  rollback.py run --date=&lt;d&gt; --env=&lt;e&gt; --slack=&lt;s&gt; --user=&lt;u&gt; --pwd=&lt;p&gt; [--dump=&lt;dr&gt;]</span></pre><p id="50e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">叉子本身:</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="f320" class="ml ld it mj b gy nj nk l nl nm">if arguments['get']:<br/>   return get(repo, env, dump)<br/>if arguments['run']:<br/>   return run(date, env, slack, user, pwd, dump)</span></pre><p id="aa92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要获得回滚，您需要首先调用Docker registry的API。<br/>我假设您使用这个图像命名模式:<br/> <code class="fe mg mh mi mj b">&lt;private-docker-registry-host:port&gt;/service-name:build-number-branch</code></p><p id="2138" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您需要获取当前repo的所有标签，按环境过滤它们，然后按日期排序并返回最后10个标签。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="d7bb" class="ml ld it mj b gy nj nk l nl nm">def get_rollbacks(repo: str, env: str):<br/>  r = requests.get(f'{DOCKER_REGISTRY}/v2/{repo}/tags/list', verify=False)<br/>  if r.status_code != 200:<br/>    raise Exception(f"Failed to fetch tags {r.status_code}") <br/>  releases = list(filter(lambda x: x.endswith(env), r.json()['tags']))<br/>  all_rollbacks = [(get_manifest(repo, r), {r: repo}) for r in releases[-10:]]<br/>  return dict(all_rollbacks)</span></pre><p id="c828" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中repo是您的<code class="fe mg mh mi mj b">service-name</code>，env是当前分支。</p><p id="fe16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">按日期排序有点复杂。标签信息中不包括日期。得到它的唯一方法是获取<strong class="js iu"> mainfest </strong>并检查<code class="fe mg mh mi mj b">history</code>。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="1591" class="ml ld it mj b gy nj nk l nl nm">def get_manifest(repo, tag):<br/>  r = requests.get(f'{DOCKER_REGISTRY}/v2/{repo}/manifests/{tag}', verify=False)<br/>  if r.status_code != 200:<br/>    raise Exception(f"Failed to fetch manifest {r.raw}")<br/>  history = r.json()['history']<br/>  sort = sorted([json.loads(h['v1Compatibility'])['created'] for h in history])<br/>  return sort[-1][:10]</span></pre><p id="b41d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的get函数:</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="3f10" class="ml ld it mj b gy nj nk l nl nm">def get(repo: str, env: str, dump: str):<br/>  rollbacks = {}<br/>  repos = repo.split(',')<br/>  for r in repos:<br/>    for date, rb in get_rollbacks(r, env).items():<br/>      if date in rollbacks:<br/>        rollbacks[date] += [rb]<br/>      else:<br/>        rollbacks[date] = [rb]<br/>  print(rollbacks)<br/>  if dump is not None:<br/>    with open(path.join(dump, "rollback.json"), mode='w') as rb: <br/>      json.dump({'all': repos, 'rollbacks': rollbacks}, rb) return   <br/>  rollbacks.keys()</span></pre><p id="d4d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中repo是逗号分隔的服务名列表。<code class="fe mg mh mi mj b">repo1,repo2,repo3</code>f . e .您还需要为Ansible debug打印回滚。</p><h2 id="8d94" class="ml ld it bd le mm mn dn li mo mp dp lm kb mq mr lq kf ms mt lu kj mu mv ly mw bi translated">詹金斯侧</h2><p id="791b" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">让我们从环境输入开始Jenkins管道。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="0240" class="ml ld it mj b gy nj nk l nl nm">parameters { <br/>  choice(choices: 'dev\nstage\nprod', description: 'Which environment should I rollback?', name: 'environment') <br/>}</span></pre><p id="2d1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您使用主环境而不是prod，您不需要做任何事情。否则，您需要在管道外部创建静态变量<code class="fe mg mh mi mj b">rollback_env</code>，并在第一步填充它。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="2784" class="ml ld it mj b gy nj nk l nl nm">script { <br/>  // need this as env names don't match each other. develop/master/stage in docker vs dev/stage/prod in marathon <br/>  if (params.environment == 'prod') {<br/>    rollback_env = "master" <br/>  } else if(params.environment == 'stage') {<br/>    rollback_env = "stage" <br/>  } else {<br/>    rollback_env = "develop" <br/>  } <br/>}</span></pre><p id="ced1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后下载您的git repo和ansible playbook并运行它。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="b57a" class="ml ld it mj b gy nj nk l nl nm">git branch: 'master', <br/>    credentialsId: &lt;your git user credentials id&gt;', <br/>    url: "&lt;your ansible repo&gt;" <br/>ansiblePlaybook( <br/>    playbook: "${env.PLAYBOOK_ROOT}/rollback_service.yaml", <br/>    inventory: "inventories/dev/hosts.ini", <br/>    credentialsId: &lt;your git user credentials id&gt;', <br/>    extras: '-e "repo=' + "${env.REPOS}" + ' env=' + "${docker_env}" + ' slack=' + "${env.SLACK_CALLBACK}" + ' dump_path=' + "/tmp" + '" -v', <br/>    tags: "get")</span></pre><p id="515b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意<code class="fe mg mh mi mj b">dump_path</code>。它告诉python脚本直接在<code class="fe mg mh mi mj b">/tmp</code>中创建json，这样我们就可以从Jenkins那里读取了。让我们开始吧。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="179a" class="ml ld it mj b gy nj nk l nl nm">import groovy.json.JsonSlurper </span><span id="1ddb" class="ml ld it mj b gy nn nk l nl nm">def gather_rollback_dates() { <br/>  def inputFile = readFile("/tmp/rollback.json")<br/>  def InputJSON = new JsonSlurper().parseText(inputFile)<br/>  return InputJSON['rollbacks'].keySet().join("\n")<br/>}</span></pre><p id="db8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个函数将找到你的回滚，获取所有日期，并用<code class="fe mg mh mi mj b">\n</code>分隔符组成一个字符串。需要用下拉菜单生成输入。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="f00a" class="ml ld it mj b gy nj nk l nl nm">stage('Select rollback date') {<br/>  steps {<br/>    script {<br/>      def userInput = false<br/>      try { <br/>        timeout(time: 120, unit: 'SECONDS') {<br/>          userInput = input(id: 'userInput', <br/>                            message: 'Select a date to rollback', <br/>                            parameters: [ <br/>                                          choice(name: 'rollback_date', <br/>                                                 choices: gather_rollback_dates(), <br/>                                                 description: 'One or more services have rollback at this date')])<br/>        } <br/>      } catch(err) { <br/>      } <br/>      if (userInput) { <br/>        print('Performing rollback') <br/>        env.DATE = userInput <br/>      } else { <br/>        print('Skip rollback') <br/>      } <br/>    } <br/>  } <br/>}</span></pre><p id="faee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来是这样的:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/0270968c1167776dbb2166ad847fc6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vV3U5iz1wRCi-HMD.png"/></div></div></figure><h1 id="e1f0" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">执行回滚</h1><p id="c429" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">我们有5个回滚操作:</p><ul class=""><li id="2796" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">从上一步读取json</li><li id="7fba" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">查找所选日期的缺失图像</li><li id="edd9" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">从码头id获取马拉松服务id</li><li id="620f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">更改马拉松应用程序的配置</li><li id="1f2f" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">更新马拉松中的应用程序</li></ul><h2 id="97e7" class="ml ld it bd le mm mn dn li mo mp dp lm kb mq mr lq kf ms mt lu kj mu mv ly mw bi translated">易弯曲侧</h2><p id="b680" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">这里没什么特别的。就叫python吧。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="aa76" class="ml ld it mj b gy nj nk l nl nm">- name: "Perform rollbacks"<br/>  shell: "source activate /tmp/{{ role_name }}/{{ conda_env }} ; {{ item }}" <br/>  with_items: <br/>    - pip install -r /tmp/{{ role_name }}/requirements.txt <br/>    - "python /tmp/{{ role_name }}/rollback.py run<br/>       --date={{ date }}<br/>       --env={{ env }} <br/>       --slack={{ slack }} <br/>       --user={{ dcos_user }} <br/>       --dump={{ dump_path }} <br/>       --pwd={{ dcos_password }}" <br/>  tags: <br/>    - run</span></pre><h2 id="ce54" class="ml ld it bd le mm mn dn li mo mp dp lm kb mq mr lq kf ms mt lu kj mu mv ly mw bi translated">Python端</h2><p id="9cac" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">让我们从<code class="fe mg mh mi mj b">run</code>方法开始</p><p id="ae7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">读取json并选择选定日期的所有可用图像。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="4532" class="ml ld it mj b gy nj nk l nl nm">def run(date, env, slack, user, pwd, dump): <br/>  json_data = read_rollbacks(dump) <br/>  all_rollbacks = OrderedDict(sorted(json_data['rollbacks'].items(), key=lambda x: x[0])) <br/>  repos = json_data['all'] <br/>  images = all_rollbacks[date]</span></pre><p id="792b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一些回购的图像丢失，我们需要找到他们的旧版本。将此添加到您的<code class="fe mg mh mi mj b">run</code>方法中:</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="6203" class="ml ld it mj b gy nj nk l nl nm">if len(repos) &gt; 1 and len(repos) &gt; len(images):    <br/>  get_missing_images(date, repos, all_rollbacks)</span></pre><p id="706c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中<code class="fe mg mh mi mj b">get_missing_images</code>只是遍历all_rollbacks并为每个丢失的映像选择日期最近的映像。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="a157" class="ml ld it mj b gy nj nk l nl nm">def get_missing_images(date, repos, all_rollbacks):<br/>  images = all_rollbacks[date] # select available images <br/>  found_services = [list(rb.values())[0] for rb in images] # get services from images <br/>  missing = list(set(repos) - set(found_services)) # substract to get missing <br/>  for service in missing: # populate images with rollback for every missing <br/>    rollback = get_nearest_date(service, date, all_rollbacks) <br/>    if rollback is None: <br/>      print(f"Previous rollback for {service} not found") <br/>    else: <br/>      images += [rollback] </span><span id="15a1" class="ml ld it mj b gy nn nk l nl nm">def get_nearest_date(repo, date, all_rollbacks): <br/>  for d, images in reversed(all_rollbacks.items()): <br/>    if d &lt; date: <br/>      for rollback, image in images[0].items(): <br/>        if image == repo: <br/>          return {rollback: image} <br/>  return None</span></pre><p id="3ba7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们有我们的图像填充后，我们需要获得马拉松服务id。我们的马拉松id使用标准<code class="fe mg mh mi mj b">/&lt;department&gt;/&lt;environment&gt;/&lt;project&gt;/&lt;service-name&gt;</code>。在这一步，我们只有<code class="fe mg mh mi mj b">service-name</code>，所以我们应该创建一个到Maration id的绑定。</p><p id="d3bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过列出在Maration中运行的所有应用程序，并根据环境和服务名称对它们进行过滤(我还没有找到更好的解决方案)。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="e2ef" class="ml ld it mj b gy nj nk l nl nm">def get_service_ids(env: str, images: list, user: str, pwd: str) -&gt; dict: <br/>  ids_only = get_marathon_ids_for_env(env, user, pwd) # all running services for env <br/>  services = {} <br/>  for rollback in images: <br/>    tag = list(rollback.keys())[0] <br/>    id_part = rollback[tag] <br/>    real_id = list(filter(lambda x: x.endswith(id_part), ids_only)) # filter by service-name <br/>    if not real_id: <br/>      raise Exception(f"Id {id_part} not found") <br/>    services[real_id[0]] = tag <br/>  return services </span><span id="b590" class="ml ld it mj b gy nn nk l nl nm">def get_marathon_ids_for_env(env: str, user: str, pwd: str): <br/>  res = call_with_output(f'dcos auth login --username={user} --password={pwd}') <br/>  if res.decode().strip() != 'Login successful!': <br/>    raise Exception("Can't login to dcos cli") <br/>  all_services = call_with_output('dcos marathon app list') <br/>  matched = list(filter(lambda x: x.startswith(f"/ds/{env}"), all_services.decode().split('\n'))) <br/>  return [m.split(' ')[0] for m in matched]</span></pre><p id="d3eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了服务id之后，我们可以遍历它们并为每个服务id执行回滚。把这个加入到你的<code class="fe mg mh mi mj b">run</code>方法中:</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="a293" class="ml ld it mj b gy nj nk l nl nm">services = get_service_ids(env, images, user, pwd) <br/>for service_id, service_tag in services.items(): <br/>  if slack is not None: <br/>    notify_slack(slack, f"Rollback { service_id }: { service_tag }")    <br/>  print(do_deploy(service_id, service_tag))</span></pre><p id="da33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，就这些。不要忘记为回滚添加松弛通知。</p><h2 id="4272" class="ml ld it bd le mm mn dn li mo mp dp lm kb mq mr lq kf ms mt lu kj mu mv ly mw bi translated">詹金斯侧</h2><p id="ccb2" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">Python部分是最复杂的。在Jenkins端，你只需要用<code class="fe mg mh mi mj b">run</code>标签和选定的日期调用Ansible。</p><pre class="my mz na nb gt nf mj ng nh aw ni bi"><span id="f6f0" class="ml ld it mj b gy nj nk l nl nm">stage('Rollback') { <br/>  when { <br/>    expression { <br/>      return env.DATE != null <br/>    } <br/>  } <br/>  steps { <br/>    ansiblePlaybook( <br/>             playbook: "${env.PLAYBOOK_ROOT}/rollback_service.yaml", <br/>             inventory: "inventories/dev/hosts.ini", <br/>             credentialsId: &lt;your git user credentials id&gt;', <br/>             extras: '-e "date=' + "${env.DATE}" + ' env=' + "${params.environment}" + ' slack=' + "${env.SLACK_CALLBACK}" + ' dump_path=' + "/tmp" + '" -v', <br/>             tags: "run")<br/>  }<br/>}</span></pre><h1 id="2a5c" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">总结</h1><p id="960b" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">当前的解决方案相当复杂，但它允许您通过cli从Ansible和Jenkins运行回滚。第二个是首选，因为您可以看到批准回滚的用户。</p><p id="e804" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好好救火，希望你永远不需要回滚！</p></div></div>    
</body>
</html>