<html>
<head>
<title>Rebuilding the monolith</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重建巨石柱</h1>
<blockquote>原文：<a href="https://itnext.io/rebuilding-the-monolith-59e54614f070?source=collection_archive---------8-----------------------#2018-02-06">https://itnext.io/rebuilding-the-monolith-59e54614f070?source=collection_archive---------8-----------------------#2018-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6edf2556e76aa8d27a679bf2b8a1cb29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2msUEoKn33HpWZR_6Pn1w.jpeg"/></div></div></figure><p id="be0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当构建前端应用程序时，我们可以用一种新的、更奇特的技术来重建我们的整体。然而，没有什么花哨的时髦词汇能拯救我们免于建造一块巨石的后果。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="5cda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ld" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Frebuilding-the-monolith-59e54614f070" rel="noopener ugc nofollow" target="_blank"> <em class="le">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="599e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们深入这篇文章之前，我想快速提醒一下，思考你的作品是在什么样的背景/组织和项目的哪一部分中形成的是多么重要。在某些情况下，一个整体可能是一个比替代品更好的主意。</p><h1 id="d2fe" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">代码的组织</h1><p id="9318" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">因此，您决定为您的前端架构创建一个前端应用程序。您有一个开发团队在前端工作。项目的文件夹结构应该是什么样的？</p><p id="2311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按文件类型组织文件相当容易。在react with redux中，这意味着您将至少拥有文件夹:<em class="le">动作、reducers、容器、组件</em>。在Angular中，您可能熟悉另一种结构:<em class="le">基于组件的架构</em>，如<a class="ae ld" href="https://johnpapa.net/angular-2-styles/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> John Papa </strong> </a> <strong class="ka ir">所述。</strong>各部件遵循<a class="ae ld" href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">稳固</strong> </a>的原则。</p><p id="e3ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于类型的文件组织很好，因为它消除了命名组件和组织哪个文件属于哪个组件的大量开销。如果你想制作一个MVP或者在一个开发团队中工作，这可能是一个不错的选择。</p><h1 id="8de9" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在规模化环境中工作</h1><p id="cd5e" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">当你在一个规模更大的环境中与多个团队一起工作时，这应该是独立的，在同一个前端应用程序上，这变得更加棘手。你可以开始将你的项目分成不同的<em class="le">包</em>别名<em class="le">大组件。</em>重要的是，这些<em class="le">包</em>及其组件中的每一个都只能在一个有限的上下文中运行，就像我们从<a class="ae ld" href="https://martinfowler.com/bliki/BoundedContext.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">领域驱动设计</strong> </a>中所知道的那样。这是因为它有助于降低团队的耦合度，提高团队的自主性，但是它确实会在项目计划中增加一些时间开销。然而，在软件的整个生命周期中，以稳定的开发速度和可维护性的形式，这种规划可能是一种可靠的投资。</p><p id="1d89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不做计划会导致代码腐烂，降低开发速度，最终导致整个项目被抛弃。</p><h1 id="84a6" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">把所有的放在一起</h1><p id="7ef4" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">每个<em class="le">包</em>都可以看作是一个微服务，可以用不同的方式单独发布。一个核心项目可以通过诸如<a class="ae ld" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Webpack </strong> </a> <strong class="ka ir"> </strong>之类的工具消费所有发布的包。一个有趣的方法是由项目<a class="ae ld" href="https://github.com/CanopyTax/single-spa" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> single-spa </strong> </a>完成的，它也是框架不可知的。根据你所做的，你可能会得到一个分布式的整体。然而，不同的方法和它们各自的缺陷值得一文讨论。</p></div></div>    
</body>
</html>