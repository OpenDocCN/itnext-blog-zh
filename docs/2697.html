<html>
<head>
<title>Android Google I/O 2019 ViewPager2 (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安卓谷歌I/O 2019 ViewPager2(第二部分)</h1>
<blockquote>原文：<a href="https://itnext.io/android-viewpager2-with-pretty-page-margin-bfae8dd397a8?source=collection_archive---------0-----------------------#2019-07-14">https://itnext.io/android-viewpager2-with-pretty-page-margin-bfae8dd397a8?source=collection_archive---------0-----------------------#2019-07-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/0ea41698edcb7b7868e20b2f9bb12a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nlf0V_eboZNKA_R5aeVRxg.gif"/></div></div></figure><p id="af2b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe la lb lc ld b">ViewPager2</code>自<a class="ae le" href="https://android-developers.googleblog.com/2019/05/whats-new-with-android-jetpack.html" rel="noopener ugc nofollow" target="_blank"> 2019 Google I/O </a>起已公布3个月，是旧款<a class="ae le" href="https://developer.android.com/reference/android/support/v4/view/ViewPager" rel="noopener ugc nofollow" target="_blank"> ViewPager </a>的替代产品。然而，它仍然处于<a class="ae le" href="https://developer.android.com/jetpack/androidx/releases/viewpager2" rel="noopener ugc nofollow" target="_blank"> alpha阶段</a> ( <code class="fe la lb lc ld b">1.0.0-alpha06</code>)，一些流行的功能对于开发者来说仍然是缺失的。设置页面之间的页边空白是其中之一，它是实现上面显示的布局行为的关键设置。</p><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj lf"><img src="../Images/6f7f8527b1eb3eb313c3a390855ef7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*Lh8jAVhMEFRcFnbHTfDnEA.png"/></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated">与设置页面边距相关的功能截图</figcaption></figure><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj lo"><img src="../Images/c669eed11e90ffde6685ac8146162232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*pxnaJFygwsIidp1pp-zlkA.png"/></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated">ViewPager2页边空白设置相关功能截图</figcaption></figure><p id="9dc0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">本文将简单讨论如何破解<code class="fe la lb lc ld b">ViewPager2</code>，实现与<code class="fe la lb lc ld b">ViewPager</code>相同的缺页边距功能和上述布局。</p></div><div class="ab cl lp lq hy lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="in io ip iq ir"><h1 id="ae27" class="lw lx iu bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">先决条件</h1><p id="b4ad" class="pw-post-body-paragraph kc kd iu ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz in bi translated">假设你已经对<code class="fe la lb lc ld b">ViewPager2</code>的设置有了基本的了解，包括给gradle文件添加相应的依赖关系，给<code class="fe la lb lc ld b">RecyclerView.Adapter</code>赋值<code class="fe la lb lc ld b">ViewPager2</code>。</p><div class="mz na gq gs nb nc"><a href="https://medium.com/swlh/android-viewpager2-tablayout-3099aae2f396" rel="noopener follow" target="_blank"><div class="nd ab fp"><div class="ne ab nf cl cj ng"><h2 class="bd iv gz z fq nh fs ft ni fv fx it bi translated">Android ViewPager2和TabLayout</h2><div class="nj l"><h3 class="bd b gz z fq nh fs ft ni fv fx dk translated">ViewPager2是在今年的2019 Google I/O中推出的，它取代了旧的ViewPager，后者是在…</h3></div><div class="nk l"><p class="bd b dl z fq nh fs ft ni fv fx dk translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ka nc"/></div></div></a></div></div><div class="ab cl lp lq hy lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="in io ip iq ir"><h1 id="ecda" class="lw lx iu bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">ViewPager2剖析</h1><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj nr"><img src="../Images/a05457fc30a2eaf5647a64264833915c.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*P4qc2jh3K9gnDTU8Ai_-xw.jpeg"/></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated">ViewPager2剖析</figcaption></figure><p id="aded" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe la lb lc ld b">ViewPager2</code>是<code class="fe la lb lc ld b">ViewPager</code>的重新设计，包含一个用于显示其内容的<code class="fe la lb lc ld b">RecyclerView</code>。</p><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj ns"><img src="../Images/5d177436287e6057bd8a491944ad031a.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*sbRWMVlynZNdgfpc7xifEQ.png"/></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated"><a class="ae le" href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/viewpager2/src/main/java/androidx/viewpager2/widget/ViewPager2.java" rel="noopener ugc nofollow" target="_blank">view page 2源代码</a>的第143行</figcaption></figure><p id="ee12" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是，<code class="fe la lb lc ld b">mRecyclerView</code>是<code class="fe la lb lc ld b">ViewPager2</code>的私有成员实例，不能直接用<code class="fe la lb lc ld b">RecyclerView</code>直接访问。因此，我们必须找到一个技巧来绕过它。</p><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj nt"><img src="../Images/8f68f234e2afb5a0f42b2444d664c6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*wOu7nYoABIxKj5F8ZHhvTg.png"/></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated">Android Studio日志显示了ViewPager2的属性</figcaption></figure><p id="ae5a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">根据Android Studio日志，每个<code class="fe la lb lc ld b">ViewGroup</code>实例都可以访问一个公共字段<code class="fe la lb lc ld b">children</code>。因此，可以通过这种方式访问内部<code class="fe la lb lc ld b">RecyclerView</code>实例。😉</p></div><div class="ab cl lp lq hy lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="in io ip iq ir"><h1 id="4cc6" class="lw lx iu bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">我们开始吧！</h1><h2 id="8953" class="nu lx iu bd ly nv nw dn mc nx ny dp mg kn nz oa mk kr ob oc mo kv od oe ms of bi translated">步骤1:访问RecyclerView实例</h2><figure class="lg lh li lj gu jv"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="0c27" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我对上述代码做了两个假设:</p><ol class=""><li id="8e0c" class="oi oj iu ke b kf kg kj kk kn ok kr ol kv om kz on oo op oq bi translated"><code class="fe la lb lc ld b">ViewPager2</code>将持续使用<code class="fe la lb lc ld b">RecyclerView</code>显示其内容。</li><li id="2029" class="oi oj iu ke b kf or kj os kn ot kr ou kv ov kz on oo op oq bi translated"><code class="fe la lb lc ld b">ViewPager2</code>只会有一个<code class="fe la lb lc ld b">RecyclerView</code>的实例。</li></ol><p id="878a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在我看来，这是目前两个有效的假设。</p><h2 id="32d7" class="nu lx iu bd ly nv nw dn mc nx ny dp mg kn nz oa mk kr ob oc mo kv od oe ms of bi translated">第2步:添加RecyclerView。RecyclerView实例的ItemDecoration</h2><figure class="lg lh li lj gu jv"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="de44" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><a class="ae le" href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.ItemDecoration" rel="noopener ugc nofollow" target="_blank">项目装饰</a>是<code class="fe la lb lc ld b">RecyclerView</code>的一部分，负责在<code class="fe la lb lc ld b">RecyclerView</code>显示的项目之间添加分隔线。结果如下所示:</p><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/3aee47709127f65329897235117c4d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*UttR9bAw7tgxVHp5VVi7iA.gif"/></div></figure><blockquote class="ox oy oz"><p id="3e87" class="kc kd pa ke b kf kg kh ki kj kk kl km pb ko kp kq pc ks kt ku pd kw kx ky kz in bi translated">请注意，如果设置了起始(左侧)分隔符，它将抛出以下奇怪的异常。它来源于<code class="fe la lb lc ld b">ScrollEventAdapter</code>其中t <em class="iu">将</em> <code class="fe la lb lc ld b"><em class="iu">RecyclerView.OnScrollListener</em></code> <em class="iu">事件转换为</em> <code class="fe la lb lc ld b"><em class="iu">OnPageChangeCallback</em></code> <em class="iu">事件<br/>为</em> <code class="fe la lb lc ld b"><em class="iu">ViewPager2</em></code> <em class="iu">。</em></p></blockquote><pre class="lg lh li lj gu pe ld pf pg aw ph bi"><span id="0f28" class="nu lx iu ld b gz pi pj l pk pl">java.lang.IllegalStateException: Page can only be offset by a positive amount, not by -42</span></pre><p id="1b70" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><em class="pa">计算</em> <code class="fe la lb lc ld b"><em class="pa">RecyclerView</em></code> <em class="pa">中第一项的偏移量时引起。我相信这是</em> <code class="fe la lb lc ld b"><em class="pa">ViewPager2</em></code> <em class="pa">的一个bug，希望在未来能够修复。</em></p></div><div class="ab cl lp lq hy lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="in io ip iq ir"><h1 id="ca1f" class="lw lx iu bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">实际案例:我们如何用ViewPager2实现以下行为？</h1><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/495c9105dca5fdbf8379e201b2c64e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*tqtLWEigwZHDLqm7AMWvvg.gif"/></div></figure><p id="d833" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi pm translated"><span class="l pn po pp bm pq pr ps pt pu di">乍一看</span>，相信通过在<code class="fe la lb lc ld b">RecyclerView</code>两侧设置水平填充，并在<code class="fe la lb lc ld b">RecyclerView</code>级别禁用<code class="fe la lb lc ld b">clipToPadding</code>属性，就可以简单地完成上述布局。</p><figure class="lg lh li lj gu jv"><div class="bz fq l di"><div class="og oh l"/></div></figure><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/ba15758d135488f559324bbfffe75c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*hA59MKzfjN32AAetim9z_g.gif"/></div></figure><p id="2af3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是，这种方法并不可行，因为<code class="fe la lb lc ld b"><em class="pa">ScrollEventAdapter</em></code>会抛出一条与设置<code class="fe la lb lc ld b">RecyclerView</code>项的起始(左)分隔符相同的错误信息。</p><pre class="lg lh li lj gu pe ld pf pg aw ph bi"><span id="3033" class="nu lx iu ld b gz pi pj l pk pl">java.lang.IllegalStateException: Page can only be offset by a positive amount, not by -42</span></pre></div><div class="ab cl lp lq hy lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="in io ip iq ir"><h1 id="5766" class="lw lx iu bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">第二次尝试—使用旧的ViewPager设置:</h1><p id="36b6" class="pw-post-body-paragraph kc kd iu ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz in bi translated">在互联网上有很多材料教导如何用旧的<code class="fe la lb lc ld b">ViewPager</code>实现上述行为。其中一个示例如下所示:</p><div class="mz na gq gs nb nc"><a href="https://stackoverflow.com/questions/7343487/android-viewpager-padding-margin-between-page-fragments" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fp"><div class="ne ab nf cl cj ng"><h2 class="bd iv gz z fq nh fs ft ni fv fx it bi translated">Android ViewPager页面片段之间的填充/边距</h2><div class="nj l"><h3 class="bd b gz z fq nh fs ft ni fv fx dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="nk l"><p class="bd b dl z fq nh fs ft ni fv fx dk translated">stackoverflow.com</p></div></div><div class="nl l"><div class="pv l nn no np nl nq ka nc"/></div></div></a></div><figure class="lg lh li lj gu jv"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="d2ca" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是，通过设置这些属性并不会让<code class="fe la lb lc ld b">RecyclerView</code>在<code class="fe la lb lc ld b">ViewPager2</code>水平填充上方显示其内容。发生了什么事？让我们看到下一个会议的进一步讨论。</p><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/4587c79dbd46f616eb63de9935726fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*i3b1yPohJdHPZXDEKxrRjg.gif"/></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated">ViewPager2上旧ViewPager设置的图示</figcaption></figure></div><div class="ab cl lp lq hy lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="in io ip iq ir"><h1 id="94fe" class="lw lx iu bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">最后一次尝试—添加ViewPager2和inner RecyclerView的更多设置</h1><h2 id="92cf" class="nu lx iu bd ly nv nw dn mc nx ny dp mg kn nz oa mk kr ob oc mo kv od oe ms of bi translated">步骤1:添加不平衡的水平填充并禁用<code class="fe la lb lc ld b">clipToPadding</code>属性</h2><figure class="lg lh li lj gu jv"><div class="bz fq l di"><div class="og oh l"/></div></figure><p id="b02c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">和那些<code class="fe la lb lc ld b">ViewPager</code>的教程一样，水平<code class="fe la lb lc ld b">padding</code>必须设置为禁用<code class="fe la lb lc ld b">clipToPadding</code>属性。这允许子视图<code class="fe la lb lc ld b">RecyclerView</code>被绘制在<code class="fe la lb lc ld b">ViewPager2</code>的填充之上。</p><p id="5939" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是，水平填充不平衡。<code class="fe la lb lc ld b">PaddingStart</code>是<code class="fe la lb lc ld b">32dp</code>，<code class="fe la lb lc ld b">paddingEnd</code>是<code class="fe la lb lc ld b">16dp</code>。这是因为只有右(端)分隔符无错误地设置在内部<code class="fe la lb lc ld b">RecyclerView</code>处，而分隔符先前设置为<code class="fe la lb lc ld b">16dp</code>。因此，<code class="fe la lb lc ld b">paddingEnd</code>必须偏移<code class="fe la lb lc ld b">16dp</code>。</p><h2 id="3b2e" class="nu lx iu bd ly nv nw dn mc nx ny dp mg kn nz oa mk kr ob oc mo kv od oe ms of bi translated">步骤2:在ViewPager2和RecyclerView级别禁用clipChildren属性</h2><figure class="lg lh li lj gu jv"><div class="bz fq l di"><div class="og oh l"/></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated">设置为<viewpager2/></figcaption></figure><figure class="lg lh li lj gu jv"><div class="bz fq l di"><div class="og oh l"/></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated">设置为内部<recyclerview/></figcaption></figure><blockquote class="ox oy oz"><p id="aa82" class="kc kd pa ke b kf kg kh ki kj kk kl km pb ko kp kq pc ks kt ku pd kw kx ky kz in bi translated"><code class="fe la lb lc ld b">ClipChildren</code>属性定义了<code class="fe la lb lc ld b">ViewGroup</code>的子视图是否可以超出其自身的界限。</p><p id="8406" class="kc kd pa ke b kf kg kh ki kj kk kl km pb ko kp kq pc ks kt ku pd kw kx ky kz in bi translated">参考:<a class="ae le" href="https://developer.android.com/reference/android/view/ViewGroup.html#setClipChildren(boolean)" rel="noopener ugc nofollow" target="_blank">谷歌开发者官方文档</a></p></blockquote><p id="7ea9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">通过禁用<code class="fe la lb lc ld b">clipChildren</code> , <code class="fe la lb lc ld b">ViewPager2</code>允许其子<code class="fe la lb lc ld b">RecyclerView</code>超出其边界(区域)绘制。</p><p id="7162" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然而，<code class="fe la lb lc ld b">RecyclerView</code>默认情况下会将它的子视图限制在自己的范围内。因此，<code class="fe la lb lc ld b">clipChildren</code>属性也必须被禁用。</p><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/fa097855ab2f031005f630af60c13dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*7TVJ6NeK1k2EoPxSbHnfhA.gif"/></div></figure><p id="4e07" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">此时，只有在滑动<code class="fe la lb lc ld b">ViewPager2</code>时才能绘制多页。这是完全不能接受的。这个问题是由于<code class="fe la lb lc ld b">ViewPager2</code>内部的<code class="fe la lb lc ld b">RecyclerView</code>缓存机制造成的。</p><h2 id="33c4" class="nu lx iu bd ly nv nw dn mc nx ny dp mg kn nz oa mk kr ob oc mo kv od oe ms of bi translated">步骤3:更新offscreenPageLimit</h2><figure class="lg lh li lj gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj pw"><img src="../Images/efe912b8cffcc58b6721dfb89a81ca12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxcRxrExW9Ta9vR8VrcJyQ.png"/></div></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated"><a class="ae le" href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/viewpager2/src/main/java/androidx/viewpager2/widget/ViewPager2.java" rel="noopener ugc nofollow" target="_blank">view page 2源代码</a>的第113–118行</figcaption></figure><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj px"><img src="../Images/d50020fac5d4b4653f9c0257433e62d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*mIE2olFFpN48vMNPTrJEqg.png"/></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated"><a class="ae le" href="https://android.googlesource.com/platform/frameworks/support/+/jb-dev/v4/java/android/support/v4/view/ViewPager.java" rel="noopener ugc nofollow" target="_blank"> ViewPager源代码</a>的第87–91行</figcaption></figure><p id="d942" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">与旧的<code class="fe la lb lc ld b">ViewPager</code>不同，<code class="fe la lb lc ld b">ViewPager2</code>的<code class="fe la lb lc ld b">offscreenPageLimit</code>被设置为<code class="fe la lb lc ld b">-1</code>，这意味着<code class="fe la lb lc ld b">RecyclerView</code>不缓存任何两边的视图。换句话说，当两边的视图不再是居中的页面时，它们将被移除。</p><p id="8336" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因此，<code class="fe la lb lc ld b">offscreenPageLimit</code>必须至少设置为<code class="fe la lb lc ld b">1</code>，以告知内部<code class="fe la lb lc ld b">RecyclerView</code>在<strong class="ke iv">两侧</strong>缓存1视图。</p><figure class="lg lh li lj gu jv"><div class="bz fq l di"><div class="og oh l"/></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated">将offscreenPageLimit设置为在两端缓存视图</figcaption></figure><blockquote class="ox oy oz"><p id="a5a4" class="kc kd pa ke b kf kg kh ki kj kk kl km pb ko kp kq pc ks kt ku pd kw kx ky kz in bi translated">旁注:<br/>默认<code class="fe la lb lc ld b"><em class="iu">offscreenPageLimit</em></code>设置为<code class="fe la lb lc ld b"><em class="iu">-1</em></code>的原因是<code class="fe la lb lc ld b"><em class="iu">ViewPager2</em></code>现在是为显示与<code class="fe la lb lc ld b"><em class="iu">ViewPager2</em></code>大小相同的页面而设计的。因此，没有必要缓存任何视图，因为它们在屏幕上都是不可见的。</p></blockquote><figure class="lg lh li lj gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj py"><img src="../Images/c2dc6a1597e85e5378046978e1c3f485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MI8c1liGDoumUnbLpqr8KQ.png"/></div></div><figcaption class="lk ll gk gi gj lm ln bd b be z dk translated"><a class="ae le" href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/viewpager2/src/main/java/androidx/viewpager2/widget/ViewPager2.java" rel="noopener ugc nofollow" target="_blank">view page 2源代码</a>的第234–257行</figcaption></figure></div><div class="ab cl lp lq hy lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="in io ip iq ir"><h2 id="c8a1" class="nu lx iu bd ly nv nw dn mc nx ny dp mg kn nz oa mk kr ob oc mo kv od oe ms of bi translated">最终结果:</h2><figure class="lg lh li lj gu jv gi gj paragraph-image"><div class="gi gj ow"><img src="../Images/495c9105dca5fdbf8379e201b2c64e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*tqtLWEigwZHDLqm7AMWvvg.gif"/></div></figure></div><div class="ab cl lp lq hy lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="in io ip iq ir"><h1 id="9b41" class="lw lx iu bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">结论</h1><ol class=""><li id="bd1e" class="oi oj iu ke b kf mu kj mv kn pz kr qa kv qb kz on oo op oq bi translated"><code class="fe la lb lc ld b">ViewPager2</code> ( <code class="fe la lb lc ld b">1.0.0-alpha06</code>)包含一个用于显示内容的<code class="fe la lb lc ld b">RecyclerView</code>。</li><li id="63db" class="oi oj iu ke b kf or kj os kn ot kr ou kv ov kz on oo op oq bi translated">即使内部<code class="fe la lb lc ld b">RecyclerView</code>实例是私有的，但是它仍然可以被<code class="fe la lb lc ld b">ViewPager2</code>的公共<code class="fe la lb lc ld b">children</code>属性访问，该属性是一个<code class="fe la lb lc ld b">ViewGroup</code>。</li><li id="ddca" class="oi oj iu ke b kf or kj os kn ot kr ou kv ov kz on oo op oq bi translated">甚至<code class="fe la lb lc ld b">ViewPager2</code>中不包含<code class="fe la lb lc ld b">setPageMargin()</code>，但可以通过设置内<code class="fe la lb lc ld b">RecyclerView</code>的<code class="fe la lb lc ld b">ItemDecoration</code>来替换</li><li id="d924" class="oi oj iu ke b kf or kj os kn ot kr ou kv ov kz on oo op oq bi translated">在保持上一页和下一页的同时设置水平填充的页面对于<code class="fe la lb lc ld b">ViewPager2</code>来说比<code class="fe la lb lc ld b">ViewPager</code>更困难，因为在<code class="fe la lb lc ld b">ViewPager2</code>视图层次结构中还有一个子层。</li><li id="494e" class="oi oj iu ke b kf or kj os kn ot kr ou kv ov kz on oo op oq bi translated">除了设置水平<code class="fe la lb lc ld b">paddings</code>和禁用<code class="fe la lb lc ld b">ViewPager2</code>的<code class="fe la lb lc ld b">clipToPadding</code>属性外，还需要禁用<code class="fe la lb lc ld b">ViewPager2</code>和内<code class="fe la lb lc ld b">RecyclerView</code>的<code class="fe la lb lc ld b">clipChildren</code>属性，以进行越界绘制。</li><li id="2ca6" class="oi oj iu ke b kf or kj os kn ot kr ou kv ov kz on oo op oq bi translated">默认情况下，内部<code class="fe la lb lc ld b">RecyclerView</code>的缓存机制是禁用的，因此必须启用才能同时显示多个视图。</li><li id="5f86" class="oi oj iu ke b kf or kj os kn ot kr ou kv ov kz on oo op oq bi translated"><code class="fe la lb lc ld b">ViewPager2</code>目前不允许设置内部<code class="fe la lb lc ld b">RecyclerView</code>的<code class="fe la lb lc ld b">paddingStart</code>和开始<code class="fe la lb lc ld b">ItemDecoration</code>。否则，将导致来自<code class="fe la lb lc ld b"><em class="pa">ScrollEventAdapter</em></code> <em class="pa"> </em>的异常。</li></ol><pre class="lg lh li lj gu pe ld pf pg aw ph bi"><span id="69b2" class="nu lx iu ld b gz pi pj l pk pl">java.lang.IllegalStateException: Page can only be offset by a positive amount, not by -42</span></pre></div><div class="ab cl lp lq hy lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="in io ip iq ir"><h1 id="3900" class="lw lx iu bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">进一步阅读:</h1><ol class=""><li id="67bc" class="oi oj iu ke b kf mu kj mv kn pz kr qa kv qb kz on oo op oq bi translated"><code class="fe la lb lc ld b">ViewPager2</code>和<code class="fe la lb lc ld b">TabLayout</code>之间的联动不再容易。为此，它需要<a class="ae le" href="https://github.com/googlesamples/android-viewpager2/blob/master/app/src/main/java/androidx/viewpager2/integration/testapp/TabLayoutMediator.java" rel="noopener ugc nofollow" target="_blank"> TabLayoutMediator </a>。本文涵盖了从基本设置到将<code class="fe la lb lc ld b">Tab</code>与<code class="fe la lb lc ld b">ViewPager2</code>链接。</li></ol><div class="mz na gq gs nb nc"><a href="https://medium.com/swlh/android-viewpager2-tablayout-3099aae2f396" rel="noopener follow" target="_blank"><div class="nd ab fp"><div class="ne ab nf cl cj ng"><h2 class="bd iv gz z fq nh fs ft ni fv fx it bi translated">Android ViewPager2和TabLayout</h2><div class="nj l"><h3 class="bd b gz z fq nh fs ft ni fv fx dk translated">ViewPager2是在今年的2019 Google I/O中推出的，它取代了旧的ViewPager，后者是在…</h3></div><div class="nk l"><p class="bd b dl z fq nh fs ft ni fv fx dk translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ka nc"/></div></div></a></div><p id="7b05" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">2.<code class="fe la lb lc ld b">TabLayout</code>与<code class="fe la lb lc ld b">ViewPager</code>和<code class="fe la lb lc ld b">ViewPager2</code>密切配合。然而，样式<code class="fe la lb lc ld b">TabLayout</code>和<code class="fe la lb lc ld b">TabItem</code>有时会混淆。需要的话可以看看下面这篇文章。</p><div class="mz na gq gs nb nc"><a href="https://medium.com/swlh/android-tablayout-and-tabitem-268ac06ba966" rel="noopener follow" target="_blank"><div class="nd ab fp"><div class="ne ab nf cl cj ng"><h2 class="bd iv gz z fq nh fs ft ni fv fx it bi translated">一体化—Android tablayut和TabItem</h2><div class="nj l"><h3 class="bd b gz z fq nh fs ft ni fv fx dk translated">设计一个TabLayout的样式并不像您想象的那么简单。Google官方文档与材料组件不同步…</h3></div><div class="nk l"><p class="bd b dl z fq nh fs ft ni fv fx dk translated">medium.com</p></div></div><div class="nl l"><div class="qc l nn no np nl nq ka nc"/></div></div></a></div><p id="38ee" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">3.点样式的<code class="fe la lb lc ld b">TabItem</code>没有正式的文档。这个过程总结起来只有4个简单的步骤。</p><div class="mz na gq gs nb nc"><a href="https://medium.com/swlh/4-steps-to-android-dot-tabitem-dadeeef44f51" rel="noopener follow" target="_blank"><div class="nd ab fp"><div class="ne ab nf cl cj ng"><h2 class="bd iv gz z fq nh fs ft ni fv fx it bi translated">Android Dot TabItem的4个步骤</h2><div class="nj l"><h3 class="bd b gz z fq nh fs ft ni fv fx dk translated">在许多应用程序中，向TabLayout呈现点是很常见的。只有4个步骤来配置点！点击阅读更多…</h3></div><div class="nk l"><p class="bd b dl z fq nh fs ft ni fv fx dk translated">medium.com</p></div></div><div class="nl l"><div class="qd l nn no np nl nq ka nc"/></div></div></a></div></div><div class="ab cl lp lq hy lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="in io ip iq ir"><p id="70be" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">欢迎您关注我，在<a class="ae le" href="https://twitter.com/myrick_chow" rel="noopener ugc nofollow" target="_blank">Twitter @ my rik _ chow</a>了解更多信息。感谢您阅读这篇文章。祝您愉快！😄</p></div></div>    
</body>
</html>