<html>
<head>
<title>Best coding practices from an Angular 12 migration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 12迁移的最佳编码实践</h1>
<blockquote>原文：<a href="https://itnext.io/best-coding-practices-from-an-angular-12-migration-78a3bc96a65d?source=collection_archive---------1-----------------------#2021-06-22">https://itnext.io/best-coding-practices-from-an-angular-12-migration-78a3bc96a65d?source=collection_archive---------1-----------------------#2021-06-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="b3c6" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">另一篇最佳实践和指南文章</h2></div><p id="0890" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">几天前，我和我的同事安排了一次会议，会上我提出了一些关于良好开发实践的指导方针。这一切都是因为我在一个特征分支上做的<a class="ae lc" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">角度12 </a>迁移。</p><p id="2d69" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">从上下文来看，我目前工作的公司有几个项目安排在<a class="ae lc" href="https://nrwl.io/" rel="noopener ugc nofollow" target="_blank"> NX Monorepo </a>中。随着新的Angular版本的发布，我们在git存储库上打开了一个特性分支，在这里我们对应用程序进行了所有必要的调整和更改，以便使用新的Angular版本。</p><p id="2319" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">Angular 12与Angular 11并没有什么不同，所以移植几乎没有痛苦。但是……代码验证有点严格，所以出现了一些问题，我在许多地方发现了一些缺陷，这就是我打算写的，希望阅读这篇文章的人不要犯同样的错误。</p></div><div class="ab cl le lf hv lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ik il im in io"><h2 id="3ed3" class="ll lm ir bd ln lo lp dn lq lr ls dp lt kp lu lv lw kt lx ly lz kx ma mb mc md bi translated">重要说明</h2><p id="a055" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">正如我已经提到的，迁移中涉及的项目是基于NX口味的monorepo构建的，这意味着几个应用程序驻留在一个存储库中。这些应用程序既是前端又是后端，所以在Angular前端项目上发现了一些问题，但在Typescript后端项目上也发现了一些问题。</p></div><div class="ab cl le lf hv lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ik il im in io"><h1 id="a005" class="mj lm ir bd ln mk ml mm lq mn mo mp lt jx mq jy lw ka mr kb lz kd ms ke mc mt bi translated">变量类型</h1><p id="83d1" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">当使用<a class="ae lc" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> Typescript </a>编写任何函数时，如果我们使用的变量没有类型，我们的代码就容易出错。Typescript在运行时不进行任何类型验证，所以如果有错误，它将抛出一个错误，如果您不注意处理错误，可能会发生大爆炸和火灾。</p><p id="445a" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">例如。</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="7714" class="ll lm ir mz b gz nd ne l nf ng">export interface User {<br/>  name: string;<br/>  age: number;<br/>  birthDate: Date;<br/>  isActive: boolean;<br/>}</span><span id="d28a" class="ll lm ir mz b gz nh ne l nf ng">// Both parameters are implicit any (can be anything)<br/>export function editUser(originalUser, newUserInfo) {<br/>  let updatedUser = Object.assign({}, originalUser, newUserInfo);<br/>  return updatedUser;<br/>}</span><span id="3814" class="ll lm ir mz b gz nh ne l nf ng">const oUser: User = {<br/>  name: 'Jose Santa Cruz',<br/>  age: 44,<br/>  birthDate: new Date('April 5, 1977'),<br/>  isActive: true<br/>};<br/>const uUser = editUser(oUser, { <br/>  fullName: 'Jose I Santa Cruz',<br/>  birthDate: new Date('April 5, 1977'),<br/>  isActive: 'false'<br/>});<br/>console.log(uUser);<br/>/*<br/>{<br/>  name: 'Jose Santa Cruz',<br/>  age: 44,<br/>  birthDate: 1977-04-05T04:00:00.000Z,<br/>  isActive: 'false',<br/>  fullName: 'Jose I Santa Cruz'<br/>}<br/>*/</span></pre><p id="1e4e" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">而那个执行是“<em class="ld">正确的</em>”，只是因为我们没有检查变量类型。如果我们只是做一些调整，同样的代码会显示一些错误(在编码时间上)。</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="ddee" class="ll lm ir mz b gz nd ne l nf ng">export function editUser(originalUser: User, newUserInfo: User) {<br/>  let updatedUser = Object.assign({}, originalUser, newUserInfo);<br/>  return updatedUser;<br/>}<br/><br/>const oUser: User = {<br/>  name: 'Jose Santa Cruz',<br/>  age: 44,<br/>  birthDate: new Date('April 5, 1977'),<br/>  isActive: true<br/>};<br/>const uUser = editUser(oUser, { <br/>  fullName: 'Jose I Santa Cruz',<br/>  birthDate: new Date('April 5, 1977'),<br/>  isActive: 'false'<br/>});</span></pre><p id="9e7a" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这立即显示了该错误(在<a class="ae lc" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank">对代码</a>):</p><figure class="mu mv mw mx gu nj gi gj paragraph-image"><div class="gi gj ni"><img src="../Images/061c69a83cd6112afdbc2955cb41b999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*Xe6a4d30bjhgZQC4Qlz7_g.jpeg"/></div></figure><p id="0150" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">类型字符串不能赋给类型boolean。而且有道理，<code class="fe nm nn no mz b">'false' !== false</code></p><p id="957d" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">更正此问题会显示另一个错误:</p><figure class="mu mv mw mx gu nj gi gj paragraph-image"><div class="gi gj np"><img src="../Images/14d830c92577d46bae8842ab0bf1ae54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*gcnKyeOSM0ammbLVVUl-JQ.jpeg"/></div></figure><p id="b395" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这也是正确的，因为一开始定义的用户界面没有fullName属性。只需将fullName属性更改为Name。您还必须根据需要添加年龄属性。如果你希望它是可选的，只需编辑界面，使其显示为:<code class="fe nm nn no mz b">age?: number;</code></p><p id="0d03" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">正如我所说的，这在编程时很有帮助，你不会因为没有输入变量而犯编程错误，但没人说这种错误不会在运行时发生。所有这些错误都会在编译阶段出现。</p><p id="376e" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">但是具有泛型的类型也需要足够具体，以避免一些类似的错误，我将在下一节解释这一点。</p></div><div class="ab cl le lf hv lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ik il im in io"><h1 id="8f63" class="mj lm ir bd ln mk ml mm lq mn mo mp lt jx mq jy lw ka mr kb lz kd ms ke mc mt bi translated">承诺</h1><p id="0bf9" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">承诺是一个不同的故事。总结一下什么是<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>，假设你问我明天的气候。我会回答“<em class="ld">好的，我会告诉你明天……</em>的气候”，答案不一定马上就出来，你还可以去给自己冲杯咖啡，再编码一会儿，某个时候我会说“<em class="ld">明天会是个晴天</em>”。你通常需要注意这个答案，否则它会丢失，你永远也不会知道我什么时候回答的，或者我什么时候重启自己而忘记回答或者出错了。</p><p id="bda6" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">在代码中:</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="2210" class="ll lm ir mz b gz nd ne l nf ng">function randomError() {<br/>  return ( Math.random() * 1000 ) &gt;= 499;<br/>}</span><span id="eaf6" class="ll lm ir mz b gz nh ne l nf ng">function dummyDelay(callback: any, timeout?: number) {<br/>  // If no timeout (in ms) is given then consider <br/>  // a random delay of at least 1.5s <br/>  // and a max delay of 3.5s<br/>  timeout = (!timeout) ? Math.floor(Math.random() * 2000) + 1500 : timeout;<br/>  console.debug('Your answer will come on after a ', timeout/1000, 's delay...');<br/>  setTimeout(callback, timeout);<br/>}</span><span id="717a" class="ll lm ir mz b gz nh ne l nf ng">export function askForClimate() {<br/>  console.log('Hi! I will tell you the climate... (please be patient :) )');<br/>  return new Promise((resolve, reject) =&gt; {<br/>    dummyDelay(()=&gt; {<br/>      if (randomError()) {<br/>        // On error, just forget to give <br/>        // the climate but acknowledge that<br/>        // to the user <br/>        reject('Oh no! something terrible happened...');<br/>      }	</span><span id="ee5f" class="ll lm ir mz b gz nh ne l nf ng">      // For the example all days will be <br/>      // sunny days<br/>      resolve('Today will be a sunny day! Enjoy...');<br/>    });<br/>		<br/>  });<br/>}</span><span id="e76f" class="ll lm ir mz b gz nh ne l nf ng">askForClimate().then(<br/>  data =&gt; console.log('The climate: ', data),<br/>  err =&gt; console.error('ERROR ', err)<br/>);</span></pre><p id="79b9" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我知道，我在这里跳过了很多思考(我很惭愧，零个文档)。但我会尽力补偿你:</p><ul class=""><li id="f48d" class="nq nr ir ki b kj kk km kn kp ns kt nt kx nu lb nv nw nx ny bi translated"><em class="ld"> askForClimate </em>:我们的主要功能。你问气候，我告诉你我会回答(有时)。由于我们没有使用API来真正获得气候，我将模拟随机误差和随机延迟。</li><li id="0ea0" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated"><em class="ld"> randomError </em>:基于随机数生成“随机”错误或无错误状态。耶！可能是一个更好的随机函数，但我保持简单。</li><li id="fe7b" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated"><em class="ld"> dummyDelay </em>:将回调函数的执行延迟超时ms，这是一个假延迟，只是为了模拟网络延迟就好像通过API调用获得气候一样。</li></ul><p id="4013" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">所以，你问气候(<em class="ld"> askForClimate </em>)，我说我来回答(<code class="fe nm nn no mz b">console.log</code> at <em class="ld"> askForClimate </em>)，时间流逝(<em class="ld"> dummyDelay </em>，有事发生(<em class="ld"> randomError </em>，最后你可能会也可能不会收到气候的答案。</p><p id="2636" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">上面的代码工作正常，但显然我们可以做得更好。事实上，如果将这段代码放在Angular 12服务下，您会得到很多错误，这是因为Angular 12编译比通常更严格。所以让我们对代码的类型更严格一些。</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="76ca" class="ll lm ir mz b gz nd ne l nf ng">function randomError(): boolean {<br/>  return ( Math.random() * 1000 ) &gt;= 499;<br/>}<br/><br/>function dummyDelay(callback: (args?: unknown) =&gt; void, timeout?: number): void {</span><span id="861f" class="ll lm ir mz b gz nh ne l nf ng">  // If no timeout (in ms) is given then consider a <br/>  // random delay of at least 1.5s <br/>  // and a max delay of 3.5s<br/>  timeout = (!timeout) ? Math.floor(Math.random() * 2000) + 1500 : timeout;<br/>  console.debug('Your answer will come on after a ', timeout/1000, 's delay...');<br/>  setTimeout(callback, timeout);<br/>}<br/><br/>export function askForClimate(): Promise&lt;string&gt; {<br/>  console.log('Hi! I will tell you the climate... (please be patient :) )');<br/>  return new Promise((resolve: (answer: string | PromiseLike&lt;string&gt;) =&gt; void, reject: (reason?: any) =&gt; void) =&gt; {<br/>    dummyDelay(()=&gt; {</span><span id="9bd5" class="ll lm ir mz b gz nh ne l nf ng">      if (randomError()) {<br/>        // On error, just forget to give the climate<br/>        // but acknowledge the user that <br/>        reject('Oh no! something terrible happened...');<br/>      }<br/><br/>      // For the example all days will be sunny days<br/>      resolve('Today will be a sunny day! Enjoy...');<br/>    });<br/>		<br/>  });<br/>}<br/><br/>askForClimate().then(<br/>  (data: string) =&gt; console.log('The climate: ', data),<br/>  (err: unknown) =&gt; console.error('ERROR ', err)<br/>);</span></pre><p id="83b4" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我要把它发挥到极致。在很多情况下，变量类型是从父函数中正确推断出来的。</p><p id="de2e" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">严格类型的好处是，当使用您编写的函数时，您的同事不会犯类型错误:</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="2d31" class="ll lm ir mz b gz nd ne l nf ng">* Argument of type '(data: number) =&gt; void' is not assignable to parameter of type '(value: string) =&gt; void | PromiseLike&lt;void&gt;'.<br/>  Types of parameters 'data' and 'value' are incompatible.<br/>    Type 'string' is not assignable to type 'number'.ts(2345) *</span></pre><p id="cb9d" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">作为一个好的实践，至少尝试为所有变量添加类型，这包括用于<a class="ae lc" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">泛型类型</a>的变量(例如Promise &lt; <em class="ld"> T </em> &gt;)。在最坏的情况下，使用<code class="fe nm nn no mz b">any</code>类型(不好，但也没那么糟)。如果将来你有机会知道变量类型，你可以使用管道连接类型，例如:<br/> <code class="fe nm nn no mz b">const pinCode: string | number; // pinCode can be a string or a number<br/></code>或者如果你不知道变量类型，也不想使用任何类型，使用未知类型。如果这样做，请确保相应地转换变量，例如:</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="ce57" class="ll lm ir mz b gz nd ne l nf ng">const pinCode: unknown;<br/>const deltaN: number = 123;<br/>const validation: number = (parseInt(pinCode as number, 10)) + deltaN;</span></pre></div><div class="ab cl le lf hv lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ik il im in io"><h1 id="b9e2" class="mj lm ir bd ln mk ml mm lq mn mo mp lt jx mq jy lw ka mr kb lz kd ms ke mc mt bi translated">回报承诺的承诺</h1><p id="2258" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">这个问题没有出现在Angular 12前端代码上，而是出现在后端。我们使用NX monorepo，因此大多数编码验证和限制都会影响前端和后端代码。</p><p id="e706" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">在我们的后端，我们使用<a class="ae lc" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>，Sequelize的大多数函数已经返回了承诺。问题是我在后端代码中发现了几个具有这种结构的函数:</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="4974" class="ll lm ir mz b gz nd ne l nf ng">// seqUser is a Sequelize model class<br/>export function retrieveUsers() {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    seqUser.findAll().then(<br/>      users =&gt; resolve(users),<br/>      error =&gt; {<br/>        console.error('ERROR retrieving user list: ', error);<br/>        reject();<br/>      }<br/>    );<br/>  });<br/>}</span></pre><p id="4057" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">看到这里的问题了吗？<code class="fe nm nn no mz b">seqUser.findAll</code>已经返回了一个<code class="fe nm nn no mz b">Promise&lt;Array&lt;seqUser&gt;&gt;</code>，所以没有必要将一个承诺包装在另一个承诺中。</p><p id="4dd0" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">但是请注意，我说的是<em class="ld">“没有真正的需要”</em>。那么，<em class="ld">真的有需求吗？很高兴你这么问。这是很有争议的，唯一有合理的理由将<em class="ld">承诺</em>包装在<em class="ld">承诺</em>中的情况是，检索到的数据需要一些额外的处理。因此您可以检索数据并修改一些值。</em></p><p id="475b" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">为什么在那里做，而不在真正使用承诺的函数中做？嗯，有一种东西叫做关注点分离(<em class="ld"> SoC </em>)，我稍后会讲到。</p></div><div class="ab cl le lf hv lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ik il im in io"><h1 id="43f4" class="mj lm ir bd ln mk ml mm lq mn mo mp lt jx mq jy lw ka mr kb lz kd ms ke mc mt bi translated">库导入</h1><p id="8f0f" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">正如我所说，该公司的项目生活在一个Nx的monorepo。repo有几个前端、后端和库项目，其中许多共享组件、类和服务。定义可伸缩的monorepo结构的意图很明显，因此组件的替换可以在不影响底层代码的情况下完成，但有时IDE(在这种情况下是VS代码)在导入库组件时无法帮助避免一些特定的错误。</p><p id="aefe" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">用一个例子；让我们假设你有几个项目被安排成一个Nx monorepo。您当前正在处理的库项目需要另一个库项目的某些功能:</p><ul class=""><li id="78b7" class="nq nr ir ki b kj kk km kn kp ns kt nt kx nu lb nv nw nx ny bi translated"><em class="ld"> lib/front-ui </em>:一个Angular库，有多个组件、服务、指令和管道，可以在多个项目中使用(这就是为什么它是一个库，以避免代码重复)。</li><li id="21be" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated"><em class="ld"> lib/shared-utils </em>:具有不依赖于任何其他库的纯函数的实用程序库。这样，我们可以在前端和后端项目中使用这个库。</li></ul><p id="5bf7" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">使用<a class="ae lc" href="https://nx.dev/latest/angular/getting-started/nx-cli" rel="noopener ugc nofollow" target="_blank"> Nx CLI </a>创建库，命令如下:</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="877e" class="ll lm ir mz b gz nd ne l nf ng">$ ng g @nrwl/angular:library FrontUi --buildable<br/>$ ng g @nrwl/node:library SharedUtils --buildable</span></pre><p id="4dc2" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">一旦执行，<code class="fe nm nn no mz b">angular.json</code>文件将有2个新的块，旨在构建这些库，<code class="fe nm nn no mz b">tsconfig.base.json</code>文件将有新的路径定义。<em class="ld">可构建的</em>参数是在你想单独构建你的库的情况下，也是利用<a class="ae lc" href="https://nx.app/docs/distributed-caching" rel="noopener ugc nofollow" target="_blank"> Nx云编译缓存</a>。</p><p id="10c0" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><strong class="ki is"> <em class="ld">注</em></strong>:Nx CLI本身就值得一篇完整的文章。</p><p id="6dbd" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">首先要做的是调整tsconfig的路径:</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="4f17" class="ll lm ir mz b gz nd ne l nf ng">"@mine/shared-utils": ["libs/shared-utils/src/index.ts"],<br/>"@mine/front-ui": ["libs/front-ui/src/index.ts"]</span></pre><p id="a0cf" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">到</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="25c0" class="ll lm ir mz b gz nd ne l nf ng">"@mine/shared-utils": ["libs/shared-utils/src/index.ts"],<br/>"@mine/shared-utils/*": ["libs/shared-utils/src/lib/*"],<br/>"@mine/front-ui": ["libs/front-ui/src/index.ts"],<br/>"@mine/front-ui/*": ["libs/front-ui/src/lib/*"]</span></pre><p id="f3c0" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">所以你有希望直接导入所有正确导出的库组件(比如<a class="ae lc" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular Material </a>)。</p><p id="4f52" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">顺便说一下，在我的<code class="fe nm nn no mz b">nx.json</code>上我有<code class="fe nm nn no mz b">"npmScope": "mine"</code>。</p><p id="963b" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">让我们假设你正在开发一个新的前台界面服务，叫做<code class="fe nm nn no mz b">NewDataService</code> : <code class="fe nm nn no mz b">$ ng g service services/NewData --project front-ui</code></p><p id="df87" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">在您的代码中，您需要从utils库中导入实用函数<code class="fe nm nn no mz b">printableJson</code>。大多数时候(也许不是大多数，但是很多时候)，如果你让<em class="ld"> IDE </em>做脏活并找出你的进口在哪里，你将<em class="ld">(可能/最有可能)</em>以类似于<br/> <code class="fe nm nn no mz b">import { printableJson } from ' libs/shared-utils/src/lib/services/new-data.service';</code> <br/>或者更糟的<br/> <code class="fe nm nn no mz b">import { printableJson } from ' ../../../../../shraed-utils/src/lib/services/new-data.service';</code>结束</p><p id="7c51" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">还记得您的tsconfig.base文件吗？让我们使用它:<br/> <code class="fe nm nn no mz b">import { printableJson } from ' @mine/shared-utils';</code> <br/>或者更好(如果一切都正确导出的话):<br/> <code class="fe nm nn no mz b">import { printableJson } from ' @mine/shared-utils/printableJson';</code></p><p id="8f40" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这更具可读性。</p><h1 id="56d7" class="mj lm ir bd ln mk oe mm lq mn of mp lt jx og jy lw ka oh kb lz kd oi ke mc mt bi translated">内部进口</h1><p id="2ed1" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">让我们假设您正在处理同一个服务(<em class="ld"> front-ui的NewDataService </em>)，但是需要添加对同一个库中另一个服务的调用，例如<code class="fe nm nn no mz b">RetrieveMetadataService</code>(已经在front-ui中定义)。你注意导入东西<em class="ld">“好的方式”</em>，在一个意想不到的例子中，你得到了:<code class="fe nm nn no mz b">import RetrieveMetadataService from '@mine/front-ui';</code></p><p id="2d66" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">记住你还在<em class="ld"> front-ui </em>里面。这可能会在开发环境中工作，但是在为生产进行构建时，您将会得到一个循环依赖错误。为什么？您不能将同一个库导入其自身。不好看，不好看= &gt;会一次生产编译失败。</p><h1 id="d484" class="mj lm ir bd ln mk oe mm lq mn of mp lt jx og jy lw ka oh kb lz kd oi ke mc mt bi translated">如何避免“坏”进口</h1><p id="3b05" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">只要确保你没有调用同一个库本身，并确保在你的导入中没有任何<em class="ld"> src </em>文件夹引用。如果你在你的导入上发现文本<em class="ld"> src/ </em>你做错了。</p><h1 id="1db6" class="mj lm ir bd ln mk oe mm lq mn of mp lt jx og jy lw ka oh kb lz kd oi ke mc mt bi translated">不可动摇的进口</h1><p id="db41" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">我在代码中发现的另一种讨厌的导入是像<br/>import * as my library from ' @ mine/my-library '；</p><p id="39d9" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这种导入对你的应用程序非常有害，因为它们将整个库作为别名导入，而不仅仅是你在代码中使用的几个函数。这些导入不是可动摇的树，并且严重影响了最终的应用程序包大小。</p><p id="0471" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">较大的包大小会导致糟糕的用户体验，因为应用程序大小会变得太大，下载大文件总是不好的(从web应用程序的角度来看)。</p><h1 id="9f73" class="mj lm ir bd ln mk oe mm lq mn of mp lt jx og jy lw ka oh kb lz kd oi ke mc mt bi translated">怎么解决？</h1><p id="bb47" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">这很简单，找到你代码中所有的<code class="fe nm nn no mz b">* as</code>,尽你所能修复它们。</p></div><div class="ab cl le lf hv lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ik il im in io"><h1 id="80ba" class="mj lm ir bd ln mk ml mm lq mn mo mp lt jx mq jy lw ka mr kb lz kd ms ke mc mt bi translated">学习使用命令行界面</h1><p id="f83a" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">正如您可能已经看到的，我使用了几个例子来放置命令执行:</p><ul class=""><li id="48de" class="nq nr ir ki b kj kk km kn kp ns kt nt kx nu lb nv nw nx ny bi translated">用于在monorepo中创建Nx库</li><li id="d697" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated">用于在<em class="ld"> front-ui </em>库中创建服务</li></ul><p id="612b" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这是因为我几乎记不住一个服务的内部语法，或者肯定不知道如何安排一个库的文件夹结构和编辑正确的文件。好消息是，有人已经努力完成了同样的任务，并制作了一个非常完整的命令行工具，所以我们可以忘记这一切，专注于开发的重要部分，即解决代码中的需求。</p><p id="89ff" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">Angular CLI是一个命令行工具，允许我们生成Angular应用程序所需的所有代码结构。之后，您必须编写所有的业务逻辑，但是您几乎可以忘记从您知道有效的组件中复制和粘贴。相信我，复制和粘贴代码可以工作几次，但你会忘记编辑或调整一些东西，一切都会悲惨地失败。</p><p id="9ba4" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">Angular CLI和Nx CLI的每个代码生成器都使用schematics。原理图是一段代码，它使用JSON定义作为其参数，一些类型脚本文件作为内部逻辑，一些模板用于生成代码。你真的不需要知道你安装的每一个CLI的所有原理图选项，只需要学习足够的知识来避免复制和粘贴。例如。</p><ul class=""><li id="01d9" class="nq nr ir ki b kj kk km kn kp ns kt nt kx nu lb nv nw nx ny bi translated">创建一个组件:<code class="fe nm nn no mz b">ng g component components/NewComponent</code></li><li id="50c9" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated">创建一个路由组件(又名页面):<code class="fe nm nn no mz b">ng g component pages/NewPage</code> <br/>，然后是<code class="fe nm nn no mz b">ng g module pages/NewPage --routing</code></li><li id="66ca" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated">创建服务:<code class="fe nm nn no mz b">ng g service services/NewService</code></li></ul><p id="c727" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">对于指令、管道、防护等等…</p><p id="81d6" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">如果你只是想看看运行生成器后会生成哪些文件，在末尾添加<em class="ld"> -预演</em>参数。如果您的服务、组件或页面不打算/打算"<em class="ld"> live </em>"在一个单独的文件夹中，请使用- flat true或<em class="ld"> - flat false </em>参数。</p><p id="2f41" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">相信我，你不会后悔学习使用CLI。</p><figure class="mu mv mw mx gu nj gi gj paragraph-image"><div class="gi gj oj"><img src="../Images/f23c6f708fce376dd13c571a10e6f01d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*fSrXGgxwqGMaYoImAwoSQw.png"/></div></figure><p id="1cdf" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">建议在运行任何CLI命令时，尝试使用<em class="ld"> -模拟运行参数</em>。是阻止自己把事情搞砸的好方法。有关更多信息，请参考:</p><ul class=""><li id="1a10" class="nq nr ir ki b kj kk km kn kp ns kt nt kx nu lb nv nw nx ny bi translated"><a class="ae lc" href="https://angular.io/cli" rel="noopener ugc nofollow" target="_blank">https://angular.io/cli</a></li><li id="f804" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated"><a class="ae lc" href="https://nx.dev/latest/angular/getting-started/nx-cli" rel="noopener ugc nofollow" target="_blank">https://nx.dev/latest/angular/getting-started/nx-cli</a></li></ul></div><div class="ab cl le lf hv lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ik il im in io"><h1 id="896c" class="mj lm ir bd ln mk ml mm lq mn mo mp lt jx mq jy lw ka mr kb lz kd ms ke mc mt bi translated">可伸缩的代码和关注点的分离</h1><p id="a52e" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">在工作中，我通常会谈到可扩展性。这与使应用程序变得更大，或者能够处理巨大的工作负载有关，只是与此有关。可伸缩应用程序可以理解为可以毫无问题地响应许多请求的应用程序，并且可以伸缩，这意味着它可以被复制以提高可靠性和性能。这也意味着你可以让你的应用程序在代码中增长，增加新的特性，而不损害已经存在的代码。(这个定义我可能错得很离谱)。</p><p id="18ad" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">理论上，所有好的代码都应该是可伸缩的(理论上……理论上，一切看起来都很美好)。</p><h1 id="1302" class="mj lm ir bd ln mk oe mm lq mn of mp lt jx og jy lw ka oh kb lz kd oi ke mc mt bi translated">“好代码”是什么样的？</h1><p id="5032" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">输入SoC或关注点分离。但是在此之前，让我告诉你一些不好的代码，类似于我在迁移过程中的一些可悲的发现。我主要是在一些后端项目中发现这种代码犯罪。</p><p id="df82" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">假设我们有一个REST API，以及一些检索完整用户列表的路径。使用公司中使用的相同技术堆栈(Express、Sequelize和其他东西)，代码应该类似于:</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="8e81" class="ll lm ir mz b gz nd ne l nf ng">import express from 'express';<br/>import { userController } from 'user.controller';</span><span id="bae5" class="ll lm ir mz b gz nh ne l nf ng">const router = express.Router();</span><span id="66bc" class="ll lm ir mz b gz nh ne l nf ng">router.get('/users', userController.retrieveUserList);</span></pre><p id="c221" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">注意，我跳过了所有的认证中间件，或者任何其他的路由、函数等等(同样，为了我们的例子简单起见)。</p><p id="f7bf" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">user.controller文件可能类似于:</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="6548" class="ll lm ir mz b gz nd ne l nf ng">import { Request, response } from 'express';<br/>import { user } from '@mine/db-models';</span><span id="19d7" class="ll lm ir mz b gz nh ne l nf ng">export function retrieveUserList(req: Request, res, Response) {<br/>  // ... lots of logic here<br/>  // ... some extra validations<br/>  // ... retrieve the userList from the database using Sequelize<br/>  user.findAll().then(<br/>    userList =&gt; res.status(200).json(userList),<br/>    err =&gt; {<br/>      console.error('ERROR Retrieving user list: ', err);<br/>      res.status(500).json({<br/>        status: 500,<br/>        errDetail: err<br/>      });<br/>    }<br/>  );<br/>}</span></pre><p id="f01e" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">乍一看，一切正常。但是:</p><ul class=""><li id="c8c6" class="nq nr ir ki b kj kk km kn kp ns kt nt kx nu lb nv nw nx ny bi translated">如果我告诉你，你需要改变很多额外的逻辑呢？</li><li id="5aae" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated">如果我告诉您额外的验证需要连接到其他地方呢？</li><li id="6fb0" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated">如果我告诉你我们不再使用Sequelize会怎么样？</li></ul><p id="0106" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">所有的<em class="ld">“假设”</em>列表都需要编辑代码，做一些调整，让事情在新的需求下工作。问题是不需要修改一些代码(事实上，我们应该为此得到报酬)，问题是如果<code class="fe nm nn no mz b">retrieveUserList</code>函数有几百行代码，这个控制器很快就会变得完全不可维护。让我们这么说吧，一个100+行的控制器函数很可能也有<em class="ld">零</em>文档或注释或任何可以帮助任何开发人员打理这个意大利面沙拉的东西。</p><p id="1fcc" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">所以让我们再想想我们到底应该做什么:</p><ol class=""><li id="6438" class="nq nr ir ki b kj kk km kn kp ns kt nt kx nu lb ok nw nx ny bi translated">获取请求</li><li id="a5fd" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb ok nw nx ny bi translated">应用额外的逻辑</li><li id="98a2" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb ok nw nx ny bi translated">进行验证</li><li id="c5d2" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb ok nw nx ny bi translated">检索用户列表(从数据库)</li><li id="6739" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb ok nw nx ny bi translated">返回用户列表(响应)</li></ol><p id="2223" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">正如您所看到的，所有这些操作都可以清楚地识别出来，即使它们之间有一些联系，它们也可以独立实现。这种方法有几个优点:</p><ul class=""><li id="daca" class="nq nr ir ki b kj kk km kn kp ns kt nt kx nu lb nv nw nx ny bi translated">您可以重用该逻辑。(粗体表示<em class="ld">重要</em></li><li id="a8b5" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated">你不需要修改一个真正无法管理的文件来改变一些代码。</li><li id="3ab7" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb nv nw nx ny bi translated">每个文件都有一个单一的责任(理想的情况)</li></ul><p id="95a2" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">因此，一个良好编码的控制器将知道它必须解决一些事情，但是…它不应该知道如何解决它们。</p><figure class="mu mv mw mx gu nj gi gj paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gi gj ol"><img src="../Images/6ac78bbcbb15f29ba8e3622f1cb63844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnp3o0imr8q4lEH7Icucag.png"/></div></div><figcaption class="oq or gk gi gj os ot bd b be z dk translated"><a class="ae lc" href="https://imgur.com/gallery/TFY1R" rel="noopener ugc nofollow" target="_blank"> Imgur/funkblast1 </a></figcaption></figure><p id="e443" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这背后的主要思想是你所有的代码应该像乐高积木一样工作。如果你需要更换一块砖(比方说一个服务做了"<em class="ld">某事</em>")，你只需要它匹配形状和大小。</p><p id="59be" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">所以，重写我们的例子:</p><p id="09d4" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">路由文件保持不变，没有任何问题。但是控制器文件:</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="ea8f" class="ll lm ir mz b gz nd ne l nf ng">import { Request, response } from 'express';<br/>import { user } from '@mine/db-models';<br/>import { UserDataService } from './user.service';<br/>import { UserValidationService, RequestHeaders } from './user-validation.service';<br/>import { CompanyUserQueryService } from './company-user-query.service';<br/>import { ErrorResponse } from '@mine/backend-utils';</span><span id="c830" class="ll lm ir mz b gz nh ne l nf ng">export function retrieveUserList(req: Request, res, Response) {</span><span id="394b" class="ll lm ir mz b gz nh ne l nf ng">  // CompanyUserQueryService logic here<br/>  const company = req.query.company || 'all';<br/>  let preparedQuery: string;<br/>  if (req.query.company) {		<br/>    preparedQuery = CompanyUserQueryService.prepareQuery(company);<br/>  }</span><span id="8e02" class="ll lm ir mz b gz nh ne l nf ng">  // User validations<br/>  const requestHeaders: RequestHeaders = UserValidationService.parseHeaders(req);<br/>  const validationStatus: boolean = UserValidationService.validateAuth(requestHeaders.auth);<br/>	<br/>  if (validationStatus) {<br/>    // Retrieve the userList from the database <br/>    UserDataService.retrieveUsers().then(<br/>      userList =&gt; res.status(200).json(userList),<br/>      err =&gt; ErrorResponse.sendError(res, err)<br/>    );<br/>  }<br/>	<br/>}</span></pre><blockquote class="ou ov ow"><p id="52a4" class="kg kh ld ki b kj kk js kl km kn jv ko ox kq kr ks oy ku kv kw oz ky kz la lb ik bi translated">我发挥了一点创造力，为额外的逻辑和验证部分添加了一些函数调用。试着想象一下，如果所有的逻辑都在控制器上实现，代码会有多可怕(如果你的想象力没有我的丰富，有太多的代码行，这是一个提示)…</p></blockquote><p id="2713" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">所以，我们重写了我们的例子，好吧，其实不是，我们只是把它分成几个服务，重构代码，让每个服务处理它们自己的责任(<em class="ld">单一责任原则</em>)。代码变得更短，因为它不包括控制器中的所有内部业务逻辑。</p><p id="56cf" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">为了更好地理解这种代码重构，请试着将这些要点视为编码规则:</p><ol class=""><li id="f9af" class="nq nr ir ki b kj kk km kn kp ns kt nt kx nu lb ok nw nx ny bi translated">一个<em class="ld"> API </em>端点必须解决一个需求</li><li id="843a" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb ok nw nx ny bi translated">需求可以是简单的或复杂的任务</li><li id="1707" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb ok nw nx ny bi translated"><em class="ld"> API </em>端点的控制器必须知道<strong class="ki is">它必须做什么</strong>，但它不必知道如何去做。</li><li id="1271" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb ok nw nx ny bi translated">控制器必须导入/要求/使用尽可能多的服务来解决它必须解决的问题。</li><li id="2da9" class="nq nr ir ki b kj nz km oa kp ob kt oc kx od lb ok nw nx ny bi translated">一个服务知道<strong class="ki is">如何</strong>解决问题(这里是良好的实现)。</li></ol><p id="831f" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我对这些特定需求进行编码的方式遵循特定的编码模式(伪代码)，其中我对应该执行的步骤或代码块的顺序进行编号:</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="f92a" class="ll lm ir mz b gz nd ne l nf ng">function requirement (parameters): return something {<br/>  // 1. capture and parse any parameters (can use functions <br/>  //    in the same controller)<br/>  // 2. validate parameters (can use functions in the same<br/>  //    controller)<br/>    // ... now a same item that can change depending on <br/>    //     the requirement<br/>    //   3. apply extra internal logic <br/>    //   3. apply validations logic <br/>    //   3. retrieve information from some source<br/>  // 4. return something<br/>}</span></pre><p id="0cc8" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">如果这些步骤中的任何一个可以用其他东西来代替，那么这就是一个很好的指示，它应该作为服务来实现。否则控制器中的内部功能就足够了。只是不要忘记，即使你知道你的一些应用程序内部不会随着时间的推移而改变，如果你认为它会改变，那么最好将它分离在不同的服务上。在理想的情况下，所有的服务都应该是可替换的，就像一个乐高积木。</p><p id="408c" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">当使用Typescript时，我实现的大多数服务都试图实现一个接口，该接口定义了所有服务变量、函数签名(意味着它们的参数(和它们的类型)以及每个函数的响应类型。例如，<code class="fe nm nn no mz b">function retrieveUserList()</code>是否连接到<em class="ld"> PostgreSQL </em>或<em class="ld"> MongoDB </em>或文件存储并不重要，内部实现是否需要不同的库来连接到数据存储库也不重要。真正重要的是，在每个服务实现上，<code class="fe nm nn no mz b">retrieveUserList</code>接收<em class="ld">零个</em>参数并返回一个<code class="fe nm nn no mz b">Promise&lt;Array&lt;User&gt;&gt;</code>。</p><p id="eae3" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">起初这似乎有点难以处理，但是当您的经理决定从PostgreSQL迁移到MongoDB，并且您发现您必须重写整个控制器时，您最终会明白，处理许多解决其自身责任的小文件要比处理一个内部实现了所有内容的大文件好得多。</p></div><div class="ab cl le lf hv lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ik il im in io"><p id="fad9" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">…最后</p><h1 id="3678" class="mj lm ir bd ln mk oe mm lq mn of mp lt jx og jy lw ka oh kb lz kd oi ke mc mt bi translated">测试和文档</h1><p id="277e" class="pw-post-body-paragraph kg kh ir ki b kj me js kl km mf jv ko kp mg kr ks kt mh kv kw kx mi kz la lb ik bi translated">根据我的经验，测试和文档都不是开发人员最喜欢的。但是它们确实很有帮助。</p><p id="342b" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">许多正式的QA专家和测试人员会讨厌这一点，但是测试并不一定是带有断言的规范。它只需要涵盖边缘情况，并表明它做了它应该做的任何事情，并且当然做得很好。即使你已经阅读了我的前一段，最好还是使用测试框架来做你的测试。如今(IMHO) <a class="ae lc" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>是统治这个领域的测试框架，所以看看它，试一试吧。</p><p id="fcfb" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">和文档。我有Java背景，JavaDocs是我非常喜欢的一个东西。只需添加<code class="fe nm nn no mz b">/**</code>并按下<code class="fe nm nn no mz b">Enter</code>键，文档框架就添加到了您的类方法中。VS代码，作为我目前的基础IDE，有JavaDoc之类的东西，也有不少<a class="ae lc" href="https://jsdoc.app/" rel="noopener ugc nofollow" target="_blank"> JsDoc </a>插件。</p><p id="d344" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我在很多地方读到过<em class="ld">“好的代码会自己说话，不需要文档。”我只会相信，如果所有的开发人员都使用同一把剪刀。没有人和其他人是一样的，所以你学习和理解的速度可能和其他队友大不相同。代码是最好的例子。举个例子:</em></p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="e3a1" class="ll lm ir mz b gz nd ne l nf ng">gb(xs: any, f: any) {<br/>  return xs.reduce((r: any, v: any, i: any, a: any, k: any = f(v)) <br/>    =&gt; ((r[k] || (r[k] = [])).push(v), r), {});<br/>}</span></pre><p id="d4b1" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">几乎完全无法理解。而且要好得多(同样的代码，只做了一些细微的调整):</p><pre class="mu mv mw mx gu my mz na nb aw nc bi"><span id="f2e3" class="ll lm ir mz b gz nd ne l nf ng">/**<br/> * GroupBy function<br/> * From: You Dont Need Lodash Underscore<br/> * Ref. https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_groupby<br/> * @param xs original array of JSON objects meant to be grouped<br/> * @param f grouping field name<br/> * @returns new JSON object with the grouped data <br/> */<br/> groupBy(xs: any, f: any) {<br/>   return xs.reduce((r: any, v: any, i: any, a: any, k: any = f(v)) <br/>     =&gt; ((r[k] || (r[k] = [])).push(v), r), {});<br/> }</span></pre><p id="84b4" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这里仍然有些不可思议，但至少它解释了这个函数的作用。作为一个很好的练习，你可以改进这个函数的类型:)</p><p id="b8e4" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">不要忘记，你(通常)不是为自己编码，而是为你的队友，甚至是你未来的自己编码。在我的特殊情况下，当我在几个星期后回到我自己的代码时，我真的很感激我放置了任何有用的注释，当我面对我自己的未记录的神秘代码时，我真的很讨厌自己。所以寓意是:<em class="ld">写有用的评论</em>。</p><p id="5224" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">还记得<code class="fe nm nn no mz b">function requirement</code>伪码上的编号项目吗？我通常会留下这些，因为，知道我的编码风格，有很大的机会面对一段巫师咒语代码行，它完成了大部分的魔法。</p></div><div class="ab cl le lf hv lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ik il im in io"><p id="bba0" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这就是了，如果你能坚持到这一步而没有睡着，感谢你的阅读。一如既往，欢迎评论、问题和掌声(如果你喜欢的话:)。</p><p id="10d6" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">注意安全。</p></div></div>    
</body>
</html>