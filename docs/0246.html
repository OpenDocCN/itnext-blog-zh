<html>
<head>
<title>Using Angular’s Router to manage state</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular的路由器管理状态</h1>
<blockquote>原文：<a href="https://itnext.io/using-angulars-router-to-manage-state-14b1142a2ffb?source=collection_archive---------1-----------------------#2018-01-24">https://itnext.io/using-angulars-router-to-manage-state-14b1142a2ffb?source=collection_archive---------1-----------------------#2018-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c6b883c75c02a1abb7190c830069d85c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nX9K-hqQ0U1JiByqYJsT6g.png"/></div></div></figure><p id="ac25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fusing-angulars-router-to-manage-state-14b1142a2ffb" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="31d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">啊，url，一个在现代应用中经常被忽略的保存状态的地方，但是它是如此强大。你有没有去过一个网站，搜索，设置你所有的过滤器，刷新，然后一切都消失了？这是为什么设计良好的路由器/url状态很重要的主要例子。虽然这篇文章是专门关于Angular的，但是在URL中存储状态的主要思想适用于所有的框架/应用程序。</p><p id="a7a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看一个搜索页面的URL示例。对我们的url的要求是，它需要说明需要导航到哪个页面，保存用户搜索的值，并保存几个搜索过滤器。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7564" class="lh li iq ld b gy lj lk l ll lm">/products?search=playstation?department=electronics&amp;priceLimit=100</span></pre><p id="4e1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的url告诉我们的应用程序关于它的状态的一些事情，所以让我们分解它。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8523" class="lh li iq ld b gy lj lk l ll lm">products - The page we are viewing</span><span id="f55b" class="lh li iq ld b gy ln lk l ll lm">search=playstation - The search value</span><span id="2928" class="lh li iq ld b gy ln lk l ll lm">department=electronics - the department filter</span><span id="2351" class="lh li iq ld b gy ln lk l ll lm">priceLimit=100 - the price limit filter</span></pre><p id="42f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为Angular的路由器是反应式的，所以使用这些值作为我们搜索页面的来源变得非常简单。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ec65" class="lh li iq ld b gy lj lk l ll lm">import { Component } from '@anguar/core';<br/>import { ActivatedRoute } from '@angular/router';<br/>import { Observable } from 'rxjs/Observable';<br/>import { switchMap } from 'rxjs/operators';</span><span id="aab4" class="lh li iq ld b gy ln lk l ll lm">import { SearchService } from './search.service';</span><span id="cf8e" class="lh li iq ld b gy ln lk l ll lm">export interface SearchParams {<br/>  department: string;<br/>  priceLimit: string;<br/>  search: string;<br/>}</span><span id="6232" class="lh li iq ld b gy ln lk l ll lm">@Component({<br/>  template: `<br/>    {{searchParams | async | json}} </span><span id="93a6" class="lh li iq ld b gy ln lk l ll lm">    {{results | async | json}}<br/>  `<br/>})<br/>class MyComponent {<br/>  searchParams: Observable&lt;SearchParams&gt; = this.route.queryParams</span><span id="0e30" class="lh li iq ld b gy ln lk l ll lm">  results = this.searchParams.pipe(<br/>    switchMap(params =&gt; this.ss.findProducts(params))<br/>  );</span><span id="1dec" class="lh li iq ld b gy ln lk l ll lm">  constructor(<br/>    private ss: SearchService, <br/>    private route: ActivatedRoute<br/>  ) {}</span><span id="3726" class="lh li iq ld b gy ln lk l ll lm">  updateSearch(params: Partial&lt;SearchParams&gt;) {<br/>    this.router.navigate(['.'], {<br/>      queryParameters: params, <br/>      queryParamsHandling: 'merge'<br/>    })<br/>  }<br/>}</span></pre><p id="ef9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们看一下上面的组件定义，我们会注意到3件事。</p><ol class=""><li id="cc44" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv lt lu lv lw bi translated">查询参数是可观察的，这意味着每当查询参数改变时，我们的订户(在本例中是通过“异步”管道的模板)都会得到通知</li><li id="b185" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">我们可以使用RxJs“switch map”操作符来触发新的搜索。</li><li id="d339" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv lt lu lv lw bi translated">要更新我们的观点，我们所要做的就是改变其中的一个参数。(请参见组件中的“updateSearch”方法。可以想象当有人选中一个复选框时它被调用)</li></ol><p id="0c3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">遵循这种模式，不需要手动管理本地状态或使用全局应用程序商店，URL是视图的状态，会告诉我们何时需要改变。</p><p id="79a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你的路线并不是存放所有东西的理想地方，所以让我们来看一些例子，看看它有什么好处，有什么坏处。</p><p id="9528" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好:</p><ul class=""><li id="5aaa" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv mc lu lv lw bi translated">过滤器:想想亚马逊页面或JIRA。</li><li id="9200" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv mc lu lv lw bi translated">任何需要用户容易共享的东西:过滤器也是在多页表中维护正确“页面”的一个好例子</li><li id="ae6d" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv mc lu lv lw bi translated">刷新时需要维护的任何状态:筛选器、页面、当前选项卡</li><li id="67d8" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv mc lu lv lw bi translated">简单值:字符串、数字、布尔值或这些值的数组，如下所示:</li></ul><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c510" class="lh li iq ld b gy lj lk l ll lm">products?list=first?list=second&amp;list=third</span></pre><p id="d4f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不好:</p><ul class=""><li id="848e" class="lo lp iq ka b kb kc kf kg kj lq kn lr kr ls kv mc lu lv lw bi translated">复杂值:url非常适合存储简单的图元或图元数组(图元数组通过添加一个同名的查询参数来表示)，但不适合存储更复杂的结构，如…</li><li id="99ff" class="lo lp iq ka b kb lx kf ly kj lz kn ma kr mb kv mc lu lv lw bi translated">对象:有时你可能想把JSON.stringify作为一个对象，并把它放在一个查询参数中，请不要…请？</li></ul><p id="748d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，把你自己想象成用户，如果你有机会不得不回到正确的标签页或者重新选择过滤器或者搜索参数，你的用户也会有很大的变化。</p><p id="668c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您有任何其他有趣的用例或使用反应式查询或路由参数的实现，请在评论中告诉我！</p></div></div>    
</body>
</html>