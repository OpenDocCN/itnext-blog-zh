<html>
<head>
<title>How to Build an Interactive SPA with Blazor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Blazor建立一个互动SPA</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-an-interactive-spa-with-blazor-a030bae66b68?source=collection_archive---------4-----------------------#2019-12-18">https://itnext.io/how-to-build-an-interactive-spa-with-blazor-a030bae66b68?source=collection_archive---------4-----------------------#2019-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="923b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你是. NET开发者吗？你是不是也有点嫉妒现在JS的人创造的美丽的，有反应的温泉？别再嫉妒了，布拉索会帮你的。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/321c78fc43804ded92629aa5bbfa1a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kjJ0I1fka0-pnmhYfhSKA.jpeg"/></div></div></figure><p id="d57b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我以前做过很多。所以当JavaScript在几年前成为后起之秀的时候，我很难过微软并没有真正解决这个问题。随着时间的推移，我找到了进入Vue.js的方法，但是像npm、webpack、bundling、deploying等东西从一开始就对我来说是一个很大的挑战。今年早些时候，我偶然发现了Blazor——一个允许开发人员编写的框架。使用Mono编译的. NET代码运行在Webassembly上。这意味着它可以在当今所有主流浏览器上运行。此外，使用Blazor，我能够呆在Visual Studio(我的舒适区)中，使用与MVC完全相同的设计模式。那么，它兑现承诺了吗？</p><p id="4fa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将向您展示如何构建一个客户端Blazor应用程序，添加一些功能，使用NuGet包，并与JavaScript进行通信。</p><h1 id="1688" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">是什么项目？</h1><p id="56a2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在我居住的城市布尔诺，我们最近有了住宅停车区，很多司机，主要是外国人，在寻找停车位时感到困惑。每个人都害怕道路上的蓝线。因此，我的目标是建立一个简单的应用程序，可以检查游客站在哪里(使用手机GPS)，并用两句话解释特定地点的规则。可能导航到最近的停车机器。简单、快速、反应灵敏。</p><h1 id="a0c7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">数据模型</h1><p id="dc19" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当你建立一个比你的狗的主页更大的网站时，你需要在某个地方组织和存储数据和内容。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mb"><img src="../Images/565325657f04d6542a384033586ce299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CepGQEMTkAVNfeBU.png"/></div></div></figure><p id="9517" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始时，我需要存储以下数据:</p><ul class=""><li id="027a" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated"><strong class="jp ir">停车区<br/> </strong> - <strong class="jp ir"> </strong>停车区名称<br/> -标记每个停车区的数百个点的坐标(地图中的红色标记)<br/> -限制</li><li id="3fd3" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><strong class="jp ir">访客限制<br/> </strong> - <strong class="jp ir"> </strong>持续时间—应用规则时<br/> -描述—规则是什么</li><li id="b975" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><strong class="jp ir">居民限制<br/> </strong> - <strong class="jp ir"> </strong>持续时间—适用规则时<br/> -邻居—允许居民在附近区域停车</li><li id="0176" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><strong class="jp ir">停车机器</strong></li></ul><p id="755a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我们在看4个模型(区域、访客限制、居民限制和停车机器)。</p><p id="a337" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我倾向于尽可能使用无头CMS，因为它不需要任何安装，在云中运行，通过CDN提供数据，并具有REST API或更好的特性——适用于我使用的平台的SDK。在任何成熟的无头CMS(如Kontent、Contentful或ContentStack)中，构建内容类型和所需的层次结构都不是问题。</p><h1 id="3626" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">从Blazor模板开始</h1><p id="7c5e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">从Blazor开始最简单的方法是让<code class="fe mq mr ms mt b">dotnet </code>为你克隆一个模板。我的目标是Blazor的客户端版本，但是也有用于服务器端(使用SignalR与浏览器通信)以及服务器和客户端组合项目的模板。要安装Blazor模板，请运行以下命令:</p><p id="2916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms mt b">dotnet new -i Microsoft.AspNetCore.Blazor.Templates::3.1.0-preview3.19555.2</code></p><p id="a4f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要克隆模板(客户端)，请使用:</p><p id="0203" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms mt b">dotnet new blazorwasm</code></p><p id="ac8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这为您提供了基本的项目结构:</p><p id="20e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">-页面<br/>-共享<br/>-wwwroot<br/>-CSS<br/></strong>index.html<br/>startup . cs</p><p id="1541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">样板文件已经使用了基本的样式表，使网站看起来很漂亮。如果你需要使用你的样式表(像我一样——我的附加样式表在这里是<a class="ae mu" href="https://github.com/ondrabus/dont-park-here-client/blob/master/wwwroot/css/dph.css" rel="noopener ugc nofollow" target="_blank"/>)，把它们放入css文件夹，并使用<code class="fe mq mr ms mt b">wwwroot/index.html</code>中的<code class="fe mq mr ms mt b">&lt;link&gt;</code>元素引用它们。该文件是Blazor呈现的每个页面的主要包装。请确保不要删除<code class="fe mq mr ms mt b">&lt;app&gt;</code>元素:-)。这就是奇迹发生的地方。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mv"><img src="../Images/dc1aade9e0e7ac8c47436591b2ada9e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GduVDQ5oqxGBD8XB.png"/></div></div></figure><p id="eeb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您运行项目时，应该会看到这个屏幕。如果没有，那么:</p><ul class=""><li id="2113" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">检查您运行的是最新版本的Visual Studio 2019 <em class="kl">预览版</em>，拥有最新版本的。NET Core SDK和最新版本的Blazor模板(看<a class="ae mu" href="https://docs.microsoft.com/en-us/aspnet/core/blazor/get-started?view=aspnetcore-3.0&amp;tabs=visual-studio" rel="noopener ugc nofollow" target="_blank">这里</a>)。</li><li id="0453" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">该问题可能与链接有关(尤其是当您在输出窗口中看到非描述性错误时)。在这种情况下，要么关闭它(看<a class="ae mu" href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/blazor/configure-linker?view=aspnetcore-3.0" rel="noopener ugc nofollow" target="_blank">这里</a>)或者添加一个链接器配置(看<a class="ae mu" href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/blazor/configure-linker?view=aspnetcore-3.0" rel="noopener ugc nofollow" target="_blank">这里</a>或者检查<a class="ae mu" href="https://github.com/petrsvihlik/StartBootstrap.Freelancer.Blazor/blob/master/src/Linker.xml" rel="noopener ugc nofollow" target="_blank">样本配置文件</a>)。</li></ul><h1 id="e79c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用Blazor页面和组件创建地图</h1><p id="0901" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在站点正在运行，让我们添加一个带有地图组件的页面。在<strong class="jp ir">页面</strong>文件夹中添加一个新文件<strong class="jp ir"> Map.razor </strong>。</p><p id="6858" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">页面总是包含一个可以访问它们的路径。</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="66a9" class="na kz iq mt b gy nb nc l nd ne">@page "/map"</span></pre><p id="ac37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文件的其余部分是页面的HTML标记。</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="2d79" class="na kz iq mt b gy nb nc l nd ne">&lt;h1&gt;Map&lt;/h1&gt;<br/>&lt;div&gt;Location: @Longitude, @Latitude&lt;/div&gt;<br/>&lt;Map /&gt;</span></pre><p id="c2d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你看，我已经在使用razor语法和呈现属性值了。属性和方法既可以使用<code class="fe mq mr ms mt b">@code{ //implementation }</code>块直接在标记中定义(这是MS的建议),也可以分离到“代码隐藏”文件中。我更喜欢后者，因为它使代码更具可读性(尤其是如果您计划两个以上的属性和一个方法)。但是，请记住，如果有任何冲突，内联代码优先于单独的文件。</p><p id="7c75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加一个新文件<strong class="jp ir"> Map.razor.cs </strong>。Visual Studio会将该文件以相同的名称放在页面下面。新类需要从ComponentBase继承，并定义页面上所有使用的属性。对我来说，那就是经度和纬度。</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="f6bb" class="na kz iq mt b gy nb nc l nd ne">public class MapBase : ComponentBase<br/>{<br/>    public decimal Latitude { get; set; }<br/>    public decimal Longitude { get; set; }<br/>}</span></pre><p id="8e72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后你需要告诉页面后面有一个代码:</p><p id="025a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms mt b">@inherits MapBase</code></p><h1 id="cf6f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">添加地图组件</h1><p id="3af2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">下一部分是地图组件。在项目的根目录下创建一个文件夹<strong class="jp ir">组件</strong>和一个新文件<strong class="jp ir"> Map.razor </strong>。在我的例子中，这个文件只包含HTML标记。</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="556c" class="na kz iq mt b gy nb nc l nd ne">&lt;div class="mapContainer"&gt;<br/>  &lt;div id="m"&gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><h1 id="a637" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">向网站添加地图JavaScripts</h1><p id="1c42" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">地图还需要一个JavaScript来初始化它。该脚本可以在线获得，所以我可以直接引用它，或者将其复制到<strong class="jp ir"> wwwroot/js </strong>文件夹并引用一个本地副本。我选择了第一个选项，因此我需要将下面几行添加到<strong class="jp ir"> wwwroot/index.html </strong>中:</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="c68e" class="na kz iq mt b gy nb nc l nd ne">&lt;script type="text/javascript" src="https://api.mapy.cz/loader.js"&gt;&lt;/script&gt;<br/>&lt;script type="text/javascript"&gt;Loader.load();&lt;/script&gt;</span></pre><p id="d01a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不能直接添加脚本到组件中，因为Blazor不允许。</p><p id="603c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我需要配置和初始化地图。这是一个简单的JS代码，定义了地图的初始中心在哪里，以及地图应该有多详细。放置该文件的最佳位置是在<strong class="jp ir"> wwwroot/js </strong>文件夹中，并从<strong class="jp ir"> wwwroot/index.html </strong>中引用它，就像其他脚本一样。</p><p id="63e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms mt b">&lt;script type="text/javascript" src="./js/map.js"&gt;&lt;/script&gt;</code></p><p id="83e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此找到完整的文件内容<a class="ae mu" href="https://github.com/ondrabus/dont-park-here-client/blob/master/wwwroot/js/map.js" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="6bae" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">从Blazor调用JavaScript</h1><p id="be4b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">初始化的函数需要在组件渲染的时候被Blazor调用。这里的问题是Blazor在组件的生命周期中多次呈现组件。原因是当访问者与我的站点交互并更改一些数据集时，组件需要对这些更改做出反应。他们需要重新渲染。但是对于地图，我只需要执行一次初始化脚本。<code class="fe mq mr ms mt b">OnAfterRenderAsync</code>功能覆盖中的布尔参数<code class="fe mq mr ms mt b">firstRender</code>将使您能够做到这一点。</p><p id="3fd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Blazor和JavaScript之间的通信可以通过JSRuntime实现。这是一个简单的服务，可以直接注入到任何组件中。</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="b1c7" class="na kz iq mt b gy nb nc l nd ne">[Inject]<br/>protected IJSRuntime JSRuntime { get; set; }<!-- --> </span></pre><p id="5a2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且，要执行一个JavaScript函数，您需要指定它的名称并为它的参数提供数据(如果它有参数的话)。如果函数返回数据，JSRuntime可以将它绑定到各自的。NET数据类型。在我的例子中，<code class="fe mq mr ms mt b">mapInit</code>不返回任何东西，所以我使用object。</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="f9b2" class="na kz iq mt b gy nb nc l nd ne">protected override async Task OnAfterRenderAsync(bool firstRender)<br/>{<br/>    if (firstRender)<br/>    {<br/>        await JSRuntime.InvokeAsync&lt;object&gt;("mapInit");<br/>    }<br/>}</span></pre><h1 id="1ce7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用NuGet包识别GPS位置</h1><p id="d561" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">地图初始化功能包含用于地图居中的固定坐标。那不理想。网站访问者必须知道他们站在哪里(或使用另一个应用程序来找出)，并在地图上点击该点。我能做的是向他们的浏览器要GPS坐标。我可以自己实现它，但是当我们可以使用NuGet时，为什么要重新发明轮子呢？</p><p id="edac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我找到了一个<a class="ae mu" href="https://github.com/AspNetMonsters/Blazor.Geolocation" rel="noopener ugc nofollow" target="_blank">包</a> <code class="fe mq mr ms mt b">AspNetMonsters.Blazor.Geolocation</code>，它实现了一个<code class="fe mq mr ms mt b">LocationService</code>。这个服务可以被注入到页面和组件中，它自动处理初始的地理位置查询。但是首先，您需要在<code class="fe mq mr ms mt b">Startup.cs</code>中注册服务:</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="7a88" class="na kz iq mt b gy nb nc l nd ne">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddSingleton&lt;LocationService&gt;();<br/>}</span></pre><p id="e7c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将服务注册为singleton，这样Blazor将为所有请求提供相同的实例。但是，您也可以使用:</p><ul class=""><li id="9e49" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated"><strong class="jp ir"> AddTransient </strong> —每次都创建新实例</li><li id="ad71" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><strong class="jp ir"> AddScoped </strong> —实例的作用域为当前请求</li></ul><p id="3e54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一个JavaScript文件需要包含在主体中。在此找到<a class="ae mu" href="https://github.com/AspNetMonsters/Blazor.Geolocation/blob/master/AspNetMonsters.Blazor.Geolocation/wwwroot/Location.js" rel="noopener ugc nofollow" target="_blank">并添加到<strong class="jp ir">/wwwroot/js/location . js</strong>。像以前一样引用它:</a></p><p id="0a3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms mt b">&lt;script type="text/javascript" src="./js/Location.js"&gt;&lt;/script&gt;</code></p><p id="7d5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是服务被注入到<strong class="jp ir">地图</strong>页面的方式:</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="29de" class="na kz iq mt b gy nb nc l nd ne">[Inject]<br/>protected LocationService LocationService { get; set; }<br/><br/>protected override async Task OnAfterRenderAsync(bool firstRender)<br/>{<br/>   if (firstRender)<br/>   {<br/>       await JSRuntime.InvokeAsync&lt;object&gt;("mapInit");<br/><br/>       var currentLocation = await LocationService.GetLocationAsync();<br/>       await JSRuntime.InvokeAsync&lt;object&gt;("mapCenter", currentLocation.Latitude, currentLocation.Longitude);<br/>   }<br/>}</span></pre><h1 id="91d7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">从JavaScript调用Blazor并添加服务</h1><p id="656a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">但是在我将它添加到地图页面之前，让我们看一下列表中的最后一项——从JavaScript调用Blazor代码。这涵盖了当访问者点击地图上的一个点时的用例。之后，地图应该以该点为中心(由JavaScript处理)，并使用新坐标调用Blazor。Blazor将对照所有停车区检查新位置，并在必要时重新渲染相应组件(允许/禁止停车)。</p><p id="47c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms mt b">DotNet.invokeMethodAsync('DontParkHere', 'SetLocation', coords.y.toString(10), coords.x.toString(10));</code></p><p id="a713" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码将使用两个参数调用<code class="fe mq mr ms mt b">DontParkHere</code>名称空间中的方法<code class="fe mq mr ms mt b">SetLocation</code>——两个GPS坐标。注意，方法需要是<strong class="jp ir">公共</strong>、<strong class="jp ir">静态</strong>，并用<code class="fe mq mr ms mt b">[JSInvokable]</code>属性修饰。</p><p id="31b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果方法是静态的，我们如何将新的坐标放入地图组件，执行检查，并更新前端呢？</p><p id="0a97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们首先在<strong class="jp ir"> Services/MapService.cs </strong>中创建一个服务。该服务将为地图页面中的一个方法保存一个动作委托，每当新的坐标到达时，我们都希望调用该方法。</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="b3ba" class="na kz iq mt b gy nb nc l nd ne">public class MapService<br/>{<br/>    static Action&lt;Location&gt; _callback;<br/><br/>    public void WatchLocation(Action&lt;Location&gt; watchCallback)<br/>    {<br/>        _callback = watchCallback;<br/>    }<br/>}</span></pre><p id="bf90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms mt b">Location</code>类型来自之前添加的NuGet包。</p><p id="b68c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们需要添加可从JavaScript调用的静态方法。</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="fa5c" class="na kz iq mt b gy nb nc l nd ne">[JSInvokable]<br/>public static void SetLocation(string latitude, string longitude)<br/>{<br/>    var location = new Location<br/>    {<br/>        Latitude = Convert.ToDecimal(latitude),<br/>        Longitude = Convert.ToDecimal(longitude),<br/>        Accuracy = 1<br/>    };<br/><br/>    _callback.Invoke(location);<br/>}</span></pre><p id="1880" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并在Startup.cs中注册服务，就像我们之前对定位服务所做的那样:</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="2985" class="na kz iq mt b gy nb nc l nd ne">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddSingleton&lt;LocationService&gt;();<br/>    services.AddSingleton&lt;MapService&gt;();<br/>}</span></pre><p id="0c79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我可以更新地图页面。我确保注入新服务:</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="b1f9" class="na kz iq mt b gy nb nc l nd ne">[Inject]<br/>protected MapService MapService { get; set; }</span></pre><p id="9c4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并添加一个方法，该方法将在每次新坐标到达时处理检查:</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="010c" class="na kz iq mt b gy nb nc l nd ne">protected void SetLocation(Location location)<br/>{<br/>    Console.WriteLine($"Check this position: {location.Latitude} {location.Longitude}");<br/>    Latitude = location.Latitude;<br/>    Longitude = location.Longitude;<br/>    StateHasChanged();<br/>}</span></pre><p id="b182" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你看，我需要调用<code class="fe mq mr ms mt b">StateHasChanged</code>来让页面知道它需要重新呈现，因为我改变了底层数据集。在渲染过程中，我将地图服务的委托分配给这个函数:</p><pre class="kn ko kp kq gt mw mt mx my aw mz bi"><span id="7436" class="na kz iq mt b gy nb nc l nd ne">protected override async Task OnAfterRenderAsync(bool firstRender)<br/>{<br/>   if (firstRender)<br/>   {<br/>       MapService.WatchLocation(this.SetLocation);<br/><br/>       await JSRuntime.InvokeAsync&lt;object&gt;("mapInit");<br/><br/>       var currentLocation = await LocationService.GetLocationAsync();<br/>       await JSRuntime.InvokeAsync&lt;object&gt;("mapCenter", currentLocation.Latitude, currentLocation.Longitude);<br/>   }<br/>}</span></pre><p id="8385" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过这些更改后，当您运行项目并访问URL <strong class="jp ir"> /map </strong>时，您的浏览器应首先要求您共享您的位置(此请求可能会被自动拒绝，因为默认情况下本地IIS Express不使用SSL)。同时，您应该看到地图渲染，每次单击地图，页面都会显示更新的坐标。</p><h1 id="a6dc" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="6aa9" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在布拉佐上建立一个功能性温泉浴场并没有花很长时间。我花了一段时间来更新我的工作空间，花了一两天时间来理解Blazor是如何工作的。那么所花的时间比得上其他任何一个。NET项目。</p><p id="92d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人喜欢这样一个事实，即我可以在任何地方使用C#，并坚持我从过去了解的模式。即使您需要使用JS组件或者将Blazor与JS框架相结合，也可以通过JS互操作来实现。我现在看到的缺点是第一次加载时的低性能和复杂的调试。总的来说，我很有兴趣看到Blazor随着时间的推移变得成熟，我希望它能打破JS框架的统治。</p><p id="77ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看GitHub上的<a class="ae mu" href="https://github.com/ondrabus/dont-park-here-client/tree/c68e76e5d7a25af59357e247a086ac69e5e5a5cf" rel="noopener ugc nofollow" target="_blank">整体实现</a>。</p><p id="da0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">系列其他文章:</strong></p><ul class=""><li id="50d7" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated"><a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/what-is-this-blazor-everyones-talking-about-34529a3e1419"> #1大家都在说的这个Blazor是什么？</a></li><li id="2c5c" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">#2如何用Blazor构建一个交互式SPA(本文)</li><li id="834d" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/avoiding-parking-fines-with-blazor-and-geolocation-d45a9a831d93"> #3利用Blazor和地理定位避免停车罚款</a></li></ul></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="3585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于2019年12月18日</em><a class="ae mu" href="https://dev.to/ondrabus_94/how-to-build-an-interactive-spa-with-blazor-4k8n" rel="noopener ugc nofollow" target="_blank"><em class="kl">https://dev . to</em></a><em class="kl">。</em></p></div></div>    
</body>
</html>