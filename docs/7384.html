<html>
<head>
<title>The secret of successfully using multi window WebGL Canvas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成功使用多窗口WebGL画布的秘诀</h1>
<blockquote>原文：<a href="https://itnext.io/the-secret-of-successfully-using-multi-window-webgl-canvas-5a2d05555ad1?source=collection_archive---------0-----------------------#2022-09-07">https://itnext.io/the-secret-of-successfully-using-multi-window-webgl-canvas-5a2d05555ad1?source=collection_archive---------0-----------------------#2022-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="35a4" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">将屏幕外画布与共享工作人员相结合</h2><div class=""/><div class=""><h2 id="26e6" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用WebGL内容渲染画布节点，并将其移动到不同的窗口中，而无需像D3那样重新加载依赖项，保持当前状态，并且无需创建新的组件JS实例。</h2></div><h1 id="18a9" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">内容</h1><ol class=""><li id="4940" class="lg lh iq li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">介绍视频</li><li id="9364" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">定义:屏幕外画布和共享工作器</li><li id="0a5e" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">优势和潜在使用案例</li><li id="22d5" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">演示的内容</li><li id="ef59" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">密码</li><li id="edb7" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">共享工作人员的功能请求</li><li id="849d" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">在线演示</li><li id="cb50" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">neo.mjs项目</li></ol><h1 id="be23" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">1.介绍视频</h1><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="4934" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">2.定义:屏幕外画布和共享工作器</h1><blockquote class="mk ml mm"><p id="c463" class="mn mo mp li b lj mq ka mr ll ms kd mt mu mv mw mx my mz na nb nc nd ne nf lt ij bi translated"><code class="fe ng nh ni nj b">OffscreenCanvas</code>接口提供了一个可以在屏幕外呈现的画布，将DOM和画布API解耦，这样<code class="fe ng nh ni nj b"><a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas" rel="noopener ugc nofollow" target="_blank">&lt;canvas&gt;</a></code>元素不再完全依赖于DOM。渲染操作也可以在一个<a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" rel="noopener ugc nofollow" target="_blank"> worker </a>上下文中运行，允许你在一个单独的线程中运行一些任务，避免主线程上的繁重工作。</p></blockquote><div class="nl nm gp gr nn no"><a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ja gy z fp nt fr fs nu fu fw iz bi translated">屏幕外画布-Web API | MDN</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">当使用元素或画布API时，渲染、动画和用户交互通常发生在主…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">developer.mozilla.org</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc od no"/></div></div></a></div><blockquote class="mk ml mm"><p id="ed0f" class="mn mo mp li b lj mq ka mr ll ms kd mt mu mv mw mx my mz na nb nc nd ne nf lt ij bi translated"><code class="fe ng nh ni nj b">SharedWorker</code>接口表示一种特定的worker，可以从几个浏览上下文中<em class="iq">访问</em>，比如几个窗口、iframes甚至worker。他们实现了一个不同于专用工人的接口，并且具有不同的全局范围<code class="fe ng nh ni nj b"><a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorkerGlobalScope" rel="noopener ugc nofollow" target="_blank">SharedWorkerGlobalScope</a></code>。</p></blockquote><div class="nl nm gp gr nn no"><a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ja gy z fp nt fr fs nu fu fw iz bi translated">shared worker-Web API | MDN</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">SharedWorker接口表示一种特定的工作器，可以从几个浏览上下文中访问它…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">developer.mozilla.org</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc od no"/></div></div></a></div><h1 id="138e" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">3.优势和潜在使用案例</h1><p id="e36d" class="pw-post-body-paragraph mn mo iq li b lj lk ka mr ll lm kd mt ln of mw mx lp og na nb lr oh ne nf lt ij bi translated"><code class="fe ng nh ni nj b">OffscreenCanvas</code>的整个概念都围绕着将画布节点的所有权转移到一个工人身上。这对于确保昂贵的计算可以在独立的CPU内核中进行非常有意义，CPU内核可以并行计算它们，而不会对我们的渲染线程产生负面影响。</p><p id="ec43" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">显然，我们想到的第一件事是将每个画布节点移动到它自己的<a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">专用工作器</a>中，只要还有空闲的CPU内核可用，以最大化性能增益。</p><p id="a033" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated"><em class="mp">那么，我们为什么还要考虑使用一个</em> <code class="fe ng nh ni nj b"><em class="mp">SharedWorker</em></code> <em class="mp">来代替，它允许我们连接到多个浏览器窗口呢？</em></p><h2 id="681c" class="oi kp iq bd kq oj ok dn ku ol om dp ky ln on oo la lp op oq lc lr or os le iw bi translated">好处:</h2><ol class=""><li id="df8c" class="lg lh iq li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如果你想使用更大的库，比如<a class="ae nk" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> D3 </a>，你只需要将它们<strong class="li ja">加载到你的共享作用域</strong>中。甚至不需要缓存重载。</li><li id="97ec" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">如果您有一个昂贵的和/或时间敏感的逻辑来操作画布的状态，您可以将它应用于多个窗口中的多个画布节点。</li></ol><h2 id="f1e9" class="oi kp iq bd kq oj ok dn ku ol om dp ky ln on oo la lp op oq lc lr or os le iw bi translated">使用案例:</h2><ol class=""><li id="5fa0" class="lg lh iq li b lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">考虑创建一个多屏幕游戏，其中你想在每个屏幕上显示一个别致的动画时钟，并想确保它们绝对同步。</li><li id="76f8" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">我最近与一家大公司讨论了一个工程工作场所，每个工程师在多个屏幕上工作。有点像复杂的基于web的IDE。他们正在使用笨重的3d模型，如果需要的话，他们希望能够在不同的屏幕上实时移动这些模型。</li></ol><h1 id="4030" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">4.演示的内容</h1><p id="bc7a" class="pw-post-body-paragraph mn mo iq li b lj lk ka mr ll lm kd mt ln of mw mx lp og na nb lr oh ne nf lt ij bi translated">创建一个体面的工人-设置我们自己可以花大量的时间。幸运的是<a class="ae nk" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>为我们提供了我们所需要的:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ou ov di ow bf ox"><div class="gh gi ot"><img src="../Images/7e0c5499adc9f506faace928f1e6a813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7Iv-yHVQKSECOtY0WJfDA.png"/></div></div></figure><p id="21cc" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">我已经在一个专门的工人内部创建了演示。请随意浏览此处的内容:</p><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/rendering-3d-offscreen-getting-max-performance-using-canvas-workers-88c207cbcdc2"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ja gy z fp nt fr fs nu fu fw iz bi translated">在屏幕外渲染3d:使用canvas workers获得最佳性能</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">OffscreenCanvas Web API使我们能够将画布DOM元素的所有权转移到workers中。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">itnext.io</p></div></div><div class="nx l"><div class="oz l nz oa ob nx oc od no"/></div></div></a></div><p id="a166" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">因为这一部分已经被讨论过了，所以我们可以把重点放在本文中的多窗口方面:)</p><h1 id="7640" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">5.密码</h1><p id="70f3" class="pw-post-body-paragraph mn mo iq li b lj lk ka mr ll lm kd mt ln of mw mx lp og na nb lr oh ne nf lt ij bi translated">您可以在这里找到包含完整工作演示(MIT许可)的存储库:</p><div class="nl nm gp gr nn no"><a href="https://github.com/neomjs/shared-offscreen" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ja gy z fp nt fr fs nu fu fw iz bi translated">GitHub - neomjs/shared-offscreen:将现有画布节点移动到新浏览器中的测试用例…</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">使用WebGL内容呈现画布节点，并将其移动到不同的窗口中，而无需重新加载依赖项，如…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="pa l nz oa ob nx oc od no"/></div></div></a></div><h2 id="3ec9" class="oi kp iq bd kq oj ok dn ku ol om dp ky ln on oo la lp op oq lc lr or os le iw bi translated">与之前演示的不同之处:</h2><p id="4278" class="pw-post-body-paragraph mn mo iq li b lj lk ka mr ll lm kd mt ln of mw mx lp og na nb lr oh ne nf lt ij bi translated">在我们的主应用程序中，我们需要切换到使用<code class="fe ng nh ni nj b">SharedWorkers</code><a class="ae nk" href="https://github.com/neomjs/shared-offscreen/blob/main/apps/mainapp/neo-config.json" rel="noopener ugc nofollow" target="_blank">apps/main app/neo-config . JSON</a></p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="pb mj l"/></div></figure><p id="d4b0" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">为了将画布节点移动到不同的浏览器窗口中，我们需要第二个应用程序:<a class="ae nk" href="https://github.com/neomjs/shared-offscreen/tree/main/apps/childapp" rel="noopener ugc nofollow" target="_blank"> apps/childapp </a></p><p id="3f79" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">这个几乎只包含一个空的视窗:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="pb mj l"/></div></figure><p id="65c4" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">在我们的演示中，右下角有<code class="fe ng nh ni nj b">Move Canvas</code>按钮:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ou ov di ow bf ox"><div class="gh gi pc"><img src="../Images/85ef7da617ac59b1604ec1e0f9d33084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAolF7VRBpPhKLhtPwbqFg.png"/></div></div></figure><p id="fd77" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">那么，让我们来看看这个→ <code class="fe ng nh ni nj b">moveCanvas()</code>是做什么的:<br/><a class="ae nk" href="https://github.com/neomjs/shared-offscreen/blob/main/apps/mainapp/view/MainContainerController.mjs" rel="noopener ugc nofollow" target="_blank">apps/main app/view/maincontainercontroller . mjs</a>(完整代码)</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="pb mj l"/></div></figure><ol class=""><li id="31a0" class="lg lh iq li b lj mq ll ms ln pd lp pe lr pf lt lu lv lw lx bi translated"><code class="fe ng nh ni nj b">moveCanvas()</code>创建一个包含我们的<code class="fe ng nh ni nj b">ChildApp</code>的新弹出窗口</li><li id="15fc" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">令人惊奇的是，我们的两个应用程序都在同一个共享应用程序工作器中，所以创建弹出窗口将触发<code class="fe ng nh ni nj b">onAppConnect()</code></li><li id="01b0" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">最好的部分是，我们可以简单地删除现有的<code class="fe ng nh ni nj b">webgl-component</code> JavaScript实例，并将其添加到我们的<code class="fe ng nh ni nj b">ChildApp</code>的视口中。虽然这个实例碰巧位于不同的浏览器窗口中，但我们甚至可以保留相同的JS实例</li><li id="010f" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">如果我们关闭弹出窗口，我们将触发<code class="fe ng nh ni nj b">onAppDisconnect()</code>，这将把我们的画布组件实例移回我们的<code class="fe ng nh ni nj b">MainApp</code></li></ol><p id="0920" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated"><strong class="li ja">但是……我们真的可以多次转移画布节点的所有权吗？</strong></p><p id="1315" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">理论上，它可能适用于一个空的canvas节点，但是一旦我们设置了像<code class="fe ng nh ni nj b">WebGL</code>这样的上下文，试图再次移动节点就会导致JS错误。</p><p id="ef86" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">那么，它是如何工作的呢？</p><p id="23a5" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">神奇的事情发生在我们的canvas组件本身内部:<br/><a class="ae nk" href="https://github.com/neomjs/neo/blob/dev/src/component/Canvas.mjs" rel="noopener ugc nofollow" target="_blank">src/component/canvas . mjs</a></p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="pb mj l"/></div></figure><p id="5303" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">每次我们(重新)挂载组件时，它都会在DOM中放入一个新的空画布节点。之后，它将被传输到我们的(共享的)画布工作器中，并被添加到我们的id映射中。</p><p id="d666" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">由于它的id和以前一样，下一个动画标记将把我们现有的状态应用到另一个浏览器窗口中的画布节点。</p><h1 id="f041" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">6.共享工作人员的功能请求</h1><p id="344c" class="pw-post-body-paragraph mn mo iq li b lj lk ka mr ll lm kd mt ln of mw mx lp og na nb lr oh ne nf lt ij bi translated">浏览器支持:</p><ol class=""><li id="63d4" class="lg lh iq li b lj mq ll ms ln pd lp pe lr pf lt lu lv lw lx bi translated">Chromium和Firefox中都有屏幕外画布</li><li id="f335" class="lg lh iq li b lj ly ll lz ln ma lp mb lr mc lt lu lv lw lx bi translated">Chromium、Firefox和Safari技术预览版中提供了共享工作器</li></ol><p id="47ba" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">对于多屏应用，我们最有可能使用原生外壳(例如<a class="ae nk" href="https://github.com/electron/electron" rel="noopener ugc nofollow" target="_blank"> Electron </a>)，所以如果不是所有的浏览器都被支持，那也不算太糟糕。不过，看到一些努力确实让我很开心！</p><blockquote class="mk ml mm"><p id="ea67" class="mn mo mp li b lj mq ka mr ll ms kd mt mu mv mw mx my mz na nb nc nd ne nf lt ij bi translated">您也可以在workers中使用requestAnimationFrame</p></blockquote><div class="nl nm gp gr nn no"><a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas#asynchronous_display_of_frames_produced_by_an_offscreencanvas" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ja gy z fp nt fr fs nu fu fw iz bi translated">屏幕外画布-Web API | MDN</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">当使用元素或画布API时，渲染、动画和用户交互通常发生在主…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">developer.mozilla.org</p></div></div><div class="nx l"><div class="pg l nz oa ob nx oc od no"/></div></div></a></div><p id="e4eb" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">虽然<code class="fe ng nh ni nj b">requestAnimationFrame()</code>在专门的工作人员中确实可用，但遗憾的是<code class="fe ng nh ni nj b">SharedWorkers</code>并非如此。</p><p id="032f" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">有点明显，因为不清楚我们想要使用哪个主线程。</p><p id="a5a1" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated"><strong class="li ja">然而，在共享工作者内部，我们有连接端口。</strong></p><p id="50ad" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">如果有新的主线程连接，端口应该包含<code class="fe ng nh ni nj b">requestAnimationFrame()</code>，我们就可以开始了。</p><h1 id="9dc8" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">7.在线演示</h1><p id="51be" class="pw-post-body-paragraph mn mo iq li b lj lk ka mr ll lm kd mt ln of mw mx lp og na nb lr oh ne nf lt ij bi translated">旁注:有时我们需要重新加载一次应用程序才能看到动画。需要在某个时候对此进行调试。</p><p id="8fbd" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">开发模式(按原样运行代码→Chromium):<br/><a class="ae nk" href="https://neomjs.github.io/pages2/workspace/neo-shared-offscreen-canvas-demo/apps/mainapp/index.html" rel="noopener ugc nofollow" target="_blank">https://neom js . github . io/pages 2/workspace/neo-shared-off screen-canvas-demo/apps/main app/index . html</a></p><p id="5263" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">dist/production(基于web pack→Chromium &amp; Firefox):<br/><a class="ae nk" href="https://neomjs.github.io/pages2/workspace/neo-shared-offscreen-canvas-demo/dist/production/apps/mainapp/index.html" rel="noopener ugc nofollow" target="_blank">https://neom js . github . io/pages 2/workspace/neo-shared-off screen-canvas-demo/dist/production/apps/main app/index . html</a></p><p id="774e" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">画布动画在开发模式下运行更加流畅。这很可能与<a class="ae nk" href="https://github.com/d3fc/d3fc" rel="noopener ugc nofollow" target="_blank"> d3fc </a> lib中的作用域问题有关。</p><p id="822b" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">不过，在火狐内部看到这个作品还是很棒的:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ou ov di ow bf ox"><div class="gh gi ph"><img src="../Images/2957a4ca9f24486cea7f231c487d25ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POjiKvpxcCJtk4FX1b2_LQ.png"/></div></div></figure><h1 id="d6ef" class="ko kp iq bd kq kr ks kt ku kv kw kx ky kf kz kg la ki lb kj lc kl ld km le lf bi translated">8.neo.mjs项目</h1><p id="162f" class="pw-post-body-paragraph mn mo iq li b lj lk ka mr ll lm kd mt ln of mw mx lp og na nb lr oh ne nf lt ij bi translated">“应用程序工作人员是主角”或“脱离主线程”不再是虚构的，而是非常稳定和快速地工作:</p><div class="nl nm gp gr nn no"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ja gy z fp nt fr fs nu fu fw iz bi translated">GitHub - neomjs/neo:应用工人驱动的前端框架</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序。不需要照顾一个…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="pi l nz oa ob nx oc od no"/></div></div></a></div><p id="ed06" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">neo已经发布了4.2.1版，在生态系统中提交了超过15000次。</p><p id="50a2" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">如果您还没有了解性能、可伸缩性和可扩展性的优势，您可能想了解下一代多线程前端主题。</p><p id="af8f" class="pw-post-body-paragraph mn mo iq li b lj mq ka mr ll ms kd mt ln mv mw mx lp mz na nb lr nd ne nf lt ij bi translated">最诚挚的问候&amp;快乐编码，<br/>托比亚斯</p></div></div>    
</body>
</html>