<html>
<head>
<title>It’s ok to use function calls in Angular templates!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在角模板中使用函数调用是可以的！</h1>
<blockquote>原文：<a href="https://itnext.io/its-ok-to-use-function-calls-in-angular-templates-ffdd12b0789e?source=collection_archive---------0-----------------------#2022-09-28">https://itnext.io/its-ok-to-use-function-calls-in-angular-templates-ffdd12b0789e?source=collection_archive---------0-----------------------#2022-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f7c8b002a900b67f4e746599d3ea401a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJVadKoMyqw_fQ7PmaFu4w.png"/></div></div></figure><div class=""/><p id="10ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"你不应该在角度模板上使用函数调用！"—这就是你会在网上看到的一切！我在这里向你证明事实并非总是如此！</p><h2 id="b7ac" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">问题</h2><p id="12d7" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">每次角度变化检测运行时(从事件、设置超时、手动或任何其他)，模板上的所有内容都将再次运行，函数调用也是如此。Angular为什么要这么做？因为它需要检查模板上发生了什么变化，以便更新它。</p><p id="9157" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果函数做了一些繁重的工作，它将影响应用程序的性能，因为Angular更新视图的方式是同步的，它必须等待函数完成，然后更新视图。</p><h2 id="ecd2" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">“使用管道”解决方案</h2><p id="5700" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们最常看到的解决方案是“使用管道”。建议这样做，因为角度模板中的管道性能更好。怎么会这样？因为Angular只有在我们传递给它的参数发生变化时才会重新运行管道的<strong class="ka jc">转换方法</strong>。</p><p id="2093" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">让我们证明这一点！</strong></p><h2 id="29a6" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">让我们深入研究源代码</h2><p id="df53" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在新的Angular编译器(Ivy)中，模板被编译成指令。让我们举个例子，看看它会生成什么。</p><p id="a063" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个带有简单管道的组件。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ddcb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是清理后生成的代码:</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d01a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所见，在<strong class="ka jc">第29行</strong>中，我们看到Angular为模板代码生成了什么。</p><p id="a222" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，有关于<strong class="ka jc">创建div </strong>、<strong class="ka jc">添加文本</strong>、<strong class="ka jc">添加管道</strong>、<strong class="ka jc">关闭div </strong>、<strong class="ka jc">创建按钮并向其添加监听器</strong>的说明……(Ivy很酷的东西🌿).我们还可以看到<strong class="ka jc"> if </strong> / <strong class="ka jc"> else </strong>语句。它的作用是将<strong class="ka jc">视图创建</strong>与<strong class="ka jc">视图更新</strong>分开，如果创建视图，则第一个<strong class="ka jc">视图，第二个视图用于更新部分。你可以在这里阅读更多关于那个<a class="ae mb" href="https://github.com/angular/angular/blob/main/packages/core/src/render3/VIEW_DATA.md" rel="noopener ugc nofollow" target="_blank">的内容。</a></strong></p><p id="6cef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们对33号线和43号线感兴趣，因为那是管子表演魔术🪄.的地方在<strong class="ka jc">行33 </strong>中，它在模板中注册管道，数据的绑定发生在<strong class="ka jc">行43 </strong>(在更新阶段)。我们看到它插入了一些文本，这些文本来自<strong class="ka jc"> ɵɵpipeBind1() </strong>函数。让我们看看这个函数在🕵️‍♂️.下面做了什么</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mc"><img src="../Images/574fb7c1bce6485dafede7b314219b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNNTGVlGtRb24I9zC2NVGA.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">链接到源代码<a class="ae mb" href="https://github.com/angular/angular/blob/main/packages/core/src/render3/pipe.ts#L123" rel="noopener ugc nofollow" target="_blank">这里</a></figcaption></figure><p id="8a96" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，前三行获取管道实例的信息，然后我们有一个返回语句。在返回中，我们有一个对<strong class="ka jc"> isPure() </strong>的检查，它只是检查我们是否在管道装饰器中设置了纯字段true或false。</p><p id="0565" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们已经将<strong class="ka jc">纯字段</strong>设置为<strong class="ka jc">假</strong>，它将直接返回<strong class="ka jc">pipe instance . transform(v1)</strong>值，这意味着Angular不会对管道做任何特殊处理，而只是再次运行<strong class="ka jc">转换方法</strong>。这与使用组件类中的方法是一样的。</p><p id="e575" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果管道是<strong class="ka jc">纯</strong>(就像我们的例子一样)，它将调用<strong class="ka jc">pure function 1 internal helper函数</strong>，并将一些字段传递给它。让我们看看<strong class="ka jc"> pureFunction1Internal </strong>在下面做什么。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mh"><img src="../Images/b335a80a2c855ef2b93ba0b00fd82857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bu8GeugTIY7zfisyR94Gg.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">链接到源代码<a class="ae mb" href="https://github.com/angular/angular/blob/main/packages/core/src/render3/pure_function.ts#L307" rel="noopener ugc nofollow" target="_blank">这里</a></figcaption></figure><p id="df4a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，它检查绑定是否在<strong class="ka jc"> bindingUpdated函数</strong>中更新，如果是，它将<strong class="ka jc">更新绑定</strong>，否则它将<strong class="ka jc">返回纯函数</strong>的值(当前值)。让我们看看它在🕵️‍♂️.下面做什么检查</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mi"><img src="../Images/80bf5eaa9a91d675ff71390ec1c0cb4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oh_igSzB2pBGQDePMA-mdQ.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">链接到源代码<a class="ae mb" href="https://github.com/angular/angular/blob/main/packages/core/src/render3/bindings.ts#L46" rel="noopener ugc nofollow" target="_blank">这里</a></figcaption></figure><p id="452a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，它真正检查的是旧值是否与新值相同(使用<strong class="ka jc"> Object.is() </strong>)。<em class="lu">你会问:这是什么值？</em>我们传递给管道<strong class="ka jc">转换方法</strong>的参数。</p><p id="3ddb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着，如果该方法的参数都没有改变，我们就可以开始了，我们可以返回false，我们不必再次运行函数，我们可以只使用绑定的旧值。</p><p id="bb15" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们首先想要证明的，🥳.</p><h2 id="e29d" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">这对我们意味着什么？</h2><p id="5c33" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">这意味着我们可以创建一个助手函数，它可以为我们完成神奇的Angular功能，而根本不需要使用管道😎。</p><p id="dc8d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是助手函数，我们将在下面解释它是如何工作的。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d91b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，<strong class="ka jc"> memo </strong>是一个接受函数作为参数并返回结果的函数。</p><p id="c846" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka jc">第6行</strong>中，我们检查功能参数是否已经改变，这就是<strong class="ka jc">对不同功能</strong>的帮助。它首先检查args的长度是否已经改变，如果是则返回true，然后进行参数的等式检查(<strong class="ka jc">就像Angular对管道</strong>所做的那样)。</p><p id="bf5e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果参数改变了，我们用新的参数再次调用函数并保存它的结果，如果没有，我们返回旧的值。</p><p id="39e0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">怎么用？</strong></p><p id="9ddb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的例子转换成使用memo函数。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0b7f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样！是的，我们在模板中使用了一个函数！而且是的，这样做不成问题！😄</p><h2 id="668e" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">有什么蹊跷吗？</h2><p id="8b88" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">有，有！当您在模板中调用memo函数并向其传递相同的值时，memo函数会对您有所帮助，不要使用不同的参数，因为这样会破坏memo函数的“缓存”。</p><p id="61b8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我这么说是什么意思？这里有一个例子。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ffe9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们在模板的不同位置传递不同的值，memo函数将缓存每个实例的内容，而不是每次使用。</p><p id="7543" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，每次我们点击按钮时，名为“T3”的“<strong class="ka jc">将会显示6次。</strong></p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mj"><img src="../Images/59a19b6fc65704839f73772876ff9e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGH5X0mwSGXNZ2HC2c4vAg.png"/></div></div></figure><p id="d01c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果我们在模板的所有地方传递相同的值，它将只触发一次。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c359" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是控制台。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mk"><img src="../Images/eda22f9d72ab40d945ef4bd3f28a5b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1cV0TYAPZam_rwL_oeMnA.png"/></div></div></figure><blockquote class="ml mm mn"><p id="6b65" class="jy jz lu ka b kb kc kd ke kf kg kh ki mo kk kl km mp ko kp kq mq ks kt ku kv ij bi translated">管道按函数使用进行缓存，而memo util按函数定义进行缓存。</p></blockquote><h2 id="878c" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">这篇博文的想法和灵感？</h2><p id="341f" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">这一切都要感谢来自<a class="ae mb" href="https://twitter.com/pkozlowski_os" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> Pawel Kozlowski </strong> </a>一位棱角分明的团队成员的推文。我只是想挖掘更多的源代码，并进一步解释它。</p><figure class="lv lw lx ly gt is"><div class="bz fp l di"><div class="mr ma l"/></div></figure><p id="9e8b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你对<strong class="ka jc">反应</strong>、<strong class="ka jc">信号</strong>、<strong class="ka jc">性能</strong>、<strong class="ka jc">变化检测</strong>感兴趣，还有其他类似的东西吗？去推特上关注Pawel，他正在探索这个空间，并在推特上发布一些很酷的东西！</p><p id="a05e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你在Twitter上的时候，如果你想知道<strong class="ka jc">最新的角度新闻</strong>、<strong class="ka jc">视频</strong>、<strong class="ka jc">播客</strong>、<strong class="ka jc">更新</strong>、<strong class="ka jc">RFC</strong>、<strong class="ka jc">拉请求</strong>等等，也可以在<a class="ae mb" href="https://twitter.com/Enea_Jahollari" rel="noopener ugc nofollow" target="_blank"> @Enea_Jahollari </a>关注我。如果你喜欢这篇文章，并希望看到更多这样的，请给我一个后续媒体！</p><p id="2b06" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">感谢您的阅读！</strong></p></div></div>    
</body>
</html>