<html>
<head>
<title>Production ready Prisma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产就绪Prisma</h1>
<blockquote>原文：<a href="https://itnext.io/production-ready-prisma-2da868a407dd?source=collection_archive---------1-----------------------#2018-09-24">https://itnext.io/production-ready-prisma-2da868a407dd?source=collection_archive---------1-----------------------#2018-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f5323a2723983c787ca4352dc094f603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEuNteiYaPXEDqIqe7KSew.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Prisma拓扑的插图</figcaption></figure><p id="fd8f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">免责声明:一般假设您知道Prisma是什么，它是做什么的，以及它的好处。要了解更多关于Prisma的信息，请访问他们的优秀网站</em><a class="ae lb" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"><em class="la">www . Prisma . io</em></a></p><p id="cd8d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Prisma免费提供了一个名为<a class="ae lb" href="https://www.prisma.io/cloud/" rel="noopener ugc nofollow" target="_blank"> Prisma Cloud </a>的非常慷慨的开发环境，但是您可能不希望或者不能够将这个环境用于您的生产应用程序。因此，我们将介绍如何在您的应用程序中建立一个高可用性的Prisma部署。</p><h1 id="92fb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">集装箱化</h1><p id="f64e" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">将您的应用程序封装在一个容器中允许您分离关注点，独立地扩展，并且以可重复的、自包含的和可靠的方式这样做。</p><p id="dd3f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">容器编排可以通过多种方式实现，但我们将专注于使用Kubernetes，因为它受到AWS、Azure和Google Cloud的支持，提供了一种管理部署和扩展这些部署的惯用方法。</p><p id="0246" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Prisma利用了docker，这使其在本地或远程docker环境中的部署变得非常灵活。</p><h1 id="519d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">数据存储</h1><p id="7770" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">Prisma用静态类型和GraphQL服务器包装我们的数据库，graph QL服务器自动为我们的建模数据生成绑定，因此确保我们有一个可靠和可伸缩的数据库是Prisma生产实例的关键。Prisma目前支持Postgres和MySQL，并有一个MongoDB测试版。</p><p id="fae8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将在基础设施中使用Kubernetes和Google Cloud，因此我们将利用Google的cloud SQL产品。</p><p id="39b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您希望部署自己的数据库，您应该考虑使用MySQL的集群部署，它至少具有主/从关系和复制。</p><h1 id="c22c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">定义我们的基础设施</h1><p id="3f08" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">我们将使用Kubernetes，它利用清单来描述它的资源，其中之一是部署，这将代表我们的应用程序并定义我们的应用程序可以访问的环境变量；其在Kubenetes中被表示为一个荚。</p><p id="7591" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还将描述我们的pod在出现故障时应该如何处理(自我修复)以及应该如何扩展。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a25b" class="mo ld iq mk b gy mp mq l mr ms">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: prisma<br/>  namespace: prisma<br/>  labels:<br/>    stage: production<br/>    name: prisma<br/>    app: prisma<br/>spec:<br/>  replicas: 2<br/>  strategy:<br/>    type:<strong class="mk ir"> RollingUpdate</strong><br/>    rollingUpdate:<br/>      maxSurge: 1<br/>      maxUnavailable: 0<br/>  template:<br/>    metadata:<br/>      labels:<br/>        stage: production<br/>        name: prisma<br/>        app: prisma<br/>    spec:<br/>      containers:<br/>        - name: prisma<br/>          image: <strong class="mk ir">'prismagraphql/prisma:1.15'</strong><br/>          ports:<br/>            - name: prisma-4466<br/>              containerPort: 4466<br/>          env:<br/>            - name: PRISMA_CONFIG<br/>              valueFrom:<br/>                configMapKeyRef:<br/>                  name: <strong class="mk ir">prisma-configmap</strong><br/>                  key: PRISMA_CONFIG<br/>            - name: DB_USER<br/>              valueFrom:<br/>                secretKeyRef:<br/>                  name: <strong class="mk ir">prisma-cloudsql-db-credentials</strong><br/>                  key: username<br/>            - name: DB_PASSWORD<br/>              valueFrom:<br/>                secretKeyRef:<br/>                  name: <strong class="mk ir">prisma-cloudsql-db-credentials</strong><br/>                  key: password        <br/>        - name: cloudsql-proxy<br/>          image: <strong class="mk ir">gcr.io/cloudsql-docker/gce-proxy:1.11</strong><br/>          command: <strong class="mk ir">["/cloud_sql_proxy",<br/>                    "-instances=mysql-212618:europe-west1:production-prisma=tcp:3306",<br/>                    "-credential_file=/secrets/cloudsql/credentials.json"]</strong><br/>          securityContext:<br/>            runAsUser: 2<br/>            allowPrivilegeEscalation: false<br/>          volumeMounts:<br/>            - name: <strong class="mk ir">prisma-cloudsql-instance-credentials</strong><br/>              mountPath: /secrets/cloudsql<br/>              readOnly: true<br/>      volumes:<br/>        - name: <strong class="mk ir">prisma-cloudsql-instance-credentials</strong><br/>          secret:<br/>            secretName: <strong class="mk ir">prisma-cloudsql-instance-credentials</strong></span></pre><h2 id="67de" class="mo ld iq bd le mt mu dn li mv mw dp lm kn mx my lq kr mz na lu kv nb nc ly nd bi translated">我们的部署清单中的一些细节</h2><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="01e7" class="mo ld iq mk b gy mp mq l mr ms">replicas: 2<br/>strategy:<br/>    type: RollingUpdate<br/>    rollingUpdate:<br/>      maxSurge: 1<br/>      maxUnavailable: 0</span></pre><p id="f993" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">扩展分为两个不同的方面:部署策略和资源可用性。</p><p id="c3f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的部署策略声明了我们希望如何将新图像发布到我们的容器中。默认是通过终止旧版本并发布新版本来重新创建；这通常会导致停机。</p><p id="6ad3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">选择滚动更新允许我们在保持正常运行时间的同时部署更改，我们还可以暂停部署并恢复或取消它。</p><p id="6d66" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于不同策略的更多信息可以在这里找到:<a class="ae lb" href="https://container-solutions.com/kubernetes-deployment-strategies/" rel="noopener ugc nofollow" target="_blank">https://container-solutions . com/kubernetes-deployment-strategies</a></p><p id="8828" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可用性可以定义为能够满足应用需求的最大pod数量。我们已经声明了2个副本，但是除了这个值之外，只能创建1个副本，这样在一次展示中，我们最多可以同时有3个活动的pod。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="736b" class="mo ld iq mk b gy mp mq l mr ms">env:<br/>  - name: PRISMA_CONFIG<br/>    valueFrom:<br/>      configMapKeyRef:<br/>        name: prisma-configmap<br/>        key: PRISMA_CONFIG</span></pre><p id="8af5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们引用一个名为PRISMA_CONFIG的配置映射，它是PRISMA所期望的，以便连接到我们的数据库并定义关于我们的主机的详细信息。</p><p id="22ac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在这里了解更多:<a class="ae lb" href="https://www.prisma.io/docs/run-prisma-server/deployment-environments/docker-rty1/#prisma_config-reference" rel="noopener ugc nofollow" target="_blank">https://www . prisma . io/docs/run-prisma-server/deployment-environments/docker-rt y1/# prisma _ config-reference</a></p><p id="f117" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以将配置图定义为Kubernetes中的一个资源:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="7f02" class="mo ld iq mk b gy mp mq l mr ms">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: prisma-configmap<br/>  namespace: prisma<br/>  labels:<br/>    stage: production<br/>    name: prisma<br/>    app: prisma<br/>data:<br/>  PRISMA_CONFIG: |<br/>    port: 4466<br/>    databases:<br/>      default:<br/>        connector: mysql<br/>        host: 127.0.0.1<br/>        port: 3306<br/>        user: prisma<br/>        password: password123 # make this a lot more complex and secure<br/>        migrations: true</span></pre><h2 id="e7bc" class="mo ld iq bd le mt mu dn li mv mw dp lm kn mx my lq kr mz na lu kv nb nc ly nd bi translated">卷安装和谷歌云代理</h2><p id="507c" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">我们需要允许我们的应用程序安全地与我们的Google Cloud SQL数据库通信，我们可以通过向我们的应用程序部署添加代理sidecar来实现这一点。</p><p id="335c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将在Google Cloud中的SQL服务和我们在Kubernetes容器中的应用程序之间创建一个安全的隧道。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="b478" class="mo ld iq mk b gy mp mq l mr ms">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>...<br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - name: cloudsql-proxy<br/>          image: <strong class="mk ir">gcr.io/cloudsql-docker/gce-proxy:1.11</strong><br/>          command: <strong class="mk ir">["/cloud_sql_proxy",<br/>                    "-instances=mysql-212618:europe-west1:production-prisma=tcp:3306",<br/>                    "-credential_file=/secrets/cloudsql/credentials.json"]</strong><br/>          securityContext:<br/>            runAsUser: 2<br/>            allowPrivilegeEscalation: false<br/>          volumeMounts:<br/>            - name: <strong class="mk ir">prisma-cloudsql-instance-credentials</strong><br/>              mountPath: /secrets/cloudsql<br/>              readOnly: true<br/>      volumes:<br/>        - name: <strong class="mk ir">prisma-cloudsql-instance-credentials</strong><br/>          secret:<br/>            secretName: <strong class="mk ir">prisma-cloudsql-instance-credentials</strong></span></pre><p id="0985" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还安装了一个代表我们的Google Cloud IAM凭证的秘密，这样我们就可以通过命令块中的<em class="la"> credentials_file </em>标志来引用它。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1a51" class="mo ld iq mk b gy mp mq l mr ms">./cloud_sql_proxy -instances=&lt;INSTANCE_CONNECTION_NAME&gt;=tcp:3306 \<br/>                  -credential_file=&lt;PATH_TO_KEY_FILE&gt; &amp;</span></pre><p id="739d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae lb" href="https://cloud.google.com/sql/docs/mysql/connect-admin-proxy#start-proxy" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/SQL/docs/MySQL/connect-admin-proxy # start-proxy</a></p><h2 id="7d7f" class="mo ld iq bd le mt mu dn li mv mw dp lm kn mx my lq kr mz na lu kv nb nc ly nd bi translated">管理秘密</h2><p id="6718" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">保持良好的秘密卫生对健康的生产环境至关重要。Kubernetes提供了一种安全存储秘密的机制，但是，如果您对存储秘密更加偏执，并且需要能够审计对秘密的访问，那么探索Hashi Corp保险库可能是一个好主意，并且超出了本练习的范围。</p><p id="e75a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们已经引用了一个秘密<em class="la">prisma-cloud QL-instance-credentials</em>同样，我们可以在Kubernetes中创建秘密作为资源。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="45d1" class="mo ld iq mk b gy mp mq l mr ms">kubectl create secret generic cloudsql-instance-credentials \<br/>    --from-file=credentials.json=[PROXY_KEY_FILE_PATH]</span></pre><p id="07c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae lb" href="https://cloud.google.com/sql/docs/mysql/connect-kubernetes-engine#5_create_your_secrets" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/SQL/docs/MySQL/connect-kubernetes-engine # 5 _ create _ your _ secrets</a></p><p id="e39f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您没有保存IAM帐户的<em class="la"> credentials.json </em>文件来访问您的数据库，您可以遵循以下说明:<a class="ae lb" href="https://cloud.google.com/sql/docs/mysql/connect-kubernetes-engine#2_create_a_service_account" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/SQL/docs/MySQL/connect-kubernetes-engine # 2 _ create _ a _ service _ account</a></p><h1 id="9f97" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">访问Prisma</h1><p id="e25a" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">现在，您应该拥有一个包含2个pods的集群，其中部署了Prisma，两个pods都连接到您的Google Cloud SQL数据库。</p><p id="d8af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，在将应用程序部署作为服务公开之前，您无法访问Prisma。这里有更多关于服务的信息:<a class="ae lb" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/services-networking/service</a></p><p id="88ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">服务是Kubernetes的资源，可以用与应用程序其他部分类似的方式来声明。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="82ea" class="mo ld iq mk b gy mp mq l mr ms">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: prisma-backend<br/>  namespace: prisma<br/>  labels:<br/>    stage: production<br/>    name: prisma<br/>    app: prisma<br/>spec:<br/>  type: NodePort<br/>  selector:<br/>    stage: production<br/>    name: prisma<br/>    app: prisma<br/>  ports:<br/>  - port: 4466<br/>    targetPort: 4466</span></pre><p id="2930" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们选择使用选择器来引用和分组我们的pod，选择器允许我们抽象出任何发现机制，并确保我们可以在不改变我们的应用基础架构的整体定义的情况下向我们的池中添加额外的pod。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ebd5" class="mo ld iq mk b gy mp mq l mr ms">spec:<br/>  type: NodePort<br/>  selector:<br/>    stage: production<br/>    name: prisma<br/>    app: prisma</span></pre><p id="684f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您应该能够通过运行以下命令来查看您的新Prisma服务</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3d27" class="mo ld iq mk b gy mp mq l mr ms">$ kubectl describe services --namespace prisma </span></pre><p id="1749" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们已经在所有清单中声明，我们创建的任何资源都应该驻留在<em class="la"> prisma </em>名称空间中，记住在任何命令前面加上这个名称空间非常重要。</p><p id="ec0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您也可以将请求代理到您的新服务。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0425" class="mo ld iq mk b gy mp mq l mr ms">$ kubectl port-forward --namespace prisma &lt;the-pod-name&gt; 4467:4466</span></pre><p id="ba2c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae lb" href="https://www.prisma.io/docs/1.14/tutorials/deploy-prisma-servers/kubernetes-aiqu8ahgha#configuration-of-the-prisma-cli" rel="noopener ugc nofollow" target="_blank">https://www . prisma . io/docs/1.14/tutorials/deploy-prisma-servers/kubernetes-aiqu 8 ah gha # configuration-of-the-prisma-CLI</a></p><p id="c9f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您应该能够在本地访问Prisma实例http://localhost:4466</p><p id="3720" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这也是测试pod的一个很好的方法，因为您指定了代理哪个pod。</p><p id="494e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此时，您还将能够使用Kubernetes内部DNS和服务发现向您的Prisma服务发送请求。如果您不想公开暴露它，建议您这样做，您应该确保在您的<em class="la"> PRISMA_CONFIG中为managementApiSecret <em class="la"> </em>值提供一个安全的秘密，并添加TLS终止。</em></p><h1 id="9eb9" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">公开暴露</h1><p id="dffc" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">如果您<em class="la">让</em>向外公开您的Prisma实例，您将需要声明一个引用我们服务的入口资源，并通过其节点端口将请求转发到一个可公开访问的地址。</p><p id="56ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于我们使用谷歌云，我们可以注册一个静态IP地址，确保对我们的入口控制器网络接口的任何更改都不会导致我们无法访问Prisma服务。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="12a0" class="mo ld iq mk b gy mp mq l mr ms">$ gcloud compute addresses create &lt;name-of-ip&gt; --global</span></pre><p id="0d19" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在可以使用新注册和分配的IP地址在DNS中创建一个A记录。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="997d" class="mo ld iq mk b gy mp mq l mr ms">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: basic-ingress<br/><strong class="mk ir">  annotations:</strong><br/><strong class="mk ir">    kubernetes.io/ingress.global-static-ip-name: </strong><strong class="mk ir">&lt;name-of-ip&gt;</strong><br/>spec:<br/>  backend:<br/>    serviceName: web<br/>    servicePort: 8080</span></pre><h1 id="15c4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">总结</strong></h1><p id="23f2" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">我们已经部署了一个Prisma服务器集群，由Google Cloud的SQL平台提供支持，然后将其作为Kubenetes的内部服务公开。</p><p id="aae5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您还应该知道如何使用Google Cloud代理访问集群中的特定pods。</p><p id="b045" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们希望从外部访问我们的集群，因此我们设置了一个全局静态IP地址，并将其分配给一个入口控制器，该控制器使用我们之前定义的服务来支持它。</p><p id="ed5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一次，我们将研究如何使用Hashicorp Vault并使用LetsEncrypt添加TLS/SSL来使我们的服务器更加安全。</p></div></div>    
</body>
</html>