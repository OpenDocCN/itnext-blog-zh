<html>
<head>
<title>How to Easily Render Multiple Elements in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中轻松渲染多个元素</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-easily-render-multiple-elements-in-react-c9193a06f23a?source=collection_archive---------0-----------------------#2019-09-29">https://itnext.io/how-to-easily-render-multiple-elements-in-react-c9193a06f23a?source=collection_archive---------0-----------------------#2019-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7b7f49d03aa30db6e6a4de4b0f740f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhBuxy4dV2vdrWPLOxtSpA.png"/></div></div></figure><p id="228b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我和Vuejs一起工作了一年多，用它做了不少个人项目。最近开始学习Reactjs后，发现了这个确定的特性。</p><p id="5b66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Vue和React中，我们只能渲染一个元素。即使我们有多个元素要渲染，也只能有一个<em class="kz">单根元素</em>。这意味着如果我们想要呈现两个或更多的元素，我们必须将它们包装在另一个元素或组件中。通常，用于此的元素是一个<code class="fe la lb lc ld b">&lt;div&gt;</code>标签。这对页面结构没有太大影响，所以<code class="fe la lb lc ld b">div</code>是一个流行的包装元素。</p><p id="c60d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，有时候，使用包装器元素可能是低效的。在某些情况下，拥有包装组件会导致CSS不一致，从而导致头痛。这并不意味着我们绝对不能使用包装元素。但是这种解决方法可能会很难，而且很耗时。</p><h1 id="6756" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">这里有一些这样的例子</h1><p id="5f29" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">第一个例子是我亲身经历的。我想创建一个倒计时定时器，并添加一个背景图片。这个项目没什么大不了的，因为我只是做它来练习我的反应技能。组件的结构大致是这样的:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/63dd276d901f11372b6559e3f1ba2d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M8Np8eBRlJPJ_qSl"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">我的倒计时项目的结构</figcaption></figure><p id="1b4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在请记住，这个<code class="fe la lb lc ld b">div</code>以及里面的所有内容都将在另一个<code class="fe la lb lc ld b">div</code>中呈现，T3是DOM中的目标元素。当我尝试应用背景图像时，它要么不成比例，要么在顶部留下了一些空白。我试了我能想到的一切，但结果是一样的。为了让它工作，我甚至将背景图片作为内嵌样式添加到HTML的主体中。最后，我不得不与<code class="fe la lb lc ld b">position: absolute</code>合作，改变两个<code class="fe la lb lc ld b">div</code>的宽度和高度，并让它正常工作。</p><p id="1238" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很好，因为唯一要显示的内容是倒计时。但是如果应用程序更复杂，处理起来会更令人沮丧。当然，也有可能有一个更好的解决方案，只是我没有足够的经验去发现它。不管怎样，根据项目的复杂程度，变通方法也可能同样复杂。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="1951" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个例子来自React文档。</p><p id="7190" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此示例在一个组件中有一个表格，该组件有一个表格行，该行中有一个子组件。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/11e0fd2b0f24fe24a364c07d844b4ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dmKDJuInfNNYmGQn"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">React文档示例中的表组件</figcaption></figure><p id="f7d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">Table</code>组件将呈现表格本身和行，而<code class="fe la lb lc ld b">Columns</code>子组件将返回列。一切看起来都很好。但是看一看<code class="fe la lb lc ld b">Columns</code>组件:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/378ece82f47569e041f3cd43af4c81ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NLxr5Ox1lZtzjCbK"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">React文档示例中的列组件</figcaption></figure><p id="87d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然这是一个有效的组件，它返回了包装在一个<code class="fe la lb lc ld b">div</code>中的多个元素，但是它不能与父组件<code class="fe la lb lc ld b">Table</code>一起工作。看看渲染的结果:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/233ac954d0126e7d05db344867b2988a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gxvJZlE4r5WN_aNI"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">无效的HTML结果</figcaption></figure><p id="7239" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是完全无效的HTML。</p><p id="96e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幸运的是，有一种方法可以解决这个问题。有了这个，我们就不必担心调整CSS，也将满足呈现多个元素的需求。</p><p id="16f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有两种方法可以解决这个问题。</p><h1 id="1cd2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第一种解决方案</h1><p id="19de" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">第一个解决方案是使用React提供的一个特性，叫做<code class="fe la lb lc ld b">Fragments</code>。一个<em class="kz">片段</em>是一个空的包装组件，它不呈现任何自己的HTML。它只是返回写在标签中的内容。将此应用于React docs示例，我们将得到:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/2c7556aeddd49bbbf7a8fd94ab3aba74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X7ZvPA9KFKJU7Z7b"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">使用反应片段的第一种解决方案</figcaption></figure><p id="1aa0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，<code class="fe la lb lc ld b">Table</code>组件将呈现有效的HTML:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/5a86fae53628fd3177f6a9b99229ba5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UMJMFHmkDadW2pQL"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">有效的HTML结果</figcaption></figure><p id="e390" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React v16.2提供了这个特性。</p><p id="e875" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">React.Fragment</code>实现起来并不那么困难。我们可以做一个空的组件，得到同样的结果。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/b63356bbd01a8a8741f0ce575d62f028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LfLZwZ7c1D8nXuV6"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">实现React片段</figcaption></figure><p id="65ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以像使用<code class="fe la lb lc ld b">Fragment</code>一样使用这个定制的包装组件。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/b4714414b2bb551fef0793b1c9bb5624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g9jUlQvNj8twaboH"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">使用片段实现</figcaption></figure><p id="c911" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">产生的HTML将是相同的。虽然我们可以自己实现，但是使用<code class="fe la lb lc ld b">React.Fragment</code>意味着我们的项目树中少了一个组件，使用<code class="fe la lb lc ld b">Fragments</code>会更有效，因为它在默认的React包中可用。</p><p id="3056" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一个新的短语法可供您用于<em class="kz">片段</em>:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/bcd3ec9990fb9cc24c5dc00e130bdac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJjH2ySRjh1qlywJbg_Z6g.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">片段的简短语法</figcaption></figure><p id="91c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以像平常的组件一样使用<code class="fe la lb lc ld b">&lt;&gt;&lt;/&gt;</code>，但是它不支持属性或者键。</p><h1 id="c609" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">另一种解决方案</h1><p id="1f84" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">第二个解决方案是将返回的JSX放在方括号中，而不是括号中。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/1092763029159d838065079abd70ed60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ReDAZ9xeUJGeHrdcBHDJ7Q.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">第二种解决方案</figcaption></figure><p id="cf43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是完全有效的，也是我们想要它做的。React呈现元素的方式是，当我们返回包装在单个<code class="fe la lb lc ld b">&lt;div&gt;</code>元素中的整个JSX时，它将这个单个<code class="fe la lb lc ld b">&lt;div&gt;</code>传递给<code class="fe la lb lc ld b">ReactDOM.createElement()</code>方法。该方法只接受一个参数。</p><p id="2e6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们上面的解决方案有效的原因。尽管它实际上是一组没有任何包装元素的元素，如<code class="fe la lb lc ld b">&lt;div&gt;</code>，但它是单个数组的一部分(记住，数组实际上是对象)。因此，我们将单个对象传递给<code class="fe la lb lc ld b">ReactDOM.createElement()</code>。</p><p id="74a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，这确实有一个缺点。虽然这样做很好，但是React会给我们一个警告。每个元素都必须有一个键。这类似于我们要求Vuejs中的<code class="fe la lb lc ld b">v-for</code>元素每个都有一个键。添加了所需的键后，我们看到了缺点:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/6b3f49bdf089f4060397ae54080fde6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*De_VLK00UGzqB2HfhYZ4Xg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">带钥匙的第二种解决方案</figcaption></figure><p id="e668" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着我们必须为每个元素添加一个唯一的键。这可能会变得相当乏味。对于一个JSX很少的小组件来说可能没问题，但是对于渲染大量JSX的巨大而复杂的组件来说，使用<em class="kz">片段</em>可能会更好。你可以在React文档中阅读更多关于片段<a class="ae mx" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><h1 id="eea4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">收尾</h1><p id="4701" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">包装另一个组件的组件实际上被称为高阶组件(Higher Order Component，HOC ),但这不是本文讨论的范围。如果你有兴趣，可以在React文档中了解更多关于hoc的信息。</p><p id="af5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章教你一些关于React如何渲染元素的新知识。了解React中的多个元素是如何呈现的，将所有元素包装在一个根元素中的原因是什么，以及当情况需要时我们如何绕过它，如果不是必要的话，这对成为React开发人员是有益的。</p><p id="31f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你对我如何改进这篇文章有任何建议或任何问题，请在下面的评论中留下。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="0192" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">最初发布于</em> <a class="ae mx" href="https://dev.to/napoleon039/how-to-easily-render-multiple-elements-in-react-4020" rel="noopener ugc nofollow" target="_blank"> <em class="kz"> dev.to </em> </a> <em class="kz">。</em></p></div></div>    
</body>
</html>