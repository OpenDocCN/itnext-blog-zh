<html>
<head>
<title>Regex Named Groups and Backreferences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式命名组和反向引用</h1>
<blockquote>原文：<a href="https://itnext.io/android-regex-named-groups-and-backreferences-940cb7f545b1?source=collection_archive---------1-----------------------#2021-11-26">https://itnext.io/android-regex-named-groups-and-backreferences-940cb7f545b1?source=collection_archive---------1-----------------------#2021-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f43894aab2895707039b00aa86b02161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkE4fnzwljPuMNKATN97bg.png"/></div></div></figure><p id="79ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大家好，我是Amr Hesham，一名软件工程师，我对Android开发和编译器设计感兴趣，在这篇文章中，我将谈论Regex命名的group和Backreferences这一非常好且有用的功能，并附有示例。</p><p id="6635" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Python re模块中首次引入了正则表达式命名的组和反向引用，然后微软开发人员在中支持它。NET的不同语法，Java从JDK 7开始支持它，现在它支持大多数现代编程语言，如Ruby、PHP、R…等，</p><p id="c52c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个特性可以帮助你在正则表达式中用名字和对这些组的引用来分组你的正则表达式，要了解更多关于这个特性的历史和更多细节，我推荐你查看Jan Goyvaerts写的教程。</p><p id="599d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从如何定义一个命名组和通过名称和索引获取组的例子开始，我将使用Kotlin编程语言，概念是相同的，正如我之前所说的错误，但是一些非JVM语言对于相同的特性有不同的语法。</p><p id="ff3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想要解析Android项目color.xml文件中的颜色属性，并打印每种颜色的名称和值，例如这里我们有3种颜色。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="a29c" class="lg lh iq lc b gy li lj l lk ll">&lt;color name="black"&gt;#000000&lt;/color&gt;<br/>&lt;color name="white"&gt;#ffffff&lt;/color&gt;<br/>&lt;color name="grey"&gt;#cccccc&lt;/color&gt;</span></pre><p id="54b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想打印</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b474" class="lg lh iq lc b gy li lj l lk ll">black #000000<br/>white #ffffff<br/>grey #cccccc</span></pre><p id="6ab3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用许多不同的技术来完成这项任务，但是我将向您展示如何使用正则表达式命名的组轻松地完成这项任务。</p><p id="30aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要创建一个正则表达式来匹配每个属性，每个属性包含类型、名称和值，如下所示</p><p id="1110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><type name="”attribute_name”">值</type></p><p id="5ebd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以正常的正则表达式应该是</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="89aa" class="lg lh iq lc b gy li lj l lk ll">&lt;\\w+ name=<strong class="lc ir">\"</strong>\\w+<strong class="lc ir">\"</strong>&gt;.+&lt;/\\w+&gt;</span></pre><p id="1638" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以使用Regex101.com的<a class="ae kw" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">来测试你的正则表达式并理解它，但是要确保你使用的是精选的Java 8版本。</a></p><p id="f4e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在我们创建了正则表达式之后，我们需要对获取它们所需的信息进行分组，</p><p id="e721" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要的是属性名和值，所以只需将它们的正则表达式放入( )中，如下所示</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="98bd" class="lg lh iq lc b gy li lj l lk ll">&lt;\\w+ name=<strong class="lc ir">\"</strong>(\\w+)<strong class="lc ir">\"</strong>&gt;(.+)&lt;/\\w+&gt;</span></pre><p id="ee0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，属性名称将位于组号1中，因为组号0包含与组号2上的完整正则表达式和属性值相匹配的完整文本，</p><p id="d82a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了首先获得信息，我们将编译这个模式</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3663" class="lg lh iq lc b gy li lj l lk ll">val pattern = Pattern.compile(attributePattern)</span></pre><p id="daa5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们将得到匹配我们模式的每个子串，并得到2个组1和2</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="fe36" class="lg lh iq lc b gy li lj l lk ll">val matcher = pattern.matcher(text) <br/>while (matcher.find()) {<br/>    val attributeName = matcher.group(1)<br/>    val attributeValue = matcher.group(2)<br/>    println("$attributeName $attributeValue")<br/>}</span></pre><p id="ccb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！！而输出正是我们想要的。</p><p id="8b9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用按名称分组，您只需为每个组添加一个名称，只需添加？<name>比如在你的团队内部。</name></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5fa0" class="lg lh iq lc b gy li lj l lk ll">&lt;\\w+ name=<strong class="lc ir">\"</strong>(?&lt;KEY&gt;\\w+)<strong class="lc ir">\"</strong>&gt;(?&lt;VALUE&gt;.+)&lt;/\\w+&gt;</span></pre><p id="a0bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组名必须是以字母开头的字母数字序列，并且不能用相同的名称命名两个组。</p><p id="d8d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将使用键和值，而不是像1，2那样按索引分组，</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="fcd2" class="lg lh iq lc b gy li lj l lk ll">while (matcher.find()) {<br/>    val attributeName = matcher.group("KEY")<br/>    val attributeValue = matcher.group("VALUE")<br/>    println("$attributeName $attributeValue")<br/>}</span></pre><p id="0dbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会得到相同的输出。</p><p id="ff7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在我们了解了什么是命名组以及如何使用它之后，是时候进行反向引用了。</p><p id="26c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，反向引用用于匹配先前由一个组匹配的相同文本，例如，假设我们想检查一个数字是否只包含一个重复的数字，如1，22，333，444，那么我们如何使用Regex，</p><p id="d23f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用反向引用，首先我们需要定义一个组，在这种情况下，我们的组是一个数字(？<digit> \\d)，因此这将正确匹配第一个数字，然后我们将使用反向引用来检查所有其他数字是否与第一个数字的匹配文本相同，为此，您可以使用' \k <digit>'或通过类似' \\1 '的索引。</digit></digit></p><p id="624e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的完整正则表达式将是“(？<digit> \d)\\k <digit> * "或“(\\d)\\1*”这意味着我们期望一个数字与一个组数字和零个或多个与该组匹配的相同数字，完整的代码将是这样的</digit></digit></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d141" class="lg lh iq lc b gy li lj l lk ll">fun main() {     <br/>    val repeatedDigitRegex = "(?&lt;DIGIT&gt;\\d)\\k&lt;DIGIT&gt;*"<br/>    val pattern = Pattern.compile(repeatedDigitRegex)</span><span id="7bd1" class="lg lh iq lc b gy lm lj l lk ll">    println(pattern.matcher("1").matches())<br/>    println(pattern.matcher("22").matches())<br/>    println(pattern.matcher("333").matches())<br/>    println(pattern.matcher("4444").matches())</span><span id="e79a" class="lg lh iq lc b gy lm lj l lk ll">    println(pattern.matcher("10").matches())<br/>    println(pattern.matcher("21").matches())<br/>    println(pattern.matcher("101").matches())<br/>}</span></pre><p id="624d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出将是</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="e608" class="lg lh iq lc b gy li lj l lk ll">true true true true false false false</span></pre><p id="510a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这个特性可以产生很多想法，例如检查HTML是否由相同的标签开始和结束，检查是否有重复的内容等等</p><p id="c6d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">matcher类中有另一个有用的方法叫做replaceAll，它可以使用引用将当前匹配的子字符串替换为任何字符串或组匹配的文本，例如在最后一个示例中，如果我们想用其中一个数字替换所有重复的数字，那么我们需要用它的第一个组替换regex。</p><p id="a762" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们将使用replaceAll并通过一个值$1传递组引用，而不是使用matches，代码如下所示。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d0f5" class="lg lh iq lc b gy li lj l lk ll">println(pattern.matcher("2222").replaceAll("$1"))</span></pre><p id="200a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打印输出将是2</p><p id="90f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你喜欢这篇文章，如果你想更多地了解这个话题，这里有一些有用的资源。</p><ul class=""><li id="186b" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated"><a class="ae kw" href="https://www.regular-expressions.info" rel="noopener ugc nofollow" target="_blank"> regular-expressions.info </a>网站上有很多不错的教程和信息</li><li id="a221" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">来自Jan Goyvaerts的regular-expressions.info/books regex图书评论</li><li id="180f" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated"><a class="ae kw" href="https://www.youtube.com/watch?v=c9HbsUSWilw" rel="noopener ugc nofollow" target="_blank">正则表达式</a>:从编码列车通道捕获分组</li></ul><p id="cfcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在:<a class="ae kw" href="https://github.com/amrdeveloper" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> GitHub </strong> </a>，<a class="ae kw" href="https://www.linkedin.com/in/amrdeveloper/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> LinkedIn </strong> </a>，<a class="ae kw" href="https://twitter.com/amrdeveloper" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Twitter </strong> </a>上找到我。</p><p id="68b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">享受编程😋。</p></div></div>    
</body>
</html>