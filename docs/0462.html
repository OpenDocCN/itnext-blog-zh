<html>
<head>
<title>Using Service Worker as an auth relay</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用服务人员作为身份验证中继</h1>
<blockquote>原文：<a href="https://itnext.io/using-service-worker-as-an-auth-relay-5abc402878dd?source=collection_archive---------3-----------------------#2018-03-13">https://itnext.io/using-service-worker-as-an-auth-relay-5abc402878dd?source=collection_archive---------3-----------------------#2018-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="42a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fusing-service-worker-as-an-auth-relay-5abc402878dd" rel="noopener ugc nofollow" target="_blank"> <em class="km">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="b82f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我偶尔听说服务人员被用于缓存、推送通知或后台同步。很长一段时间，我一直在想，他们没有带来任何新的东西来补偿他们的复杂性。那是直到最近。</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="59f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在通过<em class="km">授权头</em>交换<a class="ae kl" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank"> JWT </a>的单页应用程序上工作。在AngularJS中添加这种功能的标准方式是实现一个拦截器:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="e872" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们这样做时，使用<em class="km"> $http </em>执行的每个请求都将透明地添加授权。</p><p id="c936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于Ajax来说，这是一个很好的解决方案，但是有时我们也需要下载文件。这是可能的，但是很痛苦:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="5101" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数时候，我对这样的解决方案还满意，但我内心深处有一种想法，试图以增加复杂性为代价让它变得更好。我心目中的最终目标是让下载文件变得简单，就像:</p><pre class="ku kv kw kx gt lb lc ld le aw lf bi"><span id="80ac" class="lg lh iq lc b gy li lj l lk ll">&lt;a href='/api/file'&gt;Download file&lt;/a&gt;</span></pre><p id="3f8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">堆上没有任何响应缓冲。</p><p id="784c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是如何做到这一点的想法:</p><ul class=""><li id="246d" class="lm ln iq jp b jq jr ju jv jy lo kc lp kg lq kk lr ls lt lu bi translated">我们可以使用<em class="km">授权服务</em>来持有<em class="km"> JWT </em>并执行登录和注销</li><li id="990c" class="lm ln iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">服务人员将拦截对<em class="km"> /api </em>的所有请求，并动态添加报头</li></ul><p id="869e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">会不会很难实施？让我们来了解一下！</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><h1 id="4592" class="ma lh iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">Webpack配置(3.11.0版)</h1><p id="e34d" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">服务人员不同于我们在网上找到的大多数资源。这甚至在构建配置中也能体现出来。对于所有资产，我们应该尝试添加散列来使缓存破坏变得自然，但是对于服务人员，我们应该很少这样做。为什么？</p><p id="e459" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在某个时候，我们决定实现离线第一页和缓存<em class="km">index.html</em>，我们将永远不会获取一个新的服务工作者，因为页面将指向它的旧版本。因此，最好保持相同的网址为软件和浏览器会检查自己，如果没有更新的版本。除非在过去24小时内已经进行了检查，否则在导航到软件或功能事件(推送、同步和获取)范围内的页面时会发生这种情况。</p><p id="c450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免服务工作者文件名中的散列，构建它们的标准方式依赖于外部插件:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><h1 id="6c72" class="ma lh iq bd mb mc nc me mf mg nd mi mj mk ne mm mn mo nf mq mr ms ng mu mv mw bi translated">服务行业人员</h1><p id="a5d3" class="pw-post-body-paragraph jn jo iq jp b jq mx js jt ju my jw jx jy mz ka kb kc na ke kf kg nb ki kj kk ij bi translated">让我们直接跳到代码:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="9ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经完成了基本的设置，我们可以专注于身份验证和拦截请求。这部分可以分为三个主要模块:</p><ul class=""><li id="d558" class="lm ln iq jp b jq jr ju jv jy lo kc lp kg lq kk lr ls lt lu bi translated">我们的<em class="km"> fetchHandler </em>模块的默认导出将检查目标资源是否被<em class="km"> API </em>公开</li><li id="9cf6" class="lm ln iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><em class="km"> getAuthTokenHeader </em>方法将与页面中执行的js通信，以获取当前令牌</li><li id="0fcc" class="lm ln iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><em class="km"> getResponse </em>将使用授权令牌丰富请求并获取响应</li></ul><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="047c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一部分是在页面中注册<em class="km">服务人员</em>并响应<em class="km"> sw: </em>发送的<em class="km"> getAuthTokenHeader </em>动作</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="109a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以检查网络图来验证我们服务人员的行为。让我们看一下整个流程，从使用API进行身份验证到文件下载:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ca"><img src="../Images/0793bd0efd13f2369d638747e01011fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wweUqCosTRn4XBOmOfLXuA.png"/></div></div></figure><p id="8750" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个请求是由页面中执行的javascript创建的。我们可以通过查看启动器列来发现这一点。</p><p id="6acf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大齿轮总是表示请求是由服务人员提出的。在我们的例子中，它是日志请求的转发(参见复制的<em class="km"> auth </em>请求)和最终的文件下载。我们没有将<em class="km"> csv </em>端点作为服务工作人员转发的浏览器导航事件的额外请求，该事件由点击html链接触发。</p><p id="be56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天到此为止。如果你在寻找更多关于服务人员的信息，我建议你看看<a class="ae kl" href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle" rel="noopener ugc nofollow" target="_blank">网络基础</a>和<a class="ae kl" href="https://serviceworke.rs/" rel="noopener ugc nofollow" target="_blank">https://serviceworke.rs/</a>的现成食谱。</p><p id="587f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><blockquote class="nn no np"><p id="3184" class="jn jo km jp b jq jr js jt ju jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj kk ij bi translated">本文的所有代码都可以在我的Github repo<a class="ae kl" href="https://github.com/bartekbp/blog/tree/master/service-worker-auth" rel="noopener ugc nofollow" target="_blank">https://Github . com/bartekbp/blog/tree/master/service-worker-auth</a>中找到。</p></blockquote></div></div>    
</body>
</html>