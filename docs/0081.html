<html>
<head>
<title>How to MongoDB in C# — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在C#中使用MongoDB第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-mongodb-in-c-part-1-ac05e592a3e7?source=collection_archive---------1-----------------------#2016-11-14">https://itnext.io/how-to-mongodb-in-c-part-1-ac05e592a3e7?source=collection_archive---------1-----------------------#2016-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="24f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“如何在C#中使用MongoDB”将是一个由多个部分组成的博客文章系列:</p><ol class=""><li id="ccd1" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">如何在C#中使用MongoDB第一部分</strong></li><li id="909f" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae kz" href="https://medium.com/@stasrivkin/how-to-mongodb-in-c-part-2-49106e643ca9" rel="noopener"> <strong class="jp ir">如何在C#中使用MongoDB第二部分</strong> </a></li><li id="f9bd" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><em class="la">如何在C#中使用MongoDB第三部分</em></li><li id="41ac" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><em class="la">如何在C#中使用MongoDB第四部分</em></li></ol><p id="a56a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个新项目都有新的惊喜和冒险，但是想象一下当我意识到我是将与<a class="ae kz" href="https://www.mongodb.com/?_ga=1.153986620.560290164.1470766224" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>一起工作的受害者时我的惊讶。作为一名熟悉SQL server的C#开发人员，我当时想:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/94e6d51ee1c1f6ba70b950e849c92603.png" data-original-src="https://miro.medium.com/v2/0*aWLscPHNYUtSin2t.gif"/></div></figure><p id="8fd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此..当这些消息被消化后，我做了下一个最好的事情——谷歌“MongoDB”(也暴饮暴食😉)</p><p id="a942" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个小时后，我对我的发现感到沮丧。有很多关于如何使用旧的驱动程序的例子，但是很少有使用新的 C#驱动程序API的例子。</p><p id="7fcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我决定写这个关于“如何在C#中使用MongoDB”的博客系列文章，以省去我旅途中令人沮丧的部分。</p><p id="17ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章将简单地谈谈如何设置MongoDB等。(有很多关于这个主题的教程)。但是，在接下来的文章中，我将重点关注MongoDB的CRUD API必须提供的不同的方式，包括标准的和高级的(称为聚合FW T21)。为了获得有趣的东西，我们必须设置我们的开发环境。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="e91f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">介绍</h1><p id="ece5" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">考虑以下JSON结构:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7f6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个JSON结构将代表我们在DB中的“开发人员”对象(实际上，MongoDB将对象存储为二进制JSON的<a class="ae kz" href="https://www.mongodb.com/json-and-bson" rel="noopener ugc nofollow" target="_blank"> BSON </a>对象，但这是另一篇博文的主题)。</p><p id="bedf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在MongoDB中，在C# API中，一切都被认为是一个文档(或者准确地说，是一个<a class="ae kz" href="http://api.mongodb.com/csharp/current/html/T_MongoDB_Bson_BsonDocument.htm" rel="noopener ugc nofollow" target="_blank"> BsonDocument </a>)。稍后，我将解释我们的强类型开发人员类和MongoDB的BsonDocument之间的关联。</p><p id="b5e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们对应的JSON对象的C#类表示:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="03ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是开发者对象的样子:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/73d2d7ac26aea750c64881d8b40b1123.png" data-original-src="https://miro.medium.com/v2/format:webp/0*DG_rrFmpTQKae7e0.png"/></div></figure><p id="95fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个后续系列中，我们将使用各种最好的OzCode🙂</p><p id="8534" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用MongoDB的CRUD操作来处理大量(我的意思是，<strong class="jp ir">大量</strong>)数据，因此我们最好用适当的调试工具来装备自己。</p><p id="4d5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将演示如何使用<a class="ae kz" href="http://o.oz-code.com/features#search" rel="noopener ugc nofollow" target="_blank">搜索特性</a>搜索检索到的对象集合，如何使用<a class="ae kz" href="http://o.oz-code.com/features#filter" rel="noopener ugc nofollow" target="_blank">集合过滤</a>过滤它们并仅显示满足特定标准的对象，甚至使用<a class="ae kz" href="https://vimeo.com/185820705" rel="noopener ugc nofollow" target="_blank">导出</a>导出大量数据(参见从26:30分钟开始的操作)</p><p id="d225" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的截图中，我正在使用OzCode的出色的<a class="ae kz" href="http://o.oz-code.com/features#reveal" rel="noopener ugc nofollow" target="_blank"> Reveal特性</a>来更好地可视化调试体验，否则我需要用<a class="ae kz" href="https://msdn.microsoft.com/en-us/library/system.diagnostics.debuggerdisplayattribute%28v=vs.110%29.aspx" rel="noopener ugc nofollow" target="_blank">DebuggerDisplayAttribute</a>来包装我的POCO对象，甚至更糟，使用<a class="ae kz" href="https://msdn.microsoft.com/en-us/library/system.diagnostics.debuggertypeproxyattribute%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" rel="noopener ugc nofollow" target="_blank">DebuggerTypeProxyAttribute</a>来构建调试器代理。(<em class="la">开发者</em>类调试显示可通过选择相关星号进行配置)</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="df99" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">MongoDB的对象映射</h1><p id="25ff" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">有一堆新东西你可能想知道。</p><p id="50c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到，我不需要将我的C#类属性与JSON对象匹配，MongoDB在其存储和检索操作中提供了两种不同的方法来实现这一点:</p><ol class=""><li id="424e" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">"<strong class="jp ir">自动</strong>"-基于属性。还有一种使用<a class="ae kz" href="http://api.mongodb.com/csharp/current/html/T_MongoDB_Bson_Serialization_Conventions_ConventionPack.htm" rel="noopener ugc nofollow" target="_blank"> ConventionPack </a>定义系统范围通用约定的方法</li><li id="5803" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">“<strong class="jp ir">手动</strong>——我们可以使用<a class="ae kz" href="http://api.mongodb.com/csharp/current/html/T_MongoDB_Bson_Serialization_BsonClassMap.htm" rel="noopener ugc nofollow" target="_blank"> BsonClassMap </a>、<a class="ae kz" href="http://api.mongodb.com/csharp/current/html/M_MongoDB_Bson_Serialization_BsonClassMap_RegisterClassMap__1_1.htm" rel="noopener ugc nofollow" target="_blank"> RegisterClassMap </a>静态方法来配置每个属性</li></ol><h1 id="8eec" class="lq lr iq bd ls lt mv lv lw lx mw lz ma mb mx md me mf my mh mi mj mz ml mm mn bi translated">使用自动映射</h1><p id="be6f" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">关于这些属性:</p><ul class=""><li id="807d" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk na kr ks kt bi translated"><a class="ae kz" href="http://api.mongodb.com/csharp/current/html/T_MongoDB_Bson_Serialization_Attributes_BsonIdAttribute.htm" rel="noopener ugc nofollow" target="_blank"> BsonId </a>，让您指定哪个属性将作为文档的<strong class="jp ir">唯一</strong> ID。</li><li id="9a07" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk na kr ks kt bi translated"><a class="ae kz" href="http://api.mongodb.com/csharp/current/html/T_MongoDB_Bson_Serialization_Attributes_BsonElementAttribute.htm" rel="noopener ugc nofollow" target="_blank"> BsonElementAttribute </a>，让您调整属性的名称，并告诉MongoDB它应该存储在JSON中的哪个属性键下。</li></ul><p id="efb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于唯一ID属性，有几件事值得一提:</p><p id="082b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> &gt; </strong> MongoDB将<strong class="jp ir"> always </strong>把你的ID属性作为“_id”存储在DB里面，不能更改。<em class="la">试图使用BsonElementAttribute更改名称将被忽略。</em></p><p id="1bf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> &gt; </strong>您不需要指定一个属性作为惟一ID，MongoDB会发现您缺少一个ID属性，并自动为您生成一个基于<a class="ae kz" href="https://docs.mongodb.com/v3.2/reference/method/ObjectId/" rel="noopener ugc nofollow" target="_blank"> ObjectId </a>的“_id”。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5f44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="la">在这里你可以看到，我们的</em> <strong class="jp ir"> <em class="la">开发者</em> </strong> <em class="la">类丢失了它的ID属性(树中的最后一个属性丢失了)。</em></p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/e4a77a9f2170c905fab207d3b39f05c2.png" data-original-src="https://miro.medium.com/v2/format:webp/0*SCldED1Xmk4IGuuP.png"/></div></figure><p id="1306" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用MongoDB的客户端(随安装一起提供)来检索插入的<em class="la">开发人员</em>对象。虽然我们没有添加ID属性，但是您可以清楚地看到MongoDB已经为我们添加了它:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/8cf2df1d6a786a3a0ffabef1893eb166.png" data-original-src="https://miro.medium.com/v2/format:webp/0*S_ZNu4yHUaB63ML3.png"/></div></figure><blockquote class="nb nc nd"><p id="a179" class="jn jo la jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated">请注意——当将这个对象检索回C#应用程序时，MongoDB将抛出一个异常，告诉您缺少一个ID属性。如果您决定为您的应用程序选择这个策略，您必须用<a class="ae kz" href="http://api.mongodb.com/csharp/current/html/T_MongoDB_Bson_Serialization_Attributes_BsonIgnoreExtraElementsAttribute.htm" rel="noopener ugc nofollow" target="_blank">bsonignoreextralements</a>标记您的类</p></blockquote><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e60e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ID属性可以是复杂类型——这是MongoDB不会自动为您生成ID并使用您的类/结构的默认值的情况之一</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="ab gu cl lg"><img src="../Images/67e9a9b1744c3cdfb999040c0d65ebc6.png" data-original-src="https://miro.medium.com/v2/format:webp/0*lewK_6KnVjm-iXoM.png"/></div></figure><p id="edf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你决定用ID属性来修饰你的类，你没有义务使用MongoDB的ObjectId结构。实际上，ID可以是不同的类型，比如string、int甚至GUID。需要记住的主要事情是，MongoDB为它的“_id”字段分配了一个类型为<a class="ae kz" href="https://docs.mongodb.com/manual/core/index-unique/" rel="noopener ugc nofollow" target="_blank"> Unique </a>的<a class="ae kz" href="https://docs.mongodb.com/manual/indexes/" rel="noopener ugc nofollow" target="_blank">索引</a>。因此，请确保添加一个具有唯一ID值的条目，因为与备注#3相同，它将使用ID类型的默认值(GUID类型除外——MongoDB将自动为其生成值),并且当试图添加一个具有相同默认ID值的条目时，将抛出一个异常。</p><p id="c936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> &gt; </strong>您可以使用类型为<a class="ae kz" href="http://api.mongodb.com/csharp/current/html/T_MongoDB_Bson_Serialization_IIdGenerator.htm" rel="noopener ugc nofollow" target="_blank"> IIdGenerator </a>的IdGenerator作为BsonIdAttribute参数。如果您不想使用ObjectId结构，您可以利用一些内置的IdGenerator，例如<a class="ae kz" href="http://api.mongodb.com/csharp/current/html/T_MongoDB_Bson_Serialization_IdGenerators_StringObjectIdGenerator.htm" rel="noopener ugc nofollow" target="_blank">stringobjectdgenerator</a>。将此类型传递给BsonIdAttribute，会将ObjectId的字符串表示形式存储到Id属性中。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b3bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的工作方式是，对于MongoDB试图插入的每个文档，它会将ID值传递给<em class="la"> IsEmpty </em>方法，返回<em class="la"> true </em>会将文档传递给<em class="la"> GenerateId </em>方法，该方法接受一个容器(负责文档的CRUD操作、amount other stuff的集合)和文档本身。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="c229" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">MongoDB的自动约定</h1><p id="6055" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">最后一件事——我之前提到过，我们可以使用<a class="ae kz" href="http://api.mongodb.com/csharp/current/html/T_MongoDB_Bson_Serialization_Conventions_ConventionPack.htm" rel="noopener ugc nofollow" target="_blank"> ConventionPack </a>来一般化我们的应用程序。</p><p id="0e10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑下面的例子:您的团队决定所有的属性名称都以小写形式存储，并且在MongoDB内部的每个大写字母之间用下划线隔开(<em class="la"> CompanyName </em>变成<strong class="jp ir"> <em class="la"> company_name </em> </strong>)。这种类型的决策需要您检查每个文档及其属性，并应用命名约定。如果你重构你的类呢？如果你的团队制定了一个新的惯例，会怎么样？</p><p id="6205" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸好(！！)MongoDB提供了一个基于约定的API。</p><p id="87be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以创建一个<em class="la"> ConventionPack </em>实例，它基本上是一个<a class="ae kz" href="http://api.mongodb.com/csharp/2.2/html/T_MongoDB_Bson_Serialization_Conventions_IConvention.htm" rel="noopener ugc nofollow" target="_blank"> IConvention </a>类型的集合(MongoDB为您提供了广泛的预定义约定，您可以在<a class="ae kz" href="http://api.mongodb.com/csharp/2.2/html/N_MongoDB_Bson_Serialization_Conventions.htm" rel="noopener ugc nofollow" target="_blank">这里</a>找到)。然后，您可以添加任意多的约定，并在<em class="la">convention registry中注册<em class="la"> ConventionPack </em>。注册</em>静态方法。</p><p id="fe3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该方法接受<strong class="jp ir"> 3参数</strong>:</p><ol class=""><li id="13f3" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">您的会议包的名称</li><li id="bf65" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">要使用的<em class="la">约定包</em></li><li id="25fa" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">一个<em class="la"> Func &lt;类型，bool &gt; </em>过滤器，该约定不适用于哪些类型(只需传递一个"<em class="la"> t = &gt; true </em>"来应用于所有类型)</li></ol><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cc8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我决定基于<a class="ae kz" href="http://api.mongodb.com/csharp/2.2/html/T_MongoDB_Bson_Serialization_Conventions_IMemberMapConvention.htm" rel="noopener ugc nofollow" target="_blank">imembermapconvention</a>(从<em class="la"> IConvention </em>派生)实现我之前描述的两个约定，并将它们仅应用于<em class="la"> Developer </em>类。现在我们的<em class="la">开发者</em>类看起来更干净了:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="6b37" class="lq lr iq bd ls lt mv lv lw lx mw lz ma mb mx md me mf my mh mi mj mz ml mm mn bi translated">哦，对了，还有手工操作的方式</h1><p id="8feb" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">这是写给所有喜欢打字的程序员的。正如您所想象的，任何可以用自动化(基于属性)方式完成的事情都可以用手工方式完成。这部分我就不多说了，因为这本手册有一个相当不错的教程，教你如何用手动方式工作(和自动化方式，以一种更详细的方式)。</p><p id="df4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以…到目前为止，我们已经涵盖了以下最基本的内容:</p><ol class=""><li id="660c" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">JSON对象和它的孪生兄弟C#文档之间的关系。</li><li id="2352" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">如何使用属性设置和定制您的类</li><li id="f0ec" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">ID属性突出显示—从MongoDB的角度来看</li></ol></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="4829" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">下一步是什么</h1><p id="d6b0" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在我们深入MongoDB的过程中，仍然有很多内容需要介绍，在下一篇文章和以后的文章中，我将介绍以下内容:</p><ul class=""><li id="3c5f" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk na kr ks kt bi translated">如何设置您的数据库连接</li><li id="3dd8" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk na kr ks kt bi translated">如何实例化MongoClient、MongoDatabase和MongoCollection类</li><li id="bf2c" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk na kr ks kt bi translated">使用OzCode的<a class="ae kz" href="http://o.oz-code.com/features#search" rel="noopener ugc nofollow" target="_blank">搜索、</a> <a class="ae kz" href="http://o.oz-code.com/features#filter" rel="noopener ugc nofollow" target="_blank">收集过滤器</a>和导出特征分析CRUD操作结果</li></ul><p id="defa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与此同时，我想到的任何其他东西，敬请关注..</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h2 id="55b9" class="nh lr iq bd ls ni nj dn lw nk nl dp ma jy nm nn me kc no np mi kg nq nr mm ns bi translated"><strong class="ak">博客帖子</strong>:</h2><ol class=""><li id="a77a" class="kl km iq jp b jq mo ju mp jy nt kc nu kg nv kk kq kr ks kt bi translated"><strong class="jp ir">如何在C#中使用MongoDB第一部分</strong></li><li id="e26c" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae kz" href="https://medium.com/@stasrivkin/how-to-mongodb-in-c-part-2-49106e643ca9" rel="noopener"> <strong class="jp ir">如何在C#中使用MongoDB第二部分</strong> </a></li><li id="a1c4" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><em class="la">如何在C#中使用MongoDB第三部分</em></li><li id="2256" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><em class="la">如何在C#中使用MongoDB第四部分</em></li></ol></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="2fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="la">原载于2016年11月14日</em><a class="ae kz" href="https://medium.com/@stasrivkin/how-to-mongodb-in-c-part-1-e778b5dc29ce" rel="noopener"><em class="la">blog.oz-code.com</em></a><em class="la">。</em></p></div></div>    
</body>
</html>