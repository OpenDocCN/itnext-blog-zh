<html>
<head>
<title>Introduction to Web Components — Part I Custom Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件简介—第一部分自定义元素</h1>
<blockquote>原文：<a href="https://itnext.io/introduction-to-web-components-part-i-custom-elements-4de6713cef9d?source=collection_archive---------5-----------------------#2019-08-15">https://itnext.io/introduction-to-web-components-part-i-custom-elements-4de6713cef9d?source=collection_archive---------5-----------------------#2019-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="42df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">HTML</code>规范描述了许多不同的标签，这些标签可用于构建网页或应用程序。这些标签定义了具有功能或用户界面意图的元素。<code class="fe ko kp kq kr b">head</code>和<code class="fe ko kp kq kr b">body</code>标签都是传统的<code class="fe ko kp kq kr b">HTML</code>布局。借助于<code class="fe ko kp kq kr b">link</code>、<code class="fe ko kp kq kr b">script</code>、<code class="fe ko kp kq kr b">title</code>和<code class="fe ko kp kq kr b">meta</code>标签等，在<code class="fe ko kp kq kr b">head</code>部分中声明了不同的元定义和依赖关系。另一方面，<code class="fe ko kp kq kr b">body</code>元素用如下元素定义了文档的结构:</p><ul class=""><li id="8287" class="ks kt it js b jt ju jx jy kb ku kf kv kj kw kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">div</code>和<code class="fe ko kp kq kr b">span</code>有时分别作为<code class="fe ko kp kq kr b">block</code>或<code class="fe ko kp kq kr b">inline</code>显示元素的基础</li><li id="44ec" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">p</code>描述包含任何文本的段落</li><li id="ee2a" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">h1</code>到<code class="fe ko kp kq kr b">h6</code>标签定义了文档中不同的标题级别</li><li id="643f" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">button</code>可作为用户动作，即在<code class="fe ko kp kq kr b">form</code>内部或用于<code class="fe ko kp kq kr b">navigation</code>目的</li><li id="75cb" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">标签有助于定位输入用户数据的字段</li><li id="95ca" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">select</code>和<code class="fe ko kp kq kr b">input</code>元素用于<code class="fe ko kp kq kr b">form</code>字段的描述。为这些标签添加一个<code class="fe ko kp kq kr b">attribute</code>可以定义验证规则、大小或可能的输入数据类型，如数字、日期或密码。自从<code class="fe ko kp kq kr b">HTML5</code>标准引入以来，开发人员可以使用更具体的标签，比如:</li><li id="7d16" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">audio</code>和<code class="fe ko kp kq kr b">video</code>元素定位并提供多媒体内容</li><li id="d253" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">section</code>、<code class="fe ko kp kq kr b">article</code>、<code class="fe ko kp kq kr b">nav</code>、<code class="fe ko kp kq kr b">header</code>、<code class="fe ko kp kq kr b">footer</code>等很多标签勾勒出了结构，为文档增加了更多的语义。这个列表并不完整，它只是显示了<code class="fe ko kp kq kr b">FrontEnd</code>开发者构建网页的不同可能性。</li></ul><blockquote class="lg"><p id="7a38" class="lh li it bd lj lk ll lm ln lo lp kn dk translated">如果一个项目需要一个行为不同的元素呢？</p></blockquote><p id="a32d" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">例如，它可以是一个<code class="fe ko kp kq kr b">tab</code>元素来演示关于所选项目的不同内容，或者是一个<code class="fe ko kp kq kr b">expand</code>元素来显示文本的额外内容，等等。像<code class="fe ko kp kq kr b">Vue</code>、<code class="fe ko kp kq kr b">React</code>和<code class="fe ko kp kq kr b">Angular</code>这样的现代库和框架围绕<code class="fe ko kp kq kr b">DOM</code>引入了许多抽象，以简化定制元素的概念和用法。它们都将应用程序分解为组件。它们定义了如何创建组件、如何将组件插入到文档中、如何相互交互以及如何呈现组件的规则。事实上，<code class="fe ko kp kq kr b">Vue</code>和<code class="fe ko kp kq kr b">React</code>库内部都使用了一个<code class="fe ko kp kq kr b">Virtual DOM </code>算法，它创建了一个与真正的<code class="fe ko kp kq kr b">HTML</code>结构并行的结构。每当框架要更新视图时，首先<code class="fe ko kp kq kr b">Virtual DOM</code>实现会比较需要更新的内容，然后再对真正的<code class="fe ko kp kq kr b">DOM</code>应用任何更改。像<code class="fe ko kp kq kr b">jQuery</code>这样的老库通过将<code class="fe ko kp kq kr b">JavaScript</code>逻辑应用于<code class="fe ko kp kq kr b">HTML</code>结构来解决这种情况。通常，元素被用作<code class="fe ko kp kq kr b">jQuery</code>插件的入口点，插件包装它，添加额外的元素，绑定事件监听器，并附加一个业务逻辑。同时，文档的结构并不总是代表开发者的意图——神奇的事情发生在<code class="fe ko kp kq kr b">JavaScript</code>库内部。然而，这种方法适用于较小的网站，页面越大，维护和扩展就越困难。</p><blockquote class="lg"><p id="3452" class="lh li it bd lj lk lv lw lx ly lz kn dk translated">现在有一种本地的方式来实现元素的定制— <code class="fe ko kp kq kr b">Web Components</code></p></blockquote><p id="a3e7" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated"><code class="fe ko kp kq kr b">Web Components </code>规范是Web标准的通用名称，其目的是将基于浏览器的应用程序表示为可重用元素的层次结构。这个想法是让开发人员能够定义他们自己的组件，他们可以封装状态、行为、风格等。组件可以相互通信，对于浏览器环境来说是“自然”的。可以通过<code class="fe ko kp kq kr b">HTML</code>声明将元素添加到页面中，这样文档的结构可以更一致地表示。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/fd2b00561dc97c81fc674f5bc48d41ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*geSNRrK8K9qcpuiDISH80g.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">Web组件</figcaption></figure><h1 id="cdac" class="mm mn it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">自定义元素</h1><p id="1cbc" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated"><code class="fe ko kp kq kr b">Custom Elements</code>规范允许开发者定义他们自己的元素，几乎与内置元素没有区别。事实上，这个过程甚至可以反过来，最终原生元素应该是在浏览器引擎中定义的<code class="fe ko kp kq kr b">Custom Elements</code>，就像<code class="fe ko kp kq kr b">FrontEnd</code>开发人员在应用程序中所做的那样。</p><pre class="mb mc md me gt np kr nq nr aw ns bi"><span id="3908" class="nt mn it kr b gy nu nv l nw nx">&lt;select&gt;<br/>  &lt;option value="1"&gt;1&lt;/option&gt;<br/>  &lt;option value="2"&gt;2&lt;/option&gt;<br/>&lt;/select&gt;</span><span id="5367" class="nt mn it kr b gy ny nv l nw nx">&lt;!-- What if we want multiple select? --&gt;</span><span id="edda" class="nt mn it kr b gy ny nv l nw nx">&lt;multiple-select&gt;<br/>  &lt;option value="1"&gt;1&lt;/option&gt;<br/>  &lt;option value="2"&gt;2&lt;/option&gt;<br/>&lt;/multiple-select&gt;</span></pre><p id="dd59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">浏览器中没有<code class="fe ko kp kq kr b">multiple-select</code>元素，但是有一个会很有用。所以<code class="fe ko kp kq kr b">Custom Element</code>可以在页面内的<code class="fe ko kp kq kr b">JavaScript</code>代码中定义。</p><pre class="mb mc md me gt np kr nq nr aw ns bi"><span id="ef58" class="nt mn it kr b gy nu nv l nw nx">&lt;script&gt;<br/>class HelloWorldElement extends HTMLElement {<br/>  connectedCallback() {<br/>    this.textContent = "Hello World"<br/>  }<br/>}<br/>customElements.define('hello-world-element', HelloWorldElement);<br/>&lt;/script&gt;</span><span id="22af" class="nt mn it kr b gy ny nv l nw nx">&lt;hello-world-element&gt;&lt;/hello-world-element&gt;</span></pre><p id="b943" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码中有一个新的<code class="fe ko kp kq kr b">HelloWorldElement</code>类定义。它继承自基类<code class="fe ko kp kq kr b">HTMLElement</code>，并在初始化后添加文本。<code class="fe ko kp kq kr b">connectedCallback</code>是一个生命周期钩子，当一个元素被添加到文档中时执行。它是生命周期系统的一部分，这将在后面描述。在定义了类本身之后，重要的事情发生了- <code class="fe ko kp kq kr b">customElements.define()</code>被标签名和<code class="fe ko kp kq kr b">HelloWorldElement</code>类一起调用。<code class="fe ko kp kq kr b">HelloWorldElement</code>注册在<code class="fe ko kp kq kr b">customElements</code>中——页面上所有元素的注册表。<code class="fe ko kp kq kr b">customElements</code>是<code class="fe ko kp kq kr b">CustomElementRegistry</code>类的实例，为每个<code class="fe ko kp kq kr b">HTML</code>文档公开。这是每个页面的唯一对象，或者更准确地说，是每个页面的<code class="fe ko kp kq kr b">window</code>实例的唯一对象。规范还将它与每个<code class="fe ko kp kq kr b">window</code>名称空间的<code class="fe ko kp kq kr b">HTMLElement</code>类特异性相关联。定义完成后，可以用任何可能的方式创建<code class="fe ko kp kq kr b">HelloWorldElement </code>元素。</p><p id="b055" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要么使用<code class="fe ko kp kq kr b">JavaScript</code>文档<code class="fe ko kp kq kr b">createElement()</code>方法，要么调用最近创建的类的构造函数，然后将一个元素附加到<code class="fe ko kp kq kr b">DOM</code>结构。</p><pre class="mb mc md me gt np kr nq nr aw ns bi"><span id="8be7" class="nt mn it kr b gy nu nv l nw nx">// use createElement<br/>const helloWorld = document.createElement('hello-world-element')<br/>document.body.appendChild(helloWorld)</span><span id="0902" class="nt mn it kr b gy ny nv l nw nx">// use new<br/>const newHelloWorld = new HelloWorldElement()<br/>document.body.appendChild(newHelloWorld)</span></pre><p id="4e4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也可以在<code class="fe ko kp kq kr b">HTML</code> markdown中声明它。</p><pre class="mb mc md me gt np kr nq nr aw ns bi"><span id="061e" class="nt mn it kr b gy nu nv l nw nx">&lt;hello-world-element&gt;&lt;/hello-world-element&gt;</span></pre><p id="a6a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以任何一种选择的方式，元素都会出现在页面上，并根据它的定义来表现。</p><h1 id="64bb" class="mm mn it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">提升</h1><p id="3674" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">在最新的例子中，<code class="fe ko kp kq kr b">HTML</code>和<code class="fe ko kp kq kr b">JavaScript</code>代码是分开的，因此元素的声明可以发生在脚本评估之前、之后甚至期间。非自定义元素可以随时成为自定义元素。这包括在规范中，这个过程被称为<code class="fe ko kp kq kr b">upgrading</code>程序。当元素被添加到<code class="fe ko kp kq kr b">DOM</code>时，<code class="fe ko kp kq kr b">upgrading</code>过程被正常触发。然而，即使元素不在文档结构中，也可以通过<code class="fe ko kp kq kr b">customElements.upgrade()</code>方法强制完成。</p><h1 id="db23" class="mm mn it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">属性示例</h1><p id="8809" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">可以描述符合<code class="fe ko kp kq kr b">HTML</code>语法的属性<code class="fe ko kp kq kr b">setters / getters</code>行为。下面的代码演示了这个过程。当执行添加的<code class="fe ko kp kq kr b">attributeChangedCallback</code>和<code class="fe ko kp kq kr b">connectedCallback</code>方法时，它们检查当前元素的属性值并同步内部和外部状态——它的属性和特性。</p><pre class="mb mc md me gt np kr nq nr aw ns bi"><span id="8dee" class="nt mn it kr b gy nu nv l nw nx">class HelloWorldElement extends HTMLElement {<br/>  static get observedAttributes() {<br/>    return ['name']<br/>  }<br/>  attributeChangedCallback(name, oldValue, newValue) {<br/>    this._name = newValue<br/>  }<br/>  connectedCallback() {<br/>    this.name = this.getAttribute('name') || 'World'        <br/>  }<br/>  get name() {<br/>    return this._name<br/>  }<br/>  set name(name) {<br/>    this.setAttribute('name', name)<br/>    this.render()<br/>  }<br/>  render() {<br/>    this.textContent = `Hello ${this.name}`<br/>  }<br/>}<br/>customElements.define('hello-world-element', HelloWorldElement)</span></pre><p id="7d74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，应该为订阅属性改变事件定义静态方法<code class="fe ko kp kq kr b">observedAttributes()</code>。它应该返回要监听的名称数组。当元素被声明为</p><pre class="mb mc md me gt np kr nq nr aw ns bi"><span id="dda0" class="nt mn it kr b gy nu nv l nw nx">&lt;hello-world-element name="Alex"&gt;&lt;/hello-world-element&gt;</span></pre><p id="3a8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">文本<code class="fe ko kp kq kr b">Hello Alex</code>将被打印。以相反的方式</p><pre class="mb mc md me gt np kr nq nr aw ns bi"><span id="7a98" class="nt mn it kr b gy nu nv l nw nx">&lt;hello-world-element&gt;&lt;/hello-world-element&gt;</span></pre><p id="6a37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将输出<code class="fe ko kp kq kr b">Hello World</code>作为默认值。</p><h1 id="3304" class="mm mn it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">扩展现有元素</h1><p id="4f9a" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">很难模仿现有的浏览器元素。例如，<code class="fe ko kp kq kr b">HTML</code> <code class="fe ko kp kq kr b">button</code>有一组行为，对于新的定制元素是不可用的:</p><ul class=""><li id="aab9" class="ks kt it js b jt ju jx jy kb ku kf kv kj kw kn kx ky kz la bi translated">当<code class="fe ko kp kq kr b">tab</code>键盘事件发生时为<code class="fe ko kp kq kr b">focused</code>。这可以通过向新元素添加一个<code class="fe ko kp kq kr b">tabindex</code>属性来实现。</li><li id="029e" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">button</code>可由<code class="fe ko kp kq kr b">mouse</code>和<code class="fe ko kp kq kr b">keyboard</code>激活或“推动”。在一个表单里面，<code class="fe ko kp kq kr b">button</code>可以提交数据。需要额外的事件侦听器来添加此功能。</li><li id="a7bd" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">它有一个内部<code class="fe ko kp kq kr b">disabled</code>状态，可以通过<code class="fe ko kp kq kr b">JavaScript</code>代码实现。</li><li id="ecf8" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">它支持与可访问性相关的特性，如<code class="fe ko kp kq kr b">aria-label, role</code>等。而且只是一个<code class="fe ko kp kq kr b">button</code>。有了互动元素，比如<code class="fe ko kp kq kr b">input</code>、<code class="fe ko kp kq kr b">form</code>或<code class="fe ko kp kq kr b">img</code>，就更难了。人们很容易忘记这些内置功能，并因为不希望的和意想不到的行为而使用户不高兴。<code class="fe ko kp kq kr b">Custom Elements</code>规范提出了一种减少内置元素和新元素之间差异的方法。</li></ul><p id="0547" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，所有的例子都展示了新类型元素的创建，它们是从基类<code class="fe ko kp kq kr b">HTMLElement</code>继承的。这些类型的元素被称为“自主定制元素”。</p><p id="36b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重用不止一个基类的方法是在<code class="fe ko kp kq kr b">customElements</code>中注册新元素的类型时指定<code class="fe ko kp kq kr b">extends</code>标志。任何使用<code class="fe ko kp kq kr b">extends</code>选项的元素都被命名为“定制内置元素”。</p><p id="2bcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任何内置元素都可以通过扩展其<code class="fe ko kp kq kr b">JavaScript</code>类和使用特殊的定义参数来定制。在下面的例子中，原始的<code class="fe ko kp kq kr b">button</code>元素被一个新的<code class="fe ko kp kq kr b">MyButton</code>类继承。</p><pre class="mb mc md me gt np kr nq nr aw ns bi"><span id="0d51" class="nt mn it kr b gy nu nv l nw nx">class MyButton extends HTMLButtonElement {<br/>  constructor() {<br/>    super()<br/>    // ...<br/>  }<br/>}</span><span id="a219" class="nt mn it kr b gy ny nv l nw nx">customElements.define('my-button', MyButton, { extends: 'button' })<br/>document.createElement('button', { is: 'my-button' })</span></pre><p id="98c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然也可以在<code class="fe ko kp kq kr b">HTML</code>中声明一个元素。</p><pre class="mb mc md me gt np kr nq nr aw ns bi"><span id="e562" class="nt mn it kr b gy nu nv l nw nx">&lt;button is="my-button"&gt;Click Me!&lt;/button&gt;</span></pre><p id="fed3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，<code class="fe ko kp kq kr b">is</code>属性的存在对于定制的内置元素的创建是必要的。</p><h1 id="b788" class="mm mn it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">生命周期</h1><p id="ef54" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">在<code class="fe ko kp kq kr b">FrontEnd</code>框架和库的上下文中讨论组件时，<code class="fe ko kp kq kr b">lifecycle</code>是一个常规术语。它描述了如何创建组件、如何修改组件以及在此过程中会发生什么。</p><p id="4f23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将事件绑定到组件生命周期的某个阶段是很常见的。这些事件被附加到钩子或反应——方法上，每当这样的事件发生时就会被调用。</p><p id="ea13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当事件发生时，如果在自定义元素的类上设置了相应的方法，则会调用该方法。为任何<code class="fe ko kp kq kr b">Custom Element</code>定义的反应有:</p><ul class=""><li id="ca25" class="ks kt it js b jt ju jx jy kb ku kf kv kj kw kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">upgrade</code>反应，包括元素的<code class="fe ko kp kq kr b">constructor</code>调用。</li><li id="c1f2" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">当元素被添加到文档中时，元素的<code class="fe ko kp kq kr b">connectedCallback</code>被执行，换句话说就是<code class="fe ko kp kq kr b">connected</code>。</li><li id="2284" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">disconnectedCallback</code>与<code class="fe ko kp kq kr b">connected</code>事件的反应相反，当元素<code class="fe ko kp kq kr b">disconnects</code>或从<code class="fe ko kp kq kr b">DOM</code>中移除时发生。</li><li id="5ca9" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">当元素改变它的父文档时，就会发生<code class="fe ko kp kq kr b">adopted</code>事件。</li><li id="0ea8" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">最后，每当元素的属性改变时，包括添加和删除，都会调用<code class="fe ko kp kq kr b">attributeChangedCallback</code>。当调用它时，回调按以下顺序接收属性名、旧值和新值作为参数。</li></ul><pre class="mb mc md me gt np kr nq nr aw ns bi"><span id="62ec" class="nt mn it kr b gy nu nv l nw nx">class CustomElement extends HTMLElement {<br/>  constructor() {<br/>    super()<br/>    console.log('constructor')<br/>  }<br/>  connectedCallback() {<br/>    this.textContent = "Hello Custom Element"<br/>  }<br/>  disconnectedCallback() {<br/>    console.log('disconnectedCallback')<br/>  }<br/>  adoptedCallback() {<br/>    console.log('adoptedCallback')<br/>  }<br/>  attributeChangedCallback() {<br/>    console.log('attributeChangedCallback')<br/>  }<br/>  static get observedAttributes() {<br/>    return ['test']<br/>  }<br/>}<br/>customElements.define('hello-custom-element', CustomElement)</span><span id="f764" class="nt mn it kr b gy ny nv l nw nx">&lt;hello-custom-element test="test"&gt;&lt;/hello-custom-element&gt;</span></pre><p id="c2d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，<code class="fe ko kp kq kr b">constructor()</code>的主体以<code class="fe ko kp kq kr b">super()</code>调用开始。它执行一个父类<code class="fe ko kp kq kr b">constructor()</code>以便初始化可以继续。<code class="fe ko kp kq kr b">constructor()</code>的主体不应该修改或使用元素或其属性。它的目的是定义初始元素的状态，并附加所有需要的事件侦听器。所有额外的工作应该被推迟到<code class="fe ko kp kq kr b">connectedCallback</code>。</p><h1 id="8b46" class="mm mn it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">摘要</h1><p id="1a76" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">在这个Web组件系列的第一部分中，我们介绍了定制元素规范的基本概念。我们已经概述了如何定义、使用、升级和使用新元素的生命周期挂钩。<a class="ae nz" href="https://medium.com/@korzio/introduction-to-web-components-part-ii-shadow-dom-8d1d8e126332" rel="noopener">下一篇是关于<strong class="js iu">阴影DOM </strong>和<strong class="js iu"> HTML模板</strong>用法</a>。</p><p id="26ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一个不错的编码，并希望看到你的评论！</p></div></div>    
</body>
</html>