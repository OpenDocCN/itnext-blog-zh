<html>
<head>
<title>Dockerizing a JVM app with CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用CircleCI编写JVM应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/dockerizing-a-jvm-app-with-circleci-204fcd48d211?source=collection_archive---------3-----------------------#2019-07-15">https://itnext.io/dockerizing-a-jvm-app-with-circleci-204fcd48d211?source=collection_archive---------3-----------------------#2019-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="41d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很长一段时间以来，我一直在用特拉维斯做我的个人项目，直到大规模裁员的消息吓得我开始寻找替代方案。我听说过关于CircleCI 的好消息，所以我决定试一试。具体来说，我希望构建一个管道来完成以下任务:</p><ul class=""><li id="4c51" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">封装一个用<a class="ae ko" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>编写的<a class="ae ko" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> SpringBoot </a>应用程序作为<code class="fe ky kz la lb b">jar</code>，运行linters和之前的测试，保存测试结果。</li><li id="bf07" class="kp kq it js b jt lc jx ld kb le kf lf kj lg kn ku kv kw kx bi translated">构建一个<a class="ae ko" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>映像来运行应用程序，首先运行<a class="ae ko" href="https://serverspec.org/" rel="noopener ugc nofollow" target="_blank"> ServerSpec </a>，并将其推送到<em class="lh"> Docker </em>注册表。</li></ul><p id="291f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">按照我自己对管道的想法，我希望它快速、可视化、易于维护并且可靠地构建我的玩具应用。成功了吗？休息之后更精彩！</p><h1 id="4b5b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">绕圈跑</h1><p id="767e" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">CircleCI 有一个<a class="ae ko" href="https://circleci.com/pricing/usage/" rel="noopener ugc nofollow" target="_blank">免费计划</a>，非常适合实验，与<a class="ae ko" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> Github </a>无缝集成，这使得开始变得轻而易举。</p><p id="b2c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基础知识在<a class="ae ko" href="https://circleci.com/docs/2.0/getting-started/" rel="noopener ugc nofollow" target="_blank">他们自己的网站</a>上有深入的介绍，所以我会跳过。让我们直接进入细节。这是要实现的管道的草图:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/bc10c5252285af851c2b882f0986c0a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UAVVdSVEtWKTgLHA.jpg"/></div></div></figure><p id="8840" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将讨论一些我感兴趣的细节，以及实现部分管道的代码。TLDR:这是完整的管道。</p><h1 id="bb49" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用工作流</h1><p id="c5e1" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">工作流是CircleCI 组织工作间依赖关系的方式。在我的例子中，这只是一种说法，即一个作业应该在另一个作业之后执行，如下图所示:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/79fbe0ce6c7d9811853fee96244df72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4Mfh-aohc9QfHc2u.png"/></div></div></figure><p id="89ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来很简单，对吧？然而，这幅图并没有展示全部的真相。我使用一个过滤器将<code class="fe ky kz la lb b">docker</code>任务限制在<code class="fe ky kz la lb b">master</code>分支。工作流定义如下所示:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c023" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么有限制？嗯，我正在使用<a class="ae ko" href="https://dependabot.com/" rel="noopener ugc nofollow" target="_blank">dependent bot</a>来自动检查依赖关系的新版本，我希望工具生成的PRs运行我的测试，但不要生成新的docker映像。</p><h1 id="9ce2" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">构建步骤</h1><p id="e79d" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我总是在某个Docker映像中运行我的工作。对于构建，我使用由<em class="lh"> CircleCI </em>提供的<em class="lh"> OpenJDK </em>图像，这是它们维护的许多图像中的一个。这些是步骤。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e3cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://github.com/arturbosch/detekt" rel="noopener ugc nofollow" target="_blank"> detekt </a>基本上是一个可以在管道内独立运行的棉绒。除此之外，执行单元测试，如果一切正常，就构建一个<code class="fe ky kz la lb b">jar</code>。</p><h1 id="e38e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">坚持</h1><p id="1d04" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">与<a class="ae ko" href="https://concourse-ci.org/" rel="noopener ugc nofollow" target="_blank"> Concourse </a>不同的是，<em class="lh"> CircleCI </em>允许你在任务之间持久化工件，这非常方便。在这种情况下，当我构建<em class="lh"> Docker </em>映像时，我需要我们刚刚生成的<code class="fe ky kz la lb b">jar</code>文件。为了持久化它，您在<code class="fe ky kz la lb b">build</code>作业的步骤列表中添加了一个额外的指令:</p><pre class="mm mn mo mp gt mz lb na nb aw nc bi"><span id="2dc1" class="nd lj it lb b gy ne nf l ng nh">- persist_to_workspace: <br/>    root: build/libs <br/>    paths: <br/>      - echo.jar</span></pre><h1 id="029b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">你必须保存测试</h1><p id="a5e5" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我发现的另一个漂亮的特性是<a class="ae ko" href="https://circleci.com/docs/2.0/collect-test-data/" rel="noopener ugc nofollow" target="_blank">存储测试结果</a>，它出现在仪表板中，让你更容易理解你的工作在做什么。</p><p id="49ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">测试结果和执行摘要都被存储为工件。为此，需要添加一些额外的步骤:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c7ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总而言之，构建有一堆步骤，正如在这个截图中可以看到的。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/b63de280bc73165ad936a7e545105689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iLaGPxOJqqbtXL95.png"/></div></div></figure><h1 id="80d1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">码头工步骤</h1><h1 id="2fb6" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">图像本身</h1><p id="089b" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">因此，如果我想对我们的应用程序进行归档，我需要一个归档文件。).该映像运行在前一个任务上构建的<code class="fe ky kz la lb b">jar</code>:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="eff6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没什么异常。<a class="ae ko" href="https://blog.docker.com/2019/07/intro-guide-to-dockerfile-best-practices/" rel="noopener ugc nofollow" target="_blank">这是最近的一篇关于提高你的<em class="lh"> Docker </em>图片质量的文章</a>。</p><h1 id="32f8" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">运行ServerSpec</h1><p id="85bb" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我是使用<a class="ae ko" href="https://serverspec.org/" rel="noopener ugc nofollow" target="_blank"> ServerSpec </a>测试容器的忠实粉丝，因为<a class="ae ko" href="https://hceris.com/testing-containers-serverspec-and-localstack/" rel="noopener ugc nofollow" target="_blank">我在</a>之前已经写过并且多次提到过<a class="ae ko" href="https://github.com/sirech/talks/blob/master/2019-01-tw-tdd_containers.pdf" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="0374" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于臭名昭著的<a class="ae ko" href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" rel="noopener ugc nofollow" target="_blank"> docker in docker </a>问题，在配置项中运行这些测试往往很痛苦。当我试图安排他们去CircleCI的时候，我还以为会有另一轮的痛苦。</p><p id="b06b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没那么多！令人惊讶的是，它进行得相当迅速。也许我现在已经习惯了，谁知道呢。但是，如何去做呢？</p><p id="9702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我为此设立了一份新工作。我用ruby image 创建并上传了自己的<a class="ae ko" href="https://hub.docker.com/r/sirech/dind-ruby/tags" rel="noopener ugc nofollow" target="_blank"> dind，这样我就可以访问更新的<code class="fe ky kz la lb b">ruby</code>版本。它的简化版本如下所示:</a></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3f7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于有了<a class="ae ko" href="https://circleci.com/docs/2.0/building-docker-images/" rel="noopener ugc nofollow" target="_blank"> setup_remote_docker </a>指令，常规的<code class="fe ky kz la lb b">docker</code>命令可用于这项工作。安装完依赖项后，<a class="ae ko" href="https://github.com/sirech/echo/blob/master/spec/container_spec.rb" rel="noopener ugc nofollow" target="_blank">测试</a>可以在管道内部运行。</p><p id="1260" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过使用<code class="fe ky kz la lb b">attach_workspace</code>指令，可以获得前一个作业中生成的<code class="fe ky kz la lb b">jar</code>。</p><h1 id="8fb7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">建立形象</h1><p id="1e88" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">一旦容器测试通过，就该构建映像并将其发布到某个注册中心了。这将是我们最终可以用于部署的工件。部署可以在同一个管道中进行，也可以在单独的管道中进行，这并不重要。</p><p id="bf1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从和以前一样的工作开始，是时候登录到我们应该保存图像的注册表中了。然后我们用正确的标签构建图像，并按下它:</p><pre class="mm mn mo mp gt mz lb na nb aw nc bi"><span id="fc8f" class="nd lj it lb b gy ne nf l ng nh">- run: <br/>    name: Publish docker image <br/>    command: | <br/>      echo $DOCKER_PASSWORD | docker login -u $DOCKER_USER $DOCKER_REGISTRY --password-stdin<br/>      docker build . --tag $DOCKER_REGISTRY/echo <br/>      docker push $DOCKER_REGISTRY/echo</span></pre><p id="e052" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以看到我没有对图像进行版本控制。对于严肃的应用程序，不要这样做。您可以通过使用<code class="fe ky kz la lb b">CIRCLE_SHA1</code>变量来附加<code class="fe ky kz la lb b">git</code>提交，这是许多现成可用的<a class="ae ko" href="https://circleci.com/docs/2.0/env-vars/#built-in-environment-variables" rel="noopener ugc nofollow" target="_blank">内置</a>变量之一。</p><h1 id="0d08" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">贮藏</h1><p id="6145" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">隔离非常有助于保持我们的构建的可靠性。不过，这通常与性能不一致。我不想像过去黑暗的日子里那样缓存整个工作空间，但是避免每次都下载依赖项非常方便，并且保持管道快速，这正是我喜欢的方式。</p><p id="18b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<em class="lh"> CircleCI </em>中，你可以通过保存一个基于键的特定文件夹来实现。例如，如果我想缓存我用于容器测试的<code class="fe ky kz la lb b">ruby</code>依赖项，我使用这样一个块:</p><pre class="mm mn mo mp gt mz lb na nb aw nc bi"><span id="2341" class="nd lj it lb b gy ne nf l ng nh">- restore_cache:     <br/>    key: bundle-2-{{ checksum "Gemfile.lock" }} <br/>- run: bundle check || bundle install --without ops development <br/>- save_cache:     <br/>    key: bundle-2-{{ checksum "Gemfile.lock" }}     <br/>    paths:       <br/>      - vendor/bundle</span></pre><p id="1f12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在此之后，同一作业中的所有步骤都将可用，并且它们将被缓存，直到<code class="fe ky kz la lb b">Gemfile.lock</code>文件发生变化。</p><h1 id="f770" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">定义变量</h1><p id="01a6" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我在整个管道中使用变量来编码某些值，比如我的<em class="lh"> Docker </em>凭证。它们是通过UI 来管理的，坦白地说，这并不理想。老实说，我更喜欢更程序化的解决方案。不用说，直接把秘密放在<code class="fe ky kz la lb b">config.yml</code>是不可能的，所以这将不得不做。</p><p id="24ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想要管理多个项目的一组变量，一个选项可以是使用上下文的<a class="ae ko" href="https://circleci.com/docs/2.0/contexts/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="65f0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">这一切看起来怎么样？</h1><p id="ad98" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">那也没那么糟。我发现CircleCI非常直观，对于业余爱好项目来说，他们的标准账户已经足够了。事实上，管道运行速度非常快。开始时，我等了一会儿去检查它们，当我看的时候，它们已经完成了一会儿。</p><p id="e568" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">整条管线都在<a class="ae ko" href="https://github.com/sirech/echo/blob/master/.circleci/config.yml" rel="noopener ugc nofollow" target="_blank"> github </a>中。这应该是构建您自己的应用程序的良好开端。事实上，管道并没有停止在<em class="lh"> Docker </em>阶段，而是有一个基于定制脚本的部署步骤。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="d2be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lh">原载于2019年7月15日https://hceris.com</em><em class="lh">的</em><a class="ae ko" href="https://hceris.com/dockerizing-a-jvm-app-with-circleci/" rel="noopener ugc nofollow" target="_blank">T22。</a></p></div></div>    
</body>
</html>