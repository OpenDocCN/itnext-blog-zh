<html>
<head>
<title>Monoids in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的幺半群</h1>
<blockquote>原文：<a href="https://itnext.io/monoids-in-javascript-6ee1eab7a18f?source=collection_archive---------2-----------------------#2020-05-20">https://itnext.io/monoids-in-javascript-6ee1eab7a18f?source=collection_archive---------2-----------------------#2020-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8c70127f72ff7eefdd5485a881027fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wY3yqVFaH6HjqFdVXzjCJA.png"/></div></div></figure><div class=""/><p id="78d0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">或者，范畴理论的基本概念是幺半群的概念</p><p id="f1e2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—工作数学家的类别</p><blockquote class="lf lg lh"><p id="5c15" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated">维基百科说一个<strong class="ka jc">幺半群</strong>是一个<a class="ae lm" href="https://en.wikipedia.org/wiki/Algebraic_structure" rel="noopener ugc nofollow" target="_blank">代数结构</a>，带有一个单一的<a class="ae lm" href="https://en.wikipedia.org/wiki/Associative" rel="noopener ugc nofollow" target="_blank">结合</a>二元运算和一个<a class="ae lm" href="https://en.wikipedia.org/wiki/Identity_element" rel="noopener ugc nofollow" target="_blank">单位元</a>。任何具有这两个元素的结构都是幺半群。</p></blockquote><p id="c205" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设s是一个<a class="ae lm" href="https://en.wikipedia.org/wiki/Set_(mathematics)" rel="noopener ugc nofollow" target="_blank">结构</a>而⊗是某个<a class="ae lm" href="https://en.wikipedia.org/wiki/Binary_operation" rel="noopener ugc nofollow" target="_blank">二元运算</a> S ⊗ S → S，那么s与⊗是一个<strong class="ka jc">幺半群</strong>如果它满足以下两个公理:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="4dca" class="lw lx jb ls b gy ly lz l ma mb">1. <strong class="ls jc">Associativity</strong>:   (a ⊗ b) ⊗ c = a ⊗ (b ⊗ c) holds.</span><span id="e6bc" class="lw lx jb ls b gy mc lz l ma mb">2. <strong class="ls jc">Identity element</strong>: There exists an element e such that for all <strong class="ls jc">a  </strong>e ⊗<strong class="ls jc"> a </strong>= a ⊗ e =<strong class="ls jc"> a</strong>  </span></pre><p id="424e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们以整数为例，我们可以把加法看作是两个整数之间的二元运算。</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div class="gh gi md"><img src="../Images/6cacbfedac9eca85ebe1bda1024a2a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*Ih5PNCRORfyiYcwMkB2zPg.png"/></div></figure><p id="fb53" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加的是<a class="ae lm" href="https://en.wikipedia.org/wiki/Associative" rel="noopener ugc nofollow" target="_blank">联想</a>。这意味着加法的顺序并不重要。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="f8e7" class="lw lx jb ls b gy ly lz l ma mb">(x+(y+z)) = ((x+y) +z)</span></pre><p id="5313" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且0是用于加法的单位元素，因为:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="9925" class="lw lx jb ls b gy ly lz l ma mb">x + 0 = x</span></pre><p id="6818" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这些<strong class="ka jc">原因，对(+，0)形成整数上的幺半群</strong>。然而，我们可以在整数上形成不同的其他幺半群。</p><p id="7b47" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，<strong class="ka jc">乘法*也可以看作是一个幺半群，它有各自的单位元1。这样，对(*，1) </strong>是整数上的另一个幺半群。</p><p id="8586" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">JavaScript中的字符串有一个默认的幺半群</strong>，由串联和空字符串(concat，'' )组成。</p><blockquote class="lf lg lh"><p id="9e87" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated">我们将通过定义简单的对象文字在代码中使用幺半群，</p><p id="7ba9" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated">1.一个返回名为<strong class="ka jc">空</strong>的标识元素</p><p id="e059" class="jy jz li ka b kb kc kd ke kf kg kh ki lj kk kl km lk ko kp kq ll ks kt ku kv ij bi translated">2.一个表示二进制操作，称为<strong class="ka jc"> concat </strong>。</p></blockquote><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="d7b6" class="lw lx jb ls b gy ly lz l ma mb">var Sum = { <strong class="ls jc">empty</strong>: () =&gt; 0, <strong class="ls jc">concat</strong>: (x, y) =&gt; x + y }</span><span id="87e2" class="lw lx jb ls b gy mc lz l ma mb">var Product = { <strong class="ls jc">empty</strong>: () =&gt; 1, <strong class="ls jc">concat</strong>: (x, y) =&gt; x * y }</span></pre><p id="f5dd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们会这样使用它:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="7a69" class="lw lx jb ls b gy ly lz l ma mb">Product.concat(Product.empty(), 5);</span></pre><p id="fad6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个定义允许我们以一种直接的方式将它与列表的<strong class="ka jc"> reduce </strong>函数一起使用</p><figure class="ln lo lp lq gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="0624" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">或者</strong>，如果我们想要有<a class="ae lm" href="https://en.wikipedia.org/wiki/Closure_(mathematics)" rel="noopener ugc nofollow" target="_blank">闭包</a>[意味着concat和empty的返回类型与初始对象的类型相同]，我们可以为每个幺半群定义一个新类。</p><figure class="ln lo lp lq gt is"><div class="bz fp l di"><div class="mg mf l"/></div></figure><p id="af7b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">返回类型为Sum，允许<a class="ae lm" href="https://en.wikipedia.org/wiki/Fluent_interface" rel="noopener ugc nofollow" target="_blank">流畅链接</a>。您可以运行下面的jsFiddle:</p><figure class="ln lo lp lq gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="8e4e" class="mh lx jb bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">折叠幺半群</h1><p id="9d5d" class="pw-post-body-paragraph jy jz jb ka b kb ne kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">幺半群具有这种非常理想的性质，如果我们继续应用这种二元运算，我们总是可以将计算减少到同一类型的单个元素:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="40ce" class="lw lx jb ls b gy ly lz l ma mb">(M⊗…(M (⊗(M ⊗ M))) → M</span></pre><p id="b801" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这叫折叠。我们已经从js数组类型中知道折叠为<strong class="ka jc">减少</strong>。然而，在后面的章节中，我们将把fold推广为我们称之为可遍历的数据结构。回到折叠，让我们试着导出reduce。</p><p id="62ab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有一些2，4，5，6的整数序列，我们想把它们相加，这是一个初级问题:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="341c" class="lw lx jb ls b gy ly lz l ma mb">var array  = [2,4,5,6 ]</span><span id="8213" class="lw lx jb ls b gy mc lz l ma mb">var accumulation = <strong class="ls jc">0;</strong></span><span id="75be" class="lw lx jb ls b gy mc lz l ma mb">    for (let i = 0; i &lt; array.length; i++) {</span><span id="b73e" class="lw lx jb ls b gy mc lz l ma mb">     const element = array[i];</span><span id="9c3b" class="lw lx jb ls b gy mc lz l ma mb">    accumulation =  accumulation <strong class="ls jc">+</strong> element</span><span id="b364" class="lw lx jb ls b gy mc lz l ma mb">}</span></pre><p id="e9b1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在那里强调了幺半群的元素。所以，我们来抽象一下。如果我们用任何其他幺半群替换(0，+)这应该是可行的，那么为什么不抽象和重用。</p><figure class="ln lo lp lq gt is"><div class="bz fp l di"><div class="mg mf l"/></div></figure><p id="e34c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以对所有的幺半群使用这个函数</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="ef9a" class="lw lx jb ls b gy ly lz l ma mb">var sum = fold([2, 4, 5, 6],<br/>       { empty: () =&gt; 0, concat: (a, b) =&gt; a + b })</span><span id="1595" class="lw lx jb ls b gy mc lz l ma mb">var product = fold([2, 4, 5, 6], <br/>      { empty: () =&gt; 1, concat: (a, b) =&gt; a * b })</span><span id="7162" class="lw lx jb ls b gy mc lz l ma mb">var max = fold([2, 4, 5, 6], <br/>     { empty: () =&gt; -Infinity, concat: (a, b) =&gt; Math.max(a, b) })</span></pre><figure class="ln lo lp lq gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="7d6e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">你可能会认出这其实就是</strong> <a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> array.reduce </strong> </a>。reduce只不过是for循环的抽象。</p></div></div>    
</body>
</html>