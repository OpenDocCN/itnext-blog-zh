<html>
<head>
<title>How To Synchronize Multiple Threads In Java — Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Java中同步多线程——揭秘</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-synchronize-multiple-threads-in-java-demystified-3c4419b0364a?source=collection_archive---------0-----------------------#2019-08-28">https://itnext.io/how-to-synchronize-multiple-threads-in-java-demystified-3c4419b0364a?source=collection_archive---------0-----------------------#2019-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="03a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当有人让你<strong class="jp ir">写一个多线程应用</strong>的时候，你会害怕吗？我曾经。我已经尝试阅读各种书籍，但仍然有相同的恐惧盛行，直到我试图实现它们，并与它们玩耍。它们非常令人兴奋，会提出许多好奇的问题，最好的部分是调试它们。</p><p id="7bb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将讨论使用Java线程的线程同步，并用一个非常简单的例子来阐明我们的概念。唯一的先决条件是理解基本的Java语法和关于Java线程的初步知识(或者，你可以快速参考<a class="ae kl" href="https://medium.com/@madhupathy/a-beginners-guide-to-java-part-3-of-3-f0c9ba3648b1" rel="noopener">这个</a>)。所以，让我们跳进去吧！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/9005ba73c6804efabd694f858e2743f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptzVuTSbJDTOlSDUBmAbug.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">嗯...不是那些线！学分:<a class="ae kl" href="https://unsplash.com/@amir_v_ali" rel="noopener ugc nofollow" target="_blank">阿米拉里</a></figcaption></figure><p id="d6bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">线程是轻量级进程，可以以分时方式并行执行。它们是程序将自己分成两个或更多同时(或<em class="lc">伪同时</em>)运行的任务的一种方式。线程和进程因操作系统而异，但通常，一个线程包含在一个进程中，同一进程中的不同线程共享相同的资源，而同一多任务操作系统中的不同进程则不共享。</p><p id="d095" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Java通过使用<strong class="jp ir">同步块</strong>提供了一种创建线程和同步其任务的方法。让我们从我们的例子开始。</p><p id="d19c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用一个计数器类，它只有一个成员变量<strong class="jp ir"> count </strong>和一个方法<strong class="jp ir"> incr() </strong>，该方法将count变量的值递增1。</p><pre class="kn ko kp kq gt ld le lf lg aw lh bi"><span id="06ac" class="li lj iq le b gy lk ll l lm ln">class Counter{<br/>  int count;<br/>  public void incr(){ count++; }<br/>}</span></pre><p id="2ac3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> main() </strong>中，我们使用<strong class="jp ir"> <em class="lc"> Runnable </em> </strong>对象并覆盖<strong class="jp ir"> run() </strong>方法来创建一个线程<strong class="jp ir"> t1 </strong>，在其中我们将count的值递增100次。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="7211" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应该会打印<code class="fe lq lr ls le b">Count = 100</code>吧？但事实并非如此。暂停，想一会儿！</p><p id="fc77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> main() </strong>方法也运行在一个线程上，这个线程是JVM创建的Java中的默认主线程。当我们的线程t1在循环内部0到100之间的某个位置时，主线程继续前进(<em class="lc">它不等待</em>)并在那个实例打印count <strong class="jp ir">的值。非常迷人的东西。</strong></p><p id="0270" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望程序等待线程t1完成它的执行。我们将利用线程的<strong class="jp ir"> join() </strong>方法，这将确保<strong class="jp ir"> <em class="lc"> t1 </em> </strong>在程序执行<strong class="jp ir"> <em class="lc">下一条指令</em> </strong>之前终止。此外，它还抛出需要处理的<strong class="jp ir">中断异常</strong>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="597a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">酷！它根据我们的需要打印<code class="fe lq lr ls le b">Count = 100</code>。现在让我们<strong class="jp ir">将它带到下一个级别</strong>并添加另一个可以并行运行的线程。</p><p id="5e73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们定义了另一个线程t2，它做的事情和t1一样。现在<em class="lc">两者都将计数器递增1000倍</em>，那么我们预期的正确值应该是2000。轻松点。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="0e9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的本地系统上运行上面的Java程序<strong class="jp ir">(在线编译器很慢，可能会给出意想不到的结果)，您会发现count的打印值<strong class="jp ir">小于2000 </strong>。</strong></p><p id="4731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么会这样？</p><p id="ebb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操作<code class="fe lq lr ls le b">count++</code>是<strong class="jp ir">而不是原子</strong>，在底层，机器需要为这一行代码发出多条指令。可能发生的情况是，当线程t1将计数器从1000递增到1001时，并且在它被更新到1001之前，线程t2访问计数器并且再次将其从1000递增到1001。因此，在大多数情况下，我们得到的值小于或等于2000。我们可以借助于<strong class="jp ir"> synchronized关键字来处理这个问题。</strong></p><p id="c51e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使<strong class="jp ir"> incr() </strong>方法同步将确保只有一个线程可以使用该方法，其他线程必须等待。从而使其成为线程安全的。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="0c95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，计数器产生的输出是2000，仍然需要<strong class="jp ir"> join() </strong>方法，因为我们希望打印语句等到线程t1和t2的执行都结束。</p><h2 id="c21d" class="li lj iq bd lt lu lv dn lw lx ly dp lz jy ma mb mc kc md me mf kg mg mh mi mj bi translated">语法概述</h2><p id="683a" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我们知道如何在Java中同步多个线程。让我们来看看一些语法。比如我们在同步对象的时候(比方说，<strong class="jp ir"> sync_obj </strong>)。</p><pre class="kn ko kp kq gt ld le lf lg aw lh bi"><span id="0e39" class="li lj iq le b gy lk ll l lm ln">synchronized (sync_obj){<br/>  // code<br/>  // more code ..<br/>  // Access shared resources<br/>  ...<br/>}</span></pre><p id="5164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时，我们需要同步<strong class="jp ir">方法</strong>，也许是为了防止它被两个或更多线程同时调用。例如，我们想要同步<strong class="jp ir"> my_func() </strong>方法。</p><pre class="kn ko kp kq gt ld le lf lg aw lh bi"><span id="ef4e" class="li lj iq le b gy lk ll l lm ln">public synchronized void my_func(){<br/>  // code<br/>  // more code ..<br/>  // Access shared resources<br/>  ...<br/>}</span></pre><p id="f681" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，有时我们可能需要同步方法的一部分，如下所示。</p><pre class="kn ko kp kq gt ld le lf lg aw lh bi"><span id="7e52" class="li lj iq le b gy lk ll l lm ln">public void my_func(){<br/>  System.out.println("Hello World!");<br/>  ...<br/>  synchronized (<strong class="le ir">this</strong>){<br/>    ...<br/>    // Access shared resources<br/>    ...<br/>  }<br/>  ...<br/>  System.out.println("Goodbye!");<br/>}</span></pre><p id="f94b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这么多的知识，您现在已经做好了准备，可以在Java中深入研究和试验多线程程序了。一路平安！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mp"><img src="../Images/01e10a351d0411ece0c13c99630e1643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkbQf4V-Jn6SZRq-wPxMLw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">来源:<a class="ae kl" href="https://unsplash.com/photos/A7_JA-0djb4" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="9210" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这篇文章对你有帮助，请考虑鼓掌。祝您愉快！:)</p></div></div>    
</body>
</html>