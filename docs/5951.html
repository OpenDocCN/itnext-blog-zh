<html>
<head>
<title>How To Build A Kubernetes Backend In Compose CLI ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Compose CLI中构建Kubernetes后端？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-a-kubernetes-backend-in-compose-cli-7ec79b071700?source=collection_archive---------0-----------------------#2021-07-09">https://itnext.io/how-to-build-a-kubernetes-backend-in-compose-cli-7ec79b071700?source=collection_archive---------0-----------------------#2021-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="80d3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">…并使用它将合成应用程序直接部署到K8s中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/efadadd85c8b51d3b784fa7e49976f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gW0uHULXItci5ATVkU7_Qg.png"/></div></div></figure><p id="ec0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Docker Compose是Docker的一个很棒的工具，数百万人使用它来部署和管理多容器应用程序。Docker撰写基本上是两件事:</p><ul class=""><li id="0414" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">Compose文件是yaml中的一个规范(默认情况下名为<em class="lz">Docker-Compose . YAML</em>), Docker Compose将它作为输入。这个文件定义了容器化应用程序的组件以及它们是如何连接在一起的。应该是按照<a class="ae ma" href="https://compose-spec.io/" rel="noopener ugc nofollow" target="_blank">编写规范</a>编写的，规范的细节可以从<a class="ae ma" href="https://github.com/compose-spec/compose-spec/blob/master/spec.md" rel="noopener ugc nofollow" target="_blank">这个库</a>里得到</li><li id="7713" class="lq lr it kw b kx mb la mc ld md lh me ll mf lp lv lw lx ly bi translated">Docker Compose是处理这个合成文件的工具:它检查它是否是根据合成规范编写的，并部署应用程序组件</li></ul><p id="56e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">来自Docker的安卡·约尔达切解释了Compose规范的公开化，以及她是如何作为一个附带项目开始为Compose CLI开发kube后端的:</p><blockquote class="mg mh mi"><p id="2375" class="ku kv lz kw b kx ky ju kz la lb jx lc mj le lf lg mk li lj lk ml lm ln lo lp im bi translated">“由于其简单性，Compose格式在开发人员中非常受欢迎，人们总是对在平台上部署Compose文件的工具感兴趣，而不是单个Docker引擎或Swarm。为了让Compose超越Docker和Swarm，在2020年初，我们开放了Compose规范，使任何人都可以围绕它构建工具。我们使用新的开放规范和参考库在Docker CLI中构建对Amazon ECS和Microsoft ACI的支持，以便在这些平台上部署Compose应用程序。一个明显的下一个目标是Kubernetes，因为它非常受欢迎，人们对在其上部署Compose应用程序非常感兴趣。我们写了一个初步的概念证明来测试这种集成，但它还没有被添加到Docker的产品路线图中。我把它作为我的黑客项目，继续在这个集成上取得进展。Kubernetes后端的当前代码可以在公共存储库<a class="ae ma" href="https://github.com/docker/compose-cli" rel="noopener ugc nofollow" target="_blank"> docker/compose-cli </a>中找到，欢迎每个人对其做出贡献。”</p></blockquote><p id="db2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如Anca所说，<a class="ae ma" href="https://github.com/docker/compose-cli" rel="noopener ugc nofollow" target="_blank"> Compose CLI </a> GitHub存储库是托管不同后端的地方:</p><div class="mm mn gp gr mo mp"><a href="https://github.com/docker/compose-cli" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">docker/compose-cli</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">这个编写CLI工具使运行Docker容器和Docker编写应用程序变得容易:在本地作为一个命令在…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ks mp"/></div></div></a></div><p id="6098" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，等等…我们谈论的后端到底是什么？</p><p id="a5a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的图片(来自compose-cli GitHub库的图片的略微修改版本)使事情变得更加清楚:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/c98f88bf9e0237c608ae5b1c23a9a21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrEwCSO4y1iaQoZfUDVzlA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">来自https://github.com/docker/compose-cli<a class="ae ma" href="https://github.com/docker/compose-cli" rel="noopener ugc nofollow" target="_blank">的修改图片</a></figcaption></figure><p id="e11c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">后端是Compose API的一个实现，每个后端针对一个特定的平台(Amazon ECS，Azure ACI)。另外，Docker compose是这个compose api的cli客户机。</p><p id="c9e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们如何选择我们想要使用的后端？</p><p id="bd71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Docker compose cli知道使用哪个后端的方式是通过当前使用的Docker上下文。从"<em class="lz">docker context create-help "</em>命令中，我们可以看到<strong class="kw iu"> aci </strong>和<strong class="kw iu"> ecs </strong>上下文都可以在更常见的Docker引擎之上创建:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="4190" class="no np it nk b gy nq nr l ns nt">Create docker engine context:<br/>$ docker context create CONTEXT [flags]</span><span id="d38d" class="no np it nk b gy nu nr l ns nt">Create Azure Container Instances context:<br/>$ docker context create aci CONTEXT [flags]<br/>(see docker context create aci --help)</span><span id="d8ff" class="no np it nk b gy nu nr l ns nt">Create Amazon ECS context:<br/>$ docker context create ecs CONTEXT [flags]<br/>(see docker context create ecs --help)</span></pre><p id="339c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，基于当前上下文选择后端。</p><p id="4479" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前有3个官方后端:</p><ul class=""><li id="3d26" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw iu">本地</strong>:部署在本地机器上。这个后端是<a class="ae ma" href="https://docs.docker.com/compose/cli-command/" rel="noopener ugc nofollow" target="_blank"> Compose V2 </a>，它将作为CLI插件发布，取代原来的python docker-compose</li><li id="1320" class="lq lr it kw b kx mb la mc ld md lh me ll mf lp lv lw lx ly bi translated"><strong class="kw iu"> aci </strong>:部署在<a class="ae ma" href="https://docs.docker.com/cloud/aci-integration/" rel="noopener ugc nofollow" target="_blank"> Azure容器实例上</a></li><li id="0cdd" class="lq lr it kw b kx mb la mc ld md lh me ll mf lp lv lw lx ly bi translated"><strong class="kw iu"> ecs </strong>:部署在<a class="ae ma" href="https://docs.docker.com/cloud/ecs-integration/" rel="noopener ugc nofollow" target="_blank">亚马逊弹性容器服务</a></li></ul><p id="5b10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除此之外，Anca还在开发后端项目kube。该后端将允许在Kubernetes集群上部署一个组合应用程序。</p><p id="ab04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在接下来的部分中，我们将详细介绍用于设置整个环境的步骤。因为这个项目还很年轻，没有附带Docker CLI，所以有必要从源代码编译它，但是你会发现它并不复杂。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="1009" class="oc np it bd od oe of og oh oi oj ok ol jz om ka on kc oo kd op kf oq kg or os bi translated">设置环境</h1><p id="8fe0" class="pw-post-body-paragraph ku kv it kw b kx ot ju kz la ou jx lc ld ov lf lg lh ow lj lk ll ox ln lo lp im bi translated"><strong class="kw iu"> Linux虚拟机</strong></p><p id="042f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们创建一个Ubuntu虚拟机。为了这篇文章的目的，我用Terraform配置文件在一个伟大的欧洲云提供商Exoscale上创建了它。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="17d2" class="no np it nk b gy nq nr l ns nt"><strong class="nk iu">$ terraform apply<br/></strong>...<br/>Outputs:</span><span id="cad2" class="no np it nk b gy nu nr l ns nt">instances_names = {<br/>  "exo-0" = "89.145.160.162"<br/>}</span></pre><p id="01c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下指令将通过新虚拟机中的shell运行。</p><p id="23e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">码头工人安装</strong></p><p id="2a6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们在其中安装Docker，这可以通过下面这个方便的命令来完成:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="08cd" class="no np it nk b gy nq nr l ns nt">$ curl -sSL <a class="ae ma" href="https://get.docker.com" rel="noopener ugc nofollow" target="_blank">https://get.docker.com</a> | sh</span></pre><p id="81bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">获取撰写CLI报告</strong></p><p id="f9af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们获取Compose CLI源代码并移入其中</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="cf42" class="no np it nk b gy nq nr l ns nt">$ git clone <a class="ae ma" href="https://github.com/docker/compose-cli.git" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/compose-cli.git</a><br/>$ cd compose-cli/</span></pre><p id="0a35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编译编写命令行界面</p><p id="797c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">🔥下面的几个说明是必需的，因为kube后端没有在Compose版本中发布，它需要从源代码中构建。</p><p id="ffdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先我们需要安装<em class="lz"> make </em>实用程序:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="e018" class="no np it nk b gy nq nr l ns nt">$ apt-get install make</span></pre><p id="125a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们可以针对compose-cli项目运行它:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f2ee" class="no np it nk b gy nq nr l ns nt">$ make</span></pre><p id="99aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编译是在一个容器中完成的，只需要几分钟。然后在<em class="lz">中创建一个新的<em class="lz"> docker </em>二进制文件。/bin </em>文件夹(旁边是一个docker-compose二进制文件，我们在这个例子中不会用到它)。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="1bab" class="no np it nk b gy nq nr l ns nt">root@exo-0:~/compose-cli# tree bin<br/>bin<br/>├── docker<br/>└── docker-compose</span></pre><p id="f11f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使用新的docker二进制文件，我们需要将之前的二进制文件重命名为<em class="lz"> com.docker.cli </em>，并将当前的二进制文件移动到PATH中</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="4c8c" class="no np it nk b gy nq nr l ns nt">$ mv /usr/bin/docker /usr/bin/com.docker.cli<br/>$ mv ./bin/docker /usr/bin/docker</span></pre><p id="3c1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它目前的工作方式是:<em class="lz"> compose </em>子命令将由我们刚刚构建的<em class="lz"> docker </em>二进制文件处理，所有其他命令(容器、图像……)将由<em class="lz"> com.docker.cli </em>二进制文件运行。</p><p id="2ac9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Kubernetes集群</strong></p><p id="4b4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一步是创建一个Kubernetes集群。我们将采用简单的方法，建立一个本地单节点<a class="ae ma" href="https://get.k3s.io" rel="noopener ugc nofollow" target="_blank"> k3s </a>集群。只需一个命令(几十秒钟)就可以启动并运行集群:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2579" class="no np it nk b gy nq nr l ns nt">$ curl -sSL <a class="ae ma" href="https://get.k3s.io" rel="noopener ugc nofollow" target="_blank">https://get.k3s.io</a> | sh</span></pre><p id="9389" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">k3s自带kubectl二进制文件，这使得直接检查集群是否正在运行变得容易</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="2e98" class="no np it nk b gy nq nr l ns nt">$ k3s kubectl get nodes<br/>NAME   STATUS   ROLES                  AGE   VERSION<br/>demo   Ready    control-plane,master   87s   v1.21.1+k3s1</span><span id="f313" class="no np it nk b gy nu nr l ns nt">$ kubectl get pods -A</span></pre><p id="a8c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只是把k3s创建的kubeconfig文件(位于<em class="lz">/etc/rancher/k3s/k3s . YAML</em>)复制到默认的<em class="lz"> ~/中。kube/config，</em>我们将在后面的步骤中需要它。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="20af" class="no np it nk b gy nq nr l ns nt">$ cp /etc/rancher/k3s/k3s.yaml ~/.kube/config</span></pre><p id="0249" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要创建的最后一件事是Docker上下文。我们使用<strong class="kw iu"> kubernetes </strong>类型选择默认的<em class="lz"> kubeconfig </em>文件(<em class="lz"> ~/)。kube/config </em>)来获取集群的信息:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9244" class="no np it nk b gy nq nr l ns nt"><strong class="nk iu">$ docker context create kubernetes k3s<br/></strong>? Create a Docker context using: Context from kubeconfig file<br/>? Select kubeconfig context default<br/>Successfully created kube context "k3s"</span></pre><p id="b4dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们需要使用这个新的上下文:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a21a" class="no np it nk b gy nq nr l ns nt">$ docker context use k3s</span></pre><p id="22b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们应该看到“compose”子命令是可用的。它会生成一个空列表，因为我们还没有部署应用程序:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="201b" class="no np it nk b gy nq nr l ns nt">$ docker compose ls<br/>NAME                STATUS</span></pre><p id="c6bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经安装了Compose CLI，现在可以开始使用了。在下文中，我们将展示如何部署一个示例应用程序</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="9859" class="oc np it bd od oe of og oh oi oj ok ol jz om ka on kc oo kd op kf oq kg or os bi translated">在示例应用程序上使用kube后端</h1><p id="007c" class="pw-post-body-paragraph ku kv it kw b kx ot ju kz la ou jx lc ld ov lf lg lh ow lj lk ll ox ln lo lp im bi translated">kube后端实现了Docker Compose命令，用于在Kubernetes集群上部署容器化的应用程序。</p><p id="8e54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:由于这个后端不是官方的，我们需要考虑到并不是所有的编写命令都被实现了，只有下面的命令被实现了:</p><ul class=""><li id="b323" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">docker组合起来部署一个组合应用程序</li><li id="c6b6" class="lq lr it kw b kx mb la mc ld md lh me ll mf lp lv lw lx ly bi translated"><em class="lz"> docker compose ls </em>列出当前部署的合成项目</li><li id="3e33" class="lq lr it kw b kx mb la mc ld md lh me ll mf lp lv lw lx ly bi translated"><em class="lz"> docker编写ps </em>列出pod</li><li id="2257" class="lq lr it kw b kx mb la mc ld md lh me ll mf lp lv lw lx ly bi translated"><em class="lz"> docker compose exec </em>在容器中运行shell</li><li id="5d3a" class="lq lr it kw b kx mb la mc ld md lh me ll mf lp lv lw lx ly bi translated"><em class="lz"> docker编写日志</em>以获取一个容器的日志</li><li id="4ee9" class="lq lr it kw b kx mb la mc ld md lh me ll mf lp lv lw lx ly bi translated"><em class="lz"> docker撰写关闭</em>卸载撰写应用程序</li></ul><p id="0028" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，并不是所有在合成文件中定义的属性都会被考虑在内</p><p id="798c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了说明kube后端的用法，我们将使用投票应用程序v3的简化版本(如<a class="ae ma" href="https://gitlab.com/voting-application/config" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/voting-application/config</a>中所定义的)。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9350" class="no np it nk b gy nq nr l ns nt"><strong class="nk iu">$ cat &lt;&lt;EOF &gt; compose.yaml<br/></strong>services:<br/>  nats:<br/>    image: nats:2.2-alpine3.13<br/>    expose:<br/>      - 4222:4222<br/>  vote:<br/>    image: registry.gitlab.com/voting-application/vote:v3<br/>    expose:<br/>      - 80<br/>  vote-ui:<br/>    image: registry.gitlab.com/voting-application/vote-ui<br/>    ports:<br/>      - 5000:80<br/>  result:<br/>    image: registry.gitlab.com/voting-application/result:v3<br/>    expose:<br/>       - 80<br/>  result-ui:<br/>    image: registry.gitlab.com/voting-application/result-ui<br/>    ports:<br/>      - 5001:80<br/><strong class="nk iu">EOF</strong></span></pre><p id="5139" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在部署应用程序之前，我们可以检查kubernetes的规范，这会产生:</p><ul class=""><li id="bb27" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">描述该项目的README.md文件</li><li id="61c5" class="lq lr it kw b kx mb la mc ld md lh me ll mf lp lv lw lx ly bi translated">包含项目元数据的Chart.yaml</li><li id="92e9" class="lq lr it kw b kx mb la mc ld md lh me ll mf lp lv lw lx ly bi translated">应用程序的每个微服务的部署和服务</li></ul><p id="a90f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae ma" href="https://gist.github.com/lucj/a75b29e671f84b4a1e8da5f7dbc9c0b6" rel="noopener ugc nofollow" target="_blank">要点</a>中输出是命令<em class="lz">docker compose converter</em>的结果，它从<em class="lz"> compose.yaml </em>文件中生成Kubernetes规范</p><p id="e068" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">🔥目前，在Compose文件中定义的服务是在Helm档案中转换的，但是这种行为在不久的将来可能会改变，直接访问Kubernetes API，从而避免helm vendoring。</p><p id="1978" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以测试应用程序的部署了</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9796" class="no np it nk b gy nq nr l ns nt"><strong class="nk iu">$ docker compose up<br/></strong>[+] Running 7/7<br/> ⠿ Convert Compose file to Helm charts      0.0s<br/> ⠿ Install Compose stack                    0.4s<br/> ⠿ nats                                     22.5s<br/> ⠿ vote                                     22.5s<br/> ⠿ result                                   22.5s<br/> ⠿ vote-ui                                  22.5s<br/> ⠿ result-ui</span></pre><p id="f07b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用kubectl，我们可以看到已经创建了部署和服务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/340e007fc33e309a6cd36db7fb7b2188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wotUzE215YPPvQVOPchlDQ.png"/></div></div></figure><p id="da7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用上面信息中指定的节点端口，我们可以访问投票界面，为我们最喜欢的小猫投票。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/b94792fd3e0922581dbfde10fd03d97b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZ2I5kJsqC2nWdfGLwONjg.png"/></div></div></figure><p id="bce6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几个组合命令可用于获取信息和管理应用程序的整个生命周期:</p><ul class=""><li id="f57a" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">列出用compose-cli创建的项目。只有当前项目出现在这个列表中，它被命名为vote，因为它是从<em class="lz"> vote </em>文件夹中运行的。</li></ul><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="955c" class="no np it nk b gy nq nr l ns nt"><strong class="nk iu">$ docker compose ls<br/></strong>NAME                STATUS<br/>vote                deployed</span></pre><ul class=""><li id="5ae6" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">列出创建的窗格</li></ul><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="11ad" class="no np it nk b gy nq nr l ns nt">$ docker compose ps</span></pre><ul class=""><li id="34ca" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">我们可以在容器中运行shell</li></ul><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ba7d" class="no np it nk b gy nq nr l ns nt">$ docker compose exec www bash</span></pre><ul class=""><li id="2163" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">还要检查正在运行的容器的日志</li></ul><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="6c24" class="no np it nk b gy nq nr l ns nt">$ docker compose logs nats</span></pre><p id="4510" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们完成了我们的测试，我们可以简单地删除项目，因为我们已经习惯了:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="162f" class="no np it nk b gy nq nr l ns nt">$ docker compose down</span></pre></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h2 id="792b" class="no np it bd od pa pb dn oh pc pd dp ol ld pe pf on lh pg ph op ll pi pj or pk bi translated">关键要点</h2><p id="4ae3" class="pw-post-body-paragraph ku kv it kw b kx ot ju kz la ou jx lc ld ov lf lg lh ow lj lk ll ox ln lo lp im bi translated">这个kube后端仍处于起步阶段，但绝对是一个伟大的举动，它将在Compose规范中定义的应用程序和Kubernetes资源之间架起一座桥梁。</p><p id="7b73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想尝试一下这个项目，甚至为它做点贡献吗？不要再想了，勇往直前:)</p><p id="cb03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">非常感谢来自Docker的Anca约尔达切启动了这个kube后端，并花时间向我展示了代码的当前状态，并一步一步地展示了如何通过一对一的视频通话来设置整个事情👍也感谢她对这篇文章的详细评论，以及她在Docker博客上写的所有精彩文章。</p></div></div>    
</body>
</html>