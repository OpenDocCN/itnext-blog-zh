<html>
<head>
<title>Writing Testable Swift — Part 1: Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写可测试的Swift —第1部分:依赖注入</h1>
<blockquote>原文：<a href="https://itnext.io/writing-testable-swift-part-1-dependency-injection-f7a9e3955369?source=collection_archive---------5-----------------------#2018-02-22">https://itnext.io/writing-testable-swift-part-1-dependency-injection-f7a9e3955369?source=collection_archive---------5-----------------------#2018-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0b04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">你可以在Github </em> <a class="ae km" href="https://github.com/tnev/writing-testable-swift" rel="noopener ugc nofollow" target="_blank"> <em class="kl">这里</em> </a> <em class="kl">关注这个系列的发展。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/dd29f3495c5c7b1a5cdf93cf71598d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOJbDpL5g5rAfy2n7DBMYA.jpeg"/></div></div></figure><p id="87c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fwriting-testable-swift-part-1-dependency-injection-f7a9e3955369" rel="noopener ugc nofollow" target="_blank"> <em class="kl">点击这里在LinkedIn </em> </a>上分享这篇文章</p><p id="fcb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为软件开发人员，我们每天都要做出很多决定。我们正在修复错误、构建功能和设计新系统。我们有太多的选择要做，有时我们不确定我们是否在做正确的选择。</p><p id="54b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，如果我们对自己的解决方案充满信心会怎么样呢？如果我们能够高度确信我们的代码将按预期工作，那会怎么样呢？这就是编写可测试Swift的目标。</p><p id="d335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本课程介绍了如何在没有任何第三方依赖的情况下编写干净、健壮且可测试的Swift代码。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><p id="02e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们在一家机器人工厂工作，老板要求我们为机器人创建一个类。她说，机器人需要一根电线、一根天线和一个电源才能工作，而且一旦制造出来，我们就不能更换零件。</p><p id="af03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们写了一个简洁的机器人类:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="24e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！这符合所有要求。</p><p id="5801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们把这个拿给我们的老板，我们的老板回答，“好的，但是我们需要能够制造所有不同种类的机器人。我们的一些客户喜欢绿色电线和5000瓦的电源。”</p><p id="f940" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该死。所以回到制图板。我们如何在制造机器人的时候动态地创造它的零件？轻松点。我们将使用一个初始化器，它接受部件的自定义值:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="bbd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，看起来不错！我们跑到老板的办公室，大声说，“看这个。现在你可以制造任何你想要的机器人。”</p><p id="1508" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的老板看起来有点被逗乐了，她说，“很好，但我们实际上刚刚决定把我们的零件制造转移到海外，所以我们的机器人不能自己制造零件。”</p><p id="6dc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">啊！我们闷闷不乐地走出她的办公室，遇到了一个在机器人测试部门工作的朋友。我们告诉他我们在机器人课上遇到的问题。</p><p id="6eb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“为什么不用<strong class="jp ir">依赖注入</strong>？”我们的朋友问道。</p><p id="0fe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“Dependsiwhatsit？”，我们回复。我们的朋友引用了詹姆斯·肖的话，</p><blockquote class="li lj lk"><p id="9784" class="jn jo kl jp b jq jr js jt ju jv jw jx ll jz ka kb lm kd ke kf ln kh ki kj kk ij bi translated"><em class="iq">“依赖注入就是给一个对象赋予它的实例变量。真的。就是这样。”</em></p></blockquote><p id="088b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！我们跑回到我们的电脑前，很快想出了一个使用依赖注入的解决方案:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="e085" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这被称为初始化器注入。当我们初始化机器人时，我们给了它依赖项(实例变量)。这在理论和实践上都很简单。</p><p id="dea0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，使用依赖注入实际上更简单。为了说明这一点，让我们看看在我们的第一个实现中，实例变量是如何赋值的:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="ba27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看所有的复杂性和特殊性。它给我们带来了什么？一种机器人。让我们看看在第二个实现中，我们的实例变量是如何分配的:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="5217" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更好，但看看仍在发生的事情——我们的机器人知道如何创造自己的零件。这意味着我们的机器人<strong class="jp ir">依赖</strong>实现电线、天线和电源。如果任何一种类型的初始化器改变了，我们将不得不改变机器人初始化器的实现。这似乎不太对，是吗？</p><p id="5a27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们看看在使用依赖注入时如何设置实例变量:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="ec18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单。</p><p id="a30c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可能会问，“电线、天线和电源的实现在哪里？在不知道这些其他组件是如何创建的情况下，我们如何知道这真的如此简单？”</p><p id="e455" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是依赖注入最伟大的部分:<em class="kl">我们不关心</em>。我们不关心电线、天线、电源或机器人的任何其他依赖是如何产生的。我们是机器人工程师；我们唯一的工作就是创建一个机器人类。我们所关心的是当我们需要的时候(在初始化的时候)得到我们的部分。</p><p id="351a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们指出依赖注入的一些巨大优势:</p><h1 id="2256" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">透明度</h1><p id="e311" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">对象的责任和需求(依赖)变得更加清晰。通过查看我们的对象需要什么功能，以及<strong class="jp ir">仅</strong>我们的对象需要什么功能，我们可以更容易地假设我们的对象做什么。</p><h1 id="b5ac" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">分离</h1><p id="7054" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们希望我们的对象只知道它们绝对需要知道的东西，以便运行。我们的机器人需要知道如何创造它的部件才能发挥作用吗？正如我们看到的使用依赖注入，不，它没有。即使我们的机器人使用它的零件，它也不负责制造那些零件。</p><h1 id="7ed7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">退耦</h1><p id="5dfe" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">当我们的软件片段被<strong class="jp ir">耦合</strong>时，它们相互依赖才能运行。紧密耦合会降低可重用性和可维护性。当我们将依赖注入与Swift协议的使用结合起来时，我们将在本系列的后面看到，我们可以减少组件之间的耦合。通过让我们的对象依赖于其他组件的接口，而不是它们的实现，我们将能够在架构或需求改变时更快地改变代码。</p><h1 id="29cc" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">易测性</h1><p id="609e" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">这可以说是编写软件时使用依赖注入的最重要的原因。测试代码的能力<em class="kl">直接关系到</em>你的组件如何获得它们的依赖。正如我们很快会看到的，如果你的对象正在创建它们自己的依赖关系，那么控制它们的行为会非常困难，这意味着测试它们的行为会非常困难或者不可能。</p></div><div class="ab cl kz la hu lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ij ik il im in"><p id="fcd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">想想这个:</strong></p><p id="3880" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们一开始就实现了依赖注入，那么与我们老板的对话会是怎样的呢？</p><p id="73ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些对话并不完全是虚构的——我们项目的需求和约束是不断变化和发展的。我们的工作是确保变革不会引起恐慌。使用依赖注入是在我们对代码所做的更改中变得<em class="kl">确定</em>和<em class="kl">自信</em>的第一步。</p><p id="973e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">你可以在这里</em>  <em class="kl">阅读part 2 </em> <a class="ae km" href="https://medium.com/@tneveldine/writing-testable-swift-part-2-interfaces-e4897c426028" rel="noopener"> <em class="kl">。</em></a></p></div></div>    
</body>
</html>