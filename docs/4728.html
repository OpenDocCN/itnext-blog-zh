<html>
<head>
<title>Gradle modules: Running unit tests only in affected modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">梯度模块:仅在受影响的模块中运行单元测试</h1>
<blockquote>原文：<a href="https://itnext.io/gradle-modules-running-unit-tests-only-in-affected-modules-fff89562339e?source=collection_archive---------4-----------------------#2020-09-02">https://itnext.io/gradle-modules-running-unit-tests-only-in-affected-modules-fff89562339e?source=collection_archive---------4-----------------------#2020-09-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e31f89819a7dba82db32294222c6ad54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CnZspxEAwgw-SfkRONTFhQ.jpeg"/></div></div></figure><div class=""/><h1 id="4e58" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1 —简介</h1><p id="9e29" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你好。</p><p id="c6b5" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">多模块项目在Android世界越来越受欢迎，特别是在2019年谷歌IO之后，谷歌引入了这一想法，并展示了它的好处。</p><p id="e570" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">尽管模块变得越来越流行，但是在工具中仍然有很多事情要做，需要分析和处理。很难找到工具来分析模块之间的代码分布有多好，然后如何使编译更快，可视化模块之间的依赖关系，并寻找可能的优化。</p><p id="63fe" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，在这篇文章中，我想教你如何制作一个有趣的项目，以帮助你分析你的模块化Gradle项目(重要的是，它适用于任何Gradle项目，这根本不仅限于android)。目标是:</p><p id="8510" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">1-按分支打印受影响的模块。</p><p id="f7ba" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">2-仅在受影响的模块中运行单元测试。</p><p id="c8f8" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">3-在受影响的模块中运行UI测试。(这将出现在以后的文章中)</p><p id="8c6a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">4-可视化依赖关系图，并研究它们之间的关系。(这也会出现在以后的文章中)</p><p id="e42e" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这可以帮助你和你的团队避免在没有被PR改变的模块上运行单元测试，并且加速你的CI，理解模块如何相互作用，以及这个图此刻有多复杂。介绍完了，让我们找点乐子吧！</p><h1 id="71aa" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2 —查找受影响的模块</h1><p id="6ff9" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">针对这个问题，我创建了一个Gradle插件，你可以使用并打印你的模块的邻接表(对了，如果你不知道什么是邻接表:是不是一种表示图的方式，你可以搜索一下，会有很多引用)。你可以在这里找到这个插件的文档和代码:<a class="ae lz" href="https://github.com/leandroBorgesFerreira/dag-command" rel="noopener ugc nofollow" target="_blank">https://github.com/leandroBorgesFerreira/dag-command</a>。它是根据<a class="ae lz" href="https://github.com/hpedrorodrigues" rel="noopener ugc nofollow" target="_blank"> <strong class="ky jc">佩德罗罗德里格斯</strong> </a> <strong class="ky jc">的惊人之作改编而成。</strong></p><p id="10da" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">假设我们有一个模块化的应用程序，就像这样:</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ma"><img src="../Images/48e1197bef363cf11fff2c90c9acacef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o13pbg7Hzt8nxD_rPDWAhA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">图1 —模块应用示例。</figcaption></figure><p id="3122" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">可以看看这里的小项目:<a class="ae lz" href="https://github.com/leandroBorgesFerreira/FoodList" rel="noopener ugc nofollow" target="_blank">https://github.com/leandroBorgesFerreira/FoodList</a></p><p id="43f2" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，6个模块和它们彼此之间有一些依赖关系，我们将在本文后面理解它们是如何相互依赖的。</p><p id="165a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可以通过这种方式添加库。项目级Gradle文件中的库。</p><p id="ec95" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc"> build.gradle.kts(科特林版本):</strong></p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">该版本可能已过时！</figcaption></figure><p id="e107" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc"> build.gradle (Groovy版本):</strong></p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">该版本可能已过时！</figcaption></figure><p id="6552" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后你可以在<strong class="ky jc">核心</strong>模块中做一个小的改变(只改变代码的任何一行，比如添加一个注释),我运行插件:</p><pre class="mb mc md me gt ml mm mn mo aw mp bi"><span id="898f" class="mq jz jb mm b gy mr ms l mt mu">./gradlew dag-command</span></pre><p id="8f74" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可以去文件夹<strong class="ky jc">。/build/dag-command/ </strong>你会看到一些文件。在那里你会找到<strong class="ky jc"> adjacencies-list.json. </strong>这个文件包含了你的应用程序的模块依赖图的信息。在图像1的例子中，这是我得到的输出:</p><pre class="mb mc md me gt ml mm mn mo aw mp bi"><span id="49e0" class="mq jz jb mm b gy mr ms l mt mu">{“app”:[],”core”:[“showfood”],”data”:[“app”,”showfood”],”domain”:[“data”,”showfood”],”search”:[“showfood”],”showfood”:[“app”]}</span></pre><p id="2551" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">可以格式化为:</p><pre class="mb mc md me gt ml mm mn mo aw mp bi"><span id="fe6f" class="mq jz jb mm b gy mr ms l mt mu">{<br/>  "app": [],<br/>  "core": [<br/>    "showfood"<br/>  ],<br/>  "data": [<br/>    "app",<br/>    "showfood"<br/>  ],<br/>  "domain": [<br/>    "data",<br/>    "showfood"<br/>  ],<br/>  "search": [<br/>    "showfood"<br/>  ],<br/>  "showfood": [<br/>    "app"<br/>  ]<br/>}</span></pre><p id="639b" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可以通过查看文件<strong class="ky jc"> affected-modules.json </strong>来查看受影响的模块。这是我的输出:</p><pre class="mb mc md me gt ml mm mn mo aw mp bi"><span id="238c" class="mq jz jb mm b gy mr ms l mt mu">["app","core","showfood"]</span></pre><p id="984a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可以看一下邻接表得出结论:改变<strong class="ky jc">核心</strong>会影响<strong class="ky jc"> app、showfood </strong>和<strong class="ky jc">核心</strong>因为依赖关系是<strong class="ky jc">核心</strong>-&gt;<strong class="ky jc">show food</strong>-&gt;<strong class="ky jc">app</strong>。</p><p id="1198" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">好的。所以我们成功了！现在我们知道如何通过我们的PR创建受影响的模块了！但是…那不是很有用…对吧？我们需要使用这些信息来创造更多的东西，比如加速我们的测试或者分析我们的模块是如何连接的(后者将在另一篇文章中介绍，抱歉=P)。这就把我们带到了文章的下一部分。</p><h1 id="44ec" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3-仅对更改的模块运行单元测试</h1><p id="b134" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们现在需要做的是创建一个命令，该命令将只为被当前分支改变的模块运行单元测试。</p><p id="f198" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我使用Python进行日常自动化，但是您可以使用任何您喜欢的语言。您可以毫不费力地将受影响的模块解析为一个简单的命令:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">想用什么都可以，包括这个=P</figcaption></figure><p id="66b4" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这个代码片段将产生这个Gradle命令:</p><pre class="mb mc md me gt ml mm mn mo aw mp bi"><span id="0223" class="mq jz jb mm b gy mr ms l mt mu">./gradlew core:testDebug showfood:testDebug app:testDebug</span></pre><p id="2c4b" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以模块<strong class="ky jc">数据、</strong> <strong class="ky jc">域</strong>和<strong class="ky jc">搜索</strong>没有被测试，因为我们的改变没有影响到它们，所以在这些模块上运行单元测试只是浪费时间。</p><h1 id="5a33" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4 —我希望你喜欢它=]</h1><p id="8f2a" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在你可以在你的CI上享受一些额外的时间。也许你可以多喝一杯咖啡，和你的同事聊聊天，读一本书的一小部分…你能想到的！</p><p id="67f4" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果这篇文章和库在某种程度上帮助了你(或者如果你认为这是一篇有趣的文章),请记得点击鼓掌按钮，在Github上给我一个小星星。那很有帮助！</p><p id="53af" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">谢谢！</p></div></div>    
</body>
</html>