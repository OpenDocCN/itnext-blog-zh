<html>
<head>
<title>What Makes the Zig Programming Language Unique?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么让Zig编程语言独一无二？</h1>
<blockquote>原文：<a href="https://itnext.io/what-makes-zig-unique-1b98bfb95701?source=collection_archive---------1-----------------------#2022-10-05">https://itnext.io/what-makes-zig-unique-1b98bfb95701?source=collection_archive---------1-----------------------#2022-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c2de" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Zig允许您在编译期间运行代码。有什么含义？</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/d9472dddbb2ed08c21d4bd018b59b4c2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*b3og8n0fDkAnHUx-0lDMHg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">Zig吉祥物Zero the Ziguana</figcaption></figure><p id="2b0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">20世纪60年代，Lisp编程语言开创了编译时计算。编译时计算意味着你以后编译的代码不仅仅是你写下来的。你后来编译的也是你的代码“写”出来的代码。代码生成代码。虽然在动态类型语言(如Lisp和Julia)中这是一个常见的特性，但在静态类型系统编程语言(如C)中却很少见。</p><p id="2e0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在讨论静态类型语言的编译时计算时，我决定选择Zig作为示例语言。为什么不是一种更广为人知的语言？Zig非常接近C，并且选择了以编译时计算为中心的语言。对于C++来说，它更像是一个附加的东西。你可以很好地编写C++代码，而无需有意识地进行编译时计算。Zig翻转了脚本，使编译时计算成为该语言最核心、最受支持的特性之一。这就是为什么Zig是学习这个概念的好语言。在Zig世界中，我们称之为编译时计算<code class="fe lz ma mb mc b">comptime</code>，来自于用来标记编译时需要运行的代码或者编译时已知的变量的关键字。</p><p id="da3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在编译期间运行Zig代码的能力允许Zig开发人员编写泛型代码和进行元编程，而不需要任何对泛型或模板的显式支持。</p><p id="f0a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我带您看一些代码示例，以便更好地解释整个想法是什么以及为什么它很重要。考虑下面的简单函数来找出两个值<code class="fe lz ma mb mc b">a</code>和<code class="fe lz ma mb mc b">b</code>中的最大值。如果没有泛型或<code class="fe lz ma mb mc b">comptime</code>代码，我们将需要硬连接这样一个函数来操作特定的变量类型，比如在Zig中被称为<code class="fe lz ma mb mc b">i32</code>的32位整数。</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="1975" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">fn</strong> maximum(a: i32, b: i32) i32 {<br/>    var result: i32 = undefined;<br/><br/>    <strong class="mc iu">if</strong> (a &gt; b) {<br/>        result = a;<br/>    } <strong class="mc iu">else</strong> {<br/>        result = b;<br/>    }<br/><br/>    <strong class="mc iu">return</strong> result;<br/>}</span></pre><p id="690b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，Zig中的可执行程序会有一个<code class="fe lz ma mb mc b">main</code>函数，就像C/C++程序一样。从那里我们可以调用我们的<code class="fe lz ma mb mc b">maximum</code>函数。在下一个代码示例中，不要太关注我们如何获取<code class="fe lz ma mb mc b">stdout</code>或者为什么我们需要用<code class="fe lz ma mb mc b">try</code>关键字作为<code class="fe lz ma mb mc b">print</code>函数调用的前缀。后者与Zig错误处理有关，我们不会在本文中涉及。</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="5728" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">pub</strong> <strong class="mc iu">fn</strong> main() !void {<br/>    const stdout = std.io.getStdOut().writer();<br/><br/>    const a = 10;<br/>    const b = 5;<br/><br/>    const biggest = maximum(a, b);<br/><br/>    <strong class="mc iu">try</strong> stdout.print("Max of {} and {} is {}\n", <br/>                     .{ a, b, biggest });<br/>}</span></pre><p id="b2ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显然，给出的解决方案相当有限。<code class="fe lz ma mb mc b">maximum</code>只对32位整数进行运算。c程序员对这个问题非常熟悉。在C程序员的世界里，C预处理器宏来拯救他们。然而，安德鲁·凯利将Zig设计成不依赖C风格的宏。事实上，Zig存在的全部原因是，Andrew只是想用C语言编程，但没有像宏这样不好的部分。<code class="fe lz ma mb mc b">comptime</code>的出现正是为了取代C宏。</p><p id="6322" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看这个问题的Zig解决方案。我们将在Zig中定义一个通用的<code class="fe lz ma mb mc b">maxiumum</code>函数。<code class="fe lz ma mb mc b">i32</code>类型参数将被替换为<code class="fe lz ma mb mc b">anytype</code>和<code class="fe lz ma mb mc b">@TypeOf(a)</code>。在调用<code class="fe lz ma mb mc b">maximum</code>函数时，<code class="fe lz ma mb mc b">anytype</code>将采用所提供的参数类型。请记住，我们不是在处理动态编程语言。相反，Zig将为每种情况编译不同的<code class="fe lz ma mb mc b">maximum</code>变体，其中<code class="fe lz ma mb mc b">maximum</code>是用一组不同的参数类型调用的。<code class="fe lz ma mb mc b">a</code>和<code class="fe lz ma mb mc b">b</code>的类型仍然在编译时确定，而不是在运行时确定。</p><p id="f272" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然可以在编译时确定输入参数的类型，但是对于变量或返回类型来说，这样做要复杂得多。您不能声明返回类型是<code class="fe lz ma mb mc b">anytype</code>，因为在调用位置无法确定具体的类型。相反，我们使用一个编译器内在函数<code class="fe lz ma mb mc b">@TypeOf</code>，它在编译时运行以产生返回类型。<code class="fe lz ma mb mc b">@TypeOf(a)</code>在编译时评估为<code class="fe lz ma mb mc b">a</code>参数的类型。我们使用同样的技巧来指定<code class="fe lz ma mb mc b">result</code>变量的类型。</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="8898" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">fn</strong> maximum(a: <strong class="mc iu">anytype</strong>, b: <strong class="mc iu">anytype</strong>) @TypeOf(a) {<br/>    <strong class="mc iu">var</strong> result: @TypeOf(a) = undefined;<br/><br/>    <strong class="mc iu">if </strong>(a &gt; b) {<br/>        result = a;<br/>    } <strong class="mc iu">else</strong> {<br/>        result = b;<br/>    }<br/><br/>    <strong class="mc iu">return</strong> result;<br/>}</span></pre><p id="9e5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这种解决方案是一种改进，但它有许多问题:</p><ol class=""><li id="6d4c" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">没有什么能阻止你用非数字的值调用<code class="fe lz ma mb mc b">maximum</code>。</li><li id="b072" class="mn mo it kw b kx mw la mx ld my lh mz ll na lp ms mt mu mv bi translated">如果<code class="fe lz ma mb mc b">b</code>是较大的值，它可能包含一个比类型<code class="fe lz ma mb mc b">@TypeOf(a)</code>所能容纳的位更多的值。</li></ol><p id="5659" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了检查<code class="fe lz ma mb mc b">a</code>和<code class="fe lz ma mb mc b">b</code>的类型是否正确，我们可以创建一个在编译时运行的函数来检查类型是否为数字。让我们定义一个函数<code class="fe lz ma mb mc b">assertNumber</code>，用一个参数<code class="fe lz ma mb mc b">T</code>代表一个类型而不是一个值。参数定义前面有关键字<code class="fe lz ma mb mc b">comptime</code>，告诉编译器参数<em class="nb">在编译时必须已知</em>。</p><p id="95bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要注意switch-case语句。在Zig中，switch-case可以返回值。我们打开类型参数<code class="fe lz ma mb mc b">T</code>。如果<code class="fe lz ma mb mc b">T</code>匹配一个数字类型，switch-case语句返回<code class="fe lz ma mb mc b">true</code>，它被赋给<code class="fe lz ma mb mc b">is_num</code>变量。否则，我们默认使用<code class="fe lz ma mb mc b">else</code>关键字返回<code class="fe lz ma mb mc b">false</code>。</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="35b4" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">fn</strong> assertNumber(comptime T: type) void {<br/>    const is_num = <strong class="mc iu">switch</strong> (T) {<br/>        i8, i16, i32, i64 =&gt; true,<br/>        u8, u16, u32, u64 =&gt; true,<br/>        comptime_int, comptime_float =&gt; true,<br/>        f16, f32, f64 =&gt; true,<br/>        <strong class="mc iu">else</strong> =&gt; false,<br/>    };<br/><br/>    <strong class="mc iu">if</strong> (!is_num) {<br/>        @compileError("Inputs must be numbers");<br/>    }<br/>}<br/><br/>// testing function<br/><strong class="mc iu">pub</strong> <strong class="mc iu">fn</strong> main() !void {<br/>    assertNumber(bool);<br/>}</span></pre><p id="eeba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对这个函数定义特别感兴趣的是编译器内部函数<code class="fe lz ma mb mc b">@compileError</code>。它用于向用户发送编译器错误。在这个代码示例中，我提供了一个非数字类型作为<code class="fe lz ma mb mc b">assertNumber</code>的参数。<code class="fe lz ma mb mc b">bool</code>具体来说。如果您尝试编译这个程序，您将会得到以下错误消息:</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="7f7d" class="mh mi it mc b gy mj mk l ml mm">assert-number.zig:11:9: error: Inputs must be numbers<br/>        @compileError("Inputs must be numbers");<br/>        ^<br/>assert-number.zig:17:17: note: called from here<br/>    assertNumber(bool);<br/>                ^<br/>assert-number.zig:16:21: note: called from here<br/>pub fn main() !void {</span></pre><p id="bae9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，我们可以以这样的方式编写代码，当用户试图编译无效代码时，我们可以给用户一个有用的错误消息。</p><p id="2a21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<code class="fe lz ma mb mc b">assertNumber</code>来检查<code class="fe lz ma mb mc b">maximum</code>函数的输入。为了确保返回类型足够大，我们将要求两个输入都是相同的类型。</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="91ab" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">fn</strong> maximum(a: <strong class="mc iu">anytype</strong>, b: <strong class="mc iu">anytype</strong>) @TypeOf(a) {<br/>    const A = @TypeOf(a);<br/>    const B = @TypeOf(b);<br/><br/>    assertNumber(A);<br/>    assertNumber(B);<br/><br/>    var result: @TypeOf(a) = undefined;<br/><br/>    <strong class="mc iu">if</strong> (A != B) {<br/>        @compileError("Inputs must be of the same type");<br/>    }<br/><br/>    <strong class="mc iu">if</strong> (a &gt; b) {<br/>        result = a;<br/>    } <strong class="mc iu">else</strong> {<br/>        result = b;<br/>    }<br/><br/>    <strong class="mc iu">return</strong> result;<br/>}</span></pre><p id="d690" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe lz ma mb mc b">maximum</code>在运行时被调用时，所有的编译时代码都已经运行并被它们的结果所取代。</p><p id="bd61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当前的解决方案不能解决我们最初天真的解决方案的所有问题。我们被迫将<code class="fe lz ma mb mc b">a</code>和<code class="fe lz ma mb mc b">b</code>参数设为同一类型。如果我们希望同时允许有符号的8位和有符号的32位整数参数呢？在Zig中，这将是类型为<code class="fe lz ma mb mc b">i8</code>和<code class="fe lz ma mb mc b">i32</code>的参数。在这种情况下，我们必须确保返回类型是<code class="fe lz ma mb mc b">i32</code>。我们当前的解决方案不能做到这一点。我们需要的是一个在编译时运行的函数，比较<code class="fe lz ma mb mc b">a</code>和<code class="fe lz ma mb mc b">b</code>的类型，并返回具有最高位长的类型。</p><p id="679b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了实现这一点，我们将制作一些函数:</p><ul class=""><li id="5f7d" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp nc mt mu mv bi translated"><code class="fe lz ma mb mc b">nbits</code>计算一种类型的位数的函数<code class="fe lz ma mb mc b">T</code></li><li id="6ea7" class="mn mo it kw b kx mw la mx ld my lh mz ll na lp nc mt mu mv bi translated"><code class="fe lz ma mb mc b">largestType</code>功能选择<code class="fe lz ma mb mc b">A</code>和<code class="fe lz ma mb mc b">B</code>两种类型中最大的</li></ul><p id="b999" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，在下一个代码示例中，我们如何用<code class="fe lz ma mb mc b">comptime</code>标记类型参数，以告诉Zig这些输入必须在编译时已知。我们使用<code class="fe lz ma mb mc b">@typeInfo</code>编译器内部函数，它在编译时返回一个复合对象<code class="fe lz ma mb mc b">info</code>，它描述了一个类型:这个类型是有符号的还是无符号的？用多少位来表示类型？</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="1a36" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">fn</strong> nbits(comptime T: type) i8 {<br/>    <strong class="mc iu">return</strong> <strong class="mc iu">switch</strong> (@typeInfo(T)) {<br/>        .Float =&gt; |info| info.bits,<br/>        .Int =&gt; |info| info.bits,<br/>        <strong class="mc iu">else</strong> =&gt; 64,<br/>    };<br/>}<br/><br/><strong class="mc iu">fn</strong> largestType(<strong class="mc iu">comptime</strong> A: type, comptime B: type) type {<br/>    <strong class="mc iu">if</strong> (nbits(A) &gt; nbits(B)) {<br/>        <strong class="mc iu">return</strong> A;<br/>    } <strong class="mc iu">else</strong> {<br/>        <strong class="mc iu">return</strong> B;<br/>    }<br/>}<br/><br/><strong class="mc iu">fn</strong> maximum(a: anytype, b: anytype) largestType(@TypeOf(a),<br/>                                               @TypeOf(b)) {<br/>    var result: @TypeOf(a) = undefined;<br/><br/>    <strong class="mc iu">if</strong> (a &gt; b) {<br/>        result = a;<br/>    } <strong class="mc iu">else</strong> {<br/>        result = b;<br/>    }<br/><br/>    <strong class="mc iu">return</strong> result;<br/>}</span></pre><p id="576f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面代码示例中的switch语句可能不太明显。让我澄清一下。从<code class="fe lz ma mb mc b">@typeInfo(T)</code>返回的类型是类型<code class="fe lz ma mb mc b">std.builtin.TypeInfo</code>，它是一个<em class="nb">联合类型</em>。联合类型有点像结构。它们有多个字段，但是这些字段共享内存。因此，我们需要弄清楚哪个字段实际上正在使用。开关盒允许我们确定当前使用的是<code class="fe lz ma mb mc b">.Int</code>还是<code class="fe lz ma mb mc b">.Float</code>字段。Zig使用<code class="fe lz ma mb mc b">|info|</code>语法来展开值。在这种情况下，我们展开描述类型的结构。</p><p id="fadf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lz ma mb mc b">info</code>对象可以是<code class="fe lz ma mb mc b">TypeInfo.Int</code>或<code class="fe lz ma mb mc b">TypeInfo.Float</code>类型，但是两种<code class="fe lz ma mb mc b">struct</code>类型都有一个<code class="fe lz ma mb mc b">bits</code>字段。</p><p id="0b27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们修改过的<code class="fe lz ma mb mc b">maximum</code>函数中，我们没有明确指定返回值。相反，我们调用<code class="fe lz ma mb mc b">largestType</code>函数，该函数返回我们想要用作<code class="fe lz ma mb mc b">maximum</code>的返回类型的类型。我知道这听起来很奇怪，但它确实有效，因为Zig编译器可以确定<code class="fe lz ma mb mc b">largestType</code>函数调用只依赖于编译时已知的信息。编译器会根据每个被调用的地方生成<code class="fe lz ma mb mc b">maximum</code>的多个变体。每个版本都将使用不同的输入和输出类型进行编译。</p><h1 id="1a23" class="nd mi it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">使用编译时代码实现泛型</h1><p id="62d8" class="pw-post-body-paragraph ku kv it kw b kx nu ju kz la nv jx lc ld nw lf lg lh nx lj lk ll ny ln lo lp im bi translated">为了展示Zig <code class="fe lz ma mb mc b">comptime</code>有多强大，我将向您展示如何使用它来实现泛型。这里我们实现了一个<code class="fe lz ma mb mc b">minimum</code>函数，对于习惯于泛型或基于模板的编程的开发人员来说，这个函数看起来更熟悉。一个关键的区别是类型参数<code class="fe lz ma mb mc b">T</code>是作为常规参数提供的。C++、Java和C#开发人员会通过编写类似于<code class="fe lz ma mb mc b">minimum&lt;i8&gt;(x, y)</code>的东西来调用这个函数，而Zig开发人员编写的是<code class="fe lz ma mb mc b">minimum(i8, x, y)</code>。</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="193f" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">fn</strong> minimum(<strong class="mc iu">comptime</strong> T: type, a: T, b: T) T {<br/>    assertNumber(T);<br/><br/>    var result: T = undefined;<br/>    <strong class="mc iu">if</strong> (a &lt; b) {<br/>        result = a;<br/>    } <strong class="mc iu">else</strong> {<br/>        result = b;<br/>    }<br/><br/>    <strong class="mc iu">return</strong> result;<br/>}</span></pre><p id="05ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在C++、Java、C++和Swift等语言中，通常可以通过查看输入参数来推断类型。使用Zig，这样的类型推断是不可能的，因为参数<code class="fe lz ma mb mc b">T</code>是作为常规参数提供的，因此不能得到特殊处理。虽然这个限制是<code class="fe lz ma mb mc b">comptime</code>优于泛型的一个缺点，但好处是<code class="fe lz ma mb mc b">comptime</code>在使用上更加灵活。</p><p id="c1b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<code class="fe lz ma mb mc b">comptime</code>代码来定义泛型类型。我将用一个简单的2D向量类来演示，它用来表示力、速度或位置等东西。</p><h2 id="7a5c" class="mh mi it bd ne nz oa dn ni ob oc dp nm ld od oe no lh of og nq ll oh oi ns oj bi translated">2D向量类型</h2><p id="c4ff" class="pw-post-body-paragraph ku kv it kw b kx nu ju kz la nv jx lc ld nw lf lg lh nx lj lk ll ny ln lo lp im bi translated">我们将从称为<code class="fe lz ma mb mc b">Vector2D</code>的非通用复合类型的定义开始，该复合类型用于表示平面中的位移。两个字段<code class="fe lz ma mb mc b">dx</code>和<code class="fe lz ma mb mc b">dy</code>用于保存沿x轴和y轴的位移。每个字段的默认值都设置为零。我们得到了<code class="fe lz ma mb mc b">sub</code>和<code class="fe lz ma mb mc b">add</code>成员函数来处理减法和加法向量。</p><p id="2f7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lz ma mb mc b">format</code>功能很好用。您可以将此函数添加到任何结构中，以允许通过<code class="fe lz ma mb mc b">print</code>函数显示结构。它给出了复合类型的默认文本表示。</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="824b" class="mh mi it mc b gy mj mk l ml mm">const Vector2D = <strong class="mc iu">struct</strong> {<br/>    dx: f64 = 0,<br/>    dy: f64 = 0,<br/><br/>    <strong class="mc iu">fn</strong> sub(u: Vector2D, v: Vector2D) Vector2D {<br/>        <strong class="mc iu">return</strong> Vector2D { <br/>			.dx = u.dx - v.dx,<br/>			.dy = u.dy - v.dy<br/>		};<br/>    }<br/><br/>    <strong class="mc iu">fn</strong> add(u: Vector2D, v: Vector2D) Vector2D {<br/>        <strong class="mc iu">return</strong> Vector2D { <br/>			.dx = u.dx + v.dx, <br/>			.dy = u.dy + v.dy <br/>		};<br/>    }<br/><br/>    <strong class="mc iu">pub</strong> <strong class="mc iu">fn</strong> format(<br/>        v: Vector2D,<br/>        <strong class="mc iu">comptime</strong> _: []const u8,<br/>        _: std.fmt.FormatOptions,<br/>        writer: anytype,<br/>    ) !void {<br/>        <strong class="mc iu">try</strong> writer.print("Vector2D({}, {})", .{ v.dx, v.dy });<br/>    }<br/>};</span></pre><p id="6d5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用这个<code class="fe lz ma mb mc b">Vector2D</code>定义来定义一个<code class="fe lz ma mb mc b">main</code>函数。注意我们如何使用<code class="fe lz ma mb mc b">{}</code>作为<code class="fe lz ma mb mc b">Vector2D</code>值的占位符。感谢<code class="fe lz ma mb mc b">format</code>功能，<code class="fe lz ma mb mc b">print</code>将知道在<code class="fe lz ma mb mc b">{}</code>占位符处插入什么文本。</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="2e29" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">pub</strong> <strong class="mc iu">fn</strong> main() !void {<br/>    const stdout = std.io.getStdOut().writer();<br/><br/>    const u = Vector2D{ .dx = 5, .dy = 4 };<br/>    const v = Vector2D{ .dx = 10, .dy = 2 };<br/><br/>    <strong class="mc iu">try</strong> stdout.print("Adding u and v gives {}\n", .{u.add(v)});<br/>    <strong class="mc iu">try</strong> stdout.print("Subtracting u from v gives {}\n", <br/>                     .{v.sub(u)});<br/>}</span></pre><p id="f2ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行这个程序，我们得到以下预期输出:</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="6b21" class="mh mi it mc b gy mj mk l ml mm">Adding u and v gives Vector2D(15, 6)<br/>Subtracting u from v gives Vector2D(5, -2)</span></pre><p id="ddcd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当前解决方案的问题是，它被硬连线到具有64位浮点位移值的2D向量。如果我们想使用整数或不同的位长呢？这样做需要在我们当前的解决方案中复制代码。让我们看看<code class="fe lz ma mb mc b">comptime</code>如何帮助我们避免代码重复。</p><h2 id="07bb" class="mh mi it bd ne nz oa dn ni ob oc dp nm ld od oe no lh of og nq ll oh oi ns oj bi translated">通用2D向量类型</h2><p id="8bde" class="pw-post-body-paragraph ku kv it kw b kx nu ju kz la nv jx lc ld nw lf lg lh nx lj lk ll ny ln lo lp im bi translated">为了能够为给定的字段类型<code class="fe lz ma mb mc b">T</code>快速生成一个<code class="fe lz ma mb mc b">Vector2D</code>类型，我们将定义一个函数<code class="fe lz ma mb mc b">Vector2D(T: type)</code>，它将类型参数<code class="fe lz ma mb mc b">T</code>作为输入，并返回一个在该类型上参数化的2D向量类型。因此，我们正在处理类型为<code class="fe lz ma mb mc b">type</code>的值。保存类型的变量属于类型<code class="fe lz ma mb mc b">type</code>。在编译时，Zig允许我们返回或接受像结构这样的类型作为参数。我们在下面的代码中利用了这种能力。该函数返回一个<code class="fe lz ma mb mc b">struct</code>类型定义。</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="dc83" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">fn</strong> Vector2D(<strong class="mc iu">comptime</strong> T: <strong class="mc iu">type</strong>) <strong class="mc iu">type</strong> {<br/>    <strong class="mc iu">return</strong> struct {<br/>        dx: T = 0,<br/>        dy: T = 0,<br/><br/>        <strong class="mc iu">fn</strong> sub(u: Vector2D(T), v: Vector2D(T)) Vector2D(T) {<br/>            return Vector2D(T) { <br/>				.dx = u.dx - v.dx, <br/>				.dy = u.dy - v.dy <br/>			};<br/>        }<br/><br/>        <strong class="mc iu">fn</strong> add(u: Vector2D(T), v: Vector2D(T)) Vector2D(T) {<br/>            return Vector2D(T) { <br/>				.dx = u.dx + v.dx, <br/>				.dy = u.dy + v.dy<br/>			};<br/>        }<br/><br/>        <strong class="mc iu">pub</strong> <strong class="mc iu">fn</strong> format(<br/>            v: Vector2D(T),<br/>            comptime _: []const u8,<br/>            _: std.fmt.FormatOptions,<br/>            writer: anytype,<br/>        ) !void {<br/>            <strong class="mc iu">try</strong> writer.print("Vector2D({d}, {d})", .{ v.dx, v.dy });<br/>        }<br/>    };<br/>}</span></pre><p id="ce14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个使用我们创建的<code class="fe lz ma mb mc b">Vector2D</code>函数的例子。该函数允许我们按需剔除新的2D向量类型。在编译期间，<code class="fe lz ma mb mc b">Vector2D(i8)</code>调用将被一个实际的2D向量类型所取代，该向量类型将<code class="fe lz ma mb mc b">dx</code>和<code class="fe lz ma mb mc b">dy</code>字段作为8位有符号整数值。因此，在代码被调用后，这些泛型类型就消失了。代码只包含具体类型。</p><pre class="ki kj kk kl gt md mc me mf aw mg bi"><span id="cda1" class="mh mi it mc b gy mj mk l ml mm"><strong class="mc iu">pub</strong> <strong class="mc iu">fn</strong> main() !void {<br/>    const stdout = std.io.getStdOut().writer();<br/><br/>    const u = Vector2D(i8){ .dx = 5, .dy = 4 };<br/>    const v = Vector2D(i8){ .dx = 10, .dy = 2 };<br/><br/>    <strong class="mc iu">try</strong> stdout.print("Adding u and v gives {}\n", .{u.add(v)});<br/>    <strong class="mc iu">try</strong> stdout.print("Subtracting u from v gives {}\n", <br/>                     .{v.sub(u)});<br/>}</span></pre><h1 id="c1e0" class="nd mi it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">结束语</h1><p id="b0af" class="pw-post-body-paragraph ku kv it kw b kx nu ju kz la nv jx lc ld nw lf lg lh nx lj lk ll ny ln lo lp im bi translated">我发现Zig <code class="fe lz ma mb mc b">comptime</code>解决方案的美妙之处在于开发人员自己可以创建所有这些很酷的特性，比如特别的泛型类型。语言设计者从来不需要显式地设计语言来拥有模板。安德鲁·凯利只是想找到一种替代C宏的方法，而所有这些东西都是副作用。我非常喜欢动态类型语言，比如Lisp、Julia和Lua。我喜欢动态语言的很多原因是我们在元编程方面获得的灵活性。多亏了<code class="fe lz ma mb mc b">comptime</code>，Zig将这一点带入了静态类型的世界。</p><p id="93b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我做了大约15年的C++开发人员，尽管我使用的语言非常复杂，但我还是被迫写了这么多重复的样板代码，这一直困扰着我。具有强大功能和灵活性的简单语言一直吸引着我。Zig做了我认为几乎不可能的事情，即在静态类型语言中实现简单、灵活和强大。Zig是一种类似于C的非常低级的语言，这使得它能够具有这种程度的灵活性更加令人瞩目。</p><p id="2f71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也许是你在使用Zig时需要不断提醒自己的事情之一:它只是类固醇上的一种C。你不是在用高级语言工作。Zig没有提供闭包、自动内存管理、继承，甚至接口。它是一种基本的语言，但<code class="fe lz ma mb mc b">comptime</code>经常可以与你的感知进行游戏，因为它非常强大。</p></div></div>    
</body>
</html>