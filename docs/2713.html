<html>
<head>
<title>JavaScript Fundamentals: Mastering Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础:掌握类</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-fundamentals-mastering-classes-38e7668023be?source=collection_archive---------2-----------------------#2019-07-17">https://itnext.io/javascript-fundamentals-mastering-classes-38e7668023be?source=collection_archive---------2-----------------------#2019-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/896c4a0bf30f8d13ad7fb7d609e87b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BHWKXevzWq-lmCEIRvhfvA.png"/></div></div></figure><p id="fdc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在ECMAScript 2015中引入了JavaScript类，它们通常被描述为JavaScript现有原型继承结构上的<em class="kz">语法糖</em>。因此，虽然类<em class="kz">没有</em>为JavaScript引入新的继承模型，但它们确实提供了语法上的简单性。这种简单性可以帮助我们产生更少的易错代码。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="efb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🤓<em class="kz">想了解最新的web开发吗？</em>T12】🚀<em class="kz">想要将最新消息直接发送到您的收件箱？<br/>🎉加入一个不断壮大的设计师&amp;开发者社区！</em></p><p id="9aa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在这里订阅我的简讯→</strong><a class="ae lh" href="https://easeout.eo.page/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://ease out . EO . page</strong></a></p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="cf4a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">类就像函数！</h1><p id="0165" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">类与函数非常相似。很像既有函数表达式又有函数声明的函数，类有两个组成部分:<strong class="kd iu">类表达式</strong>和<strong class="kd iu">类声明</strong>。</p><h1 id="61e9" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">类声明</h1><p id="7dec" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">让我们看看如何使用<strong class="kd iu">类声明</strong>来定义一个类。我们在类名后面使用了<code class="fe mq mr ms mt b">class </code>关键字:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="4ff8" class="nc lj it mt b gy nd ne l nf ng">class Image {<br/>  constructor(height, width) {<br/>    this.height = height;<br/>    this.width = width;<br/>  }<br/>}</span></pre><h2 id="cbf4" class="nc lj it bd lk nh ni dn lo nj nk dp ls km nl nm lw kq nn no ma ku np nq me nr bi translated">提升</h2><p id="a032" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated"><strong class="kd iu">函数声明</strong>和<strong class="kd iu">类声明</strong>的一个重要区别是函数声明被提升，而类声明没有。您首先需要声明您的类，然后访问它，否则像下面这样的代码将抛出一个<code class="fe mq mr ms mt b">ReferenceError</code>:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="063b" class="nc lj it mt b gy nd ne l nf ng">const p = new Image(); // ReferenceError</span><span id="5f45" class="nc lj it mt b gy ns ne l nf ng">class Image{}</span></pre><h1 id="8333" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">类别表达式</h1><p id="da18" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">一个<strong class="kd iu">类表达式</strong>是定义类的另一种方式。类表达式可以是命名的，也可以是未命名的。请注意，命名类表达式的名称是局部于类体的。(因此可以通过该类的<code class="fe mq mr ms mt b">name</code>属性来检索):</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="bfe3" class="nc lj it mt b gy nd ne l nf ng">// An unnamed class expression<br/>let Image = class {<br/>  constructor(height, width) {<br/>    this.height = height;<br/>    this.width = width;<br/>  }<br/>};<br/>console.log(Image.name);<br/>// output: "Image"</span><span id="5583" class="nc lj it mt b gy ns ne l nf ng">// A named class expression<br/>let MyImage = class Image {<br/>  constructor(height, width) {<br/>    this.height = height;<br/>    this.width = width;<br/>  }<br/>};<br/>console.log(MyImage.name);<br/>// output: "Image"</span></pre><p id="40a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">注:</em>类<strong class="kd iu">表达式</strong>受到与之前在类声明部分描述的相同的提升限制。</p><h1 id="5d89" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">构造器</h1><p id="de89" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated"><code class="fe mq mr ms mt b">constructor</code>方法是JavaScript中的一个特殊方法，我们用它来创建和初始化一个用<code class="fe mq mr ms mt b">class</code>创建的对象。我们只能在一个类中使用一个名为“constructor”的方法。</p><p id="831d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的构造函数可以使用<code class="fe mq mr ms mt b">super</code>关键字来调用超类的构造函数(在本文后面会有更多的介绍！).</p><h1 id="b60d" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">实例属性</h1><p id="cf25" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">实例属性必须在我们的类方法中定义:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="4c7b" class="nc lj it mt b gy nd ne l nf ng">class Image {<br/>  constructor(height, width) {    <br/>    this.height = height;<br/>    this.width = width;<br/>  }<br/>}</span></pre><p id="4193" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们希望使用静态类端属性和原型数据属性，这些属性必须在类体声明之外定义:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="743c" class="nc lj it mt b gy nd ne l nf ng">Image.staticWidth = 50;<br/>Image.prototype.prototypeWidth = 55;</span></pre><h1 id="3a70" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">字段声明</h1><p id="8f40" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">虽然语法仍被认为是实验性的(许多浏览器尚未采用)，但公共和私有字段声明也是值得了解的——因为您经常会开发一个Babel来为您转换语法。</p><h2 id="4c95" class="nc lj it bd lk nh ni dn lo nj nk dp ls km nl nm lw kq nn no ma ku np nq me nr bi translated">公共字段声明</h2><p id="da47" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">让我们用JavaScript字段声明语法重温一下我们的例子:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="cb10" class="nc lj it mt b gy nd ne l nf ng">class Image {<br/>  height = 0;<br/>  width;<br/>  constructor(height, width) {    <br/>    this.height = height;<br/>    this.width = width;<br/>  }<br/>}</span></pre><p id="0ad4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不同之处在于我们的字段已经预先声明。所以我们的类定义变得更加自文档化，并且字段总是存在。</p><p id="a44c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">注意:</em>字段可以声明有或没有默认值！</p><h2 id="a505" class="nc lj it bd lk nh ni dn lo nj nk dp ls km nl nm lw kq nn no ma ku np nq me nr bi translated">私有字段声明</h2><p id="6c29" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">当我们使用私有字段时，定义可以细化如下:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="6fc9" class="nc lj it mt b gy nd ne l nf ng">class Image {<br/>  #height = 0;<br/>  #width;<br/>  constructor(height, width) {    <br/>    this.#height = height;<br/>    this.#width = width;<br/>  }<br/>}</span></pre><p id="6c44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">私有字段(用<code class="fe mq mr ms mt b">#</code>声明)不能在类外引用，只能在类体内引用。这确保了你的类的用户不能依赖于内部，因为内部可能会随着版本的改变而改变。</p><p id="e690" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">注意:</em>私有字段以后不能通过赋值来创建。它们只能在字段声明中预先声明。</p><h1 id="dd69" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">使用'<code class="fe mq mr ms mt b">extends'</code>的子类</h1><p id="2ec6" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我们可以使用<code class="fe mq mr ms mt b">extends</code>关键字和<em class="kz">类声明</em>或<em class="kz">类表达式</em>来创建一个类作为另一个类的子类。</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="3dbb" class="nc lj it mt b gy nd ne l nf ng">class Vehicle{ <br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  <br/>  sound() {<br/>    console.log(`${this.name} makes a sound.`);<br/>  }<br/>}</span><span id="b327" class="nc lj it mt b gy ns ne l nf ng">class Car extends Vehicle{<br/>  constructor(name) {<br/>    super(name); // call the super class constructor and pass in the name parameter<br/>  }</span><span id="7d56" class="nc lj it mt b gy ns ne l nf ng">  sound() {<br/>    console.log(`The ${this.name} tooted its horn!`);<br/>  }<br/>}</span><span id="6763" class="nc lj it mt b gy ns ne l nf ng">let c = new Car('<!-- -->Volkswagen<!-- -->');<br/>c.sound(); // The <!-- -->Volkswagen<!-- --> tooted its horn!</span></pre><p id="4d05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果子类中存在构造函数，那么在使用“this”之前，需要先调用super()。</p><p id="6a9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于函数的“类”也可以扩展:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="72e2" class="nc lj it mt b gy nd ne l nf ng">function Vehicle (name) {<br/>  this.name = name;  <br/>}</span><span id="8c20" class="nc lj it mt b gy ns ne l nf ng">Vehicle.prototype.sound = function () {<br/>  console.log(`${this.name} makes a sound.`);<br/>}</span><span id="2a30" class="nc lj it mt b gy ns ne l nf ng">class Car extends Vehicle{<br/>  speak() {<br/>    console.log(`The ${this.name} tooted its horn!`);<br/>  }<br/>}</span><span id="49b0" class="nc lj it mt b gy ns ne l nf ng">let c = new Car('<!-- -->Volkswagen<!-- -->');<br/>c.sound(); // The <!-- -->Volkswagen<!-- --> tooted its horn!</span></pre><p id="40b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">注意:</em>类不能扩展常规对象！如果你想从一个对象继承，使用<code class="fe mq mr ms mt b">Object.setPrototypeOf()</code>:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="66ca" class="nc lj it mt b gy nd ne l nf ng">const Vehicle = {<br/>  sound() {<br/>    console.log(`${this.name} makes a sound.`);<br/>  }<br/>};</span><span id="7369" class="nc lj it mt b gy ns ne l nf ng">class Car{<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="023c" class="nc lj it mt b gy ns ne l nf ng">let c = new Car('<!-- -->Volkswagen<!-- -->');<br/>c.sound(); // <!-- -->Volkswagen<!-- --> makes a sound.</span></pre><h1 id="f4ad" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">种类</h1><p id="b298" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">如果你想从数组类<code class="fe mq mr ms mt b">MyArray</code>中返回<code class="fe mq mr ms mt b">Array</code>对象。您可以使用“物种”模式来实现这一点，该模式允许您覆盖默认的构造函数。</p><p id="1603" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果使用像<code class="fe mq mr ms mt b">map()</code>这样的方法，它将返回默认的构造函数。然后你会希望这些方法返回一个父<code class="fe mq mr ms mt b">Array</code>对象，而不是<code class="fe mq mr ms mt b">MyArray</code>对象。<code class="fe mq mr ms mt b">Symbol.species </code>让你这样做，就像这样:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="c7db" class="nc lj it mt b gy nd ne l nf ng">class MyArray extends Array {<br/>  // Overwrite species to the parent Array constructor<br/>  static get [Symbol.species]() { return Array; }<br/>}</span><span id="a6c7" class="nc lj it mt b gy ns ne l nf ng">let a = new MyArray(1,2,3);<br/>let mapped = a.map(x =&gt; x * x);</span><span id="431c" class="nc lj it mt b gy ns ne l nf ng">console.log(mapped instanceof MyArray); // false<br/>console.log(mapped instanceof Array);   // true</span></pre><h1 id="c554" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">“超级”关键词</h1><p id="daec" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated"><code class="fe mq mr ms mt b">super</code>关键字用于调用超类的相应方法。这是基于原型的继承的一个优势。让我们看一个例子:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="32ee" class="nc lj it mt b gy nd ne l nf ng">class <!-- -->Volkswagen<!-- --> { <br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  <br/>  sound() {<br/>    console.log(`${this.name} makes a sound.`);<br/>  }<br/>}</span><span id="432c" class="nc lj it mt b gy ns ne l nf ng">class Beetle extends <!-- -->Volkswagen<!-- --> {<br/>  sound() {<br/>    super.sound();<br/>    console.log(`${this.name} toots it's horn.`);<br/>  }<br/>}</span><span id="b081" class="nc lj it mt b gy ns ne l nf ng">let b = new Beetle('Herbie');<br/>b.sound(); <br/>// Herbie makes a sound.<br/>// Herbie toots it's horn.</span></pre><h1 id="19d6" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">混合食品</h1><p id="3197" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated"><em class="kz">混音版</em>是类的模板。一个ECMAScript类只能有一个超类，所以从工具类的多重继承是不可能的。该功能必须由超类提供。</p><p id="9071" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在ECMAScript中，可以使用一个将超类作为输入、将该超类扩展为输出的子类来实现混合功能:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="d73d" class="nc lj it mt b gy nd ne l nf ng">let calculatorMixin = Base =&gt; class extends Base {<br/>  calc() { }<br/>};</span><span id="8b13" class="nc lj it mt b gy ns ne l nf ng">let randomizerMixin = Base =&gt; class extends Base {<br/>  randomize() { }<br/>};</span></pre><p id="74cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用这些混合的类可以写成这样:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="2b3f" class="nc lj it mt b gy nd ne l nf ng">class First { }<br/>class Second extends calculatorMixin(randomizerMixin(First)) {</span></pre></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="a603" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="kz">你准备好让你的JavaScript技能更上一层楼了吗？</em> </strong> <em class="kz">今天就开始用我的新电子书吧！无论你是想学习你的第一行代码，还是想扩展你的知识面并真正学习基础知识..</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank"><em class="kz">JavaScript精通完全指南</em> </a> <em class="kz">带你从零到英雄！</em></p><figure class="mu mv mw mx gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/dde515044536421c6c999650977f80c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fUokZkbKj-qlRPVN_Txrg.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated"><em class="ny">现已上市！👉</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank">https://gum.co/mastering-javascript</a></figcaption></figure><h1 id="b5b2" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">结论</h1><p id="8202" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">今天就到这里吧！我们已经深入研究了JavaScript类，包括类声明、类表达式、构造函数、实例属性、字段声明、扩展、种类、超级和混合。</p><p id="abc4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对你有用！你可以在Medium上<a class="ae lh" href="https://medium.com/@timothyrobards" rel="noopener">关注我</a>。我也在<a class="ae lh" href="https://twitter.com/easeoutco" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h1 id="d19f" class="li lj it bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">关于我的一点点..</h1><p id="72d3" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">嘿，我是提姆！👋我是一名开发人员、技术作家和作家。如果你想看我所有的教程，可以在我的个人博客上找到。</p><p id="50a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我目前正在撰写我的<a class="ae lh" href="http://www.easeout.co/freelance" rel="noopener ugc nofollow" target="_blank">自由职业完整指南</a>。坏消息是它还不可用！但是如果这是你可能感兴趣的东西，你可以<a class="ae lh" href="https://easeout.eo.page/news" rel="noopener ugc nofollow" target="_blank">注册，当它可用的时候会通知你👍</a></p><p id="71dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读🎉</p></div></div>    
</body>
</html>