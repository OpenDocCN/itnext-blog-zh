<html>
<head>
<title>C++ vs Rust — simple polymorphism comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++与Rust——简单的多态性比较</h1>
<blockquote>原文：<a href="https://itnext.io/c-vs-rust-simple-polymorphism-comparison-e4d16024b57?source=collection_archive---------0-----------------------#2020-11-26">https://itnext.io/c-vs-rust-simple-polymorphism-comparison-e4d16024b57?source=collection_archive---------0-----------------------#2020-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我的第一个Medium.com故事。在阅读、发推特和用书签标记了数百个故事之后，我决定为那些像我一样从C++学习Rust的人创建一个简单的故事。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="e7c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇短文中，我们将比较C++和Rust处理动态多态性的方式。快速声明，我不是一个Rust专家，而是一个更熟悉C++的人(顺便说一下，你可以参加我们在https://www.meetup.com/San-Diego-CPP/的圣地亚哥C++聚会)</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="208c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从多态性的目的开始:通过动态的运行时多态性，我们能够保存一个指向一个类型的指针或引用，该类型实际上指向一个更具体的派生类型。这是人们在使用面向对象语言时学到的基本知识。对于我们的例子，我们将使用<strong class="jp ir">动物</strong>作为基础，顶级类型，以及更具体的类型，如<strong class="jp ir">猫</strong>和<strong class="jp ir">狗</strong>。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/c87f84478884702bd46efad283406029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrUAG0HGJ_9CFEQRjcm2Dg.png"/></div></div></figure><p id="a0bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">动物</strong>类类型有一种</p><ol class=""><li id="7d0b" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">虚拟默认析构函数。这是在处理堆分配时释放正确类型所必需的。虽然这超出了本文的范围，但是请在评论部分提问。</li><li id="cc8a" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">虚方法/成员函数<strong class="jp ir"> talk() </strong>。它是纯虚拟的，没有实现。派生的具体类类型必须实现它才能创建实例。以下是方法:</li></ol><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lt"><img src="../Images/81435b2ab85ad6338a59d5672360a3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CXaRyUzqNkoQlAHeQlEnQ.png"/></div></div></figure><p id="32b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面很简单:我们创建两个新的<strong class="jp ir"> </strong>类，<strong class="jp ir"> Dog </strong>和<strong class="jp ir"> Cat </strong>，使用<strong class="jp ir"> Animal </strong>的公共继承，实现<strong class="jp ir"> Animal </strong>基类，<strong class="jp ir"> talk()中声明的纯虚函数。</strong>final关键字定义了这个类将是一个叶子类型。您不能从<strong class="jp ir"> Dog/Cat子类化。</strong></p><p id="e4bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们如何使用“现代C++”中演示的类层次结构。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lu"><img src="../Images/b55e902e582ea3608b8d21697cc7e26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9i2qtRgYIMMSvWPlWyQWQ.png"/></div></div></figure><p id="a75e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了进行编译，你将需要<strong class="jp ir">#包含</strong>以下头文件:<strong class="jp ir"> &lt; iostream &gt; </strong>，<strong class="jp ir"> &lt;内存&gt; </strong>和&lt;矢量&gt; 。</p><p id="6e36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的主函数中，我们创建了一个指向<strong class="jp ir">动物</strong>类类型的指针向量。我们使用<strong class="jp ir"> unique_ptr &lt; &gt; </strong>来管理堆的分配和释放。这是C++11的一个特性。<strong class="jp ir"> make_unique &lt;</strong></p><p id="3785" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们创建循环(C++11特性—循环的<strong class="jp ir">范围)来迭代<strong class="jp ir">动物</strong>，并在每个实例上调用<strong class="jp ir"> talk() </strong>。只要每个类型实现了<strong class="jp ir"> talk() </strong>接口(覆盖<strong class="jp ir"> Animal </strong>基类的虚函数)，具体实例的类型就无关紧要了。</strong></p><p id="a30f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是输出:</p><pre class="ku kv kw kx gt lv lw lx ly aw lz bi"><span id="feb1" class="ma mb iq lw b gy mc md l me mf">I'm a dog</span><span id="135a" class="ma mb iq lw b gy mg md l me mf">I'm a cat</span></pre></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="9c9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们对铁锈做同样的事情。</p><p id="a217" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Rust与C++不同，因为它实现了类型定义之外的类型接口。</p><p id="97d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让大家理解这一点，让我们再做一个与上一个例子相似的例子。首先，让我们实现一个特征，或者一个接口的定义。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/8441e23f89fec1a9cc9d8968d49264da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*DK5NjMNrVtJIEuIjHfHHPA.png"/></div></figure><p id="1c97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们定义了一个<strong class="jp ir"> Animal </strong> trait，它有一个不返回任何东西(void)的函数，并使用<strong class="jp ir"> &amp; self </strong>作为函数的参数。Rust中的<strong class="jp ir"> &amp; self </strong>概念类似于C++中的<strong class="jp ir"> this </strong>指针。</p><p id="b883" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们可以定义<strong class="jp ir">狗/猫</strong>并实现这个trait(或者特性/接口)。</p><p id="8865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Rust中，我们在开始添加功能之前定义了没有接口的<strong class="jp ir">狗/猫</strong>。相反，C++同时定义了类和它们的特性。因此，在C++中，独立的<strong class="jp ir"> Dog/Cat </strong>类类型已经能够进行<strong class="jp ir"> talk() </strong>。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mi"><img src="../Images/73a5e445f71775b415418e395332c56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOHaWOe_OjgpZ6q4mL_n6Q.png"/></div></div></figure><p id="55ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后要实现的是<strong class="jp ir"> main() </strong>，它迭代<strong class="jp ir"> Dog </strong> / <strong class="jp ir"> Cat </strong>实例。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi mj"><img src="../Images/6f782621ef25a3beb634e0b60a9c82a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgNd--st24kjVyR565QVFQ.png"/></div></div></figure><p id="b198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Rust的<strong class="jp ir"> Box &lt; &gt; </strong>就像C++的<strong class="jp ir"> unique_ptr &lt; &gt; </strong>:我们创建一个<strong class="jp ir"> Animal </strong> s的向量，并在每次迭代中调用<strong class="jp ir"> talk() </strong>，保持输出与我们的C++示例中相同。</p><p id="db24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">盒子&lt; &gt; </strong>里面的<strong class="jp ir">【dyn Animal】</strong>之所以存在，仅仅是因为Rust不知道<strong class="jp ir">动物</strong>性状的大小。特征没有“大小”，因为特征只是接口。为了让程序能够编译，我们告诉Rust,<strong class="jp ir">Animal</strong>trait是一个动态类型，它将被实例化(堆分配),用一个实现这个trait的具体类型。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="687c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是现在，希望你喜欢阅读我的第一篇文章。我们发现，尽管两种语言的语法截然不同，但在实现多态性语义时有很多相似之处。</p></div></div>    
</body>
</html>