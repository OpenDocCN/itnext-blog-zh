<html>
<head>
<title>How to Rock the Party with Apollo GraphQL Cache🎉🎈</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Apollo GraphQL缓存震撼派对🎉🎈</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-rock-the-party-with-apollo-graphql-cache-f4679e4abd4e?source=collection_archive---------5-----------------------#2019-09-23">https://itnext.io/how-to-rock-the-party-with-apollo-graphql-cache-f4679e4abd4e?source=collection_archive---------5-----------------------#2019-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6eb696e09682ad5283b0805c1b35d462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAdceAQUZpc-wrguIEYE3Q.jpeg"/></div></div></figure><p id="52ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嗨，我是<code class="fe kz la lb lc b">apollo-cache-inmemory</code>又名<code class="fe kz la lb lc b"><strong class="kd iu">Apollo Cache</strong></code>。我是你的Apollo客户端中缓存的默认实现。所以让我解释一下我们为什么在这里！</p><p id="c39e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我会在你需要的时候帮助你访问和操作缓存。你进行了变异吗？别担心！我可以帮你更新缓存。哦，顺便说一下，那个<code class="fe kz la lb lc b">Redux</code>很酷，但是你可能不需要再和他一起存储数据了🤷‍♂.请允许我…</p><p id="c998" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嗯...谢谢，阿波罗缓存的介绍，但我想我会从这里开始。</p><p id="33f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，所以当我第一次尝试阿波罗缓存的时候，我是无法理解的。有这么多不同的用例，我肯定会迷路。将“__typename”添加到所有的混乱中。所以我决定让阿波罗·凯奇成为我的朋友。事情是这样的:</p><p id="b7eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，你得邀请阿波罗缓存参加你的派对:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="566f" class="ll lm it lc b gy ln lo l lp lq">npm install apollo-cache-inmemory --save</span></pre><p id="188e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，阿波罗缓存将开始打破常规。刚介绍到<code class="fe kz la lb lc b">Apollo Client</code>(阿波罗客户端对缓存情有独钟)嘣！</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="cc4b" class="ll lm it lc b gy ln lo l lp lq">const cache = new InMemoryCache();<br/><br/>const client = new ApolloClient({<br/>  link: new HttpLink(),<br/>  cache<br/>});</span></pre><p id="3283" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是我们想让它做更多的事情。所以，让它明白你的聚会规则，这样它就会按照你想要的方式行动。类似于<code class="fe kz la lb lc b">code of conduct</code>的东西？我们将在其构造函数中提供行为准则。对了，这是<strong class="kd iu">全可选</strong>。所以我们开始吧！</p><p id="186e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">行为准则:</strong></p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lr"><img src="../Images/ed985c436438f8e499c6bcb036805371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpbT9HLPNncWutLwepjkcQ.jpeg"/></div></div></figure><p id="9ba5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> addTypename: </strong>一个布尔值，指定是否将<code class="fe kz la lb lc b">__typename</code>添加到文档中。(默认为真)。<em class="ls">稍后详细介绍。</em></p><p id="1aa5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> dataIdFromObject: </strong>缓存在将所有数据保存到存储之前对其进行规范化。这是一个接受数据对象并返回唯一id的函数。<em class="ls">在后面的故事中会详细介绍它的用法。</em></p><p id="bc13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">片段匹配器:</strong>默认情况下，Apollo缓存使用启发式片段匹配器。如果你打算在联合和接口上使用片段，这是一件<strong class="kd iu">奇怪的</strong>事情，你需要<a class="ae lt" href="https://www.apollographql.com/docs/react/advanced/fragments/#fragments-on-unions-and-interfaces" rel="noopener ugc nofollow" target="_blank">告诉</a> apollo cache。</p><p id="e10f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> cacheRedirects: </strong>有时，我们会请求apollo cache已经存在于其存储中但位于不同资源键下的数据。通过cacheRedirects，我们告诉apollo cache在哪里寻找已经存在的数据。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/6e94daf3bbf4a230b2df048df1d2e90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HEDZS65zF1Yn52NhWhBP1Q.jpeg"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">醉酒阿波罗缓存</figcaption></figure><p id="8b2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">阿波罗缓存立即在党内流行。所有的派对客人(你可以把他们想象成组件)都与缓存交互。我们在玩<a class="ae lt" href="https://www.icebreakers.ws/active/react-and-act-game.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">反应和行动</strong> </a> <strong class="kd iu"> 🧐 </strong>在<strong class="kd iu"> </strong>中，其中<strong class="kd iu"> </strong>缓存保存了我们可以采取行动的所有事件以及每个团队的分数。让我告诉你，它做得很棒。阿波罗缓存做了三件事来快速存储和检索数据—</p><ol class=""><li id="aa15" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">将数据分割成单独的对象</li><li id="4306" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">为每个对象创建一个唯一的标识符</li><li id="061c" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">将数据存储在扁平数据结构中</li></ol><p id="f90f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它使用行为准则点<strong class="kd iu"> addTypename </strong>和<strong class="kd iu"> dataIdFromObject </strong>来做到这一点。通常，缓存使用数据中的<code class="fe kz la lb lc b">id</code>和<code class="fe kz la lb lc b">_id</code>字段以及<code class="fe kz la lb lc b">__typename</code>来创建唯一标识符。如果数据中没有提供<code class="fe kz la lb lc b">ids</code>，它将关闭<code class="fe kz la lb lc b">__typename</code>。<strong class="kd iu"> dataIdFromObject </strong>函数<strong class="kd iu"/></p><p id="e673" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我知道这很令人困惑。所以，让我们更深入地讨论这个问题:</p><p id="960e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是首先，缓存是如何记住所有东西的？简单来说，Apollo cache会记住你与它交互的方式。缓存将此称为<strong class="kd iu">查询路径</strong>。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="a043" class="ll lm it lc b gy ln lo l lp lq">query {<br/>    Events (category = 'happy') { <br/>        name<br/>    }<br/>}</span></pre><p id="d131" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于上面的查询，缓存会创建如下查询路径:<strong class="kd iu">root query-&gt;Events(category =‘happy’)-&gt;name。</strong>它假设对于一个查询路径，必须恰好有一个它所指向的资源。因此，下次当任何人询问cache相同的查询时，它会立即回答。例如，一位客人向apollo cache询问团队的得分和“快乐”类别的事件列表。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="6008" class="ll lm it lc b gy ln lo l lp lq">query {<br/>    Score(team = 'A') {<br/>        points<br/>    }<br/>    Events (category = 'happy') { <br/>        name<br/>    }<br/>}</span></pre><p id="34e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">缓存已经知道了事件列表，因为有人已经请求了它。所以它立刻回答了。爽快！</p><p id="69b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">缓存尽力记住事情。但有时，查询路径不够清晰。例如，这是另外两位客人提出的问题:</p><p id="87c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">嘉宾甲:</strong>嘿，阿波罗缓存。你能给我一个属于“<strong class="kd iu">跳舞</strong>的项目吗？</p><p id="9e43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">嘉宾B: </strong>缓存，你能给我提供<strong class="kd iu">第二类的事件吗？</strong>(此处类别由id引用)</p><p id="af2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在碰巧id = 2(或第二类)实际上是一个属于“跳舞”类别的事件。缓存如何看待这些请求？</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="8e84" class="ll lm it lc b gy ln lo l lp lq">// 1st Request<br/>query {<br/>    Event (category = 'dancing') { <br/>        name<br/>    }<br/>}</span><span id="4347" class="ll lm it lc b gy mu lo l lp lq">// 2nd Request<br/>query {<br/>    Event (id = 2) { <br/>        name<br/>    }<br/>}</span></pre><p id="9c52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，缓存不知道这两个请求指向同一个结果。在正常情况下，缓存将获取该数据，并在其存储中保存两次。此时，缓存能够使用<code class="fe kz la lb lc b">dataIdFromObject</code>规则计算出这些请求发生了什么。</p><p id="eb62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">怎么会？在我们的帮助下。因此，在<code class="fe kz la lb lc b">dataIdFromObject</code>中，我们为任何需要查询的对象指定了唯一的标识符。这里，我们需要注意不要提供原始id(SQL主键)作为唯一标识符，因为id = 5可以表示事件或访客。我们需要把这个和<code class="fe kz la lb lc b">__typename</code>结合起来。所以像<code class="fe kz la lb lc b">Event:5</code>这样的标识符只表示id =5的事件数据，而<code class="fe kz la lb lc b">Guest:5</code>只表示id = 5的访客数据。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/0593d05ac50525ae0ba3ff3112ac8267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuzutZz5hqJRLTm86-j-hA.png"/></div></div></figure><p id="67d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果跳舞类别中的事件名称从“bachata”更改为“salsa ”,以上两个查询都将获得更新的答案。轻松利落！</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/15e6143c29a7fd7d35349701a32344d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R32kfWvTDRuS3iMRq9I28A.jpeg"/></div></div></figure><p id="dac7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">阿波罗缓存还有许多其他的锦囊妙计。我们改天再讨论吧！</p><p id="85b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ls">感谢推特用户@DrunkBB8的原创图片。</em></p></div></div>    
</body>
</html>