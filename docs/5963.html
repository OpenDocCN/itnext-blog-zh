<html>
<head>
<title>How to properly use IAsyncDisposable in C#8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在C#8中正确使用IAsyncDisposable</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-properly-use-iasyncdisposable-in-c-8-3c7ec6dcc9fe?source=collection_archive---------0-----------------------#2021-07-14">https://itnext.io/how-to-properly-use-iasyncdisposable-in-c-8-3c7ec6dcc9fe?source=collection_archive---------0-----------------------#2021-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/55cd75e8a3bfdb939cef28cf4448e766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sCb7DCiZLzquYGbQdB2wFQ.jpeg"/></div></div></figure><div class=""/><p id="f3f1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">C# 8是这种语言的一次重大更新，为开发者提供了许多新的关键功能。然而，像nullable reference types和<em class="kz"> IAsyncEnumerable </em>这样的大人物，也有很多特性被忽略了。</p><p id="cd0a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其中一个很好地填补了空白的特性是<strong class="kd jf"> <em class="kz"> IAsyncDisposable </em> </strong>。它是<em class="kz"> IDisposable </em>长期缺失的异步对应物，在异步处理越来越被广泛使用的开发世界中，它扮演了一个非常重要的角色。</p><h1 id="908c" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">什么&amp;为什么</strong></h1><p id="f1ad" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">那么，<em class="kz"> IAsyncDisposable </em>到底是担任哪个角色呢？在C#8之前，开发人员只能通过使用仅同步的<em class="kz"> IDisposable </em>接口来使用一次性模式。对于大多数情况，这工作得很好。大多数情况下，清理/处置部分应该是一个快速而干净的操作。</p><p id="b611" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，随着时间的推移，许多异步API变得越来越可用，大多数时候同步处理并不能很好地与API一起工作。通常，开发人员更喜欢异步接口，因为它们不会阻塞线程的执行。此外，许多开发人员不仅喜欢使用dispose模式来实际处理和清理非托管资源，还喜欢使用自动清理来引入特定的范围，这在许多方面也是异步的。</p><p id="077a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，由于异步编程API的丰富性和仍然只能同步处理资源的可能性之间的差异。Net团队决定引入<em class="kz"> IAsyncDisposable </em>，它现在支持</p><h1 id="1891" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何实现IAsyncDisposable</h1><p id="5b8b" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">基本上，实现IAsyncDisposable的最简单方法如下:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1c1b" class="mm lb je mi b gy mn mo l mp mq">public class Example : IAsyncDisposable<br/>{<br/>    public async ValueTask DisposeAsync()<br/>    {<br/>        // Async cleanup mock<br/>        await Task.Yield();<br/>        Console.WriteLine("Cleaned up!");<br/>    }<br/>}</span></pre><p id="1e86" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该接口需要实现带有签名<em class="kz">public value task dispose easync()</em>的方法。就是这样。然而，有多个陷阱:</p><p id="0f0a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据MS指南(<a class="ae mr" href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-disposeasync" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/standard/garbage-collection/implementing-dispose easync</a>)，非密封类应该总是被认为是可继承的。类似于常规同步<em class="kz"> IDisposable </em>实现的继承模式，我们也应该添加一个虚拟方法来覆盖子类中的处置行为。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7c07" class="mm lb je mi b gy mn mo l mp mq">public class Example : IAsyncDisposable<br/>{<br/>    public async ValueTask DisposeAsync()<br/>    {<br/>        await DisposeAsyncInternal();<br/>        GC.SuppressFinalize(this);<br/>    }<br/> <br/>    protected virtual async ValueTask DisposeAsyncInternal() <br/>    {<br/>        // Async cleanup mock<br/>        await Task.Yield();<br/>        Console.WriteLine("Base cleaned up!");<br/>    }<br/>}</span><span id="7cf3" class="mm lb je mi b gy ms mo l mp mq">public class ExampleInherited : Example<br/>{ <br/>    protected override async ValueTask DisposeAsyncInternal() <br/>    {<br/>        await base.DisposeAsyncInternal();<br/>  <br/>        // Async cleanup mock<br/>        await Task.Yield();<br/>        Console.WriteLine("Subclass cleaned up!");<br/>    }<br/>}</span></pre><p id="4576" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，我们可以安全地扩展处置逻辑。</p><p id="848c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个重要的问题是建议在类上实现一个常规的<em class="kz"> IDisposable </em>接口，因为不是每个消费者都能够正确处理新的风格。例如，许多旧的反转控制框架还不能处理异步处理。在我们“更简单”的例子中，可能如下所示。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7d0f" class="mm lb je mi b gy mn mo l mp mq">public class Example : IDisposable, IAsyncDisposable<br/>{<br/>    private Stream _memoryStream = new MemoryStream();<br/> <br/>    public void Dispose()<br/>    {<br/>        _memoryStream.Dispose();<br/>        GC.SuppressFinalize(this);<br/>    }</span><span id="3d63" class="mm lb je mi b gy ms mo l mp mq">    public async ValueTask DisposeAsync()<br/>    {<br/>        await _memoryStream.DisposeAsync();<br/>        GC.SuppressFinalize(this);<br/>    }<br/>}</span></pre><p id="687f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，我们可以确保我们的资源能够以两种方式得到适当的清理。幸运的是，在这个例子中，我让自己变得非常容易，因为流提供了同步和异步处理。如果您的资源只提供异步处理，您可能需要硬着头皮进行异步同步，以确保正确的清理。我知道你在想什么，是的，这确实感觉很糟糕，但请记住——在我们有“新”方法之前，每次清理都必须这样做。</p><p id="313d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，根据复杂性和继承结构，还有多种更复杂的方式来实现该模式。如果你对遵循提议的处置模式的更复杂的例子感兴趣，请在MS文档上查看<a class="ae mr" href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-disposeasync#implement-both-dispose-and-async-dispose-patterns" rel="noopener ugc nofollow" target="_blank">这个例子。</a></p><h1 id="97fd" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何使用它</h1><p id="4a71" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在，我们已经介绍了一些实现示例，并进入了正确的思维模式，让我们看看如何使用它。为了简单明了，我将使用下面的实现:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="cb83" class="mm lb je mi b gy mn mo l mp mq">public class Example : IAsyncDisposable<br/>{<br/>    private bool _disposed;<br/> <br/>    public void PrintDisposeState() =&gt; Console.WriteLine(_disposed);</span><span id="3dd2" class="mm lb je mi b gy ms mo l mp mq">public async ValueTask DisposeAsync()<br/>    {<br/>        // Async cleanup mock<br/>        await Task.Yield();<br/>        Console.WriteLine("Cleaned up!");<br/>        _disposed = true;<br/>    }<br/>}</span></pre><p id="9991" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消费它是非常容易的。它基本上是旧的使用模式，但是在使用范围上以一个<em class="kz"> await </em>关键字为前缀:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="de78" class="mm lb je mi b gy mn mo l mp mq">async Task Main()<br/>{<br/>    var example = new Example();<br/>    await using (example)<br/>    {<br/>        example.PrintDisposeState();<br/>    }<br/> <br/>    example.PrintDisposeState();<br/>}</span><span id="2dd8" class="mm lb je mi b gy ms mo l mp mq">// Output: <br/>False<br/>Cleaned up!<br/>True</span></pre><p id="d952" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，由于C#8引入了使用范围，我们可以简单地将上面的语句转换为以下内容:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7f67" class="mm lb je mi b gy mn mo l mp mq">async Task Main()<br/>{<br/>    await using var example = new Example();<br/>    example.PrintDisposeState();<br/>}</span></pre><p id="a105" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，可处置的资源将在作用域的末尾被自动处置。</p><p id="874f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样！现在在C#中使用异步可处理性非常容易，它们确实弥补了一个重要的空白。这可能不是你每天都需要使用的东西，但知道这一点很好。尽管接口本身相当容易使用，但是当要正确实现整个模式时，在您的脑海中仍然有一些问题。</p></div></div>    
</body>
</html>