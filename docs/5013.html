<html>
<head>
<title>Terragrunt- Dynamic Remote State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态远程状态管理</h1>
<blockquote>原文：<a href="https://itnext.io/terragrunt-dynamic-remote-state-management-1467a6992693?source=collection_archive---------2-----------------------#2020-11-16">https://itnext.io/terragrunt-dynamic-remote-state-management-1467a6992693?source=collection_archive---------2-----------------------#2020-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/7d2ad12da3a8f72ea70d1081e302fe88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*aX_IRODRERNb63Zt.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">远程状态管理</figcaption></figure><p id="d1fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在介绍性的博客条目中，我强调了Terragrunt的一项功能:动态生成远程状态配置。在深入研究它是如何工作的之前，让我们先看看如何在vanilla Terraform中处理它。</p><h1 id="b309" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Terraform的方法</h1><p id="f88e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用Terraform，要远程存储您的状态，您需要创建一个后端配置，如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b185" class="mi kx iq me b gy mj mk l ml mm">terraform {<br/>  backend "azurerm" {<br/>    tenant_id            = "xxxxxxxx-84e2-4390-b0b9-c79fdf7323ea"<br/>    subscription_id      = "xxxxxxxx-b1ee-41e4-8bd5-e4a04300b5c1"<br/>    resource_group_name  = "rg-tfstates-prod"<br/>    storage_account_name = "stprod"<br/>    container_name       = "prod"</span><span id="ccf4" class="mi kx iq me b gy mn mk l ml mm">key      = "core-routing/terraform.tfstate"<br/>    snapshot = true<br/>  }<br/>}</span></pre><p id="a7c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于每个部署，您将需要上述配置并修改密钥，可能还需要资源组/存储帐户/容器名称。由于您可能使用整合的存储帐户，因此配置详细信息会重复出现。</p><p id="a025" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个挑战是如何在Git中管理这个配置。假设您将同一个堆栈部署到生产和非生产环境中。您将需要创建2个存储库，每个环境一个(或者可能使用不同的分支)。理想情况下，你会想把代码和配置分开，有了vanilla terraform，配置回购的数量会快速增长。</p><p id="d334" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了减少重复，人们可能会考虑使用变量传递<em class="mo">后端</em>对象中的配置。然而，<em class="mo">提供者</em>和<em class="mo">后端</em>的配置必须在“编译时”就知道，并且不能动态传入。</p><h1 id="37ee" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">特拉格朗特方法</h1><p id="61f2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Terragrunt在其HCL语言中引入了一个特殊的资源，称为<em class="mo"> remote_state </em>。此资源适合动态生成此配置…正是我们需要的。让我们看一个生成远程状态的示例配置。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c30a" class="mi kx iq me b gy mj mk l ml mm">locals {<br/>  rscfg = yamldecode(file(find_in_parent_folders("remote_state.yaml")))<br/>}</span><span id="0519" class="mi kx iq me b gy mn mk l ml mm">remote_state {<br/>  backend = "azurerm"<br/>  generate = {<br/>    path      = "backend.tf"<br/>    if_exists = "overwrite" # Always overrides the file if one exists<br/>  }<br/>  config = {<br/>    tenant_id       = local.rscfg.remote_state.tenant_id<br/>    subscription_id = local.rscfg.remote_state.subscription_id</span><span id="4069" class="mi kx iq me b gy mn mk l ml mm">resource_group_name  = local.rscfg.remote_state.nonp.resource_group_name<br/>    storage_account_name = local.rscfg.remote_state.nonp.storage_account_name<br/>    container_name       = local.rscfg.remote_state.nonp.container_name</span><span id="3702" class="mi kx iq me b gy mn mk l ml mm">key = "${path_relative_to_include()}/terraform.tfstate"</span><span id="4c2d" class="mi kx iq me b gy mn mk l ml mm">snapshot = true<br/>  }<br/>}</span></pre><p id="10ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于配置细节会重复出现，所以我将这些值外部化到一个YAML配置文件中，在运行时读取该文件以检索适当的设置。这在<em class="mo">局部</em>部分可以看到。还要注意函数<em class="mo"> find_in_parent_folders </em>的使用，它是一个Terragrunt函数。</p><p id="dda1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="mo"> remote_state </em>资源中，我有一个<em class="mo"> generate </em>语句，它将覆盖文件<em class="mo"> backend.tf </em>如果它存在，并强制使用系统生成的文件。在config部分，这里提供了基本后端对象中的设置。大多数设置来自YAML配置。</p><p id="0782" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要注意的是<em class="mo">键</em>属性的使用。该值是根据存储该HCL文件的文件夹层次结构生成的。它使用了一个Terragrunt函数(这个函数不是Terraform基础语言的一部分)。因此，如果您有一个如初始博客条目所示的层次结构，您将让该层次结构传播到blob存储命名空间。</p><blockquote class="mp mq mr"><p id="9ef0" class="jy jz mo ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated">警告—一旦设置了该项的值并且部署了基础结构；不要改变它。如果您更改配置中的路径，未来的计划将看不到状态文件，并将从头开始重新部署基础架构。</p></blockquote><p id="24e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为参考，我包含了这段代码来源的YAML文件:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="dc63" class="mi kx iq me b gy mj mk l ml mm">remote_state:<br/>  tenant_id: xxxxxxxxxx-84e2-4390-b0b9-c79fdf7323ea<br/>  subscription_id: xxxxxxxxxx-b1ee-41e4-8bd5-e4a04300b5c1<br/>  common:<br/>    resource_group_name: rg-tfstates-common<br/>    storage_account_name: stcommon<br/>    container_name: common<br/>  nonp:<br/>    resource_group_name: rg-tfstates-nonp<br/>    storage_account_name: stnonp<br/>    container_name: nonp<br/>  prod:<br/>    resource_group_name: rg-tfstates-prod<br/>    storage_account_name: stprod<br/>    container_name: prod</span></pre><h1 id="f886" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="d297" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如您所见，Terragrunt提供了减少代码重复和管理远程状态配置的工具。我们已经扩展了这个概念，使用YAML来使用集中的配置文件。Terragrunt遵循类似DSL的terraform，这使得它易于学习和使用。您已经看到了它提供的两个函数(find_in_parent_folders()和path_relative_to_include())</p><p id="7d84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有关此功能的更多信息，请查看该产品的文档<a class="ae mv" href="https://terragrunt.gruntwork.io/docs/features/keep-your-remote-state-configuration-dry/" rel="noopener ugc nofollow" target="_blank">https://terra grunt . grunt work . io/docs/features/keep-your-remote-state-configuration-dry/</a></p></div></div>    
</body>
</html>