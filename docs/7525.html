<html>
<head>
<title>⚛️ Top 7 Tweaks and Tricks to Improve React Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">⚛️提高React性能的7大调整和技巧</h1>
<blockquote>原文：<a href="https://itnext.io/%EF%B8%8F-top-7-tweaks-and-tricks-to-improve-react-performance-8957bab33266?source=collection_archive---------0-----------------------#2022-10-23">https://itnext.io/%EF%B8%8F-top-7-tweaks-and-tricks-to-improve-react-performance-8957bab33266?source=collection_archive---------0-----------------------#2022-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="78db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还没有看到性能问题，并不意味着它们不存在😄</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/045962fc2326a43126cc6cc0712b3f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ig_zN5BK57NAlZxIK6l4Bw.png"/></div></div></figure><h1 id="665b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">内容</h1><ul class=""><li id="640b" class="lv lw iq jp b jq lx ju ly jy lz kc ma kg mb kk mc md me mf bi translated"><a class="ae mg" href="#ecaa" rel="noopener ugc nofollow"> <strong class="jp ir">简介</strong> </a></li><li id="8abd" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" href="#d081" rel="noopener ugc nofollow"> <strong class="jp ir"> 1。冗余重卷机</strong>故障排除</a></li><li id="17a1" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" href="#3bc7" rel="noopener ugc nofollow"> <strong class="jp ir"> 2。通过拆分组件</strong> </a>减少重新渲染</li><li id="c413" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" href="#31a7" rel="noopener ugc nofollow"> <strong class="jp ir"> 3。什么是实例再创建，如何避免？</strong>T15】</a></li><li id="284d" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" href="#6b0f" rel="noopener ugc nofollow"> <strong class="jp ir"> 4。不要懒加载</strong> </a></li><li id="2115" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" href="#f6f3" rel="noopener ugc nofollow"> <strong class="jp ir"> 5。为什么以及何时使用React片段？</strong> </a></li><li id="65cb" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" href="#0d12" rel="noopener ugc nofollow"> <strong class="jp ir"> 6。避免在列出的元素中使用索引作为关键字</strong> </a></li><li id="ac57" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" href="#2170" rel="noopener ugc nofollow"> <strong class="jp ir"> 7。避免传播道具</strong> </a></li><li id="7dce" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" href="#b5d6" rel="noopener ugc nofollow"> <strong class="jp ir">结论</strong> </a></li><li id="f915" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk mc md me mf bi translated"><a class="ae mg" href="#7a38" rel="noopener ugc nofollow"> <strong class="jp ir">了解更多</strong> </a></li></ul></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="ecaa" class="kx ky iq bd kz la mt lc ld le mu lg lh li mv lk ll lm mw lo lp lq mx ls lt lu bi translated">介绍</h1><p id="c15a" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">一些刚开始学习React，或者从其他框架转到React的开发人员，在开始时可能不会太关注性能。因为发现新学习的框架的性能下降需要一些时间。后来，由于缺乏经验，这样的开发人员在编写代码时会犯一些小错误，这些小错误最终会积累起来，导致性能下降。此外，他们将很难解决问题。<em class="nb">在这里，我们将探讨7种调整和技巧，它们将有助于避免构建任何类型的应用程序时出现的大多数React性能问题。</em></p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="d081" class="kx ky iq bd kz la mt lc ld le mu lg lh li mv lk ll lm mw lo lp lq mx ls lt lu bi translated">1.冗余重卷机故障排除</h1><p id="3684" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">我们大多数人都知道虚拟DOM是如何工作的，但最重要的是检测树比较何时被触发。当我们可以跟踪它时，我们可以控制组件的重新呈现，并最终防止意外的性能流。令人惊讶的是，它并不那么难抓。首先，将<a class="ae mg" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener ugc nofollow" target="_blank"> React Devtool扩展</a>添加到浏览器中。</p><ol class=""><li id="88c4" class="lv lw iq jp b jq jr ju jv jy nc kc nd kg ne kk nf md me mf bi translated">然后打开浏览器开发者工具(在Chrome中是<strong class="jp ir"> Option + ⌘ + J </strong>(在macOS上)，或者<strong class="jp ir"> Shift + CTRL + J </strong>(在Windows/Linux上)。</li><li id="4e8a" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk nf md me mf bi translated">选择<strong class="jp ir">组件</strong></li><li id="a996" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk nf md me mf bi translated">点击设置图标</li><li id="4bc0" class="lv lw iq jp b jq mh ju mi jy mj kc mk kg ml kk nf md me mf bi translated">以及复选标记“组件渲染时高亮显示更新”</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f62425a25d5e5a32258b0e5380533f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*zTA3H7B55_yZOdtnznH2OA.gif"/></div></figure><p id="b61f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样，现在，当我们与UI交互时，它会在当前重新呈现的元素上显示绿色边框。了解了这一点，我们就可以分析我们的任何React组件并重构它们，以避免不必要的重新呈现。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="3bc7" class="kx ky iq bd kz la mt lc ld le mu lg lh li mv lk ll lm mw lo lp lq mx ls lt lu bi translated">2.通过拆分组件来减少重复渲染</h1><p id="ffec" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">如果我们能够减少意外重新呈现元素的数量，它将涵盖React中很大一部分性能问题。但我们必须先回答这个问题:<em class="nb">“是什么触发了重新渲染？”</em>。答案很简单——<strong class="jp ir">状态改变</strong>。每次组件状态发生突变，都会唤醒树比较，也称为<strong class="jp ir">协调、</strong>并重新呈现<strong class="jp ir">状态上下文的元素。状态上下文</strong> —是初始化这种状态的组件。也就是说，如果我们有一个巨大的组件，它有很多状态(不一定相互依赖),其中一个状态改变了，它将重新呈现整个组件元素🤯。这绝对不是我们想要的。</p><p id="9ee1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么解决办法是什么？解决方法是通过将组件的一部分和它的一些状态移动到它自己的子组件中来分离状态上下文，让我们看一下这个例子:</p><p id="9ef3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一个带有搜索过滤器的表格组件。搜索过滤器是一个受控输入，其状态在输入文本更改后更新。这是它的样子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/a6b23747a1790d8fd020c43a3165abb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*No0xO1IkbYljLuut"/></div></div></figure><p id="f6cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们开始在搜索输入字段中输入时会发生什么？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d164369e5b1af7a66e6972630969c1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*17ixTVmo83RRhUzj"/></div></figure><p id="adbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，它将重新呈现整个表格元素。这是因为输入状态上下文与表组件共享相同的上下文。现在，让我们尝试我们的解决方案，将input元素及其状态移动到一个单独的组件中，并将其注入到table组件中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/55163c48c929bb34188a24788e58eaef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zTzYKGygGQL-bXxf"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/49034c73d57a5a7719bc05c4b746f7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*0ECOvfO_GoNNue_i"/></div></figure><p id="1be1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">神奇的🧙，表格组件不再被渲染。当我们希望输入影响表元素时，我们可以通过从输入向控件发出事件来增强这个特性。</p><blockquote class="nj nk nl"><p id="9abf" class="jn jo nb jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">好的做法是拆分组件以分离状态上下文，从而避免冗余的重新呈现器</p></blockquote></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="31a7" class="kx ky iq bd kz la mt lc ld le mu lg lh li mv lk ll lm mw lo lp lq mx ls lt lu bi translated">3.什么是实例再创建，如何避免？</h1><p id="71d3" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">我们已经发现状态更改会触发组件重新呈现，但是我们需要考虑另一个重要的副作用。当状态改变并且<strong class="jp ir">协调</strong>发生<strong class="jp ir"> — </strong>时，它将重新初始化整个组件实例，并保持新的状态值。对我们来说，这意味着在<strong class="jp ir">协调期间，</strong>所有功能实例将被重新创建，以便能够考虑新的状态值。我们不需要它，而且在大多数情况下，函数可以只依赖于几个状态。我们不想重新创建函数实例，因为它不依赖于已更改的状态。</p><p id="1bba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个提高绩效的机会。我们有几个解决方案:<strong class="jp ir">使用回调</strong>和<strong class="jp ir"> useRef </strong>。让我们看看这个例子:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="a140" class="nu ky iq nq b gy nv nw l nx ny">const {someState, setSomeState} = useState('')<br/>const {otherState, setOtherState} = useState('')</span><span id="6e63" class="nu ky iq nq b gy nz nw l nx ny">const foo = () =&gt; {console.log(someState)}</span></pre><p id="f2ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是最常见的例子。我们有<strong class="jp ir"> foo </strong>依赖于状态<strong class="jp ir"> someState。当<strong class="jp ir"> someState </strong>发生变化时，它将重新创建<strong class="jp ir"> foo </strong>的新实例。这段代码的<strong class="jp ir"> </strong>问题是，即使其他状态发生了变化，比如<strong class="jp ir"> otherState，</strong>foo</strong>也会被重新创建，这是我们实际上不想要的。我们可以使用<strong class="jp ir"> useCallback </strong>来告诉React我们的函数状态依赖是什么，以便在重新创建实例时更加明确:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="e559" class="nu ky iq nq b gy nv nw l nx ny">const {someState, setSomeState} = useState('')<br/>const {otherState, setOtherState} = useState('')</span><span id="d3b7" class="nu ky iq nq b gy nz nw l nx ny">const foo = <strong class="nq ir">useCallback</strong>(() =&gt; {console.log(someState)}, [<strong class="nq ir">someState</strong>])</span></pre><p id="436e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们将依赖数组传递给<strong class="jp ir"> useCallback </strong>钩子。更好的是，<strong class="jp ir"> foo </strong>将避免<strong class="jp ir">其他状态</strong>变化<strong class="jp ir">。</strong></p><p id="e08b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种选择是使用<strong class="jp ir"> useRef </strong>。<strong class="jp ir"> useRef — </strong>你可以把它想成和<strong class="jp ir"> useState、</strong>一样，但是不触发组件re render(UI不会更新)。<strong class="jp ir"> useRef </strong>没有依赖列表，所以我们需要将<strong class="jp ir"> someState </strong>作为<strong class="jp ir"> foo </strong>属性传递:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="2e07" class="nu ky iq nq b gy nv nw l nx ny">const {someState, setSomeState} = useState('')<br/>const {otherState, setOtherState} = useState('')</span><span id="26bb" class="nu ky iq nq b gy nz nw l nx ny">const foo = <strong class="nq ir">useRef</strong>((<strong class="nq ir">currentSomeState</strong>) =&gt; {console.log(<strong class="nq ir">currentSomeState</strong>)}).current;</span></pre><p id="a6e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们不会重新创建<strong class="jp ir"> foo </strong>实例。结论:</p><blockquote class="nj nk nl"><p id="6750" class="jn jo nb jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">使用<strong class="jp ir"> useCallback </strong>和<strong class="jp ir"> useRef </strong>控制功能实例的重新创建</p></blockquote></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="6b0f" class="kx ky iq bd kz la mt lc ld le mu lg lh li mv lk ll lm mw lo lp lq mx ls lt lu bi translated">4.不要懒加载</h1><p id="c809" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">默认情况下，React同步渲染组件。这意味着组件将在呈现它自己之前等待它的子组件被呈现。没有必要等待，尤其是当一些子组件没有耦合时。这可能会导致页面挂起。假设我们点击了某个导航链接，它会把我们重定向到另一个页面。导航将一直等到所有的页面组件都呈现完成重定向。这将影响用户体验，人们不会等待，只会离开你的网站。我们需要让页面内容异步呈现，这样就不会损害导航。解决方案是将您的页面组件包装到<code class="fe oa ob oc nq b">React.lazy(()</code>中，并告诉React完成导航，然后等待页面组件完成呈现:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="7a55" class="nu ky iq nq b gy nv nw l nx ny">const PageComponent = React.lazy(() =&gt; import('./PageComponent'));</span></pre><p id="e9a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后我们可以通过使用<code class="fe oa ob oc nq b">&lt;Suspense/&gt;</code>展示一些当页面组件还没有准备好时的加载动画</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="331f" class="nu ky iq nq b gy nv nw l nx ny">&lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br/>   &lt;PageComponent /&gt;<br/>&lt;/Suspense&gt;</span></pre><p id="212d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这并不意味着我们必须在任何地方都使用惰性加载组件，当我们在不太损害性能的地方使用它时，可能会导致过度工程化。另一种场景是一些组件可能默认隐藏在UI中，所以我们不必等待。例如模式窗口、对话框、抽屉和可折叠侧板。</p><blockquote class="nj nk nl"><p id="342c" class="jn jo nb jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">延迟加载页面组件和隐藏的UI组件</p></blockquote></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="f6f3" class="kx ky iq bd kz la mt lc ld le mu lg lh li mv lk ll lm mw lo lp lq mx ls lt lu bi translated"><strong class="ak"> 5。为什么以及何时使用React片段？</strong></h1><p id="cca8" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">这种情况经常发生，当我们在JSX构建一些布局并想要对我们的元素进行分组时，在大多数情况下我们使用<code class="fe oa ob oc nq b">&lt;div&gt;</code>标签。或者，举例来说，我们有父子HTML标签，我们想移动到一个单独的组件:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="184b" class="nu ky iq nq b gy nv nw l nx ny">&lt;ul&gt;<br/>    &lt;li&gt;Item 1&lt;/li&gt; &lt;--- | Want to move it to child &lt;Li&gt; |<br/>    &lt;li&gt;Item 2&lt;/li&gt; &lt;--- |                               |<br/>&lt;/ul&gt;</span></pre><p id="d15a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，当我们将<code class="fe oa ob oc nq b">&lt;li&gt;</code>移动到单独的组件中时，比如:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="ec60" class="nu ky iq nq b gy nv nw l nx ny">const <strong class="nq ir">Li</strong> = () =&gt; {<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;li&gt;Item 1&lt;/li&gt;<br/>            &lt;li&gt;Item 2&lt;/li&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span></pre><p id="8a11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并改变它:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="f288" class="nu ky iq nq b gy nv nw l nx ny">&lt;ul&gt;<br/>    &lt;<strong class="nq ir">Li</strong>/&gt;<br/>&lt;/ul&gt;</span></pre><p id="305e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">渲染后会是这样的:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="a774" class="nu ky iq nq b gy nv nw l nx ny">&lt;ul&gt;<br/>    &lt;div&gt;<br/>        &lt;li&gt;Item 1&lt;/li&gt;  <br/>        &lt;li&gt;Item 2&lt;/li&gt;    <br/>    &lt;/div&gt;<br/>&lt;/ul&gt;</span></pre><p id="97d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将创建一个我们不需要的额外的<code class="fe oa ob oc nq b">&lt;div&gt;</code>节点。这将使我们的DOM树更加嵌套，从而减慢<strong class="jp ir">协调</strong>过程。相反，<code class="fe oa ob oc nq b">&lt;div&gt;</code>我们可以将子元素包装到片段中。最初，Fragment让你对DOM元素进行分组，插入后只会导致一次<a class="ae mg" href="https://developers.google.com/speed/docs/insights/browser-reflow" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">重排</strong> </a> <strong class="jp ir">。</strong>在<strong class="jp ir">中</strong>做出反应，碎片也会让你减少不必要的节点。当你想对元素进行分组时，你唯一需要做的就是使用Fragment而不是<code class="fe oa ob oc nq b">&lt;div&gt;</code>:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="320d" class="nu ky iq nq b gy nv nw l nx ny">const <strong class="nq ir">Li</strong> = () =&gt; {<br/>    return (<br/>        &lt;&gt; /* or &lt;React.Fragment&gt;, or &lt;Fragment&gt;*/<br/>            &lt;li&gt;Item 1&lt;/li&gt;<br/>            &lt;li&gt;Item 2&lt;/li&gt;<br/>        &lt;/&gt;<br/>    )<br/>}</span></pre><p id="0742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样，就这么简单</p><blockquote class="nj nk nl"><p id="9b0e" class="jn jo nb jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">如果要对元素进行分组以减少节点数量，请使用片段</p></blockquote></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="0d12" class="kx ky iq bd kz la mt lc ld le mu lg lh li mv lk ll lm mw lo lp lq mx ls lt lu bi translated">6.避免在列出的元素中使用索引作为键</h1><p id="d86f" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">所有人都知道，如果不是这样，Eslint会强制执行😜在列出的元素中使用<strong class="jp ir">键</strong>，例如:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="3725" class="nu ky iq nq b gy nv nw l nx ny">&lt;ul&gt;<br/>    &lt;li key="1"&gt;Item 1&lt;/li&gt;  <br/>    &lt;li key="2"&gt;Item 2&lt;/li&gt;    <br/>&lt;/ul&gt;</span></pre><p id="927a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React中的<strong class="jp ir">键</strong>是惟一标识符，帮助React指向列表中正确的元素并更新正确的元素。如果我们使用一个索引作为列表中的一个键，比如:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="e3f5" class="nu ky iq nq b gy nv nw l nx ny">&lt;ul&gt;<br/>    {[1, 2].map((val, <strong class="nq ir">index</strong>) =&gt; &lt;li <strong class="nq ir">key={index</strong>}&gt;Item {val}&lt;/li&gt;)}  <br/>&lt;/ul&gt;</span></pre><p id="e0c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将元素映射到它的索引。但是如果我们进行排序，列表中元素的顺序可能会改变，初始键将不再指向正确的元素。它会引起一些意想不到的副作用，你可以在这里阅读更多<a class="ae mg" href="https://robinpokorny.com/blog/index-as-a-key-is-an-anti-pattern/" rel="noopener ugc nofollow" target="_blank"/>。</p><blockquote class="nj nk nl"><p id="1b95" class="jn jo nb jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">在列出的元素中总是使用唯一的id作为键，如果对象没有它，你可以使用外部库显式地赋值，比如<a class="ae mg" href="https://www.npmjs.com/package/uid" rel="noopener ugc nofollow" target="_blank"> uid </a></p></blockquote></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="2170" class="kx ky iq bd kz la mt lc ld le mu lg lh li mv lk ll lm mw lo lp lq mx ls lt lu bi translated">7.避免传播道具</h1><p id="31a9" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">这是今天的最后一个调整，已经很多了😓你肯定见过，或者更惨的是你自己做过——铺道具。类似于:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="4677" class="nu ky iq nq b gy nv nw l nx ny">const Input = ({ onChange, ...props }) =&gt; (<br/>    &lt;input {...props} onChange={e =&gt; onChange(e.target.value)}/&gt;<br/>);</span></pre><p id="f0c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不仅迫使您猜测<code class="fe oa ob oc nq b">input</code>实际收到了什么属性，还在<code class="fe oa ob oc nq b">input</code>元素中创建了一堆您不一定需要的属性。</p><p id="b609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使它显式，并且不要害怕传递您需要的尽可能多的属性，您总是可以将它们分组到某个对象中:</p><pre class="km kn ko kp gt np nq nr ns aw nt bi"><span id="3c32" class="nu ky iq nq b gy nv nw l nx ny">const Input = ({ onChange, inputProps: {value, type, className} }) =&gt; (<br/>    &lt;input className={className} type={type} value={value} onChange={e =&gt; onChange(e.target.value)}/&gt;<br/>);</span></pre><p id="b3a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，现在可读性更好了。</p><blockquote class="nj nk nl"><p id="207e" class="jn jo nb jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">不要分散道具，分开传递每个道具</p></blockquote></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="b5d6" class="kx ky iq bd kz la mt lc ld le mu lg lh li mv lk ll lm mw lo lp lq mx ls lt lu bi translated">结论</h1><p id="fdd8" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">好吧，可能你已经知道了一些由Eslint执行的调整。但是现在你知道为什么遵循它们是重要的了。此外，您还可以对代码进行性能分析，这将为您提供改进的空间。希望你喜欢阅读并学到了新的东西，鼓掌👏在medium上跟我学，这样你就不会错过任何学习的机会。</p><div class="od oe gp gr of og"><a href="https://easy-web.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">easy-web.medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kv og"/></div></div></a></div><h1 id="7a38" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">了解更多信息</h1><div class="od oe gp gr of og"><a href="https://levelup.gitconnected.com/top-3-react-tricks-pros-like-to-use-to-reduce-the-size-of-component-980900370505" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">🔥前3名React技巧专家😎喜欢用来减小组件的大小</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">不要让您的React组件成为一个科学怪人</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="op l"><div class="ov l or os ot op ou kv og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://levelup.gitconnected.com/building-react-micro-frontends-monorepo-with-state-management-using-nx-in-2-min-b8b04f9afee0" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">🔥使用NX在2分钟内构建⚛反应微前端Monorepo和状态管理😅</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">甚至你的祖母也可以用NX构建react微前端</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="op l"><div class="ow l or os ot op ou kv og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://levelup.gitconnected.com/top-3-ways-to-style-react-components-like-pro-in-2022-9d210bacb98f" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">🔥2022年设计React组件(如Pro)的三大方式</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">对于那些不想花几天时间对齐div的人</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="op l"><div class="ox l or os ot op ou kv og"/></div></div></a></div></div></div>    
</body>
</html>