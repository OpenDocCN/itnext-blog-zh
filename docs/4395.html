<html>
<head>
<title>N26 Cards in Flutter, part two</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">N26卡在颤动，第二部分</h1>
<blockquote>原文：<a href="https://itnext.io/n26-cards-in-flutter-part-two-89765954e3ed?source=collection_archive---------10-----------------------#2020-06-21">https://itnext.io/n26-cards-in-flutter-part-two-89765954e3ed?source=collection_archive---------10-----------------------#2020-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="574c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">在Flutter中实现N26卡的一个小系列</em></p><ol class=""><li id="d3dc" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">第一部分:<a class="ae kv" href="https://link.medium.com/KGYQADmxv7" rel="noopener">简介</a></li><li id="aee6" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated"><em class="kl">声明UI </em></li><li id="dd2e" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk kr ks kt ku bi translated">第3部分:卡组(即将推出)</li></ol><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/4fbbd32b489732738d219475f250ec8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEaKkhuBN_L9y4FoVIE8Iw.jpeg"/></div></div></figure><h1 id="a724" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">声明用户界面</h1><p id="caa0" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">让我们从那些彩色的块开始，实现成功状态的UI，这样我们就建立了我们想要去的方向。我们对成功状态的理解是:</p><ul class=""><li id="8f7c" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk mq ks kt ku bi translated"><em class="kl">卡片列表</em></li><li id="b67b" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><em class="kl">该列表下的循环操作</em>(锁定/解锁、卡详情、重置PIN、激活订单)</li><li id="fd99" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><em class="kl">横向动作</em>(添加到Google支付/钱包管理、每日限额、订购新卡)</li><li id="3b43" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><em class="kl">开关</em>(网上支付、ATM取款、境外支付)</li></ul><p id="58af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有当这些视图显示并且它们的值在卡片列表中的交互或刷卡时发生变化时，视图才处于成功状态。</p><p id="4dd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们的关键抽象将由显示不同颜色的外观相似的卡对象以及显示不同颜色的动作的列表组成。如果是圆形操作，则为圆形绿色按钮；如果是入口点操作，则为带箭头&gt;的水平按钮；如果是偏好设置操作，则为复选符号。大概是这样的:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/47c8c0f55deba60048c92459b30c7892.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*kGAJx_FEo2sWLV4HtG5ozg.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">在iOS模拟器中运行的实际颤振应用程序显示了我们想要看到的结果</em></figcaption></figure><h2 id="4301" class="mx lo iq bd lp my mz dn lt na nb dp lx jy nc nd mb kc ne nf mf kg ng nh mj ni bi translated">我们如何做到这一点？</h2><p id="4364" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">让我们首先定义主应用程序作为起点。</p><p id="34e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的情况下，这很简单。它定义了应用程序的标题(<em class="kl">卡片设置</em>)、主题数据(颜色和样式的基本材料设置)和回家路线(我们将导航到的第一页)。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="c19f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">风格</h1><p id="8fe8" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">我们的主应用程序的<code class="fe nl nm nn no b">themeData</code>只定义了几个参数，这些参数将帮助我们完成项目。从第一部分的截图来看，我们的卡片屏幕看起来是黑白的，开关和分页指示器用了一些蓝绿色。在本文中，我们将像这样任意定义样式:</p><ul class=""><li id="8489" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk mq ks kt ku bi translated"><code class="fe nl nm nn no b"><strong class="jp ir">primaryColor</strong></code>:白色</li><li id="51bc" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><code class="fe nl nm nn no b"><strong class="jp ir">primaryColorDark</strong></code>:黑色</li><li id="c349" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><code class="fe nl nm nn no b"><strong class="jp ir">accentColor</strong></code>:灰色</li><li id="996b" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><code class="fe nl nm nn no b"><strong class="jp ir">headline6</strong></code>(用于标题的主标题):字体系列:Roboto，大小20.0，重量:w500)</li><li id="2615" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><code class="fe nl nm nn no b"><strong class="jp ir">subtitle1</strong></code>(主要用于列表项和较小标题的文本):字体系列:Roboto，大小16.0，重量:w400)</li><li id="fe87" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><code class="fe nl nm nn no b"><strong class="jp ir">subtitle2</strong></code>(进一步强调):font-family: Roboto，尺寸14.0，重量:w200)</li></ul><p id="ea9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要访问主应用程序这一部分中设置的全局样式，可以在代码的任何地方使用静态调用<code class="fe nl nm nn no b">Theme.of(context)</code>，例如:</p><p id="1dc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn no b">Theme.of(context).textTheme.headline6</code></p><p id="d6cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多来自素材库的规格和字体样式<a class="ae kv" href="https://api.flutter.dev/flutter/material/TextTheme-class.html" rel="noopener ugc nofollow" target="_blank">见此处</a>或颤振的通用<a class="ae kv" href="https://flutter.dev/docs/cookbook/design/themes" rel="noopener ugc nofollow" target="_blank">样式指南</a>。</p><p id="1f59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了处理字体，我们将使用官方的谷歌字体库。</p><h1 id="8b3d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">项目结构</h1><p id="8a70" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">当我们实现Bloc时，我们必须为每个特性创建几个样板类。首先是4。我们的特性所在的主<em class="kl">页面</em>，可以从视图传递的一组<em class="kl">事件</em>，一个定义视图所有状态的<em class="kl"> state </em>类，以及特性的实际bloc类。在处理Bloc时，你至少需要这4个类来处理你的所有特性。也就是说，对于卡片，我们有:</p><ul class=""><li id="87b5" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk mq ks kt ku bi translated"><code class="fe nl nm nn no b"><strong class="jp ir">CardsPage</strong></code> -一个有状态的小部件，为卡片保存支架和事件状态生成器。</li><li id="f924" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><code class="fe nl nm nn no b"><strong class="jp ir">CardsEvent</strong></code> -描述所有可以从Cards视图向事件处理程序发出的事件的抽象。</li><li id="f3c4" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><code class="fe nl nm nn no b"><strong class="jp ir">CardsState</strong></code> -卡片视图代表的州的描述。</li><li id="465e" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated"><code class="fe nl nm nn no b"><strong class="jp ir">CardsBloc</strong></code> -一个针对视图所有事件的Cards Bloc实现。</li></ul><p id="413f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先做一个非常基本的UI设置，然后我们可以详细讨论这些类中的每一个。</p><h1 id="5326" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">小部件集</h1><p id="ff28" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">在Flutter中有有状态和无状态的小部件。</p><p id="a123" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无状态小部件是只由它们的构造函数定义的小部件。用于创建这些小部件的输入参数是这些小部件将呈现或依赖的最终数据。因为这些小部件是不可变的，所以改变这些小部件的数据意味着创建它们的新对象。这就是为什么在一个无状态小部件中定义一个全局非final字段，会激活Lint告诉你有问题。</p><p id="25b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有状态小部件与无状态小部件相同。的确，有状态窗口小部件是无状态窗口小部件<em class="kl">，除了</em>有一个很大的不同:它们被赋予一个可变的<a class="ae kv" href="https://api.flutter.dev/flutter/widgets/State-class.html" rel="noopener ugc nofollow" target="_blank">状态</a>，这个状态超越了构建过程。因此，对该状态所做的更改可以触发仅受该状态数据影响的零件的重新创建。例如，如果您有一个复选框，并且希望向用户显示复选框小部件的变化。复选框的值是state。将状态设置为真或假定义了Switch类的值参数。因此，如果您将此布尔值的状态设置为true，则不会重新创建有状态的小部件，但是在状态的构建函数中绘制的开关小部件会重新创建，但会使用不同的值。</p><p id="b815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要构建的第一个小部件是<code class="fe nl nm nn no b">CardsPage</code>。它的主要构建函数如下所示:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8594" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们定义了页面的框架，作为这个框架的一部分，AppBar和主体。身体是脚手架的内容块。在这个例子中，内容是一个带有两个列表的<code class="fe nl nm nn no b">Column</code>,<code class="fe nl nm nn no b">CardsList</code>和<code class="fe nl nm nn no b">CardActionsList</code>。</p><p id="535e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn no b">CardsList</code>小部件看起来怎么样:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，我们给它一个260的绝对高度，这在实时应用中是不应该的(你想让它相对于屏幕大小和密度)。<code class="fe nl nm nn no b">PageView</code>将显示一些来自<code class="fe nl nm nn no b">cardsList()</code>的基本窗口小部件，它将视口的比例设置为90%,因为我们想查看一下上一个和下一个项目。我们通过将<code class="fe nl nm nn no b">viewPortFraction</code>属性设置为0.9来实现。<code class="fe nl nm nn no b">cardsList()</code>实际上会给我们一个<code class="fe nl nm nn no b">CardItemWidget </code>对象列表，这个小部件现在看起来像这样:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">只显示颜色的基本卡片项目小工具</em></figcaption></figure><p id="e043" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将只使用指定的<code class="fe nl nm nn no b">color</code>创建<code class="fe nl nm nn no b">Container</code>作为背景，这样我们可以在页面中看到一些东西。我们像这样创建它的对象:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">不一定是表达式体。</em></p><p id="9b97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，将所有这些放在一起并运行将会产生以下结果:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi np"><img src="../Images/a97527b4a6e077846ee7b4b600a80f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*4DqjaWGI7Q5Qkc1w"/></div></figure><p id="d03f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个非常丰富多彩的卡片屏幕。让我们让它有意义。</p><p id="c8ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">动作的每个彩色项目都由<code class="fe nl nm nn no b">CardAction</code>抽象，定义如下:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7b77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么为什么不是抽象类呢？因为它本来就是一个界面，只是它本来就在我脑子里。🤷🏼‍♂️</p><p id="a44a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Dart中有一个东西叫做<em class="kl">隐式接口。</em>这意味着，每个类都可以被实现，这样它的字段就可以被覆盖(注意也有抽象类)。这样我们就可以轻松做到:</p><p id="58b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nl nm nn no b">class RoundCardAction implements CardAction {...}</code></p><p id="c21f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将为<code class="fe nl nm nn no b">RoundCardActionWidget</code>和<code class="fe nl nm nn no b">HorizontalCardActionWidget</code>使用这个接口类。</p><p id="72ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先从观察第一个开始，<code class="fe nl nm nn no b">RoundCardActionWidget</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6ffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，对于圆形的动作，我使用了一个可以根据需要定义和成形的<code class="fe nl nm nn no b"><a class="ae kv" href="https://api.flutter.dev/flutter/material/RawMaterialButton-class.html" rel="noopener ugc nofollow" target="_blank">RawMaterialButton</a></code>。<code class="fe nl nm nn no b"><a class="ae kv" href="https://api.flutter.dev/flutter/material/FloatingActionButton-class.html" rel="noopener ugc nofollow" target="_blank">FloatingActionButton</a></code>也可以用没有任何问题，我就是喜欢避免歧义。我正在确定它的大小，并将形状设置为<code class="fe nl nm nn no b">CircleBorder</code>。</p><p id="38f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">水平动作(带箭头)是<code class="fe nl nm nn no b">HorizontalCardActionWidgets</code>，也是无状态的小部件，因为它们只对它们采取点击动作:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a5c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以很容易地使用<a class="ae kv" href="https://api.flutter.dev/flutter/material/ListTile-class.html" rel="noopener ugc nofollow" target="_blank"> ListTile </a>，它是可定制的，足以满足大多数需求，但我想展示我们自己创建一个定制的小部件。</p><p id="3348" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这组动作中只有一个有状态的小部件，它的状态包含切换的值(真/假)。这个小部件看起来和水平动作一样，除了有一个<code class="fe nl nm nn no b">Switch</code>代替了<code class="fe nl nm nn no b">trailingIcon</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0d07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，现在我们可以轻松地填写我们想要的数据，以便相应地显示这些操作，例如:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="10fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们现在运行代码时，我们得到这样的视图:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d9edfdaebd499e84ad2481a68afb1b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*CZDBRwgUBnkQVCqYPsdgdw.png"/></div></figure><p id="926f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好多了。这个屏幕剩下的唯一内容是卡片列表。</p><p id="4ec6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们更改<code class="fe nl nm nn no b">CardItemWidget</code>以便它实际上正确地表示卡片项目。首先，我们将再添加两个字段:</p><ul class=""><li id="a070" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk mq ks kt ku bi translated">字符串<code class="fe nl nm nn no b">cardImageUrl</code> —卡片的图像，以及</li><li id="4964" class="km kn iq jp b jq kw ju kx jy ky kc kz kg la kk mq ks kt ku bi translated">布尔型<code class="fe nl nm nn no b">isLocked</code> —如果卡片被锁定，是否显示锁定的卡片覆盖图:</li></ul><p id="95b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个小部件也是无状态的，因为它只表示没有状态的静态数据。它是这样建造的:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ceb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意这里的<code class="fe nl nm nn no b">FadeInImage</code>,这是一个非常有用的小部件，它将显示一个占位符(来自资产),直到来自URL的图像被加载。然后它会缓存并重用它👌。</p><p id="31b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们在这个实现中使用了Stack小部件，因为我们希望在卡片图像上显示锁定卡片的覆盖图。因此有两个视图，一个在另一个的上面，上面那个视图的可见性由<code class="fe nl nm nn no b">isLocked</code>字段决定。如果我们用正确的参数创建了<code class="fe nl nm nn no b">CardItemWidget</code>,我们会看到以下内容:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nr"><img src="../Images/80b71378bff6e7c105942ed860e4eb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4gTv_niy9izdVqSG_vc_w.png"/></div></div></figure><p id="165e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个是解锁时的视图，第二个是锁定时的视图。</p><p id="ed96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，我们走了很长的路来到这里！🦕这一观点是如何演变的:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ns"><img src="../Images/60a731690b99c698ee5e42be0c8c7905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9Gm66Zx9_L4CUjDM4La8A.png"/></div></div></figure><p id="b978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经准备好显示数据和取决于该数据的不同状态的UI。</p><p id="8eee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一篇文章中，我们将看到如何将视图实体映射为数据载体，并利用Bloc抽象来创建状态。</p><p id="33e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是<a class="ae kv" href="http://github.com/abalalovski/n26-cards-flutter" rel="noopener ugc nofollow" target="_blank">库</a>，它将在本系列结束时保存完整的代码。</p><p id="c198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">感谢迄今为止的阅读。</em></p><blockquote class="nt nu nv"><p id="cb53" class="jn jo kl jp b jq jr js jt ju jv jw jx nw jz ka kb nx kd ke kf ny kh ki kj kk ij bi translated">💙欢迎在评论中或推特上联系我们！</p></blockquote></div></div>    
</body>
</html>