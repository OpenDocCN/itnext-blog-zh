<html>
<head>
<title>From Native to JavaScript and back or trigger native components in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从本机到JavaScript，并在React Native中返回或触发本机组件</h1>
<blockquote>原文：<a href="https://itnext.io/from-native-to-javascript-and-back-or-trigger-native-components-in-react-native-b19992bb822d?source=collection_archive---------1-----------------------#2018-11-28">https://itnext.io/from-native-to-javascript-and-back-or-trigger-native-components-in-react-native-b19992bb822d?source=collection_archive---------1-----------------------#2018-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/39457f3d53953809e6f94a93d1a0cd87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcurE7mkH9rNXG2vCb2UbA.jpeg"/></div></div></figure><p id="5e74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您正在寻找如何在React Native中将本地组件与JavaScript桥接，您可以查看<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-react-native-bridge-and-get-pdf-viewer-44614f11e08e">如何构建react-native桥并获取PDF Viewer </a>文章，这在大多数情况下已经足够了。但是如果你需要用另一种方式过桥呢？当然，你可以使用声明的方式和改变属性，但这不是我们要找的，我们不想重新呈现反应组件。此外，它限制了缺乏功能的应用程序，如果加载失败(<em class="le">可能是一些网络问题或您需要刷新文档等)，则很难实现像<code class="fe la lb lc ld b">reload</code>文档这样的功能。</em>)，或者其他动作如<code class="fe la lb lc ld b">save</code>、<code class="fe la lb lc ld b">refresh</code>等。实际上，我们可以把它与单向过桥相比较，因为没有回头路</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/8c8deaeffb7bed69840e1dffa0b92784.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*bku_lJByUZI8XZ-emB7YQg.jpeg"/></div></figure><p id="9a12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望React Native足够强大，也允许从JavaScript调用本地组件。假设您已经有了一个项目和一个桥接到JavaScript的组件，让我们从JavaScript调用本地组件并扩展桥接功能成为可能。可以通过以下方式完成:</p><ul class=""><li id="1a49" class="lk ll it kd b ke kf ki kj km lm kq ln ku lo ky lp lq lr ls bi translated">实施android变更</li><li id="77ce" class="lk ll it kd b ke lt ki lu km lv kq lw ku lx ky lp lq lr ls bi translated">实现JavaScript更改和测试</li><li id="2a7b" class="lk ll it kd b ke lt ki lu km lv kq lw ku lx ky lp lq lr ls bi translated">实施iOS变更</li></ul><h1 id="94b8" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">Android实现</h1><p id="3a3a" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">打开视图管理器，实现<code class="fe la lb lc ld b">getCommandsMap</code>和<code class="fe la lb lc ld b">receiveCommand</code>方法:</p><ul class=""><li id="ccf7" class="lk ll it kd b ke kf ki kj km lm kq ln ku lo ky lp lq lr ls bi translated"><code class="fe la lb lc ld b">getCommandsMap</code> -应返回命令名和id之间的映射，然后在<code class="fe la lb lc ld b">receiveCommand</code>方法中使用</li><li id="7774" class="lk ll it kd b ke lt ki lu km lv kq lw ku lx ky lp lq lr ls bi translated"><code class="fe la lb lc ld b">receiveCommand</code> -直接从JavaScript接收事件/命令的方法</li></ul><p id="866f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实现如下:</p><pre class="lg lh li lj gt nb ld nc nd aw ne bi"><span id="8d46" class="nf lz it ld b gy ng nh l ni nj">private static final int COMMAND_RELOAD = 1;</span><span id="a27c" class="nf lz it ld b gy nk nh l ni nj">// the code of your view manager<br/>...</span><span id="d1a4" class="nf lz it ld b gy nk nh l ni nj">@Override<br/>public Map&lt;String,Integer&gt; getCommandsMap() {<br/>  return MapBuilder.of("reload", COMMAND_RELOAD);<br/>}</span><span id="e2e8" class="nf lz it ld b gy nk nh l ni nj">public void receiveCommand(final PDFView view, int command, final ReadableArray args) {<br/>  switch (command) {<br/>    case COMMAND_RELOAD: {<br/>      // The code you are going to execute when the command is called<br/>      break;<br/>    }<br/>    default: {<br/>      break;<br/>    }<br/>  }<br/>}</span></pre><p id="8df9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们所看到的，它实现起来非常简单，您也可以轻松地用其他命令扩展它。</p><h1 id="d4c3" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">JavaScript实现</h1><p id="83c8" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">实现需要<a class="ae kz" href="https://facebook.github.io/react-native/docs/direct-manipulation" rel="noopener ugc nofollow" target="_blank">直接操作</a>和访问组件(可以使用 <code class="fe la lb lc ld b"><em class="le">ref</em></code>访问<em class="le">):</em></p><pre class="lg lh li lj gt nb ld nc nd aw ne bi"><span id="0d20" class="nf lz it ld b gy ng nh l ni nj">&lt;RNPDFView<br/>  ref={ref =&gt; {<br/>    this._viewerRef = ref;<br/>  }}<br/>  {/* other attributes */}<br/>/&gt;</span></pre><p id="7a1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步是定义将触发命令的<code class="fe la lb lc ld b">reload</code>函数，它对于android和iOS略有不同:</p><ul class=""><li id="8a7e" class="lk ll it kd b ke kf ki kj km lm kq ln ku lo ky lp lq lr ls bi translated">在android上，我们可以使用<code class="fe la lb lc ld b">UIManager</code>和<code class="fe la lb lc ld b">dispatchViewManagerCommand</code></li><li id="a2f2" class="lk ll it kd b ke lt ki lu km lv kq lw ku lx ky lp lq lr ls bi translated">在iOS上，我们访问视图管理器并调用它的方法来触发事件</li></ul><p id="5576" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实施将是:</p><pre class="lg lh li lj gt nb ld nc nd aw ne bi"><span id="f1ae" class="nf lz it ld b gy ng nh l ni nj">// Imports and other code</span><span id="642e" class="nf lz it ld b gy nk nh l ni nj">class PDFView extends React.Component&lt;Props, *&gt; {<br/>  // component implementation<br/>  <br/>  reload() {<br/>    if (this._viewerRef) {<br/>      const handle = findNodeHandle(this._viewerRef);</span><span id="4ae3" class="nf lz it ld b gy nk nh l ni nj">      if (!handle) {<br/>        throw new Error('Cannot find node handles');<br/>      }</span><span id="fa37" class="nf lz it ld b gy nk nh l ni nj">      await Platform.select({<br/>        android: async () =&gt; {<br/>          return UIManager.dispatchViewManagerCommand(<br/>            handle,<br/>            UIManager.PDFView.Commands.reload,<br/>            [],<br/>          );<br/>        },<br/>        ios: async () =&gt; {<br/>          return NativeModules.PDFViewManager.reload(handle);<br/>        },<br/>      })();<br/>    } else {<br/>      throw new Error('No ref to PDFView component, check that component is mounted');<br/>    }<br/>  }<br/>}</span></pre><p id="7e39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并且在您的应用中，在接收到<code class="fe la lb lc ld b">ref</code>到<code class="fe la lb lc ld b">PDFView</code>组件后，触发<code class="fe la lb lc ld b">reload</code>命令:</p><pre class="lg lh li lj gt nb ld nc nd aw ne bi"><span id="af63" class="nf lz it ld b gy ng nh l ni nj">// Event that can be triggered by some button<br/>onButtonClick = () =&gt; {<br/>  this.reload();<br/>}</span><span id="49cc" class="nf lz it ld b gy nk nh l ni nj">// A method that triggers reload<br/>reload = () =&gt; {<br/>  if (this._pdfRef) {<br/>    this._pdfRef.reload();<br/>  }<br/>}</span><span id="bbb8" class="nf lz it ld b gy nk nh l ni nj">// Get ref to component<br/>onRef = (ref: ?PDFView) =&gt; {<br/>  this._pdfRef = ref;<br/>}</span><span id="2503" class="nf lz it ld b gy nk nh l ni nj">render() {<br/>  // other code<br/>  return (<br/>    {/* App implementation */}<br/>    &lt;PDFView<br/>      {/* Other properties */}<br/>      onRef={this.onRef}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="d8d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅此而已。现在<code class="fe la lb lc ld b">reload</code>方法可以在应用程序的任何地方被调用，只要需要。不需要强制更改属性或重新加载react组件。</p><h1 id="7f9b" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">iOS实施</h1><p id="36df" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">现在，当JavaScript到android的桥梁准备好并工作时，是时候在iOS上实现它了。iOS的实现略有不同，需要组件公开必须触发的方法。<code class="fe la lb lc ld b">RCT_EXPORT_METHOD</code>用于说明:</p><pre class="lg lh li lj gt nb ld nc nd aw ne bi"><span id="f781" class="nf lz it ld b gy ng nh l ni nj">RCT_EXPORT_METHOD(reload: (nonnull NSNumber *)reactTag resolver: (RCTPromiseResolveBlock)resolve rejecter: (RCTPromiseRejectBlock)reject) {<br/>  // implementation<br/>}</span></pre><p id="54c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并且导出的方法提供了<code class="fe la lb lc ld b">reactTag</code>参数并承诺。使用<code class="fe la lb lc ld b">uiManager</code>和received <code class="fe la lb lc ld b">reactTag</code>可以获得查看器的实例:</p><pre class="lg lh li lj gt nb ld nc nd aw ne bi"><span id="5370" class="nf lz it ld b gy ng nh l ni nj">PDFView *view = (PDFView *)[self.bridge.uiManager viewForReactTag: reactTag];</span></pre><p id="5c99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此后，查看器的任何方法都可以被触发(当前情况下<em class="le">重新加载</em>)。最终实现将是:</p><pre class="lg lh li lj gt nb ld nc nd aw ne bi"><span id="af3f" class="nf lz it ld b gy ng nh l ni nj">RCT_EXPORT_METHOD(reload: (nonnull NSNumber *)reactTag resolver: (RCTPromiseResolveBlock)resolve rejecter: (RCTPromiseRejectBlock)reject) {<br/>    dispatch_async(dispatch_get_main_queue(), ^{<br/>        PDFView *pdfView = (PDFView *)[self.bridge.uiManager viewForReactTag: reactTag];<br/>        if (!pdfView) {<br/>            reject(ERROR_INVALID_REACT_TAG, [NSString stringWithFormat: @"ReactTag passed: %@", reactTag], nil);<br/>            return;<br/>        }<br/>        [pdfView reload];<br/>        resolve(nil);<br/>    });<br/>}</span></pre><h1 id="4d24" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">结论</h1><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/0ff41dbcc155d988619d4074bddc12d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lKXCjsqoiKvH2ZzyV4Wobw.jpeg"/></div></div></figure><p id="5963" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在JavaScript和native之间建立桥梁并不需要做很多工作。拥有这样的桥梁使我们能够显著扩展React Native的功能，例如提高应用程序中一些需要更好性能的关键部分的性能，实现缺失的功能或重用一些已经开发的组件。此外，它再次证明了React Native的可能性真的很惊人，React Native允许在iOS和android两个平台上以更少的努力开发成熟的应用程序。</p><p id="a4c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有描述的技术都在<a class="ae kz" href="https://github.com/rumax/react-native-PDFView" rel="noopener ugc nofollow" target="_blank"> PDF Viewer </a> react native组件中使用，该组件还包括一个<a class="ae kz" href="https://github.com/rumax/react-native-PDFView/tree/master/demo" rel="noopener ugc nofollow" target="_blank">演示项目</a>，您可以在其中检查桥是如何工作的，等等。</p></div></div>    
</body>
</html>