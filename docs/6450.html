<html>
<head>
<title>How to run a dockerized Azure Function within docker-compose in Visual Studio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Visual Studio的docker-compose中运行dockerized Azure函数</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-run-a-dockerized-azure-function-within-docker-compose-in-visual-studio-8958e912d3fa?source=collection_archive---------0-----------------------#2021-11-20">https://itnext.io/how-to-run-a-dockerized-azure-function-within-docker-compose-in-visual-studio-8958e912d3fa?source=collection_archive---------0-----------------------#2021-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/850833b421728f7e30fae10789a1fbeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*X7DOIUM018YZBvgf-2mhuw.png"/></div></figure><div class=""/><p id="b308" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您正在使用Docker和Visual Studio，那么您很可能也在使用Visual Studio快速模式容器工具。在容器化的环境中进行快速开发是一种非常方便的集成，类似于一个合适的容器在生产系统中的表现。</p><p id="08b0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您正在一次开发多个容器，您可能还会使用VS提供的同样惊人的docker-compose设置。</p><p id="d843" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这一切都很棒，您可以快速调试自己的服务，甚至可以轻松集成常见的外部容器，如rabbitmq、sql或seq。</p><p id="4e28" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，<strong class="jz jb">还没有</strong>起作用的是添加一个容器化的Azure功能。虽然Azure函数支持容器工具，但还不能将其添加到docker-compose项目中。</p><p id="4666" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当然，你可以像任何其他服务一样，手动将其添加到docker-compose.yml中，但这样你将缺少调试等功能。—当然，除非您安装了远程调试器。</p><p id="2ff2" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是，有一种方法可以使它成为第一流的，只需一个小的变通方法，就可以在docker-compose网络中调试您的函数，以解决DNS解析问题，并且所有这些都在从VS中启动/停止调试的常规范围内。</p><h1 id="e998" class="kv kw ja bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">怎么做</h1><p id="fd11" class="pw-post-body-paragraph jx jy ja jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">我是这样做的:</p><p id="9144" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在Visual Studio中，在解决方案资源管理器中右键单击您的解决方案，转到“属性”,在“启动项目”部分，选择“多个启动项目”,并将您的docker-compose项目以及您各自的Azure Function项目设置为“启动”</p><p id="ec78" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们需要创建一个docker网络，您的compose项目和函数将在其中运行，这样服务名DNS解析就可以在您的函数容器和compose服务之间工作。<br/>我们通过docker cli来实现这一点。以下是命令:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="983c" class="mh kw ja md b gy mi mj l mk ml">docker network create yournetworkname</span></pre><p id="08c6" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当然，<em class="mm">你的网络名</em>在这里由你决定。</p><p id="b0fa" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，导航到。azure函数项目的csproj文件。在PropertyGroup标记中，为了一致性，最好是已经包含由VS生成的docker设置的标记，我们需要添加另一个标记:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="d927" class="mh kw ja md b gy mi mj l mk ml">&lt;DockerfileRunArguments&gt;--network yournetworkname --network-alias yourservicename&lt;/DockerfileRunArguments&gt;</span></pre><p id="771a" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当然，同样在这个例子中，用您在步骤2中选择的名称替换您的networkname。此外，yourservicename将是网络别名，通过它，容器网络中的DNS解析将起作用，因此在这里选择适合您的容器的名称。</p><p id="666d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">csproj文件到此为止，现在就去你的docker-compose.yml吧。我们现在需要声明各自的网络，方法是将这个部分添加到docker-compose文件中:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="dcca" class="mh kw ja md b gy mi mj l mk ml"><em class="mm">networks:<br/>  </em>yourcomposenetworkname<em class="mm">:<br/>    external:<br/>      name: </em>yournetworkname</span></pre><p id="9125" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这将把您的networkname声明为docker-compose设置的外部网络，并在compose yaml中使用您的composenetworkname的别名。如果您愿意，您可以在这里更改内部别名，但为了保持一致，我只是将两个网络命名为相同的名称。</p><p id="fa51" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">快到了。我们现在需要做的就是将新网络添加到docker-compose.yml文件中声明的所有服务中。我们通过在需要的任何地方将它添加到networks属性中来做到这一点。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ce2c" class="mh kw ja md b gy mi mj l mk ml">services:<br/>  serviceone:<br/>    ...<br/>    <strong class="md jb">networks:<br/>      - yourcomposenetworkname</strong><br/>  servicetwo:<br/>    ...<br/>    <strong class="md jb">networks:<br/>      - yourcomposenetworkname</strong></span></pre><p id="f08f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">仅此而已。如果我们现在开始运行我们设置的东西，VS将立刻分别启动docker-compose项目和函数，但是它将把runarguments传递给“松散的”容器，这样一切都将很好地结合在一起。</p><p id="7bef" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">请记住，我仍然认为这是一个有点黑客的解决办法，所以手指交叉在微软的开发人员将正式支持这很快✌️</p></div></div>    
</body>
</html>