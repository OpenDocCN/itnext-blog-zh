<html>
<head>
<title>Communication between Go service and Postgres database (both running in Docker)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go服务和Postgres数据库之间的通信(都运行在Docker中)</h1>
<blockquote>原文：<a href="https://itnext.io/communication-between-go-service-and-postgres-database-both-running-in-docker-ae0fd53a25b8?source=collection_archive---------3-----------------------#2021-01-04">https://itnext.io/communication-between-go-service-and-postgres-database-both-running-in-docker-ae0fd53a25b8?source=collection_archive---------3-----------------------#2021-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5094" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过一个直接从Go代码创建数据库和表的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0243cd43ffd7d54cb5eb45bfb48a7270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InFe0jU-dOOJbhFISFyZXg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由Renee French创建的原始地鼠图像，使用由Maria Letta创建的地鼠图像</figcaption></figure><ol class=""><li id="b6b6" class="ky kz it la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">部分:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-de827d7f07cf" rel="noopener">创建服务</a></li><li id="c5aa" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">part: <a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-ii-c397fd17875" rel="noopener">改善服务</a></li><li id="bb97" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">part: <a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-iii-c84489cc1ee0" rel="noopener">网页升级</a></li><li id="ae68" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">零件:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-iv-c1f6b91401c1" rel="noopener">添加SSE </a></li><li id="b0cb" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">部分:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-v-63c260594ed9" rel="noopener">简单的javascript前端功能</a></li><li id="88e1" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">零件:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-vi-1fc383d435bd" rel="noopener">前端—后端通信</a></li><li id="d482" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">部分:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-vii-2a550c9204a6" rel="noopener">服务器端日志</a></li><li id="856e" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">零件:<a class="ae lq" href="https://petrjahoda.medium.com/create-go-service-the-easy-way-viii-157427e7cd35" rel="noopener">在docker </a>中运行所有零件</li><li id="2037" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">零件:<a class="ae lq" href="https://petrjahoda.medium.com/test-story-618d1cfca0cd" rel="noopener">添加数据库容器</a></li><li id="64f4" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">part: <strong class="la iu">你现在正在看</strong></li></ol><p id="c8f9" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">追加1: <a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/go-functions-methods-pointers-and-interfaces-1c034fd198d3">函数、方法、指针和接口</a> <br/>追加2: <a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/websocket-communication-between-two-go-programs-the-easy-way-d8c9cf40043f"> websocket通信</a> <br/>追加3: <a class="ae lq" href="https://petrjahoda.medium.com/plain-socket-communication-between-two-go-programs-the-easy-way-bd5ac5819eb6" rel="noopener"> socket通信</a></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9969" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">访问Docker中运行的数据库</h1><p id="4e23" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">假设您运行两个(或更多)Docker容器。其中一个容器包含正在运行的数据库。并且您想从所有这些非数据库容器中访问这个数据库。</p><p id="f932" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">这篇文章将告诉你，如何去做。它还将向您展示如何直接从Go代码创建数据库和表。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="83c8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">准备项目</h1><p id="498c" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">再次打开您的项目并导航到<strong class="la iu">数据库。转到</strong>文件。在此添加一个新常数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="acbf" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">这个常量保存到我们新的<code class="fe np nq nr ns b">medium</code>数据库(尚未创建)的连接字符串。</p><p id="454e" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated"><strong class="la iu">本文包含五大步骤:</strong></p><ol class=""><li id="0119" class="ky kz it la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">直接从代码创建数据库</li><li id="dc1e" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">直接从代码创建表</li><li id="0450" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">添加简单的写操作</li><li id="e91b" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">添加简单的读取操作</li><li id="994a" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">在网页上显示已读数据</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="066a" class="nt mr it bd ms nu nv dn mw nw nx dp na lf ny nz nc lh oa ob ne lj oc od ng oe bi translated">直接从Go代码创建数据库</h2><p id="b3ad" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">我们的函数<code class="fe np nq nr ns b">checkDatabase()</code>现在只做一件事:检查PostgreSQL数据库是否可访问。</p><p id="63a9" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">用下面的代码更新这个函数。首先，该函数将检查主数据库<code class="fe np nq nr ns b">postgres</code>是否可用，这保持不变。如果可用，就要进行第二次可用性检查——这次是针对名为<code class="fe np nq nr ns b">medium</code>的数据库。如果这个<code class="fe np nq nr ns b">medium</code>数据库不可用，它会尝试创建它。如果它可用(已经创建)，它只记录这个信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="9d6a" class="nt mr it bd ms nu nv dn mw nw nx dp na lf ny nz nc lh oa ob ne lj oc od ng oe bi translated">首次测试</h2><p id="4242" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">如果您现在构建您的<code class="fe np nq nr ns b">medium_service</code> docker映像并运行<code class="fe np nq nr ns b">docker-compose up -d</code>，您会注意到您首先遇到了一个错误。这和我们在上一篇文章中运行的错误是一样的:<code class="fe np nq nr ns b">medium_service</code>运行起来比<code class="fe np nq nr ns b">medium_database</code>启动它的数据库要快得多。</p><p id="05b3" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">要解决这个问题，只需使用<code class="fe np nq nr ns b">docker restart medium_service</code>重启这个服务，并显示日志<code class="fe np nq nr ns b">docker logs -f medium_service.</code>，现在您可以看到结果。</p><ol class=""><li id="64e2" class="ky kz it la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">服务已启动</li><li id="ec8c" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">为postgres数据库检查的服务…可用</li><li id="ceb0" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">为中型数据库检查服务…不可用</li><li id="c065" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll lm ln lo lp bi translated">服务创建了此数据库</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ee0e1b98f8247e31f556329474080ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9IvqnCogT2pq9Uek2Cq3Q.png"/></div></div></figure><p id="a6e7" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">如果您重新启动服务并再次获取日志，您会看到，这一次，即使是这个中型数据库也已经创建好了(它应该已经创建好了)。第一步完成了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/92ed2ff1a2512b3b6eed2037bca9f668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h72gZoFJzUifTiQ9fFbZQw.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="4477" class="nt mr it bd ms nu nv dn mw nw nx dp na lf ny nz nc lh oa ob ne lj oc od ng oe bi translated">直接从Go代码创建表格</h2><p id="2ada" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">我们需要开始在<strong class="la iu">数据库中为我们的新表创建结构。在已经存在的两个常量下面添加一个新的结构。这个结构将用于在Go和数据库之间映射数据。我们将这个表命名为<code class="fe np nq nr ns b">ButtonRecords</code>，它有6列:</strong></p><ul class=""><li id="4c8d" class="ky kz it la b lb lc ld le lf lg lh li lj lk ll oh ln lo lp bi translated"><code class="fe np nq nr ns b">gorm.Model </code>创建了四个非常有用的列(参见奖励部分的截图)</li><li id="bc2c" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll oh ln lo lp bi translated"><code class="fe np nq nr ns b">Name</code>创建文本类型的列</li><li id="6399" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll oh ln lo lp bi translated"><code class="fe np nq nr ns b">Time</code>创建时间戳类型的列</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9f45" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">现在添加代码，它将处理创建表和更新表(如果已经创建了的话)。</p><p id="de12" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">如果您有一个新版本的表，例如包含新列的表，那么更新会很方便。第二部分代码会自动将这些新列添加到已经存在的表中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="3291" class="nt mr it bd ms nu nv dn mw nw nx dp na lf ny nz nc lh oa ob ne lj oc od ng oe bi translated">第二次测试</h2><p id="9b65" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">现在<code class="fe np nq nr ns b">docker-compose down</code>你的运行容器。然后更新你的<code class="fe np nq nr ns b">medium_service</code>图。让卷<code class="fe np nq nr ns b">medium_db</code>保留已经创建的数据库，并使用<code class="fe np nq nr ns b">docker-compose up -d</code>再次运行它。这一次您将看到，两个数据库检查都正常。然后代码检查该表，如果没有找到，就创建它。就像这个例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ae7b899d1e4045a43d56162cc55300a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_q4hY821MGGcGPwUXH6rg.png"/></div></div></figure><p id="6bc3" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">如果您重新启动您的<code class="fe np nq nr ns b">medium_service</code>并再次检查日志，这一次您会看到，该表已经存在，所以只有更新将被处理。这样我们的第二步就完成了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/b6d545438c37fb63a59446cbab42bf88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVgyvJ8FccJmQNeAbenDqg.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="8a08" class="nt mr it bd ms nu nv dn mw nw nx dp na lf ny nz nc lh oa ob ne lj oc od ng oe bi translated">添加读写操作</h2><p id="5721" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">导航到您的<strong class="la iu">主页，转到</strong>文件，进入<code class="fe np nq nr ns b">getTime()</code>功能。</p><p id="696e" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">我们将在这里添加一个小功能:当用户点击网页按钮时，我们的代码将在已经创建的表中创建新的记录。然后从该表中读取所有记录，并将它们发送回网页。然后我们将在HTML表格中显示这些数据。</p><p id="3914" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">如下更新<code class="fe np nq nr ns b">getTime()</code>功能。正如你所看到的，我们删除了一半的代码，并添加了新的代码。因为我们希望首先处理错误，所以这个新代码会尝试打开数据库，如果出现错误，它会将错误信息发送回网页。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="20b9" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated"><em class="ok">附注:您可以使用许多Go模块进行数据库通信。我几乎都试过了，最后用了</em><a class="ae lq" href="https://gorm.io" rel="noopener ugc nofollow" target="_blank"><em class="ok">GORM</em></a><em class="ok">，它易于使用，代码可读，可以访问所有主要的数据库，而且——以我的经验来看——真的很快。</em></p><p id="d5a5" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">现在我们将添加这个读写功能。现在所有的错误都被处理了，所以我们可以向函数的其余部分添加代码了——这是我们的幸福之路。</p><p id="a4d8" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">添加两行新行，创建一个名为<code class="fe np nq nr ns b">record</code>的新变量，当用户单击该按钮时，用来自我们网页的数据填充它的字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ff25" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">就是这样，将数据写入数据库很容易。</p><p id="32dd" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">从数据库中读取数据也很容易。添加这三行。第一行创建名为<code class="fe np nq nr ns b">records</code>的变量，第二行从表<code class="fe np nq nr ns b">ButtonRecords</code>中读取所有记录，第三行只是打印一些有用的信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ba42" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">我们还需要为输出的数据更新我们的结构，这样我们就可以把那些记录发送回去。如下所示更新TimeDataOutput结构(只添加了一行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0124" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">然后为函数的其余部分添加代码。有一条<em class="ok">新</em>线<code class="fe np nq nr ns b">responseData.Records = records</code>。这一行将我们的数据库<code class="fe np nq nr ns b">records</code>添加到我们返回网页的响应中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="80df" class="nt mr it bd ms nu nv dn mw nw nx dp na lf ny nz nc lh oa ob ne lj oc od ng oe bi translated">第三次测试</h2><p id="6081" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">再一次… <code class="fe np nq nr ns b">docker-compose down</code>一切，创造你的<code class="fe np nq nr ns b">medium_service</code>和<code class="fe np nq nr ns b">docker-compose up -d</code>一切回来。</p><p id="1b62" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">打开浏览器，打开页面，查看<code class="fe np nq nr ns b">medium_service</code>日志。下面的截图是你按下按钮后应该看到的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/48ad8678e027611fb313bb0e4e2f98ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBSum66TmZAGoghkQ6KOpQ.png"/></div></div></figure><p id="855a" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">按下按钮的次数越多，从数据库中读取的记录就越多。就像下面的截图一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/5bd7e6092d2d1a610ea7df06b414b104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94v0SkbW28wE7hi1kR0j3g.png"/></div></div></figure><p id="6a08" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">我们还需要检查，是否所有内容都返回到浏览器。如果您在浏览器中打开了控制台，您应该会看到在单击一个按钮并接收回数据后，有一个包含数据数组的对象。这些是数据库里的数据。</p><p id="63a2" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">我们完成了第3步和第4步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/df7a1503d0c78107c0a40a0e4cf9526b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2RZK6u1wGCkVY8zZev92Q.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="f6fe" class="nt mr it bd ms nu nv dn mw nw nx dp na lf ny nz nc lh oa ob ne lj oc od ng oe bi translated">完成项目</h2><p id="7eba" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">我们就要结束了。我们将添加最后一个功能:在用户单击该按钮后，在页面上的一个简单表格中显示数据库中的数据。</p><p id="45ab" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">用新行更新您的<strong class="la iu">homepage.html</strong>文件，它将保存那些返回的数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3064" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">然后导航到<strong class="la iu"> homepage.js </strong>并在文件的开头添加一个新行:<code class="fe np nq nr ns b">const table = document.getElementById(“table”)</code>，这样我们就可以访问那个html表。</p><p id="2e1f" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">然后用下面的代码更新您的<code class="fe np nq nr ns b">response</code>函数。这段代码将访问这些<code class="fe np nq nr ns b">Records</code>并将一条又一条记录添加到我们的表中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c198" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">还要在你的<code class="fe np nq nr ns b">checkDatabase()</code>函数的开头添加<code class="fe np nq nr ns b">time.Sleep(2*time.Second) </code>，这样我们就不需要再次重启<code class="fe np nq nr ns b">medium_service</code>容器，当我们从头开始运行所有的<em class="ok"/>。</p><h2 id="d7a0" class="nt mr it bd ms nu nv dn mw nw nx dp na lf ny nz nc lh oa ob ne lj oc od ng oe bi translated">最后试验</h2><p id="3bb5" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">再次，<code class="fe np nq nr ns b">docker-compose down</code>一切，使用<code class="fe np nq nr ns b">docker rm medium_db</code>移除卷，再次创建我们的<code class="fe np nq nr ns b">medium_service</code>并<code class="fe np nq nr ns b">docker-compose up -d</code>一切正常。</p><p id="7f7a" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">这两秒钟足以让<code class="fe np nq nr ns b">medium_database</code>创建它的基本postgres数据库，所以我们的<code class="fe np nq nr ns b">medium</code>数据库是在第一次运行时创建的。</p><p id="d837" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">希望您能看到如下内容。每次按下按钮，新的记录就会在后台保存到数据库中。之后，所有记录立即从数据库中下载，并在浏览器中显示为表格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/7d37ca4cd37426016be169b28fcfdbaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FCBS5gl7P56a9P8oM2wEnQ.gif"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bce7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="6bc8" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">我们到达了终点，现在你知道，如何…</p><ul class=""><li id="d65f" class="ky kz it la b lb lc ld le lf lg lh li lj lk ll oh ln lo lp bi translated">写入运行在不同docker容器中的数据库</li><li id="3db9" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll oh ln lo lp bi translated">从该数据库中读取</li><li id="c1d6" class="ky kz it la b lb lr ld ls lf lt lh lu lj lv ll oh ln lo lp bi translated">将这些数据发送回浏览器并显示给用户</li></ul><div class="oo op gp gr oq or"><a href="https://github.com/petrjahoda/medium_service/tree/Chapter_10" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">petrjahoda/中型服务</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">中等_服务。在GitHub上创建一个帐户，为petrjahoda/medium-service的发展作出贡献。</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ffec" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">额外功能</h1><p id="e875" class="pw-post-body-paragraph lw lx it la b lb ni ju ly ld nj jx lz lf nk mb mc lh nl me mf lj nm mh mi ll im bi translated">我希望你现在已经厌倦了那些码头工人写的东西。我们这样做的原因是让你为这个额外的功能做好准备:-)。</p><p id="91f0" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">由于我们现在已经构建了我们的<code class="fe np nq nr ns b">docker-compose.yml</code>文件，我们不能从Docker外部访问我们的数据库。出于安全原因，这很好，但是对于开发来说很烦人。</p><p id="4dd4" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">因此，对于开发来说，将端口映射添加到我们的<code class="fe np nq nr ns b">docker-compose.yml</code>文件中，并保持您的数据库运行。在这个例子中，端口5433用于从Docker外部访问容器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="049e" class="pw-post-body-paragraph lw lx it la b lb lc ju ly ld le jx lz lf ma mb mc lh md me mf lj mg mh mi ll im bi translated">现在，您可以在启用该端口的情况下再次运行它，然后使用Goland的内置数据库功能，并在开发代码时访问我们的表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/f1529c57b0badad4ff1041994189711b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dcNArP8rOb20l4kLhZayA.png"/></div></div></figure></div></div>    
</body>
</html>