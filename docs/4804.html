<html>
<head>
<title>I’m sorry OpenShift, I’ve taken you for granted…(the evidence)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对不起，我把你想当然了……(证据)</h1>
<blockquote>原文：<a href="https://itnext.io/im-sorry-openshift-i-ve-taken-you-for-granted-the-evidence-dd7a7d471fa1?source=collection_archive---------2-----------------------#2020-09-22">https://itnext.io/im-sorry-openshift-i-ve-taken-you-for-granted-the-evidence-dd7a7d471fa1?source=collection_archive---------2-----------------------#2020-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d38ba40af040fbf6fc37f750d4abc95c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDUnPqU8ShgiwVwxJhm8RQ.png"/></div></div></figure><p id="1900" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是旨在了解Kubernetes应用程序开发入门的两篇文章的第二部分。请看这里第一部分<a class="ae kw" href="https://medium.com/@graemecolman/im-so-sorry-openshift-i-ve-taken-you-for-granted-f36fb47ea4d9" rel="noopener"> <strong class="ka ir">对不起OpenShift，我把你当成了</strong> </a></p><p id="8a04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我写这篇文章是因为我与客户(我在Red Hat工作)就Kubernetes上的应用程序开发以及为什么OpenShift上的应用程序开发与众不同进行了多次讨论。</p><p id="9071" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我首先要让他们明白的是，Kubernetes是Kubernetes，OpenShift是一个Kubernetes平台，就像AK或EKS是Kubernetes平台一样。这些平台都增加了针对其目标用户群的价值。一旦解决了这个问题，接下来的问题就是一个平台相对于另一个平台增加了什么价值。</p><p id="be03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我想我应该以<em class="kx">的结论写一篇文章:“嘿，让你的代码在AKS、EKS、DIY Kubernetes或“另一个Kubernetes平台”</em> <strong class="ka ir"> <em class="kx">(我将把这个称为AKP) </em> </strong> <em class="kx">或在OpenShift上运行没有什么区别，答案是……它们都真的很容易！”</em></p><p id="6dc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我想我应该在AKP和红帽OpenShift容器平台(OCP或只是OpenShift)上做一个非常简单的“Hello World”的例子，以探索任何差异和相似之处。</p><p id="122f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在写这篇文章时，我意识到我已经习惯使用OpenShift很长时间了，并看到它成长为一个令人敬畏的平台，其价值超越了Kubernetes发行版。实际上，我认为OpenShift的成熟和简单是理所当然的，并强调了OpenShift的一些亮点。</p><p id="c2d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章是一个关于我如何在两个平台上建立和运行我的“Hello World”的一步一步的客观指南(好吧，也许是一点点意见！).如果你想对同一件事有一个完全主观的看法，那么<strong class="ka ir">我这里有另一个帖子</strong> :) [[URL]]对于这个帖子，我会尽量坚持事实！</p><h1 id="38bb" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">集群</h1><p id="9309" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">所以我的“Hello World”需要集群。我没有走公共云路线，因为有些事情意味着要为计算、注册、网络、数据传输等付费。所以我选择了Minikube<a class="ae kw" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank">中的简单单节点集群工具</a>(用于AKP)和<a class="ae kw" href="https://developers.redhat.com/products/codeready-containers/overview" rel="noopener ugc nofollow" target="_blank">代码就绪容器</a>(用于我的OpenShift集群的CRC)。这两个工具设置起来都很简单，但是确实需要笔记本电脑上的大量资源。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/b0204372233ac345398ff0b66a97c820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DMCiMZLmn4sg15pq"/></div></div></figure><h1 id="dc43" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">另一个Kubernetes平台(AKP)构建</h1><p id="7f67" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">流程如下…[流程步骤图]</p><h1 id="fcbc" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第一步—构建我的容器映像</h1><p id="8726" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">首先，我将把我们的“Hello World”部署到minikube中。所以我需要的是:</p><p id="c611" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装了1个对接器</p><p id="2bf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装了2个Git</p><p id="e3df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3-安装了Maven(实际上我们在项目中使用了mvnw二进制文件，所以不一定需要它)</p><p id="98c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4-获取源代码:git克隆<a class="ae kw" href="https://github.com/gcolman/quarkus-hello-world.git" rel="noopener ugc nofollow" target="_blank">https://github.com/gcolman/quarkus-hello-world.git</a></p><p id="4128" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我需要做的第一件事是创建Quarkus项目。如果你没有看过Quarkus.io网站，那么这简直太简单了。选择项目中需要的组件(RestEasy、Hibernate、亚马逊SQS、Camel等)。).通过选择这些组件，Quarkus配置了一个maven原型，而我不需要做任何其他事情，然后它将整个事情推给github，只需点击一个按钮。我知道你会对我构建“Hello World”项目的技能印象深刻，但点击按钮真的是我唯一的贡献，谢谢你。我爱夸库斯！</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/8a814aa56c2b509964766e2fd371a295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bj_coOEL04zblzmE"/></div></div></figure><p id="995a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将我的Hello World构建成容器映像的最简单方法是使用docker Quarkus maven扩展，它将完成我的“Hello World”所需的一切。Quarkus让它变得非常简单，只需添加“container-image-docker”扩展来添加从maven命令创建图像的功能。</p><p id="1df2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">。/mvnw quar kus:add-extension-dex tensions = " container-image-docker "</strong></p><p id="1c6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后使用maven构建我的图像。这从我的源代码创建了一个容器映像，准备在我的本地容器运行时环境中运行。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/b42125dc076c1f9e92ffe67dfae05c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YsqLZAwvhVlTffBQ"/></div></div></figure><p id="cd18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">。/mvnw-X clean package-dquarkus . container-image . build = true</strong></p><p id="52a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已。我准备使用docker run命令运行容器，映射端口8080以使我能够调用我的服务。</p><p id="6dab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">docker run-I—RM-p 8080:8080 gcolman/quar kus-hello-world</strong></p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/c2501dd27b936f630840be569339a3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ATtHnNto-fDgD7O4"/></div></div></figure><p id="16fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着容器实例的运行，我只需要通过卷曲端点来测试我的Hello服务是否正在运行:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/48527898d2084d36d233e5669c664572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mKVsj3ksSuGEeNqx"/></div></div></figure><p id="f2f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，这是非常甜蜜的，很好，很容易，刚刚工作！</p><h1 id="7ffd" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第二步—将我的容器推送到容器映像存储库中。</h1><p id="ef75" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我在本地容器存储中构建并存储了我的映像，但是如果我希望该映像在我的AKP环境中运行，我需要将我的映像存储在某个存储库中。Kubernetes没有为我提供这些。我将使用dockerhub，因为它有一个慷慨的免费层，这是大多数人都会使用的。</p><p id="3022" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这相当简单，只需要你有一个dockerhub账户。</p><p id="bd38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个设置，把图像推送到dockerhub。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/b1e33156c8583483d87f9b44e9843a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cPiWPFC1s-aIL40L"/></div></div></figure><h1 id="a53a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第三步——启动Kubernetes</h1><p id="c119" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">现在有很多方法来构建一个kubernetes配置来运行我的“Hello World ”,但我只想要最简单最省力的，因为我就是那种类型的人！</p><p id="a8ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，启动我的minikube集群</p><p id="b5f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> minikube启动</strong></p><h1 id="ba84" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第四步—部署我的容器映像</h1><p id="6857" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我现在需要将我的代码和容器映像放入kubernetes配置中，我需要一个pod和部署定义，指向我的dockerhub容器映像。最简单的方法之一是运行指向容器映像的“创建部署”命令。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/af02ee45ea53a947207a64162403a10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/0*pMNA4M_9JErnek6-"/></div></figure><p id="0b6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> kubectl创建部署hello-quar kus-image = gcolman/quar kus-hello-world:1 . 0 . 0-SNAPSHOT</strong></p><p id="538c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行这个命令，我已经让我的AKP创建了一个部署配置，其中包括一个保存我的容器映像的pod规范。该命令还将配置应用于我的minikube集群，并创建了一个部署，该部署提取容器映像并在集群内的pod中运行。</p><h1 id="4eda" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第五步-创建对我的服务的访问</h1><p id="8622" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">现在我已经部署了容器映像，我需要考虑如何配置对代码创建的Restful服务的外部访问。</p><p id="850e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有相当多的方法可以做到这一点。例如，我可以使用expose命令自动创建Kubernetes组件，如服务和端点，这就是我们将要做的。在我的例子中，我可以用下面的命令公开部署对象对象，以给出我们所需要的。</p><p id="4084" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> kubectl expose部署hello-quar kus—type = node port—port = 8080</strong></p><p id="1091" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在继续之前，让我快速看一下expose命令的“— type”。</p><p id="ef54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们公开和创建运行服务所需的组件时，我们需要做的事情之一是将外部世界连接到位于内部软件定义网络中的hello-quarkus服务。<strong class="ka ir">类型</strong>参数允许我们创建和连接负载平衡器之类的东西，以将流量路由到网络中。</p><p id="74e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，<strong class="ka ir"> type=LoadBalancer </strong>将使一个自动配置的公共云负载平衡器能够插入到您的Kubernetes集群中。这很酷，但是请注意，这种配置将导致特定于公共云的配置，这种配置可能更难以跨环境跨poK实例移植。</p><p id="0552" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，我使用的是<strong class="ka ir"> type=NodePort </strong>。通过公开节点端口，我可以通过节点ip:端口组合来访问服务。我需要这样做，因为我没有使用公共云，所以我需要做一些额外的步骤。我需要做的第一件事是部署一个负载平衡器，我将把一个NGINX负载平衡器直接部署到集群中。</p><h1 id="a49f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第六步—安装负载平衡器</h1><p id="fdc1" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">幸运的是，我正在使用minikube，它具有一些平台特性，可以更容易地创建像ingress控制器这样的组件。Minikube带有一个Nginx入口控制器，我只需要启用它，然后进行配置。</p><p id="f0d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> minikube插件启用入口</strong></p><p id="6a9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢这种简单，它添加了一个NGINX入口控制器，在我的minikube集群中运行，只需一个命令！</p><p id="cb7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">入口-nginx-控制器-69ccf5d9d8-j5gs9 1/1运行1 33m </strong></p><h1 id="5aea" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第七步—配置入口</h1><p id="9436" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">所以，我现在需要配置我的NGINX入口控制器来接收hello-quarkus。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/37f465d57e4cc3ee52ed33e80655f6d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Me27Jor1Vjr7NPH2"/></div></div></figure><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/21d505f52d68a2e703fed41596bbcc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MuYO30L5plXnqtHm"/></div></div></figure><p id="fa7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后应用配置。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/ebb0e42c0a68eb9937a8285944e284be.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/0*9rpRWXD88eOwohLd"/></div></figure><p id="6cc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">ku bectl apply-f ingress . yml</strong></p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/0811cfac162fd3686c2dd4df0a0e9eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_RzUI3bL4yCOqUyw"/></div></div></figure><p id="21f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我在本地笔记本电脑上，所以我将把暴露的ip添加到我的/etc/ hosts文件中，以将http请求定向到我的minikube NGINX load balancer。</p><p id="091e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你好-quarkus.info</p><p id="1b14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后…现在你可以通过NGINX入口控制器作为外部服务访问minikube服务。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/d960256909d5528913559d0b6aaf9604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gDclCzJGb2QVC3SH"/></div></div></figure><h2 id="3d52" class="mm kz iq bd la mn mo dn le mp mq dp li kj mr ms lm kn mt mu lq kr mv mw lu mx bi translated">哇哦，那很简单，不是吗…不是吗？</h2><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/4fa00ea62a69e9705feb458377b87805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cKqNnOwGIsl8Hw5Z"/></div></div></figure><h1 id="e3e1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在OpenShift(代码就绪容器)上运行</h1><p id="5eb6" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这里是我在Red Hat OpenShift容器平台(OCP)上部署相同代码的地方。</p><p id="b8ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在选择在OpenShift上运行我的示例时，类似于使用minikube的原因，我使用了代码就绪容器(CRC)形式的单节点本地OpenShift集群。这在过去被称为minishift，它使用OpenShift Origin项目，CRC是使用Red Hat支持的OpenShift容器平台的较新版本。</p><p id="a0f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在这个博客的<strong class="ka ir">姐妹贴</strong>中说，我从来没有打算让这个帖子成为“OpenShift很棒”的文章，但是对不起，<strong class="ka ir"> OpenShift很棒</strong>！</p><p id="d27d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最初想说的是，在OpenShift上开发与在Kubernetes上开发没有什么不同，这在本质上是正确的，但在走过场的过程中，我忘记了OpenShift对开发人员有多友好。我喜欢简单，在OpenShift上建立并运行hello world的简单性让我无法不写这篇文章！</p><p id="85fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看我需要经历的过程:</p><p id="a168" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[[Openshift过程]]]</p><p id="2fb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">等等，真的，…我不需要装Docker？</p><p id="b363" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我不需要本地git？</strong></p><p id="f6a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我不需要Maven？</strong></p><p id="e677" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我不需要手动创建图像？</strong></p><p id="af7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我不需要找图像库？</strong></p><p id="9fbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我不需要安装入口控制器？</strong></p><p id="1e0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我不需要配置ingress？</strong></p><p id="0cdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，不，我不需要以上任何一个来启动和运行OpenShift。下面是我经历的过程。</p><p id="83ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">步骤1 —启动我的OpenShift集群</strong></p><p id="7bbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用的是Red Hat的代码就绪容器，它本质上和Minikube一样，但是有一个完整的单节点Openshift custer。</p><p id="1165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">华润创业</strong></p><p id="26a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">步骤2——构建应用并将其部署到我的OpenShift集群中</strong></p><p id="7b60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，这就是简单变得真实的地方。与所有Kubernetes发行版一样，有许多方法可以让应用程序在集群中运行。与我的AKP集群一样，我希望以最简单的方式启动并运行我的“Hello World”。</p><p id="35d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">OpenShift一直将自己定位为构建和运行容器应用程序的应用程序平台。构建容器一直是该平台不可或缺的一部分，因此有大量Kubernetes自定义资源可以提供帮助。</p><p id="62cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将为我的Hello World使用OpenShift的源2图像(S2I)过程。S2I有多种方法获取源代码(代码或二进制文件)并将源代码转换成在我的OpenShift集群中运行的容器映像。</p><p id="7545" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我需要两样东西:</p><ul class=""><li id="95e7" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">我在git repo中的源代码</li><li id="fb81" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">构建所基于的构建器图像。</li></ul><p id="9b5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有许多受支持的和社区构建器映像，我将使用OpenJDK映像，因为，嗯，我正在构建一个Java应用程序！</p><p id="717b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以使用OpenShift开发人员控制台或命令行来启动S2I构建。我将使用new-app命令，指向构建器映像和我的源代码。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/290ca25a227474c91ce3f3678924d38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*krK7izENwTWqvNu-"/></div></div></figure><p id="7e7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">oc new-app registry . access . red hat . com/ubi 8/open JDK-11:最新~ https://github . com/gcolman/quar kus-hello-world . git</strong></p><p id="64e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，我的新应用就创建好了。S2I进程:</p><ul class=""><li id="df91" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">创建了一个构建pod来为构建应用程序做“事情”</li><li id="f411" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">创建了OpenShift构建配置</li><li id="4f81" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">将构建器映像放入OpenShift的内部docker注册表中。</li><li id="f0f2" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">在本地克隆了“Hello World”repo</li><li id="286c" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">看到有一个maven pom，所以用maven编译了应用程序</li><li id="b007" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">用编译后的java应用程序创建了一个新的容器映像，并将这个容器映像推入内部容器注册中心</li><li id="4f93" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">使用pod规范、服务规范等创建了Kubernetes部署。</li><li id="5876" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">开始部署容器映像。</li><li id="62f9" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">移除了构建窗格。</li></ul><p id="ae62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是很多东西，但要注意的关键是:所有的构建都发生在OpenShift内部，OpenShift内部有一个Docker注册中心，这个过程创建所有的Kubernetes组件并在集群中运行它们。</p><p id="be4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我在运行S2I时查看控制台，我会看到一个构建窗格开始运行构建。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/0c25e944c09b856911812fa751406022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x_YE8DmQDMMd8DdO"/></div></div></figure><p id="1459" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一下构建器pod日志，看看发生了什么。我能看到的第一件事是maven在做它的事情，为我的java构建引入依赖项。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/c7a43f61ee9788fa2de56e6d7f4b9e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QkmoSBh1d_mR-Ogm"/></div></div></figure><p id="a75e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦maven构建完成，我可以看到容器映像构建正在进行，并最终将构建好的容器映像推入内部repo。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/75c472b4062df8412f3a609864c0b875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ta73RFBq4rUMNYJq"/></div></div></figure><p id="c4d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建已完成！如果我查看我的群集，我会看到我的应用程序和服务正在运行！</p><p id="f566" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">oc获取服务</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/7c8a4aa590fd6eed6cb7d5a303290701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yU_JpuUd81jMh0jk"/></div></div></figure><p id="9289" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。一个命令。我需要做的另一件事是向外界公开服务。</p><p id="da10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第三步——向外界公开服务</strong></p><p id="33cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与AKP的例子一样，我的open shift“Hello World”需要一个路由器将外部流量定向到集群中我的服务。OpenShift使这变得非常容易，不仅集群默认安装了HAProxy路由器组件(虽然这可以与NGINX之类的东西交换)，它还拥有自定义资源来配置被调用的路由，这类似于plain old中的Ingress对象。Kubernetes(事实上OpenShift路由极大地影响了Ingress设计，您可以在OpenShift中使用Ingress对象)，但是对于我们的“Hello World”和OpenShift中的几乎所有其他用例，我们将只使用路由。</p><p id="473f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要为“Hello World”创建可路由的FQDN(是的，OpenShiift有DNS来创建和路由服务),我们只需公开服务:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/8b80199bce5548ec3f39165db19767c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N2BrL6DfnpCJjngO"/></div></div></figure><p id="e75c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> oc暴露服务quarkus-hello-world </strong></p><p id="81ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我看一看创建的路线，我可以看到FQDN和其他路线的详细信息:</p><p id="a2be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> oc获取路线</strong></p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/f05a06c86e8d17bb0e7decec76f39e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I0robHs5gRNSGOye"/></div></div></figure><p id="8f13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，从浏览器调用服务:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/a0577aa517ad892ff919c94f0478daa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_6sXXeDZc5IgOp7B"/></div></div></figure><h2 id="e2a8" class="mm kz iq bd la mn mo dn le mp mq dp li kj mr ms lm kn mt mu lq kr mv mw lu mx bi translated">完成了。这很容易！</h2><p id="8b81" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我喜欢Kubernetes和技术带来的一切，我也喜欢简单。现在，Kubernetes被设计来使分布式的、可伸缩的容器变得非常简单，但是仍然不够简单，不能快速启动和运行。这就是OpenShift站出来为Kubernetes提供开发人员的地方。为了使OpenShift成为一个开发者友好的平台，已经投入了大量的精力，比如；S2I，ODI，开发者门户，OpenShift操作框架，IDE集成，开发者目录，Helm集成，监控，…</p><p id="b8fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你觉得这篇博文有趣并且有用。看看<a class="ae kw" href="https://developers.redhat.com/" rel="noopener ugc nofollow" target="_blank"> Red Hat Developers </a>用OpenShift为开发者找到大量的资源、内容和满足感。</p></div></div>    
</body>
</html>