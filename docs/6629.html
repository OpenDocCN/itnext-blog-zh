<html>
<head>
<title>Lazy Evaluation in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的惰性求值</h1>
<blockquote>原文：<a href="https://itnext.io/lazy-evaluation-in-javascript-62b8ec45e0f6?source=collection_archive---------1-----------------------#2022-01-10">https://itnext.io/lazy-evaluation-in-javascript-62b8ec45e0f6?source=collection_archive---------1-----------------------#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2b7da81fcc2f1c56942f8e5ac5e8427d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Ih6h1cc78tM0pU1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@madhatterzone?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Manja Vitolic </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e884" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在编程语言设计中，要做的许多架构决策之一涉及到语言应该如何评估它的表达式。它应该在代码中声明它们的时候对它们进行全面评估吗？还是应该将这种评估延迟到实际需要这些值的时间点(<em class="lb">例如</em>，打印到控制台或写入数据库)？</p><p id="b628" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这组问题的两个主要答案是设计一种严格或非严格的语言。严格求值意味着当表达式到达时，它的值就被确定了，而不管这个值何时(甚至是否)会被使用。因此<code class="fe lc ld le lf b">3 + 5</code>总是立即减少到<code class="fe lc ld le lf b">8</code>。而非严格，则相反。只有当代码中确实需要表达式的值时，它才会减少<code class="fe lc ld le lf b">3 + 5</code>,并将加法运算延迟到那个时候。通常我们使用各自的术语“渴望”和“懒惰”来给这些评估策略取通俗的名字。</p><p id="99d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数编程语言(包括JavaScript)都倾向于渴望。这意味着如果我们调用一个函数<code class="fe lc ld le lf b">sequence</code>定义为</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="d8c5" class="lo lp iq lf b gy lq lr l ls lt">const sequence = (l, u) =&gt;<br/>    Array(u - l + 1)<br/>        .fill(0)<br/>        .map((_, idx) =&gt; l + idx);</span></pre><p id="5b88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它在<code class="fe lc ld le lf b">l</code>和<code class="fe lc ld le lf b">u</code>之间创建一个整数数组，然后将每个数字映射到它的平方</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="bea8" class="lo lp iq lf b gy lq lr l ls lt">const squares = sequence(1, 5).map(x =&gt; x ** 2);</span></pre><p id="dcb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在映射数组中的每个值之前，我们的语言将全面评估<code class="fe lc ld le lf b">sequence(1, 5)</code>。然后，我们剩下一个数组<code class="fe lc ld le lf b">squares</code>，在我们继续下一行代码之前，它已经被完全评估过了。</p><p id="e459" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在eager语言中，当使用具有复杂操作的大型数据结构时，我们应该小心。如果要执行昂贵的计算，需要多次遍历数组，并且必须分配和释放大量内存来支持所有这些操作，那么映射数千个数组项会使程序的性能下降。如果所有的工作都完成了，而程序只需要其中的几个值(如果有的话),这是非常浪费的。</p><p id="6ac7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，有很多方法可以缓解这些问题。人们可以通过使用<a class="ae kc" href="https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d" rel="noopener">换能器</a>将大型阵列中的多次迭代减少到一次。人们可以操纵控制流，以防止在程序的生命周期中过早地评估许多昂贵的计算。或者可以使用突变来就地改变数组，而不是为任何操作创建新的副本。这些都没有回避这样一个事实，即在某个时刻，程序会到达这样一个表达式，并在继续下一条指令之前对其进行充分评估。</p><p id="fe5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非严格语言没有这些限制。通过推迟到必须评估一个值的最后一分钟，以及采取只评估必要的值的方法，许多有趣的特性成为语言中的一等公民。为了说明这些，我们将使用Haskell，一种最著名的惰性语言。</p><p id="3bc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Haskell中，创建无限列表很简单:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="1569" class="lo lp iq lf b gy lq lr l ls lt">infiniteList = [1..]</span></pre><p id="1820" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们永远不能用一种热切的语言来创建它，因为无限列表在被绑定到一个变量之前必须被完全评估，这将导致环境在计算列表中的下一个数字时挂起(直到它耗尽内存并崩溃)。</p><p id="5474" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是真正强大的是，我们可以在这个无限列表上执行许多操作，而不需要立即对它们进行评估。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="19ed" class="lo lp iq lf b gy lq lr l ls lt">-- Filter out odds<br/>infiniteEvens = filter even infiniteList</span><span id="b8ae" class="lo lp iq lf b gy lu lr l ls lt">-- Add 5 to each item<br/>infiniteEvensPlus5 = map (+ 5) infiniteEvens</span></pre><p id="a7be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，我们可能想要获取这个列表的一部分，以便可以在控制台中显示它:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="bdf8" class="lo lp iq lf b gy lq lr l ls lt">first5Elements = take 5 infiniteEvensPlus5<br/>show first5Elements -- "[7,9,11,13,15]"</span></pre><p id="bb94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管我们创建了一个无限列表，指定了一个过滤器，然后在该列表上指定了一个映射操作，并对其中的五个元素进行了强制求值，但是我们的操作没有一个遍历了该列表的整个长度——它们只是尽可能地对列表中的前五个元素进行求值。然而，列表的其余部分还没有被评估，等待着需要列表的另一部分的东西出现。</p><h1 id="bbe2" class="lv lp iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">JavaScript中的惰性求值</h1><p id="2e6a" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">随着JavaScript成为一种渴望的语言，我们可以问这样一个问题，我们是否可以以某种方式达到我们在Haskell中看到的相同效果。我们希望能够创建一个(潜在的)无限的数据结构，并在其上指定除非绝对必要否则不会执行的操作。</p><p id="f5d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前JavaScript中没有内置的数据结构适合这个目的。数组、对象、集合、地图、<em class="lb">等。</em>，都是由严格评价的必然性所限定的。为了避开这种严格性，我们需要创建我们自己的数据结构，这样它就不仅仅是简单地<em class="lb">存储</em>值(比如上面所做的),而且还有一种方式<em class="lb">根据需要任意程度地生成</em>值。</p><p id="d3e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，JavaScript自带了一个机制来实现这一点，这将作为我们惰性数据结构的基础:<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank">生成器函数</a>。</p><p id="0af0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我们不会深入解释生成器函数(或它们返回的值)，但我们会注意到，这些函数与常规函数不同，常规函数可以返回任何值，而生成器函数则返回一个特殊的生成器对象。该对象允许控制程序在需要时执行生成器函数体中定义的代码，并且该代码甚至可以在执行过程中在指定的断点处暂停，它可以在将来某个不确定的时间(如果有的话)从该断点恢复执行。正是暂停能力的这一特性，我们将利用它来实现懒惰。</p><h2 id="faae" class="lo lp iq bd lw mx my dn ma mz na dp me ko nb nc mi ks nd ne mm kw nf ng mq nh bi translated">惰性序列</h2><p id="7327" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">虽然生成器将用于数据结构本身，但它们也非常适合表示我们的惰性列表的基本构建块:一个惰性的无限数字序列。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="a346" class="lo lp iq lf b gy lq lr l ls lt">const range = (l, u = Infinity) =&gt; function* () {<br/>    while (true) {<br/>        if (l &lt; u) {<br/>            yield l++;<br/>            continue;<br/>        }</span><span id="9293" class="lo lp iq lf b gy lu lr l ls lt">        return l;<br/>    }<br/>};</span></pre><p id="3355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<code class="fe lc ld le lf b">range</code>函数的构造将为我们如何设计我们的列表打下基础。首先，应该注意它返回一个生成器函数。这将是贯穿始终的一个共同主题——包装懒惰总是涉及到创建生成器函数，懒惰的消费者可以在下游利用这些函数。第二，惰性序列不必是无限的，所以我们需要列出当我们的惰性列表执行它的一些操作时，由生成器对象产生的值是已经被<code class="fe lc ld le lf b">return</code>处理还是仅仅被<code class="fe lc ld le lf b">yield</code>处理</p><h2 id="762b" class="lo lp iq bd lw mx my dn ma mz na dp me ko nb nc mi ks nd ne mm kw nf ng mq nh bi translated">懒惰列表</h2><p id="645a" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">使用我们上面的Haskell代码作为灵感，我们希望能够有一个列表，我们可以映射，过滤，切片，<em class="lb">等。</em>，但是服从某一组约束。</p><p id="a35f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，除非绝对必要，否则我们不想执行任何操作。因此，尽管<code class="fe lc ld le lf b">Array.prototype.map</code>会立即用新值创建一个新数组，但我们只希望我们的列表的map操作只在我们需要从列表中获取值时运行。第二，我们只想尽可能多地评估列表以获得我们的价值，仅此而已；如果我们想得到列表的第三个值，我们必须创建第一个和第二个值，但绝对不能创建第四个值。第三，我们不希望在同一个列表上多次执行相同的操作，所以我们应该缓存构建的任何值。</p><p id="2160" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构建动作方面，我们将采用基于类的方法，这样我们就可以将Haskell操作写成</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="aac9" class="lo lp iq lf b gy lq lr l ls lt">lazyList<br/>    .filter(n =&gt; (n % 2) === 0)<br/>    .map(n =&gt; n + 5)<br/>    .take(5);</span></pre><p id="75a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由此，我们可以通过从列表中获取，来强制评估这五个值中的任何一个。</p><p id="ed33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们类的框架将会是这样的:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="0470" class="lo lp iq lf b gy lq lr l ls lt">class LazyList {<br/>    #generator;<br/>    #generatedValues = [];<br/>    #done = false;</span><span id="1b9e" class="lo lp iq lf b gy lu lr l ls lt">    constructor(generatorFn) {<br/>        this.#generator = generatorFn();<br/>    }</span><span id="4ba4" class="lo lp iq lf b gy lu lr l ls lt">    get(n) {}</span><span id="437b" class="lo lp iq lf b gy lu lr l ls lt">    take(n) {}</span><span id="525c" class="lo lp iq lf b gy lu lr l ls lt">    map(fn) {}</span><span id="267c" class="lo lp iq lf b gy lu lr l ls lt">    filter(fn) {}<br/>}</span></pre><p id="8a25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将有三个私有属性:</p><ul class=""><li id="b27e" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated"><code class="fe lc ld le lf b">#generator</code>保存表示要创建的序列的生成器对象，该对象最终将从我们上面创建的惰性<code class="fe lc ld le lf b">range</code>序列中派生出来</li><li id="5348" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><code class="fe lc ld le lf b">#generatedValues</code>是一个已经计算过的值的缓存，所以如果我们从一个列表中得到第十个值，我们将把它存储在这个数组中，这样我们就可以在以后的任意次数中获取它，而无需重新计算</li><li id="ac0b" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><code class="fe lc ld le lf b">#done</code>将跟踪我们的生成器对象是否已经完成；稍后我们将看到为什么这是一个必要的属性</li></ul><p id="da04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe lc ld le lf b">get</code>方法将是列表中唯一强制评估值的方法——否则我们无法获得第一个、第二个或第<code class="fe lc ld le lf b">n</code>个值。它将从<code class="fe lc ld le lf b">#generatedValues</code>数组中获取数据，因此它的部分操作是将数组填充到传递给它的任何参数<code class="fe lc ld le lf b">n</code>中。</p><p id="cf05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创造<code class="fe lc ld le lf b">get</code>:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="ef8e" class="lo lp iq lf b gy lq lr l ls lt">class LazyList {<br/>    #generator;<br/>    #generatedValues = [];<br/>    #done = false;</span><span id="9d6d" class="lo lp iq lf b gy lu lr l ls lt">    constructor(generatorFn) {<br/>        this.#generator = generatorFn();<br/>    }</span><span id="6b60" class="lo lp iq lf b gy lu lr l ls lt">    #next() {<br/>        const { value, done } = this.#generator.next();</span><span id="3d6f" class="lo lp iq lf b gy lu lr l ls lt">        if (done) {<br/>            this.#done = true;<br/>        }</span><span id="a5e6" class="lo lp iq lf b gy lu lr l ls lt">        if (value !== $SKIP) {<br/>            this.#generatedValues.push(value);<br/>        }<br/>    }</span><span id="a871" class="lo lp iq lf b gy lu lr l ls lt">    get(n) {<br/>        while (this.#generatedValues.length &lt;= n &amp;&amp; !this.#done) {<br/>            this.#next();<br/>        }</span><span id="041f" class="lo lp iq lf b gy lu lr l ls lt">        return this.#generatedValues[n];<br/>    }<br/>}</span></pre><p id="da9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，上面的<code class="fe lc ld le lf b">get</code>检查已经生成了多少个值，并生成任何缺失的值，直到第<code class="fe lc ld le lf b">n</code>个位置。如果底层生成器在到达该位置之前已经完成，它将提前中止，在这种情况下，它将返回<code class="fe lc ld le lf b">undefined</code>(因为我们要求的值超出了<code class="fe lc ld le lf b">#generatedValues</code>数组的界限)。</p><p id="600f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lc ld le lf b">get</code>使用的<code class="fe lc ld le lf b">#next</code>方法中，我们确保不将任何标记为<code class="fe lc ld le lf b">$SKIP</code>的值视为有效。很少有情况会产生这种情况，所以这是一种边缘情况。但是我们将在下面看到，如果没有它，我们可能会有意想不到的行为。</p><p id="e055" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的每一个懒惰方法<code class="fe lc ld le lf b">take</code>、<code class="fe lc ld le lf b">map</code>和<code class="fe lc ld le lf b">filter</code>，我们有两个逻辑要实现:获取/映射/过滤的实际操作，以及每个操作应该如何与<code class="fe lc ld le lf b">LazyList</code>类交互。</p><p id="5162" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在操作方面，为了保持惰性，我们希望创建接受生成器并返回执行所需操作的生成器的函数。这些人都不需要知道<em class="lb">他们正在接收什么</em>生成器，尽管他们确实需要尊重那个生成器指定的<code class="fe lc ld le lf b">done</code>属性。由于这些函数的操作没有外部环境，所以我们的三种方法的所有逻辑都可以提取为效用函数。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="162e" class="lo lp iq lf b gy lq lr l ls lt">const take = (n) =&gt; (generator) =&gt; function* () {<br/>    while (n-- &gt; 0) {<br/>        const { value, done } = generator.next();</span><span id="8fe5" class="lo lp iq lf b gy lu lr l ls lt">        if (done) {<br/>            return value;<br/>        }</span><span id="a700" class="lo lp iq lf b gy lu lr l ls lt">        yield value;<br/>    }<br/>};</span></pre><p id="14dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，我们对<code class="fe lc ld le lf b">generator</code>参数的值循环<code class="fe lc ld le lf b">n</code>次，然后将它们丢弃。我们必须注意它是否已经完成(因为我们不知道它是否创建了一个有限或无限的序列),并且同样通过选择<code class="fe lc ld le lf b">return</code>或<code class="fe lc ld le lf b">yield</code>来传递信息。</p><p id="a943" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">映射和过滤是相似的。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="8c70" class="lo lp iq lf b gy lq lr l ls lt">const map = (fn) =&gt; (generator) =&gt; function* () {<br/>    while (true) {<br/>        const { value, done } = generator.next();</span><span id="a2a0" class="lo lp iq lf b gy lu lr l ls lt">        if (done) {<br/>            return fn(value);<br/>        }</span><span id="910f" class="lo lp iq lf b gy lu lr l ls lt">        yield fn(value);<br/>    }<br/>};</span><span id="261f" class="lo lp iq lf b gy lu lr l ls lt">const $SKIP = Symbol('skip');</span><span id="c187" class="lo lp iq lf b gy lu lr l ls lt">const filter = (fn) =&gt; (generator) =&gt; function* () {<br/>    while (true) {<br/>        const { value, done } = generator.next();</span><span id="ee91" class="lo lp iq lf b gy lu lr l ls lt">        if (done &amp;&amp; fn(value)) {<br/>            return value;<br/>        }</span><span id="81e9" class="lo lp iq lf b gy lu lr l ls lt">        if (done &amp;&amp; !fn(value)) {<br/>            return $SKIP;<br/>        }</span><span id="b9a7" class="lo lp iq lf b gy lu lr l ls lt">        if (!fn(value)) {<br/>            continue;<br/>        }</span><span id="96d3" class="lo lp iq lf b gy lu lr l ls lt">        yield value;<br/>    }<br/>};</span></pre><p id="db45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到我们的过滤函数利用了前面介绍的<code class="fe lc ld le lf b">$SKIP</code>值。原因如下。通过过滤，我们的谓词函数(<code class="fe lc ld le lf b">fn</code>)决定了<code class="fe lc ld le lf b">generator</code>给出的值应该被产生还是被丢弃。如果<code class="fe lc ld le lf b">fn</code>返回<code class="fe lc ld le lf b">false</code>，我们希望继续遍历生成器的值，直到它返回<code class="fe lc ld le lf b">true</code>为止。如果由于某种原因，我们的生成器完成了(因为它是有限的)，我们仍然需要检查那个最终值，看看它是否应该被传递。最好的情况是它应该是，我们可以简单地<code class="fe lc ld le lf b">return</code>这个值。然而，有时它应该<em class="lb">而不是</em>被传递(例如过滤掉范围<code class="fe lc ld le lf b">[1, 3]</code>中的奇数值，其中<code class="fe lc ld le lf b">3</code>是最终值并且也是奇数值，不应该被返回)。在这种情况下，我们仍然需要给<em class="lb">一些东西</em>，所以我们返回一个特殊的符号<code class="fe lc ld le lf b">$SKIP</code>，下游处理会考虑这个符号。</p><p id="d143" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成这三个操作的纯实现后，他们现在需要与<code class="fe lc ld le lf b">LazyList</code>类交互。概括来说，我们将执行以下步骤:</p><ul class=""><li id="4eea" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated">将类打包成一个生成器函数</li><li id="28d7" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">将该生成器函数提供给适当的实用函数</li><li id="9adf" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">将实用程序返回的生成器函数输入到新的<code class="fe lc ld le lf b">LazyList</code>实例中。</li></ul><p id="0121" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当将类实例转换为生成器时，请记住，我们需要考虑已经生成的值，并在可用时使用这些值，并且只生成我们必须生成的新值。</p><p id="5f19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在我们的类中添加一个新的实用方法，将其重新打包为一个生成器函数。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="4ecd" class="lo lp iq lf b gy lq lr l ls lt">class LazyList {<br/>    #generator;<br/>    #generatedValues = [];<br/>    #done = false;</span><span id="39d9" class="lo lp iq lf b gy lu lr l ls lt">    constructor(generatorFn) {<br/>        this.#generator = generatorFn();<br/>    }</span><span id="2dae" class="lo lp iq lf b gy lu lr l ls lt">    #next() {<br/>        const { value, done } = this.#generator.next();</span><span id="8556" class="lo lp iq lf b gy lu lr l ls lt">        if (done) {<br/>            this.#done = true;<br/>        }</span><span id="6cdc" class="lo lp iq lf b gy lu lr l ls lt">        if (value !== $SKIP) {<br/>            this.#generatedValues.push(value);<br/>        }<br/>    }</span><span id="1fe5" class="lo lp iq lf b gy lu lr l ls lt">    #asGenerator() {<br/>        function* toGenerator() {<br/>            let cursor = 0;</span><span id="16ac" class="lo lp iq lf b gy lu lr l ls lt">            while (true) {<br/>                if (!Reflect.has(this.#generatedValues, cursor)) {<br/>                    this.#next();<br/>                }</span><span id="96ad" class="lo lp iq lf b gy lu lr l ls lt">                if (this.#done) {<br/>                    return this.#generatedValues[cursor++];<br/>                }<br/>                <br/>                yield this.#generatedValues[cursor++];<br/>            }<br/>        }</span><span id="9568" class="lo lp iq lf b gy lu lr l ls lt">        return toGenerator.apply(this);<br/>    }<br/>}</span></pre><p id="ab92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个名为<code class="fe lc ld le lf b">toGenerator</code>的新生成器函数，它将<code class="fe lc ld le lf b">yield</code>当前惰性列表类的每个值(在需要时通过调用<code class="fe lc ld le lf b">#next</code>来生成它)，直到底层生成器用完为止。当然，如果我们正在生成一个像fibonacci数一样的无限序列，我们将永远不会耗尽生成器，所以这将是我们的懒惰实现是否工作的真正测试:如果它挂起，我们将尝试评估整个底层列表，而不仅仅是我们下一个操作的本质。</p><p id="400f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对类实例本身执行<code class="fe lc ld le lf b">apply</code>这个生成器函数，以便它在访问它的一些私有属性时有正确的<code class="fe lc ld le lf b">this</code>上下文。</p><p id="9255" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果方法本身是简单的单行实现。整个班级都会</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="be76" class="lo lp iq lf b gy lq lr l ls lt">class LazyList {<br/>    #generator;<br/>    #generatedValues = [];<br/>    #done = false;</span><span id="633a" class="lo lp iq lf b gy lu lr l ls lt">    constructor(generatorFn) {<br/>        this.#generator = generatorFn();<br/>    }</span><span id="1a0e" class="lo lp iq lf b gy lu lr l ls lt">    #next() {<br/>        const { value, done } = this.#generator.next();</span><span id="839a" class="lo lp iq lf b gy lu lr l ls lt">        if (done) {<br/>            this.#done = true;<br/>        }</span><span id="dc41" class="lo lp iq lf b gy lu lr l ls lt">        if (value !== $SKIP) {<br/>            this.#generatedValues.push(value);<br/>        }<br/>    }</span><span id="e496" class="lo lp iq lf b gy lu lr l ls lt">    #asGenerator() {<br/>        function* toGenerator() {<br/>            let cursor = 0;</span><span id="f7ac" class="lo lp iq lf b gy lu lr l ls lt">            while (true) {<br/>                if (!Reflect.has(this.#generatedValues, cursor)) {<br/>                    this.#next();<br/>                }</span><span id="dcc6" class="lo lp iq lf b gy lu lr l ls lt">                if (this.#done) {<br/>                    return this.#generatedValues[cursor++];<br/>                }<br/>                <br/>                yield this.#generatedValues[cursor++];<br/>            }<br/>        }</span><span id="f039" class="lo lp iq lf b gy lu lr l ls lt">        return toGenerator.apply(this);<br/>    }</span><span id="7c30" class="lo lp iq lf b gy lu lr l ls lt">    get(n) {<br/>        while (this.#generatedValues.length &lt;= n &amp;&amp; !this.#done) {<br/>            this.#next();<br/>        }</span><span id="bd20" class="lo lp iq lf b gy lu lr l ls lt">        return this.#generatedValues[n];<br/>    }</span><span id="56e6" class="lo lp iq lf b gy lu lr l ls lt">    take(n) {<br/>        const generator = take(n)(this.#asGenerator());<br/>        return new LazyList(generator);<br/>    }</span><span id="bb00" class="lo lp iq lf b gy lu lr l ls lt">    map(fn) {<br/>        const generator = map(fn)(this.#asGenerator());<br/>        return new LazyList(generator);<br/>    }</span><span id="a3cd" class="lo lp iq lf b gy lu lr l ls lt">    filter(fn) {<br/>        const generator = filter(fn)(this.#asGenerator());<br/>        return new LazyList(generator);<br/>    }<br/>}</span></pre><h2 id="c0a1" class="lo lp iq bd lw mx my dn ma mz na dp me ko nb nc mi ks nd ne mm kw nf ng mq nh bi translated">测试懒惰列表</h2><p id="00e5" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">现在我们有了懒惰生成的列表，我们应该测试我们的主要目标是否已经达到。记住我们的三个目标是:</p><ul class=""><li id="7195" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated">除非绝对必要，否则不做评估</li><li id="29a7" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">没有多余的评估</li><li id="4343" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">没有值会被评估一次以上</li></ul><p id="fbcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试这一点，我们将在相关的函数和方法中添加控制台日志，并记录这些控制台日志的执行时间。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="e927" class="lo lp iq lf b gy lq lr l ls lt">const plus1 = (n) =&gt; {<br/>    console.log('Adding one to', n);<br/>    return n + 1;<br/>};</span><span id="2784" class="lo lp iq lf b gy lu lr l ls lt">const oneToFive = new LazyList(range(1, 5));<br/>const oneToFivePlus1 = oneToFive.map(plus1);</span><span id="12e9" class="lo lp iq lf b gy lu lr l ls lt">// No console logging yet.</span><span id="989b" class="lo lp iq lf b gy lu lr l ls lt">oneToFivePlus1.get(0);</span><span id="edba" class="lo lp iq lf b gy lu lr l ls lt">// log: 'Adding one to 1'</span><span id="98c3" class="lo lp iq lf b gy lu lr l ls lt">oneToFivePlus1.get(0);</span><span id="7b52" class="lo lp iq lf b gy lu lr l ls lt">// No console log</span><span id="5c2a" class="lo lp iq lf b gy lu lr l ls lt">oneToFivePlus1.get(2);</span><span id="5dbb" class="lo lp iq lf b gy lu lr l ls lt">// log: 'Adding one to 2'<br/>// log: 'Adding one to 3'</span></pre><p id="2b7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这段摘录中我们可以看到，我们的三个条件都得到了满足。在我们的素数序列上的映射不执行任何直接的计算。获得序列中的第<code class="fe lc ld le lf b">0</code>项仅触发了一次评估。并且获取第<code class="fe lc ld le lf b">0</code>和第<code class="fe lc ld le lf b">2</code>项时，除了各自的位置之外，不会评估任何东西。</p><p id="a3b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以建立更复杂的操作。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="a423" class="lo lp iq lf b gy lq lr l ls lt">const notDivisibleBy3 = new LazyList(range(1))<br/>    .map(n =&gt; {<br/>        console.log('Adding one to', n);<br/>        return n + 1;<br/>    })<br/>    .filter(n =&gt; {<br/>        console.log('Evaluating', n);<br/>        return (n % 3) !== 0;<br/>    })<br/>    .take(5);</span><span id="12f2" class="lo lp iq lf b gy lu lr l ls lt">notDivisibleBy3.get(0); // 2</span><span id="b046" class="lo lp iq lf b gy lu lr l ls lt">// log: 'Adding one to 1'<br/>// log: 'Evaluating 2'</span><span id="a6fb" class="lo lp iq lf b gy lu lr l ls lt">notDivisibleBy3.get(0); // 2</span><span id="1e8e" class="lo lp iq lf b gy lu lr l ls lt">// No console log</span><span id="3c3d" class="lo lp iq lf b gy lu lr l ls lt">notDivisibleBy3.get(2); // 5</span><span id="eb2f" class="lo lp iq lf b gy lu lr l ls lt">// log: 'Adding one to 2'<br/>// log: 'Evaluating 3'<br/>// log: 'Adding one to 3'<br/>// log: 'Evaluating 4'<br/>// log: 'Adding one to 4'<br/>// log: 'Evaluating 5'</span><span id="7ff7" class="lo lp iq lf b gy lu lr l ls lt">notDivisibleBy3.get(5); // undefined</span><span id="7b4e" class="lo lp iq lf b gy lu lr l ls lt">// Similar console logs as above but for numbers 5 - 8</span></pre><p id="2381" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，当我们得到不能被3整除的序列的第<code class="fe lc ld le lf b">2</code>个元素时，我们做了三次评估。其中一个数字<em class="lb">可被3整除，因此我们将其作为无效序列丢弃，并生成两个适当的值(4和5)。</em></p><h2 id="f8f4" class="lo lp iq bd lw mx my dn ma mz na dp me ko nb nc mi ks nd ne mm kw nf ng mq nh bi translated">关于懒惰名单的思考</h2><p id="2ded" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">从我们的惰性列表数据结构可以看出，我们可以定义相当有效的管道，允许我们在无休止的输入流上创建复杂的操作系统。通过缓存评估值，并且每次只处理我们需要的量，我们可以在相当昂贵的操作上获得相当好的性能。</p><p id="e38e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管我们已经实现了所有这些好处，但值得注意的是，最终我们并没有真正的懒惰评估(撇开命名不谈)。我们可以称我们的列表为“懒惰的”,但是在每个操作的每一步，运行时已经完全评估了每个表达式。只是那个运行时也有一些特定的构造，这些构造模拟了延迟求值的编程语言的某些特性。不幸的是，因为评估策略是语言的基本方面，懒惰不是JavaScript的首要元素，所以模拟懒惰与懒惰不是一回事。我们仍然必须编写在适当的时候调用评估的代码，因为运行时本身没有执行评估的内置概念。</p><p id="a021" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着Haskell可以做的非常符合人体工程学的事情，我们只能通过变通办法和额外的实现代码以及增加的复杂性来做(当同时执行多个操作时，我们的懒惰列表必须使用的生成器函数层会变得非常复杂)。</p><p id="2174" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我们只能粗略地估计Haskell能做的事情，但我们在JavaScript中拥有这样的特性仍然是一件好事。能够定义一组只对少量值调用(或者根本不调用)的昂贵的操作，仍然为运行时引擎执行其他重要任务节省了宝贵的时间。</p><p id="7c74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列表也只是我们可以惰性生成的许多东西中的一种。我们可以扩展我们的代码来生成无限的树或分形，甚至是近似的可计算的实数，只要我们可以为我们试图生成的任何东西编码“下一次迭代”的概念。</p><p id="ed89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是我们为惰性列表生成的代码的<a class="ae kc" href="https://gist.github.com/ryandabler/f4f19256183bec068bcb4e2094678f5f" rel="noopener ugc nofollow" target="_blank">要点</a>，以及一些在Haskell等语言中常见的列表操作方法，我们没有时间在本文中开发。</p></div></div>    
</body>
</html>