<html>
<head>
<title>Master environment variables on Node.js with dotenv-expand</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用dotenv-expand控制Node.js上的环境变量</h1>
<blockquote>原文：<a href="https://itnext.io/master-environment-variables-on-node-js-with-dotenv-expand-f9724b310bc7?source=collection_archive---------0-----------------------#2020-08-19">https://itnext.io/master-environment-variables-on-node-js-with-dotenv-expand-f9724b310bc7?source=collection_archive---------0-----------------------#2020-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/788f542161efbf1270e946dbffe9e4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OYpQsh-ZpqjEWntS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯汀娜面粉在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="67eb" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="5af1" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">作为开发人员，我们发现自己经常处于这样的情况:我们不仅需要保护某些数据或变量免受潜在的攻击，还需要保护它们免受用户的攻击。当开发一个移动应用程序、一个web平台、甚至一个单页面应用程序时，我们使用不同的库或第三方服务(例如用于定位的谷歌地图、用于登录的脸书或谷歌，等等)，以及API凭证(在我们自己的服务器或外部服务器上)，和用于远程连接的SSH-keys。综合来说，我们说的是敏感信息。</p><p id="eb35" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为了保证代码的安全，我们可以将代码存放在不同的存储库中，比如最常用的GitHub、GitLab和Bitbucket。最近科技巨头微软对Github的<a class="ae kf" href="https://blogs.microsoft.com/blog/2018/10/26/microsoft-completes-github-acquisition/" rel="noopener ugc nofollow" target="_blank">收购，使得大多数用户根据他们需要的功能和他们对每个平台的感受来评估他们正在使用的存储库。下图反映了提供商的实际份额:</a></p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/22bd041d3dc825d8fe8da874bdcd6889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cS27UR56icZTv804R9F1kQ.png"/></div></div></figure><h1 id="7d87" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是环境变量？</h1><p id="ded2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">环境变量是在描述您的环境的系统中定义的变量。大概你在编辑<strong class="lg iu"> ~/的时候已经用过这种变量了。bash_profile </strong>文件，或者当你做一个<strong class="lg iu">导出路径时。</strong>但这些变量都是系统层面的。我们可以在那里定义我们想要的所有变量，但是想象一下，有多个应用程序，它们有自己的环境变量，可能需要它们的不同工具，如Android Studio和Java开发工具包，甚至是您过去可能已经定义过的键和快捷键。</p><h2 id="93f3" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated">Node.js的解决方案</h2><p id="7c39" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">除了系统级别，Node.js还提供了一个现成的解决方案:dotenv。当Node.js流程在运行时启动时，它将通过创建一个对象(从现在开始为env)作为流程全局对象的属性，自动提供对所有现有环境变量的访问。</p><p id="e5e1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您可以在Node.js中键入以下命令来检查您的env变量:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="62b2" class="mm kh it mz b gy nd ne l nf ng">console.log(process.env);</span></pre><h2 id="0fb9" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated">. env文件的重要性</h2><p id="3e5a" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在我们的根文件夹中有一个. env文件不仅可以让我们更容易地管理变量。利用gitignore忽略将要上传到存储库的文件，我们可以隐藏我们的。env文件只在本地可用，所以它不会出现在您的存储库中。</p><p id="633d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">假设我们正在开发一个Node.js项目，该项目包含一个MongoDB数据库连接查询，通常如下所示:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="34e3" class="mm kh it mz b gy nd ne l nf ng">db.mongoose<br/>.connect(`mongodb://<strong class="mz iu">username</strong>:<strong class="mz iu">password</strong>@<strong class="mz iu">localhost</strong>:<strong class="mz iu">27017</strong>/<strong class="mz iu">my-mongodb-server</strong>`, {<br/> useNewUrlParser: true,<br/> useUnifiedTopology: true,<br/> useCreateIndex: true,<br/> useFindAndModify: true<br/> })</span></pre><p id="9ff7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在本例中，我们公开了我们的用户名、密码、主机及其相应的端口和数据库名称。一个人远程连接到我们的数据库并访问我们的信息所需的所有信息。</p><p id="c51e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">建议的解决方案是将所有信息转移到我们的隐藏文件中，格式为<strong class="lg iu"> key=value </strong>。约定是大写键，值应该是字符串。在您的项目根文件夹中创建(或者修改现有的)一个名为<strong class="lg iu">的文件。env </strong>，内容如下:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="58db" class="mm kh it mz b gy nd ne l nf ng">MONGODB_USERNAME=testuser<br/>MONGODB_PASSWORD=testpassword<br/>MONGODB_HOST=localhost<br/>MONGODB_PORT=27017<br/>MONGODB_SERVERNAME=my-mongodb-server</span></pre><p id="9499" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在，我们可以将代码更新为以下内容:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="7db3" class="mm kh it mz b gy nd ne l nf ng">db.mongoose<br/>.connect(`mongodb://${<strong class="mz iu">process.env.MONGODB_USERNAME}</strong>:${<strong class="mz iu">process.env.MONGODB_PASSWORD}</strong>@${<strong class="mz iu">process.env.MONGODB_HOST}</strong>:${<strong class="mz iu">process.env.MONGODB_PORT}</strong>/${<strong class="mz iu">process.env.MONGODB_SERVERNAME}</strong>`, {<br/> useNewUrlParser: true,<br/> useUnifiedTopology: true,<br/> useCreateIndex: true,<br/> useFindAndModify: true<br/> })</span></pre><p id="61c4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果我们正确地添加到。gitignore文件为<strong class="lg iu">的异常。env </strong>文件，这个文件不会被推送到我们的存储库，所以如果任何人有机会访问我们的代码，敏感信息将不会出现在代码中。请记住，我们的env文件只在我们的系统中可用。如果我们将代码推送到外部服务器，比如DigitalOcean或Amazon Web Services，我们也需要在那里创建env文件，以便被使用。</p><p id="4258" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">一个好的做法是在源代码存储库中创建并更新一个. sample-env文件(这个文件是提交和推送的)，这样您就可以跟踪您正在使用的变量。否则，您可能会多次阅读代码，以检查是否遗漏了一个变量。</p><p id="f9cc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">使用简单环境变量的另一个简单例子是设置Express.js应用程序的端口。我们检查我们的。env文件；如果没有定义端口，我们将默认值设置为3000:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="8c59" class="mm kh it mz b gy nd ne l nf ng">const PORT = process.env.PORT || 3000;<br/><br/>app.listen(PORT, () =&gt; {<br/>  console.log(`Listening on PORT: ${PORT}`);<br/>});</span></pre><p id="496e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">注意:这也可以通过执行我们的节点应用程序并在同一个命令中发送变量来实现:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="2314" class="mm kh it mz b gy nd ne l nf ng">PORT=3001 node server.js</span><span id="d69a" class="mm kh it mz b gy nh ne l nf ng"># for multiple env variables:<br/>PORT=3001 MONGODB_USERNAME=testuser node server.js</span></pre><p id="495b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">实际上，上述步骤是Node.js上环境变量的最简单用法。环境文件、加载失败等。出于这个原因，大多数开发人员选择使用Node.js 的<a class="ae kf" href="https://github.com/motdotla/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv工具。</a></p><h1 id="dd23" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是dotenv？</h1><p id="c04e" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Dotenv是一个零依赖模块，它基于<a class="ae kf" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">十二因素应用方法</a>将环境变量从. env文件加载到process.env中。它具有一些功能，如预加载、路径配置、编码等等。</p><p id="3865" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在新的或现有的项目中使用它就像用npm或yarn安装它一样简单:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="961b" class="mm kh it mz b gy nd ne l nf ng"># With NPM<br/>npm install dotenv</span><span id="b99c" class="mm kh it mz b gy nh ne l nf ng"># With Yarn<br/>yarn add dotenv</span></pre><h2 id="9c19" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated">简单用法</h2><p id="1612" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">正如12因素应用程序方法所建议的那样，我们应该将环境变量存储在应用程序的配置中，这些变量在不同的部署之间可能会有所不同，包括:</p><ul class=""><li id="e9e2" class="ni nj it lg b lh mc ll md lp nk lt nl lx nm mb nn no np nq bi translated">数据库、Memcached和其他后台服务的资源句柄</li><li id="bb73" class="ni nj it lg b lh nr ll ns lp nt lt nu lx nv mb nn no np nq bi translated">外部服务的凭证，如亚马逊S3或脸书</li><li id="5011" class="ni nj it lg b lh nr ll ns lp nt lt nu lx nv mb nn no np nq bi translated">每个部署的值，例如部署的规范主机名</li></ul><p id="4153" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">dotenv的简单用法是要求和配置Dotenv:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="2ab8" class="mm kh it mz b gy nd ne l nf ng">require('dotenv').config();</span></pre><p id="8209" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">使用建议的格式在项目的根目录下创建一个. env文件:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="132f" class="mm kh it mz b gy nd ne l nf ng">MY_VALUE=my-key</span></pre><p id="2ad2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们可以在Node.js中使用它:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="f140" class="mm kh it mz b gy nd ne l nf ng">console.log(process.env.MY_VALUE);</span></pre><h2 id="76b3" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated">预加载dotenv</h2><p id="3327" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">您可以使用—要求命令行选项来预加载dotenv。通过这样做，您不需要在应用程序代码中要求和加载dotenv:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="ff1d" class="mm kh it mz b gy nd ne l nf ng">node -r dotenv/config your_script.js</span></pre><h2 id="bde9" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated">利用配置功能</h2><p id="8650" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">config将读取您的。env文件，解析内容，将其分配给process.env，并返回一个对象，该对象带有包含加载内容的解析键，如果失败，则返回一个错误键。</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="2465" class="mm kh it mz b gy nd ne l nf ng">const result = dotenv.config()<br/><br/>if (result.error) {<br/>  throw result.error<br/>}<br/><br/>console.log(result.parsed)</span></pre><p id="8878" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">拥有一个<strong class="lg iu">配置</strong>的重要性在于我们可以额外传递它选项。我们可以设置自定义路径(选项#1)来指定文件定位时的自定义路径，我们可以指定编码(选项#2)或者我们可以打开日志来帮助调试(选项#3)以及其他功能。</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="12c9" class="mm kh it mz b gy nd ne l nf ng"># Option 1<br/>require('dotenv').config({ path: '/custom/path/to/.env' });</span><span id="038f" class="mm kh it mz b gy nh ne l nf ng"># Option 2<br/>require('dotenv').config({ encofing: 'latin1' });</span><span id="ff85" class="mm kh it mz b gy nh ne l nf ng"># Option 3<br/>require('dotenv').config({ debug: process.env.DEBUG });</span></pre><h1 id="fd76" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">使用dotenv-expand升级到全部功能</h1><p id="9075" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://github.com/motdotla/dotenv-expand" rel="noopener ugc nofollow" target="_blank"> Dotenv-expand </a>是一个NPM库，它在我们之前使用的Dotenv库的基础上增加了变量扩展。<br/>它允许我们使用动态字符串格式，能够使用如下所示的. env文件:</p><pre class="mi mj mk ml gt my mz na nb aw nc bi"><span id="61a1" class="mm kh it mz b gy nd ne l nf ng">MONGODB_USERNAME=testuser<br/>MONGODB_PASSWORD=testpassword<br/>MONGODB_HOST=localhost<br/>MONGODB_PORT=27017<br/>MONGODB_SERVERNAME=my-mongodb-server<br/>MONGODB_URI=mongodb://${MONGODB_USERNAME}:${MONGODB_PASSWORD}@${MONGODB_HOST}:${MONGODB_PORT}/${MONGODB_SERVERNAME}</span></pre><p id="0ec4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">正如我们所看到的，我们使用了用户名、密码、主机、端口和服务器名称变量来导出一个URI变量，将过去的字符串连接起来。这样我们可以增加复杂性和动态字符串。</p><h1 id="fe90" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="48e6" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">环境变量存在于应用程序代码之外，一旦Node.js进程启动，它们就可用了。它们可以用来将应用程序的配置从代码中分离出来，隐藏秘密的API密钥、用户名、密码和敏感数据，以及其他功能。当我们在私人项目以及协作环境(如work或开源项目)中工作时，如果您想避免与其他人共享您的数据库登录凭证或您的Github数据，这是很有帮助的。使用dotenv-expand，我们可以轻松地添加动态字符串，以充分利用dotenv的全部功能。这只是一个介绍性的教程，我们可以用dotenv实现的事情有几种方法，所以请随意使用这个库，看看它如何利用您的代码。</p></div></div>    
</body>
</html>