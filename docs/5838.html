<html>
<head>
<title>Creating a DB2 client container as Prometheus scraping target in K8s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在K8s中创建一个DB2客户机容器作为Prometheus抓取目标</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-db2-client-container-as-prometheus-scraping-target-in-k8s-b36e5cdbd394?source=collection_archive---------4-----------------------#2021-06-06">https://itnext.io/creating-a-db2-client-container-as-prometheus-scraping-target-in-k8s-b36e5cdbd394?source=collection_archive---------4-----------------------#2021-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ddd23014ca412f83062014049f4613da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d-_rR_grAGYWUY1b.jpg"/></div></div></figure><p id="f358" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我需要从DB2数据库中挖掘一些业务指标，并将其呈现在Grafana仪表板中。一种普罗米修斯刮靶即将研制出来。</p><p id="74fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大约3年前，我发表了一篇中型论文,通过使用DB2 ODBC/CLI驱动程序在Golang中运行DB2查询。接下来，让我们创建一个容器映像作为Prometheus抓取目标，并在Kubernetes中运行它。</p><h1 id="59c6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">作为抓取目标的应用程序</h1><p id="10f9" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">一些Golang代码摘录描述了数据收集的工作原理，</p><p id="6f04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据库和度量结构</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="9874" class="mm lb it mi b gy mn mo l mp mq">type MetricConfig struct {<br/> Name      string `yaml:"name"`<br/> Desc      string `yaml:"desc"`<br/> Sql       string `yaml:"sql"`<br/> Frequency string `yaml:"frequency"`<br/>}</span><span id="b81a" class="mm lb it mi b gy mr mo l mp mq">type DBMetricsConfig struct {<br/> Dsn      string         `yaml:"dsn,omitempty"`<br/> User     string         `yaml:"user,omitempty"`<br/> Password string         `yaml:"password,omitempty"`<br/> Metrics  []MetricConfig `yaml:"metrics,omitempty"`<br/>}</span></pre><p id="8dba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Dsn是DB2的ODBC数据源名称。公制是一种普罗米修斯规格。度量值将从返回单行和单列的SQL查询中设置。我们使用<a class="ae kz" href="https://github.com/bamzi/jobrunner" rel="noopener ugc nofollow" target="_blank"> jobrunner库</a>将数据收集作为cron作业运行。</p><p id="d005" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">初始化功能，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="fde9" class="mm lb it mi b gy mn mo l mp mq">func ScheduleDBMetricJob(mc DBMetricsConfig) error {<br/> user := os.Getenv(mc.User)<br/> password := os.Getenv(mc.Password)<br/> db, err := sqlx.Open("odbc", fmt.Sprintf("DSN=%s;uid=%s;pwd=%s", mc.Dsn, user, password))<br/> if err != nil {<br/>  logrus.Errorf("Error opening database: %v", err)<br/>  return err<br/> }</span><span id="7153" class="mm lb it mi b gy mr mo l mp mq"> db.SetMaxIdleConns(5)<br/> db.SetMaxOpenConns(5)</span><span id="1b73" class="mm lb it mi b gy mr mo l mp mq"> for _, met := range mc.Metrics {<br/>  gauge := prometheus.NewGauge(prometheus.GaugeOpts{<br/>   Namespace: "db2",<br/>   Subsystem: "mon",<br/>   Name:      met.Name,<br/>   Help:      met.Desc,<br/>  })<br/>  prometheus.MustRegister(gauge)<br/>  jobrunner.Schedule(fmt.Sprintf("<a class="ae kz" href="http://twitter.com/every" rel="noopener ugc nofollow" target="_blank">@every</a> %s", met.Frequency), DBMetricJob{<br/>   db:    db,<br/>   sql:   met.Sql,<br/>   gauge: gauge,<br/>  })<br/> }</span><span id="5082" class="mm lb it mi b gy mr mo l mp mq"> return nil<br/>}</span></pre><p id="9cb2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于有了<code class="fe ms mt mu mi b">sqlx</code>助手函数，下面显示的实际数据收集函数非常简单。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="ff3d" class="mm lb it mi b gy mn mo l mp mq">type DBMetricJob struct {<br/> db    *sqlx.DB<br/> sql   string<br/> gauge prometheus.Gauge<br/>}</span><span id="b9b3" class="mm lb it mi b gy mr mo l mp mq">func (job DBMetricJob) Run() {<br/> var i int</span><span id="4dc8" class="mm lb it mi b gy mr mo l mp mq"> err := job.db.Get(&amp;i, job.sql)<br/> if err != nil {<br/>  logrus.Errorf("failed to run sql:%v", err)<br/>  return<br/> }</span><span id="a91b" class="mm lb it mi b gy mr mo l mp mq"> job.gauge.Set(float64(i))<br/>}</span></pre><h1 id="7db6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">构建容器映像</h1><p id="eaaf" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">从IBM网站<a class="ae kz" href="https://www.ibm.com/support/pages/node/323035" rel="noopener ugc nofollow" target="_blank">获取DB2 ODBC/CLI驱动程序</a>。说我们有的是<code class="fe ms mt mu mi b">v11.5.5fp1_linuxx64_odbc_cli.tar.gz</code>的tar文件。</p><p id="582f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">构建图像的Dockerfile文件如下所示，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="bdb0" class="mm lb it mi b gy mn mo l mp mq">FROM golang as builder<br/>RUN apt update &amp;&amp; apt install -y unixodbc-dev<br/>WORKDIR /build<br/>COPY ./src /build<br/>RUN go build -o serving *.go</span><span id="a783" class="mm lb it mi b gy mr mo l mp mq">FROM ubuntu<br/>WORKDIR /app<br/>COPY --from=builder /build/serving /app<br/>ENTRYPOINT ["./serving"]</span><span id="0b05" class="mm lb it mi b gy mr mo l mp mq">ADD v11.5.5fp1_linuxx64_odbc_cli.tar.gz ./<br/>RUN apt update &amp;&amp; \<br/>    apt install -y curl unixodbc libxml2-dev libpam0g-dev &amp;&amp; \<br/>    rm -rf /var/lib/apt/lists/*</span><span id="72ac" class="mm lb it mi b gy mr mo l mp mq">ENV DB2_CLI_DRIVER_INSTALL_PATH /app/odbc_cli/clidriver<br/>ENV LD_LIBRARY_PATH /app/odbc_cli/clidriver/lib<br/>ENV LIBPATH /app/odbc_cli/clidriver/lib<br/>ENV DB2BINPATH /app/odbc_cli/clidriver/bin:/app/odbc_cli/clidriver/adm</span></pre><p id="7aef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个多阶段的容器构建。golang builder需要<code class="fe ms mt mu mi b">unixodbc-dev</code>库进行构建。由于ODBC库的依赖性，应用程序必须在不禁用CGO的情况下构建。因此不能使用Alpine base图像，因为它不提供glibc。</p><p id="04cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而是用Ubuntu作为app镜像库。添加编译好的app和下载的ODBC驱动。在Dockerfile中添加时，驱动程序tar文件会自动展开。安装DB2驱动程序的运行时依赖项，包括<code class="fe ms mt mu mi b">unixodbc, ibxml2-dev, libpam0g-dev</code></p><p id="4873" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如docker文件所示，最后一部分是DB2驱动程序的环境变量。如果需要，可以在容器中使用DB2BINPATH来设置路径。这些环境变量是静态的。</p><p id="c7bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有另外两个环境变量。<code class="fe ms mt mu mi b">ODBCINI</code>告诉ODBC驱动程序用户odbc.ini文件在哪里。<code class="fe ms mt mu mi b">DB2CLIINIPATH</code>告诉db2 CLI驱动程序cli ini文件的目录在哪里。当我们将应用程序部署到K8s中时，我们将动态地使用这两个环境变量。</p><p id="c17c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用Buildah构建并推送图像，将图像标签设置为db2mon:v1.0</p><h1 id="520d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">部署到K8s中</h1><p id="0b5e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在我们部署K8s部署之前，创建以下odbc.ini文件。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="af92" class="mm lb it mi b gy mn mo l mp mq">[mydb2]<br/>Protocol=TCPIP<br/>Hostname=192.168.10.102<br/>ServiceName=50001<br/>Database=dbname<br/>CurrentSchema=dbschema<br/>Driver=/app/odbc_cli/clidriver/lib/libdb2o.so</span></pre><p id="5c65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个文件将用于odbc.ini和db2cli.ini。在名称空间中创建它们相应的配置映射，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="b32d" class="mm lb it mi b gy mn mo l mp mq">kubectl create cm cm-db2odbc --from-file=odbc.ini=odbc.ini<br/>kubectl create cm cm-db2cli --from-file=db2cli.ini=obdc.ini</span></pre><p id="7787" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">配置图内容相同，但密钥不同。</p><p id="80b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如下所示创建K8s部署，</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="eebe" class="mm lb it mi b gy mn mo l mp mq">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: db2mon<br/>  labels:<br/>    app: db2mon<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: db2mon<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: db2mon<br/>    spec:<br/>      containers:<br/>      - name: db2mon<br/>        image: db2mon:v1.0<br/>        ports:<br/>        - containerPort: 9090<br/>        volumeMounts:<br/>        - name: config<br/>          mountPath: /app/config.yaml<br/>          subPath: config.yaml<br/>        - name: odbcini<br/>          mountPath: /app/odbc.ini<br/>          subPath: odbc.ini<br/>        - name: db2cliini<br/>          mountPath: /app/db2cli.ini<br/>          subPath: db2cli.ini<br/>        env:<br/>        - <strong class="mi iu">name: ODBCINI</strong><br/>          value: /app/odbc.ini<br/>        - <strong class="mi iu">name: DB2CLIINIPATH</strong><br/>          value: /app<br/>        - name: DB_USER<br/>          value: db2inst1<br/>        - name: DB_PASSWORD<br/>          value: password<br/>      volumes:<br/>      - name: config<br/>        configMap:<br/>          name: cm-db2monconfig<br/>      - name: odbcini<br/>        configMap:<br/>          name: cm-db2odbc<br/>      - name: db2cliini<br/>        configMap:<br/>          name: cm-db2cli</span></pre><p id="db06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们使用mountPath和子路径将configMap挂载到/app目录，并使用其特定的文件名，这样就不会覆盖/app的原始结构。</p><p id="e543" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">定义分别指向<code class="fe ms mt mu mi b">/app/odbc.ini</code>和<code class="fe ms mt mu mi b">/app</code>的环境变量<code class="fe ms mt mu mi b">ODBCINI</code>和<code class="fe ms mt mu mi b">DB2CLIINIPATH</code>。</p><p id="d84b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过这些设置，ODBC DSN被正确设置，golang可以将DB2数据作为Prometheus gauge数据类型进行查询。</p><p id="76e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关于如何公开服务并为Prometheus操作者设置服务监视器以收集数据的其余内容在这里跳过。</p></div></div>    
</body>
</html>