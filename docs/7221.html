<html>
<head>
<title>Auto-vectorization: How to get beaten by compiler optimization — Java JIT!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动向量化:如何被编译器优化击败——Java JIT！</h1>
<blockquote>原文：<a href="https://itnext.io/auto-vectorization-how-to-get-beaten-by-compiler-optimization-java-jit-vector-api-92c72b97fba3?source=collection_archive---------0-----------------------#2022-07-20">https://itnext.io/auto-vectorization-how-to-get-beaten-by-compiler-optimization-java-jit-vector-api-92c72b97fba3?source=collection_archive---------0-----------------------#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="a535" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">动机</h1><p id="ce11" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最近，我调查了新的Vector API的第三次迭代:<br/><a class="ae lj" href="https://medium.com/@Styp/java-18-vector-api-do-we-get-free-speed-up-c4510eda50d2" rel="noopener">Java 18:Vector API——我们获得免费加速了吗？！</a></p><p id="9151" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这篇文章旨在跟进一些我在第一篇文章中无法回答的有趣发现。我想总结一下我的发现，并展示Java Vector API如何通过利用平台的内在特性来加速代码。融合乘加(FMA)基准测试的结果在某种程度上是意料之中的，并且显示了有希望的结果。然而，简单求和的例子没有显示任何改进。平均加速为0%，反复运行基准后，仍显示0%的提升。现在是时候调查这种失望了。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/c9adfbd7c513f748b2a84745e6fcfd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQwfov8n1Kk0oF3J1meWCQ.jpeg"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">插图我盯着恒星0x加速！</figcaption></figure><p id="526d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">简单求和是两个数组<em class="mf"> a </em>和<em class="mf"> b </em>最基本的相加，结果得到一个数组<em class="mf"> c </em>。我们也可以用下面几行代码来表达这一点:</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="bd58" class="ml jo iq mh b gy mm mn l mo mp">public static int[] simpleSum(int[] a, int[] b) {<br/>    int c = new int[a.length];    <br/>    for (var i = 0; i &lt; a.length; i++){<br/>        c[i] = a[i] + b[i];<br/>    }<br/>    return c;<br/>}</span></pre><p id="b689" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们获得的性能显示，在所有不同的阵列大小下，速度都提高了0倍，如下图所示:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mq"><img src="../Images/8c77089cb42ba8802b293c4ce6fe2f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89HbWUOFp9AmBHcUQfLdVA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">基准测试及其惊人的0%加速！非Vector表示Java for-loop实现，而Vector表示基于本地Vector API的实现。</figcaption></figure><p id="a94b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">基准测试是在具有最宽寄存器的支持AVX-512的CPU上进行的；因此，预计数据并行指令的运行时改进最为显著。然而，令人着迷的是，一个纯java基准测试与高度优化的解决方案不相上下。</p><h1 id="5bd0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">这种实时编译(JIT)是什么东西？</h1><p id="4a8f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这一点上，我们可以假设要么我们的Vector API版本没有按预期工作，要么Java正在对代码的某些关键区域应用一些加速魔法。然而，为了理解Java优化代码的能力，我们需要看看提前机器代码生成和即时机器代码生成之间的根本区别——就像在Java中一样。</p><p id="a364" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">提前生成机器代码:</strong></p><p id="3a5d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">提前(AoT)机器码生成发生在编译时。这种技术在C++等语言中使用。在编译过程中，源代码被<em class="mf">转录</em>为机器码。机器代码取决于目标平台，如x86、Itanium、ARM、M1。因此，代码仅在编译期间被<em class="mf">接触</em>，并且<em class="mf">被转录</em>到目标平台的汇编规范。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mr"><img src="../Images/b15a34627613c8f91c46571199ffd3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DmsjWH2UeqRAJiVPHlaHw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">解释代码编译的过程(例如C++)</figcaption></figure><p id="d7b0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">即时机器代码生成:</strong></p><p id="95cd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">相反，实时(JiT)机器代码生成工作起来稍微复杂一些。代码不是直接转录成目标平台的汇编语言，而是被转录成称为字节码的中间代码。Java字节码是一种中间表示，涵盖了JVM指令集，同时结合了一些编译器优化。</p><p id="71b5" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">JIT编译器读取字节码，并为所需的平台(x86、ARM等)发出正确的汇编指令。).此外，它可以利用程序流的<em class="mf">知识</em>应用一些更具体的优化。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ms"><img src="../Images/5537b6f178274480963762edac1ca222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fYQjaPgnnwtdAVegniAhA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">基于JVM语言的两阶段编译过程。</figcaption></figure><p id="c995" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">JIT编译器结合了两种机器代码翻译方法:解释和提前编译。它负责将字节码翻译成特定于平台的指令。有了增加的运行时知识，就可以进行特定的优化，而这些优化在编译时并不明显。这有助于进一步优化代码，并提高传统语言的运行时性能。</p><p id="3fa7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">闪耀时刻到了:</strong></p><p id="f4d8" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">了解了实时编译器的特性后，有人可能会问，与传统的提前编译相比，它有什么好处。让我们用一个简单的例子来探讨这个问题:</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="db37" class="ml jo iq mh b gy mm mn l mo mp">public void randomLoop(){<br/>    var rnd = new Random();<br/>    int maxItems = rnd.nextInt();<br/>    for(int i = 0; i &lt; maxItems; i++){<br/>        doSomethingWith(i);<br/>    }<br/>}</span></pre><p id="76ce" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">提前编译器没有合理的机会知道循环将执行多少次迭代。另一方面，即时编译器精确地知道maxItems 有多大，并且可以针对小<em class="mf"/>、<em class="mf">中</em>或<em class="mf">大</em>循环进行优化！(这个片段只显示了与提前编译相比，运行时的<em class="mf">知识</em>优势。当然，不能保证任何实时的编译器改进。)</p><h1 id="db9c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">优化选项</strong></h1><p id="586c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir">循环展开:<br/> </strong>循环展开是一种最小化循环开销的优化技术，如边界检查、变量增加等。不是检查循环计数器(I)并随每个元素增加，而是在一个循环体中完成多个元素，以最小化开销:</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="fccc" class="ml jo iq mh b gy mm mn l mo mp">public void normalLoop(){<br/>    for(int i = 0; i &lt; 128; i++){<br/>        doSomethingWith(i);<br/>    }<br/>}</span><span id="695b" class="ml jo iq mh b gy mt mn l mo mp">public void unrolledLoop(){<br/>    for(int i = 0; i &lt; 32; i+=4){<br/>        doSomethingWith(i+0);<br/>        doSomethingWith(i+1);<br/>        doSomethingWith(i+2);<br/>        doSomethingWith(i+3);<br/>    }<br/>}</span></pre><p id="75cd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">只要迭代次数已知，这是提前编译期间使用的一种流行技术。(曾经问过自己为什么C++ <em class="mf">常量变量</em>如此重要——现在你知道了！)实时编译器知道运行时的循环大小，因此可以根据变量的大小强制展开循环。</p><p id="9a1b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">矢量化:<br/> </strong>另一种潜在的方法是自动矢量化(Auto-vectorization)。基于向量的指令触发处理器的特定SIMD(单指令、多数据)寄存器，这些寄存器可以在同一个指令周期内对多个元素执行一个操作。被剪切的<em class="mf"> simpleSum </em>代码是一个可以用矢量化进行优化的完美例子。有了Javas Vector API，我们可以编写平台无关但SIMD优化的代码。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mu"><img src="../Images/8903f65027fcafbfa4f9b0d2c77e16c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CReEwIob8gL4Kuouz7yyA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">单指令、单数据(SISD) — vs —单指令、多数据(SIMD)</figcaption></figure><p id="ef5a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这个介绍引出了一个开放性的问题:<strong class="kn ir">为什么我在比较一个原始实现和一个Vector API加速实现时没有得到任何加速？</strong></p><h1 id="2767" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">找到罪魁祸首:自动矢量化还是循环展开？</h1><p id="fd9e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们现在已经提出了两种策略来优化简单的算术运算循环。最后，是时候证明哪些JIT优化消除了手动调整代码的潜在加速。</p><p id="b035" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">JVM由各种诊断标志组成，这些标志支持将发出的汇编代码存储到日志文件中。此外，还可以打开和关闭一些JIT特性。JIT特性的启用和禁用有助于研究优化技术及其对代码运行时的影响。例如，关闭自动向量化和循环展开，可以为simpleSum示例生成最原始的汇编代码:</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="5fb5" class="ml jo iq mh b gy mm mn l mo mp"><em class="mf">Operation: add a[i]+b[i] and move data to c[i]:</em><br/>0x11dad89e0:   mov    0x10(%r8,%r13,<em class="mf">4</em>),%eax<br/>0x11dad89e5:   add    0x10(%r11,%r13,<em class="mf">4</em>),%eax<br/>0x11dad89ea:   mov    %eax,0x10(%rbx,%r13,<em class="mf">4</em>)       ;*iastore </span><span id="df48" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: Increment Loop-Counter i:</em>                                                         <em class="mf">ch.styp.TestMain</em>::addArray@<em class="mf">27</em> (line <em class="mf">37</em>)<br/>0x11dad89ef:   inc    %r13d                        ;*iinc </span><span id="3982" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: Compare Loop-Counter i, and jump to add-Block:</em>                                                       <em class="mf">ch.styp.TestMain</em>::addArray@<em class="mf">28</em> (line <em class="mf">36</em>)<br/>0x11dad89f2:   cmp    %r9d,%r13d<br/>0x11dad89f5:   jl     0x11dad89e0                  ;*goto </span></pre><p id="d49e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">截取的下一个生成的代码是打开了循环展开特性的代码。因此，此配置会生成以下代码:</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="762e" class="ml jo iq mh b gy mm mn l mo mp"><em class="mf">Operation: add a[i+0]+b[i+0] and move data to c[i+0]:<br/></em>0x11bd3e240:   mov    0x10(%rbp,%rdi,<em class="mf">4</em>),%esi<br/>0x11bd3e244:   add    0x10(%rdx,%rdi,<em class="mf">4</em>),%esi<br/>0x11bd3e248:   mov    %esi,0x10(%r8,%rdi,<em class="mf">4</em>)</span><span id="0430" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: add a[i+1]+b[i+1] and move data to c[i+1]:</em><br/>0x11bd3e24d:   mov    0x14(%rbp,%rdi,<em class="mf">4</em>),%r10d<br/>0x11bd3e252:   add    0x14(%rdx,%rdi,<em class="mf">4</em>),%r10d<br/>0x11bd3e257:   mov    %r10d,0x14(%r8,%rdi,<em class="mf">4</em>)</span><span id="1528" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: add a[i+2]+b[i+2] and move data to c[i+2]:<br/></em>0x11bd3e25c:   mov    0x18(%rdx,%rdi,<em class="mf">4</em>),%r10d<br/>0x11bd3e261:   add    0x18(%rbp,%rdi,<em class="mf">4</em>),%r10d<br/>0x11bd3e266:   mov    %r10d,0x18(%r8,%rdi,<em class="mf">4</em>)</span><span id="73d6" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: add a[i+3]+b[i+3] and move data to c[i+3]:<br/></em>0x11bd3e26b:   mov    0x1c(%rdx,%rdi,<em class="mf">4</em>),%r10d<br/>0x11bd3e270:   add    0x1c(%rbp,%rdi,<em class="mf">4</em>),%r10d<br/>0x11bd3e275:   mov    %r10d,0x1c(%r8,%rdi,<em class="mf">4</em>)       </span><span id="dbcc" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: Increment Loop-Counter i (This time +4):<br/>ch.styp.TestMain</em>::addArray@<em class="mf">27</em> (line <em class="mf">37</em>)<br/>0x11bd3e27a:   add    $0x4,%edi                    ;*iinc </span><span id="47ce" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: Compare Loop-Counter i, and jump to add-Block:</em>                        <em class="mf">ch.styp.TestMain</em>::addArray@<em class="mf">28</em> (line <em class="mf">36</em>)<br/>0x11bd3e27d:   cmp    %eax,%edi<br/>0x11bd3e27f:   jl     0x11bd3e240                  ;*goto</span></pre><p id="3a1d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">最后但同样重要的是，我们强化了Java必须提供的所有特性，并且我们期望循环展开和向量并行出现在汇编代码中。x86指令集在向量形式上相当于mov和add，如<em class="mf"> vmov </em>和<em class="mf"> vadd </em>(及其变体)，因此我们希望在发出的汇编代码中看到这些指令:</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="f00b" class="ml jo iq mh b gy mm mn l mo mp"><em class="mf">Operation: add a[i+0..3]+b[i+0..3] and move data to c[i+0..3]:</em><br/>0x112c9d300:   vmovdqu 0x10(%rbp,%r11,<em class="mf">4</em>),%ymm0<br/>0x112c9d307:   vpaddd 0x10(%r13,%r11,<em class="mf">4</em>),%ymm0,%ymm0<br/>0x112c9d30e:   vmovdqu %ymm0,0x10(%rdx,%r11,<em class="mf">4</em>)</span><span id="34ad" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: add a[i+4..7]+b[i+4..7] and move data to c[i+4..7]:</em><br/>0x112c9d315:   vmovdqu 0x30(%rbp,%r11,<em class="mf">4</em>),%ymm0<br/>0x112c9d31c:   vpaddd 0x30(%r13,%r11,<em class="mf">4</em>),%ymm0,%ymm0<br/>0x112c9d323:   vmovdqu %ymm0,0x30(%rdx,%r11,<em class="mf">4</em>)</span><span id="4764" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: add a[i+8..11]+b[i+8..11] and move data to c[i+8..11]:</em><br/>0x112c9d32a:   vmovdqu 0x50(%rbp,%r11,<em class="mf">4</em>),%ymm0<br/>0x112c9d331:   vpaddd 0x50(%r13,%r11,<em class="mf">4</em>),%ymm0,%ymm0<br/>0x112c9d338:   vmovdqu %ymm0,0x50(%rdx,%r11,<em class="mf">4</em>)</span><span id="cb8f" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: add a[i+12..15]+b[i+12..15] and move data to c[i+12..15]:</em><br/>0x112c9d33f:   vmovdqu 0x70(%rbp,%r11,<em class="mf">4</em>),%ymm0<br/>0x112c9d346:   vpaddd 0x70(%r13,%r11,<em class="mf">4</em>),%ymm0,%ymm0<br/>0x112c9d34d:   vmovdqu %ymm0,0x70(%rdx,%r11,<em class="mf">4</em>)     </span><span id="0e6f" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: Increment Loop-Counter i (This time +16):<br/>ch.styp.TestMain</em>::addArray@<em class="mf">27</em> (line <em class="mf">37</em>)<br/>0x112c9d354:   add    $0x20,%r11d                    ;*iinc</span><span id="1770" class="ml jo iq mh b gy mt mn l mo mp"><em class="mf">Operation: Compare Loop-Counter i, and jump to add-Block:</em>                        <em class="mf">ch.styp.TestMain</em>::addArray@<em class="mf">28</em> (line <em class="mf">36</em>)<br/>0x112c9d358:   cmp    %eax,%r11d<br/>0x112c9d35b:   jl     0x112c9d300                    ;*goto</span></pre><p id="4591" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="mf"> ymm- </em>寄存器的出现表明使用了代表8个整数的256位宽向量运算。这证明了AVX-2在这个例子中的用法。(为了更好的可读性，编辑了所有装配片段。)</p><p id="8ca6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">就这样——默认生成的机器码包含向量并行和循环展开，最后一个例子证明了这一点。因此，向量并行实现无法击败JVM发出的代码。自动矢量化和循环展开应用得如此巧妙，以至于基于API的实现无法带来任何性能提升。令人印象深刻的是，JVM可以很好地优化简单的代码片段，从而在任何平台上产生最佳性能。</p><h1 id="926e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我们来证明一下假设:基准。</h1><p id="bee5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">谈论改进并在汇编代码中展示它们是一回事，但是要完成这项工作，交付基准测试是必要的。有趣的问题是simpleSum实现是否效率不高——或者基线是否优化得如此之好，以至于手动应用代码调整(Vector API)无法提供任何进一步的性能优势。<br/>出于完整性原因，不同的JVM配置和本地Vector API实现已经过基准测试:</p><p id="dbb4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">无展开，无向量:<br/> </strong>在这种情况下，循环展开和自动向量化的JVM特性被禁用。该模式用作所有连续实验的基线，生成应用最少优化的汇编代码。</p><ul class=""><li id="147b" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated"><strong class="kn ir">使用展开，无向量:<br/> </strong>启用循环展开，但禁用自动向量化。</li><li id="434d" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated"><strong class="kn ir">无展开，带向量:<br/> </strong>启用自动向量化，但禁用循环展开。</li><li id="06b3" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated"><strong class="kn ir"> With Unroll，With Vector: <br/> </strong>循环展开和自动向量化的标志都被启用——这是强制应用两种技术，还是仅基于最佳情况基础进行优化，不幸的是没有记录。</li><li id="3ad1" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated"><strong class="kn ir"> Java默认:<br/> </strong>没有附加标志；JVM在其默认配置下运行。</li><li id="d8af" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated"><strong class="kn ir">向量实现:<br/> </strong>代码使用向量API实现，因此强制作为向量并行代码运行；JVM设置保留默认模式。</li></ul><p id="408c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">选择阵列长度是为了代表最差情况下的适用性。这些测试是在多个2^n-1.上进行的具体来说，使用了以下值:<em class="mf"> 15，255，4095，65535，16777215，268435455 </em>。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mq"><img src="../Images/91a582718d5b5bcbc4e54c062d74f98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MTdEhFE4hR-utdcbPcTeww.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">具有循环展开、自动向量化以及两者结合的性能指标评测。包括与本地Vector API实现的比较。</figcaption></figure><p id="7d42" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">结果显示预期的行为；在数据保存在本地缓存的区域(L1数据和L2)可以看到最显著的加速。<br/>此外，simpleSum基准测试极大地受益于Java运行时默认设置中的循环展开和自动向量化！因此，不可能通过利用Vector API来进一步改进:</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="1fc3" class="ml jo iq mh b gy mm mn l mo mp">+--------------------------+---------------+<br/>|          Method          | Peak Speed-Up |<br/>+--------------------------+---------------+<br/>| No Unroll, No Vector     | 1.00x         |<br/>| With Unroll, No Vector   | 1.22x         |<br/>| No Unroll, With Vector   | 1.01x         |<br/>| With Unroll, With Vector | 2.15x         |<br/>| Java Default             | 2.06x         |<br/>| Vector Implementation    | 2.08x         |<br/>+--------------------------+---------------+</span></pre><p id="3665" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">峰值加速表给基准测试过程带来了更多的启示:循环展开和自动矢量化作为独立的解决方案只能提供很少的好处。但合在一起，它们带来了超过2倍的巨大速度提升。</p><h1 id="4b49" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">讨论</strong></h1><p id="4358" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在最初的博文中，我推测了为什么Vector API实现与原始的Java实现相比没有显著的速度提升。在这一点上，答案很简单:<em class="mf">JVM太他妈聪明了，在简单的情况下是不可能打败即时编译器的！——</em>句号，不讨论！</p><p id="7b2b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">通过观察JVM的内部，令人印象深刻的是需要循环展开和自动向量化的组合来产生最大的吞吐量。</p><p id="1c58" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">可以通过比较两个机器代码块来估计假设的计算效率改进。没有循环展开的版本每数组项需要6条指令，而有循环展开的版本每4项需要15条指令；因此，对4个项目的24条指令到4个项目的15条指令的简化估计导致1.6倍的“非常”假设提升。这纯属理论！</p><p id="60e9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">矢量化将带来4倍的理论性能优势(AVX-2)。然而，在这种情况下，预计不会出现这种上升。与计算操作的原始性质相比，通过寄存器移动数据的开销非常昂贵。因此，测得的加速较低。当循环展开和矢量化相结合时，速度提高了2倍，这表明英特尔x86架构受益于SIMD模式下更长的指令跨度，而不会受到比较指令或跳转指令的干扰。CPU在向量寄存器中不间断运行的时间越长，加速可能就越高。这导致了矢量指令存在“冷启动”的结论，这会使处理器暂停一段时间。(在我看来，这也提出了一个问题，所有这些TFLOP数是代表真实世界，还是仅仅是串联起来产生最优数的汇编指令。)</p><h1 id="1d6b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="ae80" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了结束这篇文章，我坚持我已经经常提到的优化声明:你的里程可能会有所不同。</p><p id="16ee" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们已经看到，实时编译器是一个非常强大的优化器；在简单的例子中，它的性能是无法超越的。因此，在未来，要注意优化是一门艺术，基准测试也是一门艺术。研究优化选项可能是值得的，但同时，失望也是可以的——因为Java在这方面做得非常好。</p><h1 id="51d9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">确认</h1><ul class=""><li id="87c2" class="mv mw iq kn b ko kp ks kt kw nj la nk le nl li na nb nc nd bi translated">Christoph Amrein和Marco Glauser分享了一些想法并改进了一些想法。</li></ul></div></div>    
</body>
</html>