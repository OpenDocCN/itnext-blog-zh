<html>
<head>
<title>Web Relay Ingress with Docker for Mac or Minikube</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker for Mac或Minikube的Web中继入口</h1>
<blockquote>原文：<a href="https://itnext.io/web-relay-ingress-with-docker-for-mac-or-minikube-753d71b28275?source=collection_archive---------1-----------------------#2018-01-08">https://itnext.io/web-relay-ingress-with-docker-for-mac-or-minikube-753d71b28275?source=collection_archive---------1-----------------------#2018-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1b860a421b61eba706666b5b6574ae44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5BF0hZUR6VAeqKm6.png"/></div></div></figure><p id="2cd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes在Mac 17.12 CE Edge 的<strong class="ka ir"> Docker中可用。<a class="ae kw" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank">去年，Kubernetes </a>展示了它是运行容器工作负载的最灵活和最<strong class="ka ir">可靠的</strong>选择，几乎击败了竞争对手:</strong></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/a8c58e4765041108509e1b32708b857b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zm6dScQyij-0RSGasLPSOA.png"/></div></div></figure><p id="3655" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在参观了奥斯汀和哥本哈根的上两次KubeCon会议后，我看到专门从事Kubernetes咨询的公司数量大幅增加，几乎所有的云提供商都在开发托管Kubernetes解决方案，我想很快它将像托管静态网站一样简单，可供所有人使用:)</p><p id="11fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在本文中，我们将:</strong></p><ul class=""><li id="8b73" class="lc ld iq ka b kb kc kf kg kj le kn lf kr lg kv lh li lj lk bi translated">在您的<strong class="ka ir"> Docker for Mac </strong>中启用Kubernetes支持。</li><li id="f80a" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">创建并部署一个示例Node.js应用程序。</li><li id="00d0" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">使用Web Relay ingress控制器向全世界共享我们计算机中运行的应用程序:)</li></ul><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/42e39f6c06b717dd2a57dc6dae1601bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qra8KyH8oa4b9gOK.gif"/></div></div></figure><p id="a052" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">先决条件:</strong></p><ul class=""><li id="0c65" class="lc ld iq ka b kb kc kf kg kj le kn lf kr lg kv lh li lj lk bi translated"><a class="ae kw" href="https://docs.docker.com/docker-for-mac/release-notes/" rel="noopener ugc nofollow" target="_blank">支持Kubernetes</a>或<a class="ae kw" href="https://github.com/kubernetes/minikube" rel="noopener ugc nofollow" target="_blank"> Minikube </a>或任何其他Kubernetes集群的Mac Docker在GKE上运行良好！</li><li id="0c9f" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">Webhook中继<a class="ae kw" href="https://my.webhookrelay.com/register" rel="noopener ugc nofollow" target="_blank">账号</a>和<a class="ae kw" href="https://webhookrelay.com/v1/guide/installation.html#MacOS" rel="noopener ugc nofollow" target="_blank">中继</a>客户端命令。</li><li id="5e7d" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated"><code class="fe lr ls lt lu b">kubectl</code>，Kubernetes客户端命令。它应该由Mac的Docker来包含和配置，或者你可以单独安装:【https://kubernetes.io/docs/tasks/tools/install-kubectl/T21】</li></ul><blockquote class="lv lw lx"><p id="b697" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><em class="iq">如果您没有使用Mac或</em><strong class="ka ir"><em class="iq">Docker for Mac</em></strong><em class="iq">，请跳过“在您的Docker for Mac中启用Kubernetes”部分。本教程适用于任何具有互联网连接的</em><strong class="ka ir"><em class="iq">Kubernetes集群。</em></strong></p></blockquote></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="5d33" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">入门指南</h1><p id="97b4" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">是时候把手弄脏了！如果你已经做了，可以跳过一些事情，比如启用Kubernetes。</p><h1 id="bf06" class="mj mk iq bd ml mm nm mo mp mq nn ms mt mu no mw mx my np na nb nc nq ne nf ng bi translated">在Mac Docker中启用Kubernetes(仅适用于MacOS用户)</h1><p id="f06e" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">要在Mac Docker中启用Kubernetes支持，选择<strong class="ka ir">启用Kubernetes </strong>并点击<strong class="ka ir">应用并重启</strong>按钮:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/075692e31ac6d4d731c4e989067c1d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XoBCCf-KeaVRfYCN.png"/></div></div></figure><p id="b5ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据可用的互联网带宽，这需要一点时间，一旦完成，它应该报告安装完成。如果你对这一步有任何问题，访问<a class="ae kw" href="https://docs.docker.com/docker-for-mac/#kubernetes" rel="noopener ugc nofollow" target="_blank"> Docker文档</a>可能是有意义的。</p><p id="6603" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与Minikube不同，Docker for Mac不劫持kubectl上下文，所以您必须设置它:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="d6d4" class="nw mk iq lu b gy nx ny l nz oa">kubectl config use-context docker-for-desktop</span></pre><p id="c22a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查您的<code class="fe lr ls lt lu b">kubectl</code>是否正在使用<strong class="ka ir"> docker-for-desktop </strong>上下文。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/4d35f7a5b1ee6e41951bfc8aa7b06d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JtGxXhyEhIEgM_5MwHamIg.png"/></div></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="62d3" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">在Minikube上启动Kubernetes(针对Linux用户)</h1><p id="220e" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">嗯，这很简单。你可能已经知道了，但是:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="21b6" class="nw mk iq lu b gy nx ny l nz oa">minikube start</span></pre></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="8467" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">将入口控制器添加到Mac Kubernetes的Docker</h1><p id="8498" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">添加入口控制器:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="6627" class="nw mk iq lu b gy nx ny l nz oa">relay ingress init</span></pre><p id="56ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出应该如下所示:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/9b10d7c608e355a3b561280e2161c974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgkl_vVmL2ULOfGZ74EytQ.png"/></div></div></figure><p id="117e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，你们中的一些人现在可能会想:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/d65c9de1ad5f9436e4d30fd3a9f14bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*e4JncTovnFL5GC46.png"/></div></div></figure><p id="073f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是等等，这个命令在<code class="fe lr ls lt lu b">webrelay-ingress</code>名称空间中创建了支持RBAC的入口控制器，并且已经为您的帐户<strong class="ka ir">配置了凭证。你可以阅读更多关于网络中继入口控制器<a class="ae kw" href="https://webhookrelay.com/v1/guide/ingress-controller" rel="noopener ugc nofollow" target="_blank">这里</a>。</strong></p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="9bba" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">创建Node.js应用程序</h1><p id="ce08" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">下一步是编写应用程序。创建一个名为<code class="fe lr ls lt lu b">hello</code>的新目录，文件名为<code class="fe lr ls lt lu b">server.js</code>:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="48ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要运行应用程序:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="0c51" class="nw mk iq lu b gy nx ny l nz oa">node server.js</span></pre><p id="11dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你应该能看到你的“Hello World！”在<a class="ae kw" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">的消息http://localhost:8080/ </a>。</p><p id="150a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过按下<strong class="ka ir"> Ctrl-C </strong>停止正在运行的Node.js服务器。</p><p id="d92a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是将应用程序打包到Docker容器中。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="11d2" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">将您的应用程序放入Docker容器中</h1><p id="5370" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">创建一个文件，也在<code class="fe lr ls lt lu b">hello</code>目录下，命名为<strong class="ka ir"> Dockerfile </strong>。Dockerfile文件描述了您想要构建的映像。您可以通过扩展现有映像来构建Docker容器映像。本教程中的图像扩展了现有的Node.js图像。</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="b27a" class="nw mk iq lu b gy nx ny l nz oa">FROM node:9.2.0    # base image, needs Node.js<br/>EXPOSE 8080        # on which port your application is listening<br/>COPY server.js .   # copies our file into the Dockerfile<br/>CMD node server.js # tells the runtime how to start your app</span></pre><p id="0b74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个Docker文件从Docker注册表中的官方Node.js映像开始，公开端口8080，将server.js文件复制到映像并启动Node.js服务器。<br/>建立你的码头工人形象:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="df96" class="nw mk iq lu b gy nx ny l nz oa">docker build -t hello-node:v1 .</span></pre><p id="38d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Kubernetes的Docker for Mac的真正好处是，您可以在Kubernetes集群中轻松运行本地构建的Docker映像。不需要仅仅为了测试而改变Docker守护进程或将映像推送到公共存储库。现在，Docker for Mac Kubernetes可以运行您构建的映像。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="3a73" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">创建部署和服务</h1><p id="8bb3" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">Kubernetes <a class="ae kw" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> Deployments </a>检查<a class="ae kw" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" rel="noopener ugc nofollow" target="_blank">Pod</a>的健康状况，如果Pod终止，则重启Pod的容器。Pod可以由多个容器组成，但在本例中，我们只有一个容器:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="ae71" class="nw mk iq lu b gy nx ny l nz oa">kubectl run hello-node — image=hello-node:v1 — port=8080</span></pre><p id="edde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看部署:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="db83" class="nw mk iq lu b gy nx ny l nz oa">kubectl get deployments</span></pre><p id="6f7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/b23a9bfee0be7ecc190e95e0f7e421e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZzrSz-RZBc-kDPGmLHevlQ.png"/></div></div></figure><p id="7aff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为在默认情况下，Pod只能通过其在Kubernetes集群中的内部IP地址进行访问，所以我们需要公开它。创建一个<a class="ae kw" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="8045" class="nw mk iq lu b gy nx ny l nz oa">kubectl expose deployment hello-node — type=ClusterIP</span></pre><p id="72f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看创建的服务:</p><p id="5a30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/a6a58df40014cabe5a2cc8b35f782dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OllCoTYbdTF_mRh8QzUVGA.png"/></div></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="e629" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">定义入口并将您的应用程序暴露于互联网</h1><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/9fac2da69ac8f7f8a5917cc267d1b411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*4vqLcbXD7zcPawuH.png"/></div></figure><p id="1307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes中的入口提供了一种简单的方法来定义主机名和服务之间的路由规则。让我们通过创建一个隧道来使用<code class="fe lr ls lt lu b">relay</code>命令客户端获得我们的公共端点:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="1ee8" class="nw mk iq lu b gy nx ny l nz oa">relay tunnel create — group webrelay-ingress hellonode</span></pre><p id="c975" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/8ff14aac8cd122740b0b28694e9ba5d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AgN8LUS6RZjmvpq5uisRfw.png"/></div></div></figure><p id="87ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要参数<em class="ly">–group web relay-ingress</em>来让我们的ingress控制器知道它可以管理哪些隧道。</p><blockquote class="lv lw lx"><p id="35c5" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><em class="iq">注意，拥有付费计划的用户可以指定任何自定义子域(只要不被占用)，而无需先创建隧道。这允许简单地定义</em> <code class="fe lr ls lt lu b"><em class="iq">ingress.yaml</em></code> <em class="iq">，入口控制器将为其创建一个隧道。</em></p></blockquote><p id="5597" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只对这个<code class="fe lr ls lt lu b">pis9izc72c1wd9i21gxqxm.webrelay.io</code>(主持人)部分感兴趣。每个用户都有一个唯一的隧道链接。使用您的隧道主机名编辑此代码，并将其保存在名为<code class="fe lr ls lt lu b">hello</code>的文件夹中，文件名为<code class="fe lr ls lt lu b">ingress.yml</code>:</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="347e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建它:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="2705" class="nw mk iq lu b gy nx ny l nz oa">kubectl create -f ingress.yml</span></pre><p id="7511" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的应用程序现在公开在公共互联网上。请参阅下一节如何访问或只需在浏览器中输入主机名。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="6e9e" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">通过互联网访问您的应用程序</h1><p id="b6c5" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">要查看现有入口:</p><pre class="ky kz la lb gt ns lu nt nu aw nv bi"><span id="9253" class="nw mk iq lu b gy nx ny l nz oa">relay ingress ls</span></pre><p id="05ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/6c4c9012ce9225c62a4f68848dffc1f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EwfATAS-QhOEYjX4tw4hw.png"/></div></div></figure><p id="9dad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">后端</strong>列应该显示公开服务的<code class="fe lr ls lt lu b">&lt;namespace&gt;/&lt;service&gt;/&lt;port&gt;</code>。你可以在这里用浏览器访问<a class="ae kw" href="http://pis9izc72c1wd9i21gxqxm.webrelay.io/" rel="noopener ugc nofollow" target="_blank"> http:// &lt;你的子域&gt; .webrelay.io </a>(把链接改成你自己的隧道地址就可以了)。</p><p id="1e6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您也可以在https://my.webhookrelay.com/tunnels<a class="ae kw" href="https://my.webhookrelay.com/tunnels" rel="noopener ugc nofollow" target="_blank">使用网络用户界面</a>查看您的简介:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/0a5c861702bae31690b8edec2fb1569e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lmBrJHHrOlm63-vx.png"/></div></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="13b7" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">包扎</h1><p id="fc16" class="pw-post-body-paragraph jy jz iq ka b kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv ij bi translated">在本文中，我们创建、部署了一个应用程序，并将其暴露在互联网上，该应用程序在我们的笔记本电脑上本地运行。有人说这是一个<strong class="ka ir">“真实的hello world”</strong>应用程序，而不仅仅是通常的<strong class="ka ir">“hello localhost”</strong>。</p><p id="b923" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了Docker for Mac Kubernetes和Minikube支持，现在开发和测试我们的应用程序就容易多了。本地构建、本地运行和本地演示。我希望Web Relay ingress controller在开发、测试和运行您的应用程序时能为您提供很好的服务。</p><p id="c4aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一如既往，如果您有任何问题，请随时联系我。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="229d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ly">原载于2018年1月8日</em><a class="ae kw" href="https://webhookrelay.com/blog/2018/01/08/ingress-with-docker-for-mac/" rel="noopener ugc nofollow" target="_blank"><em class="ly">【webhookrelay.com】</em></a><em class="ly">。2018年7月31日更新。</em></p></div></div>    
</body>
</html>