<html>
<head>
<title>TDD in Flutter Part 4: Creating Mocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter中的TDD第4部分:创建模拟</h1>
<blockquote>原文：<a href="https://itnext.io/tdd-in-flutter-part-4-creating-mocks-eb3b0a38bae0?source=collection_archive---------1-----------------------#2022-08-24">https://itnext.io/tdd-in-flutter-part-4-creating-mocks-eb3b0a38bae0?source=collection_archive---------1-----------------------#2022-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8d86239268090316ddb2997da442d57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cnOxe4bps8i07G-atX2c0w.jpeg"/></div></div></figure><p id="fa80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">欢迎来到“Flutter中的测试驱动开发”系列的第四集，今天我将解释“模仿”类和方法的概念。然后我会比较嘲笑你的类的不同方式，包括两个流行的嘲笑包<a class="ae kz" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank"> mockito </a>，由<a class="ae kz" href="https://github.com/dart-lang" rel="noopener ugc nofollow" target="_blank"> Dart团队</a>维护，和<a class="ae kz" href="https://pub.dev/packages/mocktail" rel="noopener ugc nofollow" target="_blank"> mocktail </a>，由<a class="ae kz" href="https://verygood.ventures/" rel="noopener ugc nofollow" target="_blank"> Very Good Ventures </a>维护。</p><p id="4398" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你也可以在专门的“TDD in Flutter”列表这里查看之前的文章:<a class="ae kz" href="https://rouxguillaume.medium.com/list/tdd-in-flutter-64d0d5f07854" rel="noopener">https://rouxguillaume . medium . com/list/TDD-in-Flutter-64d 0 D5 f 07854</a></p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="bad4" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">什么是模仿？</h1><p id="0c06" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">模拟对象是以受控方式模仿真实对象行为的对象。程序员通常创建一个模拟对象来测试其他对象的行为。</p><p id="c3f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">模拟对象具有与它们模拟的真实对象相同的接口，允许客户端对象不知道它是在使用真实对象还是模拟对象。(这通常是通过依赖注入工具来管理的。)</p><p id="f00f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Flutter中，你有不同的创建模仿的方法，你可以直接创建你自己的模仿对象，用你想要的方法的特定实现，或者使用第三方包，比如上面提到的那个。</p><p id="b711" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们用一个从<a class="ae kz" href="https://randomuser.me/" rel="noopener ugc nofollow" target="_blank"> randomuser.me </a>获取随机用户数据的简单应用程序来探索这些不同的模拟和测试方法。</p><h1 id="714f" class="lh li it bd lj lk mk lm ln lo ml lq lr ls mm lu lv lw mn ly lz ma mo mc md me bi translated">基础项目</h1><p id="c1f5" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">假设我们想要解析下面的JSON:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/6ea65c08472d77d8c8b97e3d00b2a6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YtNa8NAuVz1a1qnkZIyEyw.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">用<a class="ae kz" href="https://randomuser.me/api/" rel="noopener ugc nofollow" target="_blank">https://randomuser.me/api/</a>生成</figcaption></figure><p id="1716" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先我们需要定义一个<code class="fe my mz na nb b">UserModel</code>类(为了避免文章变得太长，我将跳过“编写测试”部分，但是你可以在这里找到所有与类<a class="ae kz" href="https://github.com/TesteurManiak/tdd_in_flutter/blob/main/creating_mocks/test/user_model_test.dart" rel="noopener ugc nofollow" target="_blank">相关的测试):</a></p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/f9e2e0ac653b4eaf2651578b7f1072b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hR1qluiNIOWBvBfBWh19qA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">用户模型. dart</figcaption></figure><p id="24d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们必须定义一个API来执行我们的HTTP请求，在这种情况下，我将创建一个依赖于<code class="fe my mz na nb b">MyHttpClient</code>类的类<code class="fe my mz na nb b">RemoteDataSource</code>，因为如果不依赖于第三方包(如<a class="ae kz" href="https://pub.dev/packages/http_mock_adapter" rel="noopener ugc nofollow" target="_blank"> http_mock_adapter </a>)来模仿某些包(如<a class="ae kz" href="https://pub.dev/packages/dio" rel="noopener ugc nofollow" target="_blank"> dio </a>)会有些乏味。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/5aeddb8ea73a4836e1ede9cd481220a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3FrdV7TtQvcnjGTliLMOqw.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">例外的是，我不会事先为这个类编写测试，因为整个重点是向你展示单元测试的不同方法。</figcaption></figure><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/afac1f96710c95adf6163e42fb7549cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbD-WRKyZM0QVJtnYCP8Rg.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">my_http_client.dart ( <a class="ae kz" href="https://github.com/TesteurManiak/tdd_in_flutter/blob/main/creating_mocks/test/my_http_client_test.dart" rel="noopener ugc nofollow" target="_blank">单元测试</a>)</figcaption></figure><p id="6e6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经写好了基础代码，我们可以开始使用mocks为<code class="fe my mz na nb b">RemoteDataSource</code>写一些测试。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="d27c" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">自定义模拟对象</h1><p id="4259" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">如果你不想依赖一个软件包，你可以自己写一些模拟程序，下面是一个你可以实现的例子:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/1cb485cc5b9c8de48ff0ea6dc3eee5b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7j5sgRHMPSL8dIcBOuoSFg.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">mocks.dart ( <a class="ae kz" href="https://github.com/TesteurManiak/tdd_in_flutter/blob/main/creating_mocks/test/utils/fixture_reader.dart" rel="noopener ugc nofollow" target="_blank"> fixture </a>是一个从测试文件夹中读取文件的实用函数)</figcaption></figure><p id="bf58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，我必须编写两个模拟类。背后的原因是因为我想测试我的<code class="fe my mz na nb b">RemoteDataSourceImpl</code>的两个行为:</p><ul class=""><li id="5d2e" class="ng nh it kd b ke kf ki kj km ni kq nj ku nk ky nl nm nn no bi translated">我想测试一个<code class="fe my mz na nb b">UserModel</code>是否被正确解析和返回，</li><li id="a4b1" class="ng nh it kd b ke np ki nq km nr kq ns ku nt ky nl nm nn no bi translated">我想测试一下，如果我没有任何数据要解析，将会返回一个<code class="fe my mz na nb b">null</code>值。</li></ul><p id="b287" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是如何编写测试的方法:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/efb71f6ce9aa2ce78c80026a0837479e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pij7MmcgPXbhlv_opnyVew.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">我使用了“custom”标签，以便能够使用我的定制模拟只执行测试。</figcaption></figure><p id="dad7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建了一个<code class="fe my mz na nb b">MyHttpClient</code>的模拟实例，它将被我们的<code class="fe my mz na nb b">RemoteDataSourceImpl</code>使用。然后我们将能够调用我们想要测试的方法，因为返回值总是相同的，我们现在可以断言接收到的结果。</p><p id="c22f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过这样做，我们已经能够测试<code class="fe my mz na nb b">RemoteDataSourceImpl</code>类，但是正如你所看到的，每当我们需要测试一些特定的情况时，我们将不得不创建一个新的模拟类来实现期望的行为。这在中型和大型代码库上会很快变得单调乏味，这就是模仿包派上用场的地方。</p><h1 id="a6a8" class="lh li it bd lj lk mk lm ln lo ml lq lr ls mm lu lv lw mn ly lz ma mo mc md me bi translated">莫克托&amp;莫克泰尔</h1><p id="8fd0" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">在撰写本文时，<a class="ae kz" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank"> mockito </a>和<a class="ae kz" href="https://pub.dev/packages/mocktail" rel="noopener ugc nofollow" target="_blank"> mocktail </a>是轻松创建类模拟的首选解决方案。虽然我个人偏爱mocktail，但这两个包提供了几乎完全相同的特性和API，与您的测试代码不会有任何显著的差异。</p><p id="b9a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，用这些包装制作的模型是什么样的呢？</p><p id="0048" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嗯，对于mockito，类是用<a class="ae kz" href="https://pub.dev/packages/build_runner" rel="noopener ugc nofollow" target="_blank"> build_runner </a>生成的，因此，您必须注释该方法以生成正确的mock类(您可以直接参考<a class="ae kz" href="https://pub.dev/packages/mockito#lets-create-mocks" rel="noopener ugc nofollow" target="_blank"> mockito的文档</a>以了解更多关于如何生成mock的信息)。</p><p id="a4ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于mocktail，您只需要扩展<code class="fe my mz na nb b">Mock</code>对象。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/03d7a0499cca07becbee722ad802407a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9BnnccPKELQsMwiLBjGjA.png"/></div></div></figure><p id="0b30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至于我们的测试，两个代码将几乎相同。</p><div class="mq mr ms mt gt ab cb"><figure class="nw ju nx ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/bb07a1e004d1e086fdafbe929be2a649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Ot3XYbvlFrQLwmsEjMVp3g.png"/></div></figure><figure class="nw ju nx ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/7fa5cb56347405685e02bd304dc2e06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*1A3iiL9btm0y2lXfKuZAVQ.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk oc di od oe translated">莫克托(左)和莫克泰尔(右)</figcaption></figure></div><p id="78e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">依靠其中的一个包，我们可以使用两个非常方便的方法，一个是<code class="fe my mz na nb b">when</code>来隐藏模拟的行为(不需要创建一个全新的类),另一个是<code class="fe my mz na nb b">verify</code>,它允许我们确认模拟类中的特定方法已经被调用。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="7140" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="c5d7" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">本文到此结束，我希望嘲讽一个类背后的概念现在对你来说更清楚了。最终没有“最佳解决方案”，只有你和你的团队会选择。更喜欢写你的mock还是依赖一个包完全取决于你。</p><p id="e2c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想更详细地查看代码，可以在我的GitHub上找到本文使用的整个项目:</p><div class="of og gp gr oh oi"><a href="https://github.com/TesteurManiak/tdd_in_flutter" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">GitHub-TesteurManiak/TDD _ in _ flutter</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在GitHub上创建一个帐户，为TesteurManiak/tdd_in_flutter开发做贡献。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow jz oi"/></div></div></a></div><p id="37e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你有问题，你可以<a class="ae kz" href="https://twitter.com/TesteurManiak" rel="noopener ugc nofollow" target="_blank">在Twitter上联系我</a>,如果你喜欢这篇文章，不要犹豫，继续关注，鼓掌和/或评论，这有助于我保持动力。</p><p id="67c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">祝你有美好的一天和快乐的编码！</p></div></div>    
</body>
</html>