<html>
<head>
<title>How to Deploy and Use Kube-fledged to Cache Images in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Kubernetes中部署和使用Kube-fledged来缓存图像</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-deploy-and-use-kube-fledged-to-cache-images-in-kubernetes-8b6b9d6c2733?source=collection_archive---------1-----------------------#2021-09-30">https://itnext.io/how-to-deploy-and-use-kube-fledged-to-cache-images-in-kubernetes-8b6b9d6c2733?source=collection_archive---------1-----------------------#2021-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6e45e63c5d34df54fddd22d100c6ec58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YIYJLNJ5EeJp7yOO1261uw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">MF Evelyn 在<a class="ae jd" href="https://unsplash.com/s/photos/parakeet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="ab01" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">羽翼未丰是飞行动物生命中从孵化或出生到能够飞行的阶段。当羽毛和翅膀肌肉发育到足以飞行时，所有的鸟都被认为是羽翼丰满的。一只刚刚羽化但仍然依赖父母照顾和喂养的小鸟被称为雏鸟。(来源:维基百科)</em></p><h1 id="6ecf" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是kube-fledged？</h1><p id="1779" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">kube-friedged是一个kubernetes插件或操作器，用于直接在kubernetes集群的工作节点上创建和管理容器图像的缓存。它允许用户定义图像列表以及那些图像应该被缓存(即，拉取)到哪个工作者节点上。因此，应用程序窗格几乎可以立即启动，因为不需要从注册表中提取图像。kube-friedged提供CRUD APIs来管理图像缓存的生命周期，并支持几个可配置的参数来根据个人需求定制功能。(回购网址:<a class="ae jd" href="https://github.com/senthilrch/kube-fledged" rel="noopener ugc nofollow" target="_blank">https://github.com/senthilrch/kube-fledged</a>)</p><p id="3d58" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博文中，我将解释(I)如何部署kube-成熟的，(ii)配置标志，(iii)在Kubernetes集群中创建容器图像缓存，以及(iv)支持的各种图像缓存操作</p><h1 id="a323" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">先决条件</h1><ul class=""><li id="8f17" class="mf mg jg kf b kg ma kk mb ko mh ks mi kw mj la mk ml mm mn bi translated">一个正在运行的K8s集群。您应该在集群上拥有<em class="lb">集群管理</em>权限来部署kube-friedged</li><li id="3261" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">安装在本地Linux或Mac机器上的kubectl、make和git。</li></ul><h1 id="5c97" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用YAML清单部署kube-fledged</h1><p id="2945" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这些指令使用YAML清单和<a class="ae jd" href="https://hub.docker.com/u/senthilrch" rel="noopener ugc nofollow" target="_blank"> Docker Hub中的预建映像，将kube-friended部署到一个名为“kube-friended”的独立名称空间。</a></p><ul class=""><li id="2398" class="mf mg jg kf b kg kh kk kl ko mt ks mu kw mv la mk ml mm mn bi translated">克隆源代码库</li></ul><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="1f3c" class="nf ld jg nb b gy ng nh l ni nj">mkdir -p $HOME/src/github.com/senthilrch<br/>git clone <a class="ae jd" href="https://github.com/senthilrch/kube-fledged.git" rel="noopener ugc nofollow" target="_blank">https://github.com/senthilrch/kube-fledged.git</a> $HOME/src/github.com/senthilrch/kube-fledged<br/>cd $HOME/src/github.com/senthilrch/kube-fledged</span></pre><ul class=""><li id="39aa" class="mf mg jg kf b kg kh kk kl ko mt ks mu kw mv la mk ml mm mn bi translated">将kube-edged部署到集群</li></ul><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="f0b1" class="nf ld jg nb b gy ng nh l ni nj">make deploy-using-yaml</span></pre><ul class=""><li id="36a3" class="mf mg jg kf b kg kh kk kl ko mt ks mu kw mv la mk ml mm mn bi translated">验证kube-edged是否部署成功</li></ul><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="be99" class="nf ld jg nb b gy ng nh l ni nj">kubectl get pods -n kube-fledged -l app=kubefledged<br/>kubectl get imagecaches -n kube-fledged (Output should be: 'No resources found')</span></pre><p id="ddd1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">kube-成熟的支持部署通过舵图表和舵操作员以及。参考项目(<a class="ae jd" href="https://github.com/senthilrch/kube-fledged" rel="noopener ugc nofollow" target="_blank">https://github.com/senthilrch/kube-fledged</a>)的自述文件，了解使用这些方法进行部署的步骤。</p><h1 id="d452" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">成熟的配置标志</h1><p id="ad02" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">kube-fledged支持几个配置标志，可以用来定制行为。</p><p id="f262" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nk nl nm nb b"><strong class="kf jh">--image-pull-deadline-duration:</strong></code>拉动图像所允许的最大持续时间。在这段时间之后，图像拉取被认为已经失败。默认“5m”</p><p id="c6ce" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nk nl nm nb b"><strong class="kf jh">--image-cache-refresh-frequency:</strong></code>图像缓存会定期刷新，以确保缓存是最新的。将此标志设置为“0s”将禁用刷新。默认“15米”</p><p id="16ae" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nk nl nm nb b"><strong class="kf jh">--image-pull-policy:</strong></code>图像提取策略，用于提取图像并刷新缓存。可能的值为“如果不存在”和“总是”。默认值为“IfNotPresent”(没有or的图像):总是提取“最新”标签</p><p id="9ff6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nk nl nm nb b"><strong class="kf jh">--stderrthreshold:</strong></code>日志级别。默认为信息</p><h1 id="9852" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">创建图像缓存</h1><p id="cdc3" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在群集上创建映像缓存的第一步是确定要缓存的映像列表，以及这些映像应该缓存到哪些节点上。让我们假设您需要:-</p><ul class=""><li id="87ad" class="mf mg jg kf b kg kh kk kl ko mt ks mu kw mv la mk ml mm mn bi translated">缓存图像<code class="fe nk nl nm nb b">quay.io/bitnami/nginx:1.21.1</code>和<code class="fe nk nl nm nb b">quay.io/bitnami/tomcat:10.0.8 </code>到<strong class="kf jh">集群中的所有</strong>节点</li><li id="210e" class="mf mg jg kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">仅将图像<code class="fe nk nl nm nb b">quay.io/bitnami/redis:6.2.5</code>和<code class="fe nk nl nm nb b">quay.io/bitnami/mariadb:10.5.11</code>和<strong class="kf jh">缓存到标签为<code class="fe nk nl nm nb b">tier: backend</code>的节点</strong></li></ul><p id="d151" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个名为<code class="fe nk nl nm nb b">kubefledged-imagecache.yaml</code>的文件，内容如下:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="34f9" class="nf ld jg nb b gy ng nh l ni nj">apiVersion: kubefledged.io/v1alpha2<br/>kind: ImageCache<br/>metadata:<br/> <strong class="nb jh"> </strong># Name of the image cache.<br/>  name: imagecache1<br/>  # The namespace to be used for this image cache.<br/>  namespace: kube-fledged<br/>  labels:<br/>    app: kubefledged<br/>    component: imagecache<br/>spec:<br/>  # The "cacheSpec" field allows a user to define a list of images and onto which worker nodes those images should be cached (i.e. pre-pulled).<br/>  cacheSpec:<br/>  # Specifies a list of images (nginx:1.21.1 and tomcat:10.0.8) with no node selector, hence these images will be cached in all the nodes in the cluster<br/>  - images:<br/>    - quay.io/bitnami/nginx:1.21.1<br/>    - quay.io/bitnami/tomcat:10.0.8<br/>  # Specifies a list of images (redis:6.2.5 and mariadb:10.5.11) with a node selector, hence these images will be cached only on the nodes selected by the node selector<br/>  - images:<br/>    - quay.io/bitnami/redis:6.2.5<br/>    - quay.io/bitnami/mariadb:10.5.11<br/>    nodeSelector:<br/>      tier: backend</span></pre><p id="f3ee" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用kubectl创建图像缓存</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="ca31" class="nf ld jg nb b gy ng nh l ni nj">kubectl create -f kubefledged-imagecache.yaml</span></pre><p id="f8e9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，图像缓存清单被提交给k8s api服务器。api服务器创建一个HTTP POST请求，并将其发送到kubefledged-webhook-server。webhook服务器验证ImageCache资源的内容，并向api服务器返回成功的响应。</p><p id="2083" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，api服务器将ImageCache资源保存在etcd中。kubefledged-controller然后在worker节点上创建几个k8s作业，用于将图像拉入缓存。一个作业负责将一个图像拉入一个节点。所有作业成功完成后，控制器会更新ImageCache资源的状态字段。用户可以查询ImageCache资源并查看状态字段，以了解图像缓存是否创建成功。如果有失败，状态字段还会有错误消息和错误描述，指出失败的原因</p><p id="b0e6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证图像缓存创建的状态</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="91a2" class="nf ld jg nb b gy ng nh l ni nj">kubectl get imagecache imagecache1 -n kube-fledged -o yaml</span></pre><h1 id="56ce" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">修改图像缓存</h1><p id="e591" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">成功创建映像缓存后，可以通过修改映像缓存清单并将其重新提交到群集来对其进行更改。让我们假设您想要从图像缓存中移除图像<code class="fe nk nl nm nb b">quay.io/bitnami/tomcat:10.0.8</code>。</p><p id="e869" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编辑图像缓存清单文件<code class="fe nk nl nm nb b">kubefledged-imagecache.yaml</code>，如下所示:-</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="aa68" class="nf ld jg nb b gy ng nh l ni nj">apiVersion: kubefledged.io/v1alpha2<br/>kind: ImageCache<br/>metadata:<br/> <strong class="nb jh"> </strong># Name of the image cache.<br/>  name: imagecache1<br/>  # The namespace to be used for this image cache.<br/>  namespace: kube-fledged<br/>  labels:<br/>    app: kubefledged<br/>    component: imagecache<br/>spec:<br/>  # The "cacheSpec" field allows a user to define a list of images and onto which worker nodes those images should be cached (i.e. pre-pulled).<br/>  cacheSpec:<br/>  # Specifies a list of images (nginx:1.21.1) with no node selector, hence these images will be cached in all the nodes in the cluster<br/>  - images:<br/>    - quay.io/bitnami/nginx:1.21.1<br/>  # Specifies a list of images (redis:6.2.5 and mariadb:10.5.11) with a node selector, hence these images will be cached only on the nodes selected by the node selector<br/>  - images:<br/>    - quay.io/bitnami/redis:6.2.5<br/>    - quay.io/bitnami/mariadb:10.5.11<br/>    nodeSelector:<br/>      tier: backend</span></pre><p id="6e5d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用kubectl将更改应用到图像缓存</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="205c" class="nf ld jg nb b gy ng nh l ni nj">kubectl apply -f kubefledged-imagecache.yaml</span></pre><p id="53c6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">kubefledged-controller将检测对ImageCache资源的更改，并确定需要从集群上的图像缓存中删除图像<code class="fe nk nl nm nb b">quay.io/bitnami/tomcat:10.0.8 </code>。因此，它创建作业从图像缓存中删除图像。这些操作的结果在ImageCache资源的status字段中更新。</p><p id="e53d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证图像缓存修改的状态</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d215" class="nf ld jg nb b gy ng nh l ni nj">kubectl get imagecache imagecache1 -n kube-fledged -o yaml</span></pre><h1 id="dd2d" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">清除图像缓存</h1><p id="51b2" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">如果您决定从图像缓存中删除所有图像，可以通过提交清除请求来完成。通过使用以下命令注释ImageCache资源来提交清除请求</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="a580" class="nf ld jg nb b gy ng nh l ni nj">kubectl annotate imagecaches imagecache1 -n kube-fledged kubefledged.io/purge-imagecache=</span></pre><p id="8a61" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证清除图像缓存的状态</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="f783" class="nf ld jg nb b gy ng nh l ni nj">kubectl get imagecache imagecache1 -n kube-fledged -o yaml</span></pre><h1 id="246f" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">刷新图像缓存</h1><p id="021d" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">一旦图像缓存被清除，就可以通过提交刷新请求轻松恢复。通过使用以下命令注释ImageCache资源来提交刷新请求</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d214" class="nf ld jg nb b gy ng nh l ni nj">kubectl annotate imagecaches imagecache1 -n kube-fledged kubefledged.io/refresh-imagecache=</span></pre><p id="5f6c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证图像缓存刷新的状态</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0ff8" class="nf ld jg nb b gy ng nh l ni nj">kubectl get imagecache imagecache1 -n kube-fledged -o yaml</span></pre><h1 id="306e" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="d0e0" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在这篇博客中，我解释了如何使用kube-friedged在kubernetes集群上创建容器图像缓存，以及如何对创建的图像缓存执行不同的操作:查看、修改、清除、刷新。前往该项目的github资源库:【https://github.com/senthilrch/kube-fledged T2】</p><p id="c993" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想了解更多关于Kube-fleeded的信息，请阅读我之前的博客<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/kube-fledged-cache-container-images-in-kubernetes-7880a00bab91">Kube-fleeded:在Kubernetes中缓存容器图像</a></p><p id="35f2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">👉我定期在Kubernetes和云原生技术上发微博。 <em class="lb">跟我上</em> <a class="ae jd" href="https://twitter.com/senthilrch" rel="noopener ugc nofollow" target="_blank"> <em class="lb">推特</em> </a> <em class="lb">和</em> <a class="ae jd" href="https://medium.com/@senthilrch" rel="noopener"> <em class="lb">中</em> </a></p></div></div>    
</body>
</html>