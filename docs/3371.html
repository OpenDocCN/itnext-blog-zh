<html>
<head>
<title>Deploy an App on Kubernetes (GKE) with Kong Ingress, LetsEncrypt and Cloudflare.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kong Ingress、LetsEncrypt和Cloudflare在Kubernetes (GKE)上部署一个应用程序。</h1>
<blockquote>原文：<a href="https://itnext.io/deploy-an-app-on-kubernetes-gke-with-kong-ingress-letsencrypt-and-cloudflare-94913e127c2b?source=collection_archive---------1-----------------------#2019-11-30">https://itnext.io/deploy-an-app-on-kubernetes-gke-with-kong-ingress-letsencrypt-and-cloudflare-94913e127c2b?source=collection_archive---------1-----------------------#2019-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84b6a7492de041871f886e498ef832c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zlQFqDU5AOcY0Y9wtIQOEg.jpeg"/></div></div></figure><p id="6f9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有一个小应用程序(希望有几个微服务，前端和后端)，我不建议你使用Kubernetes来部署它们。有更好的全面管理的替代品。但是…</p><p id="baf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你认为你真的需要它，或者你想为别人提供这种服务，那么这个指南将作为蓝本。</p><h2 id="20f2" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">输入、输出和步骤。</h2><p id="6ea1" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们的最终结果将是:在我们的域上提供一个启用了TLS的web应用程序，它足够健壮，可以抵御DDoS攻击。</p><p id="dada" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，Kong Ingress将帮助我们在根路径上提供前端服务，在/api路径上提供后端服务。LetsEncrypt将提供TLS证书，Cloudflare将提供额外的安全性和DNS服务。都托管在GKE的Kubernetes集群上。</p><p id="bf85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(注意:Kong Ingress不是绝对必要的，因为我们只有几个服务，但是，考虑到一旦您走微服务路线，通常会有新服务的内部爆炸，我们可能需要做好准备)</p><p id="956f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们需要:</p><ul class=""><li id="0962" class="lu lv iq ka b kb kc kf kg kj lw kn lx kr ly kv lz ma mb mc bi translated">前端应用程序:为了简单起见，我们将使用next js(<a class="ae md" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/</a>)</li><li id="1c75" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated">后端应用程序:将只解决静态请求。(连接到数据库或任何其他资源超出了本指南的范围)</li><li id="48e6" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated">域名:你可以在谷歌域名(<a class="ae md" href="https://domains.google/" rel="noopener ugc nofollow" target="_blank">https://domains.google/</a>)、云闪(<a class="ae md" href="https://www.cloudflare.com/" rel="noopener ugc nofollow" target="_blank">https://www.cloudflare.com/</a>)或go daddy(<a class="ae md" href="https://www.godaddy.com/" rel="noopener ugc nofollow" target="_blank">https://www.godaddy.com/</a>)上购买一个。我为这个指南选择的是<strong class="ka ir"> outsrc.dev </strong>(在谷歌域名上。谷歌浏览器上的开发域被强制使用TLS)</li><li id="020f" class="lu lv iq ka b kb me kf mf kj mg kn mh kr mi kv lz ma mb mc bi translated">一个谷歌云账户。(<a class="ae md" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/</a>)</li></ul><h2 id="4d5d" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">后端服务</h2><p id="09f3" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们的后端服务非常简单，它不依赖于任何外部依赖。我们只想有几个可以使用的API。</p><p id="1ce4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">/states</code>返回美国各州的列表，只有2个字母的代码。</p><p id="4166" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">/states/&lt;code&gt;</code>返回一个带有州代码和州名的对象</p><p id="bf19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码托管在这里:<a class="ae md" href="https://github.com/ernestofreyreg/outsrc-demo-back" rel="noopener ugc nofollow" target="_blank">https://github.com/ernestofreyreg/outsrc-demo-back</a></p><p id="8fb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是一点点Javascript和最重要的一个<code class="fe mj mk ml mm b">Dockerfile</code></p><h2 id="cd8d" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">前端应用程序</h2><p id="e163" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们的前端应用程序非常简单。只有2页，第一页将从API加载状态列表，第二页将显示状态的详细信息(也来自API)。状态将从后端服务中获取。</p><p id="1768" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">/</code>首页，显示美国各州的链接列表</p><p id="bee7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">/state?state=&lt;code&gt;</code>显示州代码和名称以及一个后退链接。</p><p id="677b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码是用Typescript写的，你可以在这里找到源代码:<a class="ae md" href="https://github.com/ernestofreyreg/outsrc-demo-front" rel="noopener ugc nofollow" target="_blank">https://github.com/ernestofreyreg/outsrc-demo-front</a></p><p id="b353" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，包含一个<code class="fe mj mk ml mm b">Dockerfile</code>,我们希望将这个应用程序作为一个容器。</p><h1 id="d2d2" class="mn kx iq bd ky mo mp mq lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd bi translated">步骤0:创建一个GCP项目。</h1><p id="d4a5" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">前往谷歌云控制台(<a class="ae md" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/</a>)创建一个新项目。(我将我的矿命名为<code class="fe mj mk ml mm b">Outsrc</code>，项目ID为<code class="fe mj mk ml mm b">outsrc</code>)</p><h1 id="6eeb" class="mn kx iq bd ky mo mp mq lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd bi translated">步骤1:为前端和后端构建、标记和推送Docker映像。</h1><p id="522c" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">让我们克隆并构建前端和后端这两个服务。</p><p id="4cc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一前端:</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="70b9" class="kw kx iq mm b gy nm nn l no np">$ git clone <a class="ae md" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:ernestofreyreg/outsrc-demo-front.git<br/>$ cd outsrc-demo-front<br/>$ docker build -t outsrc-demo-front .<br/>$ docker tag outsrc-demo-front:latest gcr.io/outsrc/outsrc-demo-front:1.0.0<br/>$ docker push gcr.io/outsrc/outsrc-demo-front:1.0.0</span></pre><p id="bc70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端:</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="9613" class="kw kx iq mm b gy nm nn l no np">$ git clone <a class="ae md" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:ernestofreyreg/outsrc-demo-back.git<br/>$ cd outsrc-demo-back<br/>$ docker build -t outsrc-demo-back .<br/>$ docker tag outsrc-demo-back:latest gcr.io/outsrc/outsrc-demo-back:1.0.0<br/>$ docker push gcr.io/outsrc/outsrc-demo-back:1.0.0</span></pre><p id="5d91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们完成，我们将有这个在我们的GCP控制台上的容器注册服务。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/e2f0d2174b09fcc37db245b0e2bd4ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rs8AN0qaaGlCV4QXKkpzaw.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">推送我们的2个服务映像后的容器注册表</figcaption></figure><h1 id="55fe" class="mn kx iq bd ky mo mp mq lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd bi translated">步骤2:在GCP上创建一个Kubernetes集群</h1><p id="a7bc" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">为此，我们将使用GCP的托管Kubernetes服务或GKE(谷歌Kubernetes引擎)</p><p id="4c3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GCP控制台-&gt; Kubernetes引擎-&gt;集群-&gt;创建集群</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/54ff144fa5f823475d102de7d774efa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7mKHujqLFs5alN4PNgUew.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">创建我们的Kubernetes集群</figcaption></figure><p id="9857" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用了第一个集群模板(小节点池，适合实验，只是将池大小从1改为3)</p><p id="ecc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建集群需要一些时间。</p><p id="07a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建完成后，我们可以将本地dev box连接到集群，这样我们就可以使用<code class="fe mj mk ml mm b">kubectl</code>命令来控制集群。</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="1b78" class="kw kx iq mm b gy nm nn l no np">$ gcloud container clusters get-credentials outsrc-cluster --zone us-west1-a --project outsrc</span></pre><p id="cc07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查集群节点(应该显示集群中的3个节点)</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="9f36" class="kw kx iq mm b gy nm nn l no np">$ kubectl get nodes<br/>NAME                                      STATUS   ROLES    AGE   VERSION<br/>gke-outsrc-cluster-pool-1-f00215b6-7d0t   Ready    &lt;none&gt;   11h   v1.14.8-gke.12<br/>gke-outsrc-cluster-pool-1-f00215b6-dvvl   Ready    &lt;none&gt;   11h   v1.14.8-gke.12<br/>gke-outsrc-cluster-pool-1-f00215b6-tct2   Ready    &lt;none&gt;   11h   v1.14.8-gke.12</span></pre><h1 id="f395" class="mn kx iq bd ky mo mp mq lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd bi translated">步骤3:在Kubernetes上部署我们的应用程序</h1><p id="51a9" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">要在Kubernetes上部署我们的应用程序，我们需要几样东西:</p><h2 id="be4a" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">步骤3.1命名空间</h2><p id="4aa8" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们的应用将在Kubernetes中共享相同的名称空间。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">outsrc-namespace.yml</figcaption></figure><p id="e8be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用<code class="fe mj mk ml mm b">kubectl apply</code>命令来创建我们所有的Kubernetes工件。</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="1897" class="kw kx iq mm b gy nm nn l no np">$ kubectl apply -f outsrc-namespace.yml<br/>namespace/outsrc created</span><span id="9a66" class="kw kx iq mm b gy ny nn l no np">$ kubectl get namespaces<br/>NAME              STATUS   AGE<br/>default           Active   12m<br/>kube-node-lease   Active   12m<br/>kube-public       Active   12m<br/>kube-system       Active   12m<br/>outsrc            Active   19s</span></pre><p id="9c75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要在所有命令中包含参数<code class="fe mj mk ml mm b">--namespace=outsrc</code>,或者……我们可以:</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="017f" class="kw kx iq mm b gy nm nn l no np">$ kubectl config set-context --current --namespace=outsrc<br/>Context "gke_outsrc_us-west1-a_outsrc-cluster" modified.</span></pre><p id="370a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有后续的<code class="fe mj mk ml mm b">kubectl</code>命令将已经映射到<code class="fe mj mk ml mm b">outsrc</code>名称空间(您可以通过设置<code class="fe mj mk ml mm b">--namespace=...</code>参数来覆盖。</p><h2 id="e7a0" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">步骤3.2:部署</h2><p id="b668" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们的2个服务前端和后端需要部署资源文件。</p><p id="1654" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">outsrc-back-deployment.yml</figcaption></figure><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="f4be" class="kw kx iq mm b gy nm nn l no np">$ kubectl apply -f outsrc-back-deployment.yml<br/>deployment.apps/outsrc-back-deployment created</span></pre><p id="e3c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端:</p><p id="3ad8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端服务需要一个运行时参数:指向后端服务的<code class="fe mj mk ml mm b">API_URL</code>。由于该服务将从<code class="fe mj mk ml mm b">outsrc.dev</code>域访问，那么我们需要指定一个URL +路径，我们将在那里为这个应用程序的后端服务。在这种情况下会有<code class="fe mj mk ml mm b">https://outsrc.dev/api</code></p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">outsrc-front-deployment.yml</figcaption></figure><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="3524" class="kw kx iq mm b gy nm nn l no np">$ kubectl apply -f outsrc-front-deployment.yml<br/>deployment.apps/outsrc-front-deployment created</span></pre><p id="7707" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们创建了两个在集群上运行的服务，每个服务有两个副本。</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="bbb2" class="kw kx iq mm b gy nm nn l no np">$ kubectl get deployments<br/>NAME                      READY   UP-TO-DATE   AVAILABLE   AGE<br/>outsrc-back-deployment    2/2     2            2           11m<br/>outsrc-front-deployment   2/2     2            2           2m48s</span><span id="dbec" class="kw kx iq mm b gy ny nn l no np">$ kubectl get pods<br/>NAME                                       READY   STATUS    RESTARTS   AGE<br/>outsrc-back-deployment-5cbf946975-6tshn    1/1     Running   0          18s<br/>outsrc-back-deployment-5cbf946975-prtqk    1/1     Running   0          11m<br/>outsrc-front-deployment-7995b6bdc4-g9krr   1/1     Running   0          35s<br/>outsrc-front-deployment-7995b6bdc4-mlvk2   1/1     Running   0          2m54s</span></pre><p id="3044" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要检查前端服务日志:</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="e4df" class="kw kx iq mm b gy nm nn l no np">$ kubectl logs -l service=front<br/>&gt; Ready on <a class="ae md" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a><br/>&gt; Ready on http://localhost:3000</span></pre><h2 id="477a" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">步骤3.3:服务</h2><p id="2377" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">服务是一种网络资源，Kubernetes使用它来管理对正在运行的pod的访问。为前端和后端服务创建几个服务资源定义。</p><p id="e8e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">outsrc-front-service.yml</figcaption></figure><p id="3b3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">outsrc-back-service.yml</figcaption></figure><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="9c6b" class="kw kx iq mm b gy nm nn l no np">$ kubectl apply -f outsrc-front-service.yml<br/>service/outsrc-front-service created</span><span id="2528" class="kw kx iq mm b gy ny nn l no np">$ kubectl apply -f outsrc-back-service.yml<br/>service/outsrc-back-service created</span></pre><p id="cd02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的星团目前看起来怎么样？从GCP控制台我们可以看到:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/9e84ac6a3ffcf96848b8d1c2ca1d0945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-4c1RzRJ4O-hVjxVttfJA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">部署我们的前端和后端服务</figcaption></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/05e22e90235f053959ac14cab887e1f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSJYz6CQI8Tabtbrex78YA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">后端和前端服务映射到端口3000</figcaption></figure><h1 id="5a24" class="mn kx iq bd ky mo mp mq lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd bi translated">第四步。安装孔入口</h1><p id="969b" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">一个<strong class="ka ir">入口</strong>是一个允许从Kubernetes集群外部访问您的Kubernetes服务的对象。我们将使用Kong的入口控制器。(<a class="ae md" href="https://konghq.com/solutions/kubernetes-ingress/" rel="noopener ugc nofollow" target="_blank">https://konghq.com/solutions/kubernetes-ingress</a>)即使我们在这个练习中不一定需要它，我还是把它包括进来了，因为它的多功能性和对扩展/插件的支持。</p><p id="9e17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">据其Github回购(<a class="ae md" href="https://github.com/Kong/kubernetes-ingress-controller" rel="noopener ugc nofollow" target="_blank">https://github.com/Kong/kubernetes-ingress-controller</a>):</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="b31f" class="kw kx iq mm b gy nm nn l no np">$ kubectl apply -f <a class="ae md" href="https://bit.ly/k4k8s" rel="noopener ugc nofollow" target="_blank">https://bit.ly/k4k8s</a><br/>namespace/kong created<br/>customresourcedefinition.apiextensions.k8s.io/kongconsumers.configuration.konghq.com created<br/>customresourcedefinition.apiextensions.k8s.io/kongcredentials.configuration.konghq.com created<br/>customresourcedefinition.apiextensions.k8s.io/kongingresses.configuration.konghq.com created<br/>customresourcedefinition.apiextensions.k8s.io/kongplugins.configuration.konghq.com created<br/>serviceaccount/kong-serviceaccount created<br/>clusterrole.rbac.authorization.k8s.io/kong-ingress-clusterrole created<br/>clusterrolebinding.rbac.authorization.k8s.io/kong-ingress-clusterrole-nisa-binding created<br/>configmap/kong-server-blocks created<br/>service/kong-proxy created<br/>service/kong-validation-webhook created<br/>deployment.apps/ingress-kong created</span></pre><p id="5819" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(如果您在安装Kong Ingress控制器时遇到问题，请查看<a class="ae md" href="https://github.com/Kong/kubernetes-ingress-controller/blob/master/docs/deployment/gke.md" rel="noopener ugc nofollow" target="_blank">https://github . com/Kong/kubernetes-Ingress-Controller/blob/master/docs/deployment/gke . MD</a>)</p><p id="be3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦安装了Kong Ingress，将使用公共IP地址创建一个负载平衡器。我们需要这个IP地址进行下一步，DNS。</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="31f4" class="kw kx iq mm b gy nm nn l no np">$ kubectl get service --namespace=kong<br/>NAME                      TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)                      AGE<br/>kong-proxy                LoadBalancer   10.40.12.83   35.212.152.27   80:30435/TCP,443:32312/TCP   72m<br/>kong-validation-webhook   ClusterIP      10.40.9.92    &lt;none&gt;          443/TCP                      72m</span></pre><p id="9083" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以看到<code class="fe mj mk ml mm b">kong-proxy</code>服务上的外部IP地址是:<code class="fe mj mk ml mm b">35.212.152.27</code></p><h1 id="e524" class="mn kx iq bd ky mo mp mq lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd bi translated">步骤5:设置域。</h1><p id="dad9" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我在Google Domains上买了<code class="fe mj mk ml mm b">outsrc.dev</code>域名。您也可以使用您首选的提供商。拥有您的域后，请继续在Cloudflare上注册并添加您的域。您需要使用Cloudflare的DNS设置您的域(您可以在下一张图中看到)</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/595217965f7e58486168e27e782bcaaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbieVMGCLecPllCksmXU8w.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">在Google域上使用Cloudflare的名称服务器</figcaption></figure><p id="0649" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成此步骤后，在Cloudflare DNS服务上创建以下注册表:</p><p id="6f10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一:<code class="fe mj mk ml mm b">proxy.outsrc.dev</code>，A型，指向公有IP: <code class="fe mj mk ml mm b">35.212.152.27</code>。这是唯一需要指向公共IP地址的注册表。所有其他注册管理机构将使用指向<code class="fe mj mk ml mm b">proxy.outsrc.dev</code>的CNAME注册管理机构</p><p id="c0af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二:将部署应用程序的主域:</p><p id="8a05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">outsrc.dev</code>，键入CNAME，指向<code class="fe mj mk ml mm b">proxy.outsrc.dev</code></p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/258757915a358f8e6e77e6778d172133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*acP07MK8DZ_kLUOuUxNuqA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">outsrc.dev的DNS区域</figcaption></figure><p id="3b5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要注意，我们没有在主<code class="fe mj mk ml mm b">outsrc.dev</code>域上激活代理模式。现在我们将只使用Cloudflare的DNS服务。</p><h1 id="9be7" class="mn kx iq bd ky mo mp mq lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd bi translated">步骤6:证书管理器+ LetsEncrypt</h1><p id="10cf" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">CertManager是一个原生的<a class="ae md" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>证书管理控制器。它可以帮助从各种来源发布证书，例如<a class="ae md" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank"> Let's Encrypt </a>、<a class="ae md" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> HashiCorp Vault </a>、<a class="ae md" href="https://www.venafi.com/" rel="noopener ugc nofollow" target="_blank"> Venafi </a>、简单签名密钥对或自签名。</p><p id="03a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将它安装在Kubernetes集群上:(<a class="ae md" href="https://cert-manager.io/docs/installation/kubernetes/" rel="noopener ugc nofollow" target="_blank">https://cert-manager.io/docs/installation/kubernetes/</a>)</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="3449" class="kw kx iq mm b gy nm nn l no np">$ <!-- -->kubectl create namespace cert-manager<br/>namespace/cert-manager created</span><span id="c68c" class="kw kx iq mm b gy ny nn l no np">$ kubectl apply --validate=false -f <a class="ae md" href="https://github.com/jetstack/cert-manager/releases/download/v0.12.0/cert-manager.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/jetstack/cert-manager/releases/download/v0.12.0/cert-manager.yaml</a><br/>customresourcedefinition.apiextensions.k8s.io/certificaterequests.cert-manager.io created<br/>customresourcedefinition.apiextensions.k8s.io/certificates.cert-manager.io created<br/>customresourcedefinition.apiextensions.k8s.io/challenges.acme.cert-manager.io created<br/>customresourcedefinition.apiextensions.k8s.io/clusterissuers.cert-manager.io created<br/>customresourcedefinition.apiextensions.k8s.io/issuers.cert-manager.io created<br/>customresourcedefinition.apiextensions.k8s.io/orders.acme.cert-manager.io created<br/>Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply<br/>namespace/cert-manager configured<br/>serviceaccount/cert-manager-cainjector created<br/>serviceaccount/cert-manager created<br/>serviceaccount/cert-manager-webhook created<br/>clusterrole.rbac.authorization.k8s.io/cert-manager-cainjector created<br/>clusterrolebinding.rbac.authorization.k8s.io/cert-manager-cainjector created<br/>role.rbac.authorization.k8s.io/cert-manager-cainjector:leaderelection created<br/>rolebinding.rbac.authorization.k8s.io/cert-manager-cainjector:leaderelection created<br/>clusterrolebinding.rbac.authorization.k8s.io/cert-manager-webhook:auth-delegator created<br/>rolebinding.rbac.authorization.k8s.io/cert-manager-webhook:webhook-authentication-reader created<br/>clusterrole.rbac.authorization.k8s.io/cert-manager-webhook:webhook-requester created<br/>role.rbac.authorization.k8s.io/cert-manager:leaderelection created<br/>rolebinding.rbac.authorization.k8s.io/cert-manager:leaderelection created<br/>clusterrole.rbac.authorization.k8s.io/cert-manager-controller-issuers created<br/>clusterrole.rbac.authorization.k8s.io/cert-manager-controller-clusterissuers created<br/>clusterrole.rbac.authorization.k8s.io/cert-manager-controller-certificates created<br/>clusterrole.rbac.authorization.k8s.io/cert-manager-controller-orders created<br/>clusterrole.rbac.authorization.k8s.io/cert-manager-controller-challenges created<br/>clusterrole.rbac.authorization.k8s.io/cert-manager-controller-ingress-shim created<br/>clusterrolebinding.rbac.authorization.k8s.io/cert-manager-controller-issuers created<br/>clusterrolebinding.rbac.authorization.k8s.io/cert-manager-controller-clusterissuers created<br/>clusterrolebinding.rbac.authorization.k8s.io/cert-manager-controller-certificates created<br/>clusterrolebinding.rbac.authorization.k8s.io/cert-manager-controller-orders created<br/>clusterrolebinding.rbac.authorization.k8s.io/cert-manager-controller-challenges created<br/>clusterrolebinding.rbac.authorization.k8s.io/cert-manager-controller-ingress-shim created<br/>clusterrole.rbac.authorization.k8s.io/cert-manager-view created<br/>clusterrole.rbac.authorization.k8s.io/cert-manager-edit created<br/>service/cert-manager created<br/>service/cert-manager-webhook created<br/>deployment.apps/cert-manager-cainjector created<br/>deployment.apps/cert-manager created<br/>deployment.apps/cert-manager-webhook created<br/>mutatingwebhookconfiguration.admissionregistration.k8s.io/cert-manager-webhook created<br/>validatingwebhookconfiguration.admissionregistration.k8s.io/cert-manager-webhook created</span></pre><p id="c4da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用CertManager创建ClusterIssuer，这是一个将创建我们需要的证书的对象。在这种情况下使用LetsEncrypt发行者。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">letsencrypt-staging.yml</figcaption></figure><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">letsencrypt-production.yml</figcaption></figure><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="9712" class="kw kx iq mm b gy nm nn l no np">$ kubectl apply -f letsencrypt-staging.yml<br/>clusterissuer.cert-manager.io/letsencrypt-staging created</span><span id="6f52" class="kw kx iq mm b gy ny nn l no np">$ kubectl apply -f letsencrypt-production.yml<br/>clusterissuer.cert-manager.io/letsencrypt-production created</span></pre><p id="0e9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">LetsEncrypt是一个免费的公共服务，必须保护自己不被不公平的使用，所以，如果你正在测试，不确定你的DNS区域配置正确，等等。我建议你使用<code class="fe mj mk ml mm b">letsencrypt-staging</code>发行商。</p><h1 id="d8a3" class="mn kx iq bd ky mo mp mq lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd bi translated">第七步:进入</h1><p id="5ab6" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated"><code class="fe mj mk ml mm b">outsrc.dev</code>应用程序的入口资源定义有几个对我们已经拥有的元素的引用:后端和前端服务，Kong入口，LetsEncrypt产品发布者。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="99c4" class="kw kx iq mm b gy nm nn l no np">$ kubectl apply -f outsrc-dev-ingress.yml<br/>ingress.extensions/outsrc-dev-ingress created</span></pre><p id="1853" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建后，服务将在<code class="fe mj mk ml mm b">http://outsrc.dev</code>立即可用，但TLS可能还没有配置。为域颁发证书需要很短的时间。之后我们得到的是:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/9709679818845b8f2555468814794e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcOrraWaAkqXGe-lbDHj2A.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">有用！！带TLS(感谢LetsEncrypt)</figcaption></figure><p id="e3d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们的应用程序由托管在GKE的Kubernetes集群提供服务，使用Kong Ingress控制器和LetsEncrypt for TLS。最后一步是激活Cloudflare的代理模式。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/845d1bb9161374009c8496d95f43a444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2OqKJ6towg4WXLURW-XQjg.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">我们的主域outsrc.dev代理模式</figcaption></figure><p id="c86e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们在主<code class="fe mj mk ml mm b">outsrc.dev</code>域上设置了代理模式。Cloudflare将提供一个证书，并将所有请求代理给我们的应用程序。实现额外的安全性和DDoS保护。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/e207ef741beb1f55b37cc2fa3da80811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0OJ0h54YFiCxlSvM_WlFA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">代理模式打开时的Cloudflare证书。</figcaption></figure><p id="17a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端服务立即可见，后端不太明显(尽管前端的所有数据都来自后端)，但是也可以测试后端服务:</p><pre class="ne nf ng nh gt ni mm nj nk aw nl bi"><span id="c2bd" class="kw kx iq mm b gy nm nn l no np">$ curl <a class="ae md" href="https://outsrc.dev/api/states/CA" rel="noopener ugc nofollow" target="_blank">https://outsrc.dev/api/states/CA</a><br/>{"state":"CA","name":"California"}</span></pre><h1 id="d1de" class="mn kx iq bd ky mo mp mq lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd bi translated">最后一步:结论</h1><p id="a8d3" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">可以看到，在Kubernetes上部署一个相当简单的应用程序(通过GKE)非常简单。但这并不意味着简单，特别是保护它，这在本指南中没有涉及(只是部分)和维护它(我们将在其他指南中看到如何滚动升级和回滚)</p><p id="0676" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">黑客快乐…</p></div></div>    
</body>
</html>