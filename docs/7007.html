<html>
<head>
<title>RISC-V Instruction-Set Cheatsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RISC-V指令集清单</h1>
<blockquote>原文：<a href="https://itnext.io/risc-v-instruction-set-cheatsheet-70961b4bbe8?source=collection_archive---------0-----------------------#2022-05-15">https://itnext.io/risc-v-instruction-set-cheatsheet-70961b4bbe8?source=collection_archive---------0-----------------------#2022-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3acb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">RISC-V处理器的RV32I基本指令集概述，包括与AVR指令集的比较。</h2></div><p id="9fd8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">许多人已经尝试制作给出RISC-V指令集概述的表格，所以这是我的变体。我试图在有用和易读之间找到平衡。这意味着我已经从这个概述中排除了一些东西。例如，大多数处理立即值的指令都使用<a class="ae ln" href="https://en.wikipedia.org/wiki/Sign_extension" rel="noopener ugc nofollow" target="_blank">符号扩展</a>，我选择不在这个概述中记录。你问什么是符号扩展？</span></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/0c25b64b5488117a960f475f3663155a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K9_qchqCTGRdM_OiaF-Oew.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">许多算术运算都有符号扩展。rd是目的寄存器。rs1和rs1是输入寄存器。imm指的是立即值。imm20是20位立即值，而imm12是12位立即值。</figcaption></figure><p id="5fa5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">计算机只存储带有1和0的二进制数。因此，为了表示负数，我们利用了整数回绕的事实。考虑下图所示的经典机械计数器。如果上面写着9999，那么在上面加4会得到什么？它给出的数字是0003，因为数字是环绕的。本质上，9999的行为就好像它是-1。上面写着9998，你加了4？那么结果将是0002，因此9998的行为就好像它是-2。因此，我们可以使用高数值来表示负数。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi me"><img src="../Images/cb67dcdc00b255c397db6086dcae4495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xVQfWyTumbT1NI9ITuZXA.jpeg"/></div></div></figure><p id="fe08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数字计算机的工作原理大同小异。因此，一旦达到最大值，二进制数就会回绕。处理这个问题时，一个复杂的因素是-1、-2、-3等等的构成取决于所用的位数。在十进制系统中，如果你只能用一位数表示数字，那么9代表-1，8代表-2，而如果你有两位数，那么99代表-1，98代表-2，97代表-3，依此类推。</p><p id="6f28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样的事情也适用于二进制数。十进制数字的符号扩展意味着，如果数字是负数，则每次添加数字时都要添加9作为第一个数字。因此，如果9代表一个有符号的数字，那么09将不起作用，因为它将是一个正数。你必须把它变成99。对于二进制数，检查第一个数字是否是1，然后在添加位时在前面加上1。符号扩展甚至适用于逻辑运算，如<code class="fe mf mg mh mi b">AND</code>和<code class="fe mf mg mh mi b">OR</code>。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mj"><img src="../Images/923d2c7d3349e7a10f81fd4ea6cdc94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BQoFgbIF87viTLHqR6d_A.png"/></div></div></figure><p id="1188" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会注意到，每条指令都标有R、I和u等类型，这说明了指令是如何在32位字中编码的。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mk"><img src="../Images/fd8557e98326a43c40ddb8b37371a724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mznpgo4kFWIayagpftLmTg.png"/></div></div></figure><p id="ef7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在RISC处理器中，对内存的访问只能通过特殊的加载和存储指令来完成。这些指令有多种变体，能够加载不同位大小的值。只有RV64I支持<code class="fe mf mg mh mi b">LD</code>(加载双字)，因为它加载64位值。一个字指的是一个32位的值，所以<code class="fe mf mg mh mi b">LW</code>可以用来加载一个常规的32位整数。在处理字符串时，你可能想通过使用<code class="fe mf mg mh mi b">LB</code>来加载单个字节。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mj"><img src="../Images/e618896d0def80c752f076308bbca7a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EAp2eigMdoY-44wOIScz6w.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><em class="ml"> mem </em>将系统内存表示为一个数组。</figcaption></figure><p id="b550" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RISC-V上的分支和跳转是由非常通用的<code class="fe mf mg mh mi b">JAL</code>和<code class="fe mf mg mh mi b">JALR</code>指令完成的。与其他流行的架构相比，RISC-V上的条件分支是不同的。因为RISC-V处理器没有状态寄存器，所以我们在条件指令本身中提供了比较寄存器。因此，如果寄存器<code class="fe mf mg mh mi b">x4</code>和<code class="fe mf mg mh mi b">x6</code>相等，则<code class="fe mf mg mh mi b">BEQ x4, x6, foo</code>跳转到标签<code class="fe mf mg mh mi b">foo</code>。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mm"><img src="../Images/453047209c1068b683b39b06055d9023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVqoi2jj6GjounRAhm4xxg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">PC代表程序计数器(程序的当前位置)</figcaption></figure><p id="8293" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于这张表，需要指出的另一件有用的事情是伪指令。它们不是RISC-V处理器支持的真正指令。相反，它们只是编写其他指令的便捷方式。例如，如果我想把一个寄存器的值从<code class="fe mf mg mh mi b">x3</code>移动到<code class="fe mf mg mh mi b">x4</code>，如果RISC-V有一个移动指令就好了。<code class="fe mf mg mh mi b">MV x4, x3</code>会实现这一点，只不过它并不真正存在。为什么？因为同样可以通过以下方式实现:</p><pre class="lp lq lr ls gt mn mi mo mp aw mq bi"><span id="8120" class="mr ms it mi b gy mt mu l mv mw">ADDI x4, x3, 0  # x4 ← x3 + 0</span></pre><p id="ac20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着您可以避免将<code class="fe mf mg mh mi b">MV</code>指令的编码添加到指令集架构(ISA)中。</p><p id="55c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">伪指令好处的一个很好的例子是<code class="fe mf mg mh mi b">LI</code>和<code class="fe mf mg mh mi b">LA</code>指令。因为所有RISC-V指令都必须是32位宽，所以它们不能包含完整的32位地址。因此，将32位地址载入寄存器必须分两步完成。首先，我们用<code class="fe mf mg mh mi b">LUI</code>或<code class="fe mf mg mh mi b">AUIP</code>加载前20位，然后用<code class="fe mf mg mh mi b">ADDI</code>添加剩余的12位。</p><pre class="lp lq lr ls gt mn mi mo mp aw mq bi"><span id="cf16" class="mr ms it mi b gy mt mu l mv mw">.section .text             # Mark code section</span><span id="669f" class="mr ms it mi b gy mx mu l mv mw">  LUI  a1,     %hi(msg)    # Load upper 20 bits of msg address<br/>  ADDI a1, a1, %lo(msg)    # Load lower 12 bits of msg address<br/>  CALL puts                # Call puts function to show string</span><span id="52ce" class="mr ms it mi b gy mx mu l mv mw">loop:<br/>  J loop                   # Jump to loop - Infinite loop</span><span id="3a0d" class="mr ms it mi b gy mx mu l mv mw">.section .data             # Mark section for R/W data storage</span><span id="9e46" class="mr ms it mi b gy mx mu l mv mw">  msg: <!-- -->.string "Hello World\n"</span></pre><p id="0506" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建可以加载到任何内存地址的代码(位置无关代码)，我们使用了翻译成<code class="fe mf mg mh mi b">AUIP</code>和<code class="fe mf mg mh mi b">ADDI</code>的<code class="fe mf mg mh mi b">LA</code>指令。</p><p id="b583" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">阅读更多:<a class="ae ln" href="https://michaeljclark.github.io/asm.html" rel="noopener ugc nofollow" target="_blank"> RISC-V汇编程序参考</a></p><p id="8ce8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用伪指令，我们大大简化了这段代码:</p><pre class="lp lq lr ls gt mn mi mo mp aw mq bi"><span id="8bbb" class="mr ms it mi b gy mt mu l mv mw">.section .text             # Mark code section</span><span id="8d6e" class="mr ms it mi b gy mx mu l mv mw">  LI a1, msg               # Load immediate. Julia expands to <br/>                           # multiple instructions as needed.</span><span id="18aa" class="mr ms it mi b gy mx mu l mv mw">  CALL puts                # Call puts function to show string</span><span id="b75f" class="mr ms it mi b gy mx mu l mv mw">loop:<br/>  J loop                   # Jump to loop - Infinite loop</span><span id="6528" class="mr ms it mi b gy mx mu l mv mw">.section .data             # Mark section for R/W data storage</span><span id="f0f5" class="mr ms it mi b gy mx mu l mv mw">msg: <!-- -->.string "Hello World\n"</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi my"><img src="../Images/8c8ff5f8c4f50355f91927d5c3c26c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpvcmFDtJgmYJobpDSwRZw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">零对应于寄存器x0，它总是保存值0。</figcaption></figure><p id="3eb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以看到有些指令是重复的，比如<code class="fe mf mg mh mi b">LI</code>(立即加载)和<code class="fe mf mg mh mi b">CALL</code>。原因是根据上下文，这些伪指令可以产生各种不同的RISC-V指令。如果提供给<code class="fe mf mg mh mi b">LI</code>的立即值在12位有符号值的范围内，那么它将产生一个<code class="fe mf mg mh mi b">ADDI</code>指令。如果它更大，将增加一个额外的<code class="fe mf mg mh mi b">LUI</code>(立即加载上部)。甚至编译器标志也会影响结果。这在<code class="fe mf mg mh mi b">LA</code>(加载地址)示例中显示。它使用<code class="fe mf mg mh mi b">AUIPC</code>(将上位立即数添加到PC)给出位置独立代码。否则将使用<code class="fe mf mg mh mi b">LUI</code>。</p><p id="4df5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据大众的要求，我将所有这些表格制作成两个不同的用于RISC-V的pdf，并与AVR指令集进行了比较。</p><ul class=""><li id="1cd0" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated"><a class="ae ln" href="http://blog.translusion.com/images/posts/RISC-V-cheatsheet-RV32I-4-3.pdf" rel="noopener ugc nofollow" target="_blank"> RISC-V指令备忘单PDF </a></li><li id="d329" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="http://blog.translusion.com/images/posts/RISC-V-vs-AVR-cheatsheet.pdf" rel="noopener ugc nofollow" target="_blank"> AVR和RISC-V指令对比PDF </a></li></ul><h1 id="43dd" class="nn ms it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">AVR与RISC-V的比较</h1><p id="da2e" class="pw-post-body-paragraph ki kj it kk b kl oe ju kn ko of jx kq kr og kt ku kv oh kx ky kz oi lb lc ld im bi translated">我打算写一个更深入的AVR和RISC-V的比较，但这里是一个比较AVR和RISC-V指令的尝试。指令集完全不同，遵循它们自己的逻辑，这使得任何简单的比较都有缺陷。</p><p id="740f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，对于RISC-V，每个寄存器都可以以相同的方式使用，而对于AVR，一些寄存器具有特殊的用途，这在比较中没有准确地传达。</p><p id="7d5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个问题是AVR通常使用16位地址，而RISC-V使用32位地址。AVR和RISC-V对它们的寄存器使用不同的命名方案和约定。我在这里使用RISC-V命名约定，这对于AVR来说并不理想。</p><p id="9733" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">支持的算术运算非常相似。一个明显的区别是RISC-V没有<code class="fe mf mg mh mi b">SUBI</code>指令。相反，您可以使用带有负立即值的<code class="fe mf mg mh mi b">ADDI</code>。有趣的是，AVR已经交换了这一点，没有<code class="fe mf mg mh mi b">ADDI</code>。相反，AVR有一个<code class="fe mf mg mh mi b">SUBI</code>，这意味着如果你想增加一个即时值，你需要减去一个负值。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oj"><img src="../Images/2cedff497e1df27fec9e5e21c44e5518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGTXdvqd4oucuEbJYHmofg.png"/></div></div></figure><p id="be9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，立即值的可用位数也有所不同。对于AVR，我们通常只有8位，而RISC-V可以根据指令使用12或20位立即值。</p><p id="3832" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逻辑运算则截然不同。AVR一次只能移动一位，而RISC-V可以向左或向右移动任意数量的位。另一个很大的区别是AVR上的旋转操作使用进位状态标志。RISC-V不能这样做，因为它没有状态标志。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oj"><img src="../Images/0e46113c25898f05fbdaa04fadbb11f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f50RuF9IRqgzCatWIpXCuw.png"/></div></div></figure><p id="5c11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AVR和RISC-V在寄存器和内存之间加载和存储数据的方法也大不相同。RISC-V加载和存储指令非常有规律。源地址是通过将寄存器的内容与立即值相结合来计算的。相比之下，AVR在负载方面有很多变化:</p><ul class=""><li id="b9db" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated">间接加载—从存储在X、Y或Z寄存器(最后六个寄存器的实际对)中的存储器地址加载。</li><li id="a712" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">带位移加载— LDD类似于RISC-V加载指令的工作方式。它使用位移和寄存器来计算源地址。</li><li id="59ec" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">后递增或前递减AVR上的许多加载和存储指令会在加载数据之前或之后递增或递减X、Y或Z寄存器。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oj"><img src="../Images/d7bf3ed8f3f68c85b46f7ed026963f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pn0xWcgEGv7m4MS40IPtmQ.png"/></div></div></figure><p id="f658" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AVR使用状态寄存器，而RISC-V不使用，这导致条件分支指令非常不同。RISC-V上所有的无条件分支都是只用两条指令<code class="fe mf mg mh mi b">JAL</code>和<code class="fe mf mg mh mi b">JALR</code>完成的，而AVR有<code class="fe mf mg mh mi b">JMP</code>、<code class="fe mf mg mh mi b">IJMP</code>、<code class="fe mf mg mh mi b">CALL</code>、<code class="fe mf mg mh mi b">RCALL</code>、<code class="fe mf mg mh mi b">ICALL</code>、<code class="fe mf mg mh mi b">RET</code>等几条这里没有列出。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ok"><img src="../Images/dc760b399fd615e87813bdb39aee9ee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PvsPCyYPc9JNxk8hx2zFuQ.png"/></div></div></figure><p id="6dc8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个比较中，我指出了JAL和JALR，但人们自然会在RISC-V上使用伪指令，如<code class="fe mf mg mh mi b">J</code>(跳转)<code class="fe mf mg mh mi b">CALL</code>、<code class="fe mf mg mh mi b">RET</code>和<code class="fe mf mg mh mi b">TAIL</code>(跳转而不存储返回地址)</p><p id="6f4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AVR有一些你必须知道的边缘情况。例如，某些指令仅适用于寄存器R16至R31。其他的只在X，Y，Z寄存器上工作。这里还有更多我没有涉及到的说明。所以我建议你看看官方文档:<a class="ae ln" href="http://www.mmajunke.de/doc0856.pdf" rel="noopener ugc nofollow" target="_blank"> AVR指令集</a></p><h1 id="aadc" class="nn ms it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">相关故事</h1><p id="be87" class="pw-post-body-paragraph ki kj it kk b kl oe ju kn ko of jx kq kr og kt ku kv oh kx ky kz oi lb lc ld im bi translated">我写过的关于RISC-V和AVR编程或硬件的其他故事:</p><ul class=""><li id="87c5" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated"><a class="ae ln" href="https://medium.com/swlh/risc-v-assembly-for-beginners-387c6cd02c49" rel="noopener">面向初学者的RISC-V汇编语言</a> —假设您是汇编编程新手。</li><li id="6d05" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="https://erik-engheim.medium.com/risc-v-assembly-code-examples-7bca0e7ebaa3" rel="noopener"> RISC-V汇编代码示例</a> —微小而简单的RISC-V代码示例。</li><li id="2f1f" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="http://blog.translusion.com/posts/avr_without_arduino/" rel="noopener ugc nofollow" target="_blank">AVR编程入门</a> —关于超越Arduino，直接编程AVR芯片。介绍程序员、保险丝计算器、AVRdude和ATiny13芯片(仅8个引脚)。</li><li id="e12b" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="http://blog.translusion.com/posts/avrassembly/" rel="noopener ugc nofollow" target="_blank">Mac OS X上的AVR汇编编程</a> —在Mac OS上设置汇编编程。这篇文章需要更新。</li><li id="f93e" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="http://blog.translusion.com/posts/avrdevboard/" rel="noopener ugc nofollow" target="_blank">8针AVR微控制器开发板</a>——我做的一个小项目，可以对13个AVR芯片进行编程和测试。这些很酷的小集成电路只有8个引脚。</li><li id="9a33" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="http://blog.translusion.com/posts/debugavrproject/" rel="noopener ugc nofollow" target="_blank">调试AVR项目</a> —分享您在开始AVR编程之旅时容易出错的地方的经验。</li></ul><p id="e9b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对微处理器更普遍的兴趣:</p><ul class=""><li id="20c0" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated"><a class="ae ln" href="https://erik-engheim.medium.com/what-the-heck-is-a-micro-operation-e991f76209e" rel="noopener">微操作到底是个什么鬼？</a> —微操作是讨论现代RISC和CISC处理器时经常弹出的概念。这个故事揭秘了什么是微操作。</li><li id="1205" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="https://erik-engheim.medium.com/microprocessor-pipelining-f63df4ee60cf" rel="noopener">为什么要流水线一个微处理器？</a> — RISC处理器率先使用指令流水线。它们是什么？为什么它们对提高性能有用？</li><li id="85ae" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="https://medium.com/swlh/what-does-risc-and-cisc-mean-in-2020-7b4d42c9a9de" rel="noopener">2020年的RISC和CISC意味着什么？</a>—RISC和CISC设计的历史比较，以及它们的趋同性和仍然存在的差异。</li><li id="af2c" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="https://medium.com/swlh/risc-v-vector-instructions-vs-arm-and-x86-simd-8c9b17963a31" rel="noopener"> RISC-V矢量指令vs ARM和x86 SIMD </a> —重点比较打包SIMD和矢量SIMD指令以及它们存在的原因。</li><li id="1a55" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">ARMv9:有什么大不了的？ —详细介绍添加到ARMv9架构中的SVE2矢量SIMD指令集。</li><li id="e329" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="https://erik-engheim.medium.com/the-genius-of-risc-v-microprocessors-b19d735abaa6" rel="noopener">RISC-V微处理器的天才</a>——与SIMD无关，而是关于RISC-V内核中的指令压缩和宏操作融合。</li><li id="4934" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="https://erik-engheim.medium.com/vector-processing-on-cpus-and-gpus-compared-b1fab24343e6" rel="noopener">CPU和GPU上的矢量处理比较</a> —比较和探索实现数据并行的不同方式。</li><li id="3232" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae ln" href="https://debugger.medium.com/why-is-apples-m1-chip-so-fast-3262b158cba2" rel="noopener">为什么苹果的M1芯片这么快？</a> —与讨论RISC和CISC处理器相关，因为这涉及到M1是RISC教授这一事实如何在解释它为什么表现如此出色方面发挥了重要作用。</li></ul></div></div>    
</body>
</html>