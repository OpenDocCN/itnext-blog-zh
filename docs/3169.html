<html>
<head>
<title>Unit Testing a Jenkins Shared Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jenkins共享库的单元测试</h1>
<blockquote>原文：<a href="https://itnext.io/unit-testing-a-jenkins-shared-library-9bfb6b599748?source=collection_archive---------0-----------------------#2019-10-16">https://itnext.io/unit-testing-a-jenkins-shared-library-9bfb6b599748?source=collection_archive---------0-----------------------#2019-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e647" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Jenkins共享库系列文章的第三部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9746f5e21ebee43ceaaaf97de40026bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xY4qH6IqSRQ7SJnVJDDZw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">【https://jenkins.io/ T4】</figcaption></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="1b2b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在我的Jenkins共享库系列的第二部分中，我们构建了自己的Jenkins共享库，将其加载到Jenkins中，并在管道中运行。在这一部分，我们将和<a class="ae kv" href="https://github.com/homeaway/jenkins-spock" rel="noopener ugc nofollow" target="_blank"> Jenkins-Spock </a>一起演练如何为你的共享库编写单元测试</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="7e13" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在本教程中，我们将利用一个名为<a class="ae kv" href="https://github.com/homeaway/jenkins-spock" rel="noopener ugc nofollow" target="_blank"> Jenkins-Spock </a>的测试框架。Jenkins Spock建立在Spock测试框架之上，并提供了一个模拟Jenkins环境来模拟Jenkins，而无需实际拥有Jenkins实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0bc5" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">上面的视频是本库作者奥斯汀·威特(Github上的<a class="ae kv" href="https://github.com/awittha" rel="noopener ugc nofollow" target="_blank"> @awittha </a>)给出的詹金斯-斯波克的奇幻演示。我强烈建议在继续之前观看它。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="c7d4" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">先决条件</h1><p id="d56c" class="pw-post-body-paragraph ld le iq lf b lg mt jr li lj mu ju ll lm mv lo lp lq mw ls lt lu mx lw lx ly ij bi translated">本教程要求我们安装了Maven和Groovy。</p><ul class=""><li id="40a3" class="my mz iq lf b lg lh lj lk lm na lq nb lu nc ly nd ne nf ng bi translated">玛文—<a class="ae kv" href="https://maven.apache.org/install.html" rel="noopener ugc nofollow" target="_blank">https://maven.apache.org/install.html</a></li><li id="362a" class="my mz iq lf b lg nh lj ni lm nj lq nk lu nl ly nd ne nf ng bi translated">groovy—<a class="ae kv" href="http://groovy-lang.org/install.html" rel="noopener ugc nofollow" target="_blank">http://groovy-lang.org/install.html</a></li></ul></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="3ad5" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">入门指南</h1><p id="a0bf" class="pw-post-body-paragraph ld le iq lf b lg mt jr li lj mu ju ll lm mv lo lp lq mw ls lt lu mx lw lx ly ij bi translated">我们将基于我们在本系列第二部分中构建的共享库来编写本教程。如果您完成了该教程，您将能够继续使用相同的代码库。如果没有，你可以回到<a class="ae kv" href="https://medium.com/@werne2j/how-to-build-your-own-jenkins-shared-library-9dc129db260c" rel="noopener">第二部分</a>或者你可以从<a class="ae kv" href="https://github.com/werne2j/jenkins-shared-library" rel="noopener ugc nofollow" target="_blank">https://github.com/werne2j/jenkins-shared-library</a>克隆共享库。</p><p id="1d24" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在写测试之前，我们要做一些设置。我们将在项目的根目录下创建一个<code class="fe nm nn no np b">test</code>目录。在这个目录中，我们将有一个<code class="fe nm nn no np b">vars</code>和<code class="fe nm nn no np b">resources</code>目录。</p><p id="330c" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这可以通过在项目的根目录下运行<code class="fe nm nn no np b">mkdir -p test/{vars, resources}</code>来完成。项目的结构应该如下所示:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="7a12" class="nu mc iq np b gy nv nw l nx ny">├── jenkins-shared-library<br/>│   ├── src<br/>│   │   ├── org<br/>│   │   │   ├── example<br/>│   │   │   │   ├── Constants.groovy<br/>│   ├── test<br/>│   │   ├── resources<br/>│   │   ├── vars<br/>│   ├── vars<br/>│   │   ├── buildJavascriptApp.groovy<br/>│   │   ├── notify.groovy</span></pre><p id="13b3" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">因为Jenkins-Spock要求我们使用Maven，所以我们需要一个<code class="fe nm nn no np b">pom.xml</code>文件来列出我们的依赖项和插件。我们将在项目的根目录中执行此操作，并粘贴以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz ma l"/></div></figure><p id="cbc3" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我不打算深入讨论<code class="fe nm nn no np b">pom.xml</code>，但有几点:</p><ul class=""><li id="30f1" class="my mz iq lf b lg lh lj lk lm na lq nb lu nc ly nd ne nf ng bi translated">包括我们所有的依赖，如詹金斯-斯波克</li><li id="a364" class="my mz iq lf b lg nh lj ni lm nj lq nk lu nl ly nd ne nf ng bi translated">包括Jenkins插件以及执行我们测试的<code class="fe nm nn no np b">test</code>命令的配置</li><li id="31e4" class="my mz iq lf b lg nh lj ni lm nj lq nk lu nl ly nd ne nf ng bi translated">我们正在用<code class="fe nm nn no np b">sources</code>标签设置我们希望测试在<code class="fe nm nn no np b">gmavenplus</code>插件中的位置</li><li id="ab21" class="my mz iq lf b lg nh lj ni lm nj lq nk lu nl ly nd ne nf ng bi translated">如果您想了解更多关于<code class="fe nm nn no np b">pom.xml</code>的信息，maven在这里提供了一个很好的资源—<a class="ae kv" href="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html" rel="noopener ugc nofollow" target="_blank">Pom简介</a></li></ul></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="064d" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">写作测试</h1><p id="205b" class="pw-post-body-paragraph ld le iq lf b lg mt jr li lj mu ju ll lm mv lo lp lq mw ls lt lu mx lw lx ly ij bi translated">在我们的共享库中，有两个全局变量，<code class="fe nm nn no np b">buildJavascriptApp</code>和<code class="fe nm nn no np b">notify</code>。我们将演练如何为每个变量编写测试。</p><p id="805f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">先说<code class="fe nm nn no np b">buildJavascriptApp</code>。如果你记得，这个变量是一个完整的管道，它安装依赖项，运行测试，然后发布应用程序。该变量的代码如下所示:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="4f97" class="nu mc iq np b gy nv nw l nx ny">def call(Map config=[:], Closure body={}) {<br/>  node {<br/>    git url: "<a class="ae kv" href="https://github.com/werne2j/sample-nodejs" rel="noopener ugc nofollow" target="_blank">https://github.com/werne2j/sample-nodejs</a>"</span><span id="02a6" class="nu mc iq np b gy oa nw l nx ny">    stage("Install") {<br/>      sh "npm install"<br/>    }</span><span id="32ec" class="nu mc iq np b gy oa nw l nx ny">    stage("Test") {<br/>      sh "npm test"<br/>    }</span><span id="fde0" class="nu mc iq np b gy oa nw l nx ny">    stage("Deploy") {<br/>      if (config.deploy) {<br/>        sh "npm publish"<br/>      }<br/>    }</span><span id="9608" class="nu mc iq np b gy oa nw l nx ny">    body()<br/>  }<br/>}</span></pre><p id="2749" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这条管道的主要逻辑是决定是否运行<code class="fe nm nn no np b">npm publish</code>命令，然后调用传递给变量的闭包。</p><p id="9ac5" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">考虑到这一点，我看到了三种不同的测试。</p><ol class=""><li id="57e2" class="my mz iq lf b lg lh lj lk lm na lq nb lu nc ly ob ne nf ng bi translated">如果部署为真，将运行npm发布</li><li id="6c6e" class="my mz iq lf b lg nh lj ni lm nj lq nk lu nl ly ob ne nf ng bi translated">如果部署为假，将不运行npm发布</li><li id="58aa" class="my mz iq lf b lg nh lj ni lm nj lq nk lu nl ly ob ne nf ng bi translated">如果向变量传递了一个闭包，将调用closure</li></ol><p id="0d88" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">首先，我们将创建我们的测试文件。使用您喜欢的编辑器，在<code class="fe nm nn no np b">test/vars</code>目录中创建一个名为<code class="fe nm nn no np b">BuildJavascriptApp.groovy</code>的文件。测试将会是一个扩展来自Jenkins-Spock的<code class="fe nm nn no np b">JenkinsPipelineSpecification</code>的类。</p><p id="616c" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们测试的外壳将看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz ma l"/></div></figure><p id="f6a1" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">第一行代码导入了为我们提供模拟Jenkins环境的<code class="fe nm nn no np b">JenkinsPipelineSpecification</code>类。该测试是一个扩展了<code class="fe nm nn no np b">JenkinsPipelineSpecification</code>的类，它被命名为<code class="fe nm nn no np b">BuildJavascriptAppSpec</code>,遵循Groovy和Jenkins-Spock的命名约定。</p><p id="1e7f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在测试中，我们将创建一个名为<code class="fe nm nn no np b">buildJavascriptApp</code>的变量，并使用它来加载我们的管道。</p><p id="4ded" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">接下来我们看到的是一个叫做<code class="fe nm nn no np b">setup</code>的方法。这是一个在我们每次测试之前运行的<a class="ae kv" href="http://spockframework.org/spock/docs/1.3/all_in_one.html#_fixture_methods" rel="noopener ugc nofollow" target="_blank"> Spock夹具方法</a>。我们将使用这个fixture方法来加载变量。为此，我们使用来自詹金斯-斯波克的方法<code class="fe nm nn no np b">loadPipelineScriptForTest</code>。在这一点上，我们有一个变量，<code class="fe nm nn no np b">buildJavascriptApp</code>，我们已经将它分配给我们的管道变量，准备进行测试。</p><p id="2c4c" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">继续我们的测试。我们有前面列出的三个测试场景。我们使用<code class="fe nm nn no np b">def</code>关键字来表示测试定义的开始。我们使用格式<code class="fe nm nn no np b">[variable] will do something</code>来描述我们的测试，这使得组织我们的测试更加容易。你可以在这里阅读更多关于测试结构的信息。</p><p id="5e4b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">下一步是向我们的测试中添加逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz ma l"/></div></figure><p id="6910" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这里发生了一些事情，我会尽我最大的努力去打破它。</p><p id="2aa0" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在第一次测试中，我们使用了<code class="fe nm nn no np b"><a class="ae kv" href="http://spockframework.org/spock/docs/1.3/all_in_one.html#_when_and_then_blocks" rel="noopener ugc nofollow" target="_blank">when</a></code>和<code class="fe nm nn no np b"><a class="ae kv" href="http://spockframework.org/spock/docs/1.3/all_in_one.html#_when_and_then_blocks" rel="noopener ugc nofollow" target="_blank">then</a></code>模块。<code class="fe nm nn no np b">when</code>块用于调用我们正在测试的变量。在这个例子中，我们正在测试如果deploy为真，那么<code class="fe nm nn no np b">buildJavascriptApp</code>运行<code class="fe nm nn no np b">npm install</code>，所以在<code class="fe nm nn no np b">when</code>块中我们有<code class="fe nm nn no np b">buildJavascriptApp deploy: true</code>。如果我们在一个真实的Jenkinsfile中调用这个变量，就会得到这个结果。</p><p id="2d01" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在<code class="fe nm nn no np b">then</code>块中，我们处理交互、条件和表达式。对于我们检查<code class="fe nm nn no np b">npm install</code>是否被调用的例子，我们可以使用<a class="ae kv" href="http://spockframework.org/spock/docs/1.3/all_in_one.html#_interactions_2" rel="noopener ugc nofollow" target="_blank"> Spock交互</a>。在我们街区我们看到了<code class="fe nm nn no np b">1 * getPipelineMock(“sh”)(“npm publish”)</code>。这就是说“我们期望用<code class="fe nm nn no np b">npm publish</code>作为参数来调用<code class="fe nm nn no np b">sh</code>。如果<code class="fe nm nn no np b">npm publish</code>没有被调用，这个交互将失败，因为它应该被调用一次。</p><p id="ba4b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们的第二次测试几乎完全相同。唯一的区别是我们将<code class="fe nm nn no np b">deploy: false</code>传递给<code class="fe nm nn no np b">buildJavascriptApp</code>，然后检查<code class="fe nm nn no np b">npm deploy</code>是否被调用。</p><p id="8045" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">希望这开始有意义了。</p><p id="b02b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">最后一个测试引入了一个新的概念叫做“<a class="ae kv" href="http://spockframework.org/spock/docs/1.3/all_in_one.html#_mocking" rel="noopener ugc nofollow" target="_blank">嘲讽</a>”。我们模仿传递给变量的闭包，这样我们就可以检查它是否被调用，就像我们对<code class="fe nm nn no np b">sh</code>步骤所做的那样。在<code class="fe nm nn no np b">then</code>块中，我们可以写<code class="fe nm nn no np b">1 * body()</code>，也就是说我们希望模拟闭包只被调用一次。</p><p id="6adb" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们已经完成了第一个测试文件！现在是运行测试的时候了！</p><p id="6c54" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">转到您的终端，从项目的根目录运行<code class="fe nm nn no np b">mvn clean test</code>。</p><p id="0670" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们得到一个错误！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/791d8e916ec7d7b9ce5e4437fd693e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZVHAsZY7jwa7Yphh2235g.png"/></div></div></figure><p id="73d1" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们得到这样的错误时，这意味着我们有一个没有被嘲笑的管道步骤。所以看起来我们需要将这些缺失的插件添加到我们的<code class="fe nm nn no np b">pom.xml</code>中。</p><p id="604d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">添加:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="5c3f" class="nu mc iq np b gy nv nw l nx ny">&lt;dependencies&gt;<br/>...<br/>  &lt;dependency&gt;<br/>    &lt;!-- provides sh() step --&gt;<br/>    &lt;groupId&gt;org.jenkins-ci.plugins.workflow&lt;/groupId&gt;<br/>    &lt;artifactId&gt;workflow-durable-task-step&lt;/artifactId&gt;<br/>    &lt;version&gt;2.21&lt;/version&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>  &lt;/dependency&gt;<br/>  &lt;dependency&gt;<br/>    &lt;!-- provides stage() step --&gt;<br/>    &lt;groupId&gt;org.jenkins-ci.plugins&lt;/groupId&gt;<br/>    &lt;artifactId&gt;pipeline-stage-step&lt;/artifactId&gt;<br/>    &lt;version&gt;2.3&lt;/version&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>    &lt;/dependency&gt;<br/>  &lt;dependency&gt;<br/>    &lt;!-- provides git() step --&gt;<br/>    &lt;groupId&gt;org.jenkins-ci.plugins&lt;/groupId&gt;<br/>    &lt;artifactId&gt;git&lt;/artifactId&gt;<br/>    &lt;version&gt;3.9.1&lt;/version&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>  &lt;/dependency&gt;<br/>...<br/>&lt;/dependencies&gt;</span></pre><p id="37ff" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">正如我们在这里看到的，我们正在添加<code class="fe nm nn no np b">sh</code>、<code class="fe nm nn no np b">stage</code>和<code class="fe nm nn no np b">git</code>管道步骤所需的插件。</p><p id="55fa" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">将这些添加到pom.xml中的<code class="fe nm nn no np b">org.jenkins-ci.plugins.workflow </code>依赖标签之后。<code class="fe nm nn no np b">pom.xml</code>现在应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz ma l"/></div></figure><p id="9a61" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在，您可以再次尝试运行您的测试。</p><p id="83d1" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果你看到这样的东西:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/f038b8002bacdd4f7bbb4b8a9fa9c8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWnRDc-nhebpyFDagkSo9A.png"/></div></div></figure><p id="48ff" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">恭喜你！我们的测试通过了！</p><p id="a303" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果您没有看到这一点，请返回并确保您的代码看起来像上面的代码。</p><p id="6ad7" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有时测试可以通过，但并没有真正按照我们想要的方式工作。确保我们的测试有效的一个方法是返回并改变交互。回到您的测试，对于第一个测试，将其更改为</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="f228" class="nu mc iq np b gy nv nw l nx ny">def "[buildJavascriptApp] will run npm publish if deploy is true"() {<br/>  when:<br/>    buildJavascriptApp deploy: true<br/>  then:<br/>    0 * getPipelineMock("sh")("npm publish")<br/>}</span></pre><p id="527b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">然后再次运行测试。您应该看到测试失败，输出如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/36e972eb8e85df41a051ae89c1c2afb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFy3DYC_fFZ69aSNPUBCjA.png"/></div></div></figure><p id="92e9" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这个错误是说我们期望<code class="fe nm nn no np b">npm publish</code>不会被调用，但是它实际上被调用了一次，这正是我们希望代码做的。这很好看！</p><p id="1050" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在您已经掌握了编写Jenkins-Spock的知识，试着为notify变量编写一组测试吧！</p><p id="0134" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="lf ir">免责声明:</strong>有一个名为<code class="fe nm nn no np b">notify</code>的Java方法，所以我们的变量存在命名问题。编写测试时，将变量命名为<code class="fe nm nn no np b">notifyVar</code>，而不是<code class="fe nm nn no np b">notify</code>。</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="f020" class="nu mc iq np b gy nv nw l nx ny">class NotifySpec extends JenkinsPipelineSpecification {<br/>  def notifyVar = null<br/>  <br/>  def setup() {<br/>    notifyVar = loadPipelineScriptForTest("vars/notify.groovy")<br/>  }</span><span id="3187" class="nu mc iq np b gy oa nw l nx ny">  ...<br/>}</span></pre><p id="5d5d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">你可以在这里找到完整的例子<a class="ae kv" href="https://github.com/werne2j/jenkins-shared-library/tree/tests" rel="noopener ugc nofollow" target="_blank">，但是我建议在看代码之前先试一试！</a></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="56e4" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">感谢您阅读我的Jenkins共享库系列的第三部分。</p><p id="dcab" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在我的Jenkins共享库系列的第四部分中，我们将讨论如何对代码库进行一些小的修改，以允许我们收集代码覆盖率并将其发送到<a class="ae kv" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank"> Sonarqube </a>。我希望在那里见到你！</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="8d19" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">我的詹金斯共享图书馆系列</h1><div class="of og gp gr oh oi"><a href="https://medium.com/@werne2j/jenkins-shared-libraries-part-1-5ba3d072536a" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">什么是Jenkins共享库，为什么你应该使用它们</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">Jenkins共享库系列文章的第1部分</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow kp oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/@werne2j/how-to-build-your-own-jenkins-shared-library-9dc129db260c" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">如何构建自己的Jenkins共享库</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">我的Jenkins共享库系列的第二部分</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow kp oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/@werne2j/unit-testing-a-jenkins-shared-library-9bfb6b599748" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">Jenkins共享库的单元测试</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">我的Jenkins共享库系列的第三部分在我的Jenkins共享库系列的第二篇文章中，我们构建了…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow kp oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/@werne2j/collecting-code-coverage-for-a-jenkins-shared-library-c2d8f502732e" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">收集Jenkins共享库的代码覆盖率</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">我的Jenkins共享库系列的第四部分</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow kp oi"/></div></div></a></div></div></div>    
</body>
</html>