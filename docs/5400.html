<html>
<head>
<title>Kubernetes: NGINX/PHP-FPM graceful shutdown and 502 errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes: NGINX/PHP-FPM正常关机和502错误</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-nginx-php-fpm-graceful-shutdown-and-502-errors-b2878cc3df5d?source=collection_archive---------2-----------------------#2021-02-25">https://itnext.io/kubernetes-nginx-php-fpm-graceful-shutdown-and-502-errors-b2878cc3df5d?source=collection_archive---------2-----------------------#2021-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/48ab6731fc89f28452dfdf73d5fe5ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-LJw8RG96qMMxPZeKcV5w.png"/></div></div></figure><p id="29d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个PHP应用程序在带有两个专用容器的pods中与Kubernetes一起运行——NGINXиPHP-FPM。</p><p id="b86a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是在缩减过程中，客户端得到502个错误。例如，当pod停止时，其容器不能正确关闭现有连接。</p><p id="c046" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在这篇文章中，我们将更仔细地看看pods的一般终止过程，特别是NGINX和PHP-FPM容器。</p><p id="3f47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由<a class="ae kw" href="https://rtfm.co.ua/en/yandex-tank-load-testing-tool-an-overview-configuration-and-examples/" rel="noopener ugc nofollow" target="_blank"> Yandex对AWS Elastic Kubernetes服务进行测试。坦克</a>实用。</p><p id="29d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">入口资源将使用<a class="ae kw" href="https://rtfm.co.ua/en/aws-elastic-kubernetes-service-running-alb-ingress-controller/" rel="noopener ugc nofollow" target="_blank"> AWS ALB入口控制器</a>创建一个AWS应用负载平衡器。</p><p id="a344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">испольузется·道克尔。</p><h1 id="1d52" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Pod生命周期Pod的终止</h1><p id="631b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">因此，让我们来概述一下pod的停止和终止过程。</p><p id="5737" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，pod是在Kubernetes WorkerNode上运行的一组进程，它们由标准IPC ( <a class="ae kw" href="https://en.wikipedia.org/wiki/Inter-process_communication" rel="noopener ugc nofollow" target="_blank"> <em class="ma">进程间通信</em> </a> ) <a class="ae kw" href="https://en.wikipedia.org/wiki/Signal_(IPC)" rel="noopener ugc nofollow" target="_blank">信号</a>停止。</p><p id="d3fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了赋予pod完成其所有操作的能力，<a class="ae kw" href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/" rel="noopener ugc nofollow" target="_blank">容器运行时</a>首先通过向该pod的每个容器中的PID 1发送<code class="fe mb mc md me b">SIGTERM</code>信号来软停止它(<em class="ma">正常关闭</em>)(参见<a class="ae kw" href="https://docs.docker.com/engine/reference/commandline/stop/" rel="noopener ugc nofollow" target="_blank">停靠站停止</a>)。此外，在通过发送一个<code class="fe mb mc md me b">SIGKILL</code>信号强制杀死这个pod之前，一个集群开始计算一个<em class="ma">宽限期</em>。</p><p id="1e67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以通过在用于旋转容器的图像中使用<code class="fe mb mc md me b"><a class="ae kw" href="https://docs.docker.com/engine/reference/builder/#stopsignal" rel="noopener ugc nofollow" target="_blank">STOPSIGNAL</a></code>来覆盖<code class="fe mb mc md me b">SIGTERM</code>。</p><p id="c364" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，删除pod的整个流程是(实际上，下面的部分是对<a class="ae kw" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination" rel="noopener ugc nofollow" target="_blank">官方文档</a>的一种复制):</p><ol class=""><li id="cdd5" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">用户发出<code class="fe mb mc md me b">kubectl delete pod</code>或<code class="fe mb mc md me b">kubectl scale deployment</code>命令，触发流程和宽限期的集群开始倒计时，默认值设置为30秒</li><li id="6518" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">集群的API服务器更新pod的状态—从<em class="ma">运行</em>状态，变为<em class="ma">终止</em>(参见<a class="ae kw" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-states" rel="noopener ugc nofollow" target="_blank">容器状态</a>)。运行此pod的工作节点上的<code class="fe mb mc md me b">kubelet</code>接收此状态更新并启动pod的终止过程:</li><li id="c8cb" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">如果pod中的容器有一个<code class="fe mb mc md me b"><a class="ae kw" href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks" rel="noopener ugc nofollow" target="_blank">preStop</a></code> <a class="ae kw" href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks" rel="noopener ugc nofollow" target="_blank">挂钩</a> - <code class="fe mb mc md me b">kubelet</code>将运行它。如果钩子仍然在默认的30秒宽限期内运行，那么将增加2秒。可以用<code class="fe mb mc md me b"><a class="ae kw" href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#hook-handler-execution" rel="noopener ugc nofollow" target="_blank">terminationGracePeriodSeconds</a></code>设置宽限期</li><li id="1621" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">当一个<code class="fe mb mc md me b">preStop</code>钩子完成时，一个<code class="fe mb mc md me b">kubelet</code>将向Docker运行时发送通知，停止与pod相关的容器。Docker守护进程将发送<code class="fe mb mc md me b">SIGTERM</code>信号给每个容器中PID为1的进程。集装箱将以随机的顺序接收信号。</li><li id="11c5" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><strong class="ka ir">在</strong>开始正常关机的同时，Kubernetes控制平面(其<code class="fe mb mc md me b"><a class="ae kw" href="https://kubernetes.io/docs/concepts/overview/components/#kube-controller-manager" rel="noopener ugc nofollow" target="_blank">kube-controller-manager</a></code>)将从端点移除pod(参见<a class="ae kw" href="https://theithollow.com/2019/02/04/kubernetes-endpoints/" rel="noopener ugc nofollow" target="_blank">Kubernetes–端点</a>)，相应的服务将停止向该pod发送流量</li><li id="c3c8" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">宽限期倒计时结束后，一个<code class="fe mb mc md me b">kubelet</code>将启动<em class="ma">强制关机</em> - Docker将发送<code class="fe mb mc md me b">SIGKILL</code>信号给pod的所有容器中的所有剩余进程，这些进程将立即终止，不做任何更改，以正确完成它们的操作</li><li id="cb4c" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><code class="fe mb mc md me b">kubelet</code>触发从API服务器删除pod</li><li id="2043" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">API服务器从<code class="fe mb mc md me b">etcd</code>中删除关于该pod的记录</li></ol><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/b891feed34a8ee4600c3225689798b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aP753hyfnqJlinU-.png"/></div></div></figure><p id="69af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，有两个问题:</p><ol class=""><li id="a14c" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">NGINX和PHP-FPM将<code class="fe mb mc md me b">SIGTERM</code>信号视为一种力量как“残酷的谋杀”,并将立即完成它们的进程，而不考虑现有的连接(参见<a class="ae kw" href="http://nginx.org/en/docs/control.html" rel="noopener ugc nofollow" target="_blank">控制nginx </a>和<a class="ae kw" href="https://linux.die.net/man/8/php-fpm" rel="noopener ugc nofollow" target="_blank"> php-fpm(8) - Linux手册页)</a></li><li id="c436" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">第2步和第3步——发送<code class="fe mb mc md me b">SIGTERM</code>和端点删除——同时执行。此外，入口服务将不会立即更新其关于端点的数据，并且在入口停止向其发送流量之前，可以终止pod，从而导致客户端的502错误，因为pod不能接受新的连接</li></ol><p id="c4c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果我们有一个到nginx服务器的连接，NGINX主进程在快速关闭期间将会断开这个连接，我们的客户端将会收到502错误，参见<a class="ae kw" href="https://ubuntu.com/blog/avoiding-dropped-connections-in-nginx-containers-with-stopsignal-sigquit" rel="noopener ugc nofollow" target="_blank">使用“STOPSIGNAL SIGQUIT”避免NGINX容器中的连接断开</a>。</p><h1 id="e2bf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">NGINX <code class="fe mb mc md me b">STOPSIGNAL</code>和502</h1><p id="72fd" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">好了，现在我们对它的进展有了一些了解——让我们试着用NGINX重现第一个问题。</p><p id="4553" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的例子摘自上面的帖子，并将被部署到Kubernetes集群。</p><p id="8fa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">准备Dockerfile文件:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="c256" class="nc ky iq me b gy nd ne l nf ng">FROM nginx<br/><br/>RUN echo 'server {\n\<br/>    listen 80 default_server;\n\<br/>    location / {\n\<br/>      proxy_pass      <a class="ae kw" href="http://httpbin.org/delay/10;\n\" rel="noopener ugc nofollow" target="_blank">http://httpbin.org/delay/10;\n\</a><br/>    }\n\<br/>}' &gt; /etc/nginx/conf.d/default.conf<br/><br/>CMD ["nginx", "-g", "daemon off;"]</span></pre><p id="6678" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里NGINX将<code class="fe mb mc md me b">proxy_pass</code>向<a class="ae kw" href="http://httpbin.org" rel="noopener ugc nofollow" target="_blank">http://httpbin.org</a>发出一个请求，后者将以10秒的延迟做出响应，以模拟PHP后端。</p><p id="afaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建映像并将其推送到存储库:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="97bf" class="nc ky iq me b gy nd ne l nf ng">$ docker build -t setevoy/nginx-sigterm .<br/>$ docker push setevoy/nginx-sigterm</span></pre><p id="7da4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，添加一个部署清单，从这个映像中旋转10个pod。</p><p id="fc66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是包含名称空间、服务和入口的完整文件，在本文的后续部分，将只添加清单的更新部分:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="8ab9" class="nc ky iq me b gy nd ne l nf ng">---<br/>apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: test-namespace<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: test-deployment<br/>  namespace: test-namespace<br/>  labels:<br/>    app: test<br/>spec:<br/>  replicas: 10<br/>  selector:<br/>    matchLabels:<br/>      app: test<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test<br/>    spec:<br/>      containers:<br/>      - name: web<br/>        image: setevoy/nginx-sigterm<br/>        ports:<br/>        - containerPort: 80<br/>        resources:<br/>          requests:<br/>            cpu: 100m<br/>            memory: 100Mi<br/>        readinessProbe:<br/>          tcpSocket:<br/>            port: 80<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: test-svc<br/>  namespace: test-namespace<br/>spec:<br/>  type: NodePort<br/>  selector:<br/>    app: test<br/>  ports:<br/>    - protocol: TCP<br/>      port: 80<br/>      targetPort: 80<br/>---<br/>apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test-ingress<br/>  namespace: test-namespace<br/>  annotations:<br/>    kubernetes.io/ingress.class: alb<br/>    alb.ingress.kubernetes.io/scheme: internet-facing<br/>    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}]'<br/>spec:<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - backend:<br/>          serviceName: test-svc<br/>          servicePort: 80</span></pre><p id="7cf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">部署它:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="724a" class="nc ky iq me b gy nd ne l nf ng">$ kubectl apply -f test-deployment.yaml<br/>namespace/test-namespace created<br/>deployment.apps/test-deployment created<br/>service/test-svc created<br/>ingress.extensions/test-ingress created</span></pre><p id="9610" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查入口:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="8ba7" class="nc ky iq me b gy nd ne l nf ng">$ curl -I aadca942-testnamespace-tes-5874–698012771.us-east-2.elb.amazonaws.com<br/>HTTP/1.1 200 OK</span></pre><p id="6504" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有10个吊舱在运行:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="2005" class="nc ky iq me b gy nd ne l nf ng">$ kubectl -n test-namespace get pod<br/>NAME READY STATUS RESTARTS AGE<br/>test-deployment-ccb7ff8b6–2d6gn 1/1 Running 0 26s<br/>test-deployment-ccb7ff8b6–4scxc 1/1 Running 0 35s<br/>test-deployment-ccb7ff8b6–8b2cj 1/1 Running 0 35s<br/>test-deployment-ccb7ff8b6-bvzgz 1/1 Running 0 35s<br/>test-deployment-ccb7ff8b6-db6jj 1/1 Running 0 35s<br/>test-deployment-ccb7ff8b6-h9zsm 1/1 Running 0 20s<br/>test-deployment-ccb7ff8b6-n5rhz 1/1 Running 0 23s<br/>test-deployment-ccb7ff8b6-smpjd 1/1 Running 0 23s<br/>test-deployment-ccb7ff8b6-x5dc2 1/1 Running 0 35s<br/>test-deployment-ccb7ff8b6-zlqxs 1/1 Running 0 25s</span></pre><p id="b615" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为<a class="ae kw" href="https://rtfm.co.ua/yandex-tank-nagruzochnoe-testirovanie/" rel="noopener ugc nofollow" target="_blank"> Yandex准备一个<code class="fe mb mc md me b">load.yaml</code>。坦克</a>:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="152d" class="nc ky iq me b gy nd ne l nf ng">phantom:<br/>  address: aadca942-testnamespace-tes-5874-698012771.us-east-2.elb.amazonaws.com<br/>  header_http: "1.1"<br/>  headers:<br/>     - "[Host: aadca942-testnamespace-tes-5874-698012771.us-east-2.elb.amazonaws.com]"<br/>  uris:<br/>    - /    <br/>  load_profile:<br/>    load_type: rps<br/>    schedule: const(100,30m)<br/>  ssl: false<br/>console:<br/>  enabled: true<br/>telegraf:<br/>  enabled: false<br/>  package: yandextank.plugins.Telegraf<br/>  config: monitoring.xml</span></pre><p id="d350" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们将对入口后面的pod每秒执行一次请求。</p><p id="249e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行测试:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/b64dbd7bd93f1fe67544ae167908dca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*n2O5pbQw8v1nHoeu.png"/></div></figure><p id="2c98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前为止一切顺利。</p><p id="e701" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，将部署规模缩小到只有一个单元:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="0deb" class="nc ky iq me b gy nd ne l nf ng">$ kubectl -n test-namespace scale deploy test-deployment — replicas=1<br/>deployment.apps/test-deployment scaled</span></pre><p id="163b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">豆荚变成了<em class="ma">终止</em>:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="f7b8" class="nc ky iq me b gy nd ne l nf ng">$ kubectl -n test-namespace get pod<br/>NAME READY STATUS RESTARTS AGE<br/>test-deployment-647ddf455–67gv8 1/1 Terminating 0 4m15s<br/>test-deployment-647ddf455–6wmcq 1/1 Terminating 0 4m15s<br/>test-deployment-647ddf455-cjvj6 1/1 Terminating 0 4m15s<br/>test-deployment-647ddf455-dh7pc 1/1 Terminating 0 4m15s<br/>test-deployment-647ddf455-dvh7g 1/1 Terminating 0 4m15s<br/>test-deployment-647ddf455-gpwc6 1/1 Terminating 0 4m15s<br/>test-deployment-647ddf455-nbgkn 1/1 Terminating 0 4m15s<br/>test-deployment-647ddf455-tm27p 1/1 Running 0 26m<br/>…</span></pre><p id="8d7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们得到了502个错误:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/afd5aa76e6023d198c9b67377aacb844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*NTY7mh7z5SsJqgk7.png"/></div></figure><p id="c0bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，更新Dockerfile —添加<code class="fe mb mc md me b">STOPSIGNAL SIGQUIT</code>:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="72dd" class="nc ky iq me b gy nd ne l nf ng">FROM nginx<br/><br/>RUN echo 'server {\n\<br/>    listen 80 default_server;\n\<br/>    location / {\n\<br/>      proxy_pass      <a class="ae kw" href="http://httpbin.org/delay/10;\n\" rel="noopener ugc nofollow" target="_blank">http://httpbin.org/delay/10;\n\</a><br/>    }\n\<br/>}' &gt; /etc/nginx/conf.d/default.conf<br/><br/>STOPSIGNAL SIGQUIT<br/><br/>CMD ["nginx", "-g", "daemon off;"]</span></pre><p id="babd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建、推送:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="5902" class="nc ky iq me b gy nd ne l nf ng">$ docker build -t setevoy/nginx-sigquit .<br/>docker push setevoy/nginx-sigquit</span></pre><p id="abd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用新映像更新部署:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="b2e1" class="nc ky iq me b gy nd ne l nf ng">...<br/>    spec:<br/>      containers:<br/>      - name: web<br/>        image: setevoy/nginx-sigquit<br/>        ports:<br/>        - containerPort: 80<br/>...</span></pre><p id="2194" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重新部署，并再次检查。</p><p id="0fbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行测试:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/a4d939b5746723ff0c23ce0d132095ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*nd8HaslyHJOHYSzo.png"/></div></figure><p id="7712" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次缩小部署规模:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="7c56" class="nc ky iq me b gy nd ne l nf ng">$ kubectl -n test-namespace scale deploy test-deployment — replicas=1<br/>deployment.apps/test-deployment scaled</span></pre><p id="6dd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这次没有错误:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/dc431c36d7fcbd955df0881d7242a3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*dC_A-_OD-_DOz-LQ.png"/></div></figure><p id="eb5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了！</p><h1 id="5be5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">交通、<code class="fe mb mc md me b">preStop</code>和<code class="fe mb mc md me b">sleep</code></h1><p id="4a77" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">但是，如果重复测试几次，我们仍然会得到一些502错误:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/20337aa71b70834039e536170ecce4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VVTa-NL2mfuYbCMO.png"/></div></div></figure><p id="0649" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一次我们很可能面临第二个问题——端点更新是在发送<code class="fe mb mc md me b">SIGTERM</code>的同时执行的。</p><p id="a587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加一个带有<code class="fe mb mc md me b">sleep</code>的<code class="fe mb mc md me b">preStop</code>钩子，给一些时间来更新端点和入口，这样在集群接收到停止pod的请求后，WorkerNode上的<code class="fe mb mc md me b">kubelet</code>将等待5秒钟，然后发送<code class="fe mb mc md me b">SIGTERM</code>:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="e2e0" class="nc ky iq me b gy nd ne l nf ng">...<br/>    spec:<br/>      containers:<br/>      - name: web<br/>        image: setevoy/nginx-sigquit<br/>        ports:<br/>        - containerPort: 80<br/>        lifecycle:<br/>          preStop:<br/>            exec:<br/>              command: ["/bin/sleep","5"]<br/>...</span></pre><p id="b580" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重复测试——现在一切正常</p><p id="19e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的PHP-FPM没有这样的问题，因为它的<a class="ae kw" href="https://hub.docker.com/layers/phpdockerio/php74-fpm/latest/images/sha256-bd812f269663fb369c4c7d810e99f52ae939e45412b600c88fabacb982de858d?context=explore" rel="noopener ugc nofollow" target="_blank">图像</a>最初是用<code class="fe mb mc md me b">STOPSIGNAL SIGQUIT</code>构建的。</p><h1 id="27e3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">其他可能的解决方案</h1><p id="ff7b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当然，在调试期间，我尝试了一些其他方法来缓解这个问题。</p><p id="7223" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">见本文末尾的链接，这里我将用简短的术语来描述它们。</p><h2 id="7bae" class="nc ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated"><code class="fe mb mc md me b">preStop</code>和<code class="fe mb mc md me b">nginx -s quit</code></h2><p id="9a09" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">其中一个解决方案是添加一个<code class="fe mb mc md me b">preStop</code>钩子，将<code class="fe mb mc md me b">QUIT</code>发送到NGINX:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="797d" class="nc ky iq me b gy nd ne l nf ng">lifecycle:<br/>  preStop:<br/>    exec:<br/>      command:<br/>      - /usr/sbin/nginx<br/>      - -s<br/>      - quit</span></pre><p id="4402" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者:</p><pre class="mu mv mw mx gt my me mz na aw nb bi"><span id="e0ca" class="nc ky iq me b gy nd ne l nf ng">...<br/>        lifecycle:<br/>          preStop:<br/>            exec:<br/>              command:<br/>              - /bin/sh<br/>              - -SIGQUIT<br/>              - 1<br/>....</span></pre><p id="b397" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但无济于事。不知道为什么这个想法似乎是正确的——我们没有等待来自Kubernetes/Docker的<code class="fe mb mc md me b">TERM</code>—而是通过发送<code class="fe mb mc md me b">QUIT</code>优雅地停止了NGINX主进程。</p><p id="856b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以运行<code class="fe mb mc md me b">strace</code>实用程序来检查NGINX真正接收到了哪个信号。</p><h2 id="d604" class="nc ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">NGINX + PHP-FPM，<code class="fe mb mc md me b">supervisord</code>和<code class="fe mb mc md me b">stopsignal</code></h2><p id="e772" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们的应用程序在一个pod中的两个容器中运行，但在调试过程中，我也尝试过使用一个同时具有NGINX和PHP-FPM的容器，例如，<a class="ae kw" href="https://hub.docker.com/r/trafex/alpine-nginx-php7" rel="noopener ugc nofollow" target="_blank">trafex/alpine-NGINX-PHP 7</a>。</p><p id="c86b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那里，我试图用<code class="fe mb mc md me b">QUIT</code>值给NGINX和PHP-FPM的<code class="fe mb mc md me b">supervisor.conf</code>加上<code class="fe mb mc md me b"><a class="ae kw" href="http://supervisord.org/configuration.html#program-x-section-values" rel="noopener ugc nofollow" target="_blank">stopsignal</a></code>，但这也没有帮助，尽管这个想法似乎也是正确的。</p><p id="08f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，人们还是可以试试这种方法。</p><h2 id="fea3" class="nc ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">PHP-FPM，和<code class="fe mb mc md me b">process_control_timeout</code></h2><p id="d056" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在Kubernetes中的<a class="ae kw" href="https://medium.com/flant-com/kubernetes-graceful-shutdown-nginx-php-fpm-d5ab266963c2" rel="noopener">优雅关闭并不总是微不足道的</a>和在<a class="ae kw" href="https://stackoverflow.com/questions/36564074/nginx-php-fpm-graceful-stop-sigquit-not-so-graceful" rel="noopener ugc nofollow" target="_blank"> Nginx / PHP FPM优雅停止(SIGQUIT)中的Stackoveflow:不那么优雅</a>问题是注意到FPM的主进程在其子进程之前被杀死，这也可能导致502。</p><p id="f9f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不是我们目前的情况，但请注意<code class="fe mb mc md me b"><a class="ae kw" href="https://www.php.net/manual/ru/install.fpm.configuration.php" rel="noopener ugc nofollow" target="_blank">process_control_timeout</a></code>。</p><h2 id="b143" class="nc ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">NGINX、HTTP和保持活动会话</h2><p id="ef10" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">此外，使用<code class="fe mb mc md me b">[Connection: close]</code>头也是一个好主意——客户端将在请求完成后立即关闭连接，这可以减少502错误计数。</p><p id="4cef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是不管怎样，如果NGINX在处理请求的过程中获得了<code class="fe mb mc md me b">SIGTERM</code>，那么它们就会坚持下去。</p><p id="cb5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参见<a class="ae kw" href="https://en.wikipedia.org/wiki/HTTP_persistent_connection" rel="noopener ugc nofollow" target="_blank"> HTTP持久连接</a>。</p><h1 id="9a75" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">有用的链接</h1><ul class=""><li id="ae8a" class="mf mg iq ka b kb lv kf lw kj nu kn nv kr nw kv nx ml mm mn bi translated"><a class="ae kw" href="https://medium.com/flant-com/kubernetes-graceful-shutdown-nginx-php-fpm-d5ab266963c2" rel="noopener">Kubernetes的正常关机并不总是微不足道的</a>(<a class="ae kw" href="https://habr.com/ru/company/flant/blog/489994/" rel="noopener ugc nofollow" target="_blank">переводнахабре</a>)</li><li id="c041" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv nx ml mm mn bi translated"><a class="ae kw" href="https://blog.gruntwork.io/gracefully-shutting-down-pods-in-a-kubernetes-cluster-328aecec90d" rel="noopener ugc nofollow" target="_blank">优雅地关闭Kubernetes集群中的Pods</a>—<code class="fe mb mc md me b">preStop</code>解决方案中的<code class="fe mb mc md me b">nginx -s quit</code>也很好地描述了向终止的Pods发送流量的问题</li><li id="9d19" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv nx ml mm mn bi translated"><a class="ae kw" href="https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-terminating-with-grace" rel="noopener ugc nofollow" target="_blank"> Kubernetes最佳实践:优雅地终止</a></li><li id="ddcb" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv nx ml mm mn bi translated"><a class="ae kw" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination" rel="noopener ugc nofollow" target="_blank">吊舱的终止</a></li><li id="a3d7" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv nx ml mm mn bi translated"><a class="ae kw" href="https://philpearl.github.io/post/k8s_ingress/" rel="noopener ugc nofollow" target="_blank"> Kubernetes的肮脏端点秘密和入口</a></li><li id="c1ce" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv nx ml mm mn bi translated"><a class="ae kw" href="https://ubuntu.com/blog/avoiding-dropped-connections-in-nginx-containers-with-stopsignal-sigquit" rel="noopener ugc nofollow" target="_blank">用“STOPSIGNAL SIGQUIT”避免nginx容器中的掉线</a>——实际上，在这里我找到了我们的解决方案，以及如何重现它的想法</li></ul></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="520d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ma">最初发布于</em> <a class="ae kw" href="https://rtfm.co.ua/en/kubernetes-nginx-php-fpm-graceful-shutdown-and-502-errors/" rel="noopener ugc nofollow" target="_blank"> <em class="ma"> RTFM: Linux、DevOps和系统管理</em> </a> <em class="ma">。</em></p></div></div>    
</body>
</html>