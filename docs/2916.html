<html>
<head>
<title>Redis: fork — Cannot allocate memory, Linux, virtual memory and vm.overcommit_memory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis: fork —无法分配内存、Linux、虚拟内存和vm.overcommit_memory</h1>
<blockquote>原文：<a href="https://itnext.io/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit-memory-5005ea697411?source=collection_archive---------4-----------------------#2019-08-28">https://itnext.io/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit-memory-5005ea697411?source=collection_archive---------4-----------------------#2019-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/6c27137da9dc80ff5d537b82df760cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/0*JNpXEMeqPUrRbXkK.png"/></div></figure><p id="8ad8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">目前，我正在为我们的应用程序配置一个Redis作为缓存服务，在此期间，我面临着这样一个问题:我需要将<code class="fe kv kw kx ky b">vm.overcommit_memory</code>设置为值1，即禁用它吗？</p><p id="97e4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个问题对我来说太老了，见<a class="ae kz" href="https://rtfm.co.ua/en/?p=21521#The_story" rel="noopener ugc nofollow" target="_blank"> <em class="la">故事</em> </a>，但直到现在我才有时间找到问题的真正根源，把所有的东西放在一起，写下了下面的帖子。</p><p id="b940" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它最初是用俄语发布的<a class="ae kz" href="https://rtfm.co.ua/redis-linux-i-vm-overcommit_memory/" rel="noopener ugc nofollow" target="_blank">，这是我自己翻译的副本。因为真的有很多文本——我希望我在翻译过程中没有混淆任何东西。如果有—请随意用鼠标选择文本，然后按Shift+Enter向我发送通知。</a></p><p id="229a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以，问题本身是Redis文档和几乎所有关于Redis性能的HowTo/guide都漫不经心地告诉我们通过将<code class="fe kv kw kx ky b">vm.overcommit_memory</code>设置为1来禁用Linux <code class="fe kv kw kx ky b">overcommit_memory</code>机制，特别是作为“<em class="la"> fork —无法分配内存</em>”错误的解决方案。</p><p id="ebda" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇文章中，我们将试图弄清楚<code class="fe kv kw kx ky b">overcommit_memory</code>到底是什么，在哪里以及如何使用它，在我目前的情况下，我们真的需要改变它吗，也就是说，Redis何时将仅用于缓存。</p><p id="3a24" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本帖涵盖的主题:</p><ul class=""><li id="d063" class="lb lc it jz b ka kb ke kf ki ld km le kq lf ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#Why_overcommitting_is_bad" rel="noopener ugc nofollow" target="_blank">为什么过度承诺不好？</a></li><li id="e7b5" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#Redis_persistence" rel="noopener ugc nofollow" target="_blank"> Redis持久性</a></li><li id="82a2" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#Redis_save_SAVE_BGSAVE" rel="noopener ugc nofollow" target="_blank"> Redis保存，保存иBG保存</a></li><li id="ec1d" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#Redis_rdbSave_and_rdbSaveBackground_functions" rel="noopener ugc nofollow" target="_blank"> Redis rdbSave()和rdbSaveBackground()函数</a></li><li id="113d" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#fork_vs_fork_vs_clone" rel="noopener ugc nofollow" target="_blank">叉子()vs叉子()vs克隆()</a></li><li id="df5d" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#Redis_fork_Cannot_allocate_memory_the_cause" rel="noopener ugc nofollow" target="_blank"> Redis — fork:无法分配内存—原因</a></li><li id="24a0" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#The_overcommit_memory_values" rel="noopener ugc nofollow" target="_blank">过载_内存值</a></li><li id="6df1" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#The_famous_heuristic_algorithm_Heuristic_Overcommit_handling" rel="noopener ugc nofollow" target="_blank">著名的“启发式算法”(Heuristic Overcommit handling)</a></li><li id="b131" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#Checking_vmovercommit_memory" rel="noopener ugc nofollow" target="_blank">检查vm.overcommit_memory </a></li><li id="9b4e" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#Conclusions" rel="noopener ugc nofollow" target="_blank">结论</a></li><li id="840d" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#The_story" rel="noopener ugc nofollow" target="_blank">故事</a></li><li id="1115" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#Useful_links" rel="noopener ugc nofollow" target="_blank">有用链接</a></li><li id="99bd" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/#Similar_posts" rel="noopener ugc nofollow" target="_blank">类似岗位</a></li></ul><h2 id="570e" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated">为什么过度承诺不好？</h2><p id="e3d6" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated"><em class="la">因为这篇文章原本是俄语的，这部分被翻译了——我在这里只是复制粘贴原文的一部分。阅读全文— </em> <a class="ae kz" href="https://www.etalabs.net/overcommit.html" rel="noopener ugc nofollow" target="_blank"> <em class="la">什么是过度承诺？为什么不好？</em> </a></p><p id="93f6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">过量使用指的是在不保证物理存储存在的情况下分配虚拟内存。打个比方，这就像使用信用卡却不记录你的购物记录。一个执行过量使用的系统只是不断地释放虚拟内存，直到收债人来调用——也就是说，直到某个程序接触到一个以前没有接触过的页面，而内核找不到任何物理内存来实例化它——然后东西开始崩溃。</strong></p><p id="6095" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当“东西开始倒塌”时会发生什么？它可以有所不同，但Linux的方法是在内核中设计一个精心设计的启发式“OOM杀手”,它判断每个进程的行为，并决定谁是造成机器内存不足的“罪魁祸首”,然后杀死有罪的一方。在实践中，从避免杀死关键系统进程和杀死“霸占”内存的进程的角度来看，这种方法非常有效，但问题是没有一个进程真正“犯了”使用比可用内存更多的内存的错误，因为每个人都被(错误地)告知内存可用。</p><p id="7388" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">假设你不希望内存分配出现这种不确定性/危险？简单的解决方案是立即静态分配对应于所有虚拟内存的物理内存。延伸一下信用卡的比喻，这就像使用现金购买所有商品，或者使用借记卡。你从超支中获得了安全感，但也失去了很多流动性。谢天谢地，有更好的方法来管理内存。</p><p id="5420" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当你想避免提交太多内存时，现实中采用的方法是<em class="la">考虑</em>所有分配的内存。在我们的信用卡类比中，这相当于使用信用卡，但是记录所有的购物记录，并且永远不要购买超过你有能力偿还的金额。在管理虚拟内存时，这被证明是正确的，事实上，当您将vm.overcommit_memory sysctl参数设置为值2时，Linux就是这样做的。在这种模式下，所有可能被修改(即具有读写权限)或缺乏支持(即磁盘或其他设备上的原始副本，如果需要丢弃，可以从该副本恢复)的虚拟内存都被视为“提交费用”，即内核作为<em class="la">提交</em>/承诺给应用程序的内存量。当新的虚拟内存分配将导致提交费用超过可配置的限制(默认情况下，交换空间的大小加上物理ram大小的一半)时，分配将失败。</p><h2 id="66cc" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated">Redis持久性</h2><p id="10d5" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">Redis使用两种机制来实现数据持久性——RDB快照(<em class="la">时间点快照</em>),它创建从内存到固态硬盘的数据副本；AOF，它不断地将服务器在其工作期间执行的每个操作写入日志。更多信息请参见文档— <a class="ae kz" href="https://redis.io/topics/persistence" rel="noopener ugc nofollow" target="_blank"> Redis持久性</a>。</p><p id="fc42" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当Redis从磁盘上的内存创建数据快照时，<code class="fe kv kw kx ky b">overcommit_memory</code>介入，特别是在<code class="fe kv kw kx ky b"><a class="ae kz" href="https://redis.io/commands/bgsave" rel="noopener ugc nofollow" target="_blank">BGSAVE</a></code>和<code class="fe kv kw kx ky b"><a class="ae kz" href="https://redis.io/commands/bgrewriteaof" rel="noopener ugc nofollow" target="_blank">BGREWRITEAOF</a></code>命令执行期间。</p><p id="0aa9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面我们将关注<code class="fe kv kw kx ky b"><a class="ae kz" href="https://redis.io/commands/bgsave" rel="noopener ugc nofollow" target="_blank">BGSAVE</a></code>命令，在此期间Redis创建一个子进程，将数据复制到磁盘。</p><h2 id="aa55" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated">Redis保存，保存иBG保存</h2><p id="1fef" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">有点令人困惑的可能是Redis本身:在其配置文件中，<code class="fe kv kw kx ky b">save</code>选项负责<code class="fe kv kw kx ky b">BGSAVE</code>操作。</p><p id="772e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，Redis也有<code class="fe kv kw kx ky b">SAVE</code>命令，但它的工作方式不同:</p><ul class=""><li id="eedd" class="lb lc it jz b ka kb ke kf ki ld km le kq lf ku lg lh li lj bi translated"><code class="fe kv kw kx ky b">SAVE</code>是同步命令，在创建副本期间在内存上执行写块操作</li><li id="fc1b" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><code class="fe kv kw kx ky b">BGSAVE</code>它本身是一种异步机制——它与主服务器的进程并行工作，不会影响其操作和客户端连接，因此它是创建备份的首选方式</li></ul><p id="09c8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是在<code class="fe kv kw kx ky b">BGSAVE</code>无法使用的情况下，例如，由于“<a class="ae kz" href="https://rtfm.co.ua/en/?p=21521#Redis_fork_Cannot_allocate_memory_the_cause" rel="noopener ugc nofollow" target="_blank"> <em class="la">无法在后台保存:fork:无法分配内存</em> </a>”错误-可以使用<code class="fe kv kw kx ky b">SAVE</code>命令。</p><p id="2242" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们使用<code class="fe kv kw kx ky b">strace</code>工具进行检查。</p><p id="fb4d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建一个测试配置文件<code class="fe kv kw kx ky b">redis-testing.conf</code>:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="8c04" class="lp lq it ky b gy mv mw l mx my">save 1 1<br/>port 7777</span></pre><p id="c947" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用以下配置运行<code class="fe kv kw kx ky b">strace</code>和<code class="fe kv kw kx ky b">redis-server</code>:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="bf4f" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# strace -o redis-trace.log redis-server redis-testing.conf</span></pre><p id="1b65" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe kv kw kx ky b">strace</code>将把它的输出写入<em class="la"> redis-trace.log </em>文件，我们将检查该文件，以找到redis-server在<code class="fe kv kw kx ky b">SAVE</code>和<code class="fe kv kw kx ky b">BGSAVE</code>操作期间使用的系统调用:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="c7e3" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# tail -f redis-trace.log | grep -v ‘gettimeofday\|close\|open\|epoll_wait\|getpid\|read\|write’</span></pre><p id="7c7b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里用<code class="fe kv kw kx ky b">grep -v</code>我们去掉了一个我们现在不需要的“垃圾”调用。</p><p id="c2f0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们可以使用<code class="fe kv kw kx ky b">-e trace=</code>只抓取必要的呼叫——但是我们还不知道我们到底在找什么。</p><p id="f7da" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在Redis配置文件中，我们设置了<code class="fe kv kw kx ky b">port 777</code>和<code class="fe kv kw kx ky b">save 1 1</code>，例如，如果至少一个键被更改，每秒钟创建一个数据库副本到磁盘。</p><p id="28c8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">添加新密钥:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="1ac7" class="lp lq it ky b gy mv mw l mx my">admin@bttrm-dev-console:~$ redis-cli -p 7777 set test test</span></pre><p id="929f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">好</p><p id="6e14" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并检查<code class="fe kv kw kx ky b">strace</code>日志:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="024b" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# tail -f redis-trace.log | grep -v ‘gettimeofday\|close\|open\|epoll_wait\|getpid\|read\|write’<br/>accept(5, {sa_family=AF_INET, sin_port=htons(60816), sin_addr=inet_addr(“127.0.0.1”)}, [128-&gt;16]) = 6<br/>…<br/>stat(“/etc/localtime”, {st_mode=S_IFREG|0644, st_size=2097, …}) = 0<br/>clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7ff26beda190) = 1790<br/>stat(“/etc/localtime”, {st_mode=S_IFREG|0644, st_size=2097, …}) = 0<br/> — — SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=1790, si_uid=0, si_status=0, si_utime=0, si_stime=0} — -<br/>wait4(-1, [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 1790<br/>stat(“/etc/localtime”, {st_mode=S_IFREG|0644, st_size=2097, …}) = 0</span></pre><p id="225b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里是<code class="fe kv kw kx ky b">clone()</code>调用(为什么是<code class="fe kv kw kx ky b">clone()</code>而不是<code class="fe kv kw kx ky b">fork()</code>——我们稍后会讲到，在<a class="ae kz" href="https://rtfm.co.ua/en/?p=21521#fork_vs_fork_vs_clone" rel="noopener ugc nofollow" target="_blank"><em class="la">fork()vs fork()vs clone()</em></a>)。这个<code class="fe kv kw kx ky b">clone()</code>创建了一个新的子进程，该子进程将依次创建数据副本。</p><p id="dfc1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在—运行<code class="fe kv kw kx ky b">SAVE</code>命令:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="2c3d" class="lp lq it ky b gy mv mw l mx my">admin@bttrm-dev-console:~$ redis-cli -p 7777 save<br/>OK</span></pre><p id="dcc9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并检查日志:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="91e6" class="lp lq it ky b gy mv mw l mx my">accept(5, {sa_family=AF_INET, sin_port=htons(32870), sin_addr=inet_addr(“127.0.0.1”)}, [128-&gt;16]) = 6<br/>…<br/>rename(“temp-1652.rdb”, “dump.rdb”) = 0<br/>stat(“/etc/localtime”, {st_mode=S_IFREG|0644, st_size=2097, …}) = 0<br/>epoll_ctl(3, EPOLL_CTL_DEL, 6, 0x7ffe6712430c) = 0</span></pre><p id="adf7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此时没有<code class="fe kv kw kx ky b">clone()</code>——转储由主Redis进程执行并保存到<code class="fe kv kw kx ky b">dump.rdb</code>文件——检查<code class="fe kv kw kx ky b">strace</code>输出中的<em class="la"> rename("temp-1652.rdb "，" dump.rdb") </em>行(我们将很快看到这个名称出现在那里- <em class="la"> temp-1652.rdb)。</em></p><p id="4584" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在调用<code class="fe kv kw kx ky b">BGSAVE</code>:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="dc5d" class="lp lq it ky b gy mv mw l mx my">admin@bttrm-dev-console:~$ redis-cli -p 7777 bgsave<br/>Background saving started</span></pre><p id="ff6d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并再次检查日志:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="233b" class="lp lq it ky b gy mv mw l mx my">accept(5, {sa_family=AF_INET, sin_port=htons(33030), sin_addr=inet_addr(“127.0.0.1”)}, [128-&gt;16]) = 6<br/>…<br/>clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7ff26beda190) = 1879<br/>stat(“/etc/localtime”, {st_mode=S_IFREG|0644, st_size=2097, …}) = 0<br/>epoll_ctl(3, EPOLL_CTL_DEL, 6, 0x7ffe6712430c) = 0<br/> — — SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=1879, si_uid=0, si_status=0, si_utime=0, si_stime=0} — -<br/>wait4(-1, [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0}], WNOHANG, NULL) = 1879<br/>stat(“/etc/localtime”, {st_mode=S_IFREG|0644, st_size=2097, …}) = 0</span></pre><p id="4b52" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的<code class="fe kv kw kx ky b">clone()</code>也在这里，它产生了另一个PID为1879的子进程:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="1181" class="lp lq it ky b gy mv mw l mx my">…<br/>clone([…]) = 187<br/>…</span></pre><h2 id="3c71" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated">Redis <code class="fe kv kw kx ky b">rdbSave()</code>和<code class="fe kv kw kx ky b">rdbSaveBackground()</code>功能</h2><p id="d7fc" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">确切地说，转储本身是由唯一的Redis函数创建的— <code class="fe kv kw kx ky b"><a class="ae kz" href="https://github.com/antirez/redis/blob/unstable/src/rdb.c#L1268" rel="noopener ugc nofollow" target="_blank">rdbSave()</a></code>:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="0532" class="lp lq it ky b gy mv mw l mx my">...<br/>/* Save the DB on disk. Return C_ERR on error, C_OK on success. */<br/>int rdbSave(char *filename, rdbSaveInfo *rsi) {<br/>    ...<br/>    snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid());<br/>    fp = fopen(tmpfile,"w");<br/>...</span></pre><p id="965a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在执行<code class="fe kv kw kx ky b">redis-cli -p 7777 SAVE</code>命令时调用。</p><p id="0b47" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是我们从上面的<code class="fe kv kw kx ky b">strace</code>输出中得到的<em class="la"> temp-1652.rdb </em>文件名:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="ba08" class="lp lq it ky b gy mv mw l mx my">...<br/>snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid());<br/>...</span></pre><p id="6b90" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">其中<em class="la"> 1652 </em> —是Redis服务器的主进程PID。</p><p id="2ed7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">就其本身而言，在<code class="fe kv kw kx ky b">BGSAVE</code>命令期间，另一个功能被调用- <code class="fe kv kw kx ky b"><a class="ae kz" href="https://github.com/antirez/redis/blob/unstable/src/rdb.c#L1331" rel="noopener ugc nofollow" target="_blank">rdbSaveBackground()</a></code>:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="6d08" class="lp lq it ky b gy mv mw l mx my">...<br/>int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {<br/>    ...<br/>    start = ustime();<br/>    if ((childpid = fork()) == 0) {<br/>        int retval;<br/><br/>        /* Child */<br/>        closeListeningSockets(0);<br/>        redisSetProcTitle("redis-rdb-bgsave");<br/>        retval = rdbSave(filename,rsi);<br/>...</span></pre><p id="6ecd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这又会创建一个新的子进程:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="9a01" class="lp lq it ky b gy mv mw l mx my">...<br/>if ((childpid = fork()) == 0)<br/>...</span></pre><p id="3f71" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并且该过程将依次执行<code class="fe kv kw kx ky b">rdbSave()</code>:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="c663" class="lp lq it ky b gy mv mw l mx my">...<br/>retval = rdbSave(filename,rsi);<br/>...</span></pre><h2 id="5c5a" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated"><code class="fe kv kw kx ky b">fork()</code> vs <code class="fe kv kw kx ky b">fork()</code> vs <code class="fe kv kw kx ky b">clone()</code></h2><p id="8127" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">现在，让我们回到这个问题——为什么在<code class="fe kv kw kx ky b">strace</code>的输出中我们看到的是<code class="fe kv kw kx ky b">clone()</code>系统调用，而不是由<code class="fe kv kw kx ky b">rdbSaveBackground()</code>函数调用的<code class="fe kv kw kx ky b">fork()</code>?</p><p id="e336" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">嗯，那只是因为<code class="fe kv kw kx ky b">fork()</code>！= <code class="fe kv kw kx ky b">fork()</code>:</p><ol class=""><li id="cefc" class="lb lc it jz b ka kb ke kf ki ld km le kq lf ku mz lh li lj bi translated">有一个Linux内核系统调用</li><li id="bb53" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">还有一个<code class="fe kv kw kx ky b">glibc</code>的<code class="fe kv kw kx ky b">fork()</code>函数，它是<code class="fe kv kw kx ky b"><a class="ae kz" href="https://linux.die.net/man/2/clone" rel="noopener ugc nofollow" target="_blank">clone()</a></code>系统调用的包装器</li></ol><p id="4a03" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">尝试使用<code class="fe kv kw kx ky b"><a class="ae kz" href="https://rtfm.co.ua/linux-apropos-poisk-po-man-stranicam/" rel="noopener ugc nofollow" target="_blank">apropos</a></code>工具检查它们:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="40fa" class="lp lq it ky b gy mv mw l mx my">[setevoy@setevoy-arch-work ~/Temp/redis] [unstable*] $ apropos fork<br/>fork (2) — create a child process<br/>fork (3am) — basic process management<br/>fork (3p) — create a new process</span></pre><p id="0cc1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，<code class="fe kv kw kx ky b"><a class="ae kz" href="https://linux.die.net/man/2/fork" rel="noopener ugc nofollow" target="_blank">fork(2)</a></code> -是一个系统调用，而<code class="fe kv kw kx ky b">fork(3p)</code> -是<code class="fe kv kw kx ky b">glibc</code>的函数-<a class="ae kz" href="https://github.com/bminor/glibc/blob/master/sysdeps/nptl/fork.c#L48" rel="noopener ugc nofollow" target="_blank">https://github . com/bminor/glibc/blob/master/sysdeps/nptl/fork . c # L48</a>。</p><p id="d131" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，阅读下面的手册:-) —打开<code class="fe kv kw kx ky b">man 2 fork</code>:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="5430" class="lp lq it ky b gy mv mw l mx my">[setevoy@setevoy-arch-work ~/Temp/redis] [unstable*] $ man 2 fork | grep -A 5 NOTES<br/>NOTES<br/>Under Linux, fork() is implemented using copy-on-write pages, so the only penalty that it incurs is the time and memory required to duplicate the parent’s page tables, and to create a unique task structure for the child.<br/>C library/kernel differences<br/>Since version 2.3.3, rather than invoking the kernel’s fork() system call, the glibc fork() wrapper that is provided as part of the NPTL threading implementation invokes clone(2) with flags that provide the same effect as the traditional system call. (A call to fork() is equivalent to a call to clone(2) specifying flags as just SIGCHLD.) The glibc wrapper invokes any fork handlers that have been established using pthread_atfork(3).</span></pre><blockquote class="na nb nc"><p id="fb7a" class="jx jy la jz b ka kb kc kd ke kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ku im bi translated">glibc fork()包装器[…]调用clone(2)，而不是调用内核的fork()系统调用</p></blockquote><p id="380d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，当<code class="fe kv kw kx ky b">rdbSaveBackground()</code>执行<code class="fe kv kw kx ky b">fork()</code>时，它使用的不是<code class="fe kv kw kx ky b">fork(2)</code>而是来自<code class="fe kv kw kx ky b">glibc</code>的<code class="fe kv kw kx ky b">fork(3p)</code>，而<code class="fe kv kw kx ky b">fork(3p)</code>又被别名为<code class="fe kv kw kx ky b"><a class="ae kz" href="https://github.com/bminor/glibc/blob/master/sysdeps/nptl/fork.c#L149" rel="noopener ugc nofollow" target="_blank">__libc_fork()</a></code>:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="404a" class="lp lq it ky b gy mv mw l mx my">...<br/>weak_alias (__libc_fork, __fork)<br/>libc_hidden_def (__fork)<br/>weak_alias (__libc_fork, fork)</span></pre><p id="3b19" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<code class="fe kv kw kx ky b">__libc_fork()</code>内部，通过调用<code class="fe kv kw kx ky b"><a class="ae kz" href="https://github.com/bminor/glibc/blob/master/sysdeps/unix/sysv/linux/arch-fork.h#L32" rel="noopener ugc nofollow" target="_blank">arch_fork()</a></code>宏来实现“魔法”:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="3307" class="lp lq it ky b gy mv mw l mx my">...<br/>pid = arch_fork (&amp;THREAD_SELF-&gt;tid);<br/>...</span></pre><p id="2d16" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过<code class="fe kv kw kx ky b">grep</code>在<code class="fe kv kw kx ky b">glibc</code>的源代码中找到它:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="54ea" class="lp lq it ky b gy mv mw l mx my">[setevoy@setevoy-arch-work ~/Temp/glibc] [master*] $ grep -r arch_fork .<br/>./ChangeLog: (arch_fork): Issue INLINE_CLONE_SYSCALL if defined.<br/>./ChangeLog: * sysdeps/nptl/fork.c (ARCH_FORK): Replace by arch_fork.<br/>./ChangeLog: * sysdeps/unix/sysv/linux/arch-fork.h (arch_fork): New function.<br/>./sysdeps/unix/sysv/linux/arch-fork.h:/* arch_fork definition for Linux fork implementation.<br/>./sysdeps/unix/sysv/linux/arch-fork.h:arch_fork (void *ctid)<br/>./sysdeps/nptl/fork.c: pid = arch_fork (&amp;THREAD_SELF-&gt;tid);</span></pre><p id="0e18" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe kv kw kx ky b">arch_fork()</code>在<code class="fe kv kw kx ky b"><a class="ae kz" href="https://github.com/bminor/glibc/blob/master/sysdeps/unix/sysv/linux/arch-fork.h#L32" rel="noopener ugc nofollow" target="_blank">sysdeps/unix/sysv/linux/arch-fork.h</a></code>文件中描述，该文件将调用<code class="fe kv kw kx ky b">clone()</code>:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="9056" class="lp lq it ky b gy mv mw l mx my">...<br/>ret = INLINE_SYSCALL_CALL (clone, flags, 0, NULL, 0, ctid);<br/>...</span></pre><p id="be4c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将在<code class="fe kv kw kx ky b">strace</code>的日志中看到。</p><p id="6c9e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了检查是否如此，我们真的使用了<code class="fe kv kw kx ky b">glibc fork()</code>而不是系统调用——让我们通过使用GNU的官方<a class="ae kz" href="https://www.gnu.org/software/libc/manual/html_node/Process-Creation-Example.html" rel="noopener ugc nofollow" target="_blank">文档</a>写一些小的C程序:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="2f0e" class="lp lq it ky b gy mv mw l mx my">#include &lt;unistd.h&gt;<br/>#include &lt;sys/wait.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>int main () {<br/>  pid_t pid;<br/>  pid = fork ();<br/>  if (pid == 0) {<br/>      printf("Child created\n");<br/>      sleep(100);<br/>  }<br/>}</span></pre><p id="e616" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这里的<code class="fe kv kw kx ky b">pid = fork()</code>中，我们以同样的方式调用<code class="fe kv kw kx ky b">fork()</code>，就像它被<code class="fe kv kw kx ky b">rdbSaveBackground()</code>函数调用一样。</p><p id="cac9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后让我们使用<code class="fe kv kw kx ky b">ltrace</code>来跟踪一个库函数(不像<code class="fe kv kw kx ky b">strace</code>用于跟踪系统调用):</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="2dc4" class="lp lq it ky b gy mv mw l mx my">$ ltrace -C -f ./test_fork_lib<br/>[pid 5530] fork( &lt;unfinished …&gt;<br/>[pid 5531] &lt;… fork resumed&gt; ) = 0<br/>[pid 5530] &lt;… fork resumed&gt; ) = 5531<br/>[pid 5531] puts(“Child created” &lt;no return …&gt;<br/>[pid 5530] +++ exited (status 0) +++<br/>Child created<br/>[pid 5531] &lt;… puts resumed&gt; ) = 14<br/>[pid 5531] sleep(100) = 0</span></pre><p id="cc7b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过使用<code class="fe kv kw kx ky b">lsof</code>工具——找到我们的进程打开的所有文件:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="da59" class="lp lq it ky b gy mv mw l mx my">[setevoy@setevoy-arch-work ~/Temp/glibc] [master*] $ lsof -p 5531<br/>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br/>test_fork 5531 setevoy cwd DIR 254,3 4096 4854992 /home/setevoy/Temp/glibc<br/>test_fork 5531 setevoy rtd DIR 254,2 4096 2 /<br/>test_fork 5531 setevoy txt REG 254,3 16648 4855715 /home/setevoy/Temp/glibc/test_fork_lib<br/>test_fork 5531 setevoy mem REG 254,2 2133648 396251 /usr/lib/libc-2.29.so<br/>…</span></pre><p id="1df4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">或者通过使用<code class="fe kv kw kx ky b">ldd</code>——检查哪些库将被用来使代码工作:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="28fb" class="lp lq it ky b gy mv mw l mx my">[setevoy@setevoy-arch-work ~/Temp/glibc] [master*] $ ldd test_fork_lib<br/>…<br/>libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f26ba77f000)</span></pre><p id="e631" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe kv kw kx ky b">libc-2.29.so</code>取自<code class="fe kv kw kx ky b">glibc</code>包:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="e024" class="lp lq it ky b gy mv mw l mx my">[setevoy@setevoy-arch-work ~/Temp/glibc] [master*] $ pacman -Ql glibc | grep libc-2.29.so<br/>glibc /usr/lib/libc-2.29.so</span></pre><p id="ccc7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">检查库文件中函数的另一种方法——使用<code class="fe kv kw kx ky b">objdump</code>工具:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="b67a" class="lp lq it ky b gy mv mw l mx my">[setevoy@setevoy-arch-work ~/Temp/linux] [master*] $ objdump -T /usr/lib/libc.so.6 | grep fork<br/>00000000000c93c0 g DF .text 00000000000001fe GLIBC_PRIVATE __libc_fork</span></pre><p id="44e1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe kv kw kx ky b">__libc_fork</code> -这是我们在<code class="fe kv kw kx ky b">.text</code>部分的函数(更多信息请参见<a class="ae kz" href="https://rtfm.co.ua/linux-c-adresnoe-prostranstvo-processa/" rel="noopener ugc nofollow" target="_blank">Linux:c—адресноепроститтввопроцесса</a>和<a class="ae kz" href="https://rtfm.co.ua/c-sozdanie-i-primenenie-shared-library-v-linux/" rel="noopener ugc nofollow" target="_blank">c:созданиеие</a></p><h2 id="0b3e" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated">Redis — fork:无法分配内存—原因</h2><p id="b267" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated"><em class="la">同样，由于下面的文本最初是为俄语版翻译的，我将把文档复制粘贴到这里。阅读完整文档— </em> <a class="ae kz" href="https://redis.io/topics/faq#background-saving-fails-with-a-fork-error-under-linux-even-if-i-have-a-lot-of-free-ram" rel="noopener ugc nofollow" target="_blank"> <em class="la">后台保存失败Linux下有fork()错误即使我有很多空闲RAM </em> </a> <em class="la">。</em></p><p id="4934" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Redis后台保存模式依赖于现代操作系统中fork的写时复制语义:Redis forks(创建子进程)是父进程的精确副本。子进程将数据库转储到磁盘上，并最终退出。理论上，子进程应该使用与作为副本的父进程一样多的内存，但实际上，由于大多数现代操作系统实现的写时复制语义，父进程和子进程将共享公共内存页面。只有在子页面或父页面发生变化时，页面才会被复制。因为从理论上讲，当子进程保存内存时，所有的页面都可能改变，Linux不能预先知道子进程将占用多少内存，所以如果overcommit_memory设置被设置为零，fork将会失败，除非有足够的空闲RAM来复制所有的父内存页面，结果是如果您有一个3 GB的Redis数据集，而只有2 GB的空闲内存，那么它将会失败。</p><p id="0a8e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">将overcommit_memory设置为1告诉Linux放松下来，以更乐观的分配方式执行fork，这确实是您希望Redis实现的。</p><h2 id="47ad" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated"><code class="fe kv kw kx ky b">overcommit_memory</code>值</h2><p id="b419" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated"><code class="fe kv kw kx ky b">vm.overcommit_memory</code>可以包含以下三个值之一:</p><ul class=""><li id="129f" class="lb lc it jz b ka kb ke kf ki ld km le kq lf ku lg lh li lj bi translated"><strong class="jz iu"> 0 </strong>:内核将执行更多的虚拟内存分配，然后服务器执行，但是将依靠“启发式算法”(<a class="ae kz" href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" rel="noopener ugc nofollow" target="_blank"> <em class="la">启发式过量分配处理</em> </a>)来决定何时批准或拒绝进程的内存分配</li><li id="d6df" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><strong class="jz iu"> 1 </strong>:内核总是会执行过量提交，这会导致更多的<em class="la">内存不足</em>错误，但对于正在使用内存的服务来说可能是好事</li><li id="3d8e" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><strong class="jz iu"> 2 </strong>:内核将执行过量提交，但在<code class="fe kv kw kx ky b">overcommit_ratio</code>或<code class="fe kv kw kx ky b">overcommit_kbytes</code>参数设置的范围内</li></ul><h2 id="eee7" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated">著名的“启发式算法”(启发式过量使用处理)</h2><p id="a65f" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">在大多数文档/指南/指南等中，只提到了这个算法，但是要找到它的详细描述来理解它是如何工作的并不容易。</p><p id="9447" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">像往常一样— <em class="la">“只看出处！”</em></p><p id="65c1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">过量使用检查由内存管理模块的补充函数<code class="fe kv kw kx ky b"><a class="ae kz" href="https://elixir.bootlin.com/linux/v5.0.7/source/mm/util.c#L639" rel="noopener ugc nofollow" target="_blank">__vm_enough_memory()</a></code>执行，并在内核的<code class="fe kv kw kx ky b">mm/util.c</code>文件中描述。</p><p id="bd5f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此函数接受进程请求分配的页面数量，然后此函数将:</p><ol class=""><li id="8b32" class="lb lc it jz b ka kb ke kf ki ld km le kq lf ku mz lh li lj bi translated">如果overcommit_memory == 1 ( <code class="fe kv kw kx ky b">if (sysctl_overcommit_memory == OVERCOMMIT_ALWAYS)</code>):返回0并允许超量提交</li><li id="1cce" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">如果overcommit_memory == 0 ( <code class="fe kv kw kx ky b">if (sysctl_overcommit_memory == OVERCOMMIT_GUESS)</code>和<code class="fe kv kw kx ky b">sysctl_overcommit_memory</code> <a class="ae kz" href="https://elixir.bootlin.com/linux/v5.0.7/source/mm/util.c#L555" rel="noopener ugc nofollow" target="_blank">默认设置为</a>OVERCOMMIT_GUESS，OVERCOMMIT _ GUESS设置为<code class="fe kv kw kx ky b"><a class="ae kz" href="https://elixir.bootlin.com/linux/v5.0.7/source/include/uapi/linux/mman.h#L11" rel="noopener ugc nofollow" target="_blank">linux/mman.h</a></code>文件中的0):</li><li id="57bd" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">现在统计所有空闲页面并保存到<code class="fe kv kw kx ky b">free</code>变量:<br/> <code class="fe kv kw kx ky b">free = global_zone_page_state(NR_FREE_PAGES)</code></li><li id="977c" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">将<code class="fe kv kw kx ky b">free</code>增加到<a class="ae kz" href="https://en.wikipedia.org/wiki/Memory-mapped_file" rel="noopener ugc nofollow" target="_blank">文件备份</a>(参见<a class="ae kz" href="https://techtalk.intersec.com/2013/07/memory-part-1-memory-types/#File-backed_and_Swap" rel="noopener ugc nofollow" target="_blank">文件备份和交换</a>、<a class="ae kz" href="https://en.wikipedia.org/wiki/Memory-mapped_file" rel="noopener ugc nofollow" target="_blank">内存映射文件</a>)内存页的数量，即通过交换到磁盘可以释放的页面:<br/> <code class="fe kv kw kx ky b">free += global_node_page_state(NR_FILE_PAGES)</code></li><li id="e9bc" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">通过共享内存减少<code class="fe kv kw kx ky b">free</code>(参见<a class="ae kz" href="https://techtalk.intersec.com/2013/07/memory-part-1-memory-types/#Shared_Memory," rel="noopener ugc nofollow" target="_blank">共享内存</a>、<a class="ae kz" href="https://en.wikipedia.org/wiki/Shared_memory" rel="noopener ugc nofollow" target="_blank">共享内存</a>)页数<br/> <code class="fe kv kw kx ky b">free -= global_node_page_state(NR_SHMEM)</code></li><li id="6efa" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">通过添加交换页<br/> <code class="fe kv kw kx ky b">free += get_nr_swap_pages()</code>来增加<code class="fe kv kw kx ky b">free</code></li><li id="4c75" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">增加由SReclaimable(参见<code class="fe kv kw kx ky b"><a class="ae kz" href="http://man7.org/linux/man-pages/man5/proc.5.html" rel="noopener ugc nofollow" target="_blank">man 5 proc</a></code>SReclaimable编号<br/>T13】</li><li id="e21d" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">按KReclaimable(见<code class="fe kv kw kx ky b"><a class="ae kz" href="http://man7.org/linux/man-pages/man5/proc.5.html" rel="noopener ugc nofollow" target="_blank">man 5 proc</a></code> <em class="la"> KReclaimable </em>)号<br/> <code class="fe kv kw kx ky b">free += global_node_page_state(NR_KERNEL_MISC_RECLAIMABLE)</code>增加</li><li id="6a7f" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">减少最小保留页面(参见<code class="fe kv kw kx ky b"><a class="ae kz" href="https://elixir.bootlin.com/linux/v5.0.7/source/mm/page_alloc.c#L7394" rel="noopener ugc nofollow" target="_blank">calculate_totalreserve_pages()</a></code>和<a class="ae kz" href="https://lwn.net/Articles/178850/" rel="noopener ugc nofollow" target="_blank">一个增强的OVERCOMMIT_GUESS </a> ) <br/> <code class="fe kv kw kx ky b">free -= totalreserve_pages</code></li><li id="799b" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">减少为根用户保留的内存(см。<code class="fe kv kw kx ky b"><a class="ae kz" href="https://elixir.bootlin.com/linux/v5.0.7/source/mm/mmap.c#L3676" rel="noopener ugc nofollow" target="_blank">init_admin_reserve()</a></code> ) <br/> <code class="fe kv kw kx ky b">free -= sysctl_admin_reserve_kbytes</code></li><li id="fbce" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku mz lh li lj bi translated">最后一步是检查当前可用的内存——以及一个进程所请求的——如果我们上面所有的计算的<code class="fe kv kw kx ky b">free</code>变量将包含足够的页面——它将返回0值:<br/> <code class="fe kv kw kx ky b">if (free &gt; pages) return 0;</code></li></ol><p id="037d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">参见<a class="ae kz" href="https://utcc.utoronto.ca/~cks/space/blog/linux/LinuxVMOvercommit" rel="noopener ugc nofollow" target="_blank">Linux如何处理虚拟内存过量使用</a>、<a class="ae kz" href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" rel="noopener ugc nofollow" target="_blank">过量使用-会计</a>、<a class="ae kz" href="https://www.kernel.org/doc/gorman/html/understand/understand016.html" rel="noopener ugc nofollow" target="_blank">检查可用内存</a>。</p><h2 id="b35d" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated">检查<code class="fe kv kw kx ky b">vm.overcommit_memory</code></h2><p id="2cb1" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">嗯——这只是一个理论——现在还不是时候真正看看在<code class="fe kv kw kx ky b">vm.overcommit_memory</code>变化期间这一切是如何工作的，内存一般是如何分配的。</p><p id="ef5b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们使用下一个简单的代码:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="53b6" class="lp lq it ky b gy mv mw l mx my">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;fcntl.h&gt;<br/><br/>int main() {<br/>    <br/>    printf("main() started\n");<br/>    <br/>    long int mem_size = 4096;<br/>    <br/>    void *mem_stack = malloc(mem_size);<br/>    <br/>    printf("Parent pid: %lu\n", getpid());<br/><br/>    sleep(1200);<br/>}</span></pre><p id="84e8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<code class="fe kv kw kx ky b">void *mem_stack = malloc(mem_size)</code>行中，我们被请求分配4096字节，这是在<code class="fe kv kw kx ky b">mem_size</code>变量中设置的。</p><p id="9da6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">检查当前<code class="fe kv kw kx ky b">overcommit_memory</code>值:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="964e" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# cat /proc/sys/vm/overcommit_memory 0</span></pre><p id="a0fe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">运行我们的程序:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="a796" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# ./test_vm<br/>main() started<br/>Parent pid: 14353</span></pre><p id="a350" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在检查进程使用的内存:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="0d7f" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# ps aux | grep test_vm | grep -v grep<br/>root 14353 0.0 0.0 4160 676 pts/4 S+ 17:29 0:00 ./test_vm</span></pre><p id="ee14" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">VSZ(虚拟尺寸)——正如我们在<code class="fe kv kw kx ky b">malloc(mem_size)</code>电话中所要求的。</p><p id="d57f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在—将<code class="fe kv kw kx ky b">mem_size</code>变量值从4个<em class="la"> 096 </em>字节更改为<em class="la">1099511627776</em>-<strong class="jz iu">1tb</strong>:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="0322" class="lp lq it ky b gy mv mw l mx my">...<br/>long int mem_size = 1099511627776;<br/>...</span></pre><p id="a1de" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">构建、运行，然后:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="5359" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# ./test_vm<br/>main() started<br/>Segmentation fault</span></pre><p id="b281" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">太好了！</p><p id="2390" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">用<code class="fe kv kw kx ky b">strace</code>检查:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="5a6b" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# strace -e trace=mmap ./test_vm<br/>mmap(NULL, 47657, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fa268f24000<br/>mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa268f22000<br/>mmap(NULL, 3795296, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fa26896e000<br/>mmap(0x7fa268d03000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x195000) = 0x7fa268d03000<br/>mmap(0x7fa268d09000, 14688, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fa268d09000<br/>main() started<br/>mmap(NULL, 1099511631872, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = -1 ENOMEM (Cannot allocate memory)<br/>mmap(NULL, 1099511762944, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = -1 ENOMEM (Cannot allocate memory)<br/>mmap(NULL, 134217728, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0) = 0x7fa26096e000<br/>mmap(NULL, 1099511631872, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = -1 ENOMEM (Cannot allocate memory)<br/> — — SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0xfffffffff8} — -<br/>+++ killed by SIGSEGV +++<br/>Segmentation fault</span></pre><p id="8f00" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">而这里是我们可爱的<strong class="jz iu"> -1 ENOMEM ( <em class="la">无法分配内存</em> ) </strong>，我们可以在Redis日志中看到其“<strong class="jz iu">无法后台保存:fork: <em class="la">无法分配内存</em>”</strong>错误信息。</p><p id="91b4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里是调用<code class="fe kv kw kx ky b"><a class="ae kz" href="https://elixir.bootlin.com/linux/v5.0.21/source/include/linux/security.h#L497" rel="noopener ugc nofollow" target="_blank">security_vm_enough_memory_mm()</a></code>函数的<code class="fe kv kw kx ky b"><a class="ae kz" href="https://elixir.bootlin.com/linux/v5.0.21/source/mm/mmap.c#L2323" rel="noopener ugc nofollow" target="_blank">mmap()</a></code>系统调用:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="3745" class="lp lq it ky b gy mv mw l mx my">...<br/>    if (security_vm_enough_memory_mm(mm, grow))<br/>        return -ENOMEM;<br/>...</span></pre><p id="4ee6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在<code class="fe kv kw kx ky b">security.h</code>头文件中描述了什么，<code class="fe kv kw kx ky b"><a class="ae kz" href="https://rtfm.co.ua/goto/https://elixir.bootlin.com/linux/v5.0.7/source/mm/util.c#L639" rel="noopener ugc nofollow" target="_blank">__vm_enough_memory()</a></code>在哪里被调用:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="2c2a" class="lp lq it ky b gy mv mw l mx my">...<br/>static inline int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)<br/>{<br/>    return __vm_enough_memory(mm, pages, cap_vm_enough_memory(mm, pages));<br/>}<br/>...</span></pre><p id="f956" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在—禁用超量承诺限制检查:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="5ff7" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# echo 1 &gt; /proc/sys/vm/overcommit_memory</span></pre><p id="afd6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">再次运行程序:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="36f7" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# ./test_vm<br/>main() started<br/>Parent pid: 11337<br/>Child pid: 11338<br/>Child is running with PID 11338</span></pre><p id="034f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">检查现在使用的VSZ:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="84bb" class="lp lq it ky b gy mv mw l mx my">admin@bttrm-dev-console:~/redis-logs$ ps aux | grep -v grep | grep 11337<br/>root 11337 0.0 0.0 1073745988 656 pts/4 S+ 16:34 0:00 ./test_vm</span></pre><p id="8521" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">VSZ == <strong class="jz iu"> 1073745988 </strong> —太棒了:我们刚刚在AWS <a class="ae kz" href="https://www.ec2instances.info/?selected=t2.medium" rel="noopener ugc nofollow" target="_blank"> t2.medium </a> EC2实例上分配了1tb的虚拟内存，而只有4g的“真实”内存！</p><p id="5a86" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在——猜猜会发生什么，一个子进程将开始积极使用这个分配的虚拟(尚未)内存？</p><p id="f46f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">添加<code class="fe kv kw kx ky b"><a class="ae kz" href="http://man7.org/linux/man-pages/man3/memset.3.html" rel="noopener ugc nofollow" target="_blank">memset()</a></code>系统调用，通过填充整个<code class="fe kv kw kx ky b">mem_size</code>将0设置到我们的<code class="fe kv kw kx ky b">mem_stack</code>中，例如1 TB:</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="5d9d" class="lp lq it ky b gy mv mw l mx my">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;fcntl.h&gt;<br/><br/>int main() {<br/>    <br/>    printf("main() started\n");<br/>    <br/>    long int mem_size = 1099511627776;<br/>    <br/>    void *mem_stack = malloc(mem_size);<br/>    <br/>    printf("Parent pid: %lu\n", getpid());<br/>                <br/>    memset(mem_stack, 0, mem_size);<br/><br/>    sleep(120);<br/>}</span></pre><p id="2747" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">运行它(<strong class="jz iu">不要在生产环境中运行它！</strong>):</p><pre class="mn mo mp mq gt mr ky ms mt aw mu bi"><span id="3deb" class="lp lq it ky b gy mv mw l mx my">root@bttrm-dev-console:/home/admin# ./test_vm<br/>main() started<br/>Parent pid: 15219<br/>Killed</span></pre><p id="a843" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">并检查操作系统的日志:</p><blockquote class="na nb nc"><p id="8757" class="jx jy la jz b ka kb kc kd ke kf kg kh nd kj kk kl ne kn ko kp nf kr ks kt ku im bi translated">8月27日17:46:43本地主机内核:[7974462.384723]内存不足:终止进程15219 (test_vm)分数818或牺牲子进程<br/>8月27日17:46:43本地主机内核:[7974462.393395]终止进程15219 (test_vm)总数-vm:1073745988kB，anon-RSS:3411695</p></blockquote><p id="9b79" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">OOM黑仔来到这里，杀了所有人。这个时候。下次可能就来不及了。</p><p id="5032" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，我们的进程有时间从给定的1tb虚拟内存中消耗掉整个3.4 GB的实际内存—<em class="la">anon-RSS:3411676k</em>—total—VM:1073745988 kb。</p><h2 id="204b" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated">结论</h2><p id="aad9" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">在我们当前的例子中，当Redis仅用于缓存，并且没有启用RDB或AOF备份时——不需要更改<code class="fe kv kw kx ky b">overcommit_memory</code>,最好保留默认值- 0。</p><p id="12f1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你真的想自己设定界限，最好使用<code class="fe kv kw kx ky b">overcommit_memory</code> == 2，并通过设置<code class="fe kv kw kx ky b">overcommit_ratio</code>或<code class="fe kv kw kx ky b">overcommit_kbytes</code>参数来限制过度承诺。</p><h2 id="95c0" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated">故事</h2><p id="8c0d" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">事实上，关于<code class="fe kv kw kx ky b">vm.overcommit_memory</code>的整个故事开始于大约一年前。</p><p id="9d24" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当时我对Redis还不太熟悉，我刚刚来到已经使用Redis的新项目。</p><p id="5fae" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在完美的一天——我们的生产服务器(当我刚开始这个项目时——整个后端都在唯一的AWS EC2上工作)有点累了，去休息了。</p><p id="d9aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在通过AWS控制台进行神奇的dropkick之后——服务器重新上线，我开始寻找根本原因。</p><p id="0a63" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在它的日志中，我发现了一些关于OOM黑仔的记录，这些记录都在Redis或RabbitMQ上——现在还不确定。但无论如何，在调查过程中，我发现<code class="fe kv kw kx ky b">vm.overcommit_memory</code>被设置为1，即完全禁用。</p><p id="024e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">总之，这个故事首先给了我一个理由，为我们的后端基础设施创建一个更可靠和容错的架构，其次，教会我不要盲目相信任何文档。</p><h2 id="6816" class="lp lq it bd lr ls lt dn lu lv lw dp lx ki ly lz ma km mb mc md kq me mf mg mh bi translated">有用的链接</h2><ul class=""><li id="4444" class="lb lc it jz b ka mi ke mj ki ng km nh kq ni ku lg lh li lj bi translated">【Linux下后台保存失败，出现fork()错误，即使我有很多空闲RAM！</li><li id="c362" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://redis.io/topics/persistence" rel="noopener ugc nofollow" target="_blank"> Redis持久性</a></li><li id="a73c" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://eli.thegreenplace.net/2018/launching-linux-threads-and-processes-with-clone/" rel="noopener ugc nofollow" target="_blank">使用克隆启动Linux线程和进程</a></li><li id="3f24" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://thorstenball.com/blog/2014/06/13/where-did-fork-go/" rel="noopener ugc nofollow" target="_blank">叉子去哪了？</a></li><li id="4741" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://www.etalabs.net/overcommit.html" rel="noopener ugc nofollow" target="_blank">什么是过度承诺？为什么不好？</a></li><li id="1ef5" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://devarea.com/linux-fork-system-call-and-its-pitfalls/#.XWVUanVfg3F" rel="noopener ugc nofollow" target="_blank"> Linux — fork系统调用及其陷阱</a></li><li id="5662" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://filippo.io/linux-syscall-table/" rel="noopener ugc nofollow" target="_blank">面向x86和x86_64的可搜索Linux系统调用表</a></li><li id="06ca" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="http://eastrivervillage.com/The-Linux-COW/" rel="noopener ugc nofollow" target="_blank">Linux奶牛</a></li><li id="a7ef" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://www.win.tue.nl/~aeb/linux/lk/lk-9.html" rel="noopener ugc nofollow" target="_blank">物理和虚拟内存</a></li><li id="d03d" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://www.systutorials.com/docs/linux/man/3-mtrace/" rel="noopener ugc nofollow" target="_blank"> mtrace (3) — Linux手册页</a></li><li id="082e" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://www.kernel.org/doc/gorman/html/understand/understand016.html" rel="noopener ugc nofollow" target="_blank">内存不足管理</a></li><li id="e07f" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" rel="noopener ugc nofollow" target="_blank">内核过量使用-会计</a></li><li id="9e24" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="http://engineering.pivotal.io/post/virtual_memory_settings_in_linux_-_the_problem_with_overcommit/" rel="noopener ugc nofollow" target="_blank">Linux中的虚拟内存设置——过量使用的问题</a></li><li id="5418" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://techtalk.intersec.com/2013/07/memory-part-1-memory-types/#Shared_Memory" rel="noopener ugc nofollow" target="_blank">存储器—第1部分:存储器类型</a></li><li id="8bb8" class="lb lc it jz b ka lk ke ll ki lm km ln kq lo ku lg lh li lj bi translated"><a class="ae kz" href="https://linux-kernel-labs.github.io/master/labs/memory_mapping.html#struct-page" rel="noopener ugc nofollow" target="_blank">内存映射</a></li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="0704" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="la">最初发布于</em> <a class="ae kz" href="https://rtfm.co.ua/en/redis-fork-cannot-allocate-memory-linux-virtual-memory-and-vm-overcommit_memory/" rel="noopener ugc nofollow" target="_blank"> <em class="la"> RTFM: Linux、DevOps和系统管理</em> </a> <em class="la">。</em></p></div></div>    
</body>
</html>