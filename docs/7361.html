<html>
<head>
<title>Native iOS Game Development w/ Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Rust的原生iOS游戏开发</h1>
<blockquote>原文：<a href="https://itnext.io/native-ios-game-development-w-rust-a1134887c35f?source=collection_archive---------0-----------------------#2022-09-01">https://itnext.io/native-ios-game-development-w-rust-a1134887c35f?source=collection_archive---------0-----------------------#2022-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e10e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我用纯Rust探索跨平台游戏开发的记录之旅。</p><blockquote class="ko kp kq"><p id="0bd8" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">说真的。100%生锈或破裂！</p></blockquote><p id="bbcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一篇:<a class="ae kv" href="https://medium.com/@wadecodez/rust-native-ios-touch-events-8b01418e0f3b" rel="noopener"> <strong class="js iu">原生iOS触摸事件w/ Rust </strong> </a></p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/29b33505d0b660c816b03aba96c0c0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tcx3rsqb2f2IZ-nV.png"/></div></div></figure><h1 id="5b39" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">为什么我选择了铁锈</h1><p id="6078" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">当谈到性能和模块化设计时，Rust是一个热门话题，但在撰写本文时，Rust社区中只有iOS开发的微弱消息。所以我选择Rust是因为我想要一个跨平台的系统编程语言。</p><blockquote class="ko kp kq"><p id="5acf" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">后知之明:我喜欢Rust的地方</strong></p><p id="f0a8" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">在深入研究Rust几个星期后，我发现一些最可怕的特性令人惊讶地令人愉快。虽然有一个学习曲线，但事后看来，我真的很欣赏Rust的以下特性。</p><p id="8568" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">没有OOP</p><p id="83ab" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">模块化代码</p><p id="b07d" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">文档生态系统</p><p id="80d8" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">构建系统</p><p id="fb1d" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">包装管理</p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="6302" class="li lj it bd lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf bi translated">我探索铁锈的目标</h1><p id="3462" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我的目标是找到一种语言，它允许我编写跨平台的代码，而不需要经历一系列困难。作为一名业余爱好者，我没有以前那么多时间去学习新语言或钻研框架。</p><p id="3a1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终我想在App Store上发布一个成品，但是现在我的目标是编译一些东西。如果Rust允许我去掉大部分(如果不是全部的话)Swift和Objective-C编程，我会很高兴。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="98b1" class="li lj it bd lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf bi translated">0.项目环境设置</h1><p id="162b" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">进入这个项目，我知道我会频繁地修改环境变量和构建脚本。所以在开始使用Rust之前，我增强了我的<code class="fe mx my mz na b">.bashrc</code>,这使得我可以很容易地对我的开发环境进行大的修改。</p><p id="0998" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的脚本允许我从我的<code class="fe mx my mz na b">~/code</code>文件夹中的任何项目目录扩展我的<code class="fe mx my mz na b">.bashrc</code>，向上遍历直到找到一个名为<code class="fe mx my mz na b">.devenv</code>的文件夹。从那里我可以获得每个项目的bash脚本。</p><pre class="kx ky kz la gt nb na nc bn nd ne bi"><span id="0b07" class="nf lj it na b be ng nh l ni nj"># get the first match from `find` while traversing upwards<br/>function find_above {<br/>    old_pwd="$PWD"<br/>    while [[ "$PWD" == $HOME/code/* ]] ; do<br/>        new_pwd=`find "$PWD"/ -maxdepth 1 "$@"`<br/><br/>        if [[ "$new_pwd" ]]; then<br/>            break<br/>        fi<br/><br/>        cd ..<br/>    done<br/><br/>    echo "$new_pwd"<br/>    cd "$old_pwd"<br/>    old_pwd=""<br/>    new_pwd=""<br/>}</span></pre><p id="fc0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我使用该方法寻找本地<code class="fe mx my mz na b">.bashrc</code>的部分。每次切换项目时，我都必须重新开发我的环境，但这不是问题。</p><pre class="kx ky kz la gt nb na nc bn nd ne bi"><span id="d232" class="nf lj it na b be ng nh l ni nj"># see code above<br/><br/>ENVDIR=$(find_above -type d -name ".devenv")<br/>if [[ "$ENVDIR" ]]; then<br/>    source "$ENVDIR/.bashrc"<br/>fi</span></pre><h1 id="4c2b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建别名</h1><p id="e33e" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">现在我的机器可以处理每个项目的bash环境，我设置了几个命令来快速跳过我的代码。</p><pre class="kx ky kz la gt nb na nc bn nd ne bi"><span id="94eb" class="nf lj it na b be ng nh l ni nj"># ~/code/tictactoe/.devenv/.bashrc<br/>echo "detected local env: $PWD"<br/><br/># src directory<br/>export SRCDIR=$(find_above -name "src")<br/><br/># root directory<br/>export ROOTDIR=$(dirname $SRCDIR)<br/><br/># build directory<br/>export BUILDDIR="$ROOTDIR/target"<br/>mkdir -p "$BUILDDIR"<br/><br/># lib directory<br/>export LIBDIR="$ROOTDIR/src"<br/>mkdir -p "$LIBDIR"<br/><br/># bin directory<br/>export BINDIR="$ROOTDIR/.devenv/bin"<br/>mkdir -p "$BINDIR"<br/>export PATH="$BINDIR:$PATH"<br/><br/>export RUST_LOG="warn,handmade=debug"<br/>export RUST_BACKTRACE=1<br/><br/># aliases<br/>alias c="cargo build"<br/>alias clean="clean"<br/>alias s="source $HOME/.zshrc"<br/>alias root="cd $ROOTDIR"<br/>alias r="cargo run"<br/>alias t="cargo test"<br/>alias i="run-ios-sim.sh"<br/>alias cr="c &amp;&amp; r"</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9c94" class="li lj it bd lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf bi translated">1.Hello World Rust/Bevy</h1><p id="d07e" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">几周前，我想从尽可能低的水平开始。我想写自己的图形渲染器和游戏引擎。然而，大约3天零进展后，我放弃了那个梦想，寻找一个Rust游戏引擎。<em class="kr">大概是先试跑再学走的经典场景。</em></p><h1 id="e3b3" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">安装Bevy</h1><p id="6360" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">所以很自然地，我下载了我能找到的第一个游戏引擎。这是一个非常好的框架。Bevy是一个游戏引擎，它是围绕高度模块化的应用程序而设计的。我已经用了几个星期的图书馆了，非常棒！</p><pre class="kx ky kz la gt nb na nk nl aw nm bi"><span id="f905" class="nn lj it na b gy no np l nq nj">cargo add bevy</span></pre><h1 id="630d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用Bevy范式编写代码</h1><p id="b477" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">这是在Mac OS上使用Bevy的Hello world:</p><pre class="kx ky kz la gt nb na nc bn nd ne bi"><span id="8554" class="nf lj it na b be ng nh l ni nj">use bevy::prelude::*;<br/><br/>fn main() {<br/>    App::new()<br/>        .add_system(hello_world_system)<br/>        .run();<br/>}<br/><br/>fn hello_world_system() {<br/>    println!("Hello Rust");<br/>}</span></pre><p id="a773" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意我没有直接调用<code class="fe mx my mz na b">println</code>。这是因为Bevy提供了一个非常类似于<code class="fe mx my mz na b">ExpressJS</code>中路由系统的框架。在更大的项目中，你可以在模块/插件中提取功能，每个插件都可以访问上下文来注册更多的系统。</p><h1 id="f8f4" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">运行Bevy Hello World</h1><pre class="kx ky kz la gt nb na nk nl aw nm bi"><span id="6894" class="nn lj it na b gy no np l nq nj">cargo run</span></pre><h1 id="a754" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">GUI在哪里？</h1><p id="c207" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">Bevy将其所有组件隔离成插件，所以如果你想放弃整个“游戏引擎”的东西，你可以这样做！你也可以在无头模式下运行Bevy！尽管为了这个实验，我启用了默认插件。</p><pre class="kx ky kz la gt nb na nc bn nd ne bi"><span id="e04c" class="nf lj it na b be ng nh l ni nj">use bevy::prelude::*;<br/><br/>fn main() {<br/>    App::new()<br/>        .add_plugins(DefaultPlugins)<br/>        // ...<br/>        .run();<br/>}<br/><br/>// ...</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="c04f" class="li lj it bd lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf bi translated">2.为iOS构建(跨平台前期)</h1><p id="ec5c" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我想立即尝试为iOS编译<code class="fe mx my mz na b">hello world</code>。这节省了我大量的前期时间，因为如果我不能让iOS与Rust一起工作，那么这个项目就是失败的。此外，没有什么比编写一个项目，然后在事后试图将其移植到另一个系统更困难的了。</p><blockquote class="ko kp kq"><p id="53ca" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">后见之明:警告导致发现</strong></p><p id="d9c5" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">我花了很长时间才成功编译。最初，我认为我需要使用 <code class="fe mx my mz na b"><em class="it">extern "C"</em></code> <em class="it">创建一个头桥，但事实并非如此。一切都用纯Rust代码工作！</em></p></blockquote><h1 id="157b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">集束</h1><p id="582a" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">有一个用于cargo的构建工具，让我可以毫不费力地为iOS编译和打包。首先安装构建工具:</p><pre class="kx ky kz la gt nb na nk nl aw nm bi"><span id="6d7c" class="nn lj it na b gy no np l nq nj">cargo install cargo-bundle</span></pre><h2 id="6415" class="nn lj it bd lk nr ns dn lo nt nu dp ls kb nv nw lw kf nx ny ma kj nz oa me ob bi translated">添加编译目标</h2><p id="995a" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">然后你可以列出Rust支持的所有可能的构建目标。因为我的目标是iOS，所以我运行了以下命令:</p><pre class="kx ky kz la gt nb na nk nl aw nm bi"><span id="7a08" class="nn lj it na b gy no np l nq nj">rustup target list | grep ios</span></pre><p id="33b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您缺少作为目标的iOS，您可以基于您的机器的架构添加一个新的目标。</p><pre class="kx ky kz la gt nb na nc bn nd ne bi"><span id="5a2a" class="nf lj it na b be ng nh l ni nj"># for production<br/>rustup target add aarch64-apple-ios<br/><br/># for development<br/>rustup target add aarch64-apple-ios-sim</span></pre><h1 id="4011" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">iOS模拟器的打包</h1><p id="c48c" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">一旦您的系统<strong class="js iu">上有了可用的编译目标，并且您在Mac </strong>上，您可以使用下面的脚本或者复制并粘贴以下命令来将您的应用程序注入模拟器。大多数命令都是XCode附带的。</p><p id="1e75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该脚本使用<a class="ae kv" href="https://github.com/TomWright/dasel" rel="noopener ugc nofollow" target="_blank"> dasel </a>从项目<code class="fe mx my mz na b">Cargo.toml</code>文件中查询名称和包标识符。</p><pre class="kx ky kz la gt nb na nk nl aw nm bi"><span id="2220" class="nn lj it na b gy no np l nq nj">brew install dasel</span></pre><p id="6374" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用XCode提供的一系列命令，我可以在不启动GUI的情况下使用iPhone模拟器。关于这个脚本中的命令如何工作的更多信息可以使用这个<a class="ae kv" href="https://nshipster.com/simctl/" rel="noopener ugc nofollow" target="_blank">备忘单</a>找到。</p><pre class="kx ky kz la gt nb na nc bn nd ne bi"><span id="57dd" class="nf lj it na b be ng nh l ni nj">#/usr/bin/env bash<br/><br/>APP_NAME="$(cat Cargo.toml | dasel -r toml '.package.name')"<br/>BUNDLE_ID="$(cat Cargo.toml | dasel -r toml '.package.metadata.bundle.identifier')"<br/><br/>cargo bundle --target aarch64-apple-ios-sim<br/>xcrun simctl boot "iPhone 12 mini"  <br/>open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app <br/>xcrun simctl install booted "target/aarch64-apple-ios-sim/debug/bundle/ios/$APP_NAME.app"<br/>xcrun simctl launch --console booted "$BUNDLE_ID"</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="1c10" class="li lj it bd lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf bi translated">3.项目成功！</h1><p id="a71a" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">如果一切正常，我应该会有一个iOS应用程序向我的终端发送“Hello Rust ”,并满足以下标准:</p><ul class=""><li id="6f03" class="oc od it js b jt ju jx jy kb oe kf of kj og kn oh oi oj ok bi translated">完全用铁锈写的</li><li id="36e5" class="oc od it js b jt ol jx om kb on kf oo kj op kn oh oi oj ok bi translated">没有桥接代码</li><li id="f595" class="oc od it js b jt ol jx om kb on kf oo kj op kn oh oi oj ok bi translated">没有XCode</li><li id="dd42" class="oc od it js b jt ol jx om kb on kf oo kj op kn oh oi oj ok bi translated">标准设计</li><li id="14c4" class="oc od it js b jt ol jx om kb on kf oo kj op kn oh oi oj ok bi translated">灵活的开发环境</li></ul><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi oq"><img src="../Images/bfadb630bd1e5208faeb4b48e56537db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ov_3eqcvrfF5HMD-.png"/></div></div></figure><h1 id="2b8c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">待续</h1><p id="6121" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">如果您想将项目的其余部分作为一个系列来记录或共享源代码，请关注、鼓掌并发表评论！它帮助我保持动力</p><p id="969d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下篇:<a class="ae kv" href="https://medium.com/@wadecodez/rust-native-ios-touch-events-8b01418e0f3b" rel="noopener"> <strong class="js iu">原生iOS触摸事件w/ Rust </strong> </a></p><h1 id="9ff7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="51eb" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">完全用Rust写一个游戏，编译到iOS是有可能的。</p><div class="or os gp gr ot ou"><a href="https://devmap.org/membership" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">通过我的推荐链接加入Medium-Wade Zimmerman</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">阅读Wade Zimmerman(以及Medium上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">devmap.org</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi lg ou"/></div></div></a></div></div></div>    
</body>
</html>