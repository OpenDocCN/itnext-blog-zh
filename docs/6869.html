<html>
<head>
<title>APISIX, an API Gateway the Apache way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">APISIX，Apache方式的API网关</h1>
<blockquote>原文：<a href="https://itnext.io/apisix-api-gateway-f5650ab86be4?source=collection_archive---------5-----------------------#2022-03-27">https://itnext.io/apisix-api-gateway-f5650ab86be4?source=collection_archive---------5-----------------------#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/17602922db8f81bd940ba9627367e4fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9AWJ1wLfaJVa6WmQDcY_ng.png"/></div></div></figure><p id="636d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在万维网的先驱领域，内容是静态的。为了服务它，一组开发人员创建了一个web服务器，现在被称为<a class="ae kw" href="https://httpd.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Web服务器</a>。</p><p id="7b38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Apache Web服务器是围绕模块架构构建的。开发人员创建了一个模块来运行CGI脚本，以便向批次添加动态内容。用户用Perl编写早期的CGI脚本。过了一段时间，很明显从头开始生成一个完整的HTML页面并不是最好的方法，而模板化——提供一个带有占位符的HTML页面——是一个更好的方法。PHP语言就是这样开始的，作为一个由模块解释的简单模板引擎。</p><p id="7c39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，人们开始认为web服务器的核心职责不是生成内容，而是提供服务。这种关注点的分离将单一的web服务器分成了两个部分:前端的web服务器提供静态内容，应用服务器生成动态内容，通常是从存储在数据库中的数据生成的。</p><h1 id="b06a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">反向代理</h1><p id="2b56" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">尽管应用服务器可以提供静态内容，但是组织仍然保留了这种架构。我记得在2007年左右，我读过一篇文章，对Apache Web服务器和Apache Tomcat(一种基于Java的应用服务器)的性能进行了基准测试:为了提供纯静态内容，后者与前者不相上下，甚至更快。</p><p id="9e1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理论上，移除网络服务器是合理的。我甚至向我当时工作的公司经理倡议过一次。组织惯性减缓了主动性，然后我就走了。当时，我感到失望。事后看来，这并不是明智之举。</p><p id="d5d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">原因是除了直接提供内容，web服务器还必须将请求路由到其他组件。在这方面，他们也成为路由专家，基于一些属性:域，当然，路径，甚至一个HTTP头。因此，web服务器的职责不再是提供内容，而是成为基础设施其余部分的单一入口点。</p><p id="7301" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与此同时，专注于交流的网站发展成了成熟的网络交易应用。网络应用在公司与其周围生态系统——潜在客户、客户、提供商等——的互动中占据了越来越大的份额。当您的企业依赖于某个基础设施时，您需要将其停机时间保持在最低限度:这意味着配置关键组件的冗余，并将请求定向到可用的组件。路由不再是简单的路由，而是几个相同服务器之间的负载平衡。</p><p id="b966" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">引入负载平衡后，添加越来越多的功能变得很容易。入口点开始处理跨领域的职责:身份验证(但不总是授权)、缓存、IP阻塞等。网络服务器变成了一个反向代理服务器。</p><h1 id="1bbf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">原料药的兴起</h1><p id="a32e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">随着时间的推移，服务的数量随着它们相互通信的需求呈指数级增长。在同一个组织中，长期以来的传统是保持尽可能少的技术堆栈，具体数量取决于组织的规模。</p><p id="994a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，当服务必须与来自另一个组织的服务通信时，事情变得一团糟，因为拥有不同技术堆栈的可能性变得更高了。SOAP诞生于微软，后来成为W3C标准(或标准的集合)，是第一个提出堆栈中立方法的严肃尝试。</p><p id="e27b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然它在企业世界中变得广泛，但它在自己的重压下崩溃了。在企业中，标准的添加成了一个泥潭。在企业外部，前端开发人员(即JavaScript)发现处理HTTP和JSON要容易得多。越多的前端开发者进入市场，他们就越不想和SOAP打交道。</p><p id="6b31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当SOAP的流行减弱时，HTTP的流行(我不敢写REST)却增强了。HTTP成为了在互联网上集成异构信息系统的事实标准。公司开始通过HTTP:Web API提供对他们系统的访问。很快，大多数都放弃了Web部件，API隐式地暗示了Web with time。</p><p id="035c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这一点，我们忠实的web服务器发展成了它现在的形式，API gateway。这很有意义:web服务器已经作为反向代理的中心入口点。现在，我们只需要添加特定于API的功能。他们是哪几个？</p><h1 id="bc2f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">对API网关的需求</h1><p id="5e16" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这里有两个基本功能，它们强调了对API的需求，而这是常规web服务器无法提供的。</p><ul class=""><li id="1f64" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">复杂的速率限制:速率限制是一种通用功能，用于保护信息系统免受DDoS攻击。然而，当您区分消费者时，例如，免费与付费，您需要从简单的费率转移到更复杂的业务逻辑规则。</li><li id="5d8e" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">付费:如果你支付了订阅费，你就可以访问常规内容的资源。然而，当你的业务是出售数据时，你可能会根据数据量来出售数据。虽然服务本身有可能嵌入计费功能，但它会阻止更多依赖于几个服务来提供所需数据的分布式体系结构。在这一点上，只有中央接入点可以可靠地测量和收费使用。</li></ul><h1 id="542b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">阿帕奇APISIX</h1><p id="a88c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最广泛使用的API网关的非详尽列表包括:</p><ul class=""><li id="f2a7" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">阿帕奇APISIX</li><li id="8993" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">孔门户</li><li id="46a9" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">Tyk</li><li id="9d2f" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">格洛</li><li id="6b14" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">大使</li><li id="0f13" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">重力仪</li></ul><p id="67a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我故意忽略了云提供商的网关，因为他们将您锁定在他们的生态系统中。</p><p id="df5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">APISIX在刘彘技术公司开发后，于2019年6月捐赠给<a class="ae kw" href="https://www.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇基金会</a>，并于2020年7月成为顶级项目。作为ASF <a class="ae kw" href="https://www.apache.org/foundation/how-it-works.html#meritocracy" rel="noopener ugc nofollow" target="_blank">精英管理</a>方法的一部分，你必须首先成为一名积极的贡献者，才能获得提交者的权利。</p><p id="a196" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在技术方面，APISIX基于流行的Nginx web服务器，顶部有Lua引擎(OpenResty)和插件架构。</p><p id="086c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">APISIX提供了几个核心对象:</p><ul class=""><li id="a123" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">上游:“根据配置规则在一组给定的服务节点上执行负载平衡的虚拟主机抽象”</li><li id="adc0" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">消费者:客户的身份</li><li id="ab18" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">route:“route通过定义规则匹配客户端的请求，然后根据匹配结果加载并执行相应的插件，将请求转发到指定的上游。”</li><li id="3876" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">服务:绑定一组插件和一个上游插件的可重用对象。</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/ed6f5a116dbce8731938c6422c6308a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/0*37Xik-1iVwCeuiC5.png"/></div></figure><p id="acdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对象存储在<a class="ae kw" href="https://etcd.io/" rel="noopener ugc nofollow" target="_blank"> etcd </a>中，这是一个分布式键值存储，Kubernetes也使用它。Apache APISIX公开了一个REST API，这样您就可以以一种与技术无关的方式访问配置。在此，我们请求所有现有路线:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0b62" class="my ky iq mu b gy mz na l nb nc">curl <a class="ae kw" href="http://apisix:9080/apisix/admin/routes" rel="noopener ugc nofollow" target="_blank">http://apisix:9080/apisix/admin/routes</a> -H 'X-API-KEY: xyz' # 1</span></pre><ol class=""><li id="3476" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv nd mg mh mi bi translated">默认情况下，配置访问受到保护。需要传递API密钥。</li></ol><p id="4c51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用其他对象的对象可以定义它们或指向现有引用。例如，可以将独立的<code class="fe ne nf ng mu b">Route</code>定义为:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="38e2" class="my ky iq mu b gy mz na l nb nc">curl <a class="ae kw" href="http://apisix:9080/apisix/admin/routes/1" rel="noopener ugc nofollow" target="_blank">http://apisix:9080/apisix/admin/routes/1</a> -H 'X-API-KEY: xyz' -X PUT -d '<br/>{<br/>  "uri": "/foo",<br/>  "upstream": {<br/>    "type": "roundrobin",<br/>    "nodes": {<br/>      "127.0.0.1:8080": 1<br/>    }<br/>  }<br/>}'</span></pre><p id="2c62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，首先定义一个<code class="fe ne nf ng mu b">Upstream</code>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6974" class="my ky iq mu b gy mz na l nb nc">curl <a class="ae kw" href="http://apisix:9080/apisix/admin/upstreams/1" rel="noopener ugc nofollow" target="_blank">http://apisix:9080/apisix/admin/upstreams/1</a> -H 'X-API-KEY: xyz' -X PUT -d '<br/>{<br/>  "type": "roundrobin",<br/>  "nodes": {<br/>    "127.0.0.1:8080": 1<br/>  }<br/>}'</span></pre><p id="0cf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以在新的<code class="fe ne nf ng mu b">Route</code>中引用新创建的<code class="fe ne nf ng mu b">Upstream</code>:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="25c9" class="my ky iq mu b gy mz na l nb nc">curl <a class="ae kw" href="http://apisix:9080/apisix/admin/routes/2" rel="noopener ugc nofollow" target="_blank">http://apisix:9080/apisix/admin/routes/2</a> -H 'X-API-KEY: xyz' -X PUT -d '<br/>{<br/>  "uri": "/bar",<br/>  "upstream_id": 1<br/>}'</span></pre><h1 id="610b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">弄湿你的脚</h1><p id="e6e7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">试用Apache APISIX的最快方法是通过Docker。Apache APISIX的配置依赖于etcd，所以让我们使用Docker Compose:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8b07" class="my ky iq mu b gy mz na l nb nc">version: "3"</span><span id="bdb5" class="my ky iq mu b gy nh na l nb nc">services:<br/>  apisix:<br/>    image: apache/apisix:2.12.1-alpine                           # 1<br/>    command: sh -c "/opt/util/wait-for etcd:2397 -- /usr/bin/apisix init &amp;&amp; /usr/bin/apisix init_etcd &amp;&amp; /usr/local/openresty/bin/openresty -p /usr/local/apisix -g 'daemon off;'"            # 2<br/>    volumes:<br/>      - ./apisix_log:/usr/local/apisix/logs<br/>      - ./apisix_conf/config.yaml:/usr/local/apisix/conf/config.yaml:ro<br/>      - ./util:/opt/util:ro                                      # 2<br/>    ports:<br/>      - "9080:9080"<br/>      - "9091:9091"<br/>      - "9443:9443"<br/>    depends_on:<br/>      - etcd<br/>  etcd:<br/>    image: bitnami/etcd:3.5.2                                    # 3<br/>    environment:<br/>      ETCD_ENABLE_V2: "true"<br/>      ALLOW_NONE_AUTHENTICATION: "yes"<br/>      ETCD_ADVERTISE_CLIENT_URLS: "http://0.0.0.0:2397"          # 4<br/>      ETCD_LISTEN_CLIENT_URLS: "http://0.0.0.0:2397"             # 4<br/>    ports:<br/>      - "2397:2397"</span></pre><ol class=""><li id="ca52" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv nd mg mh mi bi translated">Apache APISIX图像</li><li id="19a8" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv nd mg mh mi bi translated">技巧等待，直到etcd完全初始化，而不是只开始。<code class="fe ne nf ng mu b">depends_on</code>属性不够</li><li id="646c" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv nd mg mh mi bi translated">etcd图像</li><li id="8786" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv nd mg mh mi bi translated">如果您激活了Kubernetes，Docker Desktop将启动自己的etcd。为了避免端口冲突，让我们更改默认端口。</li></ol><p id="9c9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在<code class="fe ne nf ng mu b">config.yaml</code>文件中配置Apache APISIX。最小的配置文件如下所示:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="878e" class="my ky iq mu b gy mz na l nb nc">apisix:<br/>  node_listen: 9080                           <br/>  allow_admin:<br/>    - 0.0.0.0/0<br/>  admin_key:<br/>    - name: "admin"<br/>      key: edd1c9f034335f136f87ad84b625c8f1<br/>      role: admin<br/>etcd:<br/>  host:<br/>    - "http://etcd:2397"<br/>  prefix: "/apisix"<br/>  timeout: 30</span></pre><p id="7cbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以创建一个简单的路线。我们将代理httpbin.org服务:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1578" class="my ky iq mu b gy mz na l nb nc">#!/bin/sh<br/>curl <a class="ae kw" href="http://localhost:9080/apisix/admin/routes" rel="noopener ugc nofollow" target="_blank">http://localhost:9080/apisix/admin/routes</a> -H 'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1' -X POST -d '<br/>{<br/>  "name": "Route to httpbin",<br/>  "uris": ["/*"],<br/>  "upstream": {<br/>    "type": "roundrobin",<br/>    "nodes": {<br/>      "httpbin.org": 1<br/>    }<br/>  }<br/>}'</span></pre><p id="3160" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以测试路线。<code class="fe ne nf ng mu b">httpbin</code>提供了几个端点。名副其实的<code class="fe ne nf ng mu b">/anything</code>端点返回请求数据中传递的任何内容。我们可以使用这个端点来检查一切是否按预期工作:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b43e" class="my ky iq mu b gy mz na l nb nc">curl 'localhost:9080/anything?foo=bar&amp;baz' -X POST -d '{ "hello": "world" }' -H 'Content-Type: application/json'</span></pre><p id="451d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出应该非常类似于以下内容:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6842" class="my ky iq mu b gy mz na l nb nc">{<br/>  "args": {<br/>    "baz": "", <br/>    "foo": "bar"<br/>  }, <br/>  "data": "{ \"hello\": \"world\" }", <br/>  "files": {}, <br/>  "form": {}, <br/>  "headers": {<br/>    "Accept": "*/*", <br/>    "Content-Length": "20", <br/>    "Content-Type": "application/json", <br/>    "Host": "localhost", <br/>    "User-Agent": "curl/7.79.1", <br/>    "X-Amzn-Trace-Id": "Root=1-6239ae8e-633a33fb0d5fe44e354c9149", <br/>    "X-Forwarded-Host": "localhost"<br/>  }, <br/>  "json": {<br/>    "hello": "world"<br/>  }, <br/>  "method": "POST", <br/>  "origin": "172.21.0.1, 176.153.7.175", <br/>  "url": "http://localhost/anything?foo=bar&amp;baz"<br/>}</span></pre><h1 id="cc3f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="70fe" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在这篇文章中，我解释了web服务器的发展。一开始，他们唯一的职责是提供静态内容。然后，他们增加了路由和负载平衡功能，并成为反向代理。在这一点上，添加额外的横切特性是一个简单的步骤。</p><p id="6297" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在API时代，web服务器已经到了另一个阶段:API网关。Apache APISIX就是这样一个网关。它不仅具有友好的Apache v2许可；这是阿帕奇基金会投资组合的一部分。</p><p id="82a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从Apache APISIX开始非常容易。使用Docker，使用APISIX和etcd图像，然后就可以开始了。</p><p id="02f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在GitHub 上找到这篇文章的来源。</p><p id="51e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步</strong>:</p><ul class=""><li id="8957" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><a class="ae kw" href="https://apisix.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇APISIX网站</a></li><li id="85b1" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae kw" href="https://apisix.apache.org/docs/apisix/architecture-design/apisix" rel="noopener ugc nofollow" target="_blank">阿帕奇APISIX架构</a></li><li id="a016" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae kw" href="https://github.com/apache/apisix" rel="noopener ugc nofollow" target="_blank">GitHub上的Apache API six</a></li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="fa58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="np">原载于2022年3月25日</em> <a class="ae kw" href="https://blog.frankel.ch/apisix-api-gateway/" rel="noopener ugc nofollow" target="_blank"> <em class="np">一个Java极客</em> </a> <em class="np"/></p></div></div>    
</body>
</html>