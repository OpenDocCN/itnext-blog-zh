<html>
<head>
<title>C++ Sort 5 numbers using only if-statements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++只使用if语句对5个数进行排序</h1>
<blockquote>原文：<a href="https://itnext.io/c-sort-5-numbers-using-only-if-statements-21d183751f72?source=collection_archive---------1-----------------------#2019-09-28">https://itnext.io/c-sort-5-numbers-using-only-if-statements-21d183751f72?source=collection_archive---------1-----------------------#2019-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/db06978a9865b54f8c781fc71418b745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ozZ0WzLvwyB9rUJhVFTJTg.jpeg"/></div></figure><p id="1f80" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在编程中对数字进行排序并不有趣，尤其是当你不得不在不使用任何内置函数的情况下从头开始排序的时候。当你理解道格拉斯·亚当斯的这句话时:</p><blockquote class="ks kt ku"><p id="9388" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated">当我花一整天的时间给我的电脑编程，让它自动执行一项原本需要我用十秒钟才能完成的任务时，我很少比这更开心了。</p></blockquote><p id="28c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我们将只使用c++ if语句编写代码来对5个数字进行排序。我们将讨论以下主题:</p><ul class=""><li id="68c3" class="kz la iq jw b jx jy kb kc kf lb kj lc kn ld kr le lf lg lh bi translated">对3个数字进行排序的算法</li><li id="9554" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated">仅使用c++ if语句为5个数字编写算法代码</li><li id="c036" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated">结论</li></ul><h2 id="61b1" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kf lw lx ly kj lz ma mb kn mc md me mf bi translated">对3个数字进行排序的算法</h2><p id="7580" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">我将从解释仅使用<em class="kv"> if语句</em>对数字进行排序的算法开始。我们将首先考虑对3个数字进行排序，使其不那么复杂和易于理解。</p><p id="bcc3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">考虑未排序数字的数组<em class="kv"> arr= [3，1，0]。</em>我们可以按以下步骤进行排序:<br/> <strong class="jw ir">第一步</strong>:比较索引1和0。<em class="kv">If(arr[1]&lt;arr[0])</em><br/>如果这个条件成立，那么就交换数字。我们可以看到1 &lt; 3是真的。所以我们交换，数组变成[1，3，0]</p><p id="646e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">步骤2 </strong>:比较下一个索引2和1。<em class="kv">If(arr[2]&lt;arr[1])</em><br/>如果这个条件成立，那么就交换数字。我们可以看到0 &lt; 3是真的。所以我们交换，数组变成了[1，0，3]</p><p id="1a55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">步骤2.1 </strong>:如果步骤2的条件为真，则重复步骤1。<em class="kv">If(arr[1]&lt;arr[0])</em><br/>如果这个条件成立，那么交换数字。我们可以看到0 &lt; 1为真。所以我们交换，数组变成[0，1，3]。</p><p id="2b70" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在有了排序后的数组[0，1，3]。我们看到，排序3个数字最多需要3个if语句。我们将扩展我们在这里学到的知识，对更多(5)个数字进行排序。</p><blockquote class="ks kt ku"><p id="4146" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated">数字越多，对数字进行排序所需的if语句就越多。</p></blockquote><h2 id="e56f" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kf lw lx ly kj lz ma mb kn mc md me mf bi translated">仅使用c++ if语句为5个数字编写算法代码</h2><p id="7f19" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">在这里，我将扩展上面解释的算法，对5个数字进行排序；不过，我直接从代码来解释。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">仅使用if语句对5个数字进行排序</figcaption></figure><p id="c31d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从上面的代码中，我们可以识别3个函数；swap()、sort()和main()。</p><p id="44e7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> main() </strong>:</p><p id="ada1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是我们的主要功能。这里，我们测试排序函数。我们的排序函数接受一个数字数组，并返回一个指向数组第一个元素的指针</p><blockquote class="ks kt ku"><p id="0c3d" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated">在C++中，我们不能返回整个数组</p></blockquote><p id="960d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">互换()</strong>:</p><p id="663a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个简单的函数，它通过引用接受两个变量，并使用一个临时变量来交换这两个变量。在这里，我决定从头开始编写代码，但是我们仍然可以使用函数std::swap()，这是C++标准模板库(STL)中的一个内置函数</p><p id="9464" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Sort(): </strong></p><p id="75d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了更好地理解这几行代码，让我们考虑一下数组<br/><strong class="jw ir">a =【4，5，7，9，6】</strong>。你会注意到第一部分(<strong class="jw ir">a部分</strong>)是我们上面描述的排序3个数字的相同算法。因此，a部分将对数组的前三个数字进行排序，我们将得到<strong class="jw ir"> a = [4，5，7，9，6] </strong></p><p id="48e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">a部分</strong>以指数2和1结束。现在<strong class="jw ir">部分b </strong>从那里继续。考虑在if语句的每个阶段，我们递增索引。因此，我们有指数3和2，然后我们遵循以下步骤:</p><ul class=""><li id="9a75" class="kz la iq jw b jx jy kb kc kf lb kj lc kn ld kr le lf lg lh bi translated"><strong class="jw ir">步骤b1 </strong>:比较指标3和指标2。if(a[3] &lt; a[2]) <br/>如果这个条件成立，那么就交换数字。我们可以看到9 &lt; 7是假的。所以，这里没有交换。</li><li id="debe" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated"><strong class="jw ir">步骤b2 </strong>:如果步骤a为真，则应用<strong class="jw ir">a部分</strong> ( <strong class="jw ir">步骤1 </strong>、<strong class="jw ir">步骤2 </strong>和或<strong class="jw ir">步骤2.1) </strong>)。我们在这里意识到的是，每次我们在一个特定的位置排序时，我们需要确保我们再次排序该位置后面的所有内容。因此，<strong class="jw ir">a部分</strong>将确保所有内容都在索引位置3以下排序。</li></ul><p id="6475" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">c部分</strong>从<strong class="jw ir">b部分</strong>离开的地方继续。我们现在首先要排序的是索引4和3。如果遵循以下步骤:</p><ul class=""><li id="3784" class="kz la iq jw b jx jy kb kc kf lb kj lc kn ld kr le lf lg lh bi translated"><strong class="jw ir">步骤c1 </strong>:比较指标4和3。if(a[4] &lt; a[3]) <br/>如果这个条件成立，那么就交换数字。我们可以看到6 &lt; 9为真，所以我们互换得到<strong class="jw ir"> a = [4，5，7，6，9]。</strong></li><li id="ec7f" class="kz la iq jw b jx li kb lj kf lk kj ll kn lm kr le lf lg lh bi translated"><strong class="jw ir">步骤c2: </strong>如果步骤c1为真，则应用<strong class="jw ir">部分b(步骤b1，步骤b2 </strong>)。我们在这里会注意到，<strong class="jw ir">乙部</strong>也会适用于<strong class="jw ir">甲部</strong>。最后，我们将得到排序后的数组<br/><strong class="jw ir">a =【4，5，6，7，9】</strong></li></ul><h2 id="d9d2" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kf lw lx ly kj lz ma mb kn mc md me mf bi translated">结论</h2><p id="d82e" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">我必须承认，这里的解决方案并不简单，我可能没有解释清楚；然而，我尽了最大努力使它尽可能简单。我仍在寻找降低代码复杂性的方法。一种方法是我们可以减少冗余代码。此外，可以使用更好的算法，该算法产生更少的代码行，并且还降低了其复杂性。我乐于接受建议，所以请随意批评、欣赏和分享。</p></div></div>    
</body>
</html>