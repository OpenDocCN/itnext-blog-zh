<html>
<head>
<title>Entity Framework Core: SQLite Concurrency Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体框架核心:SQLite并发检查</h1>
<blockquote>原文：<a href="https://itnext.io/entity-framework-core-sqlite-concurrency-checks-a908ac6814ef?source=collection_archive---------2-----------------------#2018-12-30">https://itnext.io/entity-framework-core-sqlite-concurrency-checks-a908ac6814ef?source=collection_archive---------2-----------------------#2018-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6cbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用SQLite所做的大部分工作都是在单用户系统上进行的，但是最近我不得不从事一个SQLite项目，该项目将有少量并发用户，并且用户活动的子集将需要处理并发问题。过去，在这种情况下，我一直使用SQL Server并使用<a class="ae kl" href="https://docs.microsoft.com/en-us/sql/t-sql/data-types/rowversion-transact-sql?view=sql-server-2017" rel="noopener ugc nofollow" target="_blank"> rowversion或timestamp column type </a>,它在任何更新或插入的行上放置一个唯一值。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d4260c01ebc3ea36b635d5c327cd29d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jXjB9zWEhYCgy_Ld"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae kl" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="335c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在官方文档中有一页是关于<a class="ae kl" href="https://docs.microsoft.com/en-us/ef/core/modeling/concurrency" rel="noopener ugc nofollow" target="_blank">并发令牌</a>的，但是对我来说，这并不是很有帮助。谢天谢地，经过一番搜索后，我在ASP.Net Core 2 . x中遇到了GitHub问题<a class="ae kl" href="https://github.com/aspnet/EntityFrameworkCore/issues/12260" rel="noopener ugc nofollow" target="_blank">，带有实体框架核心，并发控制无法与SQLite </a>一起工作，其中一个回复中有一个可靠的示例。这篇文章将介绍该示例的一个示例实现。代码的起点可以在这个GitHub repo 中找到<a class="ae kl" href="https://github.com/elanderson/ASP.NET-Core-Entity-Framework/tree/e2dc7bcf15f40e35f0f73dc267fadddf4431ae94" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="5ffa" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">样本背景</h2><p id="2aa0" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">正在使用的示例项目是一个管理联系人列表的简单web应用程序。repo包含一个使用Postgres的实现和一个使用Sqlite的实现。这整个职位将只是触摸文件中找到的Sqlite文件夹/项目。</p><h2 id="e4ec" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">模型变更和数据迁移</h2><p id="4e44" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">SQLite没有时间戳列的概念，但是这个解决方案将模拟时间戳列。为此，我们将更改在<strong class="jp ir">模型</strong>文件夹中找到的<strong class="jp ir">联系人</strong>模型。我们将添加一个带有<strong class="jp ir">时间戳</strong>数据注释的<strong class="jp ir">时间戳</strong>属性。下面是底部带有新属性的完整模型类。</p><pre class="kn ko kp kq gt ma mb mc md aw me bi"><span id="019a" class="lc ld iq mb b gy mf mg l mh mi">public class Contact<br/>{<br/>    public int Id { get; set; }<br/>    public string Name { get; set; }<br/>    public string Address { get; set; }<br/>    public string City { get; set; }<br/>    public string Subregion { get; set; }<br/>    public string PostalCode { get; set; }<br/>    public string Phone { get; set; }<br/>    public string Email { get; set; }<br/>    [Timestamp] public byte[] Timestamp { get; set; }<br/>}</span></pre><p id="4d51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们创建一个新的迁移，并对模型进行更改。我在用。因此，从项目目录中的命令提示符处运行以下命令。</p><pre class="kn ko kp kq gt ma mb mc md aw me bi"><span id="60e4" class="lc ld iq mb b gy mf mg l mh mi">dotnet ef migrations add ContactTimestamp --context ContactsDbContext</span></pre><p id="50e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">迁移</strong>目录中，打开新创建的迁移。应该命名为<strong class="jp ir"> *_ContactTimestamp.cs </strong>之类的。在<strong class="jp ir"> Up </strong>函数中，我们将向新的时间戳列添加几个触发器。当插入或更新一行时，这些触发器将为timestamp列分配一个随机blob，这就是我们模拟SQL Server Timestamp数据类型功能的方式。以下是添加了触发器的完整<strong class="jp ir"> Up </strong>功能。</p><pre class="kn ko kp kq gt ma mb mc md aw me bi"><span id="77c8" class="lc ld iq mb b gy mf mg l mh mi">protected override void Up(MigrationBuilder migrationBuilder)<br/>{<br/>    migrationBuilder.AddColumn&lt;byte[]&gt;(<br/>        name: "Timestamp",<br/>        table: "Contacts",<br/>        rowVersion: true,<br/>        nullable: true);<br/><br/>    migrationBuilder.Sql(<br/>        @"<br/>        CREATE TRIGGER SetContactTimestampOnUpdate<br/>        AFTER UPDATE ON Contacts<br/>        BEGIN<br/>            UPDATE Contacts<br/>            SET Timestamp = randomblob(8)<br/>            WHERE rowid = NEW.rowid;<br/>        END<br/>    ");<br/><br/>    migrationBuilder.Sql(<br/>        @"<br/>        CREATE TRIGGER SetContactTimestampOnInsert<br/>        AFTER INSERT ON Contacts<br/>        BEGIN<br/>            UPDATE Contacts<br/>            SET Timestamp = randomblob(8)<br/>            WHERE rowid = NEW.rowid;<br/>        END<br/>    ");<br/>}</span></pre><p id="8d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将迁移应用到数据库，您可以使用以下命令。</p><pre class="kn ko kp kq gt ma mb mc md aw me bi"><span id="31d3" class="lc ld iq mb b gy mf mg l mh mi">dotnet ef database update --context ContactsDbContext</span></pre><h2 id="076c" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">测试它</h2><p id="7293" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在进行一个快速的测试，我们将为现有的<strong class="jp ir"> ContactsController </strong>添加一个<strong class="jp ir">并发测试</strong>函数。这个函数将确保特定的contact存在，然后从两个不同的DBContexts中提取contact，对产生的contact对象进行变异，然后尝试保存。第一次保存会成功，第二次应该会失败。请注意，这个函数不是一个应该如何做的例子，只是一个快速和肮脏的方法来证明并发检查正在发生。</p><pre class="kn ko kp kq gt ma mb mc md aw me bi"><span id="0c11" class="lc ld iq mb b gy mf mg l mh mi">[Route("ConcurrencyTest")]<br/>public void ConcurrencyTest()<br/>{<br/>    var context1 = new ContactsDbContext(new DbContextOptionsBuilder&lt;ContactsDbContext&gt;()<br/>                                         .UseSqlite("Data Source=Database.db").Options);<br/>    var context2 = new ContactsDbContext(new DbContextOptionsBuilder&lt;ContactsDbContext&gt;()<br/>                                         .UseSqlite("Data Source=Database.db").Options);<br/><br/>    var contactFromContext1 = context1.Contacts.FirstOrDefault(c =&gt; c.Name == "Test");<br/><br/>    if (contactFromContext1 == null)<br/>    {<br/>        contactFromContext1 = new Contact<br/>        {<br/>            Name = "Test"<br/>        };<br/><br/>        context1.Add(contactFromContext1);<br/>        context1.SaveChanges();<br/>    }<br/><br/>    var contactFromContext2 = context2.Contacts.FirstOrDefault(c =&gt; c.Name == "Test");<br/><br/>    contactFromContext1.Address = DateTime.Now.ToString();<br/>    contactFromContext2.Address = DateTime.UtcNow.ToString();<br/><br/>    context1.SaveChanges();<br/>    context2.SaveChanges();<br/>}</span></pre><p id="95f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行应用程序并点击<strong class="jp ir">concurrency test</strong>路径，对于我的测试来说是<a class="ae kl" href="http://localhost:1842/ConcurrencyTest" rel="noopener ugc nofollow" target="_blank">http://localhost:1842/concurrency test</a>。下面是产生的异常。</p><h1 id="f48e" class="mj ld iq bd le mk ml mm lh mn mo mp lk mq mr ms ln mt mu mv lq mw mx my lt mz bi translated">处理请求时出现未处理的异常。</h1><blockquote class="na nb nc"><p id="fc4b" class="jn jo nd jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated">DbUpdateConcurrencyException:数据库操作预期影响1行，但实际影响了0行。自实体加载后，数据可能已被修改或删除。参见<a class="ae kl" href="http://go.microsoft.com/fwlink/?LinkId=527962" rel="noopener ugc nofollow" target="_blank">http://go.microsoft.com/fwlink/?LinkId=527962</a>了解和处理乐观并发异常的信息。</p></blockquote><h2 id="2ccd" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">包扎</h2><p id="bc7f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">虽然信息并不容易找到，但正如您所见，使用SQLite的Entity Framework Core对并发控制有很好的支持。以上只是其实现的一种选择。我希望这能节省你们的时间。</p><p id="4eab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终状态的代码可以在这里找到<a class="ae kl" href="https://github.com/elanderson/ASP.NET-Core-Entity-Framework/tree/d1415d23f00117e3fb727d428dbdd7664ee17a0d" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="a4e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nd">原载于</em> <a class="ae kl" href="https://elanderson.net/2018/12/entity-framework-core-sqlite-concurrency-checks/" rel="noopener ugc nofollow" target="_blank"> <em class="nd">埃里克·安德森</em> </a> <em class="nd">。</em></p></div></div>    
</body>
</html>