<html>
<head>
<title>A Kafka streaming application with Quarkus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Quarkus的Kafka流应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/a-kafka-streaming-application-with-quarkus-722ad2a8def1?source=collection_archive---------1-----------------------#2021-08-26">https://itnext.io/a-kafka-streaming-application-with-quarkus-722ad2a8def1?source=collection_archive---------1-----------------------#2021-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b01ee8fd7d07ebc20704b0519a9e8825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jw8LlzByNcKPp_ZH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约书亚·索蒂诺在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a2c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kafka流媒体应用平台正在成为<em class="lb">【事实上】</em>ETL(提取、转换和加载)世界的现代方法。也许你已经读了很多关于“什么是卡夫卡”、“什么是主题”和“什么是分区”的内容，但我想与你讨论“什么是流媒体应用”，这是本文的目的，我希望我会达到这个目的。《Kafka streams in Action》一书<em class="lb"/>将流处理定义为<em class="lb">“在数据到达您的系统时对其进行处理”</em>或者更精确的说法<em class="lb">“流处理是在数据流动时，通过连续计算对无限数据流进行处理的能力，而无需收集或存储数据来对其进行处理”</em>。通常，当我们拥有大量数据(BigData)并且需要快速响应或报告传入数据时，我们会使用流处理应用程序。</p><p id="58fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在继续之前，这里描述的完整示例发布在https://github.com/paspao/quarkus-streaming-app的Github上，它不仅包含流媒体应用，还包含完整的部署场景:</p><ul class=""><li id="8e06" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">1个Zookeeper实例</li><li id="a38e" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">3个卡夫卡实例</li><li id="f5b2" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">1个Kafdrop实例(查看Kafka主题/实例等内容的简单方法)</li><li id="0fbb" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">1个流媒体应用程序(如本文所述)</li></ul><p id="da60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过Kafdrop你可以验证卡夫卡主题的内容。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="7c01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们假设所有的数据都已经存在于Kafka主题中，我试着在下图中画出它们:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lx"><img src="../Images/2c0a0e68bfecb4eba738a18308ec6ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7DX3fzWlycbjGbp97pcwoA.png"/></div></div></figure><p id="bc90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我创建了四个简单的实体(每一个都是Kafka主题表示):Person、DriverLicense、Sim、Fee。数据架构非常简单:一个人可以有一些驾照，一个人可以有sim卡，最后但并非最不重要的是，一个人不幸地支付费用。我用红色标记了主题的<em class="lb">键</em>，整行都是卡夫卡的信息或<em class="lb">有效载荷</em>。</p><p id="658b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，表格表示是一种简化，我们必须记住，表格中的每一行都可能包含多条消息，如下图所示:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/7fa06f25908c1c087001caf814b2052e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*Jo-A__xGk1pGUNO_rI2Bjg.png"/></div></figure><p id="d729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同一行/消息可能有多个<em class="lb">版本</em>，为什么？</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div class="gh gi md"><img src="../Images/7260fccd07525351a4252f1247a195f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*T9uNFBUnAS0j-brM9Blg3Q.png"/></div></figure><p id="6387" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">卡夫卡的行为就像一个<em class="lb">提交日志</em>，它是交易的记录。在数据库环境中，它用于跟踪正在发生的事情，并有助于灾难恢复，它代表所有RDBMS的承载结构。我们可以将<em class="lb">提交日志</em>定义为不可变的有序事件记录。</p><p id="572b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kafka为每一行存储了两个隐藏值:一个<em class="lb">偏移量</em>和一个<em class="lb">时间戳</em>。使用<em class="lb">偏移量</em>字段，您可以明确地标识分区中的一行。选择管理这两个<em class="lb">隐藏的</em>值是因为管理<em class="lb">时间</em>:事实上Kafka给了我们在特定时间窗口内处理消息的选项。例如，我们可以决定处理我们在2009年收到的消息，忽略我们在那一年之前或之后收到的所有消息，<em class="lb">忽略</em>这是让我们实现高速度的原因，事实上这是卡夫卡赞助/实现的实时处理(<em class="lb">流</em>)的秘密之一。</p><p id="1b44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在回到这个例子。我的第一个目标是加入两个简单的主题，即<em class="lb">人</em>和<em class="lb">驾照</em>，因为我想知道有多少人已经有了驾照，所以让我们开始加入这两个主题。从数据的角度来看，要连接两个主题，它们必须遵守<em class="lb">共同分区</em>要求，即:</p><ul class=""><li id="6c46" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">连接的输入记录必须具有相同的键(或键模式)</li><li id="fa73" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">输入记录的两边必须有相同数量的分区</li><li id="85c7" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">连接的两端必须具有相同的分区策略(通常我们使用kafka客户端提供的默认策略，实际上忽略了选择不同策略的能力)</li></ul><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="aa0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这段代码中，你找不到配置，这不是我们的重点，这里的重点是流(无论如何你可以在repo中找到细节):在第3行和第5行，我们定义了两个流，一个用于<em class="lb"> Person </em>主题，一个用于<em class="lb"> DriverLicense </em>主题，然后只是一个<em class="lb"> peek </em>操作来记录<em class="lb"> stream person </em>以及随后在第10–16行Person和driver之间的<em class="lb"> join </em>操作注意，我在第10行使用了一个<em class="lb"> peekStream </em>而不是<em class="lb"> personStream </em>，因为我想添加一个新的节点来记录流(我正在构建一个<em class="lb">拓扑… </em>)，我们需要一些东西来查看这个拓扑，所以在第21行我打印出了控制台日志中的流/拓扑，这是一个逻辑描述:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="c4f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用这个片段来绘制拓扑，使用类似<a class="ae kc" href="https://zz85.github.io/kafka-streams-viz/" rel="noopener ugc nofollow" target="_blank">https://zz85.github.io/kafka-streams-viz/</a>的工具，下面你可以找到结果:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/7007fc39245d4cf6f9cebec58c19770d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIRIiQUsFAeM3ZgK0y55Tg.png"/></div></div></figure><p id="1e66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了简单拓扑的图形表示。可以更清楚地看到我们已经讨论过的主题、流和<em class="lb"> peek </em>操作，但是现在我们可以更清楚地看到在join操作期间发生了什么。在第12行，我们使用了一个<em class="lb">join window</em>,<em class="lb">join</em>操作是一个有状态转换，我们需要一个状态存储来收集到目前为止在定义的窗口边界内接收到的所有记录。使用Kafka，我们能够将时间视为数据，因此我们不想处理特定记录收到的所有更新，而只处理最近5分钟内发生的更改。例如，这样我将只处理几千字节的数据(在BigData上下文中，我们可以处理万亿字节的数据)。因此，对于join操作的每个元素，拓扑结构方面将创建一个状态存储(图片右侧的两个圆柱体),并且在kafka上也将创建一个相应的主题，这些主题被命名为<em class="lb"> store-changelog </em> topics，这是为了确保Kafka流的foult-talerant功能。如汇合文档中所述:<em class="lb">“这些changelog主题也被分区，以便每个本地状态存储实例以及访问存储的任务都有自己专用的changelog主题分区。在changelog主题上启用了日志压缩，以便可以安全地清除旧数据，防止主题无限增长。如果任务在一台失败的机器上运行，并在另一台机器上重新启动，Kafka Streams保证在重新开始处理新启动的任务之前，通过重放相应的changelog主题，将它们的关联状态存储恢复到失败之前的内容。因此，故障处理对最终用户来说是完全透明的。”</em></p><p id="dda3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在第18行的最后一步中，数据将通过键连接，结果将存储在<em class="lb"> alltogether </em>主题中，类似于:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="09a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在让我们试着创建一个更复杂/更现实的场景:让我们试着加入没有<em class="lb">共同划分的</em>主题，或者至少还没有，所以我们现在要做的是将<em class="lb"> alltogether </em>主题与<em class="lb"> fee </em>主题结合起来。结果将是具有以下内容的有效载荷:</p><ul class=""><li id="b7f1" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">人</li><li id="b234" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">驾照</li><li id="8933" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">费用</li></ul><p id="1a46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一部分已经实现(它是前一部分的副本)，所以我们可以完全忽略第1–20行:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="f7d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第24行，我们为<em class="lb"> fee </em>主题定义了一个新的流，然后在第27–32行，我们定义了一个新的东西，即用于设置用于序列化和反序列化数据的<em class="lb"> serde </em>类的<em class="lb">持久键值存储</em>。</p><p id="70de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第34行，我们开始将<em class="lb"> alltogether </em>主题与<em class="lb"> fee </em>主题连接起来:</p><ul class=""><li id="7a87" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">我们需要“覆盖”主题<em class="lb"> fee </em>的关键字，因为我不能用不同的关键字连接两个主题，我们在第35行完成</li><li id="9473" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">当覆盖键时，您还需要定义一个聚合策略，这在第37–41行完成。</li><li id="4bde" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">现在<em class="lb"> fee </em>流已经准备好与<em class="lb"> alltogether </em>连接，所以在第42–49行，我们简单地连接这两个定义序列化和时间窗口的流(在我们的例子中，时间窗口只是一个例子)</li><li id="dd5a" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">最后一步连接的数据被移动到一个新的主题</li></ul><p id="4e40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像往常一样，在第53行，我们打印出已定义拓扑的描述:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="0687" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在真的更复杂了，下面是上面代码片段的图形表示:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/8dda6598d87ea538290623803254ad98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdba91Zl4bzwaupQg8Gviw.png"/></div></div></figure><p id="79a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用红线突出显示了文章第一部分中分析的第一个拓扑，它只是由图形工具以不同的方式表示，红色部分之外的所有内容都是由第二个拓扑添加的。我用蓝色部分突出显示了遵守共同分区规则所需的<em class="lb">选择键/重新分区</em>操作。这个新连接拓扑的结果如下所示:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="8c2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非常感谢你的阅读，如果有不清楚的地方请告诉我。</p></div></div>    
</body>
</html>