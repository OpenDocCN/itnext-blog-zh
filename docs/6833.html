<html>
<head>
<title>Cluster.dev: All-in-One Tool for Cloud Native Infrastructure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cluster.dev:用于云本地基础设施的一体化工具</h1>
<blockquote>原文：<a href="https://itnext.io/cluster-dev-all-in-one-tool-for-cloud-native-infrastructure-636ed6ba8e28?source=collection_archive---------4-----------------------#2022-03-14">https://itnext.io/cluster-dev-all-in-one-tool-for-cloud-native-infrastructure-636ed6ba8e28?source=collection_archive---------4-----------------------#2022-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="cc79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将Terraform、Helm、ArgoCD等捆绑到一个简单的框架中，使用Cluster.dev创建和管理端到端基础设施。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2afe02e00caf45741d011cf9caee78d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lJmgyMK8Kzv-NAXc.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来源:<a class="ae le" href="https://cluster.dev/" rel="noopener ugc nofollow" target="_blank"> cluster.dev </a></figcaption></figure><p id="5a18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">注意:Cluster.dev由一个来自乌克兰的团队提供支持，其成员已经设法从基辅撤离，目前是安全的。(</em>🇺🇦<em class="lf">#站在乌克兰)</em></p><p id="313e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着云原生架构的复杂性增加，管理基础架构所需的工具数量以及大规模管理和操作这些工具的专业知识增加了大多数基础架构团队面临的挑战。例如，要在Kubernetes上运行应用程序，团队需要首先通过Terraform、Pulumi或Crossplane提供云基础设施。然后，可以通过Helm或kustomize打包应用程序，并通过ArgoCD或其他CI/CD工具进行部署。最后，可能会有其他脚本、cronjobs、Argo工作流和secrets manager将一切联系在一起。</p><p id="5b32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于具有优秀的IaC和GitOps实践的已建立的团队来说，这个挑战可能会得到部分解决。然而，对于现在希望采用现代基础架构最佳实践的组织来说，处理所有这些工具和工作流可能会令人望而生畏。当基础架构还必须打包并交付给运行许可软件或本地软件的客户时，这种情况也同样适用。</p><p id="71e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Cluster.dev是一个工具，旨在通过将所有流行的基础设施工具整合到一个框架中来解决这个问题。它使用一个“堆栈模板”以一种熟悉的声明性清单方法来定义所有的基础结构部分。堆栈模板可以是任何东西，从Terraform模块到shell脚本、舵图、ArgoCD应用程序，甚至是OPA/Kyverno策略。</p><h1 id="1d67" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">重要概念</h1><p id="6c97" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">每个堆栈模板都由单元组成，这些单元接收变量和来自其他单元的输出，以部署一些基础设施。这个单元可以是一个bash脚本来创建一些TLS证书、一个Terraform模块或一些定制的解决方案。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mj"><img src="../Images/47de80bc6831525a3f846e956242c03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P5x8d2xa7LI_Nkqj.png"/></div></div></figure><p id="3c27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">深入研究模板，cluster.dev公开了熟悉的YAML模板逻辑(类似于Helm/Go模板)以及类似Terraform的语法。在最高层，有一个<code class="fe mk ml mm mn b">project.yaml</code>和秘密。该文件可定义全局变量，如AWS区域(如<code class="fe mk ml mm mn b">us-east-1</code>)或通常定义在Terraform/Terragrunt模块根的变量(如Terraform provider)。</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="548b" class="ms lh it mn b gy mt mu l mv mw">name: my_project <br/>kind: project <br/>backend: aws-backend <br/>variables:   <br/>  organization: my-org   <br/>  region: us-east-1   <br/>  state_bucket_name: cluster-dev-state<br/>exports:   <br/>  AWS_PROFILE: development</span></pre><p id="079d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">secrets的工作方式类似于external-secrets，通过sop与云提供商的secret store(例如AWS Secrets Manager)或加密的Secrets集成。</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="5a3a" class="ms lh it mn b gy mt mu l mv mw">name: my-aws-secret<br/>kind: Secret<br/>driver: aws_secretmanager<br/>spec: <br/>    region: us-east-1<br/>    aws_secret_name: my-secret</span></pre><p id="f6a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们有了<code class="fe mk ml mm mn b">backend.yaml</code>，类似于Terraform后端定义:</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="cc11" class="ms lh it mn b gy mt mu l mv mw">name: aws-backend<br/>kind: Backend<br/>provider: s3<br/>spec:  <br/>  bucket: {{ .project.variables.state_bucket_name }}  <br/>  region: {{ .project.variables.region }}</span></pre><p id="fc00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意熟悉的go-templating将变量从顶层<code class="fe mk ml mm mn b">project.yaml</code>传入后端定义。</p><p id="1940" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们有各种<code class="fe mk ml mm mn b">stack.yaml</code>文件来定义各个单元。一个简单的EKS例子可能是这样的:</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="6e5d" class="ms lh it mn b gy mt mu l mv mw">name: eks-demo<br/>template: https://github.com/shalb/cdev-aws-eks?ref=v0.2.0<br/>kind: Stack<br/>backend: aws-backend<br/>variables:<br/>  region: {{ .project.variables.region }}<br/>  organization: {{ .project.variables.organization }}<br/>  domain: cluster.dev<br/>  instance_type: "t3.medium"<br/>  eks_version: "1.20"</span></pre><p id="f834" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前只有三个“官方”支持的模板(<a class="ae le" href="https://github.com/shalb/cdev-aws-k3s" rel="noopener ugc nofollow" target="_blank"> AWS K3s </a>、<a class="ae le" href="https://github.com/shalb/cdev-aws-eks" rel="noopener ugc nofollow" target="_blank"> AWS EKS </a>和<a class="ae le" href="https://github.com/shalb/cdev-do-k8s" rel="noopener ugc nofollow" target="_blank">数字海洋K8s </a>)，但鉴于其设计，现有的Terraform模块可以用来轻松支持其他模块。</p><h1 id="80ef" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">演示安装</h1><p id="5ccb" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">为了测试这一点，我使用了<a class="ae le" href="https://github.com/shalb/cdev-aws-eks" rel="noopener ugc nofollow" target="_blank"> AWS EKS </a>示例模板，它为AWS VPC、53号公路、EKS打包了Terraform模块，然后安装cert-manager、ingress-nginx和argocd Helm charts(完整的堆栈定义在此<a class="ae le" href="https://github.com/shalb/cdev-aws-eks/blob/main/aws-eks.yaml" rel="noopener ugc nofollow" target="_blank">列出</a>)。</p><p id="a30f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使用Cluster.dev，需要安装<a class="ae le" href="https://www.terraform.io/downloads" rel="noopener ugc nofollow" target="_blank"> Terraform </a>和<a class="ae le" href="https://docs.cluster.dev/get-started-install/" rel="noopener ugc nofollow" target="_blank"> Cluster.dev二进制文件</a>。不幸的是，Mac M1s还不被支持，所以我为这个演示创建了一个Linux AMD64 VM。</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="b4ff" class="ms lh it mn b gy mt mu l mv mw">$ cdev project create <a class="ae le" href="https://github.com/shalb/cdev-aws-eks" rel="noopener ugc nofollow" target="_blank">https://github.com/shalb/cdev-aws-eks</a> --interactive</span></pre><p id="0ce7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在交互模式下运行<code class="fe mk ml mm mn b">cdev</code>提供了关于Cluster.dev所期望的更多信息(例如，它如何通过AWS认证、S3桶持有状态等)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/67c93427e5d9652082dd42c5c247c2fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ex8bcT3q3qQYQfyN2pbpkg.png"/></div></div></figure><p id="6953" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在填写项目名称、组织名称、AWS区域和DNS区域域名之后，项目后端和示例堆栈文件会自动生成。这也可以在Github 上的<code class="fe mk ml mm mn b"><a class="ae le" href="https://github.com/shalb/cdev-aws-eks/tree/main/examples" rel="noopener ugc nofollow" target="_blank">example</a></code>T19】目录下看到。</p><p id="6c93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们可以运行<code class="fe mk ml mm mn b">cdev plan</code>来预览将要创建的资源:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/5e6dea58beb06f4c8922b352edf79e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*AQpUqqugV1TbT1Ai--tEuQ.png"/></div></figure><p id="3631" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似地，我们可以运行<code class="fe mk ml mm mn b">cdev apply</code>来创建计划好的工件。</p><h1 id="929b" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">用例</h1><p id="28ee" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">对于有经验的Terraform用户来说，Cluster.dev应该看起来非常类似于Terraform和Terragrunt。演示模板就像一个简单的Terraform包装器，将EKS创建与舵图部署捆绑在一起。这是一个相当人为的例子，因为Terraform也可以处理舵图。然而，Cluster.dev最有趣的部分隐藏在单元的钩子中。最明显的例子是它如何单独管理aws-auth:</p><pre class="kp kq kr ks gt mo mn mp mq aw mr bi"><span id="37c0" class="ms lh it mn b gy mt mu l mv mw">- name: eks_auth    <br/>  type: kubernetes    <br/>  provider_version: "0.6.0"    <br/>  pre_hook:      <br/>    command: *getKubeconfig      <br/>    on_destroy: true    <br/>  kubeconfig: ../kubeconfig_{{ .name }}    <br/>  depends_on: this.eks    <br/>  source: ./eks/</span></pre><p id="1eeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">EKS Terraform模块用户熟悉让Terraform管理aws-auth 的<a class="ae le" href="https://www.koslib.com/posts/troubleshooting-terraform-eks-module/" rel="noopener ugc nofollow" target="_blank">陷阱，因为</a><a class="ae le" href="https://www.terraform.io/language/providers/configuration" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> Terraform只能引用配置应用前已知的值</em> </a>。Cluster.dev能够通过将它作为一个单元来管理来规避这个问题。</p><p id="3208" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Cluster.dev是一个很好的解决方案，适用于:</p><ol class=""><li id="6ada" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated">基础设施团队拥有一系列不同的工具。对于在本地运行遗留应用程序以及在Kubernetes上运行新的云原生应用程序的团队来说，这一点可能更加明显。</li><li id="23ff" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">平台工程团队负责为新团队维护一个启动模板，以构建和测试他们的新服务。这也适用于需要快速启动基础设施的咨询或基于项目的团队。</li><li id="816b" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">根据合同有义务交付基础设施代码和许可应用程序的软件供应商。在金融科技领域，这仍然非常普遍，大型金融机构更倾向于在自己的数据中心运行，而不是使用SaaS的产品。</li></ol><p id="272e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果您的组织的结构使得处理Terraform和Helm/argod的团队不同，Cluster.dev可能并不适合。例如，如果您的组织中的开发人员负责创建/维护掌舵图，那么引入另一个工具来抽象它将会更加困难，特别是如果已经有一个运行的CI/CD管道来处理它。</p><p id="4f8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看Cluster.dev如何默认支持更多的模板并与非地形工具(如Pulumi和Crossplane)集成将会很有趣。他们的文档网站上有一篇很好的比较文章，但是随着这些工具越来越受欢迎，重新评估会很有趣。</p></div></div>    
</body>
</html>