<html>
<head>
<title>Creating a RESTful API using Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js创建RESTful API</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-restful-api-using-node-js-256c22c47e0b?source=collection_archive---------0-----------------------#2018-03-11">https://itnext.io/creating-a-restful-api-using-node-js-256c22c47e0b?source=collection_archive---------0-----------------------#2018-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c44203b27fb410cf395f6e7d79dfef93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRp3G6ffXDMDVOvMebzYgg.jpeg"/></div></div></figure><div class=""/><p id="178a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fcreating-a-restful-api-using-node-js-256c22c47e0b" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="db0b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文面向初级开发人员和任何对在应用程序中使用node.js感兴趣的人。在深入研究之前，您应该对JavaScript和一些ES6特性有基本的了解。您还应该已经在本地计算机上安装了node.js。</p><p id="4bfb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">准备好一些代码了吗？</strong></p><p id="3e02" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不，只是开玩笑。我们需要设置和安装应用程序正常工作所需的依赖项和节点模块。由于我们将创建一个API，显然需要一个数据库。我们将使用<a class="ae kw" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>，一个<a class="ae kw" href="https://en.wikipedia.org/wiki/NoSQL" rel="noopener ugc nofollow" target="_blank"> NOSQL数据库</a>。这是满足我们需求的最佳选择，因为我们不需要关系数据库。为了简单起见，我们不在本地安装和运行它，而是在<a class="ae kw" href="https://mlab.com" rel="noopener ugc nofollow" target="_blank"> mLab </a>上连接一个沙盒数据库。</p><p id="2bd4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，请记住，mLab就像一个玩具，我建议使用<a class="ae kw" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas </a>在生产环境中托管您的数据库。这是官方的MongoDB云托管服务。</p><p id="31f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">初始化npm并安装以下模块:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8ab4" class="lh li jb ld b gy lj lk l ll lm">npm init<br/>npm install express --save<br/>npm install mongoose --save<br/>npm install body-parser --save</span></pre><p id="9383" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在这个应用程序中使用<a class="ae kw" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>，因为它是当今大多数节点应用程序的事实标准。Mongoose是一个对象关系映射器。准确的说是MongoDB使用的官方ORM。为了分解它，我们使用ORM来简化应用程序和数据库之间的数据传输。它映射我们应用程序中的数据，以支持数据库设置的一组严格规则。body-parser模块只是一个中间件，我们用它来解析通过HTTP请求发送的数据。</p><p id="d410" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">设置项目</strong></p><p id="4a30" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用你选择的任何文本编辑器。我推荐用visual studio(代码)。首先，我们应该在文本编辑器中创建一个带有js扩展名的新文件，比如(server.js)。创建文件后，下一步是在该文件中编写以下代码:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5243" class="lh li jb ld b gy lj lk l ll lm">const express = require('express');<br/>const {mongoose}= require('mongoose');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>const port =process.env.PORT||3000;<br/>app.use(bodyParser.json());<br/>module.exports = app;</span></pre><p id="bcab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码为项目设置了添加快速路线的功能。这些用来写不同的URL到你的API。</p><p id="5ab7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">设置几个其他文件</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f2e1" class="lh li jb ld b gy lj lk l ll lm">//mongoose.js<br/>var mongoose = require('mongoose');<br/>mongoose.Promise = global.Promise;<br/>mongoose.connect(process.env.MONGODB_URI);<br/>module.exports = {mongoose};</span></pre><p id="625a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个文件允许我们连接我们的mLab mongodb客户端。</p><p id="e31f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">设置猫鼬模式</strong></p><p id="afe5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将创建一个模式，给数据库中的每个用户一个特定的外观。用户将有一个名字，一个电子邮件和一个密码。通过指定<code class="fe ln lo lp ld b">mongoose.model('User', UserSchema)</code>，您将模式的布局绑定到名为<code class="fe ln lo lp ld b">'User'</code>的模型。这是您将用来访问数据库中的数据的内容，这也是您将它导出以在程序的其他部分使用的原因。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7f77" class="lh li jb ld b gy lj lk l ll lm">// User.js<br/>var mongoose = require('mongoose');  <br/>var UserSchema = new mongoose.Schema({  <br/>  name: String,<br/>  email: String,<br/>  password: String<br/>});<br/>mongoose.model('User', UserSchema);</span><span id="853e" class="lh li jb ld b gy lq lk l ll lm">module.exports = mongoose.model('User');</span></pre><p id="505f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">添加各种路线</strong></p><p id="8e1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">路由不过是不同的URL，用户必须点击它们才能执行不同的操作(获取、发布、上传、删除)。</p><p id="7d6c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用它，我们可以为我们的API创建各种路由路径，它将包含控制数据流入和流出数据库的操作。让我们继续为POST请求创建一个简单的路由:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ad40" class="lh li jb ld b gy lj lk l ll lm"><em class="kx">app.post('/users/signup',(req,res)=&gt;{<br/>var body=req.body;<br/>var user=new User(body);<br/>user.save().then(()=&gt;{<br/>res.status(200).send();})<br/>.catch((e)=&gt;{<br/>res.send(400).send(e);});});</em></span></pre><p id="47fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">app对象有一个接受两个参数的<code class="fe ln lo lp ld b">.post </code>方法。第一个是将被链接到一个函数的路由。这个函数是第二个参数。它需要另外两个参数，分别代表对服务器的请求和来自服务器的响应。在函数内部，您将使用上面要求的用户模型。用户对象包含要插入数据库的值。你看，它们的结构就像你在上面创建的模式一样。在它被创建之后，回调函数用另外两个参数调用，一个<strong class="ka jc">错误</strong>值和一个<strong class="ka jc">成功</strong>值。您将检查在创建新用户的过程中是否有错误，并做出相应的响应，或者如果一切正常，则使用新创建的数据进行响应</p><p id="d56a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Post请求应该包含以下JSON数据:</p><figure class="ky kz la lb gt is gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/fb6491b5cceba52f13faddd2ef503ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*L0J3IV5ywlbpPmX0MFS4lw.jpeg"/></div></figure><p id="8549" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要将这些数据存储到MongoDB中，我们必须:创建一个用户模型的实例，然后我们必须用该实例调用mongoose方法save()，即我们在上面的代码中所做的user.save()。我们可以挂接一个then调用和一个catch调用来添加所需的功能。在我们的示例中，我们发送状态代码200作为对成功案例的响应。对于失败案例，我们发送一个400状态代码。</p><p id="f4bd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个get请求来返回这个数据库中的所有用户:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f459" class="lh li jb ld b gy lj lk l ll lm">app.get('/users/data',(req,res)=&gt;{<br/>Sale.find().then((data)=&gt;{<br/>res.status(200).send(JSON.stringify(data,undefined,2))})<br/>.catch((e)=&gt;{<br/>res.status(400).send(e);});});</span></pre><p id="59ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">app对象还有一个<code class="fe ln lo lp ld b">.get</code>方法，它也接受两个参数。在这个函数中，你现在调用用户模型上的<code class="fe ln lo lp ld b">find()</code>方法，它也有两个参数。Find是一种从数据库中返回值的方法。它的第一个参数是一个对象，定义了返回值必须满足的要求。因为在本例中对象是空的，所以将返回数据库中的所有用户。</p><h1 id="f9fd" class="ls li jb bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">所以你认为就这样了？</h1><p id="dbe3" class="pw-post-body-paragraph jy jz jb ka b kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv ij bi translated">你只是刮到了冰山的一角。但是，现在已经足够了。不要让Node吓到你。这只是普通的JavaScript。以与您在浏览器中编写的代码相同的方式查看它。分解一下，它只是一堆事件侦听器和处理程序。</p><p id="1442" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您对Node或JavaScript有任何疑问，请随时在insta gram:<a class="ae kw" href="https://www.instagram.com/suryateja_adluri/" rel="noopener ugc nofollow" target="_blank">Suryatejaadluri</a>和脸书:<a class="ae kw" href="https://m.facebook.com/suryateja.adluri?ref=bookmarks" rel="noopener ugc nofollow" target="_blank"> suryateja.adluri </a>与我联系</p><p id="03a9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">你觉得这个教程会对某个人有帮助吗？不要犹豫分享。如果你喜欢它，点击下面的</em> <strong class="ka jc"> <em class="kx">拍手</em> </strong> <em class="kx">，这样其他人会在媒体上看到它。</em></p></div></div>    
</body>
</html>