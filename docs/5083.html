<html>
<head>
<title>Vue tricks: smart router for VueJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue窍门:VueJS的智能路由器</h1>
<blockquote>原文：<a href="https://itnext.io/vue-tricks-smart-router-for-vuejs-93c287f46b50?source=collection_archive---------0-----------------------#2020-12-07">https://itnext.io/vue-tricks-smart-router-for-vuejs-93c287f46b50?source=collection_archive---------0-----------------------#2020-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="aba4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗨，伙计们！</p><p id="c9d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将继续为我们的VueJS应用程序添加更多功能。在讲述了vue布局的故事后，我想更深入地研究自动化，为这个应用程序创建一个自动路由器。我的朋友Philipp遇到了vue路由器的下一个问题:他的应用程序中有数百条路由，路由器文件包含数百行代码。我想如果应用程序中的页面多于几页，读者也会发现这个问题。一旦开发人员在应用程序中添加新页面，允许路由器自动创建路由将是一个好主意。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/97914db83d80e5af62ef2042a1911b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*T0I_QwbUL2_0a3laN1Zfng.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">让我们实现自动化。</figcaption></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="e65b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">先决条件</h1><p id="dff3" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我们再次开始使用Vue CLI<a class="ae kl" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"><em class="mi"/></a>创建一个新的应用程序</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="ccb9" class="mo lg iq mk b gy mp mq l mr ms">vue create vue-automatic-router</span></pre><p id="2378" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以选择Vue2+或者Vue3+。该解决方案只需稍加调整，就可以在两个版本中使用。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="7859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把这个项目中不用的文件清理掉。删除<code class="fe mt mu mv mk b">assets</code>和<code class="fe mt mu mv mk b">components</code>目录。创建<code class="fe mt mu mv mk b">router</code>目录，将<code class="fe mt mu mv mk b">router.js</code>重命名为<code class="fe mt mu mv mk b">index.js</code>并移动到<code class="fe mt mu mv mk b">router</code>目录。移除<code class="fe mt mu mv mk b">Home.vue</code>中<code class="fe mt mu mv mk b">logo</code>和<code class="fe mt mu mv mk b">HelloWorld.vue</code>的所有链接，并将<code class="fe mt mu mv mk b">Home.vue</code>重命名为<code class="fe mt mu mv mk b">Index.vue</code></p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="4123" class="mo lg iq mk b gy mp mq l mr ms">--src<br/>----router<br/>------index.js<br/>----views<br/>------About.vue<br/>------Index.vue<br/>----App.vue<br/>----main.js</span></pre><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">路由器/index.js</figcaption></figure><p id="99be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们的文件夹结构，我们准备好了。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="061f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建自动路由器</h1><h2 id="e034" class="mo lg iq bd lh my mz dn ll na nb dp lp jy nc nd lt kc ne nf lx kg ng nh mb ni bi translated">基本实现</h2><p id="8e15" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">首先，在<code class="fe mt mu mv mk b">router</code>目录中创建一个名为<code class="fe mt mu mv mk b">routes.js</code>的新文件。</p><p id="a34e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在内部添加下一个函数。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">router/routes.js</figcaption></figure><p id="74c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数试图找到所有vue文件，从指向目录的开头<code class="fe mt mu mv mk b">./</code>删除两个字符，删除文件扩展名<code class="fe mt mu mv mk b">.vue</code>并使用斜杠<code class="fe mt mu mv mk b">/</code>作为分隔符从文件的路径字符串创建一个数组。</p><p id="683e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们应该从视图目录中导入所有的页面。客户端应用程序和浏览器不能直接访问文件系统的问题。我们可以尝试使用一些棘手的方法来访问文件系统，但幸运的是，由于我们使用的是webpack，因此可以使用webpack的<code class="fe mt mu mv mk b"><a class="ae kl" href="https://webpack.js.org/guides/dependency-management/#requirecontext" rel="noopener ugc nofollow" target="_blank">require.context</a></code>函数。让我们这样做:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">router/routes.js</figcaption></figure><p id="1e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">明白我们到底在做什么。<br/>我们在之前的函数<code class="fe mt mu mv mk b">importAll</code>中添加了<code class="fe mt mu mv mk b">require.context</code>作为参数</p><p id="8312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">require.context</code>的第一个参数是页面文件夹的相对路径。请确保您使用的结构与我相同，或者相应地调整路径。</p><p id="13d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个参数允许函数递归地检查内部文件夹。</p><p id="4a6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第三个例子中，我们指定文件扩展名，在我们的例子中是<code class="fe mt mu mv mk b">.vue</code>。</p><p id="6148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在pages变量是一个包含两个元素的数组</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="9f65" class="mo lg iq mk b gy mp mq l mr ms">[["About"], ["Home"]]</span></pre><p id="2c81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候创建一个助手函数来从页面创建我们的路线了</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">router/routes.js</figcaption></figure><p id="bac5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个功能现在很简单，但在我们创建自动路由器的过程中，它会逐步扩展。现在我们只需检查文件名是否是<code class="fe mt mu mv mk b">index</code>并将路径改为<code class="fe mt mu mv mk b">/</code>而不是<code class="fe mt mu mv mk b">/index</code>，否则它返回小写的路径名。对于<code class="fe mt mu mv mk b">About.vue</code>是<code class="fe mt mu mv mk b">/about</code></p><p id="85d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mt mu mv mk b">routes.js</code>年底，我们需要导入我们的新路线</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">router/routes.js</figcaption></figure><p id="411f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在默认导出中，所有组件都是动态导入的。它需要从组件中获取路由的名称。稍后，我们将从这里的组件导入更多数据。</p><p id="2d70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们应该调整<code class="fe mt mu mv mk b">router/index.js</code>和<code class="fe mt mu mv mk b">main.js</code>来处理我们在<code class="fe mt mu mv mk b">router/routes.js</code>中创建的承诺</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">路由器/index.js</figcaption></figure><p id="17db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不是导出路由器，而是导出代表我们的路由器的承诺数组，并等待所有路由都被导入。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">主页. js</figcaption></figure><p id="3b86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们的路由器现在是异步的，所以我们应该在创建Vue实例之前创建一个异步包装器。</p><p id="cfd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是两个文件的Vue3实现</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">路由器. index.js</figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">主页. js</figcaption></figure><p id="55e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候从<code class="fe mt mu mv mk b">npm run serve</code>开始我们的项目了，要知道一切都在按预期进行。</p><h2 id="fc62" class="mo lg iq bd lh my mz dn ll na nb dp lp jy nc nd lt kc ne nf lx kg ng nh mb ni bi translated">创建路由树</h2><p id="36a1" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在大多数情况下，仅仅有简单的路线还不够，如<code class="fe mt mu mv mk b">/</code> <code class="fe mt mu mv mk b">/about</code> <code class="fe mt mu mv mk b">/countacts</code>等等。通常，真正的web应用程序有更复杂的路由系统。现在让我们调整我们的<code class="fe mt mu mv mk b">generateRoute</code>函数来处理更复杂的树。</p><p id="de99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你熟悉NuxtJS方法，我下面分享的方法你也会很熟悉。如果没有，我来解释一下它的工作原理。</p><p id="7ff3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">路由是基于我们的文件结构创建的。在我们最初的例子中，我们只有两个页面组件<code class="fe mt mu mv mk b">Index.vue</code>和<code class="fe mt mu mv mk b">About.vue</code>。它为我们提供了两条路线:<code class="fe mt mu mv mk b">/</code>和<code class="fe mt mu mv mk b">/about</code>。如果你需要路线<code class="fe mt mu mv mk b">/users</code>和<code class="fe mt mu mv mk b">/user/profile</code>，你应该有下一个文件结构:</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="379a" class="mo lg iq mk b gy mp mq l mr ms">--src<br/>----views<br/>------users<br/>--------Profile.vue<br/>--------Index.vue</span></pre><p id="a7f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要创建一个包含两个<code class="fe mt mu mv mk b">vue</code>文件<code class="fe mt mu mv mk b">Profile.vue</code>和<code class="fe mt mu mv mk b">Index.vue</code>的文件夹<code class="fe mt mu mv mk b">users</code></p><p id="f436" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们为<code class="fe mt mu mv mk b">posts</code>资源创建一个典型的CRUD视图。我们不会得到API连接，因为这是我在这篇<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/vue-tricks-smart-api-module-for-vuejs-b0cae563e67b">文章</a>中涉及的另一个主题。只需为该系统创建路线:</p><p id="3235" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">/posts</code> —显示帖子列表</p><p id="5942" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">/posts/create</code> —创建新帖子</p><p id="f33e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">/posts/1</code> —显示id === 1的帖子</p><p id="ca08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mk b">/posts/edit/1</code> —编辑id === 1的帖子</p><p id="ecb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在下一小节中讨论动态路由，并集中讨论前两个:显示帖子列表和创建新帖子。</p><p id="0e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用两个文件<code class="fe mt mu mv mk b">Index.vue</code>和<code class="fe mt mu mv mk b">Created.vue</code>创建一个<code class="fe mt mu mv mk b">posts</code>文件夹</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">视图/帖子/索引. vue</figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">views/post/create . vue</figcaption></figure><p id="e57d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它对我们的路由器没有任何作用，因为我们应该首先调整我们的<code class="fe mt mu mv mk b">generateRoute</code>功能。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">router/routes.js</figcaption></figure><p id="71ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您测试您的两条路线，您可以看到我们的组件的内容。路由器有下一个结构:</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="8cd7" class="mo lg iq mk b gy mp mq l mr ms">[<br/>{<br/>  component: About.vue,<br/>  name: 'About',<br/>  path: '/about'<br/>}<br/>{<br/>  component: Index.vue,<br/>  name: 'Home',<br/>  path: '/'<br/>}<br/>{<br/>  component: posts/Index.vue,<br/>  name: 'Posts',<br/>  path: '/posts'<br/>}<br/>{<br/>  component: posts/Create.vue,<br/>  name: 'PostCreate',<br/>  path: '/posts/create'<br/>}<br/>]</span></pre><h2 id="8652" class="mo lg iq bd lh my mz dn ll na nb dp lp jy nc nd lt kc ne nf lx kg ng nh mb ni bi translated">处理动态路由</h2><p id="05ca" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">通常，在构建应用程序的过程中，开发人员不仅需要处理静态路由，还需要处理动态路由。让我们将此功能添加到我们的自动路由器中。我们将再次调整我们的<code class="fe mt mu mv mk b">generateRoute</code>函数。但在此之前，让我们在视图文件夹中创建两个新文件。在编辑<code class="fe mt mu mv mk b">posts</code>文件夹中创建文件<code class="fe mt mu mv mk b">_Id.vue</code>。是的，不是错别字。文件必须以<code class="fe mt mu mv mk b">_</code>符号开始。它告诉我们的路由器这条路由是动态的。在<code class="fe mt mu mv mk b">views/posts</code>文件夹中创建名为<code class="fe mt mu mv mk b">edit</code>的文件夹。在里面添加文件<code class="fe mt mu mv mk b">_Id.vue</code>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">views/posts/_Id.vue</figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">views/posts/edit/_Id.vue</figcaption></figure><p id="9409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是<code class="fe mt mu mv mk b">generateRoute</code>功能的最后调整</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">路由器中又增加了两条路由</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="22e6" class="mo lg iq mk b gy mp mq l mr ms">[<br/>...<br/>{<br/>  component: posts/_Id.vue,<br/>  name: 'PostDetails',<br/>  path: '/posts/:id'<br/>}<br/>{<br/>  component: posts/edit/_Id.vue,<br/>  name: 'PostEdit',<br/>  path: '/posts/edit/:id'<br/>}<br/>]</span></pre><p id="de84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用<code class="fe mt mu mv mk b">npm run serve</code>测试</p><h2 id="a450" class="mo lg iq bd lh my mz dn ll na nb dp lp jy nc nd lt kc ne nf lx kg ng nh mb ni bi translated">处理嵌套路线</h2><p id="2b85" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">不太经常，但有时需要使用<a class="ae kl" href="https://router.vuejs.org/guide/essentials/nested-routes.html" rel="noopener ugc nofollow" target="_blank">嵌套路由</a>，也称为子路由。所以，我们再把手弄脏，加到我们的自动路由器上。</p><p id="4db0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与动态路由一样，对于嵌套路由，我们将使用前缀让路由器知道它是嵌套路由。在嵌套路线的情况下，它是<code class="fe mt mu mv mk b">^</code>符号。嵌套路由必须放置在与父路由相同的级别上。</p><p id="5d3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们将这个功能添加到我们的<code class="fe mt mu mv mk b">router/routes.js</code>文件中。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8346" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数创建一个嵌套路由列表，其中的键是嵌套路由的父路径和值数组。让我们也扩展导出的函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">router/routes.js</figcaption></figure><p id="efbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要看到这些变化，我们应该在一个新文件夹<code class="fe mt mu mv mk b">users</code> <code class="fe mt mu mv mk b">users/Index.vue</code>和<code class="fe mt mu mv mk b">users/^Profile.vue</code>中再创建两个页面</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你是否注意到这里需要另一个<code class="fe mt mu mv mk b">router-view</code>来显示嵌套的路线？</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="504c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个具有嵌套路由的路由已被添加到自动路由器中。</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="88dc" class="mo lg iq mk b gy mp mq l mr ms">[<br/>...<br/>{<br/>  children: [<br/>    component: users/^Profile.vue,<br/>    name: 'UserProfile',<br/>    path: '/users/profile'<br/>  ],<br/>  component: users/Index.vue,<br/>  name: 'Users',<br/>  path: '/users'<br/>}<br/>]</span></pre><p id="4163" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们结束了。我们介绍了一个新的自动路由器，它有助于开发者保持路由器的整洁，特别是当应用程序中有很多路由时，可以避免长路由文件地狱。</p><h2 id="c7a1" class="mo lg iq bd lh my mz dn ll na nb dp lp jy nc nd lt kc ne nf lx kg ng nh mb ni bi translated">奖金。添加布局和中间件。</h2><p id="ddf6" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">在我们继续之前，我鼓励读者阅读这篇<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/vue-tricks-smart-layouts-for-vuejs-5c61a472b69b">文章</a>来理解这里正在发生的事情。我们不会深入智能布局的主题，但将这两种方法结合成一个。正如您所记得的，要向路由添加布局，我们应该为路由指定<code class="fe mt mu mv mk b">meta</code>属性，并在那里添加布局名称(以及中间件)。让我们在我们的自动路由器中也这样做。</p><p id="44ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该调整<code class="fe mt mu mv mk b">router/routes.js</code>文件中的导出功能。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae kl" href="https://gist.github.com/NovoManu/08269f3df606ca5ae4142c44982c6bef" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/novo manu/08269 F3 df 606 ca 5a e 4142 c 44982 c 6 bef</a></figcaption></figure><p id="b361" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了处理中间件，也应该调整<code class="fe mt mu mv mk b">router/index.js</code>文件</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">路由器/index.js</figcaption></figure><p id="c4f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以直接在组件中指定您的布局和中间件。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">views/home.vue</figcaption></figure><h2 id="c593" class="mo lg iq bd lh my mz dn ll na nb dp lp jy nc nd lt kc ne nf lx kg ng nh mb ni bi translated">奖金。NMP模块</h2><p id="be95" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">如果您不想从头开始创建整个实现，请随意使用我创建的npm模块，可以在这里找到:</p><div class="nj nk gp gr nl nm"><a href="https://www.npmjs.com/package/vue-automatic-router" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">vue-自动路由器</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">受NuxtJS路由的启发，这个包将类似的系统添加到本地VueJS项目中。这意味着它不…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">www.npmjs.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa ks nm"/></div></div></a></div></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="65ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这种方法可以使你的项目更整洁，节省一些时间。无论如何，尝试一些新的东西来避免你的日常事务总是很有趣的。你可以在我的github账户上找到代码库—<a class="ae kl" href="https://github.com/NovoManu/vue-automatic-router-example" rel="noopener ugc nofollow" target="_blank">https://github.com/NovoManu/vue-automatic-router-example</a></p><p id="53b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您对本文或我的其他文章感兴趣，请随时关注我:</p><p id="e361" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">github:【https://github.com/NovoManu T2】</p><p id="1d58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">推特:【https://twitter.com/ManuSEngineer T4】</p><p id="701e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乡亲们就这些了，<br/>下篇见。</p></div></div>    
</body>
</html>