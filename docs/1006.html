<html>
<head>
<title>Using Enums and Closures to Substitute Delegates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用枚举和闭包替换委托</h1>
<blockquote>原文：<a href="https://itnext.io/using-enums-and-closures-to-substitute-delegates-901c7b9ea8ce?source=collection_archive---------4-----------------------#2018-07-03">https://itnext.io/using-enums-and-closures-to-substitute-delegates-901c7b9ea8ce?source=collection_archive---------4-----------------------#2018-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/db2092e9087698dc39b2f5c42ce58b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hZVew8ASYYZ2ps8abkbXA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/photos/MAgPyHRO0AA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">你好我是Nik </a>上<a class="ae kc" href="https://unsplash.com/search/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="f4f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为iOS开发者，我们习惯于使用委托来异步移动数据，苹果当然也喜欢使用它们。<br/>然而，如果你和我(以及其他许多iOS开发者)一样，避免使用它们是我们开发步骤中很重要的一部分，尤其是在使用没有RxSwift(或任何其他函数式反应式编程库)的MVVM时。</p><p id="a7b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将结合使用闭包和枚举来避免在<code class="fe lb lc ld le b">ViewModel</code>和<code class="fe lb lc ld le b">ViewController</code>之间使用委托。<br/>我们将要处理的项目使用了委托，我们将重构它，改为使用枚举和闭包。</p><p id="21dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对闭包不够熟悉，我推荐你先看看这个:<a class="ae kc" href="https://medium.com/@dmlebron/using-swift-closures-as-an-alternative-to-delegates-5c3c1a7f45d6" rel="noopener"> <em class="lf">不要滥用委托，用Swift闭包代替</em> </a></p><p id="69e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，访问<a class="ae kc" href="https://github.com/dmlebron/closure_enums_delegates/tree/initial_state" rel="noopener ugc nofollow" target="_blank">这里</a>获得初始项目。</p><p id="368f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们运行应用程序，了解它的工作原理:</p><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/a6fe09da5b56aff3c4b4552adde0a049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ik0lyI6cahuTg-J7r1r8Q.png"/></div></div></figure><p id="8668" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是一个简单的应用程序，它有一个Api客户端、一个视图模型和一个视图控制器。<br/>Api客户端通过网络调用获取所有作业，然后将对象发送给视图模型，视图模型通知视图控制器加载状态，并传递要显示的对象。所有这些调用都是异步的。因此，我们使用委托将数据从Api客户机一直传递到视图控制器。</p><h2 id="15d2" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">重构:</h2><p id="2f6e" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated"><strong class="kf ir"> Api客户端<br/>这里我们有两个委托:</strong></p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b73c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始在名为<code class="fe lb lc ld le b">Response</code>的<code class="fe lb lc ld le b">ApiClient</code>类中创建一个<code class="fe lb lc ld le b">enum</code>。</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7af1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们为结束语创建一个<code class="fe lb lc ld le b">typealias</code>。</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7fb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们差不多完成了，现在让我们修改函数签名，让我们刚刚声明的<code class="fe lb lc ld le b">Closure</code> typealias。</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="95a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了，现在让我们把所有的碎片放在一起。<br/>在用新的<code class="fe lb lc ld le b">closure</code>参数替换委托方法调用，并删除类中与<code class="fe lb lc ld le b">ApiClientDelegate</code>相关的所有内容之后，它看起来应该是这样的。</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7890" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">厉害！<br/>到现在为止，您应该会在视图模型上看到一堆错误，但是不要担心，我们会马上处理这些错误。</p><p id="cb5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">查看模型</strong> <br/>按照我们刚刚在<code class="fe lb lc ld le b">ApiClient</code>中所做的相同模式，我们需要:</p><ul class=""><li id="9105" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">在名为<code class="fe lb lc ld le b">Result</code>的ViewModel类中添加一个<code class="fe lb lc ld le b">enum</code></li><li id="bfb9" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">声明一个名为<code class="fe lb lc ld le b">Closure</code>的<code class="fe lb lc ld le b">Result -&gt; ()</code>类型的typealias</li><li id="2cdb" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">移除底部的委托变量、init和扩展</li><li id="a5ff" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">修改函数声明，使其具有一个<code class="fe lb lc ld le b">Closure</code>参数</li><li id="58fa" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">在<code class="fe lb lc ld le b">get</code>函数中，我们需要对<code class="fe lb lc ld le b">response</code>进行<code class="fe lb lc ld le b">switch</code>操作，以从调用中获取<code class="fe lb lc ld le b">result</code>或<code class="fe lb lc ld le b">error</code>。</li><li id="8c0b" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">完成所有这些步骤后，该类应该如下所示:</li></ul><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f3c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在……视图控制器正在大声呼救，让我们直接跳进来吧。</p><p id="a8c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">视图控制器</strong></p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="cbfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们可以将viewModel变量改为<code class="fe lb lc ld le b">let</code>而不是<code class="fe lb lc ld le b">lazy var</code>，现在，让我们将<code class="fe lb lc ld le b">switch</code>放在<code class="fe lb lc ld le b">result</code>上，就像我们在视图模型上所做的那样。</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f9f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样…等等… <br/>我们通过在闭包内部调用self来创建一个引用循环。为了解决这个问题，让我们在闭包中的<code class="fe lb lc ld le b">(result)</code>之前使用下面的捕获列表<code class="fe lb lc ld le b">[unowned self]</code>。对于应该使用<code class="fe lb lc ld le b">[weak self]</code>还是<code class="fe lb lc ld le b">[unowned self]</code>有很多争议，但是对于这个例子，使用unowned是正确的选择。</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="fc0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行应用程序，一切都应该像预期的那样工作。</p><h2 id="01d0" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">可扩展:</h2><p id="ecbc" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">如果您有两个以上的委托(如本例所示)，您可以快速扩展您的枚举以包含更多的事例。这就是这种方法吸引人、干净、易于遵循和易于扩展的原因。</p><p id="6ccd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要下载最终项目，请访问<a class="ae kc" href="https://github.com/dmlebron/closure_enums_delegates/tree/final_state" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="4fa1" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">跟我来</h2><p id="a137" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">推特:<a class="ae kc" href="https://twitter.com/dmlebron" rel="noopener ugc nofollow" target="_blank">勒布朗</a></p></div></div>    
</body>
</html>