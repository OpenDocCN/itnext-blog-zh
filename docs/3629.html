<html>
<head>
<title>CQRS &amp; Mediator Part 1: Why and how I implemented CQRS and Mediator patterns in a microservice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CQRS和仲裁者第1部分:为什么以及如何在微服务中实现CQRS和仲裁者模式</h1>
<blockquote>原文：<a href="https://itnext.io/why-and-how-i-implemented-cqrs-and-mediator-patterns-in-a-microservice-b07034592b6d?source=collection_archive---------0-----------------------#2020-01-21">https://itnext.io/why-and-how-i-implemented-cqrs-and-mediator-patterns-in-a-microservice-b07034592b6d?source=collection_archive---------0-----------------------#2020-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ae6e90bf8de88e77a4af57bd84c499d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hwb4RVZWnjjeZS7oW7QIDQ.jpeg"/></div></div></figure><blockquote class="jy jz ka"><p id="9d78" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这篇文章介绍了我为什么选择CQRS和中介模式，使用哪些库，多层项目结构，设置以及如何在微服务环境中应用它们。<a class="ae la" href="https://github.com/ArmandJ77/CQRSAndMediator-Microservice" rel="noopener ugc nofollow" target="_blank"> Git回购</a></p></blockquote><h1 id="f327" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">系列</h1><ul class=""><li id="1c7b" class="lz ma iq ke b kf mb kj mc md me mf mg mh mi kz mj mk ml mm bi translated"><a class="ae la" href="https://medium.com/@armandjordaan6/why-and-how-i-implemented-cqrs-and-mediator-patterns-in-a-microservice-b07034592b6d" rel="noopener"> CQRS &amp;中介器第1部分:<br/>为什么以及如何在微服务中实现CQRS和中介器模式</a></li><li id="7b77" class="lz ma iq ke b kf mn kj mo md mp mf mq mh mr kz mj mk ml mm bi translated"><a class="ae la" href="https://medium.com/@armandjordaan6/cqrs-mediator-part-2-domain-scaffolding-with-roslyn-api-and-dotnet-cli-7c99b5b011f" rel="noopener"> CQRS &amp;中介器第2部分:<br/>使用Roslyn API和Dotnet CLI的领域搭建</a></li></ul></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="1534" class="lb lc iq bd ld le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly bi translated">语境</h1><p id="8950" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km md ne kp kq mf nf kt ku mh ng kx ky kz ij bi translated">但是为什么我听到你问？在使用膨胀的域类(其中使用多个函数来修改状态和实现域规则)时，调试、扩展和审查变得越来越困难。我经常发现一个业务规则函数实现了多个子规则，这些子规则在领域中的某个地方重复出现。多个复杂的抽象层试图共享功能，或者多个开发人员实现了他们各自倡导不同模式和实践的策略。但是最大的挑战是代码库随着业务领域需求的不断变化而不断变化。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="fcae" class="lb lc iq bd ld le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly bi translated">问题</h1><p id="451f" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km md ne kp kq mf nf kt ku mh ng kx ky kz ij bi translated">一些服务以CRUD应用开始，但随着时间的推移，领域变得更加复杂，规则更多，但随后开发人员改变角色，新的开发人员决定要么重写服务，要么开始复杂的重构过程，这会进一步延迟交付。</p><p id="114c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">膨胀的域管理器代码的气味之一是注入多个接口时不断增加的参数列表。</p><p id="b230" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">按领域关注分组的业务逻辑，例如一个订单管理器类，包含订单上可能的每个操作，其中一个函数会修改另一个管理器类的状态。</p><p id="4b18" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">遵循业务规则的流程会导致您在没有明确的方法来解释确切意图的情况下，一步一步地通过多个管理人员和跨领域的功能。</p><p id="3b39" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">当您只想测试一个新功能时，测试变得复杂，必须模拟多个接口。一些开发人员走捷径，认为庞大的manger测试类会在某个时候测试它，从而使测试不完整。</p><p id="2435" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">在API级别不对入站请求进行验证。相反，请求被允许通过中间件层、API层，并且只在管理器的动作功能中被验证。在开始编写实际的域规则之前，这会导致臃肿的动作函数和大量的验证规则。<br/> —这个又费时又烦人。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="e10a" class="lb lc iq bd ld le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly bi translated">模式</h1><p id="ca71" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km md ne kp kq mf nf kt ku mh ng kx ky kz ij bi translated">鉴于上述情况，我研究了以下模式来重构服务。</p><p id="51ca" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir"> CQRS模式</strong></p><p id="44da" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">简而言之，这种模式允许您将创建/更新操作(命令)与读取操作(查询)分开，每个操作返回它们的响应模型，以便清楚地分离每个操作。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/4e58be3d90da52e4b15c6133d96ad814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9FxL9PqRbP6_y_tw95oxQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">CQRS的一个单层工程的基本操作示例</figcaption></figure><p id="2f24" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">这种模式可以应用于其他情况，其中API被分成两个独立的微服务，一个用于命令，另一个用于读取。</p><p id="eb3c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">这超出了本文的范围，但是鼓励您查看这篇<a class="ae la" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs" rel="noopener ugc nofollow" target="_blank"> MSDN </a>的文章以了解更多细节。</p><p id="ebde" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">需要注意的是，在用一个处理函数将逻辑从一个集中的域对象转移到多个动作对象时，它确实会产生开销。但是这在你的领域中创建了一个标准，允许你在其上构建脚手架模板。</p><p id="84ff" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">在后面的文章中，我将构建一个dotnet CLI工具，该工具将搭建出所需的类，从而让开发人员纯粹专注于解决业务问题。</p><p id="c349" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">调解人模式</strong></p><p id="48bc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">通过促进松散耦合，该模式实现了一个中介对象，其中其他对象与其通信，而不是相互通信。</p><p id="4e54" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">在给定的例子中，邮件收发室充当入站信件之间通信的中介，并将它们发送到正确的目的地。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/78a005d545edf6f857fee8229f9b8cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wteJCDw0Ix2jg7dHPPRCg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">中介模式的邮件收发室示例</figcaption></figure><p id="c3be" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">我推荐这个<a class="ae la" href="https://sourcemaking.com/design_patterns/mediator" rel="noopener ugc nofollow" target="_blank">站点</a>以获得详细的解释，它也是各种其他模式的快速参考指南。</p><p id="2142" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">例如，我们不会滚动我们的mediator，相反，我们将使用Jimmy Bogard编写的<a class="ae la" href="https://github.com/jbogard/MediatR" rel="noopener ugc nofollow" target="_blank">mediator</a>库，该库也因创建了auto mapper库而闻名。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="1139" class="lb lc iq bd ld le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly bi translated">解决办法</h1><p id="c181" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km md ne kp kq mf nf kt ku mh ng kx ky kz ij bi translated">构建一个面向3.1的dotnet核心微服务来演示这些模式。由此我们走向一个更加垂直的架构，即将臃肿的控制器功能分解成一种action类，每个类实现一个称为handler的功能，并让MediatR库促进这些handler之间的通信。</p><p id="8155" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">我们将只关注API和域层，因为测试和数据库层是大多数dotnet核心应用程序中的标准实现。</p><h2 id="c006" class="nr lc iq bd ld ns nt dn lh nu nv dp ll md nw nx lp mf ny nz lt mh oa ob lx oc bi translated">结构:</h2><p id="2912" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km md ne kp kq mf nf kt ku mh ng kx ky kz ij bi translated">对于更复杂的应用程序来说，将它们的服务分解到一个多层项目中可能是一种最佳实践。使用这种方法的最佳权衡之一是清晰的关注点分离，并且一层中的变化不应该导致另一层中的主要架构变化。推荐这个<a class="ae la" href="https://youtu.be/5OtUm1BLmG0" rel="noopener ugc nofollow" target="_blank">演讲</a>来更广泛地概述清洁架构和罗伯特·c·马丁的<a class="ae la" href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" rel="noopener ugc nofollow" target="_blank">清洁代码</a></p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c74318624d340b485a3c7a1b27f3faa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*Ja97m26_WVFYhu64JdvulQ.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">多层溶液结构</figcaption></figure><h2 id="4b73" class="nr lc iq bd ld ns nt dn lh nu nv dp ll md nw nx lp mf ny nz lt mh oa ob lx oc bi translated">API层</h2><p id="b747" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km md ne kp kq mf nf kt ku mh ng kx ky kz ij bi translated">API NuGet包</p><p id="0b7f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir"> API等级验证:</strong></p><pre class="ni nj nk nl gt oe of og oh aw oi bi"><span id="805a" class="nr lc iq of b gy oj ok l ol om">Install-Package FluentValidation -Version 8.6.1<br/>Install-Package FluentValidation.AspNetCore -Version 8.6.1<br/>Install-Package FluentValidation.DependencyInjectionExtensions -Version 8.6.1</span></pre><p id="c8f6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">中介:</strong></p><pre class="ni nj nk nl gt oe of og oh aw oi bi"><span id="423a" class="nr lc iq of b gy oj ok l ol om">Install-Package MediatR -Version 8.0.0<br/>Install-Package MediatR.Extensions.Microsoft.DependencyInjection -Version 8.0.0</span></pre><p id="384a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir"> JsonPatch: </strong></p><pre class="ni nj nk nl gt oe of og oh aw oi bi"><span id="3472" class="nr lc iq of b gy oj ok l ol om">Install-Package Microsoft.AspNetCore.JsonPatch -Version 3.1.0<br/>Install-Package Microsoft.AspNetCore.Mvc.NewtonsoftJson -Version 3.1.0</span></pre><p id="0f61" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir"> Setup.cs </strong></p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">Setup.cs</figcaption></figure><p id="a833" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">第16行:<br/>向MVC请求管道注册验证过滤器中间件。</p><p id="19b6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">第18–21行:<br/>注册实现AbstractValidator &lt; T &gt;类的Fluent验证类。</p><p id="31b4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">第20行:<br/>配置Fluent验证从微服务加载。逻辑汇编。任何验证类都可以作为&lt; T &gt;传递。</p><p id="cf9e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">第26行:<br/>加载域设置和服务。</p><p id="750e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">第28行:<br/>注册实现IRequest &lt; T &gt;和IRequestHandlers &lt; TRequest，TResponse &gt;接口的类。</p><p id="129f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">第30行:<br/>在MediatR请求管道中添加验证中间件。它的工作原理和普通中间件一样。这将在从一个处理程序到另一个处理程序时提供域级验证，同时使用与API级验证相同的验证类。</p><p id="8674" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">过滤器:</strong></p><p id="1ec2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">Fluent验证中间件类的标准实现，通过它我们检查请求的模型状态是否有效，提取错误消息，然后实例化自己定义的使用模型状态错误消息填充的<em class="kd">error response/error model</em>对象，然后用<em class="kd"> errorResponse </em>实例化新的<em class="kd"> BadRequestObjectResult </em>并返回。</p><p id="5203" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">验证过滤器. cs</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">验证过滤器. cs</figcaption></figure><p id="6e8e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">如果入站模型包含任何无效属性，我们将在中间件级别返回，而无需支付在域管理器中验证请求的处理成本，并减少编写空检查和其他普通验证操作的持续需求。相反，我们只关注领域规则及其需求。</p><p id="9c9d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">一旦进入领域层，我们将看看如何重用Fluent验证类，以确保在调用另一个处理程序时进行验证，即领域级验证。</p><p id="fc1a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">控制器:</strong></p><p id="23e6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">像你在网上找到的大多数例子一样，我们将从一个基本的CRUD实现开始，即<em class="kd"> OrdersController。在领域层，我将讨论如何利用更高级的特性，以及在哪里可以利用处理程序。</em></p><p id="9338" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">OrdersController.cs</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">OrdersController.cs</figcaption></figure><p id="054e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">第15–20行:<br/>你会注意到的第一件事是，我们在这里注入的唯一依赖项是控制器方法用来传递命令和查询的<em class="kd"> IMediator </em>接口。中介会将这些请求解析到域层中正确的处理程序。</p><p id="a48c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">第25、33和48行:<br/>用请求参数初始化和实例化查询/命令对象。</p><p id="d3a8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">第26、34、41和49行:<br/>调用<em class="kd"> IMediator </em>接口上的send函数，将命令/查询解析到相应的处理程序。</p><p id="4e92" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">第27、35、42和50行:<br/>格式化响应并返回结果。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="bf20" class="nr lc iq bd ld ns nt dn lh nu nv dp ll md nw nx lp mf ny nz lt mh oa ob lx oc bi translated">逻辑/域层</h2><p id="d00c" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km md ne kp kq mf nf kt ku mh ng kx ky kz ij bi translated">你可以称之为逻辑层或领域层，这是一回事，所有领域规则都存在的地方，你的小时费率也是从这里产生的。老实说，不管您的服务实现了多少先进的模式和实践，赚钱的机会都在领域中，而不是在通信或基础设施设置中。</p><p id="27f4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">我认为这一层是时间和重构成本损失最大的地方。一个不是为变化而构建的领域，或者一个业务规则不断变化的领域，将导致代价高昂的重构和浪费上市时间。</p><p id="b121" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">我发现，在我看来，当开发人员在没有项目模板或核心开发支持团队的环境中工作时，他们往往会在初始阶段花费70/30的时间，更多地关注项目设置和基础设施，而不是初始的领域规则。</p><p id="d431" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">但是，为什么我需要一个项目模板或你所说的“核心团队”，作为一个服务所有者，我想从头开始构建一切，因为每个领域都是不同的，我需要在服务中完全自治？</p><p id="d266" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">很棒的问题！首先，核心团队的概念可能会在未来的文章中讨论，因为有各种各样的因素，如预算、个人/项目约束等。然而，我相信，包含结构、中间件设置和已安装的内部/外部NuGet包的结构良好的项目模板，在考虑扩展您的体系结构时，将极大地提高您的团队的效率，因为它给团队领导或架构师团队提供了某种程度上的监督，并确保大多数项目都以正确的方式开始。是的，在有些情况下，领域要么是未知的，要么是高度专门化的，项目模板会妨碍它们。然而，这些项目很可能由在该领域有经验的高级开发人员和架构师来处理。</p><p id="6da6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">但是足够的意见，让我们深入到域设置:</p><p id="8557" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">获取软件包:</strong></p><pre class="ni nj nk nl gt oe of og oh aw oi bi"><span id="c4f1" class="nr lc iq of b gy oj ok l ol om">Install-Package FluentValidation -Version 8.6.1<br/>Install-Package MediatR -Version 8.0.0<br/>Install-Package Microsoft.AspNetCore.JsonPatch -Version 3.1.0</span></pre><p id="baf1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">项目结构:</strong></p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/3e9fa560fcdb623a85863235938f8aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*GtsNHNtKlUEfX-FsQOhLng.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">畴结构</figcaption></figure><p id="4e3e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">注:</strong></p><ul class=""><li id="96e6" class="lz ma iq ke b kf kg kj kk md oq mf or mh os kz mj mk ml mm bi translated">在模型目录中，有一个不属于CQRS模式的OrderPatch模型。它在Patch函数中用于将入站更改应用于原始订单和新更改之间的比较。</li><li id="9265" class="lz ma iq ke b kf mn kj mo md mp mf mq mh mr kz mj mk ml mm bi translated">至于对象映射策略，我已经对位于<em class="kd"> Mappers.OrderMapper.cs. </em>中的<em class="kd"> Order </em>实体使用了扩展函数。规则是在这里添加映射函数，该函数在多个处理程序中使用，否则在处理程序函数中实例化和初始化映射，因为它仅在那里使用。其他策略可能包括使用对象到对象的映射库，如<a class="ae la" href="https://automapper.org" rel="noopener ugc nofollow" target="_blank">自动映射器</a>或定制实现。</li></ul><p id="97e0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">配置:</strong></p><p id="a08c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">configureservicecollectionextensions . cs</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">configureservicecollectionextensions . cs</figcaption></figure><p id="4cd3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">响应，命令&amp;查询:</strong> <br/>两者都是标准类，每个都实现<em class="kd">mediator的I request&lt;t Response&gt;</em>接口，其中<em class="kd"> TResponse是标准C# </em>类，即</p><p id="2bd0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">订单响应. cs</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">订单响应. cs</figcaption></figure><p id="d1ff" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">GetOrderByIdQuery.cs</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">GetOrderByIdQuery.cs</figcaption></figure><p id="eb55" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">经手人:</strong></p><p id="7bf8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">PatchOrdersHandler.cs</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="on oo l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">PatchOrdersHandler.cs</figcaption></figure><p id="ad81" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">每个处理程序都实现了<em class="kd">IRequestHandler&lt;t request，t response&gt;T18】接口。在这个例子中，处理程序将接受一个<em class="kd"> PatchOrderCommand </em>并返回一个<em class="kd"> OrderResponse对象</em>。</em></p><p id="2748" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">此外，该示例实现了<em class="kd"> BaseHandler </em>类，该类公开了<em class="kd"> DbContext </em>和<em class="kd"> IMediator </em>属性。</p><p id="d7fb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated"><strong class="ke ir">域名级别验证:</strong></p><p id="5411" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">我之前提到过这一点，其实现方式是使用MediatR请求管道中的中间件和Fluent验证的<em class="kd">abstract validator&lt;T&gt;T</em>基类实现在<em class="kd">验证器</em>目录中</p><p id="694b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">使用MediatR进行域级验证</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="89d5" class="lb lc iq bd ld le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly bi translated">结论</h1><p id="c717" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km md ne kp kq mf nf kt ku mh ng kx ky kz ij bi translated">转向更垂直的架构的好处在于它的简单性，开发者在进行改变时可以一次完全专注于架构的一层。通过限制副作用，这个领域变得一片混乱，一个清晰的业务规则的意图浮现在脑海中。</p><p id="0099" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km md ko kp kq mf ks kt ku mh kw kx ky kz ij bi translated">最大的代价是对象创建的数量，这也是一个烦恼。在下一篇文章中，我将研究Roslyn APIs，以构建一个dotnet CLI工具来构建一个新处理程序的所有细节，让开发人员专注于域实现，而不是被基础设施设置分散注意力。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="b2bb" class="lb lc iq bd ld le mz lg lh li na lk ll lm nb lo lp lq nc ls lt lu nd lw lx ly bi translated">资源</h1><ul class=""><li id="55e2" class="lz ma iq ke b kf mb kj mc md me mf mg mh mi kz mj mk ml mm bi translated"><a class="ae la" href="https://youtu.be/SUiWfhAhgQw" rel="noopener ugc nofollow" target="_blank">垂直切片架构——吉米·博加德</a></li><li id="ebaf" class="lz ma iq ke b kf mn kj mo md mp mf mq mh mr kz mj mk ml mm bi translated"><a class="ae la" href="https://youtu.be/Zygw4UAxCdg" rel="noopener ugc nofollow" target="_blank">采用ASP.NET酷睿2.2的清洁架构—贾森·泰勒</a></li><li id="5013" class="lz ma iq ke b kf mn kj mo md mp mf mq mh mr kz mj mk ml mm bi translated"><a class="ae la" href="https://youtu.be/DngAZyWMGR0" rel="noopener ugc nofollow" target="_blank">让建筑变得重要——马丁·福勒</a></li><li id="a5cd" class="lz ma iq ke b kf mn kj mo md mp mf mq mh mr kz mj mk ml mm bi translated"><a class="ae la" href="https://youtu.be/2JzQuIvxIqk" rel="noopener ugc nofollow" target="_blank">使用MediatR的管道行为和FluentValidation | Clean进行验证。网络核心——尼克·查普萨斯</a></li><li id="dc85" class="lz ma iq ke b kf mn kj mo md mp mf mq mh mr kz mj mk ml mm bi translated"><a class="ae la" href="https://youtu.be/YzOBrVlthMk" rel="noopener ugc nofollow" target="_blank">使用联发科和CQRS清理ASP.NET核心API尼克·查普萨斯</a></li><li id="17a4" class="lz ma iq ke b kf mn kj mo md mp mf mq mh mr kz mj mk ml mm bi translated"><a class="ae la" href="https://lostechies.com/jimmybogard/2015/05/05/cqrs-with-mediatr-and-automapper/" rel="noopener ugc nofollow" target="_blank">拥有MediatR和AutoMapper的CQRS</a></li><li id="2b83" class="lz ma iq ke b kf mn kj mo md mp mf mq mh mr kz mj mk ml mm bi translated"><a class="ae la" href="https://medium.com/@ducmeit/net-core-using-cqrs-pattern-with-mediatr-part-1-55557e90931b" rel="noopener">使用CQRS模式与mediator Part 1—Duc Ho</a></li><li id="714f" class="lz ma iq ke b kf mn kj mo md mp mf mq mh mr kz mj mk ml mm bi translated"><a class="ae la" href="https://medium.com/@ducmeit/net-core-using-cqrs-pattern-with-mediatr-part-2-cc55763e83f0" rel="noopener">使用CQRS模式和MediatR第2部分— Duc Ho </a></li></ul></div></div>    
</body>
</html>