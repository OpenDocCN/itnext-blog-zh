<html>
<head>
<title>Modularize Xcode Project using local Swift Packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用本地Swift包模块化Xcode项目</h1>
<blockquote>原文：<a href="https://itnext.io/modularize-xcode-projects-using-local-swift-packages-8fd844c19081?source=collection_archive---------0-----------------------#2021-04-12">https://itnext.io/modularize-xcode-projects-using-local-swift-packages-8fd844c19081?source=collection_archive---------0-----------------------#2021-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0229" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Swift包管理器</em>……<em class="kl">SPM……</em>它无处不在，许多人都在使用它，它很可能是与Swift依赖项合作的未来。一个文件来获取所有可爱的开源包。随着社区接受度的提高，甚至会有更多的包在不安装任何工具的情况下可用，比如Cocoapods或Carthage。</p><p id="d2d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们如何进一步利用这种依赖结构呢？外部代码是使用包管理器的唯一原因吗？</p><p id="6fb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的代码库随着每一个新文件而增长。首先我们创建一个文件夹结构来组织我们的<em class="kl">。swift </em>文件，但然后即使是最轻微的代码也需要Xcode重新编译一切。我们的构建过程变得越来越慢。…<em class="kl">*在等待Xcode完成编译时，去喝咖啡* </em> …。…慢一点。</p><p id="b85c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用功能丰富的大型应用程序时，情况会更糟。它们变得笨拙，当你只想迭代你自己的新的、新鲜的特性时，你要花费大量时间等待重新构建未改变的部分。</p><p id="af05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">示例:<br/>一个功能丰富的收据跟踪应用程序，它连接到您的银行帐户进行匹配交易，使用云进行实时同步，与朋友共享帐户等。<br/>您想要添加扫描功能，该功能会拍摄照片并将其转换为您的应用程序使用的收据数据。</em></p><h1 id="43bf" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">SPM来救援了！</h1><p id="ddda" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Swift Package Manager允许我们创建小型、可重复使用的代码包。一方面，这允许在构建过程中隔离未更改的代码，另一方面，它让我们有机会简单地创建一个应用程序的衍生演示版本，仅使用必要的部分来改进单个功能。</p><p id="48ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">继续上面的例子:<br/>使用本地SPM包，您可以创建一个仅显示扫描特性的小型原型应用程序。功能完成后，就可以在主app中使用了。</em></p><p id="2222" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我简单介绍一下我们将如何构建自己的多平台<em class="kl">计算器</em>作为iOS应用和命令行工具(创建iOS应用的指南也适用于macOS):</p><ol class=""><li id="807b" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">创建starter SPM命令行工具</li><li id="b5cc" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">将逻辑代码移动到自己的SPM库中</li><li id="c852" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">使用库创建iOS项目</li><li id="4acd" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">创建更多的本地库来构建依赖图</li></ol><p id="bf58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对最终的解决方案更感兴趣，请查看GitHub库中的最终代码。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/ec1de1df34ca5146c246d4e8ebe74c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QsDafQARHFJKCrCbrb3GQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">提供相同功能的iOS应用程序和命令行可执行文件</figcaption></figure><h1 id="e875" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">创建SPM命令行工具</h1><p id="cc17" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">开始启动你选择的终端(对我来说是iTerm2)。然后创建一个名为<em class="kl"> Calculator </em>的新文件夹，然后将工作目录更改到该文件夹中:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="0356" class="mz kn iq mv b gy na nb l nc nd">$ mkdir Calculator<br/>$ cd Calculator</span></pre><p id="ae12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是初始化我们的Swift包。Swift命令行界面(CLI)允许我们创建多种类型的包。要找出是哪些，运行<code class="fe ne nf ng mv b">swift package init --help</code>获得一个列表:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="9fe0" class="mz kn iq mv b gy na nb l nc nd">$ swift package init --help<br/>OVERVIEW: Initialize a new package</span><span id="5f15" class="mz kn iq mv b gy nh nb l nc nd">OPTIONS:<br/>  --name   Provide custom package name<br/>  --type   empty|library|executable|system-module|manifest</span></pre><p id="2353" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们主要关注的是<code class="fe ne nf ng mv b">library</code>和<code class="fe ne nf ng mv b">executable</code>。如果您只是创建一个库包，运行<code class="fe ne nf ng mv b">swift package init --type library</code>，但是在我们的例子中，我们希望从一个可执行文件开始(前导<code class="fe ne nf ng mv b">$</code>意味着它是一个命令):</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="273b" class="mz kn iq mv b gy na nb l nc nd">$ swift package init --type executable<br/>Creating executable package: Calculator<br/>Creating Package.swift<br/>Creating README.md<br/>Creating .gitignore<br/>Creating Sources/<br/>Creating Sources/Calculator/main.swift<br/>Creating Tests/<br/>Creating Tests/LinuxMain.swift<br/>Creating Tests/CalculatorTests/<br/>Creating Tests/CalculatorTests/CalculatorTests.swift<br/>Creating Tests/CalculatorTests/XCTestManifests.swift</span></pre><p id="5a9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！您创建了第一个Swift包裹🔥</p><p id="6226" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的文件夹结构现在看起来如下:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="04c5" class="mz kn iq mv b gy na nb l nc nd">Calculator<br/>├── Package.swift<br/>├── README.md<br/>├── Sources<br/>│   └── Calculator<br/>│       └── main.swift<br/>└── Tests<br/>    ├── CalculatorTests<br/>    │   ├── CalculatorTests.swift<br/>    │   └── XCTestManifests.swift<br/>    └── LinuxMain.swift</span></pre><p id="2fd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要开始工作，只需打开/双击<code class="fe ne nf ng mv b">Package.swift</code>文件，Xcode会将其识别为一个包(-project)。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ni"><img src="../Images/86180956f688051c2702e1584ebca020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xugU0avpIyDDi7K01Xugag.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">双击Package.Swift文件可以直接在Xcode中打开swift包</figcaption></figure><p id="6311" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这篇博文不太像是关于在Swift中构建计算器的教程，我在评论中只提供了简单的实施步骤(如果你想要更详细的教程，请在<a class="ae md" href="http://twitter.com/philprimes" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上告诉我)。<br/>将以下代码放入您的<code class="fe ne nf ng mv b">main.swift</code>文件中:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="3a56" class="mz kn iq mv b gy na nb l nc nd">import Foundation<br/><br/>// CommandLine gives us access to the given CLI arguments<br/>let arguments = CommandLine.arguments<br/><br/>// We expect three parameters: first number, operator, second number<br/>func printUsage(message: String) {<br/>    let name = URL(string: CommandLine.arguments[0])!.lastPathComponent<br/>    print("usage: " + name + " number1 [+ | - | / | *] number2")<br/>    print("    " + message)<br/>}<br/><br/>// The first one is the binary name, so in total 4 arguments<br/>guard arguments.count == 4 else {<br/>    printUsage(message: "You need to provide two numbers and an operator")<br/>    exit(1);<br/>}<br/>// We expect the first parameter to be a number<br/>guard let number1 = Double(arguments[1]) else {<br/>    printUsage(message: arguments[1] + " is not a valid number")<br/>    exit(1);<br/>}<br/>// We expect the second parameter, to be one of our operators<br/>enum Operator: String {<br/>    case plus = "+"<br/>    case minus = "-"<br/>    case divide = "/"<br/>    case multiply = "*"<br/>}<br/>guard let op = Operator(rawValue: arguments[2]) else {<br/>    printUsage(message: arguments[2] + " is not a known operator")<br/>    exit(1);<br/>}<br/>// We expect the third parameter to also be a number<br/>guard let number2 = Double(arguments[3]) else {<br/>    printUsage(message: arguments[3] + " is not a valid number")<br/>    exit(1);<br/>}<br/>// Calculation function using our two numbers and the operator<br/>func calculate(number1: Double, op: Operator, number2: Double) -&gt; Double {<br/>    switch op {<br/>    case .plus:<br/>        return number1 + number2<br/>    case .minus:<br/>        return number1 - number2<br/>    case .divide:<br/>        return number1 / number2<br/>    case .multiply:<br/>        return number1 * number2<br/>    }<br/>}<br/>// Calculate the result<br/>let result = calculate(number1: number1, op: op, number2: number2)<br/>// Print result to output<br/>print("Result: \(result)")</span></pre><p id="c868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用新的计算器，回到终端，在包文件夹中，使用<code class="fe ne nf ng mv b">swift run</code>命令测试实现:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="253d" class="mz kn iq mv b gy na nb l nc nd">$ swift run Calculator 13 + 14<br/>Result: 27.0</span></pre><h1 id="fbb7" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">将逻辑代码移动到自己的SPM库中</h1><p id="451f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们启动并运行了两个应用程序中的第一个。在我们继续创建iOS应用程序之前，让我们回顾一下代码，弄清楚哪些部分应该由所有应用程序共享。</p><p id="9b5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码的两个部分是相关的:</p><ul class=""><li id="1c0c" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk nj lv lw lx bi translated"><code class="fe ne nf ng mv b">enum Operator</code>是我们的数学运算符集合</li><li id="b5f1" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nj lv lw lx bi translated"><code class="fe ne nf ng mv b">calculate</code>函数接受两个数字和一个运算符来执行实际的数学运算。</li></ul><p id="4df2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们从创建一个新库开始。首先，我们通过删除所有注释和未使用的参数来清理默认的<code class="fe ne nf ng mv b">Package.swift</code>清单文件:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="c574" class="mz kn iq mv b gy na nb l nc nd">// swift-tools-version:5.3<br/><br/>import PackageDescription<br/><br/>let package = Package(<br/>    name: "Calculator",<br/>    targets: [<br/>        .target(name: "Calculator"),<br/>        .testTarget(name: "CalculatorTests", <br/>                    dependencies: ["Calculator"]),<br/>    ]<br/>)</span></pre><p id="db07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在名为<code class="fe ne nf ng mv b">CalculatorCore</code>的<code class="fe ne nf ng mv b">Sources</code>文件夹中创建一个新文件夹，这是我们的共享应用程序核心逻辑。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/7206ac1d27f0e52ad509090f6758e983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*o9qXO3fb_4DjapYX4d3BJw.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">创建新库从创建同名文件夹开始</figcaption></figure><p id="3afe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个新创建的文件夹中，我们正在创建两个新的Swift文件:</p><p id="b0a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先创建文件<code class="fe ne nf ng mv b">Operator.swift</code>并将<code class="fe ne nf ng mv b">enum Operator {...}</code>声明移入其中:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="db82" class="mz kn iq mv b gy na nb l nc nd">enum Operator: String {<br/>    case plus = "+"<br/>    case minus = "-"<br/>    case divide = "/"<br/>    case multiply = "*"<br/>}</span></pre><p id="4648" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次创建另一个文件<code class="fe ne nf ng mv b">calculate.swift</code>并将<code class="fe ne nf ng mv b">calculate(...)</code>函数移入其中:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="a802" class="mz kn iq mv b gy na nb l nc nd">// Calculation function using our two numbers and the operator<br/>func calculate(number1: Double, op: Operator, number2: Double) -&gt; Double {<br/>    switch op {<br/>    case .plus:<br/>        return number1 + number2<br/>    case .minus:<br/>        return number1 - number2<br/>    case .divide:<br/>        return number1 / number2<br/>    case .multiply:<br/>        return number1 * number2<br/>    }<br/>}</span></pre><p id="26fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">移出代码后，您的main.swift文件现在应该如下所示:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="91fc" class="mz kn iq mv b gy na nb l nc nd">import Darwin<br/>import Foundation<br/><br/>// CommandLine gives us access to the given arguments<br/>let arguments = CommandLine.arguments<br/><br/>// We expect three parameters: first number, operator, second number<br/>func printUsage(message: String) {<br/>    let name = URL(string: CommandLine.arguments[0])!.lastPathComponent<br/>    print("usage: " + name + " number1 [+ | - | / | *] number2")<br/>    print("    " + message)<br/>}<br/><br/>// The first one is the binary name, so in total 4 arguments<br/>guard arguments.count == 4 else {<br/>    printUsage(message: "You need to provide two numbers and an operator")<br/>    exit(1);<br/>}<br/>// We expect the first parameter to be a number<br/>guard let number1 = Double(arguments[1]) else {<br/>    printUsage(message: arguments[1] + " is not a valid number")<br/>    exit(1);<br/>}<br/>// We expect the second parameter, to be one of our operators<br/>guard let op = Operator(rawValue: arguments[2]) else {<br/>    printUsage(message: arguments[2] + " is not a known operator")<br/>    exit(1);<br/>}<br/>// We expect the third parameter to also be a number<br/>guard let number2 = Double(arguments[3]) else {<br/>    printUsage(message: arguments[3] + " is not a valid number")<br/>    exit(1);<br/>}<br/>// Calculate the result<br/>let result = calculate(number1: number1, op: op, number2: number2)<br/>// Print result to output<br/>print("Result: \(result)")</span></pre><p id="3c8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您尝试再次运行您的应用程序，它会提示您一个错误，说它再也找不到<code class="fe ne nf ng mv b">Operator</code>或<code class="fe ne nf ng mv b">calculate</code>。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nl"><img src="../Images/096c070ee21e59c1950ab79818bed4b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMToyJ4sydp8QPqTB57lzw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">当将类移出该范围时，将会出现错误。</figcaption></figure><p id="2bfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是意料之中的，所以现在我们必须完成创建<code class="fe ne nf ng mv b">CalculatorCore</code>库，并将其作为依赖项添加到我们的<code class="fe ne nf ng mv b">Calculator</code>中。为此，我们只需要在我们的<code class="fe ne nf ng mv b">Package.swift</code>中声明库:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="46ad" class="mz kn iq mv b gy na nb l nc nd">// swift-tools-version:5.3<br/><br/>import PackageDescription<br/><br/>let package = Package(<br/>    name: "Calculator",<br/>    targets: [<br/>        .target(name: "CalculatorCore"),<br/>        .target(name: "Calculator",<br/>                dependencies: ["CalculatorCore"]),<br/>        .testTarget(name: "CalculatorTests",<br/>                    dependencies: ["Calculator"]),<br/>    ]<br/>)</span></pre><p id="cf88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您尝试再次运行该应用程序，您仍然会看到相同的错误。这种行为背后的原因是<code class="fe ne nf ng mv b">main.swift</code>中缺少<code class="fe ne nf ng mv b">import CalculatorCore</code>:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="4653" class="mz kn iq mv b gy na nb l nc nd">import Foundation<br/>import CalculatorCore<br/><br/>// CommandLine gives us access to the given arguments<br/>...</span></pre><p id="13ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，Swift包的隔离功能(在我看来很棒)要求我们将<code class="fe ne nf ng mv b">Operator</code>和<code class="fe ne nf ng mv b">calculate</code>都声明为<code class="fe ne nf ng mv b">public</code>，否则它们在包外不可用:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="dfcf" class="mz kn iq mv b gy na nb l nc nd">// in Operator.swift:<br/>public enum Operator { ... }<br/>// in calculate.swift:<br/>public func calculate(...) -&gt; Double { ... }</span></pre><p id="3ff8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe ne nf ng mv b">swift run</code>运行您的应用程序，它应该会再次工作。</p><h1 id="d82e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用库创建iOS项目</h1><p id="9eb1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">到目前为止干得不错！您已经创建了命令行可执行文件和SPM库。现在我们进一步扩展它，使用我们的SPM库计算逻辑创建一个iOS应用程序。</p><p id="b918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于本教程，我们将使用SwiftUI应用程序，因为它是iOS/macOS应用程序开发的未来，并允许我们以比使用传统UIKit更快的方式创建一个简单的计算器。</p><p id="8491" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开Xcode，点击<strong class="jp ir">文件/新建/项目</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nm"><img src="../Images/90f119f8575c287c7f8eeb0b66bd5b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgQVBgm1rpkY1CvaKZvJnQ.png"/></div></div></figure><p id="67f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在在<strong class="jp ir"> iOS </strong>选项卡中选择<strong class="jp ir"> App </strong>，命名为<em class="kl"> Calculator_iOS </em>，选择<strong class="jp ir"> SwiftUI </strong>进行所有设置。</p><div class="mf mg mh mi gt ab cb"><figure class="nn mj no np nq nr ns paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/a09dbaa05e0d4c9d61d2382517b18492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*SZ80RUJ1eVmRGNWEGZsf6g.png"/></div></figure><figure class="nn mj no np nq nr ns paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/41580856f056a5e8823c54d7e4dcba36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*rMQo7AnH7mun2TpEEGhQ0g.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk nt di nu nv translated">创建一个iOS应用程序项目只需要几个简单的步骤</figcaption></figure></div><p id="898b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保将项目放在您的主<code class="fe ne nf ng mv b">Calculator</code>文件夹中，您应该得到以下文件结构:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nw"><img src="../Images/ba9b0ad72e2a0497e62987bd62e5425a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YYbFW5pfYMjXEhUggQJQjg.png"/></div></div></figure><p id="bf29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们不需要嵌套的iOS文件夹，所以关闭Xcode项目并将内容上移一层。此外，我们将包移动到它自己的子文件夹<code class="fe ne nf ng mv b">Calculator</code>中，所以之后你的文件夹结构应该是这样的:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nx"><img src="../Images/17f970008da958c5c74b9b05a255ec1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*494sNrWRU6eiA6w9LpAgFw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">所有的iOS应用代码都在Calculator_iOS里面</figcaption></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ny"><img src="../Images/fe0a3987ef390c09f0c307a81b1ccc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlVGrWerJIhg4_sqKFBpfQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">所有的包代码都在CalculatorPackage里面</figcaption></figure><p id="39ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在打开<code class="fe ne nf ng mv b">Calculator_iOS.xcodeproj</code>，选择你选择的模拟器，运行初始应用程序，确保一切正常。</p><p id="a042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步，我们继续使用两个文本字段和一个操作符选择来创建计算器UI。用以下代码替换<code class="fe ne nf ng mv b">ContentView.swift</code>中的<code class="fe ne nf ng mv b">struct ContentView {...}</code>,并再次运行应用程序:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="6c68" class="mz kn iq mv b gy na nb l nc nd">struct ContentView: View {<br/><br/>    @State var number1 = ""<br/>    @State var op = "+"<br/>    @State var number2 = ""<br/><br/>    var body: some View {<br/>        VStack {<br/>            TextField("Number 1", text: $number1)<br/>                .keyboardType(.numberPad)<br/>                .padding(10)<br/>                .cornerRadius(5)<br/>            Picker("Operator", selection: $op) {<br/>                ForEach(["+", "-", "*", "/"], id: \.self) { op in<br/>                    Text(op)<br/>                }<br/>            }<br/>            .pickerStyle(SegmentedPickerStyle())<br/>            TextField("Number 2", text: $number2)<br/>                .keyboardType(.numberPad)<br/>                .padding(10)<br/>                .cornerRadius(5)<br/>            Divider()<br/>            Text("Result: " + result)<br/>                .padding(10)<br/>        }<br/>        .padding(20)<br/>    }<br/><br/>    var result: String {<br/>        return "?"<br/>    }<br/>}</span></pre><p id="9cf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您可以输入数字并选择一个运算符时，您的基本计算器就完成了:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nz"><img src="../Images/b778e4ced27b6aa886bb46fb668106ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbM59puvQX8c1zrrEO3pyg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我们的首款计算器iOS应用UI</figcaption></figure><p id="04d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是添加我们的本地Swift包作为iOS应用程序依赖项。这一步没有被很好地记录或了解，但是非常简单。你所要做的就是将文件夹<code class="fe ne nf ng mv b">CalculatorPackage</code>拖到最顶端的<code class="fe ne nf ng mv b">Calculator_iOS</code>文件浏览器中:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oa"><img src="../Images/bab0327768ce441967ee82259e24e83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QllJVakcvj8vHsZ00c0Bgg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">Xcode会自动将文件夹检测为Swift包</figcaption></figure><p id="e0d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后Xcode会将该文件夹检测为本地包:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ob"><img src="../Images/5543502b55cecf3178cdf0f9e57ada53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0MqwG8R4DjtVUX8dO_-6w.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">Swift包裹参考显示为文件夹参考</figcaption></figure><p id="86e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们真正将我们的库添加到iOS项目之前，我们需要将它声明为<code class="fe ne nf ng mv b">Package.swift</code>中的一个产品。由于库产品可以将多个目标捆绑在一起，我们需要添加<code class="fe ne nf ng mv b">CalculatorCore</code>作为<code class="fe ne nf ng mv b">targets</code>参数。</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="d3b5" class="mz kn iq mv b gy na nb l nc nd">let package = Package(<br/>    name: "Calculator",<br/>    products: [<br/>        .library(name: "CalculatorCore", <br/>                 targets: ["CalculatorCore"])<br/>    ],<br/>    targets: [<br/>        .target(name: "CalculatorCore"),<br/>        .target(name: "Calculator",<br/>                dependencies: ["CalculatorCore"]),<br/>        .testTarget(name: "CalculatorTests",<br/>                    dependencies: ["Calculator"]),<br/>    ]<br/>)</span></pre><p id="30d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步，您必须将<code class="fe ne nf ng mv b">CalculatorCore</code>库作为一个依赖项添加到iOS应用目标，方法是在<strong class="jp ir">框架、库和嵌入内容</strong>部分的目标设置中点击<strong class="jp ir">加号+ </strong>，并在列表中选择它:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oc"><img src="../Images/56d1d1c0a2aa17dbb60fdd21becc885e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l-urfbY7yxBqr0BiJYjRUQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">在依赖关系管理列表中添加包</figcaption></figure><p id="8e9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是了。您的本地Swift包现已在您的iOS应用程序中提供🎉</p><p id="4b22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe ne nf ng mv b">ContentView.swift</code>中，我们可以将<code class="fe ne nf ng mv b">import CalculatorCore</code>添加到文件的顶部，我们可以再次在计算属性<code class="fe ne nf ng mv b">result</code>中使用<code class="fe ne nf ng mv b">Operator</code>和<code class="fe ne nf ng mv b">calculate</code>函数:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="6db0" class="mz kn iq mv b gy na nb l nc nd">var result: String {<br/>    guard let num1 = Double(number1) else {<br/>        return number1 + " is not a valid number"<br/>    }<br/>    guard let num2 = Double(number2) else {<br/>       return number2 + " is not a valid number"<br/>    }<br/>    // Force unwrap the operator for now,<br/>    // as we can be sure that we only added known ones<br/>    let op = Operator(rawValue: self.op)!<br/>    let result = calculate(number1: num1, op: op, number2: num2)<br/>    return result.description<br/>}</span></pre><p id="c199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次运行该应用程序，您就可以在iOS中使用计算器了:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nz"><img src="../Images/2f291c6b7b91041f36d2545dde95bedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s49Mt9Ktwzl9-ss3Nz21WQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我们的iOS计算器正在工作并计算正确的值</figcaption></figure><h2 id="6d8c" class="mz kn iq bd ko od oe dn ks of og dp kw jy oh oi la kc oj ok le kg ol om li on bi translated">是时候清理一下了</h2><p id="3cef" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们的共享代码库现在已经准备好增长，但是我们希望保持对我们个人应用程序的维护在控制之下。</p><p id="c52a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，您的程序中有两行非常难看的代码:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="2fea" class="mz kn iq mv b gy na nb l nc nd">// main.swift, Line 10:<br/>print("usage: " + name + " number1 [+ | - | / | *] number2")</span><span id="1b6b" class="mz kn iq mv b gy nh nb l nc nd">// ContentView.swift, Line 24:<br/>ForEach(["+", "-", "*", "/"], id: \.self) { op in ... </span></pre><p id="bab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两行都手工列出了我们已经实现的操作符，如果我们向<code class="fe ne nf ng mv b">enum Operator</code>添加另一个操作符，它们将不会被更新。更糟糕的是，我们可能会忘记将它添加到我们的应用程序中。</p><p id="63a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过将<code class="fe ne nf ng mv b">CaseIterable</code>协议添加到<code class="fe ne nf ng mv b">Operator</code>枚举来解决这个问题，这给了我们<code class="fe ne nf ng mv b">Operator.allCases</code>，一个包含所有可用操作符的合成数组。</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="5615" class="mz kn iq mv b gy na nb l nc nd">public enum Operator: String, CaseIterable {<br/>    case plus = "+"<br/>    case minus = "-"<br/>    case divide = "/"<br/>    case multiply = "*"<br/>}</span></pre><p id="f3ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe ne nf ng mv b">ContentView.swift</code>内将<code class="fe ne nf ng mv b">ForEach</code>改为使用<code class="fe ne nf ng mv b">.allCases</code>:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="d639" class="mz kn iq mv b gy na nb l nc nd">ForEach(Operator.allCases, id: \.self) { op in<br/>    Text(op.rawValue)<br/>}</span></pre><p id="6ec2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当<code class="fe ne nf ng mv b">Picker</code>中的<code class="fe ne nf ng mv b">ForEach</code>将操作符作为标签添加到<code class="fe ne nf ng mv b">Text</code>对象时，我们现在也必须更改选择属性:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="7269" class="mz kn iq mv b gy na nb l nc nd">...<br/>@State var op: Operator = .plus<br/>...</span></pre><p id="deda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样也可以摆脱里面的强行解开<code class="fe ne nf ng mv b">var result: String {..}</code></p><p id="3519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的CLI应用程序的<code class="fe ne nf ng mv b">main.swift</code>中，您现在可以在<code class="fe ne nf ng mv b">printUsage</code>函数中动态创建操作符列表:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="0040" class="mz kn iq mv b gy na nb l nc nd">func printUsage(message: String) {<br/>    let name = URL(string: CommandLine.arguments[0])!<br/>        .lastPathComponent<br/>    let operators = Operator.allCases<br/>        .map(\.rawValue)<br/>        .joined(separator: " | ")<br/>    print("usage: \(name) number1 [\(operators)] number2")<br/>    print("    " + message)<br/>}</span></pre><p id="05d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，你想再加一个操作员吗？不用担心，只需通过另一个案例扩展<code class="fe ne nf ng mv b">enum Operator</code>并在<code class="fe ne nf ng mv b">calculate()</code>函数中实现它🎉</p><h1 id="32cc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">创建更多的本地库来构建依赖图</h1><p id="f6b1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在这一步中，我们想给我们的<code class="fe ne nf ng mv b">CalculatorCore</code>添加一个调试记录器。我们可以只使用<code class="fe ne nf ng mv b">print()</code>方法，但那样就没那么有趣了，对吧？😄</p><p id="8e39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建更多的本地包非常简单。像以前一样，在<strong class="jp ir">源</strong>中创建一个文件夹，并以包名命名。在这种情况下，它将是<code class="fe ne nf ng mv b">CalculatorLogger</code>，并且包含一个单独的<code class="fe ne nf ng mv b">Logger.swift</code>文件:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="4803" class="mz kn iq mv b gy na nb l nc nd">public class Logger {<br/><br/>    public static func warn(_ message: String) {<br/>        print("⚠️ " + message)<br/>    }<br/><br/>    public static func debug(_ message: String) {<br/>        print("🔍 " + message)<br/>    }<br/>}</span></pre><p id="8f2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在包清单中创建一个新的目标，并将其作为依赖项添加到<code class="fe ne nf ng mv b">CalculatorCore</code>包中</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="1ca1" class="mz kn iq mv b gy na nb l nc nd">targets: [<br/>    .target(name: "CalculatorCore", dependencies: [<br/>       "CalculatorLogger"<br/>    ]),<br/>    .target(name: "CalculatorLogger"),<br/>    ...<br/>]</span></pre><p id="0148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其导入我们的<code class="fe ne nf ng mv b">calculate.swift</code>文件:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="9568" class="mz kn iq mv b gy na nb l nc nd">import CalculatorLogger<br/><br/>// Calculation function using our two numbers and the operator<br/>public func calculate(number1: Double, op: Operator, number2: Double) -&gt; Double {<br/>    Logger.debug("Now calculating \(number1) with \(number2) using \(op)")<br/>    ...<br/>}</span></pre><p id="7817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当在<code class="fe ne nf ng mv b">CalculatorPackage</code>目录中运行<code class="fe ne nf ng mv b">swift run</code>时，它给出以下输出:</p><pre class="mf mg mh mi gt mu mv mw mx aw my bi"><span id="aa51" class="mz kn iq mv b gy na nb l nc nd">$ swift run Calculator 13 + 14<br/>[3/3] Linking Calculator<br/>🔍 Now calculating 13.0 with 14.0 using plus<br/>Result: 27.0</span></pre><h1 id="43c2" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">更多即将推出！</h1><p id="d1b3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">基本上就是这样。如果您一直这样做，那么您现在已经使用相同的核心逻辑创建了一个多平台应用程序🚀<br/>总结一下为什么这很有用:</p><ul class=""><li id="f4f0" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk nj lv lw lx bi translated">如果我们改变我们的应用程序，包将不会被重新构建，这给了我们更快的构建时间。</li><li id="198f" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nj lv lw lx bi translated">我们可以处理包本身，尤其是在向它们添加单元测试时，而无需运行完整的应用程序。</li><li id="6640" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nj lv lw lx bi translated">包的隔离使用可见性来保持我们代码的干净(例如<code class="fe ne nf ng mv b">public</code>对<code class="fe ne nf ng mv b">internal</code>)</li><li id="ba7c" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nj lv lw lx bi translated">本文中我们还没有探索的是并行编译。<br/>想象你正在使用更多的包作为我们<code class="fe ne nf ng mv b">CalculatorCore</code>包的依赖，类似于<code class="fe ne nf ng mv b">CalculatorLogger</code>包。由于它们互不依赖，它们可以并行构建，这给了我们更快的构建时间！</li></ul><p id="ebf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在撰写本文时，我意识到不可能涵盖更高级的功能，例如每个平台的UI模块使用接口以<a class="ae md" href="https://www.objc.io/issues/13-architecture/viper/" rel="noopener ugc nofollow" target="_blank"> VIPER模式</a>进行通信(这是我目前在一个大规模iOS/macOS跨平台应用程序中使用的)。<br/>因此，我将在以后的文章中讨论高级主题，例如SPM如何使用自己包中的XIB文件帮助您从UIKit/AppKit过渡到SwiftUI(请确保关注我以获得通知！).</p><p id="d060" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新19.04.2021: </strong>我刚发表了<a class="ae md" href="https://philprime.medium.com/advanced-cross-platform-apps-using-local-swift-packages-and-uikit-appkit-2a478e8b05cd" rel="noopener">后续文章</a>！</p><p id="aff4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想了解更多，请查看我的其他文章，在<a class="ae md" href="https://twitter.com/philprimes" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，并随时给我发短信。你有具体的话题想让我介绍吗？让我知道！😃</p><p id="2da2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">编辑13.04.2021: <br/> </strong> <em class="kl">新增大型项目分拆app示例</em></p></div></div>    
</body>
</html>