<html>
<head>
<title>Kubernetes in production @ ShopGun</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产中的kubernetes @ shop gun</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-in-production-shopgun-2c280f0c0923?source=collection_archive---------2-----------------------#2018-12-19">https://itnext.io/kubernetes-in-production-shopgun-2c280f0c0923?source=collection_archive---------2-----------------------#2018-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="da78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">—建造、装箱、运输</p><blockquote class="kl km kn"><p id="f244" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">与旧的基于CodeDeploy的设置相比，通过访问Kubernetes，我们将运行实例的数量减少了大约50%,并将每月EC2运行成本降低了40%</p></blockquote><p id="c5b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我开始在我现在的雇主<a class="ae ks" href="https://shopgun.com/about" rel="noopener ugc nofollow" target="_blank"> ShopGun </a>工作时，我的目的是将当前的AWS平台集装箱化，并将所有东西都转移到Kubernetes</p><p id="dc2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你这么说听起来很简单，不是吗？😃</p><p id="cc1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过大约9个月的紧张工作，最后一个软件项目被转移到我们的生产Kubernetes集群。为devops团队树立里程碑</p><p id="8404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不仅大幅降低了EC2的运营成本。我们在收购我们在挪威最大的竞争对手<a class="ae ks" href="https://mattilbud.com" rel="noopener ugc nofollow" target="_blank"> Mattilbud </a>时做到了这一点，将他们的整个基础设施纳入我们的羽翼之下，大大增加了整个平台的用户群</p><h1 id="1804" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">背景</h1><p id="2cda" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">当我开始的时候，平台的大部分都配备了terraform或云形成代码，为每个项目和环境创建一个实例。总共大约70个不同的实例和一堆ELB，大约三分之一是暂存环境</p><p id="9424" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个Jenkins实例构建代码，我们主要使用CodeDeploy将项目发布到实例中</p><p id="be6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个坚实的，但不是很划算的设置</p><p id="f164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我要处理的是大约20个不同形状、大小和形式的软件项目，每个环境都运行在一个EC2实例上。<br/>大部分都是用Erlang、Python、Nodejs、PHP或者Go写的</p><p id="01f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有的都必须放进容器里</p><h1 id="af89" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">新管道诞生</strong></h1><blockquote class="kl km kn"><p id="4252" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">手头有一个用Erlang编写的hello-world项目，我在一个周五的傍晚开始了我的探索之旅。它在周六早上的某个时候结束了，基础已经奠定，我现在拥有了继续前进所需的一切</p></blockquote><p id="d6f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要克服的早期障碍之一是我们如何在新的堆栈中构建我们的软件</p><p id="973e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">詹金斯是詹金斯，它偶尔会放弃，需要一脚踢。有些项目需要相当奇怪和笨拙的部署脚本才能在AWS上按预期工作。人们渴望更容易交互、更透明、最重要的是更精简的东西</p><p id="d7d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过一些测试和观察，我决定用CodePipeline、code build &amp; Elastic Container Registry来创建我的Docker图像</p><p id="7967" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我用Python编写了自己的lambda函数，它作为每个项目代码管道中的一个步骤触发，将代码部署到不同的Kubernetes集群</p><p id="6d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">清单在Github repo中存储为Jinja2模板化的Kubernetes YAML资源</p><p id="1da0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">pod的运行时配置主要是通过环境变量来完成的，并且作为秘密存储在Kubernetes中，在创建pod时使用</p><p id="45b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，从概念的角度来看，这就是它看起来的样子</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/2e43d85a377aa7c600f8881c40659028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fQz6iThJzfYHGqbn"/></div></div></figure><ul class=""><li id="c608" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">开发人员向Github提交代码</li><li id="ae02" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">CodePipeline获取代码并将其发送给CodeBuild</li><li id="8f00" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">CodeBuild构建docker文件并将其推送到ECR</li><li id="2c05" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">CodePipeline触发构建的docker映像的部署</li><li id="0420" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">部署者从安全存储中创建k8s中的秘密</li><li id="3578" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">部署人员呈现Github repo提供的YAML文件，并创建任何已定义的资源，如部署、有状态集、服务、入口规则等</li></ul><p id="30a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的所有步骤都会在我们的工程频道上发布反馈，同时还提供了一个小的一行程序，开发人员可以在世界上任何地方的终端上实时跟踪构建输出</p><p id="9e63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦管道运行，我们有一些Docker图像建设项目可以继续进行</p><h1 id="317f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">建立Kubernetes集群</h1><p id="56fd" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">手动配置Kubernetes集群可能会非常痛苦，因为有很多按钮和旋钮可以转动，也有很多地方可能会出错</p><blockquote class="kl km kn"><p id="977d" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">您实际上需要一个在后端完全运行的ETCD集群，大多数集群安装程序很少或根本没有注意到如何操作或在出现问题时如何恢复</p></blockquote><p id="a583" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我以前在裸机上配置过Kubernetes集群，这里有一些例子<a class="ae ks" href="https://github.com/roffe/eznetes" rel="noopener ugc nofollow" target="_blank">关于如何用CoreOS实现这一点</a>(<em class="ko">警告内容现在相当旧，没有维护</em></p><p id="7a6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我在云中工作，为了我自己和任何将要使用这个堆栈的人，我需要找到一个更好的方法来做这件事</p><p id="caee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始时，考虑了一系列工具和方法:</p><ul class=""><li id="f221" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">kubeadm</li><li id="3c5a" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><a class="ae ks" href="https://github.com/kubernetes/kops" rel="noopener ugc nofollow" target="_blank"> kops </a></li><li id="9b7a" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><a class="ae ks" href="https://github.com/kubernetes-incubator/kube-aws" rel="noopener ugc nofollow" target="_blank"> kube-aws </a></li><li id="a652" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><a class="ae ks" href="https://github.com/kubernetes-sigs/kubespray" rel="noopener ugc nofollow" target="_blank"> kubespray </a></li><li id="87c6" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><a class="ae ks" href="https://github.com/zalando-incubator/kubernetes-on-aws" rel="noopener ugc nofollow" target="_blank"> Zalando的kuberentes-on-aws </a></li></ul><p id="265f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终它落在了kops上，因为当时它看起来像是一个维护良好的项目，并且我用它做的测试产生了良好的结果。它还提供了terraform输出，可以很容易地在Github中进行检查</p><p id="7aeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于网络CNI <a class="ae ks" href="https://www.kube-router.io/" rel="noopener ugc nofollow" target="_blank">来说，kube-router </a>被使用，因为我在为它写了大部分的<a class="ae ks" href="https://github.com/cloudnativelabs/kube-router/blob/master/docs/metrics.md" rel="noopener ugc nofollow" target="_blank">指标</a>之后成为了它的维护者之一。我也认为养狗是一种美德。</p><h1 id="8952" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">管道反击了</h1><ul class=""><li id="f74b" class="mi mj iq jp b jq lr ju ls jy mw kc mx kg my kk mn mo mp mq bi translated">快速地为每个构建一遍又一遍地做同样的事情变得令人厌倦，而且浪费时间。为运行时和构建构建一组基本映像，您可以在多阶段Docker构建中使用这些映像来加速构建</li><li id="f31f" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">注意你的形象。映像越大，部署所需的时间就越长。如果你要制作<a class="ae ks" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank"> Dockerfiles </a>一定要在添加图层之前完全理解它们是如何工作的，不要考虑最终结果。否则，你的微型服务可能最终只有一个完整安装的操作系统那么大。</li><li id="7eac" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">将git commit ref添加到docker图像标签中，这样可以非常容易地找到它们是由什么代码构建的</li><li id="5b1e" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">将使用的公共图像镜像到您的ECR帐户或创建本地图像缓存。Docker hub在历史上曾多次停机，您不希望由于新节点无法下载您正在使用的公共映像而导致集群停机</li></ul><h1 id="7cdb" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">反向代理的返回(入口)</h1><p id="da23" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Kubernetes集群的一个常见问题是如何让外界的流量进入集群。在云上，与裸机相比，这非常方便，但如果要分解幕后发生的事情，这仍然不是一项简单的任务</p><p id="f6aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的设置中，流量在外部边缘由一组ALB终止，这些ALB也处理HTTPS终止。</p><p id="1d76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些又有Skipper作为后端。Skipper监听我们集群中一组节点上的特定端口，并将充当反向代理，将流量进一步路由到集群中，并提供影子流量、速率限制、断路器、报头重写等功能</p><p id="9019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我测试了多种解决方案，包括(无特定顺序):</p><ul class=""><li id="344b" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">Nginx入口控制器(均为<a class="ae ks" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank">贡献</a> &amp; <a class="ae ks" href="https://github.com/nginxinc/kubernetes-ingress" rel="noopener ugc nofollow" target="_blank">官方NGINX one </a>)</li><li id="6032" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><a class="ae ks" href="https://github.com/jcmoraisjr/haproxy-ingress" rel="noopener ugc nofollow" target="_blank"> haproxy入口控制器</a></li><li id="cd2c" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><a class="ae ks" href="https://github.com/kubernetes-sigs/aws-alb-ingress-controller" rel="noopener ugc nofollow" target="_blank">ALB-入口控制器</a></li><li id="2dbe" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><a class="ae ks" href="https://traefik.io/" rel="noopener ugc nofollow" target="_blank"> traefik </a></li><li id="16eb" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">Zalando的skipper Ingres ss+kube-ingress-AWS-控制器</li></ul><p id="d8a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Nginx控制器在裸机时间为我提供了很好的服务，但有一些缺陷，需要我在它前面设置所有的网络+控制器归结为编写Nginx配置文件并在更改时重新加载这些文件</p><p id="70ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种可能以或多或少的恒定速率发生的情况下，这不是很理想。我觉得我们需要更适合这个目的的东西</p><p id="00c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在CoreOS/Ticketmaster的alb-ingress控制器上取得了一些成功，它允许用户自动为ingress资源提供alb。</p><p id="38aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ks" href="https://github.com/zalando/skipper/" rel="noopener ugc nofollow" target="_blank">来自Zalando的Skipper </a>在我的测试中表现非常好，并与<a class="ae ks" href="https://github.com/zalando-incubator/kube-ingress-aws-controller" rel="noopener ugc nofollow" target="_blank">kube-ingress-AWS-controller</a>配合使用，从外部通过ingress无缝访问我的服务。如果设置正确，该设置还会自动处理HTTPS证书从AWS ACM到新提供的ALB的映射。</p><blockquote class="kl km kn"><p id="3160" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">Skipper是一个HTTP路由器和服务组合的反向代理。它旨在处理超过300k的HTTP路由定义和详细的查找条件，并通过过滤器灵活地扩充请求流。它可以开箱即用，也可以通过自定义查找、过滤逻辑和配置源进行扩展。</p></blockquote><p id="f3eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它有一个非常丰富的功能集,如果发现任何错误，开发者总是能快速做出反应🙏(大声呼喊sszuecs，感谢他们在我有问题的时候出现)</p><h1 id="8e9f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">存储威胁</h1><p id="e6bf" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">AWS中的存储简单、可靠，EBS &amp; EFS有很多选项。如果这些不能满足您的需要，还有对各种文件系统的支持。GlusterFS &amp; Ceph就是其中之一</p><p id="0531" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">EFS位于NFS。我不打算长篇大论地解释为什么，但我通常倾向于避免这种存储，除非特定的用例可以使用它</p><p id="f5bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">EBS是连接到本地实例的块存储。在大多数情况下，它非常适合任何需要持久存储的东西，但是它有一个缺点。EBS卷绑定到创建它们的AZ</p><p id="2be4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AWS上一个典型的高可用性Kubernetes集群将跨越一个区域中的多个可用性区域，以便能够在其中一个区域发生故障时存活下来</p><p id="c545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有需要持久存储的单片系统，并且它们可以在NFS文件系统上工作。EFS在这里是完美的，它允许应用程序在Kubernetes集群中的任何AZ上运行。</p><p id="d96c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">efs-provisioner 是一个可以在Kubernetes集群中运行的服务，允许在pods中提供和使用efs支持的文件系统</p><p id="0f53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个EFS文件系统，你的IO信用是不同的，默认情况下，你只有一个特定的预算，根据文件系统的使用情况，你可能会得到<a class="ae ks" href="https://docs.aws.amazon.com/efs/latest/ug/performance.html" rel="noopener ugc nofollow" target="_blank">节流</a></p><p id="fa89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让EBS卷在Kubernetes中可靠地工作，我建议从一开始就将您的计算节点分成绑定到特定AZ的实例组，并且每个AZ中至少有1个节点。</p><p id="b45e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有跨IG/ASG的多AZ，风险在于当一个新节点开始运行以覆盖一个出现故障的旧节点时，它可能会出现在错误的AZ中，现在您的pod无法启动，因为它的永久存储不可用</p><h1 id="fa4c" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">IAM凭证攻击</h1><p id="23af" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">后来出现的一个问题是IAM的证书。在旧的堆栈中，每个实例都有自己的权限集，但是现在有了Kubernetes，几个具有不同权限要求的软件必须在同一个节点上运行</p><p id="6ddb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给计算节点分配广泛的权限似乎不是最佳解决方案。在挖了一些之后，我找到了kube2iam</p><p id="b362" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我测试了kube2iam，但它有几个竞争条件，iam凭证在pod start上不可用，这迫使我在有长睡眠的容器中使用奇怪的init脚本。不太符合Kubernetes pod生命周期管理</p><p id="95ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我找到了<a class="ae ks" href="https://github.com/uswitch/kiam" rel="noopener ugc nofollow" target="_blank"> KIAM </a>,加上一些我在部署时注入的<a class="ae ks" href="https://github.com/uswitch/kiam/issues/47#issuecomment-413876312" rel="noopener ugc nofollow" target="_blank"> ENV变量</a>,到目前为止它工作得很好</p><p id="9a8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我甚至最终为这个项目制作了一个<a class="ae ks" href="https://github.com/uswitch/kiam/blob/master/docs/METRICS.md" rel="noopener ugc nofollow" target="_blank"> Grafana仪表盘</a></p><h1 id="96f2" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">api访问的复仇</h1><p id="ad21" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">整个基础设施建立在一个私有的VPC上，通过ssh端口转发访问Kubernetes的api相当笨拙，这需要维护和凭证</p><p id="dd59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">kubectl 是上帝赐予的礼物，我希望我们的开发人员能够充分享受它，在集群中与他们的服务进行交互</p><p id="abe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避开跳转主机ssh-tunnel历史，我创建了一个lambda函数，它也作为CloudWatch触发的cronjob来执行清理。它的主要功能是由开发人员调用，将连接到LB的SG中的IP列入白名单，使他们能够与各自的集群api服务器对话</p><h1 id="fbbd" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">开发者觉醒了</h1><p id="a52c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">随着管道和集群的运行，开发人员开始了解并需要与新的世界秩序对接</p><p id="c50d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一开始，令牌是分发出去的，但它需要每个用户一个秘密的配置文件，以及用私有ssh密钥保护的笨重的反向ssh隧道。</p><p id="d7b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了lambda函数，现在每个用户只有一个令牌</p><h1 id="71d3" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">最后一个访问令牌</h1><p id="4458" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><a class="ae ks" href="http://aws-iam-authenticator" rel="noopener ugc nofollow" target="_blank"> aws-iam-authenticator </a>允许您的用户仅使用他们的aws凭证针对您的集群进行身份验证</p><p id="ecf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是缺失的拼图。现在，我们的开发人员需要访问我们的Kubernetes集群:</p><ul class=""><li id="0b2b" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">aws cli工具(pip安装)</li><li id="7997" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">非机密kubectl配置文件(在内部文档中可用)</li><li id="941c" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">一个bash登录脚本，调用白名单lambda(每个人都应该下载的工具包的一部分)</li><li id="99eb" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">认证器软件(一行安装程序)</li><li id="6183" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">AWS凭证(发给每个开发人员，以便他们可以使用系统)</li><li id="ea6e" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">kubectl二进制</li></ul><p id="6904" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个，他们现在可以调试和监控他们的项目，就像他们可以直接访问旧设置中的实例一样</p><p id="3591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">软件构建、测试、部署和运行集成测试只需要git提交</p><p id="ba58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的Erlang开发人员可以在世界任何地方，通过几个按键，安全地将一个实时远程控制台直接放入他们的应用程序中</p><h1 id="bb38" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一些问题</h1><p id="49ae" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">请务必仔细阅读<a class="ae ks" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">dock file</a>和layers如何工作。在结构合理的图像上，您可以节省数百兆字节，有时甚至是数十亿字节</p><p id="9f86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为DNS做好计划！这是Kubernetes的失踪儿童，已经在雷达下飞行了相当一段时间。要深入了解这个问题，请前往</p><blockquote class="kl km kn"><p id="8cdd" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><a class="ae ks" href="https://pracucci.com/kubernetes-dns-resolution-ndots-options-and-why-it-may-affect-application-performances.html" rel="noopener ugc nofollow" target="_blank">Kubernetes pods/etc/resolv . conf ndots:5选项以及为什么它会对您的应用程序性能产生负面影响</a></p></blockquote><p id="df4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes官方对此的处理方式似乎是<a class="ae ks" href="https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/dns/nodelocaldns/README.md" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/master/cluster/addons/DNS/nodelocaldns/readme . MD</a></p><p id="1353" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Zalando有一个他们如何做的例子<a class="ae ks" href="https://github.com/zalando-incubator/kubernetes-on-aws/blob/dev/cluster/manifests/kube-dns/node-local-daemonset.yaml" rel="noopener ugc nofollow" target="_blank">在这里</a></p><p id="6795" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解内存和cpu在容器中是如何工作的。Docker使用CGROUPS来限制容器的资源。这意味着当内存限制在200mb时，您的容器可能会看到所有节点都利用了内存，并且当内存超过分配给它的200mb时，不会看到终止</p><p id="ca24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些关于容器和java内存处理的好读物可以在@ <a class="ae ks" href="https://developers.redhat.com/blog/2017/03/14/java-inside-docker/" rel="noopener ugc nofollow" target="_blank"> Java inside docker:你必须知道的不会失败的事情</a>中找到</p><p id="8d03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">养成在容器中使用轻量级初始化系统的习惯，比如<a class="ae ks" href="https://github.com/Yelp/dumb-init" rel="noopener ugc nofollow" target="_blank">哑初始化</a></p><blockquote class="kl km kn"><p id="cd6d" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">我在节点上遇到过几次PID饥饿的问题，因为容器缺少一个僵尸收割PID 1，容器中的某个循环丢弃了孩子，就像罗布·祖姆比电影中那样</p></blockquote><p id="57ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">运送神器而不是建造环境！</strong></p><h1 id="eb49" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">(著名)遗言</strong></h1><p id="fbc3" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">有些事情我在这篇文章中没有提到。监控设置可能会同样充满所有东西是如何联系在一起的(<a class="ae ks" href="https://github.com/coreos/prometheus-operator" rel="noopener ugc nofollow" target="_blank">普罗米修斯操作者</a>和Grafana一直很好地为我们服务)</p><p id="f61b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后。如果你想和其他Kubernauts聊天或寻找大多数特殊兴趣小组(SIG ),一定要注册http://slack.k8s.io/官方Kubernetes Slack @ <a class="ae ks" href="http://slack.k8s.io/" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="acde" class="mz ku iq bd kv na nb dn kz nc nd dp ld jy ne nf lh kc ng nh ll kg ni nj lp nk bi translated">感谢阅读，我希望你对我的文章感兴趣！</h2><h1 id="bf72" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">词典</h1><p id="59eb" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">AZ —可用性区域<br/> ALB —应用负载均衡器<br/> ASG —自动扩展组<br/> EBS —弹性块存储服务<br/> ECR —弹性容器注册表<br/> EFS —弹性文件系统<br/> ELB —弹性负载均衡<br/> IG —实例组</p></div></div>    
</body>
</html>