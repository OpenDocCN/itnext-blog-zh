<html>
<head>
<title>Databases Behind the Scenes: How BoltDB Saves Data To the Disk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幕后的数据库:BoltDB如何将数据保存到磁盘</h1>
<blockquote>原文：<a href="https://itnext.io/databases-behind-the-scenes-how-boltdb-saves-data-to-the-disk-de8f1e3feda6?source=collection_archive---------1-----------------------#2021-10-04">https://itnext.io/databases-behind-the-scenes-how-boltdb-saves-data-to-the-disk-de8f1e3feda6?source=collection_archive---------1-----------------------#2021-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb79" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过阅读源代码了解数据库如何将数据写入磁盘</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/800963f78de6138958037a7bffbb19e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YFseH0D9AjJNQWYD"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="edaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数软件工程师不懂数据库。对于许多人来说，他们对数据库的唯一了解是它是否支持SQL或NoSQL。</p><p id="adc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们将谈论数据库的概念。我们将看到从<em class="ls">写入</em>开始到提交到磁盘会发生什么。</p><p id="941e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将通过查看BoltDB来实现。一个用Go编写的轻量级数据库，用于在磁盘上存储数据。代码很简单，只有不到5000行代码，所以这是开始阅读数据库的好地方。</p><p id="5668" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管Bolt是用Go编写的，但这篇文章将是语言不可知的。</p><h1 id="e268" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">BoltDB概述</h1><p id="b9cb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">BoltDB是一个基于B+树的NoSQL键/值存储引擎。BoltDB中只有几种类型:<code class="fe mq mr ms mt b">DB</code>、<code class="fe mq mr ms mt b">Bucket</code>、<code class="fe mq mr ms mt b">Tx</code>和<code class="fe mq mr ms mt b">Cursor</code>。</p><p id="e3e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">DB</code>是数据库的包装器。<code class="fe mq mr ms mt b">Bucket</code>是键/值对的集合。<code class="fe mq mr ms mt b">Bucket</code>操作在内部交易<code class="fe mq mr ms mt b">Tx</code>中处理。取决于进程的只读或读写事务。<code class="fe mq mr ms mt b">Cursor</code>用于按顺序遍历树中的键。</p><p id="e07f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">BoltDB没有像成熟的数据库那样的查询语言。相反，所有操作都是通过事务本身内部的<code class="fe mq mr ms mt b">Read</code>、<code class="fe mq mr ms mt b">Put</code>和<code class="fe mq mr ms mt b">Delete</code>函数进行的。</p><h1 id="7c1a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">数据结构</h1><h2 id="edc9" class="mu lu iq bd lv mv mw dn lz mx my dp md lf mz na mf lj nb nc mh ln nd ne mj nf bi translated">记忆表征</h2><p id="aa35" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了定位记录，数据库系统使用<em class="ls">索引。</em><em class="ls">索引</em>建立在不同的数据结构之上，各有各的好处。最流行的是LSM树和B树及其变体。</p><p id="4179" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bolt的底层数据结构是B+树。这意味着Bolt适合于大量读取的应用程序。所有节点都包含名为<code class="fe mq mr ms mt b">inodes</code>的键/值对。在分支节点上，该值是指向磁盘上的子节点的指针，在叶子节点上，它是实际值。</p><p id="c650" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">BoltDB树不同于传统的树。子节点不持有指向同级节点的指针，这使得范围扫描更慢，有利于更少的空间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/c563f438e20683a5e7d700ea06baf44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zovzND-fuOK_5vuzvaKECA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">BoltDB树</figcaption></figure><p id="785d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再平衡也适用于“现实世界”的含义。它只包含合并和分割，没有旋转。此外，它会延迟到事务提交，以避免在事务回滚时撤消更改。</p><h2 id="9ea2" class="mu lu iq bd lv mv mw dn lz mx my dp md lf mz na mf lj nb nc mh ln nd ne mj nf bi translated">磁盘表示</h2><p id="bed5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当写入磁盘时，数据库必须开发一种如何在磁盘上放置数据的格式。页面是操作系统可以读写的最小数据量。它的大小通常为4kb，并连续放置在磁盘上。数据库旨在使其数据与页面对齐，以最大限度地减少对磁盘的请求并提高性能。</p><p id="f5c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Bolt中，每个树节点对应一个或多个磁盘页面。每个页面都包含标题:id、标志、计数和溢出。</p><ul class=""><li id="d786" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><code class="fe mq mr ms mt b">flags</code>是页面的类型:<code class="fe mq mr ms mt b">branch</code>、<code class="fe mq mr ms mt b">leaf</code>、<code class="fe mq mr ms mt b">meta</code>或<code class="fe mq mr ms mt b">freelist</code></li><li id="1aae" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><code class="fe mq mr ms mt b">count</code>是键值对的数量</li><li id="c452" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><code class="fe mq mr ms mt b">overflow</code>是节点大时溢出的页数</li></ul><p id="fe5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以及指向页面类型特定数据的通用<code class="fe mq mr ms mt b">ptr</code>字段。页面在磁盘上的布局如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/26f5a5c2d5e1bc06421a8c235c25c548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgHJYnHEtuDUeNdSmn2ZuQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">页面布局</figcaption></figure><h2 id="6a48" class="mu lu iq bd lv mv mw dn lz mx my dp md lf mz na mf lj nb nc mh ln nd ne mj nf bi translated">分支页面</h2><p id="e245" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">分支页面分为两个部分:键和指向键的指针。指针有固定的大小，但是键可以变化。要找到一个键，我们可以很容易地定位指针并读取<em class="ls"> ksize </em>字节。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/0dac365fbde88926c52e03643ffde90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTrow6iAtUwqjjeunHdWuw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">分支节点布局</figcaption></figure><h2 id="58c5" class="mu lu iq bd lv mv mw dn lz mx my dp md lf mz na mf lj nb nc mh ln nd ne mj nf bi translated">叶页面</h2><p id="353d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">叶页面类似于分支页面。最显著的区别是<code class="fe mq mr ms mt b">pgid</code>被替换为<code class="fe mq mr ms mt b">vsize</code>，并且值被添加到keys段。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/0208b6ee5c0eb321604a908673d77b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOirnYiydgcH4mGa-S9zUg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">叶节点布局</figcaption></figure><p id="65d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个节点被加载时，它必须首先被反序列化。BoltDB没有把事情复杂化，使用二进制编码。当反序列化时，<code class="fe mq mr ms mt b">flags</code>字段用于将适当的页面类型加载到<code class="fe mq mr ms mt b">ptr</code>中。</p><p id="25b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当节点被保存回来时，它必须从节点表示转换成页面。因此数据被序列化为页面格式。</p><h1 id="f43c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">处理</h1><p id="62a9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">酸代表原子性、一致性、隔离性和持久性。它是数据库的一组属性，保证事务得到可靠的处理。</p><ul class=""><li id="e403" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">原子性意味着要么所有事务都成功，要么都不成功。这确保了数据库不会处于未定义的状态。</li><li id="8756" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">一致性确保在事务完成后，根据所有定义的规则，写入数据库的任何数据都必须是有效的。</li><li id="c93b" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">隔离保证所有的事务都是孤立发生的。任何交易都不会受到其他交易的影响。因此，事务不能从任何其他尚未完成的事务中读取数据。</li><li id="628b" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">持久性意味着一旦事务被提交，即使在系统出现故障的情况下，数据也将被保留。</li></ul><p id="7c7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">BoltDB事务符合ACID。它使用写入时复制，所以当一个节点被修改时，BoltDB会复制指向它的路径中的所有节点。然后，要应用更改，所要做的就是替换新分支的根。</p><p id="1008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，事务就被隔离了。在修改复制版本时，可以使用原始版本为多个读者服务。此外，事务是原子的，因为它的状态可以使用指针开关从无执行变为完成执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/ae13369e2240e74daea9c5e3717241c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IDaQbTQkl9TpuPQ7e7qVA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">写入时复制</figcaption></figure><p id="6f2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">元数据在带有前面提到的标志<code class="fe mq mr ms mt b">meta</code>的页面中被跟踪。元页面包含对根存储桶的页面id的引用。所以BoltDB通过重写元页来替换根指针。</p><h1 id="10eb" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">页面管理</h1><p id="b127" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">操作系统维护一个页面缓存来提高读取性能。对于常规的文件读取，调用通过缓存，但是页面可能在很久以前就已经从缓存中被逐出了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/0a1f9ccb827ff2a52c51e416d8ee4531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1IIL8__92AN_Qdl56CsNUQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">页面缓存</figcaption></figure><p id="f3f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多数据库改为实现它们的缓存。BoltDB不实现自己的缓存，而是使用<code class="fe mq mr ms mt b">mmap</code>。使用<code class="fe mq mr ms mt b">mmap</code>,页面在完成之前会单独保存在内存中，所以页面永远不会被驱逐。为了加快读取速度，需要更多的RAM。</p><p id="3c47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个数据库是一个文件。使用<code class="fe mq mr ms mt b">mmap</code>，必须指定映射的固定大小。文件可能会无限增长，因此必须相应地调用<code class="fe mq mr ms mt b">mmap</code>。</p><p id="54f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">mmap</code>是一个系统调用，开销很大，所以BoltDB避免在每次写入后调用它。相反，它映射的内容比需要的多，因此需要调用的内容更少。从32KB到1GB，增量是2的幂。1GB之后，文件会以1GB为单位增长。</p><p id="8aa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩余空间的空闲页面由<code class="fe mq mr ms mt b">freelist</code>管理。当一个事务被提交时，它从<code class="fe mq mr ms mt b">freelist</code>请求空闲页面来写入修改过的节点。一旦事务完成或回滚，就可以回收页面。如果没有空闲页面，则使用更大的大小调用<code class="fe mq mr ms mt b">mmap</code>。</p><h1 id="86ae" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">把所有的放在一起</h1><p id="3ff2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最后，我们可以将所有内容放在一起，以了解数据库事务在BoltDB中是如何工作的。</p><ol class=""><li id="789b" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nz nn no np bi translated">要对数据库进行更改，需要打开一个读写事务。</li><li id="90c1" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nz nn no np bi translated">例如，调用<code class="fe mq mr ms mt b">Put</code>并将<code class="fe mq mr ms mt b">Cursor</code>移动到树中正确的节点和位置。</li><li id="e2a2" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nz nn no np bi translated">要修改节点，必须先复制它。根据页面类型加载和反序列化相关页面。所有更改都在树上执行，直到事务提交。</li><li id="4cfb" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nz nn no np bi translated">一旦调用了<em class="ls">提交</em>,树就会通过合并或分割重新平衡。</li><li id="f6aa" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nz nn no np bi translated"><code class="fe mq mr ms mt b">freelist</code>分配新页面。如果没有足够的页面，使用<code class="fe mq mr ms mt b">mmap</code>重新映射文件。</li><li id="2c2f" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nz nn no np bi translated">修改后的节点被序列化到页面中。页面被写入磁盘。</li><li id="f709" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nz nn no np bi translated">根通过重写元页面来替换，指向新的元页面。</li></ol><h1 id="89fc" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="28ef" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我希望现在您对数据库是如何工作的有了更好的理解。最大的收获是认识到即使现代数据库很复杂，研究它们也不是那么困难。</p><p id="a0d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对数据库感兴趣，我推荐阅读我的关于B树和数据库的博客文章。我也推荐你自己阅读BoltDB 的<a class="ae kv" href="https://github.com/boltdb/bolt" rel="noopener ugc nofollow" target="_blank">源代码。</a></p></div></div>    
</body>
</html>