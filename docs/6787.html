<html>
<head>
<title>Importing an ES6 modules over HTTP/HTTPS in a Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中通过HTTP/HTTPS导入ES6模块</h1>
<blockquote>原文：<a href="https://itnext.io/importing-an-es6-modules-over-http-https-in-a-node-js-225ffba8c3fc?source=collection_archive---------1-----------------------#2022-02-26">https://itnext.io/importing-an-es6-modules-over-http-https-in-a-node-js-225ffba8c3fc?source=collection_archive---------1-----------------------#2022-02-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6f39" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">通过HTTP/HTTPS导入模块即将到来，这需要重新考虑安全模型</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/dcf8187d198cf9194a1a26bad9d0c274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YAomAPN_Vuk1jRJK.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片，使用Node.js徽标</figcaption></figure><p id="f512" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在Node.js 17.6.0中，一个实验性的新特性允许我们从HTTP或HTTPS URL导入T2模块。这将消除Node.js和Deno之间的一个差异，Deno允许使用HTTPS导入包。此外，浏览器中的ES6模块允许通过HTTPS导入模块。直到现在，Node.js团队还不允许这样做，理由是安全问题。</p><p id="7f0b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这个通过HTTP或HTTPS导入模块的新功能是一个高度实验性的特性。这有很多严重的安全隐患，我个人也有疑虑。然而，<a class="ae lw" href="https://github.com/nodejs/node/pull/36328" rel="noopener ugc nofollow" target="_blank">对这个特性</a>的拉请求围绕这个问题的几个方面有很多讨论。由于没有阅读整个对话，我不得不相信Node.js技术团队已经考虑了我所担心的问题。</p><p id="78a9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">首先，我们来解释一下HTTP导入是关于什么的:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="30a6" class="mc md iu ly b gz me mf l mg mh">import example from 'https://example.com/path/to/index.mjs';  example('Hello, world!');</span></pre><p id="7a6d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">换句话说，这是关于直接导入通过HTTPS或HTTP检索的Node.js模块。</p><p id="166c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该特性在版本17.6.0中被添加到Node.js中。文档已经可以在:<a class="ae lw" href="https://nodejs.org/api/esm.html#https-and-http-imports" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/esm.html#https-and-http-imports</a>获得</p><h1 id="fa10" class="mi md iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">背景和一些疑虑</h1><p id="ff71" class="pw-post-body-paragraph kz la iu lb b lc mz jv le lf na jy lh li nb lk ll lm nc lo lp lq nd ls lt lu in bi translated">在我们更深入地使用这个特性之前，我们先来谈谈理论。相关拉取请求位于:<a class="ae lw" href="https://github.com/nodejs/node/pull/36328" rel="noopener ugc nofollow" target="_blank">https://github.com/nodejs/node/pull/36328</a></p><p id="0c6a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我对这个想法有两个担心:</p><ol class=""><li id="3224" class="ne nf iu lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">显而易见的是安全性——显然很多人都同意这一点——正如我们将看到的，由于安全问题，实现非常有限。我们习惯于使用npm/yarn存储库，虽然已经有安全入侵通过该存储库，但我们仍然每天都在大规模地使用它。</li><li id="aca6" class="ne nf iu lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">通过拥有一个公共的包存储库，包的可发现性得到了极大的增强</li></ol><p id="49a8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">关于安全问题，wperron 的评论是这样说的:</p><blockquote class="ns nt nu"><p id="d52b" class="kz la lv lb b lc ld jv le lf lg jy lh nv lj lk ll nw ln lo lp nx lr ls lt lu in bi translated"><em class="iu">从npm导入并不一定比从原始URL导入更安全，所以让我们努力使整个生态系统更安全，不管包是如何导入的。</em></p></blockquote><p id="0d13" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">一个HTTP请求容易受到"<em class="lv">中间人</em>"攻击，入侵者会提供一个伪造的包服务器版本。HTTPS至少不受这个问题的影响。但是我预见到了你在网络服务器上找到的随机资料的可信度问题。</p><p id="051d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是，读了wperron的评论，我意识到我没有考虑过这个问题，它可能是不准确的。比如<code class="fe ny nz oa ly b">import foo from 'https://example.com/path/to/index.mjs';</code>和下面有多大区别:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="d453" class="mc md iu ly b gz me mf l mg mh">$ npm init -y <br/>$ npm install https://example.com/path/to --save</span></pre><p id="dc9e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">尽管npm/yarn的设计主要是为了从npm/yarn存储库中获取包，但是它支持的可能的包URL有很长的列表。例如，我经常使用GitHub URL对我的包的测试版本运行代码。而且很有可能有人会公布一个HTTPS网址来安装一个软件包。</p><p id="1ae9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">换句话说，<code class="fe ny nz oa ly b">import .. from 'https://...'</code>和<code class="fe ny nz oa ly b">npm install https://...</code>都在从HTTPS的服务器上抓取Node.js代码。有什么区别？</p><p id="f3d5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">wperron的评论继续讨论了通过npm/yarn存储库传播的各种安全违规。恶意软件一再通过存储库传播。这显然是一个问题，但它也证明了npm/yarn存储库没有提供很多安全保证。</p><p id="7e8f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我所说的包可发现性是什么意思？虽然npm/yarn存储库有缺陷，但这是发现哪些包可用的好方法。你想要一个Node.js甚至前端JavaScript包？前往<code class="fe ny nz oa ly b">npmjs.com</code>并搜索。</p><p id="e6ae" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果Node.js社区脱离了npm/yarn存储库，那么我们如何发现哪些包是可用的呢？我们会依赖搜索引擎来寻找包裹吗？我不认为这是一个好的解决方案，我认为最好有一个专门为Node.js/Deno/Browser.的JavaScript包做广告的网站</p><h1 id="7cd4" class="mi md iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">用示例测试HTTPS/HTTP导入</h1><p id="21b3" class="pw-post-body-paragraph kz la iu lb b lc mz jv le lf na jy lh li nb lk ll lm nc lo lp lq nd ls lt lu in bi translated">好吧，在那个理论之后我们需要着手一些代码。</p><p id="6265" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我在https://github.com/robogeek/example-es6-nodejs-package<a class="ae lw" href="https://github.com/robogeek/example-es6-nodejs-package" rel="noopener ugc nofollow" target="_blank">创建了一个简单的包，这是一个纯ES6模块。</a></p><p id="6f1b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这是一小段代码，具有简单的功能，因此我们可以通过HTTP/HTTPS <code class="fe ny nz oa ly b">import</code>语句关注可用性。<code class="fe ny nz oa ly b">lib/main.mjs</code>要展示的第一个功能是:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="f47a" class="mc md iu ly b gz me mf l mg mh">export default function hello(message) {<br/>     console.log(`main Hello ${message}`); <br/>}</span></pre><p id="f102" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">目的是典型的<em class="lv"> Hello World </em>示例，这样我们可以很快看到HTTPS导入技术是否有效。</p><p id="eae2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因为这是一个实验性的特性，所以可以使用命令行选项<code class="fe ny nz oa ly b">--experimental-network-imports</code>来启用它，如下所示:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="d643" class="mc md iu ly b gz me mf l mg mh">$ node --experimental-network-imports example.mjs</span></pre><p id="014c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">从文档来看，这个客户端代码似乎可以工作:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="cbca" class="mc md iu ly b gz me mf l mg mh">import example from 'https://github.com/robogeek/example-es6-nodejs-package/lib/index.mjs'; <br/>// ALTERNATE using the raw file <br/>// import example from 'https://raw.githubusercontent.com/robogeek/example-es6-nodejs-package/main/lib/main.mjs';</span><span id="223f" class="mc md iu ly b gz ob mf l mg mh">example('World!');</span></pre><p id="461f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是，这会导致错误:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="d5ec" class="mc md iu ly b gz me mf l mg mh">$ node --experimental-network-imports index.mjs <br/>node :internal/errors:465<br/> ErrorCaptureStackTrace(err);<br/> ^ </span><span id="3f2a" class="mc md iu ly b gz ob mf l mg mh">Error [ERR_NETWORK_IMPORT_BAD_RESPONSE]: import 'https://github.com/robogeek/example-es6-nodejs-package/lib/index.mjs' received a bad response: HTTP response returned status code of 404 </span><span id="1f00" class="mc md iu ly b gz ob mf l mg mh">###### Using the alternate<br/>$ node --experimental-network-imports index.mjs <br/>node :internal/errors:465 <br/>ErrorCaptureStackTrace(err); <br/>^ <br/>RangeError [ERR_UNKNOWN_MODULE_FORMAT]: Unknown module format: null for URL <a class="ae lw" href="https://raw.githubusercontent.com/robogeek/example-es6-nodejs-package/main/lib/main.mjs" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/robogeek/example-es6-nodejs-package/main/lib/main.mjs</a></span></pre><p id="a930" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">嗯，除了检索到的模块有问题之外，我不确定这是怎么回事。</p><p id="7e00" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们可以用<code class="fe ny nz oa ly b">curl</code>命令检查是否可以通过HTTPS检索模块源代码:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="dacf" class="mc md iu ly b gz me mf l mg mh">$ curl -f https://raw.githubusercontent.com/robogeek/example-es6-nodejs-package/main/lib/main.mjs <br/>export default function hello(message) {<br/>     console.log(`main Hello ${message}`); <br/>}</span></pre><p id="fb5f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">事实上，模块源在HTTPS上空被正确地恢复了。您可以使用<code class="fe ny nz oa ly b">-v</code>选项再次运行该命令，以查看HTTP对话的详细信息。需要注意的一个细节是GitHub使用了HTTP/2。需要注意的下一个细节是，HTTPS导入功能只适用于HTTP/1，不适用于HTTP/2。根据文档，对HTTP/2和HTTP/3的支持正在进行中。</p><p id="3268" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因此，我们需要一个不同的HTTP或HTTPS服务器。另一种方法是安装本地web服务器，如下所示:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="9861" class="mc md iu ly b gz me mf l mg mh">$ npm install @compodoc/live-server --save <br/>... <br/>$ npx @compodoc/live-server <br/>Serving "/home/david/Projects/nodejs/example-es6-nodejs-package" at http://127.0.0.1 : 8080 <br/>Ready for changes</span></pre><p id="6e5d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这将启动一个本地web服务器，甚至可以为HTTPS和各种高级功能进行配置。在此默认模式下运行，它通过HTTP从本地目录提供文件。</p><p id="7ff8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">换句话说，出于测试目的，切换到本地服务器上的URL。</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="e883" class="mc md iu ly b gz me mf l mg mh">$ node --experimental-network-imports index.mjs <br/>main Hello World!</span></pre><p id="0d8b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用这个URL，通过HTTP导入Node.js模块非常有效。</p><p id="91e5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">解决了这个问题之后，让我们进一步探索一下，看看我们还能做些什么，或者我们还会遇到哪些错误。</p><h1 id="c5bd" class="mi md iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">这能装一整包吗？</h1><p id="1372" class="pw-post-body-paragraph kz la iu lb b lc mz jv le lf na jy lh li nb lk ll lm nc lo lp lq nd ls lt lu in bi translated">导入单个文件很好，也很有用，但是当然我们几乎总是使用复杂的包。这些文件以一个<code class="fe ny nz oa ly b">package.json</code>开头，可以很容易地拥有一打或一百个单独的JavaScript文件。</p><p id="efc3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">但是，HTTPS导入的Node.js文档显示了一个以文件名结尾的URL，比如<code class="fe ny nz oa ly b">http://127.0.0.1:8080/lib/main.mjs</code>。我们可以用<code class="fe ny nz oa ly b">package.json</code>实现的所有高级特性呢？我们会因为HTTP/HTTPS而忽略这一切吗？</p><p id="1d58" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在示例包中有一个<code class="fe ny nz oa ly b">package.json</code>。如果我们把客户端改成这样会怎么样？</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="ef0b" class="mc md iu ly b gz me mf l mg mh">// THIS FAILS <br/>import example from 'http://127.0.0.1:8080/package.json'; <br/>// AS DOES THIS <br/>// import example from 'http://127.0.0.1:8080';  <br/>example('World!');</span></pre><p id="6d33" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用HTTP或HTTPS URL，我想知道如何让Node.js清楚地检索整个包。URL应该直接引用<code class="fe ny nz oa ly b">package.json</code>，还是应该引用<code class="fe ny nz oa ly b">package.json</code>的父URL？</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="b3df" class="mc md iu ly b gz me mf l mg mh">$ node <!-- --> --experimental-network-imports index.mjs<br/>node:internal/errors:465 <br/>ErrorCaptureStackTrace(err); <br/>^ <br/>RangeError [ERR_UNKNOWN_MODULE_FORMAT]: Unknown module format: null for URL http://127.0 .0 .1:8080/package.json</span></pre><p id="cc19" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">不幸的是，这个例子导致了这个错误。文档没有说明是否支持使用HTTP/HTTPS上的<code class="fe ny nz oa ly b">package.json</code>来标识整个包。</p><h1 id="82d4" class="mi md iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">我们可以从通过HTTP/HTTPS加载的模块中加载其他代码吗？</h1><p id="1a70" class="pw-post-body-paragraph kz la iu lb b lc mz jv le lf na jy lh li nb lk ll lm nc lo lp lq nd ls lt lu in bi translated">使用<code class="fe ny nz oa ly b">package.json</code>的目的是我们是否可以通过HTTP/HTTPS导入一个复杂的包。</p><p id="7d5f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">文档说，通过HTTP/HTTPS加载的模块不能访问不是通过HTTP/HTTPS加载的模块。据推测，安全分析发现了一个漏洞，这个漏洞被这个需求所封闭。</p><p id="ec7f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">若要使用从本地文件加载的数据或资源，请将它们作为数据传递。为了理解这意味着什么，我在示例模块中添加了另一个函数:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="9ebb" class="mc md iu ly b gz me mf l mg mh">export default function hello(message) {<br/>     console.log(`main Hello ${message}`); <br/>}  </span><span id="0df7" class="mc md iu ly b gz ob mf l mg mh">export function configure(settings) {<br/>     console.log(`We're being configured with `, settings); <br/>}</span></pre><p id="fe9b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后，在使用该模块的客户端应用程序中，我们可以创建第二个名为<code class="fe ny nz oa ly b">config.mjs</code>的文件，其中包含:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="6b93" class="mc md iu ly b gz me mf l mg mh">export const settings = {<br/>     type: 'mysql',<br/>     port: 3360 <br/>};</span></pre><p id="28ad" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们可以这样重写客户端程序:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="d943" class="mc md iu ly b gz me mf l mg mh">import {<br/>      default as example,<br/>     configure <br/>} from 'http://127.0.0.1:8080/lib/main.mjs'; <br/>import { settings } from './config.mjs'; </span><span id="ab6f" class="mc md iu ly b gz ob mf l mg mh"> example('World!');  </span><span id="373e" class="mc md iu ly b gz ob mf l mg mh">/* const settings = {<br/>     type: 'mysql',<br/>     port: 3360 }; <br/>*/ <br/>configure(settings);</span></pre><p id="0943" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在，我们有了一个数据对象，它既可以内联创建，也可以从本地模块加载。</p><p id="e4d6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">执行脚本时，我们会得到这样的结果:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="dcbd" class="mc md iu ly b gz me mf l mg mh">$ node <!-- -->--experimental-network-imports index.mjs<br/>main Hello World! <br/>We're being configured with { type: 'mysql', port: 3360 }</span></pre><p id="5203" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这很简单，我们可以向远程加载的模块中的函数提供一些数据。</p><h1 id="841c" class="mi md iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">试图通过HTTP/HTTPS导入复杂的Node.js模块</h1><p id="d716" class="pw-post-body-paragraph kz la iu lb b lc mz jv le lf na jy lh li nb lk ll lm nc lo lp lq nd ls lt lu in bi translated">但是，让我们尝试使用一个复杂的Node.js模块。远程加载的模块本身可以加载远程加载模块的本地模块吗？在<code class="fe ny nz oa ly b">example-es6-nodejs-package</code>存储库中，有另一个模块文件<code class="fe ny nz oa ly b">api.mjs</code>，它包含:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="247c" class="mc md iu ly b gz me mf l mg mh">export function echo(message) {<br/>     return message; <br/>}</span></pre><p id="3198" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">它是用来模仿API的。<code class="fe ny nz oa ly b">echo</code>函数只是返回给定的数据。</p><p id="55c9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后在<code class="fe ny nz oa ly b">main.mjs</code>中添加这个:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="cd78" class="mc md iu ly b gz me mf l mg mh">import * as _api from './api.mjs'; <br/>export const api = _api; <br/>// ALTERNATIVE: <br/>// export * from './api.mjs';</span></pre><p id="3daf" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这是一个典型的局部引用，我们会在模块之间进行引用。<code class="fe ny nz oa ly b">echo</code>函数作为名为<code class="fe ny nz oa ly b">api</code>的对象的一部分导出。</p><p id="d444" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在客户端程序中:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="a307" class="mc md iu ly b gz me mf l mg mh">import {<br/>      default as example,<br/>     configure,<br/>     api <br/>} from 'http://127.0.0.1:8080/lib/main.mjs';  <br/>... <br/>console.log(api.echo('Hello, world'));</span></pre><p id="2675" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这将尝试访问<code class="fe ny nz oa ly b">api</code>对象中的函数。但是，这将失败，原因如下:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="fa58" class="mc md iu ly b gz me mf l mg mh">$ node --experimental-network-imports index.mjs <br/>node :internal/errors:465<br/> ErrorCaptureStackTrace(err);<br/> ^<br/> TypeError [ERR_INVALID_URL]: Invalid URL<br/>     at new NodeError (node :internal/errors:372:5)<br/>     at onParseError (node :internal/url:563:9)<br/>     at new URL (node :internal/url:643:5)<br/>     at ESMLoader.resolve (node :internal/modules/esm/loader:577:5)<br/>     at processTicksAndRejections (node :internal/process/task_queues:96:5)<br/>     at async ESMLoader.getModuleJob (node :internal/modules/esm/loader:250:7)<br/>     at async ModuleWrap.&lt;anonymous&gt; (node :internal/modules/esm/module_job:81:21)<br/>     at async Promise.all (index 0)<br/>     at async link (node :internal/modules/esm/module_job:86:9) {<br/> input: './api.mjs',<br/> code: 'ERR_INVALID_URL' <br/>}</span></pre><p id="f591" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们加载的模块有一个引用<code class="fe ny nz oa ly b">./api.mjs</code>的<code class="fe ny nz oa ly b">import</code>语句。加载的模块在我们的机器上执行，它可以访问远程文件系统，而不是只有HTTP访问权。当然，它不能访问这个文件，但它不应该能够计算出一个HTTP或HTTPS的网址吗？在这种情况下，从<code class="fe ny nz oa ly b">http://127.0.0.1:8080/lib/main.mjs</code>到<code class="fe ny nz oa ly b">http://127.0.0.1:8080/lib/api.mjs</code>是一个简单的计算。显然，当前的实现无法做到这一点。</p><p id="4a37" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">一种解决方案是，在<code class="fe ny nz oa ly b">main.mjs</code>中根本不加载<code class="fe ny nz oa ly b">api.mjs</code>，然后在客户端程序中这样做:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="f97b" class="mc md iu ly b gz me mf l mg mh">import * as api from 'http://127.0.0.1:8080/lib/api.mjs';</span></pre><p id="92aa" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后程序正常工作:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="43f7" class="mc md iu ly b gz me mf l mg mh">$ node <!-- --> --experimental-network-imports index.mjs<br/>main Hello World!<br/>We're being configured with { type: 'mysql', port: 3360 }<br/>Hello, world</span></pre><p id="fea6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一个有效的组合是<code class="fe ny nz oa ly b">main.mjs</code>包含这个:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="6ec1" class="mc md iu ly b gz me mf l mg mh">import * as _api from 'http://localhost:8080/lib/api.mjs'; <br/>export const api = _api;</span></pre><p id="c3e8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这需要<code class="fe ny nz oa ly b">main.mjs</code>知道它将通过这个URL被访问。通过这种改变，可以改变客户端程序来做到这一点:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="910c" class="mc md iu ly b gz me mf l mg mh">import {<br/>      default as example,<br/>     configure,<br/>     api <br/>} from 'http://127.0.0.1:8080/lib/main.mjs';  </span></pre><p id="0973" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后“api”由<code class="fe ny nz oa ly b">main.mjs</code>管理，而不是在客户端程序中。并且，当这个被执行时，它正确地工作。</p><p id="aad4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一个实验是导入通过其他方式安装的模块，例如从<code class="fe ny nz oa ly b">node_modules</code>安装。在<code class="fe ny nz oa ly b">main.mjs</code>中，我们可以添加以下内容:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="1f85" class="mc md iu ly b gz me mf l mg mh">... <br/>import * as mime from 'mime-types';  <br/>... <br/>export function mimetype(mt) {<br/>     return mime.lookup(mt); <br/>}</span></pre><p id="9be4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们可以使用任何第三方软件包，这是我随机选择的一个。这是对正常情况下从<code class="fe ny nz oa ly b">node_module</code>导入的模块的引用。这意味着我们必须运行以下命令:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="5b9c" class="mc md iu ly b gz me mf l mg mh">$ npm install mime-types --save</span></pre><p id="5419" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后，在客户端程序中，我们进行以下更改:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="fe44" class="mc md iu ly b gz me mf l mg mh">import {<br/>      default as example,<br/>     configure,<br/>     api,<br/>     mimetype <br/>} from 'http://127.0.0.1:8080/lib/main.mjs';</span><span id="c07b" class="mc md iu ly b gz ob mf l mg mh">console.log(mimetype('foo.json'));</span></pre><p id="4a15" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们添加了一个新的函数<code class="fe ny nz oa ly b">mimetype</code>，它返回并向<code class="fe ny nz oa ly b">mime-types</code>包请求信息。</p><p id="bcb0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们可以尝试运行客户端程序，但会得到以下错误消息:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="f758" class="mc md iu ly b gz me mf l mg mh">$ node --experimental-network-imports index.mjs<br/>  node:internal/errors:465<br/>     ErrorCaptureStackTrace(err);<br/>     ^<br/>  TypeError [ERR_INVALID_URL_SCHEME]: The URL must be of scheme file</span></pre><p id="9f00" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">换句话说，<code class="fe ny nz oa ly b">import .. 'mime-types';</code>命令是不允许的。我们回头参考Node.js文档，其中说:</p><blockquote class="ns nt nu"><p id="7f24" class="kz la lv lb b lc ld jv le lf lg jy lh nv lj lk ll nw ln lo lp nx lr ls lt lu in bi translated"><em class="iu">这些模块不能访问未超过</em> <code class="fe ny nz oa ly b"><em class="iu">http:</em></code> <em class="iu">或</em> <code class="fe ny nz oa ly b"><em class="iu">https:</em></code> <em class="iu">的其他模块。</em></p></blockquote><p id="2660" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe ny nz oa ly b">mime-types</code>的这个进口不符合那个要求。</p><h1 id="904e" class="mi md iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">远程加载的Node.js模块可以读取文件吗？</h1><p id="9cf8" class="pw-post-body-paragraph kz la iu lb b lc mz jv le lf na jy lh li nb lk ll lm nc lo lp lq nd ls lt lu in bi translated">另一个要做的安全测试是从HTTP或HTTPS URL导入的模块是否可以使用像<code class="fe ny nz oa ly b">fs</code>这样的内部包。为了测试这一点，让我们尝试读取一个文件。</p><p id="8e4b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在<code class="fe ny nz oa ly b">main.mjs</code>中添加以下内容:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="8f65" class="mc md iu ly b gz me mf l mg mh">import { promises as fsp, default as fs } from 'fs'; <br/>... <br/>export async function readFile(fn) {<br/>     return await fsp.readFile(fn, 'utf8'); <br/>}</span></pre><p id="5f09" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">它使用<code class="fe ny nz oa ly b">fs.readFile</code>函数尝试读取一个文件，从名为<code class="fe ny nz oa ly b">fs</code>的内置模块中加载它。</p><p id="466a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在客户端程序中，我们可以进行这样的更改:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="0605" class="mc md iu ly b gz me mf l mg mh">import {<br/>      default as example,<br/>     configure,<br/>     api,<br/>     readFile <br/>} from 'http://127.0.0.1:8080/lib/main.mjs'; <br/>... <br/>console.log(readFile('package.json'));</span></pre><p id="80ba" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">它使用远程加载代码中的<code class="fe ny nz oa ly b">readFile</code>函数来尝试读取文件。但是，我们得到了同样的错误:<code class="fe ny nz oa ly b">The URL must be of scheme file</code></p><p id="b5c6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这是相同错误消息。嘿，Node.js团队，我不认为这个错误消息给出了该怎么做的好建议。</p><p id="0cdb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">一个更简单的测试是将<code class="fe ny nz oa ly b">api.mjs</code>改为:</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="133a" class="mc md iu ly b gz me mf l mg mh">import * as util from 'util';  <br/>export function echo(message) {<br/>     return util.inspect(message); <br/>}</span></pre><p id="074f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这将从另一个内置包中导入另一个函数。在<code class="fe ny nz oa ly b">main.mjs</code>中，记得注释掉与<code class="fe ny nz oa ly b">fs</code>模块相关的代码。然后，再次运行客户端程序，我们再次得到相同的错误:<code class="fe ny nz oa ly b">The URL must be of scheme file</code></p><p id="31dd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">它验证任何内置Node.js模块都会出现该消息。错误信息的含义与<code class="fe ny nz oa ly b">import</code>语句中的URL有关。</p><h1 id="f7df" class="mi md iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">摘要</h1><p id="b2a3" class="pw-post-body-paragraph kz la iu lb b lc mz jv le lf na jy lh li nb lk ll lm nc lo lp lq nd ls lt lu in bi translated">我们了解到，启用<code class="fe ny nz oa ly b">--experimental-network-imports</code>后，我们可以使用引用HTTP或HTTPS URL的<code class="fe ny nz oa ly b">import</code>语句。</p><p id="f454" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为什么这篇文章显示了如此多的失败，这可能令人费解？首先，我们在探索我们能用这个特性做什么，以及不能用它做什么。但是，我们也必须认识到，我们遇到的限制是由于安全问题。</p><p id="a978" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因为我曾经在Sun Microsystems的Java SE团队工作，所以我想起了可以在Java运行时中配置的限制。在Java中，类是通过类加载器对象加载的，这与Node.js中的模块是由模块加载器加载的非常相似。在某些情况下，安全类加载器用于限制类文件的可能来源，并限制从给定类加载器运行的代码的能力。因为Java最初设计用于移动设备或基于浏览器的小应用程序，所以增加了安全类加载器来约束从一个或另一个源加载的代码的能力。</p><p id="58b3" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">智能手机应用程序中也使用了类似的模型。他们经常显示对话框，请求执行这个或那个动作的许可。这是由于这些应用程序执行的安全模式。</p><p id="fa28" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们刚刚检查的HTTP/HTTPS导入行为表明了某种安全模型在起作用。</p><p id="c21e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">到目前为止，Node.js已经有了一个开放的安全模型。我们导入到<code class="fe ny nz oa ly b">node_modules</code>中的任何代码都可以完全访问任何内置模块，或者<code class="fe ny nz oa ly b">node_modules</code>中的任何其他模块。为了向前发展，Node.js中的安全模型可能需要改变。</p><h1 id="f385" class="mi md iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">关于作者</h1><p id="c28c" class="pw-post-body-paragraph kz la iu lb b lc mz jv le lf na jy lh li nb lk ll lm nc lo lp lq nd ls lt lu in bi translated"><a class="ae lw" href="https://davidherron.com" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iv"> <em class="lv">大卫·赫伦</em> </strong> </a> <em class="lv">:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</em></p></div><div class="ab cl oc od hy oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="in io ip iq ir"><p id="ec97" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="lv">原载于</em><a class="ae lw" href="https://techsparx.com/nodejs/esnext/import-https.html" rel="noopener ugc nofollow" target="_blank"><em class="lv">https://techsparx.com</em></a><em class="lv">。</em></p></div></div>    
</body>
</html>