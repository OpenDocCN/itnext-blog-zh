<html>
<head>
<title>Explore Different Methods to Build and Push Image to Private Registry with Tekton Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索使用Tekton管道构建映像并将其推送到私有注册表的不同方法</h1>
<blockquote>原文：<a href="https://itnext.io/explore-different-methods-to-build-and-push-image-to-private-registry-with-tekton-pipelines-5cad9dec1ddc?source=collection_archive---------3-----------------------#2019-11-10">https://itnext.io/explore-different-methods-to-build-and-push-image-to-private-registry-with-tekton-pipelines-5cad9dec1ddc?source=collection_archive---------3-----------------------#2019-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/52c8761576bf9d004749bb19919e44ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wDBU8mCDAmq7_mNc.jpg"/></div></div></figure><p id="7f4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://tekton.dev/" rel="noopener ugc nofollow" target="_blank"> Tekton </a>项目使管道资源能够被宣布为Kubernetes CRDs，并因此以Kubernetes本地方式进行管理。本地Kubernetes集群的一个常见用例是构建Docker映像并将其推入私有注册中心。针对OpenShift 3.11 docker注册表，本文探讨了在Tekton管道中构建和推送映像的不同方式。</p><h2 id="b574" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">泰克顿管道资源</h2><p id="fd3f" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">Tekton管道的目标是从Git存储库中提取一个简单的hello world Golang HTTP处理程序的源代码，构建可执行文件和docker映像，并将其推送到OpenShift映像注册中心。</p><p id="2354" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">文档附在下面，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="89b9" class="la lb it md b gy mh mi l mj mk">FROM golang as builder<br/>WORKDIR /build<br/>COPY src/*go /build</span><span id="e8ff" class="la lb it md b gy ml mi l mj mk">RUN CGO_ENABLED=0 go build -o demoApp *.go</span><span id="0df4" class="la lb it md b gy ml mi l mj mk">FROM alpine<br/>WORKDIR /app</span><span id="ac94" class="la lb it md b gy ml mi l mj mk">COPY --from=builder /build/demoApp /app</span><span id="26c0" class="la lb it md b gy ml mi l mj mk">CMD ["./demoApp"]</span></pre><p id="297e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了概括这个过程，为git repo和docker registry repo创建了以下管道资源。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="a357" class="la lb it md b gy mh mi l mj mk">---<br/>apiVersion: tekton.dev/v1alpha1<br/>kind: PipelineResource<br/>metadata:<br/>  name: cicd-demo-git-source<br/>spec:<br/>  type: git<br/>  params:<br/>    - name: revision<br/>      value: master<br/>    - name: url<br/>      value: http://gitea.apps.ocp.fyre.io.cpak/wenzm/cicd-demo.git<br/>---<br/>apiVersion: tekton.dev/v1alpha1<br/>kind: PipelineResource<br/>metadata:<br/>  name: cicd-demo-registry-image<br/>spec:<br/>  type: image<br/>  params:<br/>    - name: url<br/>      value: docker-registry.default.svc.cluster.local:5000/cicd-demo/cicd-demo</span></pre><p id="8e0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">git资源是Gitea的Git repo，托管在OpenShift Kubernetes集群上。图像资源是用名称空间和repo名称定义的OpenShift注册表。</p><h2 id="7fe1" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">访问OpenShift图像注册表</h2><p id="b602" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">由于Tekton管道运行在Kubernetes集群内部，我们可以通过它的服务名来访问OpenShift图像注册中心，服务名是</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="1b92" class="la lb it md b gy mh mi l mj mk">docker-registry.default.svc.cluster.local:5000</span></pre><p id="71e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用服务帐户及其令牌进行身份验证。在名称空间中，创建名为<code class="fe mm mn mo md b">pipeline</code>的服务帐户。将集群角色<code class="fe mm mn mo md b">system:image-pusher</code>分配给这个服务帐户，以便RBAC允许它创建图像流对象并将图像推送到这个名称空间。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="46b4" class="la lb it md b gy mh mi l mj mk">oc create sa pipeline<br/>oc adm policy add-role-to-user system:image-builder -z pipeline</span></pre><p id="596d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">密码是服务帐户的令牌，可以通过，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f16b" class="la lb it md b gy mh mi l mj mk">oc get secret $(oc get secret | grep pipeline-token | head -1 | awk '{print $1}') -o jsonpath="{.data.token}" | base64 -d</span></pre><p id="806d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过连接到OpenShift路由器暴露的注册表来验证它，在我的例子中是<code class="fe mm mn mo md b">docker-registry-default.apps.ocp.fyre.io.cpak</code>，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="39e3" class="la lb it md b gy mh mi l mj mk">docker login docker-registry-default.apps.ocp.fyre.io.cpak<br/>Username: sa<br/>Password: &lt;The token shown with above command&gt;<br/>Login Succeeded</span></pre><h2 id="eff7" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">方法一。用Docker构建</h2><p id="0847" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">在Tekton管道中构建映像的直接方法是使用docker容器(docker in docker)进行构建。然而，要使它在OpenShift集群中工作，需要注意一些要点。</p><blockquote class="mp"><p id="5711" class="mq mr it bd ms mt mu mv mw mx my ky dk translated">在这种方法中，主机docker插座的安装是一个很大的安全问题。不要在生产环境中这样做。</p></blockquote><p id="a974" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">以下是为此任务创建的Tekton任务对象。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ab5f" class="la lb it md b gy mh mi l mj mk">apiVersion: tekton.dev/v1alpha1<br/>kind: Task<br/>metadata:<br/>  name: cicd-demo-build-with-docker<br/>  namespace: cicd-demo<br/>spec:<br/>  inputs:<br/>    resources:<br/>      - name: git-source<br/>        type: git<br/>    params:<br/>      - name: pathToDockerFile<br/>        default: /workspace/git-source/compile.Dockerfile<br/>      - name: pathToContext<br/>        default: /workspace/git-source<br/>      - name: registryHost<br/>        default: "docker-registry.default.svc.cluster.local:5000"<br/>  outputs:<br/>    resources:<br/>      - name: docker-image<br/>        type: image<br/>  steps:<br/>    - name: build<br/>      image: docker<br/>      securityContext:<br/>        runAsUser: 0<br/>        privileged: true<br/>      command:<br/>        - sh<br/>        - -c<br/>        - "cd ${inputs.params.pathToContext} &amp;&amp; \<br/>           docker build -f int-build.dockerfile -t int-build . &amp;&amp; \<br/>           docker stop int-container || echo ignore not running &amp;&amp; \ <br/>           docker rm int-container || echo ignore non-exists &amp;&amp; \<br/>           docker run --name int-container -d int-build sh -c 'while true; do sleep 60; done' &amp;&amp; \<br/>           docker cp int-container:/go/demoApp . &amp;&amp; \<br/>           docker stop int-container &amp;&amp; \<br/>           docker build -f final-build.dockerfile -t ${outputs.resources.docker-image.url} . &amp;&amp; \<br/>           docker login ${inputs.params.registryHost} -u sa -p $(cat /var/run/secrets/kubernetes.io/serviceaccount/token) &amp;&amp; \<br/>           docker push ${outputs.resources.docker-image.url}<br/>          "<br/>      volumeMounts:<br/>        - name: docker-socket<br/>          mountPath: /var/run/docker.sock<br/>  volumes:<br/>    - name: docker-socket<br/>      hostPath:<br/>        path: /var/run/docker.sock<br/>        type: Socket</span></pre><p id="a30d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在构建步骤中，我们使用<code class="fe mm mn mo md b">docker</code>图像。然而，为了在docker (dind)中的docker中构建映像，我们将docker套接字从节点挂载到pod中，并且容器必须在特权模式下运行。因此，必须将相应的安全上下文约束(SCC)分配给运行pod的服务帐户。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="dc2d" class="la lb it md b gy mh mi l mj mk">oc adm policy add-scc-to-user privileged -z pipeline</span></pre><p id="7c6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，容器定义中的安全上下文设置了以下内容，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="d406" class="la lb it md b gy mh mi l mj mk">      securityContext:<br/>        runAsUser: 0<br/>        privileged: true</span></pre><p id="c29b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如在OpenShift 3.11中，Doker的版本不支持多阶段构建，我们必须切换回一些旧的Docker技术来相应地构建映像。首先，我们用名为int-build的dockerfile文件编译和构建二进制文件。Dockerfile，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="bd28" class="la lb it md b gy mh mi l mj mk">FROM golang<br/>COPY src/* src<br/>RUN CGO_ENABLED=0 go build -o demoApp src/*.go</span></pre><p id="5633" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们使用循环shell命令将容器作为守护进程运行。使用“<code class="fe mm mn mo md b"><em class="ne">docker cp</em></code>”将二进制文件复制到构建上下文中。最后，我们用下面的dockerfile文件构建发布映像，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="8cd6" class="la lb it md b gy mh mi l mj mk">FROM alpine<br/>WORKDIR /app<br/>COPY demoApp /app</span><span id="e667" class="la lb it md b gy ml mi l mj mk">CMD ["./demoApp"]</span></pre><p id="d3bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们将映像推送到注册表之前，我们需要使用<code class="fe mm mn mo md b">docker login</code>命令登录。用户名可以是任意的，密码是服务帐户的令牌，Kubernetes将它安装到<code class="fe mm mn mo md b">/var/run/secrets/kubernetes.io/serviceaccount/token</code>的位置。用这个文件的内容登录，我们就可以推送图像了。</p><p id="c78e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过创建任务运行CRD对象来运行任务。它的内容被跳过。</p><p id="579b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总的来说建造速度很快。然而，安装节点的Docker套接字和特权安全上下文需求是这种方法最大的安全问题。</p><h2 id="6925" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated"><strong class="ak">方法二。用Buildah构建</strong></h2><p id="6778" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">Buildah是一个命令行工具，有助于构建开放容器倡议(OCI)容器映像。</p><p id="b40f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然在主机中的集群之外运行命令行工具相当顺利，但是在OpenShift的Kubernetes集群内部运行该工具相当具有挑战性。我们使用预先构建的Docker映像<code class="fe mm mn mo md b">quay.io/buildah/stable</code>来完成Tekton任务。最终的工作版本如下所示，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ab2c" class="la lb it md b gy mh mi l mj mk">apiVersion: tekton.dev/v1alpha1<br/>kind: Task<br/>metadata:<br/>  name: cicd-demo-build-with-buildah<br/>  namespace: cicd-demo<br/>spec:<br/>  inputs:<br/>    resources:<br/>      - name: git-source<br/>        type: git<br/>    params:<br/>      - name: pathToDockerFile<br/>        default: /workspace/git-source/Dockerfile<br/>      - name: pathToContext<br/>        default: /workspace/git-source<br/>      - name: registryHost<br/>        default: "docker-registry.default.svc.cluster.local:5000"<br/>      - name: imageTag<br/>        default: cicd-demo<br/>  outputs:<br/>    resources:<br/>      - name: docker-image<br/>        type: image<br/>  steps:<br/>    - name: build<br/>      image: quay.io/buildah/stable<br/>      securityContext:<br/>        runAsUser: 0<br/>        privileged: true<br/>      command:<br/>        - sh<br/>        - -c<br/>        - "cd ${inputs.params.pathToContext} &amp;&amp; \<br/>           buildah --storage-driver=vfs build-using-dockerfile -f ${inputs.params.pathToDockerFile} -t ${inputs.params.imageTag} . &amp;&amp; \           <br/>           buildah --storage-driver=vfs push --tls-verify=false --creds=anyone:$(cat /var/run/secrets/kubernetes.io/serviceaccount/token) ${inputs.params.imageTag} docker://${outputs.resources.docker-image.url}<br/>          "</span></pre><p id="20ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">理想情况下，我们不应该期望安全上下文的特权要求。但是，如果没有这些，我会遇到下面的错误，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="92a2" class="la lb it md b gy mh mi l mj mk">Error during unshare(CLONE_NEWUSER): Invalid argumentUser namespaces are not enabled in /proc/sys/user/max_user_namespaces.</span></pre><p id="6da9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们应该能够运行如下所示的普通构建命令，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="8ac6" class="la lb it md b gy mh mi l mj mk">buildah build-using-dockerfile -f ${inputs.params.pathToDockerFile} -t ${inputs.params.imageTag} .</span></pre><p id="17ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，我遇到了以下错误，(<em class="ne">是从容器日志</em>中复制的)</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="1838" class="la lb it md b gy mh mi l mj mk">process exited with error: fork/exec /bin/sh: no such file or directorysubprocess exited with status 1</span></pre><p id="4a33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最终我们不得不使用<code class="fe mm mn mo md b">buildah — storage-driver=vfs</code>选项来构建图像。还要注意的是，为了让<code class="fe mm mn mo md b">WORKDIR /build</code>工作，我们必须在order文件中显式地创建该目录，如下所示，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3509" class="la lb it md b gy mh mi l mj mk">FROM golang as builder<br/><strong class="md iu">RUN mkdir  /build</strong><br/>WORKDIR /build<br/>COPY src/*go /build</span><span id="e9d0" class="la lb it md b gy ml mi l mj mk">RUN CGO_ENABLED=0 go build -o demoApp *.go</span><span id="fe63" class="la lb it md b gy ml mi l mj mk">FROM alpine<br/><strong class="md iu">RUN mkdir /app</strong><br/>WORKDIR /app</span><span id="f3ce" class="la lb it md b gy ml mi l mj mk">COPY --from=builder /build/demoApp /app</span><span id="1fbe" class="la lb it md b gy ml mi l mj mk">CMD ["./demoApp"]</span></pre><p id="49a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于身份验证部分，我们使用令牌文件的内容作为登录注册中心的密码。</p><p id="e21f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总的来说，Buildah不需要从主机挂载任何东西，但是我们仍然需要特权安全上下文，并且构建速度相对较慢，因为我们必须使用vfs存储驱动程序来使它在集群内工作。</p><h2 id="76c5" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">方法三。与Kaniko一起构建</h2><p id="9de6" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">让我们创建以下Tekton任务，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="8b9f" class="la lb it md b gy mh mi l mj mk">apiVersion: tekton.dev/v1alpha1<br/>kind: Task<br/>metadata:<br/>  name: cicd-demo-build-with-kaniko<br/>  namespace: cicd-demo<br/>spec:<br/>  inputs:<br/>    resources:<br/>      - name: git-source<br/>        type: git<br/>    params:<br/>      - name: pathToDockerFile<br/>        default: /workspace/git-source/Dockerfile<br/>      - name: pathToContext<br/>        default: /workspace/git-source<br/>  outputs:<br/>    resources:<br/>      - name: docker-image<br/>        type: image<br/>  steps:<br/>    - name: build<br/>      image: gcr.io/kaniko-project/executor:debug<br/>      securityContext:<br/>        runAsUser: 0<br/>      command:<br/>        - sh<br/>        - "-c"<br/>        - " <br/>            /kaniko/executor \<br/>            --dockerfile=${inputs.params.pathToDockerFile} \<br/>            --destination=${outputs.resources.docker-image.url} \<br/>            --context=${inputs.params.pathToContext}  \<br/>            --skip-tls-verify <br/>          "<br/>      volumeMounts:<br/>        - name: docker-config<br/>          mountPath: /kaniko/.docker<br/>  volumes:<br/>    - name: docker-config<br/>      configMap: <br/>        name: docker-config</span></pre><p id="ba41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我正在使用<code class="fe mm mn mo md b">gcr.io/kaniko-project/executor:debug</code>图像，这样我可以在中间插入睡眠命令来排除故障。</p><p id="81e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，我们不需要特权安全上下文。</p><p id="522c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个特殊的事情是，对于Kaniko将图像推送到私有注册中心，我们需要以Docker的config.json格式提供认证。</p><p id="52f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建以下JSON文件，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="143f" class="la lb it md b gy mh mi l mj mk">{<br/>  "auths": {<br/>    "docker-registry.default.svc.cluster.local:5000": {<br/>      "auth": "c2E6ZXlKaGJHY2lPaUp&lt;...skipped many lines ...&gt;"<br/>    }<br/>  }<br/>}</span></pre><p id="0e35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用以下命令获得<code class="fe mm mn mo md b">auth</code>的值</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="601a" class="la lb it md b gy mh mi l mj mk">secret=$(oc get secret  | grep pipeline-token | head -1 | awk '{print $1}')</span><span id="7723" class="la lb it md b gy ml mi l mj mk">token=$(oc get secret $secret -o jsonpath="{.data.token}" | base64 -d -i)<br/>echo "sa:$token" | base64</span></pre><p id="8135" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ne">您可能需要努力删除新行来加入base64编码行。一个更好的方法可能是用一些golang魔法来自动化它，比如</em> <code class="fe mm mn mo md b">base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf(“sa:%s”, token)))</code></p><p id="fd0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用名为config.json的键创建配置映射，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="147c" class="la lb it md b gy mh mi l mj mk">kubectl -n cicd-demo create configmap docker-config --from-file=config.json=docker.config.json</span></pre><p id="23ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用这个配置图将它挂载到Pod的默认目录<code class="fe mm mn mo md b">/kaniko/.docker</code></p><h2 id="7849" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">结论</h2><p id="e816" class="pw-post-body-paragraph kb kc it kd b ke lt kg kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky im bi translated">基于此时的比较，Kaniko提供了一种更安全但足够快速的方法来在Tekton管道中构建和推送图像。</p></div></div>    
</body>
</html>