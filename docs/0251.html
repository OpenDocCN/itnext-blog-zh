<html>
<head>
<title>Going epic with Redux Observable tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux可观察测试进行史诗级测试</h1>
<blockquote>原文：<a href="https://itnext.io/going-epic-with-redux-observable-tests-dd42b80ee4f8?source=collection_archive---------0-----------------------#2018-01-26">https://itnext.io/going-epic-with-redux-observable-tests-dd42b80ee4f8?source=collection_archive---------0-----------------------#2018-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="49c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fgoing-epic-with-redux-observable-tests-dd42b80ee4f8" rel="noopener ugc nofollow" target="_blank"> <em class="km">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="cdd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我开发的最后几个React项目是在<strong class="jp ir"> Redux Observable </strong>库的大量帮助下构建的。这是一个很好的将业务逻辑从组件中分离出来的库，但是正确的测试方法仍然是他们需要找到的。在这篇文章中，我将分享我对这个话题的想法。</p><h1 id="b6c7" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">那么这个Redux可观测是什么呢？</h1><p id="9f45" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">对于那些不了解这个库的人，我推荐你去看看<a class="ae kl" href="https://www.youtube.com/watch?v=AslncyG8whg" rel="noopener ugc nofollow" target="_blank"> RxJS + Redux + React = Amazing！杰伊·菲尔普斯的谈话。这是一个非常鼓舞人心的演讲，讲述了网飞如何使用一些常见的JS模式结合</a><a class="ae kl" href="https://www.robinvdvleuten.nl/blog/going-epic-with-redux-observable-tests/(https://github.com/Reactive-Extensions/RxJS" rel="noopener ugc nofollow" target="_blank"> RxJS </a>的功能来管理React应用程序中的业务逻辑。他们从网飞提取了核心，并在Github上作为开源库<a class="ae kl" href="https://github.com/redux-observable/redux-observable/" rel="noopener ugc nofollow" target="_blank">共享。</a></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/c69df2bb168993c1078ec29e48d1fed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/1*iyup_llTYsmHINX5wnTI1Q.gif"/></div></figure><p id="6685" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们的<a class="ae kl" href="https://redux-observable.js.org/" rel="noopener ugc nofollow" target="_blank">文档</a>非常优秀，包含了许多小的运行示例来帮助你开始。整个图书馆本身就值得写一篇文章，但是有一个重要的方面仍然没有得到充分的展示。事实上，他们自己还在为最佳途径而挣扎；</p><blockquote class="ly lz ma"><p id="c957" class="jn jo km jp b jq jr js jt ju jv jw jx mb jz ka kb mc kd ke kf md kh ki kj kk ij bi translated">测试会产生副作用的异步代码并不容易。我们仍在学习测试史诗的最佳方法。如果你找到了完美的方法，请分享！”<br/> —  <a class="ae kl" href="https://redux-observable.js.org/docs/recipes/WritingTests.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Redux可观察文档</em> </a></p></blockquote><p id="05e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在与几个项目上的可观察测试进行斗争之后，我想在本文中就这个主题发表我的两点意见。</p><h1 id="4670" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">我们要测试什么史诗？</h1><p id="b84e" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">为了更好地展示如何测试异步业务逻辑，我想到了以下方法:</p><pre class="lr ls lt lu gt me mf mg mh aw mi bi"><span id="bcaa" class="mj ko iq mf b gy mk ml l mm mn">export const authenticateUserEpic = (action$, store, { client }) =&gt; {<br/>  // Only act on actions of a given type,<br/>  // in this case "USER_AUTHENTICATE_REQUEST".<br/>  return action$.ofType('USER_AUTHENTICATE_REQUEST')<br/>    // Map the received action to a new action "observable".<br/>    .switchMap(action =&gt; {<br/>      // Authenticate with the dispatched credentials in the action,<br/>      // using the injected client instance.<br/>      return client.authenticate(action.username, action.password)<br/>        .then(response =&gt; {<br/>          if (!response.isSuccessful) {<br/>            // Map the response to a "failed" action with the error.<br/>            return {<br/>              type: 'USER_AUTHENTICATE_FAILURE',<br/>              error: 'Something went wrong while authenticating',<br/>            };<br/>          }</span><span id="1b27" class="mj ko iq mf b gy mo ml l mm mn">          return {<br/>            // Map the response to a "successful" action with a JWT token.<br/>            type: 'USER_AUTHENTICATE_SUCCESS',<br/>            idToken: response.idToken,<br/>          };<br/>        });<br/>    });<br/>}</span></pre><p id="c8c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到，这是一部关于使用发送的凭证对用户进行身份验证的史诗。我可以想象我会派遣这样的行动；</p><pre class="lr ls lt lu gt me mf mg mh aw mi bi"><span id="7f99" class="mj ko iq mf b gy mk ml l mm mn">export const authenticate = (username, password) {<br/>  return { type: 'USER_AUTHENTICATE_REQUEST', username, password };<br/>}</span><span id="d18a" class="mj ko iq mf b gy mo ml l mm mn">dispatch(authenticate('johndoe', 'mysupersecretpassword'));</span></pre><p id="a0f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能也注意到了，我已经将客户端依赖关系注入到我的epic中。您可以通过<em class="km"> require </em>或<em class="km"> import </em>语句获得一个客户端实例。但是通过使用<em class="km">依赖注入</em>，它使得客户端方式更容易被模仿，而你的epic方式更容易被测试。</p><h1 id="d3d8" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">用Jest创建测试</h1><p id="95cf" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">大多数React项目似乎都在使用<a class="ae kl" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>，所以我只在示例测试中使用它。</p><p id="c4b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我测试上述epic的方法是，当epic接收到<em class="km">分派的</em>动作时，得到<em class="km">预期的</em>动作。因此，对epic的快速浏览告诉我们，我们需要两个测试；一个是我们期望的带有JWT令牌的“用户验证成功”,另一个是我们期望的带有错误的“用户验证失败”。要将它们定义为Jest测试，可以这样定义它们:</p><pre class="lr ls lt lu gt me mf mg mh aw mi bi"><span id="2be5" class="mj ko iq mf b gy mk ml l mm mn">describe('authenticateUserEpic', () =&gt; {<br/>  it('should dispatch a JWT token when authenticating is successful', () =&gt; {<br/>    // ...<br/>  })</span><span id="e0d4" class="mj ko iq mf b gy mo ml l mm mn">  it('should dispatch an error when authenticating has failed', () =&gt; {<br/>    // ...<br/>  })<br/>});</span></pre><p id="ffc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在让我们把注意力集中在第一个测试上。我们需要向epic传递<em class="km">调度</em>动作，并在RxJS观察完成时获得结果动作。有许多方法可以编写这样的代码，但是下面的方法最适合我；</p><pre class="lr ls lt lu gt me mf mg mh aw mi bi"><span id="2b31" class="mj ko iq mf b gy mk ml l mm mn">import { ActionsObservable } from 'redux-observable';<br/>import authenticateUserEpic from './epics';</span><span id="3299" class="mj ko iq mf b gy mo ml l mm mn">// ...</span><span id="3c54" class="mj ko iq mf b gy mo ml l mm mn">it('should dispatch a JWT token when authenticating is successful', async () =&gt; {<br/>  // The response object we expect to receive from the server.<br/>  const response = {<br/>    isSuccessful: true,<br/>    idToken: 'a-random-generated-jwt',<br/>  };</span><span id="13f9" class="mj ko iq mf b gy mo ml l mm mn">  // Create a fake client instance which will return<br/>  const client = { authenticate: jest.fn() };<br/>  client.authenticate.mockReturnValue(Promise.resolve(response));</span><span id="ead8" class="mj ko iq mf b gy mo ml l mm mn">  // Create an Observable stream of the dispatching action.<br/>  const action$ = ActonsObservable.of({<br/>    type: 'USER_AUTHENTICATE_REQUEST',<br/>    username: 'johndoe',<br/>    password: 'mysupersecretpassword',<br/>  });</span><span id="b781" class="mj ko iq mf b gy mo ml l mm mn">  // Pass the Observable action to our action and inject the<br/>  // mocked client instance.<br/>  const epic$ = authenticateUserEpic(action$, store, { client });</span><span id="4a1d" class="mj ko iq mf b gy mo ml l mm mn">  // Get the resulting actions by using async/await.<br/>  const result = await epic$.toArray().toPromise();</span><span id="7aa7" class="mj ko iq mf b gy mo ml l mm mn">  // Test if we've received the expected action as result.<br/>  expect(result).toEqual([<br/>    { type: 'USER_AUTHENTICATE_SUCCESS', idToken: 'a-random-generated-jwt' }<br/>  ])<br/>});</span></pre><p id="ba43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没那么难吧。你首先需要了解RxJS。但是在这之后，您将在React应用程序中很好地分离关注点。为了使示例完整，下面的测试将处理失败的响应；</p><pre class="lr ls lt lu gt me mf mg mh aw mi bi"><span id="c828" class="mj ko iq mf b gy mk ml l mm mn">it('should dispatch an error when authenticating has failed', async () =&gt; {<br/>  // The response object we expect to receive from the server.<br/>  const response = {<br/>    isSuccessful: false,<br/>  };</span><span id="e626" class="mj ko iq mf b gy mo ml l mm mn">  // Create a fake client instance which will return<br/>  const client = { authenticate: jest.fn() };<br/>  client.authenticate.mockReturnValue(Promise.resolve(response));</span><span id="1f9d" class="mj ko iq mf b gy mo ml l mm mn">  // Create an Observable stream of the dispatching action.<br/>  const action$ = ActonsObservable.of({<br/>    type: 'USER_AUTHENTICATE_REQUEST',<br/>    username: 'johndoe',<br/>    password: 'mysupersecretpassword',<br/>  });</span><span id="be6f" class="mj ko iq mf b gy mo ml l mm mn">  // Pass the Observable action to our action and inject the<br/>  // mocked client instance.<br/>  const epic$ = authenticateUserEpic(action$, store, { client });</span><span id="85e4" class="mj ko iq mf b gy mo ml l mm mn">  // Get the resulting actions by using async/await.<br/>  const result = await epic$.toArray().toPromise();</span><span id="e5a7" class="mj ko iq mf b gy mo ml l mm mn">  // Test if we've received the expected action as result.<br/>  expect(result).toEqual([<br/>    { type: 'USER_AUTHENTICATE_FAILURE', error: 'Something went wrong while authenticating' }<br/>  ])<br/>});</span></pre><p id="a1d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一路上我有没有头疼？在对RxJS有一个基本的了解之前我肯定是得了<a class="ae kl" href="https://stackoverflow.com/questions/42276419/invoking-epics-from-within-other-epics" rel="noopener ugc nofollow" target="_blank">一些</a> <a class="ae kl" href="https://stackoverflow.com/questions/47037119/testing-observable-epic-which-invokes-other-epic" rel="noopener ugc nofollow" target="_blank">题</a>！但幸运的是，Redux Observable非常有用。现在我有了一个非常有价值的新工具来构建我的React应用程序👌</p><pre class="lr ls lt lu gt me mf mg mh aw mi bi"><span id="df12" class="mj ko iq mf b gy mk ml l mm mn">Originally published at <a class="ae kl" href="https://www.robinvdvleuten.nl/blog/going-epic-with-redux-observable-tests/?utm_source=medium&amp;utm_medium=article" rel="noopener ugc nofollow" target="_blank">www.robinvdvleuten.nl</a></span></pre></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="dc60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">希望它帮助你用React和RxJS构建了一些令人惊奇的东西。请在下方按</em> <strong class="jp ir"> <em class="km">推荐</em> </strong> <em class="km">展示一些欣赏或在评论中分享你的想法。</em></p><p id="6085" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你正在做类似的事情，并且有任何你认为我可以帮忙的问题，我是推特上的<a class="ae kl" href="https://twitter.com/robinvdvleuten" rel="noopener ugc nofollow" target="_blank"><em class="km">@ robinvdvleuten</em></a><em class="km">！</em></p></div></div>    
</body>
</html>