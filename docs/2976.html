<html>
<head>
<title>Iterator pattern in Go using channels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用通道的Go中的迭代器模式</h1>
<blockquote>原文：<a href="https://itnext.io/iterator-pattern-in-go-using-channels-73a36746c7ac?source=collection_archive---------7-----------------------#2019-09-09">https://itnext.io/iterator-pattern-in-go-using-channels-73a36746c7ac?source=collection_archive---------7-----------------------#2019-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5392698df038d28de2730fec9cd0736a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2koJvMdxQafYEZiWMIxZg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@edvinasd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Edvinas daugordas</a>在<a class="ae jg" href="https://unsplash.com/search/photos/staircase?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="e6d9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通道和Goroutines是Go中并发模型的两个特性之一。它们在语言中如此普遍，以至于运行库在语法中为它们提供了内在支持。一个这样的语法支持是在<code class="fe le lf lg lh b">for range</code>循环中。您可以使用<code class="fe le lf lg lh b">for range</code>循环对<em class="li">打开的</em>通道中的值进行范围调整(当通道<em class="li">关闭</em>时，范围循环终止)</p><pre class="lj lk ll lm gt ln lh lo lp aw lq bi"><span id="c892" class="lr ls jj lh b gy lt lu l lv lw">ch := make(chan int)<br/>for i := ch {<br/>    fmt.Println(i)<br/>}</span></pre><p id="c722" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种语法支持允许我们在go中创建迭代器模式，而不需要明确使用<code class="fe le lf lg lh b">next()</code>或<code class="fe le lf lg lh b">isDone()</code>方法。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="b3da" class="lr ls jj bd me mf mg dn mh mi mj dp mk kr ml mm mn kv mo mp mq kz mr ms mt mu bi translated">问题</h2><p id="74b8" class="pw-post-body-paragraph kg kh jj ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">我们最近有一个用例，在这个用例中，我们必须定期从服务中获取分页数据，并将聚合数据上传到AWS S3</p><h2 id="e15e" class="lr ls jj bd me mf mg dn mh mi mj dp mk kr ml mm mn kv mo mp mq kz mr ms mt mu bi translated">解决办法</h2><p id="992a" class="pw-post-body-paragraph kg kh jj ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">为了解决这个问题，我们使用go通道并发地向远程服务发出迭代RPC请求，并聚合结果。该解决方案包含以下组件:</p><ol class=""><li id="fc5f" class="na nb jj ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated">定期运行<code class="fe le lf lg lh b">fetch-and-upload</code>作业的<a class="ae jg" href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" rel="noopener ugc nofollow" target="_blank"> K8S Cronjob </a>。</li><li id="e6ea" class="na nb jj ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">这个问题的获取部分是对远程REST端点的RPC调用。</li><li id="022f" class="na nb jj ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">请求分页数据的迭代器(<em class="li">我们将只关注解决方案的这一部分</em></li><li id="68fc" class="na nb jj ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">上传部分使用go中的<code class="fe le lf lg lh b">aws-sdk</code>上传聚合文件</li></ol><h2 id="6ce9" class="lr ls jj bd me mf mg dn mh mi mj dp mk kr ml mm mn kv mo mp mq kz mr ms mt mu bi translated">使用通道的迭代器模式</h2><p id="539b" class="pw-post-body-paragraph kg kh jj ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">创建迭代器的先决条件是能够清楚地区分迭代器何时完成。在大多数迭代器的实现中，这是使用类似<code class="fe le lf lg lh b">isDone</code>(双关语)的方法来完成的。在我的例子中，远程服务允许基于光标的响应，当数据结束时，字段<code class="fe le lf lg lh b">next</code>为空。这非常适合迭代器模式，在迭代器模式中，我们需要某种东西来识别分页数据的结尾。</p><p id="ae28" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，获取分页用户信息的<code class="fe le lf lg lh b">iterator</code>使用通道编写为:</p><pre class="lj lk ll lm gt ln lh lo lp aw lq bi"><span id="bfa0" class="lr ls jj lh b gy lt lu l lv lw">import (<br/>  "log"<br/>  "github.com/dummy-package/service"<br/>)</span><span id="d7dc" class="lr ls jj lh b gy no lu l lv lw">func UserIterator() &lt;-chan User {<br/>  ch := make(ch User)<br/>  offset := 0<br/>  limit := 1000</span><span id="08c5" class="lr ls jj lh b gy no lu l lv lw">  go func() {<br/>    for {<br/>      userResponse, err := service.GetUsers(offset)<br/>      if err != nil {<br/>          log.Println("Cannot fetch data for offset", offset)<br/>      }<br/>     <br/>      offset += limit<br/>      ch &lt;- userResponse.Items</span><span id="13dd" class="lr ls jj lh b gy no lu l lv lw">      if userResponse.Next == nil {<br/>        log.Println("Finished fetching all users")<br/>        close(ch)<br/>        return<br/>      }<br/>    }<br/>  }()<br/>  return ch<br/>}</span></pre><p id="4816" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下,<code class="fe le lf lg lh b">service.GetUsers(offset)</code>的签名如下</p><pre class="lj lk ll lm gt ln lh lo lp aw lq bi"><span id="a9fa" class="lr ls jj lh b gy lt lu l lv lw">type NextCursor struct {<br/>  Href string<br/>}</span><span id="e18c" class="lr ls jj lh b gy no lu l lv lw">type UserResponse struct {<br/>   Items []User<br/>   Next NextCursor<br/>}</span><span id="c4cb" class="lr ls jj lh b gy no lu l lv lw">func GetUsers(offset int) UserResponse {<br/>  ...<br/>}</span></pre><p id="4468" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了上面的迭代器，我们可以声明性地遍历通道，并将所有返回的用户响应组合到一个<code class="fe le lf lg lh b">slice</code>中</p><pre class="lj lk ll lm gt ln lh lo lp aw lq bi"><span id="a310" class="lr ls jj lh b gy lt lu l lv lw">package main</span><span id="cb7a" class="lr ls jj lh b gy no lu l lv lw">func main() {<br/>  var allUsers []User<br/>  for users := range UserIterator() {<br/>    allUsers = append(allUsers, users...)<br/>  }</span><span id="a082" class="lr ls jj lh b gy no lu l lv lw">  UploadToS3(allUsers)<br/>}</span></pre><p id="a0f7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种模式允许我们直观地推理远程服务的分页行为并聚合响应，而不必处理HTTP响应中有太多信息的问题。</p></div></div>    
</body>
</html>