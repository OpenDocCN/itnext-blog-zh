# 为什么不应该在应用程序“周围”实现授权，而应该做些什么

> 原文：<https://itnext.io/why-you-shouldnt-implement-authorization-around-your-application-and-what-to-do-instead-35c7851bfd9f?source=collection_archive---------0----------------------->

**Update 2020–03–31**:这篇文章可能会给你留下这样的印象:HTTP 动词的错误解释和这类问题只与 Apache CXF 有关，但事实上它们更普遍，正如下面文章中的[所描述的。](https://about.gitlab.com/blog/2020/03/30/how-to-exploit-parser-differentials/)请不要仅仅因为你在使用其他东西/在不同的软件平台/堆栈上，就认为你是安全的。

如果你负责定义如何为你的应用程序实现授权，那么就要非常小心*如何*和*在哪里*实现它。

在这篇文章中，我将只关注“在哪里”，尽管“如何”也很重要。这里也不讨论认证。

这只是一个介绍性的帖子，所以不要期待深入的建议。无论如何，对这篇文章要有所保留。安全是一个深刻而复杂的问题，一篇文章不可能涵盖它的所有方面；-)

# 假想系统

让我们假设您的信息系统分为两个主要部分:一方面是公开数据和功能的后端，另一方面是通过一个漂亮的 Web 用户界面消费服务和公开功能的前端。

假设这个虚构的系统具有以下特征:

*   前端应用程序:SPA(例如，React)
*   后端应用程序:公开 RESTful API

该后端系统分层如下:

*   Web 服务器(例如，servlet 容器或任何东西)处理请求/响应及其相关的生命周期
*   一组过滤器处理请求/响应，并且如果需要的话可以阻止/转换这些请求/响应
*   将 URIs /方法等映射到类/函数的 REST 层
*   REST 层、其他 API(例如，SOAP API)和应用程序的其他服务(例如，批处理作业)使用的业务层
*   包含您的领域模型、dto 等的领域层
*   由应用程序的业务层专门使用的存储库层，处理与底层数据库的交互(无论您喜欢什么类型)
*   数据库系统

让我们假设前端和后端都是单独部署的(尽管这对我们的讨论并不重要),并且在它们前面放置了多个基础架构:

*   Web 应用程序防火墙
*   负载平衡器
*   API 网关
*   …

# 可能性…

您的任务是为这个系统实现授权:您做什么？

理论上，你当然有无数的选择。由于 IT 系统是思维的产物，创造力在我们所做的每一件事情中都扮演着重要的角色。所以在你面前有一个无限可能的世界。

你*可能*(不是说你应该！):

*   完全忽略这些问题，继续你的生活(哎呀)
*   在前端应用程序中添加逻辑以实施授权
*   请基础结构团队将经过身份验证的用户所属的相关 LDAP 组成员身份注入到转发到后端服务器的请求的 HTTP 头中，以便您的应用程序可以利用这些身份
*   让基础设施团队生成并签署令牌(JWT/SAML ),其中包含您的后端在某一层检查授权所需的一切(例如，前面提到的组成员)
*   要求基础架构团队根据经过身份验证的用户 LDAP 组成员身份，在某些 URIs 上实施访问控制规则
*   在应用程序周围添加一个安全过滤器*，在其中检查授权规则，以允许/拒绝请求传递到应用程序的较低层。基本上，这与前一点非常相似，因为请求 URIs 是你在这里处理的。*
*   仅在 REST 层解决授权问题，确保您不会让未经授权的请求被接受/处理并传递到您的业务层
*   解决业务服务层中的授权问题
*   解决存储库层的授权问题
*   解决数据库本身的授权问题

这只是你能想象到的一小部分。你也可以结合不同的方法。

虽然，由于我近期内不会就这个主题写一本书，让我们来探讨一下上面列出的一些选项，看看哪些更好/更差。

# 前端===用户体验

首先，让我们排除死显而易见的:**授权检查可能在前端对用户体验有用，但对安全性绝对没有附加值**。

当前端应用程序在客户端机器上执行时，在那里运行的代码完全不受您的控制。事实上，攻击者会查看前端，看看他们如何与您的后端进行交互，但他们甚至不会费心使用它(除了探索其他漏洞)。

攻击者的目标是您的后端系统，尤其是您的数据库和敏感文件。为此，他们将重点攻击后端暴露的任何东西。所以基本上，他们会直接请求您的后端基础架构。

所以请不要认为你可以在前端设置任何有意义的安全控制*。*

如果您确实在前端实现了授权检查，那只是为了改善用户的体验(如果可以的话，您确实应该这样做)。

这并不是说对前端的安全性没有什么可做的，远非如此！如果你对这个话题感兴趣，那就去了解一些关于 CSRF、XSS 和 CORS 的事情，内容安全政策，cookie 安全等等。

# 在基础设施层面处理一切

第二个可能给你带来麻烦的想法是这个。

在基础设施级别处理身份验证(至少部分)是有意义的，因为这是一个普遍关注的问题，即基础设施可以通过一致的 UI/UX 干净地解决许多不同的系统。

处理授权完全是另外一回事。

首先，您的授权模型可能非常复杂，您很快就会让基础设施团队对它所带来的维护负担感到愤怒。

第二，你的检查的粒度将非常有限。基于特定的上下文对相同的用户应用不同的规则集在这个层次上不是一件容易的事情。

更重要的是，如果您只在基础设施级别实现对 URL 的检查，如果攻击者能够以某种方式绕过基础设施并直接到达您的后端服务器，会发生什么？

如果您完全在应用程序之外实现授权，而它仍然暴露在外，那么您的数据就没有了，您的完整性就没有了。当然，你的名声很可能会随之而来。

所以不，这不是个好主意。当然有办法让它变得更好。例如，您可以在您的后端和那些基础设施部分之间部署相互身份验证，或者在您的后端上确保您只接受来自那些基础设施部分的请求。但它很快就会变得毛茸茸的。并不是说这些不好实现，但是要意识到这是有代价的(我会在结论中回到这一点)。

尽管如此，它并没有提供足够好的安全级别，因为它完全位于您的系统之外。如果有攻击者进来，你就死在水里了。

但是不要误解我说的话。这并不意味着您不能在基础架构级别检查任何内容。事实上，您可以在那里实现高级别的检查，这将提高您的安全性。例如，根据系统中稳定的高级角色来允许/阻止对应用程序的访问是有意义的。例如，如果您有一个只有管理员可以访问的“/admin”端点，那么您可以在基础结构级别检查角色成员资格。理解这一点至关重要，这是不够的。您的应用程序本身仍然应该在事后验证授权。

# 通过安全过滤器处理授权

您可以考虑的第三个选项是在应用程序的最外层处理授权:过滤器。

基本上，这仍然在应用程序的“外部”，因为请求甚至不会到达应用程序的最高层(在本例中是 REST API 层)。

这听起来不错，对于一些高级检查来说确实有意义(与基础设施级别的高级授权检查的基本原理相同)。

但是，这又一次给攻击者留下了太多的可能性。如果他们能够以某种方式绕过过滤器，或者如果他们只是配置错误，那么你的系统就完蛋了。例如，假设你的过滤器是区分大小写的，而你却没有意识到？我见过这种事！如果你认为 Get VS GET 总是以同样的方式处理，那么再想想吧！

此外，当添加或修改功能时，很容易忘记更新过滤器，这可能会使新的端点不受保护。如果没有适当的代码审查和测试，这可能会被忽视，直到为时已晚。

此外，在这一级实现细粒度的上下文控制也非常困难。

# 在最外层的 API 层(例如 REST)处理授权

架构的下一层是 REST API 层。

您可以决定在 API 层实施授权控制，确保只有经过授权的调用才能进一步进入业务层。

这一次，您在后端代码中，因此您可以访问更多的上下文，甚至可以与您的服务/存储库/数据库进行交互，以获取额外的信息来衡量您的访问控制决策。

像其他解决方案一样，这也可行，但不是最好的主意。如果您*只*这样做，那么当您在系统中实现另一个 API(例如 SOAP)时会发生什么呢？您是否创建了额外的授权规则？你复制现有的吗？

此外，就像过滤器一样，如果有人找到了绕过这些限制的方法，会发生什么呢？

这里我有一个 Java 生态系统的具体例子。直到最近，Apache CXF 还允许客户端通过不同的方式(例如，X-HTTP-Method-Override HTTP header，_method query parameter)在请求中覆盖 HTTP 方法。多亏了这个(有点)酷的特性，任何人都可以发出 GET 请求，但是要像对待帖子或其他东西一样对待它。

如果您的安全性设置在 REST API 层或以上，那么您可能会认为请求可以被允许通过，因为它看起来像 GET，而实际上它将被作为 POST 处理。默认情况下，Apache CXF 的这个特性现在是禁用的。它的存在是为了解决一些基础设施问题(例如，不支持补丁 HTTP 动词的代理)。你可以在这里找到更多关于它的信息:【https://cwiki.apache.org/confluence/pages/viewpage.action? pageId = 24190906 # JAX-RS-OverridingHTTPmethod

一旦找到了解决方法/弱点，那么你的整个系统就又一次玩完了。

# 在业务服务层处理问题

现在我们进入更有趣的解决方案。

对我来说，业务服务层是您需要认真考虑进行授权检查的第一层。

如果您的所有面向外部的访问点都依赖于这个业务服务层来执行它们需要的任何事情，那么您可以非常自信地认为您的授权检查将是有效的，不会被轻易绕过。

在这里，您通常拥有做出良好安全决策所需的所有上下文。您在自己的城堡中，可以访问您的数据库、其他服务等，因此您可以基于精细的信息做出决策。

此外，您可以实现这些检查一次，不需要在其他层重复那些不必要的。

如果绕过了这些检查，那么您仍然难逃一死，但这可能意味着您在其他地方实现了功能，或者直接在上层中使用了下层，这很可能是一个错误，您的代码审查应该快速突出这一点。您可以通过创建单独的模块并通过依赖关系管理实施规则来防止这样的体系结构捷径/中断。

我不是说这是唯一的解决方案，但你绝对应该从这里开始。

# 在存储库层处理问题

在这一层实现授权不如前一个选项好，因为您将开始非常糟糕地混合不同的关注点。这一层应该只关心数据访问/持久性/一致性/完整性。

事务界定和授权(以及其他事项)属于上面的层。

在这一层实现授权检查的一个问题是，您不能利用业务服务来做出决策，因为您会引入应该在第一位置就存在的循环依赖，因此您可以支配的上下文较少。

此外，存储库层可能会公开不同业务场景中使用的特定功能，如果没有足够的上下文，您可能无法确定是否应该授权访问 A 或 B(可能在一种情况下应该授权，而在另一种情况下不应该授权)。这通常会导致一种“最小公分母”的情况，即总是应用最宽松的规则，削弱了系统的安全性。

# 处理数据库中的问题

您可以实施授权的最后一个地方是您的数据库。

这是最接近您的数据的，所以从安全的角度来看，它实际上是最理想的。

不幸的是，在这一层，您通常没有多少上下文来做出访问控制决策。您可以实施非常细粒度的访问控制，但是要做出相关的业务上下文感知决策可能会非常困难。

一个角色为 X 的用户使用业务特性 Y 时，可能被授权执行 A、B 或 C，而在使用特性 z 时，他不应该被允许这样做。

尽管如此，您还是应该在数据库系统本身中实施适当的身份验证和授权。

# 那么…授权应该在哪里办理呢？

很抱歉让你失望了，但是这里没有唯一的答案！

事实上，您应该应用深度防御方法(不仅仅是授权)。**保护系统就是保护“洋葱”的每一层**。

当一个请求碰到应用程序前面的安全基础设施时，它应该执行一些(可能是粗粒度的)授权检查，作为第一道屏障。

一旦您的后端系统接收到请求，为了安全起见，过滤器可能会再次执行相同的检查(例如，验证令牌的存在、其签名的有效性、特定角色的存在等)。如果这些检查是粗粒度的，那么维护负担将非常有限。

如果您有能力这样做，那么在基础设施和后端系统之间部署相互身份认证肯定是有益的(多一层保护)，但不要被愚弄，这不仅复杂，而且实施/维护成本高昂。

就个人而言，我不会花太多精力在我的外部 API 层中进行授权检查。对我来说，这是次优的，而且容易出错。此外，正如我们所看到的，如果绕过这种保护，那么您的系统的安全性就被破坏了。

我不想拿当前的世界局势开坏玩笑，但这就像说“我们很安全，我们已经关闭了边境，现在没有什么能发生在我们身上”。

这是旧的世界观:相信环境，相信界限。**在我们当前的世界中，零信任安全模式应该是你的默认选择**。不要盲目相信基础设施，不要盲目相信网络，不要相信自己关起门来就是安全的。

我最努力的地方是业务服务层。我会尽最大努力让每个流程都通过该层，并确保强化、保护和测试整个 API，无论它是由 REST、SOAP、batch 还是其他什么使用。

最重要的是，我会花时间来适当地保护数据库系统本身，例如加密静态、传输中的数据，并对数据本身适当地实现身份验证和(至少是高级别的)授权控制。

最后但并非最不重要的一点是，将用户上下文移植到数据库可能会更好，并且在数据库级别有更细粒度的访问控制(和更清晰的审计日志)。

当然，关于这个主题还有很多其他的东西要说，但是因为我最近讨论过这个问题，我想这可能对其他人有帮助。这篇文章应该会给你自己的研究和思考提供一个很好的起点。

所以请跟我重复:

*   我们需要采用零信任安全模型
*   我们需要实施纵深防御
*   我们喜欢洋葱，每一层都应该有安全措施，即使只是粗粒度的
*   我们不能只依赖基础设施
*   我们不能只依赖“围绕”我们核心系统的安全措施
*   我们不能只依赖面向外部的 API 级控制

今天到此为止！