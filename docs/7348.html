<html>
<head>
<title>How to setup and test TLS in gRPC/gRPC-Web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在gRPC/gRPC-Web中设置和测试TLS</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-setup-and-test-tls-in-grpc-grpc-web-1b67cc4413e6?source=collection_archive---------2-----------------------#2022-08-29">https://itnext.io/how-to-setup-and-test-tls-in-grpc-grpc-web-1b67cc4413e6?source=collection_archive---------2-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ba2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文在Node中有示例。JS但是对其他语言可能会有帮助，所以我们开始吧。所有工作实例你都可以在这里找到<a class="ae kl" href="https://github.com/getezy/ezy/tree/master/__tests__/tls-service" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="d0b5" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">TLS是如何工作的？</strong></h1><p id="a76d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">推荐阅读关于<a class="ae kl" href="https://howhttps.works/" rel="noopener ugc nofollow" target="_blank">TLS如何工作</a>的最佳漫画文章。</p><h1 id="8339" class="kt ku iq bd kv kw lw ky kz la lx lc ld le ly lg lh li lz lk ll lm ma lo lp lq bi translated">gRPC连接类型</h1><p id="d40e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">您可以使用三种类型的gRPC连接:</p><ol class=""><li id="8bea" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">不安全—所有传输的数据都不加密。</li><li id="4d9d" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">服务器端TLS —类似浏览器的加密，其中只有服务器向客户端提供TLS证书。</li><li id="346b" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">相互TLS —最安全的方法是，服务器和客户端互相提供证书。</li></ol></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="f77c" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建自签名证书</h1><p id="da59" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">如果您没有来自任何CA的证书或者想要在localhost上使用TLS，这是一个可选步骤。</p><p id="c956" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mp">注意，在生产环境中大多建议选择CA的证书以获得更多的安全性，例如，您可以从</em> <a class="ae kl" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">获得一个免费证书，让我们加密</em> </a> <em class="mp">。</em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="a191" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">准备</h1><p id="3961" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">让我们从实现gRPC服务开始。</p><p id="755d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将定义我们的服务<a class="ae kl" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>文件。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6b89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，我们需要生成类型、服务和客户端定义。<br/>对于TypeScript，我更喜欢用<a class="ae kl" href="https://github.com/stephenh/ts-proto" rel="noopener ugc nofollow" target="_blank"> ts-proto </a>，但是你可以选择任何你喜欢的工具，这取决于你的语言。</p><pre class="mq mr ms mt gt mx my mz na aw nb bi"><span id="18cc" class="nc ku iq my b gy nd ne l nf ng">protoc --plugin=./node_modules/.bin/protoc-gen-ts_proto --ts_proto_opt=env=node,outputServices=grpc-js --ts_proto_out=./src/generated ./proto/tls_service.proto</span></pre><p id="58af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以实现在Node.js上运行的服务器了。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="70b6" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">gRPC</h1><p id="31ff" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们将在这里为服务器和客户端使用一个官方的<a class="ae kl" href="https://github.com/grpc/grpc-node/tree/master/packages/grpc-js" rel="noopener ugc nofollow" target="_blank"> @grpc/grpc-js </a>包。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h2 id="e3d9" class="nc ku iq bd kv nh ni dn kz nj nk dp ld jy nl nm lh kc nn no ll kg np nq lp nr bi translated">服务器端TLS</h2><p id="2eef" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">服务器端TLS只需要服务器证书及其私钥。</p><p id="4cce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">服务器</strong></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">客户端</strong></p><p id="e305" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以实现客户端了。</p><p id="754b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mp">这里注意，如果你的TLS证书是CA签名的(非自签名)，你不需要在客户端提供这个证书；它应该会自动工作。</em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h2 id="4406" class="nc ku iq bd kv nh ni dn kz nj nk dp ld jy nl nm lh kc nn no ll kg np nq lp nr bi translated">相互TLS</h2><p id="b4ed" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">相互TLS需要根证书、服务器证书及其私钥。<br/>这里将使用根证书来检查客户端证书是否已签名，以及服务器是否信任客户端。</p><p id="08e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">服务器</strong></p><p id="77e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像在服务器端部分一样，只改变了<code class="fe ns nt nu my b">getServerCredentials</code>功能。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8284" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">客户端</strong></p><p id="a66a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像在服务器端部分，只改变了<code class="fe ns nt nu my b">getChannelCredentials</code>功能。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h2 id="f25c" class="nc ku iq bd kv nh ni dn kz nj nk dp ld jy nl nm lh kc nn no ll kg np nq lp nr bi translated">覆盖SSL目标名</h2><p id="2f6e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">@grpc/grpc-js包额外提供了一些有用的<a class="ae kl" href="https://github.com/grpc/grpc-node/tree/master/packages/grpc-js#supported-channel-options" rel="noopener ugc nofollow" target="_blank">频道选项</a>供你设置。你可以在这里了解他们每个人<a class="ae kl" href="https://grpc.github.io/grpc/core/group__grpc__arg__keys.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="791f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ns nt nu my b">grpc.ssl_target_name_override</code> —当代理背后的实际服务器和CN不匹配时，这对我们很有帮助。</p><p id="217b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要设置通道选项，您需要将它们传递给客户端构造函数的第三个参数。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="96e8" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">gRPC-Web</h1><p id="371d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">阅读grpc.io关于gRPC-Web状态的博文。</p><p id="ae36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TL；<br/>博士你应该知道的事情:</p><ol class=""><li id="a655" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">工作方案:<br/>客户端↔代理【http(s)gRPC-web】↔服务器(grpc)</li><li id="34d0" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">有两个实现——<a class="ae kl" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank">官方gRPC-Web </a>和<a class="ae kl" href="https://github.com/improbable-eng/grpc-web" rel="noopener ugc nofollow" target="_blank">@ impossible-eng/gRPC-Web</a>。</li><li id="5333" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">目前，gRPC-Web只支持通过HTTP(S)的一元和服务器流请求。<br/> <em class="mp">另外</em><a class="ae kl" href="https://github.com/improbable-eng/grpc-web" rel="noopener ugc nofollow" target="_blank"><em class="mp">@ implementable-eng/grpc-web</em></a><em class="mp">通过实验性的websocket传输支持客户端和双向流。这不是gRPC-Web规范的一部分，不建议在生产中使用。</em></li><li id="d5dd" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">有两个代理——来自官方gRPC-Web的带<a class="ae kl" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_web_filter" rel="noopener ugc nofollow" target="_blank"> gRPC-Web过滤器的特使</a>和来自@ implementable-eng的<a class="ae kl" href="https://github.com/improbable-eng/grpc-web/tree/master/go/grpcwebproxy" rel="noopener ugc nofollow" target="_blank"> grpcwebproxy </a>。</li><li id="d5da" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">您可以将任一客户端与任一代理一起使用。</li><li id="0d48" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">客户端有不同的通信传输。<br/> <em class="mp">官方gRPC-web仅支持XMLHttpRequest。<br/>@ impossible-eng/grpc-web另外支持Fetch(如果可用的话使用它)并且可以用自定义传输来扩展，例如</em><a class="ae kl" href="https://github.com/improbable-eng/grpc-web/tree/master/client/grpc-web-node-http-transport" rel="noopener ugc nofollow" target="_blank"><em class="mp">node . js</em></a><em class="mp">。</em></li></ol><p id="6175" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">@ impossible-eng/grpc-web包在过去10个月没有更新，所以如果你不打算在自定义传输或Node.js环境中使用gRPC-Web，我认为你应该选择官方gRPC-Web客户端。我已经在官方包中创建了添加Node.js支持<a class="ae kl" href="https://github.com/grpc/grpc-web/issues/1277" rel="noopener ugc nofollow" target="_blank">https://github.com/grpc/grpc-web/issues/1277</a>的功能请求。</p><p id="ae8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们将使用在docker中运行的Envoy代理。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h2 id="5946" class="nc ku iq bd kv nh ni dn kz nj nk dp ld jy nl nm lh kc nn no ll kg np nq lp nr bi translated">服务器端TLS</h2><p id="4d8f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><strong class="jp ir">服务器</strong></p><p id="ea7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您已经注意到的，我们需要在代理后面启动gRPC服务。所以没有什么需要改变的，只需用我们前面讨论过的服务器端TLS启动服务。</p><p id="4708" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们需要设置特使，并启动它。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">docker-compose.yaml</figcaption></figure><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">特使服务器. yaml</figcaption></figure><pre class="mq mr ms mt gt mx my mz na aw nb bi"><span id="2c97" class="nc ku iq my b gy nd ne l nf ng">docker-compose up envoy-server</span></pre><p id="af46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。您的带有服务器端TLS的gRPC-Web代理将在<code class="fe ns nt nu my b">https://0.0.0.0:8080</code>可用。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h2 id="d20f" class="nc ku iq bd kv nh ni dn kz nj nk dp ld jy nl nm lh kc nn no ll kg np nq lp nr bi translated">相互TLS</h2><p id="2663" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><strong class="jp ir">服务器</strong></p><p id="a646" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的技巧是用<strong class="jp ir">服务器端TLS、</strong>启动gRPC服务，但是在特使端检查由可信CA签名的客户端证书。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">docker-compose.yaml</figcaption></figure><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">特使-互助. yaml</figcaption></figure><pre class="mq mr ms mt gt mx my mz na aw nb bi"><span id="9c25" class="nc ku iq my b gy nd ne l nf ng">docker-compose up envoy-mutual</span></pre><p id="a9e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！您的gRPC-Web代理将于<code class="fe ns nt nu my b">https://0.0.0.0:8080</code>提供。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="8097" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">测试gRPC和gRPC-Web请求</h1><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi nz"><img src="../Images/5c29e798d0afa7bcc51a6c49f23e37cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hx3dwDHtjMXQdWEYpxZq8Q.png"/></div></div></figure><p id="8348" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近我发布了一个叫做<code class="fe ns nt nu my b"><a class="ae kl" href="https://www.getezy.dev/" rel="noopener ugc nofollow" target="_blank">ezy</a></code>的多平台桌面gRPC / gRPC-Web客户端。我每天都在和gRPC打交道，没有功能齐全的UI/UX完美的客户端用于gRPC测试，所以我试图创建一个。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi og"><img src="../Images/01e1e9ecd15ecce9e1d7f193e9563f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DJN7kaccDd1mTjXZOLdBCQ.gif"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">试映</figcaption></figure><div class="oh oi gp gr oj ok"><a href="https://github.com/getezy/ezy" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">GitHub - getezy/ezy:桌面gRPC GUI客户端。</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">桌面gRPC客户端。🚧这个项目是在测试阶段，可以在任何时候得到突破性的变化，直到它去…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy oe ok"/></div></div></a></div><p id="c862" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个客户端完全支持gRPC / gRPC-Web。如果你试一下，我会很感激。</p><p id="9159" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🙏如果您有任何反馈或想法，请随时打开<a class="ae kl" href="https://github.com/getezy/ezy/discussions" rel="noopener ugc nofollow" target="_blank">讨论</a>。</p></div></div>    
</body>
</html>