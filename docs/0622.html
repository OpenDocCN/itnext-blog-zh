<html>
<head>
<title>AST for JavaScript developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向JavaScript开发人员的AST</h1>
<blockquote>原文：<a href="https://itnext.io/ast-for-javascript-developers-3e79aeb08343?source=collection_archive---------0-----------------------#2018-04-19">https://itnext.io/ast-for-javascript-developers-3e79aeb08343?source=collection_archive---------0-----------------------#2018-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="4717" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">TL；这篇文章是我最近在斯德哥尔摩会议上的发言。你可以在这里查看幻灯片<a class="ae kp" href="https://www.slideshare.net/BohdanLiashenko/ast-for-javascript-developers" rel="noopener ugc nofollow" target="_blank">https://www . slide share . net/bohdaniashenko/ast-for-JavaScript-developers</a></strong></p></blockquote><p id="69b2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">为什么要抽象语法树？</p><p id="d25f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果你检查任何现代项目的devDependencies，你会看到它在过去几年中增长了多少。我们在那里有各种各样的工具:JavaScript transpiling、代码精简、CSS预处理、eslint、appellister等等。这些是JavaScript模块，我们并没有将它们发布到产品中，但是它们在我们的开发过程中扮演着非常重要的角色。所有这些工具，无论如何，都是建立在AST处理之上的。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/b2a0c5a3166f123c62bc998fcc648615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wXtJkRUNEKXj7MpbAZKOw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">所有这些工具，无论如何，都是建立在AST处理之上的。</figcaption></figure><p id="b528" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我会谈到一个计划。我们从什么是AST以及如何用普通代码构建它开始。然后，我们将略微涉及一些最流行的用例以及构建在AST处理之上的工具。并且，我计划结束谈论我的项目js2流程图，它将是您在使用AST时可以构建的很好的演示。所以，和我在一起，让我们开始吧。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/4f9de79d9f656597b8f99e5b733d48ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*496HiFEm4Qyz2M6sH_gZZg.png"/></div></div></figure><p id="ece3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">什么是抽象语法树？</p><blockquote class="jn jo jp"><p id="e680" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">它是一种分层的程序表示，根据编程语言的语法来表示源代码结构，每个AST节点对应于一个源代码项。</p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/808751cd06e65fac13161b36f96a5d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRMq9F__EHGSr4vuTztSYQ.png"/></div></div></figure><p id="ae5a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">好吧。让我们看看例子。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/ed652dfe2db01705ead18d24653e3106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M06SPmEAvaMXZ5ls_p3Hxw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">很简化。</figcaption></figure><p id="fa6f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">但这是主旨。从纯文本中，我们得到了树状的数据结构。代码中的项与树中的节点匹配。</p><p id="3cbf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如何从明码中获取AST？我们知道编译器已经在这么做了。让我们检查一个普通的编译器。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/d40ddb3779aab7ad38bb6017b424e87e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*axHs9o5pHqTte5XonwcDag.png"/></div></div></figure><p id="ac8f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">幸运的是，我们不需要经历它的所有阶段，将高级语言代码转换成比特。我们只对词法和句法分析感兴趣。这两个步骤在从代码生成AST的过程中起主要作用。</p><p id="a9d4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">第一步。词法分析器，也称为扫描器，它读取字符流(我们的代码)，并使用定义的规则将它们组合成令牌。此外，它还会删除空白字符、注释等。最后，整个代码串将被分割成一个令牌列表。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/4fbdc2db61b9c160ff958a306313ff37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeBwF6uvY-o84Hp_mTfYMA.png"/></div></div></figure><p id="ec6d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">当词法分析器读取源代码时，它逐字母扫描代码；当它遇到一个空格、操作符或特殊符号时，它决定一个单词是完整的。</p><p id="1358" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">第二步。语法分析器，也称为解析器，将在词法分析后获取一个普通的标记列表，并将其转换为树表示，验证语言语法并在发生语法错误时抛出语法错误。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/6c6dfab167e130d81b209152787cb4fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHpz5dkvZUGB-DCVXI9s6g.png"/></div></div></figure><p id="8866" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在生成树的时候，一些解析器省略了不必要的标记(比如多余的括号),所以他们创建了“抽象语法树”——虽然不是100%的代码匹配，但足以知道如何处理它。另一方面，完全覆盖所有代码结构的分析器生成称为“具体语法树”的树。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/f7767b17bc3483e2e746044f2da95040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lL7HB7A5JGV8OKxiHZobQ.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">我们最后得到的。</figcaption></figure><p id="19e5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">想了解更多关于编译器的知识吗？</p><p id="0d45" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">超级小编译器。可以从这个回购开始。这是一个用JavaScript编写的编译器所有主要部分的超级简化的例子。它有大约200行实际代码，背后的想法是将Lisp编译成C语言。所有代码都包含注释和解释。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/583c7e0f8670a52b696fddea92604dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zquMqdqiNK-3hEYCxwRCpg.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated"><a class="ae kp" href="https://github.com/jamiebuilds/the-super-tiny-compiler" rel="noopener ugc nofollow" target="_blank">https://github.com/jamiebuilds/the-super-tiny-compiler</a></figcaption></figure><p id="51be" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">LangSandbox。还有一个不错的项目要检查。它说明了如何构建编程语言。有一个如何做到这一点的文章或书籍(如果你喜欢的话)的列表。所以，它走得更远了一点，因为在这里你可以编写你的语言，编译成C/字节码，然后执行，而不是把Lisp编译成C(就像上一个例子那样)。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/b983f8ceb93cf05bd8166fa76ba3edf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7dHOaSFxtAnzjl7E2ajEg.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">https://github.com/ftomassetti/LangSandbox<a class="ae kp" href="https://github.com/ftomassetti/LangSandbox" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="9b50" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我可以用图书馆吗？当然，有很多图书馆。你可以访问一个探索者，挑选一个你喜欢的。有一个live editor，您可以在其中使用AST解析器。除了JavaScript之外，它还包含许多其他语言。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/56fcdae8b6b6ed30f9c4c96f09643af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3S7f-ELTfxLu-5KnRZ8ag.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">【https://astexplorer.net/ T4】</figcaption></figure><p id="a82d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我想特别强调其中的一个，我认为是非常好的一个，叫做巴比伦。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/dde775aecc01f16358c2f001d385cef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DWHrql27LgsXbksek4lsQ.png"/></div></div></figure><p id="aeee" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">用在巴别塔里，也许是它流行的一个原因。因为它是由Babel project支持的，所以你可以预期它会一直更新新的JS特性，这是我们在过去几年中经常看到的。所以，当我们得到下一个东西，像“异步迭代”(无论什么)，这个解析器不会告诉你“意外的令牌”。此外，它有一个相当好的API，并且易于使用。</p><p id="8c27" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">好了，现在你知道如何为代码生成AST了。让我们转到现实生活中的用例。</p><p id="78af" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我想谈的第一个用例是代码转换，当然还有Babel。</p><blockquote class="jn jo jp"><p id="e794" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">Babel不是一个“支持ES6的工具”。嗯，是的，但它远不止是关于什么的。</p></blockquote><p id="46b2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">许多人将Babel与ES6/7/8特性的支持联系在一起。事实上，这也是我们经常使用它的原因。但它只是一组插件。我们也可以用它来缩小代码，进行与React相关的语法转换(比如JSX)，流插件等等。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/55c4c9e809c1a5351d2629b5e1acc1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8KqG4quFo7IKdWYgtydvZg.png"/></div></div></figure><p id="3d49" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">Babel是一个JS编译器。在高层次上，它有3个运行代码的阶段:解析、转换和生成。你给Babel一些JavaScript代码，它修改代码并重新生成新代码。它是如何修改代码的？没错。它构建AST，遍历它，基于应用的插件修改它，然后从修改后的AST生成新代码。</p><p id="e761" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">让我们在一个简单的代码示例中看到这一点。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/8301874c66958ccf972b446a6de3c022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57QRQ0PU87qsYyitLgWvUA.png"/></div></div></figure><p id="49a1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">正如我之前提到的，Babel使用Babylon，所以，我们首先解析代码，然后遍历AST并反转所有变量名。最后一步—生成代码。完成了。正如你在这里看到的，第一阶段(解析)和第三阶段(代码生成)看起来很普通，这就是你每次要做的。所以，巴别塔照顾他们，因为你唯一真正感兴趣的，是AST转换。</p><p id="905e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">当你开发Babel-plugin时，你只需描述节点“访问者”,它将改变你的AST。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/79b663962a1a826f735fe19afa9a8a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfDSQq6TpqFQG_XEjZGh4g.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">把它添加到你的Babel插件列表中，在你的webpack配置中设置babel-loader，然后我们就可以开始了。</figcaption></figure><p id="df2a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果你想了解更多关于如何构建你的第一个巴别塔插件，你可以查阅巴别塔手册。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/f3c853339491d40425f302d9c96331d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zj8X1VcUXCUatiQtx9EFVA.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated"><a class="ae kp" href="https://github.com/jamiebuilds/babel-handbook" rel="noopener ugc nofollow" target="_blank">https://github.com/jamiebuilds/babel-handbook</a></figcaption></figure><p id="c782" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">让我们继续，我想提到的下一个用例是自动化代码重构和JSCodeshift。</p><p id="308b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">比方说，你想把所有老式的匿名函数替换成短小精悍的箭头函数。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/3de2a57807796c233de6f3ac54794f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNu_lOaNK9BTlHN3yFPBiA.png"/></div></div></figure><p id="41c9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">您的代码编辑器很可能无法做到这一点，因为这不是简单的查找-替换操作。这就是jscodeshift发挥作用的地方。</p><p id="a511" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果你听到“jscodeshift ”,你很可能会把它和“codemods”放在一起听，这在第一时间会让人感到困惑。Jscodeshift是一个运行“codemods”的工具包。“codemod”是实际描述应该对AST进行什么转换的代码。所以，这个想法和巴别塔及其插件非常相似。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/7d1a30dd9cddebac6624f3549a7467e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuZw7kHwOQ9IlBLJ0Ey3Zw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">你可以看到它看起来几乎像一个巴别塔插件。</figcaption></figure><p id="d81f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">因此，如果你想创建“自动化的方法”来将你的代码库迁移到新的框架版本，这里有一条路可以走。例如，这里是react 16属性类型重构。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/27eb6b2051a00525028fb9eb0682274a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dI1a_Z26hMCtoMbei8lE-g.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">希望大家都已经迁移到16版本了；)</figcaption></figure><p id="7dbb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">尝试一下，已经创建了许多不同的代码模式，您可以通过不手动创建来节省时间。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/4611c3b7695eb7cb180736f73d43bdbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJmrwlTIU6IfcQklc4fnnA.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">https://github.com/facebook/jscodeshift<a class="ae kp" href="https://github.com/facebook/jscodeshift" rel="noopener ugc nofollow" target="_blank"/>；【https://github.com/reactjs/react-codemod T4】</figcaption></figure><p id="2aa9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我想稍微提一下的最后一个用例更漂亮，因为可能每个人都使用它的日常工作。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/ce44bb2efafdb495b7ee0d8bc48c0da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZL0SS7CsGvUrwFvyAWFWg.png"/></div></div></figure><p id="a183" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">更漂亮地格式化我们的代码。它将打破长行，清理空间，括号等。所以它将代码作为输入，并将修改后的代码作为输出返回。听起来很熟悉，对吧？没错。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/7462a30503d10f92b17dc07f94821568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Naaal2my4GVn32NHN4rMcg.png"/></div></div></figure><p id="fb6b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">想法还是一样的。首先，获取代码并生成AST。然后，更漂亮的魔术就要发生了。AST将被转换为“中间表示”或“Doc”。在高层次上，AST节点将被扩展，提供它们在格式方面如何相互关联的信息，例如，函数的参数列表应该被视为一组项目。所以如果列表很长，一行写不下，就把每个参数分成单独的一行，等等。然后，被称为“打印机”的主要算法将通过IR并基于整个图片决定如何格式化代码。</p><p id="36d7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">同样，如果你想了解漂亮印刷背后的更多理论，实际上看起来并不那么简单，有一本书可以让你深入了解。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/250a45dad66f45aae0a43477aa567fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hu-NO9PiYhtBsxwKKU_0Hg.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated"><a class="ae kp" href="http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf" rel="noopener ugc nofollow" target="_blank">http://home pages . INF . ed . AC . uk/wadler/papers/appellister/appellister . pdf</a></figcaption></figure><p id="1777" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">好了，今天我想说的最后一件事是我的库js 2 flow trade(Github上的4.2 k stars)。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/acf790b658fd3126c7de3d82b5ea207b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oO_jSxqY2ToTsCjfJjuaeQ.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">正如它的名字一样，它接受JS代码并生成SVG流程图。</figcaption></figure><p id="a2d0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这是一个很好的例子，因为它告诉你，当你有了AST代码表示，你可以做任何你想做的事情。没有必要把它放回代码串中，你可以画出它的流程图，无论你想要什么。</p><p id="e79f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">用例是什么？您可以通过流程图解释/记录您的代码，通过视觉理解学习其他代码，为任何用有效的JS语法简单描述的过程创建流程图。</p><p id="649f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">现在尝试的最简单的方法是——使用live editor。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/a510220c9f2dc12aafbfe77cc999f347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G6zWPT21CdJg93NZ6gZGZQ.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated"><a class="ae kp" href="https://bogdan-lyashenko.github.io/js-code-to-svg-flowchart/docs/live-editor/index.html" rel="noopener ugc nofollow" target="_blank">https://bogdan-lyashenko . github . io/js-code-to-SVG-flow trade/docs/live-editor/index . html</a></figcaption></figure><p id="6ae9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">试试看。此外，您可以从代码中使用它，或者，它也有CLI，所以您可以只从每个文件指向您想要生成的SVG文件。此外，还有VS代码扩展(readme中的链接)。</p><p id="31f0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">那么，它还能做什么呢？首先，除了生成所有代码的大方案之外，你还可以指定方案应该有多详细的抽象层次。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/b0acbef26e2a787b2b08b4480ee7be66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIdne4C6WqDUfFbYdDzWIA.png"/></div></div></figure><p id="faf9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这意味着，例如，你可以只画出模块输出的内容，或者只画出类定义，或者函数定义和它们的调用。然后，您可以生成一个演示文稿，其中每张幻灯片都更深入地探究细节。</p><p id="7375" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">还有一大堆方便的工具可以帮助你修改树。例如，你可以在这里看到。“forEach”方法调用，这只是方法调用，但我们可以指定它们应该被视为循环，因为我们知道forEach是一个循环，所以，让我们立即将其渲染为一个循环。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/7d3e5b36d71aa24413c3d04b3a5f27fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gVUvrPOZ7XSol-V3LJHARA.png"/></div></div></figure><p id="184e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">好吧，它是如何工作的？</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/477113a73ef01f656722825a6da58f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HnEmGPxamq2nSZVqECLycA.png"/></div></div></figure><p id="c214" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">首先，将代码解析到AST，然后，我们遍历AST并生成另一棵树，我称之为FlowTree。它省略了许多小的、不重要的标记，但是把关键块放在一起，比如函数、循环、条件等等。之后，我们遍历FlowTree并从中创建ShapesTree。ShapesTree的每个节点都包含关于其视觉类型、定位、树中的连接等信息。最后一步，我们遍历所有的形状，并为每个形状生成SVG表示，将所有形状组合成一个SVG文件。</p><p id="5a95" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">查看一下<a class="ae kp" href="https://github.com/Bogdan-Lyashenko/js-code-to-svg-flowchart" rel="noopener ugc nofollow" target="_blank">https://github . com/波格丹一世-利亚申科/js-code-to-SVG-流程图</a>。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="a3c1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果你喜欢这篇文章，并想了解我下一篇文章的更新，请在twitter上关注我<a class="ae kp" href="https://twitter.com/bliashenko" rel="noopener ugc nofollow" target="_blank"> @bliashenko </a>！</p></div></div>    
</body>
</html>