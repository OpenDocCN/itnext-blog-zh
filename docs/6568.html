<html>
<head>
<title>Beautify third-party API with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin美化第三方API</h1>
<blockquote>原文：<a href="https://itnext.io/beautify-third-party-api-kotlin-d77992847256?source=collection_archive---------6-----------------------#2021-12-19">https://itnext.io/beautify-third-party-api-kotlin-d77992847256?source=collection_archive---------6-----------------------#2021-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0037cf6d20debeef5fd66d69fdf70bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*it6QqESNMNAxxw5ffvo45g.jpeg"/></div></div></figure><p id="cda1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Scala推广了“给我的库拉皮条”的模式:</p><blockquote class="kw kx ky"><p id="50e9" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq">这只是一个花哨的表达，指的是使用隐式转换来补充库的能力。</em></p><p id="6785" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae ld" href="https://www.baeldung.com/scala/pimp-my-library-pattern" rel="noopener ugc nofollow" target="_blank"> <em class="iq">在Scala中拉皮条我的库模式</em> </a></p></blockquote><p id="0bae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">科特林确实提供了同样的能力。但是，它是通过<em class="kz">扩展函数</em>来实现的。虽然生成的字节码类似于Java的静态方法，但开发人员的体验与向现有类型添加函数是一样的。</p><p id="8965" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过，这种方法有局限性。不能更新类型层次结构。</p><p id="aff8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设一个库提供了一个具有开放/关闭生命周期的组件。组件在你实例化它时打开，但是你需要确保在使用后关闭它，<em class="kz">例如</em>，一个文件，一个流，等等。</p><p id="d6f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Java 7之前，您实际上必须显式关闭组件:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d1a6" class="ln lo iq lj b gy lp lq l lr ls">Component component;<br/>try {<br/>    component = new Component();<br/>    // Use component<br/>} finally {<br/>    component.close();<br/>}</span></pre><p id="b3e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Java 7引入了<em class="kz"> try-with-resource </em>语句，这样您就可以编写如下代码:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e4fa" class="ln lo iq lj b gy lp lq l lr ls">try (Component component = new Component()) {<br/>    // Use component<br/>}                                                // 1</span></pre><ol class=""><li id="c22c" class="lt lu iq ka b kb kc kf kg kj lv kn lw kr lx kv ly lz ma mb bi translated"><code class="fe mc md me lj b">Component</code>在生成的<code class="fe mc md me lj b">finally</code>块中关闭</li></ol><p id="ded0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，<code class="fe mc md me lj b">Component</code>必须实现<code class="fe mc md me lj b">AutoCloseable</code>。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/bc7b16595628973a2edf38fd64ec3196.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*h5kAB9yAPN3m7gYo42ZE2A.png"/></div></figure><p id="6ecd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">科特林在<code class="fe mc md me lj b">Closeable</code>上提供了<code class="fe mc md me lj b">use()</code>扩展功能。因此，我们可以用一个简单的函数调用来代替try-with-resource语句:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="90d1" class="ln lo iq lj b gy lp lq l lr ls">Component().use {<br/>  // Use component as it<br/>}                                                // 1</span></pre><ol class=""><li id="72da" class="lt lu iq ka b kb kc kf kg kj lv kn lw kr lx kv ly lz ma mb bi translated"><code class="fe mc md me lj b">Component</code>在<code class="fe mc md me lj b">finally</code>块中关闭</li></ol><p id="acbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">话虽如此，想象一下上面的库既没有实现<code class="fe mc md me lj b">Closeable</code>也没有实现<code class="fe mc md me lj b">AutoCloseable</code>。我们不能使用<code class="fe mc md me lj b">use()</code>。科特林代表团来救援了！</p><p id="3a4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">委托模式在面向对象语言中很普遍:</p><blockquote class="kw kx ky"><p id="c8b1" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq">在委托中，一个对象通过委托给第二个对象来处理一个请求(</em>委托<em class="iq">)。该委托是一个辅助对象，但是</em>具有原始上下文<em class="iq">。对于委托的语言级支持，这是通过让委托中的</em> <code class="fe mc md me lj b"><em class="iq">self</em></code> <em class="iq">引用原始(发送)对象，而不是委托(接收对象)来隐式完成的。在委托模式中，这是通过将原始对象作为方法的参数显式传递给委托来实现的。</em></p><p id="67ce" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae ld" href="https://en.wikipedia.org/wiki/Delegation_pattern" rel="noopener ugc nofollow" target="_blank"> <em class="iq">百科</em> </a></p></blockquote><p id="1d30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Java中实现委托模式需要编写大量样板代码。原始类的方法越多，就越无聊:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="dee5" class="ln lo iq lj b gy lp lq l lr ls">interface class Component {<br/>    void a();<br/>    void b();<br/>    void c();<br/>}</span><span id="b514" class="ln lo iq lj b gy mg lq l lr ls">public class CloseableComponent extends Component implements Closeable {</span><span id="06a1" class="ln lo iq lj b gy mg lq l lr ls">    private final Component component;</span><span id="3f89" class="ln lo iq lj b gy mg lq l lr ls">    public CloseableComponent(Component component) {<br/>        this.component = component;<br/>    }</span><span id="1af4" class="ln lo iq lj b gy mg lq l lr ls">    void a() { component.a(); }<br/>    void b() { component.b(); }<br/>    void c() { component.c(); }<br/>    public void close() {}<br/>}</span></pre><p id="28a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kotlin通过关键字<code class="fe mc md me lj b">by</code>支持现成的委托模式。人们可以将上面的代码重写为:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1c65" class="ln lo iq lj b gy lp lq l lr ls">interface Component {<br/>    fun a() {}<br/>    fun b() {}<br/>    fun c() {}<br/>}</span><span id="b9d4" class="ln lo iq lj b gy mg lq l lr ls">class CloseableComponent(component: Component) :<br/>           Component by component, Closeable {                  // 1<br/>    override fun close() {}<br/>}</span></pre><ol class=""><li id="4579" class="lt lu iq ka b kb kc kf kg kj lv kn lw kr lx kv ly lz ma mb bi translated">将<code class="fe mc md me lj b">a()</code>、<code class="fe mc md me lj b">b()</code>和<code class="fe mc md me lj b">c()</code>的所有呼叫委托给底层<code class="fe mc md me lj b">component</code></li></ol><p id="3da2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们终于可以写出想要的代码了:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1f6c" class="ln lo iq lj b gy lp lq l lr ls">CloseableComponent(RealComponent()).use {<br/>    // Use component as it<br/>}</span></pre><p id="4914" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更好的是，它与第三方代码一起使用，通过这种方法来改进外部库。</p><p id="57d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">锦上添花的是，还可以从一个<em class="kz"> try-with-resource </em> Java语句中调用代码:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f12e" class="ln lo iq lj b gy lp lq l lr ls">try (CloseableComponent component =<br/>                      new CloseableComponent(new RealComponent())) {<br/>    // Use component<br/>}</span></pre><p id="1e43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我上面写的，你也可以用Java来做。然而，一般来说，为了实现委托而需要编写的大量样板代码是一个很大的障碍。科特林让它变得轻而易举。</p><p id="cbca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们错过了使代码更容易编写的最后一步。我们如何得到<code class="fe mc md me lj b">CloseableComponent</code>？让我们在<code class="fe mc md me lj b">Component</code>上创建一个扩展函数:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e247" class="ln lo iq lj b gy lp lq l lr ls">fun Component.toCloseable() = CloseableComponent(this)</span></pre><p id="0818" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，用法很流畅:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1219" class="ln lo iq lj b gy lp lq l lr ls">RealComponent().toCloseable().use {<br/>    // Use component<br/>}</span></pre><p id="6bc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们看到了如何改进第三方库提供的API。我们通过结合Kotlin扩展函数和委托来实现它。</p><p id="1e77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="f535" class="lt lu iq ka b kb kc kf kg kj lv kn lw kr lx kv mh lz ma mb bi translated"><a class="ae ld" href="https://blog.frankel.ch/extending-third-party-apis/" rel="noopener ugc nofollow" target="_blank">扩展不同语言的第三方API</a></li><li id="397b" class="lt lu iq ka b kb mi kf mj kj mk kn ml kr mm kv mh lz ma mb bi translated"><a class="ae ld" href="https://kotlinlang.org/docs/extensions.html#extension-functions" rel="noopener ugc nofollow" target="_blank">扩展功能</a></li><li id="9109" class="lt lu iq ka b kb mi kf mj kj mk kn ml kr mm kv mh lz ma mb bi translated"><a class="ae ld" href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" rel="noopener ugc nofollow" target="_blank">资源尝试声明</a></li><li id="6927" class="lt lu iq ka b kb mi kf mj kj mk kn ml kr mm kv mh lz ma mb bi translated"><a class="ae ld" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html" rel="noopener ugc nofollow" target="_blank">科特林的用法</a></li><li id="4152" class="lt lu iq ka b kb mi kf mj kj mk kn ml kr mm kv mh lz ma mb bi translated"><a class="ae ld" href="https://en.wikipedia.org/wiki/Delegation_pattern" rel="noopener ugc nofollow" target="_blank">委托模式</a></li><li id="5835" class="lt lu iq ka b kb mi kf mj kj mk kn ml kr mm kv mh lz ma mb bi translated"><a class="ae ld" href="https://kotlinlang.org/docs/delegation.html" rel="noopener ugc nofollow" target="_blank">科特林的代表团</a></li></ul></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="b759" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kz">原载于</em> <a class="ae ld" href="https://blog.frankel.ch/beautify-third-party-api-kotlin/" rel="noopener ugc nofollow" target="_blank"> <em class="kz">一个Java极客</em></a><em class="kz">2021年12月19日</em></p></div></div>    
</body>
</html>