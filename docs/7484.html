<html>
<head>
<title>Protecting Applications with Kong security plugins and using StatsD to monitor system states — A healthy camera story</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kong安全插件保护应用程序并使用StatsD监控系统状态——一个健康的相机故事</h1>
<blockquote>原文：<a href="https://itnext.io/protecting-applications-with-kong-security-plugins-and-using-statsd-to-monitor-system-states-a-eb3468d47319?source=collection_archive---------0-----------------------#2022-10-07">https://itnext.io/protecting-applications-with-kong-security-plugins-and-using-statsd-to-monitor-system-states-a-eb3468d47319?source=collection_archive---------0-----------------------#2022-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c508f5170097469f70e8ba5635f16010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEnQRa9gVw6x0FKSzHWv-A.jpeg"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="3ad2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在当前开发软件时，我们都面临的一个问题是监控和检查应用程序的需要和意愿。除了使用度量来研究和调查我们的应用程序，我们还可以将它们用于其他方面，比如通知和警报。为了实现这个目标，<strong class="kk iu">孔门户</strong>提供了许多我们可以探索的免费选项。在本文中，我将尝试展示免费的<strong class="kk iu"> Kong Gateway </strong>插件的几个重要方面，这些插件可以帮助我们检测我们的<strong class="kk iu"> Java/Kotlin </strong>实现中的问题。我将尝试使用最先进和最复杂的方法来实现这两种语言的算法，以及孔可以如何帮助我们。对于本文，我们的真实生活环境是保护珍贵物品的摄像机。特别是，我们将保护一种植物。如果你不知道那是什么，这是我自己种的这种植物的照片:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/9d264dc0a58741eeadb84b3f7533177d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*mLdgbD-Zg1y0b77wbmjzxQ.jpeg"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">钝叶胡椒</figcaption></figure><p id="8cd1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">那么，为什么是孔，又为什么要努力寻找它能做什么呢？Kong框架虽然是一个付费的框架，但如果我们真的想很好地升级我们的产品(就像任何其他框架一样)，它确实允许我们在应用程序中实现很多东西，并为它提供安全性。</p><p id="ad27" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这个例子的应用程序中，我们还将看看如何用Kong轻松地保护运行中不安全的应用程序。我们将看看没有网关的情况下如何工作的例子，什么时候使用它是个好主意，什么时候它可能是一件过犹不及的事情。</p><p id="a8fe" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">但现在，我只是想漫谈一下安全性，以及为什么安全性很重要，尤其是在当前这个时代，对于几乎每个人来说，除非你根本不使用互联网，没有电子邮件，没有电话，也不用电。</p><p id="d8a8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">请注意，在你继续阅读之前，这篇文章在未来会有多次更新。支持这个的回购位于<a class="ae lt" href="https://github.com/jesperancinha/healthy-cameras" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p><h1 id="bda8" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">私人用户眼中的安全性</strong></h1><p id="9588" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi mx translated">如果我们看看今天的时代，我们生活在一个几乎不可能不谈网络安全的时代。每个人都在某种程度上受此影响。讨论最多的例子是欺诈。它可以采取许多形状或形式。我们可能会收到电子邮件，告诉我们一些关于我们的故事，承诺奖励和奖品，或者告诉我们我们有身体问题，我们需要点击一些链接以避免罚款、惩罚或其他任何事情。欺诈者无所不用其极，即使他们意识到我们注意到了，他们仍会继续使用规避技术发送电子邮件，如创建多个子域、创建带有哈希的电子邮件、发送带有6位数前缀组合的子域、使用陌生字符伪装成真实交易等。最糟糕的例子是当一个人收到一封来自真实域名的电子邮件，但它仍然只是一个骗局。也许它来自于那个组织的一个渗透者，或者也许它是一封伪装的电子邮件。不幸的是，当我们收到这种疯狂的电子邮件泛滥时，我们无法一下子就摆脱它们，因为欺诈者能够尽可能频繁地创建匿名电子邮件。我们应该继续将它们报告为网络钓鱼企图，当它们来自Gmail帐户时报告给谷歌，并阻止它们。虽然有时候，你似乎不能阻止他们，但你真的总是可以的。我收到了以上所有邮件，但也收到了没有发件人的邮件或域名前带点的邮件。然而，<strong class="kk iu">所有的邮件都有标题，在标题中</strong>，你可以找到<strong class="kk iu">大量关于邮件来源的信息</strong>。您的电子邮件提供商应该为您提供查看源邮件头的选项。在那里你会发现邮件来自哪里。清除这些邮件的一个简单方法是让你的邮件提供商使用你的<strong class="kk iu">垃圾邮件文件夹</strong>，或者<strong class="kk iu">创建重定向规则</strong>。然而，问题是，我们仍然会收到这些电子邮件，所以犯罪实体没有理由相信你永远不会对特定的电子邮件做出反应。如果你自动删除了那封邮件，你仍然没有给出任何迹象表明你明白什么是假邮件。如果你<strong class="kk iu">屏蔽了邮件</strong>或者整个<strong class="kk iu">域名</strong>，那就另当别论了。如果您的电子邮件提供商允许您阻止电子邮件，以至于它们甚至不会进入您的电子邮件收件箱，那么这也意味着犯罪实体将会收到电子邮件未送达的回复。不会有任何迹象表明你的电子邮件帐户存在，是阻止电子邮件，或其他任何事情。他们将得到的唯一数据只是他们的黑客企图没有进入你的电子邮件。你应该<strong class="kk iu">永远不要</strong>做的事情，是与发送者接触，责备发送者，或者把这些事情掌握在你自己手中。<strong class="kk iu">千万不要这样！每次你把你的挫败感发送进来，你只是在给犯罪实体提供额外的信息。务必阅读邮件头，在邮件头的发件人字段中阻止发件人发送电子邮件，并至少使用网络钓鱼选项来报告您的电子邮件。一些提供商举报犯罪邮件的级别更高。有时候，向本国或国际上负责网络安全的第三方报告也是一个好主意。我已经建立了一个回购协议，在那里我不断开发开源代码来帮助抵御这种现象。可以在<a class="ae lt" href="https://github.com/jesperancinha/jeorg-security-defense-test-drives" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</strong></p><p id="0535" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">他们会放弃吗？不幸的是，让他们放弃可能相当困难。不幸的是，网络犯罪确实在增加，为了对此做些什么，我们必须明白这是我们新生活的一部分，接受它并共同努力阻止它。</p><p id="0257" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这和这篇文章有什么关系？潜在的信息是，为了保护我们的应用程序，我们需要考虑到在最糟糕的情况下，威胁参与者可能会非常顽固，他们会进入兔子洞，用尽他们所知道的一切来达到他们的目标。</p><p id="323c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对欺诈邮件的几点建议？为了确保您阻止了正确的邮件，请查看您的邮件标题。您的提供商应该可以选择这样做，并在您查看时获得的很长的文本中查找这些标题:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="32ab" class="nk lv it lj b gy nl nm l nn no"><strong class="lj iu">From</strong>: "possibly an actual email. this could be masked one so it's not always a good idea to block whatever is put here"<br/><strong class="lj iu">To</strong>: undisclosed-recipients:;<br/><strong class="lj iu">Subject</strong>: "whatever"<br/><strong class="lj iu">Reply-To</strong>: "this is the email you should block"<br/><strong class="lj iu">Mail-Reply-To</strong>: "this is the other email you should block"<br/><strong class="lj iu">In-Reply-To</strong>: "block this one too"<br/><strong class="lj iu">References</strong>: "whatever"<br/><strong class="lj iu">Message-ID</strong>: "whatever"</span></pre><p id="0ca2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您需要知道这封电子邮件是从哪个国家和地点发送到您这里的，请查找这些邮件头:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="d550" class="nk lv it lj b gy nl nm l nn no"><strong class="lj iu">Authentication-Results</strong>: spf=pass (sender IP is "this is the IP you are looking for")</span></pre><p id="79ba" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">或者你也可以在这个标题上查找:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="dfb3" class="nk lv it lj b gy nl nm l nn no"><strong class="lj iu">X-Sender-IP</strong>: "this is the IP you are looking for"</span></pre><p id="7583" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后，您可以选择此IP并在以下位置查找:</p><div class="np nq gp gr nr ns"><a href="https://www.whatismyip.com/ip-whois-lookup/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">IP WHOIS查找</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">IP WHOIS查找确定任何IP地址的所有权信息。使用IP搜索IP WHOIS信息…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.whatismyip.com</p></div></div></div></a></div><h1 id="fe62" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">公共服务眼中的安全</h1><p id="48cd" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi mx translated">今天，有几种不同的算法可以让我们创建非常安全的应用程序访问。我们可以拥有完全基于用户名/密码组合、共享机密、令牌、最新完整性检查和第三方授权码的安全系统。此外，我们还可以使用可用于不同监控应用的标准来监控我们的应用。这意味着，一方面，我们必须负责保护我们的应用程序和网关。另一方面，我们必须确保无论何时出现安全漏洞，我们都能检测到。在这篇文章中，我们将看看这个等式的两边。</p><h1 id="6f73" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">1 —简介</h1><p id="cb73" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">我们会去看一看，就像之前提到的监测植物的情况。为此，我们有6个摄像头，或者至少6个模拟摄像头，每个摄像头都有自己的安全算法。摄像机1运行的是一种称为StatsD的公制系统。摄像机编号从1到6，它们各自的安全实现的安全算法是:基本、HMAC、JWT、ApiKey、LDAP和OAuth2。其工作方式是在Kong网关后面运行一个完全不受保护的服务。出于本文的目的，我们不打算深入研究入口控制器或其他将我们的域与外界隔离的方法。目前，我们只是使用最简单形式的孔网关。最后，我们将快速浏览一下如何使用StatsD处理数据。</p><h1 id="419f" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak"> 2 —通用概述</strong></h1><p id="7321" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">为了启动我们的系统，我们将简单地创建一个Spring Boot服务，在那里我们将提供一个欢迎消息和一个端点，该端点将简单地给出一个图像。我们展示的形象和受欢迎的终点没有受到任何保护。在这篇文章中，我们将简单地看看如何通过孔来保护它们。以下是我们为我们的案例实现的可视化表示:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/3f636378defecd101024074c6dffcab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8CR1l3Pya6l6UER-_aK-w.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">系统简图</figcaption></figure><p id="a15c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我们的系统中，我们将有6台摄像机。它们都以完全相同的方式实现。因为理解正在发生的事情很重要，所以让我们首先深入服务的后端代码。为此，我们将涵盖几个主要部分:StatsD定制指标、Rest服务实现、反应式WebSockets实现，以及最后与OAuth2相关的安全标记。</p><h1 id="a9f1" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">3.— StatsD</h1><h1 id="9a1c" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">3.1.—自定义StatsD标记</h1><p id="c69e" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">为了开始使用StatsD，我们需要了解它的基本工作原理。<strong class="kk iu"> StatsD </strong>最初由<a class="ae lt" href="https://www.etsy.com/codeascraft/measure-anything-measure-everything" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> Etsy </strong> </a>开发，用于许多需要监控应用的应用开发。许多框架都提供了标准的StatsD度量标准，通常包括发出请求所需的时间、请求负载、响应时间和请求类型。我们通常关心我们的应用程序真正的响应速度，它的容量，它的弹性，以及它的反应速度。<a class="ae lt" href="https://github.com/statsd/statsd" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> StatsD </strong> </a>的设计正是为了让我们能够使用标准来执行这些类型的测量。网上有关于它开始于2011年<strong class="kk iu">左右</strong>的记录，但很可能在那之前几年就已经在制作了。在那之后，像<strong class="kk iu">孔</strong>和<strong class="kk iu"> Datadog </strong>这样的主要竞争对手创建了插件和适配器，以便读取这些数据并以图表的形式呈现出来。这也是因为，<strong class="kk iu"> StatsD </strong>作为标准创建，也允许我们以标准方式创建<strong class="kk iu">新的</strong> <strong class="kk iu">指标</strong>。在讨论安全性之前，这也是本文的重点。<strong class="kk iu">孔</strong>为了消化<strong class="kk iu"> StatsD </strong>信息，提供了两个插件。它有一个<a class="ae lt" href="https://docs.konghq.com/hub/kong-inc/statsd/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> StatsD </strong> </a>常规插件和一个<a class="ae lt" href="https://docs.konghq.com/hub/kong-inc/statsd-advanced/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> StatsD高级</strong> </a>插件。后者用于更高级的企业应用程序。第一个是我们要看的。但在此之前，让我们看看纯粹通过<strong class="kk iu">弹簧</strong>和使用<strong class="kk iu">石墨</strong>作为服务来监听这些数据，从而使<strong class="kk iu"> StatsD </strong>成为现实的必要部分:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/585c4269a56b5ea91d48ff7ed26d6036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AaaxucqIWpNnSIPjx-3YGw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">自定义StatsD流向石墨</figcaption></figure><p id="d33b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">Graphite为其web接口打开端口8085。它不是有史以来最迷人的网页，但该服务的启动时间很长，并且不会消耗大量资源。因此它非常适合用于演示目的。流程从每个单独的摄像机开始，我们使用一个<strong class="kk iu">千分尺</strong>库以一种<strong class="kk iu"> StatsD识别的</strong>格式发送我们的<strong class="kk iu">普罗米修斯</strong>数据。我们为我们的项目选择的格式是<strong class="kk iu"> Etsy </strong>，它被<a class="ae lt" href="https://graphiteapp.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> Graphite </strong> </a>所接受。那么，我们该怎么做呢？首先，<a class="ae lt" href="https://github.com/jesperancinha/healthy-cameras" rel="noopener ugc nofollow" target="_blank">我们添加必要的库</a>:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/ff4c76630f13f1d2fcb5e4d3ffa05c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9XMlM63nzEkL3XP4Ml93w.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">StatsD必要的依赖关系</figcaption></figure><p id="c639" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这使我们能够配置SringBoot服务:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/b15b728b81b18799034e8a461737bd58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIGO2qXIiClZGNd0lUpqaQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">跳趾的StatsD配置</strong></figcaption></figure><p id="3955" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种配置中，我们说SpringBoot打开<strong class="kk iu"> Prometheus </strong>和<strong class="kk iu"> health </strong>端点。这两个非常重要。普罗米修斯端点是我们将要公开自定义指标的地方。显示<strong class="kk iu">健康细节</strong>可能很重要，因为通用<strong class="kk iu">健康</strong> <strong class="kk iu">致动器</strong>端点通常是不同健康端点的组合。在我们的例子中，我们也有数据库端点，因此，如果我们的服务没有变得健康，对正在发生的事情有一个完整的描述总是好的。此外，我们启用了<strong class="kk iu"> StatsD </strong>，这将立即允许我们的SpringBoot服务将<strong class="kk iu"> StatsD </strong>数据发送到目的地。我们在接下来的2个步骤中定义目的地，我们说<strong class="kk iu">主机</strong>是<strong class="kk iu">本地主机</strong>，而<strong class="kk iu">端口</strong>是<strong class="kk iu"> 8125 </strong>。这个端口不是我们之前看到的<strong class="kk iu"> 8085的<strong class="kk iu"> GUI </strong>端口。</strong>字段<strong class="kk iu">味道</strong>只是一种调用协议的有趣方式，我们的度量数据就是用它来发送的。有其他口味可以替代Etsy。最后，我们定义了推送到<strong class="kk iu"> Graphite </strong>的频率以及对我们已经实现的任何计量器的轮询周期。如果任何一个仪表显示的数值与之前的读数不同，StatsD输出器将再次将所有数据发送回<strong class="kk iu">石墨</strong>。</p><p id="af31" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们已经配置好了一切，我们可以看看<a class="ae lt" href="https://github.com/jesperancinha/healthy-cameras" rel="noopener ugc nofollow" target="_blank">代码</a>:</p><pre class="ll lm ln lo gt ng lj of bn og oh bi"><span id="336f" class="oi lv it lj b be oj ok l ol no">@Configuration<br/>class MetricsConfiguration(<br/>    val cameraService: CameraService,<br/>    @Value("\${hc.camera.number}")<br/>    val cameraNumber: Long,<br/>) {<br/>    private val last10FileDeltaNSReading: MutableList&lt;Double&gt; = mutableListOf()<br/><br/>    /**<br/>     * You should see all fails happening every 10 seconds if your polling rate is every 10 seconds<br/>     * For every 10 seconds you'll get all fails in that period<br/>     */<br/>    @Bean<br/>    @Qualifier("counterMetric")<br/>    fun counterMetric(meterRegistry: MeterRegistry) = Counter.builder("camera.fail.count")<br/>        .tag("type", "fail_count")<br/>        .description("The number of anomalies detected by the camera")<br/>        .register(meterRegistry)<br/><br/>    /**<br/>     * You should see all fails happening every 10 seconds if your polling rate is every 10 seconds<br/>     * For every 10 seconds you'll get all heartbeats in the period<br/>     */<br/>    @Bean<br/>    @Qualifier("heartBeats")<br/>    fun heartBeatCounter(meterRegistry: MeterRegistry) = Counter.builder("camera.heartbeats")<br/>        .tag("type", "heart_beats")<br/>        .description("The number of heartbeats measured per time and counts 1 per second")<br/>        .baseUnit("beats")<br/>        .register(meterRegistry)<br/><br/>    /**<br/>     * Measures the time it takes to read an image.<br/>     * This is purely to illustrate how can we inject our own custom metrics in StatsD.<br/>     */<br/>    @Bean<br/>    fun gaugeMetric(meterRegistry: MeterRegistry) =<br/>        Gauge.builder("camera.image.read.time", last10FileDeltaNSReading)<br/>        { last10Records -&gt;<br/>            logger.debug("$last10FileDeltaNSReading")<br/>            measureNanoTime { runBlocking { cameraService.getImageByteArrayByCameraNumber(cameraNumber) } }.toDouble()<br/>                .let { record -&gt;<br/>                    last10Records.add(record)<br/>                    if (last10Records.size == 11) {<br/>                        last10Records.removeFirst()<br/>                    }<br/>                    logger.info("Refreshed ${last10Records.size} metrics. Last value read is ${last10Records.last()} ns")<br/>                    record<br/>                }<br/>        }<br/>            .tag("type", "image_read_ns")<br/>            .description("Time to read one image from camera in ns")<br/>            .baseUnit("ns")<br/>            .register(meterRegistry)<br/><br/>}</span></pre><p id="7260" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于这种情况，我们正在创建一个名为<code class="fe lg lh li lj b"><strong class="kk iu">counterMetric</strong></code> <strong class="kk iu"> </strong>的类型为<code class="fe lg lh li lj b"><strong class="kk iu">Counter</strong></code>的bean。这种类型的指标的功能是简单地统计某个事件的发生次数。我们可以通过编程来实现这一点，稍后我们将看到这是如何发生的。现在，我们只需要记住，bean <code class="fe lg lh li lj b"><strong class="kk iu">counterMetric</strong></code> <strong class="kk iu"> </strong>和bean <code class="fe lg lh li lj b"><strong class="kk iu">heartBeatCounter</strong></code> <strong class="kk iu"> </strong>将分别计算访问具有错误范围的<strong class="kk iu"> OAuth </strong>端点的失败尝试次数，另一个将计算每<strong class="kk iu">秒</strong>的1次<strong class="kk iu">心跳</strong>。最后，纯粹因为我们想以自己的方式制作一个奇怪的度量，我们创建了一个<code class="fe lg lh li lj b"><strong class="kk iu">gaugeMetric</strong></code>类型<code class="fe lg lh li lj b"><strong class="kk iu">Gauge</strong></code> <strong class="kk iu">。这个计量器只会读取从相机读取图像所需的时间。<code class="fe lg lh li lj b"><strong class="kk iu">Gauge</strong></code>是一种度量标准，与计数器不同，它测量在某个时间点读取的实际值。在这一点上，重要的是要意识到一个计量器<strong class="kk iu">在我们定义的特定点处理</strong>信息。我们将通过编程来实现这一点。因此，为了更好地说明<strong class="kk iu">计数器</strong>和<strong class="kk iu">仪表</strong>之间的区别，我们可以说计数器测量读数之间事件发生的次数。因此，在我们的具体例子中，我们将记录每秒10次心跳。我们的<strong class="kk iu">计数器</strong>只知道每秒钟计数加1。然而，当将该信息发送到<strong class="kk iu"> Graphite，</strong>时，它将记录从最后一点开始计数的次数，或者如果没有读数，则记录到该点为止的次数。因此，如果在graphite中每10秒处理一次数据，我们将每10秒得到10个读数。每两分钟发送一次数据并不能改变这一点。<strong class="kk iu">仪表，</strong>则记录该场合的特定值。这是通过将数据保存在列表<strong class="kk iu">中来实现的。然而，这个列表在向<strong class="kk iu"> StatsD </strong>发送数据的过程中并没有真正发挥作用。相反，如果我们想使用一个公共对象来共享读数之间的数据，它就在那里。它的工作方式更像一个<strong class="kk iu">豆</strong>，我们可以插入任何我们想插入的东西，或者用它做任何我们想做的事情。我们传入的函数的结果对我们的<strong class="kk iu">量规</strong>度量很重要。让我们放大一下:</strong></strong></p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/db4eb9e76f3ca836abdb1b44b9fd9d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUU9bUXjhd-14MlaEughKw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">负责<strong class="bd lw">的函数测量</strong>读取一个相机文件需要多长时间</figcaption></figure><p id="9717" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因此，在我们函数的接收器中，我们得到了一个<strong class="kk iu"> last10Records </strong>对象，我们已经将它制作成了一个列表。然后我们测量读取一台相机需要多长时间。在这种情况下，我们必须以一种阻塞的方式来完成，纯粹是因为我们不在协程上下文中，而且我们想知道读取图像需要多长时间。如果我们通过类似于<strong class="kk iu"> GlobalScope.launch </strong>的其他方式来做，我们将不会对读取图像所花费的时间有一个真实的想法，因为这样一来，协程将在线程之间展开，并且不可能对读取图像时会有多糟糕有一个真实的想法。我们将<strong class="kk iu">记录</strong>测量添加到10个记录的列表中，并确保我们总是保留最后10个记录。</p><p id="94db" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们已经有了度量标准，我们需要看看计数器是如何工作的，以及我们在哪里触发度量。我们先来看看类<strong class="kk iu">CameraServiceApplication</strong>:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/4072ab1f77a1736b1fc2fe4ec437db2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NsfiLQyiyUSKcSdL_UYlvw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">心跳发送</strong></figcaption></figure><p id="d38e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这里需要理解的重要一点是，我们使用一个Spring调度程序来调用心跳计数器的递增函数。</p><p id="5a06" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">所以现在我们知道<strong class="kk iu">心跳</strong>计数器和<strong class="kk iu">度量</strong>发生了什么。那么失败计数器呢？这位于服务级别。在我们的端点，我们需要保护我们的入口点，我们这样做:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/64886c84eca8f0cb23e7eddc4f728181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9_X9VR-uAGZPCxsUTUkUQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">受保护的OAuth端点</strong></figcaption></figure><p id="9092" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这里我们使用<strong class="kk iu">预授权</strong>注释来表示一个<strong class="kk iu">表达式语言(EL) </strong>条件，以验证我们可以进行rest调用。这些注释在应用程序运行类中被激活:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/fbc66b6988a18dbd02e69cd04c37e4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcllLfJuBnGP1RqOUyzeVA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">激活预授权注释</strong></figcaption></figure><p id="1baf" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">所以回到我们的方法，我们看到它们都使用了一个叫做<code class="fe lg lh li lj b"><strong class="kk iu">securityService</strong></code>的组件。本质上，这是一个组件，也是一个<strong class="kk iu">服务</strong>，我们只是简单地调用一个名为<strong class="kk iu">check&lt;scope&gt;Header</strong>的方法。在这个方法中，我们检查标题是否与我们的<strong class="kk iu">范围</strong>预期相匹配，然后在内部让我们的计数器增加1个单位:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/cc931d9b930d10d1487db077c032a959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00morpH8KvK3tIsfAh7HCA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">在范围验证失败时触发计数器计数</strong></figcaption></figure><p id="3dcb" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们将进一步了解<strong class="kk iu">仪表</strong>是累积的，但目前这是我们需要了解的关于可能的定制StatsD配置的所有基本信息。</p><h1 id="9160" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">3.2.— StatsD via Kong</h1><p id="32a0" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi mx translated"><span class="l my mz na bm nb nc nd ne nf di"> C </span>定制标签是向<strong class="kk iu"> Graphite </strong>发送指标的好方法，使用<code class="fe lg lh li lj b"><strong class="kk iu">micrometer</strong></code>作为触发机制非常容易。然而，在大多数情况下，正如我之前提到的，我们并不真的需要手动或者定制的指标。这就是<strong class="kk iu"> StatsD </strong>变得如此重要的原因。<strong class="kk iu">孔</strong>用标准<strong class="kk iu"> StatsD </strong>插件提供了许多功能。让我们来看看它是如何工作的。我们将使用<strong class="kk iu"> deck </strong>容器使<strong class="kk iu"> Kong </strong>更新成为可能。在这篇文章的后面，我们将研究<strong class="kk iu"> deck </strong>容器的细节。现在，让我们记住<strong class="kk iu"> deck </strong>容器允许重新加载和更新我们的<strong class="kk iu"> konh.yml </strong>文件。我们将只配置<strong class="kk iu"> StatsD </strong>与<strong class="kk iu">摄像机1 </strong>一起工作。我们首先需要配置一条路由:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/b5d630a694c9f38c98b3c46e6442b61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_RJt6P0AyjJbufsysjfZw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机-1-服务的YAML片段</strong></figcaption></figure><p id="420d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">所以这仅仅意味着我们将能够访问在主机<strong class="kk iu"> camera-1-service </strong>上本地运行的服务，在端口<strong class="kk iu"> 8080 </strong>上，路径为<code class="fe lg lh li lj b"><strong class="kk iu">/api/v1/hc</strong></code>。然后通过路径<code class="fe lg lh li lj b"><strong class="kk iu">/camera-1-service/api/v1/hc</strong>.</code>上的端口<strong class="kk iu"> 8000 ( </strong>孔网关端口)访问该位置，这确保了当我们试图访问我们的<strong class="kk iu">摄像机-1-服务</strong>时，我们将总是必须通过<strong class="kk iu">孔</strong>网关。这种机制与简单的代理没有太大区别。然而，因为<strong class="kk iu">孔</strong>是一个网关平台，它是高度可管理的，我们可以实时做出改变。我们可以做的事情之一是直接添加<strong class="kk iu"> StatsD </strong>插件:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/58f160d0a96dc38b6e021c943da3fce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*DeJN-brGt-tTuIgeWFZHQQ.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">配置StatsD插件向Graphite发送数据的YAML代码片段</strong></figcaption></figure><p id="ebd0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种情况下，我们使用现成的指标。<strong class="kk iu">请求_计数</strong>、请求_大小<strong class="kk iu">、</strong>以及最后的<strong class="kk iu">响应_大小</strong>。数据将每秒发送到<strong class="kk iu">石墨</strong>。正如我们之前看到的，这相当于轮询间隔，其工作方式完全相同。</p><h1 id="e3f5" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak"> 4。—常见相机功能</strong></h1><p id="da6e" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">正如我之前提到的，所有摄像机都将从同一个部署包开始。它们具有共同的功能和特定于某些协议的其他功能。现在，让我们来看看我们所有相机可以使用的功能。</p><h1 id="4807" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak"> 4.1。—欢迎信息</strong></h1><p id="a524" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">欢迎信息只是一个文本，对于测试我们将要看的内容是有用的。它就像一个<strong class="kk iu">得到</strong>端点一样简单:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi or"><img src="../Images/604b1cb35325ed3e3ce20f13fbb35f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QdBThX1ohio0BvuW9JmR3A.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">通用欢迎信息</figcaption></figure><p id="0932" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">旁边是负责检索给定时间的摄像机图像的端点:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi os"><img src="../Images/35a8cefd572574d77465e8446f16da1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxFRzKadtLVsVUJzD30j3w.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">相机端点</figcaption></figure><p id="87b0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">及其在这里的实现:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ot"><img src="../Images/40d9af7f5e90a90fb765534b4df36b31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06a3IHTDBTOQkJyV15dlSw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机图像检索实现</strong></figcaption></figure><p id="77fb" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">一般来说，一旦我们被认证，我们就可以得到一个时间点的图像。由于这个练习只是一个模拟，我们将根据<strong class="kk iu">10</strong>T10】秒的匹配分数得到一个新的图像。这样我们在刷新前端页面的时候就有一种运动的感觉。</p><p id="944a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">无论用户是否通过身份验证，前端都将连接到后端。在这里，我们将向前端实时发送状态数据。这将通过<strong class="kk iu"> Websockets </strong>完成:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/75d7e1edb6152bdcd52db5f34102f0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvEzvnbrTTiUO9bsArJC7A.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">汇聚流向前端发送实时数据，显示摄像机状态</strong></figcaption></figure><h1 id="27bc" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">5.—身份验证协议</h1><h1 id="5455" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">5.1.—基本身份验证</h1><p id="ed59" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">在我们将要讨论的所有6种访问摄像机的协议中，这可能是最不安全的一种。下图显示了消息流的工作方式。</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ou"><img src="../Images/457f3fbf64f603a88970dec581ff5573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55i_t-1uIuxmIHA5EIS1oA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机1序列图</strong></figcaption></figure><p id="5c49" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在任何情况下，我们都知道我们的相机最初没有受到保护，并且出于某种奇怪的原因，我们希望通过简单的用户名和密码实现最简单，当然也是最不安全的访问方式。如果您的命令行包含<strong class="kk iu"> base64 </strong>命令，我们已经可以尝试做一个简单的测试了。假设我是用户<strong class="kk iu">露西</strong>，我的密码是<code class="fe lg lh li lj b"><strong class="kk iu">winkelallemaal</strong></code>。我们还假设这个凭证已经被配置为在系统中工作。有了基本的auth，我们所要做的就是将<code class="fe lg lh li lj b"><strong class="kk iu">Lucy:winkelallemaal</strong></code>和你的请求一起发送到服务器。但是，我们不会空白发送。我们使用的是它的<strong class="kk iu"> base64 </strong>编码版本。这将通过命令行以下列方式完成:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="3745" class="nk lv it lj b gy nl nm l nn no"><strong class="lj iu">echo ‘Lucy:winkelallemaal’ | base64</strong></span></pre><p id="9019" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">结果将是这样的:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="95a6" class="nk lv it lj b gy nl nm l nn no"><strong class="lj iu">THVjeTp3aW5rZWxhbGxlbWFhbAo=</strong></span></pre><p id="1b60" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">所以现在这看起来像一些加密的东西，我们通过<strong class="kk iu">授权</strong>头中的线路发送它:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="c9fd" class="nk lv it lj b gy nl nm l nn no">Authorization: basic <strong class="lj iu">THVjeTp3aW5rZWxhbGxlbWFhbAo=</strong></span></pre><p id="2dbc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">当出于这样或那样的原因，有人获取令牌时，这个安全协议就会出现问题。在这种情况下，一个简单的解码操作就可以检索用户名和密码:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="6844" class="nk lv it lj b gy nl nm l nn no">echo <strong class="lj iu">THVjeTp3aW5rZWxhbGxlbWFhbAo= </strong>| base64 — decode</span></pre><p id="0b99" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">结果将会是:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="eb8e" class="nk lv it lj b gy nl nm l nn no"><strong class="lj iu">Lucy:winkelallemaal</strong></span></pre><p id="2e2d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">但是当然，我们想知道这是如何与<strong class="kk iu">孔</strong>一起工作的，这实际上是学习至少这6个安全协议的存在的一个很好的开始。</p><p id="f2fa" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我们的<code class="fe lg lh li lj b"><strong class="kk iu">Kong.yaml</strong></code>文件中，我们需要将路线添加到我们的<strong class="kk iu"> camera-1-service </strong>中，并创建一个与之相关的插件。对于路径，我们可以使用以下内容:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ov"><img src="../Images/07a993f29908c6708a803bcb610c29ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*leqcD1Hp1L6F5kGGwSXKMQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像头1服务孔路由</strong></figcaption></figure><p id="1e2a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于摄像机1，我们定义了3条路线。第一种是<strong class="kk iu">相机特有的</strong>1<strong class="kk iu">1</strong>。另外两条是我们将为所有摄像机复制的路线。我们将保护路线1，因为在那里我们将获得相机信息和当前图像。另外两条路线是<strong class="kk iu">致动器</strong>和<strong class="kk iu">套筒</strong>路线。重要的是，它们保持开放和不受保护，以便我们可以实时检查摄像机的状态。</p><p id="8ecb" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了保护第一条路由，我们为基本身份验证创建了一个插件配置:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/4e658b6711b88619598da5611e5cc789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*U9B03WIq-5RwcGUXqxMANg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机1对</strong>的基本认证</figcaption></figure><p id="c65d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">当我们创建这个时，我们已经保护了我们的路由，但是我们仍然没有任何用户。为了进行配置，我们可以简单地运行几个命令，这些命令可以通过GUI运行，或者在我们的例子中，通过<code class="fe lg lh li lj b"><strong class="kk iu">cUrl</strong></code>命令运行:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="5887" class="nk lv it lj b gy nl nm l nn no">curl -d "username=camera1&amp;custom_id=CC1" http://127.0.0.1:8001/consumers/<br/>curl -X POST http://127.0.0.1:8001/consumers/camera1/basic-auth \<br/>  --data "username=cameraUser1" \<br/>  --data "password=administrator"</span></pre><p id="5096" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在第一个命令中，我们创建了一个消费者。在第二个示例中，我们为同一个用户定义了用户名和密码。</p><p id="3452" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这是用这个插件配置基本身份验证的简单方法。</p><h1 id="a69d" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">5.2.— HMAC</h1><p id="8871" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated"><strong class="kk iu"> HMAC </strong>是一种基于位置、时间戳、秘密和协议选择的非凡算法。通过HMAC发送数据非常简单，如下图所示:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/103d1c652801acbdbf0e00f388a5d182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxWBOuHQoqcGI00YgmtOnw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机2序列图</strong></figcaption></figure><p id="4f34" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们可以看到，它遵循与基本Auth协议完全相同的流程。但是，它的令牌不可能被解密。它是以一种方式创建的，此外，它还取决于生成它的位置以及为其专门生成的路径。这意味着如果黑客获得了<strong class="kk iu"> HMAC </strong>令牌，他们将无法在任何地方使用它，即使它是一个有效的令牌。在两端使用相同的秘密或私有密钥是一个被称为<strong class="kk iu">对称密钥加密的概念。</strong>这种算法常用于<strong class="kk iu"/><strong class="kk iu">(机器对机器)</strong>连接和文件传输。其思想是以一种安全的方式认证和授权各方之间的数据传输。越复杂的<strong class="kk iu">秘密</strong>就越难猜到我们用的是哪一个。正如我们之前看到的，这就是为什么在某些情况下，我们使用<strong class="kk iu"> PEM </strong>私钥。不过，对于我们的例子，为了尽量不使用<strong class="kk iu"> HMAC </strong>，我们将只使用<code class="fe lg lh li lj b"><strong class="kk iu">dragon</strong></code> <strong class="kk iu"> </strong>作为我们的秘密。</p><p id="6e22" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了使这个配置在<strong class="kk iu">孔</strong>我们首先像往常一样需要创建路线。在这种情况下，让我们看看<strong class="kk iu">摄像机2的路线</strong>:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/fd1ef7c9ef4283775164b7710bd77104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raW7bd11KJsEPeisMfVAWw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机2路线</strong></figcaption></figure><p id="44dc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在让我们用HMAC来保护它:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/227e86d1b01f27a55bd2c5a6cd9a3c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*szEDCCfEuFPXWQUCgxyhnw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像头2 HMAC插件配置</strong></figcaption></figure><p id="c758" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">使用这种配置，我们可以保护摄像机2，但目前无法访问它。为了使其可访问，我们需要发出几个命令:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="1c51" class="nk lv it lj b gy nl nm l nn no">curl -d "username=camera2&amp;custom_id=CC2" http://127.0.0.1:8001/consumers/<br/>curl -X POST http://127.0.0.1:8001/consumers/camera2/hmac-auth \<br/>  --data "username=cameraUser2" \<br/>  --data "secret=dragon"</span></pre><p id="9358" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于这种情况，我们还需要一个消费者。在这种情况下，我们还为它创建了一个<strong class="kk iu">用户名</strong>，但是我们没有创建<strong class="kk iu">密码</strong>，而是创建了一个<strong class="kk iu">密码</strong></p><p id="2179" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们还没有看到算法到底是如何工作的，但这也不是本文的目的。这篇文章的真正目的是向你展示我们需要什么样的变量来创建一个最低可接受的HMAC令牌。为此，最好是使用<strong class="kk iu"> crypto </strong>创建算法:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/94780a0b82cebe101d9e637739c9cf87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kh-Gpep_vXeSjY7LBFbZrQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw"> HMAC </strong>头文件创建函数的类型脚本实现</figcaption></figure><p id="063c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">让我们大致了解一下我们在这里的意图。当我们试图连接到摄像机2时，我们需要创建一个<strong class="kk iu"> HMAC </strong>令牌。为此，我们传入我们试图访问的路径和我们希望用来执行请求的方法。这些只是这个项目中的<strong class="kk iu"> GET </strong>请求，但是它们可以应用于任何方法。我们首先初始化对我们的算法很重要的变量:<strong class="kk iu">用户名、密码、算法和当前日期</strong>。在我们的<strong class="kk iu"> HMAC </strong>头中，我们需要包含一个<strong class="kk iu">摘要头。通过提供由“<strong class="kk iu"> SHA=256=base64Hash </strong>”组成的文本来创建该<strong class="kk iu">头</strong>。现在，我们只需要知道这是算法工作所需要的。</strong></p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/1d3a34f3081aaa291fe50b484cde7068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iJJ0_R1Uvq6btZgNX4g2w.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">关于HMAC如何工作的摘要</strong></figcaption></figure><p id="ae3c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因此，对于HMAC算法的这个实现，我们需要4个基本元素在我们的头中。<strong class="kk iu">摘要</strong>，它包含关于我们正在使用的算法的加密信息，<strong class="kk iu">授权</strong>，它是一个包含不同元素的加密字符串，<strong class="kk iu">当前日期，</strong>，最后是一个<strong class="kk iu">内容类型</strong>头，它决定了我们将要通过网络发送的内容的类型。所有四个标题都非常重要，但最广泛的一个是<strong class="kk iu">授权</strong>，其形式如下:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="eb22" class="nk lv it lj b gy nl nm l nn no"><strong class="lj iu">Authorization</strong> : <strong class="lj iu">hmac</strong> <strong class="lj iu">username</strong>="<strong class="lj iu">cameraUser2</strong>",<strong class="lj iu">algorithm</strong>="<strong class="lj iu">hmac-sha256</strong><strong class="lj iu">"</strong>,<strong class="lj iu">headers</strong>="<strong class="lj iu">x-date request-line digest</strong>",<strong class="lj iu">signature</strong>="<strong class="lj iu">&lt;signature&gt;</strong>"</span></pre><p id="3cf4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">以这种方式通过网络发送请求意味着每个请求都可以用一个新的<strong class="kk iu"> HMAC </strong>头发送。关键是，既然我们能做到，为什么不呢？<strong class="kk iu"> HMAC </strong>可以是一个重算法过程。我们牺牲性能来获得最佳的安全性。</p><p id="7b0f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于这款相机，我们仅仅触及了HMAC工作原理的表面。我们只发出get请求，它们都没有要加密的有效负载。尽管<strong class="kk iu"> HMAC </strong>是专门为保护出站数据而设计的，但我们在本文中的目标只是对其进行配置并了解一点它是如何工作的。</p><h1 id="9017" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">5.3.— JWT</h1><p id="1123" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">JWT令牌通常被创建为用户可以添加到他们的请求中的令牌，以便对某些方法的使用进行身份验证和授权。jwt可以按照我们想要的方式创建。它依赖于非对称密钥加密的原理。加密发生在签名级别。通常在JWT我们只需要一个代币。令牌可能有到期日期，它包含有关登录用户和用户权限的各种信息。一个<strong class="kk iu"> JWT </strong>令牌，很像基本的认证，并没有隐藏太多。如果请求带有无效的令牌，它就会失效。一个<strong class="kk iu"> JWT </strong>令牌由一个报头、一个有效载荷和一个签名组成。报头和有效载荷采用<strong class="kk iu"> base64 </strong>编码，而<strong class="kk iu">签名</strong>是<strong class="kk iu">报头</strong>和<strong class="kk iu">有效载荷</strong>的函数。在这个函数中，我们使用一个<strong class="kk iu">私有</strong>密钥来签署我们的令牌。如果签名不正确，那么我们的应用程序将拒绝它。令牌的验证需要一个<strong class="kk iu">公共</strong>密钥。该过程不需要密码，尽管可以使用密码来请求新的<strong class="kk iu"> JWT </strong>令牌。本质上，它是这样工作的:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oy"><img src="../Images/1e0cc131ab7e7d76535b6734fffedc73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUX66c8sVtr_4yyn7v5UAw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">JWT令牌的非对称签名加密</strong></figcaption></figure><p id="2fa6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">使用<strong class="kk iu">孔</strong>插件，我们可以实现这个工作流程:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oz"><img src="../Images/6b1d48a40476d48e02b0cb50cfbffb53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fB_SXLUir38iC7r2WVsSog.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机3序列图</strong></figcaption></figure><p id="374b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这是一个非常简单的工作流程，我们向<strong class="kk iu"> Kong </strong> <strong class="kk iu"> Gateway </strong>发出请求，只需添加一个这样的令牌:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="a383" class="nk lv it lj b gy nl nm l nn no">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuU0Q3WlNxU3dTeDIwN3ZSNVh4aW9jVFVaaHNCMlF4ViIsImV4cGlyZXNJbiI6IjEyaCIsImFsZ29yaXRobSI6IkhTMjU2In0.R4S8yV_CPJRvJ2dAX_56HfNUZrbKr7Jt4AxEmsqqx8w</span></pre><p id="354a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">稍后，我们将在我们的应用程序中看到<strong class="kk iu">孔</strong>如何以及何时可以将这些代币返还给我们。现在，让我们看看<a class="ae lt" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> JWT.io </strong> </a>，看看破译这个令牌能告诉我们什么:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pa"><img src="../Images/1e9de1144e6e6e36352979d2bca8fd8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CorJtmCV6FYwl4QqDN2xxA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">一孔JWT令牌已破译但未验证</strong></figcaption></figure><p id="291e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果你是这些对红色信息非常敏感的人之一，当检查这个令牌时，你可能首先意识到的是<a class="ae lt" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> JWT。IO </strong> </a>，是在告诉我们令牌无效。我们没有将签名插入到<strong class="kk iu">验证签名</strong>框中。因为我们没有给JWT.io 一个能够验证的秘密，它只是说这个令牌是无效的。但是让我们看看<strong class="kk iu">割台</strong>和<strong class="kk iu">有效载荷</strong>。我们能够破译这两个，原因是它们只是被加密了。让我们来破译这个。至此，您已经看到了它是如何工作的。我们只发出几个命令:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="8496" class="nk lv it lj b gy nl nm l nn no">echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 --decode</span></pre><p id="f4a9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">结果是:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="962f" class="nk lv it lj b gy nl nm l nn no">{“alg”:”HS256",”typ”:”JWT”}</span></pre><p id="3eb5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这说明这是一个基本的<strong class="kk iu"> JWT </strong>令牌，用<strong class="kk iu">算法HS256 </strong>实现，用于验证我们正在发送的签名。</p><p id="4814" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在让我们检查一下尸体:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="929b" class="nk lv it lj b gy nl nm l nn no">echo “eyJpc3MiOiJuU0Q3WlNxU3dTeDIwN3ZSNVh4aW9jVFVaaHNCMlF4ViIsImV4cGlyZXNJbiI6IjEyaCIsImFsZ29yaXRobSI6IkhTMjU2In0” | base64 --decode</span></pre><p id="67bd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">结果是:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="c874" class="nk lv it lj b gy nl nm l nn no">{"iss":"nSD7ZSqSwSx207vR5XxiocTUZhsB2QxV","expiresIn":"12h","algorithm":"HS256"}</span></pre><p id="a675" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><strong class="kk iu"> Iss </strong>是发行人。这个问题可以指定，如果我们不指定，<strong class="kk iu">孔</strong>会随机给我们一个。虽然不受保护，但是<strong class="kk iu">发布者</strong>是签名的重要组成部分。每当我们要求一个JWT，一个新的秘密就产生了。这次跑步的秘密是:<code class="fe lg lh li lj b">xwRs1oR22OhzBeq2hWH4NnIxdF5Jr6jv</code>。如果我们把它输入JWT。IO 我们将能够得到验证，我们在有效载荷和请求中提供的任何操作都将被允许通过安全检查。如果当时授权允许或进一步操作无关紧要。我们已经能够到达系统，但是只能在我们在有效载荷中指定的条件下:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pb"><img src="../Images/81a0c2a6412bf884881654aea7bc7653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dumbfpvwot6wevhqU08EiA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">一孔JWT令牌破译验证</strong></figcaption></figure><p id="8811" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这里的秘密是<strong class="kk iu">密钥</strong>，它永远不会被共享。这就是我们通过<strong class="kk iu"> JWT验证请求的方式。IO </strong>。但是当然，这里我们拥有私钥。在<strong class="kk iu">孔</strong>端的算法，仅用其<strong class="kk iu">公共</strong>密钥验证请求是否有效。</p><p id="718c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了在<strong class="kk iu">孔</strong>中进行配置，我们需要首先配置我们的路线:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/a4c118b3f525026ebaf7b964612904fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xz6m2e8-EtibjiSg608ubA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">3号摄像机路线</strong></figcaption></figure><p id="c2e8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后只需配置插件:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/19fdbd7b2f6e13cd4e0a9e7e89b13082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*zmxkfug2zjVKPGhZXtWyOA.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">启用摄像机3服务的JWT</strong></figcaption></figure><p id="8adc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">一旦在摄像机3运行的情况下启用服务，我们就可以请求我们的<strong class="kk iu"> JWT </strong>令牌参数:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="a30c" class="nk lv it lj b gy nl nm l nn no">curl -d "username=camera3&amp;custom_id=CC3" http://127.0.0.1:8001/consumers/<br/>curl -X POST http://127.0.0.1:8001/consumers/camera3/jwt -H "Content-Type: application/x-www-form-urlencoded"<br/>curl -X GET http://127.0.0.1:8001/consumers/camera3/jwt &gt; ../e2e/cypress/fixtures/CC3KongToken.json</span></pre><p id="b2d5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这些命令创建了一个名为<strong class="kk iu"> camera3 </strong>的消费者。然后，我们用<strong class="kk iu"> POST </strong>请求生成令牌。为了能够在网站中使用令牌，我创建了一个名为<strong class="kk iu"> CC3KongToken.json </strong>的文件，在这里我们可以找到<strong class="kk iu">发布者</strong>和<strong class="kk iu">秘密。</strong>后者也是我们所说的<strong class="kk iu">私有</strong>密钥。它被称为<strong class="kk iu"> private </strong>，因为它不是共享的。如果另一台摄像机配置了相同的<strong class="kk iu">公共</strong>密钥，它将接受具有相同令牌的请求。</p><p id="5f5c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果我们执行最后一个<strong class="kk iu"> GET </strong>请求，我们将得到与这个类似的回答:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="936f" class="nk lv it lj b gy nl nm l nn no">{<br/>  "data": [<br/>    {<br/>      "tags": null,<br/>      "rsa_public_key": null,<br/>      "consumer": {<br/>        "id": "137558e2-bcc0–4fc4-a423–33a37e2d9f6e"<br/>      },<br/>      "key": "nSD7ZSqSwSx207vR5XxiocTUZhsB2QxV",<br/>      "created_at": 1665153305,<br/>      "algorithm": "HS256",<br/>      "id": "9d6febc6–2602–42ae-a2b2–4ec3924e7bce",<br/>      "secret": "xwRs1oR22OhzBeq2hWH4NnIxdF5Jr6jv"<br/>    }<br/>  ],<br/>  "next": null<br/>}</span></pre><p id="e033" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了获得<strong class="kk iu"> JWT </strong>令牌，我们手动完成，我们在<strong class="kk iu">类型脚本</strong>代码中有一个这样的例子。我们首先对令牌进行编码:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/1064fff318d8da59e16bacc0f8e830f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pii2A_-5nA2nn3z6aDW8mg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">打印头和有效载荷创建</strong></figcaption></figure><p id="aff0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后我们签署完整的令牌:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pe"><img src="../Images/7891f4ff14e50161cc8689f3a8288150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LxhDbTzM9LaPXwBN2zG41g.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">签署令牌</strong></figcaption></figure><p id="e167" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们可以从几个层面来看待JWT。在某种程度上，我们可以认为这是纯HMAC的某种进化。也许JWT<strong class="kk iu">和</strong>之间不太好的地方在于我们确实共享一些数据。当然这也不是一个<strong class="kk iu"> TLS </strong>隧道解决不了的。但同样，向潜在黑客提供一些信息总是比什么都不提供更糟糕。JWT 允许作为前两个安全协议的额外功能的是赋予权限和角色的能力。有效授权。也许我们需要理解的另一个区别是，这种情况下的令牌是一个<strong class="kk iu">不记名</strong>令牌:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="3a63" class="nk lv it lj b gy nl nm l nn no">{<br/>  "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuU0Q3WlNxU3dTeDIwN3ZSNVh4aW9jVFVaaHNCMlF4ViIsImV4cGlyZXNJbiI6IjEyaCIsImFsZ29yaXRobSI6IkhTMjU2In0.R4S8yV_CPJRvJ2dAX_56HfNUZrbKr7Jt4AxEmsqqx8w"<br/>}</span></pre><p id="3707" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><strong class="kk iu">持有人</strong>令牌实际上是我们将在<strong class="kk iu"> OAuth </strong>中看到的同一问题的一部分。如果令牌有效，那么官方<a class="ae lt" href="https://oauth.net/2/bearer-tokens/" rel="noopener ugc nofollow" target="_blank"> RFC6750 </a>将其描述为:</p><blockquote class="pf pg ph"><p id="1d8c" class="ki kj pi kk b kl km kn ko kp kq kr ks pj ku kv kw pk ky kz la pl lc ld le lf im bi translated">一种安全令牌，具有这样的属性:拥有该令牌的任何一方(“持有者”)都可以像拥有该令牌的任何其他方一样使用该令牌</p></blockquote><p id="9ec3" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这意味着，只要令牌有效，任何拥有它的人都可以访问受保护的应用程序。</p><h1 id="d405" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">5.4.— API密钥</h1><p id="f79a" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">对于这种类型或形式的身份验证，没有什么可说的。API密钥是一种身份验证形式，本质上允许用户完全基于拥有API密钥来访问应用程序。<strong class="kk iu"> apiKey </strong>不是通过<strong class="kk iu">授权</strong>头发送的，而是通过同名头发送的:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/b38587386391bc73d28f22d89cce9941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*LqBvyYoRWzFFqGEvQofF0Q.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机4序列图</strong></figcaption></figure><p id="fcb8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">摄像机4受到该安全协议的保护。要配置它，我们首先配置路由:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/fd47a02cb8b6d73739e042bef5a6a637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqhheV_nc_kamzfIanF0yg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机4路线</strong></figcaption></figure><p id="ce75" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后我们激活<strong class="kk iu"> apiKey </strong>插件:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/8e32482e795bc1ad0bfdd35753e44432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*YPEM2TMo3eTeyJX24GAmcA.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">4号摄像头apiKey </strong></figcaption></figure><p id="54b2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种情况下，我们也需要一个消费者。要创建它，我们可以发出以下命令:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="d96f" class="nk lv it lj b gy nl nm l nn no">curl -d "username=camera4&amp;custom_id=CC4" http://127.0.0.1:8001/consumers/<br/>curl -X POST http://127.0.0.1:8001/consumers/camera4/key-auth<br/>curl -X GET http://127.0.0.1:8001/key-auths &gt; ../e2e/cypress/fixtures/CC4KongKeys.json</span></pre><p id="30e7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">简而言之，我们首先创建一个名为<strong class="kk iu"> camera4，</strong>的用户名，然后请求一个<strong class="kk iu"> apiKey </strong>。使用<strong class="kk iu"> key-auths </strong>端点，我们能够发出请求，作为响应，我们将得到一个这种形式的请求，然后我们能够在<strong class="kk iu"> CC4KongKeys.json </strong>文件中找到它:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="320e" class="nk lv it lj b gy nl nm l nn no">{<br/>  "data": [<br/>    {<br/>      "ttl": null,<br/>      "consumer": {<br/>        "id": "99647244-bc39-4981-a187-00e2402be24b"<br/>      },<br/>      "created_at": 1665157122,<br/>      "id": "7a5a39f5-011d-4557-b021-d35e6fb60030",<br/>      "tags": null,<br/>      "key": "87FNNInZXturFdEsal3InGMu7Me3CX5C"<br/>    }<br/>  ],<br/>  "next": null<br/>}</span></pre><p id="8d1f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种情况下，<strong class="kk iu">键</strong>就是我们的<strong class="kk iu"> apiKey </strong>。让我们看看带有apiKey的请求在<strong class="kk iu">类型脚本</strong>代码中是什么样子的:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pn"><img src="../Images/43b53a5815e60c3d1415c94729a0de4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5d3b63LpzPzV4HV12ArdA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">ApiKey类型脚本发送代码</figcaption></figure><p id="f7f7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因此，重要的是要看到我们正在通过线路明文发送<strong class="kk iu"> apiKey </strong>:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="5058" class="nk lv it lj b gy nl nm l nn no">{"apiKey":"87FNNInZXturFdEsal3InGMu7Me3CX5C"}</span></pre><p id="02c2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果我们想自动化应用程序之间的连接，那么<code class="fe lg lh li lj b"><strong class="kk iu">apiKey</strong></code>可能会很有用。它是非常轻量级的，只需要少量的处理。然而，如果我们选择使用这个安全协议，我们必须确保我们是通过<strong class="kk iu"> TLS/HTTPS </strong>连接或者加密连接来使用它。</p><h1 id="c931" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">5.5.— LDAP</h1><p id="e03c" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">这个安全协议让我们想起了windows，但它并不一定与windows有内在联系。在这篇文章中，我的目的不是解释它是如何工作的，而是我们如何通过<strong class="kk iu">孔</strong>网关来配置它？我们将从LDAP实现自身的方式中抽象出来，并关注它的实际实现。<strong class="kk iu"> LDAP </strong>流的最简单形式如下:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi po"><img src="../Images/0db455a1fd6532219c3f90b0e64b719e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bwY0BV1O5Q9f_wU8tQTBg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机5序列图</strong></figcaption></figure><p id="bdab" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">首先我们实现路线:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/3dd225357829399519dced02bca57f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w0g0UU9e8Vjy_fjCOBzTDg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机5路线</strong></figcaption></figure><p id="858c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后我们可以配置插件:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/e2cd4066b33312489e8a5be7a4f997be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*KkHcS6ObGQNowuTU92EYag.png"/></div></figure><p id="b820" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于LDAP ，我们有一些与其他协议稍有不同的东西。<strong class="kk iu"> LDAP </strong>需要一个外部<strong class="kk iu"> LDAP </strong>服务才能工作。所以，本质上，通过<strong class="kk iu">孔</strong>使用<strong class="kk iu"> LDAP </strong>，我们不仅将我们的请求代理到摄像机，还代理到认证<strong class="kk iu"> LDAP </strong>服务。<strong class="kk iu"> LDAP </strong>服务就是我们在docker-compose中发现的<code class="fe lg lh li lj b"><strong class="kk iu">openldap</strong></code>服务。</p><p id="e7ca" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">一旦所有这些都准备就绪，那么我们只需要将我们的请求发送给服务，并在旁边附上身份验证头。在这种情况下，我们将发送一个与我们在<strong class="kk iu"> basic-auth </strong>算法中用于摄像机1的头非常相似的头，但是在这种情况下，我们称它为<strong class="kk iu"> ldap </strong>:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="689f" class="nk lv it lj b gy nl nm l nn no">{ Authorization: ldap YWRtaW46cGFzc3dvcmQ= }</span></pre><p id="0a51" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这是相同的原理，并且以与基本授权请求相同的方式实现:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/1379ea9794309799acf5257ba88b69b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIvNs4zG4onxEeUrmizGIQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">带有LDAP报头的LDAP请求</strong></figcaption></figure><h1 id="e9bf" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">5.6.— OAuth2</h1><p id="976a" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">最后，我们到达了OAuth2。这个安全算法有点复杂，因为它涉及到我们应用程序的外部方。当我们试图登录一些应用程序，并且这些应用程序要求我们通过谷歌、脸书、iCloud、GitHub或任何其他认证提供商登录时，我们通常会看到这个外部方。当我们第一次通过身份验证提供商登录时，它可能会询问我们是否要向他们提供我们的数据，如我们的姓名和电子邮件，当我们说是并登录时，这仅意味着身份验证成功，此外，我们的应用程序已经用身份验证提供商提供的数据注册了我们。接下来，我们可以成功登录。对于本文的这一部分，我们将跳过注册过程，只使用一个身份验证提供者，就好像我们已经注册了一样。身份验证提供者可以通过多种方式实现，这已经超出了本文的范围。然而，我想创建一个例子，这样我们就可以看到OAuth2在本地运行。所以我创建了一个简单的SpringBoot服务，用<strong class="kk iu">基本认证</strong>保护。当然，这只是用作真实事物的模拟。其思想是，在我们认证之后，该服务将在数据库中寻找用户，获取用户的范围并使用它来向camera-6服务请求载体认证报头。然后，该不记名令牌可用于通过<strong class="kk iu"> HTTPS </strong>访问摄像机6服务。以下数据流说明了整个过程:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pq"><img src="../Images/cf9f1223f5d8107cbc02b1ea3c315a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZhXRgGDPpgNNtXpwab_yA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机6序列图</strong></figcaption></figure><p id="ed77" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了进行配置，我们首先需要定义摄像机6的路线:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/485373c801728d89c23390d71323fe9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SBZuxrFisKvjoR8UofhWAg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">摄像机6路线</strong></figcaption></figure><p id="a6c9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我们可以配置<strong class="kk iu"> OAuth2 </strong>插件。对于<strong class="kk iu"> OAuth2 </strong>我决定只通过curl命令保护路线:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="b111" class="nk lv it lj b gy nl nm l nn no">curl -X POST http://127.0.0.1:8001/consumers/ \<br/>  --data "username=camera6" \<br/>  --data "custom_id=CC6"<br/>curl -X POST \<br/>  --url http://127.0.0.1:8001/services/camera-6-service/plugins/ \<br/>  --data "name=oauth2" \<br/>  --data "config.enable_password_grant=true" \<br/>  --data "config.enable_client_credentials=true" \<br/>  --data "config.scopes=admin" \<br/>  --data "config.scopes=observer" \<br/>  --data "config.scopes=visitor" \<br/>  --data "config.scopes=researcher" \<br/>  --data "config.mandatory_scope=true" \<br/>  --data "config.enable_authorization_code=true" &gt; ../e2e/cypress/fixtures/CC6KongProvOauth2.json<br/>cp ../e2e/cypress/fixtures/CC6KongProvOauth2.json ../cameras-auth-service/target/CC6KongProvOauth2.json<br/>curl -X POST http://127.0.0.1:8001/consumers/camera6/oauth2 \<br/>  --data "name=Camera%20Application" \<br/>  --data "client_id=CAMERA06CLIENTID" \<br/>  --data "client_secret=CAMERA06CLIENTSECRET" \<br/>  --data "redirect_uris=https://127.0.0.1:8443/camera-6-service/api/v1/hc" \<br/>  --data "hash_secret=true" &gt; ../e2e/cypress/fixtures/CC6KongOauth2.json<br/>curl -X GET http://127.0.0.1:8001/oauth2_tokens/</span></pre><p id="6f0c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">因此，我们首先创建一个消费者，然后我们用范围<strong class="kk iu"> admin </strong>、<strong class="kk iu"> observer </strong>、<strong class="kk iu"> visitor </strong>、<strong class="kk iu">research、</strong>配置OAuth2，最后我们用消费者自己的<strong class="kk iu"> client_id、client_secret </strong>和<strong class="kk iu">redirect _ uri</strong>配置消费者。创建文件<strong class="kk iu"> CC6KongProvOauth2.json </strong>和<strong class="kk iu"> CC6KongOauth2.json </strong>是因为我们需要这些命令生成的数据来运行我们的测试。</p><p id="c8cc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们可以看看我们的身份认证提供者。在项目中，它被称为<strong class="kk iu">camera-auth-service</strong>。此服务连接到包含以下数据的SQL数据库:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/80aa2aaafca928fcfb5696d7341102ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFYs-Nmizsrj4gRPww2jmg.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">授权数据库中的用户</strong></figcaption></figure><p id="e80b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">字段<strong class="kk iu">角色</strong>实际上是范围。所有用户都有相同的密码，密码是<strong class="kk iu"> admin。</strong>不断重申<strong class="kk iu"> admin </strong>可以用作演示目的的密码<strong class="kk iu">只是</strong>是远远不够的。千万不要在自己的帐户中使用这种密码。</p><p id="129f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">要检索<code class="fe lg lh li lj b"><strong class="kk iu">authorization</strong></code> <code class="fe lg lh li lj b"><strong class="kk iu">bearer</strong></code> <code class="fe lg lh li lj b"><strong class="kk iu">token</strong></code>，有两种方法。我们将首先检索一个<strong class="kk iu">访问代码</strong>，然后使用它来获得<strong class="kk iu">访问令牌。</strong>这在以下Kotlin代码中实现:</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/f27834b4036bbe293820843514da6c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCZI5zmhsqdb_PNPZJ3s2w.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">检索OAuth承载接入码</strong></figcaption></figure><p id="1b85" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果我们放大第一个请求的方式，我们可以看到我们需要创建一个特殊的令牌，其中我们需要<code class="fe lg lh li lj b"><strong class="kk iu">clientId</strong></code>、用户的<code class="fe lg lh li lj b"><strong class="kk iu">scope</strong></code>、<code class="fe lg lh li lj b"><strong class="kk iu">provisionKey</strong></code>、(这是由孔提供的)、<code class="fe lg lh li lj b"><strong class="kk iu">authenticatedUserId</strong></code>、<strong class="kk iu">、<code class="fe lg lh li lj b"><strong class="kk iu">responseType</strong></code>、<strong class="kk iu">、</strong>:</strong></p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pr"><img src="../Images/6c02eb43017109960349e120e58fa1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVRFKqlnVp_RFJcWaQp-ZA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">createAuthFormRequestBody</strong></figcaption></figure><p id="9522" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个第一个请求将为我们提供<strong class="kk iu">访问代码</strong>，然后我们可以使用它来进行请求，这将为我们提供授权持有人代码</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ps"><img src="../Images/dc41d34614e57658238c8462465fa90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWMvIFgcjhbPW75us6jBHA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">createTokenFormRequestBody</strong></figcaption></figure><p id="3f5f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在<a class="ae lt" href="http://localhost:8000/cameras-auth-service/api/v1/cameras/auth/login" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/camera-auth-service/API/v1/camera/auth/log in</a>上登录auth应用程序的结果将是:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="06ba" class="nk lv it lj b gy nl nm l nn no">{<br/>  "refresh_token": "zy2hwv8ov90e5XWRXmbNxZ9NiITMkRYG",<br/>  "access_token": "se4rpVnIofug611XgoqYwAmV7FSTwoMy",<br/>  "expires_in": "7200",<br/>  "token_type": "bearer",<br/>  "redirect_uri": "https://localhost:8443/camera-6-service/api/v1/hc?code=HGsfiB63XY2MyoX7YZk42ryLKNchucyP"<br/>}</span></pre><p id="bcc9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这是对我们的摄像机执行第一个OAuth2请求所必需的一组数据。</p><p id="7bc3" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">发送带有<strong class="kk iu">载体</strong>令牌的数据将允许我们访问摄像机:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="6b9f" class="nk lv it lj b gy nl nm l nn no">{<br/>  "Content-Type": "application/text",<br/>  "Authorization": "Bearer kY0FMKviJgHQTuSjEE9ago1CSz5of8WA"<br/>}</span></pre><p id="fcd7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">除了我们的相机，任何人都无法读取不记名令牌中的内容。将这个传递到后端将很容易。当我们访问我们的OAuth2应用程序时，我们就可以访问header<strong class="kk iu">x-authenticated-scope。</strong>我们知道，当我们通过Kong网关时，我们已经在畅通无阻地访问我们的应用程序。<strong class="kk iu">孔</strong>给我们提供的不仅仅是这个表头，还有<code class="fe lg lh li lj b"><strong class="kk iu">x-authenticated-userid</strong></code> <strong class="kk iu">、</strong>、<code class="fe lg lh li lj b"><strong class="kk iu">x-consumer-username</strong></code>、<strong class="kk iu">、</strong>、<strong class="kk iu">。</strong>这就是我们上面接近本文开头的所有内容。</p><h1 id="1145" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">6.—运行演示</h1><p id="280c" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">要运行演示，请使用以下命令:</p><pre class="ll lm ln lo gt ng lj nh ni aw nj bi"><span id="bdd0" class="nk lv it lj b gy nl nm l nn no">make dcup-full-action</span></pre><p id="b0f1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">运行的时候直接去<a class="ae lt" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000 </a></p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pt"><img src="../Images/2556e2551180707cb686d69a9fff44eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRsYyEc08RtaKSz_sEcqnA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw">测试所有摄像机的应用概述</strong></figcaption></figure><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pu"><img src="../Images/e57a8aa8676c2f7716181ebc37181ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEHWFHf8iBn_S0Z0zXDXFw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated"><strong class="bd lw"> StatsD捕获</strong></figcaption></figure><h1 id="f60a" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">7.结论</h1><p id="f098" class="pw-post-body-paragraph ki kj it kk b kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb mw ld le lf im bi translated">我们在本文中看到的是，通过使用应用程序网关，我们几乎可以控制应用程序面临的任何方面。在本文中，我们只讨论了解释和阅读度量的可能性，但是还有很多其他的可能性。</p><p id="68a2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在任何情况下，我们也看到了基本Auth如何能够很好地用于简单的演示应用程序。例如，这就是我们在OAuth2案例中为身份验证提供者所做的事情。我们现在知道Basic-Auth可能非常不安全。我们实际上是通过线路发送<code class="fe lg lh li lj b">username</code>和<code class="fe lg lh li lj b">passwords</code>，而没有任何活动协议来保护这一对。我们可以说TLS隧道最终会解决这个问题。但是在TLS隧道中窃听已经被证明是可能的，这是我们不想冒的风险。所以Basic-Auth绝对不能在生产中使用。</p><p id="4ab9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">当我们看着HMAC时，我们也看到了一些基本的好处。它是高度加密的，即使有人得到了HMAC令牌乱码，它也几乎是无法破解的。我们知道HMAC也是基于起源的，从令牌中我们不能得到起源，所以令牌的许多方面对潜在的黑客来说是不可及的。HMAC算法的缺点是它的秘密是固定的，而且它被用于永久的自动连接，如M2M。我们仅通过提供用户名和密码来使用它。我们不通过网络发送纯文本，加密依赖于时间戳和位置，当然还有秘密。但是不管我们考虑到什么程度，后端都会识别这个请求，检查它的完整性是否正常，以及用户是否完全基于这个秘密被授权。从令牌中获取秘密几乎是不可能的，但通过社会工程，这就变得不那么清楚了。这是人们不使用像<code class="fe lg lh li lj b"><strong class="kk iu">dragon</strong></code> <strong class="kk iu"> </strong>这样的东西作为秘密，而是使用他们可以配置但不记得的东西，例如PEM私钥的部分原因。但是另一个可能阻碍HMAC的事情是概要文件、角色的定义，以及对某些方法的访问限制。</p><p id="448f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于JWT，我们也看到了我们所需要的是一个秘密和一个发布者。这种算法在保护我们的应用程序方面也非常强大。也许失败的地方在于报头和有效载荷总是在请求时是透明的。这意味着黑客可能无法通过请求，但因为标头和正文始终只是Base64编码，所以解码操作始终是可能的。在任何情况下，主体都是非常方便的，因为在那里我们可以定义，例如，用户可能拥有的角色，但是同样，如果角色被暴露，那么黑客已经拥有了这条信息。对于一个黑客来说，这足以造成大破坏吗？单独发生这种情况并不是因为它不一定危及应用程序，而是因为它仍然是一条信息，有助于增加可能的黑客攻击的表面积</p><p id="4c4f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">使用APIKey是一个有趣的概念，本质上并不能很好地转化为赋予我们的应用程序密钥更多的安全性。本质上，拥有APIKey的消费者只是另一个拥有用户名和密码的用户。只是在这种情况下，用户不能确定密码。API给用户一个APIKey来访问应用程序。它可用于预认证目的或创建另一层安全防护形式。</p><p id="b137" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">LDAP是另一种安全形式，它引入了基本身份验证提供的几乎相同类型的范例、问题和情况。不同之处在于LDAP在网络级别管理访问。在我们的例子中，我们没有探究它是如何真正工作的，但重要的是要记住它更复杂，并且它提供认证和授权功能。只是对于本文的目的来说，它在使应用程序安全方面并没有真正的区别，因为它仍然基于用户以明文形式发送其密码的原则。</p><p id="357c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我们已经了解了OAuth2的工作原理。这是目前为止我们见过的六种算法中最先进的。如果我们有一个允许OTP(一次性密码)、MFA、SMS身份验证或任何其他形式的安全登录的授权提供者，那么我们可以保证对我们的应用程序的访问也是安全的。一旦我们从身份验证提供者那里获得了令牌，我们就知道可以用它来访问我们的应用程序。通常通过OAuth，我们会得到一个请求许可的屏幕。这是示波器意义的一部分。每个范围意味着用户可以访问应用程序的某些部分。另一方面，这也意味着<strong class="kk iu"> camera-6-service </strong>将能够访问所提供的与该范围相关联的用户信息。</p><p id="4958" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">StatsD也是我们如何发送标准统计数据的完美例子。</p><p id="8d41" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><em class="pi">正如我在引言中提到的，鉴于本文的实验性质，它将受到更频繁的审查。</em></p><p id="b373" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我已经把这个应用程序的所有源代码放在了<a class="ae lt" href="https://github.com/jesperancinha/healthy-cameras" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上</p><p id="6ead" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我希望你能像我喜欢写这篇文章一样喜欢它。</p><p id="bba7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我很想听听你的想法，所以请在下面留下你的评论。</p><p id="db90" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">感谢您的阅读！</p><div class="np nq gp gr nr ns"><a href="https://www.etsy.com/codeascraft/measure-anything-measure-everything" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">Etsy工程|测量一切，测量一切</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">如果Etsy的工程学有一种信仰，那就是图形教堂。如果它动了，我们就追踪它。有时我们会画一个…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.etsy.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa jz ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://github.com/statsd/statsd" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">GitHub - statsd/statsd:用于简单而强大的统计数据聚合的守护进程</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">一个运行在Node.js平台上的网络守护进程，它监听通过UDP发送的统计信息，如计数器和计时器…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="pv l"><div class="qb l px py pz pv qa jz ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://www.datadoghq.com/blog/statsd/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">StatsD，它是什么以及它如何帮助您</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">在不到3年的时间里，StatsD已经成为……</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.datadoghq.com</p></div></div><div class="pv l"><div class="qc l px py pz pv qa jz ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://github.com/danielkocot/kong-blogposts" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">GitHub-danielkocot/Kong-blog posts:以代码为中心的Kong blogposts</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="pv l"><div class="qd l px py pz pv qa jz ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://blog.codecentric.de/en/2019/12/kong-api-gateway-observability-with-prometheus-grafana-and-opsgenie/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">kong API-Gateway-Prometheus、Grafana和OpsGenie的可观测性</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">在我的博客上，我看到了最好的演示设置。修女应该死去…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">blog.codecentric.de</p></div></div><div class="pv l"><div class="qe l px py pz pv qa jz ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://docs.konghq.com/hub/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">Kong Hub |插件和集成| Kong文档</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">面向API和微服务的云连接公司Kong的文档。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">docs.konghq.com</p></div></div><div class="pv l"><div class="qf l px py pz pv qa jz ns"/></div></div></a></div></div></div>    
</body>
</html>