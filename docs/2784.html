<html>
<head>
<title>CSS is Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSS是数据</h1>
<blockquote>原文：<a href="https://itnext.io/css-is-data-94d4baaa4f83?source=collection_archive---------1-----------------------#2019-08-01">https://itnext.io/css-is-data-94d4baaa4f83?source=collection_archive---------1-----------------------#2019-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fea1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用React + CSS时，重新评估你的思维方式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/85e516ba276c8892ad4cab81d1c44cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*L2zACLNGCuKwe-oGwNyS-w.gif"/></div></div></figure><p id="8568" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可能看起来是革命性的，也可能不是，但我认为我们经常很容易忘记CSS只是简单的数据。出于某种原因，我们对它的处理与其他数据大相径庭。因此，在创建和使用这些数据时，我们不知道自己在做什么。很多人认为CSS从根本上就坏了。我曾经认为这是完美的，只是被误解了。尽管我确信CSS比人们想象的要好得多，但我还是加倍了这个观点。</p><p id="a2f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">世界上可能只有不到10个人能真正写出真正可伸缩和可维护的CSS。我想很多人都在纠结于<em class="ln">层叠</em>和<em class="ln">继承</em>的问题，以及缺乏直观的范围界定，我真的不能责怪他们。CSS创建于1996年；它当时要解决的问题不一定是今天存在的问题。当然，从根本上来说，CSS的目标是让网站看起来<em class="ln">漂亮</em>和<em class="ln">可用</em>，但是在今天这个软件主宰一切的时代，它现在还有其他目标，或者更确切地说，来自开发者的其他要求。</p><p id="3b99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发者需要从工具和技术中获得良好的体验，就像用户需要从我们使用这些工具和技术构建的软件中获得良好的体验一样。打开网站单一的CSS样式表，在已经有几百行的文件底部随意插入一些CSS的日子已经一去不复返了。今天，可伸缩性和可维护性是非常重要的，为了构建可伸缩和可维护的好看的软件，我们似乎真的不能只使用HTML + CSS + JavaScript来管理它，这就是为什么像jQuery这样的框架如此受欢迎，也是为什么像React这样的框架目前如此受欢迎。这也是像Sass和BEM这样的东西被开创的原因。公平地说，如果使用得当，Sass + BEM实际上可以解决CSS的大部分问题。</p><h2 id="17ab" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">为什么是CSS数据？</h2><p id="2e34" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">CSS本质上是一种<em class="ln"> key:value </em>语言。实际上有数百个有效的CSS属性(键)，都有许多可能不同的值(有些是<em class="ln">连续的</em>，有些是<em class="ln">离散的</em>)。但是这没关系，它们都有文档记录，我们不需要记住它们，只需要记住我们经常使用的那些。由于CSS只是提供给选择器的键和值的集合，所以理论上可以将任何CSS表示为JSON，并且两个示例几乎完全相同，唯一的区别是语法上的细微差别。这使得CSS在理论上成为了<em class="ln">简单的</em>语言(就像JSON一样简单)，那么为什么在实践中却如此困难呢？</p><h2 id="8cb5" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">控制和可预测性</h2><p id="9100" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们真的应该完全控制我们的风格属性。我们应该知道在什么条件下，哪些属性将应用于哪些元素，以及为什么。我不想说，但是CSS不被尊重。人们(似乎是大多数人)会不断地将CSS属性扔向某个东西，直到它做了他们想要它做的事情，而不考虑这些属性将如何彼此交互或影响其他元素(并且在他们自己之后没有清理)。这意味着我们对它没有适当的控制，我们无法预测它。<em class="ln">这让我害怕</em>。每个CSS属性都有其用途和效果。如果您负责项目的CSS，您应该能够准确地说出每个DOM元素上的每个属性在做什么，并且准确地知道该属性将如何影响其他元素。</p><p id="d90d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不能代表其他人，但是从我自己的经验来看，我通过仅仅移除错误的风格属性来修复错误的次数<em class="ln">太高了</em>。也许CSS <em class="ln">是</em>坏了。</p><h2 id="16bc" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">将CSS数据映射到DOM</h2><p id="c8e1" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">为了将一些CSS数据映射到所需的DOM元素，我们有一堆笨拙的抽象可供我们使用，比如类名、选择器、层叠、嵌套等等。我们以选择器的形式创建了一系列条件，并让浏览器根据DOM的状态(元素的位置、它们的类名/id/属性等)应用它们。请记住，这些概念是在前端开发人员将网站视为抽象UI组件集合之前<em class="ln">发明的。从历史上看，为了更新DOM，您需要有单独的JavaScript文件，其中包含UI事件的事件侦听器和业务逻辑的数据提取。然后你会做一大堆乱七八糟的事情，DOM会被更新以拥有新的类来对应一些CSS，这样你就可以根据刚刚发生的事件使网站看起来不同。</em></p><p id="6da4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大多数现代工具、技术和约定都是基于这样一个前提，即每个页面都是UI组件的集合，所以像<em class="ln">作用域</em>这样的事情自然成为更大的关注点。此外，像React这样的现代工具允许UI组件拥有像<em class="ln">状态</em>和<em class="ln">上下文</em>这样的东西。这一点对于以后的工作很重要。</p><h2 id="35bb" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">CSS-in-JS</h2><p id="8ac9" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">不管你喜欢它还是讨厌它，CSS-in-JS已经存在了。仅仅一年前，我会说这是不幸的。但是今天，我的想法被改变了。我相信，就目前情况而言，JavaScript可以比常规CSS、Sass或任何其他不涉及JavaScript的解决方案更有效地用于创建样式表(从开发人员体验的角度来看)。</p><p id="ba75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管像<a class="ae mm" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank"> Styled-Components </a>这样的解决方案很受欢迎，但我不禁想知道这种在标记的模板文字中编写CSS语法的想法是从哪里来的，以及为什么它获得了这么多的关注。</p><p id="c9c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你不知道我在说什么，看看这个来自样式组件主页的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="380d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我完全赞成让人们喜欢他们喜欢的东西，使用对他们有用的东西，但是老实说，这个代码片段不仅被认为是可以接受的，而且是<em class="ln">好的</em>，这让我困惑。我觉得我好像吃了疯狂的药，或者其他人都在骗自己…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/f90dbff4d7f63a490ece3bc451a24e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*teqHGerGouI_4l6NgNFfKg.jpeg"/></div></div></figure><p id="2cf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…但现在我会保持开放的心态，假设我是个疯子。回到字符串内部CSS的例子。我不得不问，既然我们在使用JavaScript，为什么我们不至少写一些类似于:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="cf22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…这个<em class="ln">显然</em>对每个人来说不是更有意义吗，至少从API的角度来看是这样(忘记了这两种解决方案可能如何工作的逻辑)？难道不是更有意义，看起来更好吗？显然不是。我以前曾说过，尽可能使用宿主语言的概念和特性(即JavaScript对象利用像<a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">对象扩展语法</a>这样的东西)比在字符串中编写代码更好。人们似乎认为，因为带标签的模板文字是ES6的一个特性，它要么不能算作在字符串中编写代码，要么代码在字符串中并不重要。</p><p id="35f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当相同的数据可以用对象表示时，仅仅为了符合CSS语法而以键和值的形式获取数据并将其存储在模板字符串中真的有意义吗？你知道，就像一个正常的人？如果你的目标是编写CSS语法而没有任何精神负担，考虑学习如何编写可伸缩和可维护的CSS，或者使用Sass + BEM。对我来说，CSS-in-JS的目标不是能够在一个JavaScript文件中编写CSS语法，而是能够使用JavaScript的概念和范例以一种更有效和实用的方式来设计我的UI组件。</p><h2 id="74c2" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">React和CSS-in-JS</h2><blockquote class="mq mr ms"><p id="1559" class="kr ks ln kt b ku kv jr kw kx ky ju kz mt lb lc ld mu lf lg lh mv lj lk ll lm ij bi translated">如果您不熟悉React，这一部分可能不太有意义。</p></blockquote><p id="c28e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React是创建可重用UI组件的一个很好的框架。它也非常适合处理数据。由于CSS只是数据，我们肯定能够使用react/JavaScript的概念将一些对应于CSS的键和值传递给React组件，并且以一种既实用又高效的方式完成。如果我们可以移除CSS中存在的所有这些抽象，从而改变我们对组件的样式，使之更符合现代实践，会怎么样？</p><p id="d7e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文目前正在研究如何将CSS视为数据，以及React组件如何消费和使用这些数据来对它们进行样式化。它的重点更多的是理论而不是实践。如果一些现有的解决方案已经提供了本文将要讨论的理论，我会很高兴，但是在<a class="ae mm" href="https://medium.com/valtech-design/why-i-dislike-existing-css-in-js-solutions-for-react-7b81786e0fd5" rel="noopener">我评估了10个最流行的CSS-in-JS解决方案</a>之后，没有一个解决方案提供了这样的理论。我目前正在建立一个基于将要讨论的理论的库。</p><p id="8c82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们使用React，我们就按照组件来考虑，组件有<code class="fe mw mx my mz b">props</code>、<code class="fe mw mx my mz b">state</code>和<code class="fe mw mx my mz b">context</code>。因此，我们可以考虑基于这些值，我们可能希望我们的UI组件看起来特别；也就是说，我们可能希望我们的UI组件(和子组件)拥有基于它们对应的<code class="fe mw mx my mz b">props</code>、<code class="fe mw mx my mz b">state</code>和<code class="fe mw mx my mz b">context</code>对象的值的特定CSS属性(仅此而已)。如果我们知道组件的CSS(除了它的默认/静态值)只能基于这些对象改变，并且我们预先知道对象的值到CSS属性的映射应该是什么(我们会知道)，那么我们实际上可以消除对类名或任何类型的选择器和级联废话的需要。而不是说这样的话:</p><blockquote class="mq mr ms"><p id="478b" class="kr ks ln kt b ku kv jr kw kx ky ju kz mt lb lc ld mu lf lg lh mv lj lk ll lm ij bi translated">“在这个元素上，如果这个值为真，就添加这个类。在此元素上，如果该类存在，请添加这些样式。</p></blockquote><p id="ae09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以简单地说:</p><blockquote class="mq mr ms"><p id="820b" class="kr ks ln kt b ku kv jr kw kx ky ju kz mt lb lc ld mu lf lg lh mv lj lk ll lm ij bi translated">"在这个元素上，如果这个值为真，添加这些样式."</p></blockquote><h2 id="0aec" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">它是如何工作的？</h2><p id="3e3c" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">为了考虑这在实践中如何工作，从一个UI组件的基本HTML、CSS和JavaScript示例开始可能会有所帮助。我发现用手风琴能很好地展示这些东西。之后，我们可以看看如何使用React重新创建完全相同的accordion，并考虑如何在不抽象类名和选择器的情况下将相同的样式应用于它(从React的角度考虑)。希望好处会很明显。</p><p id="09b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从HTML开始，我们将使用BEM作为命名约定，留给我们这样的东西:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e710" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…相应的Sass可能类似于:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8d6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…最后是一些让它工作的JavaScript:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4489" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…希望到目前为止一切都有意义。这里可以看到一个工作示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na mo l"/></div></figure><p id="4569" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了一个工作的基础，我们可以尝试使用React在没有CSS的情况下重新创建同样的东西。让我们从尽可能简单的东西开始——将原始HTML移动到一些JSX中，并使折叠面板动态化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0b6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以使用React钩子很容易地添加功能。这会给我们的手风琴(或者至少是手风琴的面板)一些<em class="ln">状态</em>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1e63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据<code class="fe mw mx my mz b">isActive</code>状态，我们将<code class="fe mw mx my mz b">accordion__panel--active</code>类传递给<code class="fe mw mx my mz b">panel</code>元素。根据<code class="fe mw mx my mz b">accordion__panel--active</code>类的存在，我们会在之前(使用Sass时)对<code class="fe mw mx my mz b">heading</code>和<code class="fe mw mx my mz b">content</code>元素应用一些新的样式。在这一点上，我们还没有真正重新发明任何东西或引入任何新概念。要获得我们使用CSS-in-JS技术用Sass创建的风格化手风琴，您必须在上面的JSX中引入一个(或多个)以下内容:</p><ul class=""><li id="79c8" class="nb nc iq kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated">独立的提供者组件</li><li id="bb35" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">用用户定义的组件替换<code class="fe mw mx my mz b">div</code> s(例如<em class="ln">样式化组件</em></li><li id="bb30" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">标记模板文字中的CSS语法(字符串中的CSS)</li><li id="0af2" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">修改Webpack配置</li></ul><p id="98b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然可以说，这些都不理想，但我个人最喜欢的选择是用用户定义的组件替换<code class="fe mw mx my mz b">div</code>。由于这也是<em class="ln"> Styled-Components </em>的一个特性，这似乎是目前为止最流行的CSS-in-JS解决方案，这在一定程度上证实了我的偏见。让我们看看如果使用样式化组件，解决方案会是什么样子。在不试图过多改变我们做事方式的情况下，我得出了以下结论:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4d75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想让面板样式保持在顶部(即在<code class="fe mw mx my mz b">Heading</code>和<code class="fe mw mx my mz b">Content</code>之上)，但是由于某种原因，当相应的面板处于活动状态时，它停止了标题悬停样式的应用。</p><p id="cebf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看是否可以重构这段代码，去掉类名的使用(例如— <code class="fe mw mx my mz b">accordion__panel--active</code>)。Styled-Components让我们将<code class="fe mw mx my mz b">props</code>传递给样式，所以不要指定<code class="fe mw mx my mz b">accordion__panel--active</code>类名，让我们看看是否可以传递一个道具，让我们的JSX为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6879" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在代码沙箱中摆弄了一会儿之后，我们发现，只要稍加摆弄，我们就可以做我们想做的事情:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="77ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就好多了，我可以将<code class="fe mw mx my mz b">Panel</code>样式保留在顶部，并且没有类名的情况下一切正常。在这一点上，我们的JSX可能是有史以来最干净的，我对此非常满意。样式的API当然是可以接受的，但是我仍然对模板字符串感到有点不舒服，因为同样的信息和逻辑可以很容易地用普通对象和箭头函数来表达。而且，真的，我会觉得在一个引用中为一个UI组件保留我的所有样式更舒服(即— <code class="fe mw mx my mz b">const styles = {…}</code>)，但是真的没有办法用样式化组件很好地做这两件事。</p><p id="0f5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我觉得这样会更好:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0328" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…它传达了完全相同的信息，除了不是模板字符串，而是返回对象的普通对象和箭头函数(我最讨厌的问题是在悬停时控制标题背景颜色，这个问题更容易处理)。你可以通过使用<code class="fe mw mx my mz b">context</code>(即<code class="fe mw mx my mz b">panel</code>组件上的<code class="fe mw mx my mz b">active</code>属性)来获取父组件属性和状态，而不是级联。我真的很难找到任何论据表明模板字符串API在这一点上更好。</p><p id="e4e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，为了使这个例子与我们使用样式化组件的JSX一起工作，我们需要手动定义一些<code class="fe mw mx my mz b">&lt;Panel&gt;</code>、<code class="fe mw mx my mz b">&lt;Heading&gt;</code>和<code class="fe mw mx my mz b">&lt;Content&gt;</code>组件，增加了JSX(当使用样式化组件时，这不是一个大问题，因为我们同时定义了组件样式)。我们希望避免使用div和类名(例如<code class="fe mw mx my mz b">&lt;div className='panel'&gt;</code>)。一个好的折衷方案可能是类似于<code class="fe mw mx my mz b">&lt;Component name='panel'&gt;</code>的东西——这给我们留下了一种情况，我们不需要为模块中的每个元素定义新的组件，但是可以保持JSX在语义上更有意义。</p><p id="ba5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要某种提供者，因为我们所有的样式都包含在一个引用中。我们可以将之前的<code class="fe mw mx my mz b">&lt;div class="accordion"&gt;</code>包装器视为提供者，并将我们的样式传递给它，而不是用专用的提供者元素来膨胀我们的JSX。当然，这意味着我们将无法使用<code class="fe mw mx my mz b">div</code>，我们将以与<code class="fe mw mx my mz b">&lt;Component&gt;</code>相同的方式进行某种抽象，因此<code class="fe mw mx my mz b">&lt;Module&gt;</code>似乎是合适的，我们将把我们的<code class="fe mw mx my mz b">styles</code>引用作为道具传递给它。</p><p id="235b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">把这些联系在一起，我们的JSX就会变成这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8985" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不认为这比我们使用的样式化组件稍微麻烦一些；我们从样式中得到的语法上的好处弥补了这一点。<a class="ae mm" href="https://github.com/One-Nexus/Lucid/wiki" rel="noopener ugc nofollow" target="_blank">如果你对这个解决方案感兴趣，你可以关注我的开发进度</a>——它目前处于可用状态(虽然还不会在生产中使用)。</p><h2 id="d68c" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">结论</h2><p id="9793" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">本文的目标是看看我们如何以不同的方式看待CSS，以便更好地使用React和JavaScript范例。我们最终能够提出一种不需要类名，而是使用<code class="fe mw mx my mz b">props</code>、<code class="fe mw mx my mz b">state</code>和<code class="fe mw mx my mz b">context</code>的方法。我们还从DX的角度看了如何使用对象而不是模板字符串来进一步改进。最终，我们得到了一个使用样式化组件(使用模板字符串)的相当不错的生产就绪的解决方案，以及一个稍加修改的解决方案，我目前正在开发该解决方案以提供一个更适合我的API(使用对象)。</p><p id="f5aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">延伸阅读:</p><ul class=""><li id="3258" class="nb nc iq kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated"><a class="ae mm" href="https://levelup.gitconnected.com/react-css-in-js-es6-objects-vs-tagged-template-literals-71670e78995f?source=your_stories_page---------------------------" rel="noopener ugc nofollow" target="_blank"> React &amp; CSS-in-JS: ES6对象vs标记模板文字</a></li><li id="bb91" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated"><a class="ae mm" href="https://medium.com/valtech-design/beautiful-state-context-based-styling-with-react-css-in-js-781a14cb2f9b?source=your_stories_page---------------------------" rel="noopener">漂亮的状态&amp;基于上下文的样式和React (CSS-in-JS) </a></li><li id="0f17" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated"><a class="ae mm" href="https://levelup.gitconnected.com/css-at-scale-cosmetic-vs-layout-properties-a1c8acc875d7?source=your_stories_page---------------------------" rel="noopener ugc nofollow" target="_blank"> CSS缩放:外观与布局属性</a></li><li id="f0fb" class="nb nc iq kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated"><a class="ae mm" href="https://medium.com/valtech-design/why-i-dislike-existing-css-in-js-solutions-for-react-7b81786e0fd5?source=your_stories_page---------------------------" rel="noopener">为什么我不喜欢React现有的CSS-in-JS解决方案</a></li></ul></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/0f4eaa82f76695a20f09ba4fa9fd37ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbifSkjSDCs7zGgIwXMiwg.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated"><a class="ae mm" href="https://twitter.com/esr360" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae mm" href="https://github.com/esr360" rel="noopener ugc nofollow" target="_blank"> Github </a></figcaption></figure></div></div>    
</body>
</html>