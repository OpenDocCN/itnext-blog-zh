<html>
<head>
<title>Why You Rendering, React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你为什么渲染，有什么反应？</h1>
<blockquote>原文：<a href="https://itnext.io/why-you-rendering-react-a6332b3ced24?source=collection_archive---------4-----------------------#2019-09-19">https://itnext.io/why-you-rendering-react-a6332b3ced24?source=collection_archive---------4-----------------------#2019-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4d96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React让开发人员可以自由地以他们认为合适的方式设计他们的应用程序。你使用类组件，高阶组件，渲染道具组件，钩子，还是这些模式的混合？然后是国家管理决策。你的应用程序的组件+状态架构很快就会变得非常笨拙。</p><p id="e056" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论你如何组装你的应用程序，确保你的组件和状态的改变能够像预期的那样触发重新渲染总是一个好主意。如果要重新渲染昂贵的组件，这一点尤为重要。</p><p id="d74e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了确保这不会发生，一个全面的方法是使用一个方便的开发包，<a class="ae ko" href="https://www.npmjs.com/package/@welldone-software/why-did-you-render" rel="noopener ugc nofollow" target="_blank">Why-do-You-Render</a>。要设置它，只需在安装包后将此代码片段添加到您的应用程序代码库中:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="0b5a" class="ky kz it ku b gy la lb l lc ld">if (process.env.NODE_ENV === 'development') {</span><span id="cc85" class="ky kz it ku b gy le lb l lc ld">const whyDidYouRender = require('@welldone-software/why-did-you-render');</span><span id="b6c7" class="ky kz it ku b gy le lb l lc ld">whyDidYouRender(React, {<br/>    include: [/** REGEX here to include **/]<br/>  });<br/>}</span></pre><p id="ba76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加环境变量conditional，以便仅在开发模式下执行此操作。</p><p id="1cb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至少，您只需要<code class="fe lf lg lh ku b">include</code>选项。它接受一个与组件displayName匹配的正则表达式数组。我会选择包含最昂贵的组件。但是，如果你想测试你的整个应用程序，只需要做<code class="fe lf lg lh ku b">[/A-za-z/]</code>。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="df18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦就位，任何可避免的重新渲染都会被记录到你的控制台上。<strong class="js iu">那么哪些是可以避免的重渲染呢？为了回答这个问题，让我们来看看Why-do-You-Render的一些日志。</strong></p><p id="b539" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开下面的代码沙盒示例，点击<em class="lp">“坏集计数”</em>按钮。哇，这么多日志，我们甚至还没有输入一个新的值！</p><figure class="kp kq kr ks gt lq"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">从最初的<a class="ae ko" href="https://medium.com/welldone-software/track-redundant-re-renders-that-caused-by-hooks-with-why-did-you-render-version-3-504468deb653" rel="noopener">为什么渲染</a>示例扩展而来。显示嵌套对象并使用Immer。</figcaption></figure><p id="a267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看一下日志——</p><p id="b7e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">“因挂钩变化而重新渲染:值相等的不同对象”</strong></p><figure class="kp kq kr ks gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi lx"><img src="../Images/f002b587b5c8f4390ec82e9a851ba40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XF3jtEwvnan-L9qaJ_aJsQ.png"/></div></div></figure><p id="936b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为React钩子通过比较引用而不是值来呈现。所以它会重新渲染，除非通过<code class="fe lf lg lh ku b"><a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" rel="noopener ugc nofollow" target="_blank">object.is</a></code>比较两个值相等。</p><p id="04b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由“坏集计数”调用的reducer case发生变异并创建一个新对象:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="1555" class="ky kz it ku b gy la lb l lc ld">case "broken-set-count":</span><span id="6e2a" class="ky kz it ku b gy le lb l lc ld">return {<br/>    robot: { count: action.payload.count } // mutated no!<br/>  };</span></pre><p id="6ffb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh ku b">set-count</code>方法确实更好。它比较变异前的值。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="7240" class="ky kz it ku b gy la lb l lc ld">case "set-count":</span><span id="7d67" class="ky kz it ku b gy le lb l lc ld">if (action.payload.count === state.robot.count) {<br/>    return state; // return previous state<br/>  }</span><span id="8fbc" class="ky kz it ku b gy le lb l lc ld">return {<br/>    robot: { count: action.payload.count } // new object<br/>  };</span></pre><p id="905f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是实际上，使用像<a class="ae ko" href="https://github.com/immerjs/immer" rel="noopener ugc nofollow" target="_blank"> ImmerJS </a>这样的实用程序库来处理不变性要好得多:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="5734" class="ky kz it ku b gy la lb l lc ld">case "set-immer-count":</span><span id="b44c" class="ky kz it ku b gy le lb l lc ld">const newState = produce(state, <br/>   draftState =&gt; { draftState.robot.count = action.payload.count });</span><span id="7fcd" class="ky kz it ku b gy le lb l lc ld">return newState; // all good!</span></pre><p id="4773" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">“重新渲染，因为道具对象本身发生了变化，但其值都是相等的。”</strong></p><figure class="kp kq kr ks gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi me"><img src="../Images/a71ec9157847c5066bf3fe81be86c712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUnv8Jkl40gV8xTZUt3cOw.png"/></div></div></figure><p id="3485" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为当父组件重新渲染时，子组件也会重新创建为新元素。(此处阅读更多<a class="ae ko" href="https://medium.com/welldone-software/why-did-you-render-mr-big-pure-react-component-part-2-common-fixing-scenarios-667bfdec2e0f" rel="noopener">深度解释</a>)。</p><p id="c699" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在演示中，问题的关键是变异的对象。因此，有了两个更好的减速器方法，这个<em class="lp">似乎</em>被固定。</p><p id="3be9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但也不尽然。</p><p id="6174" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当父组件合法地重新呈现时，并不是所有的子组件都需要更新。例如，当我们点击<em class="lp">“切换机器人颜色”</em>按钮更新<code class="fe lf lg lh ku b">props.monochrome</code>时，我们不希望<code class="fe lf lg lh ku b">Counter</code>重新渲染。它应该只与<code class="fe lf lg lh ku b">props.count</code>有关。然而，我们从日志中看到它确实如此。</p><p id="4e47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决办法就是用<code class="fe lf lg lh ku b">React.memo</code>。(如果使用一个类组件，等效的解决方案是扩展为一个<code class="fe lf lg lh ku b">Pure.component</code>。)当<code class="fe lf lg lh ku b">props.monochrome</code>改变时，封装在记忆化函数中的<code class="fe lf lg lh ku b">CounterMemo</code>组件不会触发任何不必要的重新渲染。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="9659" class="ky kz it ku b gy la lb l lc ld">const CounterMemo = React.memo(({ count }) =&gt; {<br/>  return &lt;p&gt;how many robots (memo)?: {count}&lt;/p&gt;;<br/>});</span></pre></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="97fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不变性和记忆性都是当今常见的最佳实践。使用Why-do-You-Render是检查任何遗漏或意外的好方法。我发现现在新的React Dev工具<a class="ae ko" href="https://github.com/facebook/react/issues/16437" rel="noopener ugc nofollow" target="_blank">移除了高亮更新</a>特性，这更加有用了。:(</p></div></div>    
</body>
</html>