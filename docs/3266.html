<html>
<head>
<title>Azure ARM templates and the sad state of infrastructure as code in Azure cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure ARM模板和Azure cloud中作为代码的基础设施的可悲状态</h1>
<blockquote>原文：<a href="https://itnext.io/azure-arm-templates-are-broken-671f32ea63c5?source=collection_archive---------0-----------------------#2019-11-09">https://itnext.io/azure-arm-templates-are-broken-671f32ea63c5?source=collection_archive---------0-----------------------#2019-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9526" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个咆哮，希望能让雷德蒙的人听听，并试图解决它。</p><h1 id="5172" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">开始</h1><p id="1fb6" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">起初有光。和服务器。但是服务器供应和设置变成了工具和雪花设置的泥潭。鉴于此，有人有了一个好主意。因此“作为代码的基础设施”来到了这个世界。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/b127f1d4c235ba7171d1dbd56ae52ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRVAuaj8qdt1OtEK4KNCfg.jpeg"/></div></div></figure><h1 id="b082" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">基础设施作为代码</h1><p id="7812" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">作为代码的基础设施是一个伟大的概念，是devops的支柱。其核心是将我们的云基础设施视为代码= &gt;用可部署的代码来描述它。拥有一个从push开始的CI/CD管道，以及一个基于PRs和带有git revert的回滚的review管道。作为代码的基础设施的Azure工具选择是ARM模板(ARM代表Azure资源管理器)。ARM模板是JSON(稍后查看关于sad技术选择的更多信息)，它们由参数、变量、资源和输出(还有其他一些东西)组成。也可以从模板外部传递参数:从参数文件或从CLI，从而允许我们在不同的场景中重用模板(例如staging/prod)或动态获取参数(例如从keyVault)。由于JSON很难描述复杂的场景，ARM模板有一个函数的概念，它被描述为一个JSON数组。例如，concat函数:</p><pre class="lp lq lr ls gt ma mb mc md aw me bi"><span id="25ac" class="mf km iq mb b gy mg mh l mi mj">{“name“:”[concat(‘my-prefix’, parameters('environment'), '-this-service')]”}</span></pre><p id="9bf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ARM模板还有一个其他解决方案缺乏的“杀手锏”:从azure UI下载当前设置的模板，允许从UI点击驱动的设置过渡到代码形式的基础设施。当然，这并不总是有效的，但是有时候这是一个救命稻草，尤其是在处理文档化API的时候。</p><p id="601d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我已经描述了一个不错的技术栈。虽然它有一些内在的问题，如即使对于琐碎的任务也非常冗长(这也是AWS Cloudformation的问题)，但它是解决代码基础设施问题的好办法。要是这是真的就好了</p><p id="bda7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们很乐观，所以我们用我们的基础设施和CI管道建立了一个git repo来验证和部署这些变化。看妈妈！我们像大男孩一样把基础设施作为代码来做！什么会出错？</p><h1 id="7448" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">ARM模板的失败</h1><h1 id="76e0" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">严格的JSON(没有评论的生活)</h1><p id="a666" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">开发人员是ARM模板的使用者，作为开发人员，代码的可维护性和可读性是重中之重。为了在我们的代码中实现这一点，我们试图将代码分解为模块、类和函数。我们思考有意义的命名，并向未来的读者(可能是一个月后的我们)评论我们的逻辑和决定。请记住，开发人员花在阅读代码上的时间比写代码多10倍。选择一种严格的基于模式的JSON作为实现语言使得这变得非常困难。例如，您不能添加特定api方案中不支持的字段，可能是为了您自己的文档，这些字段也可能用于用一些脚本和描述来包装ARM模板。虽然我可以理解这是一个“警告”还是一个可选的“严格”模式，但是把它作为一个错误似乎是错误的。</p><p id="6430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在研究这篇文章的时候，我发现我可以添加一个`<em class="mk">元数据</em>'对象，该对象将包含一个`<em class="mk">评论</em>'属性到每个对象，这应该是一个解决方案，但只允许在某些地方发表评论。此外，当你快速迭代ARM模板，试图找出确切的正确设置时，我通常会添加/删除代码块，能够注释掉不需要的代码块会很有帮助。但不是严格的JSON。不允许这样。为什么不是YAML？汤姆。甚至是带注释的JSON？</p><h1 id="2313" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">参数-到处都是参数</h1><p id="f2ec" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">ARM模板有一个参数的概念，可以在模板中用默认值和类型来定义，也可以用“参数文件”和/或CLI中的参数来覆盖。参数和变量(可由参数和其他变量和函数组合而成)允许我们的模板是动态的。在我们的转移环境中，我们可能需要2台虚拟机，而在另一个环境中需要8台。不同类型的虚拟机、区域等。这是有用的。问题是当我们对多个模板使用单个覆盖参数文件时，我们在基础设施的CI流程中遇到过这种情况。我们使用一个模板，因为我们在多个模板中使用了(一些)参数，这是一个合理的用例。问题是当一个参数文件包含一个没有在模板中定义的参数时，你会得到一个错误。因此，您发现自己要么使用大量的参数文件，复制重复的值，并希望在有变化时不要错过一个；或者是<strong class="jp ir"> <em class="mk"> parametitis </em> </strong>的可怕症状:复制所有模板中的单个文件参数，包括那些不会使用它们的模板。目前我们在每个模板中有数百行参数，而每个模板只使用了很少的几行；使他们更难阅读和推理。</p><h1 id="e4aa" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">确认</h1><p id="ecec" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">作为代码工具的基础设施的一个重要部分是验证模板的能力；最好甚至做一次演习，让你断言会创建什么，并验证你的模板的正确性。Azure ARM不提供模拟运行选项AFAIK，但它有一个验证命令，唯一的问题是验证非常有限。实际的验证运行是验证JSON模板、丢失的参数(见上文)以及一些丢失的依赖项。不幸的是，当我们尝试实际部署模板时，我们发现还有另一个验证步骤，只有在部署了特定的组件(可能已经运行了很久)然后失败时，才会检查这个步骤。</p><p id="6836" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果验证命令不进行验证，那么它有什么意义呢？我最近遇到的一个更糟糕的问题是一些验证，这些验证不是检查可能由模板构建的AST(抽象语法树),而是试图根据实际部署的组件而不是声明的组件来验证某些属性；忽略声明的依赖关系树。因此，除非我先部署这些组件，然后添加依赖组件，否则模板会失败。从很多方面来看，这都是一种反模式。</p><h1 id="71d1" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">可组合性</h1><p id="6383" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">软件开发的一个重要部分是可组合性，我们不想写10，000个巨大的LOC文件。我们想要可以阅读的小文件，我们想要一种在不同场景中组合和重用它们的方法。</p><p id="70f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，假设我有一个为特定微服务创建资源的模板，我宁愿为每个资源(例如postgresql数据库和redis缓存)创建一个预定义的工作模板，只需在定义该服务所需资源的模板中组合它们。虽然ARM有链接模板(templateUri)的概念，但它仅限于由http位置提供服务的模板。这是ARM模板团队的一个非常糟糕的决定。为什么不允许本地模板？通常建议的解决方法是将模板上传到blob存储(如Azure存储帐户),并从那里通过SASL提供模板。但是为什么呢？这只会增加复杂性，上传要链接的内容——如果模板没有通过验证怎么办？还是在部署过程中出现了其他错误？现在我们还必须清理远程上传的资源。显然，这不是一个真正解决方案，所以我们发现自己有巨大的ARM模板，不可读，几乎不可行。</p><h1 id="c431" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">幂等性</h1><p id="0122" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">作为代码系统的基础设施的一个重要要求是幂等的。多次运行相同的部署代码不会改变结果。通常，这还意味着对于已经按照描述部署的基础架构组件来说，速度会更快。随着时间的推移，您的云基础架构环境几乎不可避免地会增长，描述它的代码也会随之增长。但是我们通常都是重新部署的？每一次基础设施的推进，我们都必须确保它不会破坏/改变已经按照描述设置好的东西。遗憾的是，对于某些部分，ARM无法保证这一点。具体到Azure Kubernetes服务，我遇到过多次重新部署同一个集群以各种方式破坏集群的情况。</p><p id="0495" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最糟糕的是，它很脆弱，各种API变化会引入新的错误。我最近在Azure arm模板中发现了2个错误，使用最新的api版本和标准lb，您无法重新部署已部署的AKS集群，除非它在您创建它时使用的确切节点数中，并且没有自动缩放。如果您更改计数以适应当前的节点数，就会遇到一个验证，如果您保持原来的计数，就会遇到另一个验证。我们刚刚在模板中禁用了AKS部署，因为这个bug使得它无法工作。大型部署会遇到速率限制(虽然很难将这些部署分开，见上文),这些速率限制是硬编码的，支持人员无法升级它们。</p><p id="8342" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个事情感觉就像他们没有在他们自己的过程中真正使用它；如此容易捕捉的错误直接交付到生产中。</p><p id="f79c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会继续使用ARM模板吗？目前是的，因为我不想放弃作为代码的基础设施。但这是一个非常糟糕的体验，不修复它，我看不出高级Devops实践者会心甘情愿地选择Azure云。</p></div></div>    
</body>
</html>