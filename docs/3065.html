<html>
<head>
<title>Kubernetes Volumes: the definitive guide (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特卷:权威指南(第二部分)</h1>
<blockquote>原文：<a href="https://itnext.io/tutorial-basics-of-kubernetes-volumes-part-2-b2ea6f397402?source=collection_archive---------2-----------------------#2019-09-27">https://itnext.io/tutorial-basics-of-kubernetes-volumes-part-2-b2ea6f397402?source=collection_archive---------2-----------------------#2019-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ed38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎来到<a class="ae kl" href="https://medium.com/@abhishek1987/kubernetes-in-a-nutshell-blog-series-c3a97fce9445" rel="noopener">“Kubernetes in the坚果壳”</a>博客系列的另一部分，它关注Kubernetes的“广度”并涵盖基本主题，如<a class="ae kl" href="https://dev.to/itnext/stateless-apps-in-kubernetes-beyond-pods-4p52" rel="noopener ugc nofollow" target="_blank">编排无状态应用</a>，如何<a class="ae kl" href="https://dev.to/itnext/hands-on-guide-configure-your-kubernetes-apps-using-the-configmap-object-44gj" rel="noopener ugc nofollow" target="_blank">使用</a> <code class="fe km kn ko kp b"><a class="ae kl" href="https://dev.to/itnext/hands-on-guide-configure-your-kubernetes-apps-using-the-configmap-object-44gj" rel="noopener ugc nofollow" target="_blank">ConfigMap</a></code>配置Kubernetes应用等。我希望你到目前为止喜欢它！</p><div class="kq kr gp gr ks kt"><a href="https://medium.com/@abhishek1987/kubernetes-in-a-nutshell-blog-series-c3a97fce9445" rel="noopener follow" target="_blank"><div class="ku ab fo"><div class="kv ab kw cl cj kx"><h2 class="bd ir gy z fp ky fr fs kz fu fw ip bi translated">“果壳中的库伯内特”——博客系列</h2><div class="la l"><h3 class="bd b gy z fp ky fr fs kz fu fw dk translated">本系列将涵盖Kubernetes的“广度”和核心/基础主题(见下一节)。它会…</h3></div><div class="lb l"><p class="bd b dl z fp ky fr fs kz fu fw dk translated">medium.com</p></div></div></div></a></div><p id="3187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是上一篇博客的延续，上一篇博客讲述了Kubernetes <code class="fe km kn ko kp b">Volume</code>的基础知识。</p><div class="kq kr gp gr ks kt"><a rel="noopener  ugc nofollow" target="_blank" href="/learn-about-the-basics-of-kubernetes-persistence-part-1-b1fa2847768f"><div class="ku ab fo"><div class="kv ab kw cl cj kx"><h2 class="bd ir gy z fp ky fr fs kz fu fw ip bi translated">了解Kubernetes持久性的基础知识—第1部分</h2><div class="la l"><h3 class="bd b gy z fp ky fr fs kz fu fw dk translated">我们继续我们的“果壳中的库伯内特”之旅，这一部分将涵盖库伯内特卷！</h3></div><div class="lb l"><p class="bd b dl z fp ky fr fs kz fu fw dk translated">itnext.io</p></div></div><div class="lc l"><div class="ld l le lf lg lc lh li kt"/></div></div></a></div><p id="dcd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分，我们将对其进行一些改进:</p><ul class=""><li id="cf45" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">了解<code class="fe km kn ko kp b">PersistentVolume</code>、<code class="fe km kn ko kp b">PersistentVolumeClaim</code>物体以及它们如何协同工作</li><li id="a4f9" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">深入了解Kubernetes中的资源调配类型—静态、动态</li><li id="d382" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">了解存储类别以及它们如何支持动态配置</li><li id="a628" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">探索相关示例</li></ul><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/9cd931e2b34723530f2732b9162fdeab.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*1Cc99RF4vtCSKaHDgz_iyQ.png"/></div></figure><h1 id="1258" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">先决条件:</h1><p id="c883" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">要遵循这篇博客中的例子，您需要以下内容:</p><ul class=""><li id="9c3d" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">一个<a class="ae kl" href="https://docs.microsoft.com/azure/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">微软Azure账户</a>—<a class="ae kl" href="https://azure.microsoft.com/free/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">注册一个免费账户吧！</a></li><li id="c3f7" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><a class="ae kl" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务(AKS)集群</a>——本博客将指导您创建一个集群</li><li id="8e8f" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">Azure CLI或Azure Cloud Shell——如果你还没有安装Azure CLI ,你可以选择安装它(应该很快！)或者直接从你的浏览器使用<a class="ae kl" href="https://azure.microsoft.com/features/cloud-shell/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure云壳</a>。</li><li id="ff37" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b"><a class="ae kl" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">kubectl</a></code>与您的AKS集群互动</li></ul><p id="c650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码可从GitHub 上的<a class="ae kl" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell/blob/master/volumes-2" rel="noopener ugc nofollow" target="_blank">获得</a></p><h1 id="ebca" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">前一集…</h1><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/6572d90c42ceb237d60eeecc06aa75dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*q_OS6eEOWrCT7M0e.gif"/></div></figure><p id="e94f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…最后讨论了“对持久存储的需求”,因为普通Kubernetes <code class="fe km kn ko kp b">Volume</code>的生命周期与<code class="fe km kn ko kp b">Pod</code>紧密相关，而严肃的应用需要比<code class="fe km kn ko kp b">Pod</code>甚至运行<code class="fe km kn ko kp b">Pod</code>的<code class="fe km kn ko kp b">Node</code>更持久的稳定持久的存储。</p><p id="bf53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长期存储介质的例子是网络文件系统(NFS、Ceph、GlusterFS等)。)或者基于云的选项，比如<a class="ae kl" href="https://azure.microsoft.com/services/storage/disks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Disk </a>，亚马逊EBS，GCE持久盘等。</p><p id="4113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码片段展示了如何使用<code class="fe km kn ko kp b">nfs</code>卷类型将NFS(网络文件系统)挂载到<code class="fe km kn ko kp b">Pod</code>中。您可以使用<code class="fe km kn ko kp b">server</code>属性指向一个现有的NFS实例。</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="8358" class="nm mf iq kp b gy nn no l np nq">spec:<br/>  volumes:<br/>  - name: app-data<br/>    nfs:<br/>      server: nfs://localhost<br/>      path: "/"<br/>  containers:<br/>  - image: myapp-docker-image<br/>    name: myapp<br/>    volumeMounts:<br/>    - mountPath: /data<br/>      name: app-data</span></pre><h1 id="dd40" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">这是👆够好吗？</h1><p id="aefa" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">在上面的<code class="fe km kn ko kp b">Pod</code>清单中，存储信息(NFS)直接在<code class="fe km kn ko kp b">Pod</code>中指定(使用<code class="fe km kn ko kp b">volumes</code>部分)。这意味着开发者需要知道NFS服务器的细节，包括它的位置等等。这里肯定有改进的余地，就像软件中的大多数事情一样，可以使用持久卷和持久卷声明的概念，通过另一个层次的间接或抽象来实现。</p><p id="7c7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关键思想围绕着“职责分离”以及将存储创建/管理与其需求/请求分离开来。这就是<code class="fe km kn ko kp b">PersistentVolumeClaim</code>和<code class="fe km kn ko kp b">PersistentVolume</code>发挥作用的地方:</p><ul class=""><li id="97ba" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">PersistentVolumeClaim</code>允许用户通过指定需求(例如存储量)作为<code class="fe km kn ko kp b">PersistentVolumeClaim</code>规范的一部分，以“声明”的方式请求持久存储。</li><li id="a951" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">一个<code class="fe km kn ko kp b">PersistentVolume</code>是对<code class="fe km kn ko kp b">PersistentVolumeClaim</code>的补充，代表Kubernetes集群中的存储介质。存储的实际供应(例如，使用Azure CLI 创建<a class="ae kl" href="https://docs.microsoft.com/cli/azure/disk?view=azure-cli-latest&amp;WT.mc_id=medium-blog-abhishgu#az-disk-create" rel="noopener ugc nofollow" target="_blank"> Azure磁盘、Azure门户等)。)并且集群中的<code class="fe km kn ko kp b">PersistentVolume</code>的创建通常由管理员完成，或者在动态供应的情况下，由Kubernetes自己完成(稍后将介绍)</a></li></ul><p id="2397" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了职责的分离和分离，它还提供了灵活性和可移植性。例如，您有多个环境，如开发、测试、生产等。使用<code class="fe km kn ko kp b">PersistentVolume</code>，您只需声明一次存储需求(例如，“我的应用需要5 GB”)，并根据环境切换实际存储介质，这要归功于<code class="fe km kn ko kp b">PersistentVolumeClaim</code>——这可以是开发环境中的本地磁盘、测试中的标准硬盘和生产中的固态硬盘。这同样适用于多云场景中的可移植性，在这种场景中，您可以使用相同的请求规范，但是根据云提供商切换<code class="fe km kn ko kp b">PersistentVolume</code></p><blockquote class="nr ns nt"><p id="a626" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><em class="iq">在接下来的章节中，我们将举例来帮助巩固这些概念。</em></p></blockquote><h1 id="84fb" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">深潜</h1><h2 id="0d74" class="nm mf iq bd mg ny nz dn mk oa ob dp mo jy oc od ms kc oe of mw kg og oh na oi bi translated">PersistentVolumeClaim</h2><p id="8efc" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">一个<code class="fe km kn ko kp b">PersistentVolumeClaim</code>只是另一个Kubernetes对象(如<code class="fe km kn ko kp b">Pod</code>、<code class="fe km kn ko kp b">Deployment</code>、<code class="fe km kn ko kp b">ConfigMap</code>等)。).这里有一个例子:</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="6ee3" class="nm mf iq kp b gy nn no l np nq">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: data-volume-claim<br/>spec:<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 2Gi<br/>  storageClassName: volume-class</span></pre><p id="9c35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的部分是<code class="fe km kn ko kp b"><strong class="jp ir">spec</strong></code>，它是对一个<code class="fe km kn ko kp b"><a class="ae kl" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#persistentvolumeclaimspec-v1-core" rel="noopener ugc nofollow" target="_blank">PersistentVolumeClaimSpec</a></code>对象的引用——这是定义存储需求的地方。需要关注的重要属性包括:</p><ul class=""><li id="e658" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">resources</code> -卷所需的最小资源</li><li id="d7ac" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">accessModes</code> -卷可以安装的方式(有效值为<code class="fe km kn ko kp b">ReadWriteOnce</code>、<code class="fe km kn ko kp b">ReadOnlyMany</code>、<code class="fe km kn ko kp b">ReadWriteMany</code>)</li><li id="7480" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">storageClassName</code> -权利要求所要求的<code class="fe km kn ko kp b">StorageClass</code>的名称(<code class="fe km kn ko kp b">StorageClass</code>另节)</li></ul><blockquote class="nr ns nt"><p id="27b7" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><code class="fe km kn ko kp b"><em class="iq">PersistentVolumeClaim</em></code> <em class="iq">有其他属性</em><code class="fe km kn ko kp b"><em class="iq">apiVersion</em></code><em class="iq"/><code class="fe km kn ko kp b"><em class="iq">kind</em></code><em class="iq"/><code class="fe km kn ko kp b"><em class="iq">metadata</em></code><em class="iq"/><code class="fe km kn ko kp b"><em class="iq">status</em></code><em class="iq">。这些是所有Kubernetes对象共有的。</em></p></blockquote><h2 id="2be2" class="nm mf iq bd mg ny nz dn mk oa ob dp mo jy oc od ms kc oe of mw kg og oh na oi bi translated">持久卷</h2><p id="0d60" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">这是典型的<code class="fe km kn ko kp b">PersistentVolume</code>规格的样子:</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="55e6" class="nm mf iq kp b gy nn no l np nq">apiVersion: v1<br/>  kind: PersistentVolume<br/>  metadata:<br/>    name: my-pvc<br/>  spec:<br/>    capacity:<br/>      storage: 10Gi<br/>    accessModes:<br/>      - ReadWriteOnce<br/>    persistentVolumeReclaimPolicy: Recycle<br/>    storageClassName: volume-class<br/>    nfs:<br/>      server: nfs://localhost<br/>      path: "/"</span></pre><p id="e0f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像<code class="fe km kn ko kp b">PersistentVolumeClaim</code>，<code class="fe km kn ko kp b">spec</code> ( <code class="fe km kn ko kp b">PersistentVolumeSpec</code>对象)是<code class="fe km kn ko kp b">PersistentVolume</code>最重要的部分——让我们进一步剖析它:</p><ul class=""><li id="6060" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">特定于提供商/存储—如<code class="fe km kn ko kp b">nfs</code>、<code class="fe km kn ko kp b">azureDisk</code>、<code class="fe km kn ko kp b">gcePersistentDisk</code>、<code class="fe km kn ko kp b">awsElasticBlockStore</code>等。它允许你提供特定于存储介质(NFS，Azure磁盘等)的信息。)</li><li id="cd61" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">accessModes</code> -卷的安装方式</li><li id="2c57" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">capacity</code> -永久卷的资源和容量信息。</li><li id="d358" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">storageClassName</code> -该持久卷所属的<code class="fe km kn ko kp b">StorageClass</code>的名称(<code class="fe km kn ko kp b">StorageClass</code>即将被覆盖)</li><li id="eefb" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">persistentVolumeReclaimPolicy</code> -删除相应的<code class="fe km kn ko kp b">PersistentVolumeClaim</code>会发生什么-选项有<code class="fe km kn ko kp b">Retain</code>、<code class="fe km kn ko kp b">Delete</code>和<code class="fe km kn ko kp b">Recycle</code>(已弃用)</li></ul><p id="2132" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为作业，请探究<code class="fe km kn ko kp b">nodeAffinity</code>、<code class="fe km kn ko kp b">volumeMode</code>、<code class="fe km kn ko kp b">mountOptions</code>属性，确定它们起什么作用</p><blockquote class="nr ns nt"><p id="eaa3" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><code class="fe km kn ko kp b"><em class="iq">PersistentVolume</em></code> <em class="iq">有其他属性——</em><code class="fe km kn ko kp b"><em class="iq">apiVersion</em></code><em class="iq"/><code class="fe km kn ko kp b"><em class="iq">kind</em></code><em class="iq"/><code class="fe km kn ko kp b"><em class="iq">metadata</em></code><em class="iq"/><code class="fe km kn ko kp b"><em class="iq">status</em></code><em class="iq">。这些是所有Kubernetes对象共有的。</em></p></blockquote><h2 id="9f1b" class="nm mf iq bd mg ny nz dn mk oa ob dp mo jy oc od ms kc oe of mw kg og oh na oi bi translated">这些对象是如何协同工作的？</h2><p id="2ddd" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">有两种方法可以使用这些结构为Kubernetes应用程序获取存储— <strong class="jp ir">静态</strong>和<strong class="jp ir">动态</strong>。</p><p id="0835" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在“静态”模式下，用户需要负责调配实际存储(云、本地存储等))然后在<code class="fe km kn ko kp b">Pod</code>规范(您的应用程序)中引用它</p><p id="a244" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在“动态”方式中，Kubernetes承担了存储供应的重任，并创建了<code class="fe km kn ko kp b">PersistentVolume</code>。您所做的就是通过在<code class="fe km kn ko kp b">Pod</code>规范中创建并引用一个<code class="fe km kn ko kp b">PersistentVolumeClaim</code>来提供您的存储需求</p><blockquote class="nr ns nt"><p id="9b2c" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><em class="iq">应在群集上启用动态预配置—在大多数提供商中，这是现成的</em></p></blockquote><p id="96d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们探索一下静态资源调配</p><h1 id="9d1a" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">静态供应</h1><p id="3da1" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">使用静态资源调配有两种方式:</p><p id="b96b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中之一是调配存储，并在<code class="fe km kn ko kp b">Pod</code>规范中直接使用其信息<strong class="jp ir"/></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/ad017830bb29558eb19a21edc9e26826.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/0*MUgB0mfHs-KjiS2A.jpg"/></div></figure><p id="baf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经提到了这一点，但这是我最后一次这样做(在这种情况下)，并建议尝试一下关于如何<a class="ae kl" href="https://docs.microsoft.com/azure/aks/azure-disk-volume?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">“在Azure Kubernetes服务(AKS)中手动创建和使用带有Azure磁盘的卷”</a>的优秀教程。这就是它看起来的样子(正如你之前读到的，这很方便，但是有它的局限性)</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="bd90" class="nm mf iq kp b gy nn no l np nq">spec:<br/>  containers:<br/>  - image: nginx<br/>    name: mypod<br/>    volumeMounts:<br/>      - name: azure<br/>        mountPath: /mnt/azure<br/>  volumes:<br/>      - name: azure<br/>        azureDisk:<br/>          kind: Managed<br/>          diskName: myAKSDisk<br/>          diskURI: /subscriptions/&lt;subscriptionID&gt;/resourceGroups/MC_myAKSCluster_myAKSCluster_eastus/providers/Microsoft.Compute/disks/myAKSDisk</span></pre><p id="d221" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二种方法中，不是创建磁盘并提供它的细节(在本例中是<code class="fe km kn ko kp b">azureDisk</code>，而是将信息封装在一个<code class="fe km kn ko kp b">PersistentVolume</code>中。然后您创建一个<code class="fe km kn ko kp b">PersistentVolumeClaim</code>并从<code class="fe km kn ko kp b">Pod</code>规范中引用它，并将其留给Kubernetes来匹配可用的存储需求</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c1ebae31b2fd3183c56bfd36ae01fb2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*3FOyBnSjlUk8vbKp.jpg"/></div></figure><p id="0861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个片段可以让你有所了解</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="6b34" class="nm mf iq kp b gy nn no l np nq">spec:<br/>      volumes:<br/>      - name: app-data<br/>        persistentVolumeClaim:<br/>          claimName: data-volume-claim</span></pre><blockquote class="nr ns nt"><p id="5ffb" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><em class="iq">把它想象成把一个逻辑重构成它自己的方法——你接受一堆存储请求信息，并以</em> <code class="fe km kn ko kp b"><em class="iq">PersistentVolume</em></code> <em class="iq">(类似于一个方法)的形式将其具体化。</em></p></blockquote><h1 id="67a9" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">动态供应</h1><p id="8082" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">如前所述，使用动态预配置，您可以将所有繁重的工作交给Kubernetes。在我们开始之前，这里有一个它是如何工作的快照</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/a76812cc339d7eb98ec1d79568f4e0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/0*h2Z3WRiEv1Ul1qkS.jpg"/></div></figure><p id="209d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与动态预配置相关的一个关键概念是<code class="fe km kn ko kp b">StorageClass</code></p><h2 id="9363" class="nm mf iq bd mg ny nz dn mk oa ob dp mo jy oc od ms kc oe of mw kg og oh na oi bi translated">存储类</h2><p id="9821" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">就像<code class="fe km kn ko kp b">PersistentVolume</code>封装存储细节一样，<code class="fe km kn ko kp b">StorageClass</code>提供了一种描述存储“类别”的方式。为了使用<code class="fe km kn ko kp b">StorageClass</code>，你需要做的就是从<code class="fe km kn ko kp b">PersistentVolumeClaim</code>中引用它。</p><p id="b7d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们实际理解一下——这是一个<a class="ae kl" href="https://azure.microsoft.com/services/storage/disks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure磁盘</a>的<code class="fe km kn ko kp b">StorageClass</code>的例子。</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="56a7" class="nm mf iq kp b gy nn no l np nq">apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/>  labels:<br/>    kubernetes.io/cluster-service: "true"<br/>  name: default<br/>parameters:<br/>  cachingmode: ReadOnly<br/>  kind: Managed<br/>  storageaccounttype: Standard_LRS<br/>provisioner: kubernetes.io/azure-disk<br/>reclaimPolicy: Delete<br/>volumeBindingMode: Immediate</span></pre><p id="367c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">StorageClass</code>规格中的关键参数是:</p><ul class=""><li id="7ec9" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">provisioner</code> -提供实际存储的卷插件(细节如下)</li><li id="24d5" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">parameters</code> -可在运行时用作供应器的自定义键值对</li><li id="9ac0" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">reclaimPolicy</code> -创建<code class="fe km kn ko kp b">PersistentVolume</code>的回收策略(<code class="fe km kn ko kp b">Delete</code>删除PVC时删除PV，保留PV)</li><li id="064b" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">volumeBindingMode</code> -指示<code class="fe km kn ko kp b">PersistentVolumeClaim</code>应如何供应和绑定(有效值为<code class="fe km kn ko kp b">Immediate</code>和<code class="fe km kn ko kp b">WaitForFirstConsumer</code>)</li></ul><p id="69c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些参数(以及其他一些参数，如<code class="fe km kn ko kp b">allowVolumeExpansion</code>、<code class="fe km kn ko kp b">allowedTopologies</code>、<code class="fe km kn ko kp b">mountOptions</code>)中的信息在运行时用于动态配置存储并创建相应的<code class="fe km kn ko kp b">PersistentVolume</code>。</p><blockquote class="nr ns nt"><p id="3360" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><code class="fe km kn ko kp b"><em class="iq">StorageClass</em></code> <em class="iq">也有其他属性——</em><code class="fe km kn ko kp b"><em class="iq">apiVersion</em></code><em class="iq"/><code class="fe km kn ko kp b"><em class="iq">kind</em></code><em class="iq"/><code class="fe km kn ko kp b"><em class="iq">metadata</em></code><em class="iq">。这些是所有Kubernetes对象共有的。</em></p></blockquote><h2 id="8a87" class="nm mf iq bd mg ny nz dn mk oa ob dp mo jy oc od ms kc oe of mw kg og oh na oi bi translated">什么是<code class="fe km kn ko kp b">provisioner</code>？</h2><p id="d6f3" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated"><code class="fe km kn ko kp b">provisioner</code>是动态预配置的核心——它是一个插件，包含用于创建特定类型存储资源的定制逻辑。Kubernetes附带了一系列供应器，包括基于云的供应器，如<a class="ae kl" href="https://azure.microsoft.com/services/storage/disks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Disk </a> ( <code class="fe km kn ko kp b">kubernetes.io/azure-disk</code>)、Azure File ( <code class="fe km kn ko kp b">kubernetes.io/azure-file</code>)、GCE持久性磁盘、AWS EBS等。</p><blockquote class="nr ns nt"><p id="df6c" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><em class="iq">在上面的示例中，</em> <code class="fe km kn ko kp b"><em class="iq">kubernetes.io/azure-disk</em></code> <em class="iq">被用作供应器</em></p></blockquote><p id="448a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">parameters</code>部分提供了一种在运行时将信息传递给参数的方法——这显然是特定于<code class="fe km kn ko kp b">provisioner</code>的。在上面的例子中，<code class="fe km kn ko kp b">cachingmode</code>、<code class="fe km kn ko kp b">storageaccounttype</code>和<code class="fe km kn ko kp b">kind</code>作为参数传递给<code class="fe km kn ko kp b">kubernetes.io/azure-disk</code>provisioner——这提供了很大的灵活性。</p><blockquote class="nr ns nt"><p id="e6c3" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><em class="iq">如果参数未通过，则使用默认值</em></p></blockquote><h2 id="bd19" class="nm mf iq bd mg ny nz dn mk oa ob dp mo jy oc od ms kc oe of mw kg og oh na oi bi translated">关于缺省存储类的一个注记</h2><p id="0a13" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">可以将<code class="fe km kn ko kp b">StorageClass</code>标记为默认值，以便在<code class="fe km kn ko kp b">PersistentVolumeClaim</code>中未提供<code class="fe km kn ko kp b">storageClass</code>属性时使用它(用于动态供应)。</p><p id="4db3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务</a>通过包含两个预播种存储类，简化了动态配置。您可以通过运行<code class="fe km kn ko kp b">kubectl get storageclass</code>命令进行检查</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="e46a" class="nm mf iq kp b gy nn no l np nq">NAME                PROVISIONER                AGE<br/>default (default)   kubernetes.io/azure-disk   6d10h<br/>managed-premium     kubernetes.io/azure-disk   6d10h</span></pre><ul class=""><li id="9813" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">default</code>存储类别:提供由标准硬盘支持的标准<a class="ae kl" href="https://docs.microsoft.com/azure/virtual-machines/windows/disks-types?WT.mc_id=medium-blog-abhishgu#standard-hdd" rel="noopener ugc nofollow" target="_blank"> Azure磁盘</a></li><li id="ba4f" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated"><code class="fe km kn ko kp b">managed-premium</code>存储类别:提供由高级固态硬盘支持的高级<a class="ae kl" href="https://docs.microsoft.com/azure/virtual-machines/windows/disks-types?WT.mc_id=medium-blog-abhishgu#premium-ssd" rel="noopener ugc nofollow" target="_blank"> Azure磁盘</a></li></ul><h1 id="8ad9" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">动手操作:动态配置</h1><p id="d7ed" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">是时候使用<a class="ae kl" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务</a>尝试动态预配置了。您将创建一个<code class="fe km kn ko kp b">PersistenceVolumeClaim</code>，一个简单的应用程序(<code class="fe km kn ko kp b">Deployment</code>)，它引用该声明并查看事情在实践中是如何工作的。</p><p id="9301" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还没有一个Azure帐户，现在是时候注册一个免费帐户了。</p><h1 id="a29a" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">Kubernetes集群设置</h1><p id="a0a8" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">你只需要一个命令就可以在Azure上建立一个Kubernetes集群。但是，在此之前，我们必须创建一个资源组</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="0c3a" class="nm mf iq kp b gy nn no l np nq">export AZURE_SUBSCRIPTION_ID=[to be filled]<br/>export AZURE_RESOURCE_GROUP=[to be filled]<br/>export AZURE_REGION=[to be filled] (e.g. southeastasia)</span></pre><p id="b905" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">切换到您的订阅并调用<code class="fe km kn ko kp b">az group create</code></p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="03b6" class="nm mf iq kp b gy nn no l np nq">az account set -s $AZURE_SUBSCRIPTION_ID<br/>az group create -l $AZURE_REGION -n $AZURE_RESOURCE_GROUP</span></pre><p id="1313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您现在可以调用<code class="fe km kn ko kp b">az aks create</code>来创建新的集群</p><blockquote class="nr ns nt"><p id="5c18" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><em class="iq">为了简单起见，下面的命令创建了一个单节点集群。请根据您的要求随意更改规格</em></p></blockquote><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="81de" class="nm mf iq kp b gy nn no l np nq">export AKS_CLUSTER_NAME=[to be filled]</span><span id="f98b" class="nm mf iq kp b gy om no l np nq">az aks create --resource-group $AZURE_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --node-count 1 --node-vm-size Standard_B2s --node-osdisk-size 30 --generate-ssh-keys</span></pre><p id="65a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe km kn ko kp b">az aks get-credentials</code>获取AKS集群凭证——因此，<code class="fe km kn ko kp b">kubectl</code>现在将指向您的新集群。你可以证实这一点</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="7853" class="nm mf iq kp b gy nn no l np nq">az aks get-credentials --resource-group $AZURE_RESOURCE_GROUP --name $AKS_CLUSTER_NAME<br/>kubectl get nodes</span></pre><blockquote class="nr ns nt"><p id="e306" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><em class="iq">如果你有兴趣使用</em><a class="ae kl" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"><em class="iq">Azure</em></a><em class="iq">学习Kubernetes和Containers，一个很好的起点是使用文档中的</em> <a class="ae kl" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">快速入门、教程和代码示例</em> </a> <em class="iq">来熟悉这项服务。我也强烈推荐查看一下</em> <a class="ae kl" href="https://azure.microsoft.com/resources/kubernetes-learning-path/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> 50天Kubernetes学习路径</em> </a> <em class="iq">。高级用户可能希望参考</em> <a class="ae kl" href="https://docs.microsoft.com/azure/aks/best-practices?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Kubernetes最佳实践</em> </a> <em class="iq">或观看一些</em> <a class="ae kl" href="https://azure.microsoft.com/resources/videos/index/?services=kubernetes-service&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">视频</em> </a> <em class="iq">以了解演示、主要功能和技术会议。</em></p></blockquote><h1 id="f397" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">创建PersistentVolumeClaim，然后部署应用程序</h1><p id="f021" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">这是我们将使用的<code class="fe km kn ko kp b">PersistentVolumeClaim</code>规格</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="5873" class="nm mf iq kp b gy nn no l np nq">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: azure-disk-pvc<br/>spec:<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 2Gi</span></pre><p id="8b8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，<code class="fe km kn ko kp b">PersistenceVolumeClaim</code>没有使用<code class="fe km kn ko kp b">storageClass</code>——这是为了确保<code class="fe km kn ko kp b">default</code>存储类用于动态供应。</p><p id="b5c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创造了<code class="fe km kn ko kp b">PersistenceVolumeClaim</code></p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="ee00" class="nm mf iq kp b gy nn no l np nq">kubectl apply -f <a class="ae kl" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/volumes-2/azure-disk-pvc.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/volumes-2/azure-disk-pvc.yaml</a></span></pre><p id="ae3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你检查一下，你会看到这样的东西(<code class="fe km kn ko kp b">STATUS</code> = <code class="fe km kn ko kp b">Pending</code>)</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="48c4" class="nm mf iq kp b gy nn no l np nq">kubectl get pvc</span><span id="2400" class="nm mf iq kp b gy om no l np nq">NAME             STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br/>azure-disk-pvc   Pending                                      default        11s</span></pre><p id="914d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一段时间后，它应该变成(<code class="fe km kn ko kp b">STATUS</code>=<code class="fe km kn ko kp b">Bound</code>)——这是因为Azure磁盘和<code class="fe km kn ko kp b">PersistenceVolume</code>是自动创建的</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="19a9" class="nm mf iq kp b gy nn no l np nq">NAME             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br/>azure-disk-pvc   Bound    pvc-7b0e2911-df74-11e9-93ab-025752f370d3   2Gi        RWO            default        36s</span></pre><p id="84a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以检查动态配置的<code class="fe km kn ko kp b">PersistenceVolume</code>-<code class="fe km kn ko kp b">kubectl get pv</code></p><p id="e230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确认Azure磁盘已创建</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="e032" class="nm mf iq kp b gy nn no l np nq">AKS_NODE_RESOURCE_GROUP=$(az aks show --resource-group $AZURE_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --query nodeResourceGroup -o tsv)</span><span id="3d3c" class="nm mf iq kp b gy om no l np nq">az disk list -g $AKS_NODE_RESOURCE_GROUP</span></pre><p id="f803" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">tags</code>部分看起来类似于</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="6345" class="nm mf iq kp b gy nn no l np nq">"tags": {<br/>      "created-by": "kubernetes-azure-dd",<br/>      "kubernetes.io-created-for-pv-name": "pvc-7b0e2911-df74-11e9-93ab-025752f370d3",<br/>      "kubernetes.io-created-for-pvc-name": "azure-disk-pvc",<br/>      "kubernetes.io-created-for-pvc-namespace": "default"<br/>}</span></pre><p id="804a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建应用程序<code class="fe km kn ko kp b">Deployment</code></p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="53f9" class="nm mf iq kp b gy nn no l np nq">kubectl apply -f <a class="ae kl" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/volumes-2/app.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/volumes-2/app.yaml</a></span></pre><p id="a699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试它，我们将使用一个简单的Go应用程序。它所做的只是将日志语句推送到<code class="fe km kn ko kp b">/mnt/logs</code>中的一个文件<code class="fe km kn ko kp b">logz.out</code>——这是安装到<code class="fe km kn ko kp b">Pod</code>中的路径</p><p id="493e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等待一段时间，使部署处于<code class="fe km kn ko kp b">Running</code>状态</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="f696" class="nm mf iq kp b gy nn no l np nq">kubectl get pods -l=app=logz</span><span id="086e" class="nm mf iq kp b gy om no l np nq">NAME                               READY   STATUS    RESTARTS   AGE<br/>logz-deployment-59b75bc786-wt98d   1/1     Running   0          15s</span></pre><p id="a433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确认，检查<code class="fe km kn ko kp b">Pod</code>中的<code class="fe km kn ko kp b">mnt/logs/logz.out</code></p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="fb59" class="nm mf iq kp b gy nn no l np nq">kubectl exec -it $(kubectl get pods -l=app=logz --output=jsonpath={.items..metadata.name}) -- tail -f /mnt/logs/logz.out</span></pre><p id="bf46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将每3秒钟看到一次日志(只有时间戳)</p><pre class="ly lz ma mb gt ni kp nj nk aw nl bi"><span id="d9a3" class="nm mf iq kp b gy nn no l np nq">2019-09-25 09:17:11.960671937 +0000 UTC m=+84.002677518<br/>2019-09-25 09:17:14.961347341 +0000 UTC m=+87.003352922<br/>2019-09-25 09:17:17.960697766 +0000 UTC m=+90.002703347<br/>2019-09-25 09:17:20.960666399 +0000 UTC m=+93.002671980</span></pre></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="005a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们关于Kubernetes卷的两部分系列的结尾。你觉得这篇文章怎么样？你从中学到了什么吗？它是否有助于解决一个问题，解决您一直以来的疑问？😃😃或者它需要改进😡请提供您的反馈——它非常有价值，我将非常感谢！你可以通过推特或者直接在下面留言来开始讨论。</p><p id="f024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我前面提到的，这是更大的博客系列<a class="ae kl" href="https://medium.com/@abhishek1987/kubernetes-in-a-nutshell-blog-series-c3a97fce9445" rel="noopener">“Kubernetes in through”</a>的一个子部分，还有更多！请不要忘记喜欢和关注😉</p></div></div>    
</body>
</html>