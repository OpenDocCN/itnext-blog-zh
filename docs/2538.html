<html>
<head>
<title>Building a kubernetes cluster on Raspberry Pi and low-end equipment. Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Raspberry Pi和低端设备上构建kubernetes集群。第一部分</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-kubernetes-cluster-on-raspberry-pi-and-low-end-equipment-part-1-a768359fbba3?source=collection_archive---------0-----------------------#2019-06-11">https://itnext.io/building-a-kubernetes-cluster-on-raspberry-pi-and-low-end-equipment-part-1-a768359fbba3?source=collection_archive---------0-----------------------#2019-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8165" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一系列文章中，我将使用Raspberry Pi设备构建一个kubernetes集群作为计算平台的基础。Kubernetes是一个流行的系统，用于部署自动化、容器编排；它包含了如此多的特性(伸缩性、负载平衡、卷管理、安全性等等)，以至于我更愿意称kubernetes为一个生态系统。</p><p id="eca2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在硬件层面——我只会使用在任何计算机硬件商店都能买到的廉价设备:路由器、交换机和存储服务器。</p><p id="eedf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于kubernetes覆盖了90%的软件需求，我仍然可以使用一些ansible来实现自动化；现代的路由器、交换机和存储服务器运行在类似UNIX的操作系统之上，所以我也要用一点。</p><p id="d655" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终，kubernetes集群应该作为云基础设施工作，我可以在类似云的环境中运行应用程序，从互联网访问它们，有状态的应用程序将能够使用数据存储层。</p><p id="010e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第1部分将关注基本的东西:Raspberry Pi设备需求、kubernetes节点供应、集群设置。</p><h1 id="ce30" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">硬件设置概述</h1><p id="fc2a" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我将使用由路由器<em class="ko"> Microtik hEX S(RB760iGS) </em>组成的家用设备。售价69.00美元，它提供了通常只有思科、Juniper等厂商的高端路由器才有的各种功能。一个路由器端口用于连接互联网服务提供商。另一个端口连接路由器和交换机。</p><p id="19a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种交换机<em class="ko">的D-Link DGS-1005 P </em>售价不到50美元，它有五个千兆以太网端口。四个端口<a class="ae ls" href="https://en.wikipedia.org/wiki/Power_over_Ethernet" rel="noopener ugc nofollow" target="_blank"> <em class="ko">以太网供电</em> </a> <em class="ko"> (PoE) </em>使能。端口5用于连接路由器。那种链路叫做<em class="ko">上行</em>。其他四个端口可用于连接<em class="ko">树莓Pi </em>设备。由于端口上的<em class="ko"> PoE </em>，<em class="ko"> Raspberry Pi </em>设备不需要通过USB供电。</p><p id="b581" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于Kubernetes集群与我的家用设备共享网络，我决定将其隔离在VLAN中。对我来说，这不是必需的，只是为了方便。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/152d40d3f990f0e6bb575122512051f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*kLrk15RUho-GwXeAVb-YTQ.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">图一。网络安装程序</figcaption></figure><p id="17f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谈论细节。我们有以下组件:</p><ul class=""><li id="38cd" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">mikro tik Rb 760 IGS——路由器。该设备为Kubernetes集群提供互联网连接、VLAN交换、DHCP服务器、NAT、动态DNS等功能</li><li id="68aa" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><a class="ae ls" href="https://www.dlink.com/en/products/des-1005p-5-port-10100-switch-with-4-poe-ports" rel="noopener ugc nofollow" target="_blank"> D-Link DGS-1005P </a> —带有4个PoE启用端口的非托管交换机。交换机为Raspberry Pi提供电源，并与路由器和Kubernetes节点进行数据链路层交换</li><li id="39fb" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><a class="ae ls" href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b-plus/" rel="noopener ugc nofollow" target="_blank"> Raspberry Pi 3型号B+ </a> —一台配备1.4GHz 64位四核处理器、1GB RAM、千兆以太网的迷你电脑</li><li id="3e87" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated"><a class="ae ls" href="https://www.raspberrypi.org/products/poe-hat/" rel="noopener ugc nofollow" target="_blank">Raspberry Pi PoE HAT</a>—Raspberry Pi扩展，允许通过以太网为设备供电</li><li id="7ba3" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn mk ml mm mn bi translated">microSDHC灭蚁灵(class10) 8GB — SD卡，带Raspberry Pi操作系统</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mt"><img src="../Images/f55808694e5ee38a9c76593f901576b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OTlIPbQpVF8kSWAVFgIOKg.jpeg"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">图二。运行中的网络设置</figcaption></figure><p id="3e93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在图2中，路由器是白盒，交换机是黑盒。黄色电缆是上行链路(交换机到路由器的连接)。灰色电缆连接Raspberry Pi设备和交换机。</p><h1 id="eae9" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">软件概述</h1><p id="ab19" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">让我们从列出我们将使用的所有软件组件开始。</p><ol class=""><li id="a024" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn my ml mm mn bi translated">Ubuntu 18.04:一个操作系统</li><li id="2f7e" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn my ml mm mn bi translated"><a class="ae ls" href="https://www.docker.com/products/container-runtime" rel="noopener ugc nofollow" target="_blank"> Docker引擎</a>:容器运行时</li><li id="f3a8" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn my ml mm mn bi translated"><a class="ae ls" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="noopener ugc nofollow" target="_blank"><em class="ko"/></a>:运行在每个节点上的“节点代理”</li><li id="c30d" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn my ml mm mn bi translated"><a class="ae ls" href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> kubeadm </em> </a>:创建Kubernetes集群的工具</li><li id="6a7e" class="mf mg it js b jt mo jx mp kb mq kf mr kj ms kn my ml mm mn bi translated"><a class="ae ls" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> kubectl </em> </a>:针对Kubernetes集群运行命令的命令行接口</li></ol><p id="0364" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">列表不完整。Kubernetes的组件更多:<em class="ko"> kube-apiserver </em>、<em class="ko"> kube-scheduler </em>、<em class="ko">kube-controller-manager</em>、<em class="ko"> etcd </em>、<em class="ko"> kubelet </em>、<em class="ko"> kube-proxy </em>以及不可数的addons。详细情况最好参考官方文档<a class="ae ls" href="https://kubernetes.io/docs/concepts/overview/components/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Kubernetes组件</strong> </a>。</p><p id="7161" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，kubeadm将在Kubernetes集群初始化时安装这些组件。</p><h2 id="5ad4" class="mz kq it bd kr na nb dn kv nc nd dp kz kb ne nf ld kf ng nh lh kj ni nj ll nk bi translated">操作系统</h2><p id="9369" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我在另一篇文章中写过关于操作选择的内容:<a class="ae ls" href="https://medium.com/@eduard.iskandarov/golang-development-for-raspberry-pi-3-getting-started-c6d5a97850d1" rel="noopener"> <strong class="js iu"> Golang为Raspberry Pi 3开发。</strong>入门</a>。</p><p id="5001" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TL；博士；医生</p><p id="72a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Ubuntu 18.04有ARM 64版本，甚至为Raspberry Pi准备了操作系统映像。Google用Kubernetes为ARM 64构建deb包。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="4229" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，请参考该文章，了解如何将操作系统映像刷新到SD卡并确定设备的IP地址。</p><h2 id="d919" class="mz kq it bd kr na nb dn kv nc nd dp kz kb ne nf ld kf ng nh lh kj ni nj ll nk bi translated">容器运行时和Kubernetes组件</h2><p id="857e" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">毫不奇怪，我们将使用<em class="ko"> Docker引擎</em>来运行容器。尽管有<a class="ae ls" href="https://coreos.com/rkt/" rel="noopener ugc nofollow" target="_blank"><em class="ko">rkt</em></a><a class="ae ls" href="https://cri-o.io/" rel="noopener ugc nofollow" target="_blank"><em class="ko">CRI-o</em></a>等替代。然而，仔细观察，我们可以看到Kubernetes使用了<a class="ae ls" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> containerd </em> </a>。对容器运行时的深入讨论超出了本文的范围。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="1782" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko"> kubelet </em>是一个节点代理。它与主节点上的<em class="ko"> kube-apiserver </em>通信，另一方面与本地容器运行时通信，以便按照主命令so运行Docker容器。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ns"><img src="../Images/390844e759c5743c5e7230deffaac4b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NsSH6unHDSrHlZK1e63CBA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">图3。Kubernetes节点组件</figcaption></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="4cc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">kubectl 是一个命令行界面，用于针对Kubernetes集群运行命令。它可以创建/读取/更新/删除kubernetes中的资源。例如:</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="6c37" class="mz kq it nu b gy ny nz l oa ob">$ kubectl create -f deployment.yaml<br/>$ kubectl create secret generic db-pass --from-file=./password.txt<strong class="nu iu"><br/></strong>$ kubectl get pods<br/>$ kubectl --namespace=kube-system edit deployment coredns<br/>$ kubectl delete node node1.kube.local</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="5086" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">kubeadm 是一个Kubernetes集群创建工具。在简单的情况下— <code class="fe oc od oe nu b">kubeadm init</code>命令创建一个kubernetes主节点；<code class="fe oc od oe nu b">kubeadm join</code>命令通过将节点与主节点相关联来将节点加入集群。</p><h1 id="b868" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">创建Kubernetes集群</h1><p id="ee39" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">假设SD卡是用Ubuntu 18.04操作系统闪存的，SD卡被插入设备，所有需要的布线都完成了，我们就有了如图2所示的东西。</p><p id="599d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以开始本文最激动人心的部分了——在Raspberry Pi上创建并运行Kubernetes集群。</p><p id="a085" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，从资源调配开始。为了自动化供应，我使用了<a class="ae ls" href="https://www.ansible.com/" rel="noopener ugc nofollow" target="_blank"> ansible </a>。自动化脚本和文档可以在GitHub库<a class="ae ls" href="https://github.com/toidi/home-kubernetes/" rel="noopener ugc nofollow" target="_blank">https://github.com/toidi/home-kubernetes/</a>获得。此外，在这篇文章中，我将尽量保持一个可翻译的小部分，它应该可以手动重现所有的步骤。</p><h2 id="f739" class="mz kq it bd kr na nb dn kv nc nd dp kz kb ne nf ld kf ng nh lh kj ni nj ll nk bi translated">Kubernetes主节点和节点供应</h2><p id="ee86" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">Kubernetes乍一看是一个复杂的系统。幸运的是，所有的复杂性都隐藏在几个可靠且优化良好的组件后面；比如kubelet和容器运行时。</p><p id="01c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，应特别注意网络规划。</p><p id="ae43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在主服务器上注册后，kubernetes节点提供其名称。该名称应该是唯一的，并且可被解析器(域名系统)发现。在云基础设施中，如亚马逊网络服务、谷歌云平台、微软Azure和其他——这是一种原生功能。任何虚拟机都有唯一且可解析的主机名；例如，<code class="fe oc od oe nu b">ip-12-34-56-78.us-west-2.compute.internal</code>被解析为<code class="fe oc od oe nu b">12.34.56.78</code> IP地址。<br/>在我们的例子中，Raspberry Pi设备默认有相似的主机名，这需要修正。有几种方法可以做到这一点。<br/>最先进的将是DHCP(动态主机配置协议)服务器与DNS(域名系统)服务器的集成，但对于我们力求简单的设置来说，这可能太复杂了。</p><p id="a1a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，为了解决这个问题，我们做了以下工作:<br/>使用<a class="ae ls" href="https://www.freedesktop.org/software/systemd/man/hostnamectl.html" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> hostnamectl </em> </a>命令行工具(例如<code class="fe oc od oe nu b">hostnamectl set-hostname node1.kube.local</code>)更新每台主机上的主机名，并在<em class="ko"> /etc/hosts </em>文件中为每台主机添加一条记录。</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="b695" class="mz kq it nu b gy ny nz l oa ob">192.168.40.102 master1.kube.local<br/>192.168.40.103 node1.kube.local<br/>192.168.40.104 node2.kube.local</span></pre><p id="fc01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我使用ansible automation。任务看起来如下:</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="0b2e" class="mz kq it nu b gy ny nz l oa ob">- name: Update hosts file<br/>  lineinfile:<br/>    dest: /etc/hosts<br/>    line: "{{ hostvars[item].ansible_host }} {{ item }}"<br/>    regexp: '.*{{ item }}$'<br/>  with_items: "{{ groups.all }}"<br/><br/>- name: Update host name<br/>  hostname:<br/>    name: "{{ inventory_hostname }}"</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="f4cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Linux控制组(<a class="ae ls" href="http://man7.org/linux/man-pages/man7/cgroups.7.html" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> cgroups </em> </a>)是容器和kubernetes生态系统的关键部分。没有适当的配置，事情不会像预期的那样工作。</p><p id="7d4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于某种原因，Ubuntu 18.04的Raspberry Pi build默认禁用内存控制组子系统。</p><p id="5570" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我们需要添加下面一行</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="0cf3" class="mz kq it nu b gy ny nz l oa ob">cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory</span></pre><p id="71a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到每个设备上的Linux内核cmd行。在Ubuntu 18.04中，<code class="fe oc od oe nu b">/boot/firmware/cmdline.txt</code>文件为Raspberry Pi设置了必需的参数。</p><p id="d191" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我为自动化创建了以下可完成的任务:</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="863b" class="mz kq it nu b gy ny nz l oa ob">- name: Enable memory control group subsystem<br/>  replace:<br/>    # <a class="ae ls" href="https://wiki.ubuntu.com/ARM/RaspberryPi#Raspberry_Pi_packages" rel="noopener ugc nofollow" target="_blank">https://wiki.ubuntu.com/ARM/RaspberryPi#Raspberry_Pi_packages</a><br/>    path: /boot/firmware/cmdline.txt<br/>    regexp: '(rootwait)$'<br/>    replace: '\1 cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory'</span></pre><p id="fd55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设备重启后，kubernetes拥有了所有需要的cgroups配置。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="92ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kuberntes没有太多的软件依赖。基本上，您所需要的就是启用一个官方的kubernetes apt存储库(https://apt.kubernetes.io/)。然后安装软件包:<em class="ko"> kubelet </em>，<em class="ko"> kubeadm </em>，<em class="ko"> docker </em>，<em class="ko"> kubectl </em>(仅主节点需要)。</p><p id="2c44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样。我们已经准备好设置kubernetes集群。</p><h2 id="6a53" class="mz kq it bd kr na nb dn kv nc nd dp kz kb ne nf ld kf ng nh lh kj ni nj ll nk bi translated">建立kubernetes集群</h2><p id="ffe4" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">现在，一切准备就绪——我们使用安全shell( <em class="ko"> ssh </em>)登录到主节点，并执行以下命令:</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="6ed4" class="mz kq it nu b gy ny nz l oa ob">kubeadm init --pod-network-cidr=10.244.0.0/16</span></pre><p id="8df3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能需要一段时间。大概15分钟左右。在此期间，kubeadm为kubernetes主组件提取docker映像，生成<a class="ae ls" href="https://kubernetes.io/docs/setup/certificates/" rel="noopener ugc nofollow" target="_blank"> PKI证书</a>并启动服务。</p><p id="e410" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果命令成功完成，将kubernetes管理配置复制到一个<em class="ko">Kubernetes</em>配置文件中，以便对Kubernetes集群运行命令。</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="3441" class="mz kq it nu b gy ny nz l oa ob">mkdir ~/.kube<br/>sudo cp /etc/kubernetes/admin.conf ~/.kube/config<br/>sudo chown $(id -u):$(id -g) ~/.kube/config</span></pre><p id="200e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一切顺利，kubernetes将回复命令:</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="8cc7" class="mz kq it nu b gy ny nz l oa ob">$ kubectl get node<br/>NAME                 STATUS     ROLES    AGE   VERSION<br/>master1.kube.local   NotReady   master   1h    v1.14.2</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="4fab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们启动并运行了master，将dumb Raspberry Pi机器转换成kubernetes节点就是一个简单的操作。第一步，我们使用以下命令在主节点上获得一个join命令:</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="04ba" class="mz kq it nu b gy ny nz l oa ob">$ kubeadm token create --print-join-command</span></pre><p id="c888" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe oc od oe nu b">kubeadm token create</code>命令的输出示例:</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="af84" class="mz kq it nu b gy ny nz l oa ob">kubeadm join 192.168.40.102:6443 --token xh0b2k.56yrq79emc79ad7n     --discovery-token-ca-cert-hash sha256:d4868076fbf3aa8dec5faa7add744350c9c0b3d9ba10a6ef09c08b42d5702870</span></pre><p id="7f06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一部分是在每个节点上执行命令。完成后，我们可以通过在主节点上运行<code class="fe oc od oe nu b">kubectl get node</code>命令来检查节点状态。</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="a349" class="mz kq it nu b gy ny nz l oa ob">$ kubectl get node<br/>NAME                 STATUS      ROLES    AGE   VERSION<br/>master1.kube.local   NotReady    master   11h   v1.14.2<br/>node1.kube.local     NotReady    &lt;none&gt;   10h   v1.14.2<br/>node2.kube.local     NotReady    &lt;none&gt;   10h   v1.14.2</span></pre><p id="9a52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有节点都已连接，但状态为<em class="ko">未就绪</em>，因为未设置容器网络。我们会马上解决这个问题！</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="75a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">容器网络是kubernetes集群设置中最重要的主题之一。基于您选择的网络模式—您可以有网络策略，也可以没有，可以扩展到数千个节点，可以启用加密。在正在运行的集群上切换容器网络是不可能的，因此应该考虑仔细的规划。</p><p id="4e91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初，我尝试使用<a class="ae ls" href="https://www.projectcalico.org/" rel="noopener ugc nofollow" target="_blank"> Calico CNI插件</a>。与其他网络插件相比，Calico有几个优势。特别是，它有ARM 64版本，它支持kubernetes中的<a class="ae ls" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank">网络策略</a>，它是资源高效的。出于某种原因，它没有工作；幸运的是，有一个简单而强大的解决方案——<a class="ae ls" href="https://github.com/coreos/flannel" rel="noopener ugc nofollow" target="_blank">法兰绒</a>，它确实有效。法兰绒是kubernetes集装箱网络的先驱。许多集群使用它；我们也是。</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="aebb" class="mz kq it nu b gy ny nz l oa ob">$ kubectl apply -f <a class="ae ls" href="https://raw.githubusercontent.com/coreos/flannel/v0.11.0/Documentation/kube-flannel.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/coreos/flannel/v0.11.0/Documentation/kube-flannel.yml</a></span></pre><p id="bbe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">细节超出了这个故事的范围。</p><p id="61ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，通过检查kubernetes节点和法兰绒pod状态，我们看到kubernetes已经启动并运行。</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="4feb" class="mz kq it nu b gy ny nz l oa ob">$ kubectl --namespace="kube-system" get pod --selector="app=flannel"<br/>NAME                          READY   STATUS    RESTARTS   AGE<br/>kube-flannel-ds-arm64-6lnd4   1/1     Running   0         10h<br/>kube-flannel-ds-arm64-g8ltj   1/1     Running   0         10h<br/>kube-flannel-ds-arm64-ntr2j   1/1     Running   0         10h</span><span id="6fa3" class="mz kq it nu b gy of nz l oa ob">$ kubectl get node<br/>NAME                 STATUS   ROLES    AGE   VERSION<br/>master1.kube.local   Ready    master   11h   v1.14.2<br/>node1.kube.local     Ready    &lt;none&gt;   10h   v1.14.2<br/>node2.kube.local     Ready    &lt;none&gt;   10h   v1.14.2</span></pre><p id="2654" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">法兰绒CNI豆荚已就位，kubernetes节点处于<em class="ko">就绪</em>状态。Kubernetes集群已经准备好进行第一次部署。</p><h1 id="2d28" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">在Kubernetes集群上部署测试应用</h1><p id="2029" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">有许多方法可以将应用程序部署到kubernetes。</p><p id="b188" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的代码片段中，我展示了一个示例终端会话，该会话在集群中创建一个nginx web服务器，并将其端口暴露给本地网络。</p><p id="c074" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，<code class="fe oc od oe nu b">kubectl create deployment nginx</code>命令在集群中创建一个<a class="ae ls" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署控制器</a>。Kubernetes scheduler根据部署定义创建一个<a class="ae ls" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" rel="noopener ugc nofollow" target="_blank"> pod </a>。一旦nginx pod处于<em class="ko">运行</em>状态，nginx网络服务器就准备好服务HTTP请求。</p><p id="bd2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe oc od oe nu b">kubectl create service nginx</code>命令创建<a class="ae ls" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">kubernets服务</a>。该服务将nginx pods公开为网络服务。</p><p id="2569" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不会深入讨论指挥细节和他们的旗帜。请参阅互联网上的官方文档和教程；幸运的是，现在有大量的信息可用。</p><pre class="lu lv lw lx gt nt nu nv nw aw nx bi"><span id="a140" class="mz kq it nu b gy ny nz l oa ob">$ kubectl create deployment nginx --image=nginx<br/>deployment.apps/nginx created</span><span id="17b2" class="mz kq it nu b gy of nz l oa ob">$ kubectl get deployments<br/>NAME    READY   UP-TO-DATE   AVAILABLE   AGE<br/>nginx   0/1     1            0           16s</span><span id="8bcd" class="mz kq it nu b gy of nz l oa ob">$ kubectl create service nodeport nginx --tcp=80:80<br/>service/nginx created</span><span id="06e1" class="mz kq it nu b gy of nz l oa ob">$ kubectl get pod<br/>NAME                     READY   STATUS    RESTARTS   AGE<br/>nginx-65f88748fd-7hb6x   1/1     Running   0          41s</span><span id="9528" class="mz kq it nu b gy of nz l oa ob">$ kubectl describe service nginx<br/>Name:                     nginx<br/>Namespace:                default<br/>Labels:                   app=nginx<br/>Annotations:              &lt;none&gt;<br/>Selector:                 app=nginx<br/>Type:                     NodePort<br/>IP:                       10.102.102.220<br/>Port:                     80-80  80/TCP<br/>TargetPort:               80/TCP<br/><strong class="nu iu">NodePort:                 80-80  31681/TCP<br/></strong>Endpoints:                10.244.2.8:80<br/>Session Affinity:         None<br/>External Traffic Policy:  Cluster<br/>Events:                   &lt;none&gt;</span></pre><p id="d0ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但需要注意的是，我们创建了<em class="ko"> NodePort </em>类型的服务，这意味着kubernetes将在节点机器级别公开该服务。要从本地网络访问服务，我们应连接kube <strong class="js iu">任何</strong>节点的IP地址，并使用服务的NodePort TCP端口(由kubernetes从30000–32767范围内随机分配)。</p><p id="10d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我将打开节点1的IP地址<strong class="js iu"> 192.168.40.103 </strong>和nginx的服务节点端口<strong class="js iu"> 31681 </strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi og"><img src="../Images/f9e51b5a1e67bd51c14815ca0e7f3bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*foIWOWKcbbWIMsKU4TjqEw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">图4。库本内特斯试验中的nginx</figcaption></figure><p id="b583" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">图4显示了我们可以访问kubernetes集群中的nginx web服务器。这证实了kubernetes集群、容器联网以及在kubernetes上的应用对rubber Pi的工作如预期。</p><h1 id="ba41" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">今后的步骤</h1><p id="6887" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated"><strong class="js iu">在覆盆子Pi和低端设备</strong>系列上构建一个kubernets集群，在接下来的部分中，我将解释如何正确地将kubernets资源公开给互联网(<a class="ae ls" href="https://medium.com/@eduard.iskandarov/building-a-kubernetes-cluster-on-raspberry-pi-and-low-end-equipment-part-2-33f21695251c" rel="noopener">链接</a>，为pod启用持久存储层，并寻找设备资源优化的方法。</p></div></div>    
</body>
</html>