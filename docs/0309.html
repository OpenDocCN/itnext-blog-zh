<html>
<head>
<title>Building Single Page App with Azure Functions and improving cold start time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Azure功能构建单页面应用程序并改善冷启动时间</h1>
<blockquote>原文：<a href="https://itnext.io/building-single-page-app-with-azure-functions-and-improving-cold-start-time-79a0faec9913?source=collection_archive---------2-----------------------#2018-02-15">https://itnext.io/building-single-page-app-with-azure-functions-and-improving-cold-start-time-79a0faec9913?source=collection_archive---------2-----------------------#2018-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/28f239c587328a7728f13d4f4d9d2b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ifIWH6wSDH5ejSAr."/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卡斯帕·鲁宾在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的“MacBook屏幕上的彩色代码行”</figcaption></figure><p id="b810" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我们使用React、Node、Express和MongoDB构建了一个单页面应用程序(实际上是一组多个SPA)。最初的计划是将其部署在公司的数据中心内，但是典型的公司流程导致获得所需硬件方面的延迟。此外，还要求提供电子邮件功能，而对于私有数据中心来说，这种事情很麻烦。</p><p id="18df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到成本因素和应用程序的低流量要求，我们决定使用Azure功能实现无服务器。它基于消费的定价模式非常适合我们的情况。</p><p id="72d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fbuilding-single-page-app-with-azure-functions-and-improving-cold-start-time-79a0faec9913" rel="noopener ugc nofollow" target="_blank"> <em class="lb">点击这里在LinkedIn上分享这篇文章</em> </a></p><h1 id="b38f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第1部分:迁移到Azure函数</h1><p id="1594" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">由于SPA使用基于REST的API与服务器进行交互，所以迁移很简单。唯一的困惑是如何托管静态文件。有两种选择，第一种是使用Azure Blob存储创建静态网站，第二种是使用Azure函数提供静态文件。我们选择了azure function，因为它可以为静态内容提供一致的安全机制，减少部署步骤，并且无需启用<em class="lb"> CORS </em>。</p><p id="4f4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文件夹结构看起来像这样</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6585" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">App</strong><br/>- <strong class="mk ir">staticserver</strong>/<br/>   index.js<br/>   function.json<br/>   wwwroot ==&gt; contained all the static files generated by Webpack    <br/>               for SPA<br/>- <strong class="mk ir">abc</strong>/<br/>   index.js<br/>   function.json<br/><strong class="mk ir">- xyz/<br/></strong>   index.js<br/>   function.json<br/>- <strong class="mk ir">packages.json</strong><br/>- <strong class="mk ir">proxies.json</strong></span></pre><p id="9bf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">staticserver是Azure Functions代理，它处理对https://ourpwa.azurewebsites.net/ui/*,的所有请求，并提供wwwroot文件夹中的文件。例如，如果用户请求/ui/home.html，它将简单地在wwwroot文件夹下查找“home.html”并返回它。</p><p id="04e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">API映射如下</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3b43" class="mo ld iq mk b gy mp mq l mr ms">https://ourpwa.azurewebsites.net/api/v1/abc<br/>https://ourpwa.azurewebsites.net/api/v1/xyz</span></pre><p id="955b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用于存储数据的Azure表存储和Blob存储。azure-storage和uuid只是用来实现各种API的两个npm包。</p><p id="9e9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切都运行良好，本地开发和调试非常容易。参考<a class="ae kc" href="https://goo.gl/39PE64" rel="noopener ugc nofollow" target="_blank">代码并在本地测试azure函数</a>以获取说明。请注意，2.x版还不支持代理，所以您必须使用运行时1.x版。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="f659" class="lc ld iq bd le lf na lh li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz bi translated">第2部分:部署到Azure并使用冷启动</h1><p id="5e43" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">用“<a class="ae kc" href="https://goo.gl/RxdneN" rel="noopener ugc nofollow" target="_blank"> local git </a>”部署也很简单，只需一个“git commit”就足以让一切在Azure上运行起来。</p><p id="7812" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">试运行也非常令人印象深刻，但很快我们就遇到了障碍，即“冷启动”的痛苦。在基于消费的模式下，Azure不会让你的功能全天候部署。对于任何新的请求，Azure将首先将功能部署到某个VM，然后让它们为请求服务。这种冷启动大约需要20秒，有时需要80-90秒。后续请求在大约50毫秒到500毫秒内得到处理。根据我们的观察，函数在大约10分钟的不活动状态下保持部署，然后被刷新。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9ea1b42279d0b80ab994f5e252f594e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*stQNvj72tWd3oU1FIWEsiw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Azure函数响应时间—红色表示冷启动</figcaption></figure><p id="96ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个大问题。一位用户与PWA交互了一段时间后，遇到了严重的性能问题。</p><p id="a945" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个众所周知的问题，在这里<a class="ae kc" href="https://goo.gl/BiJA1L" rel="noopener ugc nofollow" target="_blank">和这里</a>和<a class="ae kc" href="https://goo.gl/ar3u8N" rel="noopener ugc nofollow" target="_blank">这里</a>进行了详细的讨论。常见的解决方案是定期ping azure功能，或者转到“永远在线”选项。这两者都违背了只有在你的功能运行时才付费的消费模式的目的。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="8f82" class="lc ld iq bd le lf na lh li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz bi translated">第3部分:临时解决方案始终可用</h1><p id="2c02" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">团队需要一些解决方案，将它转换回基于Node.js的Azure web app是选项之一。Azure功能可以通过应用服务计划下的“永远在线”选项托管。在app服务计划中，你的功能App运行在类似web app的专用虚拟机上，解决了冷启动的问题，但也带来了成本。更多细节请参考<a class="ae kc" href="https://goo.gl/TKJnux" rel="noopener ugc nofollow" target="_blank"> Azure functions缩放和托管</a>。</p><p id="ae93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写了一些powershell脚本，在繁忙时段升级到“永远在线”，然后降级为“消费计划”。</p><p id="936f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为功能应用程序打开“始终打开”的脚本</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="729c" class="mo ld iq mk b gy mp mq l mr ms">$ResourceGroupName = "YOUR_RSGRP"<br/>$FunctionAppName = "YOUR_FUNCAPP"<br/>$WebAppResourceType = "microsoft.web/sites"<br/>$TempPlanName = "ALWAYS_ON_PLAN"<br/>$PlanLocation = "PLAN_LOCATION"<br/>$WebAppPropertiesObject = @{"siteConfig" = @{"AlwaysOn" = $true}}</span><span id="6550" class="mo ld iq mk b gy ng mq l mr ms"><em class="lb">#Create new plan</em><br/>New-AzureRmAppServicePlan -ResourceGroupName $ResourceGroupName    <br/>                          -Name $TempPlanName <br/>                          -Location $PlanLocation<br/>                          -Tier "Basic"<br/>                          -NumberofWorkers 1<br/>                          -WorkerSize "Small"</span><span id="90ac" class="mo ld iq mk b gy ng mq l mr ms"><em class="lb">#Set the web app to the new plan<br/></em>Set-AzureRmWebApp -ResourceGroupName $ResourceGroupName<br/>                  -Name $FunctionAppName<br/>                  -AppServicePlan $TempPlanName</span><span id="4c58" class="mo ld iq mk b gy ng mq l mr ms"><em class="lb">#Set the alwayson to true</em><br/>$webAppResource = Get-AzureRmResource<br/>                         -ResourceType $WebAppResourceType <br/>                         -ResourceGroupName $ResourceGroupName <br/>                         -ResourceName $FunctionAppName</span><span id="7844" class="mo ld iq mk b gy ng mq l mr ms">$webAppResource | Set-AzureRmResource<br/>                         -PropertyObject $WebAppPropertiesObject</span></pre><p id="fe15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恢复到消耗计划的脚本</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="348f" class="mo ld iq mk b gy mp mq l mr ms">$ResourceGroupName = "YOUR_RSGRP"<br/>$FunctionAppName = "YOUR_FUNCAPP"<br/>$WebAppResourceType = "microsoft.web/sites"<br/>$TempPlanName = "ALWAYS_ON_PLAN"<br/>$PayAsYouGoPlanName = "CONSUMPTION_PLAN"<br/>$PlanLocation = "PLAN_LOCATION"<br/>$WebAppPropertiesObject = @{"siteConfig" = @{"AlwaysOn" = $false}}<br/><br/><em class="lb">#Set the always on to false<br/>#without that you wont be able to change the plan</em><br/>$webAppResource = Get-AzureRmResource<br/>                         -ResourceType $WebAppResourceType   <br/>                         -ResourceGroupName $ResourceGroupName <br/>                         -ResourceName $FunctionAppName</span><span id="5219" class="mo ld iq mk b gy ng mq l mr ms">$webAppResource | Set-AzureRmResource<br/>                         -PropertyObject $WebAppPropertiesObject <br/>                         </span><span id="79b6" class="mo ld iq mk b gy ng mq l mr ms"><em class="lb">#Update the plan for Azure function app</em><br/>Set-AzureRmWebApp -ResourceGroupName $ResourceGroupName<br/>                  -Name $FunctionAppName<br/>                  -AppServicePlan $PayAsYouGoPlanName</span><span id="792b" class="mo ld iq mk b gy ng mq l mr ms">#Delete the plan<br/>Remove-AzureRmAppServicePlan -ResourceGroupName $ResourceGroupName <br/>                             -Name $TempPlanName                      </span></pre><blockquote class="nh ni nj"><p id="a328" class="kd ke lb kf b kg kh ki kj kk kl km kn nk kp kq kr nl kt ku kv nm kx ky kz la ij bi translated">重要:空的azure服务计划与托管应用程序的azure服务计划的成本相同，因此请确保删除未附加到任何应用程序的azure服务计划。</p></blockquote><p id="0733" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这暂时缓解了冷启动问题，但以基本应用服务计划为代价。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="35f1" class="lc ld iq bd le lf na lh li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz bi translated">第4部分:摆脱npm包，拯救Webpack。</h1><p id="4985" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">经过调查，我们发现在冷启动期间，大部分时间都用于恢复虚拟机上的npm程序包。为了摆脱npm包，我们决定使用webpack来打包功能。通常，在使用webpack构建节点应用程序时，“<a class="ae kc" href="https://goo.gl/nKoeoj" rel="noopener ugc nofollow" target="_blank"> webpack-node-externals </a>”有助于避免捆绑其节点模块依赖关系。但是这里需要将所有的依赖项捆绑在一起并创建一个文件。在UglifyJSPlugin的帮助下使用树摇动技术，可以进一步优化这个包。</p><p id="ca26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同时，我们将函数转换为TypeScript。这是更新后的结构</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="32ca" class="mo ld iq mk b gy mp mq l mr ms"><strong class="mk ir">App</strong><br/>- <strong class="mk ir">staticserver</strong>/<br/>   index.js<br/>   function.json<br/>   wwwroot ==&gt; contained all the static files generated by Webpack    <br/>               for SPA<br/>- <strong class="mk ir">abc</strong>/<br/>   index.js<br/>   function.json<br/><strong class="mk ir">- xyz/<br/></strong>   index.js<br/>   function.json<br/>- <strong class="mk ir">proxies.json</strong></span></pre><p id="7179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">注意:现在每个index.js都是某种编译过的JavaScript，包含了它需要运行的所有代码，没有任何依赖node_modules。没有package.json，Azure会在部署前查找package.json并还原包，影响冷启动时间。确保即使在子文件夹下也没有package.json。</em></p><p id="e827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该出结果了</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/74cfb065c1f1bdb30bf28db29b6c9614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A0DgUg0t0AdFF8hGqoA4gQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">红框表示删除npm依赖关系之前的冷启动，蓝框表示删除npm依赖关系之后的冷启动时间。</figcaption></figure><p id="633b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，消除npm依赖性有助于我们将冷启动时间从21秒减少到3秒。对于我们的应用程序来说，3秒已经足够了。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="0e0e" class="lc ld iq bd le lf na lh li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz bi translated">离别的思绪</h1><ul class=""><li id="e350" class="no np iq kf b kg ma kk mb ko nq ks nr kw ns la nt nu nv nw bi translated">移除npm依赖性使得Azure Function成为托管低流量PWA的有吸引力的模型。</li><li id="423c" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la nt nu nv nw bi translated">如果你有一个流量很大的网站，Azure Functions不是选择，最好选择Azure web app或其他基于PaaS的选项。</li><li id="0fcc" class="no np iq kf b kg nx kk ny ko nz ks oa kw ob la nt nu nv nw bi translated">Azure团队也发布了一个工具<a class="ae kc" href="https://goo.gl/ND5Bvc" rel="noopener ugc nofollow" target="_blank"> Funpack </a>来解决这个问题，<a class="ae kc" href="https://goo.gl/7p9jrc" rel="noopener ugc nofollow" target="_blank">查看这篇msdn文章</a>了解更多细节。</li></ul><p id="8fbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这篇文章对你有用，欢迎留下评论。</p></div></div>    
</body>
</html>