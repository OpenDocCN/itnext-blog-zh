<html>
<head>
<title>Writing SQL in C# or When You should not use ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不应该使用ORM的时候用C#编写SQL</h1>
<blockquote>原文：<a href="https://itnext.io/writing-sql-in-c-or-when-you-should-not-use-orm-5800a868db43?source=collection_archive---------1-----------------------#2021-02-22">https://itnext.io/writing-sql-in-c-or-when-you-should-not-use-orm-5800a868db43?source=collection_archive---------1-----------------------#2021-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0d27a3a8c02cd43709914817d060132a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANPmPrnM8US80_Ogy2zasA.png"/></div></div></figure><p id="c4ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我注意到当有必要在。Net应用程序，开发人员经常选择一些ORM库(。Net实体框架)，甚至没有考虑其他替代方案。乍一看，这是一个合理的决定，因为对于流行的ORM库来说，有很多教程、很棒的工具包和很多有经验的开发人员。但是，这并不总是一个好的选择，如果您的应用程序:</p><ol class=""><li id="34c5" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">主要处理事实关系，而不是对象</li><li id="d630" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">需要使用动态(非预定义)查询</li></ol><h1 id="28a8" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">事实关系</h1><p id="a43e" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">如果您的应用程序主要实现与这些类似的用例:</p><p id="67e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1)“给我一份按部门分类的薪水最高的员工名单”</p><p id="9e41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2)“给所有4月份注册的客户打折”</p><p id="42e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3)“将去年系列的t恤价格降低20%”</p><p id="291f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么您的应用程序将关注事实关系而不是对象，因为所有这些场景都涉及处理不可预测的数据量。例如，组织可能有2个部门和30名员工，或者有数百个部门和数十万名员工。如果使用某种ORM，则假设所有数据都被加载到内存中，然后进行分析，如果是写操作，则上传回SQL数据库。显然，这不能不影响性能。</p><p id="848c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mn">注。现代ORM库有许多方法来解决性能问题，如LINQ表达式可转换为SQL、延迟加载等。但我们必须记住，这些只是部分缓解概念问题的技巧，问题在某些时候不可避免地会出现。</em></p><p id="9f0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，SQL是专门为处理事实关系而设计的，上面描述的场景可以用几个相对简单的表达式来实现。显然，在这里使用没有任何ORM的纯SQL是有意义的，但是我们有什么选择呢？没有那么多。常见的有:</p><p id="a25d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1)存储过程</p><p id="a43f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2)基于文本的查询</p><p id="e020" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3)一些基于LINQ的查询构建器(例如“LINQ到数据库”)</p><p id="2750" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4) <a class="ae mo" href="https://github.com/0x1000000/SqExpress" rel="noopener ugc nofollow" target="_blank">我的图书馆“sq express”</a>:)</p><h1 id="506d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">存储过程</h1><p id="5125" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">当您需要使用本机SQL的全部功能时，首先想到的是存储过程，但是这种方法有几个严重的缺点:</p><p id="e1a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1) <strong class="ka ir">维护困难</strong>——总是需要确保。Net代码与应用程序使用的所有数据库实例中的存储过程代码同步。这意味着您注定要在几乎每个部署中弄乱迁移脚本，并且不可避免地会在某个时候出错。</p><p id="573f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2) <strong class="ka ir"> SQL是一种很棒的查询语言，但却是一种非常糟糕的编程语言</strong> —一旦你开始编写存储过程，你将很难抵制将尽可能多的逻辑移入其中的诱惑，因为这是一种解决性能问题和快速修复应用程序设计中的问题的简单方法。但是不利的一面是，您将无法将您的逻辑分解成小模块并孤立地测试它们(我经常看到内部有数百个变量的五千行的“超级”过程)</p><p id="0765" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3) <strong class="ka ir">复制粘贴</strong> —程序中的代码很难重用(不过函数部分解决了这个问题)，所以一些通用的逻辑会在很多程序中重复。</p><p id="0364" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4) <strong class="ka ir">难以实现批量加工</strong>。<em class="mn"> UpdateUserById </em> —这是存储过程的典型名称。但是如果我有100个用户呢？没问题！让我们调用过程100次！唯一的问题是，这将花费100倍的时间(一些数据库支持表值参数，但这种参数很难使用和维护)。</p><p id="1771" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5)如果您需要动态查询，存储过程没有帮助</p><p id="a657" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">6)如果您经常使用存储过程，那么迁移到另一个SQL数据库将会非常困难。</p><h1 id="8b9c" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">基于文本的查询</h1><p id="9adc" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">由简单的字符串连接产生的查询是非常糟糕的。这样的代码很难编写、阅读和维护。安全性也是一个大问题——Sql注入在今天仍然是相关的。</p><p id="7600" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，令人惊讶的是，这种方法也有一些积极的方面:</p><p id="5988" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1)除了任何其他方法之外，您还可以使用该方法</p><p id="1feb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2)它仍然是创建每个人都可以使用的动态查询的最流行的方法。</p><h1 id="b3a3" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">基于LINQ的查询构建器</h1><p id="6cdb" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">当您需要达到SQL能力时，这样的查询构建器(例如<a class="ae mo" href="https://linq2db.github.io/" rel="noopener ugc nofollow" target="_blank">“LINQ到数据库”</a>)可能是一个不错的选择。“左”、“右”、“全”、“交叉”连接等。不再是一个问题——您可以直接用C#代码表达它们(使用LINQ):</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3cbf" class="my ll iq mu b gy mz na l nb nc">//Full Join<br/>var query =<br/>    from c in db.Category<br/>    from p in db.Product.FullJoin(pr =&gt; pr.CategoryID == c.CategoryID)<br/>    where !p.Discontinued<br/>    select c;</span></pre><p id="be05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mn">也支持cte</em></p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="277f" class="my ll iq mu b gy mz na l nb nc">//CTE<br/>var employeeSubordinatesReport  =<br/>   from e in db.Employee<br/>   select new<br/>   {<br/>      e.EmployeeID,<br/>      e.LastName,<br/>      e.FirstName,<br/>      NumberOfSubordinates = db.Employee<br/>          .Where(e2 =&gt; e2.ReportsTo == e.ReportsTo)<br/>          .Count(),<br/>      e.ReportsTo<br/>   };<br/><br/>var employeeSubordinatesReportCte = employeeSubordinatesReport<br/>                                       .AsCte("EmployeeSubordinatesReport");</span><span id="6942" class="my ll iq mu b gy nd na l nb nc">var result =<br/>   from employee in employeeSubordinatesReportCte<br/>   from manager in employeeSubordinatesReportCte<br/>                      .LeftJoin(manager =&gt; employee.ReportsTo == manager.EmployeeID)<br/>   select new<br/>   {<br/>      employee.LastName,<br/>      employee.FirstName,<br/>      employee.NumberOfSubordinates,<br/>      ManagerLastName = manager.LastName,<br/>      ManagerFirstName = manager.FirstName,<br/>      ManagerNumberOfSubordinates = manager.NumberOfSubordinates<br/>   };</span></pre><p id="b3da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，当涉及到动态查询时，LINQ并不是最好的解决方案。理论上，改变表达是可能的，但这不是一个简单的动作。</p><h1 id="ee4b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">SqExpresss</h1><p id="57a0" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">多年来，我一直不喜欢使用SQL。但是后来我写了<a class="ae mo" href="https://github.com/0x1000000/SqExpress" rel="noopener ugc nofollow" target="_blank">我自己的库(SqExpress) </a>它允许我尽可能接近SQL地写C #代码。它不使用LINQ —查询构建是通过助手函数和操作符重载实现的。因此，动态查询没有任何问题。这里有一个例子:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="418d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">还是ORM？</strong></h1><p id="3505" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">还有一个问题:“什么时候ORM是一个好的解决方案？”良好的..让我们颠倒一下不推荐使用ORM的条件:</p><ol class=""><li id="c569" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在绝大多数情况下，您可以准确地预测数据库表中将被读取或修改的行数(这意味着所有数据都可以映射到对象)</li><li id="5ecb" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">不经常需要动态查询</li></ol><p id="fd38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果满足这些条件，那么ORM很可能是正确的选择。</p><p id="cfb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">—</p><p id="43f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇短文能帮助您决定哪种使用SQL数据库的方式最适合您的应用程序，或者至少您会有所反思，而不会做出草率的决定。</p><p id="ca28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">链接:</p><ul class=""><li id="87fe" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv ng lc ld le bi translated"><a class="ae mo" href="https://github.com/linq2db/linq2db" rel="noopener ugc nofollow" target="_blank"> linq to db on github </a></li><li id="b36c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ng lc ld le bi translated"><a class="ae mo" href="https://github.com/0x1000000/SqExpress" rel="noopener ugc nofollow" target="_blank">github上的SqExpress</a></li><li id="953e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv ng lc ld le bi translated"><a class="ae mo" rel="noopener ugc nofollow" target="_blank" href="/syntax-tree-and-alternative-to-linq-in-interaction-with-sql-databases-656b78fe00dc?source=friends_link&amp;sk=f5f0587c08166d8824b96b48fe2cf33c">“语法树和与SQL数据库交互的LINQ的替代方案”</a> -我的与此主题相关的文章预览</li></ul></div></div>    
</body>
</html>