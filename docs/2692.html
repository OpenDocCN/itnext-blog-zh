<html>
<head>
<title>restana-static, serving the frontend with Node.js beyond Nginx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">restana-static，用超出Nginx的Node.js服务前端</h1>
<blockquote>原文：<a href="https://itnext.io/restana-static-serving-the-frontend-with-node-js-beyond-nginx-e45fdb2e49cb?source=collection_archive---------3-----------------------#2019-07-12">https://itnext.io/restana-static-serving-the-frontend-with-node-js-beyond-nginx-e45fdb2e49cb?source=collection_archive---------3-----------------------#2019-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/069f138d6bea531fe26848202c7f5d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S60YI_RRtU2-tYeWIGg4NA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">静态文件类比；)——图片由<a class="ae kc" href="https://pexels.com/" rel="noopener ugc nofollow" target="_blank">https://pexels.com</a>提供</figcaption></figure><p id="84db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lb">不要用Node.js来服务静态文件，这样效率不高</em>。你应该用Nginx！</strong></p><p id="8109" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这话我听了多少遍了，你呢？正确答案是:<br/> <strong class="kf ir"> <em class="lb">嗯，看情况吧！</em> </strong></p><p id="bbb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将描述如何使用Node.js有效地服务静态文件，特别是在前端应用程序的上下文中。</p><h1 id="3364" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">码头集装箱？</h1><p id="2edd" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">如今，我们当然使用Docker来服务前端应用程序，并且有很多很好的理由这样做:<a class="ae kc" href="https://www.kiratech.it/en/blog/the-6-benefits-of-docker-container" rel="noopener ugc nofollow" target="_blank"><em class="lb">Docker容器的6个好处</em> </a></p><p id="59f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着，在构建前端应用程序之后，我们将生成的静态文件打包在一个版本化的docker映像中，并部署它。在这种情况下，文件状态永远不会改变。</p><h1 id="79be" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">我们的前端演示</h1><p id="6de2" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">为了简单起见，在本文中，我们将使用一个非常简单的HTML前端:</p><p id="fd96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单个"<strong class="kf ir"><em class="lb">【index.html】</em></strong>"文件下的"<strong class="kf ir"> <em class="lb"> src </em> </strong>"目录:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="a1be" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用restana和静态服务中间件提供静态文件服务</h1><p id="936e" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">让我们使用<a class="ae kc" href="https://www.npmjs.com/package/restana" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> restana </em> </a>和<a class="ae kc" href="https://www.npmjs.com/package/serve-static" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> serve-static </em> </a>实现一个Node.js服务器来服务前端静态文件。</p><h2 id="3155" class="ml ld iq bd le mm mn dn li mo mp dp lm ko mq mr lq ks ms mt lu kw mu mv ly mw bi translated">基本设置，从文件系统加载文件</h2><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="901a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“<strong class="kf ir"> <em class="lb"> serve-static </em> </strong>”的默认设置使用<strong class="kf ir"><em class="lb">Last-Modified</em></strong>和<strong class="kf ir"> <em class="lb"> ETag </em> </strong>头启用HTTP缓存，这样我们可以通过在浏览器缓存中保存文件副本来减少网络开销。</p><p id="3465" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里描述了可用的配置选项和高级用例:<a class="ae kc" href="https://www.npmjs.com/package/serve-static" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/serve-static</a></p><h2 id="a60b" class="ml ld iq bd le mm mn dn li mo mp dp lm ko mq mr lq ks ms mt lu kw mu mv ly mw bi translated">从RAM提供文件</h2><p id="9755" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">正如我们提到的，如果您使用docker容器来公开您的前端应用程序，您可能还会发现您的文件永远不会改变。在这种情况下，我们可以直接从RAM提供文件，并提供最高的性能:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="07ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序将在<em class="lb">“1周”</em>期间提供来自RAM的静态文件，并在客户端浏览器上启用HTTP缓存。<strong class="kf ir"><em class="lb">http-cache-middleware</em></strong>模块的高级用例可从这里获得:<a class="ae kc" href="https://www.npmjs.com/package/http-cache-middleware" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/http-cache-middleware</a></p><p id="3868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">别担心，通过使用<strong class="kf ir"><em class="lb">Cache-Control</em></strong>头中的<strong class="kf ir"> <em class="lb"> no-cache </em> </strong>指令，我们告诉浏览器在提交缓存的内容之前向服务器验证缓存状态。因此，如果您部署一个新版本的前端应用程序(意味着一个新的docker映像)，新的内容将按预期立即提供。</p><h1 id="95fa" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">restana-static与Nginx</h1><p id="6899" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这种替代品与Nginx相比如何？</p><blockquote class="mx my mz"><p id="29f7" class="kd ke lb kf b kg kh ki kj kk kl km kn na kp kq kr nb kt ku kv nc kx ky kz la ij bi translated"><strong class="kf ir"> NGINX </strong>是一款开源软件，用于web服务、反向代理、缓存、负载平衡、媒体流等等。它最初是一个为获得最佳性能和稳定性而设计的web服务器。除了HTTP服务器功能，NGINX还可以充当电子邮件(IMAP、POP3和SMTP)的代理服务器，以及HTTP、TCP和UDP服务器的反向代理和负载平衡器。</p><p id="9f80" class="kd ke lb kf b kg kh ki kj kk kl km kn na kp kq kr nb kt ku kv nc kx ky kz la ij bi translated"><a class="ae kc" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank">HTTPS://WWW.NGINX.COM/</a></p></blockquote><p id="3c14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是MacBook Pro 2016、2,7 GHz英特尔酷睿i7、16 GB 2133 MHz LPDDR3的基本基准测试，使用:</p><blockquote class="mx my mz"><p id="1018" class="kd ke lb kf b kg kh ki kj kk kl km kn na kp kq kr nb kt ku kv nc kx ky kz la ij bi translated">wrk-t8-c8-d20s<a class="ae kc" href="http://127.0.0.1:3000/index.html" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/index . html</a></p></blockquote><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/aecb98457f75ebe67096d90097846897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*Db6qAfIfJIo-GYzl.png"/></div></figure><blockquote class="mx my mz"><p id="eacc" class="kd ke lb kf b kg kh ki kj kk kl km kn na kp kq kr nb kt ku kv nc kx ky kz la ij bi translated">在这个测试中，我们使用了HTTP服务器的单个实例，在集群模式下，数字应该更高。</p></blockquote><h1 id="4e21" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Docker图像</h1><p id="85ff" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">“restana-static”方法也可以通过https://hub.docker.com/r/kyberneees/restana-static的docker获得，也包括日志支持。</p><h2 id="72a5" class="ml ld iq bd le mm mn dn li mo mp dp lm ko mq mr lq ks ms mt lu kw mu mv ly mw bi translated">使用示例:</h2><pre class="mf mg mh mi gt ne nf ng nh aw ni bi"><span id="f58b" class="ml ld iq nf b gy nj nk l nl nm">FROM kyberneees/restana-static:latest<br/>RUN rm dist/index.html<br/>RUN echo "Hello World!" &gt;&gt; dist/index.html</span></pre><h1 id="0084" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="38f5" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在本文中，我们已经描述了如何使用Node.js + restana + serve-static高效地服务静态文件(即前端)。我们很快提到了浏览器缓存集成以及与Nginx的性能比较。</p><blockquote class="mx my mz"><p id="5e4f" class="kd ke lb kf b kg kh ki kj kk kl km kn na kp kq kr nb kt ku kv nc kx ky kz la ij bi translated">不要误会，Nginx很棒，非常成熟！但是如果你和我一样是一个“全是JavaScript”的人，并且你也想要更多的自由和对代码的控制，你可以试一试，Node.js在这方面也很棒！</p></blockquote></div></div>    
</body>
</html>