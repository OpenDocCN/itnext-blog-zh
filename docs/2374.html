<html>
<head>
<title>Creating a Parallax Background in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在颤动中创建视差背景</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-parallax-background-in-flutter-5e8b5f4bb837?source=collection_archive---------0-----------------------#2019-05-14">https://itnext.io/creating-a-parallax-background-in-flutter-5e8b5f4bb837?source=collection_archive---------0-----------------------#2019-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4880" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Flutter中构建具有视差背景的选项卡导航器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/11066ad371b3b4676b0c2f4f0df471b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RxKa1hTOBwjSAgLNBGeQ5g.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行<a class="ae ky" href="https://github.com/kenreilly/flutter-parallax-nav-demo" rel="noopener ugc nofollow" target="_blank">颤振-视差-导航-演示</a>项目的iOS模拟器的屏幕截图</figcaption></figure><h2 id="d389" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="afa0" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在这篇文章中，我们将看看使用<a class="ae ky" href="https://www.dartlang.org" rel="noopener ugc nofollow" target="_blank"> Dart </a>和<a class="ae ky" href="https://flutter.dev" rel="noopener ugc nofollow" target="_blank"> Flutter创建具有同步视差背景的可滚动标签导航布局的过程。</a></p><p id="0396" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">Dart和Flutter是移动开发的绝佳组合。从Silverlight和WPF到数十种不同的桌面、web和移动平台，我已经构建了各种用户界面，我发现Flutter为快速构建丰富的移动应用程序体验提供了一个很好的环境。</p><p id="a439" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果您还没有Flutter SDK，请转到<a class="ae ky" href="https://flutter.dev/docs/get-started/install" rel="noopener ugc nofollow" target="_blank">安装页面</a>，按照您的操作系统的说明进行操作。如果您想要一份本文中使用的演示项目的源代码，请在这里查看<a class="ae ky" href="https://github.com/kenreilly/flutter-parallax-nav-demo" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="4e54" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">入门</strong></h2><p id="7855" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">让我们来看看项目结构及其定义文件，<strong class="lx iu"> pubspec.yaml </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/594c9c05aa66ac5dd856cb4e5f83ca69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUP7cNry7G8TXornw-lAjw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">添加了<strong class="bd lb"> event_bus </strong>包和图像<strong class="bd lb">资产</strong>的默认<strong class="bd lb"> pubspec.yaml </strong></figcaption></figure><p id="7096" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在项目定义文件<strong class="lx iu"> pubspec.yaml </strong>中，增加了<strong class="lx iu"> event_bus </strong>依赖关系。事件总线允许侦听器订阅事件，并允许发布者触发这些事件。关于Dart的<strong class="lx iu"> event_bus </strong>包及其工作原理的更多信息，<a class="ae ky" href="https://pub.dev/packages/event_bus/versions/0.2.3" rel="noopener ugc nofollow" target="_blank">查看这里</a>。同样在该文件中，背景图像作为图像资产包含在<strong class="lx iu">资产下。</strong>这将允许从应用程序中引用和显示图像文件。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="75e4" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">主应用程序容器</h2><p id="78e5" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">接下来，让我们检查应用程序的主入口文件，<strong class="lx iu"> lib/main.dart </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/cd25db48aa9e44b7a33c2bf45ab401c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_YjTxCR7wlmhXrESdaGpcw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有顶级小部件构建器的应用入口文件<strong class="bd lb"> lib/main.dart </strong></figcaption></figure><p id="03ea" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个文件定义了根应用程序组件<strong class="lx iu"> ParallaxDemo </strong>，它是一个<a class="ae ky" href="https://docs.flutter.io/flutter/widgets/StatelessWidget-class.html" rel="noopener ugc nofollow" target="_blank"> StatelessWidget </a>，返回一个<strong class="lx iu"> MaterialApp </strong>组件，带有我们的标题<em class="nb">“视差背景”</em>、一些默认主题数据和home <strong class="lx iu"> AppContainer </strong>小部件。</p><p id="dc28" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在这个项目中,“屏幕”的定义只是字母A到E，为了简单起见，我们将它们表示为选项卡图标和屏幕内容。</p><p id="d8cc" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">请注意，我们的<strong class="lx iu"> main() </strong>函数已经使用<strong class="lx iu"> async </strong>进行了定义，以允许调用异步方法<strong class="lx iu">system chrome . setpreferedorientations()，</strong>，该方法将设备方向锁定到<strong class="lx iu">device orientation . portraitup .</strong>这只是为了方便起见而选择的，并且可以针对任何目的进行修改。</p><p id="f001" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在让我们检查一下<strong class="lx iu">组件/app-container.dart </strong>中的<strong class="lx iu"> AppContainer </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/c72a3ef17a3a439db054ef5c35fad602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4eLXn0iWLqXBWB_bGLegQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有堆叠在z轴上的<strong class="bd lb">背景</strong>和<strong class="bd lb">导航容器</strong>的<strong class="bd lb"> AppContainer </strong>类</figcaption></figure><p id="9052" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个类还扩展了StatelessWidget，因为它只是一个没有自己状态的容器。它采用<strong class="lx iu">屏幕</strong>参数，即我们的字母列表<em class="nb"> A </em>到<em class="nb"> E </em>。注意，构建器返回了<strong class="lx iu"> WillPopScope </strong>，这允许这个小部件捕获Android back按钮，然后调用<em class="nb"> onWillPop </em>处理程序中的<strong class="lx iu"> NavigationBus </strong>向上游转发事件。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="8639" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">可滚动背景</strong></h2><p id="ad0e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们要检查的下一个组件类是背景小部件，它位于<strong class="lx iu">lib/components/Background . dart</strong>中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/9c773d02dc04aaf9274c8ae838fd452e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IVVT-kktxbQIkUEyewxBxQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有各种属性和初始化器的<strong class="bd lb">背景</strong>类</figcaption></figure><p id="4c6b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">与我们之前检查的类文件不同，这个<strong class="lx iu">背景</strong>类扩展了一个<a class="ae ky" href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html" rel="noopener ugc nofollow" target="_blank"> StatefulWidget </a>来支持本地可变状态属性和事件触发使用<strong class="lx iu"> setState() </strong>重绘的能力。有一个<em class="nb"> aspectRatio </em>属性，我将它任意设置为<em class="nb"> 16/9 </em>，但它可以是任何纵横比，这取决于您选择显示的图像以及您打算在应用程序中支持的设备大小和方向。此外，还有一个<strong class="lx iu"> initState() </strong>方法覆盖，它在上一个类中出现的同一个<strong class="lx iu"> NavigationBus </strong>上注册一个事件侦听器。该监听器的目的是当新的<strong class="lx iu">动画</strong>对象在事件总线上可用时，使该小部件重新绘制自身。由于滚动标签动画在背景第一次被创建时不太可能存在，这确保了一旦它被滚动标签控制器创建，它将接收到对更新的动画的引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/f9a9c0cb12eefde57016676b9d26e5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3U4eL3ix6zvhKBoQ7zX1g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">显示<strong class="bd lb">构建</strong>方法的<strong class="bd lb">背景</strong>类</figcaption></figure><p id="e00f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">用于<strong class="lx iu">背景</strong>类的<strong class="lx iu">构建</strong>方法获取对NavController上可用的<strong class="lx iu">动画</strong>的当前实例的引用，将其传递给<strong class="lx iu"> AnimatedBuilder </strong>，然后计算对齐偏移量，该偏移量为动画值的10%。在这个有五个屏幕的例子中，<em class="nb"> animation.value </em>的值的范围是从<em class="nb"> 0.0 </em>到<em class="nb"> 4.0 </em>，我们依次从<em class="nb"> 0.0 </em>到<em class="nb"> 0.4 </em>映射到<strong class="lx iu">对齐</strong>小部件，它使用这个值作为一个百分比来偏移<strong class="lx iu">溢出框</strong>的子对象。这对于我们的示例项目来说非常有用，但是在现实应用中，图像的实际位置将取决于它的大小和用于视差效果的<strong class="lx iu">比例</strong>。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="96f3" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">导航事件总线</strong></h2><p id="4c29" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">接下来是我们唯一的服务文件，<strong class="lx iu">services/navigation-bus . dart</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/d0c46b7676a0be918f15299dddeff9bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6hxcd-D26sw4vzCUvPHFw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">文件<strong class="bd lb">services/navigation-bus . dart</strong>带有事件类型和<strong class="bd lb"> NavigationBus </strong>类</figcaption></figure><p id="be4e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">就在<strong class="lx iu"> NavigationBus </strong>类的上面，有几个针对事件类型的单行类定义，在根据事件类型将事件转发给特定侦听器时会用到它们。创建了一个<strong class="lx iu"> EventBus </strong>的实例，并且有一个用于<em class="nb">动画的getter，</em>返回一个<strong class="lx iu"> AlwaysStoppedAnimation </strong>，除非有一个<strong class="lx iu"> TabController </strong>的实例可用，此时它将开始返回该控制器的动画，以允许其他小部件将自己从选项卡导航器的变化动画值中移走。还有注册新侦听器的方法。其中的第一个，<strong class="lx iu">registerNavigationListener</strong>()，没有在这个项目中使用，但它提供了一个示例，说明如何使用<strong class="lx iu"> EventBus </strong>来跟踪应用范围内的导航事件，以处理各种事情，从触发后台网络请求到记录分析或任何其他事情。另一个事件监听器<strong class="lx iu">registercontrolrattachedlistener</strong>被<strong class="lx iu">后台</strong>类用来订阅<strong class="lx iu">ControllerAttachedEvent</strong>类型的事件。</p><p id="b3a8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当一个<strong class="lx iu"> TabController </strong>被注册到总线上时，一个对它的引用被保存，来自它的动画事件通过处理程序<strong class="lx iu">onupdatabanimation被转发到事件总线。</strong>此外，一个<strong class="lx iu">ControllerAttachedEvent</strong>沿着总线被触发，以通知任何相关组件获取一个新的<strong class="lx iu">动画</strong>的副本，就像<strong class="lx iu">背景</strong>只在固定位置开始的情况一样，然后一旦一切启动并运行，就开始跟随选项卡导航器。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="6bee" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">导航集装箱UX</h2><p id="89db" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">导航组件分为三个文件:父容器、屏幕内容本身的小部件和选项卡导航图标的小部件。我们将从主导航文件<strong class="lx iu">components/nav-container . dart</strong>开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/e111f62514b6272d6b552933ae252c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-JXqM_e8rkXt-dgIQeH5Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有各种状态属性的<strong class="bd lb"> NavContainer </strong>类</figcaption></figure><p id="edfd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> NavContainer </strong>作为父容器，用于显示应用程序内容本身和底部选项卡。对于<strong class="lx iu"> TabController </strong>和<strong class="lx iu">动画</strong>有一个<em class="nb">子</em>属性和局部引用。<strong class="lx iu"> _tabs </strong> getter从<em class="nb">子</em>属性<em class="nb"> ( </em>字母<em class="nb"> A </em>到<em class="nb">E】</em>开始，将其<em class="nb"> </em>映射到带有<strong class="lx iu"> NavTabIcon </strong>实例的<strong class="lx iu">列表&lt; Tab &gt; </strong>，突出显示当前选中的选项卡。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/387b3f63b65c6af41d12a3078e320d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_KY-GRvnH92DlSKheLspw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">显示_ <strong class="bd lb">路线</strong>和各种覆盖的<strong class="bd lb"> NavContainer </strong>类</figcaption></figure><p id="7cbb" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个类中还有一个getter，它使用相同的子属性，并将is映射到一个<strong class="lx iu">列表&lt; NavRouteView &gt; </strong>，该列表显示我们的字母A到E，并在页面转换期间应用一些很酷的导航效果。对<strong class="lx iu"> initState() </strong>的覆盖创建了一个<strong class="lx iu"> TabController </strong>，并将其注册到<strong class="lx iu"> NavigationBus </strong>上。此外，还有一个dispose()方法，当导航容器被释放时，该方法显式地释放控制器实例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/c8cf71077a0da798ab0193020e5a8779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ja5AtgnIk_5sZoWv_2drkg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用<strong class="bd lb">构建</strong>方法的<strong class="bd lb"> NavContainer </strong>类</figcaption></figure><p id="42b3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们不会深入研究这个类，但是它是常见的列、容器和装饰的标准实现。有几个条件分支来处理标签栏在iOS上的呈现方式不同于Android，这有助于将标签从iPhone X上的圆角和底部抽屉手柄中取出，这通常会干扰它们。</p><p id="5a50" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">接下来是文件<strong class="lx iu">lib/components/nav-route-view . dart</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/5a5a6672a004e8c2b1dfd4afba5cadd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jR21bFF_QmDVwVVXRI2LA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">动画部件<strong class="bd lb"> NavRouteView </strong>带有一些计算</figcaption></figure><p id="ca0d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这里我们有我们的<strong class="lx iu"> NavRouteView </strong>，它是一个<a class="ae ky" href="https://docs.flutter.io/flutter/widgets/AnimatedWidget-class.html" rel="noopener ugc nofollow" target="_blank">动画化的小工具</a>，当路线飞入和飞出屏幕时，它对路线应用各种变换。方法<strong class="lx iu"> scaleDouble </strong>是一个线性变换，它将动画值按比例缩小到一个更小的值，在本例中为原始值的80%。请注意计算<em class="nb">比例</em>的公式，该公式根据容器是滑入还是滑出视图，以及它相对于屏幕可见部分的位置来确定如何在屏幕上绘制容器，这是通过从动画值中减去小部件的索引，然后对结果执行一组条件测试来处理的。</p><p id="89fd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">最后但同样重要的是，我们将看看<strong class="lx iu">lib/components/nav-tab-icon . dart:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/80e4659cd675aedd5c228407a28f3641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rx6WtRbU4dDO-gmgOXa3Dg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb"> NavTabIcon </strong>用于渲染图标的计算</figcaption></figure><p id="d737" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> NavTabIcon </strong>类与<strong class="lx iu"> NavRouteView </strong>类似，它根据传递给它的动画的当前状态(我们的选项卡导航器动画值)更新它的外观。实现这一点的代码可以做成一些抽象的特性，而不是在这些类之间复制，但是这确实给了一些灵活性，可以为每个类试验不同的值。</p><p id="2474" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个小部件呈现提供的<strong class="lx iu">图标</strong>，在本例中，它只是应用了文本样式的相同字母A到E中的一个。</p><p id="6f9d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们再次看到平台检查有助于缓解在原生iOS手机组件上绘制时出现的任何问题。在这个小部件中，不透明度值被固定在<em class="nb"> 0.26 </em>和<em class="nb"> 0.84 </em>之间，以防止图标完全不透明或透明，使它们看起来更微妙。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="71bb" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="fae6" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Flutter提供了一组强大的功能，充分利用Dart语言来创建现代化的本地应用程序，具有令人难以置信的动画和过渡，可以无缝呈现出色的性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/823c87e940da9aff971b99f1aa873e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEzetqbjxUorFaUJy_vT3A.png"/></div></div></figure><p id="5d94" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个项目展示了Flutter中的一些概念，这些概念使得用干净的源文件构建高度复杂的、交互式的移动应用成为可能。</p><p id="9017" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">使用事件总线和一些标准组件，我们能够以一种易于维护且不太可能在您最不期望的时候无缘无故中断的方式，将原本需要另一个依赖包的东西连接起来。这些概念可以应用于你能想到的任何一种动画或控制手势，只受想象力的限制。</p><p id="5620" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我希望你喜欢这篇文章，并发现它很有用。该项目的完整源代码可在<a class="ae ky" href="https://github.com/kenreilly/flutter-parallax-nav-demo" rel="noopener ugc nofollow" target="_blank">这里</a>获得，如果有任何问题或建议，请随时联系我。</p><p id="47f8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">感谢你的阅读，祝你好运！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><blockquote class="nd"><p id="0d23" class="ne nf it bd ng nh ni nj nk nl nm mn dk translated">肯尼斯·雷利(<a class="ae ky" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a>)是<a class="ae ky" href="https://lvl-up.tech/" rel="noopener ugc nofollow" target="_blank"> LevelUP </a>的CTO</p></blockquote></div></div>    
</body>
</html>