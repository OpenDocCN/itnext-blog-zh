<html>
<head>
<title>Code to extend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要扩展的代码</h1>
<blockquote>原文：<a href="https://itnext.io/code-to-extend-3b520d2d6745?source=collection_archive---------3-----------------------#2019-11-24">https://itnext.io/code-to-extend-3b520d2d6745?source=collection_archive---------3-----------------------#2019-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/15ad2d587e6f9e8b3bbdf998b50ceede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*10krG9dLp-2JAyOo1TNVPQ.jpeg"/></div></div></figure><p id="7238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">软件和硬件相比，什么是伟大的？很容易改变、维护和理解。</p><blockquote class="kw kx ky"><p id="168f" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">软件是用来操作计算机和执行特定任务的一组指令、数据或程序。</p></blockquote><p id="b2eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“软件”一词包含软件，根据定义应该是</p><blockquote class="kw kx ky"><p id="a97c" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">易于成型、切割、压缩或折叠；摸起来不硬或者不结实。</p></blockquote><p id="cd24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这都是真的，但是</p><blockquote class="kw kx ky"><p id="716f" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">任何傻瓜都能写出计算机能理解的代码。优秀的程序员编写人类能够理解的代码。—马丁·福勒</p></blockquote><p id="1efa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">计算机不会给一只飞翔的火烈鸟你的代码是如何构造的，有没有经过评审，有没有包含无意义的注释。编译器将代码归结为指令，计算机执行，工作完成。每个人都很高兴，除了下一个必须做出改变的开发者。如果他的改变破坏了什么，要负全责。</p><p id="2f01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">女士们先生们，这是我们的故事，如何使你的代码可读，最重要的是可扩展。我邀请我的朋友参加播客，他的名字是<a class="ae ld" href="https://github.com/oganzins" rel="noopener ugc nofollow" target="_blank">oļegs·甘辛斯</a>，他有丰富的开发经验。我们讨论了代码中的if语句。</p><p id="99b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">If语句是一件独一无二的艺术品，例如，无法比较两个数字。但是当它们被误用或过度使用时，问题就出现了，例如“如果圣诞树”。</p><p id="1fef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么是如果圣诞树。当你把嵌套的if语句代码旋转90度，代码会突然变成树的形状。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="114c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个问题，上下文切换。当然，在提供的例子中，遵循代码很容易，上下文的切换也不会造成伤害。但在现实生活中，在下一条语句生效之前，已经写了一大堆逻辑。当下一个if语句命中时，大脑内部的上下文必须从“转向”切换到“周围”。</p><p id="d399" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个问题，代码扩展。让我们增加新的功能，让船慢慢掉头。再来一个if，然后把参数直接传到兔子洞里。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="8aed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单的扩展已经变得如此糟糕。head里各种红旗弹出，这个怎么测试，每个if分支要跳多少个单元测试。当“t”等于“超级慢”时会发生什么。</p><p id="2260" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三个问题，责任的层次。方法“turn”不仅在设计上很复杂，而且有不止一个职责。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="78f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">方法知道怎么转快，怎么转慢。这表明当改变一件事时，另一件事会受到意外的影响。这些错误通常被称为特性。</p><p id="3cb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何使代码可扩展，并记住它应该做一件事。深入研究<a class="ae ld" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实的</a>原则，通过探索每一条原则，如何创建整洁结构的模式和方法就会出现在日常生活中。</p><p id="2089" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们把注意力集中在S上，代表“单一责任原则”做好一件事，O代表“开放-封闭原则”,开放是为了扩展，封闭是为了修改。</p><p id="86af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在播客的最后，我给了Oleg一个挑战。用IF语句编写代码。然后在没有它们的情况下做同样的事情。用例是一个基于网关处理支付的支付系统。其中网关可以是谷歌，脸书等。</p><p id="40bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看纯粹的如果结果如何。<a class="ae ld" href="https://github.com/oganzins/alternative-to-ifs/blob/master/src/main/java/com/intelmodus/billing/service/BillingService.java" rel="noopener ugc nofollow" target="_blank"> Github </a>。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="defc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们眼前有一个常见的嫌疑犯。但是我不得不说，即使有了IFs，代码看起来还是干净易读的。我在等更糟糕的东西。这样做的问题是，每当有新的网关时，计费服务就必须改变。这样我们就突破了固体中的O。至于SOLID中的S，类或者代码应该只有一个改变的理由。但是我们可以列举出计费服务可以改变的多种原因。引入新的支付网关，现有支付处理器的新实现。</p><p id="86ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看当他删除相同服务的IF语句时发生了什么。<a class="ae ld" href="https://github.com/oganzins/alternative-to-ifs/blob/ifs-removed/src/main/java/com/intelmodus/billing/service/BillingService.java" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="33ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他们走了，代码看起来更干净，在新的网关，这些代码仍然保持不变。因此对扩展开放，对修改关闭，只有一个原因要改变。</p><p id="3bbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">奥列格做了哪些改变？他让BillingService不再负责创建一个支付处理器，并了解有多少网关。</p><p id="ba5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的处理器和网关都在<a class="ae ld" href="https://github.com/oganzins/alternative-to-ifs/blob/ifs-removed/src/main/java/com/intelmodus/billing/service/PaymentProcessorRepository.java" rel="noopener ugc nofollow" target="_blank">PaymentProcessorRepository</a>中定义。这仍然在某种程度上打破了O，但至少我们只是扩展了知识库的知识，而不是改变它。</p><p id="58e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他更进一步，用<a class="ae ld" href="https://github.com/google/guice/wiki/GettingStarted" rel="noopener ugc nofollow" target="_blank"> Guice注入</a>实现了相同的if墙。让我们看看相同的BillingService在Guice注入框架中是什么样子的。<a class="ae ld" href="https://github.com/oganzins/alternative-to-ifs/blob/ifs-removed-using-guice/src/main/java/com/intelmodus/billing/service/BillingService.java" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="9bf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">抽象程度简直暴涨上天:)。抽象胜于实现是确保解决方案经得起未来考验的一个非常好的方法。这不仅适用于软件世界，也适用于现实世界。比如一辆没有离合机构的车，换挡就有点不可能。</p><p id="f2e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">BillingService的实现在哪里？在这里。<a class="ae ld" href="https://github.com/oganzins/alternative-to-ifs/blob/ifs-removed-using-guice/src/main/java/com/intelmodus/billing/service/DefaultBillingService.java" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="dd17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们仍然看到有一个PaymentProcessorRepository，但是它有一个显著的变化。但是在我们开始之前，让我们看一下Guice模块PaymentProcessorModule。这是焊接发生的地方，接缝牢固，但易于更换。基本上，在任何新的处理器上，我们都在模块中注册它。紧凑，简洁，有意义，因为这是作为配置的代码。请记住，类发现可以自动进行，但是这样您就失去了什么与什么以及如何绑定的高度概述。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="4639" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">PaymentProcessorRepository的变化是惊人的。它完全不知道处理器是在哪里、如何创建的，也不知道支持多少个网关。它只是通过注入获得所有的处理器，并在需要时为它们服务。每当创建一个新的网关或交换处理器的实现时，存储库不需要任何改变。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="c515" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从而实现固体中的S和O。每段代码只做一件事。支付系统对变化是封闭的，但对扩展是开放的。</p><p id="30fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法开放了很多功能，比如交换实现，甚至在运行时。单元测试变得简单多了，因为它实际上测试的是小单元。</p><p id="8ed0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让这种方法真正闪光的是，业务逻辑可以与引擎分开测试。“DefaultBillingService”和“PaymentProcessorRepository”是引擎的一部分，但支付处理器是业务逻辑。为什么这很重要。通常，这样的引擎被创建一次，它就工作了。商业一直在发展。主要目标是不要因为业务而更换引擎。因此，避免它不是一个错误，而是一个特性。</p><p id="c6a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们关于如何处理IF语句的故事。完全不用它们是不可能的，但不过度使用它们是可能的。</p><p id="1a80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们建议阅读坚实的原则，因为它将导致许多有趣的方法和模式。记住，强迫自己去寻找和实现模式需要时间和思考。这增加了您的解决方案的初始成本，但从长远来看，这是值得的。另一方面，最初做快速而蹩脚的代码是便宜的，但从长远来看，将永远得不到回报，并且添加新功能的成本会越来越高。</p><p id="128d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub <br/> <a class="ae ld" href="https://github.com/oganzins/alternative-to-ifs" rel="noopener ugc nofollow" target="_blank">带IF语句<br/> </a> <a class="ae ld" href="https://github.com/oganzins/alternative-to-ifs/tree/ifs-removed" rel="noopener ugc nofollow" target="_blank">不带IF语句</a> <br/> <a class="ae ld" href="https://github.com/oganzins/alternative-to-ifs/tree/ifs-removed-using-guice" rel="noopener ugc nofollow" target="_blank">不带IF语句用Guice </a>实现。</p></div></div>    
</body>
</html>