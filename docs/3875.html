<html>
<head>
<title>How to make a serverless Flutter video sharing app with Firebase Storage, including HLS and client-side encoding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Firebase存储制作一个无服务器的Flutter视频分享app，包括HLS和客户端编码</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-make-a-serverless-flutter-video-sharing-app-with-firebase-storage-including-hls-and-411e4fff68fa?source=collection_archive---------0-----------------------#2020-03-17">https://itnext.io/how-to-make-a-serverless-flutter-video-sharing-app-with-firebase-storage-including-hls-and-411e4fff68fa?source=collection_archive---------0-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6a96ec2c7d0604c12754707a6a3c05d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I4qRH0xZn6O0P0l-.png"/></div></div></figure><h1 id="cf04" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我们正在建造的东西</h1><p id="1325" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将看到如何为iOS/Android构建一个flutter应用程序，允许用户查看和共享视频。在我的<a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-cross-platform-serverless-video-sharing-app-with-flutter-firebase-and-publitio-900a9fa0dd68">上一篇文章</a>中，我展示了如何用<a class="ae lx" href="https://publit.io?fpr=jonathan43" rel="noopener ugc nofollow" target="_blank"> Publitio </a>作为我们的视频存储API来实现这一点。在本教程中，我们将使用<a class="ae lx" href="https://firebase.google.com/docs/storage" rel="noopener ugc nofollow" target="_blank"> Firebase云存储</a>来托管视频。我们还将添加客户端编码和HLS支持，因此客户端可以以自适应比特率传输视频。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/63b22bc737b29d61e767a590ab9c9fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*sq7b9CBB_3KOliuI.gif"/></div></figure><h1 id="f3de" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">堆栈</h1><ul class=""><li id="137c" class="md me it lb b lc ld lg lh lk mf lo mg ls mh lw mi mj mk ml bi translated"><a class="ae lx" href="https://flutter.dev/" rel="noopener ugc nofollow" target="_blank">Flutter</a>——用于制作跨平台app。</li><li id="a9ee" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" href="https://firebase.google.com/docs/firestore" rel="noopener ugc nofollow" target="_blank"> Firebase Cloud Firestore </a> —用于存储视频元数据(URL)和客户端之间的同步(无需编写服务器代码)。</li><li id="be95" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" href="https://firebase.google.com/docs/storage" rel="noopener ugc nofollow" target="_blank"> Firebase云存储</a> —用于托管实际视频。</li><li id="1cca" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" href="https://www.ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"> FFmpeg </a> —用于运行客户端视频编码。</li></ul><h1 id="f483" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">为什么要客户端编码？</h1><p id="5ca2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在大多数视频工作流中，会有一个转码服务器或无服务器云功能，将视频编码为各种分辨率和比特率，以便在所有设备和网络速度下实现最佳观看效果。</p><p id="57bc" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">如果你不想使用转码服务器或API(这可能非常昂贵)，并且取决于你的应用程序需要上传和查看的视频类型，你可以选择完全放弃服务器端转码，只在客户端对视频进行编码。这将节省大量成本，但会将视频编码的负担加在客户端上。</p><p id="08c9" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">即使您<em class="mw">确实</em>使用了某种服务器端代码转换解决方案，您也可能希望在客户端执行最少的编码。原始视频的大小(尤其是在iOS上)可能很大，你不想浪费用户的数据计划，或者强迫他们不必要地等待WiFi。</p><blockquote class="mx my mz"><p id="add2" class="kz la mw lb b lc mr le lf lg ms li lj na mt lm ln nb mu lq lr nc mv lu lv lw im bi translated">要了解如何使用云函数和专用API进行服务器端编码，请阅读下一篇文章</p></blockquote><h1 id="ace3" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">视频编码引物</h1><p id="e41b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是我们将要使用的一些术语的简要介绍。</p><h2 id="4701" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">X264编解码器/编码器</h2><p id="d99f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是用于将视频编码为H.264/MPEG-4 AVC格式的软件。还有许多其他编解码器，但鉴于H.264格式是目前唯一一种在iOS和Android上都受到本机支持的编解码器，这是我们将使用的。</p><h2 id="34ff" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">自适应比特率流</h2><p id="5b05" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一种将视频编码成多种比特率(不同质量)，并将每种比特率编码成许多小块的方法。<em class="mw">流协议</em>将允许玩家根据网络速度选择下一个块的质量。因此，如果您从WiFi转向蜂窝数据，您的播放器可以相应地调整比特率，而无需重新加载整个视频。</p><p id="1313" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">有许多流媒体协议，但iOS和Android原生支持的是苹果的<em class="mw"> HLS </em> — HTTP直播流媒体。在HLS中，视频以<code class="fe np nq nr ns b">.ts</code>文件的形式被分割成块，一个<code class="fe np nq nr ns b">.m3u8</code>播放列表文件用于指向块。对于每种质量，或者说<em class="mw">变体流</em>，都有一个播放列表文件和一个主播放列表来管理它们💍。</p><h1 id="7511" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">配置</h1><h2 id="0a50" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">安装flutter_ffmpeg</h2><p id="a54b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将使用<a class="ae lx" href="https://pub.dev/packages/flutter_ffmpeg" rel="noopener ugc nofollow" target="_blank"> flutter_ffmpeg </a>包在iOS/Android上运行编码作业。<code class="fe np nq nr ns b">flutter_ffmpeg</code>要求选择一个编解码器<code class="fe np nq nr ns b">package</code>，根据你想要使用的。这里我们将使用<code class="fe np nq nr ns b">min-gpl-lts</code>包，因为它包含x264编解码器，并且可以在发布版本中使用。</p><p id="5fca" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">将以下内容添加到您的<code class="fe np nq nr ns b">android/build.gradle</code>:</p><pre class="lz ma mb mc gt nt ns nu nv aw nw bi"><span id="d85a" class="nd kc it ns b gy nx ny l nz oa">ext { <br/>  flutterFFmpegPackage = "min-gpl-lts" <br/>}</span></pre><p id="3861" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">在你的<code class="fe np nq nr ns b">Podfile</code>中替换这一行:</p><pre class="lz ma mb mc gt nt ns nu nv aw nw bi"><span id="5ac9" class="nd kc it ns b gy nx ny l nz oa">pod name, :path =&gt; File.join(symlink, 'ios')</span></pre><p id="9ee1" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">有了这个:</p><pre class="lz ma mb mc gt nt ns nu nv aw nw bi"><span id="4933" class="nd kc it ns b gy nx ny l nz oa">if name == 'flutter_ffmpeg'<br/>  pod name+'/min-gpl-lts', :path =&gt; File.join(symlink, 'ios')<br/>else<br/>  pod name, :path =&gt; File.join(symlink, 'ios')</span></pre><h2 id="e6df" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">云存储配置</h2><p id="f5d2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果你已经在你的项目中设置了<a class="ae lx" href="https://firebase.google.com/docs/flutter/setup" rel="noopener ugc nofollow" target="_blank"> firebase，正如</a><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-cross-platform-serverless-video-sharing-app-with-flutter-firebase-and-publitio-900a9fa0dd68">上一篇文章</a>中所讨论的，那么你只需要添加<code class="fe np nq nr ns b">cloud_firestore</code>包。</p><p id="70e8" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">现在我们需要配置视频文件的公共读取权限，这样我们就可以在没有令牌的情况下访问它们(见<a class="ae lx" href="https://www.learningsomethingnew.com/flutter-video-upload-firebase-storage-hls#public-access-to-stored-videos" rel="noopener ugc nofollow" target="_blank">评论</a>)。在这个例子中，为了简单起见，我没有添加任何身份验证，所以我们也允许公共写访问，但这应该在生产应用程序中进行更改。因此，在Firebase控制台中，转到存储- &gt;规则并将其更改为:</p><pre class="lz ma mb mc gt nt ns nu nv aw nw bi"><span id="4dc6" class="nd kc it ns b gy nx ny l nz oa">service firebase.storage { <br/>  match /b/{bucket}/o { <br/>    match /{allPaths=**} { <br/>      allow read; allow write; <br/>    } <br/>  } <br/>}</span></pre><h1 id="d820" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">客户端视频处理中的阶段</h1><p id="1651" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是我们对每个视频要做的一系列步骤:</p><ul class=""><li id="5ef5" class="md me it lb b lc mr lg ms lk ob lo oc ls od lw mi mj mk ml bi translated">从<code class="fe np nq nr ns b">image_picker</code>获取原始视频路径</li><li id="77de" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">获取纵横比</li><li id="92f9" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">使用ffmpeg生成缩略图</li><li id="e6fb" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">将原始视频编码到HLS文件中</li><li id="c431" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">上传缩略图jpg到云存储</li><li id="2c21" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">将编码文件上传到云存储</li><li id="e114" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">将视频元数据保存到云Firestore</li></ul><p id="8bbb" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">我们来过一遍每一步，看看怎么实现。</p><h1 id="2638" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">编码提供商</h1><p id="4936" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将创建一个封装编码逻辑的<code class="fe np nq nr ns b">EncodingProvider</code>类。该类将保存所需的<code class="fe np nq nr ns b">flutter_ffmpeg</code>实例。</p><pre class="lz ma mb mc gt nt ns nu nv aw nw bi"><span id="21a6" class="nd kc it ns b gy nx ny l nz oa">class EncodingProvider {<br/>  static final FlutterFFmpeg _encoder = FlutterFFmpeg();<br/>  static final FlutterFFprobe _probe = FlutterFFprobe();<br/>  static final FlutterFFmpegConfig _config = FlutterFFmpegConfig();<br/><br/>...<br/>}</span></pre><h2 id="976c" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">生成缩略图</h2><p id="6923" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将使用编码器生成一个缩略图，稍后保存到云存储中。我们告诉FFmpeg从尺寸为<code class="fe np nq nr ns b">width x height</code> ( <code class="fe np nq nr ns b">-s</code>选项)的<code class="fe np nq nr ns b">videoPath</code> ( <code class="fe np nq nr ns b">-i</code>选项)中取出一帧(<code class="fe np nq nr ns b">-vframes</code>选项)。我们检查结果代码以确保操作成功完成。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="e8e0" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">获取视频长度和纵横比</h2><p id="ef05" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将使用<code class="fe np nq nr ns b">FlutterFFprobe.getMediaInformation</code>并计算纵横比(flutter视频播放器需要的)并获得视频长度(计算编码进度需要的):</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="bf3b" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">编码视频</h2><p id="1aa6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在是实际的视频编码。对于这个例子，我使用了这个优秀的<a class="ae lx" href="https://hlsbook.net/creating-a-master-playlist-with-ffmpeg/" rel="noopener ugc nofollow" target="_blank"> HLS教程</a>中的参数。我们正在创建两个不同的流，一个有<code class="fe np nq nr ns b">2000k</code>比特率，一个有<code class="fe np nq nr ns b">365k</code>比特率。这将为每个不同质量流生成多个<code class="fe np nq nr ns b">fileSequence.ts</code>文件(视频块),并为每个流生成一个<code class="fe np nq nr ns b">playlistVariant.m3u8</code>文件(播放列表)。它还会生成一个列出所有<code class="fe np nq nr ns b">playlistVariant.m3u8</code>文件的<code class="fe np nq nr ns b">master.m3u8</code>。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><blockquote class="mx my mz"><p id="4b5e" class="kz la mw lb b lc mr le lf lg ms li lj na mt lm ln nb mu lq lr nc mv lu lv lw im bi translated">注意:这是一个简单的编码示例，但是选项是无穷无尽的。完整名单:【https://ffmpeg.org/ffmpeg-formats.html】<a class="ae lx" href="https://ffmpeg.org/ffmpeg-formats.html" rel="noopener ugc nofollow" target="_blank"><em class="it"/></a></p></blockquote><h2 id="4e9f" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">显示编码进度</h2><p id="c441" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">编码可能需要很长时间，向用户展示正在发生的事情是很重要的。我们将使用FFmpeg的<code class="fe np nq nr ns b">enableStatisticsCallback</code>来获得当前编码帧的时间，并除以视频持续时间来获得进度。然后我们将更新连接到<code class="fe np nq nr ns b">LinearProgressBar</code>的<code class="fe np nq nr ns b">_progress</code>状态字段。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="9aad" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">上传文件</h1><p id="409b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">既然编码已经完成，我们需要将文件上传到云存储。</p><h2 id="72d9" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">将单个文件上传到云存储</h2><p id="bdb9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">上传到云存储非常简单。我们用<code class="fe np nq nr ns b">FirebaseStorage.instance.ref().child(folderName).child(fileName)</code>将一个<code class="fe np nq nr ns b">StorageReference</code>放入我们想要存储文件的路径中。然后我们调用<code class="fe np nq nr ns b">ref.putFile(file)</code>，用<code class="fe np nq nr ns b">_onUploadProgress</code>监听事件流，在那里我们更新<code class="fe np nq nr ns b">_progress</code>状态字段，就像我们对编码所做的那样。上传完成后，<code class="fe np nq nr ns b">await taskSnapshot.ref.getDownloadURL()</code>将返回我们可以用来访问文件的url。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="05c6" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">修复HLS文件</h2><p id="79ec" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在我们需要检查所有生成的HLS文件(<code class="fe np nq nr ns b">.ts</code>和<code class="fe np nq nr ns b">.m3u8</code>)，并将它们上传到云存储文件夹中。但在此之前，我们需要修复它们，以便它们指向与它们在云存储中的位置相关的正确URL。以下是在客户端创建<code class="fe np nq nr ns b">.m3u8</code>文件的方式:</p><pre class="lz ma mb mc gt nt ns nu nv aw nw bi"><span id="a331" class="nd kc it ns b gy nx ny l nz oa">#EXTM3U<br/>#EXT-X-VERSION:3<br/>#EXT-X-TARGETDURATION:3<br/>#EXT-X-MEDIA-SEQUENCE:0<br/>#EXTINF:2.760000,<br/>1_fileSequence_0.ts<br/>#EXT-X-ENDLIST</span></pre><p id="9801" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">注意这条线<code class="fe np nq nr ns b">1_fileSequence_0.ts</code>。这是播放列表中<code class="fe np nq nr ns b">.ts</code>块的相对路径。但是当我们将它上传到一个文件夹时，它在URL中缺少文件夹名称。它还缺少<code class="fe np nq nr ns b">?alt=media</code>查询参数，该参数是从Firebase获取实际文件而不仅仅是元数据所必需的。它应该是这样的:</p><pre class="lz ma mb mc gt nt ns nu nv aw nw bi"><span id="55a9" class="nd kc it ns b gy nx ny l nz oa">#EXTM3U<br/>#EXT-X-VERSION:3<br/>#EXT-X-TARGETDURATION:3<br/>#EXT-X-MEDIA-SEQUENCE:0<br/>#EXTINF:2.760000,<br/>video4494%2F1_fileSequence_0.ts?alt=media<br/>#EXT-X-ENDLIST</span></pre><p id="8e52" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">因此，我们需要一个函数将这两样东西添加到主播放列表中的每个<code class="fe np nq nr ns b">.ts</code>条目和每个<code class="fe np nq nr ns b">.m3u8</code>条目:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="5fc8" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">上传HLS文件</h2><p id="dcc0" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">最后，我们将检查所有生成的文件并上传它们，必要时修复<code class="fe np nq nr ns b">.m3u8</code>文件:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e60d" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">这是上传的文件在云存储中的样子:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/6b83fcf84134e23daec080bbe2a1c72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*khjCA8C2FG582N-L.png"/></div></div></figure><h1 id="7d56" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">将元数据保存到Firestore</h1><p id="b756" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">获得视频的存储url后，我们可以将元数据保存在Firestore中，这样我们就可以在用户之间即时共享视频。正如我们在<a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-cross-platform-serverless-video-sharing-app-with-flutter-firebase-and-publitio-900a9fa0dd68">上一篇文章</a>中看到的，将元数据保存到Firestore很容易:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="403b" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">这是Firestore中视频文档的外观:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/a996619676436afd213ffd9fbffc5aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WHjqE-SqihsHe8i6.png"/></div></div></figure><h1 id="eca6" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">把所有的放在一起</h1><p id="7839" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在将它们放在一个处理函数中，该函数将经历我们看到的所有阶段，并更新状态以显示当前的作业状态(输入来自输出):</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="d44f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">显示视频列表</h1><p id="5afb" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们在<a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-cross-platform-serverless-video-sharing-app-with-flutter-firebase-and-publitio-900a9fa0dd68">之前的帖子</a>中看到了如何收听Firestore并显示视频列表视图。简而言之，我们使用<code class="fe np nq nr ns b">snapshots().listen()</code>来监听更新流，使用<code class="fe np nq nr ns b">ListView.builder()</code>来创建一个列表，通过_videos状态字段对流中的变化做出反应。</p><p id="139c" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">对于每个视频，我们显示一个包含显示视频的<code class="fe np nq nr ns b">thumbUrl</code>的<code class="fe np nq nr ns b">adeInImage.memoryNetwork</code>的<code class="fe np nq nr ns b">Card</code>，在它旁边是<code class="fe np nq nr ns b">videoName</code>和<code class="fe np nq nr ns b">uploadedAt</code>字段。我使用了<a class="ae lx" href="https://pub.dev/packages/timeago" rel="noopener ugc nofollow" target="_blank"> timeago </a>插件以友好的方式显示上传时间。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="de2b" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">现在我们有了:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/0ac790b4297281de56c514143a1a909a.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*tNJ1K46mTRPMeMBA.gif"/></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated">限制</figcaption></figure><h1 id="9203" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">限制</h1><h2 id="1ca9" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">邱建</h2><p id="0325" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">视频编码是一项CPU密集型工作。因为flutter是单线程的，所以运行ffmpeg编码会在运行时导致jank(不连贯的UI)。解决方案当然是将编码卸载到后台进程。遗憾的是，我还没有找到用flutter_ffmpeg轻松做到这一点的方法。如果你有一个在后台长时间运行的视频编码工作的工作方法，请让我知道！(为了减轻jank效应，您可以显示一个编码进度条，并且在它完成之前不允许对UI的任何其他使用。)</p><h2 id="1e51" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">提前终止</h2><p id="175b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">长时间编码/上传作业的另一个问题是，在作业完成之前，操作系统可以决定在最小化时关闭应用程序的进程。您必须管理作业状态，并从作业停止的地方重新启动/恢复作业。</p><h2 id="0116" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">公众对存储视频的访问</h2><p id="2381" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">使用这种方法从云存储中提供HLS服务需要对所有文件的公共读取权限。如果您需要对视频进行认证访问，您必须找到一种方法，在每次客户端下载文件时用Firebase令牌动态更新<code class="fe np nq nr ns b">.m3u8</code>播放列表(因为令牌会不同)。</p><h2 id="e4be" class="nd kc it bd kd ne nf dn kh ng nh dp kl lk ni nj kp lo nk nl kt ls nm nn kx no bi translated">贮藏</h2><p id="cfd1" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">flutter <code class="fe np nq nr ns b">video_player</code>插件目前不支持缓存。可以尝试用<a class="ae lx" href="https://github.com/syonip/plugins.git" rel="noopener ugc nofollow" target="_blank">这个支持缓存的fork </a>(我在我的app里用的)，但是我没有用HLS测试过。</p><p id="a591" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">要使用它，请将它添加到“pubspec.yaml”中:</p><pre class="lz ma mb mc gt nt ns nu nv aw nw bi"><span id="d90c" class="nd kc it ns b gy nx ny l nz oa">video_player:<br/>  git:<br/>    url: git://github.com/syonip/plugins.git<br/>    ref: a669b59<br/>    path: packages/video_player</span></pre><h1 id="21d0" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">包裹</h1><p id="f426" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我认为这是一个很好的DIY视频托管方法，主要有两个原因:</p><ol class=""><li id="03c4" class="md me it lb b lc mr lg ms lk ob lo oc ls od lw ol mj mk ml bi translated">最少的编码量——无需编写或维护服务器代码。</li><li id="806a" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw ol mj mk ml bi translated">非常便宜——如果你正在做一个副业项目，想要零成本开始，你可以。Firebase的免费计划有1GB存储和10gb/月的传输限制，这是一个很好的开始。</li></ol><p id="9667" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">感谢阅读！和往常一样，完整的源代码可以在<a class="ae lx" href="https://github.com/syonip/flutter_fbstorage_video_upload" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="770a" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated">如有疑问，欢迎留言评论！</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="18d6" class="pw-post-body-paragraph kz la it lb b lc mr le lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw im bi translated"><em class="mw">最初发表于</em><a class="ae lx" href="https://www.learningsomethingnew.com/flutter-video-upload-firebase-storage-hls" rel="noopener ugc nofollow" target="_blank">T5【https://www.learningsomethingnew.com】</a><em class="mw">。</em></p></div></div>    
</body>
</html>