<html>
<head>
<title>Immutable vs Immutable.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不可变vs不可变. js</h1>
<blockquote>原文：<a href="https://itnext.io/immutable-vs-immutable-js-d524bf515bcd?source=collection_archive---------1-----------------------#2018-09-08">https://itnext.io/immutable-vs-immutable-js-d524bf515bcd?source=collection_archive---------1-----------------------#2018-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="6cd9" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">不变性— </strong>可能是你在现代前端世界学习的第一件事。</p><p id="51e8" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">不变性— </strong>可能是你跟Docker学习的第一件事。</p><p id="44bf" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">不变性— </strong>可能是第一件…在函数式编程中。</p></blockquote><p id="47c8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">但是不变性代表什么，<strong class="jt ir">不可变数据</strong>和<strong class="jt ir">不可变. js </strong>有什么区别？</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/457e4ee02d46c91900d1f8bfc445c285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jy5phuaYu0oiJDMuv-TJvw.jpeg"/></div></div></figure><h1 id="bca9" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不变性代表什么？</h1><p id="dded" class="pw-post-body-paragraph jq jr iq jt b ju mc jw jx jy md ka kb kp me ke kf kq mf ki kj kr mg km kn ko ij bi translated">只有两个<strong class="jt ir">规则</strong>定义了<em class="js"/>“不变性”:</p><blockquote class="jn jo jp"><p id="e2ab" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">–不要改变数据，如果必须的话–创建一个克隆并改变它。</p><p id="9fd8" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">–重复使用未改变的零件。只应更换已更换的零件。</p></blockquote><p id="acdb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这导致了不变性的2个<strong class="jt ir">好处</strong>:</p><blockquote class="jn jo jp"><p id="5175" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">–如果数据发生了变化–那么，你知道，它已经发生了变化。但是你总是有新旧物品可以比较。<em class="iq">此启用超</em> <strong class="jt ir"> <em class="iq">易</em> </strong> <em class="iq">和超</em> <strong class="jt ir"> <em class="iq">快</em> </strong> <em class="iq">【浅】</em> <strong class="jt ir"> <em class="iq">比较</em> </strong> <em class="iq">。</em></p><p id="30b9" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">–你将永远拥有新旧物品。无论你执行多少次转换，源数据都是一样的。这代表功能纯度和理想效能。这个<strong class="jt ir">使得测试</strong>超级<strong class="jt ir">容易</strong>。</p></blockquote><h1 id="3000" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">“超级容易”！</h1><p id="756b" class="pw-post-body-paragraph jq jr iq jt b ju mc jw jx jy md ka kb kp me ke kf kq mf ki kj kr mg km kn ko ij bi translated">这就是为什么每个人都喜欢不可变的数据-<strong class="jt ir">它很容易处理</strong>。或者说，说实话——不容易，但不<em class="js">难</em>。</p><p id="170f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">但是有一个问题——只要“结果”,不可变的工作方式，是每个人都喜欢的东西，过程，保持不变的方式，是没有人喜欢的东西。</p><blockquote class="mh"><p id="c786" class="mi mj iq bd mk ml mm mn mo mp mq ko dk translated">你和电脑都不行。</p></blockquote><p id="46f9" class="pw-post-body-paragraph jq jr iq jt b ju mr jw jx jy ms ka kb kp mt ke kf kq mu ki kj kr mv km kn ko ij bi translated">问题不在于不可变性，而在于JavaScript语言本身。它只是没有为这项任务提供“正确的”数据结构或一些语言特性(也称为“糖”)来简化这个过程。你知道-🤷‍♂️“JavaScript”。</p><h1 id="6925" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">例子？</h1><p id="b454" class="pw-post-body-paragraph jq jr iq jt b ju mc jw jx jy md ka kb kp me ke kf kq mf ki kj kr mg km kn ko ij bi translated">这是你不需要例子的事情。你只需要想一想。你必须做些什么来“实现”不变性？循序渐进。</p><blockquote class="jn jo jp"><p id="889c" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">如何克隆一个对象？如何克隆一个数组？如何在数组中添加或删除元素，或者替换对象中的键？</p></blockquote><p id="8474" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">怎么会？！轻松自如！您可以在任何与redux相关的文章或函数式编程备忘单中找到答案。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi mw"><img src="../Images/7c45107911b753312d0f238bbff76067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIomHpo_tojh65EXI0SXUg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">类似这样的东西</figcaption></figure><p id="b966" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">你总是可以使用像<strong class="jt ir"> immer.js </strong>这样的库，使可变的不可变，隐藏ES6代理后面的所有“副本”。</p><div class="nb nc gp gr nd ne"><a href="https://hackernoon.com/introducing-immer-immutability-the-easy-way-9d73d8f71cb3" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">Immer简介:不变性是最简单的方法</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">不可变的、结构上共享的数据结构是存储状态的一个很好的范例。尤其是在与事件源相结合时…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">hackernoon.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns lc ne"/></div></div></a></div><blockquote class="jn jo jp"><p id="1711" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">我<strong class="jt ir">想推荐</strong>你去看看这个库，更好地了解immer.js到底在为什么而奋斗。<strong class="jt ir">以及为什么</strong>。</p></blockquote><p id="10f0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">问题出在操作本身——你必须浪费十几个CPU周期来创建一个已存在的东西的克隆，然后浪费十几个CPU周期来让垃圾收集器消耗和<em class="js">消化不再使用的</em>旧变量。</p><blockquote class="mh"><p id="b96d" class="mi mj iq bd mk ml mm mn mo mp mq ko dk translated">你得到的数据结构越复杂或越大，你花在管理它上的时间就越多。</p></blockquote><blockquote class="jn jo jp"><p id="ca58" class="jq jr js jt b ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk mv km kn ko ij bi translated">实际上——这对于一个小的应用程序来说不是问题，但是有一天你的应用程序会成长起来——到那时做什么都晚了。</p></blockquote><p id="e5ad" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">不要忘记，当您“管理”数据时，内存中会有您数据的2份(也许更多)副本。双倍内存消耗。太棒了。</p><h1 id="c6f5" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不行吗？！</h1><p id="5124" class="pw-post-body-paragraph jq jr iq jt b ju mc jw jx jy md ka kb kp me ke kf kq mf ki kj kr mg km kn ko ij bi translated">同时，对于不变性是语言的一部分的语言(例如“不是JavaScript”)，这不是问题。不变性可能是他们天生的。</p><blockquote class="mh"><p id="3427" class="mi mj iq bd mk ml mm mn mo mp mq ko dk translated">幸运的是，他们得到了“结构共享”。</p></blockquote><p id="6e94" class="pw-post-body-paragraph jq jr iq jt b ju mr jw jx jy ms ka kb kp mt ke kf kq mu ki kj kr mv km kn ko ij bi translated">结构共享是<strong class="jt ir">存储</strong>数据结构的一种方式。聪明的方法。</p><p id="78ce" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">简而言之——如果您有一个1000个字符串的数组，并且想要在中间添加一个新的——您将创建一个<code class="fe nt nu nv nw b">blueprint</code>；您必须从原始数组中获取500个元素，从新数组中获取1个元素，然后再从原始数组中获取500个元素。有了这个蓝图，你就可以构建数据，或者再次修改它。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/90e04cf354934ab22e777e6a3658b8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/1*iuN5-LFUB993xduW4gC1ZA.gif"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">红色—是一个“新”对象。</figcaption></figure><p id="6a88" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">没有内存浪费，没有CPU时间从一个数组复制1000个元素到另一个。双赢！它应该具有的永恒性！</p><p id="7574" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">点击此处了解更多信息，快速浏览:</p><div class="nb nc gp gr nd ne"><a href="https://hackernoon.com/how-immutable-data-structures-e-g-immutable-js-are-optimized-using-structural-sharing-e4424a866d56" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">如何优化不可变数据结构(例如，不可变. js)</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">最近我一直在学习一些使用JavaScript的函数式编程。我开始真正喜欢功能性的…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">hackernoon.com</p></div></div><div class="nn l"><div class="ny l np nq nr nn ns lc ne"/></div></div></a></div><p id="b932" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">或者在这里，得到更完整的理解</p><div class="nb nc gp gr nd ne"><a href="https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">不可变的. js，持久数据结构和结构共享</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">为什么要用Immutable.js而不是普通的JavaScript对象？</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">medium.com</p></div></div><div class="nn l"><div class="nz l np nq nr nn ns lc ne"/></div></div></a></div><p id="1935" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">像Lisp和Closure这样的旧函数式语言太棒了！</p><h1 id="1339" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">但是这些都是Lisp和Closure，我的JavaScript呢？</h1><p id="851d" class="pw-post-body-paragraph jq jr iq jt b ju mc jw jx jy md ka kb kp me ke kf kq mf ki kj kr mg km kn ko ij bi translated">事实上，我们没有这样的结构或语言块，但是我们可以用JavaScript模拟这种行为。这已经做了很多次了。</p><blockquote class="mh"><p id="68ec" class="mi mj iq bd mk ml mm mn mo mp mq ko dk translated">不可变. js是一个为JavaScript带来结构化共享的库。</p></blockquote><p id="8e4d" class="pw-post-body-paragraph jq jr iq jt b ju mr jw jx jy ms ka kb kp mt ke kf kq mu ki kj kr mv km kn ko ij bi translated">唯一的问题是——仍然没有办法让这变得透明，我们必须通过复杂的API来访问或更改数据。</p><pre class="kt ku kv kw gt oa nw ob oc aw od bi"><span id="0cca" class="oe lf iq nw b gy of og l oh oi">var map1 = Immutable.Map({a:1, b:2, c:3});   <br/>var map2 = map1.set('b', 50);   <br/>map1.get('b'); <em class="js">// 2 </em>  <br/>map2.get('b'); <em class="js">// 50</em></span></pre><p id="432e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">还是那句话——immutable . js不是关于不变性的——它是关于不可变的数据结构，以使这种<em class="js">不变性</em>快速和内存高效。</p><blockquote class="jn jo jp"><p id="9930" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">🤷‍♂️说实话——我不知道有谁喜欢使用immutable.js API，或者Baobab.js(可以打电话给这里的任何一个库)。API太冗长。</p></blockquote><p id="89be" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">对我们大多数人来说——“JavaScript”维护不变性的方式更容易被接受。</p><pre class="kt ku kv kw gt oa nw ob oc aw od bi"><span id="9abe" class="oe lf iq nw b gy of og l oh oi">newState = {<br/>  ...state, <br/>  data: [...state.data, ...somethingNew].filter(Boolean)<br/>  someProp:1<br/>};</span></pre><p id="da8c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">只要这个代码对于一些简单的情况是<em class="js">可接受的</em>(就像这样)，但是对于稍微复杂一点的情况是<em class="js">不可接受的</em>，并且只要几乎不可能正确地<strong class="jt ir">嵌套</strong>所有那些<code class="fe nt nu nv nw b">{...somepart}</code>——你就会使用lodash.set这样的“函数设置器”，或者爱上immer。</p><p id="a53a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">但是在所有情况下，您将从旧数组中复制1000个元素到新数组中。</p><blockquote class="mh"><p id="597b" class="mi mj iq bd mk ml mm mn mo mp mq ko dk translated">我们刚刚到达我们开始的地方</p><p id="170d" class="mi mj iq bd mk ml mm mn mo mp mq ko dk translated">—浪费CPU和内存。</p></blockquote><h1 id="7dd5" class="le lf iq bd lg lh li lj lk ll lm ln lo lp oj lr ls lt ok lv lw lx ol lz ma mb bi translated">为什么没人用？</h1><p id="afec" class="pw-post-body-paragraph jq jr iq jt b ju mc jw jx jy md ka kb kp me ke kf kq mf ki kj kr mg km kn ko ij bi translated">为什么Immutable.js会失败应该是显而易见的。你为什么要用它，为什么要爱它，这应该很明显。但是没有人这么做——也不喜欢使用它。</p><p id="67b9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">第一个问题是接口。“不可变的”API对大多数开发人员来说有点陌生。而像<strong class="jt ir"> immer </strong>或者<strong class="jt ir"> seamless-immutable </strong>这样的库就是为了解决它而诞生的。例如，第二库可以使不可变看起来像普通的JS，但是为数据提供了神奇的“getters”。</p><pre class="kt ku kv kw gt oa nw ob oc aw od bi"><span id="5f2f" class="oe lf iq nw b gy of og l oh oi">var array = Immutable([1,2,3]);<br/>array.map(value =&gt; [value+2, value+4]);<br/>// returns Immutable([ [ 3, 5 ], [ 4, 6 ], [ 5, 7 ] ])</span><span id="a760" class="oe lf iq nw b gy om og l oh oi">Immutable.flatMap(array, value =&gt; [value+2, value+4]);<br/>// returns Immutable([ 3, 5, 4, 6, 5, 7 ])</span></pre><p id="33f8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">注意:您可以用与从本机数组“获取”数据相同的方式“获取”数据。</p><div class="nb nc gp gr nd ne"><a href="https://github.com/rtfeldman/seamless-immutable" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">rtfeldman/无缝-不可变</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">JavaScript的不可变数据结构，向后兼容普通的JS数组和对象。…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="on l np nq nr nn ns lc ne"/></div></div></a></div><p id="1002" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">无缝-不可变就像一个immer，但是用于结构共享。太棒了。</p><h1 id="a7da" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">….我也应该吗？….</h1><p id="f152" class="pw-post-body-paragraph jq jr iq jt b ju mc jw jx jy md ka kb kp me ke kf kq mf ki kj kr mg km kn ko ij bi translated">记住这是Javascript，有些特性不是“特性”，而是特性的“仿真”。具体来说——<code class="fe nt nu nv nw b">seamless-immutable</code>是有成本的(getter/setter糖)，如果你没有庞大的数组或复杂(大)的数据结构——“标准”的方式会工作得更快。</p><p id="1760" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">问题出在“大O记数法”上。从BigO的角度来看，不可变格式比“原生”格式更好，只要它具有“较低的复杂性”。但是每一个<code class="fe nt nu nv nw b">O(n)</code>实际上都是<code class="fe nt nu nv nw b">c*O(n) </code>—一些<code class="fe nt nu nv nw b">constant</code> x <code class="fe nt nu nv nw b">prediction</code>时间复杂度会如何增长。</p><blockquote class="mh"><p id="6847" class="mi mj iq bd mk ml mm mn mo mp mq ko dk translated">时间=常数*预测</p></blockquote><p id="dc31" class="pw-post-body-paragraph jq jr iq jt b ju mr jw jx jy ms ka kb kp mt ke kf kq mu ki kj kr mv km kn ko ij bi translated">在这种情况下<strong class="jt ir"> c相当大</strong>，如果你有<strong class="jt ir">小n </strong> — <strong class="jt ir">忘记</strong>关于不可变的. js，你不需要它。</p><blockquote class="mh"><p id="d39e" class="mi mj iq bd mk ml mm mn mo mp mq ko dk translated">低C*O(较高) </p></blockquote><p id="9ff7" class="pw-post-body-paragraph jq jr iq jt b ju mr jw jx jy ms ka kb kp mt ke kf kq mu ki kj kr mv km kn ko ij bi translated">不可变的. js不是银弹——它是解决复杂情况的工具。小型数据集不需要immutable.js。最后一个问题——小意味着什么？而且也不是那么好回答的。</p></div></div>    
</body>
</html>