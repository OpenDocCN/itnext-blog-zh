<html>
<head>
<title>Building a game with TypeScript. Drawing Grid 1/5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建游戏。绘制网格1/5</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb?source=collection_archive---------0-----------------------#2020-08-16">https://itnext.io/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb?source=collection_archive---------0-----------------------#2020-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">教程<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">系列</a>中的第三章讲述了如何用TypeScript和本地浏览器API从头开始构建游戏</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/434a8c51dd5a37810b50dbdfb3d9a1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHHCoguvNOSwi2xymMna-A.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">【www.freepik.com】创建的背景向量</figcaption></figure><p id="e5e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎回来，读者！这是系列文章第三章的第一部分，我们将讨论如何用TypeScript和原生浏览器API构建一个简单的回合制游戏。其他章节可在此处获得:</p><ul class=""><li id="871f" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="6d72" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="8017" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第二章。游戏循环(<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部分</a>)</li><li id="f023" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第三章。图纸网格(第1部分，<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第2部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第3部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第4部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第5部分</a>)</li><li id="3e2e" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第四章。舰船(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="4a56" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="39cc" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">部分1 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">部分2 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">部分3 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">部分4 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">部分5 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">部分6 </a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">部分7 </a>)</li><li id="dd68" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第七章。玛奇纳州</li><li id="0682" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第八章。攻击系统:生命和伤害</li><li id="6aa5" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第九章。比赛的输赢</li><li id="f1df" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第十章敌人AI</li></ul></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="de53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上次我们制作了一个游戏循环:这是一个有用的工具，不管玩家如何互动，它都可以帮助游戏继续运行。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/51c91fcc5688359637ee64565ce3d316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*twb3OLuV9kKGUE9umFWhsw.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">这是我们希望实现的游戏演示</figcaption></figure><p id="b517" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一章是关于绘画的。我们的游戏是在这些灰色方块的“棋盘”或“格子”上进行的。我们必须想象它们，这样玩家就知道在哪里放置他们的“船”。</p><p id="fd2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用浏览器的<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank">画布API </a>来绘制那些灰色方块。但这只是等式的一部分。我们必须让这些元素足够智能，这样玩家才能与它们互动。为了做到这一点，我们将使用我们在前面章节中获得的知识的全部力量:实体组件系统和游戏循环。</p><blockquote class="ly lz ma"><p id="b52f" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated">随意切换到<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe mf mg mh mi b">game-loop-2</code>分支。它包含了前几篇文章的工作成果，是这篇文章的一个很好的起点。</p></blockquote></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="d2f4" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">目录</h1><ol class=""><li id="293b" class="lc ld iq jp b jq nh ju ni jy nj kc nk kg nl kk nm li lj lk bi translated">介绍</li><li id="d260" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nm li lj lk bi translated">我们怎么画？</li><li id="c4eb" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nm li lj lk bi translated">第一次“肮脏”抽签</li><li id="655c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nm li lj lk bi translated">全局设置</li><li id="d0d7" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nm li lj lk bi translated">结论</li></ol></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="59ff" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">我们怎么画？</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nn"><img src="../Images/0fac36f5069c6724c62014e4249d1d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvuNJxVtquaSlRikPlaryw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/background" rel="noopener ugc nofollow" target="_blank">由freepik创建的背景矢量</a></figcaption></figure><p id="6279" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几种方法可以让我们在屏幕上画出任意的东西。使用JavaScript和浏览器的API，您可能已经习惯了DOM、CSS、div和spans以及其他标签/元素。虽然这些是可以呈现非常复杂的视觉效果的强大工具，但我们的工具箱中还有另一个工具:<strong class="jp ir"> Canvas API </strong>。</p><p id="da3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当涉及到布局时，大多数前端应用程序遵循相同的基本方法。在大多数情况下，我们渲染的一切都可以归结为文本框和文本串。当然，它们可以用多种方式表示，并组合起来创建独特而不可思议的用户界面。</p><p id="86e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象任何一个典型的网站。您可能会看到一个页眉、一个页脚、一个表格、大量的输入:文本框、复选框、单选按钮、长文本段落、短文字行等等。但所有这些变化都要归功于两个简单的元素:积木和绳子。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi no"><img src="../Images/58c246b85f8679b296365bdbbeda0fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgC-iPp0i06Gebeij5AP2Q.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/sign" rel="noopener ugc nofollow" target="_blank">由故事创建的符号向量</a></figcaption></figure><p id="f0cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个明显的例外:导入的资产:徽标、照片、自定义图像、用于不同目的的图片。您通常可以很快将它们与屏幕上的其他视觉效果区分开来。原因是他们视觉复杂性的独特性(我指的是好的方面)。</p><p id="e700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些图像不仅仅是由方框和文本组成的。如果你仔细看，你会发现直线、圆、曲线、三角形、多边形。HTML/CSS在历史上很难处理除块之外的形状(即使现在，有许多方法可以突破这些界限)。然而，即使在今天，由于任何外部应用程序，绘制复杂的图像并将其作为静态资产导入也要容易得多。</p><p id="b734" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，为什么要用Canvas API呢？如果我们总是可以简单地在页面上添加一个静态图像，为什么它还是一个东西呢？这个问题包含了答案:图像应该是静态的。</p><p id="fcfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时，我们需要对图像进行编程控制。经典的例子是一部动画。考虑一下，当网站加载时，你必须缓慢渐进地渲染你公司的logo。做好准备后，“烘焙”(我在这里有意抛出一个gamedev术语)图像是不够的。在每一帧，你必须渲染一个新的图像，这只是结果的一小部分。您还必须在这些分数之间进行转换。以编程方式绘制图片而不是使用静态资产可以处理这一点。Canvas的存在正是为了帮助你进行编程绘图。天啊，我们在开发游戏的时候确实需要这种能力！</p><blockquote class="ly lz ma"><p id="a829" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated">写这篇文章的时候，在2D有两种方式可以画画:Canvas API和SVG。最新的有许多吸引人的好处，但我们今天将重点放在画布上。原因是这通常是游戏中的一种方式。</p><p id="a067" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">“Canvas vs . SVG”对于浏览器游戏来说，无疑是一个令人兴奋的话题，大概值得单独讨论。现在，请允许我站在画布上。</em></p></blockquote><p id="f84c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank">画布API </a>的解剖超级简单，这里就不赘述了。外面有很多优秀的教程和例子。接下来，我假设您已经对Canvas的工作原理有了基本的了解。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="77f6" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">第一次“肮脏”抽签</h1><p id="36a5" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy np ka kb kc nq ke kf kg nr ki kj kk ij bi translated">让我们从简单的开始。我将首先做“脏”画，这将使我们看到画布“在行动”。然后，我们将慢慢地重构和改进我们的代码，使它适合我们巨大的需求。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ns"><img src="../Images/cd00667b41e9272560a0d02149f8f90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfvGzkegjX_AkR_AYlYvJw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/children" rel="noopener ugc nofollow" target="_blank">brgfx创建的子向量</a></figcaption></figure><p id="b20e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以把一个网格想象成一组“节点”，每个节点本质上是画布上的一个正方形。呈现它的最简单方法是遵循以下步骤:</p><ol class=""><li id="d34f" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk nm li lj lk bi translated">定义画布元素</li><li id="62b3" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nm li lj lk bi translated">将其添加到页面中</li><li id="f334" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nm li lj lk bi translated">画一堆长方形</li></ol><p id="3c72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在游戏实体中进行一轮肮脏的游戏:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f7ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您通过运行<code class="fe mf mg mh mi b">npm start</code>来启动代码，并在浏览器中导航到<code class="fe mf mg mh mi b">http://localhost:8080</code>，您应该会在浏览器的左上角看到一个红色的小方块:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nv"><img src="../Images/45222d96b951d98e9b17ca018d048af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbWaWbdK9lEyxmq58A2Jtg.png"/></div></div></figure><blockquote class="ly lz ma"><p id="1719" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">端口可能不同，如果8080不工作，检查webpack控制台输出</em></p></blockquote><p id="be8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，正方形的大小是<code class="fe mf mg mh mi b">50px</code>，它也从左上角移动了<code class="fe mf mg mh mi b">10px</code>。这一切都是通过简单的画布命令完成的:<code class="fe mf mg mh mi b">ctx.rect(10, 10, 50, 50)</code></p><p id="f746" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太棒了，我们有了第一个图像！这不是一张非常吸引人的照片，但是我们正在迈出第一步！</p><p id="2ae7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现网格，我们重复几次box draw调用:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3571" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我首先为盒子的<em class="mb">大小</em>和它的<em class="mb">偏移量</em>(边距，如果你愿意的话)定义常数。我在一个循环中重复绘制，有效地呈现了三个矩形。但是在浏览器中，我们仍然只能看到一个方块:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/7bd80ebf029c9d3f6530ea9e5f47e1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzxizoPLplafpOaoJ--yJw.png"/></div></div></figure><p id="733b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为我们一直在相同的<em class="mb">位置</em>渲染:从点<code class="fe mf mg mh mi b">(10, 10)</code>开始。我们一遍又一遍地重画同样的形状。我们可以通过使起始位置成为迭代的函数来检验我们的理论:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="adf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这确实证明了我们的小理论:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/8ba1e7ca32fc896cfb83f4b3448d4e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49tP-3HKYIkVjOw-uQVPBw.png"/></div></div></figure><p id="8670" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但还是不太对。矩形的一部分绘制在另一部分之上。发生这种情况是因为“保证金”的数额不够。每次我们调用<code class="fe mf mg mh mi b">ctx.rect</code>时，它的起始位置从<em class="mb">点零</em>开始计数，零点零就是左上角。但是每一个<em class="mb">新的</em>方块<em class="mb">开始于</em>前一个的地方<em class="mb">结束于</em>。我们应该增加每个新方块的起点坐标，使其成为前一个方块的右下角的坐标。然后加上偏移量:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ff1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这表现得很好:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nv"><img src="../Images/63983495b169c81ee0202a72849dc0c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYVwSjKGkFeZo_nsAeEMXg.png"/></div></div></figure><blockquote class="ly lz ma"><p id="672e" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">注意，第一个矩形没有偏移量，因为它在乘以零</em> <code class="fe mf mg mh mi b"><em class="iq">i</em></code> <em class="iq">时丢失了。这很好，因为我们希望矩形之间的偏移量为<em class="iq">。</em></em></p></blockquote><p id="7417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了画一个网格而不是这个漂亮的“梯子”，我们必须循环两次:第一次是垂直轴，第二次是水平轴:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="451c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">节点的起始位置将由各自的<code class="fe mf mg mh mi b">x</code>或<code class="fe mf mg mh mi b">y</code>乘数决定:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cb56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们劳动的成果:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/dd72ed9c4b20b8d0960228b830b098a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-oc8KbqNPOJHubbO-0-CA.png"/></div></div></figure><p id="5d34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！现在，当我们有了基本的理解，我们就可以开始改进代码了。首先，我不喜欢硬编码值的想法:网格的大小、节点的大小、节点之间的偏移量等等。如果有外部配置就更好了。它将允许我们在不钻研代码的情况下改变值。这一点至关重要，因为许多游戏都是由非技术专业人士(游戏设计师和艺术家)共同开发的。拥有一个无需深入代码就能改变游戏行为的工具可以节省大量时间。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="75fd" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">全局设置</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nx"><img src="../Images/daabd29b906a37cce065e6c3dc1563eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2CgsZVerZFFyIuYCE9l5dQ.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/business" rel="noopener ugc nofollow" target="_blank">studio stock创建的业务向量</a></figcaption></figure><p id="eee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想法很简单:我将定义一个全局不可变静态对象，它将保存所有可调整的值。我称之为<code class="fe mf mg mh mi b">Settings</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5194" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并为其定义一个桶文件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4cf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我将网格的所有设置放在这个对象中:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="458f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<em class="mb">维</em>保存网格的任意行/列中有多少节点的信息，<em class="mb">节点大小</em>是以像素为单位的节点宽度/高度，<em class="mb">节点偏移量</em>是以像素为单位的节点之间的边距，最后，<em class="mb">颜色</em>是节点的填充颜色:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1b24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有了结果:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/5e18a0101e659745eefbbd604051fa1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_KrxIbnPXBzolDw92nD-w.png"/></div></div></figure><p id="36fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些不对劲。前四行和前四列渲染正常，但第五行被裁剪，甚至没有看到第六个！这是因为我们的画布太小，无法处理那么多节点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="eaa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们根据设置来计算这些值，而不是硬编码这些值。注意，Canvas API需要一个字符串，而不是一个数字:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5ef3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们在画布上有了足够的空间:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/04e1e9ba52e8f66912befbb64587d338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYtB7J5O4WxqTBaCZ3W6RQ.png"/></div></div></figure><p id="fb96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们结束这个故事之前有一个小小的改进。您可能会注意到网格贴在屏幕的左侧。这很公平，因为画布是从左上角开始绘画的。但是在屏幕中间看到网格会稍微好一点。</p><p id="52c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过移动第一行和第一列节点来实现。然而，更简单的方法是假设我们总是从<em class="mb">画布</em>的左上角开始绘制，并简单地移动画布<em class="mb">本身</em>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="72e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们使用好的旧CSS将<code class="fe mf mg mh mi b">canvas</code> DOM元素放在页面的中间。我们对节点的计算仍然有效，因为我们总是从画布的左上角开始绘制所有内容:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/9c390466c1573b4d18b4ac4fa566f104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6JhuCLrYDeIJj9luJ9MvA.png"/></div></div></figure><p id="cc99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意这个简单但强大的概念:全球与本地职位。我们将节点放置在画布<em class="mb">局部</em>坐标系中，该坐标系相对于画布元素<em class="mb">移动画布会改变节点的<em class="mb">全局</em>位置，但不会改变<em class="mb">局部</em>位置。</em></p><blockquote class="ly lz ma"><p id="20b1" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">注意，这个项目中的webpack devServer/hotReload设置忽略了</em> <code class="fe mf mg mh mi b"><em class="iq">public</em></code> <em class="iq">文件夹中的更改。要查看更新的CSS，您必须手动重新加载页面。</em></p><p id="23b1" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><em class="iq">你可以在</em> <a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank"> <em class="iq">资源库</em> </a> <em class="iq">的</em> <code class="fe mf mg mh mi b"><em class="iq">drawing-grid-1</em></code> <em class="iq">分支中找到本帖的完整源代码。</em></p></blockquote></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="af63" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">结论</h1><p id="fffc" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy np ka kb kc nq ke kf kg nr ki kj kk ij bi translated">厉害！我们已经在屏幕上画出了我们的整个网格，并使它看起来很好。我们还让它可以通过全局设置进行调整，与代码无关。在<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener"> <em class="mb">第二部分</em> </a>中，我们将修改这段代码，使其更加健壮和可扩展。</p><p id="6e16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有任何意见、建议、问题或任何其他反馈，请不要犹豫，给我发私信或在下面留下评论！感谢您的阅读，我们下次再见！</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="f6e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mb">这是系列教程第三章“</em> <strong class="jp ir"> <em class="mb">用打字稿</em> </strong> <em class="mb">”构建游戏。其他章节可点击此处:</em></p><ul class=""><li id="59d8" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="2289" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="0622" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第二章。游戏循环(<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部分</a>)</li><li id="b7bf" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第三章。绘制网格(第1部分，<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第2部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第3部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第4部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第5部分</a>)</li><li id="9bb9" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第四章。舰船(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="cde3" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="420b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第六章。寻路与移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="ee0e" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第七章。玛奇纳州</li><li id="f0a4" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第八章。攻击系统:生命和伤害</li><li id="b6ac" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第九章。比赛的输赢</li><li id="17f8" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第十章敌人AI</li></ul></div></div>    
</body>
</html>