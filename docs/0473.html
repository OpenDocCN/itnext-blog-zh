<html>
<head>
<title>React Starter Kit — Part 1 (Introduction)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React初学者工具包—第1部分(简介)</h1>
<blockquote>原文：<a href="https://itnext.io/react-starter-kit-part-1-introduction-78a27db36f6c?source=collection_archive---------8-----------------------#2018-03-14">https://itnext.io/react-starter-kit-part-1-introduction-78a27db36f6c?source=collection_archive---------8-----------------------#2018-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/af37e75d1417c0841c7f87d859426502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdMC4chJzTyAItlnPNFIuQ.jpeg"/></div></div></figure><div class=""/><p id="13c9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在Angular中写代码已经快两年了，但是我总是在聚会、技术会议甚至酒吧中听到来自其他开发人员的消息"<em class="kw">反应太容易了</em>"我完全没有头绪，只是回复"<em class="kw">真的吗</em>！"或者“<em class="kw">可能是</em>”。</p><p id="ad98" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不再装傻了，我想学着自己去理解不同之处。让我们开始吧</p><h2 id="30f7" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">什么是反应？</h2><ul class=""><li id="e0ff" class="lq lr jb ka b kb ls kf lt kj lu kn lv kr lw kv lx ly lz ma bi translated">Javascript库(非框架)</li><li id="2aa1" class="lq lr jb ka b kb mb kf mc kj md kn me kr mf kv lx ly lz ma bi translated">建立在脸书(更容易使大型单页应用程序)</li><li id="9d34" class="lq lr jb ka b kb mb kf mc kj md kn me kr mf kv lx ly lz ma bi translated">促进函数式编程</li></ul><h2 id="9e58" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">谁使用它？</h2><p id="b291" class="pw-post-body-paragraph jy jz jb ka b kb ls kd ke kf lt kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">各种市场领导者在生产中使用React来了解细节，请参考此链接<a class="ae mj" href="https://github.com/facebook/react/wiki/Sites-Using-React" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/react/wiki/Sites-Using-React</a></p><h2 id="d90d" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">我们要用哪个反应？</h2><p id="0eff" class="pw-post-body-paragraph jy jz jb ka b kb ls kd ke kf lt kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">我很幸运地从React 16(或React fibre)开始。有很多小改动的版本。它的几个特点是:</p><ul class=""><li id="3e63" class="lq lr jb ka b kb kc kf kg kj mk kn ml kr mm kv lx ly lz ma bi translated">改进的异步渲染</li><li id="ba33" class="lq lr jb ka b kb mb kf mc kj md kn me kr mf kv lx ly lz ma bi translated">返回元素数组</li><li id="457a" class="lq lr jb ka b kb mb kf mc kj md kn me kr mf kv lx ly lz ma bi translated">更好的错误处理</li><li id="fb39" class="lq lr jb ka b kb mb kf mc kj md kn me kr mf kv lx ly lz ma bi translated">较小的文件大小</li></ul><p id="9b1d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">许多先行者注意到了巨大的性能改进，但对开发人员来说变化不大。</p><h2 id="9509" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">反应语法</h2><p id="5312" class="pw-post-body-paragraph jy jz jb ka b kb ls kd ke kf lt kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">让我们看看我们的样本index.html文件，我们有脚本链接来反应和反应dom。后者负责将所有内容呈现给我们的页面。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d25a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们使用<strong class="ka jc"> React.createElement创建了一个新的react元素，</strong>没有传递任何属性，并将“Hello world”作为子元素。第二个参数是要呈现这个新创建的元素的目标元素。很简单，对，所以如果你在浏览器中打开上面的页面，你会看到“Hello world”作为输出。</p><h2 id="d6c0" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">JSX简介</h2><p id="88e8" class="pw-post-body-paragraph jy jz jb ka b kb ls kd ke kf lt kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">现在一切都很好，但是考虑一下你想在循环中的什么地方呈现全新的复杂标签，比如list (li)或者tr等等。那么这种创建元素的方式可能会失控。这就是JSX出现的原因。JSX，或JavaScript as XML，是一种语言扩展，允许您直接在JavaScript中编写标签。</p><p id="62e8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们直接在现有文件中写下面的代码，我们会得到一个错误，因为我们需要将jsx编译成javascript。</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="bf7d" class="kx ky jb mu b gy my mz l na nb">&lt;script type="text/javascript"&gt;</span><span id="e4ae" class="kx ky jb mu b gy nc mz l na nb">ReactDOM.render(</span><span id="e0c1" class="kx ky jb mu b gy nc mz l na nb">&lt;h1&gt;&lt;/h1&gt;,</span><span id="f1ba" class="kx ky jb mu b gy nc mz l na nb">document.getElementById('react-container')</span><span id="cda8" class="kx ky jb mu b gy nc mz l na nb">)</span><span id="9d1e" class="kx ky jb mu b gy nc mz l na nb">&lt;/script&gt;</span></pre><p id="d9a7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了编译jsx，我们现在打算在babel浏览器中使用，并像下面这样修改文件。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d362" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们包括了巴别塔的cdn脚本版本，但它会非常慢。这是用来演示的，稍后我们会以更有效的方式来做。</p><p id="274d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，当项目越做越大，就很难一遍又一遍的写React.createElement。那么jsx就是我们的大救星。</p><h2 id="ccd2" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">ES6 —类别组件</h2><p id="c840" class="pw-post-body-paragraph jy jz jb ka b kb ls kd ke kf lt kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">react的主要思想是组件。我们将各种组件组合在一起，形成一个用户界面。</p><p id="e717" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建我们的第一个组件。为此，我们将使用ES6类。</p><p id="7c5d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建一个简单的ES6类，命名为HELLO，并扩展React.component。在里面，我们将编写一个名为render method的must方法，它只返回JSX。稍后，我们需要使用这个新创建的组件，如下所示。</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="6938" class="kx ky jb mu b gy my mz l na nb">ReactDOM.render(</span><span id="6116" class="kx ky jb mu b gy nc mz l na nb">&lt;Hello&gt;&lt;/Hello&gt;,</span><span id="813c" class="kx ky jb mu b gy nc mz l na nb">document.getElementById('react-container')</span><span id="2962" class="kx ky jb mu b gy nc mz l na nb">)</span></pre><p id="a909" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请参考以下完整文件的代码:</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f786" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您注意到了，我们还在新的react组件中放置了id和class。唯一的问题是我们不能在JSX中使用css类的class，因为它已经在定义ES6类中使用了。所以，我们把它命名为<strong class="ka jc"> className。</strong>其他都一样。</p><h2 id="2253" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">无状态功能组件</h2><p id="8865" class="pw-post-body-paragraph jy jz jb ka b kb ls kd ke kf lt kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">创建组件的另一种方式是通过无状态组件函数。我们上面的例子只是一个返回UI或jsx的类。我们的无状态函数也是一样的，它是一个返回UI的函数。</p><p id="2e4d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一种非常常见的语法，您会在许多react项目和文档中看到。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="09a1" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">性能</h2><p id="9359" class="pw-post-body-paragraph jy jz jb ka b kb ls kd ke kf lt kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">下一个目标是如何在我们刚刚创建的无状态组件中传递一些数据。为此我们有道具。es6组件和无状态函数组件的唯一区别是，前者有类似<strong class="ka jc"> this.props </strong>的属性，而后者是函数参数。</p><p id="5d89" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请参考以下要点，了解实际实施情况</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="5660" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">状态</h2><p id="88b0" class="pw-post-body-paragraph jy jz jb ka b kb ls kd ke kf lt kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">我个人觉得状态是react最重要的概念之一。这就像每当状态改变时，渲染函数被再次调用。</p><p id="f400" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了描述状态的实现，我们将通过es6类的方式创建组件并构造这个新类</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="8e84" class="kx ky jb mu b gy my mz l na nb">constructor(props) {</span><span id="911a" class="kx ky jb mu b gy nc mz l na nb">super(props)</span><span id="0619" class="kx ky jb mu b gy nc mz l na nb">this.state = {</span><span id="0aed" class="kx ky jb mu b gy nc mz l na nb">checked: true</span><span id="3cd4" class="kx ky jb mu b gy nc mz l na nb">}</span><span id="1ee7" class="kx ky jb mu b gy nc mz l na nb">}</span></pre><p id="b0bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们只需将我们的道具传递给super，并用选中的一个键初始化状态，就这样。</p><p id="6f63" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将编写另一个函数来处理状态的变化，只需在state中切换选中的键。</p><pre class="mn mo mp mq gt mt mu mv mw aw mx bi"><span id="adeb" class="kx ky jb mu b gy my mz l na nb">handleCheck = () =&gt; {</span><span id="9920" class="kx ky jb mu b gy nc mz l na nb">this.setState({</span><span id="bd60" class="kx ky jb mu b gy nc mz l na nb">checked: !this.state.checked</span><span id="3a9b" class="kx ky jb mu b gy nc mz l na nb">})</span><span id="0e30" class="kx ky jb mu b gy nc mz l na nb">}</span></pre><p id="f62c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很简单，请不要放松焦点，它就要结束了</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a860" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在上面的代码中，我们只是在state full组件中创建了一个复选框&amp;每当我们改变复选框时，我们就改变了存储这个选择的变量，并更新了状态。</p><p id="f520" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了验证这一点，每当状态改变时，都会再次调用render。我们实际上是在屏幕上显示消息，这取决于复选框的选中和未选中状态。</p><h2 id="eeb1" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">结论</h2><p id="e566" class="pw-post-body-paragraph jy jz jb ka b kb ls kd ke kf lt kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">这是React Starter中三个教程的第一个。本教程的目的是让你在直接创建新项目之前熟悉react的概念。接下来，我们将使用本文描述的核心概念在react中创建一个成熟的项目。</p><p id="6f73" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一篇文章链接将很快在这里更新。</p></div></div>    
</body>
</html>