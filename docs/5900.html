<html>
<head>
<title>MIDI Listener in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的MIDI监听器</h1>
<blockquote>原文：<a href="https://itnext.io/midi-listener-in-swift-b6e5fb277406?source=collection_archive---------0-----------------------#2021-06-25">https://itnext.io/midi-listener-in-swift-b6e5fb277406?source=collection_archive---------0-----------------------#2021-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d81" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">CoreMIDI实用介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d6f7abbabfe2d0814e4bf8954e5f1198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HTfkZTwm2GdCf7FWOa1fKw.png"/></div></div></figure><p id="dd5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章是一个编程教程，教你如何用自己的代码在iPhone、iPad或Mac上接收MIDI信息。它将提供一个代码遍历和一个可下载的Xcode项目，以及一个完整的工作示例。</p><h2 id="af62" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">背景</h2><p id="e3ec" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">2013年8月26日，我买了一个罗兰A-88 MIDI控制器。我真的以为我有时间自学弹钢琴。</p><p id="d3ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">众所周知，我对事物充满好奇，我曾问自己“什么是MIDI，从那个控制器出来的是什么？”。是的，我可以走捷径，下载一个应用程序，但是…</p><p id="cb8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就在一年前，我从PC转向Mac，并渴望尝试任何macOS和iOS开发。</p><p id="6593" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个新的项目诞生了:迷笛援助。</p><div class="mo mp gp gr mq mr"><a href="https://twissmueller.medium.com/midi-aid-ab4454cfee58" rel="noopener follow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">MIDI Aid</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">编辑描述</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">twissmueller.medium.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ks mr"/></div></div></a></div><p id="c2e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这么多关于学习钢琴。</p><p id="b80c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当时的app都是用Objective-C和UIKit做的。当时很难找到任何关于CoreMIDI的教程，但我已经设法完成了。MIDI Aid的首次发布是在2014年2月8日。</p><p id="3525" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着Swift和SwiftUI的推出，世界发生了变化。至少是我的世界，当然还有许多其他苹果开发者。CoreMIDI本身也有一些我想用的更新。</p><p id="b408" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我已经用Swift和SwiftUI完全重写了MIDI Aid，并于2020年11月26日发布。</p><p id="6fa7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在CoreMIDI上总是很难找到足够的教程，而且随着所有新的变化，大多数都在一夜之间过时了。有一个空白。没有完整的代码示例说明如何从iOS、iPadOS或macOS设备上的控制器接收简单的MIDI消息。</p><p id="54bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章通过提供一个代码遍历和一个完整的Xcode项目填补了空白。</p><p id="2cbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为macOS或iOS编译它，插入USB MIDI设备并开始敲击按键，或者在你的设备上触发MIDI信息的任何东西。</p><p id="f921" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当应用程序收到一个MIDI信息，它将被记录。目前，它支持“音符开”和“音符关”事件，但也可以很容易地扩展到其他类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="720d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">在这里</strong>  <strong class="kw iu">可以下载到Xcode-workspace的</strong> <a class="ae ni" href="https://www.buymeacoffee.com/twissmueller/e/35726" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">。</strong></a></p><p id="8a5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意:我没有在编写代码时考虑所谓的SysEx消息，因为我没有办法测试我的控制器。</p><h2 id="fc5e" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">先决条件</h2><p id="80db" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">遵循本教程需要做一些事情。</p><p id="f56c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们假设你有某种类型的MIDI控制器，你需要一种方法将其连接到你的Mac、iPhone或iPad。</p><p id="01b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">连接MIDI控制器有三种方式:</p><ul class=""><li id="9d3f" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">经典的MIDI电缆</li><li id="53f1" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">usb电缆</li><li id="f13e" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">蓝牙。</li></ul><p id="846c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">USB线是最简单的一种，因为它可以直接插入你的苹果设备。可能需要USB-A转Lightning或USB-C适配器。</p><p id="3c0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您的设备不支持USB，传统的MIDI端口需要使用适配器电缆，例如<a class="ae ni" href="https://www.roland.com/de/products/um-one_mk2/" rel="noopener ugc nofollow" target="_blank"> Roland UM-ONE mk2 </a>。</p><p id="9f65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">蓝牙也是一个选项，但需要更多的编码，至少对于iOS来说是这样，我在本教程中没有提到。有像Roland WM-1这样的设备可以通过蓝牙传输所有的MIDI信号。</p><p id="7952" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到先决条件，你当然也需要Xcode。我已经用Xcode 12.5.1编写并测试了代码。</p><p id="136d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">谈到Xcode，你可能想知道当你的MIDI设备插入到你的iOS设备时，如何调试你的代码。Xcode里有一个设置，表示可以通过WiFi启动app。</p><p id="0702" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只需打开<code class="fe nx ny nz oa b">Window</code> - &gt; <code class="fe nx ny nz oa b">Devices and Simulators</code>，选择你的iOS设备，激活“通过网络连接”。从现在开始，从Xcode启动iOS设备上的应用程序不需要USB电缆。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/3e4384889946a3af3c7f05c66f624ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-yG1am_H6FHruKoyUSeCAA.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">通过网络连接</figcaption></figure><h2 id="7d20" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">代码走查</h2><p id="736f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在，是时候写一些代码了。我提供了所需的类以及它们到苹果文档的链接，并引用了苹果的描述。</p><p id="1c86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一切都以a开头</p><ul class=""><li id="9388" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><code class="fe nx ny nz oa b"><a class="ae ni" href="https://developer.apple.com/documentation/coremidi/midiclientref" rel="noopener ugc nofollow" target="_blank">MIDIClientRef</a></code></li></ul><blockquote class="og oh oi"><p id="6ce6" class="ku kv oj kw b kx ky ju kz la lb jx lc ok le lf lg ol li lj lk om lm ln lo lp im bi translated">客户端对象派生自MIDIObjectRef。它没有拥有对象。</p></blockquote><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="7d5a" class="lq lr it oa b gy or os l ot ou">var midiClient: MIDIClientRef = 0</span></pre><p id="83b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们通过调用</p><ul class=""><li id="c295" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><code class="fe nx ny nz oa b"><a class="ae ni" href="https://developer.apple.com/documentation/coremidi/1495330-midiclientcreatewithblock" rel="noopener ugc nofollow" target="_blank">MIDIClientCreateWithBlock</a></code></li></ul><blockquote class="og oh oi"><p id="285b" class="ku kv oj kw b kx ky ju kz la lb jx lc ok le lf lg ol li lj lk om lm ln lo lp im bi translated">创建一个带有回调块的MIDI客户端。</p></blockquote><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="9114" class="lq lr it oa b gy or os l ot ou">MIDIClientCreateWithBlock("Client" as CFString, &amp;midiClient) { midiNotification in<br/>   ...<br/>}</span></pre><p id="6302" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们的MIDI设置发生变化时，这个回调函数将被调用。当设备插入时，它需要“内部”连接。这个在最后解释。</p><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="496b" class="lq lr it oa b gy or os l ot ou">switch (notification.messageID) {<br/>    ...<br/>    case .msgObjectAdded:<br/>         NSLog("msgObjectAdded")<br/>         // connect the source, see below</span></pre><p id="d0b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一步是声明一个</p><ul class=""><li id="2d62" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><code class="fe nx ny nz oa b"><a class="ae ni" href="https://developer.apple.com/documentation/coremidi/midiportref" rel="noopener ugc nofollow" target="_blank">MIDIPortRef</a></code></li></ul><blockquote class="og oh oi"><p id="c96d" class="ku kv oj kw b kx ky ju kz la lb jx lc ok le lf lg ol li lj lk om lm ln lo lp im bi translated">port对象派生自MIDIObjectRef，其所属对象是MIDIDeviceRef。它代表一个输入或输出端口，并提供与任意数量的MIDI源或目的地进行通信的方法。</p></blockquote><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="e361" class="lq lr it oa b gy or os l ot ou">var inputPort: MIDIPortRef = 0</span></pre><p id="1b77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与上面类似，需要创建端口对象。我们通过调用</p><ul class=""><li id="0bf5" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><code class="fe nx ny nz oa b"><a class="ae ni" href="https://developer.apple.com/documentation/coremidi/3566488-midiinputportcreatewithprotocol" rel="noopener ugc nofollow" target="_blank">MIDIInputPortCreateWithProtocol</a></code></li></ul><blockquote class="og oh oi"><p id="c042" class="ku kv oj kw b kx ky ju kz la lb jx lc ok le lf lg ol li lj lk om lm ln lo lp im bi translated">创建一个输入端口，客户端可以通过该端口接收来自任何MIDI源的MIDI信息。</p></blockquote><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="542a" class="lq lr it oa b gy or os l ot ou">MIDIInputPortCreateWithProtocol(<br/>            midiClient,<br/>            "Input Port as CFString" as CFString,<br/>            MIDIProtocolID._1_0,<br/>            &amp;inputPort) {  [weak self] eventList, srcConnRefCon in <br/>    ...            <br/>}</span></pre><p id="86e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们继续使用类型为<code class="fe nx ny nz oa b">UnsafePointer&lt;MIDIEventList&gt;</code>的<code class="fe nx ny nz oa b">eventList</code>。这是我们想要提取的MIDI数据。</p><ul class=""><li id="b7b6" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><code class="fe nx ny nz oa b"><a class="ae ni" href="https://developer.apple.com/documentation/avfaudio/midieventlist/" rel="noopener ugc nofollow" target="_blank">MIDIEventList</a></code></li></ul><blockquote class="og oh oi"><p id="9985" class="ku kv oj kw b kx ky ju kz la lb jx lc ok le lf lg ol li lj lk om lm ln lo lp im bi translated">MIDI事件包的可变长度列表。</p></blockquote><p id="404d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从那里我们可以继续分析MIDI信息。</p><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="4842" class="lq lr it oa b gy or os l ot ou">let midiEventList: MIDIEventList = unsafePointerMidiEventList.pointee<br/>var packet = midiEventList.packet<br/>        <br/>(0 ..&lt; midiEventList.numPackets).forEach { _ in<br/>    ...        <br/>}</span></pre><p id="50e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在循环中，我们可以提取所有的数据包。</p><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="96cb" class="lq lr it oa b gy or os l ot ou">let words = Mirror(reflecting: packet.words).children<br/>words.forEach { word in<br/>    let uint32 = word.value as! UInt32<br/>    guard uint32 &gt; 0 else { return }<br/>    midiPacket = MidiPacket(<br/>        first: UInt8((uint32 &amp; 0xFF000000) &gt;&gt; 24),<br/>        second: UInt8((uint32 &amp; 0x00FF0000) &gt;&gt; 16),<br/>        third: UInt8((uint32 &amp; 0x0000FF00) &gt;&gt; 8),<br/>        fourth: UInt8(uint32 &amp; 0x000000FF))        <br/>}</span></pre><p id="de9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不清楚的是包数(<code class="fe nx ny nz oa b">numPackets</code>)。根据我的观察，我按下一个键它的一个包，释放一个键，另一个包，等等。</p><p id="b0e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许当接收到一个不祥的SysEx消息时，会有更多的数据包。就我记忆所及，这些信息的长度是可变的。</p><p id="3662" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们连接来源。</p><p id="36cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们通过以下方式获得源的数量</p><ul class=""><li id="aa6d" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><code class="fe nx ny nz oa b"><a class="ae ni" href="https://developer.apple.com/documentation/coremidi/1495116-midigetnumberofsources" rel="noopener ugc nofollow" target="_blank">MIDIGetNumberOfSources</a></code></li></ul><blockquote class="og oh oi"><p id="0a7d" class="ku kv oj kw b kx ky ju kz la lb jx lc ok le lf lg ol li lj lk om lm ln lo lp im bi translated">返回系统中源的数量。</p></blockquote><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="5ed7" class="lq lr it oa b gy or os l ot ou">let sourceCount = MIDIGetNumberOfSources()</span></pre><p id="02b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们遍历每个源索引来检索源</p><ul class=""><li id="576b" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><code class="fe nx ny nz oa b"><a class="ae ni" href="https://developer.apple.com/documentation/coremidi/1495168-midigetsource" rel="noopener ugc nofollow" target="_blank">MIDIGetSource</a></code></li></ul><blockquote class="og oh oi"><p id="2b82" class="ku kv oj kw b kx ky ju kz la lb jx lc ok le lf lg ol li lj lk om lm ln lo lp im bi translated">返回系统中的源。</p></blockquote><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="6973" class="lq lr it oa b gy or os l ot ou">var source = MIDIGetSource(sourceIndex)</span></pre><p id="d60b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后每个源通过调用</p><ul class=""><li id="1d47" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><a class="ae ni" href="https://developer.apple.com/documentation/coremidi/1495278-midiportconnectsource" rel="noopener ugc nofollow" target="_blank"> MIDIPortConnectSource </a></li></ul><blockquote class="og oh oi"><p id="f5f0" class="ku kv oj kw b kx ky ju kz la lb jx lc ok le lf lg ol li lj lk om lm ln lo lp im bi translated">建立从源到客户端输入端口的连接。有效性</p></blockquote><pre class="kj kk kl km gt on oa oo op aw oq bi"><span id="ec60" class="lq lr it oa b gy or os l ot ou">MIDIPortConnectSource(inputPort, source, &amp;source)</span></pre><p id="bb98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将连接源代码的代码放在一个单独的函数中，并调用两次。首先，我在初始化并创建了<code class="fe nx ny nz oa b">MIDIClientRef</code>和<code class="fe nx ny nz oa b">MIDIPortRef</code>之后，在启动时调用它。然后，每当有新设备插入时，我也会调用它。</p><h2 id="daa2" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">结论</h2><p id="7d98" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">希望这篇教程能让你实现自己的基于CoreMIDI的代码。</p><p id="dad0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从将MIDI控制器连接到Mac、iPhone或iPad，然后在代码中设置正确的结构，最后在屏幕上显示MIDI信息，我们经历了所有需要的步骤。</p><p id="c90b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了显示MIDI信息，还有很多其他的使用案例。当然，MIDI信息也可以由代码生成，以控制其他MIDI设备。也许在未来，会有另一个教程，但也许我应该先学会弹钢琴。</p><p id="862c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果有任何不清楚的地方，或者万一你在实现你的特定用例时有困难，请随时留下你的评论。</p><p id="b13d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">在这里</strong>  <strong class="kw iu">可以下载到Xcode-workspace的</strong> <a class="ae ni" href="https://www.buymeacoffee.com/twissmueller/e/35726" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">。</strong></a></p><p id="7e9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读！</p><ul class=""><li id="4b41" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">如果你喜欢这个，请跟随我</li><li id="683b" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">给我买杯咖啡让我继续前进</li><li id="0e91" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">支持我和其他媒体作者<a class="ae ni" href="https://twissmueller.medium.com/membership" rel="noopener">在这里注册</a></li></ul><p id="7ccb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae ni" href="https://twissmueller.medium.com/membership" rel="noopener">https://twissmueller.medium.com/membership</a></p><h2 id="2d68" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">资源</h2><ul class=""><li id="42e2" class="nj nk it kw b kx mj la mk ld ov lh ow ll ox lp no np nq nr bi translated"><a class="ae ni" href="https://developer.apple.com/documentation/coremidi" rel="noopener ugc nofollow" target="_blank"> CoreMIDI </a></li><li id="6fc0" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated"><a class="ae ni" href="https://stackoverflow.com/q/26494434/1065468" rel="noopener ugc nofollow" target="_blank">在swift中使用MIDIPacketList</a></li><li id="db37" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated"><a class="ae ni" href="https://stackoverflow.com/questions/28924831/coremidi-callbacks-in-swift" rel="noopener ugc nofollow" target="_blank">Swift中的CoreMIDI回调</a></li></ul></div></div>    
</body>
</html>