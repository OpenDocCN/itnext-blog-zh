<html>
<head>
<title>Converting Ingress Objects to Istio Virtual Service HTTP Routes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将入口对象转换为Istio虚拟服务HTTP路由</h1>
<blockquote>原文：<a href="https://itnext.io/converting-ingress-objects-to-istio-virtual-service-http-routes-5461d3b2f928?source=collection_archive---------1-----------------------#2022-06-15">https://itnext.io/converting-ingress-objects-to-istio-virtual-service-http-routes-5461d3b2f928?source=collection_archive---------1-----------------------#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="8e73" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="9358" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本文将研究如何将普通入口对象转换成Istio虚拟服务HTTP路由。它不会深入研究为什么这可能是必要的，也不会深入研究Istio的任何特定特性。</p><h1 id="96a9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">问题描述</h1><p id="3e59" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">将只使用前缀的对象从ingress转换到Istio非常简单。当Nginx重写目标用于被转换的对象时，事情变得有点棘手。Istio虚拟服务文档非常好，涵盖了流量如何通过网关转发。</p><h1 id="3919" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">提示、技巧和须知</h1><p id="d635" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">根据<a class="ae lj" href="https://istio.io/latest/docs/reference/config/networking/virtual-service/#VirtualService" rel="noopener ugc nofollow" target="_blank"> Istio文档</a>，HTTP路由是“HTTP流量的有序路由列表。将使用与传入请求匹配的第一个规则。Istio将应用一个虚拟服务，它带有一个永远不会被命中的前缀，而且还会提供一条非常有用的消息，直接说明这一点。</p><p id="e5cd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">下面的虚拟服务示例将用于触发错误:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="b0a2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">关于这个虚拟服务，需要注意的重要一点是“/”被定义为“/api”之前的前缀，这意味着第一个HTTP路由将捕获每个请求，甚至是那些发往“/api”的请求。</p><p id="5a4b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">不出所料，生成了一个警告。</p><pre class="lp lq lr ls gt lw lx ly lz aw ma bi"><span id="2245" class="mb jo iq lx b gy mc md l me mf">[root@server:~]</span><span id="8b1c" class="mb jo iq lx b gy mg md l me mf">$ kubectl apply -f virtual-service-warning.yaml</span><span id="0308" class="mb jo iq lx b gy mg md l me mf"><strong class="lx ir">Warning:</strong> virtualService rule "slash-api" match #0 of prefix /api is not used (duplicate/overlapping match in rule #0 of prefix / on "slash")</span><span id="8fba" class="mb jo iq lx b gy mg md l me mf">virtualservice.networking.istio.io/example-vs created</span><span id="12f2" class="mb jo iq lx b gy mg md l me mf">[root@server:~]</span><span id="7303" class="mb jo iq lx b gy mg md l me mf">$</span></pre><p id="36a1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">所以Istio会很乐意让你创建一个虚拟服务，有一个永远不会被击中的路线，就像…</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mh lv l"/></div></figure><h1 id="e797" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">重写目标</h1><p id="077a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">棘手的部分来自重写目标，使用重写目标是为了将URL从入口控制器看到的内容更改为pod期望看到的其他内容。</p><h2 id="f604" class="mb jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">Nginx</h2><p id="0fb6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Nginx重写目标的方式是通过入口对象上的注释。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Nginx入口对象</figcaption></figure><p id="c4af" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这个入口物体是旧的，但它启发了这篇文章，所以我们继续使用它。入口API版本现在是networking.k8s.io/v1.。另一个需要注意的关键是，从<a class="ae lj" href="https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/" rel="noopener ugc nofollow" target="_blank"> K8s 1.18 </a>开始，<a class="ae lj" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types" rel="noopener ugc nofollow" target="_blank"> pathType </a>是一个必需的参数。</p><p id="e21b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">此规则的作用是捕获进入入口控制器的所有流量，匹配以“/gateway/”开头的任何内容，删除“/gateway/”，然后将请求传递到pod。如果在“/gateway/”之后有URI的附加部分，则当请求被传递到pod时，该部分仍然是URI的一部分。希望一个例子能让事情更清楚。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/f2d50745eee69673d3804abf5fc7d583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHqZr--MIIRKLgbFZTQAaw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">重写目标示例</figcaption></figure><p id="f078" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这个行为是通过要点第6行的注释来完成的，这个“/$2”是一个捕获组，它是正则表达式中的一个构造(进一步阅读<a class="ae lj" href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/#rewrite-target" rel="noopener ugc nofollow" target="_blank">这里的</a>)。在这个正则表达式位上放一个大头针，它会回来的。</p><h2 id="a104" class="mb jo iq bd jp mi mj dn jt mk ml dp jx kw mm mn kb la mo mp kf le mq mr kj ms bi translated">伊斯迪奥</h2><p id="c283" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在考虑如何在Istio中实现这一点，注意力转向<a class="ae lj" href="https://istio.io/latest/docs/reference/config/networking/virtual-service/" rel="noopener ugc nofollow" target="_blank"> Istio虚拟服务</a>，因为这是控制流量如何路由的对象，特别是在虚拟服务定义的“http”部分。进一步查看虚拟服务文档,“http”部分中的每个流量路由条目都必须有“match”定义，它告诉Istio作为规则的一部分应该路由什么流量。“匹配”部分可以可选地包括“uri”部分，其中定义了要被路由的URL路径。用于<a class="ae lj" href="https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest" rel="noopener ugc nofollow" target="_blank"> URI匹配的选项是exact/prefix/regex </a>，如果您停止阅读这里的文档，您可能倾向于使用regex路径来转换本文中提到的初始入口对象。尝试谷歌如何像这样转换对象可能会导致自定义特使过滤器被创建的道路。有人甚至在Istio repo中打开了一个问题,要求内置该功能。</p><p id="cd4f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">通读文档并不完全清楚的是，与ingress对象完全一样的路由这种流量的能力已经得到支持，而无需做任何太花哨的事情，实现这一点的Istio配置如下:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="eefa" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">但是等等…只是一个前缀URI类型，URI的其余部分是如何被捕获的？同样，文档对此并不完全清楚。这在某种程度上暗示了URI的其余部分在重写后被保留，而没有明确地声明它:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ne"><img src="../Images/744ff47d8f90b731861e1743d29501bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFXBmty81oozJBoj2PPrew.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Istio文档片段</figcaption></figure><p id="7720" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">比赛的类型是令人困惑的部分。在原始入口对象的匹配逻辑中使用了正则表达式，这可以理解地导致人们认为“regex”是这里使用的合适的URI匹配类型。这将潜在地引导我们了解如何在原始入口对象中复制注释的'/$2 '部分。同样，上面使用“前缀”的URI匹配的Istio虚拟服务定义将在没有任何正则表达式的情况下完成工作。</p><h1 id="f320" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">包裹</h1><p id="009d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里最重要的一点是，Istio虚拟服务通过使用“前缀”URI类型来支持Nginx入口对象的regex样式捕获组。为了在Istio中获得相同的功能，不需要正则表达式URI类型。</p><p id="40e1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">和乔丹·麦克林托克一起调试这个问题很有趣。</p></div></div>    
</body>
</html>