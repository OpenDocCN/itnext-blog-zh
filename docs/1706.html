<html>
<head>
<title>How to Create a Kubernetes Custom Controller Using client-go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用client-go创建Kubernetes定制控制器</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-a-kubernetes-custom-controller-using-client-go-f36a7a7536cc?source=collection_archive---------0-----------------------#2019-01-08">https://itnext.io/how-to-create-a-kubernetes-custom-controller-using-client-go-f36a7a7536cc?source=collection_archive---------0-----------------------#2019-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2ba6f5477e7f57a20e9075745d1dc04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ry6tZKad1k20jJ9P"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">菲德尔·费尔南多在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9b27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">使用Kubernetes定制控制器，您可以通过观察来自Kubernetes API对象(如名称空间、部署或pod)或您自己的CRD(定制资源定义)资源的事件来进一步开发您自己的定制业务逻辑。</p><p id="4a37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的下一部分将深入探讨client-go模块，随后是一个定制控制器示例。</p><p id="6a64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">客户端-go模块</strong></p><p id="ddb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kubernetes将client-go用作官方API客户端库，提供对Kubernetes API服务器提供的Kubernetes` restful API接口的访问。像kubectl或prometheus-operator这样的工具大量使用它。</p><p id="2612" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该库包含几个重要的包和实用程序，可用于访问API资源或方便定制控制器。</p><p id="b32a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">kubernetes</code>包提供了clientset和Kubernetes资源特定的clientset方法，用于访问标准的Kubernetes APIs。请注意，您不应该使用它来访问CRD资源。这个包是自动生成的。</p><p id="6865" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">discovery</code>包提供了发现服务器支持的API组、版本和资源的方法。</p><p id="942c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">dynamic</code>包提供了一个动态客户端，可以在任意的Kubernetes API资源上执行restful操作[1]。请注意，不建议将它用于访问CRD资源，因为它不是类型安全的[2]。</p><p id="bbf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">transport</code>软件包设置安全的TCP授权和连接。如果没有明确禁用，默认情况下将使用HTTP2协议。底层的HTTP2设施由k8s.io/apimachinery/util/net提供。由于一些操作需要在客户端和容器之间传输二进制流，例如attach、exec、portforward和logging，<code class="fe lk ll lm ln b">transport</code>包也建立了流通道。在HTTP2可用之前，它使用SPDY和WebSocket协议。</p><p id="4ac1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">plugin</code> package为Openstack、GCP和Azure等云提供商提供授权插件。</p><p id="6da5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">scale</code>软件包提供了一个多态scale客户端，能够获取和更新实现“scale”子资源的任何资源的scale，只要该子资源运行在可转换为autoscaling.Scale的厌恶Scale上。注意在Kubernetes v1.10之前，它不支持缩放CRD[2]。</p><p id="e440" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">util</code>包提供了工作队列、缓冲区等方便的实用工具。</p><p id="26ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">tool/cache</code>软件包有许多有用的功能，如共享转换器、反射器、存储和索引器。它提供了一个客户端查询和缓存机制，减少了向服务器请求的数量并保持对事件的跟踪。我将在这个包中详细介绍实用程序提供的工作流，因为它在编写自定义控制器时会做一些准备工作。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/d2f9204d07113787cc4b455f674655f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iI8uFsPRBY5m_g_WW4huMQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">客户端-go/工具/缓存/和自定义控制器流</figcaption></figure><p id="2aa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上图所示，动作有两个主要部分。一个发生在<code class="fe lk ll lm ln b">SharedIndexInformer</code>中，另一个发生在自定义控制器中。</p><p id="2abf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 1。</strong> Reflector对Kubernetes API服务器执行对象(如名称空间、pod等)列表和观察查询。三个事件类型<strong class="kf ir">被添加，更新</strong>和<strong class="kf ir">被删除</strong>与相关对象一起被记录。然后它们被传递到DeltaFIFO。注意:默认情况下，只能检索过去五分钟内发生的事件。</p><blockquote class="lt lu lv"><p id="b484" class="kd ke lw kf b kg kh ki kj kk kl km kn lx kp kq kr ly kt ku kv lz kx ky kz la ij bi translated">给定的Kubernetes服务器将只在有限的时间内保存历史变更列表。默认情况下，使用etcd3的集群会保留最近5分钟内的更改。当所请求的监视操作由于该资源的历史版本不可用而失败时，客户端必须通过识别状态代码<code class="fe lk ll lm ln b"><strong class="kf ir">410 Gone</strong></code>，清除其本地缓存，执行列表操作，并从新列表操作返回的<code class="fe lk ll lm ln b"><strong class="kf ir">resourceVersion</strong></code>开始监视来处理这种情况。大多数客户端库为这种逻辑提供了某种形式的标准工具。(在Go中，这被称为<code class="fe lk ll lm ln b"><strong class="kf ir">Reflector</strong></code>，位于<code class="fe lk ll lm ln b"><strong class="kf ir">k8s.io/client-go/cache</strong></code>包中。)[3]</p></blockquote><p id="0656" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2。</strong> DeltaFIFO接收与观察事件相对应的事件和对象，然后将其转换为Delta对象。这些增量对象被附加到一个队列中等待处理。对于Deleted，它将检查它是否已经存在于线程安全存储中，这样它就可以避免在某个东西不存在时排队等待删除操作。</p><p id="6cc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3。</strong>高速缓存控制器(不要与定制控制器混淆)调用Pop()方法使DeltaFIFO队列出队。Delta对象被传递到SharedIndexInformer的HandleDelta()方法进行进一步处理。</p><p id="7c8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 4。</strong>根据Delta对象的动作(事件)类型，对象首先通过HandleDeltas方法中索引器的方法保存到线程安全存储中。然后，它通过sharedProcessor在SharedIndexInformer中的distribute()方法将这些对象发送到事件处理程序，这些事件处理程序已由自定义控制器通过SharedInformer的方法(如addeventhandlerwithresyngperiod())注册。</p><p id="401e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 5。</strong>已注册的事件处理程序将对象转换为“名称空间/名称”格式的关键字字符串，如果没有名称空间，则通过MetaNamespaceKeyFunc()转换为添加和更新事件，deletionhandlingmetanamespace key func()转换为删除事件。然后，这些键被添加到自定义控制器的工作队列中。工作队列的类型可以在<code class="fe lk ll lm ln b">util/workqueue</code>中找到。</p><p id="11e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 6。</strong>自定义控制器通过调用自定义处理程序从工作队列中弹出键进行处理。自定义处理程序将调用索引器的GetByKey()从线程安全存储中检索对象。自定义处理程序是您的业务逻辑所在。</p><p id="9ea5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">使用工作队列的简单定制控制器示例</strong></p><p id="6845" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个在默认名称空间中监视窗格的自定义控制器的示例。工作队列类型为RateLimitQueue。在下面的例子中，控制器产生一个工人。调用controller时，您可以更改工作线程的数量。运行()。</p><p id="4e1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，下面的示例使用的是IndexInformer，它只能有一组处理程序来订阅事件。建议改用SharedIndexInformer。不同之处在于ShareIndexInformer提供了像addeventhandlerwithresyncpregion()这样的方法，允许您添加多组处理程序，因此一个事件请求可以同时分发到不同的处理程序，从而减少API请求的数量。</p><p id="7fa0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想连接你的CRD，你可以按照<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/how-to-generate-client-codes-for-kubernetes-custom-resource-definitions-crd-b4b9907769ba">这个指令</a>为你的CRD资源生成clientset，informer等。然后，您可以在自定义控制器中使用生成的SharedInformer。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">资料来源:k8s.io/client-go/examples/workqueue/main.go</figcaption></figure><p id="69e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">参考</strong></p><p id="7349" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[1]<a class="ae kc" href="https://github.com/kubernetes/client-go/tree/release-10.0" rel="noopener ugc nofollow" target="_blank">client-go v 10.0(github)</a></p><p id="2997" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2] <a class="ae kc" href="https://kubernetes.io/blog/2018/01/introducing-client-go-version-6/" rel="noopener ugc nofollow" target="_blank">推出client-go版本6 </a></p><p id="affd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[3] <a class="ae kc" href="https://kubernetes.io/docs/reference/using-api/api-concepts/" rel="noopener ugc nofollow" target="_blank"> Kubernetes API概念</a></p><p id="e41b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[4] <a class="ae kc" href="https://medium.com/@cloudark/kubernetes-custom-controllers-b6c7d0668fdf" rel="noopener">编写Kubernetes自定义控制器</a></p><p id="2165" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[5] <a class="ae kc" href="https://engineering.bitnami.com/articles/a-deep-dive-into-kubernetes-controllers.html" rel="noopener ugc nofollow" target="_blank">深入探究Kubernetes控制器</a></p><p id="0e96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lw">免责声明:此处表达的观点仅是作者以个人身份发表的观点，绝不代表任何组织的观点。</em></p></div></div>    
</body>
</html>