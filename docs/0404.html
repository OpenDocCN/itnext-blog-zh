<html>
<head>
<title>Recreating the Netflix’s Dark opening effect in Html &amp; Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Html和Javascript再现网飞的黑暗开场效果</h1>
<blockquote>原文：<a href="https://itnext.io/recreating-the-netflixs-dark-opening-effect-in-html-javascript-4f06e17b88dd?source=collection_archive---------6-----------------------#2018-03-05">https://itnext.io/recreating-the-netflixs-dark-opening-effect-in-html-javascript-4f06e17b88dd?source=collection_archive---------6-----------------------#2018-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="700e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一步一步的指导你如何用图像和普通的Javascript在画布上重建镜像效果</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/6a235c36f446cca8170a2338f87a5098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbl9t7TsBz5RAVV-SopjfQ.png"/></div></div></figure><p id="1fb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些不了解《黑暗》的人来说，这是一部来自德国温登镇的网飞的精彩而有趣的电视剧。开场效果相当简单却引人注目。在这个片段中，我试图用一个由鼠标移动产生动画的图像来重新创建这个外观。</p><p id="a940" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个到<a class="ae kx" href="http://nikpundik.github.io/dark/" rel="noopener ugc nofollow" target="_blank">演示</a>的快速链接。</p><p id="bc3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">html只是一块画布和一个固定位置的标题。画布被设置为用这个css填充窗口:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="bf5b" class="ld le iq kz b gy lf lg l lh li">* {<br/>  padding: 0;<br/>  margin: 0;<br/>}<br/>html,<br/>body {<br/>  height: 100%;<br/>}<br/>canvas {<br/>  display:block;<br/>}</span></pre><p id="8db0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以跳到脚本部分。首先，我们必须确保画布尺寸适合窗口，即使发生了尺寸调整。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="8f2e" class="ld le iq kz b gy lf lg l lh li">var canvas;<br/>var ctx;<br/>var img;</span><span id="aa5e" class="ld le iq kz b gy lj lg l lh li">function start() {<br/>  canvas = document.getElementById('dark');<br/>  ctx = canvas.getContext('2d');<br/>  load();<br/>}</span><span id="7fb2" class="ld le iq kz b gy lj lg l lh li">function load() {<br/>  img = new Image();<br/>  img.addEventListener('load', init, false);<br/>  img.src = 'dark.jpg';<br/>}</span><span id="c65e" class="ld le iq kz b gy lj lg l lh li">function init() {<br/>  window.addEventListener('resize', resize, false);<br/>  resize();<br/>}</span><span id="d771" class="ld le iq kz b gy lj lg l lh li">function resize() {<br/>  canvas.width = window.innerWidth;<br/>  canvas.height = window.innerHeight;<br/>  draw(); <br/>}</span></pre><p id="50ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数<code class="fe lk ll lm kz b">start</code>在body <code class="fe lk ll lm kz b">onload</code>事件中被调用，它简单地获取我们对画布和上下文的引用，然后开始加载图像(所以我们可以假设我们的资产总是准备好的)。当加载图像时，我们在resize事件上添加一个侦听器。当调整大小时，我们更新画布尺寸并重新绘制。</p><p id="38f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lk ll lm kz b">draw</code>功能相当简单:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="9ab2" class="ld le iq kz b gy lf lg l lh li">function draw() {<br/>  var w = canvas.width / 3;<br/>  ctx.clearRect(0,0, canvas.width, canvas.height);<br/>  drawImage(false, 0, 0, w, canvas.height);<br/>  drawImage(true, w, 0, w, canvas.height);<br/>  drawImage(false, w*2, 0, w, canvas.height);<br/>}</span></pre><p id="d959" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们只是将画布分成3部分，并使用<code class="fe lk ll lm kz b">drawImage</code>函数在每一部分中绘制我们的图像。</p><p id="c192" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有的数学计算都发生在<code class="fe lk ll lm kz b">drawImage</code>函数中。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="4c1f" class="ld le iq kz b gy lf lg l lh li">function drawImage(flip, x, y, w, h) {<br/>  ctx.save();</span><span id="d820" class="ld le iq kz b gy lj lg l lh li">  var hW = w / 2;<br/>  var hH = h / 2;<br/>  var <!-- -->sourceRect<!-- --> = getSourceRect(w, h);<br/> <br/>  ctx.translate(x, y);<br/>  ctx.translate(hW, hH);<br/>  ctx.scale(flip ? -1 : 1, 1);</span><span id="7b8a" class="ld le iq kz b gy lj lg l lh li">  ctx.drawImage(<br/>    img,<br/>    <!-- -->sourceRect<!-- -->.x,<br/>    <!-- -->sourceRect<!-- -->.y,<br/>    <!-- -->sourceRect<!-- -->.w,<br/>    <!-- -->sourceRect<!-- -->.h,<br/>    -hW,<br/>    -hH,<br/>    w,<br/>    h,<br/>  );</span><span id="ed3e" class="ld le iq kz b gy lj lg l lh li">  ctx.restore();<br/>}</span></pre><p id="76c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在输入细节之前，理解<code class="fe lk ll lm kz b">ctx.drawImage</code>功能的工作原理很重要。<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" rel="noopener ugc nofollow" target="_blank">这里是完整的解释和sintax </a>。简而言之，它可以从源矩形获取图像的一部分，并将其绘制在画布上的目标矩形上。</p><p id="346a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的目标是在画布的特定区域呈现我们的源图像(从<code class="fe lk ll lm kz b">x, y, w, h</code>中识别)。但是也应该可以在绘制之前翻转它。为了实现镜像效果，我们必须用负值来缩放我们的图像。然而，这并不简单，因为我们必须将我们的转换应用到上下文中。</p><p id="ad8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，首先，我们用<code class="fe lk ll lm kz b">ctx.save()</code>拍摄当前转换矩阵的快照，并在结束时用<code class="fe lk ll lm kz b">ctx.restore()</code>恢复它。</p><p id="0ec8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一次平移<code class="fe lk ll lm kz b">ctx.translate(x, y)</code>会将我们的图像移动到正确的位置。在应用缩放之前，我们需要用<code class="fe lk ll lm kz b">ctx.translate(hW, hH)</code>将旋转的中心移动到图像的中心。然后用<code class="fe lk ll lm kz b">ctx.scale(flip ? -1 : 1, 1)</code>根据参数进行翻转。为了回到我们的<code class="fe lk ll lm kz b">x,y</code>位置，我们将目的地设置为<code class="fe lk ll lm kz b">-hW</code>和<code class="fe lk ll lm kz b">-hH</code>。<code class="fe lk ll lm kz b">sourceRect</code>只是一个实用函数，用于在图像坐标上获得满足目标纵横比的最大矩形，这样我们的图像就不会显得被拉伸。这是:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="4a89" class="ld le iq kz b gy lf lg l lh li">function getSourceRect(srcW, srcH) {<br/>  var destW = img.naturalWidth;<br/>  var destH = img.naturalHeight;</span><span id="ea39" class="ld le iq kz b gy lj lg l lh li">  var scale = Math.min(destW / srcW, destH / srcH);</span><span id="2803" class="ld le iq kz b gy lj lg l lh li">  var scaledSrcW = srcW * scale;<br/>  var scaledSrcH = srcH * scale;</span><span id="e3fa" class="ld le iq kz b gy lj lg l lh li">  var startX = (destW - scaledSrcW) * 0.5;<br/>  var startY = (destH - scaledSrcH) * 0.5;<br/>  return {<br/>    x: startX,<br/>    y: startY,<br/>    w: scaledSrcW,<br/>    h: scaledSrcH,<br/>  };<br/>}</span></pre><p id="fa61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们应该已经在画布上绘制了三个图像，第二个图像已经翻转。现在让我们看看当鼠标移动时，我们如何将这些图像动画化。</p><p id="ef97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们添加了两个变量，<code class="fe lk ll lm kz b">mouseX</code>将保持鼠标的x位置，<code class="fe lk ll lm kz b">weight</code>将告诉我们希望图像移动多少像素。</p><p id="0bd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe lk ll lm kz b">init</code>函数中，我们添加了一个监听器:</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="707a" class="ld le iq kz b gy lf lg l lh li">function init() {<br/>  window.addEventListener('resize', resize, false);<br/>  canvas.addEventListener('mousemove', move);<br/>  resize();<br/>}</span></pre><p id="4467" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在每次鼠标移动事件中，我们调用<code class="fe lk ll lm kz b">move</code>函数，该函数简单地将x位置存储为百分比并重新绘制画布。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="4f26" class="ld le iq kz b gy lf lg l lh li">function move(e) {<br/>  mouseX = (e.clientX / canvas.width);<br/>  draw();<br/>}</span></pre><p id="ffb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了范围从0到1的<code class="fe lk ll lm kz b">mouseX</code>值，我们想根据它移动图像。这个想法是将我们传递给<code class="fe lk ll lm kz b">drawImage</code>的源位置进行移动。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="db58" class="ld le iq kz b gy lf lg l lh li">ctx.drawImage(<br/>  img,<br/>  sourceRect.x - (mouseX * weight),<br/>  sourceRect.y,<br/>  sourceRect.w,<br/>  sourceRect.h,<br/>  -hW,<br/>  -hH,<br/>  w,<br/>  h,<br/>);</span></pre><p id="5da8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们的图像随着鼠标移动，但是有一个问题。事实上，移动光源是不够的，因为我们在图像之外获得了未定义的像素(这就是我们看到白色像素的原因)。这里简单的修正是取一个比当前矩形小的源矩形，这样我们就可以安全地加上或减去那个<code class="fe lk ll lm kz b">(mouseX * weight)</code>值。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="2673" class="ld le iq kz b gy lf lg l lh li">var scaleFactor = weight / img.naturalWidth;</span><span id="0f09" class="ld le iq kz b gy lj lg l lh li">var stepX = img.naturalWidth * scaleFactor;<br/>var stepY = img.naturalHeight * scaleFactor;</span><span id="3ee2" class="ld le iq kz b gy lj lg l lh li">ctx.drawImage(<br/>  img,<br/>  sourceRect.x + stepX - (mouseX * weight),<br/>  sourceRect.y + stepY,<br/>  sourceRect.w - stepX,<br/>  sourceRect.h - stepY,<br/>  -hW,<br/>  -hH,<br/>  w,<br/>  h,<br/>);</span></pre><p id="60b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经做到了。鼠标动画只是一个选项，它可以像这里的<a class="ae kx" href="http://nikpundik.github.io/dark/stranger.html" rel="noopener ugc nofollow" target="_blank">一样连续循环动画</a>或者由一个动作触发，有很多种可能性！</p><p id="2037" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是Github上的完整代码</p><p id="6565" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是<a class="ae kx" href="http://nikpundik.github.io/dark" rel="noopener ugc nofollow" target="_blank">演示</a>的链接</p><p id="35c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在推特上连线吧！</p></div></div>    
</body>
</html>