<html>
<head>
<title>Securely Access AWS Services from Google Kubernetes Engine (GKE)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Google Kubernetes引擎(GKE)安全地访问AWS服务</h1>
<blockquote>原文：<a href="https://itnext.io/securely-access-aws-from-gke-dba1c6dbccba?source=collection_archive---------4-----------------------#2020-02-17">https://itnext.io/securely-access-aws-from-gke-dba1c6dbccba?source=collection_archive---------4-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0317" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行在谷歌Kubernetes引擎(<a class="ae ko" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> GKE </a>)上的应用程序需要访问亚马逊网络服务(<a class="ae ko" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">AWS</a>API，这种情况并不少见。任何应用都有需求。也许它需要在亚马逊红移上运行分析查询，访问亚马逊S3桶中存储的数据，用亚马逊Polly将文本转换为语音或使用任何其他AWS服务。这种多云场景现在很常见，因为公司正在与多家云提供商合作。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/b472ad719af040bf9855b63dd4be5a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXVYzhMtvz4ujcq1YaDd7g.jpeg"/></div></div></figure><p id="60cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">跨云访问带来了新的挑战；如何管理从一个云提供商访问另一个云提供商的服务所需的云凭据。天真的方法，分发和保存云提供商的秘密不是最安全的方法；向需要访问AWS服务的每个服务分发长期凭证是一项管理挑战，也是一个潜在的安全风险。</p><h2 id="a241" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">当前解决方案</h2><p id="9278" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">每种云都提供了自己独特的解决方案来应对这一挑战，如果您只与一家云提供商合作，这就足够了。</p><p id="4ca2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谷歌云宣布了一个<a class="ae ko" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity" rel="noopener ugc nofollow" target="_blank">工作负载身份</a>，这是GKE应用认证和消费其他谷歌云服务的推荐方式。工作负载身份通过绑定Kubernetes服务帐户和云IAM服务帐户来工作，因此您可以使用Kubernetes-native概念来定义哪些工作负载以哪些身份运行，并允许您的工作负载自动访问其他Google云服务，而无需管理Kubernetes机密或IAM服务帐户密钥！阅读DoiT <a class="ae ko" href="https://blog.doit-intl.com/kubernetes-gke-workload-identity-75fa197ff6bf" rel="noopener ugc nofollow" target="_blank"> Kubernetes GKE工作量身份</a>博客文章。</p><p id="d6b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Amazon Web Services支持类似的功能，具有服务帐户的<a class="ae ko" href="https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html" rel="noopener ugc nofollow" target="_blank"> IAM角色</a>特性。通过Amazon EKS集群上服务帐户的IAM角色，您可以将IAM角色与Kubernetes服务帐户相关联。然后，该服务帐户可以向使用该服务帐户的任何pod中的容器提供AWS权限。有了这个特性，您不再需要为worker node IAM角色提供扩展权限，以便该节点上的pod可以调用AWS APIs。</p><p id="0d3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果您在GKE集群上运行应用程序工作负载，并且希望在不牺牲安全性的情况下访问AWS服务，该怎么办呢？</p><h2 id="cec9" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">用例定义</h2><p id="09f3" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">让我们假设您已经拥有一个AWS帐户和一个GKE集群，并且您的公司已经决定在GKE集群上运行一个基于微服务的应用程序，但仍然希望使用AWS帐户中的资源(亚马逊S3和SNS服务)来与部署在AWS上的其他系统集成。</p><p id="87f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，<em class="lz">编排作业</em>(部署为Kubernetes作业)正在GKE集群中运行，需要将数据文件上传到S3桶中，并向Amazon SNS主题发送消息。等效的命令行可能是:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="d338" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常简单的例子。为了让这些命令成功，<em class="lz">编排作业</em>必须有可用的AWS凭证，并且这些凭证必须能够进行相关的API调用。</p><h2 id="3847" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">天真(且不安全)的方法:IAM长期凭证</h2><p id="94d5" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">为一些AWS IAM用户导出AWS访问密钥和秘密密钥，并将AWS凭证作为凭证文件或环境变量注入到<em class="lz">编排作业</em>中。可能不是直接这么做，而是使用受<a class="ae ko" href="https://kubernetes.io/docs/concepts/configuration/secret/#clients-that-use-the-secret-api" rel="noopener ugc nofollow" target="_blank"> RBAC授权策略</a>保护的<a class="ae ko" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank"> Kubernetes Secrets </a>资源。</p><p id="cb6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的风险是这些凭证永远不会过期。它们必须以某种方式从AWS环境转移到GCP环境，在大多数情况下，人们希望将它们存储在某个地方，以便在以后需要时可以用来重新创建<em class="lz">编排作业</em>。</p><p id="0ffc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当使用长期AWS凭证时，有多种方式可以危及您的AWS帐户的安全；无意中将AWS凭证提交到GitHub存储库中，将它们保存在Wiki系统中，为不同的服务和应用程序重用凭证，允许不受限制的访问等等<a class="ae ko" href="https://rhinosecuritylabs.com/aws/aws-iam-credentials-get-compromised/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1788" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然可以为颁发的IAM用户凭证设计一个适当的凭证管理解决方案，但是如果您从一开始就不创建这些长期凭证，就不需要这样做。</p><h2 id="2629" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">提议的方法</h2><p id="c869" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">基本想法是将<a class="ae ko" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html" rel="noopener ugc nofollow" target="_blank"> AWS IAM角色</a>分配给GKE Pod，类似于<strong class="js iu">工作负载身份</strong>和<strong class="js iu">服务帐户</strong>云特定功能的EKS IAM角色。</p><p id="6a64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，AWS允许为OpenID Connect Federation<a class="ae ko" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank">OIDC</a>身份提供者创建IAM角色，而不是IAM用户。另一方面，Google实现了OIDC提供者，并通过<strong class="js iu">工作负载身份</strong>特性将其与GKE紧密集成。向GKE pod提供有效的OIDC令牌，在链接到谷歌云服务帐户的Kubernetes服务帐户下运行。所有这些对于实现GKE到AWS的安全访问都可能派上用场。</p><h2 id="7ba3" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">将OIDC访问令牌交换为ID令牌</h2><p id="2b07" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">还缺一样东西，是完成拼图所必需的。通过正确设置<strong class="js iu">工作流身份</strong>，GKE·波德获得了一个允许访问谷歌云服务的OIDC <strong class="js iu">访问令牌</strong>。为了从AWS安全令牌服务(<a class="ae ko" href="https://docs.aws.amazon.com/STS/latest/APIReference/Welcome.html" rel="noopener ugc nofollow" target="_blank"> STS </a>)获得临时AWS凭证，您需要提供一个有效的OIDC <strong class="js iu"> ID令牌</strong>。</p><p id="be55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正确设置以下环境变量后，AWS SDK(和<code class="fe mc md me mf b">aws-cli</code>工具)将自动向STS服务请求临时AWS凭证:</p><ul class=""><li id="740b" class="mg mh it js b jt ju jx jy kb mi kf mj kj mk kn ml mm mn mo bi translated"><code class="fe mc md me mf b">AWS_WEB_IDENTITY_TOKEN_FILE</code>-web身份令牌文件(OIDC ID令牌)的路径</li><li id="67ee" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">AWS_ROLE_ARN</code>-<a class="ae ko" href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html" rel="noopener ugc nofollow" target="_blank">ARN</a>的角色由吊舱容器来承担</li><li id="a82c" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">AWS_ROLE_SESSION_NAME</code> -应用于此承担角色会话的名称</li></ul><p id="fd0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这听起来可能有点复杂，但是我将提供一个分步指南和支持开源项目<a class="ae ko" href="https://github.com/doitintl/gtoken" rel="noopener ugc nofollow" target="_blank"> dointl/gtoken </a>来简化设置。</p><h2 id="1ad8" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated"><code class="fe mc md me mf b">gtoken-webhook</code> Kubernetes变异录取网钩</h2><p id="1010" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated"><code class="fe mc md me mf b">gtoken-webhook</code>是一个Kubernetes变异准入webhook，它可以变异任何在特别注释的Kubernetes服务帐户下运行的K8s Pod(详见下文)。</p><h2 id="7e4b" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">gtoken-webhook变异流</h2><p id="e83d" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated"><code class="fe mc md me mf b">gtoken-webhook</code>将一个<code class="fe mc md me mf b">gtoken</code> <code class="fe mc md me mf b">initContainer</code>注入一个目标Pod和一个额外的<code class="fe mc md me mf b">gtoken</code> sidekick容器(在到期前刷新一个OIDC ID令牌)，挂载令牌卷并注入三个特定于AWS的环境变量。<code class="fe mc md me mf b">gtoken</code>容器生成一个有效的GCP OIDC ID令牌，并将其写入令牌卷。它还注入所需的AWS环境变量。</p><p id="abec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AWS SDK将自动代表您对AWS STS进行相应的<code class="fe mc md me mf b">AssumeRoleWithWebIdentity</code>调用。它将处理内存缓存，并根据需要刷新凭证。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mu"><img src="../Images/19f266842b278c6c6e862d4277220113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UsxYlt69dWXDdXZI50TEg.png"/></div></div></figure><h2 id="431c" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">《配置流程指南》</h2><h2 id="b3b0" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">展开<code class="fe mc md me mf b">gtoken-webhook</code></h2><ol class=""><li id="0c79" class="mg mh it js b jt lu jx lv kb mv kf mw kj mx kn my mm mn mo bi translated">为了部署<code class="fe mc md me mf b">gtoken-webhook</code>服务器，我们需要在我们的Kubernetes集群中创建一个webhook服务和一个部署。这非常简单，除了一件事，那就是服务器的TLS配置。如果您愿意检查一下<a class="ae ko" href="https://github.com/doitintl/gtoken/blob/master/deployment/deployment.yaml" rel="noopener ugc nofollow" target="_blank"> deployment.yaml </a>文件，您会发现证书和相应的私钥文件是从命令行参数中读取的，并且这些文件的路径来自指向Kubernetes秘密的卷挂载:</li></ol><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="bf97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要记住的最重要的事情是稍后在webhook配置中设置相应的CA证书，这样<code class="fe mc md me mf b">apiserver</code>就会知道它应该被接受。现在，我们将重用最初由Istio团队编写的脚本来生成证书签名请求。然后，我们将请求发送到Kubernetes API，获取证书，并根据结果创建所需的秘密。</p><p id="31cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，运行<a class="ae ko" href="https://github.com/doitintl/gtoken/blob/master/deployment/webhook-create-signed-cert.sh" rel="noopener ugc nofollow" target="_blank">web hook-create-signed-cert . sh</a>脚本，检查持有证书和密钥的秘密是否已经创建:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="803d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦创建了秘密，我们就可以创建部署和服务。这些是标准的Kubernetes部署和服务资源。到目前为止，我们只制作了一个HTTP服务器，它通过端口<code class="fe mc md me mf b">443</code>上的服务接受请求:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="86b3" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">配置变异准入网络挂钩</h2><p id="ac82" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">现在我们的webhook服务器正在运行，它可以接受来自<code class="fe mc md me mf b">apiserver</code>的请求。但是，我们应该首先在Kubernetes中创建一些配置资源。让我们从验证webhook开始，稍后我们将配置变异的webhook。如果您看一下<a class="ae ko" href="https://github.com/doitintl/gtoken/blob/master/deployment/mutatingwebhook.yaml" rel="noopener ugc nofollow" target="_blank"> webhook配置</a>，您会注意到它包含一个用于<code class="fe mc md me mf b">CA_BUNDLE</code>的占位符:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="26c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一个<a class="ae ko" href="https://github.com/doitintl/gtoken/blob/master/deployment/webhook-patch-ca-bundle.sh" rel="noopener ugc nofollow" target="_blank">小脚本</a>用这个CA替换配置中的CA_BUNDLE占位符。在创建验证webhook配置之前运行以下命令:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="b490" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建变异webhook配置:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="fd53" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">为gtoken-webhook配置RBAC</h2><p id="8f37" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">创建用于<code class="fe mc md me mf b">gtoken-webhook</code>的Kubernetes服务帐户:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="92e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为webhook服务帐户定义RBAC权限:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="8f57" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">流量变量</h2><p id="96f0" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">下面的一些变量应该由用户提供，其他变量将自动生成并在下面的步骤中重用。</p><ul class=""><li id="b747" class="mg mh it js b jt ju jx jy kb mi kf mj kj mk kn ml mm mn mo bi translated"><code class="fe mc md me mf b">PROJECT_ID</code> - GCP项目ID(用户提供)</li><li id="9318" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">CLUSTER_NAME</code> - GKE集群名称(由用户提供)</li><li id="ecb1" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">GSA_NAME</code> -谷歌云服务账户名称(用户提供)</li><li id="a777" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">GSA_ID</code> -谷歌云服务账户唯一ID(由谷歌生成)</li><li id="442b" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">KSA_NAME</code> - Kubernetes服务账户名称(由用户提供)</li><li id="f79d" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">KSA_NAMESPACE</code> - Kubernetes名称空间(由用户提供)</li><li id="b1da" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">AWS_ROLE_NAME</code> - AWS IAM角色名称(由用户提供)</li><li id="3429" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">AWS_POLICY_NAME</code> -分配给IAM角色的AWS IAM策略(由用户提供)</li><li id="d229" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">AWS_ROLE_ARN</code> - AWS IAM角色ARN标识符(由AWS生成)</li></ul><h2 id="8347" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">谷歌云:启用GKE工作负载身份</h2><p id="f05c" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">创建一个启用了<a class="ae ko" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity" rel="noopener ugc nofollow" target="_blank">工作负载标识</a>的新GKE集群:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="734e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者更新现有集群:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="30b6" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">谷歌云:创建一个谷歌云服务账户</h2><p id="baf6" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">创建Google云服务帐户:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5260" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用以下角色更新<code class="fe mc md me mf b">GSA_NAME</code> Google服务帐户:</p><ul class=""><li id="8493" class="mg mh it js b jt ju jx jy kb mi kf mj kj mk kn ml mm mn mo bi translated"><code class="fe mc md me mf b">roles/iam.workloadIdentityUser</code> -模拟GKE工作负载的服务帐户</li><li id="8e41" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><code class="fe mc md me mf b">roles/iam.serviceAccountTokenCreator</code> -模拟服务帐户以创建OAuth2访问令牌、签署blobs或签署JWT令牌</li></ul><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="a05d" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">AWS:与谷歌OIDC联盟创建AWS IAM角色</h2><p id="25e2" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">为谷歌OIDC提供商准备角色信任政策文档:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="f1c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Google Web身份创建AWS IAM角色:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="44ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">分配AWS角色所需的策略:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="f1cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获取要在K8s SA注释中使用的AWS角色ARN:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="c001" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">GKE:创建一个Kubernetes服务帐户</h2><p id="fa50" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">创建K8s命名空间:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="3607" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建K8s服务帐户:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="1a9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用GKE工作负载标识注释K8s服务帐户(GCP服务帐户电子邮件):</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="cbca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用AWS角色ARN注释K8s服务帐户:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="ed8b" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">运行演示</h2><p id="0c66" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">使用K8s <code class="fe mc md me mf b">${KSA_NAME}`</code>服务帐户运行新的K8s Pod:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="e3d3" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">外部参考</h2><ul class=""><li id="ba89" class="mg mh it js b jt lu jx lv kb mv kf mw kj mx kn ml mm mn mo bi translated"><strong class="js iu"> GitHub: </strong>使用<a class="ae ko" href="https://github.com/doitintl/gtoken" rel="noopener ugc nofollow" target="_blank"> doitintl/gtoken </a>从GKE集群安全地访问AWS服务</li><li id="95c4" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><strong class="js iu"> AWS文档:</strong> <a class="ae ko" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-idp_oidc.html" rel="noopener ugc nofollow" target="_blank">为Web Identity或OpenID Connect联盟创建角色</a></li><li id="5605" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><strong class="js iu">博客:</strong> Kubernetes GKE工作量身份<a class="ae ko" href="https://blog.doit-intl.com/kubernetes-gke-workload-identity-75fa197ff6bf" rel="noopener ugc nofollow" target="_blank">链接</a></li><li id="4207" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><strong class="js iu"> AWS博客:</strong>介绍服务帐户的细粒度IAM角色<a class="ae ko" href="https://aws.amazon.com/blogs/opensource/introducing-fine-grained-iam-roles-service-accounts/" rel="noopener ugc nofollow" target="_blank">链接</a></li><li id="baff" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><strong class="js iu"> GitHub: </strong> AWS Auth使用<a class="ae ko" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc.html" rel="noopener ugc nofollow" target="_blank"> Web Identity Federation </a>来自Google Cloud<a class="ae ko" href="https://github.com/shrikant0013/gcp-aws-webidentityfederation" rel="noopener ugc nofollow" target="_blank">shrikant 0013/GCP-AWS-Web Identity Federation</a>GitHub项目</li><li id="02d9" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated"><strong class="js iu">博客:</strong>使用GCP服务帐户访问AWS IAM角色<a class="ae ko" href="https://cevo.com.au/post/2019-07-29-using-gcp-service-accounts-to-access-aws/" rel="noopener ugc nofollow" target="_blank">科林·帕尼塞特的博客文章</a></li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="1b4c" class="ng lc it bd ld nh ni nj lg nk nl nm lj nn no np lm nq nr ns lp nt nu nv ls nw bi translated">摘要</h1><p id="959f" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">我希望，这篇文章对你有用。我期待您的评论和任何问题。</p><p id="38a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想要更多的故事？在<a class="ae ko" href="http://blog.doit-intl.com/" rel="noopener ugc nofollow" target="_blank">媒体</a>上查看我们的博客，或者<a class="ae ko" href="https://twitter.com/alexeiled" rel="noopener ugc nofollow" target="_blank">在Twitter上关注阿列克谢</a>。</p></div></div>    
</body>
</html>