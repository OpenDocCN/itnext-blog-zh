<html>
<head>
<title>I’m making an offline first WordPress PWA, part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我正在做一个离线的第一个WordPress PWA，第4部分</h1>
<blockquote>原文：<a href="https://itnext.io/im-making-an-offline-first-wordpress-pwa-part-4-be2d06e6ff28?source=collection_archive---------2-----------------------#2018-07-30">https://itnext.io/im-making-an-offline-first-wordpress-pwa-part-4-be2d06e6ff28?source=collection_archive---------2-----------------------#2018-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f578" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">应用程序外壳模型</h2></div><p id="d514" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该系列由以下部分组成:</p><blockquote class="lb lc ld"><p id="4a13" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-1-6ae90ea672a4">第一部分——HTTPS</a></p><p id="ae64" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-2-b313659bfc9c">第2部分— Manifest.json </a></p><p id="f9c8" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-3-1ddf61891121">第3部分—带工具箱的维修工人</a></p><p id="685c" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-4-be2d06e6ff28">第4部分— App外壳模型</a>(此部分)</p><p id="7664" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-5-e3293faefb88">第5部分—离线优先</a></p><p id="0467" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-6-1f4beea6e641">第6部分——单页应用</a></p><p id="c655" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-7-5d1ee68ec6bd">第7部分—优化</a></p></blockquote><p id="be2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最后一部分中，我使用<a class="ae li" href="https://developers.google.com/web/tools/workbox/" rel="noopener ugc nofollow" target="_blank">工具箱</a>创建了一个服务工人。这是它在这个时间点上的样子:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="7add" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它做两件事:</p><ul class=""><li id="4c87" class="lq lr iq kh b ki kj kl km ko ls ks lt kw lu la lv lw lx ly bi translated">缓存目录<code class="fe lz ma mb mc b">wp-content/themes/wp-pwa/assets/</code>中的所有文件</li><li id="10a9" class="lq lr iq kh b ki md kl me ko mf ks mg kw mh la lv lw lx ly bi translated">缓存首页，即使用户离线或连接不稳定也能加载博客。</li></ul><p id="591f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在两种情况下都使用了<code class="fe lz ma mb mc b">cacheFirst()</code>策略，这意味着文件将总是从缓存中提供。如果文件不在缓存中，它当然会像往常一样从服务器下载，然后存储在缓存中。</p><blockquote class="mi"><p id="6be6" class="mj mk iq bd ml mm mn mo mp mq mr la dk translated">这意味着用户使用的带宽更少，由于网络请求量最小，加载博客的速度非常快。</p></blockquote><p id="7e35" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">这种策略的缺点是，无论如何，文件总是由缓存而不是服务器提供。这意味着，如果在服务器上更新CSS文件，用户仍将从缓存中获得旧文件。</p><p id="8c59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这当然可以通过添加一个版本号作为查询字符串来解决:<code class="fe lz ma mb mc b">style.css?version=1.1</code>浏览器会将它视为一个新文件，下载并存储在缓存中。</p><p id="1111" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是HTML文件本身当前存储在缓存中。如果HTML没有更新，<code class="fe lz ma mb mc b">href</code>不会从<code class="fe lz ma mb mc b">style.css?version=1.0</code>更新到<code class="fe lz ma mb mc b">style.css?version=1.1</code></p><p id="bbec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但最大的问题是博客本身不会更新。如果存储在缓存中的HTML没有更新，用户将看不到任何新的博客文章。</p><h2 id="0e39" class="mx my iq bd mz na nb dn nc nd ne dp nf ko ng nh ni ks nj nk nl kw nm nn no np bi translated">新策略？</h2><p id="5ef4" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">这种策略似乎不可持续，至少在博客的HTML页面上是如此。对我来说，<a class="ae li" href="https://developers.google.com/web/fundamentals/architecture/app-shell" rel="noopener ugc nofollow" target="_blank">应用外壳模型</a>可能是一种选择。<br/>简而言之，通过使用应用程序外壳模型，我可以在缓存中保存一个博客的“空”版本，一个没有内容的外壳。外壳将使用JavaScript在客户端填充内容。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nv"><img src="../Images/aa401019d3aa516c5fd9ec86e64d286b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8PMvxJxe7SyWhCCpCzSiA.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">App Shell模型的可视化。图片来自谷歌</figcaption></figure><p id="43eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，无论我多么喜欢JavaScript，我都不愿意过多依赖客户端渲染。当然，没有JavaScript，脸书或YouTube就无法运行，但这是一个简单的博客，不是那种网络应用。博客应该或多或少地在没有CSS和JavaScript的情况下工作！</p><blockquote class="mi"><p id="de62" class="mj mk iq bd ml mm mn mo mp mq mr la dk translated">另一方面，PWA更宽容一些，因为您不必等待脚本加载。这意味着客户端渲染速度更快。</p></blockquote><p id="416b" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">但是记住并非所有的浏览器都支持服务人员还是很重要的。仅仅因为你做了PWA并不意味着每个人都会体验到PWA的好处。</p><h2 id="1fa9" class="mx my iq bd mz na nb dn nc nd ne dp nf ko ng nh ni ks nj nk nl kw nm nn no np bi translated">App外壳模型和Vue.js</h2><p id="db4e" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">但是我不应该不先测试就拒绝任何东西。使用像React和Vue这样的JS框架构建整个网站变得越来越普遍，所以我决定给应用程序外壳模型一个机会，并做了以下工作:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="518e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我现在使用WordPress循环来呈现占位符，而不是在服务器端呈现博客文章。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi og"><img src="../Images/6c07490c81b513fd37189a2b7ea75f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4N186QbwnL7fTFPhJzrSg.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">服务器端呈现的脸书样式占位符。</figcaption></figure><p id="0ee4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面代码示例的第4行，您可能已经注意到了<code class="fe lz ma mb mc b">&lt;blog-post /&gt;</code>元素。这是一个<a class="ae li" href="https://vuejs.org/v2/guide/single-file-components.html" rel="noopener ugc nofollow" target="_blank"> Vue组件</a>，当博客文章已经加载了JSON API内建的WordPress中的<code class="fe lz ma mb mc b">fetch()</code>时就会呈现出来。</p><p id="2833" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">app.js</code>现在看起来是这样的:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="9234" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是<code class="fe lz ma mb mc b">blogPost.vue</code>:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="876c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是动画。GIF显示了当博客在Chrome开发者工具中将网速调至慢3G时的样子:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oh"><img src="../Images/e992ffd0658ead5508cffd29debad7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ssRlnSE0MzzQ94Fwdi95xA.gif"/></div></div></figure><p id="3faf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，服务人员此时并不活跃。的。GIF展示了第一次访问的经历。加载时间大约是13秒，但是这个数字在下次访问时会大大提高。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oh"><img src="../Images/909958daaede95bc11049b9c8cbad6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fBWuD6BxsXvWjYU1fVuNTA.gif"/></div></div></figure><p id="fd96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网速仍然被限制为慢3G，但是博客加载只需两秒多一点！如果网速提升到快3G，加载时间提升到1，7秒！</p><p id="f1e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是可能的，因为HTML、CSS、JavaScript和标题图像存储在缓存中。唯一通过网络加载的是来自WordPress API的少量JSON数据。</p><h2 id="1ceb" class="mx my iq bd mz na nb dn nc nd ne dp nf ko ng nh ni ks nj nk nl kw nm nn no np bi translated">离线？</h2><p id="b45f" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">内容将始终是最新的，因为它不再存储在缓存中。这种方法的缺点是博客不能离线工作。它当然会加载，但是带有占位符的外壳永远不会被实际内容替换。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oi"><img src="../Images/53132d68a4cfb3c1b31969f0a1e5727e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zverv3XCpq_ASzhTk7bJEw.png"/></div></div></figure><p id="cc81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的一面是，这可以通过在缓存中保存来自WordPress API的数据来解决。但这是下一部分的任务…</p></div></div>    
</body>
</html>