<html>
<head>
<title>Comparing Crystal’s concurrency with that of Go (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Crystal与Go的并发性比较(下)</h1>
<blockquote>原文：<a href="https://itnext.io/comparing-crystals-concurrency-with-that-of-go-part-ii-89049701b1a5?source=collection_archive---------2-----------------------#2020-08-01">https://itnext.io/comparing-crystals-concurrency-with-that-of-go-part-ii-89049701b1a5?source=collection_archive---------2-----------------------#2020-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5e45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列文章第一部分 的<strong class="js iu"> </strong> <a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/comparing-crystals-concurrency-with-that-of-go-s-part-i-cd45a3388935"> <strong class="js iu">中，我重点从<strong class="js iu">通信顺序进程(CSP) </strong>的角度比较了Crystal和Go的并发性。这第二部分是填补空白，涵盖更传统的<strong class="js iu">共享内存多线程</strong>。</strong></a></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/6680c7f3fcf38800d2c75ced6719a0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HzrvQ9UCByp4-LcE.jpg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">src:<a class="ae ko" href="http://www.embeddedlinux.org.cn/rtconforembsys/5107final/LiB0095.html" rel="noopener ugc nofollow" target="_blank">http://www . embedded Linux . org . cn/rtconforembsys/5107 final/lib 0095 . html</a></figcaption></figure><p id="c8eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lf">我假设您对多线程、临界区、互斥以及确保互斥的锁定/解锁等概念有所了解。</em>T15】</strong></p><p id="cbcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像我以前的文章一样，这篇文章也将重点关注将一些Go程序转换为Crystal，并尝试比较这两者。</p><h1 id="b248" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">共享内存多线程</strong></h1><p id="1183" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">在共享内存多线程中，多个线程可以访问公共的共享变量，为了避免竞争情况并确保互斥，使用了锁。</p><p id="a8da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go使用<a class="ae ko" href="https://golang.org/pkg/sync/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">同步</strong>包</a>来支持这一点</p><ul class=""><li id="0967" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated"><strong class="js iu">互斥</strong> —用于为<strong class="js iu">锁定</strong>和<strong class="js iu">解锁</strong>提供支持。还支持变体<strong class="js iu"> RWMutex </strong></li><li id="36d2" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu"> WaitGroup </strong> —用于等待goroutines的收集完成</li></ul><p id="0af1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Crystal使用<a class="ae ko" href="https://crystal-lang.org/api/0.35.1/Mutex.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">互斥</strong>类</a>来支持这一点。但是，从版本0.35.1开始，没有<strong class="js iu"> WaitGroup </strong>支持。我将提供一个例子，演示如何使用通道来实现类似于<strong class="js iu"> WaitGroup </strong>的东西。</p><p id="244f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看几个例子——</p><h2 id="4a69" class="mx lh it bd li my mz dn lm na nb dp lq kb nc nd lu kf ne nf ly kj ng nh mc ni bi translated">并发性7</h2><p id="7e49" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">这个例子展示了如何使用互斥锁和解锁来确保互斥。</p><p id="9f2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">围棋版本——</strong>【https://tour.golang.org/concurrency/9】T42</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b507" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码被很好地注释了。但是总的来说—</p><ul class=""><li id="cd40" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated"><strong class="js iu">第32行</strong>:创建一个<strong class="js iu">安全计数器</strong>，它有一个<strong class="js iu"> mux </strong>类型的<strong class="js iu"> sync。互斥</strong></li><li id="68b8" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">第17–21行</strong>:使用<strong class="js iu"> sync的<strong class="js iu">锁定</strong>()和<strong class="js iu">解锁</strong>()功能。互斥体</strong>确保对共享变量的顺序访问(在本例中为<strong class="js iu">映射v </strong>)</li></ul><p id="473c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">水晶版— </strong></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1ad9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="220a" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated"><strong class="js iu">第22行</strong>:创建一个<strong class="js iu">安全计数器</strong>，它有一个<strong class="js iu"> mux </strong>类型的<strong class="js iu">互斥</strong></li><li id="f9e9" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">第8–11行</strong>:使用<strong class="js iu"> Mutex </strong>类的<strong class="js iu"> lock </strong>和<strong class="js iu"> unlock </strong>方法来确保对共享变量的顺序访问(在本例中是<strong class="js iu"> Hash v </strong></li></ul><p id="a23c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lf">注意</em> </strong> <em class="lf">:对于这个简单的例子，你不需要确保块(第19–12行/第17–19行)。</em></p><h2 id="d431" class="mx lh it bd li my mz dn lm na nb dp lq kb nc nd lu kf ne nf ly kj ng nh mc ni bi translated">并发性8</h2><p id="d192" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">这个例子摘自伟大的著作<a class="ae ko" href="https://quii.gitbook.io/learn-go-with-tests/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">学习围棋与测试</strong> </a>。这显示了如何使用<strong class="js iu"> WaitGroup </strong>来等待goroutines集合的完成。</p><p id="66b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">围棋版本—</strong><a class="ae ko" href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/sync" rel="noopener ugc nofollow" target="_blank">https://quii . git book . io/learn-Go-with-tests/Go-fundamentals/sync</a></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="80ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="9895" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated"><strong class="js iu">第27行</strong>:使用<strong class="js iu">同步创建一个<strong class="js iu">等待组(</strong>)。WaitGroup) </strong>侍候1000个goroutines。</li><li id="2a40" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">第28行</strong> : <strong class="js iu">添加</strong><strong class="js iu">wait group</strong>的功能用于添加我们要等待1000个goroutines的约束</li><li id="a4d6" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">第39–35行</strong>:创建1000个goroutines。每个增加一个计数器的计数，然后当完成时通过<strong class="js iu"> WaitGroup的Done </strong>方法发出信号，该方法减少等待的goroutines的计数</li><li id="81ad" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">第36行:<strong class="js iu">Wait group</strong>的功能用于阻塞main，直到所有1000个goroutines完成</li></ul><p id="69f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">水晶版</strong> —</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1b12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然Crystal仍然没有一个完整的<strong class="js iu"> WaitGroup </strong>的实现，但是我在<a class="ae ko" href="https://forum.crystal-lang.org/" rel="noopener ugc nofollow" target="_blank"> Crystal论坛</a>—<a class="ae ko" href="https://forum.crystal-lang.org/t/mt-and-mutex/1297/5" rel="noopener ugc nofollow" target="_blank">https://forum.crystal-lang.org/t/mt-and-mutex/1297/5</a>上关注了这个帖子，它建议使用通道来实现上面的替代实现。</p><p id="0669" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="4ca4" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated"><strong class="js iu">第19行</strong>:创建一个<strong class="js iu"> done_channel </strong>，当所有晶体光纤完成其增量操作时发出信号</li><li id="2c53" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">第21–26行</strong>:制造1000根水晶纤维。每次递增计数器时，通过<strong class="js iu"> done_channel </strong>发出信号，表示使用通道的<strong class="js iu"> send </strong>方法完成</li><li id="9caa" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">第28–29行</strong>:等待1000根光纤完成，并使用通道的<strong class="js iu">接收</strong>方法接收所有光纤的信号</li></ul><h1 id="1fdf" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">结束语</strong></h1><p id="74b1" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">在这个由两部分组成的系列文章中，我使用了八个不同的例子来比较Go和Crystal的并发性。在做这个练习时，我的观察是—</p><ul class=""><li id="0450" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated">Go使用<strong class="js iu"> sync </strong>包更完整的实现了<strong class="js iu">共享内存多线程</strong>。在这里，水晶有很多要赶上。</li><li id="3a76" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">与Crystal的文档相比，Go的文档要好得多。在Crystal版本中，一些库函数或类没有关于如何使用它们的适当解释。</li></ul><p id="fb1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管如此，我还是能够克服Crystal中的这些缺点，并且实现了所有八个示例程序。鉴于Crystal仍在大量开发中，我们仍在等待1.0版本，我们需要等待1.0版本的到来。当等待已久的Crystal 1.0发布时，我期待在这个问题上再看一眼。</p><h1 id="37bd" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">参考</h1><ol class=""><li id="ff08" class="mj mk it js b jt me jx mf kb nl kf nm kj nn kn no mp mq mr bi translated"><a class="ae ko" href="https://quii.gitbook.io/learn-go-with-tests/" rel="noopener ugc nofollow" target="_blank">https://quii.gitbook.io/learn-go-with-tests/</a></li><li id="47d1" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn no mp mq mr bi translated"><a class="ae ko" href="https://tour.golang.org/list" rel="noopener ugc nofollow" target="_blank">https://tour.golang.org/list</a></li><li id="456c" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn no mp mq mr bi translated"><a class="ae ko" href="https://crystal-lang.org/api/0.35.1/index.html" rel="noopener ugc nofollow" target="_blank">https://crystal-lang.org/api/0.35.1/index.html</a></li><li id="480f" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn no mp mq mr bi translated"><a class="ae ko" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank">https://golang.org/</a></li><li id="7505" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn no mp mq mr bi translated"><a class="ae ko" href="https://crystal-lang.org/" rel="noopener ugc nofollow" target="_blank">https://crystal-lang.org/</a></li></ol><p id="8d73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">更多详细和深入的未来技术帖子，请关注我这里或上</em><a class="ae ko" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"><em class="lf">Twitter</em></a><em class="lf">。</em></p></div></div>    
</body>
</html>