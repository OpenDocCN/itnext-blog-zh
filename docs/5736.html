<html>
<head>
<title>Misconceptions about Virtual DOM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对虚拟DOM的误解</h1>
<blockquote>原文：<a href="https://itnext.io/misconceptions-about-virtual-dom-35ec60b87086?source=collection_archive---------1-----------------------#2021-05-14">https://itnext.io/misconceptions-about-virtual-dom-35ec60b87086?source=collection_archive---------1-----------------------#2021-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="67fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你认为虚拟DOM是真实DOM的“轻量级拷贝”,通过将它们批处理在一起有助于加速更新，那么请继续阅读。尽管是正确的，但这是一个非常容易误导人的答案。令人惊讶的是，这也是最受欢迎的一个:谷歌搜索“react virtual DOM”会导致你看到非常相似的描述:<a class="ae km" href="https://www.geeksforgeeks.org/reactjs-virtual-dom/" rel="noopener ugc nofollow" target="_blank"> 1 </a>，<a class="ae km" href="https://programmingwithmosh.com/react/react-virtual-dom-explained/" rel="noopener ugc nofollow" target="_blank"> 2 </a>，即使你坚持使用StackOverflow上的顶级答案，你也会得到~相同的结果:<a class="ae km" href="https://stackoverflow.com/questions/50395934/whats-different-between-virtual-dom-and-shadow-dom" rel="noopener ugc nofollow" target="_blank"> 1 </a>，<a class="ae km" href="https://stackoverflow.com/questions/52513283/virtual-dom-and-real-dom-difference-in-react-js" rel="noopener ugc nofollow" target="_blank"> 2 </a>，<a class="ae km" href="https://stackoverflow.com/questions/45887841/what-is-the-advantage-of-virtual-dom-in-todo-like-app" rel="noopener ugc nofollow" target="_blank">3</a>；</p><blockquote class="kn ko kp"><p id="6628" class="jn jo kl jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">下面的内容同样适用于React和Blazor。</p></blockquote><h2 id="895a" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">为什么这是一个误导性的答案？</h2><p id="d627" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated"><strong class="jp ir"> #1。它没有突出虚拟DOM解决的关键问题——即<em class="kl">消除不必要的重新渲染</em>。</strong>当我说“重新呈现”时，并不是指在浏览器UI更新周期中重新呈现某些DOM元素。这是关于<em class="kl">而不是</em>调用已知产生相同输出的React组件的<code class="fe lr ls lt lu b">render()</code>方法，这有效地消除了组件的整个子树的重新呈现。</p><p id="3ac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你知道JS和React，可以看看<a class="ae km" href="https://codepen.io/alexyakunin/pen/JjWGZaG" rel="noopener ugc nofollow" target="_blank">这个例子</a>。它每秒记录<br/> <code class="fe lr ls lt lu b">"TimeString.render(): ..."</code>消息，即使<code class="fe lr ls lt lu b">Clock</code>组件每秒重新渲染自己10次(见第16行的<code class="fe lr ls lt lu b">setInterval</code>调用),并在每次渲染时用<code class="fe lr ls lt lu b">TimeString</code>组件产生一个输出。那么为什么<code class="fe lr ls lt lu b">TimeString</code>每秒只记录一次渲染而不是10次呢？这是因为<code class="fe lr ls lt lu b">TimeString</code>扩展了<code class="fe lr ls lt lu b"><a class="ae km" href="https://stackoverflow.com/questions/41340697/react-component-vs-react-purecomponent" rel="noopener ugc nofollow" target="_blank">PureComponent</a></code>，它覆盖了<code class="fe lr ls lt lu b"><a class="ae km" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdate</a></code>以确保重新渲染只在<code class="fe lr ls lt lu b">props</code>或<code class="fe lr ls lt lu b">state</code>改变时发生，而<code class="fe lr ls lt lu b">time</code>属性是一个每秒只改变一次的字符串。如果您将<code class="fe lr ls lt lu b">TimeString</code>的基础类型更改为<code class="fe lr ls lt lu b">Component</code>，它将开始报告每秒10次渲染。</p><p id="255e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，请注意，为了让它工作，<em class="kl">的某个东西</em>应该在现有组件上调用<code class="fe lr ls lt lu b">shouldComponentUpdate</code>。换句话说，虚拟DOM diffing算法必须推断出prev中使用的<code class="fe lr ls lt lu b">TimeString</code>组件。渲染实际上是我们刚才渲染的同一个组件。这正是在<a class="ae km" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">对账</a>期间发生的情况:</p><ul class=""><li id="6a26" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk ma mb mc md bi translated">对DOM元素所做的更改会应用到真实的DOM上——几乎所有对虚拟DOM的描述都强调了这一部分。</li><li id="0b92" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated"><em class="kl">由于</em> <code class="fe lr ls lt lu b"><em class="kl">props</em></code>中可能发生的变化，所有安装的React组件决定它们是否必须重新渲染——这一关键部分不知何故经常被忽略，尽管它是负责最大节省的部分。</li></ul><p id="6c39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是Blazor 中diffing如何工作的图示(它几乎完全复制了React组件模型):</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/018415b9f681b38eff81993492306d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8N9k87ur-1aH3kfehEJUg.png"/></div></div></figure><ul class=""><li id="3edf" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk ma mb mc md bi translated"><code class="fe lr ls lt lu b">&lt;div class="main"&gt;</code> —描述DOM元素的节点—不需要任何动作</li><li id="f5a4" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated">组件的属性发生了变化，因此它将被重新渲染</li><li id="6c7e" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated"><code class="fe lr ls lt lu b">&lt;Clock&gt;</code>组件之前不存在，因此将被渲染和挂载</li><li id="6cb9" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated"><code class="fe lr ls lt lu b">&lt;div&gt;</code>元素现在没有匹配的，所以将从DOM中删除。</li></ul><p id="bb27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> #2。你的应用中有多少虚拟DOM实例？是每个应用一个组件树，还是每个根组件一个虚拟DOM？大多数开发人员坚持后一点。</strong></p><p id="94ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，虚拟DOM只是组件的<code class="fe lr ls lt lu b">render()</code>方法的输出。看看上面例子中<code class="fe lr ls lt lu b">App</code>类的代码:</p><pre class="mk ml mm mn gt mv lu mw mx aw my bi"><span id="f3a7" class="kt ku iq lu b gy mz na l nb nc">class App extends React.Component {<br/>  render = () =&gt; <br/>    &lt;div class="main"&gt;<br/>      &lt;Welcome name="World" /&gt;<br/>      &lt;Clock /&gt;<br/>    &lt;/div&gt;<br/>}</span></pre><p id="99ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JSX transpiler将其转换为以下代码:</p><pre class="mk ml mm mn gt mv lu mw mx aw my bi"><span id="af20" class="kt ku iq lu b gy mz na l nb nc">class App extends React.Component {<br/>    constructor(...args) {<br/>        super(...args);<br/>        _defineProperty(this, "render",<br/>            () =&gt; /*#__PURE__*/<br/>            React.createElement("div", {<br/>                    class: "main"<br/>                }, /*#__PURE__*/<br/>                React.createElement(Welcome, {<br/>                    name: "World"<br/>                }), /*#__PURE__*/<br/>                React.createElement(Clock, null)));<br/>    }<br/>}</span></pre><p id="7654" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看到那里的<code class="fe lr ls lt lu b">react.createElement(...)</code>通话了吗？他们从字面上<em class="kl">定义</em>一棵树的节点。在<a class="ae km" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">协调</a>期间，将该树与前一个树(相同组件)进行比较，其中“前一个”是相同的树，但由前一次调用<code class="fe lr ls lt lu b">render()</code>方法<em class="kl">和引用<em class="kl">实际(已安装)</em>反应组件的</em>产生。</p><p id="08cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您可能猜到的，这个“本地虚拟DOM”并没有明确地“嵌入”到一个“大虚拟DOM”中，也就是说，虚拟DOM对于每个组件都是本地的。尽管从技术上讲，这些树仍然为任何根React组件形成了一个“大虚拟DOM”树，因为:</p><ul class=""><li id="0090" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk ma mb mc md bi translated">每个React组件都记得它最后的<code class="fe lr ls lt lu b">render()</code>输出，这是它的本地虚拟DOM</li><li id="f279" class="lv lw iq jp b jq me ju mf jy mg kc mh kg mi kk ma mb mc md bi translated">描述React组件的每个虚拟DOM节点都引用<em class="kl">实际(已安装)</em>组件——后者反过来跟踪自己的本地虚拟DOM，等等。</li></ul><p id="546f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样:)</p><p id="0938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我写这篇文章是作为其他几篇文章的前传，解释了为什么不可变模型如此适合React和Blazor，为什么所有流行的UI架构(MVC、MVVM / MobX、反冲、Flux/Redux等等)。)其实挺像的，最后，为什么用<a class="ae km" href="https://github.com/servicetitan/Stl.Fusion" rel="noopener ugc nofollow" target="_blank"> Fusion </a>都不需要。敬请期待！</p></div></div>    
</body>
</html>