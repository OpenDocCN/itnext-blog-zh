<html>
<head>
<title>Using Service Objects in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中使用服务对象</h1>
<blockquote>原文：<a href="https://itnext.io/using-service-objects-in-go-d899dc599335?source=collection_archive---------0-----------------------#2018-12-24">https://itnext.io/using-service-objects-in-go-d899dc599335?source=collection_archive---------0-----------------------#2018-12-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6c67a6d0d4ac52175377875cfd90728c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AGu3xb_gQ1edtgbaoKndVA.png"/></div></div></figure><p id="e7b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Ruby on Rails中，服务对象是一种高度可用的模式，它提供了保持控制器精简、模型清晰以及从两者中移除域逻辑的能力。在我看来，服务对象是单一责任原则和通过依赖注入分配责任的一个很好的例子。</p><p id="0455" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，SOLID及其背后的思想允许编写可测试的代码，这对于变化是高度灵活的。这些原则是由罗伯特“鲍勃叔叔”马丁倡导的。在他2000年的论文<a class="ae kw" href="https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf" rel="noopener ugc nofollow" target="_blank">设计原则和设计模式</a>中介绍了坚实原则的理论。戴夫·切尼有一篇关于它的文章<a class="ae kw" href="https://dave.cheney.net/2016/08/20/solid-go-design" rel="noopener ugc nofollow" target="_blank"> SOLID Go Design </a>。</p><p id="8ac4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Robert Martin在他的书<em class="kx">Clean Architecture:A craftman ' s Guide to Software Structure and Design</em>中也提出了一种架构，它包括四个层次的职责:实体、用例、接口适配器、框架和驱动程序。这个架构引入<em class="kx">用例</em>的原因与Ruby on Rails中的<em class="kx">服务对象</em>相同——封装业务逻辑。</p><p id="cc47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接口和依赖注入的广泛使用可以使代码独立于UI、框架和驱动程序。这种方法还提供了用所提供的UI和存储的模拟实现来测试业务逻辑的能力。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="90c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">举个例子，让我们看看下面的代码，看看使用SRP和引入<em class="kx">用例</em>级别后会有多好。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="8721" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，除了这个处理程序形成对传入请求的响应之外，它还保存了用户注册过程的所有业务逻辑。每当前一个步骤失败时，这段代码都会编写响应并中断其他步骤。</p><p id="4140" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当变化来临时，粘性症状会上升，因为没有明显的设计要保留，代码的每次变化都是某种形式的黑客攻击。如果需要向注册用户发送通知来验证他们的电子邮件，代码将变得更加难以理解和测试。</p><p id="896c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">完整代码示例见</em><a class="ae kw" href="https://github.com/romanyx/service_object" rel="noopener ugc nofollow" target="_blank"><em class="kx">github</em></a><em class="kx">。</em></p><p id="176e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所提供的代码示例的优点是，之前的开发人员为注册请求创建了集成测试，它不是遗留代码，这意味着它可以被重构。</p><p id="27db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们开始一些重构，并应用<em class="kx">用例</em>级别。第一步是将注册流程逻辑封装到服务对象中。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="e53d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ll lm ln lo b">Registrate</code>方法需要两个步骤在系统中注册用户:</p><ol class=""><li id="11a3" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">传入表单的验证。</li><li id="2f60" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">将模型插入到存储中。</li></ol><p id="a245" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着<em class="kx">服务对象</em>的引入，以前晦涩难懂的代码变得更加清晰易懂。如果发生了变化，工程师很可能会理解并保留现有的设计。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="8414" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">变化</em> <a class="ae kw" href="https://github.com/romanyx/service_object/pull/1/files" rel="noopener ugc nofollow" target="_blank"> <em class="kx">拉动请求</em> </a> <em class="kx">。</em></p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="ef96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现代web开发提出了很多要求，其中之一就是可观察性。可观察性由日志记录、度量和跟踪组成，它提供了不猜测任务性能和问题来源的能力，而是跟踪和修复它们。</p><p id="a19f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，为了达到这个目标，给定的代码应该通过将上下文传播到<em class="kx">服务对象</em>中来接受重要的更改，这样就可以跟踪传入的请求，并且与它相关的日志可以绑定到特定的TraceID。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="9a01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Sameer Ajmari在<a class="ae kw" href="https://blog.golang.org/context" rel="noopener ugc nofollow" target="_blank"> Go博客</a>中撰写的关于<code class="fe ll lm ln lo b">context</code>的文章描述了上下文的好处，以及为什么它应该在传入和传出请求的调用路径上的所有函数中传播。</p><p id="096f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">变化</em> <a class="ae kw" href="https://github.com/romanyx/service_object/pull/2/files" rel="noopener ugc nofollow" target="_blank"> <em class="kx">拉动请求</em> </a> <em class="kx">。</em></p><p id="eaba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这种方式，我们现在可以用Decorator扩展<em class="kx">服务对象</em>,并应用日志记录、跟踪和其他我们需要的扩展。你可以直接写这样的装饰器，或者用一些工具生成。已经有一个允许修饰接口的生成器— <a class="ae kw" href="https://github.com/hexdigest/gowrap" rel="noopener ugc nofollow" target="_blank"> gowrap </a>。作者Max Chechel在GoWayFest 2.0的演讲“<a class="ae kw" href="https://www.youtube.com/watch?v=pFFfurrCEcM" rel="noopener ugc nofollow" target="_blank">代码生成生存</a>”中解释了为什么你可能需要这样一个工具。</p><p id="c233" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">示例在</em> <a class="ae kw" href="https://github.com/romanyx/service_object/pull/3/files" rel="noopener ugc nofollow" target="_blank"> <em class="kx">拉动请求</em> </a> <em class="kx">。</em></p><p id="ff22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="kx">服务对象</em>之上应用装饰模式，使我们能够扩展它并达到许多目标，如度量、跟踪和将我们的代码移动到现代微服务时代。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="472c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管Go不是通常意义上的OOP语言，但用它编写的代码也应该是直观的，并且有明确的结构。可以使用SOLID缩写中包含的原则编写这样的代码，SOLID缩写包含一组适用于许多编程语言的通用方法。</p><p id="bcde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的目的是表达我对用Go编写的代码应该是什么样子的理解，我希望它包含的积极方面多于消极方面。</p></div></div>    
</body>
</html>