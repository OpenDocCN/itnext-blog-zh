<html>
<head>
<title>Infinite scrolling, dynamic module loading &amp; the Intersection Observer API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无限滚动、动态模块加载&amp;交叉点观察器API</h1>
<blockquote>原文：<a href="https://itnext.io/infinite-scrolling-dynamic-module-loading-the-intersection-observer-api-1f17186c7a8d?source=collection_archive---------2-----------------------#2018-02-06">https://itnext.io/infinite-scrolling-dynamic-module-loading-the-intersection-observer-api-1f17186c7a8d?source=collection_archive---------2-----------------------#2018-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3f76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们都经历过。我们构建了一个令人惊叹的web应用程序，我们加入了一些视差，用一些动画SVG为它增添了趣味，通过延迟加载图像进行了优化，并对我们的大型数据集进行了分页，当我们启动[夜间现代浏览器选择]时，我们发现世界上一切都很好。🙌然后一个需求出现了，说我们需要使用OS y来支持browser x，沮丧开始出现了。😔</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7f65d05d22fb511051bc8ad26ec7cd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlEwVUknnbq8x4DMfkaFmQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">一些严肃的玩笑的例子-&gt;<a class="ae lb" href="https://googlechrome.github.io/devtools-samples/jank/" rel="noopener ugc nofollow" target="_blank">https://googlechrome.github.io/devtools-samples/jank/</a></figcaption></figure><p id="62c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，很自然地，人们可能会启动devTools，抑制cpu，运行性能审计和神圣的废话什么是所有那些强制<a class="ae lb" href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/#layout" rel="noopener ugc nofollow" target="_blank">回流</a>和<a class="ae lb" href="http://jankfree.org/" rel="noopener ugc nofollow" target="_blank"> jank </a>。这不是一篇关于这两者的文章，但它有助于设置一个背景。</p><p id="1a93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发者可能知道也可能不知道的一件事是<a class="ae lb" href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#avoid_forced_synchronous_layouts" rel="noopener ugc nofollow" target="_blank">强制同步布局</a>是不好的，因为由于帧到屏幕的生命周期，它们会导致浏览器执行不必要的和昂贵的工作。用基本术语来说，这意味着在一个帧完成之前从DOM读回一个几何值将强制一个布局周期。反复读写会导致“布局抖动”，迫使浏览器一遍又一遍地重新计算布局。</p><h1 id="d3af" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">api简介</h1><p id="4ed3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先，描述一下这个<a class="ae lb" href="https://caniuse.com/#feat=intersectionobserver" rel="noopener ugc nofollow" target="_blank">实验api </a>是什么可能是有意义的，这样我们就可以有效地研究它帮助解决的一些用例和问题。所以让我们开始吧…</p><p id="d0fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>将IntersectionObserver API描述为:</p><blockquote class="mf mg mh"><p id="fd06" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">提供一种异步观察目标元素与祖先元素或顶级文档的视口的交集变化的方法</p></blockquote><p id="91e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上本质上归结为检测主体何时越过给定目标的边界的能力。简单地说，当一个被观察的元素进入或退出另一个元素或视口的边界时，observer api允许开发人员执行给定的回调函数。上面描述的真正关键是这个过程是一个<strong class="jp ir">异步</strong>过程。这使我们能够在不阻塞主线程的情况下监视元素之间的入口/出口/交叉点。</p><p id="4caa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多年来，开发人员一直在以各种方式解决这个问题，但他们通常归结为以下步骤的变体:</p><ul class=""><li id="6746" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">向某个事件目标添加一个事件侦听器来侦听滚动事件</li><li id="3f6e" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">如果考虑到性能，那么对事件侦听器进行去抖/节流，并确保passive选项设置为false，否则在每个事件通知时天真地触发处理程序</li><li id="cb86" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">计算目标元素相对于另一个元素的位置，以确定是否满足指定的边界限制</li><li id="6f2a" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">所有这些都发生在主线程上，如果计算时间太长，那么你会开始注意到被跳过的帧。</li></ul><blockquote class="mf mg mh"><p id="a11c" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">…如果你在一个类似滚动的动画中，你最好将你的JavaScript保持在大约<strong class="jp ir">3-4毫秒</strong>的范围内。再久一点，你就有占用太多时间的危险。— <a class="ae lb" href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution#reduce_complexity_or_use_web_workers" rel="noopener ugc nofollow" target="_blank">保罗·路易斯</a></p></blockquote><p id="717e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我想我们都同意我们需要一个更好的方法。这是IntersectionObserver真正出彩的地方，所以让我们来看看代码，好吗…</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="98a7" class="nf ld iq nb b gy ng nh l ni nj">const element = document.createElement('div');<br/>const observer = new IntersectionObserver(callback, options);</span><span id="9d35" class="nf ld iq nb b gy nk nh l ni nj">observer.observe(element);</span></pre><p id="9d8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！👏👏👏</p><p id="7f52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，请不要鼓掌，因为我肯定你想知道有哪些选项，有没有传递给回调的参数？我们来探索一下。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="b196" class="nf ld iq bd le ns nt dn li nu nv dp lm jy nw nx lq kc ny nz lu kg oa ob ly oc bi translated">选择</h2><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="849d" class="nf ld iq nb b gy ng nh l ni nj"><strong class="nb ir">interface</strong> options {<br/>  root?: <!-- -->HTMLElement<!-- --> | null;<br/>  rootMargin?: string;<br/>  threshold?: number | <!-- -->number[]<!-- -->;<br/>}</span></pre><p id="2711" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">options对象的所有属性实际上都是可选的，如果没有设置，默认为特定的值。<strong class="jp ir">根</strong>属性定义了决定目标可见性的直接祖先元素，默认为浏览器视口。<strong class="jp ir"> rootMargin </strong>指定根周围的任何边距，并在计算根和目标之间的交集时使用。<strong class="jp ir">阈值</strong>可以是[0，1]之间的单个数值，也可以是一组值，缺省值为0，这意味着只要目标的任何部分可见，就触发回调。根据文档，阈值可以更正式地描述为以下值:</p><blockquote class="mf mg mh"><p id="28ec" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">指示观察者的回调应该在目标可见性的多少百分比上执行。如果只想检测可见性何时超过50%标记，可以使用值0.5。如果您希望每次可见度超过25%时都运行回调，那么您应该指定数组[0，0.25，0.5，0.75，1]</p></blockquote></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="9b9c" class="nf ld iq bd le ns nt dn li nu nv dp lm jy nw nx lq kc ny nz lu kg oa ob ly oc bi translated">回收</h2><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="fd5c" class="nf ld iq nb b gy ng nh l ni nj">const callback = function(entries, observer) {};</span></pre><p id="9c96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向提供的回调函数传递一个<code class="fe od oe of nb b">entries</code>数组，其中每个条目对象具有以下形状:</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="17c5" class="nf ld iq nb b gy ng nh l ni nj">{<br/>  boundingClientRect<br/>  intersectionRatio<br/>  intersectionRect<br/>  isIntersecting<br/>  rootBounds<br/>  target<br/>  time<br/>}</span></pre><p id="da47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于回调，有一点需要注意，默认情况下，<strong class="jp ir">是在主线程上执行的，因此昂贵的计算可能会影响性能。如果您发现自己需要运行阻止其他交互的代码，那么可以利用<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback" rel="noopener ugc nofollow" target="_blank">window . requestidlecallback()</a>。</strong></p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">IntersectionObserver api的简单演示</figcaption></figure><p id="b48a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://codepen.io/shaunwallace/pen/xXNPZM" rel="noopener ugc nofollow" target="_blank"> <em class="mi"> codepen demo </em> </a></p><p id="8a05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从视频中，您可能会注意到，当顶行和底行正方形从视口外部移动到视口内部时，整数值会发生变化，反之亦然。这些变化是由于阈值设置引起的，在本例中，它们是通过回调来更新的。</p><p id="442e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这实际上提供了对屏幕上元素的入口/出口/交叉点的细粒度控制。为了更好地了解这是如何实现的，让我们看一下代码。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oi oh l"/></div></figure><p id="2217" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先指定options对象的值。在上面的代码中，我们允许根默认为视口，并且不关心任何额外的边距。阈值是非常细粒度的，在大多数情况下，您不需要这种粒度级别。最棒的是，你可以开始看到它的实际应用。当满足交集阈值并且没有绑定到滚动事件或定位计算时，上面的代码可以容易地获取一些图像或内容。</p><p id="ab1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文档中提到的一些其他使用案例包括:</p><ul class=""><li id="0215" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">捕捉某些元素在视图中的持续时间。例如，这可以用于分析或广告。</li><li id="54c9" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">推迟动画或计算，直到元素实际可见。</li></ul><p id="7f8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">api还支持其他一些方法。即<code class="fe od oe of nb b">disconnect() and unobserve()</code>。第一种方法将所有观察点从观察交叉点事件中移除。第二个停止观察指定的目标。</p><p id="570d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个api允许我们轻松处理的一个有趣场景是动态模块加载。如果您在任何风格中使用过<a class="ae lb" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank">动态导入</a>，您可能会看到如何利用交集来乐观地加载额外的javascript，比如说当用户到达页面上的最终元素时。</p><p id="1aa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我相信社区会找到更多的用例，但是现在我希望你喜欢这个快速浏览和愉快的编码。⌨️ 👍</p></div></div>    
</body>
</html>