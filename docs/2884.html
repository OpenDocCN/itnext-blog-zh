<html>
<head>
<title>Setup your Kubernetes clusters with helmfile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用helmfile设置Kubernetes集群</h1>
<blockquote>原文：<a href="https://itnext.io/setup-your-kubernetes-cluster-with-helmfile-809828bc0a9f?source=collection_archive---------3-----------------------#2019-08-21">https://itnext.io/setup-your-kubernetes-cluster-with-helmfile-809828bc0a9f?source=collection_archive---------3-----------------------#2019-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/912719ceb5e40be0e242f1b580f2b5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUydbZX4UfdcoC1w5JTtWA.jpeg"/></div></div></figure><p id="e343" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，你有一个Kubernetes集群启动并运行。控制平面处于活动状态，工作节点已准备好处理负载。我们要继续部署我们的业务应用程序吗？在此之前，我们可能需要做一点准备。作为任何有自尊的企业，我们希望能够监控我们部署的应用程序，进行备份和自动扩展，并能够在出现问题时搜索日志。在实际部署应用程序之前，这些只是我们想要解决的一些需求。</p><p id="50ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幸运的是，有很多工具可以解决这些基础设施需求。此外，这些基础设施应用中的大多数都有相关的<a class="ae kz" href="https://github.com/helm/charts/tree/master/stable" rel="noopener ugc nofollow" target="_blank">舵图</a>。这些只是几个例子:</p><ul class=""><li id="181c" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu">普罗米修斯</strong> / <strong class="kd iu">格拉夫纳</strong>进行监控</li><li id="482c" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">测井用流利位</strong></li><li id="97da" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu"> velero </strong>用于备份</li><li id="fad3" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu"> nginx入口</strong> <strong class="kd iu">控制器</strong>，用于负载均衡</li><li id="9e20" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">CI/CD用三角帆</strong></li><li id="6e39" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">外部dns </strong>用于与dns提供商同步k8s服务</li><li id="a09b" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">集群自动缩放器</strong></li></ul><p id="b528" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">诸如此类…</p><p id="012c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">问题是:<strong class="kd iu">我们如何在Kubernetes集群</strong>中部署它们？如果更多的Kubernetes集群涌现出来，我们如何以可靠、可维护和自动化的方式安装这些基础设施应用程序？</p><p id="4556" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们探索了几种方法来做这件事。有一把<a class="ae kz" href="https://stackoverflow.com/questions/51984976/how-to-build-umbrella-chart-with-exact-dependency-helm-chart-version-in-requirem" rel="noopener ugc nofollow" target="_blank">伞舵图</a> <br/> 2。<a class="ae kz" href="https://github.com/terraform-providers/terraform-provider-helm" rel="noopener ugc nofollow" target="_blank">使用Terraform头盔提供者</a> <br/> 3。使用<a class="ae kz" href="https://github.com/roboll/helmfile" rel="noopener ugc nofollow" target="_blank"> helmfile </a>命令行界面</p><p id="d4e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我们将探讨<a class="ae kz" href="https://github.com/roboll/helmfile" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">helm file</strong></a><strong class="kd iu">，</strong>，我们已经成功地将其用于基础架构应用部署。</p><h1 id="5f89" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Helmfile</h1><p id="9569" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">正如有人提到的，<a class="ae kz" href="https://medium.com/@naseem_60378/helmfile-its-like-a-helm-for-your-helm-74a908581599" rel="noopener"> helmfile就像是给你掌舵的一个舵</a>！它允许我们部署舵图表，正如我们将在下面的章节中看到的。</p><h1 id="4e78" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">基本的helmfile结构</h1><p id="5c3f" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">下面我们将看到的是一个受<a class="ae kz" href="https://github.com/cloudposse/helmfiles" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> Cloud Posse的GitHub repo </strong> </a>启发的结构。我们有一个主helmfile，它包含了我们想要部署的发布列表(helm charts)。</p><p id="a472" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> helmfile.yaml </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ff8a" class="na lp it mw b gy nb nc l nd ne">---<br/># Ordered list of releases.<br/>helmfiles:<br/>  - "commons/repos.yaml"<br/>  - "releases/nginx-ingress.yaml"<br/>  - "releases/kube2iam.yaml"<br/>  - "releases/cluster-autoscaler.yaml"<br/>  - "releases/dashboard.yaml"<br/>  - "releases/external-dns.yaml"<br/>  - "releases/kube-state-metrics.yaml"<br/>  - "releases/prometheus.yaml"<br/>  - "releases/thanos.yaml"<br/>  - "releases/fluent_bit.yaml"<br/>  - "releases/spinnaker.yaml"<br/>  - "releases/velero.yaml"</span></pre><p id="abc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个发布文件(基本上是一个子helmfile)看起来像这样:</p><p id="2459" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">发布/ngins-ingress.yaml </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="72d4" class="na lp it mw b gy nb nc l nd ne">---<br/>bases:<br/>  - ../commons/environments.yaml<br/>---<br/>releases:<br/>- name: "nginx-ingress"<br/>  namespace: "nginx-ingress"<br/>  labels:<br/>    chart: "nginx-ingress"<br/>    repo: "stable"<br/>    component: "balancing"<br/>  chart: "stable/nginx-ingress"<br/>  version: {{ .Environment.Values.helm.nginx_ingress.version }}<br/>  wait: true<br/>  installed: {{ .Environment.Values.helm | getOrNil "nginx_ingress.enabled" | default true }}<br/>  - name: "controller.metrics.enabled"<br/>    value: {{ .Environment.Values.helm.nginx_ingress.metrics_enabled }}</span></pre><p id="cb51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你看上面，你会看到我们正在模板化<a class="ae kz" href="https://github.com/helm/charts/tree/master/stable/nginx-ingress" rel="noopener ugc nofollow" target="_blank"> nginx-ingress </a>图的舵部署。实际值(如图表版本、启用的指标)来自环境文件:</p><p id="5f34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">commons/environments . YAML</strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="610a" class="na lp it mw b gy nb nc l nd ne">environments:<br/>  default:<br/>    values:<br/>      - ../auto-generated.yaml</span></pre><p id="c3b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其中<strong class="kd iu"> auto-generated.yaml </strong>是一个简单的yaml文件，包含以下值:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="84cf" class="na lp it mw b gy nb nc l nd ne">helm:<br/>  nginx_ingress:<br/>   installed: true<br/>   version: 1.17.1<br/>   metrics_enabled: true</span><span id="a482" class="na lp it mw b gy nf nc l nd ne">  velero:<br/>    installed: true<br/>    s3_bucket: my-s3-bucket<br/>    ...</span></pre><p id="125c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，在上面的例子中，我们使用了一个env(名为<em class="ng"> default </em>，但是你可以有更多的env(例如<em class="ng">dev</em>/<em class="ng">stage</em>/<em class="ng">prod</em>)并且在它们之间切换。每个环境都有自己的一组值，允许您进一步定制部署，我们将在下一节中看到。</p><p id="5708" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这些，我们就可以开始在我们的Kubernetes集群中部署舵图了:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7df9" class="na lp it mw b gy nb nc l nd ne">$ helmfile sync</span></pre><p id="e61b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将开始在Kubernetes集群中部署基础架构应用程序。作为额外的奖励，<strong class="kd iu">图表将按照主helmfile </strong>中提供的顺序安装。如果您的图表依赖于另一个要先安装的图表(例如kube2iam之后的外部dns ),这将非常有用。</p><h1 id="1b7e" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">释放helmfile的模板化能力</h1><p id="bdda" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">最有趣的<em class="ng"> helmfile </em>特性之一是能够使用<strong class="kd iu">模板化舵图表值</strong>(这是<em class="ng">舵</em>所缺乏的特性)。你在helmfile中看到的一切都可以被模板化。让我们以<a class="ae kz" href="https://github.com/helm/charts/tree/master/stable/cluster-autoscaler" rel="noopener ugc nofollow" target="_blank">集群自动缩放器</a>为例。假设我们想在两个Kubernetes集群中部署这个图表:一个位于AWS中，另一个位于Azure中。因为集群自动缩放器与云API挂钩，所以我们需要根据云提供商定制图表值。例如，AWS需要一个IAM角色，而Azure需要一个<em class="ng">azureClientId</em>/<em class="ng">azureClientSecret</em>。让我们看看如何用<em class="ng"> helmfile </em>实现这个行为。</p><p id="aa7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，您也可以在<a class="ae kz" href="https://github.com/costimuraru/helmfile-examples/tree/master/templatization" rel="noopener ugc nofollow" target="_blank">GitHub helm file-examples repo</a>中找到以下示例。</p><p id="2d9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">cluster-auto scaler . YAML</strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="28d6" class="na lp it mw b gy nb nc l nd ne">---<br/>bases:<br/>  - envs/environments.yaml<br/>---<br/>releases:<br/>- name: "cluster-autoscaler"<br/>  namespace: "cluster-autoscaler"<br/>  labels:<br/>    chart: "cluster-autoscaler"<br/>    repo: "stable"<br/>    component: "autoscaler"<br/>  chart: "stable/cluster-autoscaler"<br/>  version: {{ .Environment.Values.helm.autoscaler.version }}<br/>  wait: true<br/>  installed: {{ .Environment.Values | getOrNil "autoscaler.enabled" | default true }}<br/>  set:<br/>    - name: rbac.create<br/>      value: true</span><span id="29d4" class="na lp it mw b gy nf nc l nd ne">{{ if eq .Environment.Values.helm.autoscaler.cloud "aws" }}<br/>    - name: "cloudProvider"<br/>      value: "aws"<br/>    - name: "autoDiscovery.clusterName"<br/>      value: {{ .Environment.Values.helm.autoscaler.clusterName }}<br/>    - name: awsRegion<br/>      value: {{ .Environment.Values.helm.autoscaler.aws.region }}<br/>    - name: "podAnnotations.iam\\.amazonaws\\.com\\/role"<br/>      value: {{ .Environment.Values.helm.autoscaler.aws.arn }}</span><span id="a067" class="na lp it mw b gy nf nc l nd ne">{{ else if eq .Environment.Values.helm.autoscaler.cloud "azure" }}<br/>    - name: "cloudProvider"<br/>      value: "azure"<br/>    - name: azureClientID<br/>      value: {{ .Environment.Values.helm.autoscaler.azure.clientId }}<br/>    - name: azureClientSecret<br/>      value: {{ .Environment.Values.helm.autoscaler.azure.clientSecret }}<br/>{{ end }}</span></pre><p id="1373" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您在上面看到的，我们正在为集群自动缩放图表模板化helm部署。基于所选的环境，我们最终会得到AWS或Azure的特定值。</p><p id="f238" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> envs/environments.yaml </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="605f" class="na lp it mw b gy nb nc l nd ne">environments:<br/>  aws:<br/>    values:<br/>      - aws-env.yaml<br/>  azure:<br/>    values:<br/>      - azure-env.yaml</span></pre><p id="2bb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> env/aws-env.yaml </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="afb6" class="na lp it mw b gy nb nc l nd ne">helm:<br/>  autoscaler:<br/>   cloud: aws<br/>   version: 0.14.2<br/>   clusterName: experiments-k8s-cluster<br/>   aws:<br/>     arn: arn:aws:iam::00000000000:role/experiments-k8s-cluster-autoscaler<br/>     region: us-east-1</span></pre><p id="ab67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> env/azure-env.yaml </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0c30" class="na lp it mw b gy nb nc l nd ne">helm:<br/>  autoscaler:<br/>    cloud: azure<br/>    version: 0.14.2<br/>    azure:<br/>      clientId: "secret-value-here"<br/>      clientSecret: "secret-value-here"</span></pre><p id="847b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，为了选择所需的云提供商，我们可以运行:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="5e47" class="na lp it mw b gy nb nc l nd ne">helmfile --environment aws sync<br/># or <br/>helmfile --environment azure sync</span></pre><h2 id="e823" class="na lp it bd lq nh ni dn lu nj nk dp ly km nl nm mc kq nn no mg ku np nq mk nr bi translated">将整个值文件模板化</h2><p id="2080" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">您可以更进一步，通过使用. gotmpl文件，对整个值文件进行模板化。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="bede" class="na lp it mw b gy nb nc l nd ne">releases:<br/>  - name: "velero"<br/>    chart: "stable/velero"<br/>    values:<br/>      - velero-values.yaml.gotmpl</span></pre><p id="aca5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在<a class="ae kz" href="https://github.com/costimuraru/helmfile-examples/tree/master/gotmpl" rel="noopener ugc nofollow" target="_blank">GitHub helm file-examples repo</a>上看到一个例子。</p><h2 id="5166" class="na lp it bd lq nh ni dn lu nj nk dp ly km nl nm mc kq nn no mg ku np nq mk nr bi translated">对repos文件使用模板化</h2><p id="7a1e" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">我们可以定义一个舵回购列表，从中获取舵图表。稳定的库是一个明显的选择，但是我们也可以添加私有的helm库。有趣的是，我们可以使用模板化来提供凭证。</p><p id="ea17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> commons/repos.yaml </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c033" class="na lp it mw b gy nb nc l nd ne">---<br/>repositories:<br/>  # Stable repo of official helm charts<br/>  - name: "stable"<br/>    url: "<a class="ae kz" href="https://kubernetes-charts.storage.googleapis.com" rel="noopener ugc nofollow" target="_blank">https://kubernetes-charts.storage.googleapis.com</a>"<br/>  # Incubator repo for helm charts<br/>  - name: "incubator"<br/>    url: "<a class="ae kz" href="https://kubernetes-charts-incubator.storage.googleapis.com" rel="noopener ugc nofollow" target="_blank">https://kubernetes-charts-incubator.storage.googleapis.com</a>"</span><span id="d77b" class="na lp it mw b gy nf nc l nd ne">  # Private repository, with credentials coming from the env file<br/>  - name: "my-private-helm-repo"<br/>    url: "<a class="ae kz" href="https://my-repo.com" rel="noopener ugc nofollow" target="_blank">https://my-repo.com</a>"<br/>    username: {{ .Environment.Values.artifactory.username }}<br/>    password: {{ .Environment.Values.artifactory.password }}</span></pre><p id="4ce3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了保护你的凭证，<em class="ng"> helmfile </em>支持注入环境秘密值。更多详情，请点击<a class="ae kz" href="https://github.com/roboll/helmfile#environment-secrets" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="7b13" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">无瓷砖</h1><p id="e6d1" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">关于helm，困扰我们的一个问题是，它需要在Kubernetes集群中安装Tiller守护进程(在进行任何helm chart部署之前)。提醒你一下，helm有两个部分:一个客户端(helm)和一个服务器(tiller)。除了<a class="ae kz" href="https://engineering.bitnami.com/articles/helm-security.html" rel="noopener ugc nofollow" target="_blank">安全问题</a>之外，为了设置角色、服务帐户和进行实际的Tiller安装，也增加了复杂性。</p><p id="05bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好消息是<em class="ng"> helmfile </em>可以设置为在<strong class="kd iu">无平铺模式</strong>下运行。启用后，helmfile将使用<a class="ae kz" href="https://github.com/rimusz/helm-tiller" rel="noopener ugc nofollow" target="_blank">舵柄</a>插件，该插件将基本上在本地运行舵柄。不再需要在Kubernetes集群中安装<em class="ng"> tiller </em>守护进程。如果您想知道当多人试图使用这种无tiler方法安装图表时会发生什么，那么您不应该担心，因为掌舵状态信息仍然存储在Kubernetes中，作为所选名称空间中的秘密。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c0b6" class="na lp it mw b gy nb nc l nd ne">helmDefaults:<br/>  tillerNamespace: helm<br/>  tillerless: true</span></pre><p id="e5ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="ng">无舵</em>模式下运行时，可以这样列出已安装的图表:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="618c" class="na lp it mw b gy nb nc l nd ne">helm tiller run helm -- helm list</span></pre><p id="5c60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想了解更多关于这个插件的信息，这里有一篇来自主要开发者的非常酷的文章。我们也期待着<a class="ae kz" href="https://github.com/helm/helm/releases" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> helm3 </strong> </a>的发布，这将彻底摆脱蒂勒。</p><h1 id="a521" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="bea6" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">Helmfile 完成了它的工作，而且做得很好。它有强大的社区支持，模板化的力量只是<em class="ng">哇</em>。如果你还没有，那就试一试:<a class="ae kz" href="https://github.com/roboll/helmfile" rel="noopener ugc nofollow" target="_blank">https://github.com/roboll/helmfile</a></p></div></div>    
</body>
</html>