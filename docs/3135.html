<html>
<head>
<title>A Beginner’s Guide to Async/Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Async/Await初学者指南</h1>
<blockquote>原文：<a href="https://itnext.io/a-beginners-guide-to-async-await-in-javascript-97750bd09ffa?source=collection_archive---------1-----------------------#2019-10-10">https://itnext.io/a-beginners-guide-to-async-await-in-javascript-97750bd09ffa?source=collection_archive---------1-----------------------#2019-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3545" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">异步JavaScript从未如此友好</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f4506395f3e2e70e8fb0cb1a447d749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqLaXeqw_6p-sHWdYVehsg.png"/></div></div></figure><p id="eb7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会爱上Async/Await。虽然链是缩进式的，令人困惑，但Async/Await是简单的。对于本教程，我假设你已经知道<a class="ae lu" href="https://medium.com/@mikecronin92/promises-promises-understanding-the-basics-of-js-promise-objects-dd5c656f2db4" rel="noopener">承诺</a>和<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/that-data-looks-so-fetching-on-you-understanding-the-js-fetch-api-880eae0c8d25">获取</a>是如何工作的，所以如果你对概念有点模糊，请阅读那些文章。此外，Async/Await可以在现代浏览器中工作，但如果代码片段不工作，请尝试切换到Chrome或Brave。</p><h1 id="5d40" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">旧与新</h1><p id="ad74" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">让我们使用<code class="fe lq lr ls lt b">.then</code>编写一个简单的查询。您可以通过将这段代码复制到浏览器的控制台来运行它。如果CORS给你带来麻烦，试着去<a class="ae lu" href="https://jsonplaceholder.typicode.com" rel="noopener ugc nofollow" target="_blank"> jsonplaceholder </a>本身并在那里运行它。</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="ad5d" class="mw lw it lt b gy mx my l mz na">const <strong class="lt iu">getFirstUser</strong> = () =&gt; {<br/>  const url = '<em class="nb">https://jsonplaceholder.typicode.com/users/1</em>';<br/>  fetch(<strong class="lt iu">url</strong>)<br/>    .then(<strong class="lt iu">response</strong> =&gt; <strong class="lt iu">response</strong>.json())<br/>    .then(<strong class="lt iu">json</strong> =&gt; <strong class="lt iu">console</strong>.log(<strong class="lt iu">json</strong>));<br/>}</span></pre><p id="1ab1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是老方法，但是用Async/Await会是什么样子呢？老实说，非常相似:</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="efde" class="mw lw it lt b gy mx my l mz na">const <strong class="lt iu">getSecondUser</strong> = <strong class="lt iu"><em class="nb">async</em></strong> () =&gt; {<br/>  const <strong class="lt iu">url</strong> = <em class="nb">'https://jsonplaceholder.typicode.com/users/2'</em>;<br/>  const <strong class="lt iu">response</strong> = <em class="nb">await</em> fetch(<strong class="lt iu">url</strong>);<br/>  <strong class="lt iu">console</strong>.log(<em class="nb">await</em> <strong class="lt iu">response</strong>.json());<br/>}</span></pre><p id="6240" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我真的想让你看到Async/Await并不疯狂，它只是一个改进。最直接的好处是我们不再需要担心筑巢。没有更多的缩进疯狂每次你想打一个新的电话链内的<code class="fe lq lr ls lt b">.then</code>！</p><h1 id="f8f8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">分解它</h1><p id="6b85" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">最需要注意的是函数开头的<code class="fe lq lr ls lt b">async</code>关键字。这很重要，你只能在一个<code class="fe lq lr ls lt b">async</code>函数<strong class="kw iu"> </strong> ( <em class="nb">除非</em>你在一个支持顶级<code class="fe lq lr ls lt b">await</code>的环境中)中使用<code class="fe lq lr ls lt b">await</code>关键字。你可以<em class="nb">在任何你喜欢的地方调用</em>这个函数，但是我们稍后会详细讨论。当在一个<code class="fe lq lr ls lt b">async</code>函数中时，任何用<code class="fe lq lr ls lt b">.then</code>关键字链接的承诺现在都在<code class="fe lq lr ls lt b">await</code>后面。那个<code class="fe lq lr ls lt b">await</code>将等待它旁边的承诺解决，然后再继续这个程序。它基本上使异步动作同步。你可以把它赋给一个变量，但是你不需要这么做。如果您不介意以后使用解析的值，就没有必要分配它。：</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="cd7d" class="mw lw it lt b gy mx my l mz na">const <strong class="lt iu">response</strong> = <em class="nb">await</em> fetch(<strong class="lt iu">url</strong>);<br/>// also valid: <br/><em class="nb">await</em> fetch(<strong class="lt iu">url</strong>);</span></pre><h1 id="9d91" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">异步返回值</h1><p id="2270" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">让我们尝试一下那些有趣的辅导实验，虽然这显然行不通，但我还是让你去做，因为烦恼可以塑造性格。告诉我，如果我们尝试在函数的之外记录最终结果<em class="nb">，会发生什么？</em></p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="7b9b" class="mw lw it lt b gy mx my l mz na">const <strong class="lt iu">getThirdUser</strong> = <strong class="lt iu"><em class="nb">async</em></strong> () =&gt; {<br/>  const <strong class="lt iu">url</strong> = '<em class="nb">https://jsonplaceholder.typicode.com/users/3</em>';<br/>  const <strong class="lt iu">response</strong> = await fetch(<strong class="lt iu">url</strong>);<br/>  const <strong class="lt iu">json</strong> = await <strong class="lt iu">response</strong>.json();<br/>  return <strong class="lt iu">json</strong>;<br/>}</span><span id="3584" class="mw lw it lt b gy nc my l mz na">console.log(<strong class="lt iu">getThirdUser</strong>());</span></pre><p id="8360" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">剧透预警，它给你这个垃圾:<code class="fe lq lr ls lt b">Promise { &lt;pending&gt; }</code>。怎么回事？之前，我误导性地说你可以在任何地方调用这个函数，但是看起来这个函数并不真的工作。这是因为当你可以在任何地方调用异步函数时，它总是会返回一个承诺。让我重复一遍:<strong class="kw iu">异步函数总是将其返回值包装在</strong> <code class="fe lq lr ls lt b"><strong class="kw iu">Promise.resolve</strong></code> <strong class="kw iu"> <em class="nb">中。</em> </strong></p><p id="0562" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，这并不意味着什么。承诺通常存在于独立的函数中，如事件处理程序或挂载函数。现在唯一的区别是你给他们<code class="fe lq lr ls lt b">async</code>关键词:</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="ba75" class="mw lw it lt b gy mx my l mz na">const <strong class="lt iu">handleSubmit</strong> = (<strong class="lt iu">event</strong>) =&gt; {<br/>  <strong class="lt iu">event</strong>.preventDefault();<br/>  <strong class="lt iu">UserAdapter</strong>.checkUser(user)<br/>    .then(<strong class="lt iu">validUser</strong> =&gt; setCurrentUser(<strong class="lt iu">validUser</strong>));<br/>};</span><span id="09bc" class="mw lw it lt b gy nc my l mz na">// is now:<br/>const <strong class="lt iu">handleSubmit</strong> = <strong class="lt iu"><em class="nb">async</em></strong> (<strong class="lt iu">event</strong>) =&gt; {<br/>  <strong class="lt iu">event</strong>.preventDefault();<br/>  const <strong class="lt iu">validUser</strong> = <em class="nb">await</em> <strong class="lt iu">UserAdapter</strong>.checkUser(<strong class="lt iu">user</strong>);<br/>  setCurrentUser(<strong class="lt iu">validUser</strong>);    <br/>};</span></pre><p id="191e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我提到这一点是因为我认为错误调用<code class="fe lq lr ls lt b">async</code>函数会在你开始时造成很多混乱。您将尝试像使用常规函数一样使用它们，当它表现不同时会感到沮丧。</p><h1 id="1af0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">异步函数仍然是。然后表格</h1><p id="62aa" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">由于每个函数都返回一个承诺，这意味着异步函数的返回值仍然是可链接的。这对于使用一个liners或者如果您想在非异步范围内使用异步函数的返回值是很方便的。为了准确地从上面的示例中注销我们的响应，应该是:</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="5061" class="mw lw it lt b gy mx my l mz na"><strong class="lt iu">getThirdUser</strong>().then(<strong class="lt iu">console</strong>.log);</span></pre><p id="1b3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住，你仍然可以在一个<code class="fe lq lr ls lt b">async</code>函数中使用<code class="fe lq lr ls lt b">.then</code>，只是要确保<code class="fe lq lr ls lt b">await</code>它:</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="d2a5" class="mw lw it lt b gy mx my l mz na">const <strong class="lt iu">contrivedExample</strong> = <strong class="lt iu"><em class="nb">async</em></strong> () =&gt; {<br/>  <em class="nb">await</em> <strong class="lt iu">getThirdUser</strong>().then(<strong class="lt iu">console</strong>.log);<br/>  // more function stuff<br/>}</span></pre><h1 id="d6a0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">无用的等待</h1><p id="6560" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">让我们再看一下上面的一些代码:</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="27f0" class="mw lw it lt b gy mx my l mz na">const <strong class="lt iu">getThirdUser</strong> = <strong class="lt iu"><em class="nb">async</em></strong> () =&gt; {<br/>  const <strong class="lt iu">url</strong> = '<em class="nb">https://jsonplaceholder.typicode.com/users/3</em>';<br/>  const <strong class="lt iu">response</strong> = await fetch(<strong class="lt iu">url</strong>);<br/>  const <strong class="lt iu">json</strong> = await <strong class="lt iu">response</strong>.json();<br/>  return <strong class="lt iu">json</strong>;<br/>}</span></pre><p id="e728" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你看到最后的<code class="fe lq lr ls lt b">await</code>了吗？没必要。所有的<code class="fe lq lr ls lt b">await</code>真正做的是等待一个承诺来解决。然而，我们的主异步函数将把我们的返回值包装在一个承诺中。因此，如果返回值只是要返回一个承诺，我们应该避免额外的延迟，返回一个承诺:</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="1af5" class="mw lw it lt b gy mx my l mz na">const <strong class="lt iu">getThirdUser</strong> = <strong class="lt iu"><em class="nb">async</em></strong> () =&gt; {<br/>  const <strong class="lt iu">url</strong> = '<em class="nb">https://jsonplaceholder.typicode.com/users/3</em>';<br/>  const <strong class="lt iu">response</strong> = await fetch(<strong class="lt iu">url</strong>);<br/>  return <strong class="lt iu">response</strong>.json();<br/>}</span></pre><p id="c10f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有趣的是，棉绒会警告你这种情况。</p><h2 id="94d4" class="mw lw it bd lx nd ne dn mb nf ng dp mf ld nh ni mh lh nj nk mj ll nl nm ml nn bi translated">最后一个陷阱:遗忘等待和处理错误</h2><p id="17cf" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">毫无疑问，这个新语法最常见的错误是在需要的时候忘记输入一个<code class="fe lq lr ls lt b">await</code>。在我们上面的简单例子中，如果你忘记了，一些东西会坏掉，但并不总是这样。如果你正在使用一个<code class="fe lq lr ls lt b">async</code>函数，事情开始变得奇怪，确保每个异步动作都在一个<code class="fe lq lr ls lt b">await</code>之后。此外，捕捉错误也恢复正常。你可以再次使用普通的<code class="fe lq lr ls lt b">try/catch</code>积木，而不是使用特殊的<code class="fe lq lr ls lt b">.catch</code>:</p><pre class="kj kk kl km gt ms lt mt mu aw mv bi"><span id="1f56" class="mw lw it lt b gy mx my l mz na">const <strong class="lt iu">getFourthUser</strong> = <strong class="lt iu"><em class="nb">async</em></strong> () =&gt; {<br/>  try {<br/>    const <strong class="lt iu">url</strong> = '<em class="nb">https://jsonplaceholder.typicode.com/users/4</em>';<br/>    const <strong class="lt iu">response</strong> = await fetch(<strong class="lt iu">url</strong>);<br/>    return <strong class="lt iu">response</strong>.json();<br/>  } catch (e) {<br/>    // handle error<br/>  }<br/>}</span></pre><h1 id="700c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">你在等什么？</h1><p id="3726" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">这就是异步/等待的基础！我们几乎完成了我们的异步旅程，但这趟列车还有一站。所以，一旦你熟悉了你在这里学到的东西，就深入到Promise.all，学习如何优化多个承诺。</p><p id="fe99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家编码快乐，</p><p id="0240" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">麦克风</p></div></div>    
</body>
</html>