<html>
<head>
<title>Fixing Focus for Safari</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修复Safari的焦点</h1>
<blockquote>原文：<a href="https://itnext.io/fixing-focus-for-safari-b5916fef1064?source=collection_archive---------0-----------------------#2021-11-16">https://itnext.io/fixing-focus-for-safari-b5916fef1064?source=collection_archive---------0-----------------------#2021-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/8ea03c0f06125ec866e90677523d1ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*3GSQn-dUOvptidufLj6UfA.png"/></div></figure><p id="8c13" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">2008年，苹果的Safari团队遇到了一个问题:web开发人员注意到，当点击时，链接、按钮和几个输入元素与<code class="fe ks kt ku kv b">:focus</code>选择器不匹配。类似地，点击这些元素也不会触发<code class="fe ks kt ku kv b">focus</code>或<code class="fe ks kt ku kv b">focusin</code>事件。开发人员尽职尽责地提交了针对Webkit的<a class="ae kw" href="https://bugs.webkit.org/show_bug.cgi?id=22261" rel="noopener ugc nofollow" target="_blank">bug</a>并等待帮助。</p><p id="421e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种帮助从未到来。</p><p id="1967" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">原因是，macOS在被点击时没有将焦点转移到操作系统和应用程序按钮上，利益相关者决定与操作系统保持一致，而不是与竞争对手的浏览器保持一致。这种讨论已经持续了13年，现在仍在继续，但苹果的团队态度坚决:按钮、链接和非文本输入不会成为焦点。</p><p id="c889" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有益的是，团队同意一个变通方法是实现<code class="fe ks kt ku kv b">:focus-visible</code>，CSS选择器匹配等待输入的元素；它们被聚焦但没有被激活。单击一个按钮或链接既聚焦又激活它，但是进入它们将匹配这个仅聚焦选择器。这个<a class="ae kw" href="https://bugs.webkit.org/show_bug.cgi?id=185859" rel="noopener ugc nofollow" target="_blank">部分解决方案</a>确实会有所帮助，但它在2021年4月被搁置，在它被启动3年后，在它被提出11年后。</p><p id="d022" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这一失败已经开始滚雪球。Safari在2017年初推出了<code class="fe ks kt ku kv b">:focus-within</code>，用这种新标准化的伪选择器击败了大多数竞争对手。但是当点击按钮、链接或非文本输入时，它不会匹配任何容器。事实上，如果用户关注一个文本输入(为其容器匹配<code class="fe ks kt ku kv b">:focus-within</code>选择器),然后点击其中一个麻烦的元素，焦点就会完全离开容器。</p><blockquote class="kx ky kz"><p id="5aa9" class="ju jv la jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr ij bi translated"><strong class="jw ir">编辑(8/29/2022) <br/> </strong> Safari在15.4版本中已经实现了<code class="fe ks kt ku kv b">:focus-visible</code>。尽管如此，本文中描述的<code class="fe ks kt ku kv b">:focus</code>的错误仍然存在。单击任何有问题的元素都不会触发焦点事件，也不会匹配<code class="fe ks kt ku kv b">:focus</code>或<code class="fe ks kt ku kv b">:focus-within</code>选择器。</p></blockquote><p id="dd7b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">很明显，苹果的Webkit/Safari团队不会解决这个问题。WICG为<code class="fe ks kt ku kv b">:focus-visible</code>提供了一个优秀的<a class="ae kw" href="https://github.com/WICG/focus-visible/blob/main/src/focus-visible.js" rel="noopener ugc nofollow" target="_blank">聚合填充</a>。也有一个好的<a class="ae kw" href="https://github.com/matteobad/focus-within-polyfill/blob/master/src/focus-within.js" rel="noopener ugc nofollow" target="_blank">多孔填料</a>可供<code class="fe ks kt ku kv b">:focus-within</code>使用。但是我还没有为<code class="fe ks kt ku kv b">:focus</code>找到一个聚合填充，所以我写了一个:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><h2 id="f5ba" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kf lt lu lv kj lw lx ly kn lz ma mb mc bi translated">多填料分解</h2><p id="d40a" class="pw-post-body-paragraph ju jv iq jw b jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ij bi translated">这个polyfill的核心是调度<code class="fe ks kt ku kv b">focus</code>和<code class="fe ks kt ku kv b">focusin</code>事件的<code class="fe ks kt ku kv b">Element.focus()</code>方法调用(在上面要点的第112行)。一旦浏览器发现这些事件与一个元素相关联，这个元素就会匹配<code class="fe ks kt ku kv b">:focus</code>选择器。</p><p id="4bbe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有几个事件我们可以监听，以便在元素被单击时调度那个<code class="fe ks kt ku kv b">focus</code>事件:<code class="fe ks kt ku kv b">mousedown</code>、<code class="fe ks kt ku kv b">mouseup</code>和<code class="fe ks kt ku kv b">click</code>。</p><blockquote class="kx ky kz"><p id="b8ce" class="ju jv la jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr ij bi translated"><strong class="jw ir">事件说明</strong></p><p id="1f87" class="ju jv la jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr ij bi translated">如果您不熟悉事件在浏览器中的工作方式，有两个阶段。<strong class="jw ir">捕获</strong>阶段从最顶层的元素<code class="fe ks kt ku kv b">&lt;html&gt;</code>开始，并通过DOM向下到达被点击的元素。<strong class="jw ir">冒泡</strong>阶段在捕获阶段结束后开始，它从被点击的最下面的元素开始，向上(冒泡)到HTML元素。该路径中的任何节点都可以连接一个事件侦听器，当事件到达该节点时，该事件侦听器就会被触发。</p></blockquote><p id="0a5f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些事件侦听器中的任何一个都可以阻止事件继续，并为可能阻止它们触发的后续事件附加侦听器。这很重要。我们不希望其他事件侦听器阻止我们的侦听器触发。这意味着我们希望在捕获阶段附加到最早的事件<code class="fe ks kt ku kv b">mousedown</code>。这是在上面要点的第81行完成的。</p><p id="1a99" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，<code class="fe ks kt ku kv b">Element.focus()</code>同步触发，这意味着<code class="fe ks kt ku kv b">focus</code>和<code class="fe ks kt ku kv b">focusin</code>事件将在<code class="fe ks kt ku kv b">blur</code>和<code class="fe ks kt ku kv b">focusout</code>事件之前触发。事件的正确顺序是:</p><ol class=""><li id="a953" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated"><strong class="jw ir">鼠标按下</strong>【瞄准点击的元素】</li><li id="7294" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><strong class="jw ir">模糊</strong>【瞄准先前活动的元素】</li><li id="1db0" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><strong class="jw ir">聚焦</strong>【瞄准先前活动的元素】</li><li id="31f6" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><strong class="jw ir">聚焦</strong>【瞄准被点击的元素】</li><li id="5574" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><strong class="jw ir">聚焦</strong>【瞄准被点击的元素】</li><li id="4506" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><strong class="jw ir"> mouseup </strong>【瞄准被点击的元素】</li><li id="3f9a" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><strong class="jw ir">点击</strong>【针对被点击的元素】</li></ol><p id="d5da" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以使用一个零秒的<code class="fe ks kt ku kv b">setTimeout</code>调用(上面要点中的第56行)在所有当前排队的事件之后将<code class="fe ks kt ku kv b">Element.focus()</code>调用排队。这将我们的强制<code class="fe ks kt ku kv b">focus</code>事件移到了<code class="fe ks kt ku kv b">blur</code>和<code class="fe ks kt ku kv b">focusout</code>事件之后，但这也将其移到了<code class="fe ks kt ku kv b">mouseup</code>和<code class="fe ks kt ku kv b">click</code>事件之后，这并不理想。</p><p id="0af0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了确保<code class="fe ks kt ku kv b">mouseup</code>和<code class="fe ks kt ku kv b">click</code>事件在我们的强制<code class="fe ks kt ku kv b">focus</code>事件之后触发，我们需要捕获并重新发送它们。我们不想捕获每一个<code class="fe ks kt ku kv b">mouseup</code>和<code class="fe ks kt ku kv b">click</code>事件，所以我们只需要在我们要强制一个<code class="fe ks kt ku kv b">focus</code>事件时添加监听器(第41–42行),并在我们完成时移除它们(第58–59行)。最后，我们需要重新调度这些事件，使用与它们原来相同的数据，比如鼠标位置(第67行)。</p><p id="9fba" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们只需要在Safari中完成所有这些工作(见第80行),并且只在不支持的元素被点击时。<a class="ae kw" href="http://allyjs.io" rel="noopener ugc nofollow" target="_blank"> allyjs.io </a>的优秀人员提供了一个非常有用的<a class="ae kw" href="https://allyjs.io/tests/focusable/test.html" rel="noopener ugc nofollow" target="_blank">测试文档</a>，用于检查哪些元素得到了关注。在比较了在不同浏览器中单击这些元素的结果后，我发现以下元素需要此聚合填充:</p><ol class=""><li id="14e3" class="mi mj iq jw b jx jy kb kc kf mk kj ml kn mm kr mn mo mp mq bi translated">具有href属性的锚链接</li><li id="ee64" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">非禁用按钮</li><li id="0d06" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">非禁用文本区</li><li id="6d8e" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated"><code class="fe ks kt ku kv b">button</code>、<code class="fe ks kt ku kv b">reset</code>、<code class="fe ks kt ku kv b">checkbox</code>、<code class="fe ks kt ku kv b">radio</code>和<code class="fe ks kt ku kv b">submit</code>类型的非禁用输入</li><li id="c129" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">具有带数值的<code class="fe ks kt ku kv b">tabindex</code>的非交互元素(按钮、a、输入、文本区、选择)</li><li id="bc2f" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">音频元素</li><li id="d622" class="mi mj iq jw b jx mr kb ms kf mt kj mu kn mv kr mn mo mp mq bi translated">具有<code class="fe ks kt ku kv b">controls</code>属性的视频元素</li></ol><p id="6a14" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">功能<code class="fe ks kt ku kv b">isPolyfilledFocusEvent</code>(第22–36行)检查这些情况。</p><p id="ac88" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我希望这有所帮助。</p><p id="a29a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我希望Safari能在某个时候支持这种东西。</p><p id="112a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">编辑</strong>(2022年15月1日):polyfill的实际生产使用暴露了两个错误。首先，重新调度的事件应该从事件目标调度，而不是从文档调度。没有从之前的<code class="fe ks kt ku kv b">target</code>中触发的事件被剥夺了它们的<code class="fe ks kt ku kv b">target</code>属性，并且不会触发默认行为，比如在链接点击时导航。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5b710db3b1b65f239e75ca7f2b949e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*IG4-6GvYhWb5r2xoivsjnw.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">必须从事件的目标激发重新调度的事件，才能触发本机功能</figcaption></figure><p id="a44d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第二，捕捉可能的无序<code class="fe ks kt ku kv b">mouseup</code>和<code class="fe ks kt ku kv b">click</code>事件需要不同的处理方式。通过动态添加侦听器，它们将在polyfill运行后添加的任何侦听器之后添加。这意味着其他侦听器将在事件被捕获之前首先触发，然后在事件被重新调度时再次触发。解决方案是立即为<code class="fe ks kt ku kv b">mouseup</code>和<code class="fe ks kt ku kv b">click</code>添加polyfill的监听器，并切换<code class="fe ks kt ku kv b">capturing</code>标志的开和关，而不是附加和移除监听器。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1503c7fd939c5a6894458a2ef809aac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*NgqcOiXiqREkh35XBNgDSw.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">使用标志开始和结束捕获事件</figcaption></figure><figure class="le lf lg lh gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/7f2b582eb57b18da73743216b28c6378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*t_66FJQAS9NYVipJ8TiyNQ.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">立即添加侦听器，而不是动态添加</figcaption></figure><p id="f66a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">编辑</strong> (21/1/2022):更多的生产使用揭示了另一个bug。点击一个已经聚焦的元素应该<em class="la">而不是</em>触发另一个聚焦(或focusin)事件。但是，polyfill在每次单击或按下受影响的元素时都会盲目地触发一个焦点事件。为了防止这种情况发生，我们在继续多填充焦点行为之前，检查事件目标元素是否与文档的活动元素相同。</p><p id="08d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不在每次点击时触发焦点的一个副作用是，如果Safari确定目标元素不可聚焦，它会将焦点返回到body元素。为了停止这种情况，我们在mousedown处理程序上调用<code class="fe ks kt ku kv b">preventDefault()</code>。(我怎么知道这行得通呢？我没有。为了找出Safari何时以及如何将焦点转移到身体上，我们进行了一些反复试验。)</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/88555942995b77d1ffcc25cea3de8aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*s0VahO-bpAyMX50otwsh0g.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">检查目标是否已经对焦，并防止Safari对焦身体</figcaption></figure><p id="200b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">编辑</strong> (23/1/2022):点击标签元素应该将焦点重定向到标签元素。为了检测标签上发生的点击，我们有两种选择:(1)对于我们正在监听的每个<code class="fe ks kt ku kv b">mousedown</code>事件，我们可以沿着DOM树一直爬到body元素，看看事件是否在标签中的元素上触发，或者(2)在<code class="fe ks kt ku kv b">mousedown</code>事件之前检测指针何时在标签内。选项1可行，但代价很高，尤其是在大页面上。对于选项2，我们必须找到如何在触发<code class="fe ks kt ku kv b">mousedown</code>事件的之前检测用户是否在标签<em class="la">内。</em></p><p id="1028" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事件<code class="fe ks kt ku kv b">mouseenter</code>在<code class="fe ks kt ku kv b">mousedown</code>事件之前触发(甚至在触摸设备上！)并且它为<code class="fe ks kt ku kv b">mousedown</code>事件将要穿过的<em class="la">每个元素</em>触发。这意味着每个元素都有一个作为其目标的<code class="fe ks kt ku kv b">mouseenter</code>(和<code class="fe ks kt ku kv b">mouseleave</code>)事件。(因为我们使用委托监听器，我们不能依赖<code class="fe ks kt ku kv b">currentTarget</code>，因为它总是空的。)</p><p id="13b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们添加了一个函数，当用户在一个label元素中时，该函数获取重定向的焦点目标，我们使用该元素来检测它是否已经有了焦点，如果没有，就聚焦在它上面。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/37d739a03c9e27b16a265afe15808257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7i6l2iNUhVOTRlDes2WXfw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">对于标签元素上的鼠标进入和离开事件，找到关联的目标元素</figcaption></figure><p id="9a5d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">编辑</strong> (17/2/2022):我们需要考虑接受子元素的可聚焦元素中可能嵌套的子元素，例如按钮、锚标签或带有<code class="fe ks kt ku kv b">tabindex</code>属性的任意元素。因为我们正在遍历DOM寻找可聚焦的父元素，所以我们决定删除用于发现可聚焦的<code class="fe ks kt ku kv b">label</code>元素的<code class="fe ks kt ku kv b">mouseenter</code>和<code class="fe ks kt ku kv b">mouseleave</code>监听器，并将这个用例合并到新策略中。我们还在对属性<code class="fe ks kt ku kv b">tabindex</code>的检查中发现了一个错误:如果属性<em class="la">没有被显式设置，HTMLElement属性<code class="fe ks kt ku kv b">tabIndex</code>会报告一个值<code class="fe ks kt ku kv b">-1</code>。</em>解决方案是使用<code class="fe ks kt ku kv b">.getAttribute('tabindex')</code>来确定该值是否已被显式设置。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nj"><img src="../Images/aea4c3aa714c333e931363e16700ce16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgrpoLoASW9Qm35gJRzAiA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">获取可聚焦元素，即使它是mousedown目标元素的祖先或通过祖先中的标签连接</figcaption></figure></div></div>    
</body>
</html>