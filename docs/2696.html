<html>
<head>
<title>High Performance Web Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高性能Web应用</h1>
<blockquote>原文：<a href="https://itnext.io/high-performance-web-apps-2a469cfd3550?source=collection_archive---------1-----------------------#2019-07-13">https://itnext.io/high-performance-web-apps-2a469cfd3550?source=collection_archive---------1-----------------------#2019-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2f250a305347c319045aa7a66e8af746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9XeDjUzUwoR04mKRyyIEg.png"/></div></div></figure><div class=""/><blockquote class="kb"><p id="3019" class="kc kd je bd ke kf kg kh ki kj kk kl dk translated">更重并不意味着更多的等待— <a class="ae km" href="https://twitter.com/scottjehl" rel="noopener ugc nofollow" target="_blank"> @scottjehl </a></p></blockquote><p id="44c1" class="pw-post-body-paragraph kn ko je kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj kl im bi translated">当我们为web构建时，我们都意识到我们应该多小心，不要给我们的用户提供太多的JavaScript和CSS。我们发送的越多，我们的网络应用程序可能会越慢。</p><p id="cff6" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">所以思维模式通常是“总是发送尽可能少的代码”。这很好，代码越少越好。更少的下载时间，更少的处理时间，更少的绘画时间，更少的在屏幕上显示内容的时间！</p><p id="bffd" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">但是，比尽可能将我们的网络应用压缩为一个整体更重要的是，理解我们的浏览器从消费HTML、CSS和JavaScript并将其转化为屏幕上的像素的旅程——这是<strong class="kp jf">的关键呈现路径(<em class="lp"> CRP </em>)。</strong></p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/37b2a30c81e7aed24b746595cac3e3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4pwW12rmZmFaRED_Z1xEVg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">渲染与渐进式渲染</figcaption></figure><p id="d0dd" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">优化<strong class="kp jf"> <em class="lp"> CRP </em> </strong>与减少关键资源和以非阻塞方式下载非关键资源息息相关，以便获得更好的页面加载时间。</p><p id="8a7f" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">由于加载不是一个单一的时刻，加载过程中有多个阶段需要跟踪，以便我们衡量我们的web应用程序有多快或多慢。这些是:</p><ul class=""><li id="0959" class="lz ma je kp b kq lk ku ll ky mb lc mc lg md kl me mf mg mh bi translated">用户第一次在屏幕上看到<strong class="kp jf">什么东西</strong>是什么时候？— <a class="ae km" href="https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint" rel="noopener ugc nofollow" target="_blank"> FCP </a></li><li id="a31f" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated">用户什么时候第一次在屏幕上看到有意义的东西？— <a class="ae km" href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint?utm_source=lighthouse&amp;utm_medium=devtools" rel="noopener ugc nofollow" target="_blank"> FMP </a></li><li id="e1ef" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated">用户何时能够与<strong class="kp jf">交互</strong>？— <a class="ae km" href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" rel="noopener ugc nofollow" target="_blank"> TTI </a></li></ul><p id="b2f3" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">有几种不同的策略来改进这些时间表指标，但由于没有“一刀切”的解决方案，因此理解<strong class="kp jf"> <em class="lp"> CRP </em> </strong>是定义更适合我们问题的策略的基础。</p><h1 id="501d" class="mn mo je bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">关键渲染路径</h1><p id="bc3a" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated">下图包含了<strong class="kp jf"> <em class="lp"> CRP </em> </strong>的所有要点。从执行请求的那一刻起，我们收到第一个字节(<a class="ae km" href="https://developers.google.com/web/tools/chrome-devtools/network/understanding-resource-timing" rel="noopener ugc nofollow" target="_blank"> TTFB </a>):</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/65c311dfaa78541468c564384891ce20.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*seccVaJHf2yvr9PPQVqCfg.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">关键渲染路径</figcaption></figure><ol class=""><li id="8f7a" class="lz ma je kp b kq lk ku ll ky mb lc mc lg md kl nr mf mg mh bi translated">首先，抓取HTML并开始构建<a class="ae km" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model#document_object_model_dom" rel="noopener ugc nofollow" target="_blank"> DOM </a>，包含关于<strong class="kp jf">要呈现什么</strong>内容的所有信息；</li><li id="1398" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl nr mf mg mh bi translated">接下来，一旦获取了CSS，就构建<a class="ae km" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model#css_object_model_cssom" rel="noopener ugc nofollow" target="_blank"> CSSOM </a>，保存与<strong class="kp jf">如何在屏幕上呈现内容相关的所有内容；</strong></li><li id="88dc" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl nr mf mg mh bi translated">然后，将这两者结合起来，构建包含内容和样式信息的<a class="ae km" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" rel="noopener ugc nofollow" target="_blank">渲染树</a>。</li><li id="0d1c" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl nr mf mg mh bi translated">然后，是布局。在这个阶段，我们知道了内容和样式，但是还缺少一样东西，计算每个元素在设备的<a class="ae km" href="https://developers.google.com/web/fundamentals/design-and-ux/responsive/#set-the-viewport" rel="noopener ugc nofollow" target="_blank">视窗</a>中的准确位置和大小——这是<a class="ae km" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" rel="noopener ugc nofollow" target="_blank">布局</a>的职责。</li><li id="24c4" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl nr mf mg mh bi translated">最后，当布局完成时，<a class="ae km" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" rel="noopener ugc nofollow" target="_blank"> Paint </a>事件被触发，将渲染树转换成屏幕上的像素。</li></ol><p id="9e6f" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">注意，我们没有涉及JavaScript。在此之前，让我们只考虑HTML和CSS来练习一下。</p><h2 id="8d4c" class="ns mo je bd mp nt nu dn mt nv nw dp mx ky nx ny nb lc nz oa nf lg ob oc nj od bi translated">CSS和CRP</h2><p id="c85d" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated">在下面的代码片段中，我们有一个HTML文档，其中包含一些带有页面框架的标记、一个CSS资源和一些文本。</p><figure class="lr ls lt lu gt iv"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8668" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">当用户第一次导航到URL并收到响应时，DOM开始逐步构建<strong class="kp jf"/>。然后，找到<code class="fe og oh oi oj b">&lt;link&gt;</code>标签，执行新的HTTP请求，同时DOM仍继续构建，然后，当带有CSS的HTTP响应到达时，构建CSSOM，直到它完成<strong class="kp jf">，屏幕上没有呈现</strong>。一旦完成，我们就有了渲染树，布局，最后是屏幕上的像素！</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/b0999ca5984e89ebef4cdc4d5a5e28bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NnJoppBzy9NsmNAxEENIg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">CRP步骤</figcaption></figure><p id="b74b" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">这就是为什么我们把CSS定义为一个<strong class="kp jf">渲染阻塞资源</strong>，因为没有CSSOM就没有渲染树，没有渲染树就没有渲染。</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/cf1b899e29230aee36f460b194fe0d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rRoj1c5MqGXpmMCnGTnsiw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">渲染树</figcaption></figure><p id="334e" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">但是为什么CSS渲染是阻塞的而HTML不是呢？基本上是因为DOM可以渐进地构建，而CSSOM不能，这是由于CSS的“级联”性质。虽然在DOM中没有节点可以影响其他节点，但在CSS中，规则可以影响其他节点，例如:</p><pre class="lr ls lt lu gt om oj on oo aw op bi"><span id="d790" class="ns mo je oj b gy oq or l os ot">span { color: yellow; }<br/>...<br/>p span { color: ; red } // thousands of lines below</span></pre><p id="1a5b" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">假设CSSOM是逐步构建的，因此是以非阻塞的方式构建的。一种可能的情况是:</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/b89e73c71fd1805f36c78ceb459756af.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*4cKmFyKU2DTIoiMSD2UbRA.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">CSSOM</figcaption></figure><ul class=""><li id="1b70" class="lz ma je kp b kq lk ku ll ky mb lc mc lg md kl me mf mg mh bi translated">第一次渲染—仍然没有CSS，所以让我们渲染没有样式的内容；</li><li id="59b1" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated">第二次渲染CSS的第一部分到达(<code class="fe og oh oi oj b">span { color: yellow; }</code>)，所以让我们把所有的<code class="fe og oh oi oj b">span</code>都涂成黄色；</li><li id="8786" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated">第三次渲染——块n X到达(<code class="fe og oh oi oj b">p span { color: red; }</code>——层叠发生)，所以让我们把所有的<code class="fe og oh oi oj b">span</code>重新涂成红色；</li></ul><p id="38a0" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">除了由于多次重画元素而导致的一些性能问题之外，这些元素甚至可能不在页面上(由于像<code class="fe og oh oi oj b">display: "none"</code>这样的规则)，这将给用户提供非常差的体验。</p><p id="4f10" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">这就是为什么CSS是渲染阻塞的原因，所以一定要保证<strong class="kp jf"> CSS倾斜</strong>，尽可能快地交付，使用<code class="fe og oh oi oj b"><a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link" rel="noopener ugc nofollow" target="_blank">media</a></code> <a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link" rel="noopener ugc nofollow" target="_blank"> <strong class="kp jf">属性</strong> </a>和<strong class="kp jf">查询</strong>来解除阻塞渲染。</p><pre class="lr ls lt lu gt om oj on oo aw op bi"><span id="ed7c" class="ns mo je oj b gy oq or l os ot">&lt;link href="desktop.css" media="screen and (min-width: 600px)"  rel="stylesheet"&gt;</span></pre><p id="7f24" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">至于HTML，由于DOM是增量构建的，我们可以使用<a class="ae km" href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web" rel="noopener ugc nofollow" target="_blank"> <strong class="kp jf"> SSR </strong> </a>技术以及<strong class="kp jf">渐进式渲染</strong>尽可能快地以<strong class="kp jf">块</strong>的形式交付<strong class="kp jf"> HTML </strong>，提供类似谷歌搜索引擎的体验:</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/636ee720ad98c66e58f8d762057a6c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/1*vI93HzYzehq5CN4-2-Z0kQ.gif"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">谷歌搜索渐进式渲染</figcaption></figure><h2 id="220a" class="ns mo je bd mp nt nu dn mt nv nw dp mx ky nx ny nb lc nz oa nf lg ob oc nj od bi translated">JavaScript和CRP</h2><p id="c2ca" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated">现在，在这个片段中，我们有一个包含一些内联JavaScript而没有CSS资源的文档。一个简单的页面，脚本标记将更改应用到屏幕上显示的内容。</p><figure class="lr ls lt lu gt iv"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="50f6" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">在这种情况下，DOM开始逐步构建，直到找到<code class="fe og oh oi oj b">&lt;script&gt;</code>标签。一旦完成，<strong class="kp jf"> DOM构造被暂停</strong>，以便<strong class="kp jf"> JavaScript </strong>运行<strong class="kp jf">，修改DOM。之后，<strong class="kp jf"> DOM </strong>构造<strong class="kp jf">恢复</strong>并且屏幕上有渲染。</strong></p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/b48c509a89862d6c91edae38c6bb2b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC3ldlLQHoQruHXXOlw_JA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">CRP步骤—带JS</figcaption></figure><p id="b008" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">JavaScript执行得相当快，看起来这并没有对<strong class="kp jf"> CRP </strong>造成太大影响。在处理如上所示的非常简单的内联脚本时，这可能是正确的。但是对于外部依赖，DOM构造将被阻塞，直到HTTP请求被解析并且产生的JS运行，并且该请求可能需要一段时间…</p><p id="bf60" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">因此，内联CSS和JS是改善页面加载时间的一个好策略，但也只能达到足够的程度。这将有助于减少HTTP请求，但另一方面，如果在不同的页面上重复使用，您可能会多次下载相同的代码块。这将是一个很好的机会来提取和下载它作为一个外部资源，受益于缓存。记住，最快的请求，是永远不会实现的请求。</p><p id="34ca" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">一个好的做法是避免内联1kb以上的资源<a class="ae km" href="https://v8.dev/blog/cost-of-javascript-2019" rel="noopener ugc nofollow" target="_blank">并从那里开始提取，引入缓存策略。</a></p><h2 id="d679" class="ns mo je bd mp nt nu dn mt nv nw dp mx ky nx ny nb lc nz oa nf lg ob oc nj od bi translated">JavaScript、CSS和CRP</h2><p id="18da" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated">现在，一个既有CSS又有JavaScript的网页。作为外部资源的CSS和修改某些内容和样式的内嵌<code class="fe og oh oi oj b">script</code>标签。</p><figure class="lr ls lt lu gt iv"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3f50" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">这一次，在DOM构造过程中，发现了<code class="fe og oh oi oj b">&lt;link&gt;</code>标记，并触发了一个HTTP请求，同时DOM构造仍在继续。然后找到了<code class="fe og oh oi oj b">&lt;script&gt;</code>标签，但是这一次浏览器<strong class="kp jf">还不能执行JavaScript】，因为它可以操作DOM和/或CSSOM(在这种情况下，它两者都操作),所以浏览器需要<strong class="kp jf">首先等待CSSOM被构建</strong>,这将取决于HTTP响应。一旦获取了CSS并构建了CSSOM，浏览器就会执行JavaScript，并且不再阻塞<strong class="kp jf"> DOM </strong>构造<strong class="kp jf"/>。然后恢复，最后在屏幕上有一个渲染。</strong></p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/403da9fa1a1aa66de34e5eb48648e313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nxl-O4_dRwNVbcc_hdTRSg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">CRP步骤—同时考虑JS和CSS</figcaption></figure><p id="cdb2" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated"><strong class="kp jf"> CSS不仅会阻止渲染，还会阻止脚本执行</strong>，这就是优化CSS如此重要的原因。</p><p id="9f99" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">有些脚本既不改变DOM也不改变CSSOM，其中大部分可能不会被阻塞。非阻塞脚本的一个很好的例子是分析。一旦页面被加载，分析脚本是异步加载的很好的候选者，我们可以使用<code class="fe og oh oi oj b"><a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#Properties" rel="noopener ugc nofollow" target="_blank">async</a></code> <a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#Properties" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe og oh oi oj b"><a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#Properties" rel="noopener ugc nofollow" target="_blank">defer</a></code> <a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#Properties" rel="noopener ugc nofollow" target="_blank">标签</a>来实现。</p><pre class="lr ls lt lu gt om oj on oo aw op bi"><span id="74d1" class="ns mo je oj b gy oq or l os ot">&lt;script src="/analytics.js" async /&gt;</span></pre><p id="38aa" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">稍后会详细介绍。</p><h2 id="8095" class="ns mo je bd mp nt nu dn mt nv nw dp mx ky nx ny nb lc nz oa nf lg ob oc nj od bi translated">包裹</h2><p id="57ec" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated">我们刚刚讨论了<strong class="kp jf">关键渲染路径</strong>以及JS和CSS资源如何影响页面负载。我们略微涉及了一些提高页面加载性能的基本策略，但是在讨论页面加载性能时，还需要记住更多的东西。</p><p id="15ad" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">既然我们已经记住了浏览器从使用HTML、CSS和JavaScript到在屏幕上呈现内容的基本步骤，我们应该更清楚地了解什么技术最适合我们的问题以及如何应用。</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><h1 id="503a" class="mn mo je bd mp mq pe ms mt mu pf mw mx my pg na nb nc ph ne nf ng pi ni nj nk bi translated">优化关键渲染路径</h1><p id="b33b" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated">如前所述，关于优化策略没有金科玉律。但是我们应该记住一些优化CRP的一般策略。</p><p id="ef6d" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">这些被称为<strong class="kp jf"> 3个优化桶</strong>:</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/074a12fe8ba65f6337a63d518bfafa07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GV3fntF3XbI6AMNjF376AA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">大量的优化</figcaption></figure><ul class=""><li id="34cb" class="lz ma je kp b kq lk ku ll ky mb lc mc lg md kl me mf mg mh bi translated"><strong class="kp jf">最小化字节</strong>:最小化、压缩和缓存JS、CSS和HTML</li><li id="4768" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated"><strong class="kp jf">减少关键资源</strong>:最小化渲染和解析器阻塞资源的使用</li><li id="fe28" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated"><strong class="kp jf">缩短CRP长度</strong>:最大限度减少往返次数——CRP长度是关键资源与其字节大小之间的依赖关系图的函数:某些资源下载只能在处理完之前的资源后启动，资源越大，下载的往返次数就越多。(<a class="ae km" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path" rel="noopener ugc nofollow" target="_blank">由<a class="pk pl ep" href="https://medium.com/u/2578f746f852?source=post_page-----2a469cfd3550--------------------------------" rel="noopener" target="_blank">伊利亚·格里戈利克</a>优化关键渲染路径</a></li></ul><h2 id="9f55" class="ns mo je bd mp nt nu dn mt nv nw dp mx ky nx ny nb lc nz oa nf lg ob oc nj od bi translated"><strong class="ak">最小化字节</strong></h2><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/36600863aca34df9ef9b228a67de963a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*DnBDHmUDWcAepx3_Eo6Hxw.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">文件和HTTP响应压缩</figcaption></figure><ul class=""><li id="c6c7" class="lz ma je kp b kq lk ku ll ky mb lc mc lg md kl me mf mg mh bi translated">尽可能发布不太重要的代码，并且总是缩小、压缩和缓存它们。</li><li id="a59a" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated">使用像<a class="ae km" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>这样的工具在<a class="ae km" href="https://webpack.js.org/configuration/mode/#mode-production" rel="noopener ugc nofollow" target="_blank">生产模式</a>中缩小你的包，并应用<a class="ae km" href="https://webpack.js.org/guides/code-splitting/#root" rel="noopener ugc nofollow" target="_blank">代码分割</a>，这样你就可以以阻塞的方式下载关键的程序块，并推迟非关键的程序块。</li><li id="d67d" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated">利用现代浏览器的模块(<code class="fe og oh oi oj b">&lt;script type="module" src="/module.js"&gt;</code>)来下载包含更紧凑或优化语法的包，从而减少字节数。</li><li id="5905" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated">使用来自<a class="ae km" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> babel </a>的<a class="ae km" href="https://github.com/browserslist/browserslist" rel="noopener ugc nofollow" target="_blank"> browserslist </a> <a class="ae km" href="https://github.com/browserslist/browserslist" rel="noopener ugc nofollow" target="_blank">、</a> <a class="ae km" href="https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md" rel="noopener ugc nofollow" target="_blank"> core-js </a>和<a class="ae km" href="https://babeljs.io/docs/en/babel-preset-env#usebuiltins" rel="noopener ugc nofollow" target="_blank"> usebuiltIns </a>等工具，使用特定于每个浏览器的transpiled bundles和polyffills。</li><li id="404f" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated">使用像Brotli或Gzip这样的算法在你的网络服务器中应用文件压缩。</li></ul><h2 id="784b" class="ns mo je bd mp nt nu dn mt nv nw dp mx ky nx ny nb lc nz oa nf lg ob oc nj od bi translated"><strong class="ak">减少关键资源</strong></h2><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/f523574be65b4b1b41e898e087838884.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*6cngmoJVZJRpwPVHsjCZ-g.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">阻塞与非阻塞脚本</figcaption></figure><ul class=""><li id="ad02" class="lz ma je kp b kq lk ku ll ky mb lc mc lg md kl me mf mg mh bi translated">内联关键CSS，最大限度地减少阻塞渲染和脚本执行。</li><li id="fb44" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated">使用对<code class="fe og oh oi oj b">link</code>标签的媒体查询来推迟不适合您的目标的CSS(<a class="ae km" href="https://developer.mozilla.org/pt-BR/docs/Web/Guide/CSS/CSS_Media_queries" rel="noopener ugc nofollow" target="_blank">媒体类型或尺寸</a>)。</li><li id="54fa" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated">使用<code class="fe og oh oi oj b">script</code>标签上的<code class="fe og oh oi oj b">async</code>和<code class="fe og oh oi oj b">defer</code>属性，以非阻塞方式下载非关键资源。</li><li id="96f4" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated"><code class="fe og oh oi oj b">preload</code>、<code class="fe og oh oi oj b">prefetch</code>和<code class="fe og oh oi oj b">preconnect</code>脚本，您的用户在应用程序内的旅程中可能需要这些脚本。这将防止您的用户在需要时等待这些资源(当<a class="ae km" href="https://webpack.js.org/guides/lazy-loading/" rel="noopener ugc nofollow" target="_blank">延迟加载</a>时尤其有用)。</li></ul><h2 id="2c19" class="ns mo je bd mp nt nu dn mt nv nw dp mx ky nx ny nb lc nz oa nf lg ob oc nj od bi translated"><strong class="ak">缩短</strong> <a class="ae km" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> CRP长度</strong> </a></h2><p id="70dc" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated">这在很大程度上取决于你的应用程序所使用的HTTP版本。</p><blockquote class="po pp pq"><p id="938d" class="kn ko lp kp b kq lk ks kt ku ll kw kx pr lm la lb ps ln le lf pt lo li lj kl im bi translated">“HTTP/2通过支持请求和响应多路复用、报头压缩和优先级排序，能够更有效地利用网络资源并减少延迟”——<a class="ae km" href="https://hpbn.co/" rel="noopener ugc nofollow" target="_blank">高性能浏览器网络</a></p></blockquote><p id="06a4" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">也就是说，始终支持HTTP/2来交付您的应用程序。但是如果你不能，在使用HTTP/1时有一些“变通方法”可以应用。</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pu"><img src="../Images/0b227215fc7cadf843639119736d5cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KGl0O_cANmxtzygrzqt3A.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">网络请求往返</figcaption></figure><p id="2d99" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated"><a class="ae km" href="https://hpbn.co/optimizing-application-delivery/#optimizing-for-http1x" rel="noopener ugc nofollow" target="_blank"> <strong class="kp jf">为HTTP/1.x优化</strong> </a> <strong class="kp jf"> : </strong></p><ul class=""><li id="f5b0" class="lz ma je kp b kq lk ku ll ky mb lc mc lg md kl me mf mg mh bi translated">应用<a class="ae km" href="https://hpbn.co/http1x/#domain-sharding" rel="noopener ugc nofollow" target="_blank">域分片</a>。</li><li id="6a28" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated"><a class="ae km" href="https://hpbn.co/http1x/#concatenation-and-spriting" rel="noopener ugc nofollow" target="_blank">捆绑资源</a>以减少HTTP请求并避免与有限的<a class="ae km" href="https://hpbn.co/http1x/#using-multiple-tcp-connections" rel="noopener ugc nofollow" target="_blank">并行性</a>相关的问题。</li><li id="ac07" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated"><a class="ae km" href="https://hpbn.co/http1x/#resource-inlining" rel="noopener ugc nofollow" target="_blank">内联小型资源</a>(高达1kb)以最大限度地减少请求数量</li></ul><p id="711d" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated"><a class="ae km" href="https://hpbn.co/optimizing-application-delivery/#optimizing-for-http2" rel="noopener ugc nofollow" target="_blank"> <strong class="kp jf">为HTTP/2优化</strong> </a> <strong class="kp jf"> : </strong></p><ul class=""><li id="2b6f" class="lz ma je kp b kq lk ku ll ky mb lc mc lg md kl me mf mg mh bi translated">消除域分片，减少来源数量— <a class="ae km" href="https://hpbn.co/http2/#request-and-response-multiplexing" rel="noopener ugc nofollow" target="_blank">多路复用</a>。</li><li id="eaf1" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated"><a class="ae km" href="https://hpbn.co/optimizing-application-delivery/#minimize-concatenation-and-image-spriting" rel="noopener ugc nofollow" target="_blank">最小化拼接和图像显示</a></li><li id="63cb" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated"><a class="ae km" href="https://hpbn.co/optimizing-application-delivery/#eliminate-roundtrips-with-server-push" rel="noopener ugc nofollow" target="_blank">通过服务器推送消除往返</a></li></ul></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><h1 id="e617" class="mn mo je bd mp mq pe ms mt mu pf mw mx my pg na nb nc ph ne nf ng pi ni nj nk bi translated">你不能优化你不能测量的东西</h1><p id="7148" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated">没有度量，就很难知道你的web应用程序的主要痛点是什么，以及如何解决它们。</p><p id="7d2c" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">所以，正如<a class="pk pl ep" href="https://medium.com/u/2508e4c7a8ec?source=post_page-----2a469cfd3550--------------------------------" rel="noopener" target="_blank"> Addy Osmani </a>在《<a class="ae km" href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4" rel="noopener">2018年JavaScript的成本</a>》中提到的:</p><blockquote class="po pp pq"><p id="c079" class="kn ko lp kp b kq lk ks kt ku ll kw kx pr lm la lb ps ln le lf pt lo li lj kl im bi translated">测量、优化、监控和重复</p></blockquote><h2 id="7c6a" class="ns mo je bd mp nt nu dn mt nv nw dp mx ky nx ny nb lc nz oa nf lg ob oc nj od bi translated">开始绩效预算</h2><p id="8870" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated">衡量CI/CD管道的性能，根据里程碑、数量和规则定义预算— <strong class="kp jf">实验室测试</strong>。</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pv"><img src="../Images/82007dfb3b9077586432356a0d6d0182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IC4S03j8ADbIJv57Dz_Frg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">实验室测试—绩效预算</figcaption></figure><p id="3fb5" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">使用性能预算来防止您的站点性能随着时间的推移而退化。这将有助于你在早期阶段，在它到达你的用户之前，对你的web应用性能有一个清晰的认识。</p><p id="6062" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">预算可以基于:</p><ul class=""><li id="4c62" class="lz ma je kp b kq lk ku ll ky mb lc mc lg md kl me mf mg mh bi translated"><strong class="kp jf">里程碑计时:</strong>基于用户加载页面体验的计时(例如<a class="ae km" href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" rel="noopener ugc nofollow" target="_blank"> TTI </a>、<a class="ae km" href="https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint" rel="noopener ugc nofollow" target="_blank"> FCP </a>和<a class="ae km" href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint?utm_source=lighthouse&amp;utm_medium=devtools" rel="noopener ugc nofollow" target="_blank"> FMP </a>)。</li><li id="55d8" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated"><strong class="kp jf">数量指标:</strong>基于原始值(例如，JavaScript的权重(KB/MB)，HTTP请求的数量)</li><li id="dd9b" class="lz ma je kp b kq mi ku mj ky mk lc ml lg mm kl me mf mg mh bi translated"><strong class="kp jf">基于规则的度量:</strong>由Lighthouse或WebPageTest等工具生成的分数。通常，一个单一的数字或系列来评分你的网站</li></ul><p id="9083" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">有几个工具可以帮你做这个预算，比如<a class="ae km" href="https://webpack.js.org" rel="noopener ugc nofollow" target="_blank"> webpack </a>的<a class="ae km" href="https://webpack.js.org/configuration/performance/" rel="noopener ugc nofollow" target="_blank"> Performance API </a>、<a class="ae km" href="https://www.npmjs.com/package/bundlesize" rel="noopener ugc nofollow" target="_blank"> bundlesize </a>、<a class="ae km" href="https://developers.google.com/web/tools/lighthouse/" rel="noopener ugc nofollow" target="_blank"> Lighthouse </a>、<a class="ae km" href="https://webpagetest.org/" rel="noopener ugc nofollow" target="_blank"> WebPageTest </a>等等。</p><h2 id="1109" class="ns mo je bd mp nt nu dn mt nv nw dp mx ky nx ny nb lc nz oa nf lg ob oc nj od bi translated">开始性能监控</h2><p id="dcb1" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated">绩效预算将帮助您跟踪和执行您的绩效限制。您可以应用最适合实际使用场景的节流来执行这些测量。<br/>但是为了跟踪你的web app在现实世界中的影响，你应该实现<strong class="kp jf">真实使用监控</strong> ( <strong class="kp jf"> RUM </strong>)。</p><p id="4370" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">一些可以帮助你获得这些实际使用指标的服务有<a class="ae km" href="https://calibreapp.com/" rel="noopener ugc nofollow" target="_blank"> Calibre </a>、<a class="ae km" href="https://treo.sh/a/addyosmani/3" rel="noopener ugc nofollow" target="_blank"> Treo </a>、<a class="ae km" href="https://webdash.xyz/" rel="noopener ugc nofollow" target="_blank"> Webdash </a>、<a class="ae km" href="https://speedcurve.com/about/" rel="noopener ugc nofollow" target="_blank"> SpeedCurve </a>等等。</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><p id="5995" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">希望您现在对浏览器如何处理您的web应用程序资产以及它如何影响页面加载时间有了更好的理解。优化性能的一般“经验法则”是什么，如何确保团队满足您的性能预算，以及它如何通过RUM影响现实世界中的用户。</p><p id="061f" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">这是一个非常简单的概述，因为根据项目状态和目标，这些主题会变得非常密集。根据这一点，并根据您的目标受众，确定您的绩效战略，开始实施，测量，完善和始终监测。</p><p id="2e5f" class="pw-post-body-paragraph kn ko je kp b kq lk ks kt ku ll kw kx ky lm la lb lc ln le lf lg lo li lj kl im bi translated">表演更多时候是一种文化挑战，而不是技术挑战。</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><h1 id="2e05" class="mn mo je bd mp mq pe ms mt mu pf mw mx my pg na nb nc ph ne nf ng pi ni nj nk bi translated">参考</h1><p id="2677" class="pw-post-body-paragraph kn ko je kp b kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj kl im bi translated"><a class="ae km" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/" rel="noopener ugc nofollow" target="_blank">关键渲染路径</a> <br/> <a class="ae km" href="https://developers.google.com/web/tools/lighthouse/" rel="noopener ugc nofollow" target="_blank">灯塔</a><br/><a class="ae km" href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4" rel="noopener">JavaScript的成本</a> <br/> <a class="ae km" href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics#time_to_interactive" rel="noopener ugc nofollow" target="_blank">以用户为中心的性能指标</a><br/><a class="ae km" href="https://www.filamentgroup.com/lab/weight-wait.html" rel="noopener ugc nofollow" target="_blank">更重不代表更等</a><br/><a class="ae km" href="https://v8.dev/blog/cost-of-javascript-2019" rel="noopener ugc nofollow" target="_blank">2019年JavaScript的成本</a> <br/> <a class="ae km" href="https://hpbn.co" rel="noopener ugc nofollow" target="_blank">高性能浏览器联网</a></p></div></div>    
</body>
</html>