<html>
<head>
<title>Class Diagram to convey the Delegate Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">传达委托模式的类图</h1>
<blockquote>原文：<a href="https://itnext.io/class-diagram-to-convey-the-delegate-pattern-bca0a8b28d2d?source=collection_archive---------3-----------------------#2019-11-28">https://itnext.io/class-diagram-to-convey-the-delegate-pattern-bca0a8b28d2d?source=collection_archive---------3-----------------------#2019-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6169" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类图是学习设计模式的先决条件</h2></div><p id="6fa2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<em class="le">类图</em>是UML(统一建模语言)的简化版本，帮助我们获得软件项目的蓝图。在类图的帮助下，我们可以很容易地理解每个组件是如何相互关联的，从而使我们能够将软件修改到更易于维护的地方。例如，我们总是希望避免依赖链，这样我们的类就可以很容易地改变。</p><p id="1379" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们直接从最常见的设计模式之一——带有UITableView示例的委托模式——来学习类图。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="lk ll l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/8394cc4202bffd25849baa47e0ddf425.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*u9zt-acs0EBWj6sQIrNqpA.png"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lp"><img src="../Images/9952f6e6d49f8a865e13168b773c6329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNq1Vasjwr0icRyJOTW9Hw.png"/></div></div></figure><p id="6a7a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，不同的箭头代表四种类型的关系。</p><ul class=""><li id="2bc3" class="lu lv it kk b kl km ko kp kr lw kv lx kz ly ld lz ma mb mc bi translated">“是一个”代表“继承自”。例如UITableView是一个UIScrollView。</li><li id="5341" class="lu lv it kk b kl md ko me kr mf kv mg kz mh ld lz ma mb mc bi translated">“有一个”是表示一个属性。例如，ViewController有一个tableView。</li><li id="65b1" class="lu lv it kk b kl md ko me kr mf kv mg kz mh ld lz ma mb mc bi translated">“实现”代表“符合”。例如，ViewController符合UITableViewDataSource。</li><li id="abe4" class="lu lv it kk b kl md ko me kr mf kv mg kz mh ld lz ma mb mc bi translated">“uses”可以替换为“delegates to”，这是UML形式中的“dependency”。例如，tableView使用UITableViewDataSource。</li></ul><h2 id="84f1" class="mi mj it bd mk ml mm dn mn mo mp dp mq kr mr ms mt kv mu mv mw kz mx my mz na bi translated">代表模式</h2><p id="3ec7" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">这种模式可以分解大型类，创建通用的、可重用的组件。在UITableView示例中，UITableView是一个可重用的组件，可以帮助我们分解UIViewControllers。代理模式有如下三个主要角色。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ng"><img src="../Images/1005805401bc6aa53b7b73d27e3bbcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lBioozJxWESmxVSKcWEtg.png"/></div></div></figure><ul class=""><li id="7ae2" class="lu lv it kk b kl km ko kp kr lw kv lx kz ly ld lz ma mb mc bi translated"><strong class="kk iu">委托对象</strong>:即<em class="le">拥有</em> <code class="fe nh ni nj nk b">weak var delegate</code>的对象。例如UITableView</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nl"><img src="../Images/87a9ff10933f268ec9e14ce726ae1625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ywv6yaukunUWMz06csrfA.png"/></div></div></figure><p id="457e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe nh ni nj nk b">UITableView</code>和<code class="fe nh ni nj nk b">UIViewController</code>是引用类型，容易导致保留循环。因此，<strong class="kk iu">我们应该在我们的委托对象</strong>中将委托声明为弱var。</p><ul class=""><li id="3327" class="lu lv it kk b kl km ko kp kr lw kv lx kz ly ld lz ma mb mc bi translated"><strong class="kk iu">委托协议</strong>:委托人和委托对象之间的接口；它定义了委托应该实现什么，以及委托对象可以调用什么方法。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nm"><img src="../Images/ef9a061e5e31b6ee7e2832e6ccf7f709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Qpc2-AiKGBEDBx7fGymwQ.png"/></div></div></figure><p id="dbba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么协议方法传递tableView？这样，如果需要，ViewContoller可以方便地检查tableView。因此，<strong class="kk iu">在协议方法</strong>中传递委托对象成了惯例。</p><ul class=""><li id="52e6" class="lu lv it kk b kl km ko kp kr lw kv lx kz ly ld lz ma mb mc bi translated"><strong class="kk iu">委托</strong>:符合委托并实现方法的对象。</li></ul><h2 id="0581" class="mi mj it bd mk ml mm dn mn mo mp dp mq kr mr ms mt kv mu mv mw kz mx my mz na bi translated">要点</h2><ul class=""><li id="d7cd" class="lu lv it kk b kl nb ko nc kr nn kv no kz np ld lz ma mb mc bi translated">使用类图来帮助您获得软件的蓝图并获得可维护性。</li><li id="d734" class="lu lv it kk b kl md ko me kr mf kv mg kz mh ld lz ma mb mc bi translated">委托模式非常适合分解大型类和创建通用的、可重用的组件。</li><li id="f7f2" class="lu lv it kk b kl md ko me kr mf kv mg kz mh ld lz ma mb mc bi translated">委托模式有三个主要部分:委托对象、协议和委托。</li><li id="83e1" class="lu lv it kk b kl md ko me kr mf kv mg kz mh ld lz ma mb mc bi translated">使用委托模式时要注意保持循环。</li></ul></div></div>    
</body>
</html>