<html>
<head>
<title>A little bit of code [C++20 Ranges]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一点代码[C++20范围]</h1>
<blockquote>原文：<a href="https://itnext.io/a-little-bit-of-code-c-20-ranges-c6a6f7eae401?source=collection_archive---------2-----------------------#2019-12-26">https://itnext.io/a-little-bit-of-code-c-20-ranges-c6a6f7eae401?source=collection_archive---------2-----------------------#2019-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b3b3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍C++20的一个期待已久的特性:范围。</h2></div><p id="9a99" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">C++20即将推出，它有很多很酷的特性，其中之一是<strong class="kh ir"> ranges </strong>库。在本文中，我旨在展示它所带来的优雅语法背后的力量。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/0e63cb0ca9d9ef97da5f1da449c8f297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24aIMTjaaQVIf2jBTcnbFw.png"/></div></div></figure><h1 id="7bc7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">放弃</h1><ol class=""><li id="a29b" class="mf mg iq kh b ki mh kl mi ko mj ks mk kw ml la mm mn mo mp bi translated">代码示例中使用的库并不是真正的C++20 ranges，而是Eric Niebler的<a class="ae mq" href="https://github.com/ericniebler/range-v3" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> ranges-v3 </strong> </a>开源库，这是向C++添加<strong class="kh ir"> ranges </strong>的提议的基础。这是一个与C++11/14/17兼容的只有头文件的库。</li><li id="e2da" class="mf mg iq kh b ki mr kl ms ko mt ks mu kw mv la mm mn mo mp bi translated">本文中的代码纯粹是实验性的，并不真正关心干净性和可读性。</li></ol><h1 id="b532" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">C++中的函数式编程</h1><p id="653c" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">函数式编程(以下简称FP)是C++支持的编程范例之一。然而，与其他函数式语言相比，它并不是很舒服。然而，有了C++这样一个锐利而强大的工具，你可以自由地创建自己的东西。这正是<strong class="kh ir"> ranges-v3 </strong>的作用。该库最好的部分是它提供的Unix管道语法。这提高了可读性，使我们有更少的代码，从而更少的错误。这只是FP的优点之一:对于更深入的知识，我强烈推荐这本书——《c++中的函数式编程》。</p><h1 id="9824" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">范围-v3</h1><p id="df1d" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">在了解这个库带来了什么之前，让我们快速回顾一下我们拥有什么。我们有STL，在它的容器中，有算法，有迭代器的抽象层次，使算法能够与这些容器一起工作，还有一些函子。</p><p id="c03f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">范围库提供了以下功能:</p><ol class=""><li id="e7dd" class="mf mg iq kh b ki kj kl km ko mz ks na kw nb la mm mn mo mp bi translated">范围——任何类似范围的东西的包装器，例如容器、初始化列表、懒惰的类似范围的对象。</li><li id="1cca" class="mf mg iq kh b ki mr kl ms ko mt ks mu kw mv la mm mn mo mp bi translated">算法——或多或少与STL提供的算法集相同，只是这些算法适用于范围。</li><li id="58e4" class="mf mg iq kh b ki mr kl ms ko mt ks mu kw mv la mm mn mo mp bi translated">动作——修改底层范围的对象，如<em class="nc">排序</em>。</li><li id="c667" class="mf mg iq kh b ki mr kl ms ko mt ks mu kw mv la mm mn mo mp bi translated">视图——懒惰对象，其行为类似于范围或包装实际对象，如<em class="nc">过滤器</em>。</li></ol><p id="db8f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在进入代码之前，让我们更深入地研究一下<strong class="kh ir">视图</strong>。它们的意义在于它们是真正新颖和懒惰的东西，因此效率很高。考虑这个伪代码:</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="94fa" class="ni lo iq ne b gy nj nk l nl nm">ContainerT container = { ... };<br/>auto widgets = container<br/>               | views::filter(...)<br/>               | views::transform(...)<br/>               | views::take(10);</span></pre><p id="bcef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一个场景，您有一个包含用户对象的大容器，并且您想</p><ol class=""><li id="fdad" class="mf mg iq kh b ki kj kl km ko mz ks na kw nb la mm mn mo mp bi translated">选择那些符合特定标准的</li><li id="ae4f" class="mf mg iq kh b ki mr kl ms ko mt ks mu kw mv la mm mn mo mp bi translated">从每个用户对象创建一个小部件</li><li id="0428" class="mf mg iq kh b ki mr kl ms ko mt ks mu kw mv la mm mn mo mp bi translated">仅取前10个部件</li></ol><p id="69f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最直接的方法是简单地完成所有这些步骤，这可能非常低效(考虑到容器非常大，我们只需要结果的前10个)。但是当我们对视图做同样的事情时，它们的懒惰使它变得非常高效。在上面的伪代码中，什么也没有发生，我们只是创建了一个视图，一个其他视图的组合。它的行为就像一个范围，也就是说，我们可以迭代它。一旦我们开始迭代，动作就开始了:</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="1044" class="ni lo iq ne b gy nj nk l nl nm">for (auto widget: widgets) {<br/>    /* ... */<br/>}</span></pre><p id="3632" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np ne b">widgets</code>将向<code class="fe nn no np ne b">views::take</code>请求下一个小部件，而后者将依次向<code class="fe nn no np ne b">views::transform</code>请求一个小部件，但只有10次。<code class="fe nn no np ne b">views::transform</code>然后会向<code class="fe nn no np ne b">views::filter</code>请求下一个<code class="fe nn no np ne b">user</code>来创建一个小部件。<code class="fe nn no np ne b">views::filter</code>将继续从底层真实容器中请求下一个<code class="fe nn no np ne b">user</code>，直到满足其条件。对于一堆难看且容易出错的嵌套循环来说，这也是可能的。另外，请记住<code class="fe nn no np ne b">container</code>实际上是一个范围，也就是说，它可以是一个真正的容器、一个流或者仅仅是另一个视图。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="7f6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个想法是为了证明音域将会使语言变得多么强大。因此，我将展示两段解决一些现实问题的代码，尽量保持代码尽可能短，尽可能多地使用ranges-v3库。</p><h2 id="8898" class="ni lo iq bd lp nx ny dn lt nz oa dp lx ko ob oc lz ks od oe mb kw of og md oh bi translated">打印n个最常用的单词</h2><p id="cb84" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">这个问题是我在<strong class="kh ir">“c++”中的函数式编程</strong>这本书里碰到的。故事讲述，早在1986年，<a class="ae mq" href="https://en.wikipedia.org/wiki/Donald_Knuth" rel="noopener ugc nofollow" target="_blank"> Donald Knuth </a>被要求为一份杂志实现一个代码。问题陈述如下:</p><blockquote class="oi oj ok"><p id="4754" class="kf kg nc kh b ki kj jr kk kl km ju kn ol kp kq kr om kt ku kv on kx ky kz la ij bi translated">读取一个文本文件，确定最常用的单词，并打印出这些单词的排序列表以及它们的频率。</p></blockquote><p id="6b05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Knuth提出了一个10页长的Pascal实现。作为回应，<a class="ae mq" href="https://en.wikipedia.org/wiki/Douglas_McIlroy" rel="noopener ugc nofollow" target="_blank">道格·麦克洛伊</a>写了一个UNIX shell脚本来解决同样的问题，它有这么长:</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="4a6d" class="ni lo iq ne b gy nj nk l nl nm">tr -cs A-Za-z '\n' |<br/>    tr A-Z a-z |<br/>    sort |<br/>    uniq -c |<br/>    sort -rn |<br/>    sed ${1}q</span></pre><p id="91b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个故事是这篇文章的主要动机，所以我决定从同一个问题开始。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oo"><img src="../Images/3a9c41255359c734b66d0d206cc9137d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MeodwsJIGwSKAH1ozc1Ig.png"/></div></div></figure><p id="b5e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它比麦克洛伊的解决方案要长，但仍然很短，你可以不用滚动就能写出来。让我们一行一行地来看看它是如何工作的。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oo"><img src="../Images/cfed1705f7e99a67363ee292a3cd961e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Wsh49RLWrKURBc84_EYcA.png"/></div></div></figure><p id="4d54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用库中的动作和视图，因此包括。<code class="fe nn no np ne b">is_alpha</code>是一个非常简单的函数，它检查字符是否是字母。该程序基本上需要两个输入，(a)我们希望看到的最常用单词的数量，我们将作为命令行参数提供，以及(b)文本，我们将通过标准输入(<code class="fe nn no np ne b">std::cin</code>)输入。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oo"><img src="../Images/ffb595aaf6b47b9987fa7675cac4d7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFMp8Dt2G6m1a3LL_s8ppw.png"/></div></div></figure><p id="c5c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一节从一个<code class="fe nn no np ne b">istream_view</code>开始，它是来自标准输入的<code class="fe nn no np ne b">std::string</code>的惰性容器。对于这些<em class="nc">单词中的每一个</em>，我们都做了如下的转换:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi op"><img src="../Images/02186e5778cc9c0b89161458c27c19dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*So3aPphnJmVrWqAF-mK7SQ.png"/></div></div></figure><p id="4262" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe nn no np ne b">views::all</code>，我们将<code class="fe nn no np ne b">word</code>视为<code class="fe nn no np ne b">char</code> s的容器。<code class="fe nn no np ne b">views::trim</code>是另一个惰性视图，它过滤掉容器开头和结尾不满足谓词的字符。这里的谓词是上面定义的<code class="fe nn no np ne b">is_alpha</code>函数的否定(<code class="fe nn no np ne b">not_fn</code>)。<code class="fe nn no np ne b">views::transform</code>将每个字符转换为小写。最后，我们将结果转换回一个<code class="fe nn no np ne b">string</code>。</p><p id="c2dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，<code class="fe nn no np ne b">views::transform</code>期望一个函数将一个值作为输入并返回一些其他的值，不一定是相同的类型。</p><p id="21ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种转换之后，我们最终得到了一个由修整过的小写单词组成的<em class="nc">惰性容器</em>。修剪可能会导致空词。<code class="fe nn no np ne b">views::filter</code>接受一个布尔谓词，在本例中，它检查<code class="fe nn no np ne b">string</code>的空性，并过滤掉那些空性。接下来<code class="fe nn no np ne b">to_vector</code>(或<code class="fe nn no np ne b">to&lt;std::vector&gt;</code>)创建这些单词的实际容器，原因是后面的<code class="fe nn no np ne b">actions::sort</code>。显然它对容器进行了排序，但是需要注意的是<code class="fe nn no np ne b">sort</code>是一个<strong class="kh ir">动作</strong>，而不是一个<strong class="kh ir">视图</strong>。这是因为它必须围绕实际容器中的元素移动，而视图无论如何都不会影响源范围。</p><p id="d7a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe nn no np ne b">sorted_words</code>是一个经过修剪的小写字符串的排序向量。对于lorem-ipsum输入，前100个元素如下所示:</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="3350" class="ni lo iq ne b gy nj nk l nl nm">[a,a,a,a,a,a,a,a,a,a,ac,ac,ac,ac,ac,ac,ac,ac,ac,ac,ac,accumsan,accumsan,accumsan,accumsan,adipiscing,adipiscing,adipiscing,adipiscing,adipiscing,adipiscing,adipiscing,aenean,aenean,aenean,aenean,aliquam,aliquam,aliquam,aliquam,aliquam,aliquam,aliquam,aliquam,aliquam,aliquam,aliquet,aliquet,aliquet,aliquet,aliquet,aliquet,aliquet,aliquet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,amet,ante,ante,arcu,arcu,arcu,arcu,arcu,arcu,arcu,arcu,arcu,arcu,arcu,at,at,at,at,at,at,at,at,at,at,at,at,at]</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oo"><img src="../Images/0da16b7898d5c20caa53514699b2429d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e6dUnuriJ28YjFQ11w5W8A.png"/></div></div></figure><p id="77ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np ne b">views::group_by</code>将<code class="fe nn no np ne b">sorted_words</code>分割成一系列连续重复的元素(因为有了<code class="fe nn no np ne b">std::equal</code>)。然后我们把这些组中的每一组都转换成一对长度(<code class="fe nn no np ne b">distance(group)</code>)和它的第一个元素。到目前为止，我们有这样的东西:</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="abda" class="ni lo iq ne b gy nj nk l nl nm">[ {10, "a"}, {11, "ac"}, {4, "accumsan"} ... ]</span></pre><p id="ae3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剩下的唯一事情就是按照它们的<code class="fe nn no np ne b">first</code>对它们进行排序。我们可以利用默认的小于运算符<code class="fe nn no np ne b">std::pair</code>，简单地将所有内容放入一个multimap中。因此，我们将对它们进行升序排序。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oo"><img src="../Images/4e7442144f99bec9c1c6bc62c4c0c581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BfLTvadM-r343PQGYo3FvQ.png"/></div></div></figure><p id="ea3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要第<em class="nc"> n </em>个最常用的单词，因此需要最后的第<em class="nc"> n </em>个元素。为此，我们只需从multimap上的<strong class="kh ir"> reverse </strong>视图中取出第一个<em class="nc"> n </em>元素。</p><blockquote class="oi oj ok"><p id="493c" class="kf kg nc kh b ki kj jr kk kl km ju kn ol kp kq kr om kt ku kv on kx ky kz la ij bi translated">注意:这个库也提供了一个<code class="fe nn no np ne b">views::take_last</code>视图，但是它和<code class="fe nn no np ne b">| reverse | take</code>不一样。</p></blockquote><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="6503" class="ni lo iq ne b gy nj nk l nl nm">std::vector vec = { 1, 2, 3, 4, 5, 6 };<br/>auto tl_view = vec | views::take_last(3);             // [ 4, 5, 6 ]<br/>auto rt_view = vec | views::reverse | views::take(3); // [ 6, 5, 4 ]</span></pre><h2 id="05ba" class="ni lo iq bd lp nx ny dn lt nz oa dp lx ko ob oc lz ks od oe mb kw of og md oh bi translated">打印日历</h2><p id="e605" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">下一个问题是编写一个程序来打印给定年份的日历。这个想法来自埃里克·尼布勒的CppCon演讲，他是T21系列v3的创造者。不同的是我试图让代码尽可能的短。</p><blockquote class="oi oj ok"><p id="0656" class="kf kg nc kh b ki kj jr kk kl km ju kn ol kp kq kr om kt ku kv on kx ky kz la ij bi translated">同样，这个代码只有一个演示和认知的目的。否则，它充满了不良做法。</p></blockquote><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oq"><img src="../Images/638bc8619d7207341f32bed2007859ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nLwkTDOxMnhmMR8FICCJg.png"/></div></div></figure><p id="de62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们定义两个非常基本的函数:<code class="fe nn no np ne b">is_leap</code>如果给定年份是闰年，则返回true，<code class="fe nn no np ne b">first_weekday_of</code>返回给定年份的[0–6]范围内的整数，即该年1月1日的工作日(0表示星期日)。这些是打印日历的充分必要条件。</p><p id="36bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个有趣的部分如下:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oq"><img src="../Images/b0c57f2f1795f3135b1e1992960d5dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_UK0_i-jG8cydr5X8P18Tw.png"/></div></div></figure><p id="b7c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顾名思义，我们希望有一个由12个整数组成的数组来表示每月的天数。我们可以像<code class="fe nn no np ne b">month_names</code>一样简单地初始化这些值，但是不要忘记我们为什么在这里:享受范围的乐趣。还记得<a class="ae mq" href="https://en.wikipedia.org/wiki/Knuckle_mnemonic" rel="noopener ugc nofollow" target="_blank">用指关节的把戏</a>吗？</p><p id="abcd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们创建一个视图，用<code class="fe nn no np ne b">views::ints(1, 8)</code>来计算1到7，即左手指关节和指关节之间凹陷的数量。然后我们把它们连续地分成1和0。使用<code class="fe nn no np ne b">views::cycle</code>,我们让视图无限重复，模仿握住右手。然后我们取前12个值，因为我们需要这么多。然后我们再把它们加30。最后，我们根据当年的<em class="nc">leap</em>来解决二月份的案例。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi or"><img src="../Images/6e357285f495dd5f70bbe28ebef43a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_VCFxqdOIP1UJ2MRc_bdQ.png"/></div></div></figure><p id="adb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道了每个月的天数和一年的第一个工作日，我们可以计算每个月的第一个工作日。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oq"><img src="../Images/72906b2f89f628e398fcc2009f6aca17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AjmGBkKStVeHnlm96POjAA.png"/></div></div></figure><p id="4aca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能看起来有点复杂，但这只是简单的计数。这里唯一有趣的视图是<code class="fe nn no np ne b">partial_sum</code>，它产生一个同样大小的新范围，其中第<em class="nc"> n </em>个元素是将给定的二元函数(本例中为<code class="fe nn no np ne b">std::plus</code>)应用到源范围的第<em class="nc"> n </em>个元素和结果范围的第<em class="nc"> (n-1) </em>个元素的结果。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi os"><img src="../Images/cf85858c870cacef4b3ab109d35acc9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dH4V6o1PCnrZrkVpcM1H1g.png"/></div></div></figure><p id="26ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们从二月开始得到每个月的第一个工作日。至于一月，我们已经有了它，事实上，我们在最后一个<code class="fe nn no np ne b">transform</code>视图中使用它来计算其余的，所以我们只是在<code class="fe nn no np ne b">concat</code>视图的帮助下将它添加到这个视图中，这样我们就有了<code class="fe nn no np ne b">first_weekdays_per_month</code>。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oq"><img src="../Images/b67251c0e13bfd2c7c49780e46853140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Itwq5LLHBZ5ZV4n3QUtz-Q.png"/></div></div></figure><p id="60a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们遍历月份并打印每个月份的日历。<code class="fe nn no np ne b">views::zip</code>将三个大小为12的范围作为输入，并返回一个由12个元组组成的单一范围，每个元组由3个值组成—当月的<code class="fe nn no np ne b">month_name</code>、<code class="fe nn no np ne b">days</code>号和当月的<code class="fe nn no np ne b">first_weekday</code>:</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="b0ff" class="ni lo iq ne b gy nj nk l nl nm">[ ("January", 31, 2), ("February", 28, 5), ("March", 31, 5) ... ]</span></pre><p id="e38c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们打印每月的标题和第一周的填充(无聊的格式化的东西)。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oq"><img src="../Images/efb549881fbc4b531448d89786e39c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*paBa5jmGRWTVQ7rJ-uHN1A.png"/></div></div></figure><p id="e0e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一部分生成一个月中的周。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oq"><img src="../Images/044d3faed6432bcf0e66c187dfe796e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0KGCqFiD_zcqHfXjrimEg.png"/></div></div></figure><p id="0e5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np ne b">views::zip</code>拉链分为两个系列:</p><ol class=""><li id="d5dc" class="mf mg iq kh b ki kj kl km ko mz ks na kw nb la mm mn mo mp bi translated"><code class="fe nn no np ne b">views::ints(1, days + 1)</code>生成一个月中的第几天，1到<code class="fe nn no np ne b">days</code>包括在内。</li><li id="7145" class="mf mg iq kh b ki mr kl ms ko mt ks mu kw mv la mm mn mo mp bi translated">第二个<code class="fe nn no np ne b">views::ints</code>从该月的第一个工作日开始进行相同的计数，这与<code class="fe nn no np ne b">transform</code>视图相结合，产生了相同大小的工作日圆圈。</li></ol><p id="e106" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果，我们得到这样的元组:</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="79f3" class="ni lo iq ne b gy nj nk l nl nm">[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 0), (7, 1) ... (31, 4)]</span></pre><p id="db16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个范围内，我们然后应用带有二元谓词的<code class="fe nn no np ne b">group_by</code>视图，当<em class="nc">新的一周开始时</em>该谓词返回false。</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="ffac" class="ni lo iq ne b gy nj nk l nl nm">[<br/>   [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]<br/>   [(6, 0), (7, 1), (8, 2), (9, 3), (10, 4), (11, 5), (12, 6)]<br/>   ...<br/>   [(27, 0), (28, 1), (29, 2), (30, 3), (31, 4)]<br/>]</span></pre><p id="3ccc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那里我们有我们的星期。剩下的就是对周进行迭代，对每一周的每一天进行迭代，并打印出来。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oq"><img src="../Images/b5eb513a1d08a9e8895bba25e1c0c330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nSSulGN-Ddhokz3Kmhoc9w.png"/></div></div></figure><p id="a416" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这么简单。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="7581" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如免责声明中所述，示例中的代码使用了<strong class="kh ir"> ranges-v3 </strong>库。这是一个只有头文件的库，所以你只需要克隆和包含就可以使用它了。我强烈建议试用一下，以适应新的语法，更深入地研究视图和动作，至少为C++20做好更好的准备。不幸的是，并不是这个库中的所有东西最终都会出现在该语言中。然而，<strong class="kh ir"> ranges-v3 </strong>是成熟的，维护良好，足以用于更多。</p></div></div>    
</body>
</html>