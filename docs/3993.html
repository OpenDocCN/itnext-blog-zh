<html>
<head>
<title>Step-by-Step guide for Flutter JSON Serialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter JSON序列化分步指南</h1>
<blockquote>原文：<a href="https://itnext.io/step-by-step-guide-for-flutter-json-serialization-fd5acd5e7521?source=collection_archive---------2-----------------------#2020-04-07">https://itnext.io/step-by-step-guide-for-flutter-json-serialization-fd5acd5e7521?source=collection_archive---------2-----------------------#2020-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/651f718154b641b5a0b6d4370c8497ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWHnNns9PbnjQtKoAsArxw.jpeg"/></div></div></figure><p id="e158" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前一段时间，我发布了一个视频教程，讲述我们如何<a class="ae kw" href="https://www.youtube.com/watch?v=hz2LQ43muio&amp;t=7s" rel="noopener ugc nofollow" target="_blank">创建一个基本的网络请求</a>。在这篇文章中，我们想看看如何用Flutter JSON序列化来改进这个解决方案。有了它，我们可以删除代码库中的许多字符串。</p><p id="fc82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还为这篇文章制作了一个视频，大家可以随意看看。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">网络请求中的JSON序列化程序</figcaption></figure><h1 id="b7fe" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">通用序列化</h1><p id="620d" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">序列化是计算机科学中将对象转换成可以保存在数据库中或通过网络请求发送的东西的过程。今天，我们希望转换从API接收的JSON字符串，并将其转换为对象的实例。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/0440b3532ffa6ef1f8f8b2c005331373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRujRuBevUWdOfprIDsF-w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">JSON到实例</figcaption></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/da8bff12333b3a57db35af94926e6286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Wz6fI3XyzwR-vplhV6Yqw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">JSON字符串到人</figcaption></figure><p id="ed32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了获得字符串形式的个人信息，我将在下面的例子中使用随机用户生成器。这可以生成随机的用户信息，并为我们提供一个API来接收JSON字符串。</p><h1 id="cd0f" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">基本网络请求—示例应用程序</h1><p id="9869" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">在<a class="ae kw" href="https://randomuser.me/" rel="noopener ugc nofollow" target="_blank"> RandomUserAPI </a>的帮助下，我创建了一个应用程序，只要我们打开它，它就会向我们显示用户列表。在视频中，我们一起为<a class="ae kw" href="https://www.youtube.com/watch?v=hz2LQ43muio" rel="noopener ugc nofollow" target="_blank">的基本网络请求</a>创建了这个应用程序。在视频中，我们使用手动方法进行Flutter JSON序列化，而在这篇博客文章中，我们将其改为更加自动化的过程。</p><p id="9aaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你搜索这个项目和这篇文章的源代码，你会在这里找到一切<a class="ae kw" href="https://github.com/md-weber/network_request_tutorial" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/7e3c69f149fd172a7e8bb58a48090646.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/1*uog29sHlPyl_zWFhjMX5iw.gif"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Flutter中的用户滚动列表</figcaption></figure><h1 id="5b97" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">手动颤振JSON序列化</h1><p id="4f9f" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">为了更好地理解为什么我们应该更喜欢自动颤振JSON序列化，我们必须后退一步。为此，我们首先来看看手动序列化是如何精确工作的。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mm lc l"/></div></figure><p id="31b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码片段中，我们创建了一个从API接收的新的person对象。正如您可能已经看到的，我们必须将所有的键字符串写入类中，并且用API信息污染我们的类。此外，我们陷入了一个陷阱，如果我们想要添加或删除一个属性，我们必须全部改变它。</p><p id="1dc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得可维护性相当困难。尤其是当API发生变化，我们不得不从头开始创建时。这将导致大量的搜索和替换，我们将失去所有的IDE支持。</p><h1 id="4a97" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">利益</h1><ul class=""><li id="32b6" class="mn mo iq ka b kb mf kf mg kj mp kn mq kr mr kv ms mt mu mv bi translated">解决方案周围没有样板文件</li><li id="862a" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">不需要设置，所以您可以直接访问参数</li></ul><h1 id="dffb" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">不足之处</h1><ul class=""><li id="776f" class="mn mo iq ka b kb mf kf mg kj mp kn mq kr mr kv ms mt mu mv bi translated">你必须自己写每一行</li><li id="c273" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">打字错误可能会发生，并降低应用程序的稳定性</li><li id="434e" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">对于您想要添加、删除或修改的每个新字段，我们必须修改模型中的代码</li><li id="b097" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">较高的维护成本，尤其是对于较大的项目或不断变化的API</li></ul><h1 id="6db3" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">生成的序列化</h1><p id="d56c" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">现在我们已经了解了自写序列化的问题，让我们看看生成的Flutter JSON序列化。目前在Flutter框架中还没有一个内置的解决方案，但是在<a class="ae kw" href="https://pub.dev" rel="noopener ugc nofollow" target="_blank"> pub.dev </a>上有很多针对这个问题的完美包。在本文中，我们将仔细研究一下<a class="ae kw" href="https://pub.dev/packages/json_serializable" rel="noopener ugc nofollow" target="_blank"> json_serializable </a>包。</p><p id="9f91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该包与build_runner包一起工作，允许我们生成“fromJSON”和“toJSON”函数，而无需编写JSON的所有键。我们只需要正确地设置我们的模型，准确地注释它们，并在里面提供两个函数。但是话说够了，我们想看一些代码。</p><h1 id="1364" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">属国</h1><p id="0d50" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">在我们开始使用json_serializable包之前，我们必须首先在项目中添加一些依赖项。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mm lc l"/></div></figure><p id="7720" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">json_annotation是我们项目中唯一必须存在的依赖项。build_runner和json_serializable只是开发依赖项，不会成为最终捆绑包的一部分。</p><h1 id="bd2b" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">修改模型</h1><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mm lc l"/></div></figure><p id="8db6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第1行:使用<strong class="ka ir">部件‘person_model.g.dart’</strong>我们给PersonModel类访问person _ model . g . dart文件内部方法的可能性。稍后将从built _ runner中生成该文件。</p><p id="6ff1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第3行:<strong class="ka ir"> @JsonSerializable() </strong>注释告诉build_runner这个类必须关注新文件的生成和序列化的创建。</p><p id="9a3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第5 + 8行:对于JSON内部的对象，我们必须为NameModel和PictureModel创建它们的表示模型类。新模型也将使用<strong class="ka ir"> @JsonSerializable() </strong>进行注释，并将从第12行和第14行获得两个新方法。</p><p id="56a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第12行:来自Json的新<a class="ae kw" href="https://dart.dev/guides/language/language-tour#factory-constructors" rel="noopener ugc nofollow" target="_blank">工厂</a>构造函数接近我们的旧方法。但是我们没有创建PersonModel的新实例，而是调用了一个方法<strong class="ka ir">_ $ PersonModelFromJson(JSON)</strong>。这个方法将在后面借助built _ runner生成。</p><p id="59b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第14行:toJson方法按照预期返回一个Json(在Dart中是String和dynamic之间的映射)。为了接收映射，我们调用生成的函数<strong class="ka ir">_ $ PersonModelToJson(this)</strong>，并在内部传递当前实例。</p><h1 id="c5cd" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">释放内置跑步者的力量</h1><p id="f067" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">在我们成功地创建了带有必要注释和函数的模型之后，我们就可以开始使用built _ runner脚本了。我们在终端中打开项目，并执行以下命令之一。</p><pre class="kx ky kz la gt nb nc nd ne aw nf bi"><span id="c6ed" class="ng li iq nc b gy nh ni l nj nk">// Inside of Flutter projects<br/>// Generates the generate files once<br/>flutter pub run build_runner build</span><span id="c7db" class="ng li iq nc b gy nl ni l nj nk">// Watches the model files and generates on each change<br/>flutter pub run build_runner watch</span><span id="e437" class="ng li iq nc b gy nl ni l nj nk">// Inside of Dart projects<br/>// Generates the generate files once<br/>pub run build_runner build</span><span id="d543" class="ng li iq nc b gy nl ni l nj nk">// Watches the model files and generates on each change<br/>pub run build_runner watch</span></pre><p id="339e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于您有一个常规dart项目的情况，我还添加了创建一致的Dart包的命令。此命令将为您创建附加的*.g.dart文件。这些文件可以插入到。gitignore，因为团队中的每个人都可以执行这个命令。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b23ee164a9a9858dac6cfaa4cbc815bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/0*jchNilOgRa3We0wl.png"/></div></figure><p id="1ea0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更深入地了解一下电子监管生成的文件。这里您可以看到我们在分部类的fromJson和toJson中调用的两个函数。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mm lc l"/></div></figure><p id="e099" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是我们必须事先在这些方法中创建的所有字符串。多亏了built _ runner，他们现在为我们生成了。如果您看一下第18行，您可以看到甚至子模型都是正确生成的。如果我们现在改变了类中的一些东西，并再次执行构建运行器(或者让它监视)，那么我们将会看到它是如何被自动添加到列表中的。</p><h1 id="81e9" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">利益</h1><ul class=""><li id="b294" class="mn mo iq ka b kb mf kf mg kj mp kn mq kr mr kv ms mt mu mv bi translated">对该类的修改会立即反映出来</li><li id="0388" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">由于编写的代码更少，维护更少</li><li id="16e4" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">类型通过属性直接设置</li><li id="8ecb" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">没有奇迹发生，生成的文件在项目中</li></ul><h1 id="23a6" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">不足之处</h1><ul class=""><li id="9b3e" class="mn mo iq ka b kb mf kf mg kj mp kn mq kr mr kv ms mt mu mv bi translated">初始设置增加</li><li id="7f33" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">这里涉及到一些样板文件</li><li id="9108" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">您必须确保团队中的每个人都知道build_runner函数(可能的解决方案是一个脚本或一个好的readme.md文件)</li><li id="895b" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">生成的文件可能会偏离真实的模型文件</li></ul><h1 id="eb10" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Flutter JSON序列化的包</h1><p id="585a" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">有几个其他的包可以用来生成JSON序列化。</p><h2 id="9dc5" class="ng li iq bd lj nn no dn ln np nq dp lr kj nr ns lv kn nt nu lz kr nv nw md nx bi translated"><a class="ae kw" href="https://pub.dev/packages/built_value" rel="noopener ugc nofollow" target="_blank">建_值</a> / <a class="ae kw" href="https://pub.dev/packages/built_collection" rel="noopener ugc nofollow" target="_blank">建_集</a></h2><p id="3a2d" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">built _ value或built _ collection可以像我们在json_serializable中一样处理JSON序列化。但是增加了有益的功能，如不变性、可比性和其他生活质量功能。</p><h2 id="1441" class="ng li iq bd lj nn no dn ln np nq dp lr kj nr ns lv kn nt nu lz kr nv nw md nx bi translated"><a class="ae kw" href="https://pub.dev/packages/dart_json" rel="noopener ugc nofollow" target="_blank"> dart_json </a></h2><p id="920c" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">dart_json的好处是它绝对不依赖于任何东西。如果你寻找一个依赖尽可能少的解决方案，这个包是你最好的选择。</p><h2 id="cbf2" class="ng li iq bd lj nn no dn ln np nq dp lr kj nr ns lv kn nt nu lz kr nv nw md nx bi translated"><a class="ae kw" href="https://app.quicktype.io?share=Dxzba5UONSYqWKLpCbog" rel="noopener ugc nofollow" target="_blank"> JSON Web解析器</a></h2><p id="68fa" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">有一些JSON Web解析器可以从JSON中为您创建一个有效的dart模型。您可以将一个JSON复制到左侧，将右侧的模型复制到您的应用程序中。</p><h1 id="4a65" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="920a" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">JSON序列化是一个至关重要的主题，主要是当您处理大量的外部请求和不同的API时，这些API会不时地改变它们的契约。这些应该会带来更高的生产力，这样我们就可以更容易地实现重要的功能。</p><p id="6ae1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在twitter上做了一个投票，看看目前哪个框架使用得最多，但看起来两者非常接近。我的建议是看一看每个包/解决方案，然后使用最适合您需求的一个。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ny lc l"/></div></figure><p id="1cb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读，保持好奇。</p></div></div>    
</body>
</html>