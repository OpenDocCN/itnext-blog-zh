<html>
<head>
<title>Demystifying JSON.Parse()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘JSON。解析()</h1>
<blockquote>原文：<a href="https://itnext.io/demystifying-json-parse-383bb4907d79?source=collection_archive---------3-----------------------#2022-09-08">https://itnext.io/demystifying-json-parse-383bb4907d79?source=collection_archive---------3-----------------------#2022-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7ab23eb5a0ed04396a714cdde433ddef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OCswbM4NlCQ_mW8R"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卡里姆·甘图斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">软件工程的一个迷人的方面是将文本文件中的一系列字符转换成一组可以在CPU上执行的指令，以产生有意义的结果。对于一个阅读代码的人来说，期望的结果是很明显的(嗯，也许不那么明显，<a class="ae kc" href="http://www.jsfuck.com/" rel="noopener ugc nofollow" target="_blank">取决于语言</a>)。</p><p id="d435" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为人们的思维已经发展到能够有效地将一连串的字符组织成有意义的组，这些组以有意义的顺序出现。这是使人们能够交流和回应的东西，也是一种经常被认为是理所当然的活动。</p><p id="7ed2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这完全是计算机的另一个故事。他们没有自动构建内容的心理过程，这些内容可以用来指导他们的操作；一串字符就是一串字符。为了让它成为别的东西，必须教会计算机如何理解它。</p><p id="3dc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不是一项困难的任务(至少不再是了，这要感谢在这一领域开拓创新的前几代计算机科学家和工程师)，软件工程师每天用来解决问题的多种编程语言、文件格式和反序列化数据的方法证明了这一点。任何工程师都可以参与添加一种编程语言或一种文件格式或一种序列化技术。唯一真正的先决条件是具备一些文本解析的知识和经验。</p><h1 id="608c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从语法上分析</h1><p id="dce8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">解析本质上是将一系列字符(或者更一般地说，一系列位)转换成结构化数据。出于本文的目的，它将被用来处理字符，尽管像文件格式这样的东西处理位。</p><p id="7490" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单地说，将字符串转换成有结构和有意义的东西的过程有两个步骤:</p><ol class=""><li id="f600" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">词法分析:单个字符的流被转换成记号流(<em class="mn">即</em>，分组字符)</li><li id="83cc" class="me mf iq kf b kg mo kk mp ko mq ks mr kw ms la mj mk ml mm bi translated">语法分析:标记流被转换成一个抽象语法树(一种数据结构，它表达了文本中标记之间的关系，也可以记录关于它们的重要元数据)</li></ol><p id="5751" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，解析只是更大努力的第一步。例如，将Golang文件编译成可执行文件的第一步需要进行解析，但还需要做更多的工作，进一步将AST转换成CPU指令。</p><p id="86d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管最终结果如何，任何成功的解析阶段都需要指定一个<a class="ae kc" href="https://en.wikipedia.org/wiki/Formal_grammar" rel="noopener ugc nofollow" target="_blank">形式语法</a>。这是一个人类可读的规范，解释了什么是相关的令牌以及它们应该出现的顺序。</p><p id="cd5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最简单的形式是，语法可以被描述为一套重写字符串的规则。某些字符串可以根据其他字符串重写，而有些字符串不能再重写，它们分别被称为非终结符和终结符。在词汇阶段识别的记号包括该语法的终结符号集，该终结符号集进一步包括其非终结符号集(在非终结符号与终结符号之间存在一对多的关系)。</p><p id="5355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算器可以用来解析数学表达式的简单语法示例如下</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="59e3" class="nc lc iq my b gy nd ne l nf ng">EXPRESSION<br/>    : EXPRESSION '+' EXPRESSION<br/>    | EXPRESSION '-' EXPRESSION<br/>    | EXPRESSION '*' EXPRESSION<br/>    | EXPRESSION '/' EXPRESSION<br/>    | number<br/>    ;</span></pre><p id="6a51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(这实际上是一个糟糕的语法，原因超出了本文的范围；它仅用于说明稍后将使用的表单类型。)</p><p id="12bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个语法指定了终端符号<code class="fe nh ni nj my b">+</code>、<code class="fe nh ni nj my b">-</code>、<code class="fe nh ni nj my b">*</code>、<code class="fe nh ni nj my b">/</code>和<code class="fe nh ni nj my b">number</code>，并指出它们可以用五种不同的方式组织——其中四种允许递归组织。举个例子，<code class="fe nh ni nj my b">EXPRESSION '+' EXPRESSION</code>可以扩展为<code class="fe nh ni nj my b">EXPRESSION '+' EXPRESSION '-' EXPRESSION</code>。这允许用非常少的规则来表达复杂的令牌组。在这种语法下，像<code class="fe nh ni nj my b">12 + 41 * 3</code>这样的标准算术表达式可以通过以下重写匹配为一个表达式:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="de12" class="nc lc iq my b gy nd ne l nf ng">   EXPRESSION '+' EXPRESSION (rewrite the rightmost EXPRESSION)<br/>-&gt; EXPRESSION '+' EXPRESSION * EXPRESSION<br/>-&gt; number '+' number '*' number</span></pre><p id="0122" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解析是如何发生的，语法是如何被用来识别一个有效的数学表达式，这是本文的主要焦点。有两种主要的解析方法:<a class="ae kc" href="https://en.wikipedia.org/wiki/Comparison_of_parser_generators" rel="noopener ugc nofollow" target="_blank">使用众多解析器生成器库中的一个</a>(实现了成熟的解析算法)，或者手工编写一个。使用生成器可以从开发人员那里抽象出大量的工作，对于复杂的情况非常有用，但是当试图理解这个过程是如何工作的时候，最好还是手工编写一个解析器。</p><p id="9a05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，本文将为JavaScript开发人员每天使用的东西创建一个解析器:JSON。到本文结束时，将会有一个工作版本的<code class="fe nh ni nj my b">JSON.parse</code>方法，它探索了将JSON文本转换成JavaScript值时必须采取的路径和必须做出的决策。</p><h1 id="3ba9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解析JSON (lite)</h1><p id="64fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了在本文的其余部分保持词汇的一致性，“解析”将被理解为将非结构化字符串转换为结构化数据的整个过程。解析将由标记化步骤(词法分析)和紧随其后的(语法)分析步骤组成。</p><h2 id="2fd7" class="nc lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated">语法</h2><p id="bab8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了搭建标记器和分析器，将给出一个精确的语法来表达要解析的JSON。这种语法不会读取匹配完整JSON规范的所有可能的字符串；这样做将需要钻研细节，并偏离广泛理解解析管道的更高层次的目标。</p><p id="2abe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JSON字符串可以表示的值可能是字符串、数字、布尔值、空值以及对象和数组(两者都可以包含任意数量的JSON值)。这给了语法最重要的规则:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="42c9" class="nc lc iq my b gy nd ne l nf ng">JSON<br/>    : JSON_STRING<br/>    | number<br/>    | null<br/>    | JSON_BOOL<br/>    | JSON_ARRAY<br/>    | JSON_OBJECT<br/>    ;</span></pre><p id="507b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本语法中用于命名符号的约定如下:</p><ul class=""><li id="43af" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la nv mk ml mm bi translated">非终结符将全部大写</li><li id="bcd2" class="me mf iq kf b kg mo kk mp ko mq ks mr kw ms la nv mk ml mm bi translated">代表一类字符的终端符号将全部小写</li><li id="69a9" class="me mf iq kf b kg mo kk mp ko mq ks mr kw ms la nv mk ml mm bi translated">表示文字字符的终止符号将被写在单引号之间</li></ul><p id="a8fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了完整起见，这个语法的四个非终结符需要指定它们的规则。</p><p id="23da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JSON中的字符串可以是两个引号之间的任何内容。数组将是两个方括号之间的任何JSON值的逗号分隔列表。对象将是一个逗号分隔的列表，在花括号之间是键/值对。这将语法扩展为以下内容:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4ba7" class="nc lc iq my b gy nd ne l nf ng">JSON<br/>    : JSON_STRING<br/>    | number<br/>    | null<br/>    | JSON_BOOL<br/>    | JSON_ARRAY<br/>    | JSON_OBJECT<br/>    ;</span><span id="9b92" class="nc lc iq my b gy nw ne l nf ng">JSON_STRING<br/>    : '"' string '"'<br/>    ;</span><span id="60cb" class="nc lc iq my b gy nw ne l nf ng">JSON_BOOL<br/>    : true<br/>    | false<br/>    ;</span><span id="4357" class="nc lc iq my b gy nw ne l nf ng">JSON_ARRAY<br/>    : '[' JSON_ARRAY_ELS ']'<br/>    ;</span><span id="0092" class="nc lc iq my b gy nw ne l nf ng">JSON_ARRAY_ELS<br/>    : JSON_ARRAY_ELS ',' JSON<br/>    | JSON<br/>    | epsilon<br/>    ;</span><span id="21ff" class="nc lc iq my b gy nw ne l nf ng">JSON_OBJECT<br/>    : '{' JSON_OBJECT_KV_PAIRS '}'<br/>    ;</span><span id="667b" class="nc lc iq my b gy nw ne l nf ng">JSON_OBJECT_KV_PAIRS<br/>    : JSON_OBJECT_KV_PAIRS ',' JSON_OBJECT_KV_PAIR<br/>    | JSON_OBJECT_KV_PAIR<br/>    | epsilon<br/>    ;</span><span id="3566" class="nc lc iq my b gy nw ne l nf ng">JSON_OBJECT_KV_PAIR<br/>    : JSON_STRING ':' JSON<br/>    ;</span></pre><p id="846d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种语法有几个有趣的特点需要指出。</p><p id="4ac4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">引入了一个叫做<code class="fe nh ni nj my b">epsilon</code>的特殊符号。这个符号代表空字符串，在这个语法中用来表示一个数组或者对象可以是空的。这将允许<code class="fe nh ni nj my b">"[]"</code>和<code class="fe nh ni nj my b">"{}"</code>都是有效的JSON字符串。</p><p id="0a82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">语法也是递归的。这反映了JSON值本身的递归性质，因为数组和对象中可以嵌套的内容没有限制。这使得<code class="fe nh ni nj my b">"[1,[true,[]]]"</code>成为一个有效的JSON字符串，可以被解析成一系列嵌套数组。此外，这些递归规则中的一些是<em class="mn">左</em>递归的，这意味着产生式规则将自身作为规则的开始:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="231c" class="nc lc iq my b gy nd ne l nf ng">JSON_ARRAY_ELS<br/>    : JSON_ARRAY_ELS ',' JSON<br/>    ;</span></pre><p id="f56b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于使用某些解析算法的分析器来说，这可能导致无限循环，因为解析器为了解析<code class="fe nh ni nj my b">JSON_ARRAY_ELS</code>，首先必须查看它是否匹配<code class="fe nh ni nj my b">JSON_ARRAY_ELS.</code>，然后它必须查看<em class="mn">是否匹配</em><code class="fe nh ni nj my b">JSON_ARRAY_ELS</code>、<em class="mn">以及无限的</em>。因为本文是手工实现分析器，所以分析器处理左递归的方式有很大的灵活性:可以很容易地重写为迭代。</p><h2 id="c3fe" class="nc lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated">标记器</h2><p id="73dd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">记号赋予器的目的是将待解析的文本分成字符组(即使其中一些组只包含一个字符)。这些标记表示语法中的终止符号，通常由正则表达式定义并给定名称。某些标记也可以被认为是无意义的，可以完全跳过——这是对空白字符经常采用的方法。</p><p id="88e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面定义的语法给出了以下标记:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="c4e8" class="nc lc iq my b gy nd ne l nf ng">const tokens = [<br/>    [/^\s+/, null], // skip whitespace<br/>    [/^\[/, '['],<br/>    [/^]/, ']'],<br/>    [/^\{/, '{'],<br/>    [/^}/, '}'],<br/>    [/^:/, ':'],<br/>    [/^,/, ','],<br/>    [/^"/, '"'],<br/>    [/^\d+/, 'number'],<br/>    [/^null\b/, 'null'], // Add word boundaries to ensure that<br/>    [/^true\b/, 'true'], // `null`, etc., is matched exactly.<br/>    [/^false\b/, 'false'],<br/>    [/^[^"]*/, 'string'],  // Match anything not a quotation mark.<br/>];</span></pre><p id="0926" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个元组代表一个模式/名称对。每个模式都被锚定在字符串的开头，以确保记号赋予器总是生成下一个<em class="mn">记号，该记号应该被提供给分析器。通过给空白赋予一个<code class="fe nh ni nj my b">null</code>名称，这将向标记器表明所有的空白都应该被忽略。</em></p><p id="0e61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记号赋予器的逻辑是遍历记号列表，找到第一个匹配字符串开头的记号。这意味着对令牌进行排序的方式很重要，即更具体的令牌在更一般的令牌之前。例如，如果某个编程语言有两个关键字<code class="fe nh ni nj my b">def</code>和<code class="fe nh ni nj my b">define</code>，那么<code class="fe nh ni nj my b">define</code>应该排在前面，这样，对字符串<code class="fe nh ni nj my b">define add(a, b)</code>进行标记就不会首先匹配<code class="fe nh ni nj my b">def</code>，从而留下一个无效的<code class="fe nh ni nj my b">ine add(a, b)</code>供标记器以后处理。</p><p id="c689" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这给出了以下结构作为记号赋予器的框架</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="5bf9" class="nc lc iq my b gy nd ne l nf ng">class Tokenizer {<br/>    constructor(tokens) {}</span><span id="fc1f" class="nc lc iq my b gy nw ne l nf ng">    read(string) {}</span><span id="c85b" class="nc lc iq my b gy nw ne l nf ng">    next() {}<br/>}</span></pre><p id="03f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以充实到</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="529c" class="nc lc iq my b gy nd ne l nf ng">class Tokenizer {<br/>    // List of tokens recognized by the tokenizer<br/>    #tokens;</span><span id="0d42" class="nc lc iq my b gy nw ne l nf ng">    // Position in the input string from which it will <br/>    // read to get the next token<br/>    #cursor;</span><span id="9a7a" class="nc lc iq my b gy nw ne l nf ng">    // String to turn into tokens<br/>    #string;</span><span id="3ea5" class="nc lc iq my b gy nw ne l nf ng">    constructor(tokens) {<br/>        this.#tokens = tokens;<br/>    }</span><span id="baa9" class="nc lc iq my b gy nw ne l nf ng">    read(string) {<br/>        this.#cursor = 0;<br/>        this.#string = string;<br/>    }</span><span id="b15f" class="nc lc iq my b gy nw ne l nf ng">    next() {<br/>        // If at end of input, no more tokens to generate<br/>        if (this.#cursor === this.#string.length) {<br/>            return undefined;<br/>        }</span><span id="8b6c" class="nc lc iq my b gy nw ne l nf ng">        // Find substring beginning at position of cursor<br/>        const str = this.#string.slice(this.#cursor);</span><span id="2ae7" class="nc lc iq my b gy nw ne l nf ng">        for (const [pattern, type] of this.#tokens) {<br/>            const [match] = pattern.exec(str) || [];</span><span id="7156" class="nc lc iq my b gy nw ne l nf ng">            if (!match) {<br/>                continue;<br/>            }</span><span id="d1c8" class="nc lc iq my b gy nw ne l nf ng">            this.#cursor += match.length;</span><span id="9814" class="nc lc iq my b gy nw ne l nf ng">            // Skip tokens with null types<br/>            if (type === null) {<br/>                return this.next();<br/>            }</span><span id="db67" class="nc lc iq my b gy nw ne l nf ng">            return { token: match, type };<br/>        }</span><span id="6fc7" class="nc lc iq my b gy nw ne l nf ng">        // Could not extract any tokens, so throw error<br/>        throw new Error(`Unrecognized input: ${str[0]}`);<br/>    }<br/>}</span></pre><p id="d3e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然字符流可以被转换成记号流，那么是时候将这些记号转换成抽象语法树了。</p><h2 id="8add" class="nc lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated">分析者</h2><p id="a9c8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">分析器比记号赋予器要多做一点工作，因为它必须实现语法的产生式规则。由于这个分析器是手工编写的，它的大小和复杂性与它必须实现的规则数量成正比。</p><p id="76e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于各种手动创建的分析器(称为"<a class="ae kc" href="https://en.wikipedia.org/wiki/Recursive_descent_parser" rel="noopener ugc nofollow" target="_blank">递归下降</a>")直接实现语法规则，一个好的框架应该是:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="18c3" class="nc lc iq my b gy nd ne l nf ng">class Analyzer {<br/>    // Tokenizer class<br/>    #tokenizer;</span><span id="8fda" class="nc lc iq my b gy nw ne l nf ng">    // Current token being analyzed<br/>    #lookahead;</span><span id="4283" class="nc lc iq my b gy nw ne l nf ng">    constructor(tokenizer) {}</span><span id="971e" class="nc lc iq my b gy nw ne l nf ng">    #eat(tokenType) {}</span><span id="077b" class="nc lc iq my b gy nw ne l nf ng">    read(string) {}</span><span id="ce7b" class="nc lc iq my b gy nw ne l nf ng">    #JSON() {}</span><span id="965a" class="nc lc iq my b gy nw ne l nf ng">    #JSON_STRING() {}</span><span id="2389" class="nc lc iq my b gy nw ne l nf ng">    #JSON_number() {}</span><span id="9eee" class="nc lc iq my b gy nw ne l nf ng">    #JSON_null() {}</span><span id="eea7" class="nc lc iq my b gy nw ne l nf ng">    #JSON_BOOL() {}</span><span id="6380" class="nc lc iq my b gy nw ne l nf ng">    #JSON_ARRAY() {}</span><span id="5fe0" class="nc lc iq my b gy nw ne l nf ng">    #JSON_OBJECT() {}</span><span id="b2fe" class="nc lc iq my b gy nw ne l nf ng">    #JSON_ARRAY_ELS() {}</span><span id="d32f" class="nc lc iq my b gy nw ne l nf ng">    #JSON_OBJECT_KV_PAIRS() {}</span><span id="6b98" class="nc lc iq my b gy nw ne l nf ng">    #JSON_OBJECT_KV_PAIR() {}<br/>}</span></pre><p id="88aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些方法大多直接匹配语法；两个是新的。<code class="fe nh ni nj my b">read</code>是一个公共方法，将在一个字符串上被调用以将其转换成一个抽象语法树。<code class="fe nh ni nj my b">#eat</code>是分析仪常用的一种方法，用于确保当前令牌是所需的类型。如果令牌与类型匹配，它将被返回，分析器可以继续派生。否则，分析器应该抛出一个错误。<code class="fe nh ni nj my b">#eat</code>的用法将在本文后面变得更加明显。</p><p id="07a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分析器上还有一个<code class="fe nh ni nj my b">#lookahead</code>属性。这是解析最重要的方面之一:在使用当前令牌之前检查它的能力。<code class="fe nh ni nj my b">#lookahead</code>存储当前令牌，允许分析器确定它应该采用语法中的哪条路径。它的存在对于实施<code class="fe nh ni nj my b">#JSON</code>方法至关重要。一般来说，任何数量的标记都可以用作lookaheads，尽管一个标记是非常常见的数量，足以实现一个JSON解析器。</p><p id="6136" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">充实了非语法方法后，分析器将看起来像</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="de29" class="nc lc iq my b gy nd ne l nf ng">class Analyzer {<br/>    #tokenizer;<br/>    #lookahead;</span><span id="fd27" class="nc lc iq my b gy nw ne l nf ng">    constructor(tokenizer) {<br/>        this.#tokenizer = tokenizer;<br/>    }</span><span id="6b38" class="nc lc iq my b gy nw ne l nf ng">    read(string) {<br/>        this.#tokenizer.read(string);</span><span id="6ef2" class="nc lc iq my b gy nw ne l nf ng">        // Set the first token as the lookahead<br/>        this.#lookahead = this.#tokenizer.next();</span><span id="617d" class="nc lc iq my b gy nw ne l nf ng">        return this.#JSON();<br/>    }</span><span id="c8ea" class="nc lc iq my b gy nw ne l nf ng">    #eat(tokenType) {<br/>        const token = this.#lookahead;</span><span id="8a10" class="nc lc iq my b gy nw ne l nf ng">        if (!token) {<br/>            throw new Error(<br/>                `Unexpected end of input; expected ${token.type}`<br/>            );<br/>        }</span><span id="ebcb" class="nc lc iq my b gy nw ne l nf ng">        if (this.#lookahead.type !== tokenType) {<br/>            throw new Error(<br/>                `Expected ${tokenType} === ${token.type}`<br/>            );<br/>        }</span><span id="315b" class="nc lc iq my b gy nw ne l nf ng">        // Set the next token as the lookahead<br/>        this.#lookahead = this.#tokenizer.next();</span><span id="aeda" class="nc lc iq my b gy nw ne l nf ng">        return token;<br/>    }<br/>}        </span></pre><p id="cb37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着<code class="fe nh ni nj my b">#eat</code>和<code class="fe nh ni nj my b">read</code>的实现，构建AST的方法就可以实现了。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="ee23" class="nc lc iq my b gy nd ne l nf ng">class Analyzer {<br/>    // ... methods from above</span><span id="9e9b" class="nc lc iq my b gy nw ne l nf ng">    #JSON() {<br/>        switch (this.#lookahead.type) {<br/>            case '"':<br/>                return this.#JSON_STRING();</span><span id="f1c6" class="nc lc iq my b gy nw ne l nf ng">            case 'number':<br/>                return this.#JSON_number();</span><span id="40a1" class="nc lc iq my b gy nw ne l nf ng">            case 'null':<br/>                return this.#JSON_null();</span><span id="e839" class="nc lc iq my b gy nw ne l nf ng">            case 'true':<br/>            case 'false':<br/>                return this.#JSON_BOOL();</span><span id="0df7" class="nc lc iq my b gy nw ne l nf ng">            case '[':<br/>                return this.#JSON_ARRAY();</span><span id="8fa6" class="nc lc iq my b gy nw ne l nf ng">            case '{':<br/>                return this.#JSON_OBJECT();</span><span id="9323" class="nc lc iq my b gy nw ne l nf ng">            default:<br/>                throw new Error(<br/>                    `Received token which cannot be valid JSON`<br/>                );<br/>        }<br/>    }<br/>}</span></pre><p id="874a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从该方法中可以看出，前瞻标记在允许分析器确定应该解析哪个 JSON值的<em class="mn">中起着至关重要的作用。没有这些知识，分析器将无法继续。因为只有语法的标记集的子集可以开始一个JSON值，如果lookahead不在某个<code class="fe nh ni nj my b">case</code>语句中，那么分析器试图读取格式错误的JSON并抛出一个错误。</em></p><p id="44f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其余的方法(其中一些举例说明了<code class="fe nh ni nj my b">#eat</code>的用法)有:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="2cfe" class="nc lc iq my b gy nd ne l nf ng">class Analyzer {<br/>    // ... previous methods</span><span id="ffd0" class="nc lc iq my b gy nw ne l nf ng">    #JSON_STRING() {<br/>        // The quotation marks are necessary for the JSON grammar,<br/>        // but contribute nothing to the semantic content of the<br/>        // AST, so ensure they exist but do not use<br/>        this.#eat('"');<br/>        const string = this.#eat('string').token;<br/>        this.#eat('"');</span><span id="2ef7" class="nc lc iq my b gy nw ne l nf ng">        return {<br/>            type: 'JSON_STRING',<br/>            value: string,<br/>        }<br/>    }</span><span id="7599" class="nc lc iq my b gy nw ne l nf ng">    #JSON_number() {<br/>        const number = this.#eat('number').token;</span><span id="9cc3" class="nc lc iq my b gy nw ne l nf ng">        return {<br/>            type: 'JSON_number',<br/>            value: +number,<br/>        }<br/>    }</span><span id="fc13" class="nc lc iq my b gy nw ne l nf ng">    #JSON_null() {<br/>        this.#eat('null');</span><span id="e7aa" class="nc lc iq my b gy nw ne l nf ng">        return {<br/>            type: 'JSON_null',<br/>            value: null,<br/>        }<br/>    }</span><span id="b62b" class="nc lc iq my b gy nw ne l nf ng">    #JSON_BOOL() {<br/>        const bool = this.#lookahead.type === 'true'<br/>            ? this.#eat('true')<br/>            : this.#eat('false');</span><span id="3a52" class="nc lc iq my b gy nw ne l nf ng">        return {<br/>            type: 'JSON_BOOL',<br/>            value: bool.token === 'true',<br/>        }<br/>    }<br/>}</span></pre><p id="026f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这负责语法的非递归规则。每个规则返回一个对象，该对象指定它在AST中表示的节点的类型以及该节点的解释值(这意味着如果分析器正在读取一个数字，则返回的节点具有一个值<em class="mn">，该值是一个数字</em>，而不是该数字的文本标记)。</p><p id="e18d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JSON值的这些最终情况可以递归地组合到数组和对象中，因此接下来的规则将在某种程度上涉及到通过最顶层的<code class="fe nh ni nj my b">#JSON</code>方法进行递归。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="ab95" class="nc lc iq my b gy nd ne l nf ng">class Analyzer {<br/>    // ... previous rules</span><span id="87e7" class="nc lc iq my b gy nw ne l nf ng">    #JSON_ARRAY() {<br/>        this.#eat('[');<br/>        const elements = this.#JSON_ARRAY_ELS();<br/>        this.#eat(']');</span><span id="701f" class="nc lc iq my b gy nw ne l nf ng">        return {<br/>            type: 'JSON_ARRAY',<br/>            elements,<br/>        }<br/>    }</span><span id="52e6" class="nc lc iq my b gy nw ne l nf ng">    #JSON_ARRAY_ELS() {<br/>        const elements = [];</span><span id="ad59" class="nc lc iq my b gy nw ne l nf ng">        while (this.#lookahead.type !== ']') {<br/>            elements.push(this.#JSON());</span><span id="2673" class="nc lc iq my b gy nw ne l nf ng">            // The final element of an array will not have a comma<br/>            // following it, so conditionally consume any comma<br/>            // characters<br/>            this.#lookahead.type === ',' &amp;&amp; this.#eat(',');<br/>        }</span><span id="0151" class="nc lc iq my b gy nw ne l nf ng">        return elements;<br/>    }<br/>}</span></pre><p id="d7fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是第一个为AST节点使用不同形状的产生式规则:代表终端节点的规则都有<code class="fe nh ni nj my b">value</code>属性，但是这个规则使用了<code class="fe nh ni nj my b">elements</code>。AST节点可以有任何可能的形状，只要形状使用一致就没有问题。在这种情况下，对于数组节点用<code class="fe nh ni nj my b">elements</code>代替<code class="fe nh ni nj my b">value</code>更有语义意义。</p><p id="42e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nh ni nj my b">JSON_ARRAY_ELS</code>的语法规则是左递归的，如上所述，这可能导致某些算法分析器的无限递归。然而，手动分析器通过使用一个<code class="fe nh ni nj my b">while</code>循环来分析数组元素，从而绕过了这个问题。由于递归和循环是密切相关的概念，通常可以进行这样的替换，在这种情况下，它可以防止语法发生变化，同时仍然给出相同的结果。</p><p id="2a31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法<code class="fe nh ni nj my b">#JSON_ARRAY_ELS </code>本身不返回AST节点，因为它是一个实用函数，而不是读取JSON的主要方法。</p><p id="842b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">读取对象的方法与读取数组的方法非常相似:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="70a9" class="nc lc iq my b gy nd ne l nf ng">class Analyzer {<br/>    // ... previous methods</span><span id="77ae" class="nc lc iq my b gy nw ne l nf ng">    #JSON_OBJECT() {<br/>        this.#eat('{');<br/>        const kvPairs = this.#JSON_OBJECT_KV_PAIRS();<br/>        this.#eat('}');</span><span id="eab2" class="nc lc iq my b gy nw ne l nf ng">        return {<br/>            type: 'JSON_OBJECT',<br/>            entries: kvPairs,<br/>        }<br/>    }</span><span id="d6c9" class="nc lc iq my b gy nw ne l nf ng">    #JSON_OBJECT_KV_PAIRS() {<br/>        const entries = [];</span><span id="7032" class="nc lc iq my b gy nw ne l nf ng">        while (this.#lookahead.type !== '}') {<br/>            entries.push(this.#JSON_OBJECT_KV_PAIR());<br/>            this.#lookahead.type === ',' &amp;&amp; this.#eat(',');<br/>        }</span><span id="5cc6" class="nc lc iq my b gy nw ne l nf ng">        return entries;<br/>    }</span><span id="bd08" class="nc lc iq my b gy nw ne l nf ng">    #JSON_OBJECT_KV_PAIR() {<br/>        // Get key<br/>        this.#eat('"');<br/>        const key = this.#eat('string').token;<br/>        this.#eat('"');</span><span id="5a50" class="nc lc iq my b gy nw ne l nf ng">        this.#eat(':');</span><span id="1624" class="nc lc iq my b gy nw ne l nf ng">        // Get value<br/>        const value = this.#JSON();</span><span id="230a" class="nc lc iq my b gy nw ne l nf ng">        return [key, value];<br/>    }<br/>}</span></pre><h2 id="d559" class="nc lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated">抽样输出</h2><p id="9d3d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">既然解析管道已经完成，就可以把记号赋予器和分析器放在一起，展示给定各种JSON字符串输入的示例输出。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="6440" class="nc lc iq my b gy nd ne l nf ng">const tokenizer = new Tokenizer(tokens);<br/>const analyzer = new Analyzer(tokenizer);</span><span id="12b7" class="nc lc iq my b gy nw ne l nf ng">const str1 = '"abc"';<br/>const str2 = '145';<br/>const str3 = '[true, { "k": null }, []]';</span><span id="75b6" class="nc lc iq my b gy nw ne l nf ng">analyzer.read(str1);<br/>// {<br/>//   type: 'JSON_STRING',<br/>//   value: 'abc',<br/>// }</span><span id="648e" class="nc lc iq my b gy nw ne l nf ng">analyzer.read(str2);<br/>// {<br/>//   type: 'JSON_number',<br/>//   value: 145,<br/>// }</span><span id="d26f" class="nc lc iq my b gy nw ne l nf ng">analyzer.read(str3);<br/>// {<br/>//   type: 'JSON_ARRAY',<br/>//   elements: [<br/>//     { type: 'JSON_BOOL', value: true },<br/>//     { type: 'JSON_OBJECT', entries: [<br/>//       [ 'k', { type: 'JSON_null', value: null } ],<br/>//     },<br/>//     { type: 'JSON_ARRAY', elements: [] },<br/>//  }</span></pre><h2 id="ec17" class="nc lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated">将字符串转换为JavaScript值</h2><p id="0a7e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">到目前为止，分析器将JSON字符串转换为抽象语法树。然而，目标是将所述字符串转换成JavaScript值(从而模仿实际的<code class="fe nh ni nj my b">JSON.parse</code>方法)。</p><p id="f222" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要做到这一点，需要利用AST的结构已经很好地反映了JSON本身的结构这一事实:每个返回AST节点的方法都会返回一些信息，这些信息包含了创建实际的底层JSON值所必需的所有信息。这意味着，通过非常小的改变，分析器<em class="mn">可以</em>返回值，而不是ASTs。</p><p id="4a0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要做到这一点，一点重构是必要的。不是分析器的方法<em class="mn">总是</em>返回AST节点，而是调用工厂函数，返回代表工厂“主题”的东西。在最初的案例中，主题是AST节点；在下一种情况下，它将是JavaScript。</p><p id="86f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分析器的重构版本看起来像这样</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="5acd" class="nc lc iq my b gy nd ne l nf ng">const astFactory = {<br/>    JSON_STRING(token) {<br/>        return {<br/>            type: 'JSON_STRING',<br/>            value: token.token,<br/>        };<br/>    },</span><span id="083b" class="nc lc iq my b gy nw ne l nf ng">    JSON_number(token) {<br/>        return {<br/>            type: 'JSON_number',<br/>            value: +token.token,<br/>        };<br/>    },</span><span id="7d8b" class="nc lc iq my b gy nw ne l nf ng">    JSON_null() {<br/>        return {<br/>            type: 'JSON_null',<br/>            value: null,<br/>        };<br/>    },</span><span id="34e3" class="nc lc iq my b gy nw ne l nf ng">    JSON_BOOL(token) {<br/>        return {<br/>            type: 'JSON_BOOL',<br/>            value: token.token === 'true',<br/>        };<br/>    },</span><span id="1829" class="nc lc iq my b gy nw ne l nf ng">    JSON_ARRAY(elements) {<br/>        return {<br/>            type: 'JSON_ARRAY',<br/>            elements,<br/>        };<br/>    },</span><span id="f0f3" class="nc lc iq my b gy nw ne l nf ng">    JSON_OBJECT(entries) {<br/>        return {<br/>            type: 'JSON_OBJECT',<br/>            entries,<br/>        }<br/>    }<br/>};</span><span id="852a" class="nc lc iq my b gy nw ne l nf ng">class Analyzer {<br/>    // ... non-refactored methods and properties</span><span id="5da0" class="nc lc iq my b gy nw ne l nf ng">    #factory;</span><span id="cc9d" class="nc lc iq my b gy nw ne l nf ng">    constructor(tokenizer, factory) {<br/>        this.#tokenizer = tokenizer;<br/>        this.#factory = factory;<br/>    }</span><span id="d717" class="nc lc iq my b gy nw ne l nf ng">    #JSON_STRING() {<br/>        this.#eat('"');<br/>        const string = this.#eat('string');<br/>        this.#eat('"');</span><span id="950d" class="nc lc iq my b gy nw ne l nf ng">        return this.#factory.JSON_STRING(string);<br/>    }</span><span id="8979" class="nc lc iq my b gy nw ne l nf ng">    #JSON_number() {<br/>        const number = this.#eat('number');</span><span id="be66" class="nc lc iq my b gy nw ne l nf ng">        return this.#factory.JSON_number(number);<br/>    }</span><span id="709f" class="nc lc iq my b gy nw ne l nf ng">    #JSON_null() {<br/>        this.#eat('null');</span><span id="eac8" class="nc lc iq my b gy nw ne l nf ng">        return this.#factory.JSON_null();<br/>    }</span><span id="6f33" class="nc lc iq my b gy nw ne l nf ng">    #JSON_BOOL() {<br/>        const bool = this.#lookahead.type === 'true'<br/>            ? this.#eat('true')<br/>            : this.#eat('false');</span><span id="e1b6" class="nc lc iq my b gy nw ne l nf ng">        return this.#factory.JSON_BOOL(bool);<br/>    }</span><span id="b9fe" class="nc lc iq my b gy nw ne l nf ng">    #JSON_ARRAY() {<br/>        this.#eat('[');<br/>        const elements = this.#JSON_ARRAY_ELS();<br/>        this.#eat(']');</span><span id="06bf" class="nc lc iq my b gy nw ne l nf ng">        return this.#factory.JSON_ARRAY(elements);<br/>    }</span><span id="4160" class="nc lc iq my b gy nw ne l nf ng">    #JSON_OBJECT() {<br/>        this.#eat('{');<br/>        const kvPairs = this.#JSON_OBJECT_KV_PAIRS();<br/>        this.#eat('}');</span><span id="ec09" class="nc lc iq my b gy nw ne l nf ng">        return this.#factory.JSON_OBJECT(kvPairs);<br/>    }<br/>}</span></pre><p id="4705" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，无论相关的<code class="fe nh ni nj my b">#factory</code>函数返回什么，分析器都会返回。此时，需要做的就是编写一个JavaScript工厂，而不是AST工厂。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4007" class="nc lc iq my b gy nd ne l nf ng">const jsFactory = {<br/>    JSON_STRING(token) {<br/>        return token.token;<br/>    },</span><span id="8a2d" class="nc lc iq my b gy nw ne l nf ng">    JSON_number(token) {<br/>        return +token.token;<br/>    },</span><span id="ea5e" class="nc lc iq my b gy nw ne l nf ng">    JSON_null() {<br/>        return null;<br/>    },</span><span id="f02b" class="nc lc iq my b gy nw ne l nf ng">    JSON_BOOL(token) {<br/>        return token.token === 'true'<br/>    },</span><span id="d9c3" class="nc lc iq my b gy nw ne l nf ng">    JSON_ARRAY(elements) {<br/>        return elements;<br/>    },</span><span id="6899" class="nc lc iq my b gy nw ne l nf ng">    JSON_OBJECT(entries) {<br/>        return entries.reduce(<br/>            (obj, [k, v]) =&gt; {<br/>                obj[k] = v;<br/>                return obj;<br/>            },<br/>            {}<br/>        );<br/>    }<br/>};</span></pre><p id="f9df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用与上面相同的字符串，JSON工厂输出真正解析的JSON值。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="68c9" class="nc lc iq my b gy nd ne l nf ng">const tokenizer = new Tokenizer(tokens);<br/>const analyzer = new Analyzer(tokenizer, jsFactory);</span><span id="b0b3" class="nc lc iq my b gy nw ne l nf ng">const str1 = '"abc"';<br/>const str2 = '145';<br/>const str3 = '[true, { "k": null }, []]';</span><span id="2f7c" class="nc lc iq my b gy nw ne l nf ng">analyzer.read(str1); // "abc"<br/>analyzer.read(str2); // 145<br/>analyzer.read(str3); // [true, { k: null }, []]</span></pre><h1 id="1590" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="af72" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">手动编写定制的记号赋予器和分析器并不像最初看起来那样具有挑战性，并且为工程开辟了许多其他途径，例如构建正则表达式引擎、CSS引擎，甚至是自己的编程语言。事实上，最具挑战性的部分通常是恰当地建模语法。有了定义良好的语法，解析器本身的运行速度相当快。</p><p id="ab40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这个解析器没有解析完整的JSON规范，但它已经很接近了，对于任何对实现完整语法感兴趣的人来说，道格拉斯·克洛克福特的RFC <a class="ae kc" href="https://www.ietf.org/rfc/rfc4627.txt" rel="noopener ugc nofollow" target="_blank">可以在这里找到</a>。事实上，如果有人对扩展它的功能感兴趣，这个解析器可以扩展成JSON+语法。规范中不支持像<code class="fe nh ni nj my b">Infinity</code>、<code class="fe nh ni nj my b">undefined</code>和注释这样的值，但是可以很容易地添加到当前的语法中。</p><p id="cf4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://gist.github.com/ryandabler/1dcdcb88890f72677bfdaed661d64c8c" rel="noopener ugc nofollow" target="_blank">这里是所有解析器代码的一个要点</a>。</p></div></div>    
</body>
</html>