<html>
<head>
<title>Source Code Walkthrough of Telegram-iOS Part 6: Bubbles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Telegram-iOS第6部分源代码演练:气泡</h1>
<blockquote>原文：<a href="https://itnext.io/source-code-walkthrough-of-telegram-ios-part-6-bubbles-836b61759bdf?source=collection_archive---------1-----------------------#2020-06-22">https://itnext.io/source-code-walkthrough-of-telegram-ios-part-6-bubbles-836b61759bdf?source=collection_archive---------1-----------------------#2020-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="6ef2" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><a class="ae kp" href="https://hubo.dev/2020-06-22-source-code-walkthrough-of-telegram-ios-part-6/" rel="noopener ugc nofollow" target="_blank">之镜hubo.dev </a></p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/31946475b0452371d17def69ceee5007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pz3gl7asjEDcgwYg"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><a class="ae kp" href="https://unsplash.com/@ninjason?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梁杰森</a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="95ad" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi lj translated">ubbles是一种用户界面，几乎是我们日常生活中不可或缺的一部分。如果消息是一段纯文本或一个图像文件，这是一件简单的工作。Telegram中的问题很困难，因为有许多消息元素，如文本、样式文本、降价文本、图像、相册、视频、文件、网页、位置等等。当一条消息可以包含几乎多个任意类型的元素时，这就变得更加困难了。本文展示了Telegram-iOS如何在其异步UI框架上构建消息气泡。</p><h1 id="033b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">课程概述</h1><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi mq"><img src="../Images/210bd4b6cb6ed4a2a6f892a66ca2d5e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*leQZhO2INCqAuN8bjWUOWQ.png"/></div></div></figure><p id="26e7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatController.swift#L145" rel="noopener ugc nofollow" target="_blank">ChatControllerImpl</a></code>是管理消息列表UI的核心控制器。其内容<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatControllerNode.swift#L59" rel="noopener ugc nofollow" target="_blank">ChatControllerNode</a></code>由以下主要节点组成UI结构:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ec67" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">作为<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/Display/Source/ListView.swift#L134" rel="noopener ugc nofollow" target="_blank">ListView</a></code>的子类，<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatHistoryListNode.swift#L397" rel="noopener ugc nofollow" target="_blank">ChatHistoryListNode</a></code>呈现消息列表和其他信息节点。它有两种UI模式:<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatHistoryListNode.swift#L76" rel="noopener ugc nofollow" target="_blank">bubbles</a></code>和<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatHistoryListNode.swift#L77" rel="noopener ugc nofollow" target="_blank">list</a></code>。模式<code class="fe mr ms mt mu b">bubbles</code>用于正常聊天，而<code class="fe mr ms mt mu b">list</code>用于在对方信息面板中按媒体、文件、语音等类型列出聊天历史。这个帖子只说模式<code class="fe mr ms mt mu b">bubbles</code>。</p><p id="738b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">它的核心数据属性<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/Display/Source/ListView.swift#L260" rel="noopener ugc nofollow" target="_blank">items</a></code>可以取三种类型的<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/Display/Source/ListViewItem.swift#L41" rel="noopener ugc nofollow" target="_blank">ListViewItem</a></code>。每一项实现<code class="fe mr ms mt mu b">nodeConfiguredForParams</code>返回对应的UI节点。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7e79" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageItem.swift#L223" rel="noopener ugc nofollow" target="_blank">ChatMessageItem</a></code>代表一条聊天消息或一组聊天消息，应呈现为气泡。<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageItemView.swift#L644" rel="noopener ugc nofollow" target="_blank">ChatMessageItemView</a></code>的四个子类是不同类型气泡的容器节点。<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageBubbleItemNode.swift#L152" rel="noopener ugc nofollow" target="_blank">ChatMessageBubbleItemNode</a></code>实现了一种呈现消息气泡的机制，该气泡具有多个内容元素，这些内容元素是<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageBubbleContentNode.swift#L110" rel="noopener ugc nofollow" target="_blank">ChatMessageBubbleContentNode</a></code>的子类。</p><h1 id="c0b3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">列表倒置</h1><p id="9a94" class="pw-post-body-paragraph jq jr iq jt b ju mx jw jx jy my ka kb lg mz ke kf lh na ki kj li nb km kn ko ij bi translated">聊天消息列表将最新消息放在底部，垂直滚动指示器也从底部开始。它实际上是iOS上常见列表UI的倒置。Telegram-iOS使用了类似于《T5》的《T4》中的UI转换技巧。使用<code class="fe mr ms mt mu b">ASDisplayNode</code>的属性<code class="fe mr ms mt mu b">transform</code>将<code class="fe mr ms mt mu b">ChatHistoryListNode</code>旋转180°，然后所有内容节点也旋转。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0e50" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">下面的屏幕截图演示了逐步应用转换后的效果:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nc"><img src="../Images/519559bcf0eb35912429651771b7d38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vIr2pxvwkL4WfzcN9y1MCg.png"/></div></div></figure><h1 id="f8d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">ListView项目</h1><ul class=""><li id="fa5d" class="nd ne iq jt b ju mx jy my lg nf lh ng li nh ko ni nj nk nl bi translated"><code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatBotInfoItem.swift#L19" rel="noopener ugc nofollow" target="_blank">ChatBotInfoItem</a></code>。如果对等体是电报机器人，则机器人信息卡被插入到项目的第一个位置。</li><li id="3549" class="nd ne iq jt b ju nm jy nn lg no lh np li nq ko ni nj nk nl bi translated"><code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatUnreadItem.swift#L12" rel="noopener ugc nofollow" target="_blank">ChatUnreadItem</a></code>。这是一个区分未读邮件和已读邮件的指示器。</li><li id="7575" class="nd ne iq jt b ju nm jy nn lg no lh np li nq ko ni nj nk nl bi translated"><code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageItem.swift#L268" rel="noopener ugc nofollow" target="_blank">ChatMessageItem</a></code>。它对聊天消息建模如下:</li></ul><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e734" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatControllerInteraction.swift#L52" rel="noopener ugc nofollow" target="_blank">ChatControllerInteraction</a></code>是为<code class="fe mr ms mt mu b">ChatControllerImpl</code>维护77个动作回调的数据类。它通过项来触发回调，而不需要引用控制器。</p><p id="4f12" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageItem.swift#L15" rel="noopener ugc nofollow" target="_blank">ChatMessageItemContent</a></code>的结构很有意思。它是一个枚举，可以是一条消息，也可以是一组消息。依我看，它可以简化为<code class="fe mr ms mt mu b">.group</code>，因为<code class="fe mr ms mt mu b">.message</code>可以用一个元素的组来表达。</p><p id="4d23" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/Postbox/Sources/Message.swift#L487" rel="noopener ugc nofollow" target="_blank">Message</a></code>使用两个协议<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/Postbox/Sources/Message.swift#L468" rel="noopener ugc nofollow" target="_blank">MessageAttribute</a></code>和<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/Postbox/Sources/Media.swift#L75" rel="noopener ugc nofollow" target="_blank">Media</a></code>来描述消息中的内容元素。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2d62" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">一个<code class="fe mr ms mt mu b">Message</code>实例总是有一个<code class="fe mr ms mt mu b">text</code>条目和一些可选的<code class="fe mr ms mt mu b">MessageAttribute</code>。如果<code class="fe mr ms mt mu b">attributes</code>有一个<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/SyncCore/Sources/TextEntitiesMessageAttribute.swift#L129" rel="noopener ugc nofollow" target="_blank">TextEntitiesMessageAttribute</a></code>的条目，可以通过<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TextFormat/Sources/StringWithAppliedEntities.swift#L49" rel="noopener ugc nofollow" target="_blank">stringWithAppliedEntities</a></code>构造一个属性化的字符串。然后，可以在气泡内呈现丰富的格式化文本。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="62d8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">协议<code class="fe mr ms mt mu b">Media</code>及其类实现描述了丰富的媒体类型，如<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/SyncCore/Sources/TelegramMediaImage.swift#L53" rel="noopener ugc nofollow" target="_blank">TelegramMediaImage</a></code>、<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/SyncCore/Sources/TelegramMediaFile.swift#L237" rel="noopener ugc nofollow" target="_blank">TelegramMediaFile</a></code>、<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/SyncCore/Sources/TelegramMediaMap.swift#L133" rel="noopener ugc nofollow" target="_blank">TelegramMediaMap</a></code>等。</p><p id="5990" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">总而言之，<code class="fe mr ms mt mu b">Message</code>基本上是一个带有几个媒体附件的属性化字符串，而<code class="fe mr ms mt mu b">ChatMessageItem</code>是一组<code class="fe mr ms mt mu b">Message</code>实例。这种设计可以灵活地表示复杂的消息内容，并且很容易保持向后兼容性。例如，一个<a class="ae kp" href="https://telegram.org/blog/albums-saved-messages" rel="noopener ugc nofollow" target="_blank">分组相册</a>被表示为一个包含多条消息的项目，而每条消息都有一个媒体<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/SyncCore/Sources/TelegramMediaImage.swift#L53" rel="noopener ugc nofollow" target="_blank">TelegramMediaImage</a></code>。</p><h1 id="8010" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">气泡节点</h1><p id="cfec" class="pw-post-body-paragraph jq jr iq jt b ju mx jw jx jy my ka kb lg mz ke kf lh na ki kj li nb km kn ko ij bi translated"><code class="fe mr ms mt mu b">ChatMessageItem</code>执行<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageItem.swift#L378" rel="noopener ugc nofollow" target="_blank">nodeConfiguredForParams</a></code>来设置气泡节点以匹配数据。如果我们研究一下代码，它在项目结构上有一些规则。</p><ul class=""><li id="0150" class="nd ne iq jt b ju jv jy jz lg nr lh ns li nt ko ni nj nk nl bi translated">如果第一条消息具有小于128 KB的动画贴纸媒体文件，则选择<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageAnimatedStickerItemNode.swift#L35" rel="noopener ugc nofollow" target="_blank">ChatMessageAnimatedStickerItemNode</a></code>来渲染带有贴纸的气泡。项目中的其他消息和媒体数据将被忽略。</li><li id="f712" class="nd ne iq jt b ju nm jy nn lg no lh np li nq ko ni nj nk nl bi translated">默认情况下，应用程序中打开了大型表情符号支持的设置。如果一条短信只有一个表情符号字符或者所有字符都是表情符号，则用<code class="fe mr ms mt mu b">ChatMessageAnimatedStickerItemNode</code>或<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageStickerItemNode.swift#L20" rel="noopener ugc nofollow" target="_blank">ChatMessageStickerItemNode</a></code>代替纯文本实现大渲染效果。</li></ul><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c71c13b186cf8b1808376123c7591476.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*oBZ_hCa8pWQVNBhRHV4W8Q.png"/></div></figure><ul class=""><li id="b548" class="nd ne iq jt b ju jv jy jz lg nr lh ns li nt ko ni nj nk nl bi translated">如果项目的第一条消息有即时循环视频文件，则选择<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageInstantVideoItemNode.swift#L22" rel="noopener ugc nofollow" target="_blank">ChatMessageInstantVideoItemNode</a></code>显示循环视频，其他内容将被忽略。</li><li id="0f78" class="nd ne iq jt b ju nm jy nn lg no lh np li nq ko ni nj nk nl bi translated">否则，<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageBubbleItemNode.swift#L152" rel="noopener ugc nofollow" target="_blank">ChatMessageBubbleItemNode</a></code>处理结构化消息。</li></ul><p id="b236" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mr ms mt mu b">ChatMessageBubbleItemNode</code>检查一个项目，并通过将数据映射到<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageBubbleContentNode.swift#L110" rel="noopener ugc nofollow" target="_blank">ChatMessageBubbleContentNode</a></code>的16个子类来构建子节点。<code class="fe mr ms mt mu b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/release-6.1.2/submodules/TelegramUI/Sources/ChatMessageBubbleItemNode.swift#L32" rel="noopener ugc nofollow" target="_blank">contentNodeMessagesAndClassesForItem</a></code>是维护映射逻辑的核心功能:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="ecc7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">布局</h1><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nv"><img src="../Images/fea576c70ca2a1fcb54342e32e69b33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dGdYbspOnCVE7TAR9Y9QA.png"/></div></div></figure><p id="eb6c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">气泡的布局由<code class="fe mr ms mt mu b">ListView</code>的异步布局机制驱动。上图显示了最重要的布局方法的调用流程。在我对装有iOS 13.5的iPhone 6s进行测试期间，FPS能够保持在58以上，这比其他拥有长而复杂的用户界面列表的应用程序要好。这无疑证明了<code class="fe mr ms mt mu b">AsyncDisplayKit</code>是Telegram场景的一个好选择。</p><p id="77a9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">需要注意的一点是<code class="fe mr ms mt mu b">ListView</code>不会缓存布局结果。如果你的设备真的很慢，你会在滚动时看到空的单元格。</p><h1 id="6844" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="13bb" class="pw-post-body-paragraph jq jr iq jt b ju mx jw jx jy my ka kb lg mz ke kf lh na ki kj li nb km kn ko ij bi translated">这篇文章简要解释了Telegram-iOS中消息气泡的数据模型和UI结构。数据结构对于复杂的消息是灵活的，这是检查您是否开始设计自己的messenger的一个很好的参考。我鼓励您按照我的介绍深入研究代码，因为这里没有涉及更多的细节。</p></div></div>    
</body>
</html>