<html>
<head>
<title>Speeding up your CI/CD build times with a custom Docker image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用自定义Docker映像加快您的CI/CD构建时间</h1>
<blockquote>原文：<a href="https://itnext.io/speeding-up-your-ci-cd-build-times-with-a-custom-docker-image-3bfaac4e0479?source=collection_archive---------0-----------------------#2020-04-12">https://itnext.io/speeding-up-your-ci-cd-build-times-with-a-custom-docker-image-3bfaac4e0479?source=collection_archive---------0-----------------------#2020-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e1c9c05d77efc50fc8435e6d0fa81af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAI-RA-jy016kww8N42yGQ.jpeg"/></div></div></figure><p id="eb52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将解释如何大幅减少monorepo的CI/CD管道的执行时间。本文的示例适用于Gitlab CI，但是其思想也适用于其他系统。</p><p id="3649" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用Gitlab已经有一段时间了。不幸的是，基于NodeJS的项目的安装/构建时间非常令人失望。关于那个问题有一个<a class="ae kz" href="https://gitlab.com/gitlab-org/gitlab-runner/issues/1797" rel="noopener ugc nofollow" target="_blank">长期未解决的问题</a>，目前还没有可用的解决方案。</p><p id="281b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于npm项目，Gitlab 的<a class="ae kz" href="https://docs.gitlab.com/ee/ci/caching/#caching-nodejs-dependencies" rel="noopener ugc nofollow" target="_blank">官方指南提出将npm缓存文件夹添加到CI缓存中，但是这种方式对于很多项目来说太慢了。monorepos的情况更糟，依赖项的数量可能非常大。</a></p><p id="b489" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">问题是Gitlab CI 提供的<a class="ae kz" href="https://docs.gitlab.com/ee/ci/caching/" rel="noopener ugc nofollow" target="_blank">缓存机制在处理node_modules或npm缓存文件夹时并不是那么快。众所周知，node_modules文件夹是宇宙中最重的对象之一…</a></p><p id="987c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的项目中，该文件夹包含大约160K个文件，总计大约750MB(！).</p><p id="d01e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于这个原因，缓存系统需要花费很长时间来压缩所有文件，上传归档文件，并为每个后续管道作业检索/解包它。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="aa72" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">初期状况</h1><p id="9d7b" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">为了让你有个概念，下面是我的管道的样子:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mk"><img src="../Images/681f3095529799ae3e424d3dac75f8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3qqU4V5fiTjRdIFj78P-g.png"/></div></div></figure><p id="a752" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是每项工作的分类:</p><ul class=""><li id="bfde" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">Codegen基于静态资产生成共享代码</li><li id="4b30" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">编制</li><li id="cf03" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">Lint:执行基本的代码质量检查</li><li id="78e1" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">单元测试</li><li id="2829" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">端到端测试:可选/手动步骤，使用Cypress对Storybook测试页面/组件/场景</li><li id="d582" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">构建受影响的应用程序(由于依赖关系发生变化而发生变化或需要重新构建的任何内容)</li><li id="7239" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">静态安全审计:基本安全检查(依赖版本、已知漏洞等)</li><li id="8384" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">创建Docker映像(CD管道的第一步)</li></ul><p id="cc5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你在上面的图片中看到的，一些步骤并行运行，以加快这个过程。他们争分夺秒地尝试，试图失败的建设。顺便说一句，考虑一下，我可能应该将安全审计步骤和测试一起进行:)</p><p id="8bf2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数这些步骤需要安装项目依赖项。此外，端到端测试需要Cypress，它有自己的缓存特性。</p><p id="6de1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该管道使用Docker映像。是这样的。gitlab-ci.yml文件最初是这样的:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="1f56" class="ni li it ne b gy nj nk l nl nm">image: node:12.15.0-slim<br/><br/>stages:<br/>  - init<br/>  - test<br/>  - security audit<br/>  - build<br/>  - ...</span><span id="ac04" class="ni li it ne b gy nn nk l nl nm">before_script:<br/>  - echo "Pipeline ID = $CI_PIPELINE_ID"<br/>  - echo "Project name = $CI_PROJECT_NAME"<br/>  - echo "Build ref = $CI_BUILD_REF_NAME"<br/>  - pwd<br/>  - ls -ail<br/>  - ...<br/>  <strong class="ne iu">- </strong><strong class="ne iu">apt-get install -y --no-install-recommends node-gyp python make g++ bash git libgtk2.0-0 libgtk-3-0 libnotify-dev libgconf-2-4 libnss3 libxss1 libasound2 libxtst6 xauth xvfb</strong><br/>  - export NODE_VERSION=$(cat ./.nvmrc)<br/>  - export NPM_VERSION=$(cat ./.npm-version)<br/>  - export NODE_ENV=development<br/>  - echo "Enforcing npm version = ${NPM_VERSION}"<br/><strong class="ne iu">  - npm install --global npm@${NPM_VERSION}</strong><br/>  - echo "Default environment:"<br/>  - env<br/>  - echo "Installing dependencies"<br/><strong class="ne iu">  - "[ -d node_modules ] || npm ci --no-progress --quiet"</strong><br/>  - date<br/><br/>cache:<br/>  key: ${CI_COMMIT_SHA}<br/>  paths: ['node_modules/']<br/><br/>Init:<br/>  stage: init<br/>  script: ['']<br/>  cache:<br/>    policy: push<br/>    key: ${CI_COMMIT_SHA}<br/>    paths: ['node_modules/']</span></pre><p id="1f4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您在上面看到的，这个管道配置在每个作业之前做了很多工作:</p><ul class=""><li id="ce8e" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">安装了很多系统级的包，比如node-gyp(我还是讨厌你node-gyp！)</li><li id="dd06" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">已在全球范围内安装预期版本的npm</li><li id="5f03" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">安装了项目的依赖项(包括Cypress)</li></ul><p id="3a02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，在整个管道的开始，一个init脚本将node_modules中的文件推送到缓存中。</p><p id="51c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:我想知道使用不同的缓存键，但认为它不会有多大帮助，因为大量的时间浪费在压缩/解压缩存档文件上…</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="9b09" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">失败的尝试</h1><p id="7eec" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">在我的调查中，我尝试了各种组合:</p><ul class=""><li id="65d0" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">不缓存任何内容</li><li id="bbf9" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">仅缓存npm缓存</li><li id="b20c" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">仅缓存node_modules文件夹</li><li id="d9f1" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">使用Gitlab的<a class="ae kz" href="https://docs.gitlab.com/ee/ci/pipelines/job_artifacts.html" rel="noopener ugc nofollow" target="_blank">作业工件</a>特性，而不是缓存机制</li><li id="87a0" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">结合缓存机制和工件</li><li id="4bea" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi">…</li></ul><p id="d5cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">经过这一切，我意识到在那里没有解决方案；整个管道构建时间仍然非常长(总共超过40分钟)。</p><p id="083d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我需要尝试一些别的东西。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="86f1" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">使用自定义Docker图像</h1><p id="c3cd" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">通过仔细查看init脚本，我意识到大部分时间都被浪费了:</p><ul class=""><li id="6e64" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">在管道的每个作业之前，反复安装相同的系统包</li><li id="b757" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">第一次使用冷缓存安装npm和项目依赖项</li><li id="7842" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">第一次打包/上传node_modules内容</li><li id="dfbe" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">在后续作业中下载/解包node_modules内容</li></ul><p id="6b2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于此，我决定创建一个定制的Docker映像，扩展官方的NodeJS映像来做我需要的所有事情，一劳永逸。</p><p id="22e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我对这幅图像的目标是:</p><ul class=""><li id="b9ce" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">安装一次系统包，这样每个管道作业就不必再这样做了</li><li id="1818" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">使用<code class="fe no np nq ne b">NPM_CACHE_FOLDER</code>环境变量定义全局npm缓存位置</li><li id="c5eb" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">安装一次npm，这样每个管道作业就不必再这样做了</li><li id="686c" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">安装一次项目依赖项，以便npm缓存在每个管道作业开始时处于“热”状态</li><li id="38d3" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">使用环境变量<code class="fe no np nq ne b">CYPRESS_CACHE_FOLDER</code>定义全局<a class="ae kz" href="https://docs.cypress.io/guides/getting-started/installing-cypress.html#Binary-cache" rel="noopener ugc nofollow" target="_blank"> Cypress缓存位置</a></li><li id="75e7" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">按照Cypress 的<a class="ae kz" href="https://docs.cypress.io/guides/guides/continuous-integration.html#Caching" rel="noopener ugc nofollow" target="_blank">缓存指南的建议，安装一次Cypress，这样每个管道作业就不必再这样做了</a></li></ul><p id="9571" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我就是这么做的。</p><p id="2e93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我现在已经结束的docker文件:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="900d" class="ni li it ne b gy nj nk l nl nm"># ---------------------------------------------------------------<br/># CI image<br/># - Used for Gitlab (see .gitlab-ci.yml)<br/># - MUST be updated whenever the CI installation requirements (i.e., packages/versions) change<br/># ---------------------------------------------------------------</span><span id="1ebb" class="ni li it ne b gy nn nk l nl nm"># ARGS are declared before any FROM so that they are globally available<br/># Reference: <a class="ae kz" href="https://github.com/docker/for-mac/issues/2155#issuecomment-372639972" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/for-mac/issues/2155#issuecomment-372639972</a><br/><strong class="ne iu">ARG BASE_DOCKER_IMAGE</strong></span><span id="b32d" class="ni li it ne b gy nn nk l nl nm"># ---------------------------------------------------------------<br/># Base image<br/># - Configure cache folders for npm and cypress<br/># - Install npm and cypress<br/># ---------------------------------------------------------------<br/><strong class="ne iu">FROM ${BASE_DOCKER_IMAGE} as base</strong></span><span id="3d9a" class="ni li it ne b gy nn nk l nl nm"># Args<br/><strong class="ne iu">ARG NODE_VERSION<br/>ARG NPM_VERSION<br/>ARG CYPRESS_VERSION</strong></span><span id="f5d7" class="ni li it ne b gy nn nk l nl nm"># Env<br/>ENV NODE_VERSION="${NODE_VERSION}"<br/>ENV NPM_VERSION="${NPM_VERSION}"<br/>ENV NODE_ENV=development</span><span id="13fd" class="ni li it ne b gy nn nk l nl nm">ENV CYPRESS_VERSION="${CYPRESS_VERSION}"</span><span id="e588" class="ni li it ne b gy nn nk l nl nm"># good colors for most applications<br/>ENV TERM xterm</span><span id="94cb" class="ni li it ne b gy nn nk l nl nm"># avoid million NPM install messages<br/>ENV npm_config_loglevel warn</span><span id="a637" class="ni li it ne b gy nn nk l nl nm"># allow installing when the main user is root<br/>ENV npm_config_unsafe_perm true</span><span id="e5c6" class="ni li it ne b gy nn nk l nl nm"># avoid too many progress messages<br/>ENV CI=1</span><span id="f327" class="ni li it ne b gy nn nk l nl nm"># For cypress<br/># disable shared memory X11 affecting Cypress v4 and Chrome<br/># References:<br/># <a class="ae kz" href="https://github.com/cypress-io/cypress-docker-images/blob/master/included/4.3.0/Dockerfile" rel="noopener ugc nofollow" target="_blank">https://github.com/cypress-io/cypress-docker-images/blob/master/included/4.3.0/Dockerfile</a><br/># <a class="ae kz" href="https://github.com/cypress-io/cypress-docker-images/issues/270" rel="noopener ugc nofollow" target="_blank">https://github.com/cypress-io/cypress-docker-images/issues/270</a><br/>ENV QT_X11_NO_MITSHM=1<br/>ENV _X11_NO_MITSHM=1<br/>ENV _MITSHM=0</span><span id="d23e" class="ni li it ne b gy nn nk l nl nm"># Define the npm cache folder<br/>ENV NPM_CACHE_FOLDER=/root/.cache/npm</span><span id="c722" class="ni li it ne b gy nn nk l nl nm"># point Cypress at the /root/cache no matter what user account is used<br/># see <a class="ae kz" href="https://on.cypress.io/caching" rel="noopener ugc nofollow" target="_blank">https://on.cypress.io/caching</a><br/>ENV CYPRESS_CACHE_FOLDER=/root/.cache/Cypress</span><span id="be6d" class="ni li it ne b gy nn nk l nl nm">RUN mkdir -p ~/.gnupg &amp;&amp; \<br/>  echo "disable-ipv6" &gt;&gt; ~/.gnupg/dirmngr.conf &amp;&amp; \<br/>  # General packages<br/>  apt-get update &amp;&amp; \<br/>  apt-get install -y --no-install-recommends bash curl gnupg dirmngr ca-certificates gnupg-agent software-properties-common apt-transport-https node-gyp python make g++ git &amp;&amp; \<br/>  # Cypress packages<br/>  apt-get install -y --no-install-recommends libgtk2.0-0 libgtk-3-0 libnotify-dev libgconf-2-4 libnss3 libxss1 libasound2 libxtst6 xauth xvfb &amp;&amp; \<br/>  # Docker packages<br/>  curl -fsSL <a class="ae kz" href="https://download.docker.com/linux/debian/gpg" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/debian/gpg</a> | apt-key add - &amp;&amp; \<br/>  add-apt-repository "deb [arch=amd64] <a class="ae kz" href="https://download.docker.com/linux/debian" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/debian</a> $(lsb_release -cs) stable" &amp;&amp; \<br/>  apt-get update &amp;&amp; \<br/>  apt-get install -y --no-install-recommends docker-ce docker-ce-cli containerd.io &amp;&amp; \<br/>  apt-get purge --auto-remove -y dirmngr gnupg ca-certificates &amp;&amp; \<br/>  rm -rf /var/lib/apt/lists/*</span><span id="166e" class="ni li it ne b gy nn nk l nl nm"># Install npm &amp; Cypress<br/>RUN npm install --global npm@${NPM_VERSION} &amp;&amp; \<br/>  npm install -g "cypress@${CYPRESS_VERSION}" &amp;&amp; \<br/>  echo "Cypress configuration:" &amp;&amp; \<br/>  cypress cache path &amp;&amp; \<br/>  cypress cache list &amp;&amp; \<br/>  cypress info &amp;&amp; \<br/>  cypress verify</span><span id="01fa" class="ni li it ne b gy nn nk l nl nm"># Useful to inspect the image<br/>#ENTRYPOINT ["/bin/bash"]<br/>#CMD []</span><span id="b9d6" class="ni li it ne b gy nn nk l nl nm"># ---------------------------------------------------------------<br/># Prefill npm cache image<br/># - Installs our dependencies so that the npm cache is "hot" in the image<br/># - We do not keep this image! It is only used to help construct the final image<br/># ---------------------------------------------------------------<br/>FROM base as npm-install</span><span id="baa5" class="ni li it ne b gy nn nk l nl nm">RUN mkdir /temp<br/>WORKDIR /temp</span><span id="c8d7" class="ni li it ne b gy nn nk l nl nm">RUN echo "Work dir: $(pwd)"<br/>COPY --chown=root:root package.json package-lock*.json ./</span><span id="1278" class="ni li it ne b gy nn nk l nl nm"># Install npm dependencies<br/>RUN npm ci --cache ${NPM_CACHE_FOLDER} --no-audit --no-optional</span><span id="1233" class="ni li it ne b gy nn nk l nl nm">RUN echo "$(ls -ail ${NPM_CACHE_FOLDER})"</span><span id="c404" class="ni li it ne b gy nn nk l nl nm"># Useful to inspect the image<br/>#ENTRYPOINT ["/bin/bash"]<br/>#CMD []</span><span id="c886" class="ni li it ne b gy nn nk l nl nm"># ---------------------------------------------------------------<br/># Final CI image<br/># - Take the base image and add the npm cache to it (not the node modules of the project)<br/># ---------------------------------------------------------------<br/>FROM base as ci</span><span id="977e" class="ni li it ne b gy nn nk l nl nm">COPY --from=npm-install ${NPM_CACHE_FOLDER} ${NPM_CACHE_FOLDER}<br/>RUN echo "$(ls -ail ${NPM_CACHE_FOLDER})"</span><span id="6ad6" class="ni li it ne b gy nn nk l nl nm"># Useful to inspect the image<br/>#ENTRYPOINT ["/bin/bash"]<br/>#CMD []</span></pre><p id="ce8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们一步一步来。</p><p id="f908" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，图像需要定义几个参数:</p><ul class=""><li id="9f22" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated"><strong class="kd iu"> BASE_DOCKER_IMAGE </strong>:要使用的基础图像；在这种情况下，它被一个特定版本的<a class="ae kz" href="https://hub.docker.com/_/node/" rel="noopener ugc nofollow" target="_blank">官方基础Node.js Docker镜像</a>所取代(例如node-12.15.0-slim)</li><li id="91fa" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated"><strong class="kd iu"> NODE_VERSION </strong>:项目使用的节点版本的引用</li><li id="63c1" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated"><strong class="kd iu"> NPM版本</strong>:要使用的NPM版本</li><li id="5e61" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated"><strong class="kd iu"> CYPRESS_VERSION </strong>:要使用的CYPRESS版本</li></ul><p id="4244" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我传入这些参数的原因是为了能够根据monorepo依赖关系的发展，轻松地创建这个映像的新版本。你可以在这里找到更多关于Dockerfile args <a class="ae kz" href="https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="e014" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦接收到这些参数，我就使用ENV指令将它们转换成环境变量，这样我就可以在图像中使用它们。</p><p id="4808" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我为npm和Cypress定义了一些其他有用的环境变量:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="19ac" class="ni li it ne b gy nj nk l nl nm"># Env<br/>ENV NODE_VERSION="${NODE_VERSION}"<br/>ENV NPM_VERSION="${NPM_VERSION}"<br/>ENV NODE_ENV=development</span><span id="7d67" class="ni li it ne b gy nn nk l nl nm">ENV CYPRESS_VERSION="${CYPRESS_VERSION}"</span><span id="0ea8" class="ni li it ne b gy nn nk l nl nm"># good colors for most applications<br/>ENV TERM xterm</span><span id="b410" class="ni li it ne b gy nn nk l nl nm"># avoid million NPM install messages<br/>ENV npm_config_loglevel warn</span><span id="b3ab" class="ni li it ne b gy nn nk l nl nm"># allow installing when the main user is root<br/>ENV npm_config_unsafe_perm true</span><span id="acef" class="ni li it ne b gy nn nk l nl nm"># avoid too many progress messages<br/>ENV CI=1</span><span id="ad99" class="ni li it ne b gy nn nk l nl nm"># For cypress<br/># disable shared memory X11 affecting Cypress v4 and Chrome<br/># References:<br/># <a class="ae kz" href="https://github.com/cypress-io/cypress-docker-images/blob/master/included/4.3.0/Dockerfile" rel="noopener ugc nofollow" target="_blank">https://github.com/cypress-io/cypress-docker-images/blob/master/included/4.3.0/Dockerfile</a><br/># <a class="ae kz" href="https://github.com/cypress-io/cypress-docker-images/issues/270" rel="noopener ugc nofollow" target="_blank">https://github.com/cypress-io/cypress-docker-images/issues/270</a><br/>ENV QT_X11_NO_MITSHM=1<br/>ENV _X11_NO_MITSHM=1<br/>ENV _MITSHM=0</span><span id="774d" class="ni li it ne b gy nn nk l nl nm"># Define the npm cache folder<br/>ENV NPM_CACHE_FOLDER=/root/.cache/npm</span><span id="7347" class="ni li it ne b gy nn nk l nl nm"># point Cypress at the /root/cache no matter what user account is used<br/># see <a class="ae kz" href="https://on.cypress.io/caching" rel="noopener ugc nofollow" target="_blank">https://on.cypress.io/caching</a><br/>ENV CYPRESS_CACHE_FOLDER=/root/.cache/Cypress</span></pre><p id="130f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我安装了我需要的所有系统级包，遵循的最佳实践是避免创建太多的层，并在可能经常变化的部分之间取得平衡。</p><p id="6f5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我只是在一个RUN语句中重新组合了所有这些内容(因此所有这些内容都在一个层中结束，但是如果有帮助的话，我可以稍后再将它们分开:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="0a43" class="ni li it ne b gy nj nk l nl nm">RUN mkdir -p ~/.gnupg &amp;&amp; \<br/>  echo "disable-ipv6" &gt;&gt; ~/.gnupg/dirmngr.conf &amp;&amp; \<br/>  # General packages<br/>  apt-get update &amp;&amp; \<br/>  apt-get install -y --no-install-recommends bash curl gnupg dirmngr ca-certificates gnupg-agent software-properties-common apt-transport-https node-gyp python make g++ git &amp;&amp; \<br/>  # Cypress packages<br/>  apt-get install -y --no-install-recommends libgtk2.0-0 libgtk-3-0 libnotify-dev libgconf-2-4 libnss3 libxss1 libasound2 libxtst6 xauth xvfb &amp;&amp; \<br/>  # Docker packages<br/>  curl -fsSL <a class="ae kz" href="https://download.docker.com/linux/debian/gpg" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/debian/gpg</a> | apt-key add - &amp;&amp; \<br/>  add-apt-repository "deb [arch=amd64] <a class="ae kz" href="https://download.docker.com/linux/debian" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/debian</a> $(lsb_release -cs) stable" &amp;&amp; \<br/>  apt-get update &amp;&amp; \<br/>  apt-get install -y --no-install-recommends docker-ce docker-ce-cli containerd.io &amp;&amp; \<br/>  apt-get purge --auto-remove -y dirmngr gnupg ca-certificates &amp;&amp; \<br/>  rm -rf /var/lib/apt/lists/*</span></pre><p id="0a51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦有了系统包，我就安装通过参数指定的npm和Cypress版本。这样，映像就包含了预期的版本:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="bc44" class="ni li it ne b gy nj nk l nl nm"># Install npm &amp; Cypress<br/>RUN npm install --global npm@${NPM_VERSION} &amp;&amp; \<br/>  npm install -g "cypress@${CYPRESS_VERSION}" &amp;&amp; \<br/>  echo "Cypress configuration:" &amp;&amp; \<br/>  cypress cache path &amp;&amp; \<br/>  cypress cache list &amp;&amp; \<br/>  cypress info &amp;&amp; \<br/>  cypress verify</span></pre><p id="3a86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以上所有内容代表了我的配置项Dockerfile文件的“基本”映像，如下所示:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="11ad" class="ni li it ne b gy nj nk l nl nm"><strong class="ne iu">FROM ${BASE_DOCKER_IMAGE} as base</strong></span></pre><p id="5fba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“基础”是我与那个“子”图像联系在一起的名字。</p><p id="84cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我实际上定义了一个<a class="ae kz" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多级Dockerfile </a>,“基地”镜像是第一级。</p><p id="c740" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在映像的下一阶段，我安装monorepo的依赖项。我在一个单独的阶段这样做，因为我实际上并不关心已安装的依赖项。我真正关心的是作为安装的一部分创建的npm缓存。</p><p id="9867" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，在这一阶段，我添加package.json和package-lock.json文件，运行npm ci，指定要使用的缓存文件夹位置:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="3f54" class="ni li it ne b gy nj nk l nl nm"># ---------------------------------------------------------------<br/># Prefill npm cache image<br/># - Installs our dependencies so that the npm cache is "hot" in the image<br/># - We do not keep this image! It is only used to help construct the final image<br/># ---------------------------------------------------------------<br/>FROM base <strong class="ne iu">as npm-install</strong></span><span id="0b6e" class="ni li it ne b gy nn nk l nl nm">RUN mkdir /temp<br/>WORKDIR /temp</span><span id="bd5c" class="ni li it ne b gy nn nk l nl nm">RUN echo "Work dir: $(pwd)"<br/>COPY --chown=root:root package.json package-lock*.json ./</span><span id="15e6" class="ni li it ne b gy nn nk l nl nm"># Install npm dependencies<br/>RUN npm ci <strong class="ne iu">--cache ${NPM_CACHE_FOLDER}</strong> --no-audit --no-optional</span><span id="aba5" class="ni li it ne b gy nn nk l nl nm">RUN echo "$(ls -ail ${NPM_CACHE_FOLDER})"</span></pre><p id="124f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我可以做的一个改进是直接删除创建的node_modules文件夹，因为它没有用，只会浪费我的磁盘空间。</p><p id="6cb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在映像的最后阶段(真正重要的阶段)，我简单地从“基础”阶段扩展并复制npm缓存文件夹的内容:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="620b" class="ni li it ne b gy nj nk l nl nm"># ---------------------------------------------------------------<br/># Final CI image<br/># - Take the base image and add the npm cache to it (not the node modules of the project)<br/># ---------------------------------------------------------------<br/>FROM base as ci</span><span id="28ab" class="ni li it ne b gy nn nk l nl nm">COPY --from=npm-install ${NPM_CACHE_FOLDER} ${NPM_CACHE_FOLDER}<br/>RUN echo "$(ls -ail ${NPM_CACHE_FOLDER})"</span></pre></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="f6d0" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">创建和发布Docker图像</h1><p id="fa6f" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">为了创建Docker映像，我使用了一个简单的bash脚本:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="7b7a" class="ni li it ne b gy nj nk l nl nm">#!/usr/bin/env bash<br/><br/># Reference: https://stackoverflow.com/questions/19331497/set-environment-variables-from-file-of-key-value-pairs<br/># Import env vars<br/>set -o allexport<br/>source ./.env<br/>set +o allexport<br/><br/>echo "-----------------------------------"<br/>echo "Create CI image                    "<br/>echo "-----------------------------------"<br/><br/># Identify the version of Cypress used by the project<br/>export CYPRESS_VERSION="$(cat package.json | jq '.devDependencies.cypress' -r)"<br/><br/>echo "Building the Docker image for CI: ${CI_DOCKER_IMAGE_NAME}"<br/><br/># Build arg values are passed automatically because they have the same name in the Dockerfile<br/># Reference: https://vsupalov.com/docker-build-pass-environment-variables/#using-host-environment-variable-values-to-set-args<br/>docker ${DOCKER_EXTRA_OPTIONS} build \<br/>       ${DOCKER_BUILD_EXTRA_OPTIONS} \<br/>       --build-arg DOCKER_BASE_IMAGE \<br/>       --build-arg NODE_VERSION \<br/>       --build-arg NPM_VERSION \<br/>       --build-arg CYPRESS_VERSION \<br/>       --file Dockerfile \<br/>       --tag ${CI_DOCKER_IMAGE_NAME}:latest \<br/>       --tag ${CI_DOCKER_IMAGE_NAME}:${PROJECT_COMMIT_HASH} \<br/>       --tag ${CI_DOCKER_IMAGE_NAME}:${PROJECT_VERSION} \<br/>       .</span></pre><p id="1d14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，它使用<a class="ae kz" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>实用程序从package.json文件中提取要使用的Cypress版本，然后调用docker build，向它传递不同的参数。</p><p id="c96d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，图像被适当地标记。</p><p id="b4f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，第一行加载一个包含项目所有变量的env文件，但这超出了本文的范围。</p><p id="9ed9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">发布图像非常简单:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="5a03" class="ni li it ne b gy nj nk l nl nm">#!/usr/bin/env bash<br/><br/>source .env<br/><br/>echo "----------------------------------------------------"<br/>echo "Pushing the CI Docker image to Docker Hub"<br/>echo "----------------------------------------------------"<br/><br/>cat ~/.docker-hub-access-token | docker login --username ${DOCKER_USER} --password-stdin<br/><br/>docker push ${CI_DOCKER_IMAGE_NAME}:latest<br/>docker push ${CI_DOCKER_IMAGE_NAME}:${PROJECT_COMMIT_HASH}<br/>docker push ${CI_DOCKER_IMAGE_NAME}:${PROJECT_VERSION}</span></pre><p id="2999" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此，您需要有一个包含Docker hub访问密钥的文件(或环境变量)。可以参考<a class="ae kz" href="https://ropenscilabs.github.io/r-docker-tutorial/04-Dockerhub.html" rel="noopener ugc nofollow" target="_blank">这篇文章</a>了解如何将图片发布到Docker hub。</p><p id="2a87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最初，我想在我们自己的Docker注册表上发布我的图像，但默认情况下，Gitlab runners只能从Docker hub拉图像；这对公共使用是有意义的。</p><p id="256c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为这个图像是公开的，所以这不是问题。</p><p id="4906" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">瞧，图像现在在Docker hub上，</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="7873" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">重构的CI/CD管道</h1><p id="a2f1" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">现在让我们回到我们的管道配置。</p><p id="dbee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经有了一个基本的Dockerfile文件，其中包含了我们需要的大部分内容，我们可以稍微清理一下了:</p><pre class="ml mm mn mo gt nd ne nf ng aw nh bi"><span id="6b4b" class="ni li it ne b gy nj nk l nl nm"><strong class="ne iu">image: developassion/didowi-ci:latest</strong><br/><br/>...</span><span id="7d1c" class="ni li it ne b gy nn nk l nl nm">before_script:<br/>  - date<br/>  - echo "Pipeline ID = $CI_PIPELINE_ID"<br/>  - echo "Project name = $CI_PROJECT_NAME"<br/>  - echo "Build ref = $CI_BUILD_REF_NAME"<br/>  - whoami<br/>  - pwd<br/>  - ls -ail<br/>  - echo "Default environment:"<br/>  - env<br/>  - date<br/>  # FIXME track the following issue for performance improvements https://gitlab.com/gitlab-org/gitlab-runner/issues/1797<br/>  # Current approach: install everything based on cache for each job<br/>  - echo "Installing dependencies (if needed)"<br/>  # The NPM_CACHE_FOLDER env variable is defined in the Didowi CI dockerfile<br/>  - if [[ ! -d node_modules ]] || [[ -n `git diff --name-only origin/master HEAD | grep "\package-lock.json\b"` ]]; then npm ci --cache ${NPM_CACHE_FOLDER} --prefer-offline --no-audit --no-optional; fi<br/>  - date<br/><br/>...</span></pre><p id="f7cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么有什么变化呢？</p><ul class=""><li id="0682" class="mp mq it kd b ke kf ki kj km mr kq ms ku mt ky mu mv mw mx bi translated">我已经用自己的图像替换了base Node.js图像</li><li id="e88d" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">我已经删除了“缓存”指令</li><li id="3805" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">我已经删除了初始化脚本</li><li id="08c7" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">我已经删除了系统软件包安装</li><li id="04f8" class="mp mq it kd b ke my ki mz km na kq nb ku nc ky mu mv mw mx bi translated">我已经移除了npm安装</li></ul><p id="3989" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我保留了npm包的安装，因为基本映像只包含一个预填充的npm缓存，但是由于缓存是热的，安装要快得多。</p><p id="8d5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样！</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="157b" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">丰富</h1><p id="c0fe" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">既然流水线使用了定制的Docker映像，许多繁琐/重复的任务初始化工作就简单地<em class="nr">消失了</em>。</p><p id="c8c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个作业仍然需要安装npm依赖项，但是由于缓存是热的(大部分时间)，安装时间非常快(大约2分钟)</p><p id="77bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这大大减少了管道的执行时间，在我们的例子中减少到20分钟。我确信事情可以进一步改善，但我已经对新的现状感到满意了。</p><p id="1d61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在映像中缓存Cypress二进制文件的事实也是有益的，因为我们避免了npm安装期间漫长而痛苦的下载。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="6c0a" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">需要注意的事项</h1><p id="34c1" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">Docker映像很好，因为一旦被缓存，Gitlab运行者就可以立即启动它，但是它也有缺点:</p><p id="8080" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只要项目依赖关系发生变化，映像中包含的npm缓存就会过时/不完整。在一段时间内，我们可以接受“大多数”依赖项将被缓存，只有少数需要在每个管道作业开始时下载。要解决这个问题，我们只需要考虑足够频繁地更新图像，以使缓存保持相关。</p><p id="2471" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一种需要重建/重新发布映像的情况是monorepo使用的节点、npm或Cypress版本发生变化。这并不经常，所以这是完全可以接受的。</p><h1 id="ebbb" class="lh li it bd lj lk ns lm ln lo nt lq lr ls nu lu lv lw nv ly lz ma nw mc md me bi translated">后续步骤</h1><p id="8e8b" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">将来，我计划再次回到这个话题，当然希望能够从Gitlab CI的缓存特性的改进中受益。我认为有希望，因为多个PRs正在工作，但我们会看到它如何帮助。</p><p id="c92a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，我将坚持我的解决方案..；-)</p><p id="2275" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你对这篇文章有什么想法/意见，请随时加入进来。</p><p id="2eca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天到此为止！</p><p id="0053" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">PS:对于那些不知道的人，我有一份时事通讯，如果你想了解关于现代网络的新文章和很酷的东西，你可以订阅:<a class="ae kz" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">https://mailchi.mp/fb661753d54a/developassion-newsletter</a></p></div></div>    
</body>
</html>