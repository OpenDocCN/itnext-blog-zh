<html>
<head>
<title>Configuring EAP subsystems with Galleon</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Galleon配置EAP子系统</h1>
<blockquote>原文：<a href="https://itnext.io/configuring-eap-subsystems-with-galleon-9c824684a7bd?source=collection_archive---------5-----------------------#2021-01-13">https://itnext.io/configuring-eap-subsystems-with-galleon-9c824684a7bd?source=collection_archive---------5-----------------------#2021-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3e2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然绿地Java开发更有可能从基于Spring Boot、Microprofile或Quarkus的API驱动设计开始，但在传统JEE运行时基础上构建的遗留应用程序仍有很长的寿命。人们不应该为了获得容器化的好处而大量重构现有的应用程序。</p><p id="0bdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是传统环境通常会有特定于应用程序的配置调整。配置传统的JEE运行时并没有想象中那么简单。直到最近，还没有容易的中间立场；开发人员要么必须满足于现成的EAP配置，要么覆盖整个服务器配置的副本。后者意味着在两次发布之间手动将上游变更集成到他们的定制版本中。EAP 7.3通过一个名为<a class="ae kl" href="https://docs.wildfly.org/galleon/" rel="noopener ugc nofollow" target="_blank"> Galleon </a>的工具增加了选择，该工具允许开发人员管理较小的服务器配置。</p><p id="134d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，简单的Galleon例子仍然少之又少。让我们通过应用一个小的服务器配置更改来支持一个遗留应用程序，从而解决这个问题。</p><p id="b4fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的遗留应用程序通过POST方法将大量参数发送回服务器。EAP 7.3将POST和query参数的限制设置为1000个。这是很多，但传统应用程序发送的更多。在我们的传统环境中，我们已经在回流子系统的HTTP侦听器上设置了<a class="ae kl" href="https://access.redhat.com/solutions/2757361" rel="noopener ugc nofollow" target="_blank"> max-parameters </a>。让我们看看如何在Galleon上实现这一点。</p><h1 id="c268" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">查找配置路径</h1><p id="3332" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Galleon的配置似乎遵循EAP API。有几种方法可以找到路径。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/5a45f439d0a8a156e21c4a2eed55afd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*UMu56ganRieZFo1CnnJPMA.png"/></div></figure><p id="0fd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器的web UI包括一个用于管理模型的浏览器，可在右下角的“工具”下访问。容器化安装不会启用web UI，但是JBoss CLI实用程序可以用来查找相同的信息。</p><p id="cc94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将使用Docker启动EAP映像的副本，并使用<code class="fe lx ly lz ma b">docker exec</code>在单独的窗口中运行CLI工具。(类似的，Kubernetes用户启动一个裸pod，用<code class="fe lx ly lz ma b">kubectl exec</code>代替。)</p><p id="e505" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">$ docker run -it --rm --name eap73 registry.redhat.io/jboss-eap-7/eap73-openjdk11-openshift-rhel8</code></p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="0bc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">EAP现在运行在一个名为<code class="fe lx ly lz ma b">eap73</code>的容器中。我们现在将从另一个窗口启动CLI。</p><p id="f5f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">$ docker exec -it eap73 /opt/eap/bin/jboss-cli.sh --connect</code></p><p id="6a36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该看到这样的提示:</p><p id="e4bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">[standalone@localhost:9990 /]</code></p><p id="6832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以通过<code class="fe lx ly lz ma b">ls</code>和<code class="fe lx ly lz ma b">cd</code>探索CLI。在某些领域，它使用<code class="fe lx ly lz ma b">/</code>作为路径分隔符。在其他情况下，它使用<code class="fe lx ly lz ma b">=</code>。制表符补全会有所帮助，因为它会在适当的时候自动添加<code class="fe lx ly lz ma b">=</code>。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="4a94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想配置回流子系统。键入<code class="fe lx ly lz ma b">ls /sub</code>并点击&lt;标签&gt;会导致<code class="fe lx ly lz ma b">ls /subsystems=</code>。我们执行:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="5013" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续以这种方式，我们进一步深入。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="6153" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就在那里:<code class="fe lx ly lz ma b">max-parameters=1000</code>，在<code class="fe lx ly lz ma b">/subsystem=undertow/server=default-server/http-listener=default</code>。</p><p id="5747" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用Control-C关闭两个终端窗口。我们在EAP管理模型中有路径。</p><p id="fbd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是现在我们该怎么办呢？</p><h1 id="83e5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用Galleon应用配置</h1><p id="85ce" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">总体目标是将我们的应用程序容器化。当通过S2I调用时(通过<a class="ae kl" href="https://github.com/openshift/source-to-image/releases" rel="noopener ugc nofollow" target="_blank"> S2I CLI </a>或通过OpenShift BuildConfig)，EAP镜像可以调用Galleon来应用自定义配置。该配置应该包含在<code class="fe lx ly lz ma b">galleon/provisioning.xml</code>的源代码树中。</p><p id="5fed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从一个基于Red Hat的<a class="ae kl" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.3/html/getting_started_with_jboss_eap_for_openshift_container_platform/capability-trimming-eap-foropenshift_default#custom-provisioning-files-jboss-eap_default" rel="noopener ugc nofollow" target="_blank">文档</a>的最小文件开始。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="2286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回想一下，EAP管理模型中的路径是<code class="fe lx ly lz ma b">/subsystem=undertow/server=default-server/http-listener=default</code>。我们将通过在<code class="fe lx ly lz ma b">&lt;config/&gt;</code>元素中添加一个新块来将其映射到Galleon配置。我们将在每个路径元素上进行构建，以获得最终的块。</p><p id="f74d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个<code class="fe lx ly lz ma b">/subsystem=undertow</code>。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="0db3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是<code class="fe lx ly lz ma b">/subsystem=undertow/server=default-server</code>。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="51a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意名称(default-server)是如何指定的:作为一个<code class="fe lx ly lz ma b">&lt;param&gt;</code>，其名称和值取自CLI路径的末尾。也就是<code class="fe lx ly lz ma b">server=default-server</code>变成了<code class="fe lx ly lz ma b">&lt;param name=”server” value=”default-server”/&gt;</code>。</p><p id="ccc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们省略了这个<code class="fe lx ly lz ma b">&lt;param&gt;</code>条目，Galleon将会报告“Non-nil lable parameter server of { EAP-servlet @ maven(org . JBoss . universe:product-universe)} subsystem . under flow . server尚未初始化”并失败。</p><p id="46e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们按照这个模式来添加HTTP侦听器。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="cf0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以包含我们想要设置的属性。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="ed72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将这个插入到我们之前的最小<code class="fe lx ly lz ma b">galleon/provisioning.xml</code>中，现在已经完成了。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h1 id="42c1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">确认</h1><p id="4754" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们证明这是可行的。为了使用CLI进行测试，将我们的<code class="fe lx ly lz ma b">galleon/provisioning.xml</code>添加到您的Maven项目中，然后运行构建。</p><p id="f037" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">$ s2i build . registry.redhat.io/jboss-eap-7/eap73-openjdk11-openshift-rhel8 app</code></p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="e9a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像以前一样，让我们使用EAP CLI来检查。这里有细微的变化；我们将我们的容器映像称为<code class="fe lx ly lz ma b">app</code>，S2I的输出将jboss-cli.sh放在一个不同于原始EAP映像的路径中。</p><p id="8de9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个终端上:</p><p id="56d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">$ docker run -it --rm --name app app</code></p><p id="633f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器启动后，从另一个窗口启动CLI:</p><p id="7712" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">$ docker exec -it app /s2i-output/server/bin/jboss-cli.sh --connect</code></p><p id="917d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看我们的http-listener配置。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="ffe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成功！S2I进程构建了我们的应用程序，并创建了一个定制的服务器配置，其中包括我们指定的最少量的配置。</p></div></div>    
</body>
</html>