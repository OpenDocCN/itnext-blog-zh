<html>
<head>
<title>Refactor from Monolith Workflow to Micro-Workflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从整体工作流到微观工作流的重构</h1>
<blockquote>原文：<a href="https://itnext.io/refactor-from-monolith-workflow-to-micro-workflows-92afcc49c8ec?source=collection_archive---------5-----------------------#2022-05-27">https://itnext.io/refactor-from-monolith-workflow-to-micro-workflows-92afcc49c8ec?source=collection_archive---------5-----------------------#2022-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="0f0e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="f6be" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">工作流被视为在当前计算中定义和实现复杂应用的不可或缺的工具。业务流程的自动化有助于组织和客户自动处理和计算多个步骤和工作，而无需任何干预。工作流技术和过程在现代复杂计算环境中起着核心作用。如今，许多公司都在追逐大多数项目的微服务架构。在这里，工作流引擎在编排各种服务中起着至关重要的作用。这对于处理状态、监控、报告等也非常有帮助。</p><p id="0822" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在许多情况下，我注意到工作流是作为一个单一的中心组件实现的，然而该项目有多个组件来展示微服务架构的行为。工作流引擎不一定要实现为一个单一的中央组件。它可以选择作为多个分散的工作流引擎，以避免整体行为和SPOF(单点故障)。</p><h1 id="99db" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">为什么要使用工作流来进行编排或编排？</h1><p id="623c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在项目中引入和开发工作流之前，理解编排和编排的概念是非常重要的。基于这种理解，工作流的角色将被定义，否则微服务架构的某个地方将会受到损害。</p><h2 id="5e60" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">管弦乐编曲</h2><p id="8a7c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">服务编排指定了一个集中的可执行业务流程，该流程协调不同服务之间的交互。编排者负责构思和整合服务。编排采用集中的方法进行服务组合。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/4fc9cccc71c3fd590516ba914f75dace.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*alaoibPmOnVHnXes.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图1:编排</figcaption></figure><h2 id="6c78" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">舞蹈编排</h2><p id="0711" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">服务编排是参与服务的全局定义，由两个或多个端点之间的消息交换、交互规则和理解来指定。编排采用了一种分散的服务组合方法。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/a7ebe0d47fd23a7a802c66ddcdbbad6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*LJ3QnhZgkYIVLrYX.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图2:编排</figcaption></figure><p id="0049" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">编排和编排都是有价值的交流方式，不同的策略需要其中之一。工作流引擎对于编排来说非常有价值，因为它允许显式地对流程建模，并在流程运行时对其进行实时监控。它有利于管理长期运行的流程的状态。然而，编排可以屠杀微服务并创建分布式整体。它创建了一个紧密耦合的环境。在这里，服务相互之间紧密依赖，任何一点的失败都可能导致流程停止。</p><h1 id="584f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Monolith工作流示例</h1><p id="e0a4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们假设一家企业想要在一个实时场景中执行几个机器学习或深度学习模型，其中有几个重要步骤。步骤可以是数据预处理、模型的注册和验证、数据的识别和基于特定数据的特定模型的执行、监控模型的执行状态、通过给予其他服务收集和存储由模型产生的结果、通知不同的服务、清理作业等。</p><p id="181c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这些不同的步骤将调用不同的服务，有时一个服务的结果依赖于另一个服务。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/578c65c6e899a9fb7874def438e048d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2zY3PZEORXXGxTHCppJ0g.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图3:整体工作流程</figcaption></figure><p id="4fde" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这里的危险是，它失去了大规模流动的图片。理解流程、修改流程或处理流程变得极其困难。在这里，工作流引擎演变为架构的中心组件，需要正确操作，微服务之间的通信仅通过工作流完成。此外，该组件在可用性要求方面更为关键。</p><p id="3a57" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">大约十年来，工作流引擎(BPM工具)一直占据着中心地位。这是运行一个复杂系统的唯一方法。在现代系统和架构中，对于非常灵活的现代工具来说，这不再是真的。</p><p id="4a83" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">所有现代运动，如DDD或微服务，都要求组件去中心化，以实现更大的灵活性和独立性，这意味着尽快将变化投入生产，这将是未来成功企业的关键能力。</p><h1 id="599a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">分散工作流引擎，使其成为微型工作流</h1><p id="b2a5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">基于不同的相似功能，工作流可以是分散的。</p><p id="4c67" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">上述工作流程可分为四种不同的工作流程:</p><ul class=""><li id="1ec9" class="mr ms iq kn b ko lj ks lk kw mt la mu le mv li mw mx my mz bi translated">数据预处理、模型识别、验证和ML模型的执行</li><li id="1dc7" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li mw mx my mz bi translated">监视</li><li id="5d93" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li mw mx my mz bi translated">结果存储</li><li id="6975" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li mw mx my mz bi translated">清除</li></ul><h2 id="ae97" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">工作流程I:数据预处理、模型识别、验证和ML模型的执行</h2><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nf"><img src="../Images/8e7313bbb7e59c2aa1daa51cff60dc4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8_oMWU_HXiJGckHNONt7w.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图4:数据预处理、模型识别、验证和ML模型的执行</figcaption></figure><h2 id="65b8" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">工作流II:监控ML模型的执行</h2><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/bf9bc9b6ff4c62551e881777efdda130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*lEVIbipmFstYzm-U5Pc7uw.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图5:监控ML模型的执行</figcaption></figure><h2 id="78ad" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">工作流程三:结果存储</h2><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c4a68d17a511e2b9785dae715594108b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*4hZ08NrsN07CbqOaP9hBMQ.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图6:结果的存储</figcaption></figure><h2 id="e6ce" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">工作流四:清理</h2><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/cd8d84f343ddbbd0181d9b7bb472b611.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*JjcCpjNe_SLVFbFuKW15gg.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图7:清理</figcaption></figure><h1 id="fca0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="cbe7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">分散的工作流方法是正确的选择，因为它只是与微服务值同步。服务的每个部分都可以单独扩展。ML模型的执行和监控需要更多的资源，因此两者都可以单独扩展。引擎上的负载也可以使决策变得清晰——因为众多的引擎也意味着分配负载。</p></div></div>    
</body>
</html>