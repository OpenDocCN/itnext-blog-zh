<html>
<head>
<title>How To Make Your Website Work Offline part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让你的网站离线工作第二部分</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-make-your-website-work-offline-part-2-6923b9038dd6?source=collection_archive---------3-----------------------#2020-03-03">https://itnext.io/how-to-make-your-website-work-offline-part-2-6923b9038dd6?source=collection_archive---------3-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f5a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的动态内容也可以脱机使用</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4300c6422729f9dcc352f453f459e19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FvFv0sVNaLhirq_z"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Maksym Kaharlytskyi 在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="aeac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的上一篇文章中，我向你展示了如何通过使用一个服务人员来让你的静态网站离线工作。</p><p id="031e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是今天大多数网站不仅有静态内容，还有动态内容。例如，这些内容可能来自REST API，当客户端离线时，这种类型的内容通常不可用。</p><p id="8822" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，浏览器为此提供了一个解决方案，服务人员已经为您做好了准备，因为您也可以缓存它。</p><h1 id="9f8e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">缓存动态内容</h1><p id="89f7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">每当向API发出请求时，我们可以缓存响应以备后用。如果再次发出相同的请求，但由于某种原因失败了，我们只提供之前缓存的响应。</p><p id="9c9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些响应可以使用<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"> IndexedDB </a>进行缓存，这是一个面向对象的客户端键值存储，可以持久存储大量的结构化数据。虽然<code class="fe mi mj mk ml b">localStorage</code>和<code class="fe mi mj mk ml b">sessionStorage</code>对于存储少量数据很有用，但是IndexedDB对于大量数据更有用。</p><p id="250a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">IndexedDB拥有出色的浏览器支持:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mm"><img src="../Images/20cd0be33c3c17973407bf9dfec66f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hca0dZY0ttIlhhOvVxdhDQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自caniuse.com的IndexedDB浏览器支持</figcaption></figure><p id="f841" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为IndexedDB中的所有数据都是用一个键索引的，所以它提供了对这些数据的高性能搜索，这使得它非常适合缓存API响应。</p><p id="2ba8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是<code class="fe mi mj mk ml b">fetch</code>事件处理程序，它负责缓存我们的API请求和响应:</p><pre class="kp kq kr ks gt mn ml mo mp aw mq bi"><span id="222e" class="mr lg it ml b gy ms mt l mu mv">self.addEventListener('fetch', e =&gt; {<br/>  const {method, url} = e.request;<br/>  const requestClone = e.request.clone();</span><span id="c3fd" class="mr lg it ml b gy mw mt l mu mv">  // if the url of the request contains '/api', it's a call to <br/>  // our api<br/>  if(url.includes('/api')) {<br/>    e.respondWith(<br/>      fetch(e.request)<br/>      .then(response =&gt; {<br/>        const responseClone = response.clone();</span><span id="af3c" class="mr lg it ml b gy mw mt l mu mv">        // here we cache the response for future use<br/>        if(method === 'GET') {<br/>          cacheApiResponse(responseClone);<br/>        }</span><span id="ead8" class="mr lg it ml b gy mw mt l mu mv">        return response;<br/>      })<br/>      .catch(err =&gt; {         <br/>         // something went wrong in calling our api, let serve <br/>         // the response we cached earlier<br/>         if(method === 'GET') {<br/>           return getCachedApiResponse(e.request);<br/>         }<br/>         // if it was a POST request we tried to write something <br/>         // to our api.<br/>         // let's save the request and try again later     <br/>         if(method === 'POST') {<br/>           cacheApiRequest(requestClone);</span><span id="66cb" class="mr lg it ml b gy mw mt l mu mv">           return new Response(JSON.stringify({<br/>              message: 'POST request was cached'<br/>           }));<br/>         }<br/>       })<br/>   );<br/> }<br/> else {<br/>   e.respondWith(<br/>     caches.match(e.request)<br/>     .then(response =&gt; response ? response : fetch(e.request))<br/>   );<br/> }<br/>});</span></pre><p id="f976" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设API的url是<code class="fe mi mj mk ml b">https://www.oursite.com/api</code>，那么当请求的URL包含<code class="fe mi mj mk ml b">/api</code>时，我们知道这是对API的调用。然后我们通过用<code class="fe mi mj mk ml b">fetch(e.request)</code>调用<code class="fe mi mj mk ml b">e.respondWith</code>来传递它，这基本上只是转发相同的请求。</p><p id="5a8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当响应到达时，它需要被克隆，然后用<code class="fe mi mj mk ml b">cacheApiResponse</code>方法保存到IndexedDB(下面的实现),然后被服务。</p><p id="66b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，当获取时发生错误，并且从<code class="fe mi mj mk ml b">fetch(e.request)</code>返回的承诺被拒绝时，我们捕捉错误并提供一个API响应，该响应在之前用<code class="fe mi mj mk ml b">getCachedApiResponse(e.request)</code>缓存。</p><p id="33a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过这种方式，我们可以确保对动态内容的调用也会成功，即使用户离线或者API由于其他原因无法访问。</p><h2 id="a5d4" class="mr lg it bd lh mx my dn ll mz na dp lp kb nb nc lt kf nd ne lx kj nf ng mb nh bi translated">自动同步</h2><p id="600d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">上面的例子都是关于获取数据的GET请求，但是如果你需要POST请求来在后端保存数据呢？</p><p id="9e78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您所看到的，在上面的例子中的<code class="fe mi mj mk ml b">catch</code>子句中有一个POST请求的检查:</p><pre class="kp kq kr ks gt mn ml mo mp aw mq bi"><span id="1210" class="mr lg it ml b gy ms mt l mu mv">.catch(err =&gt; {<br/>  ...</span><span id="58a1" class="mr lg it ml b gy mw mt l mu mv">  if(method === 'POST') {<br/>    cacheApiRequest(requestClone);</span><span id="630b" class="mr lg it ml b gy mw mt l mu mv">    return new Response(JSON.stringify({<br/>      message: 'POST request was cached'<br/>    }));<br/>  }<br/>})</span></pre><p id="1e7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着每当对API的POST请求失败时，例如，由于用户离线，使用<code class="fe mi mj mk ml b">cacheApiRequest</code>方法(下面的实现)保存请求的一个克隆，并返回一个定制响应，指示POST请求已保存。</p><p id="0350" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这允许我们保存对IndexedDB所做的所有更改，并在用户重新上线时将这些更改发送到后端。</p><p id="671c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每当用户的连接恢复时，就会触发一个<code class="fe mi mj mk ml b">sync</code>事件，我们可以重试之前进行的API调用:</p><pre class="kp kq kr ks gt mn ml mo mp aw mq bi"><span id="0286" class="mr lg it ml b gy ms mt l mu mv">self.addEventListener('sync', e =&gt; {<br/>    e.waitUntil(retryApiCalls());<br/>});</span></pre><h2 id="692a" class="mr lg it bd lh mx my dn ll mz na dp lp kb nb nc lt kf nd ne lx kj nf ng mb nh bi translated">预加载响应</h2><p id="5db6" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">到目前为止，我们已经看到了如何为之前缓存的静态资产提供服务，以及如何保存API响应以便以后在API不可用或用户离线时从缓存中为它们提供服务。</p><p id="60bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是获取动态内容的API调用必须首先至少进行一次<em class="ni"/>，这样它们才能被缓存以供后续调用。这意味着任何不是首先进行的API调用都不会被缓存，因此当用户脱机时也不可用。</p><p id="468b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你的网站只包含静态的HTML页面，你可以在<code class="fe mi mj mk ml b">install</code>事件中缓存这些页面，把它们提供给<code class="fe mi mj mk ml b">cache.addAll()</code>调用:</p><pre class="kp kq kr ks gt mn ml mo mp aw mq bi"><span id="91d2" class="mr lg it ml b gy ms mt l mu mv">const filesToCache = [<br/>  '/index.html',<br/>  '/about.html',<br/>  '/blog/posting.html'</span><span id="121d" class="mr lg it ml b gy mw mt l mu mv">...<br/>];</span><span id="5e2a" class="mr lg it ml b gy mw mt l mu mv">self.addEventListener('install', e =&gt; {<br/>  e.waitUntil(<br/>    caches.open(cacheName)<br/>    .then(cache =&gt; cache.addAll(filesToCache))<br/>  );<br/>});</span></pre><p id="6c40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们实际上可以为任何或某些API调用做同样的事情，这些API调用将从我们的网站预取内容。例如，如果你的网站是一个博客，你可以预先获取你最近或最受欢迎的帖子，这样即使用户离线，他们也可以立即获得。</p><p id="3be2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用户只需要访问你的网站的一个页面，当服务人员被激活时，我们预取我们想要的内容。合适的位置是服务人员的<code class="fe mi mj mk ml b">activate</code>事件:</p><pre class="kp kq kr ks gt mn ml mo mp aw mq bi"><span id="b4e8" class="mr lg it ml b gy ms mt l mu mv">self.addEventListener('activate', e =&gt; {<br/>  ...</span><span id="7587" class="mr lg it ml b gy mw mt l mu mv">  const postings = [<br/>    '/api/blog/1'<br/>    '/api/blog/12'<br/>    '/api/blog/7'<br/>  ];<br/> <br/>  e.waitUntil(async () =&gt; {<br/>    await Promise.all(postings.map(url =&gt; prefetch(url)));<br/>  }());<br/>});</span><span id="7582" class="mr lg it ml b gy mw mt l mu mv">const prefetch = async url =&gt; {<br/>  const response = await fetch(url);<br/>  const clone = response.clone();<br/>  <br/>  cacheApiResponse(clone);<br/>};</span></pre><p id="0237" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mi mj mk ml b">activate</code>事件中，我们迭代一个数组，该数组包含我们最受欢迎的博客帖子的URL。然后在后台获取每个帖子，并使用<code class="fe mi mj mk ml b">cacheApiResponse</code>方法存储。</p><p id="998b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们能够从缓存中提供所有这些帖子，因此它们将立即可用，而无需网络呼叫。</p><p id="99b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不仅你的网站现在完全可以离线使用，它还会立即加载，给用户一个类似应用程序的体验。</p><p id="a8b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我建议你深入<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"> IndexedDB </a>学习它的API。挺简单的，很好学。</p><p id="a3de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是完整的服务人员，评论中有解释:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">缓存API请求和响应的服务工作者</figcaption></figure><h1 id="dfd0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">如何以及何时缓存</h1><p id="1c34" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在上面的服务工作者示例中，我们首先尝试从缓存中提供API调用，如果失败，我们尝试网络。</p><p id="2424" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，我们也可以通过网络调用所有API，并且在网络不可用时只提供缓存的响应。其他策略也是可能的，例如仅网络或仅高速缓存。</p><p id="9976" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一篇文章中，我们将深入探讨我们可以采用的各种缓存策略。</p></div></div>    
</body>
</html>