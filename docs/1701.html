<html>
<head>
<title>Istio End-User Authentication for Kubernetes using JSON Web Tokens (JWT) and Auth0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JSON Web令牌(JWT)和Auth0对Kubernetes进行Istio最终用户身份验证</h1>
<blockquote>原文：<a href="https://itnext.io/securing-kubernetes-withistio-end-user-authentication-using-json-web-tokens-jwt-97f4bb8e71c6?source=collection_archive---------0-----------------------#2019-01-07">https://itnext.io/securing-kubernetes-withistio-end-user-authentication-using-json-web-tokens-jwt-97f4bb8e71c6?source=collection_archive---------0-----------------------#2019-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f600" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在最近的帖子<a class="ae ko" href="https://medium.com/@GaryStafford/building-a-microservices-platform-with-confluent-cloud-mongodb-atlas-istio-and-google-c2279526ea84" rel="noopener">用融合云、MongoDB Atlas、Istio和Google Kubernetes引擎</a>构建微服务平台中，我们在Google云平台上用<a class="ae ko" href="https://cloud.google.com/istio/docs/istio-on-gke/overview" rel="noopener ugc nofollow" target="_blank"> Istio </a> 1.0.x构建并部署了一个基于微服务的云原生API给Google Kubernetes引擎。为了简洁起见，我们有意省略了操作和保护API所需的一些关键特性。这些缺失的特性包括HTTPS、用户认证、请求配额、请求节流，以及一个完整生命周期API管理工具的集成，比如Google <a class="ae ko" href="https://apigee.com/api-management/#/homepage" rel="noopener ugc nofollow" target="_blank"> Apigee </a>。</p><p id="6bc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在后续的文章<a class="ae ko" href="https://medium.com/@GaryStafford/securing-your-istio-ingress-gateway-with-https-8c59972cb5d7" rel="noopener">用HTTPS保护您的Istio入口网关</a>中，我们禁用了对运行在GKE集群上的API的HTTP访问。然后，我们使用HTTPS启用了客户端和GKE集群之间的双向通信加密。</p><p id="6b7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将通过使用基于JSON Web令牌的凭证启用<a class="ae ko" href="https://istio.io/help/ops/security/end-user-auth/" rel="noopener ugc nofollow" target="_blank"> Istio最终用户身份验证</a>，进一步增强店面演示API的安全性。使用JSON Web Tokens (JWT)，发音为'<em class="kp">jot【T11]'，将允许Istio对调用店面演示API的最终用户进行身份验证。作为基于OAuth 2.0令牌的授权流程的一部分，我们将使用认证即服务提供商<a class="ae ko" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>为注册的店面演示API消费者生成JWT令牌，并验证来自Istio的JWT令牌。</em></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/7ef63f090aa1825f994bb9ac4c498b31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*4kPp_M9gsTk7l9dw"/></div></figure><h1 id="9fca" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JSON Web令牌</h1><p id="0c76" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">根据Auth0的说法，基于令牌的身份验证的工作原理是，确保向服务器发出的每个请求都附有一个签名令牌，服务器验证该令牌的真实性，然后才响应请求。根据<a class="ae ko" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank"> JWT.io </a>的说法，JWT是一个开放标准(<a class="ae ko" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>)，它以JSON对象的形式定义了一种在各方之间安全传输信息的紧凑且独立的方式。该信息可以被验证和信任，因为它是数字签名的。其他常见的令牌类型包括简单Web令牌(SWT)和安全声明标记语言令牌(SAML)。</p><p id="5f72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">jwt可以使用基于<a class="ae ko" href="https://en.wikipedia.org/wiki/HMAC" rel="noopener ugc nofollow" target="_blank">哈希的消息认证码</a> (HMAC)算法的秘密进行签名，或者使用<a class="ae ko" href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" rel="noopener ugc nofollow" target="_blank">Rivest–sha mir–ad leman</a>(RSA)或<a class="ae ko" href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" rel="noopener ugc nofollow" target="_blank">椭圆曲线数字签名算法</a> (ECDSA)的公钥/私钥对进行签名。授权是使用JWT最常见的场景。在令牌有效负载中，您可以轻松指定用户角色和权限以及用户可以访问的资源。</p><p id="2846" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个注册的API消费者向授权服务器发出一个初始请求，在这个请求中，他们用某种形式的凭证交换一个令牌。JWT与一组特定的用户角色和权限相关联。每个后续请求都将包含令牌，允许用户访问该令牌允许的授权路由、服务和资源。</p><h1 id="ebdd" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Auth0</h1><p id="fd56" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">要使用JWTs通过Istio进行最终用户身份验证，我们需要一种方法来验证与特定用户相关联的凭证，并将这些凭证交换为JWT。此外，我们需要一种方法来验证来自Istio的jwt。为了满足这些要求，我们将使用Auth0。Auth0 为web、移动和遗留应用程序提供了一个通用的认证和授权平台。据<a class="ae ko" href="https://www.g2crowd.com/categories/customer-identity-and-access-management" rel="noopener ugc nofollow" target="_blank"> G2 Crowd </a>报道，Auth0在<a class="ae ko" href="https://en.wikipedia.org/wiki/Customer_Identity_Access_Management" rel="noopener ugc nofollow" target="_blank">客户身份和访问管理</a> (CIAM)软件类别的竞争对手包括Okta、微软Azure Active Directory (AD)和AD B2C、Salesforce Platform: Identity、OneLogin、Idaptive、IBM Cloud Identity Service和Bitium。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/ea6a88cc6c902c132499256d1a78fa46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*clvinu4H43_sW0oJ"/></div></figure><p id="20ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Auth0目前提供四种定价方案:免费、开发者、开发者专业版和企业版。计划订阅按月或按年打折。对于这个演示的有限要求，你只需要使用Auth0的免费计划。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/d58abf65fc101137a16a035e1a75d563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*QN_kOpfaHij65c6n"/></div></figure><p id="7742" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">OAuth 2.0协议<a class="ae ko" href="https://auth0.com/docs/protocols/oauth2" rel="noopener ugc nofollow" target="_blank">定义了四种流</a>或<em class="kp">授权类型</em>，以获取访问令牌，这取决于应用架构和最终用户的类型。我们将模拟一个需要使用店面API的第三方外部应用程序，使用<a class="ae ko" href="https://oauth.net/2/grant-types/client-credentials/" rel="noopener ugc nofollow" target="_blank">客户端凭证</a>授权类型。根据<a class="ae ko" href="https://auth0.com/docs/api-auth/tutorials/client-credentials" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>，OAuth 2.0授权框架<a class="ae ko" href="https://tools.ietf.org/html/rfc6749#section-4.4" rel="noopener ugc nofollow" target="_blank"> RFC 6749第4.4节</a>中定义的客户端凭证授权允许应用程序使用其客户端Id和客户端机密请求访问令牌。它用于非交互式应用程序，如CLI、守护程序或在您的后端上运行的服务，其中令牌颁发给应用程序本身，而不是最终用户。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/d2bb570913eac33f5a0a3ea68f0a1627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/0*LhNVo8eFFFaSVwJ8.png"/></div></figure><p id="2766" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于Auth0，我们需要创建两种类型的实体，一个Auth0 <a class="ae ko" href="https://auth0.com/docs/apis" rel="noopener ugc nofollow" target="_blank"> API </a>和一个Auth0 <a class="ae ko" href="https://auth0.com/docs/applications" rel="noopener ugc nofollow" target="_blank">应用程序</a>。首先，我们定义一个Auth0 API，它代表我们正在保护的店面API。其次，我们定义了一个Auth0应用程序，它是我们API的消费者。应用程序与API相关联。这种关联允许应用程序(<em class="kp">API</em>的消费者)使用Auth0进行身份验证，并接收一个JWT。注意Auth0和Istio或Storefront API之间没有直接集成。我们正在促进Auth0、Istio和使用API的注册终端用户应用程序之间的解耦、相互信任关系。</p><p id="a26b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先创建一个新的Auth0 API，即“店面演示API”。对于这个演示，我使用我的域的URL作为标识符。要与Istio一起使用，请选择RS256(带SHA-256的RSA签名)，这是一种使用公钥/私钥对的非对称算法，与HS256对称算法相反。对于RS256，Auth0将使用相同的私钥来创建签名和验证签名。Auth0发表了一篇关于RS256与HS256算法使用的好文章。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/eda3d46390ffcb649106643d654d646e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*RUxJs0Os3EQ1ZQBK"/></div></figure><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/b7d0d9602a75e40e63a053b5b94913e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*iGw3Hh4xNdtgdUf9"/></div></figure><p id="7256" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Auth0允许通过使用作用域对API进行粒度访问控制。根据<a class="ae ko" href="https://auth0.com/docs/scopes/current" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>，OAuth 2.0术语中由访问令牌表示的权限被称为作用域。<code class="fe mc md me mf b">scope</code>参数允许应用程序表达访问请求的期望范围。授权服务器还可以在响应中使用<code class="fe mc md me mf b">scope</code>参数来指示哪些作用域被实际授予了权限。</p><p id="3759" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管有必要为我们的Auth0应用程序定义和分配至少一个作用域，但我们实际上不会使用这些作用域来控制对Storefront API中的资源的细粒度授权。在本演示中，如果最终用户通过了身份验证，他们将被授权访问所有Storefront API资源。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/2d9b79657a54f9e37204e9069e777644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*f2O86eW8VVWLcNMM"/></div></figure><p id="b680" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，定义一个新的Auth0机器对机器(M2M)应用程序，“Storefront Demo API Consumer 1”。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/2414b880e3cdc4ebc488a11283fe319a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*dQILS2zrQ0db62Dl"/></div></figure><p id="0cea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，授权新的M2M应用程序请求访问新的店面演示API。同样，我们没有使用作用域，但是至少需要一个作用域，否则稍后您将无法进行身份验证。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/60e2276eedb62ec095bc61723c8a814b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*JZsu-5HGs6r2VUC-"/></div></figure><p id="62ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个M2M应用程序都有一个唯一的客户端ID和客户端密码，用于向Auth0服务器进行身份验证并检索JWT。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/fc868cdbbbb0f240552f89f94d9f0a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*3aAtpp1dvuLukYLb"/></div></figure><p id="24e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">多个M2M应用程序可以被授权请求访问API。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/36ceb016a76733a268cea5088989aed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*07j_q7jgB9IwFB4_"/></div></figure><p id="9919" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在“高级应用程序设置”的“端点”选项卡中，有一系列OAuth URLs。为了授权我们的新M2M应用程序使用店面演示API，我们需要“OAuth授权URL”。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/87a18ac4c53eb92e75f7efed63a686a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*N3AnHviagp4qFYrg"/></div></figure><p id="65ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了测试基于Auth0 JWT的身份验证和授权工作流，我更喜欢使用Postman。方便的是，Auth0提供了一个<a class="ae ko" href="https://auth0.com/docs/api/info" rel="noopener ugc nofollow" target="_blank"> Postman集合</a>，其中包含了您需要的所有HTTP请求，已经构建好了。使用<a class="ae ko" href="https://auth0.com/docs/api-auth/tutorials/client-credentials" rel="noopener ugc nofollow" target="_blank">客户端凭证</a> POST请求。<code class="fe mc md me mf b">grant_type</code>标题值将始终为<code class="fe mc md me mf b">client_credentials</code>。您需要提供Auth0应用程序的客户端ID和客户端秘密作为<code class="fe mc md me mf b">client_id</code>和<code class="fe mc md me mf b">client_secret</code>头值。<code class="fe mc md me mf b">audience</code>头值将是您之前用来创建Auth0 API的API标识符。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/959b3a56dcbf01aca340ea0c8f81c712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*u3b-vdxjivKCVMHG"/></div></figure><p id="d00a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果HTTP请求成功，您应该会收到一个JWT <code class="fe mc md me mf b">access_token</code>作为响应，这将允许我们稍后使用Storefront API进行身份验证。注意，用Auth0定义的作用域也是响应的一部分，还有令牌的TTL。</p><h1 id="418a" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">jwt.io调试器</h1><p id="a054" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">现在，使用<a class="ae ko" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> jwt.io </a>调试器页面测试JWT。如果一切正常，JWT应该可以成功验证。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/86b166f2cb15f1b448e1b5da34c02a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*FovVNOG6MN-Rd3L0"/></div></figure><h1 id="164a" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Istio身份验证策略</h1><p id="e6ad" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">为了使用JWT和Auth0启用Istio最终用户身份验证，我们向现有的已部署资源集添加了一个<a class="ae ko" href="https://istio.io/docs/reference/config/istio.authentication.v1alpha1/#Policy" rel="noopener ugc nofollow" target="_blank"> Istio策略身份验证资源</a>。对于最终用户身份验证，您有几个选择，例如:</p><ol class=""><li id="e094" class="mg mh it js b jt ju jx jy kb mi kf mj kj mk kn ml mm mn mo bi translated">通过Istio入口网关全局应用于所有名称空间的所有服务；</li><li id="cdb9" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated">本地应用于特定名称空间(即<code class="fe mc md me mf b">uat</code>)内的所有服务；</li><li id="a479" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated">本地应用于特定名称空间内的一个或多个服务(即<code class="fe mc md me mf b">prod.accounts</code>)；</li></ol><p id="9330" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，由于您可能有多个具有不同角色的API注册消费者，因此您将有多个身份验证策略应用于集群。</p><p id="a6cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个演示中，我们将在<a class="ae ko" href="https://istio.io/docs/tasks/traffic-management/ingress/" rel="noopener ugc nofollow" target="_blank"> Istio入口网关</a>使用JWTs对Storefront API启用全局最终用户身份验证。为了创建一个Istio认证策略资源，我们使用Istio认证API版本<code class="fe mc md me mf b">authentication.istio.io/v1alpha1</code> ( <a class="ae ko" href="https://gist.github.com/garystafford/2437110cfb64a16ca3cefa224fb8a3c5" rel="noopener ugc nofollow" target="_blank"> <em class="kp">要点</em> </a>)。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a632" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单个<code class="fe mc md me mf b">audiences</code> YAML地图值与您在之前的Postman请求中使用的受众头值相同，这是您之前用于创建Auth0 Storefront演示API的API标识符。<code class="fe mc md me mf b">issuer</code> YAML标量值是Auth0 M2M应用程序的域值，可在“Storefront Demo API Consumer 1”设置选项卡中找到。<code class="fe mc md me mf b">jwksUri</code> YAML标量值是JSON Web Key Set URL值，可以在高级应用程序设置的Endpoints选项卡中找到。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/47f348eaa955c3370ae6e0bb65b311ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*nUePpQRYlip3nMl-"/></div></figure><p id="b02b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JSON Web密钥集URL是一个可公开访问的端点。Istio将访问该端点以获取用于认证JWT的公钥。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/89ce15afdb0617727515d867d315ca03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*cBMyFS2aRIpqVQz6"/></div></figure><p id="4aff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您已经将Storefront API部署到GKE集群，只需应用新的Istio策略。我们现在应该已经使用JSON Web令牌在Istio入口网关上启用了最终用户身份验证。</p><pre class="kr ks kt ku gt mw mf mx my aw mz bi"><span id="2020" class="na kz it mf b gy nb nc l nd ne">kubectl apply -f ./resources/other/ingressgateway-jwt-policy.yaml</span></pre><h1 id="f04e" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">细粒度认证</h1><p id="da0d" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">如果需要对资源进行更细粒度的身份验证，也可以跨名称空间对特定的一个或多个服务应用Istio身份验证策略。下面，我们看到一个只对<code class="fe mc md me mf b">uat</code>名称空间应用策略的例子。当您想要控制对非生产环境中的资源的访问时，这种场景是很常见的，例如UAT、外部测试团队或一组选定的外部beta测试人员。根据<a class="ae ko" href="https://istio.io/docs/tasks/security/authn-policy/#namespace-wide-policy" rel="noopener ugc nofollow" target="_blank"> Istio </a>，要跨单个名称空间应用名称空间范围的最终用户身份验证，必须将策略命名为<code class="fe mc md me mf b">default</code> ( <a class="ae ko" href="https://gist.github.com/garystafford/9b053ccbd9eddefa6bf43515becd2eb6" rel="noopener ugc nofollow" target="_blank"> <em class="kp">要点</em> </a>)。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b331" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到一个更细粒度的策略示例，其范围仅限于<code class="fe mc md me mf b">prod</code>名称空间内的<code class="fe mc md me mf b">accounts</code>服务。当您的API消费者的角色只需要访问API的一部分时，这种情况很常见。例如，一个营销应用程序可能只需要访问<code class="fe mc md me mf b">accounts</code>服务，而不需要访问<code class="fe mc md me mf b">orders</code>或<code class="fe mc md me mf b">fulfillment</code>服务(<a class="ae ko" href="https://gist.github.com/garystafford/40c17e18e677d95f48041dfa00545813" rel="noopener ugc nofollow" target="_blank"> <em class="kp">要点</em> </a>)。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="21ae" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试认证</h1><p id="1d60" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">要测试最终用户身份验证，首先，调用任何有效的Storefront Demo API端点，而不提供授权的JWT。您应该会收到一个“401未授权”HTTP响应代码，以及响应正文中的一条<code class="fe mc md me mf b">Origin authentication failed.</code>消息。这意味着店面演示API现在是不可访问的，除非API消费者提供一个JWT，这可以由Istio成功验证。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/df7ff0f979f93774b9935f33c611ef82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*pFMh-xPW9vMVKHPL"/></div></figure><p id="3f36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，通过选择“Bearer Token”类型的身份验证方法，向Postman请求添加授权。复制并粘贴您之前从客户端凭证请求中收到的JWT ( <code class="fe mc md me mf b">access_token</code>)。这将添加一个<code class="fe mc md me mf b">Authorization</code>请求头。在curl中，请求头看起来如下(<a class="ae ko" href="https://gist.github.com/garystafford/38d0e46e2d6d3cfd88097669272cf5b8" rel="noopener ugc nofollow" target="_blank"> <em class="kp">要点</em> </a>)。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="eeab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向邮递员提出请求。如果正确应用了Istio策略，请求现在应该会收到来自Storefront API的成功响应。成功响应表示Istio针对Auth0授权服务器成功验证了位于授权头中的JWT。然后，Istio允许用户“店面演示API消费者1”应用程序访问所有店面API资源。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/c16fe8eb1532ab840de8f4c6dd227362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*ZP8Mz34M_wKkuben"/></div></figure><h1 id="9471" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">解决纷争</h1><p id="4544" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">Istio有几页关于<a class="ae ko" href="https://istio.io/help/ops/security/end-user-auth/" rel="noopener ugc nofollow" target="_blank">解决</a>认证问题的在线文档。如果您的最终用户身份验证不起作用，但JWT有效，首先要查找的错误之一就是<a class="ae ko" href="https://istio.io/docs/concepts/traffic-management/#pilot-and-envoy" rel="noopener ugc nofollow" target="_blank"> Istio Pilot </a>日志。Istio中用于流量管理的核心组件Pilot管理和配置特定Istio服务网格中部署的所有特使代理实例。Pilot向代理分发身份验证策略，如我们新的最终用户身份验证策略，以及安全的命名信息。</p><p id="8bef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，在Google Stackdriver日志中，我们看到典型的日志条目，表明飞行员无法检索JWT公钥(回想一下，我们使用的是RS256公钥/私钥对<a class="ae ko" href="https://en.wikipedia.org/wiki/Public-key_cryptography" rel="noopener ugc nofollow" target="_blank">非对称算法</a>)。此特定错误是由于Istio策略身份验证资源YAML文件中的打字错误造成的。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/0e319e5f11a3538a61ed47d3aaec764f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*deGsPeopiex0yhK9"/></div></figure><p id="b6d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面我们看到一个Istio Mixer日志条目，其中包含了对Accounts Storefront服务<code class="fe mc md me mf b">/accounts/customers/summary</code>端点的Postman请求的详细信息。根据<a class="ae ko" href="https://istio.io/docs/concepts/policies-and-telemetry/" rel="noopener ugc nofollow" target="_blank"> Istio </a>的说法，Mixer是负责提供策略控制和遥测收集的Istio组件。注意日志条目的<code class="fe mc md me mf b">textPayload</code>的<code class="fe mc md me mf b">apiClaims</code>部分，对应于该请求中传递的JWT的有效载荷段。日志条目清楚地显示，在将请求转发到帐户服务之前，JWT由Istio解码和验证。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/d70bbc836ef3c13d34e42c7ca44a71d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*EUK6SBiq4XcC9y2D"/></div></figure><h1 id="8093" class="ky kz it bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="1ffb" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">在这篇简短的帖子中，我们将终端用户身份验证添加到了店面演示API中，该API使用Istio在GKE上运行。尽管还没有准备好投入生产，但我们已经通过HTTPS客户端-服务器加密和基于JSON Web令牌的授权保护了店面API。下一步将是在Storefront API GKE集群前添加mutual TLS(MTL)和完全托管的API网关，以提供<a class="ae ko" href="https://apigee.com/about/cp/api-management-features" rel="noopener ugc nofollow" target="_blank">高级API功能</a>，如缓存、配额和速率限制。</p><p id="f684" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp">本文表达的所有观点都是我个人的，不一定代表我现在或过去的雇主或他们的客户的观点。</em></p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="5302" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp">原载于2019年1月7日</em><a class="ae ko" href="https://programmaticponderings.com/2019/01/06/securing-kubernetes-withistio-end-user-authentication-using-json-web-tokens-jwt/" rel="noopener ugc nofollow" target="_blank"><em class="kp">programmaticponderings.com</em></a><em class="kp">。</em></p></div></div>    
</body>
</html>