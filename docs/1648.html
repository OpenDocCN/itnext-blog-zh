<html>
<head>
<title>The Android Launch Mode Animated CheatSheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android启动模式动画备忘单</h1>
<blockquote>原文：<a href="https://itnext.io/the-android-launchmode-animated-cheatsheet-6657e5dd9b0f?source=collection_archive---------2-----------------------#2018-12-20">https://itnext.io/the-android-launchmode-animated-cheatsheet-6657e5dd9b0f?source=collection_archive---------2-----------------------#2018-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f65c0732288101e64905fe8996e4b0ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ds71K4oiG5suuDzIEnkGnQ.png"/></div></div></figure><p id="39cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在API 11之前，我们使用活动在屏幕上显示每个新页面。现在有了片段和API 28中的导航工具，完全有可能只用一个活动来制作一个非常复杂的应用程序。然而，活动仍然是将你的应用分成阶段和过程的好方法。也许你想把所有的营销分成一个活动，并在自己的活动中有实际的应用程序。也许你想为某个功能保留一部分，比如聊天服务。了解活动启动模式有助于您以对用户有意义的方式更好地划分这些过程。坐在办公室里，我总是记不住启动模式，所以我想我会写一篇关于它的博客，制作一些gif动画来说明这些概念，然后与大家分享。尽情享受吧！</p><p id="ac0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在讨论启动模式之前，让我们首先了解任务的角色。一个任务包含一组活动，这些活动排列在一个称为backstack的堆栈中。任务中启动的第一个活动是根活动。在根活动上按back按钮不仅会终止活动，还会终止任务，甚至可能终止应用程序。</p><p id="08e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们深入了解一些启动模式！</p><p id="5204" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您有一个任务，其根活动称为活动A，然后启动一个名为B的新活动，B被推到堆栈的顶部。现在，假设您从我们刚刚创建的B启动了另一个活动B，您现在将有两个活动B的实例堆叠在一起。如果用户按下back按钮，他们将返回到活动b的另一个实例，这可能会让用户感到非常困惑。活动在彼此之上的堆叠和创建，不管是什么，都称为<strong class="ka ir">标准</strong>启动模式。如果清单中的活动XML中没有定义启动模式，则该活动将使用标准启动模式。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/91d32ccc38e238f809277a19e007ab5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Sy6JQDhLQAY_FqT9zBpbBA.gif"/></div></div></figure><p id="6158" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们看到了标准模式是如何让用户不舒服，我们现在可以理解<strong class="ka ir">单顶</strong>发射模式。这种启动模式阻止相同活动的不同实例堆叠在一起。假设活动B是单顶。我们可以像这样在清单中定义启动模式:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="54c0" class="lg lh iq lc b gy li lj l lk ll">///AndroidManifest.xml<br/>&lt;application<br/>    ...&gt;<br/>    &lt;activity android:name=".Activity_A"&gt;<br/>        &lt;intent-filter&gt;<br/>            &lt;action android:name="android.intent.action.MAIN" /&gt;<br/>            &lt;category android:name="android.intent.category.LAUNCHER" /&gt;<br/>        &lt;/intent-filter&gt;<br/>    &lt;/activity&gt;</span><span id="735f" class="lg lh iq lc b gy lm lj l lk ll">    &lt;activity android:name=".Activity_B" android:launchMode="singleTop"/&gt;</span><span id="5e1b" class="lg lh iq lc b gy lm lj l lk ll">    &lt;activity android:name=".Activity_C"/&gt;<br/>    &lt;activity android:name=".Activity_D"/&gt;<br/>&lt;/application&gt;</span></pre><p id="d7d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，现在如果您从活动B启动活动B，而不是创建B的新实例并将其堆叠在旧的B之上，则意图被传递到B的当前实例中。在一个任务中拥有同一活动的两个实例的唯一方法是从B启动不同的活动，然后从该活动创建B。单顶启动模式的主要概念是，不能将同一活动的两个实例堆叠在一起。</p><p id="fce6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果在使用单顶启动模式时，您不希望一个任务中有两个相同的单顶活动实例，则可以在您的意图中传递FLAG_ACTIVITY_CLEAR_TOP常量。为了说明这一点，我们假设您的活动堆栈是ABC (B仍然是单顶)。如果你用FLAG_ACTIVITY_CLEAR_TOP从C启动B，你的栈将一直弹出到B，并且意图将被传递到B的那个实例。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4510" class="lg lh iq lc b gy li lj l lk ll">// code example for passing the constant flag in your intent</span><span id="9c7e" class="lg lh iq lc b gy lm lj l lk ll">Intent intent = new Intent(this, Activity_B.class);<br/>intent.addFlags(Intent.<em class="ln">FLAG_ACTIVITY_CLEAR_TOP</em>);<br/>startActivity(intent);</span></pre><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/65ae7735beb8c9ba7ff6779f2569f47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0ItkOoYwYRDSCPpEs-aTIQ.gif"/></div></div></figure><p id="6566" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个发射模式叫做<strong class="ka ir">单任务</strong>。在这种启动模式下，我们声明在应用程序的所有任务中，一个活动只能属于一个任务。因此，类似于FLAG_ACTIVITY_CLEAR_TOP行为，如果您的堆栈是ABC，并且您从C启动B(单个任务),我们会一直弹出到B，并将意图传递给该实例。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="7e4b" class="lg lh iq lc b gy li lj l lk ll">&lt;activity android:name=".Activity_B" android:launchMode="singleTask"/&gt;</span></pre><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/b6f4a4d7744e8a6d20756d4f2ad1a13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6_76zgLvPQQoRRmUrn_w3w.gif"/></div></div></figure><p id="3172" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们希望B在它自己的任务中呢？这就是任务相似性发挥作用的地方。任务关联性允许您定义活动属于哪个任务。默认情况下，活动与其根活动具有相同的任务关联性。有了任务关联，我们现在可以将活动分成不同的任务。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2a58" class="lg lh iq lc b gy li lj l lk ll">&lt;activity android:name=".Activity_A"<br/>    android:taskAffinity="com.affinity.of.a"&gt;<br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.intent.action.MAIN" /&gt;<br/>        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;<br/>    &lt;/intent-filter&gt;<br/>&lt;/activity&gt;</span><span id="25d8" class="lg lh iq lc b gy lm lj l lk ll">&lt;activity android:name=".Activity_B" <br/>    android:launchMode="singleTask"<br/>    android:taskAffinity="com.affinity.of.b"<br/>    /&gt;</span></pre><p id="fe35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，活动A和活动B具有不同的任务关联性。当在任务1中创建A时，C从A启动。默认情况下，每个活动与其根具有相同的亲缘关系，因此我们仍然在任务1中。现在B从c启动。B具有不同的任务关联性，因此它现在是Task 2的根，Task 2然后移动到前台。如果我们从B启动活动C的一个新实例，C属于Task 2，因为它是根活动(在本例中是B)的task affinity。但是如果我们现在在任务2中尝试从C启动A呢？因为A的关联是任务1，所以我们从任务2转移到任务1，一路弹出回到活动A，最后将意图传递给A。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/622ed9a8f6e23de06c1f9a5bef5df836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eh72YhSJBY8p-Xf6fEDATA.gif"/></div></div></figure><p id="bded" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">了解单个任务有助于我们更好地理解最终的发射模式；<strong class="ka ir">单实例</strong>。像单个任务一样，具有单个实例的活动可以是所有任务中唯一的活动。两者的区别在于，具有单个实例的活动也可以是任务中唯一的活动。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="e502" class="lg lh iq lc b gy li lj l lk ll">&lt;activity android:name=".Activity_B"<br/>    android:launchMode="singleInstance"<br/>    android:taskAffinity="com.affinity.of.b"<br/>    /&gt;</span></pre><p id="7f89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，活动B的启动模式为单实例。Task 1中的Activity A启动Activity B。这使得Activity B在一个新的Task中启动，然后被放在前台。然后，活动B启动活动C。由于单个实例可以是任务中的唯一活动，因此，在任务1中，C在活动A之上启动，然后任务1进入前台。</p><p id="6c07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任务相似性在单个实例中也起作用。如果活动B没有任务关联性，则用户不能导航回任务1。如果B具有任务相似性，用户将能够在任务1和任务2之间来回切换。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/91385101b662532e7bfdb4d2b1be6f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1o8nguFVuG0WxgcEMXMBQw.gif"/></div></div></figure><p id="7715" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">了解启动模式有助于我为用户提供更好的UI/UX体验，甚至帮助我解决一些令人头疼的问题，所以我希望这些信息也能帮助你！</p><p id="b6ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想为Anil Deshpande的CodeTutor youtube页面大声欢呼，它帮助我更好地理解了这个概念。这是关于这个主题的七个视频中的第一个:<a class="ae lo" href="https://www.youtube.com/watch?v=m8sf0UkJkxo" rel="noopener ugc nofollow" target="_blank"><em class="ln">【https://www.youtube.com/watch?v=m8sf0UkJkxo】</em></a></p></div></div>    
</body>
</html>