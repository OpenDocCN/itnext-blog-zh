# Express + Knex + Objection =带 DB 的无痛 API

> 原文：<https://itnext.io/express-knex-objection-painless-api-with-db-74512c484f0c?source=collection_archive---------0----------------------->

## 如何在连接到数据库时不对您的代码(和您自己)生气

# TL；速度三角形定位法(dead reckoning)

在本文中，我们将在 Node.js 上为简单的用户/消息数据库构建一个 API 系统。

最终代码可以在[这里](https://github.com/Fodark/express-knex-objection)找到。

## 介绍

由于其通用性质，Node.js 没有提供一种开箱即用的简单方法来连接到数据库，当然有像 [pg](https://www.npmjs.com/package/pg) 或[mongose](https://www.npmjs.com/package/mongoose)这样的包来直接与数据库交互，但是如果您的应用程序足够大，通过这些包管理连接和查询会很容易成为一种痛苦。

我们需要的是:

*   Node.js(任何最新版本都可以)
*   `pg`用于访问 PostgreSQL 数据库，或其他 DBMS 的任何等效物
*   `knex` SQL 构建器
*   `objection`给车型下定义(见后文)
*   `express`定义我们的端点

可选，要展开项目:

*   `body-parser`管理帖子请求

![](img/dfd9aa0749b307ffe644e1da2b88ae71.png)

你不希望你的代码看起来像这样，对吗？

# Knex.js

这是推出第一个套餐的恰当时机； [Knex.js](https://knexjs.org/) 允许在一个单独的文件(名为`knexfile.js`)中轻松定义连接属性，并且可以针对您的开发/测试/生产服务器进行不同的配置。在这个文件中，您还可以定义迁移(创建哪些表)和种子(数据库填充)文件夹，因此您不必手动跟踪您的表和数据。

安装完这个包(`npm install -g knex`)之后，您可以在控制台中键入`knex init`来生成默认的配置文件，在使它适应您的 DB 之后，它应该是这样的:

knex 配置文件示例

然后，您可以创建一个模块，将连接导出到数据库，我称之为`knex.js`

首先，我们了解我们所处的环境，生产服务器通常会导出这个变量，它可以在`process.env.NODE_ENV`中找到，否则我们就在开发服务器中。接下来，我们从之前定义的`knexfile`中获取相关配置，然后在导出时将其传递给库，很容易。

我通常将这个文件放在一个`db`文件夹中，与下一个主题迁移和种子放在一起。

## 迁移

Knex 的一个很大的优点是它的迁移工具可以让你更容易管理数据库的表。它创建带有时间戳的顺序文件，在这些文件中，您可以定义应该创建哪个表和哪些列；它还管理表的变更，因此您可以添加/删除列，而无需接触原始的迁移文件。

如果你在全局范围内安装了 Knex，你可以在不进入`.node_modules`文件夹的情况下访问 bin，所以如果你输入如下内容:

`knex migrate:make users`

它将在您的迁移文件夹中创建一个新文件，导出两个函数，第一个用于表的创建/更改，第二个用于恢复更改(如果您需要的话)。Knex 不知道您使用的是哪个数据库(除了特定的列类型)，所以如果您使用 PostgreSQL/MySQL/SQLite/[…]的话，您可以用相同的类型独立地编写相同的列

典型的迁移如下所示:

在`up`函数中，我们定义了表的名称和字段，而在`down`中，我们说如果我们想要恢复更改，应该删除表。

约束是可能的，比如 not null、唯一性和类似的，但我不会在这里讨论它们，你可以在 knex [网站](https://knexjs.org/)上找到它们。

现在，如果一切配置正确，运行`knex migrate:latest`应该会在您的数据库中创建表，万岁！

## 种子

与迁移一样，我们可以创建种子，因此我们可以一致地填充数据库。该命令类似于迁移命令，我们可以键入

`knex seed:make users`

并且将在 knexfile 中指定的 seeds 文件夹中创建一个标准种子文件。最终它将是这样的，每个条目都被定义为一个 JSON 对象，其字段的名称与迁移中的字段名称相同:

这个函数是做什么的？首先，它删除表中的每个条目，然后用我们的数据填充表。

怎么跑？只需输入【knex 就会做到！

## 额外的

在 repo 中，您可以找到 messages 表的迁移和种子文件，还可以看到如何在 knex 中创建外键；此表稍后将用于显示异议特征。

## 边注

种子文件是按顺序执行的，所以如果你有像表`messages`中的`author_id`这样的约束，你应该确保一个顺序，我通常在种子文件中放一个数字，像`01_users.js`、`02_messages.js`等等。

# Objection.js

[异议](https://vincit.github.io/objection.js/)是基于 Knex 构建的 ORM，它允许为我们的数据库定义模型，我们将在后面看到，以及其他功能，如急切加载、模式验证等……
我们将使用它进行模型和急切加载，这允许我们不必编写复杂的连接查询来获取表之间的相关行。

## 模型

我们要定义的第一件事是我们的模型，它代表我们数据库中的表。我通常将它们存储在`models`文件夹中，以组织我的代码。

使用异议模型所需的最低结构如下:

它只是告诉 Objection 我们数据库中的表名。

但是酷的东西是渴望加载的，假设我们想要得到用户写的每一条消息，通常你会写这样的查询:

你可能会说这并不复杂，但是假设你想在用户对象中使用它们来响应用户，这很容易变得一团糟！

这就是异议模型显示其优势的地方，我们可以轻松地定义表之间的关系，然后使用它们来获得相关行的子集。

所以，如果我们想得到一个用户的消息，我们可以这样定义一个关系:

我们基本上是在说两个表之间有什么关系(一个用户有许多消息)，哪个模块保存另一个表，哪个字段使这种关系成为可能。

第 2–4 行将模型绑定到我们在上一节中定义的数据库连接。

类似于消息模型:

定义反向关系不是强制性的，但拥有它可能是有用的。

是的，现在我们已经正确设置了数据库并定义了模型，最后一件事是为这些资源设置 API！

# 应用程序接口

对于这最后一部分，我们将使用最广为人知的 Node 框架 [Express，](https://www.npmjs.com/package/express)。

## 基础

首先，让我们创建一个简单的`app.js`文件，它启动一个监听端口的服务器。

我们正在导入`express`，并定义服务器应该监听传入请求的端口，然后创建一个新的应用程序，我们将在其中附加端点，并最终让它监听端口。

耶，如果你用`node app.js`开始这个程序，你应该会看到`Listening on port: 3000`或者类似的，很好！

## 端点

接下来，我们希望有一些端点为我们的资源服务，所以让我们创建一个文件夹`api`来存放我们的文件，通常每个资源一个。例如，在`users.js`中，我们可以编写这样的代码来获取数据库中的每个用户:

这是怎么回事？我们使用 Express router 来响应`/users`上的`GET`请求，并且我们使用 Objection 模型来轻松地检索表中的每一行，从 Objection 返回的 JSON 对象可以直接提供给用户。

为了测试它，我们还需要一件事，在我们的应用程序中包括端点，我们的`app.js`将看起来像这样:

很好，我们说:将在`/api/users`中定义的路线附加到基本 url `/api`，启动`node app.js`并让浏览器指向

`localhost:3000/api/users`

你会看到与用户的 JSON，再次欢呼！

## 急切装载

到目前为止一切顺利，但是我们还没有使用我们之前讨论过的急切加载，让我们假设我们想要设置一个端点来获取单个用户，当我们获取单个用户时，我们甚至想要查看他的消息:通常您会设置一个复杂的联合查询，将用户与消息连接起来，但是如果有异议，我们只需要多两行！让我们看看如何:

耶！首先，我们使用 URL 中传递的 ID 使用`where`子句进行过滤，然后，使用关键字`eager`使用模型中定义的关系名称来获取用户的消息，尝试一下，指向:

`localhost:3000/api/users/1`

您将看到一个包含消息对象的子字段 messages，简单！

# 结尾(？)

我们完了，但真的完了吗？不完全是，对传递给 URL 的 ID 没有控制，我们不能处理其他 3 个动作(POST、PUT 和 DELETE ),但这对本文来说太多了。

这个例子可以扩展到更多的表、端点、测试等等。
Objection 还允许在使用急切加载时过滤掉字段，所以如果您有像`password`这样的字段，显然您不想返回给用户，您可以从查询中删除它们。
关于异议，我要说的最后一件很酷的事情是可以将多个急切加载链接在一起。
假设我们给用户附上了图片，给消息附上了评论，您可以像这样轻松地通过一次加载检索到所有内容:

好了，现在真的结束了！

我希望这篇概述有助于您了解 Node 中的数据库管理！喜欢就鼓掌，分享！