<html>
<head>
<title>Ajax in the Fog or HTTP in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">雾中的Ajax还是React中的HTTP</h1>
<blockquote>原文：<a href="https://itnext.io/ajax-in-the-fog-or-http-in-react-b04c716e97e5?source=collection_archive---------1-----------------------#2019-08-11">https://itnext.io/ajax-in-the-fog-or-http-in-react-b04c716e97e5?source=collection_archive---------1-----------------------#2019-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c22b21322fb87feaf797bb9768251d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*YWJNX-QqA_ThSOE2KwCbyQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">迷雾中的刺猬(1975)</figcaption></figure><p id="947d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">所有前端(FE)工程师面对React的第一个问题是如何调用ajax调用。React是一个库，它不能建议任何特定的方式，因为它是为另一个目的设计的——渲染。React将数据(道具、状态或上下文)转换成HTML。</p><p id="b721" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae lf" href="http://reonomy.com" rel="noopener ugc nofollow" target="_blank">经济</a>，我发明了<a class="ae lf" href="https://www.reonomy.com/blog/post/reactive-hooks" rel="noopener ugc nofollow" target="_blank">反应钩</a>。是一个库把RxJS带入了React生态系统。这个库提供了许多钩子，其中之一是<strong class="ka ir"> useRxAjax </strong>，它为React中的HTTP提供了一个简单而优雅的解决方案。</p><p id="bf92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博文中，我将展示一种用ajax获取数据的简单方法，解决缺点，然后展示如何用<strong class="ka ir"> useRxAjax </strong>实现。</p><h1 id="fe8f" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">天真的方法</h1><p id="f455" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在支持React挂钩的React 16中，一个基本的解决方案是在渲染函数中调用fetch(图1)。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mj"><img src="../Images/6a0893d0d0d8a526f3f4b690b9cd244e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvbLJn8TaHH4b03HAKSZlQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图一。React渲染函数中fetch的基本实现。</figcaption></figure><p id="32c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这种实现不处理边缘情况，例如:</p><ol class=""><li id="5564" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">组件在等待响应时被卸载。</li><li id="9540" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">未决状态的指示。</li><li id="bc2d" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">当响应不是200时，应显示一条错误消息。</li></ol><p id="095d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们试图解决这些问题，实现将变得不那么明显。</p><h2 id="ef2e" class="ng lh iq bd li nh ni dn lm nj nk dp lq kj nl nm lu kn nn no ly kr np nq mc nr bi translated">1.组件在等待响应时被卸载。</h2><p id="0efb" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">如果组件被卸载，所有获取请求应被取消，并且根本不应调用<strong class="ka ir"> setFoo </strong>。但是标准的<strong class="ka ir">获取</strong>是不可取消的，所以我们需要更好的东西。</p><p id="7422" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着解决这个问题的第二部分，当组件被卸载时忽略<strong class="ka ir"> setFoo </strong>回调。唯一可用于此目的的标准挂钩是<strong class="ka ir">使用效果</strong>。</p><blockquote class="ns nt nu"><p id="3e40" class="jy jz nv ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated">…你可以把useEffect钩子想成componentDidMount，componentDidUpdate，componentWillUnmount <strong class="ka ir">组合</strong>。</p></blockquote><p id="d12d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果所有东西都结合在一起，我们怎么知道那是不是一个<code class="fe nz oa ob oc b">componentWillUnmount</code>事件呢？答案是我们没有。没有办法用React钩子来处理它，所以我们必须切换回React组件类。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi od"><img src="../Images/f4eca88c8579e363ec007a486f5dd437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpUgygLZVh8D5BHTX_fosw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图二。使用“componentWillUnmount”处理程序对组件做出反应，该处理程序设置一个私有变量“unmounted ”,以防止对陈旧元素的setState调用。</figcaption></figure><p id="ce23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，这一点可以通过将React render函数转换回React Component并使用更高级的HTTP库而不是标准fetch来解决。</p><h2 id="f489" class="ng lh iq bd li nh ni dn lm nj nk dp lq kj nl nm lu kn nn no ly kr np nq mc nr bi translated">2.未决状态的指示。</h2><p id="4edf" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">让我们忽略第(1)点，继续使用React钩子。为了显示挂起状态的指示器，我们需要再添加一个状态。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oe"><img src="../Images/d12696259b4835144b46c0afc2fc2cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z1Kok4_9Rs6mfNTfyaq5lw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图3。处理挂起状态。</figcaption></figure><p id="62b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还不错。只有几行额外的代码，但是现在由于分支和独立的状态，整个实现容易出错。很难预测几个并发请求会发生什么。考虑到setIsPending是异步的，我们可以在请求完成但IsPending仍然为真的状态下结束，反之亦然。</p><h2 id="05fd" class="ng lh iq bd li nh ni dn lm nj nk dp lq kj nl nm lu kn nn no ly kr np nq mc nr bi translated">3.当响应不是200时，应显示一条错误消息。</h2><p id="cec3" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">让我们再创建一个状态，如果发生错误，它将保存一个错误对象；如果请求成功，它将保存一个空值。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oe"><img src="../Images/269902cc5b45c5e6a09edb215338ff86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcMzThE4IUF60FIY-yRf5g.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图4。用错误状态对象处理错误。</figcaption></figure><p id="903f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">能不能做的简单一点，没有bug？认识一下useRxAjax！</p><h1 id="7a50" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak"> useRxAjax </strong></h1><p id="c917" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">调用数据api调用(获取请求)并返回一个带有响应对象和请求调度程序的元组。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi of"><img src="../Images/30b40bef5ae7b1f6dcf419411c7d8c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bbFHM_I1Z4E1LmQ1q4kH7g.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图5。基于useRxAjax的实现。</figcaption></figure><p id="6424" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">响应对象foo将实现一个Http接口(图6 ),并保存关于当前状态、请求体、响应和错误的信息。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/109cc6342175e89360a4e3b5c2a842f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*xN4QzITn2XBDF_6oWaVYDg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图6。Http接口。</figcaption></figure><p id="99a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果组件被卸载，此请求将被自动取消。</p><h2 id="06e6" class="ng lh iq bd li nh ni dn lm nj nk dp lq kj nl nm lu kn nn no ly kr np nq mc nr bi translated">如果我需要对反应产生另一个副作用呢？</h2><p id="061b" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated"><strong class="ka ir"> useRxAjax </strong>接收一个可选的回调，该回调将在每次请求开始、成功或失败时执行。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oh"><img src="../Images/0721c8e97a569f173d6fd114b8dbaeb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxwFKiRgZ--NgsXt7y4FbQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图7。可选回拨。</figcaption></figure><p id="65e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的API参考在<a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/hitchhikers-guide-to-reactive-hooks-92c1a708ccfe">反应式吊钩搭便车指南</a>中有描述。</p><p id="75e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">GitHub:</strong><a class="ae lf" href="http://github.com/reonomy/reactive-hooks" rel="noopener ugc nofollow" target="_blank">http://github.com/reonomy/reactive-hooks</a></p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="98bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获取数据是FE开发中最常见的操作，这就是为什么它应该很容易。当试图处理边缘情况和竞争条件时，任何简单的实现都会变得复杂。但这正是RxJS的设计目的，所以我们为什么不用它呢！Reactive Hooks库提供了RxJS和React之间的无缝集成。它提供了<strong class="ka ir"> useRxAjax </strong>钩子来帮助调用HTTP请求。这个钩子将解决陈旧元素的问题，以及保持代码简洁的竞争条件。</p></div></div>    
</body>
</html>