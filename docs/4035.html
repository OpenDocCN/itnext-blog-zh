<html>
<head>
<title>Create a Custom React Hook for Tracking Browser Window Width (with TypeScript)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个自定义的React钩子来跟踪浏览器窗口宽度(用TypeScript)</h1>
<blockquote>原文：<a href="https://itnext.io/create-a-custom-react-hook-for-tracking-browser-window-width-with-typescript-6211901e9f9d?source=collection_archive---------11-----------------------#2020-04-13">https://itnext.io/create-a-custom-react-hook-for-tracking-browser-window-width-with-typescript-6211901e9f9d?source=collection_archive---------11-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/78c64429863071b13d4057e6dacf99cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yTcNbJTrvAQMglpu"/></div></div></figure><p id="0a32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近我一直在使用定制的React钩子来清理我的代码库，它为我创造了奇迹！我已经设法将如此复杂的重复代码转移到可重用的定制钩子中。</p><p id="b2a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将通过一个例子来说明我是如何使用一个定制的钩子来跟踪我的窗口浏览器窗口的。我非常支持使用TypeScript，所以我当然会在我的例子中使用TypeScript。</p><h1 id="f53c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">在实现挂钩之前</h1><p id="9be9" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">对于那些不熟悉定制钩子的人来说，掌握它们的一个简单方法是识别它们解决的问题。这就是我们如何在不使用自定义钩子的情况下实现我们的功能。</p><p id="f4fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们有一个组件，我们想根据浏览器窗口的宽度来呈现一个不同的组件。</p><p id="955d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">举个例子，</p><ul class=""><li id="4c03" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated">如果窗口宽度为<code class="fe ml mm mn mo b">800px</code>或更大，那么我们想要渲染<code class="fe ml mm mn mo b">Desktop</code>组件。</li><li id="3520" class="mc md it kd b ke mp ki mq km mr kq ms ku mt ky mh mi mj mk bi translated">如果窗口宽度小于<code class="fe ml mm mn mo b">800px</code>，那么我们要渲染<code class="fe ml mm mn mo b">Mobile</code>组件。</li></ul><p id="53d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个简单的解决方案:</p><pre class="mu mv mw mx gt my mo mz na aw nb bi"><span id="07a6" class="nc la it mo b gy nd ne l nf ng">import React, { useEffect, useState } from 'react'</span><span id="fcc0" class="nc la it mo b gy nh ne l nf ng">const MyComponent: FC = () =&gt; {<br/>  const [width, setWidth] = useState(window.innerWidth)<br/>  <br/>  const handleResize = () =&gt; setWidth(window.innerWidth)</span><span id="8ba2" class="nc la it mo b gy nh ne l nf ng">  useEffect(() =&gt; {<br/>    window.addEventListener('resize', handleResize)<br/>    return () =&gt; window.removeEventListener('resize', handleResize)<br/>  }, [])</span><span id="d723" class="nc la it mo b gy nh ne l nf ng">  return width &lt; 800 ? &lt;Mobile /&gt; : &lt;Desktop /&gt;<br/>}</span></pre><p id="ea35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来破解这个密码，好吗？</p><p id="79a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个组件中，我们将窗口宽度存储在一个由React的<code class="fe ml mm mn mo b">setState</code>变量存储的<code class="fe ml mm mn mo b">width</code>变量中。</p><p id="d55f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个<code class="fe ml mm mn mo b">setState</code> <code class="fe ml mm mn mo b">width</code>值通过<code class="fe ml mm mn mo b">setWidth</code>回调函数设置，该回调函数由<code class="fe ml mm mn mo b">handleResize</code>函数调用。</p><p id="40ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<code class="fe ml mm mn mo b">useEffect</code>向<code class="fe ml mm mn mo b">window</code>添加一个事件监听器，每当调整窗口大小时，这个监听器就调用<code class="fe ml mm mn mo b">handleResize</code>。这个事件侦听器是在组件挂载时添加的。当组件被卸载时，我们通过删除事件侦听器来进行清理。</p><p id="203f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们执行一个简单的三元语句，根据总是在调整窗口大小时更新的<code class="fe ml mm mn mo b">width</code>值来决定呈现哪个组件。</p><p id="db30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常基本的例子，但这样做是为了让我们能够专注于重要的内容，过滤掉不相关的信息。</p><h1 id="f0e6" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">这种做法有什么问题？</h1><p id="4633" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">没什么…</p><p id="fd68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是的，如果你只打算在这一个地方使用它，这没什么不好。但是，如果您想在项目的其他地方使用同样的东西，您将遇到以下两个问题:</p><ul class=""><li id="1211" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated">您需要在想要使用该特性的每个组件中编写同样长的6行设置代码。</li><li id="0c6a" class="mc md it kd b ke mp ki mq km mr kq ms ku mt ky mh mi mj mk bi translated">您将为使用该方法的每个组件设置一个新的事件侦听器。</li></ul><p id="8bc8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们有一些易于使用的可重复使用的解决方案来解决这些问题，那不是很好吗？</p><p id="f1d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢React的一些便利特性，我们可以提出一个解决方案，每个组件只有一行设置，并且只添加一个所有组件都使用的事件侦听器。</p><h1 id="b7ae" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">解决方案</h1><p id="591b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我先给你展示一下简单的实现，这样你就可以知道我们需要构建什么来完成我们的目标。</p><p id="b37d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对解决方案进行编码后，我们将在另一个文件中开发一个<code class="fe ml mm mn mo b">useViewport</code>钩子，工作方式如下:</p><pre class="mu mv mw mx gt my mo mz na aw nb bi"><span id="bfdd" class="nc la it mo b gy nd ne l nf ng">import React, { FC } from 'react'<br/>import { useViewport } from './use-viewport'</span><span id="7dcb" class="nc la it mo b gy nh ne l nf ng">const MyComponent: FC = () =&gt; {<br/>  // See everything simplified to this one line.<br/>  const { width } = useViewport()</span><span id="c327" class="nc la it mo b gy nh ne l nf ng">  return width &lt; 800 ? &lt;Mobile /&gt; : &lt;Desktop /&gt;<br/>}</span></pre><p id="e359" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单多了，对吧？现在让我们创建我们的<code class="fe ml mm mn mo b">useViewport</code>钩子并实现它！</p><p id="8d02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了防止多个事件侦听器被订阅，我们将利用React的上下文API。</p><p id="c49b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是<code class="fe ml mm mn mo b">use-viewport</code>文件的完整实现:</p><pre class="mu mv mw mx gt my mo mz na aw nb bi"><span id="7861" class="nc la it mo b gy nd ne l nf ng">import React, {<br/>  createContext,<br/>  FC,<br/>  useContext,<br/>  useEffect,<br/>  useState,<br/>} from 'react'</span><span id="323e" class="nc la it mo b gy nh ne l nf ng">interface IViewport {<br/>  width: number<br/>}</span><span id="9d08" class="nc la it mo b gy nh ne l nf ng">const ViewportContext = createContext&lt;IViewport&gt;({<br/>  width: window.innerWidth,<br/>})</span><span id="c5cd" class="nc la it mo b gy nh ne l nf ng">export const ViewportProvider: FC = ({ children }) =&gt; {<br/>  const [width, setWidth] = useState(window.innerWidth)</span><span id="008b" class="nc la it mo b gy nh ne l nf ng">  const handleResize = () =&gt; setWidth(window.innerWidth)</span><span id="f31c" class="nc la it mo b gy nh ne l nf ng">  useEffect(() =&gt; {<br/>    window.addEventListener('resize', handleResize)<br/>    return () =&gt; window.removeEventListener('resize', handleResize)<br/>  }, [])</span><span id="d008" class="nc la it mo b gy nh ne l nf ng">  return (<br/>    &lt;ViewportContext.Provider value={{ width }}&gt;<br/>      {children}<br/>    &lt;/ViewportContext.Provider&gt;<br/>  )<br/>}</span><span id="6a85" class="nc la it mo b gy nh ne l nf ng">export function useViewport() {<br/>  return useContext&lt;IViewport&gt;(ViewportContext)<br/>}</span></pre><p id="d044" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里发生了很多事情。我们本质上要做的是将我们的整个应用程序包装在这个<code class="fe ml mm mn mo b">ViewportProvider</code>中，这样事件监听器订阅只发生一次。</p><p id="e692" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们创建自定义的<code class="fe ml mm mn mo b">useViewport</code>钩子来轻松访问组件中的宽度值。如果你不熟悉React的上下文API，那么我强烈建议你阅读React的官方文档，以便更好地掌握它。虽然就我个人而言，我在构建定制钩子时通过使用上下文API学到了很多东西。</p><p id="e185" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">阅读上面的代码时，最重要的部分如下:</p><ul class=""><li id="dc78" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated"><code class="fe ml mm mn mo b">ViewportContext</code>是使用React的<code class="fe ml mm mn mo b">createContext</code>函数创建的。</li><li id="5503" class="mc md it kd b ke mp ki mq km mr kq ms ku mt ky mh mi mj mk bi translated"><code class="fe ml mm mn mo b">ViewportContext</code>只保存值<code class="fe ml mm mn mo b">width</code>，以便我们创建的<code class="fe ml mm mn mo b">useViewport</code>钩子可以使用它。对于我们的钩子实现来说，其他一切都不重要。</li><li id="0428" class="mc md it kd b ke mp ki mq km mr kq ms ku mt ky mh mi mj mk bi translated">在<code class="fe ml mm mn mo b">ViewportProvider</code>组件的后台更新<code class="fe ml mm mn mo b">width</code>值。</li></ul><h1 id="538e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">最后的步骤</h1><p id="6f3d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这部分很重要！我们的<code class="fe ml mm mn mo b">useViewport</code>挂钩暂时还不能使用。我们需要在我们的应用程序中实现<code class="fe ml mm mn mo b">ViewportProvider</code>组件，以便hook的实现实际上可以访问上下文。记住:React context——就像Redux一样——需要一个提供者。</p><p id="df8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此，我建议在React <code class="fe ml mm mn mo b">App</code>的根附近实现。</p><p id="1c4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似这样的内容应该足够了:</p><pre class="mu mv mw mx gt my mo mz na aw nb bi"><span id="4fdb" class="nc la it mo b gy nd ne l nf ng">import React from 'react' <br/>import ReactDOM from 'react-dom'</span><span id="1a45" class="nc la it mo b gy nh ne l nf ng">import App from './app'<br/>import ViewportProvider from './use-viewport'</span><span id="407f" class="nc la it mo b gy nh ne l nf ng">ReactDOM.render(<br/>  &lt;ViewportProvider&gt;<br/>    &lt;App /&gt;<br/>  &lt;/ViewportProvider&gt;,<br/>  document.getElementById('root')<br/>)</span></pre><p id="bbaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样！现在你应该可以轻松地在你的应用中使用你的<code class="fe ml mm mn mo b">useViewport</code>钩子了🙂</p><p id="a381" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望你喜欢这本书，这对你的项目有所帮助，无论是大项目还是小项目。</p><p id="5bc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">PS:我把它叫做<code class="fe ml mm mn mo b">useViewport</code>而不是<code class="fe ml mm mn mo b">useWindowWidth</code>，因为我扩展了钩子的功能。我将很快写一篇第2部分的文章，包括一些关于如何使钩子更方便使用的改进。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="8880" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">原载于2020年4月13日</em><a class="ae nq" href="https://www.barrymichaeldoyle.com/use-viewport/" rel="noopener ugc nofollow" target="_blank"><em class="np">【https://www.barrymichaeldoyle.com】</em></a><em class="np">。</em></p></div></div>    
</body>
</html>