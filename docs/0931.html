<html>
<head>
<title>Reactive Streams are just functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应流只是函数</h1>
<blockquote>原文：<a href="https://itnext.io/reactive-streams-are-just-functions-da3f2b60753d?source=collection_archive---------3-----------------------#2018-06-20">https://itnext.io/reactive-streams-are-just-functions-da3f2b60753d?source=collection_archive---------3-----------------------#2018-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f90007be083b2165d80c1719e5160654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PelxCVHJtbTLd2vUd6vqOw.jpeg"/></div></div></figure><p id="9329" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">反应流是一个很好的工具。它们允许我们轻松地编写高性能的异步代码。它们帮助我们关注如何处理数据，而不是如何处理数据。它们很容易理解。一开始是这样的。</p><p id="cf6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们大多数人一开始都把流想象成一系列随时间推移而产生的值。这个简单的模型足以订阅流，并对其应用map等基本操作符。但是，一旦我们需要添加更复杂的操作符，或者如果某些东西不像预期的那样工作，价值流的概念就不再有用了。</p><p id="48f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我提出另一个心智模型，一个更关注流如何工作的模型:流只是函数。</p><p id="296c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个小注意:我在我的例子中使用了JavaScript，并尽量保持简单，这样即使没有JavaScript技能的开发人员也很容易理解。</p><h1 id="9420" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">源头</h1><p id="723f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当你将一个操作符应用于一个可观察对象时，你创建了一个新的可观察对象，它的父对象是原来的可观察对象。源是没有父对象的可观察对象。它只发出值。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="1c7f" class="mi kx iq me b gy mj mk l ml mm">function source(subscriber) {<br/>  subscriber(1);<br/>  subscriber(2);<br/>}</span></pre><p id="2f90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">源函数需要一个回调(订户)并通过调用订户来发出值。我们也可以在一个数组上循环，而不是“手动”发出值。让我们订阅我们的“可观察”。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9416" class="mi kx iq me b gy mj mk l ml mm">function subscriber(value) {<br/>  console.log(value);<br/>}</span><span id="b154" class="mi kx iq me b gy mn mk l ml mm">source(subscriber);</span><span id="bf2a" class="mi kx iq me b gy mn mk l ml mm">//Prints 1 and 2 in the console</span></pre><p id="f49b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能会反对这不允许异步流。我们开始吧:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="be96" class="mi kx iq me b gy mj mk l ml mm">function source(subscriber) {<br/>  setTimeout(function() {<br/>    subscriber(1);<br/>  }, 1000);</span><span id="648c" class="mi kx iq me b gy mn mk l ml mm">  setTimeout(function() {<br/>    subscriber(2);<br/>  }, 3000);<br/>}</span><span id="c72e" class="mi kx iq me b gy mn mk l ml mm">source(subscriber);</span><span id="6130" class="mi kx iq me b gy mn mk l ml mm">//Prints 1 after 1 second and 2 after 3 seconds</span></pre><p id="4122" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">setTimeout函数在给定的时间段后调用订阅者。如果您尝试这样做，您会注意到这些值在几秒钟后发出。</p><h1 id="6360" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">接线员</h1><p id="a3e7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">操作符是一个简单的函数，它接受一个值并调用一个订阅者。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="424f" class="mi kx iq me b gy mj mk l ml mm">function operator(value, subscriber) {<br/>  let newValue = "Value: " + value;<br/>  subscriber(newValue);<br/>}</span></pre><p id="fede" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运算符的秘密武器是它不返回新值，而是调用订阅者。这使得它非常强大。我们可以决定何时发出一个值(例如去抖)，发出多少个值(例如平面图)，或者是否发出任何值(例如过滤器)。</p><h1 id="3eb0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">胶水</h1><p id="8ad6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当然，我们不想直接调用算符而是将其应用于另一个可观察对象。因此，让我们创建一个管道函数:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c73e" class="mi kx iq me b gy mj mk l ml mm">function pipe(source, operator) {</span><span id="839b" class="mi kx iq me b gy mn mk l ml mm">  function newSource(subscriber) {<br/>    function operatorSubscriber(value) {<br/>      operator(value, subscriber);<br/>    }</span><span id="06fa" class="mi kx iq me b gy mn mk l ml mm">    return source(operatorSubscriber);<br/>  }</span><span id="903d" class="mi kx iq me b gy mn mk l ml mm">  return newSource;<br/>}</span></pre><p id="52b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这些嵌套函数，这看起来有点复杂。让我们过一遍。我们从最里面的operatorSubscriber开始。源只接受订阅者，因此我们将操作符包装到另一个函数中。源可以调用operatorSubscriber，operator subscriber调用操作符，操作符又可以调用实际的订户。</p><p id="81c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们将一个操作符应用于一个流时，我们就创建了一个新的流。所以管道函数需要返回一个。我称它为operatorSource(虽然它实际上不是一个源)。当有人“订阅”新源时，该请求通过调用source函数被传递给原始源。</p><p id="15a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的工作流程是这样的:</p><ul class=""><li id="efdc" class="mo mp iq ka b kb kc kf kg kj mq kn mr kr ms kv mt mu mv mw bi translated">订户调用operatorSource(它包装了操作符)</li><li id="72d3" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">operatorSource调用源</li><li id="cce1" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">信源反复调用operatorSubscriber</li><li id="be8c" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">运营商用户反复呼叫用户</li></ul><p id="76f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这基本上是一种请求/响应模式</p><h1 id="1728" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">订阅</h1><p id="d480" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们已经成功订阅了该流，但我们还想取消订阅。让我们添加一个退订功能:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="deb2" class="mi kx iq me b gy mj mk l ml mm">function source(subscriber) {<br/>  subscriber(1);</span><span id="ec2b" class="mi kx iq me b gy mn mk l ml mm">  let id1 = setTimeout(function() {<br/>             subscriber(2);<br/>            }, 1000);</span><span id="4668" class="mi kx iq me b gy mn mk l ml mm">  let id2 = setTimeout(function() {<br/>              subscriber(3);<br/>            }, 3000);</span><span id="db3f" class="mi kx iq me b gy mn mk l ml mm">  function unsubscribe() {<br/>    clearTimeout(id1);<br/>    clearTimeout(id2);<br/>  }</span><span id="914d" class="mi kx iq me b gy mn mk l ml mm">  return unsubscribe;<br/>}</span><span id="5d5a" class="mi kx iq me b gy mn mk l ml mm">let unsubscribe = source(subscriber);<br/>unsubscribe();</span></pre><p id="d1f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">clearTimeout取消setTimeout。我们在订阅后立即调用unsubscribe，因此我们不会得到异步值。但是我们确实得到了第一个值，因为它是在我们可以取消订阅之前发出的。</p><h1 id="7e04" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="3d3d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一个完全成熟的实现需要比我们所介绍的多一点，但是我们已经为流提供了一些基本的构建块。我们已经知道，流基本上就是一系列的函数调用。嗯，实际上是两个系列:当我们订阅时，从订阅者到源，当发出值时，从源到订阅者。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/24bd26eb1f88a10c9116dd9dae37255b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fbl3UdeSYQ77DnC_oOxIIg.png"/></div></div></figure><p id="386e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们也知道了为什么我们需要主动订阅一个流:我们需要调用源函数。</p><p id="5742" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一次一个流没有像预期的那样运行时，试着找出哪些函数被调用了，哪些没有被调用，以及为什么。</p></div></div>    
</body>
</html>