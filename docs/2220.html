<html>
<head>
<title>Microservices with Spring Boot and Spring Cloud. From config server to OAuth2 server (without inMemory things) — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot和春天云的微服务。从配置服务器到OAuth2服务器(没有内存内容)—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/microservices-with-spring-boot-and-spring-cloud-20f689b17fc7?source=collection_archive---------0-----------------------#2019-04-18">https://itnext.io/microservices-with-spring-boot-and-spring-cloud-20f689b17fc7?source=collection_archive---------0-----------------------#2019-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9e42fb2083de81bb7b2eebc0b8623cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCLh49Ywl5TVKNKNbJcb2Q.png"/></div></div></figure><p id="3ee0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大家好，在这第二部分，我们将建立认证服务。这就是我们在这本指南中要找的人。<br/>第一部分可用<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/microservices-with-spring-boot-and-spring-cloud-16d2c056ba12">此处</a>。</p><p id="3c80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不会使用那些<strong class="ka ir"> <em class="kx"> inMemory </em> </strong>配置，auth服务将构建在MongoDB之上，能够创建用户、对他们进行身份验证、存储他们的令牌/刷新令牌，并在需要时撤销它。</p><p id="80f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住代码可以在<a class="ae kw" href="https://github.com/marcusdacoregio/oauth2-spring-boot" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h1 id="61c1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建身份验证服务</h1><p id="9191" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">让我们开始创建授权服务，我们将使用<a class="ae kw" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>来创建maven项目。像图像一样生成它。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/16cd086ad8e0d6fc6dbcccb1c31620c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H02YtUzsCugGLh4ifpSpTQ.png"/></div></div></figure><h2 id="5e29" class="mg kz iq bd la mh mi dn le mj mk dp li kj ml mm lm kn mn mo lq kr mp mq lu mr bi translated">添加注释</h2><p id="8ff1" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在您喜欢的IDE中导入生成的项目。<br/>打开<code class="fe ms mt mu mv b">AuthServiceApplication</code>类添加一些注释。从<code class="fe ms mt mu mv b">@EnableResourceServer</code>注释开始，它将启用一个Spring安全过滤器，通过一个传入的OAuth2令牌对请求进行身份验证。</p><p id="f8e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个是我们已经知道的<code class="fe ms mt mu mv b">@EnableDiscoveryClient</code>，它将允许发现客户端实现让我们的认证服务在注册服务中注册。</p><p id="1d03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个是<code class="fe ms mt mu mv b">@EnableGlobalMethodSecurity</code>，启用Spring Security全局方法安全。将注释中的<code class="fe ms mt mu mv b">prePostEnabled </code>字段设置为<code class="fe ms mt mu mv b">true</code>以启用Spring Security的pre post注释，我们稍后会用到它们。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="3dfe" class="mg kz iq mv b gy na nb l nc nd">@SpringBootApplication<br/>@EnableResourceServer<br/>@EnableDiscoveryClient<br/>@EnableGlobalMethodSecurity(prePostEnabled = true)<br/>public class AuthServiceApplication {<br/>    public static void main(String[] args) {<br/>        SpringApplication.<em class="kx">run</em>(AuthServiceApplication.class, args);<br/>    }<br/>}</span></pre><h2 id="8e49" class="mg kz iq bd la mh mi dn le mj mk dp li kj ml mm lm kn mn mo lq kr mp mq lu mr bi translated">添加应用程序的配置文件</h2><p id="902f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">将<code class="fe ms mt mu mv b">application.properties</code>文件重命名为<code class="fe ms mt mu mv b">bootstrap.yml</code>，并添加以下配置:</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="de36" class="mg kz iq mv b gy na nb l nc nd"><strong class="mv ir">spring</strong>:<br/>  <strong class="mv ir">application</strong>:<br/>    <strong class="mv ir">name</strong>: auth-service<br/>  <strong class="mv ir">cloud</strong>:<br/>    <strong class="mv ir">config</strong>:<br/>      <strong class="mv ir">uri</strong>: http://localhost:8888<br/>      <strong class="mv ir">fail-fast</strong>: true<strong class="mv ir"><br/>      password</strong>: 1234<br/>      <strong class="mv ir">username</strong>: user</span></pre><p id="1d43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在配置服务应用程序中，创建<code class="fe ms mt mu mv b">auth-service.yml</code>文件来保存授权服务的配置。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="fdf7" class="mg kz iq mv b gy na nb l nc nd"><strong class="mv ir">spring</strong>:<br/>  <strong class="mv ir">data</strong>:<br/>    <strong class="mv ir">mongodb</strong>:<br/>      <strong class="mv ir">host</strong>: localhost<br/>      <strong class="mv ir">port</strong>: 27017<br/>      <strong class="mv ir">username</strong>: oauth-user<br/>      <strong class="mv ir">password</strong>: password<br/>      <strong class="mv ir">database</strong>: oauth-db</span><span id="a6d5" class="mg kz iq mv b gy ne nb l nc nd"><strong class="mv ir">server</strong>:<br/>  <strong class="mv ir">servlet</strong>:<br/>    <strong class="mv ir">context-path</strong>: /uaa<br/>  <strong class="mv ir">port</strong>: 8081</span></pre><p id="1ffd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不知道为什么创建这些文件，我推荐你阅读这篇<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/microservices-with-spring-boot-and-spring-cloud-16d2c056ba12">文章的第一部分。</a></p><h2 id="e4fa" class="mg kz iq bd la mh mi dn le mj mk dp li kj ml mm lm kn mn mo lq kr mp mq lu mr bi translated">创建域实体及其DAO</h2><p id="4ce6" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">让我们开始创建<strong class="ka ir">权限枚举。</strong></p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="6d37" class="mg kz iq mv b gy na nb l nc nd">import org.springframework.security.core.GrantedAuthority;<br/><br/>public enum Authorities implements GrantedAuthority {<br/>    <em class="kx">ROLE_USER</em>;<br/><br/>    @Override<br/>    public String getAuthority() {<br/>        return name();<br/>    }<br/>}</span></pre><p id="7351" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个enum负责定义我们的auth服务的权限，它实现了代表授予一个<a class="ae kw" href="https://docs.spring.io/spring-security/site/docs/4.2.11.RELEASE/apidocs/org/springframework/security/core/Authentication.html" rel="noopener ugc nofollow" target="_blank"> Authentication </a>对象的权限的<code class="fe ms mt mu mv b">GrantedAuthority</code>接口。</p><p id="d21c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在创建用户实体来代表我们的用户。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="8fa5" class="mg kz iq mv b gy na nb l nc nd">@Document<br/>public class User implements UserDetails {<br/>    @Id<br/>    private String id;<br/><br/>    @Indexed(unique = true)<br/>    private String username;<br/><br/>    private String password;<br/><br/>    private boolean activated;<br/><br/>    private String activationKey;<br/><br/>    private String resetPasswordKey;<br/><br/>    private Set&lt;Authorities&gt; authorities = new HashSet&lt;&gt;();</span><span id="c632" class="mg kz iq mv b gy ne nb l nc nd">    ...getters and setters<br/>}</span></pre><p id="76a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我省略了getters和setters，但是您可以在这里检查它们。<code class="fe ms mt mu mv b">User</code>类实现了<code class="fe ms mt mu mv b">UserDetails</code>接口，该接口提供了要封装到认证对象中的核心用户信息。<code class="fe ms mt mu mv b">@Document</code>、<code class="fe ms mt mu mv b">@Id</code>和<code class="fe ms mt mu mv b">@Indexed</code>注释是Mongo用的，这里就不赘述了，可以在评论区问。</p><p id="c091" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建<strong class="ka ir">用户存储库</strong>作为我们的DAO。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="59ae" class="mg kz iq mv b gy na nb l nc nd">import com.marcusdacoregio.authservice.domain.User;<br/>import org.springframework.data.mongodb.repository.MongoRepository;<br/>import org.springframework.stereotype.Repository;<br/><br/>import java.util.Optional;<br/><br/>@Repository<br/>public interface UserRepository extends MongoRepository&lt;User, String&gt; {<br/>    Optional&lt;User&gt; findByUsername(String username);<br/>}</span></pre><p id="4638" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是我们的定制实现<code class="fe ms mt mu mv b">UserDetailsService</code>，它是一个加载用户特定数据的核心接口。它作为用户DAO在整个spring框架中使用，并且是DaoAuthenticationProvider使用的策略。你可以在<a class="ae kw" href="https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/api/org/springframework/security/core/userdetails/UserDetailsService.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中了解更多。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="e889" class="mg kz iq mv b gy na nb l nc nd">@Service<br/>public class CustomUserDetailsService implements UserDetailsService {<br/><br/>    private final UserRepository userRepository;<br/><br/>    public CustomUserDetailsService(UserRepository userRepository) {<br/>        this.userRepository = userRepository;<br/>    }<br/><br/>    @Override<br/>    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {<br/>        return userRepository.findByUsername(username)<br/>                .orElseThrow(() -&gt; new UsernameNotFoundException("Username " + username + " not found"));<br/>    }<br/><br/>}</span></pre><p id="38ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，到这里为止，我们创建了一些需要的类来处理我们的用户。</p><p id="e678" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将创建一些类来处理我们的客户机，这些客户机是想要使用身份验证的资源服务器。让我们从表示授权客户端细节的类开始。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="74e3" class="mg kz iq mv b gy na nb l nc nd">@Document<br/>public class AuthClientDetails implements ClientDetails {<br/>    private static final long <em class="kx">serialVersionUID </em>= 1L;<br/><br/>    @Id<br/>    private String id;<br/><br/>    private String clientId;<br/><br/>    private String clientSecret;<br/><br/>    private String grantTypes;<br/><br/>    private String scopes;<br/><br/>    private String resources;<br/><br/>    private String redirectUris;<br/><br/>    private Integer accessTokenValidity;<br/><br/>    private Integer refreshTokenValidity;<br/><br/>    private String additionalInformation;</span><span id="1da7" class="mg kz iq mv b gy ne nb l nc nd">    ...getters and setters<br/>}</span></pre><p id="7893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里查看这个类的getters和setters的详细信息。查看<code class="fe ms mt mu mv b">ClientDetails</code>的<a class="ae kw" href="https://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/provider/ClientDetails.html" rel="noopener ugc nofollow" target="_blank">文档</a>会很不错。</p><p id="8eb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个类是<code class="fe ms mt mu mv b">AuthClientRepository</code>为<code class="fe ms mt mu mv b">AuthClientDetails</code>做我们的刀。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="db05" class="mg kz iq mv b gy na nb l nc nd">@Repository<br/>public interface AuthClientRepository extends MongoRepository&lt;AuthClientDetails, String&gt; {</span><span id="76c2" class="mg kz iq mv b gy ne nb l nc nd">    Optional&lt;AuthClientDetails&gt; findByClientId(String clientId);</span><span id="060f" class="mg kz iq mv b gy ne nb l nc nd">}</span></pre><p id="3834" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是类<code class="fe ms mt mu mv b">AuthClientDetailsService</code>，它实现了<a class="ae kw" href="https://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/provider/ClientDetailsService.html" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">ClientDetailsService</strong></a><strong class="ka ir"/>，这是一个提供OAuth2客户端细节的服务接口。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="1f1b" class="mg kz iq mv b gy na nb l nc nd">@Service<br/>public class AuthClientDetailsService implements ClientDetailsService {<br/>    private final AuthClientRepository authClientRepository;<br/><br/>    public AuthClientDetailsService(AuthClientRepository authClientRepository) {<br/>        this.authClientRepository = authClientRepository;<br/>    }<br/><br/>    @Override<br/>    public ClientDetails loadClientByClientId(String clientId) {<br/>        return authClientRepository.findByClientId(clientId).orElseThrow(IllegalArgumentException::new);<br/>    }<br/>}</span></pre><p id="9267" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一节中，我们将在Spring中开始配置安全性和OAuth2。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h2 id="807a" class="mg kz iq bd la mh mi dn le mj mk dp li kj ml mm lm kn mn mo lq kr mp mq lu mr bi translated">在Spring中配置安全性和OAuth2</h2><p id="5368" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">从<code class="fe ms mt mu mv b">WebSecurityConfig</code>类开始，它将扩展<code class="fe ms mt mu mv b">WebSecurityConfigurerAdapter</code>抽象类。</p><p id="66d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在它上面，我们定义了一些安全的东西和我们的<code class="fe ms mt mu mv b">AuthenticationManager</code>，以利用我们之前创建的<code class="fe ms mt mu mv b">CustomUserDetailsService</code>。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="6a48" class="mg kz iq mv b gy na nb l nc nd">@Configuration<br/>public class WebSecurityConfig extends WebSecurityConfigurerAdapter {<br/><br/>    @Autowired<br/>    private CustomUserDetailsService userDetailsService;<br/><br/>    @Override<br/>    protected void configure(HttpSecurity http) throws Exception {<br/>        // @formatter:off<br/>        http<br/>                .authorizeRequests().anyRequest().authenticated()<br/>                .antMatchers("/oauth/**").permitAll()<br/>                .and()<br/>                .csrf().disable();<br/>        // @formatter:on<br/>    }<br/><br/>    @Override<br/>    protected void configure(AuthenticationManagerBuilder auth) throws Exception {<br/>        auth.userDetailsService(userDetailsService)<br/>                .passwordEncoder(passwordEncoder());<br/>    }<br/><br/>    @Override<br/>    @Bean<br/>    public AuthenticationManager authenticationManagerBean() throws Exception {<br/>        return super.authenticationManagerBean();<br/>    }<br/><br/>    @Bean<br/>    public PasswordEncoder passwordEncoder() {<br/>        return new BCryptPasswordEncoder();<br/>    }<br/><br/>}</span></pre><p id="93e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将Spring Security配置为授权任何经过身份验证的请求，但是允许在<strong class="ka ir"> <em class="kx"> /oauth/** </em> </strong>端点上的任何请求，即使没有经过身份验证。<br/>我们确实将<code class="fe ms mt mu mv b">CustomUserDetailsService</code>设置为由<a class="ae kw" href="https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/api/org/springframework/security/authentication/AuthenticationManager.html" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">AuthenticationManager</strong></a><strong class="ka ir"/>使用，并定义了密码编码器来使用<a class="ae kw" href="https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/api/org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.html" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">BCryptPasswordEncoder</strong></a>中的实现。</p><p id="e4b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在创建<code class="fe ms mt mu mv b">OAuth2AuthorizationCofig</code>，它充当配置OAuth2授权服务器的策略。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="e585" class="mg kz iq mv b gy na nb l nc nd">@Configuration<br/>@EnableAuthorizationServer<br/>public class OAuth2AuthorizationConfig extends AuthorizationServerConfigurerAdapter {<br/><br/>    @Autowired<br/>    @Qualifier("authenticationManagerBean")<br/>    private AuthenticationManager authenticationManager;<br/><br/>    @Autowired<br/>    private CustomUserDetailsService userDetailsService;<br/><br/>    @Autowired<br/>    private AuthClientDetailsService authClientDetailsService;<br/><br/>    @Autowired<br/>    private PasswordEncoder encoder;<br/><br/>    @Override<br/>    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {<br/>        clients.withClientDetails(authClientDetailsService);<br/>    }<br/><br/>    @Bean<br/>    public TokenStore tokenStore() {<br/>        return new MongoTokenStore();<br/>    }<br/><br/>    @Override<br/>    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {<br/>        endpoints<br/>                .tokenStore(tokenStore())<br/>                .authenticationManager(authenticationManager)<br/>                .userDetailsService(userDetailsService);<br/>    }<br/><br/>    @Override<br/>    public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {<br/>        oauthServer<br/>                .tokenKeyAccess("permitAll()")<br/>                .checkTokenAccess("isAuthenticated()")<br/>                .passwordEncoder(encoder)<br/>                .allowFormAuthenticationForClients();<br/>    }<br/><br/>}</span></pre><p id="ecd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ms mt mu mv b">@EnableAuthorizationServer</code>启用一个<a class="ae kw" href="https://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/provider/endpoint/AuthorizationEndpoint.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">授权端点</strong> </a>和一个<a class="ae kw" href="https://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/provider/endpoint/TokenEndpoint.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">令牌端点</strong> </a>公开端点用于认证和授权。</p><p id="7fed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义了要使用的<code class="fe ms mt mu mv b">AuthClientDetailsService</code>实现，以及一个定制的<a class="ae kw" href="https://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/provider/token/TokenStore.html" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">token store</strong></a><strong class="ka ir"/>实现来使用MongoDB存储生成的令牌。我想让你在这里检查一下<a class="ae kw" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/config/mongodb/MongoTokenStore.java" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> MongoTokenStore </strong>的实现，还有</a><a class="ae kw" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/config/mongodb/MongoConfig.java" rel="noopener ugc nofollow" target="_blank"> MongoConfig </a>和<a class="ae kw" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/config/mongodb/MongoProperties.java" rel="noopener ugc nofollow" target="_blank"> MongoProperties </a>，我就不放在这里了，因为会变得乱七八糟。</p><p id="c6a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经创建了<a class="ae kw" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/config/mongodb/MongoBeeConfig.java" rel="noopener ugc nofollow" target="_blank"> MongoBeeConfig </a>类来在我们的Mongo数据库中插入一些初始数据，它使用了<a class="ae kw" href="https://github.com/mongobee/mongobee" rel="noopener ugc nofollow" target="_blank"> Mongobee </a>库，这是一个用于Java的MongoDB数据迁移工具，就像用于关系数据库的Flyway或Liquibase。我们将在之后创建这个初始数据。</p><h2 id="2a58" class="mg kz iq bd la mh mi dn le mj mk dp li kj ml mm lm kn mn mo lq kr mp mq lu mr bi translated">用Docker给我们提供一个Mongo数据库</h2><p id="7cf3" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">好的，到目前为止我们已经配置了MongoDB，但是我们还没有安装它。我们将使用一个<a class="ae kw" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="kx">docker-compose</em></strong></a>文件为我们提供它，而不是安装和配置它。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="3916" class="mg kz iq mv b gy na nb l nc nd">mongo-oauth:<br/>  image: mongo:4.0.4<br/>  restart: always<br/>  environment:<br/>    MONGO_INITDB_ROOT_USERNAME: root<br/>    MONGO_INITDB_ROOT_PASSWORD: example<br/>    MONGO_INITDB_DATABASE: oauth-db<br/>    MONGODB_USER: oauth-user<br/>    MONGODB_DATABASE: oauth-db<br/>    MONGODB_PASS: password<br/>  log_opt:<br/>    max-size: "10m"<br/>    max-file: "10"<br/>  ports:<br/>    - 27017:27017<br/>  volumes:<br/>    - ./mongo-init/init-mongo.sh:/docker-entrypoint-initdb.d/init-mongo.sh<br/><br/>mongo-express-oauth:<br/>  image: mongo-express:0.49<br/>  restart: always<br/>  ports:<br/>    - 10081:8081<br/>  environment:<br/>    ME_CONFIG_MONGODB_ADMINUSERNAME: root<br/>    ME_CONFIG_MONGODB_ADMINPASSWORD: example<br/>    ME_CONFIG_MONGODB_SERVER: mongo-oauth<br/>    ME_CONFIG_MONGODB_PORT: 27017<br/>  links:<br/>    - mongo-oauth</span></pre><p id="4836" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你需要安装Docker(<a class="ae kw" href="https://medium.com/@yannmjl/what-is-docker-in-simple-english-a24e8136b90b" rel="noopener">不知道Docker是什么？</a>)。在某个地方创建一个文件<strong class="ka ir"><em class="kx">docker-compose . yml</em></strong>，在同一个地方，你需要有一个名为<strong class="ka ir"> <em class="kx"> mongo-init </em> </strong>的文件夹，里面有一个名为<strong class="ka ir"><em class="kx">init-mongo . sh</em></strong>的文件。您可以将<strong class="ka ir"><em class="kx">init-mongo . sh</em></strong><a class="ae kw" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/mongo-init/init-mongo.sh" rel="noopener ugc nofollow" target="_blank">中的内容复制到这里</a>，它用于创建数据库和用户定义的环境变量<strong class="ka ir"><em class="kx">docker-compose . yml .</em></strong></p><p id="506a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦一切就绪，在首选终端中运行命令<code class="fe ms mt mu mv b">docker-compose up --build</code>来创建并启动MongoDB容器。</p><h2 id="eb67" class="mg kz iq bd la mh mi dn le mj mk dp li kj ml mm lm kn mn mo lq kr mp mq lu mr bi translated">创建我们授权服务的第一个客户端</h2><p id="c163" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们现在需要一个客户机从我们的用户那里检索访问令牌。让我们用<strong class="ka ir">密码</strong>和<strong class="ka ir">刷新令牌</strong> <a class="ae kw" href="https://oauth.net/2/grant-types/" rel="noopener ugc nofollow" target="_blank">授予类型</a>来创建他。<br/>从<strong class="ka ir"> Mongobee </strong>创建一个<strong class="ka ir"> ChangeLog </strong>，在应用程序启动时插入这个客户端。用以下内容创建一个名为<code class="fe ms mt mu mv b">InitialValuesChangeLog</code>的类:</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="2eb3" class="mg kz iq mv b gy na nb l nc nd">@ChangeLog<br/>public class InitialValuesChangeLog {</span><span id="be1f" class="mg kz iq mv b gy ne nb l nc nd">    @ChangeSet(order = "001", id = "insertBrowserClientDetails", author = "Marcus Hert Da Corégio")<br/>    public void insertBrowserClientDetails(MongoTemplate mongoTemplate) {<br/>        AuthClientDetails browserClientDetails = new AuthClientDetails();<br/>        browserClientDetails.setClientId("browser");<br/>        browserClientDetails.setClientSecret("$2a$10$fWNTd3H.u7G/aNROVQSifebOkZ2xzU5nUPOCI2Ld42M8E25/ljJqK");<br/>        browserClientDetails.setScopes("ui");<br/>        browserClientDetails.setGrantTypes("refresh_token,password");<br/><br/>        mongoTemplate.save(browserClientDetails);<br/>    }</span><span id="90fd" class="mg kz iq mv b gy ne nb l nc nd">}</span></pre><p id="97bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中，我们在MongoDB上创建了一个新的<strong class="ka ir"> AuthClientDetails </strong>，它具有一个秘密、范围和授权类型，能够基于用户凭证获得访问令牌。<br/>客户端秘密是从<strong class="ka ir"> BCryptPasswordEncoder </strong>为值<strong class="ka ir"> 1234 </strong>生成的散列。</p><p id="413c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建另一个<code class="fe ms mt mu mv b">@ChangeSet</code>来创建一个<strong class="ka ir">用户</strong>，以便我们能够使用之前用于<strong class="ka ir">浏览器客户端</strong>的相同密码来验证他。我现在不会创建端点，因为这将是本文下一部分的内容:)。</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="5673" class="mg kz iq mv b gy na nb l nc nd">@ChangeSet(order = "002", id = "insertUserToTestAuthentication", author = "Marcus Hert Da Corégio")<br/>public void insertUserToTestAuthentication(MongoTemplate mongoTemplate) {<br/>    Set&lt;Authorities&gt; authorities = new HashSet&lt;&gt;();<br/>    authorities.add(Authorities.<em class="kx">ROLE_USER</em>);<br/><br/>    User user = new User();<br/>    user.setActivated(true);<br/>    user.setAuthorities(authorities);<br/>    user.setPassword("$2a$10$fWNTd3H.u7G/aNROVQSifebOkZ2xzU5nUPOCI2Ld42M8E25/ljJqK");<br/>    user.setUsername("randomuser");<br/><br/>    mongoTemplate.save(user);<br/>}</span></pre></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h2 id="c853" class="mg kz iq bd la mh mi dn le mj mk dp li kj ml mm lm kn mn mo lq kr mp mq lu mr bi translated">测试我们到目前为止所做的事情</h2><p id="5b17" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">好的，现在我们将做一些请求来看看我们做的是否有效:d .我推荐你使用<a class="ae kw" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>来做HTTP请求。分别运行配置、注册表、网关和身份验证服务。</p><p id="64de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开Postman，让我们向<a class="ae kw" href="http://localhost:8080/uaa/oauth/token" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/uaa/oauth/token</a>发出POST请求，为我们的<strong class="ka ir"> randomuser </strong>和<strong class="ka ir">浏览器</strong>客户端检索一个访问令牌。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/87f4bbf854472fb42fdff1fadbd17127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mamLDi6gRhW15xiR3kVumQ.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">请求的授权详细信息</figcaption></figure><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/f3b870687325e8d425248b11d516657a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJl3QbQmdsr2b71ZW3pAJw.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">请求的请求正文详细信息</figcaption></figure><p id="de65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发送此请求时，我收到了以下响应正文:</p><pre class="mc md me mf gt mw mv mx my aw mz bi"><span id="2ce1" class="mg kz iq mv b gy na nb l nc nd">{<br/>    "access_token": "38f1a0ac-a762-4b2a-af51-45a26d97e2bd",<br/>    "token_type": "bearer",<br/>    "refresh_token": "fad35f6f-84e8-4c37-abc5-73c77018f885",<br/>    "expires_in": 43199,<br/>    "scope": "ui"<br/>}</span></pre><p id="642c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，我们已经完成了我们要找的东西。认证终于起作用了，你可以在<a class="ae kw" href="http://localhost:10081" rel="noopener ugc nofollow" target="_blank"> http://localhost:10081 </a>通过Mongo Express在MongoDB上检查生成的令牌。</p><p id="7322" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我知道你是否也做了这个作品，我希望如此！</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h2 id="dd77" class="mg kz iq bd la mh mi dn le mj mk dp li kj ml mm lm kn mn mo lq kr mp mq lu mr bi translated">我们将在第三部分做什么</h2><p id="8115" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">接下来我们要做的是创建一个帐户服务，这个应用程序将管理我们的用户，通过我们的认证服务进行认证等等。</p><p id="5079" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查第三部分<a class="ae kw" href="https://medium.com/@marcusdacoregio/microservices-with-spring-boot-and-spring-cloud-441e3dabc67d" rel="noopener">此处</a>。</p><p id="6c2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你们喜欢它，随时与我分享任何问题。</p></div></div>    
</body>
</html>