<html>
<head>
<title>Generically working with Kubernetes objects in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通常在Go中使用Kubernetes对象</h1>
<blockquote>原文：<a href="https://itnext.io/generically-working-with-kubernetes-resources-in-go-53bce678f887?source=collection_archive---------0-----------------------#2021-11-26">https://itnext.io/generically-working-with-kubernetes-resources-in-go-53bce678f887?source=collection_archive---------0-----------------------#2021-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8244" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用来自k8s API machinery的非结构化包</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b0d9ebc2def29c544dafeef937136577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Omyx9_Tare9Dyhht9m9Ivw.jpeg"/></div></div></figure><p id="7159" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有时候，最好是使用Kubernetes资源对象，而不是编写代码来处理特定的类型。一些示例用例如下:</p><ol class=""><li id="0b51" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">使用没有相关Golang结构的插件中的k8s API对象。</li><li id="b886" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">使用<a class="ae mb" href="https://github.com/json-path/JsonPath" rel="noopener ugc nofollow" target="_blank"> JsonPath </a>、<a class="ae mb" href="https://jmespath.org/" rel="noopener ugc nofollow" target="_blank"> JMESPath </a>、<a class="ae mb" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>等对k8s对象执行通用<a class="ae mb" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a>(创建/读取/更新/删除)操作。需要一种通用方法来避免编写显式代码来处理每种可能的资源类型。</li></ol><h1 id="67d7" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">API机械信号</h1><p id="b7c1" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">Kubernetes社区的许多项目都是由特殊利益集团管理的。<a class="ae mb" href="https://github.com/kubernetes/community/tree/master/sig-api-machinery" rel="noopener ugc nofollow" target="_blank"> API Machinery SIG </a>维护<a class="ae mb" href="https://github.com/kubernetes/apimachinery" rel="noopener ugc nofollow" target="_blank">客户端库</a>用于与k8s API服务器接口，包括通用API CRUD语义的包。API Machinery的一个众所周知的子项目是<a class="ae mb" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go </a>，用于与k8s API服务器交互的官方Go API。</p><p id="6ac5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">client-go最常见的入口点是<code class="fe mz na nb nc b">kubernetes.Clientset</code>，它是一组类型化的客户端，为每种核心资源类型(pod、部署、服务等)提供预生成的本地API对象。).由于它的易用性，我建议尽可能使用这个入口点。然而，使用类型化客户端可能会有很大的局限性，因为代码被迫与所使用的特定类型和版本紧密耦合。</p><h1 id="c337" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">客户端运行/动态和非结构化对象</h1><p id="9e8f" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">API Machinery的universal-machinery子项目维护了一个<a class="ae mb" href="https://github.com/kubernetes/apimachinery" rel="noopener ugc nofollow" target="_blank">共享依赖库</a>，供服务器和客户端在没有直接类型依赖的情况下使用Kubernetes API基础设施。<a class="ae mb" href="https://pkg.go.dev/k8s.io/apimachinery/pkg/apis/meta/v1/unstructured" rel="noopener ugc nofollow" target="_blank">非结构化</a>包是这个共享依赖库的一部分，它允许对k8s资源对象进行通用操作。struct <code class="fe mz na nb nc b">unstructured.Unstructured</code>是一个简单的类型，它使用一组嵌套的<code class="fe mz na nb nc b">map[string]interface{}</code>值来创建一个内部结构，该结构非常类似于来自k8s API服务器的REST有效负载。</p><p id="a6f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mz na nb nc b">client-go/dynamic</code>包提供了一个动态客户端，可以在任意API资源上执行RESTful操作。struct <code class="fe mz na nb nc b">dynamic.Interface</code>使用<code class="fe mz na nb nc b">unstructured.Unstructured</code>来表示来自API服务器的所有对象值。动态包将所有数据绑定推迟到运行时。</p><h1 id="948e" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">基本示例</h1><p id="5fa3" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">以下代码示例需要依赖关系<code class="fe mz na nb nc b">k8s.io/client-go/kubernetes</code>和<code class="fe mz na nb nc b">sigs.k8s.io/controller-runtime</code>。控制器运行时项目是一组用于构建Kubernetes操作符的库。可以在没有控制器运行时的情况下使用client-go，但是简化了配置用于k8s API服务器访问的client-go客户端。</p><p id="1c97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为API访问配置client-go时，有两种常见的配置方法。在pod内运行时使用集群内配置，并使用装载到pod的服务帐户令牌。在群集外运行时使用群集外配置，它使用提供的kubeconfig文件或当前用户的默认kubeconfig文件。控制器运行时库提供了一个方便的一体化函数<code class="fe mz na nb nc b">GetConfig()</code>，它首先尝试集群外配置，如果失败，则尝试集群内配置。</p><p id="b84e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要将所需的依赖项添加到Go项目中，请执行以下命令:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="164e" class="nh md iq nc b gy ni nj l nk nl">go get k8s.io/client-go/kubernetes<br/>go get sigs.k8s.io/controller-runtime</span></pre><p id="61aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下示例在功能上是等效的，但展示了使用类型化客户端和动态客户端时的语义差异。</p><h2 id="3bcf" class="nh md iq bd me nm nn dn mi no np dp mm la nq nr mo le ns nt mq li nu nv ms nw bi translated">使用kubernetes获取k8s对象。客户端集</h2><p id="0061" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">下面的代码片段定义了一个函数，使用来自<code class="fe mz na nb nc b">kubernetes.Clientset</code>的类型化部署客户端来检索k8s部署对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">使用类型化客户端获取部署列表</figcaption></figure><h2 id="9610" class="nh md iq bd me nm nn dn mi no np dp mm la nq nr mo le ns nt mq li nu nv ms nw bi translated">使用动态获取k8s对象。连接</h2><p id="67dc" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">下面的代码片段定义了一个使用动态客户端检索k8s对象的函数。调用该函数来检索默认名称空间<em class="od">中的部署列表。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">使用动态客户端获取部署列表</figcaption></figure><p id="815a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这两个例子中很明显，使用类型化客户端处理k8s对象更简单，需要的代码也更少。但是，动态方法更加强大和灵活，特别是当资源类型事先不知道，或者需要使用缺少相关Golang结构的自定义资源定义时。</p><h1 id="0dfe" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">高级示例</h1><p id="2a48" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">真正受益于动态客户端提供的灵活性的一个用例是使用<strong class="kt ir"> jq </strong>评估或变更k8s对象。Jq对于JSON数据来说就像<strong class="kt ir"> sed </strong>、<strong class="kt ir"> awk </strong>和<strong class="kt ir"> grep </strong>。它是<strong class="kt ir"> kubectl </strong>的有用伴侣，简化了k8s对象的读取、解析和变异。</p><p id="bfa8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，为遇到的每个资源类型编写显式类型处理可能会很乏味。此外，可能遇到的所有可能的资源类型可能事先都不知道。</p><p id="5aab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个代码示例使用了jq的纯Go实现<code class="fe mz na nb nc b">github.com/itchyny/gojq</code>。要将所需的依赖项添加到Go项目中，请执行以下命令:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="5ab0" class="nh md iq nc b gy ni nj l nk nl">go get github.com/itchyny/gojq</span></pre><h2 id="4edf" class="nh md iq bd me nm nn dn mi no np dp mm la nq nr mo le ns nt mq li nu nv ms nw bi translated">检查特定标签的Kubernetes对象</h2><p id="be9e" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">下面的代码片段重用了上一个示例中的函数<code class="fe mz na nb nc b">GetResourcesDynamically </code>来获取<em class="od">默认</em>名称空间中的部署列表。然后检查每个部署是否使用jq将标签<code class="fe mz na nb nc b">app.kubernetes.io/managed-by</code>设置为值<code class="fe mz na nb nc b">Helm</code>。</p><p id="1636" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使jq评估成为可能，从API服务器返回的对象必须转换成JSON。<code class="fe mz na nb nc b">k8s.io/apimachinery/pkg/runtime</code>包通过在<code class="fe mz na nb nc b">runtime.DefaultUnstructuredConverter</code>提供一个非结构化到JSON的转换器来简化这个过程。一旦转换成JSON，就执行jq评估，如果它返回一个布尔结果，并且结果为“true”，那么k8s对象就被添加到由函数返回的片上。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">动态获取部署列表并检查特定标签</figcaption></figure><p id="ee3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，使用类型化客户端，上面的示例可以用更少的代码更简单地完成。不过，这是因为我们知道我们正在处理部署并查看Kubernetes元数据，这在所有对象类型中都很常见。然而，想象一下，如果我们编写一个函数，可以计算任何对象类型中的任何字段，我们将需要多少代码。如果没有动态客户机的强大功能、对底层JSON内容的访问以及jq，这将是一项难以完成的任务。</p><h1 id="9ba2" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">摘要</h1><p id="d4a3" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在这篇文章中，我们使用API machinery子项目client-go中的类型化和动态客户端评估了在Go中使用实时Kubernetes对象的情况。对于基本用例，类型化客户端提供了对k8s对象的简单、优雅的访问。但是，如果有许多对象类型，或者特定的对象类型不是事先知道的，或者对象类型来自缺乏相关Golang结构的第三方，那么动态客户端就提供了所需的灵活性。</p><h1 id="9cec" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">参考</h1><ul class=""><li id="96a3" class="ln lo iq kt b ku mu kx mv la oe le of li og lm oh lt lu lv bi translated"><a class="ae mb" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank">转到Kubernetes客户端</a></li><li id="8d2a" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm oh lt lu lv bi translated"><a class="ae mb" href="https://github.com/kubernetes/apimachinery" rel="noopener ugc nofollow" target="_blank"> API机械库</a></li><li id="42a9" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm oh lt lu lv bi translated"><a class="ae mb" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a> / <a class="ae mb" href="https://jqplay.org" rel="noopener ugc nofollow" target="_blank"> jq游乐场</a></li></ul></div></div>    
</body>
</html>