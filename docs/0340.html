<html>
<head>
<title>What’s Point Free Style in TypeScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的点自由样式是什么？</h1>
<blockquote>原文：<a href="https://itnext.io/whats-point-free-style-in-typescript-39337000c8cb?source=collection_archive---------4-----------------------#2018-02-22">https://itnext.io/whats-point-free-style-in-typescript-39337000c8cb?source=collection_archive---------4-----------------------#2018-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="afb0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">TypeScript/JavaScript中的函数编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3652333a13a30f6176f5dd7419a4d6f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78zqcb2NSKYgzoz4FdiK0w.jpeg"/></div></div></figure><h1 id="e4c8" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">什么是无积分</h1><p id="1e95" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">单点自由风格基本上是你写代码，但不明确地在代码中提供参数。</p><p id="6a30" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这在需要函数的回调中尤其有用。我将向您展示TypeScript中的示例，它在JavaScript/ES6中也是一样的。</p><p id="954b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">想象一下你有一份财务交易清单。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="ab62" class="mp ks iq ml b gy mq mr l ms mt">interface Transaction {<br/> amount: number;<br/>}</span></pre><p id="f972" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">现在你想得到一个正交易的列表。</p><p id="0f95" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">通常您可以这样做:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="de01" class="mp ks iq ml b gy mq mr l ms mt">public getPositiveTransactions(transactions: Transaction[]) {<br/>  return transactions.filter((t: Transaction) =&gt; t.amount &gt; 0));<br/>}</span></pre><p id="ab83" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">或者您可以通过将函数名传递给过滤器回调来实现无点风格。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="d8d9" class="mp ks iq ml b gy mq mr l ms mt">public getPositiveTransactions(transactions: Transaction[]) {<br/>  return transactions.filter(this.isPositive);<br/>}</span><span id="2462" class="mp ks iq ml b gy mu mr l ms mt">private isPositive(transaction: Transaction) {<br/>  return transaction.amount &gt; 0;<br/>}</span></pre></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="dced" class="kr ks iq bd kt ku nc kw kx ky nd la lb jw ne jx ld jz nf ka lf kc ng kd lh li bi translated">积分免费的好处</h1><p id="9165" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">point free的好处是让你的代码<strong class="ll ir">易于阅读</strong>。从长远来看，当你写任何代码时，可读性应该是最重要的。这里有一句我最喜欢的关于“可读性”的名言:</p><blockquote class="nh"><p id="8db4" class="ni nj iq bd nk nl nm nn no np nq me dk translated">程序应该是写给人们阅读的，只是顺便给机器执行的。</p></blockquote><p id="a855" class="pw-post-body-paragraph lj lk iq ll b lm nr jr lo lp ns ju lr ls nt lu lv lw nu ly lz ma nv mc md me ij bi translated">但是最初看起来没有什么好处，因为我们基本上只是用函数名替换了一个内联函数实现。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="73f8" class="mp ks iq ml b gy mq mr l ms mt">transactions.filter((t: Transaction) =&gt; t.amount &gt; 0));</span><span id="a421" class="mp ks iq ml b gy mu mr l ms mt">vs</span><span id="3044" class="mp ks iq ml b gy mu mr l ms mt">transactions.filter(this.isPositive);</span></pre><p id="4c62" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">但是当需求变得更加复杂时，您将开始看到好处。</p><p id="be9d" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">现在你有了一个新的需求，说我们需要得到一个有“大”金额的交易列表，这个“大”金额在某处被定义为一个常数。</p><p id="0a08" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">所以通常你只需要更新你的函数来改变内联函数。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="9ec9" class="mp ks iq ml b gy mq mr l ms mt">private const BIG_AMOUNT = 10;  <br/><br/>public getBigTransactions(transactions: Transaction[]) {<br/>  return transactions.filter((t: Transaction) =&gt; t.amount &gt; this.BIG_AMOUNT);<br/>}</span></pre><p id="37b0" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这是可行的，但是现在你的内部函数实现依赖于一个“外部”常量，这对一个函数来说是不好的。我们希望我们的函数是“纯”的，这意味着所有的输入都被提供给函数。</p><p id="99a7" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们来看看如何以点自由的风格做到这一点:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="c1ab" class="mp ks iq ml b gy mq mr l ms mt">private const BIG_AMOUNT = 10;</span><span id="a644" class="mp ks iq ml b gy mu mr l ms mt">public getBigTransactions(transactions: Transaction[]) {<br/>  return transactions.filter(this.moreThan(this.BIG_AMOUNT));<br/>}</span><span id="a076" class="mp ks iq ml b gy mu mr l ms mt">private moreThan(amount: number) {<br/>  return (transaction: Transaction) =&gt; transaction.amount &gt; amount;<br/>}</span></pre><p id="0875" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">注意代码是"<strong class="ll ir"> fluent </strong>"读起来:如果超过BIG_AMOUNT，我们就要过滤。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="c7aa" class="kr ks iq bd kt ku nc kw kx ky nd la lb jw ne jx ld jz nf ka lf kc ng kd lh li bi translated">小心“这个”</h1><p id="df61" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果我把上面的代码改成下面的，会有用吗？</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="7a54" class="mp ks iq ml b gy mq mr l ms mt">private const BIG_AMOUNT = 10;</span><span id="f10d" class="mp ks iq ml b gy mu mr l ms mt">public getBigTransactions(transactions: Transaction[]) {<br/>  return transactions.filter(this.moreThanBigAmount);<br/>}</span><span id="5329" class="mp ks iq ml b gy mu mr l ms mt">private moreThanBigAmount(transaction: Transaction) {<br/>  return transaction.amount &gt; this.BIG_AMOUNT;<br/>}</span></pre><p id="f91b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">答案是:不会，不会因为“这个”而行不通。</p><p id="67d2" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">对于TypeScript/JavaScript中的“this”我就不多赘述了，但是“this”基本上取决于调用者。而在我们这里的例子中，当在<code class="fe nw nx ny ml b">filter</code>回调中调用<code class="fe nw nx ny ml b">this.moreThanBigAmount</code>时，调用者就是“window”。</p><p id="5dc6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们可以在定义函数时通过<code class="fe nw nx ny ml b">bind</code>到<code class="fe nw nx ny ml b">this</code>来解决这个问题，但是我们应该避免这样做。</p><p id="b729" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">关键是，如果我们试图用函数式编程来编程或思考，我们需要显式地将所有依赖项定义为函数输入。我们应该避免在任何作为第一类对象传递的函数中使用“this”。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="b01f" class="kr ks iq bd kt ku nc kw kx ky nd la lb jw ne jx ld jz nf ka lf kc ng kd lh li bi translated">积分免费是如何运作的</h1><p id="f53c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">所以自由点函数的工作原理是:</p><ol class=""><li id="b570" class="nz oa iq ll b lm mf lp mg ls ob lw oc ma od me oe of og oh bi translated">在需要函数的地方提供函数名。</li><li id="6b7e" class="nz oa iq ll b lm oi lp oj ls ok lw ol ma om me oe of og oh bi translated">在大多数情况下，该功能需要<strong class="ll ir">部分应用。</strong>(参见上面的<code class="fe nw nx ny ml b">moreThan</code>功能)</li></ol><p id="1074" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果你不熟悉<strong class="ll ir">部分应用的</strong>功能，或者技术名称“<strong class="ll ir">奉承</strong>，我会在下一篇文章中解释。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="9a79" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><em class="on">本文属于TypeScript/JavaScript中</em> <a class="ae oo" href="https://medium.com/@hamxiaoz/functional-programming-in-typescript-javascript-d9d79663bc4" rel="noopener"> <em class="on">函数式编程系列。</em>T9】</a></p></div></div>    
</body>
</html>