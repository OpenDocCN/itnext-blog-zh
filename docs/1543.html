<html>
<head>
<title>Learn to visualize React components by parsing JSX with Babel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过用巴别塔解析JSX，学习可视化React组件</h1>
<blockquote>原文：<a href="https://itnext.io/parse-react-components-with-babel-and-visualize-them-45062046cb72?source=collection_archive---------4-----------------------#2018-11-19">https://itnext.io/parse-react-components-with-babel-and-visualize-them-45062046cb72?source=collection_archive---------4-----------------------#2018-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/639e63cbd52f066e1b232c78e7da1826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6KeQWSqqXqJ-C7a1sU3aA.png"/></div></div></figure><p id="a0a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大型JavaScript应用程序中存在大数据结构或组件是很自然的。有时，这些数据结构或组件是应用程序的核心，但对于新开发人员或从事该项目的非技术人员来说，理解起来确实很困难。在这些情况下，有可能将数据结构或组件本身可视化，以使数据结构和组件更易于访问。在大多数情况下，手工做一次就足够了，但是如果您有变化的组件或数据结构，那么自动化将是一件很棒的事情。这个自动化步骤将在这篇博客文章中解释。我们要做的如下:</p><ul class=""><li id="fd17" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">学习解析编程语言</li><li id="b4a5" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">使用Babel掌握JavaScript解析的诀窍</li><li id="d6c6" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">创建反应组件的抽象语法树(AST)</li><li id="802e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">将这个抽象语法树(AST)简化为更好的格式</li><li id="ee8e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">可视化抽象语法树的改进格式</li></ul><h2 id="1809" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">编程语言的结构</h2><p id="6b92" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">每种编程语言都是逻辑运算的构造。最后，每种语言都以某种方式被编译成某种计算机或运行系统能够理解的代码。使语言能够被转换需要特定的格式。这就是抽象语法树发挥作用的地方。在这种意义上，树只是一个具有多个子节点的根节点，子节点也可以有子节点。重要的是只有一个根节点。抽象语法树中的每个节点都定义了源代码的某种结构。例如，在HTML中，带有文本的a标签应该是两个节点。第一个节点是类型为<code class="fe mi mj mk ml b">a</code>的HTML标签，它会有一个子节点，这个子节点可能是一个文本节点，里面的值为<code class="fe mi mj mk ml b">Hello World</code>。在这种情况下，根节点是HTML节点。我需要在这里提到，HTML本质上不是编程语言，但像其他语言一样是可解析的。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/9b78ac1e6fbc902360ae3ac48bde58c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*31heoCYmwjjtdxiaAgVQ2g.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">简单HTML树的结构</figcaption></figure><p id="a6f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解稍微复杂一点的例子，让我们看看下面的HTML结构结构:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/b4b4c48d7e79810fe80d3e117cb5655c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JtO17kKxqN885Gg0BY4Leg.png"/></div></div></figure><p id="547d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是一个简单的<code class="fe mi mj mk ml b">div</code>元素，带有一个标题和一个内联文本元素。该树的结构如下图所示。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/21964c18ba7208cbd33c2c14979f3398.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*f1PqzH38Fy-oaB2vcsyVyQ.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">更复杂的HTML结构的树</figcaption></figure><p id="3730" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们有一个根节点，它基本上是<code class="fe mi mj mk ml b">div</code>元素，包含子节点，这些子节点也是HTML节点，但也只包含一个子节点，即文本。这些可视化是我想要实现的，用来显示React组件，因为它们有相似的结构。为此，我们需要能够解析负责它的JavaScript。</p><h2 id="2694" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">使用Babel掌握JavaScript解析的诀窍</h2><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/bd38f532e33a5791d40a9d811c1de08e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CuYO1e5eXKE4q1ziTE9UTw.png"/></div></div></figure><p id="c251" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Babel是一个JavaScript编译器，提供了很多功能。通常情况下，它会将ES6和更新的语法编译成旧版本，这样JavaScript就可以在任何浏览器上运行，但开发者可以编写现代语法。这对开发人员来说非常有用，因为他们不需要编写与Internet Explorer兼容的代码。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d6e77a18c3cd7b4b6717dc23f857b9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmmRlnecKxVEYliHP_JV5w.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">ES6代码</figcaption></figure><p id="56c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上图中，你可以看到一些符合ES6的代码，它们可以在大多数现代浏览器上运行，但试图在Internet Explorer中运行这些代码会失败，因为它不支持这种现代语法，如<code class="fe mi mj mk ml b">const</code> [ <a class="ae my" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank"> MDN </a>或模板文字[ <a class="ae my" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank"> MDN </a> ]。但是因为这些新特性可以以某种方式重写，所以Babel能够将这些源代码编译成一个版本的源代码，这个版本的源代码甚至可以在Internet Explorer这样的旧浏览器中运行。你可以在下面看到编译好的代码，也可以在Babel网站上试用。他们提供了一个你可以四处游玩的REPL:<a class="ae my" href="https://babeljs.io/en/repl" rel="noopener ugc nofollow" target="_blank">https://babeljs.io/en/repl</a></p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d9a4979a429fb2558e29339ed6a77bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMnJUkjFmqVSCaJgXyAbhA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">用巴别塔编译代码</figcaption></figure><p id="c0b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">巴别塔看起来已经很棒了，但是它是怎么做到这样的呢？</p><p id="2294" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Babel有很多实用程序，但是第一个使用的实用程序是Babel parser。它可以从<a class="ae my" href="https://www.npmjs.com/package/@babel/parser" rel="noopener ugc nofollow" target="_blank"> npm </a>单独下载，你可以在这里找到关于这个包的文档:<a class="ae my" href="https://babeljs.io/docs/en/babel-parser" rel="noopener ugc nofollow" target="_blank">https://babeljs.io/docs/en/babel-parser</a>。基本上，该功能可以描述为引用自文档:</p><blockquote class="mz na nb"><p id="8bc5" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">巴别塔解析器根据巴别塔AST格式生成AST。它基于ESTree规范[…]</p></blockquote><p id="2719" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该软件包提供了两个功能，但我们将只关注<code class="fe mi mj mk ml b">parse</code>功能。这是一个带有两个参数的单一函数。第一个参数是要解析的代码，第二个可选参数是给函数的选项。这个函数的输出将是一个抽象的语法树。为了了解这个抽象语法树的样子，我们将使用工具AST explorer。这是一个web应用程序，你可以在其中粘贴一些代码，它会给你一个抽象的语法树，以可视化这些代码是如何被解析的。你可以在这里找到申请:<a class="ae my" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank">https://astexplorer.net/</a></p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/b1332ef158c416dc6a9fbf07e70a94c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCABH1ei6Mu6wYySY7L4Zw.png"/></div></div></figure><p id="1941" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们将粘贴到AST explorer中的源代码。务必将解析器从<code class="fe mi mj mk ml b">acord</code>设置为<code class="fe mi mj mk ml b">babylon</code>。Babylon是之前在Babel中使用的解析器，但是它给你的输出和<code class="fe mi mj mk ml b">@babel/parser</code>差不多。将源代码粘贴到内部会得到类似的输出，如下面的JSON:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d4ec01db9976cd44a78ed399816ac0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3gDY8_oqNfhLn2J9oFltVQ.png"/></div></div></figure><p id="7054" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到这在某种程度上代表了一棵树，因为只有一个根节点<code class="fe mi mj mk ml b">program</code>。然后你会越来越多地嵌套到声明和其他元素中。随着程序和源代码越来越大，这个树的规模将会急剧增长。所以Babel现在做的，是检查这些类型的声明，等等，并分析树结构，看看它是否能转换一些节点。在这个例子中，要将<code class="fe mi mj mk ml b">const</code>转换为<code class="fe mi mj mk ml b">var</code>，只需检查整个树中类型为<code class="fe mi mj mk ml b">VariableDeclaration</code>的节点，并检查<code class="fe mi mj mk ml b">kind</code>属性是否为<code class="fe mi mj mk ml b">const</code>就很容易了。如果是这种情况，可以将树重写为<code class="fe mi mj mk ml b">kind</code> <code class="fe mi mj mk ml b">var</code>。有了这个结构，我们可以再次从树中创建JavaScript。这也在一个巴别塔包中给出，但我不会在这篇博客文章中演示。只要理解这是可能的就够了，因为这对我们来说并不重要。</p><p id="3210" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是每个编译器工作的基本结构。一种语言可以被解析成抽象的语法树，然后可以被转换。这是一个很深的计算机科学主题，主要在大学课程中涉及，但理解起来真的很好，因为它也可以用于各种工作场景。</p><h2 id="47c9" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">创建反应组件的抽象语法树(AST)</h2><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/458ec1577c8c97ded11b14509084b486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcT7iFGhv2k148i3uiy71A.png"/></div></div></figure><p id="af28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了我们收集的知识，我们就可以开始解析React组件了。在左侧，您可以看到一个简单的功能性React组件。由于JSX是“符合JavaScript”的语法，我们可以直接开始尝试解析它。为此，让我们创建一个新的Node.js项目，并将依赖项<code class="fe mi mj mk ml b">@babel/parser</code>添加到该项目中。</p><p id="48cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成这些之后，我们可以开始编写代码来解析React组件。应该比较容易。我们需要从Node.js导入解析器和文件读取实用程序，之后，我们将React组件的内容读入一个变量，然后将这个变量作为解析功能的参数。我们从函数中得到的结果应该是组件的抽象语法树。源代码应该如下所示:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/076c49e46bc7768bc2e62228529a9bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naiV5PTX03wNP9wp5cU83w.png"/></div></div></figure><p id="24b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行这段代码会导致一个错误🤷<code class="fe mi mj mk ml b">SyntaxError: Unexpected token (3:4)</code>。这是因为Babel不能解析JSX，默认情况下也不支持模块。为此，我们需要向<code class="fe mi mj mk ml b">babelParser</code>的<code class="fe mi mj mk ml b">parse</code>函数传递一个配置对象。之后的源代码应该如下图所示:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/7e51714c52a9fdba24193aa69b25a23d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyeBEGz6JWDuMEqWZCKDjA.png"/></div></div></figure><p id="14f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这之后，我们的控制台会发出一个很长的JSON。这个JSON表示React组件的抽象语法树。它非常长，但是包含了对抽象语法树进行大量操作的所有细节。你可以在这个<a class="ae my" href="https://gist.github.com/igeligel/212b7fb90b5b9c13ed287d129b6f2fb8" rel="noopener ugc nofollow" target="_blank">要点</a>中找到完整的JSON。</p><p id="91f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这非常简单，并且真正展示了巴别塔的建筑有多伟大。在我看来，这个工具本身做了很多事情，并且还处理了编程世界中最复杂的事情之一，但是它将功能分解成小的可重用模块，所以你实际上可以理解一个简单的模块来使用它。非常感谢伟大的巴别塔团队:)</p><h2 id="5f6b" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">将这个抽象语法树(AST)简化为更好的格式</h2><p id="07d9" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在这个<a class="ae my" href="https://gist.github.com/igeligel/212b7fb90b5b9c13ed287d129b6f2fb8" rel="noopener ugc nofollow" target="_blank">要点</a>中显示的当前抽象语法树包含600行JSON，这是很难处理的。在这种情况下，我们的任务是可视化JSX组件的HTML结构。因此，为了了解这些信息在哪里，我们需要以某种方式观察抽象语法树。我以某种方式减少了树中的一个元素，为我们提供了重要的信息，如下图所示。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/69bc763744c4987a333c4957e625e879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SWdFVDEZgytSzGY267qFfQ.png"/></div></div></figure><p id="0ab7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到我们有一个类型为<code class="fe mi mj mk ml b">JSXElement</code>的顶级节点。在里面我们有像<code class="fe mi mj mk ml b">openingElement</code>和<code class="fe mi mj mk ml b">closingElement</code>这样的属性，还有<code class="fe mi mj mk ml b">children</code>。在这种情况下，我们应该关注JSXElement节点并寻找它们的属性<code class="fe mi mj mk ml b">openingElement.name.name</code>，因为这是我们正在寻找的信息。如果我们在整个JSON中扫描类型为<code class="fe mi mj mk ml b">JSXElement</code>的节点，我们会发现六个这种类型的节点，其中<code class="fe mi mj mk ml b">openingElement.name.name</code>如下:</p><ul class=""><li id="bfdb" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><code class="fe mi mj mk ml b">div</code></li><li id="3ce3" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><code class="fe mi mj mk ml b">div</code></li><li id="bffa" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><code class="fe mi mj mk ml b">p</code></li><li id="7bf6" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><code class="fe mi mj mk ml b">div</code></li><li id="fd9a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><code class="fe mi mj mk ml b">span</code></li><li id="3d0a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><code class="fe mi mj mk ml b">h1</code></li></ul><p id="bf59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种结构可以解释，因为巴别塔是递归遍历树。它将从一个节点转到下一个可能的子节点，然后尝试转到下一个节点，直到不再可能。每一个被访问的节点都将被标记，如果当前指针位于不能找到未被访问的节点的点上，它将返回到它的父节点。那么该算法将尝试去更多未标记的子节点。只要有未访问的节点，就会这样做。在我们的例子中，它将深入JSX组件，首先查看内部的<code class="fe mi mj mk ml b">span</code>和<code class="fe mi mj mk ml b">p</code>标记，然后返回到根<code class="fe mi mj mk ml b">div</code>，然后访问另一个<code class="fe mi mj mk ml b">h1</code>标记。</p><p id="ce5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们最终想要的，会是这样一个表示:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/fe7968cdefddaef2d939bde9d2af808a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUiqurr4wd6vxznCzJ1CCQ.png"/></div></div></figure><p id="4a71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个完全简化的抽象语法树，只有JSX组件中HTML元素的结构。为了达到这个目的，我们需要简化巴别塔解析器给出的原始抽象语法树。您可以在我创建的存储库的这个文件中找到完整的代码:<a class="ae my" href="https://github.com/igeligel/jsx-to-simple-ast/blob/master/src/parser.js" rel="noopener ugc nofollow" target="_blank">https://github . com/igeli gel/jsx-to-simple-ast/blob/master/src/parser . js</a></p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/69e50f11d71d4f3288d3da2763c96464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNuz3MJUxboGQARUsA5glg.png"/></div></div></figure><p id="030e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的第一步是找到文件的主体。我称之为<code class="fe mi mj mk ml b">initialAst</code>,因为这是抽象语法树的第一个简化版本。我们首先扫描一个指定的出口声明，然后遍历正确的声明来找到声明的主体。调用它时使用的参数实际上是export语句的值。这是我们在这里可以得到的“最原始”的树节点。从现在开始，我们有一个带有几个孩子的根节点，并以某种方式重复，这样我们就可以轻松地遍历树。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/80a893de3c15cc29dc685c5a98000373.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*aB78_UB3TK4NwVea6ZYyoA.png"/></div></figure><p id="eac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">遍历树通常是一个递归函数。这是因为我们在这里逐个节点地工作，只扫描节点是否属于某种类型，然后检查它是否有子节点。所以第一步是遍历每个节点，检查类型是否是<code class="fe mi mj mk ml b">JSXElement</code>。如果没有，我们只是或多或少地跳过这个节点，不做任何事情。这是因为我们不能直接删除节点，因为这样我们就不再有结构了，因为父子关系会丢失。想象图像中文本旁边的一个<code class="fe mi mj mk ml b">...</code>节点将被删除。对子节点的引用也将丢失，我们将不再知道底部的<code class="fe mi mj mk ml b">JSXElement</code>节点实际上引用了根节点。相反，我们所做的是给当前节点一个父节点的子节点属性的引用，这样我们就可以在那里分配适当的子节点。如果我们发现一个类型为<code class="fe mi mj mk ml b">JSXElement</code>的新节点，我们会给这个节点分配一个新的子节点数组，并将这些子节点再次传递给真正的AST子节点。所以基本上我们对每个节点都这样做，这就是为什么递归函数是我们现在能做的最好的。您可以在下面的代码片段中看到该功能:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/6af47c0076170618b04211e6d9fe0c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UAWv5B0192ZFKk49qtaTHQ.png"/></div></div></figure><p id="06f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk ml b">oldNode</code>在这个例子中只是一个被传递给函数的新数组。因此，我们实际上在这里创建了一个全新的树，只是传递新树的节点，以不破坏旧树的顺序，旧树是当前节点。</p><p id="d5c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在将初始的抽象语法树与该功能相结合，将得到以下简化的抽象语法树:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/b294d5cd6439b2da3cf3d175c4a10b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RszHEbCAJdCSZgFAEJQVg.png"/></div></div></figure><p id="43d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这正是我们想要实现的目标。现在我们有了一个简化的HTML结构的实际形式，它被表示为一个简单的抽象语法树。现在我们可以使用这种树形结构。可能性有:</p><ul class=""><li id="f37c" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">生成HTML代码</li><li id="ba93" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">生成图表</li><li id="2328" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">分析嵌套和其他复杂性趋势</li></ul><p id="2ff8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的可能性是无限的。如何处理它取决于你的任务。</p><h2 id="65d2" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">可视化抽象语法树的改进格式</h2><p id="1b16" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">视觉化是我想通过这个项目实现的最后一步。经过一些研究，我还没有找到这个问题的即插即用解决方案，但我在codepen上找到了一个很好的D3.js树形布局解决方案的例子<a class="ae my" href="https://codepen.io/zhulinpinyu/" rel="noopener ugc nofollow" target="_blank">zhulinpiyu</a>，并将其移植到codesandbox中。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f5a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要改变树的结构，我们需要转到<code class="fe mi mj mk ml b">src</code>文件夹的<code class="fe mi mj mk ml b">index.js</code>文件。在那里，我们可以找到Node.js程序生成的树的确切配置。如果您更改了Node.js项目中的React组件结构，并让该项目再次运行，您将看到更改后的输出。只需将其粘贴到codesandbox中，并让您的树得到渲染。</p><p id="9fb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用JavaScript实现可视化还有很多可能性。如果您对这些图表感兴趣，我可以明确地推荐以下工具和库:</p><ul class=""><li id="17ac" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae my" href="https://codesandbox.io" rel="noopener ugc nofollow" target="_blank">code sandbox . io</a>——一个非常棒的JavaScript应用在线编辑器</li><li id="723f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae my" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> d3.js </a> —用于创建图表的库</li><li id="9281" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae my" href="https://github.com/igeligel/jsx-to-simple-ast" rel="noopener ugc nofollow" target="_blank"> jsx-to-simple-ast </a> —树生成器的存储库</li></ul><blockquote class="mz na nb"><p id="36eb" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">感谢你阅读这篇文章。你摇滚<em class="iq">🤘</em></p><p id="5f48" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">也可以查看我的其他博客文章，比如JavaScript中的<a class="ae my" href="https://medium.com/@kevin_peters/function-parameters-in-javascript-clean-code-4caac109159b" rel="noopener">函数参数</a>，<a class="ae my" href="https://medium.com/@kevin_peters/learn-how-to-refactor-vue-js-single-file-components-on-a-real-world-example-501b3952ae49" rel="noopener">学习如何用真实的例子重构Vue.js单个文件组件</a>或者Python的自动格式化器<a class="ae my" href="https://medium.com/3yourmind/auto-formatters-for-python-8925065f9505" rel="noopener">。</a></p><p id="32f2" class="jy jz nc ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">如果你有任何反馈或者想给这篇文章添加一些东西，请在这里评论。您也可以在<a class="ae my" href="https://twitter.com/kevinpeters_" rel="noopener ugc nofollow" target="_blank"> twitter </a>上关注我，或者访问我的<a class="ae my" href="https://www.kevinpeters.net/" rel="noopener ugc nofollow" target="_blank">个人网站</a>来了解我的博客文章和许多其他内容。</p></blockquote></div></div>    
</body>
</html>