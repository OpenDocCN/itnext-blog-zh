<html>
<head>
<title>Use JSON Schema for your app config</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的应用程序配置使用JSON模式</h1>
<blockquote>原文：<a href="https://itnext.io/use-json-schema-for-your-app-config-3c1f4773560f?source=collection_archive---------6-----------------------#2019-04-05">https://itnext.io/use-json-schema-for-your-app-config-3c1f4773560f?source=collection_archive---------6-----------------------#2019-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/08be4162624bec3198ad48573f1720bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSoiPBhcwIwEFDYyv28SvQ.png"/></div></div></figure><p id="f9c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON模式</a>是一种组织应用程序配置变量的便捷方式。你的应用程序的配置毕竟是一个模型。以下是我认为在应用程序的配置设置中应该满足的要求。</p><ul class=""><li id="2464" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">变量/属性(那个是gimmy)</li><li id="28a2" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">为未来的开发人员或部署您的开源应用程序的人员提供这些变量的用户友好描述。</li><li id="2f15" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">有意义的地方默认。</li><li id="d9ae" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">一种根据环境(如开发或生产)对配置值组合进行分组的方法。</li><li id="54e0" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">将环境变量合并到您的配置中。这包括用环境中的值覆盖配置值，还包括将那些环境变量从字符串转换为数字和布尔值。不再有<code class="fe ll lm ln lo b">if (process.env.myBoolVariable === 'true')</code>。</li><li id="a8ba" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">(可选)验证您的配置数据结构。得到一个配置验证错误比在代码中找到它要好得多。</li><li id="093c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">(可选)能够在应用运行时更新配置。这应该伴随着监听应用配置变化的能力。</li><li id="73c4" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">(可选)嵌套数据结构。</li></ul><p id="9fdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我开发的应用程序中，我继承并启动了大量的配置设置。我用过<code class="fe ll lm ln lo b">dotenv</code>和<code class="fe ll lm ln lo b">nconf</code>。我还使用了像导出一个对象的JS文件这样简单的设置。上面的列表是我通过目睹别人做过的我喜欢的事情，以及从艰难的道路中学到的教训而积累起来的。我用过的大多数设置，包括<code class="fe ll lm ln lo b">dotenv</code>和<code class="fe ll lm ln lo b">nconf</code>，都没有达到上面的一个或多个要点。<code class="fe ll lm ln lo b">nconf</code>勾选了最多的框，但是<code class="fe ll lm ln lo b">dotenv</code>更受欢迎，可能是因为它的简单。不过我喜欢这些库中的一点是config是全局可访问的。使用<code class="fe ll lm ln lo b">dotenv</code> config就是<code class="fe ll lm ln lo b">process.env</code>，使用<code class="fe ll lm ln lo b">nconf</code>你只需要模块，不用担心配置文件的路径。我今天提出的设置也可以这样工作，只是需要打包。</p><p id="a934" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为您的配置使用JSON Schema使您能够满足许多需求，而其他需求可以用最少的代码来满足。下面是一个JSON模式中配置变量的例子。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="a36b" class="lx ly iq lo b gy lz ma l mb mc">"port": {<br/>  "type": "integer",<br/>  "description": "The binding port for the server",<br/>  "default": 8080,<br/>  "minimum": 0<br/>}</span></pre><p id="e503" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看我们满足了哪些要求。我们有一个变量及其类型、描述和默认值。除此之外，我们可以添加验证，比如最小值。这里的类型使我们能够转换在环境变量中得到的字符串。其余的要求就不那么容易了，但是让我们看看如何尝试满足它们。</p><h1 id="fa13" class="md ly iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">故事的其余部分</h1><p id="be03" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">本文的其余部分将包含JavaScript代码示例，说明如何从JSON模式配置模型进入工作配置设置。</p><p id="bdc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是这个例子的文件结构。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="e5eb" class="lx ly iq lo b gy lz ma l mb mc">- config<br/>  - schema.json  // config model<br/>  - development.json     // config settings for development<br/>- src<br/>  - lib<br/>    - observable.js // observable class to hold config values<br/>  - config.js    // build and export a singleton config observable<br/>  - server.js    // create http server</span></pre><h2 id="6683" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">(计划或理论的)纲要</h2><p id="27ee" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">/config/schema.json</code></p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="0633" class="lx ly iq lo b gy lz ma l mb mc">{<br/>  "$id": "https://github.com/mygithub-handle/my-app-repo/blob/master/config/schema.json",<br/>  "$schema": "http://json-schema.org/draft-07/schema#",<br/>  "title": "My app config",<br/>  "type": "object",<br/>  "required": [<br/>    "port"<br/>  ],<br/>  "properties": {<br/>    "port": {<br/>      "type": "integer",<br/>      "description": "The binding port for the server",<br/>      "default": 8080,<br/>      "minimum": 0<br/>    }<br/>  }<br/>}</span></pre><h2 id="185f" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">配置文件</h2><p id="2ebc" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">/config/dev.json</code></p><p id="4f03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了便于讨论，让我们假设您需要使用一个不同于默认端口的端口进行开发。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="0a39" class="lx ly iq lo b gy lz ma l mb mc">{<br/>  "port": 3200<br/>}</span></pre><h2 id="193e" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">可观察量</h2><p id="b26b" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">/src/lib/observable.js</code></p><p id="3dfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用一个简单的自定义可观察类来保存值。我已经把<a class="ae kw" href="https://gist.github.com/rhythnic/a84f49a0f5e5440e2cdc30cbb30f404e" rel="noopener ugc nofollow" target="_blank">藏在github gist </a>里了。它由节点的<code class="fe ll lm ln lo b">EventEmitter</code>和<code class="fe ll lm ln lo b">ramda</code>组成。它允许设置和获取任何路径，深度合并多个值，监听变化，并在变异前进行验证。使用这种观察将允许我们在应用程序运行时更新配置，并监听配置的变化。不要太担心可观察到的，只是如何使用它。</p><h2 id="71a6" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">属国</h2><p id="cf51" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">src/config.js</code></p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="12cc" class="lx ly iq lo b gy lz ma l mb mc">// ajv is a json-schema validator<br/>const Ajv = require('ajv')<br/>// observable for holding the config values<br/>const Observable = require('./lib/observable')<br/>// schema shown above<br/>const schema = require('../config/schema.json')<br/>// utilities<br/>const R = require('ramda')<br/>const path = require('path')</span></pre><h2 id="2162" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">环境变量</h2><p id="89bb" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">/src/config.js</code></p><p id="f375" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用模式中的根级键，构建一个从<code class="fe ll lm ln lo b">process.env</code>中读取这些键的对象。还要将字符串转换为模式中的类型。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="7942" class="lx ly iq lo b gy lz ma l mb mc">// build an object of config values taken from process.env<br/>function buildEnvironmentVariablesConfig (schema) {<br/>  const trueRx = /^true$/i<br/>  const configKeys = Object.keys(schema.properties)<br/>  let env = R.pick(configKeys, process.env)<br/>  return Object.keys(env).reduce((acc, key) =&gt; {<br/>    const { type } = schema.properties[key]<br/>    switch (type) {<br/>      case 'integer':<br/>        return R.assoc(key, parseInt(env[key], 10), acc)<br/>      case 'boolean':<br/>        return R.assoc(key, trueRx.test(env[key]), acc)<br/>      default:<br/>        return R.assoc(key, env[key], acc)<br/>    }<br/>  }, {})<br/>}</span></pre><h2 id="5fc3" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">默认</h2><p id="3303" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">/src/config.js</code></p><p id="5f18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从架构中的默认值构建一个对象。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="3f6f" class="lx ly iq lo b gy lz ma l mb mc">// build an object using the defaults in the schema<br/>function buildDefaults (schema, definitions) {<br/>  return Object.keys(schema.properties).reduce((acc, prop) =&gt; {<br/>    let spec = schema.properties[prop]<br/>    if (spec.$ref) {<br/>      spec = definitions[spec.$ref.replace('#/definitions/', '')]<br/>      if (spec &amp;&amp; spec.type === 'object') {<br/>        return R.assoc(prop, buildDefaults(spec, definitions), acc)<br/>      }<br/>    }<br/>    return R.assoc(prop, spec.default, acc)<br/>  }, {})<br/>}</span></pre><h2 id="af4a" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">导入配置设置文件</h2><p id="c697" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">/src/config.js</code></p><p id="4efd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导入带有该环境设置的文件，如<code class="fe ll lm ln lo b">development.json</code>、<code class="fe ll lm ln lo b">production.json</code>、<code class="fe ll lm ln lo b">staging.json</code>等。你可以用一个环境变量指向这个文件，比如CONFIG_FILE。该函数为您提供了传递绝对路径或相对于保存模式的<code class="fe ll lm ln lo b">config</code>文件夹的路径的选项。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="f065" class="lx ly iq lo b gy lz ma l mb mc">// import the config file<br/>function buildConfigFromFile (filePath) {<br/>  if (!filePath) return {}<br/>  const isAbsolutePath = filePath.charAt(0) === '/'<br/>  return isAbsolutePath<br/>    ? require(filePath)<br/>    : require(path.join(__dirname, '../config', filePath))<br/>}</span></pre><h2 id="c7cc" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">将三者合并在一起</h2><p id="bc8b" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">/src/config.js</code></p><p id="207b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了3个表示环境变量、一个配置文件和默认值的对象，我们可以将它们合并在一起。<code class="fe ll lm ln lo b">R.mergeDeepRight</code>将对默认值和配置文件值进行深度合并。<code class="fe ll lm ln lo b">R.merge</code>将对结果和环境变量值进行浅层合并。在两个合并函数中，最右边的对象优先。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="364b" class="lx ly iq lo b gy lz ma l mb mc">// merge the environment variables, config file values, and defaults<br/>let configValues = R.merge(<br/>  R.mergeDeepRight(<br/>    buildDefaults(schema, schema.definitions),<br/>    buildConfigFromFile(process.env.CONFIG_FILE)<br/>  ),<br/>  buildEnvironmentVariablesConfig(schema)<br/>)</span></pre><h2 id="6153" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">验证功能</h2><p id="45ed" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">/src/config.js</code></p><p id="689a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户试图设置一个无效的配置值，我们的验证函数将抛出一个错误。另一种选择是只返回false并记录错误。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="0c84" class="lx ly iq lo b gy lz ma l mb mc">const ajv = new Ajv()<br/>const ajvValidate = ajv.compile(schema)</span><span id="53f6" class="lx ly iq lo b gy nq ma l mb mc">function validate (data) {<br/>  const valid = ajvValidate(data)<br/>  if (valid) return true<br/>  throw new Error(ajv.errorsText())<br/>}</span></pre><h2 id="6af0" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">初始化可观察对象并导出</h2><p id="fc8a" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">/src/config.js</code></p><p id="f3d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用上面的validate函数创建可观察实例，并用我们刚刚构建的配置值初始化它。导出要在应用程序中使用的单例配置对象。在应用任何突变之前，可观察对象将需要validate返回<code class="fe ll lm ln lo b">true</code>。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="6274" class="lx ly iq lo b gy lz ma l mb mc">const config = new Observable({ validate })<br/>config.setAllValues(configValues)</span><span id="5ec5" class="lx ly iq lo b gy nq ma l mb mc">module.exports = config</span></pre><h2 id="0d39" class="lx ly iq bd me nf ng dn mi nh ni dp mm kj nj nk mq kn nl nm mu kr nn no my np bi translated">使用可观察配置</h2><p id="dd48" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated"><code class="fe ll lm ln lo b">/src/server.js</code></p><p id="b774" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个使用端口变量的小例子。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="5ed4" class="lx ly iq lo b gy lz ma l mb mc">const config = require('./config')<br/>const http = require('http')</span><span id="5c68" class="lx ly iq lo b gy nq ma l mb mc">const server = http.createServer(/* some middleware callback */)<br/>server.listen(config.get('port'))</span></pre><h1 id="03f2" class="md ly iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">结论</h1><p id="af6c" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">在JSON Schema和observable的基础上构建应用程序的配置会产生一个非常有特色的配置设置。</p></div></div>    
</body>
</html>