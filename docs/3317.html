<html>
<head>
<title>Kafka Gotchas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡抓到你了</h1>
<blockquote>原文：<a href="https://itnext.io/kafka-gotchas-24b51cc8d44e?source=collection_archive---------1-----------------------#2019-11-21">https://itnext.io/kafka-gotchas-24b51cc8d44e?source=collection_archive---------1-----------------------#2019-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e1ac4cb374e4cf26a493a8e26d6cab6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y8wJtomf0m0XsE9b"/></div></div></figure><div class=""/><div class=""><h2 id="03e0" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">很好，但不完美</h2></div><p id="8393" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我已经帮助几个大客户使用Kafka作为消息传递主干构建了一个微服务风格的架构，对它的能力和真正发挥它们的用例有相当好的理解。但无论如何我都不是卡夫卡的辩护者；任何经历了如此快速的采用曲线的技术都注定会分化其受众，并使某些开发者误入歧途，卡夫卡也不例外。像其他任何事情一样，在你完全精通并能够驾驭Kafka之前，你需要投入大量的时间来理解Kafka和事件流。委婉地说，在前进的道路上，要准备好面对一两次挫折。</p><p id="6d18" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我已经整理了一个缺点列表，这些缺点可能会让开发人员感到沮丧，或者让第一次尝试开发的人措手不及。排名不分先后:</p><h1 id="f867" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated"><strong class="ak">可调旋钮太多</strong></h1><p id="4b70" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">Kafka中的<a class="ae mm" href="https://kafka.apache.org/documentation/#configuration" rel="noopener ugc nofollow" target="_blank">配置参数</a>的数量可能是压倒性的，不仅对于新手，对于经验丰富的专业人员也是如此。可能除了JVM之外，我想不出其他技术有这么多配置参数。这并不是说配置选项是不必要的；但是人们确实想知道这些参数中有多少可以被人类工程学所取代，就像Java对G1那样。因此，与其指定过多的单个阈值和容差，不如让操作员设定一个性能目标，并让系统得出一组最符合该目标的最佳值。</p><h1 id="a773" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated"><strong class="ak">不安全默认值</strong></h1><p id="61e8" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">这是我对配置选项最大的不满。卡夫卡的作者围绕他们的订购和交付保证的力量提出了几个大胆的主张。如果你认为这些违约是合理的，那也是情有可原的，因为它们应该将安全性置于其它竞争性品质之上。<strong class="kv jf"> Kafka默认设置倾向于针对性能</strong>进行优化，当安全是一个关键目标时，需要在客户端上明确覆盖<strong class="kv jf">。幸运的是，将属性设置为保证安全对性能只有很小的影响——卡夫卡仍然是一头野兽。记住优化的第一条规则:不要做。如果卡夫卡的创作者对此多加思考，他会写得更好。我提到的一些具体例子是:</strong></p><ul class=""><li id="c611" class="mn mo je kv b kw kx kz la lc mp lg mq lk mr lo ms mt mu mv bi translated"><code class="fe mw mx my mz b">enable.auto.commit</code> —默认为<code class="fe mw mx my mz b">true</code>，这导致消费者每5秒提交一次偏移(由<code class="fe mw mx my mz b">auto.commit.interval.ms</code>配置)，而不管消费者是否已经完成记录处理。通常，这不是您想要的，因为它可能会导致混合的交付语义——在消费者失败的情况下，一些记录可能会交付两次，而其他记录可能根本不会交付。这应该默认设置为<code class="fe mw mx my mz b">false</code>，让客户端应用程序指定提交点。</li><li id="ed33" class="mn mo je kv b kw na kz nb lc nc lg nd lk ne lo ms mt mu mv bi translated"><code class="fe mw mx my mz b">max.in.flight.requests.per.connection</code> —默认为<code class="fe mw mx my mz b">5</code>，如果一条(或多条)排队消息超时并重试，可能会导致消息无序发布。这个应该已经默认为<code class="fe mw mx my mz b">1</code>。</li></ul><h1 id="a331" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated"><strong class="ak">骇人听闻的明面</strong></h1><p id="e3d6" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">命令行参数的命名没有一致性，发布键控消息的简单行为需要您经历重重困难——传入模糊的、未记录的属性。甚至不支持一些本机功能，如记录标题。内置工具的可用性是Kafka社区中众所周知的令人头疼的问题。这是一个真正的耻辱。这就像买了一辆法拉利，结果却是用塑料轮毂盖交付的。大多数Kafka实践者早就放弃了开箱即用的CLI实用程序，转而支持其他开源工具，如<a class="ae mm" href="https://github.com/obsidiandynamics/kafdrop" rel="noopener ugc nofollow" target="_blank"> Kafdrop </a>、<a class="ae mm" href="https://github.com/edenhill/kafkacat" rel="noopener ugc nofollow" target="_blank"> Kafkacat </a>和第三方商业产品，如<a class="ae mm" href="http://www.kafkatool.com/" rel="noopener ugc nofollow" target="_blank"> Kafka Tool </a>。</p><h1 id="1765" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">复杂的引导过程</h1><p id="31e5" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">客户端用来建立代理连接的自举和服务发现过程非常复杂，容易让用户感到困惑。最初将向客户端提供一个代理地址和端口列表。然后，客户端将随机连接到一个地址，发现剩余的代理节点，然后直接与发现的节点建立新的连接。这在简单的同构网络设置中是相当微不足道的，其中来自所有客户端<em class="nf">和</em>对等节点的所有连接都穿过单个入口。在异构网络中，可能有几个入口点来隔离代理到代理的通信、位于同一本地网络上的内部客户端以及可能通过Internet连接的外部客户端。自举/发现过程需要一个特殊的配置，需要专用的监听器和一个<a class="ae mm" href="https://docs.confluent.io/current/kafka/multi-node.html" rel="noopener ugc nofollow" target="_blank">单独的广告监听器集</a>，它们将呈现给连接的客户端。</p><h1 id="2042" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">不稳定的客户端库</h1><p id="d006" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">除了Java、Python、.NET和C是低于标准的。如果你是一名Java开发人员，你已经做到了——这是大部分开发集中的地方。但Golang和其他一些社区一直在努力获得稳定的库，虽然其中一些“独立”库已经存在了好几年，但我在这些语言中遇到的一些错误的数量和严重性确实令人担忧。</p><h1 id="85ec" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">缺乏真正的多租户</h1><p id="611f" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">根据Kafka维护者的说法，它支持多租户。当前的设计限于访问控制列表(ACL)来隔离主题和维护配额，这为客户端创建了隔离的假象，但是没有在管理平面中创建隔离。这就像说你的冰箱支持多租户，因为它允许你在不同的货架上储存食物。真正的多租户解决方案将在一个更大的物理集群中提供多个逻辑集群。这些逻辑集群可以单独管理；例如，一个逻辑集群中的ACL配置错误不会影响其他逻辑集群。</p><h1 id="0ac8" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated"><strong class="ak">缺乏地缘意识</strong></h1><p id="c1da" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">地理复制并不是代理的内置功能，而且人们普遍认为高性能Kafka集群和“伸展”拓扑不能混合使用。有一个开源项目——<a class="ae mm" href="https://docs.confluent.io/4.0.0/multi-dc/mirrormaker.html#" rel="noopener ugc nofollow" target="_blank">mirror maker</a>——它实际上是一个将记录从一个集群抽取到另一个集群的管道，不保留任何关键的元数据(比如偏移量)。Confluent有自己的专有工具——<a class="ae mm" href="https://docs.confluent.io/current/connect/kafka-connect-replicator/index.html" rel="noopener ugc nofollow" target="_blank">复制器</a>——它将保存元数据，但它是许可的Confluent企业套件的一部分。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="cd76" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">总的来说，尽管有以上几点，我不会说卡夫卡是垃圾——恰恰相反。当然，卡夫卡也不是没有缺点。委婉地说，工具是不合格的；Kafka的配置选项的广度是压倒性的，默认设置充满了陷阱，准备好震惊毫无戒心的第一次用户。但是作为一个事件流平台，<strong class="kv jf">卡夫卡塑造了我们现在设计和构建复杂系统的方式</strong>。它给了我们选择，这是件好事。它的好处不仅仅是多余的，它们让一项已经被如此积极采用的技术中必然存在的任何麻烦都相形见绌。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="c087" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="nf">这篇文章对你有用吗？花点时间为它鼓掌，这样其他人也会发现它。我很想听到你的反馈，所以不要退缩！如果你对卡夫卡或者事件流感兴趣，或者只是有什么疑问，</em> <a class="ae mm" href="https://twitter.com/i/user/562466177" rel="noopener ugc nofollow" target="_blank"> <em class="nf">在Twitter上关注我</em> </a> <em class="nf">。</em></p></div></div>    
</body>
</html>