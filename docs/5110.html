<html>
<head>
<title>Docker container as an executable to process images using Go (golang)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker容器作为一个可执行文件来使用Go (golang)处理图像</h1>
<blockquote>原文：<a href="https://itnext.io/docker-container-as-an-executable-to-process-images-using-go-golang-5233f9bd3bf7?source=collection_archive---------1-----------------------#2020-12-14">https://itnext.io/docker-container-as-an-executable-to-process-images-using-go-golang-5233f9bd3bf7?source=collection_archive---------1-----------------------#2020-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3390" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Docker:入口点、CMD、卷</h2><div class=""/><div class=""><h2 id="531d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在本课中，我们将创建一个docker容器，它将作为可执行文件来处理一些图像文件。为此，我们将使用Docker VOLUME、ENTRYPOINT和其他Dockerfile指令。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c1a9aee055d35fa6f2f5b55008d00b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uAUyyvSNGIt4UPmBNRVOaQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://unsplash.com/photos/3_Xwxya43hE" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">unsplash.com</strong></a>)</figcaption></figure><p id="bffb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<a class="ae lh" href="https://medium.com/sysf/creating-your-first-docker-application-b0ce40ac67d1" rel="noopener"> <strong class="ll jd">上一课</strong> </a>中，我们学习了如何使用Docker文件创建Docker映像，以及创建和管理Docker容器。我们讨论了几个Dockerfile指令，如<code class="fe mf mg mh mi b">FROM</code>、<code class="fe mf mg mh mi b">WORKDIR</code>、<code class="fe mf mg mh mi b">ADD</code>、<code class="fe mf mg mh mi b">COPY</code>、<code class="fe mf mg mh mi b">CMD</code>等。以及他们对形象塑造过程的贡献。</p><p id="1c4f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这一课中，我们将讨论用于创建Docker容器的<code class="fe mf mg mh mi b">ENTRYPOINT</code>指令，Docker容器的行为类似于可执行文件。我们还将讨论如何在Docker容器和主机之间共享文件。</p><p id="54ca" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这节课，我们要用<a class="ae lh" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> Go </strong> </a> (golang)写一个图像处理程序。因此，我们需要一个带有Go安装的<strong class="ll jd">父映像</strong>。我们将使用<code class="fe mf mg mh mi b"><a class="ae lh" href="https://hub.docker.com/_/golang/" rel="noopener ugc nofollow" target="_blank">golang:1.15.6-alpine3.12</a></code>作为我们将在本课中构建的图像的父图像。</p><blockquote class="mj mk ml"><p id="c7ce" class="lj lk mm ll b lm ln kd lo lp lq kg lr mn lt lu lv mo lx ly lz mp mb mc md me im bi translated"><em class="it">💡如果你不熟悉Go (golang)编程语言，我会推荐你去看看我在RunGo的文章。这是一种简单而强大的编程语言。</em></p></blockquote><p id="e08a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">要在您的系统上安装Go，请遵循本 官方文档中的<a class="ae lh" href="https://golang.org/dl/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">。在本课中，我们使用的是<strong class="ll jd"> Go v1.15.6 </strong>,我们对父映像使用的是相同的版本。本地安装Go是不必要的，但我们希望在创建Docker映像之前先测试我们的Go程序。</strong></a></p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="a224" class="mx my it bd li mz na nb nc nd ne nf ng ki nh kj ni kl nj km nk ko nl kp nm nn bi translated">图像处理程序</h1><p id="f5db" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated">在本课中，我们将编写一个Go程序，该程序在文件系统上获取一个源图像(使用图像的路径)并将该图像裁剪成一个正方形。它还可以调整对比度和亮度。然后它最终将图像的灰度格式保存在磁盘上。结果如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/4e77ba14803f5c3ec6f7ee5bb1d1bac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*0Ev40gr4yM-LRYPahGYo0A.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://unsplash.com/photos/QhR78CbFPoE" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">unsplash.com</strong></a>)</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/41253f7b284a1c68443d2932e4ce9069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*2Bjp7W14RLWX4vw8FGpN_w.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://unsplash.com/photos/LlOVWBaHU5E" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">unsplash.com</strong></a>)</figcaption></figure><p id="91f0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们不会编写一个具有复杂逻辑的程序来操纵源图像的每个方面来实现这一功能。相反，我们将使用用Go编写的可爱的小<code class="fe mf mg mh mi b"><a class="ae lh" href="https://github.com/disintegration/imaging" rel="noopener ugc nofollow" target="_blank">imaging</a></code>库，它为我们提供了操作图像并将其保存到磁盘的函数。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="0b12" class="nz my it mi b gy oa ob l oc od"><strong class="mi jd">docker-image-processor/</strong><br/>├── .dockerignore<br/>├── .gitignore<br/>├── Dockerfile<br/>├── bin/<br/>|  └── avatar<br/>├── go.mod<br/>├── go.sum<br/>├── main.go<br/>├── process.go<br/>├── process_test.go<br/>├── shared/<br/>├── test.jpg<br/>├── tmp/<br/>|  ├── out/<br/>|  |  ├── cmd_out.jpg<br/>|  |  ├── model-1.jpg<br/>|  |  └── model-2.jpg<br/>|  └── src/<br/>|  |  ├── model-1.jpg<br/>|  |  └── model-2.jpg<br/>└── utils.go</span></pre><p id="04ca" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们的项目结构看起来会像上面这样。不要担心现在就创建这些文件，其中一些将在以后生成。首先，让我们将这个项目转换成一个<a class="ae lh" href="https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16" rel="noopener"> <strong class="ll jd"> Go模块</strong> </a>，这样我们就可以安装和跟踪依赖项了。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="ce89" class="nz my it mi b gy oa ob l oc od">$ go mod init <strong class="mi jd">docker-image-processor</strong></span></pre><p id="4f5d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">该命令将在项目目录中创建<code class="fe mf mg mh mi b">go.mod</code>文件。我们不关心发布这个Go模块，所以<code class="fe mf mg mh mi b">docker-image-processor</code>模块名称对我们来说是合适的。现在，让我们安装<code class="fe mf mg mh mi b"><a class="ae lh" href="https://github.com/disintegration/imaging" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd">imaging</strong></a></code>模块。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="f896" class="nz my it mi b gy oa ob l oc od">$ go get -u <strong class="mi jd">github.com/disintegration/imaging</strong></span></pre><p id="7c4d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">该命令将从GitHub下载<code class="fe mf mg mh mi b">imaging</code>模块，并将其注册为<code class="fe mf mg mh mi b">go.mod</code>文件中的一个依赖项。它还会生成<code class="fe mf mg mh mi b">go.sum</code>文件来保存已安装模块的加密散列和它们自己的依赖项。</p><p id="ddab" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mf mg mh mi b">process.go</code>文件包含转换源图像并将输出图像保存到磁盘的实际逻辑。它有<code class="fe mf mg mh mi b">makaAvatar</code>功能，负责生成图像。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="d423" class="nz my it mi b gy oa ob l oc od">func makaAvatar(<strong class="mi jd">srcPath</strong> string, <strong class="mi jd">outPath</strong> string) error</span></pre><p id="dead" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">该函数接受两个参数。第一个参数<code class="fe mf mg mh mi b">srcPath</code>是源图像在磁盘上的路径，第二个参数<code class="fe mf mg mh mi b">outPath</code>是保存输出图像的路径。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/f4ee137b25e9ce0a0e4a3799761f17b7" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="75ec" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mf mg mh mi b">package main</code>声明表明这个Go项目将被编译成一个<strong class="ll jd">二进制可执行文件</strong>。我们将在处理Docker文件和Docker图像时讨论更多内容。</p><p id="158c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mf mg mh mi b">utils.go</code>文件包含一些实用函数，如<code class="fe mf mg mh mi b">fileExists</code>来帮助项目中的其他程序。现在我们已经准备好了<code class="fe mf mg mh mi b">makeAvatar()</code>函数，让我们测试一下。为此，最好的方法是创建一个<a class="ae lh" href="https://medium.com/rungo/unit-testing-made-easy-in-go-25077669318" rel="noopener"> <strong class="ll jd">单元测试</strong> </a>并执行<code class="fe mf mg mh mi b">makeAvatar()</code>函数来产生一些样本输出。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/e0abb5332487d0dafc7dadac47caa17a" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="e9ec" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Go中的单元测试文件以后缀<code class="fe mf mg mh mi b">_test</code>结尾，单元测试函数必须以前缀<code class="fe mf mg mh mi b">Test</code>开头。在<code class="fe mf mg mh mi b">process_test.go</code>测试文件中，我们编写了<code class="fe mf mg mh mi b">TestMakeAvatar</code>函数，用于测试位于<code class="fe mf mg mh mi b">./tmp/src</code>目录中的样本图像的<code class="fe mf mg mh mi b">makeAvatar</code>函数，并将输出保存在<code class="fe mf mg mh mi b">./tmp/out</code>目录中。然后，它检查输出文件是否存在，以得出测试结果。让我们看看这个测试的结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi og"><img src="../Images/67d0c3a2ef57d121a7eb2477ddf76e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*jHZRnzYdATLjJXa4Hrp1XA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ go测试-v</figcaption></figure><p id="4c1a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mf mg mh mi b">go test -v</code>命令指示Go在模块目录中查找测试文件(<code class="fe mf mg mh mi b"><em class="mm">*_test.go</em></code>)并执行测试功能。从上面的结果来看，<code class="fe mf mg mh mi b">TestMakeAvatar</code>测试已经通过。运行该测试后，您将能够在<code class="fe mf mg mh mi b">./tmp/out</code>目录中看到类似下面的输出图像(<em class="mm">右</em>)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/41253f7b284a1c68443d2932e4ce9069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*2Bjp7W14RLWX4vw8FGpN_w.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://unsplash.com/photos/LlOVWBaHU5E" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">unsplash.com</strong></a>)</figcaption></figure><p id="c9e9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们处理<code class="fe mf mg mh mi b">main.go</code>文件，这将是应用程序的入口点。我们试图构建的应用程序是一个二进制可执行文件，它接受如下所示的两个参数。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="5396" class="nz my it mi b gy oa ob l oc od">$ ./avatar &lt;srcPath&gt; &lt;outPath&gt;</span></pre><p id="501a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mf mg mh mi b">./avatar</code>文件是我们将从这个Go项目构建的可执行文件。<code class="fe mf mg mh mi b">srcPath</code>和<code class="fe mf mg mh mi b">outPath</code>参数是磁盘上源映像和输出映像的路径。当我们执行这个命令时，<code class="fe mf mg mh mi b">main.go</code>文件中的<code class="fe mf mg mh mi b">main()</code>函数将使用这些参数来执行。</p><p id="a63b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是在构建一个可执行文件之前，我们需要处理<code class="fe mf mg mh mi b">main.go</code>文件，并使用命令中收到的<code class="fe mf mg mh mi b">srcPath</code>和<code class="fe mf mg mh mi b">outPath</code>调用<code class="fe mf mg mh mi b">makeAvatar()</code>函数。我们可以使用<code class="fe mf mg mh mi b">go run .</code>来运行执行<code class="fe mf mg mh mi b">main()</code>函数的模块，就像可执行文件一样。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="5cac" class="nz my it mi b gy oa ob l oc od">$ go run . &lt;srcPath&gt; &lt;outPath&gt;</span></pre><p id="ec5b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以使用<code class="fe mf mg mh mi b">os.<a class="ae lh" href="https://golang.org/pkg/os/#pkg-variables" rel="noopener ugc nofollow" target="_blank">Args</a></code>变量访问传递给执行<code class="fe mf mg mh mi b">main()</code>函数的命令的参数。<code class="fe mf mg mh mi b">Args</code>是字符串的切片(<em class="mm">数组</em>)，该切片的第一个元素包含可执行文件的路径。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="72dc" class="nz my it mi b gy oa ob l oc od"><em class="mm">// main.go</em><br/>package main</span><span id="598c" class="nz my it mi b gy oh ob l oc od">import "fmt"<br/>import "os"</span><span id="8856" class="nz my it mi b gy oh ob l oc od">func main() {<br/> fmt.Println(os.Args)<br/>}</span></pre><p id="1c98" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个简单的程序在使用命令<code class="fe mf mg mh mi b">$ go run . ./test.jpg ./test_out.jpg</code>执行时会产生以下结果。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="9061" class="nz my it mi b gy oa ob l oc od">[<br/>  /var/folders/xx/..../b001/exe/docker-image-processor<br/>  ./test.jpg<br/>  ./test_out.jpg<br/>]</span></pre><p id="001d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这种情况下，当我们运行一个Go程序或整个模块时，Go首先动态创建一个二进制可执行文件，将其存储在一个临时位置，然后执行该二进制可执行文件。二进制可执行文件的执行从执行<code class="fe mf mg mh mi b">main()</code>函数开始。</p><p id="7d52" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们感兴趣的是从<code class="fe mf mg mh mi b">os.Args</code>收到的第二个和第三个命令行参数。所以让我们修改<code class="fe mf mg mh mi b">main()</code>函数，用这两个值调用<code class="fe mf mg mh mi b">makeAvatar()</code>函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/ba0e502d6ffd89494b5bdd457cf75aa6" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="0e31" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的程序中，首先，我们检查<code class="fe mf mg mh mi b">os.Args</code>的长度是否小于<code class="fe mf mg mh mi b">3</code>的长度，如果是这种情况，则错误退出程序。然后我们提取第二个和第三个参数，它们是<code class="fe mf mg mh mi b">makeAvatar()</code>函数的<code class="fe mf mg mh mi b">srcPath</code>和<code class="fe mf mg mh mi b">outPath</code>。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="431d" class="nz my it mi b gy oa ob l oc od">$ go build <strong class="mi jd">-o ./bin/avatar</strong> .</span></pre><p id="db8f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">上面的命令将从这个模块构建一个二进制可执行文件<code class="fe mf mg mh mi b">avatar</code>,并将它放在项目的<code class="fe mf mg mh mi b">./bin</code>目录中。然后我们可以使用<code class="fe mf mg mh mi b">./bin/avatar &lt;args&gt;</code>命令执行这个二进制可执行文件。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="1a14" class="nz my it mi b gy oa ob l oc od">$ <strong class="mi jd">./bin/avatar</strong> ./tmp/src/model-1.jpg ./tmp/out/cmd_out.jpg<br/><em class="mm">Success! Image has been generated at ./tmp/out/cmd_out.jpg.</em></span></pre><p id="6d6a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Go程序中使用的相对路径将相对于当前工作目录(<em class="mm">终端打开的位置</em>)。因此，上面的命令使用<code class="fe mf mg mh mi b">&lt;project&gt;/tmp/src/model-1.jpg</code>图像作为源图像，并生成<code class="fe mf mg mh mi b">&lt;project&gt;/tmp/out/cmd_out.jpg</code>图像。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="1303" class="mx my it bd li mz na nb nc nd ne nf ng ki nh kj ni kl nj km nk ko nl kp nm nn bi translated">建立码头形象</h1><p id="c618" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated">到目前为止，我们已经创建了一个Go项目来生成二进制可执行文件。这个可执行文件通过命令行参数接收源图像的路径，并在通过命令提供的目标路径上生成输出图像。现在我们想使用Docker将这个应用程序容器化。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/a77e6a2c21138696573052493b6a6ad1" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><blockquote class="mj mk ml"><p id="a0a1" class="lj lk mm ll b lm ln kd lo lp lq kg lr mn lt lu lv mo lx ly lz mp mb mc md me im bi translated"><em class="it">💡我们已经在上一课 中讨论了Dockerfile的结构，所以我不想再解释了。</em></p></blockquote><p id="62dc" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们使用<code class="fe mf mg mh mi b"><a class="ae lh" href="https://hub.docker.com/_/golang/" rel="noopener ugc nofollow" target="_blank">golang:1.15.6-alpine3.12</a></code>作为我们将要构建的Docker映像的父映像。然后，我们将<code class="fe mf mg mh mi b">/app</code>设置为映像中的工作目录。然后，我们将<code class="fe mf mg mh mi b">go.mod</code>和<code class="fe mf mg mh mi b">go.sum</code>文件从构建上下文复制到<code class="fe mf mg mh mi b">/app</code>目录，并通过运行<code class="fe mf mg mh mi b">go mod download</code>命令安装Go依赖项。</p><p id="24cb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦安装了依赖项，我们就将源代码从构建上下文复制到映像的<code class="fe mf mg mh mi b">/app</code>目录中。最重要的部分，<code class="fe mf mg mh mi b">go build -o ./bin/avatar .</code>命令在映像的<code class="fe mf mg mh mi b">/app/bin</code>目录下创建<code class="fe mf mg mh mi b">avatar</code>可执行文件。</p><p id="2a91" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">到目前为止，我们已经执行了基本的Dockerfile指令。现在，让我们看看<code class="fe mf mg mh mi b">VOLUME</code>和<code class="fe mf mg mh mi b">ENTRYPOINT</code>指令是做什么的。</p><h2 id="aefd" class="nz my it bd li oi oj dn nc ok ol dp ng ls om on ni lw oo op nk ma oq or nm iz bi translated">使容器可执行</h2><p id="a133" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated">当我们使用<code class="fe mf mg mh mi b">docker run &lt;image&gt;</code>命令运行容器时，<code class="fe mf mg mh mi b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank">ENTRYPOINT</a></code>指令为容器设置默认命令。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="7e4a" class="nz my it mi b gy oa ob l oc od">ENTRYPOINT ["executable", "param1", "param2"]<br/>ENTRYPOINT command param1 param2</span></pre><p id="42b0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">前一条<code class="fe mf mg mh mi b">ENTRYPOINT</code>指令以<strong class="ll jd"> exec形式</strong>设置命令，后一条<strong class="ll jd"> shell形式</strong>使用<code class="fe mf mg mh mi b">/bin/sh -c</code>执行命令。使用shell形式有一些缺点，如这里讨论的<a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd"/></a>，因此exec形式是首选。只有docker文件中的最后一条<code class="fe mf mg mh mi b">ENTRYPOINT</code>指令将用于设置容器的默认命令。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="5f46" class="nz my it mi b gy oa ob l oc od">CMD [ "param3", "param4" ]</span></pre><p id="7aec" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果<code class="fe mf mg mh mi b">ENTRYPOINT</code>出现在docker文件中，则<code class="fe mf mg mh mi b"><a class="ae lh" href="https://docs.docker.com/engine/reference/builder/#cmd" rel="noopener ugc nofollow" target="_blank">CMD</a></code>指令将作为由<code class="fe mf mg mh mi b">ENTRYPOINT</code>表示的命令的默认参数。因此，上面设置中的最后一个<code class="fe mf mg mh mi b">ENTRYPOINT</code>命令是<code class="fe mf mg mh mi b">$ executable param1 param2 param3 param4</code>。但是，我们可以通过在<code class="fe mf mg mh mi b">docker run &lt;image&gt; param33 param44</code>命令中提供参数来覆盖这些参数。</p><blockquote class="mj mk ml"><p id="cb64" class="lj lk mm ll b lm ln kd lo lp lq kg lr mn lt lu lv mo lx ly lz mp mb mc md me im bi translated"><em class="it">💡</em>我们可以用<code class="fe mf mg mh mi b">docker run</code>命令使用<code class="fe mf mg mh mi b">--entrypoint</code>标志覆盖Dockerfile中设置的默认<code class="fe mf mg mh mi b">ENTRYPOINT</code>值，但它将只接受<code class="fe mf mg mh mi b">executable</code>值。</p></blockquote><p id="50c2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">通过使用<code class="fe mf mg mh mi b">ENRTYPOINT</code>指令，我们让我们的容器<strong class="ll jd">充当一个可执行的</strong>，一旦它使用<code class="fe mf mg mh mi b">docker run</code>命令产生了一个由<code class="fe mf mg mh mi b">ENRTYPOINT</code>表示的命令，它就运行这个命令。我们可以将可选参数传递给替换<code class="fe mf mg mh mi b">CMD</code>值的<code class="fe mf mg mh mi b">docker run &lt;image&gt; [params]</code>命令。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="a8c8" class="nz my it mi b gy oa ob l oc od"><em class="mm"># Dockerfile<br/>...</em></span><span id="ee31" class="nz my it mi b gy oh ob l oc od"><em class="mm"># set entrypoint<br/></em>ENTRYPOINT [ "./bin/avatar" ]</span><span id="9fcd" class="nz my it mi b gy oh ob l oc od"># <em class="mm">set</em> default arguments<br/>CMD [ "./test.jpg", "./shared/test_out.jpg" ]</span></pre><p id="cfac" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我们的docker文件中，<code class="fe mf mg mh mi b">ENTRYPOINT</code>指令在exec格式中有<code class="fe mf mg mh mi b">["./bin/avatar"]</code>值。这意味着当我们使用<code class="fe mf mg mh mi b">docker run</code>命令从这个映像创建一个容器时，它将使用一些参数执行容器中相对于<code class="fe mf mg mh mi b">/app</code>目录的<code class="fe mf mg mh mi b">./bin/avatar</code>可执行文件。</p><p id="35df" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">由于Dockerfile中的<code class="fe mf mg mh mi b">CMD</code>指令具有<code class="fe mf mg mh mi b">[ "./test.jpg", "./shared/test_out.jpg" ]</code>值，如果没有为<code class="fe mf mg mh mi b">docker run</code>命令提供参数，则默认命令将是<code class="fe mf mg mh mi b">./bin/avatar ./test.jpg ./shared/test_out.jpg</code>。该命令将处理<code class="fe mf mg mh mi b">./test.jpg</code>图像，并在相对于<code class="fe mf mg mh mi b">/app</code>目录的容器中的<code class="fe mf mg mh mi b">./shared/test_out.jpg</code>处生成输出。</p><h2 id="cde5" class="nz my it bd li oi oj dn nc ok ol dp ng ls om on ni lw oo op nk ma oq or nm iz bi translated">管理卷</h2><p id="19fa" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated">正如我们在前面的<a class="ae lh" href="https://medium.com/sysf/creating-your-first-docker-application-b0ce40ac67d1" rel="noopener">课程</a>中所讨论的，Docker容器是一个独立的进程，有自己的文件系统。每个容器都有自己的可写层，在这里提交对文件系统所做的更改(容器中的<em class="mm">)。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/4f741f24c3552071f7c1aea500c81cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/0*ZiXU31LYOQGOf1bM.jpg"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(解释见“<a class="ae lh" href="https://medium.com/sysf/getting-started-with-docker-1-b4dc83e64389" rel="noopener"> <strong class="bd li">解剖码头工人</strong> </a>”一课)</figcaption></figure><p id="54fd" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个可写层(<em class="mm">读/写层</em>)不能从主机文件系统访问。一旦容器从Docker引擎中移除，这一层就被破坏了。为了访问这一层，以便主机可以访问容器中的文件更改，我们使用了<strong class="ll jd">卷</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/699d8e7503726cb5dfbaf9193c89ef91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*JfESbDOBy8d5P731dG8IEw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker卷</figcaption></figure><p id="ab69" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">docker卷包含诸如卷名及其在主机上的装载位置等信息。要创建docker卷，我们使用<code class="fe mf mg mh mi b">$ docker volume <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/volume_create/" rel="noopener ugc nofollow" target="_blank">create</a> [name]</code>命令。如果您省略了<code class="fe mf mg mh mi b">name</code>，一个唯一的<code class="fe mf mg mh mi b">SHA256</code>散列将用于卷名。</p><blockquote class="mj mk ml"><p id="ff6d" class="lj lk mm ll b lm ln kd lo lp lq kg lr mn lt lu lv mo lx ly lz mp mb mc md me im bi translated"><em class="it">💡</em>你可以用<code class="fe mf mg mh mi b">--driver</code>或<code class="fe mf mg mh mi b">-d</code>标志来配合<code class="fe mf mg mh mi b">$ docker volume create</code>命令来指定一个卷驱动。默认情况下，它的值是<code class="fe mf mg mh mi b">local</code>，正如您在上面的日志中看到的由<code class="fe mf mg mh mi b">Driver</code>字段指定的。卷驱动程序将允许您自定义文件在卷中的存储方式，例如它可以启用文件加密或允许存储在远程服务器(如AWS S3)上。您可以通过卷插件安装卷驱动程序。<a class="ae lh" href="https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这里的</strong> </a>是一些卷插件。</p></blockquote><p id="5310" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">要列出卷，您可以使用<code class="fe mf mg mh mi b">$ docker volume <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/volume_ls/" rel="noopener ugc nofollow" target="_blank">ls</a></code>命令。您可以使用<code class="fe mf mg mh mi b">$ docker volume <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/volume_inspect/" rel="noopener ugc nofollow" target="_blank">inspect</a> &lt;name&gt;</code>命令检查该卷，并且您将能够通过<code class="fe mf mg mh mi b">Mountpoint</code>属性看到主机上装载该卷的目录。要删除一个卷，我们使用<code class="fe mf mg mh mi b">$ docker volume <a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/volume_rm/" rel="noopener ugc nofollow" target="_blank">rm</a> &lt;name&gt;</code>命令。</p><p id="9faa" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们使用<code class="fe mf mg mh mi b">docker run &lt;image&gt;</code>命令从映像创建容器时，Dockerfile中的<code class="fe mf mg mh mi b">VOLUME</code>指令会自动创建一个卷。由<code class="fe mf mg mh mi b">VOLUME</code>指令创建的卷的<code class="fe mf mg mh mi b">Mountpoint</code>将被<strong class="ll jd">与指定的目录共享</strong>，比如我们这里的<code class="fe mf mg mh mi b">/app/shared</code>。</p><p id="030a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">即使在Docker容器退出或移除后，附加到它的卷仍将继续存在。这样，对容器中目录内容所做的任何更改都将保留在主机文件系统上。稍后，这个目录或卷可以用作另一个容器的挂载点，以进行额外的处理。</p><p id="2e79" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">虽然Docker的卷看起来很简单，但它有更多的内容。除了名为 ( <em class="mm">带有自定义名称</em>)和<strong class="ll jd">匿名卷</strong> ( <em class="mm">带有SHA256散列名称</em>)的<strong class="ll jd">之外，还有<strong class="ll jd">主机卷</strong>，您可以在其中将主机文件系统的自定义目录挂载到容器，而不是让Docker选择一个目录路径，在我们的例子中，该路径似乎在<code class="fe mf mg mh mi b">/var/lib/docker/volumes</code>内。</strong></p><blockquote class="mj mk ml"><p id="bf97" class="lj lk mm ll b lm ln kd lo lp lq kg lr mn lt lu lv mo lx ly lz mp mb mc md me im bi translated"><em class="it">💡</em>命名卷和匿名卷由Docker管理，这就是为什么它们被称为<strong class="ll jd"> Docker管理的卷</strong>，而管理主机卷的责任由我们承担。删除Docker管理的卷时，其在主机上的目录也会被删除。但是，主机卷不会显示在<code class="fe mf mg mh mi b">$ docker volume ls</code>命令中，必须手动移除。</p></blockquote><h2 id="a8db" class="nz my it bd li oi oj dn nc ok ol dp ng ls om on ni lw oo op nk ma oq or nm iz bi translated">建筑形象与容器</h2><p id="4f5e" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated">让我们使用名为<code class="fe mf mg mh mi b">avatar</code>的Docker文件创建一个Docker图像。为此，我们将使用以下命令。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/fe1831b949b29e8c3bb12b989bb7a29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-qbySpLIB3mB665atyy5A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker构建</figcaption></figure><p id="56e0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mf mg mh mi b">$ docker build</code>命令为我们创建了一个名为<code class="fe mf mg mh mi b">avatar:latest</code>的图像，显然，它的大小是<code class="fe mf mg mh mi b">363MB</code>。现在，让我们从它创建一个容器。记住，当我们创建一个容器时，默认命令将由<code class="fe mf mg mh mi b">ENTRYPOINT</code>指令指定。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/e147f33dc09d14e8ac66b2efbde82b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAzygFQ-Y9D-LiD98AkRWg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="395f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">由于我们没有向<code class="fe mf mg mh mi b">$ docker run</code>命令提供任何参数，它将使用<code class="fe mf mg mh mi b">CMD</code>指令的默认参数，该指令与<code class="fe mf mg mh mi b">ENTRYPOINT</code>指令一起使用工作区目录中的<code class="fe mf mg mh mi b">./test.jpg</code>文件作为源图像，并在容器的<code class="fe mf mg mh mi b">/app/shared</code>目录中生成输出图像(<em class="mm">与</em> <code class="fe mf mg mh mi b"><em class="mm">./shared</em></code> <em class="mm">路径相同，相对于工作区</em>)。一旦这个过程完成，容器就退出，不再运行。</p><p id="458d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">容器内生成的<code class="fe mf mg mh mi b">./shared/test_out.jpg</code>文件仍然在容器的读/写层内。由于Dockerfile有一个<code class="fe mf mg mh mi b">VOLUME</code>指令，它创建一个卷，将容器的<code class="fe mf mg mh mi b">./shared</code>目录挂载到主机的Docker管理的目录，我们应该能够在<code class="fe mf mg mh mi b">$ docker volume ls</code>命令的结果中看到这个卷的条目。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/bab3212a37bb730cc2ff15d0a6cca488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6XnnTqCCn3FvTI0Hm6qwA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$码头工人检查</figcaption></figure><p id="824b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如我们所见，Docker创建了一个匿名卷，并显示了它在主机上的装载位置。我们还可以使用<code class="fe mf mg mh mi b">$ docker inspect &lt;container&gt;</code>命令查看与容器相连的卷。在上面的例子中，我们只是美化了属性<code class="fe mf mg mh mi b">Mounts</code>，它显示容器正在使用id为<code class="fe mf mg mh mi b">3d49019ebe...c3</code>的值，它在容器中的<code class="fe mf mg mh mi b">Destination</code>是<code class="fe mf mg mh mi b">/app/shared</code>。所以我们应该能够看到<code class="fe mf mg mh mi b">/var/lib/docker/volumes/3d49019ebe...c3/_data</code>目录中容器的<code class="fe mf mg mh mi b">/app/shared</code>内容。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/fdfb11fbc4f94726a086064d4e306feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*LjpV2FhXxBqpNn6MfVIVpQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ CD/var/lib/docker/volumes/3d…C3/_ data</figcaption></figure><p id="557b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">哎呀，它说没有这个文件或目录。发生了什么事？实际上，我使用的是Macbook Pro机器，而<strong class="ll jd"> macOS不是Docker引擎的本机主机</strong>，这就是为什么Docker引擎通过<strong class="ll jd"> Linux虚拟机</strong> ( <em class="mm"> VM </em>)运行。Docker卷中指定的路径是虚拟机文件系统上的路径。</p><p id="d930" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">没有简单的方法来访问这个虚拟机的终端，但是你可以遵循这些 方法中的<a class="ae lh" href="https://gist.github.com/BretFisher/5e1a0c7bcca4c735e716abf62afad389" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">方法。我使用第二种方法，因为新版本的Docker可能不支持第一种方法。</strong></a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/73a06f2eb420e7688707635c470896e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihA1eZT02jHzXrX799osag.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Docker虚拟机</figcaption></figure><blockquote class="mj mk ml"><p id="eb58" class="lj lk mm ll b lm ln kd lo lp lq kg lr mn lt lu lv mo lx ly lz mp mb mc md me im bi translated"><em class="it">💡</em>我建议在您的<code class="fe mf mg mh mi b">.bash_profile</code>中为上面的<code class="fe mf mg mh mi b">$ docker run</code>命令添加一个<strong class="ll jd">别名</strong>，以便快速访问Docker VM。例如，在您的<code class="fe mf mg mh mi b">.bash_profile</code>中有了<code class="fe mf mg mh mi b">alias docker_vm="docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh"</code>，您只需用<code class="fe mf mg mh mi b">$ docker_vm</code>命令就可以进入Docker VM。</p></blockquote><p id="2d7d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦我们获得了对虚拟机的访问权并检查了卷目录<code class="fe mf mg mh mi b">/var/lib/docker/volumes/3d…c3/_data</code>的内容，我们就可以看到<code class="fe mf mg mh mi b">test_out.jpg</code>。现在从Docker VM下载这些文件到macOS主机非常棘手，所以我们将寻找一个替代的解决方案。</p><p id="7b42" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">除了用Dockerfile中的<code class="fe mf mg mh mi b">VOLUME</code>指令指定一个卷之外，我们还可以使用<code class="fe mf mg mh mi b">-v</code>(<em class="mm"/><code class="fe mf mg mh mi b"><em class="mm">--volume</em></code>的简称)或带有<code class="fe mf mg mh mi b">$ docker run</code>命令的<code class="fe mf mg mh mi b">--mount</code>标志动态创建和挂载一个卷。<code class="fe mf mg mh mi b">--mount</code>标志比<code class="fe mf mg mh mi b">-v</code>更加强大和冗长，但是为了简单起见，我们将使用<code class="fe mf mg mh mi b">-v</code>，你可以从<a class="ae lh" href="https://docs.docker.com/storage/volumes/#choose-the--v-or---mount-flag" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd"/></a>文档中阅读更多关于<code class="fe mf mg mh mi b">--mount</code>的信息。</p><pre class="ks kt ku kv gt nv mi nw nx aw ny bi"><span id="d0ff" class="nz my it mi b gy oa ob l oc od">$ docker run -v <strong class="mi jd">&lt;vol&gt;:&lt;dest&gt;:&lt;options&gt;</strong> &lt;image&gt;</span></pre><p id="869c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这里的<code class="fe mf mg mh mi b">&lt;vol&gt;</code>值指定要使用的音量(<em class="mm">名称</em>)。如果这个卷不存在，Docker将用给定的名称为我们创建它。如果省略这个值(<em class="mm">包括</em> <code class="fe mf mg mh mi b"><em class="mm">:</em></code>)，Docker将创建一个匿名卷，与<code class="fe mf mg mh mi b">&lt;dest&gt;</code>共享。我们还可以通过在主机的文件系统上指定目录路径来装载主机卷。</p><p id="bf7d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mf mg mh mi b">&lt;dest&gt;</code>值指定了容器文件系统目录的绝对路径，该卷将安装在该目录中。如果这个<code class="fe mf mg mh mi b">&lt;dest&gt;</code>目录不存在，将在容器中创建。</p><p id="cd08" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mf mg mh mi b">&lt;options&gt;</code>值是配置卷的选项的逗号分隔列表，例如<code class="fe mf mg mh mi b">ro</code>使卷<strong class="ll jd">对容器而言是只读的</strong>，这意味着容器将能够从该卷访问文件，但不能向其写入。</p><blockquote class="mj mk ml"><p id="241a" class="lj lk mm ll b lm ln kd lo lp lq kg lr mn lt lu lv mo lx ly lz mp mb mc md me im bi translated"><em class="it">💡</em>如果您想要挂载多个卷，您可以使用多个<code class="fe mf mg mh mi b">-v</code>标志。您还可以使用带有<code class="fe mf mg mh mi b">$ docker run</code>命令的<code class="fe mf mg mh mi b">--volumes-from</code>标志从另一个容器挂载卷。当容器被用作卷时，它被称为卷容器。从<a class="ae lh" href="https://docs.docker.com/engine/reference/commandline/run/#mount-volumes-from-container---volumes-from" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这里</strong> </a>了解更多。</p></blockquote><p id="6eb5" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这次让我们使用一个主机卷来运行一个容器。让我们使用<code class="fe mf mg mh mi b">$ docker container prune</code>和<code class="fe mf mg mh mi b">$ docker volume prune</code>命令擦除现有的容器和卷，重新开始。让我们创建另一个容器</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/4f77f853b3dc8317efd278c605414cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*DT0z71IBVtAyPyqyTArqeQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/d7d0973f10a8bab4bc34755428f24275.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*PHgAyltf87VIJ7ZKSOtVuA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">~/avatar-files/test_out.jpg</figcaption></figure><p id="a529" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，我们从<code class="fe mf mg mh mi b">avatar:latest</code>映像创建了一个新的容器，但是这一次，我们使用了<code class="fe mf mg mh mi b">~/avatar-files</code>目录作为卷。由于这是一个<strong class="ll jd">主机卷</strong>，它不由Docker管理，因此不会显示在<code class="fe mf mg mh mi b">$ docker volume ls</code>结果中。</p><blockquote class="mj mk ml"><p id="be6a" class="lj lk mm ll b lm ln kd lo lp lq kg lr mn lt lu lv mo lx ly lz mp mb mc md me im bi translated"><em class="it">💡</em>一个<strong class="ll jd">主机卷</strong>也称为<strong class="ll jd">绑定装载</strong>。因此，每当您听到<strong class="ll jd"> bind mount </strong>时，请考虑将主机上的一个目录挂载到Docker容器。如果我们使用的是<code class="fe mf mg mh mi b">--mount</code>标志而不是<code class="fe mf mg mh mi b">-v</code>，那么我们需要在值中提供<code class="fe mf mg mh mi b">type=bind</code>来创建绑定挂载。更多阅读从<a class="ae lh" href="https://docs.docker.com/storage/bind-mounts/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">这里</strong> </a>。</p></blockquote><p id="b274" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果主机卷(<em class="mm">目录</em>)不存在，将由具有适当权限的Docker在主机文件系统上创建(<em class="mm">)。即使在容器被删除后，卷仍然存在，因此如果您删除容器,<code class="fe mf mg mh mi b">~/avatar-files</code>目录将仍然存在。</em></p><p id="f060" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，我们使用默认参数用于<code class="fe mf mg mh mi b">ENTRYPOINT</code>指令，因为我们没有在<code class="fe mf mg mh mi b">$ docker run</code>命令中提供任何参数。因此，除了来自容器工作区目录的<code class="fe mf mg mh mi b">test.jpg</code>之外，我们不处理任何新图像。</p><p id="3f95" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这一次，让我们将<code class="fe mf mg mh mi b"><a class="ae lh" href="https://unsplash.com/photos/nahUo1GhcrA" rel="noopener ugc nofollow" target="_blank">src.jpg</a></code>图像保存在<code class="fe mf mg mh mi b">~/avatar-files</code>目录中，并要求Docker容器使用该图像作为源图像在同一目录中生成<code class="fe mf mg mh mi b">out.jpg</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/5e090df9c55f1e4ebf74bf75568c634a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H9cUqfdoSQB6vevkBXrojA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/b173d5b5b953263ef85b28c1304eca3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*r9XsdiDUkr_1SVMPYjgK7A.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">~/docker-files/out.jpg</figcaption></figure><p id="3e51" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的例子中，我们从<code class="fe mf mg mh mi b">avatar:latest</code>图像创建了一个新的Docker容器。这一次，<code class="fe mf mg mh mi b">--rm</code>标志将在容器一退出就移除它，这就是为什么<code class="fe mf mg mh mi b">$ docker ps -a</code>结果是空的。此外，我们将把<code class="fe mf mg mh mi b">~/avatar-files</code>目录挂载到容器的<code class="fe mf mg mh mi b">/app/shared</code>目录中，这样容器的<code class="fe mf mg mh mi b">src.jpg</code>就会在<code class="fe mf mg mh mi b">/app/shared</code>中。</p><p id="4a71" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这一次，我们通过<code class="fe mf mg mh mi b">$ docker run</code>命令本身为<code class="fe mf mg mh mi b">ENTRYPOINT</code>命令指定自定义参数来覆盖<code class="fe mf mg mh mi b">CMD</code>指令参数。使用上面的命令，我们要求容器的<code class="fe mf mg mh mi b">./bin/avatar</code>将<code class="fe mf mg mh mi b">/app/shared/src.jpg</code>作为源路径，并输出<code class="fe mf mg mh mi b">/app/shared/out.jpg</code>文件，该文件将反映在主机文件系统的<code class="fe mf mg mh mi b">~/docker-file</code>目录中。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="386b" class="mx my it bd li mz na nb nc nd ne nf ng ki nh kj ni kl nj km nk ko nl kp nm nn bi translated">多阶段构建策略</h1><p id="2f74" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated">让我们回顾一下到目前为止我们在文档中所做的事情。首先，<code class="fe mf mg mh mi b">FROM</code>指示下载并设置预装Go的父映像。然后，我们从我们的项目目录中复制一些文件(<em class="mm">构建上下文</em>)到镜像中，并安装依赖项。然后我们将项目源代码复制到映像中，并在映像中的<code class="fe mf mg mh mi b">./bin/avatar</code>处创建一个二进制可执行文件。</p><p id="6e67" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们创建一个容器时，默认的<code class="fe mf mg mh mi b">ENTRYPOINT</code>命令执行这个二进制可执行文件，并从位于容器中的源映像生成一个输出映像，该映像可以与主机的文件系统共享。</p><p id="5c0e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在考虑容器中必须包含的文件，以便能够产生预期的效果。如果使用默认的<code class="fe mf mg mh mi b">CMD</code>参数，我们只需要<code class="fe mf mg mh mi b">./bin/avatar</code>来处理源图像，<code class="fe mf mg mh mi b">./test.jpg</code>用于默认的<code class="fe mf mg mh mi b">CMD</code>参数，以及<code class="fe mf mg mh mi b">./shared</code>目录来保存输出图像。我们不需要其他东西。</p><p id="1549" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是我们为什么要这么做。如果你记得的话，我们的Docker图像尺寸是<code class="fe mf mg mh mi b">363MB</code>这是巨大的。不太好下载维护。如果我们能扔掉所有不需要的东西，创造一个更小尺寸的图像，这对每个人来说都是一个双赢的局面。</p><p id="af1f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，从技术上讲，我们可以在主机上构建<code class="fe mf mg mh mi b">./bin/avatar</code>二进制文件，只将它和其他必要的文件推送到映像中，但是这样会违背将整个项目容器化的目的。我们希望在Docker映像本身中编译整个应用程序，但仍然保持Docker映像的大小尽可能小。</p><p id="681e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这就是<strong class="ll jd">多阶段构建</strong>的用武之地。我们可以在一个Dockerfile文件中指定多个<code class="fe mf mg mh mi b">FROM</code>指令。每个<code class="fe mf mg mh mi b">FROM</code>指令创建一个新的<strong class="ll jd">构建阶段</strong>，最后一个构建状态产生最终的Docker映像。Docker将每个构建阶段指定为唯一的索引(<em class="mm">从0 </em>开始)，或者我们将使用<code class="fe mf mg mh mi b">FROM &lt;image&gt; AS &lt;stage&gt;</code>语法来命名构建状态。使用带有<code class="fe mf mg mh mi b">CMD</code>指令的<code class="fe mf mg mh mi b">--from=&lt;stage&gt;</code>标志，我们可以将文件从一个构建阶段复制到另一个构建阶段。</p><p id="ee03" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们创建一个名为<code class="fe mf mg mh mi b">Dockerfile.prod</code>的新Dockerfile并创建两个构建状态。第一个构建阶段生成<code class="fe mf mg mh mi b">./bin/avatar</code>二进制文件，第二个构建阶段复制这个二进制文件。第二个构建阶段将生成一个Docker图像，该图像将用于创建一个容器来处理图像。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(来源:<a class="ae lh" href="https://gist.github.com/thatisuday/de83a85930971d5c7125a2e074cf9e58" rel="noopener ugc nofollow" target="_blank"><strong class="ak">gist.github.com</strong></a>)</figcaption></figure><p id="f0a6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">好好看看上面的Dockerfile.prod文件(<em class="mm">我不得不使用</em> <code class="fe mf mg mh mi b"><em class="mm">Dockerfile</em></code> <em class="mm">名称来启用语法高亮显示</em>)。第一个构建阶段使用<code class="fe mf mg mh mi b">golang:1.15.6-alpine3.12</code>映像，因为它包括Go安装。<code class="fe mf mg mh mi b">AS builder</code>部分将构建阶段命名为<code class="fe mf mg mh mi b">builder</code>。</p><p id="e398" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在最终映像中，我们不需要Go安装，因此第二个构建阶段使用<code class="fe mf mg mh mi b">alpine:3.12.2</code>作为父映像。它是一个非常轻量级的Linux发行版(<em class="mm"> ~5MB </em>)。然而，我们需要将一些文件从<code class="fe mf mg mh mi b">builder</code>构建状态复制到最终映像中，因此我们在Dockerfile中使用带有<code class="fe mf mg mh mi b">COPY</code>指令的<code class="fe mf mg mh mi b">--from=builder</code>标志。</p><p id="bcda" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们从<code class="fe mf mg mh mi b">builder</code>阶段复制不超过<code class="fe mf mg mh mi b">/app/bin/avatar</code>个文件到最终图像中。此外，我们已经删除了<code class="fe mf mg mh mi b">VOLUME</code>指令，因为它将不必要地创建一个卷，我们希望用户手动指定一个。我们还删除了<code class="fe mf mg mh mi b">ENTRYPOINT</code>指令(<em class="mm">命令</em>)的默认<code class="fe mf mg mh mi b">CMD</code>参数，因为我们希望用户明确提供这些参数。现在，让我们建立图像。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/6f558269e8ed6bcbb8ce71d8f71cc73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utzUX15ZFFvaO1-rvOkejA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker构建</figcaption></figure><p id="7070" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">从docker文件构建映像时，多阶段构建没有什么特别的。然而，我们需要用<code class="fe mf mg mh mi b">$ docker build</code>命令指定<code class="fe mf mg mh mi b">--file</code>或<code class="fe mf mg mh mi b">-f</code>标志，因为我们的docker文件名不再是<code class="fe mf mg mh mi b">Dockerfile</code>了。新图像名称为<code class="fe mf mg mh mi b">avatar_prod</code>。</p><p id="e517" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们使用<code class="fe mf mg mh mi b">$ docker images</code>命令列出图像时，我们会看到ID为<code class="fe mf mg mh mi b">40a715c9cb22</code>的新图像。好好看看<strong class="ll jd">图像尺寸</strong>挺让人吃惊的。我们的<code class="fe mf mg mh mi b">avatar_prod</code>图像的大小只有<code class="fe mf mg mh mi b"><strong class="ll jd">8.74MB</strong></code>，比<code class="fe mf mg mh mi b">avatar</code>图像少了<code class="fe mf mg mh mi b">350MB</code>多。</p><p id="5d70" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了看看新图像中的文件是什么样子，我们从<code class="fe mf mg mh mi b">avatar_prod</code>图像创建了一个容器，并用<code class="fe mf mg mh mi b">sh</code>命令覆盖了默认的<code class="fe mf mg mh mi b">ENTRYPOINT</code>值，该命令在容器的工作区目录中启动了一个shell进程。使用<code class="fe mf mg mh mi b">ls</code>，我们可以验证<code class="fe mf mg mh mi b">avatar</code>文件已经从<code class="fe mf mg mh mi b">builder</code>阶段复制。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pd"><img src="../Images/11de1a491f56605878992220b38a9bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jt7QBDJAQ88VZ-GhS1Nzw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">$ docker运行</figcaption></figure><p id="1763" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这里，我们从<code class="fe mf mg mh mi b">avatar_prod</code>图像中创建了一个新的容器。如果我们不在<code class="fe mf mg mh mi b">$ docker run command</code>中提供任何参数，它将返回一条错误消息。但是通过正确的参数，我们从<code class="fe mf mg mh mi b">avatar</code>图像中获得了与容器相同的功能(尺寸巨大的<em class="mm"/>)。</p><blockquote class="mj mk ml"><p id="af65" class="lj lk mm ll b lm ln kd lo lp lq kg lr mn lt lu lv mo lx ly lz mp mb mc md me im bi translated"><em class="it">💡</em>您可以在<code class="fe mf mg mh mi b">$ docker build</code>命令中使用<code class="fe mf mg mh mi b">--target</code>标志来指定要在多阶段Dockerfile文件中构建的目标。您也可以用其他方式控制多阶段构建。阅读<a class="ae lh" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd">本</strong> </a>文档了解更多信息。</p></blockquote></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="df72" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可以从下面的GitHub资源库中找到本课中使用的示例的docker文件和源代码。</p><div class="pe pf gp gr pg ph"><a href="https://github.com/course-one/docker-image-processor" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd jd gy z fp pm fr fs pn fu fw jc bi translated">课程-一/码头-图像处理器</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">使用Go处理图像的docker图像示例。GitHub是5000多万开发者的家园，他们共同工作来托管…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">github.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv lb ph"/></div></div></a></div></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/e3da3bf1cee07cd997d46904bbbf70b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4VSpLEAu4Gmg-GweZ3RvA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">(<a class="ae lh" href="http://thatisuday.com" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">thatisuday.com</strong></a>/<a class="ae lh" href="https://github.com/thatisuday" rel="noopener ugc nofollow" target="_blank">/<strong class="bd li">GitHub</strong></a>/<a class="ae lh" href="https://twitter.com/thatisuday" rel="noopener ugc nofollow" target="_blank">/<strong class="bd li">Twitter</strong>/</a><a class="ae lh" href="https://stackoverflow.com/users/2790983/uday-hiwarale" rel="noopener ugc nofollow" target="_blank">/<strong class="bd li">stack overflow</strong></a><strong class="bd li"/>/<a class="ae lh" href="https://www.instagram.com/thatisuday/" rel="noopener ugc nofollow" target="_blank"><strong class="bd li">insta gram</strong></a>)</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi px"><img src="../Images/fdebb498630e863a0129025be5b74fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*Cj3GjJSU7reYw49BYdQfpw.gif"/></div></figure></div></div>    
</body>
</html>