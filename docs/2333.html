<html>
<head>
<title>Promises vs Observables for AngularJS-to-Angular migration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角到角偏移的前景与可观测性</h1>
<blockquote>原文：<a href="https://itnext.io/promises-vs-observables-for-angularjs-to-angular-migration-1161afacef7e?source=collection_archive---------6-----------------------#2019-05-07">https://itnext.io/promises-vs-observables-for-angularjs-to-angular-migration-1161afacef7e?source=collection_archive---------6-----------------------#2019-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="45e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AngularJS(Angular 1)大量使用Promises进行HTTP调用，而Angular 2+将网络调用包装在Observables中。这导致一些开发人员在将项目从AngularJS迁移到Angular 2+时遇到了特定的问题。我想在这里解决这些问题，并通过回顾可观察到的和承诺之间的典型差异来描述为什么它们会出现。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/27740d11d35f9abdc7c81046bae97e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1_Ed0HBa5iO7TFe_tkM8w.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">可观——为网络开发人员提供更多功能。(图片由<a class="ae lc" href="https://pixabay.com/ru/users/mediamodifier-1567646/" rel="noopener ugc nofollow" target="_blank">媒体修改器</a>拍摄)</figcaption></figure><pre class="kn ko kp kq gt ld le lf lg aw lh bi"><span id="b4a6" class="li lj iq le b gy lk ll l lm ln"><strong class="le ir">Pre-requisites:</strong> you should know JS Promises</span></pre><p id="056c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">可观察的事物和承诺——简短介绍</strong></p><p id="73ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看——可观察值只是高级承诺:承诺发出一个值并完成(resolve)，可观察值发出0、一个或多个值并完成(发出和完成是不同的动作)。AngularJS和Angular中的HTTP服务只提供一个值——所以在这种情况下，两个框架的工作方式非常相似。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lo"><img src="../Images/0d1fd7c7336d2f75387895525940a0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DraWzmN4xkcazpq1G7FLMQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://carbon.now.sh/?bg=rgba(171%2C%20184%2C%20195%2C%201)&amp;t=cobalt&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=%252F%252F%2520Observables%2520in%2520Angular%25202%252B%250Aconst%2520sourse%2524%2520%253D%2520this.httpServie.get(%27https%253A%252F%252Fsome_url.com%27)%250Asource%2524.subscribe(%250A%2509(data)%2520%253D%253E%2520handelData(data)%252C%2520%252F%252F%2520success%2520handler%250A%2520%2520%2509(err)%2520%253D%253E%2520handleError(err)%252C%2520%2520%252F%252F%2520error%2520handler%250A%2520%2520%2520%2520()%2520%253D%253E%2520completeHandler()%2520%252F%252F%2520onComplete%2520handler%250A)%250A%250A%252F%252F%2520Promises%2520in%2520AngularJS%250Aconst%2520soursePromise%2520%253D%2520http%2524.get(%27https%253A%252F%252Fsome_url.com%27)%250AsoursePromise.then(%250A%2509(data)%2520%253D%253E%2520handelResolve(data)%252C%2520%252F%252F%2520resolve%2520handler%250A%2520%2520%2509(err)%2520%253D%253E%2520handleReject(err)%2520%252F%252F%2520reject%2520handler%250A)%250A" rel="noopener ugc nofollow" target="_blank">片段链接</a></figcaption></figure><p id="5b0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且有人可能认为只要把<strong class="jp ir"> <em class="kl"> $http </em> </strong>改名为<strong class="jp ir"><em class="kl">this . httpservice</em></strong>，<strong class="jp ir"> <em class="kl">然后</em> </strong>改名为<strong class="jp ir"> <em class="kl"> subscribe </em> </strong>大家都会高兴。在非常简单的应用程序中，它甚至可以工作——但是如果你的应用程序做的不仅仅是“Hello world”——请注意这些差异。</p><h2 id="74a5" class="li lj iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">#1渴望与懒惰</h2><p id="89fa" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">看看下面的例子:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ml"><img src="../Images/6c82f1ccd5e2312a7f11339db98c55ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGNZRpJSmNjy6jcPkZ76sA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://carbon.now.sh/?bg=rgba(171%2C%20184%2C%20195%2C%201)&amp;t=cobalt&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=%252F%252FPromise-wrapped%2520http%2520request%250AsaveChanges(data)%2520%257B%250A%2520%2520return%2520%2524http.post(%27https%253A%252F%252Fsome_url.com%27%252C%2520data)%250A%257D%250A%250A%250A%252F%252FObservable-wrapped%2520http%2520request%250AsaveChanges(data)%2520%257B%250A%2520%2520return%2520this.httpService.post(%27https%253A%252F%252Fsome_url.com%27%252C%2520data)%2520%252F%252F%2520doesn%27t%2520do%2520request!%250A%257D%250A" rel="noopener ugc nofollow" target="_blank">片段链接</a></figcaption></figure><p id="b338" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我调用<strong class="jp ir"> saveChanges </strong>方法时——第一个带有承诺包装请求的例子将按预期工作。但是在秒可观察包装的例子中，什么都不会发生，因为可观察是<strong class="jp ir">懒惰评估的</strong>，而承诺是<strong class="jp ir">急切评估的。</strong></p><p id="785b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着Promises不关心他们是否有一些订阅者来获得他们的结果。但是，可观察的事物(准确地说，是冷可观察的事物)只有在我们认同它们的情况下才会变冷。在上述情况下，您应该订阅由<strong class="jp ir"> saveChanges </strong>函数返回的Observable。</p><pre class="kn ko kp kq gt ld le lf lg aw lh bi"><span id="1693" class="li lj iq le b gy lk ll l lm ln">saveChanges(data).subscribe()</span></pre><p id="319f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了保持对它的关注——使用Nicholas Jamieson 的<a class="ae lc" href="https://github.com/cartant/rxjs-tslint-rules/blob/master/source/rules/rxjsNoIgnoredObservableRule.ts" rel="noopener ugc nofollow" target="_blank"> rxjs-tslint-rules </a>中的<em class="kl">rxjs-no-ignored-observable</em>规则。</p><h2 id="079d" class="li lj iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated"><strong class="ak"> #2承诺不可取消，可观测量可退订</strong></h2><p id="2840" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">同样，从输入文本改变时我们在后端搜索的例子开始:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lo"><img src="../Images/4f549fe65600812a61d375de5be2a500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JDWlgPtRhDS3aXXBSTVnA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://carbon.now.sh/?bg=rgba(171%2C%20184%2C%20195%2C%201)&amp;t=cobalt&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=%252F%252F%2520html%250A%253Cinput%2520ngKeyup%253D%2522onKeyUp(%2524event)%2522%253E%250A%2520%2520%250A%252F%252FPromise-wrapped%2520http%2520request%250AsaveChanges(event)%2520%257B%250A%2520%2520const%2520text%2520%253D%2520event.target.value%253B%250A%2520%2520%2524http.get(%27https%253A%252F%252Fsome_url.com%253Fsearch%253D%27%2520%252B%2520text)%250A%2520%2520%2520%2520.then((searchResult)%2520%253D%253E%2520showSearchResult(searchResult))%250A%257D" rel="noopener ugc nofollow" target="_blank">片段链接</a></figcaption></figure><p id="f449" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的缺点是什么——如果用户继续输入，您不能拒绝前一个请求的结果(去抖动会使这个问题稍微减轻，但不会消除它)。还有一个问题——竞争条件是可能的(当后面的请求结果比前面的更快返回时——所以我们得到不正确的响应显示)。</p><p id="6ab6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用<a class="ae lc" href="https://rxjs-dev.firebaseapp.com/api/operators/switchMap" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> switchMap </strong> </a>操作符可以相当优雅地避免这种顾虑:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mo"><img src="../Images/dad120011131dc38c59ea339c9d402d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7g0eXrV8S49SedwSTLME3Q.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://carbon.now.sh/?bg=rgba(171%2C%20184%2C%20195%2C%201)&amp;t=cobalt&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=%252F%252F%2520html%2520template%250A%253Cinput%2520id%253D%2522search%2522%253E%250A%2520%2520%250A%252F%252FPromise-wrapped%2520http%2520request%250A%250AinputElem%2520%253D%2520document.querySelector(%27%2523search%27)%253B%250Asearch%2524%2520%253D%2520fromEvent(inputElem%252C%2520%27keyup%27)%253B%250A%250AngOnInit()%2520%257B%250A%2520%2520%250A%2520%2520search%2524.pipe(%2520%252F%252F%2520each%2520time%2520new%2520text%2520value%2520is%2520emitted%250A%2520%2520%2509switchMap((event)%2520%253D%253E%2520%257B%2520%252F%252F%2520switchMap%2520cancel%2520previous%2520request%2520and%2520send%2520a%2520new%2520one%250A%2520%2520%2520%2520%2520%2520const%2520text%2520%253D%2520event.target.value%253B%250A%2520%2520%2520%2520%2520%2520return%2520this.httpService.get(%27https%253A%252F%252Fsome_url.com%253Fsearch%253D%27%2520%252B%2520text)%253B%250A%2520%2520%2520%2520%257D)%250A%2520%2520)%250A%2520%2520%2520%2520.subscribe((newData)%2520%253D%253E%2520this.applyNewData(newData))%2520%2520%252F%252F%2520use%2520new%2520data%250A%257D%250A" rel="noopener ugc nofollow" target="_blank">片段链接</a></figcaption></figure><p id="6780" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们将输入文本转换成可观察到的排放值。每次发送新的文本值时，switchMap operator将取消之前的网络请求(如果尚未完成)并发送新的请求。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="b24c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">Packtpub.com和我准备了一整套</em> <a class="ae lc" href="https://www.udemy.com/hands-on-rxjs-for-web-development/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="kl"> RxJS课程</em> </strong> </a> <em class="kl">还有许多其他细节，告诉你如何用这个神奇的库解决你的日常开发任务。它对初学者来说可能很有趣，但也包含高级主题。</em> <a class="ae lc" href="https://www.udemy.com/hands-on-rxjs-for-web-development/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="kl">看一看！</em> </strong> </a></p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h2 id="cce6" class="li lj iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">#3没有内置的承诺重试或重复逻辑。<a class="ae lc" href="https://rxjs-dev.firebaseapp.com/api/operators/repeat" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">重复</strong> </a> <strong class="ak"> ' </strong>和'<a class="ae lc" href="https://rxjs-dev.firebaseapp.com/api/operators/retry" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">重试</strong> </a> <strong class="ak"> ' </strong>操作符为可观测量。</h2><p id="c52d" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">您可以用承诺实现重试逻辑，但这看起来有点麻烦:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lo"><img src="../Images/52f12b0bb0d75d044ed072f9d1c5a052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJc6wJzeqQqhwT_JQJAVtw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://carbon.now.sh/?bg=rgba(171%2C%20184%2C%20195%2C%201)&amp;t=cobalt&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=%2520%2520%2520%2520%2520%2520var%2520request%2520%253D%2520function()%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520%2524http(%257Bmethod%253A%2520%27GET%27%252C%2520url%253A%2520path%257D)%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520.success(function(response)%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520results.resolve(response)%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257D)%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520.error(function()%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520if%2520(counter%2520%253C%2520MAX_REQUESTS)%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520request()%253B%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520counter%252B%252B%253B%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257D%2520else%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520results.reject(%2522Could%2520not%2520load%2520after%2520multiple%2520tries%2522)%253B%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257D%250A%2520%2520%2520%2520%2520%2520%2520%2520%2520%2520%257D)%253B%250A%2520%2520%2520%2520%2520%2520%257D%253B%250A%250A%2520%2520%2520%2520%2520%2520request()%253B" rel="noopener ugc nofollow" target="_blank">片段链接</a></figcaption></figure><p id="dce7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而相同代码的可观察性会短得多:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lo"><img src="../Images/1b44f7b02b259efdeee4fe78917cd627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H68Vri8AASe8wNvgfhLd9A.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://carbon.now.sh/?bg=rgba(171%2C%20184%2C%20195%2C%201)&amp;t=cobalt&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=this.httpService.get(%27https%253A%252F%252Fsome_url.com%252Fdata%27).pipe(%250A%2509retry(MAX_REQUESTS)%250A)" rel="noopener ugc nofollow" target="_blank">片段链接</a></figcaption></figure><p id="0f19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的文章中阅读更多关于重复和重试操作符的用例。</p><h2 id="0388" class="li lj iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">#4少量承诺组合工具。Observables为此提供了各种各样的操作符。</h2><p id="7746" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">对于承诺，您可以组合结果的所有可能性有:</p><p id="5410" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Promise.all </strong> —等待所有承诺被解析，然后提供结果数组。</p><p id="540a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Promise.race </strong> —等待其中一个承诺得到解决，并返回结果。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="c88f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可观测量为组合提供了非常丰富的弹药:</p><p id="5ab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> combineLatest(observable1，observable2，…) </strong> —等待任何一个可观察对象发出并提供所有可观察对象最后发出的值的数组(结果:[value_obs1，value_obs2，..]).非常好，如果你应该从几个不同的来源更新页面上的新数据。</p><p id="251a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">observable1 . pipe(<em class="kl">with latest from</em>(observable2)</strong>—对observable 1的每个值，还提供observable 2的最后一个发出的值(结果:[value_obs1，value_obs2])。</p><p id="62c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> forkJoin(observable1，observable2，…) </strong> — analog for Promise.all —等待所有可观察值完成，然后发出所有自变量可观察值的最后一个值的数组。</p><p id="c65a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> zip </strong>..]).</p><p id="16f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> race(observable1，observable2，...)— </strong>返回一个可观测值，该可观测值反映了第一个可观测到的发射物品的源。</p><p id="6014" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> merge(observable1，observable2，…)——</strong>订阅每个可观察的参数，并从所有这些参数中重新发出值。</p><p id="61f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">switch all</strong>——如果之前的观察没有完成——取消它并订阅新的。</p><p id="1438" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> concat( </strong> observable1，observable2，...<strong class="jp ir"> ) </strong> —仅在前一个可观察序列完成后开始下一个可观察序列(在每个特定的可观察序列完成后逐一发出值)</p><p id="02f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有更多(<a class="ae lc" href="https://rxjs-dev.firebaseapp.com/api/operators/switchMap" rel="noopener ugc nofollow" target="_blank"> switchMap </a>，mergeMap，<a class="ae lc" href="https://rxjs-dev.firebaseapp.com/api/index/function/partition" rel="noopener ugc nofollow" target="_blank"> partition </a>，<a class="ae lc" href="https://rxjs-dev.firebaseapp.com/api/index/function/iif" rel="noopener ugc nofollow" target="_blank"> iif </a>，<a class="ae lc" href="https://rxjs-dev.firebaseapp.com/api/operators/groupBy" rel="noopener ugc nofollow" target="_blank"> groupBy </a>，<a class="ae lc" href="https://rxjs-dev.firebaseapp.com/api/operators/window" rel="noopener ugc nofollow" target="_blank"> window </a>等)</p><p id="1564" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在此了解有关这些运营商的更多信息:</p><ol class=""><li id="ae79" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><a class="ae lc" href="https://blog.angularindepth.com/learn-to-combine-rxjs-sequences-with-super-intuitive-interactive-diagrams-20fce8e6511" rel="noopener ugc nofollow" target="_blank"> <em class="kl">学会将RxJs序列与超级直观的交互图结合</em> </a></li><li id="29c0" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><a class="ae lc" href="https://rxjs-dev.firebaseapp.com/api" rel="noopener ugc nofollow" target="_blank">官方文件举例</a></li><li id="4a88" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">“网络开发实践RxJS”<a class="ae lc" href="https://www.packtpub.com/web-development/hands-rxjs-web-development-video" rel="noopener ugc nofollow" target="_blank">视频课程</a>。</li></ol><h2 id="3892" class="li lj iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">#5容易防止具有可观察性和难以承诺的竞态条件。</h2><p id="35c2" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">假设我们定期向网络请求更新数据。但是在某些情况下，后面的请求结果会比前面的结果返回得更快，所以我们得到的错误(前面请求的)响应显示为最后一个。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lo"><img src="../Images/e5c6f0409d132293b143d7e7a07a126c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOB9rjviLpdLD2UIuZ478Q.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://carbon.now.sh/?bg=rgba(171%2C%20184%2C%20195%2C%201)&amp;t=cobalt&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=getData()%2520%257B%250A%2520%2520%2524http.get(%27https%253A%252F%252Fsome_url.com%252Fdata%27)%250A%2520%2520%2520%2520.then((searchResult)%2520%253D%253E%2520%257B%250A%2520%2520%2509%2509doSomething(searchResult)%250A%2520%2520%2520%2520%257D%250A%2520%2520%257D)%250A%257D%250A%250AsetTimeout(getData%252C%25205000)%253B" rel="noopener ugc nofollow" target="_blank">片段链接</a></figcaption></figure><p id="133a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此代码可能会受到竞争条件问题的影响。</p><p id="903e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了防止可观察包装的请求出现这种情况，我们可以使用<a class="ae lc" href="https://rxjs-dev.firebaseapp.com/api/operators/concatMap" rel="noopener ugc nofollow" target="_blank"> concatMap </a>操作符。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lo"><img src="../Images/c7e783454084e1d83a334f329aa08ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45aw2cZ1ug79kzFBxsmVow.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://carbon.now.sh/?bg=rgba(171%2C%20184%2C%20195%2C%201)&amp;t=cobalt&amp;wt=none&amp;l=javascript&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=false&amp;pv=56px&amp;ph=56px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;es=2x&amp;wm=false&amp;code=interval(5000).pipe(%250A%2509concatMap(()%2520%253D%253E%2520this.httpService.get(%27https%253A%252F%252Fsome_url.com%252Fdata%27))%250A)%250A.subscribe(doSomethingWithData)" rel="noopener ugc nofollow" target="_blank">片段链接</a></figcaption></figure><p id="2ff0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> concatMap </strong>只有在前一个完成并处理后，才会进行下一个网络调用。当然，如果您不需要以前的结果，那么可以使用switchMap(如本文的第一个示例)。</p><h2 id="c215" class="li lj iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">结论</h2><p id="db33" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">在从AngularJS(使用网络调用的承诺)迁移到Angular 2+(使用可观察的)的过程中，您应该意识到承诺和可观察的可能差异。希望我的文章能帮助你澄清这个话题。现在是时候迁徙了！</p><p id="1f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">喜欢这篇文章？<a class="ae lc" href="https://clicktotweet.com/U46K2" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">发微博</strong> </a>和我一起上<a class="ae lc" href="https://twitter.com/El_Extremal" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">推特</strong> </a>！🤓</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><a href="http://eepurl.com/gHF0av"><div class="gh gi nk"><img src="../Images/e39daa364c50029b206bdc057d2b3487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*33AyiLH06Tzu-9KxL1hZjg.png"/></div></a></figure></div></div>    
</body>
</html>