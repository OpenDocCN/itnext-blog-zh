<html>
<head>
<title>Flutter — Layout system overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振——布局系统概述</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-layout-system-overview-c70bbe9ba909?source=collection_archive---------1-----------------------#2020-08-22">https://itnext.io/flutter-layout-system-overview-c70bbe9ba909?source=collection_archive---------1-----------------------#2020-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bfde4aecc5f60da273000a09d7a97d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVLppo8C5pN1aZRPtveEzw.png"/></div></div></figure><p id="96ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近，我决定专注于颤振的基本原理。这次我试图更好地理解“布局系统是如何工作的”，回答如下问题:</p><ul class=""><li id="314f" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">我的小工具的大小看起来不正确，这是怎么回事？</li><li id="161c" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">我只想把我的小部件放在一个特定的位置，但是没有任何属性来控制它，为什么？</li><li id="b0a9" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">我不断看到像<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html" rel="noopener ugc nofollow" target="_blank">BoxConstraints</a></code>、<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/RenderBox-class.html" rel="noopener ugc nofollow" target="_blank">RenderBox</a></code>和<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/dart-ui/Size-class.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">Size</em></a></code>这样的术语。这一切是如何联系在一起的？</li><li id="9056" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">有可能对布局系统如何工作有一个大致的概念？</li></ul><p id="21f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文无意对以上所有内容进行深入详细的描述。但是我们会对最重要的事情有一个很好的概述，试着想象任何可能的事情。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h2 id="2a8f" class="ma mb it bd mc md me dn mf mg mh dp mi km mj mk ml kq mm mn mo ku mp mq mr ms bi translated">“两阶段”布局系统和约束</h2><p id="b6c2" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">首先，小部件是Flutter SDK的构建模块，但它们不负责将自己绘制到屏幕上。每个小部件都与一个负责该功能的<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/RenderBox-class.html" rel="noopener ugc nofollow" target="_blank">RenderBox</a></code>对象相关联。这些框是2D笛卡尔坐标系，其中<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/dart-ui/Size-class.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">Size</em></a></code>表示从原点的偏移。每个<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/RenderBox-class.html" rel="noopener ugc nofollow" target="_blank">RenderBox</a></code>还将与一个<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html" rel="noopener ugc nofollow" target="_blank">BoxConstraints</a></code>对象相关联，该对象包含四个值:<em class="ls">最大|最小宽度</em>和<em class="ls">最大|最小高度</em>。一个<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/RenderBox-class.html" rel="noopener ugc nofollow" target="_blank">RenderBox</a></code>可以选择拥有任何它想要的<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/dart-ui/Size-class.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">Size</em></a></code>，但是它必须尊重那些价值观/约束。小部件的大小/位置完全取决于这些RenderBox的属性。与小部件构建小部件三的方式相同，渲染框构建渲染三。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/7b3bf331dbb0ed79a680ee0ae00a9e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LG2bCyf8VbQm5-f6qCl_kw.png"/></div></div></figure><p id="bc34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以认为Flutter的布局系统是一个2阶段系统。在第一阶段，框架遍历渲染树，将<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html" rel="noopener ugc nofollow" target="_blank">BoxConstraints</a></code>对象从父对象递归传递到子对象。它给了父母一种方式来决定/执行他们孩子的<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/dart-ui/Size-class.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">Size</em></a></code>，按照他们喜欢的方式更新这些约束。换句话说，这是负责传播约束信息的阶段，让每个人都知道它的最大/最小可能大小。</p><p id="d6a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦完成，第二阶段开始。这一次，每个<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/RenderBox-class.html" rel="noopener ugc nofollow" target="_blank">RenderBox</a></code>将它选择的<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/dart-ui/Size-class.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">Size</em></a></code>传递回它的父节点。父节点收集所有子节点的<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/dart-ui/Size-class.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">Size</em></a></code>,然后使用这些几何信息在自己的笛卡尔系统中正确定位每个子节点。在这个阶段，父母知道每个孩子有多大，以及他们将被安置在哪里。</p><p id="88ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，最后，这一切意味着什么呢？</p><p id="890e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着父母负责定义/限制/约束他们孩子的大小，并相对于其坐标系定位他们。换句话说，一个小部件可以选择它的大小，但是它必须始终遵守来自其父部件的约束。此外，小部件不知道它在屏幕上的位置，但它的父部件知道。</p><p id="4d96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您对小部件的大小或位置有问题，请尝试查看(更新)其父级。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h2 id="47cb" class="ma mb it bd mc md me dn mf mg mh dp mi km mj mk ml kq mm mn mo ku mp mq mr ms bi translated">例子</h2><p id="9e25" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">好的，让我们想象一下，通过一个例子来理解发生了什么。但在此之前，这里有一些在调试约束时可能有用的术语:</p><ul class=""><li id="d964" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">如果<em class="ls"/><strong class="kd iu"><em class="ls">max(w | h)= min(w | h)</em></strong>，那就是<strong class="kd iu"><em class="ls"/></strong>紧紧约束着。</li><li id="2f25" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">如果<strong class="kd iu"> <em class="ls"> min(w|h) = 0 </em> </strong>，我们就有了<strong class="kd iu"><em class="ls"/></strong>的宽松约束。</li><li id="bf9f" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">If <strong class="kd iu"> <em class="ls"> max(w|h)！</em>=无限</strong>，约束为<strong class="kd iu"> <em class="ls">有界。</em>T29】</strong></li><li id="f91f" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">若<strong class="kd iu"> <em class="ls"> max(w|h) =无穷大</em> </strong>，则约束为<strong class="kd iu"> <em class="ls">无界。</em> </strong></li><li id="6cd5" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">如果<strong class="kd iu"><em class="ls">【w | h】=无穷大</em> </strong>，则正好说成是<strong class="kd iu"><em class="ls"/></strong></li></ul><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/17f50a6bdf574dc8b9673148e600c485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4EkyzsvBzMlYfMufea1kQ.png"/></div></div></figure><p id="7ba7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用的应用程序是初始应用程序模板的幻灯片修改版本。一般来说，您有两种简单的方法来检查小部件<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/RenderBox-class.html" rel="noopener ugc nofollow" target="_blank">RenderBox</a></code>及其属性:</p><ol class=""><li id="49e3" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky ne lf lg lh bi translated">代码执行:我们可以在布局系统的第一阶段使用LayoutBuilder拦截<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html" rel="noopener ugc nofollow" target="_blank">BoxConstraints</a></code>传播，并检查约束。然后，在第二阶段完成后，我们使用键来获取小部件的<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/RenderBox-class.html" rel="noopener ugc nofollow" target="_blank">RenderBox</a></code>，并能够检查<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/dart-ui/Size-class.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">Size</em></a></code>、<code class="fe ln lo lp lq b">Position</code>。</li><li id="f296" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated">或者使用DevTools小部件检查器:</li></ol><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/8d83be7af6765b7c5b9e0619739e577f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AT__J3lxx3j5VjoxPw3i1w.png"/></div></div></figure><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/b70e24c5ce3c0854bf29a86fc74e93d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4bXjBdoLrfjlhf8nmNRshA.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">打印常数</figcaption></figure><p id="f199" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们一步一步来，看看发生了什么(这里我们将忽略<code class="fe ln lo lp lq b">LayoutBuilders</code>)。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/71c9c2f0caa48efe875e0fd154b6ddd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*89dGdagDNw6aNtrq5Z4EhQ.gif"/></div></div></figure><p id="fc7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中发生的第一件事是<code class="fe ln lo lp lq b">main</code>执行<code class="fe ln lo lp lq b">runApp(..)</code>。这个函数检查屏幕的当前大小(在我们的例子中是392:759 )，然后创建一个<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html" rel="noopener ugc nofollow" target="_blank">BoxConstraints</a></code>对象，保存将被发送到我们的第一个小部件(<code class="fe ln lo lp lq b">MyApp</code>)的约束。注意<strong class="kd iu"> <em class="ls"> max|min宽度和高度都等于</em></strong>；因此，<code class="fe ln lo lp lq b">runApp</code>使用了一个<strong class="kd iu"> <em class="ls">紧</em> </strong>约束——通过这样做，<code class="fe ln lo lp lq b">MyApp</code>在选择其尺寸时，除了填满屏幕上的全部可用空间之外，别无选择。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/15cf494539e3b159480184b06a5116ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nsV-7cIMxNR-MHc3UAs1Lg.gif"/></div></div></figure><p id="9fcc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，约束沿着小部件树向下传播。<code class="fe ln lo lp lq b">MyApp</code>、<code class="fe ln lo lp lq b">MaterialApp</code>、<code class="fe ln lo lp lq b">HomePage</code>和<code class="fe ln lo lp lq b">Scaffold</code>都被告知相同的<strong class="kd iu"> <em class="ls">紧</em> </strong>约束。所以所有将被强制填满整个屏幕。每个小部件都有机会向其子部件通知不同的<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html" rel="noopener ugc nofollow" target="_blank">BoxConstraints</a></code>(仍然尊重它已经收到的那个)。但是，在这种情况下，他们选择不这样做。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/7c6f5862b79f6e266e32c6ace2ef418e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uqubLnQ8f8Xfn05JGpC8Cg.gif"/></div></div></figure><p id="6d01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在事情开始变得更有趣了。<code class="fe ln lo lp lq b">Scaffold</code>通知<code class="fe ln lo lp lq b">AppBar</code>它必须使用的<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html" rel="noopener ugc nofollow" target="_blank">BoxConstraints</a></code>，但是，这一次，它使用了一个<strong class="kd iu"> <em class="ls">松散的</em> </strong>约束(min h = 0)。它给了<code class="fe ln lo lp lq b">AppBar</code>一个机会去选择它想要的任何高度，但是它必须仍然使用width = 390。</p><p id="f6bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ln lo lp lq b">AppBar</code>是一种特殊的小部件，叫做<code class="fe ln lo lp lq b">PreferredSizeWidget</code>。这种类型的小部件<em class="ls">不会对其子部件施加任何约束。如果你试图使用<code class="fe ln lo lp lq b">LayoutBuilder</code>来获得<code class="fe ln lo lp lq b">Title</code>的约束，你会得到一个错误。相反，<code class="fe ln lo lp lq b">AppBar</code>以首选/默认大小响应<code class="fe ln lo lp lq b">Scaffold</code>:<em class="ls">高度= 80 </em>，<em class="ls">宽度= 392 </em>(由接收到的约束强制)</em></p><p id="0738" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在得到<code class="fe ln lo lp lq b">AppBar</code>的<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/dart-ui/Size-class.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">Size</em></a></code>的<em class="ls">后，</em>的<code class="fe ln lo lp lq b">Scaffold</code>继续到它的下一个孩子:<code class="fe ln lo lp lq b">Center</code></p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/1eb6ee05252ade87d9dc9f48c690ec9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GD68iWA9nEcjLYa7plg_hQ.gif"/></div></div></figure><p id="4e87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，这里发生了很多事情。让我们试着理解:</p><ol class=""><li id="23a1" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky ne lf lg lh bi translated"><code class="fe ln lo lp lq b">Scaffold</code>通知<code class="fe ln lo lp lq b">Center</code>它的约束，让它选择0 &lt; w &lt; 392和0 &lt; h &lt; 697之间的任意尺寸。注意最大高度是<strong class="kd iu"> 759(屏幕最大高度)减去80(app bar选择的高度)</strong></li><li id="3354" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated"><code class="fe ln lo lp lq b">Center</code>转到其子节点<code class="fe ln lo lp lq b">Text</code>，转发相同的约束/</li><li id="b364" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated"><code class="fe ln lo lp lq b">Text</code>选择一个足以显示其数据的大小(279:16)，并回复<code class="fe ln lo lp lq b">Center</code>。</li><li id="326f" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated">有了手中的几何信息<code class="fe ln lo lp lq b"><a class="ae lr" href="https://api.flutter.dev/flutter/dart-ui/Size-class.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">(Size</em></a><em class="ls">)</em></code>,<code class="fe ln lo lp lq b">Center</code>可以在笛卡尔坐标系中正确定位<code class="fe ln lo lp lq b">Text</code>。作为父节点，<code class="fe ln lo lp lq b">Center</code>有权选择它的子节点，在这种情况下，它决定将它集中起来。</li></ol><p id="5988" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">流程继续进行:</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/f1a5055d4c7abdad13aa711ad8548973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xu8RduNCQJAs4_VttjJAPA.gif"/></div></div></figure><ol class=""><li id="fb5e" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky ne lf lg lh bi translated">然后<code class="fe ln lo lp lq b">Center</code>为自己选择一个尺寸，但是它不是只选择一个“足够”的尺寸(就像<code class="fe ln lo lp lq b">Text</code>那样)，而是决定尽可能大，相应地，它已经收到的约束。</li><li id="2674" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated"><code class="fe ln lo lp lq b">Scaffold</code>接收到<code class="fe ln lo lp lq b">Center</code>想要的大小，然后流继续流向它的最后一个孩子:<code class="fe ln lo lp lq b">FAB</code></li><li id="3435" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated"><code class="fe ln lo lp lq b">FAB</code>接收约束并将其首选尺寸(56:56)返回给<code class="fe ln lo lp lq b">Scaffold</code></li><li id="e7d1" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated">最后，<code class="fe ln lo lp lq b">Scaffold</code>拥有在笛卡尔坐标系中定位每个孩子所需的所有几何信息。</li></ol><p id="e02c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，对<code class="fe ln lo lp lq b">Scaffold</code>以上的所有微件重复该过程:</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/05b8f8ecf7d56c4573c0921560197d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UOjBaMvX114eD8S4nFxLTQ.gif"/></div></div></figure><ol class=""><li id="5f13" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky ne lf lg lh bi translated">尺寸信息继续沿着渲染树向上传播。</li><li id="1719" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated">每个小部件都使用这些信息在笛卡尔系统中定位每个孩子。</li><li id="ec92" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated"><code class="fe ln lo lp lq b">Scaffold</code>回答<code class="fe ln lo lp lq b">HomePage</code>，那个回答<code class="fe ln lo lp lq b">MaterialApp</code>，那个反过来回答<code class="fe ln lo lp lq b">MyApp</code>。直到if最终再次到达<code class="fe ln lo lp lq b">Main</code>。</li><li id="2a51" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated"><code class="fe ln lo lp lq b">Main</code>获得这个“最终”小部件，并最终将其绑定到屏幕上。</li></ol><p id="7e44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RenderBox树最终绑定在屏幕上。我们有一个正在运行的应用程序。</p><h2 id="a28e" class="ma mb it bd mc md me dn mf mg mh dp mi km mj mk ml kq mm mn mo ku mp mq mr ms bi translated">一些有趣的事情要记住</h2><ul class=""><li id="7937" class="kz la it kd b ke mt ki mu km no kq np ku nq ky le lf lg lh bi translated">小部件不知道它在屏幕上的位置；它的母公司有。</li><li id="04eb" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">小部件可以选择它想要的大小，但是它必须符合其父部件的限制。</li><li id="9a54" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">约束向下传播，尺寸向上传播。</li><li id="8ead" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">努力学习约束术语，它们以后可能会有用。</li></ul><p id="f092" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这些能帮助你更好地理解颤振布局系统是如何工作的。如果这个帖子cast🧙‍♂️是一个小光💡在这个阴影下，请考虑在Twitter上关注我:</p><p id="9468" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">☕️ <a class="ae lr" href="https://twitter.com/GuiSilvaV" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="cfa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">☕️ <a class="ae lr" href="https://www.linkedin.com/in/guilherme-silva-aa042a27/" rel="noopener ugc nofollow" target="_blank">领英</a></p><div class="nr ns gp gr nt nu"><a href="https://github.com/guilherme-v" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">guilherme-v -概述</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">北极代码库贡献者解散在GitHub上注册你自己的个人资料，托管代码，管理…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="oe l of og oh od oi jz nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/flutter-how-to-dismiss-keyboard-globally-a543452cfefa"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">颤动——如何全局消除键盘</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">当使用Flutter时，我们经常尝试模仿特定于平台的行为。比如iOS上的键盘…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">itnext.io</p></div></div><div class="od l"><div class="oj l of og oh od oi jz nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://medium.com/@valiodas/flutter-inspecting-http-request-response-payloads-and-sharedpreferences-dbd3d0cc309e" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">flutter——检查HTTP请求/响应有效负载和共享引用</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">如果你是一个Flutter开发人员，你很有可能熟悉DevTools，一套优秀的性能和…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="ok l of og oh od oi jz nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://medium.com/@valiodas/dart-isolates-and-computation-e6bbbb076d74" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">Dart隔离</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">最近我决定试着更好地理解Dart是如何支持异步编程的——通过…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="ol l of og oh od oi jz nu"/></div></div></a></div></div></div>    
</body>
</html>