<html>
<head>
<title>How to experiment locally on Kubernetes with minikube and your local Dockerfiles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用minikube和您的本地docker文件在Kubernetes上进行本地实验</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-experiment-locally-on-kubernetes-with-minikube-and-your-local-dockerfiles-48833fcd90c9?source=collection_archive---------2-----------------------#2020-09-21">https://itnext.io/how-to-experiment-locally-on-kubernetes-with-minikube-and-your-local-dockerfiles-48833fcd90c9?source=collection_archive---------2-----------------------#2020-09-21</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/0e28ec56f0743444de32593c7c2881a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NwwtQgLqrtBAX8Xj"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated">尼兰塔·伊兰加穆瓦在<a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="febc" class="ke kf ir bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">介绍</h1><p id="4832" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">在这篇入门级文章中，我介绍了一种在本地开发环境中使用Minikube(本质上是计算机上的Kubernetes)构建、公开和测试dockerized应用程序的简单方法。有时，开发人员很难处理实验图像，因为对于每个图像更改，他们都将其推送到注册表，然后在测试K8s集群上拉出。下面，我们将只使用本地环境—即使您没有网络连接，这也是可行的。</p><p id="9ab9" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">我们将收集必要的工具，安装Minikube并构建和测试我们自己的示例应用程序。</p><h1 id="75af" class="ke kf ir bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">TL；灾难恢复版本</h1><p id="8de1" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">1.您可以在自己的笔记本电脑上使用Minikube轻松运行简单的Kubernetes环境，而无需创建虚拟机。用`<em class="mf"> docker驱动</em>就行了。</p><p id="9be2" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">2.你可以插入Minikube的Docker deamon，你只需要运行' minikube docker-env '并按照说明操作。</p><p id="ee54" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">3.您可以使用此连接来构建Docker映像，以便Minikube K8s cluster自动看到它。</p><p id="0d96" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">4.然后，您可以基于构建的映像创建Kubernetes部署，并将其作为服务公开，而不必将其推送到某个外部注册中心。</p></div><div class="ab cl mg mh hv mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ik il im in io"><h1 id="14d9" class="ke kf ir bd kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx mr kz la lb bi translated">收集工具集</h1><p id="0b00" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated"><strong class="le is">获取Docker </strong></p><p id="0830" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">既然您正在阅读这篇文章，我假设您的机器上已经安装了Docker。如果没有，最好的地方是Docker文档页面，它的子页面致力于流行的发行版，比如Ubuntu Linux 。</p><p id="ff5a" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated"><strong class="le is">获取Kubectl </strong></p><p id="008e" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">为了检查是否安装了“kubectl”工具，只需运行:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="8519" class="nb kf ir mx b gz nc nd l ne nf">$ kubectl version --client</span></pre><p id="f4c4" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">结果应该看起来有点像这样:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="104d" class="nb kf ir mx b gz nc nd l ne nf">Client Version: version.Info{Major:”1", Minor:”19", GitVersion:”v1.19.2", GitCommit:”f5743093fd1c663cb0cbc89748f730662345d44d”, GitTreeState:”clean”, BuildDate:”2020–09–16T13:41:02Z”, GoVersion:”go1.15", Compiler:”gc”, Platform:”linux/amd64"}</span></pre><p id="410f" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">如果您的系统上没有`<em class="mf"> kubectl </em>工具，那么获取最新`<em class="mf"> kubectl </em>工具的流行方法是直接从<em class="mf"> kubernetes.io </em>站点获取。我建议你这样放入你的`<em class="mf"> /usr/local/bin/ </em>`文件夹:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="8d9e" class="nb kf ir mx b gz nc nd l ne nf">$ curl -Lo kubectl “https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl" &amp;&amp; chmod +x kubectl</span><span id="48d1" class="nb kf ir mx b gz ng nd l ne nf">$ sudo mv kubectl /usr/local/bin/</span></pre><p id="c18e" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">当然，如果你使用的是Windows或MacOS，你需要改变这个方法。您可以访问<a class="ae kd" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> Kubernetes文档</a>获取说明。</p><p id="f54f" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated"><strong class="le is">获取Minikube </strong></p><p id="87e8" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">由于“<em class="mf"> minikube </em>”是一个独立的应用程序，与“<em class="mf"> kubectl </em>”的方式非常相似，因此安装也非常相似:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="b6eb" class="nb kf ir mx b gz nc nd l ne nf">$ curl -Lo minikube <a class="ae kd" href="https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</a> &amp;&amp; chmod +x minikube</span><span id="05d2" class="nb kf ir mx b gz ng nd l ne nf">$ sudo mv minikube /usr/local/bin</span></pre><p id="01d5" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">请记住，移动到“<em class="mf"> /usr/local/bin </em>”只是一个建议——这是我习惯遵循的方式，以便在我的道路上拥有所有有用的工具；你可以随意改变它。只要确保`<em class="mf"> minikube </em>`命令正常工作即可:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="009d" class="nb kf ir mx b gz nc nd l ne nf">$ minikube version</span><span id="3651" class="nb kf ir mx b gz ng nd l ne nf">minikube version: v1.13.0<br/>commit: 0c5e9de4ca6f9c55147ae7f90af97eff5befef5f-dirty</span></pre><h1 id="8d90" class="ke kf ir bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">轻松跑迷你库</strong></h1><p id="6287" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">Minikube支持许多关于运行Kubernetes组件的环境的选项，比如KVM或VirtualBox。然而，这些都不是必需的，安装后会使您的开发环境变得混乱。</p><p id="8f77" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">Minikube还提供“none”和“podman”驱动程序，但这些驱动程序需要特权访问，在某些情况下可能会覆盖一些敏感的系统配置。</p><p id="34ec" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">我建议你简单地使用“docker”驱动程序，因为它不需要root权限，对你运行Minikube的系统配置没有威胁。</p><p id="2852" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">Minikube的第一次运行是一个简单的命令行，示例结果如下:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="60d5" class="nb kf ir mx b gz nc nd l ne nf">$ minikube start — driver=docker</span></pre><blockquote class="nh ni nj"><p id="4fb6" class="lc ld mf le b lf ma lh li lj mb ll lm nk mc lp lq nl md lt lu nm me lx ly lz ik bi translated">😄基于用户配置使用docker驱动程序的Linuxmint 19.3 <br/> ✨上的minikube v 1 . 13 . 0<br/>👍启动集群迷你库<br/>中的控制平面节点迷你库🚜拉出基础图像… <br/>💾正在下载Kubernetes v1.19.0预加载… <br/> &gt;预加载-images-k8s-V6-v 1 . 19 . 0-docker-overlay 2-amd64 . tar . lz4:486.28 MiB<br/>🔥正在创建docker容器(CPUs = 2，内存=2200MB) … <br/>🐳在Docker 19.03.8上准备Kubernetes v 1 . 19 . 0…<br/>🔎验证Kubernetes组件… <br/>🌟启用的插件:默认存储类，存储供应器<br/>🏄搞定了。kubectl现在默认配置为使用“minikube”</p></blockquote><p id="642a" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">完成上述操作后，您可以检查minikube部署状态:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="e0ae" class="nb kf ir mx b gz nc nd l ne nf">$ minikube status</span><span id="3e75" class="nb kf ir mx b gz ng nd l ne nf">minikube<br/>type: Control Plane<br/>host: Running<br/>kubelet: Running<br/>apiserver: Running<br/>kubeconfig: Configured</span></pre><p id="8512" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated"><strong class="le is">重用Docker守护进程</strong></p><p id="ef17" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">正如<a class="ae kd" href="https://kubernetes.io/docs/setup/learning-environment/minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube文档</a>所述，“<em class="mf">当对Kubernetes使用单个VM时，重用Minikube的内置Docker守护进程是有用的。重用内置的守护进程意味着你不必在你的主机上建立一个Docker注册表，然后把镜像推送到里面</em>。</p><p id="cf6c" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">我已经完整地引用了上面的句子，因为没有更好的词来描述这个想法。但是这个注释很容易在快速入门页面中被忽略，因为它对于在本地机器上进行快速实验是至关重要的！</p><p id="25a5" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">我们将“插入”minikube的Docker环境，因此我们将构建的任何映像都将在我们的Minikube集群中立即可见，就像它被推送到DockerHub或其他存储库一样。</p><p id="6e40" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">在终端中运行的命令是:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="a2a1" class="nb kf ir mx b gz nc nd l ne nf">$ eval $(minikube -p minikube docker-env)</span></pre><p id="837e" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">请记住，这将为这个特定的终端会话设置环境！从现在开始，你使用' docker '命令做的任何事情，都将由Minikube中的Docker解释。如果您销毁这个终端会话或启动另一个终端会话，您需要重复如上所示的“eval”命令。</p><h1 id="0dd0" class="ke kf ir bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">准备和构建映像</strong></h1><p id="25b2" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">现在，我们将进行快速DevOps配方中的“开发”部分。我们需要创建两个文件——一个是在容器中运行的应用程序，另一个包含如何构建运行该应用程序的Docker容器的说明。</p><p id="cdd8" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated"><strong class="le is">粗WWW应用</strong></p><p id="715e" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">对于我们的简单应用程序，我们将使用Arundel &amp; Dominguis的“带有Kubernetes的云原生DevOps”的思想创建go http服务器。如果你还没有接触过这本书，我强烈推荐它！</p><p id="de60" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">这种选择有一个特定的原因golang应用程序可以编译并构建到非常小的优化容器中，当构建到“scratch”容器中时，还会留下非常小的<em class="mf"> _attack surface_ </em>。基本上，我们将在Docker内创建一个应用程序，里面什么也没有。</p><p id="31b9" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">创建一个“hello.go”文件，并在您选择的编辑器中进行编辑，以实现以下目的:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="2b89" class="nb kf ir mx b gz nc nd l ne nf">package hello<br/>import (<br/>   "fmt"<br/>   "log"<br/>   "net/http"<br/>)<br/>func handler(w http.ResponseWriter, r *http.Request) {<br/>   fmt.Fprintln(w, "It works!")<br/>}<br/>func main() {<br/>   http.HandleFunc("/", handler)<br/>   log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="036f" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated"><strong class="le is">用于WWW应用的Docker图像</strong></p><p id="d220" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">接下来，在同一个目录中创建一个`<em class="mf"> Dockerfile </em>`,内容如下:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="9569" class="nb kf ir mx b gz nc nd l ne nf">FROM golang:1.15-alpine AS base<br/>WORKDIR /src/<br/>COPY hello.go /src/<br/>ENV CGO_ENABLED=0 <br/>RUN go build -o /bin/hello<br/>FROM scratch<br/>COPY --from=base /bin/hello /bin/hello<br/>ENTRYPOINT ["/bin/hello"]</span></pre><p id="151c" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">现在，如果您在连接到Minikube的Docker deamon的终端中构建容器，它将立即在K8s集群中可用。</p><p id="6ac7" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">若要使用连接，请运行下面的命令。记得留在Dockerfile放的目录下！如你所见，我们使用了“1.0”标签。注意末尾的那个点。</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="4a7f" class="nb kf ir mx b gz nc nd l ne nf">$ docker build -t go-hello:1.0 .</span></pre><p id="4aef" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">重要提示:<strong class="le is">* *始终** </strong>标记图像。不要对本地图像使用`<em class="mf">最新的</em>标签。否则，您可能会在Minikube的K8s中遇到“<em class="mf"> ErrPullBackoff </em>”错误。</p><h1 id="180d" class="ke kf ir bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">展开和暴露</strong></h1><p id="521d" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">在生产中，您应该始终遵循IaC和DevOps原则。就Kubernetes而言，您至少应该有部署和服务YAML文件，甚至是重新部署应用程序的导航图。</p><p id="92ee" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">在您的本地环境中，当您进行试验时，您可以只创建部署，并使用两个简单的命令公开它:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="5d9b" class="nb kf ir mx b gz nc nd l ne nf">$ kubectl create deployment go-hello --image=go-hello:1.0</span><span id="fac6" class="nb kf ir mx b gz ng nd l ne nf">$ kubectl expose deployment go-hello --type=NodePort --port=8080</span></pre><p id="4107" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">请记住将标签设置为您在上一小节中使用的标签。</p><p id="a637" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">部署后，如果服务已成功创建，您可以在K8s集群中验证应用程序行为，并使用Minikube的内置功能在浏览器窗口中验证服务:</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="b946" class="nb kf ir mx b gz nc nd l ne nf">$ kubectl get svc go-hello</span><span id="ffbc" class="nb kf ir mx b gz ng nd l ne nf">$ kubectl get deploy go-hello -o wide</span><span id="a662" class="nb kf ir mx b gz ng nd l ne nf">$ kubectl get pods -l=app=go-hello</span><span id="832e" class="nb kf ir mx b gz ng nd l ne nf">$ minikube service go-hello</span></pre><p id="b41e" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">最后一个命令将打开您的服务浏览器，并显示连接值，如下例所示。</p><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="c6dc" class="nb kf ir mx b gz nc nd l ne nf">| default | go-hello | 8080 | <a class="ae kd" href="http://172.17.0.3:32061" rel="noopener ugc nofollow" target="_blank">http://172.17.0.3:32061</a> |</span><span id="a446" class="nb kf ir mx b gz ng nd l ne nf">🎉 Opening service default/go-hello in default browser…</span></pre><p id="fa25" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">当然，你可以使用curl、Postman或其他工具来测试你的服务。</p><p id="7f15" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">每当您更改应用程序并希望在Kubernetes中进行测试时，您可以:</p><ul class=""><li id="2fd0" class="nn no ir le b lf ma lj mb ln np lr nq lv nr lz ns nt nu nv bi translated">使用新标签构建图像，例如“2.0”</li></ul><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="393c" class="nb kf ir mx b gz nc nd l ne nf">$ docker build -t go-hello:2.0 .</span></pre><ul class=""><li id="fdfa" class="nn no ir le b lf ma lj mb ln np lr nq lv nr lz ns nt nu nv bi translated">使用以下命令编辑Minikube中的部署:</li></ul><pre class="ms mt mu mv gu mw mx my mz aw na bi"><span id="e00d" class="nb kf ir mx b gz nc nd l ne nf">$ kubectl set image deployment/go-hello go-hello=go-hello:2.0</span></pre><p id="344f" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">更新的图像将导致窗格被重新创建，并且更改将立即在浏览器中可见。</p><h1 id="a465" class="ke kf ir bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">就是这样！</h1><p id="d9dd" class="pw-post-body-paragraph lc ld ir le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ik bi translated">您已经成功地部署了一个minikube Kubernetes集群，构建了一个优化的Docker应用程序，在集群上运行——并且在您的本地环境中完成了所有这些工作。恭喜你！</p><p id="a6f0" class="pw-post-body-paragraph lc ld ir le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ik bi translated">让我在评论中知道是否有一些部分引起了一些问题。有许多配置和操作系统，我希望我的教程涵盖了大多数，但我肯定不是所有的:)</p></div></div>    
</body>
</html>