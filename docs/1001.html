<html>
<head>
<title>Some practical rxjs techniques in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度测量中的一些实用rxjs技术</h1>
<blockquote>原文：<a href="https://itnext.io/some-practical-rxjs-techniques-in-angular-315d1bfa41c8?source=collection_archive---------1-----------------------#2018-07-02">https://itnext.io/some-practical-rxjs-techniques-in-angular-315d1bfa41c8?source=collection_archive---------1-----------------------#2018-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="79c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(免责声明:在Angular 5上使用rxjs第5版进行了演示，但我猜第6版的想法也是类似的，只是api发生了变化。)</p><p id="a6e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我试图收集一些在Angular中被动开发时使用的实用技术。</p><ol class=""><li id="bd0c" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">可观测量的“预期”选择:</li></ol><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="f5c7" class="ld le iq kz b gy lf lg l lh li">updateSomething$(something: Something[]): Observable&lt;Something[]{<br/><strong class="kz ir">const </strong>requests = something.map(thingy =&gt;  <strong class="kz ir">this</strong>.http.put(<strong class="kz ir">`/something/</strong>${thingy.i<strong class="kz ir">d</strong>}<strong class="kz ir">`</strong>, thingy)<br/>    .<strong class="kz ir">catch</strong>(err =&gt; Observable.<em class="lj">of</em>({<strong class="kz ir">err</strong>: err, <strong class="kz ir">reason</strong>:  thingy.<strong class="kz ir">message</strong>})));<br/><strong class="kz ir">return </strong>forkJoin(requests);<br/>}</span></pre><p id="ac32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解释:</p><ul class=""><li id="da44" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk lk kr ks kt bi translated">编写了一个api调用列表(observables ),用于根据id更新内容。</li><li id="c234" class="kl km iq jp b jq ll ju lm jy ln kc lo kg lp kk lk kr ks kt bi translated">如果失败——捕获失败并返回一个带有原因的可观察值。</li><li id="5775" class="kl km iq jp b jq ll ju lm jy ln kc lo kg lp kk lk kr ks kt bi translated">该函数返回传递请求列表的forkJoin运算符。(使用该函数的任何人都可以订阅它以获得forkjoined结果)</li><li id="26e3" class="kl km iq jp b jq ll ju lm jy ln kc lo kg lp kk lk kr ks kt bi translated">forkJoin将一直等到最后一个观察完成，然后它将产生最新结果的单个值。</li><li id="b410" class="kl km iq jp b jq ll ju lm jy ln kc lo kg lp kk lk kr ks kt bi translated">如果我不捕捉错误并通过返回一个可观察值来处理它以便继续，我将丢失先前的可观察值。</li></ul><p id="15b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.返回“thenable”函数(返回promise的函数)备选项:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="cbda" class="ld le iq kz b gy lf lg l lh li">SaveOrCancel$() {<br/>  <strong class="kz ir">return this</strong>.service.someObsFn().map(result =&gt; result ? followingObsFn : Observable.<em class="lj">of</em>(result));<br/>}</span></pre><p id="69f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我有一个函数，它返回一个要订阅的可观察对象(例如，您从中解析的模态实例，单击“确定”将流为真，单击“取消”将流为假)，我想运行另一个从其订阅返回可观察对象的函数(例如，用户单击“确定”来解析操作)，然后我将使用映射运算符来流“下一个”值，并将返回我希望返回的下一个反应函数(表示一个可观察对象，它包含用户单击“确定”来解析时运行的函数的结果)。</p><figure class="ku kv kw kx gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lq"><img src="../Images/c9e85a7200ee7975e66c1b854e40715d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H54nBmMCc2ic4vDDmuIkaA.png"/></div></div></figure><p id="091b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的美妙之处(与处理承诺不同)在于，如果我保留对returnObsFromSubscription$函数的订阅引用，我可以随时取消订阅！</p><p id="3bd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.<em class="lj">组合测试运算符—完全反应式—无承诺项选择</em></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="a96e" class="ld le iq kz b gy lf lg l lh li"><strong class="kz ir">this</strong>.<strong class="kz ir">combinedSubscriptions$ </strong>= <em class="lj">combineLatest</em>(<br/>  <strong class="kz ir">this</strong>.store.select(<strong class="kz ir">'a'</strong>),<br/>  <strong class="kz ir">this</strong>.store.select(<strong class="kz ir">'b'</strong>).map(b =&gt; b.name),<br/>  <strong class="kz ir">this</strong>.route.<strong class="kz ir">params)<br/>.</strong>subscribe(retValues =&gt; {<br/>console.log(`a: ${retValues[0].something} b: ${retValues[1]} routeParam: ${retValues}`);</span></pre><p id="cdcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说明</p><ul class=""><li id="64c2" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk lk kr ks kt bi translated">一旦每个可观察值产生一个值，combineLatest将返回“聚合”结果，它不会等待诸如forkJoin之类的完成，这意味着如果“a”存储将被更新，打印的结果将包含“b”和routeParam的最后值:)</li></ul><p id="523f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.行为主体</p><p id="a516" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用BehaviorSubject允许您以快速的方式在应用程序的不同区域之间共享状态，但也很容易变得混乱(难以维护)，并且在使用rxjs store以redux模式管理应用程序的可共享状态时并不总是需要。</p><p id="ef61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，我使用它来设置应用程序中几个区域的纯UI状态，我选择使用它而不是使用存储，以避免从我不希望他们订阅的组件订阅存储，并避免将存储本身作为依赖项和操作类型导入，加上我的目标是最小的更改和易于测试的解决方案，所以它是一个很好的选择。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="d2ca" class="ld le iq kz b gy lf lg l lh li">@Injectable()<br/><strong class="kz ir">export class </strong>ToggleSliderEditModeService {<br/><br/>  private <strong class="kz ir">isSliderOnEdit </strong>= <strong class="kz ir">new </strong>BehaviorSubject&lt;<strong class="kz ir">boolean</strong>&gt;(<strong class="kz ir">false</strong>);<br/><br/>  setIsEdit(isEdit: <strong class="kz ir">boolean</strong>) {<br/>    <strong class="kz ir">this</strong>.<strong class="kz ir">isSliderOnEdit</strong>.next(isEdit);<br/>  }<br/>  isSliderOnEditMode() {<br/>    <strong class="kz ir">return this</strong>.<strong class="kz ir">isSliderOnEdit</strong>.asObservable();<br/>  }<br/>}</span></pre><p id="0817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前就是这样，rxjs真的很棒，管道流很有趣..别忘了退订:P</p></div></div>    
</body>
</html>