<html>
<head>
<title>AWS Cognito example using React UI and Node.js REST APIs — part 3 (JWT secured REST APIs)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React UI和Node.js REST APIs的AWS Cognito示例—第3部分(JWT安全REST API)</h1>
<blockquote>原文：<a href="https://itnext.io/aws-cognito-example-using-react-ui-and-node-js-rest-apis-part-3-jwt-secured-rest-apis-e56d336ce306?source=collection_archive---------0-----------------------#2019-08-14">https://itnext.io/aws-cognito-example-using-react-ui-and-node-js-rest-apis-part-3-jwt-secured-rest-apis-e56d336ce306?source=collection_archive---------0-----------------------#2019-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0d72841b86ccd6327c0c4ae985aabead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*io_sEBQjZi8M84t1AaIy0A.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">在<a class="ae jg" href="https://unsplash.com/search/photos/keys?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jg" href="https://unsplash.com/@cmdrshane?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> CMDR Shane </a>拍摄的照片</figcaption></figure><div class=""/><p id="062d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">在我的AWS Cognito系列的第三篇也是最后一篇文章中，我将讲述如何使用AWS Cognito发布的JSON Web Token (JWT)访问代码创建和保护一个简单的基于Express的Node.js REST API服务。我们还将修改我们在本系列的第二篇文章<a class="ae jg" href="https://medium.com/@arron.harden/aws-cognito-example-using-react-ui-and-node-js-rest-apis-part-2-react-ui-app-with-redux-6cc22610affe" rel="noopener">中创建的React UI应用程序，以调用这个REST API，并包含它从Cognito接收的一个JWT访问代码。</a></span></p><h1 id="2791" class="ln lo jj bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">JWT概述</h1><p id="d44b" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">有大量的文档已经涵盖了JWT(尝试<a class="ae jg" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank">https://jwt.io/introduction</a>)，所以我不想在这里重复，相反，我将给出一个快速的概述，然后我们将看看一些具体方面的认知。</p><p id="b7ca" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，JSON Web令牌(JWT)是一段经过编码和数字签名的JSON，被调用者可以对其进行验证，以便I)检查调用者的授权，以及ii)获取调用者的身份信息(例如姓名、电子邮件地址、帐户id等)。</p><p id="ad2d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与更集中的用户注册类型的方法相比，JWT有几个优点，这就是为什么它成为API认证和授权的一个非常流行的解决方案。对我来说最大的优势是:</p><ul class=""><li id="3ac5" class="mq mr jj ki b kj kk kn ko kr ms kv mt kz mu ld mv mw mx my bi translated">不需要外部呼叫来验证JWT接入码。签名机构(我们示例中的Cognito用户池)的公钥被下载、缓存，然后用于验证传入API请求上的JWT访问代码的签名。如果签名得到验证，那么这意味着JWT访问代码只能从我们的Cognito用户群中发出。这极大地减少了验证传入API请求的延迟和总体系统开销，并使扩展系统变得更加容易。</li><li id="68fb" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">JWT接入码可以包括关于呼叫者的补充信息(例如，姓名、电子邮件地址、账户id等)。同样，这些都是可以实现的，不需要任何外部调用。</li><li id="71e5" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">JWT接入码通常具有到期时间。我见过使用5分钟(基于系统的JWT接入码)到60分钟(基于用户的JWT接入码)的实现。过了这段时间后，它们就不能再使用了，这意味着与用户名/密码或API密钥的无意泄露不同，JWT访问代码的泄露只有一个很小的可用时间窗口。</li></ul><p id="0370" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，应该注意不要在日志、诊断或任何其他正在进行的持久性操作中暴露用户的JWT访问代码。它们应该被视为秘密，就像API密钥、密码等。不要忘记，它们可能包含个人身份信息(PII ),因此即使在过期很久之后，也可能受到GDPR政策的保护。</p><h1 id="f5ce" class="ln lo jj bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">科宁托和JWT</h1><p id="06cb" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">作为Cognito UI登录流程的一部分，我们的UI应用程序实际上接收了3个JWT访问代码，如下所述。</p><h2 id="ebf3" class="ne lo jj bd lp nf ng dn lt nh ni dp lx kr nj nk mb kv nl nm mf kz nn no mj np bi translated">认知ID令牌</h2><p id="2295" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><em class="nq"> ID令牌</em>包含关于呼叫者身份的信息(例如姓名、电子邮件地址、帐户ID等)。来自Cognito的(过期的)编码JWT ID令牌的示例如下所示:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="62c2" class="ne lo jj nw b gy oa ob l oc od">eyJraWQiOiIwbjd6c2g0eDRlZzVCRmszZk9vNlNLeWkwenJHODNESysyQ1wvNXhtRnFNMD0iLCJhbGciOiJSUzI1NiJ9.eyJhdF9oYXNoIjoiNHhSNmpkODJlRUtiYkFXcnh2cVJlUSIsInN1YiI6IjFmMGJlNjJmLWZmY2QtNDljYS1iNWE0LTE4ZjBiZjYyZTBlNiIsImF1ZCI6IjR0bnA0azY0ZDV2NGFoOWR1ZDNwajFrYnMwIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsInRva2VuX3VzZSI6ImlkIiwiYXV0aF90aW1lIjoxNTY1MDIwNDQ5LCJpc3MiOiJodHRwczpcL1wvY29nbml0by1pZHAuZXUtd2VzdC0yLmFtYXpvbmF3cy5jb21cL2V1LXdlc3QtMl96MUdvNVhkcloiLCJjb2duaXRvOnVzZXJuYW1lIjoiYXJyb24iLCJleHAiOjE1NjUwMjQwNDksImlhdCI6MTU2NTAyMDQ0OSwiZW1haWwiOiJkZW1vQGFycm9uaGFyZGVuLmNvbSJ9.kh_Bdao1BzXIoGvcE8ByAAFdLYb8s_Tcf0RwKk6joJr43r0Q0N7Yz63c5O4DYoUKgwdHRNhKax93rkSCamabmNl8f3-K68OOC3MNn22Fn2p6prOn9jXeK4y_QDHzOj8LFSJTsQxjIq6JfaZReTfHdplEsIVfmqijFO7PPQHcK4GCgYCTxiyD8iaKF48tcdNrm9NczgtzVdT6ShNK8LRcGhdXSYxLk0h0k8lYRhV8Imy2uxAvuY9wgeKvrY7FPHJc8dsgfVuRXAn-QCtEaTCxpOlVuNgtJ06Ww09ur1eINIFFQ_WCqUV1vP7JQEylItrf1WxAYKJDNrKqWSuZeogr3A</span></pre><p id="eabb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<a class="ae jg" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> jwt.io </a>，我们可以对此进行解码，并看到报头包含以下关于jwt访问码是如何构造的信息:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="aaf2" class="ne lo jj nw b gy oa ob l oc od">{<br/>  "<strong class="nw jk">kid</strong>": "0n7zsh4x4eg5BFk3fOo6SKyi0zrG83DK+2C/5xmFqM0=",<br/>  "<strong class="nw jk">alg</strong>": "RS256"<br/>}</span></pre><p id="e23d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且有效载荷包含以下身份信息:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="cd4c" class="ne lo jj nw b gy oa ob l oc od">{  <br/>  <strong class="nw jk">"at_hash"</strong>:"4xR6jd82eEKbbAWrxvqReQ",<br/>  <strong class="nw jk">"sub"</strong>:"1f0be62f-ffcd-49ca-b5a4-18f0bf62e0e6",<br/>  <strong class="nw jk">"aud"</strong>:"4tnp4k64d5v4ah9dud3pj1kbs0",<br/>  <strong class="nw jk">"email_verified"</strong>:true,<br/>  <strong class="nw jk">"token_use"</strong>:"id",<br/>  <strong class="nw jk">"auth_time"</strong>:1565020449,<br/>  <strong class="nw jk">"iss"</strong>:"https://cognito-idp.eu-west-2.amazonaws.com/eu-west-2_z1Go5XdrZ",<br/>  <strong class="nw jk">"cognito:username"</strong>:"arron",<br/>  <strong class="nw jk">"exp"</strong>:1565024049,<br/>  <strong class="nw jk">"iat"</strong>:1565020449,<br/>  <strong class="nw jk">"email"</strong>:"demo@arronharden.com"<br/>}</span></pre><p id="b181" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性名遵循标准的JWT命名约定。一些有用的属性包括:</p><ul class=""><li id="2f2b" class="mq mr jj ki b kj kk kn ko kr ms kv mt kz mu ld mv mw mx my bi translated"><code class="fe oe of og nw b">sub</code>是代表用户的唯一且不变的ID。当持久化与用户相关的内容时，使用该属性的值，而不是用户名或电子邮件地址，因为用户可以随意更改后者。</li><li id="7302" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated"><code class="fe oe of og nw b">aud</code>是用于获取JWT接入码的客户端ID。这应该与用户池中定义的客户端ID相匹配。</li><li id="a591" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated"><code class="fe oe of og nw b">token_use</code>描述它是什么类型的JWT接入码— <em class="nq"> ID令牌</em>或<em class="nq">接入令牌</em>。</li><li id="0801" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated"><code class="fe oe of og nw b">iss</code>是发行者，对于Cognito来说是创建JWT访问代码的用户池的URL。这应该与您的用户池相匹配。</li><li id="28cf" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated"><code class="fe oe of og nw b">cognito:username</code>是包含用户名的自定义Cognito属性。用户可能希望改变这一点，所以避免在应用程序中持久化它。</li><li id="84c3" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated"><code class="fe oe of og nw b">exp</code>是到期时间戳，在此之后，JWT访问码将不再可信。</li><li id="ad32" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated"><code class="fe oe of og nw b">email</code>是用户当前的电子邮件地址。用户可能希望改变这一点，所以避免在应用程序中持久化它。</li></ul><p id="2554" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据Cognito用户池的配置方式，<em class="nq"> ID </em> <em class="nq">令牌</em>可以包含更多的身份信息，如全名、电话号码等，但在本例中，用户池仅配置为存储姓名和电子邮件地址。</p><h2 id="1389" class="ne lo jj bd lp nf ng dn lt nh ni dp lx kr nj nk mb kv nl nm mf kz nn no mj np bi translated">认知访问令牌</h2><p id="65ce" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">一个<em class="nq">访问令牌</em>包含关于调用者的访问权限的信息，并且包括用于获得令牌的OAuth范围。有效负载中的一个<code class="fe oe of og nw b">scope</code>属性将用于决定允许调用者调用哪个(哪些)API。例如，如果有效负载中的范围是只允许<code class="fe oe of og nw b">hello-world.read-only</code>，但是被调用的API是一个<code class="fe oe of og nw b">POST /users</code>，以便创建一个新的资源——实现将被期望返回一个HTTP 403(禁止的)响应，以指示调用者没有足够的权限来执行这个特定的API调用。</p><p id="c361" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nq">访问令牌</em>的解码有效载荷的一个例子是:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="b16b" class="ne lo jj nw b gy oa ob l oc od">{  <br/>  <strong class="nw jk">"sub"</strong>:"1f0be62f-ffcd-49ca-b5a4-18f0bf62e0e6",<br/>  <strong class="nw jk">"token_use"</strong>:"access",<br/>  <strong class="nw jk">"scope"</strong>:"openid profile https://cognito-demo-api.arronharden.com/hello-world.all email",<br/>  <strong class="nw jk">"auth_time"</strong>:1565020449,<br/>  <strong class="nw jk">"iss"</strong>:"https://cognito-idp.eu-west-2.amazonaws.com/eu-west-2_z1Go5XdrZ",<br/>  <strong class="nw jk">"exp"</strong>:1565024049,<br/>  <strong class="nw jk">"iat"</strong>:1565020449,<br/>  <strong class="nw jk">"version"</strong>:2,<br/>  <strong class="nw jk">"jti"</strong>:"bb8bade7-2514-4152-8a41-a1524bf43f21",<br/>  <strong class="nw jk">"client_id"</strong>:"4tnp4k64d5v4ah9dud3pj1kbs0",<br/>  <strong class="nw jk">"username"</strong>:"arron"<br/>}</span></pre><p id="d731" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，当比较<em class="nq">访问令牌</em>和<em class="nq"> ID令牌</em>的有效载荷时，包含相同信息的一些属性的名称是如何不同的，例如<code class="fe oe of og nw b">client_id</code>对<code class="fe oe of og nw b">aud</code>和<code class="fe oe of og nw b">username</code>对<code class="fe oe of og nw b">cognito:username</code>。如果需要的话，<code class="fe oe of og nw b">token_use</code>属性可以用来确定提供了哪种类型的JWT访问代码。</p><h2 id="b4f8" class="ne lo jj bd lp nf ng dn lt nh ni dp lx kr nj nk mb kv nl nm mf kz nn no mj np bi translated">认知刷新令牌</h2><p id="ab66" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们的UI从Cognito收到的第三个JWT访问代码是一个<em class="nq">刷新令牌。</em>该令牌用于在原始令牌和<em class="nq">访问令牌</em>过期后获取新的<em class="nq"> ID令牌。<em class="nq">刷新令牌</em>实际上是加密的，这意味着只有Cognito服务能够看到有效负载的内容(您可以通过尝试jwt.io来确认这一点，jwt . io也无法解码它)。刷新令牌</em>本身具有更长的寿命，以天而不是分钟来计算，因此出于这个原因，必须格外小心以保持刷新令牌的秘密。</p><h1 id="d6e0" class="ln lo jj bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">验证认知JWT访问代码</h1><h2 id="1e46" class="ne lo jj bd lp nf ng dn lt nh ni dp lx kr nj nk mb kv nl nm mf kz nn no mj np bi translated">JWKS下载</h2><p id="0a2d" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在我们能够验证任何东西之前，我们需要做的第一件事是一次性下载与我们的Cognito用户池实例相关联的公钥信息。这些信息被称为JSON Web Key Set (JWKS ),可以通过在使用您的Cognito用户池的区域和ID构建的URL上发出GET请求来下载:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="e368" class="ne lo jj nw b gy oa ob l oc od">https://cognito-idp.&lt;region&gt;.amazonaws.com/&lt;user_pool_id&gt;<a class="ae jg" href="https://cognito-idp.eu-west-2.amazonaws.com/eu-west-2_z1Go5XdrZ/.well-known/jwks.json" rel="noopener ugc nofollow" target="_blank">/.well-known/jwks.json</a></span></pre><p id="5ba2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本系列文章的第一篇<a class="ae jg" href="https://medium.com/@arron.harden/aws-cognito-example-using-react-ui-and-node-js-rest-apis-part-1-cognito-setup-5597acb02db4" rel="noopener">文章</a>中输入我们创建的用户池的值，就会得到URL<a class="ae jg" href="https://cognito-idp.eu-west-2.amazonaws.com/eu-west-2_z1Go5XdrZ/.well-known/jwks.json" rel="noopener ugc nofollow" target="_blank">https://cogn ITO-IDP . eu-west-2 . Amazon AWS . com/eu-west-2 _ z1go 5 xdrz/。知名/jwks.json </a>。由于这些是公钥，因此无需任何授权令牌即可下载，URL将返回以下JWKS内容:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="1fb5" class="ne lo jj nw b gy oa ob l oc od">{  <br/>  <strong class="nw jk">"keys"</strong>:[  <br/>    {  <br/>      <strong class="nw jk">"alg"</strong>:"RS256",<br/>      <strong class="nw jk">"e"</strong>:"AQAB",<br/>      <strong class="nw jk">"kid"</strong>:"0n7zsh4x4eg5BFk3fOo6SKyi0zrG83DK+2C/5xmFqM0=",<br/>      <strong class="nw jk">"kty"</strong>:"RSA",<br/>      <strong class="nw jk">"n"</strong>:"tKQOwFsFCRSNiL18QN77UaYYQvBvgIr-ImRW-9Y6KnfYeS5Tk-O39JjllVCYNf6EB5xcZELQuaJmh_bm8uiOxFuk1t6pCghyQWUWU_uR8BRhrqxF-ugWbnWWfkGqPjMD9Tc3oGVIZRwqpXSXkGaid6DaqhkQIzrYQtPwUMge4w4oQgl5KuowBxrxjJdrRChi4FPABNoRaB8VJOHAgvoobP9VACRkooSXKz5b0aCzExuv5mkg8WnhJi_xQCjX41QX3RbpwvgoqPrCxYmCjngy5qwItsJSOozLdxwFp6EDQExp5VwRfd0xU112Ny0ea-EeDlgkQMgVLfvb7cOm74f5WQ",<br/>      <strong class="nw jk">"use"</strong>:"sig"<br/>    },<br/>    {  <br/>      <strong class="nw jk">"alg"</strong>:"RS256",<br/>      <strong class="nw jk">"e"</strong>:"AQAB",<br/>      <strong class="nw jk">"kid"</strong>:"iPeYlnLRSbCoyi+JdywuePKNdluh4+7tIPaOn8yWZuE=",<br/>      <strong class="nw jk">"kty"</strong>:"RSA",<br/>      <strong class="nw jk">"n"</strong>:"iPu6YsSrKbVMMMmhwcyQjdzJHY9y53nEj-oHF3VimQu8gZ0qXaQRckJudZ0AOzDHZvSfdP2mLUMa6HWa_1n7NNsBWCRWTjqOXex2iAOX2Ryo9Sa_pRmXOCEPAbQor2YdYQdKqetbUllhPXmzTRtCGEcXbn8bB40rhAAcRoFUhBqWyUxIQPzwZlhTzk41u5E0V3iIt2jnFTTXfxgHj2571VTCHYTyqdOqcmdx4zvVaY8SUEg-VFRy4GM76JBEgttv7AhPtRlGkhKgIpPb8UJPDXMdtfFaHPzWOGGe9qh1YsuCeEqIUCwTmhy4sO8yVn6ylhJZpFAF8zQLtxIvYRwzdw",<br/>      <strong class="nw jk">"use"</strong>:"sig"<br/>    }<br/>  ]<br/>}</span></pre><p id="f064" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">管理下载的JWKS内容有多种技术。对于这个例子，我们在应用程序启动时下载一次，将密钥转换成PEM容器(这是我们稍后使用的JWT库所需要的),并将其保存在内存中。</p><h2 id="bbf1" class="ne lo jj bd lp nf ng dn lt nh ni dp lx kr nj nk mb kv nl nm mf kz nn no mj np bi translated">JWT验证</h2><p id="f112" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">为了验证给定的JWT访问代码是否可信，我们需要在允许任何请求的API操作继续之前对其执行一些测试。</p><ol class=""><li id="0f3c" class="mq mr jj ki b kj kk kn ko kr ms kv mt kz mu ld oh mw mx my bi translated">验证使用JWT库可以解码访问代码。这验证了格式是好的，但是没有(还没有)验证内容没有被第三方篡改。</li><li id="0db3" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld oh mw mx my bi translated">验证JWT访问代码的头部包含一个<code class="fe oe of og nw b">kid</code>(密钥ID)，该ID与我们的Cognito用户池的JWKS内容中返回的ID相匹配。</li><li id="c9da" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld oh mw mx my bi translated">使用JWT图书馆来验证访问代码。这将验证:</li></ol><ul class=""><li id="b030" class="mq mr jj ki b kj kk kn ko kr ms kv mt kz mu ld mv mw mx my bi translated">可以使用我们之前从Cognito用户池的JWKS内容中下载并缓存的公钥来验证签名。这确认了没有篡改，也确认了它是由我们的用户池实例签名的。</li><li id="f5ee" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">发卡行声明(<code class="fe oe of og nw b">iss</code>)与我们的Cognito用户池实例相匹配。</li><li id="31be" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">访问代码没有过期。</li></ul><p id="ef2b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果以上都成功了，我们就可以确定JWT访问代码是从我们的Cognito用户池生成的，并且没有被篡改。因此，我们可以信任JWT接入码有效载荷中的所有内容。</p><h1 id="53c9" class="ln lo jj bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">创建JWT安全REST API</h1><p id="1b18" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">既然我们知道了验证JWT接入码需要做什么，我们就可以开始编码了。我们首先使用<code class="fe oe of og nw b">express</code> <a class="ae jg" href="https://expressjs.com/en/starter/generator.html" rel="noopener ugc nofollow" target="_blank"> CLI命令</a>创建一个新的skeleton Express应用程序。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="8224" class="ne lo jj nw b gy oa ob l oc od">express --no-view --git cognito-demo-service</span></pre><p id="e636" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给了我们一个现成的Node.js Express应用程序，它监听端点<code class="fe oe of og nw b">/users</code>。</p><p id="3449" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们希望能够与UI应用程序同时在本地运行，所以我们将其更改为监听端口3010，而不是3000(修改<code class="fe oe of og nw b">/bin/www</code>)。我们还利用了<code class="fe oe of og nw b">cors</code>包，这样当REST API托管在<a class="ae jg" href="https://cognito-demo-api.arronharden.com" rel="noopener ugc nofollow" target="_blank">https://cognito-demo-api.arronharden.com</a>上时，就可以从托管在不同域上的UI中调用它；https://cognito-demo.arronharden.com。这需要对<code class="fe oe of og nw b">app.js</code>做一点小小的添加，以加入<code class="fe oe of og nw b">cors</code>中间件:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="96b2" class="ne lo jj nw b gy oa ob l oc od"><em class="nq">// Configure CORS for this service so our UI can make calls to us.<br/></em>var corsOptions = {<br/>  origin: [appConfig.signoutUri]<br/>}<br/>app.<strong class="nw jk">use</strong>(<strong class="nw jk">cors</strong>(corsOptions))</span></pre><h2 id="f77e" class="ne lo jj bd lp nf ng dn lt nh ni dp lx kr nj nk mb kv nl nm mf kz nn no mj np bi translated">快速中间件</h2><p id="d78a" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">接下来，我们定义我们的Express中间件。这将做两件事:</p><ul class=""><li id="0008" class="mq mr jj ki b kj kk kn ko kr ms kv mt kz mu ld mv mw mx my bi translated">验证传入的REST API调用上的JWT访问代码。我们将它定义为设置在<code class="fe oe of og nw b">Authorization</code>报头上，包括前缀<code class="fe oe of og nw b">Bearer</code>，后跟JWT访问码。</li><li id="1000" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">从JWT访问代码中提取声明，并将它们设置到传入请求对象上名为<code class="fe oe of og nw b">user</code>的对象中。这允许任何下游中间件或处理程序直接从请求中访问解码的信息。</li></ul><p id="bd06" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在自包含模块中定义我们的中间件，其入口点是<code class="fe oe of og nw b">getVerifyMiddleware()</code>。这将启动JWKS内容的下载，并返回Express要使用的中间件功能。</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">创建并返回验证中间件</figcaption></figure><p id="3f21" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将中间件功能包含在<code class="fe oe of og nw b">app.js</code>中<code class="fe oe of og nw b">/users</code>端点的路由器之前，可以轻松地将其插入Express:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="2011" class="ne lo jj nw b gy oa ob l oc od">const cognitoAuthMiddleware = cognitoAuth.<strong class="nw jk">getVerifyMiddleware</strong>()<br/>app.<strong class="nw jk">use</strong>('/users', cognitoAuthMiddleware, usersRouter)</span></pre><p id="4f5b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当调用中间件时，调用<code class="fe oe of og nw b">_verifyMiddleware()</code>函数，该函数验证<code class="fe oe of og nw b">Authorization</code>头，如果成功，则在调用链中的下一个快速处理程序之前，使用<code class="fe oe of og nw b">next()</code>将解码的信息添加到请求对象中。另一方面，如果验证不成功，它会根据情况立即向调用者返回HTTP 401(未授权)或HTTP 500(内部服务器错误)响应，而不调用下一个处理程序。</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">调用中间件时的入口点— _verifyMiddleware()</figcaption></figure><p id="2692" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述<code class="fe oe of og nw b">Authorization</code>报头的实际验证由<code class="fe oe of og nw b">_verifyProm()</code>函数处理，该函数执行前面描述的JWT访问码验证步骤，并返回一个<em class="nq">承诺</em>，该承诺根据验证是否成功而被解决或拒绝。</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">验证授权头— _verifyProm()</figcaption></figure><p id="0546" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得一提的是，在失败的情况下，我们将大多数诊断和错误信息保存在我们的私有应用程序日志中。返回给REST API调用者的错误包含最少的信息，因为我们不想在无意中帮助恶意用户的情况下提供太多帮助。</p><h2 id="6bb6" class="ne lo jj bd lp nf ng dn lt nh ni dp lx kr nj nk mb kv nl nm mf kz nn no mj np bi translated">在API中使用声明</h2><p id="792f" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">到目前为止，我们所做的只是允许或拒绝传入的API调用，这很好，但是我们现在也可以在API实现本身中使用JWT访问代码中的声明。我们可以通过简单地检查由我们的中间件添加到请求中的<code class="fe oe of og nw b">user</code>对象的内容来做到这一点。在本例中，我们将简单地在响应中返回<code class="fe oe of og nw b">user</code>对象的内容，以演示如何从下游处理程序访问它:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="aefc" class="ne lo jj nw b gy oa ob l oc od"><em class="nq">/* GET users listing. */<br/></em>router.<strong class="nw jk">get</strong>('/', function (req, res, next) {<br/>  <em class="nq">// Here we can check the req.user.scope array contains the scope<br/>  // relevant for the REST API operation being invoked<br/>  </em>res.<strong class="nw jk">send</strong>('Successfully verified JWT token. Extracted information '<br/>    + JSON.<strong class="nw jk">stringify</strong>(req.user))<br/>})</span></pre><h2 id="e484" class="ne lo jj bd lp nf ng dn lt nh ni dp lx kr nj nk mb kv nl nm mf kz nn no mj np bi translated">使用curl调用</h2><p id="0b53" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">有了这些改变，我们现在准备尝试调用<code class="fe oe of og nw b">/users</code> API。但是在我们开始改变用户界面来做到这一点之前，我想确保我们在这项服务中的工作如我们所预期的那样，所以我们可以尝试几个快速的<code class="fe oe of og nw b">curl</code>命令来进行测试。</p><p id="44aa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在成功的情况下，我们在<code class="fe oe of og nw b">Authorization</code>报头中传递一个有效的无记名令牌:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="4252" class="ne lo jj nw b gy oa ob l oc od">$ curl -H "Authorization:Bearer eyJraWQiOiJpUGVZbG5MUlNiQ295aStKZHl3dWVQS05kbHVoNCs3dElQYU9uOHlXWnVFPSIsImFsZyI6IlJTMjU2In0.eyJzdWIiOiIxZjBiZTYyZi1mZmNkLTQ5Y2EtYjVhNC0xOGYwYmY2MmUwZTYiLCJ0b2tlbl91c2UiOiJhY2Nlc3MiLCJzY29wZSI6Im9wZW5pZCBwcm9maWxlIGh0dHBzOlwvXC9jb2duaXRvLWRlbW8tYXBpLmFycm9uaGFyZGVuLmNvbVwvaGVsbG8td29ybGQuYWxsIGVtYWlsIiwiYXV0aF90aW1lIjoxNTY1Nzk0Nzg3LCJpc3MiOiJodHRwczpcL1wvY29nbml0by1pZHAuZXUtd2VzdC0yLmFtYXpvbmF3cy5jb21cL2V1LXdlc3QtMl96MUdvNVhkcloiLCJleHAiOjE1NjU3OTgzODcsImlhdCI6MTU2NTc5NDc4NywidmVyc2lvbiI6MiwianRpIjoiMDJkODk3OTQtMzIyNy00MTVlLWE1N2UtNGI1YzhlZmU2MGVjIiwiY2xpZW50X2lkIjoiNHRucDRrNjRkNXY0YWg5ZHVkM3BqMWticzAiLCJ1c2VybmFtZSI6ImFycm9uIn0.FmV1wxFHuZWYhVIdR9JnVHBzhbaoJlaUe-aw3yUte__2tRHo-zw6KyyDXQycdZ0JOo8S054mtESdYhJTc4-WTn89ymKUiXLgJXooA7w0cSI2vku1te97loPr5qqh-pnvrtf2XadDjp63lEeUG3Hq9HZEGDbyEUURPL5jMPZrbUnJevKanmPNfJRouHv2OBK6fzq79LnllmGi-_iQo_hu5NBfR6Erx33JbPcVBnw8t9o0JF4rqNPJbYT7qIXXNpRJtMzYVeY6hgfo85eq1h83DouTP3qmyiWYXBg98FoEXq-ROHq2g1E1qPasdi6IO0afqqrkYG8QaNfgGxomlehDtg" <a class="ae jg" href="http://localhost:3010/users" rel="noopener ugc nofollow" target="_blank">http://localhost:3010/users</a><br/>Successfully verified JWT token. Extracted information: {"sub":"1f0be62f-ffcd-49ca-b5a4-18f0bf62e0e6","token_use":"access","scope":["openid","profile","https://cognito-demo-api.arronharden.com/hello-world.all","email"],"username":"arron"}</span></pre><p id="2cd4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要忘记失败的情况，我们传递一个无效的JWT访问代码:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="e208" class="ne lo jj nw b gy oa ob l oc od">$ curl -H "Authorization:Bearer badbadbad" <a class="ae jg" href="http://localhost:3010/users" rel="noopener ugc nofollow" target="_blank">http://localhost:3010/users</a><br/>Authorization header contains an invalid JWT token.</span></pre><p id="2a21" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Node.js控制台中，我们还可以看到相应的调试输出，显示200 HTTP响应和401 HTTP响应:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="e573" class="ne lo jj nw b gy oa ob l oc od">Valid JWT token. Decoded: {"sub":"1f0be62f-ffcd-49ca-b5a4-18f0bf62e0e6","token_use":"access","scope":"openid profile <a class="ae jg" href="https://cognito-demo-api.arronharden.com/hello-world.all" rel="noopener ugc nofollow" target="_blank">https://cognito-demo-api.arronharden.com/hello-world.all</a> email","auth_time":1565794787,"iss":"<a class="ae jg" href="https://cognito-idp.eu-west-2.amazonaws.com/eu-west-2_z1Go5XdrZ" rel="noopener ugc nofollow" target="_blank">https://cognito-idp.eu-west-2.amazonaws.com/eu-west-2_z1Go5XdrZ</a>","exp":1565798387,"iat":1565794787,"version":2,"jti":"02d89794-3227-415e-a57e-4b5c8efe60ec","client_id":"4tnp4k64d5v4ah9dud3pj1kbs0","username":"arron"}.<br/>GET /users <strong class="nw jk">200</strong> 1.108 ms - 238<br/>Invalid JWT token. jwt.decode() failure.<br/>GET /users <strong class="nw jk">401</strong> 0.882 ms - 51</span></pre><h1 id="257a" class="ln lo jj bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">从UI调用JWT安全REST API</h1><p id="8c40" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">现在我们已经有了我们支持的REST API服务，从我们的示例React UI中使用它是一件相对简单的事情。</p><p id="0b1f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们修改<code class="fe oe of og nw b">getCognitoSession()</code>函数来返回JWT访问代码，这样它们就可以在Redux store中使用了。然后我们更新<em class="nq"> Home </em>组件，这样如果用户登录，就会调用<code class="fe oe of og nw b">/users</code> API并使用<code class="fe oe of og nw b">setState()</code>方法存储响应。</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">使用JWT访问代码调用REST API的主页组件</figcaption></figure><p id="5710" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">剩下的只是更新<em class="nq"> Home </em>组件的<code class="fe oe of og nw b">render()</code>方法，以显示我们从API调用中得到的响应。一切顺利，这应该是我们看到的从上面的<code class="fe oe of og nw b">curl</code>示例返回的相同文本。</p><figure class="nr ns nt nu gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">主页组件呈现REST API响应</figcaption></figure><p id="0b31" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行UI并进行登录，现在显示的是<em class="nq"> Home </em>组件，以及从REST API返回的响应，显示JWT访问代码已发送、解码、验证并提取了声明:</p><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/07570d659ec85220822d1798b64cdbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWUOel7PDagn4im_f8q8Wg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">更新的React UI显示成功的API响应</figcaption></figure><h1 id="df57" class="ln lo jj bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">摘要</h1><p id="d7a5" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们已经探索了AWS Cognito用户池的创建，它与基于React的单页面应用程序的集成，以及现在由Cognito发布的JWT访问代码保护的后端REST API的使用。</p><p id="5485" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用AWS API网关服务为我们做一些JWT的工作，但是我想在这篇文章中深入JWT的细节，所以我将把API网关服务的探索留到另一个时间。</p><h2 id="4650" class="ne lo jj bd lp nf ng dn lt nh ni dp lx kr nj nk mb kv nl nm mf kz nn no mj np bi translated">来源</h2><p id="08b5" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">这一系列文章中的所有源代码都可以在GitHub中找到:</p><ul class=""><li id="dcdd" class="mq mr jj ki b kj kk kn ko kr ms kv mt kz mu ld mv mw mx my bi translated">React UI应用程序来源:<a class="ae jg" href="https://github.com/arronharden/cognito-demo-ui" rel="noopener ugc nofollow" target="_blank">https://github.com/arronharden/cognito-demo-ui</a></li><li id="49e0" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">基于Express的REST API来源:【https://github.com/arronharden/cognito-demo-service T2】</li></ul><h2 id="1fcc" class="ne lo jj bd lp nf ng dn lt nh ni dp lx kr nj nk mb kv nl nm mf kz nn no mj np bi translated">实时实例</h2><p id="3546" class="pw-post-body-paragraph kg kh jj ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">这两个Node.js应用程序的实例都在AWS中运行，只要我的免费帐户保持活动状态，我就会努力让它们运行:</p><ul class=""><li id="7dbf" class="mq mr jj ki b kj kk kn ko kr ms kv mt kz mu ld mv mw mx my bi translated">React UI应用:【https://cognito-demo.arronharden.com T4】</li><li id="63b6" class="mq mr jj ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">基于Express的REST API:<a class="ae jg" href="https://cognito-demo-api.arronharden.com/" rel="noopener ugc nofollow" target="_blank">https://cognito-demo-api.arronharden.com</a></li></ul></div></div>    
</body>
</html>