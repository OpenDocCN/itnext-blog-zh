<html>
<head>
<title>API calls and HTTP Status codes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">API调用和HTTP状态代码</h1>
<blockquote>原文：<a href="https://itnext.io/api-calls-and-http-status-codes-e0240f78f585?source=collection_archive---------0-----------------------#2019-09-28">https://itnext.io/api-calls-and-http-status-codes-e0240f78f585?source=collection_archive---------0-----------------------#2019-09-28</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="f48b" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">为什么你不应该在几乎所有事情上使用状态200</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/4de2ac20f3dfe6ade0edc13852ab6a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w_iicbG7L3xEQTArjHUS6g.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">来源:https://www.youtube.com/watch?v=LtNSd_4txVc</figcaption></figure><p id="5ef7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这是一个我已经谈过很多次的话题，它通常以争论结束，因为它非常固执己见。</p><h2 id="ece3" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">使用案例</h2><p id="4c95" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">假设您有一个运行在某个web服务器上的API，不管是哪一个。除非您已经登录到web应用程序，否则无法访问登录端点和其他一些资源。要请求这些资源，您需要输入一些凭证、用户和密码，登录会被拒绝。</p><h2 id="000d" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">服务器应该返回什么状态代码？</h2><ul class=""><li id="88a1" class="mr ms ir kz b la mm ld mn lg mt lk mu lo mv ls mw mx my mz bi translated"><em class="na"> 200 </em>请求是<strong class="kz is">成功的</strong>，因为端点确实存在并进行一些内部验证，但是响应必须包括一些关于为什么访问被拒绝的信息。</li><li id="e586" class="mr ms ir kz b la nb ld nc lg nd lk ne lo nf ls mw mx my mz bi translated"><em class="na"> 401 </em>访问<strong class="kz is">未授权。</strong>回应中不需要额外信息。</li><li id="7e9b" class="mr ms ir kz b la nb ld nc lg nd lk ne lo nf ls mw mx my mz bi translated"><em class="na"> 403 </em>访问被<strong class="kz is">禁止</strong>并且响应包括关于访问被拒绝的信息。</li><li id="8867" class="mr ms ir kz b la nb ld nc lg nd lk ne lo nf ls mw mx my mz bi translated"><em class="na"> 503 </em>不能做任何事情，除非用户登录被验证和授权(<strong class="kz is">服务不可用</strong>)。</li><li id="333b" class="mr ms ir kz b la nb ld nc lg nd lk ne lo nf ls mw mx my mz bi translated">其他状态代码(让我们发挥创意)</li></ul><p id="c3f2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我在一些工作申请的技术测试中见过这种问题。</p><p id="031d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通常的答案在200和401状态代码之间有所不同，在两者之间也有一些变化。起初我回答说这取决于API实现，所以这两个代码都是有效的，但是第二个想法导致我的回答是401状态代码，带有一些额外的信息，尽管代码本身就足够了。</p><p id="0686" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了解释这一点，我将使用404代码作为参考，并用一个例子来说明。</p><h1 id="4b6d" class="ng lu ir bd lv nh ni nj ly nk nl nm mb jx nn jy me ka no kb mh kd np ke mk nq bi translated">图像服务器</h1><p id="3f83" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">假设您正在开发一个必须从API访问一些图像的应用程序。每个图像都保存在一个/img文件夹中，但是一些文件名带有“<em class="na"> protected- </em>”前缀的图像需要用户密码授权。</p><p id="e99e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">不管这些限制是如何实现的，你的应用程序都可以正常工作。(粗体字表示重要)</p><p id="a910" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">直接使用nginx配置，它会是<em class="na">类似于</em>的东西:</p><pre class="kh ki kj kk gu nr ns nt nu aw nv bi"><span id="0523" class="lt lu ir ns b gz nw nx l ny nz">location ~* \.(protected-.*\.)(jpg|gif|png)$ {<br/>  auth_basic “Restricted”;<br/>  auth_basic_user_file /etc/nginx/.htpasswd;<br/>}</span></pre><p id="e801" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Nginx配置就是这样，并不是说它和上面的代码一模一样，或者说代码会工作。<br/>基本上，它在所有匹配<em class="na"> protected-*的图像上应用一个基本的认证"<em class="na">安全</em>"层。* </em>如果需要这些图像中的任何一个，询问用户/密码对。<em class="na"> <br/> </em> Apache web服务器也有类似的东西。更多信息请访问:</p><ul class=""><li id="6e99" class="mr ms ir kz b la lb ld le lg oa lk ob lo oc ls mw mx my mz bi translated"><a class="ae kw" href="https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/" rel="noopener ugc nofollow" target="_blank">https://docs . nginx . com/nginx/admin-guide/security-controls/configuring-http-basic-authentic ation/</a></li><li id="9f0f" class="mr ms ir kz b la nb ld nc lg nd lk ne lo nf ls mw mx my mz bi translated"><a class="ae kw" href="https://www.journaldev.com/26342/nginx-location-directive#4-nginx-location-regex-example" rel="noopener ugc nofollow" target="_blank">https://www . journal dev . com/26342/nginx-location-directive # 4-nginx-location-regex-example</a></li></ul><p id="f3ba" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，如果应用程序请求文件<a class="ae kw" href="http://image-server/img/house.jpg" rel="noopener ugc nofollow" target="_blank">https://image-server/img/house . jpg</a>，它应该返回200状态和请求的文件house.jpg</p><p id="2309" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果应用程序请求文件<a class="ae kw" href="https://image-server/img/protected-secret.png" rel="noopener ugc nofollow" target="_blank">https://image-server/img/protected-secret . png</a>，它应该返回一个401代码并要求用户凭证。如果给定了用户凭证(作为授权头),但登录失败，则返回401代码。如果登录成功，请求将返回200代码和请求的protected-secret.png文件(如果文件存在，否则应该返回404)。</p><p id="0fe9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">假设应用程序请求文件<em class="na"> yoda.gif </em>，而服务器上没有yoda文件。你会得到一个404代码，文件/资源没有找到。</p><p id="2e1d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于一个不存在的<em class="na">protected-vader.jpg</em>文件的请求呢？它将首先要求凭证(这是一个401代码)，如果凭证被成功验证，一个404代码，因为没有找到资源。</p><h1 id="4586" class="ng lu ir bd lv nh ni nj ly nk nl nm mb jx nn jy me ka no kb mh kd np ke mk nq bi translated">API调用是资源请求</h1><p id="bac2" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">对于服务器来说，每个端点都是一个资源，所以每个API调用也是一个资源请求。所以最后，你的资源是如何被服务的并不重要，除非你想对每件事都使用错误的代码，比如成功的请求使用400(<strong class="kz is"><em class="na">请不要… </em> </strong>)。</p><p id="f8a8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了解释这一点，我将展示另一个同样的实现。为此，我将使用NodeJS和Express，你可以用任何其他语言做同样的事情。</p><pre class="kh ki kj kk gu nr ns nt nu aw nv bi"><span id="8c38" class="lt lu ir ns b gz nw nx l ny nz">// […]<br/>// Libraries, requires and else above this lines<br/>// WARNING: This is not a complete copy &amp; pastable code</span><span id="158b" class="lt lu ir ns b gz od nx l ny nz">const validatePwd = (req, res, next) =&gt; {<br/>  // do validation pseudo-code ahead<br/>  // check if file has to be protected<br/>  if((req.param[‘imgfile’]).indexOf(‘protected-’) === 0){<br/>    // validate user and password<br/>    if( user:password are not authorized) {<br/>      res.status(401)<br/>       .json({<br/>         statusCode: 401,<br/>         error: true,<br/>         msg: ‘Invalid credentials’<br/>      });<br/>    }</span><span id="bc52" class="lt lu ir ns b gz od nx l ny nz">  }<br/>  // else continue<br/>  next();</span><span id="5748" class="lt lu ir ns b gz od nx l ny nz">};</span><span id="7cf6" class="lt lu ir ns b gz od nx l ny nz">app.get(‘/img/:imgfile’, validatePwd, (req, res) =&gt; {<br/>  // if the endpoint flow has continued here it means the file <br/>  // is not protected, or that user:password are valid</span><span id="8fa6" class="lt lu ir ns b gz od nx l ny nz">  // Build a real file path to get the image file. storagepath <br/>  // is the real folder where images are stored<br/>  let imgpath = path.join(storagepath, req.params[‘imgfile’]);</span><span id="7042" class="lt lu ir ns b gz od nx l ny nz">  // Return the image file only if it exists, otherwise return a 404<br/>  if(fs.existsSync(imgpath)){<br/>    res.writeHead(200, {‘content-type’:’image’});<br/>    fs.createReadStream(img).pipe(res);<br/>  } else {<br/>    // File does not exist<br/>    res.status(404)<br/>      .json({<br/>        statusCode: 404,<br/>        error: true,<br/>        msg: `File ${req.params[‘imgfile’]} not found`</span><span id="9d15" class="lt lu ir ns b gz od nx l ny nz">    });</span><span id="502b" class="lt lu ir ns b gz od nx l ny nz">  }<br/>});</span></pre><p id="35fc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="na">但是请等待，即使凭证被正确验证并且访问被授权，如果对不存在的文件(如protected-vader.jpg)发出请求，该请求将通过现有的API端点提供服务。那不应该返回一个200的代码吗？API端点确实存在，并且它已经执行了所有必需的操作来验证凭据和文件是否存在。</em></p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj oe"><img src="../Images/f0b169c365d9dea3cd9a59b4696e327b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*bn0qeQyYz00x3biitbeIsw.gif"/></div></figure><p id="d203" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">没错。我一直都是这个意思。端点(在这个上下文中我更喜欢称它们为资源)<strong class="kz is">确实存在</strong>。</p><p id="fddc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你对HTTP 状态码的理解仅限于:</p><ul class=""><li id="15cd" class="mr ms ir kz b la lb ld le lg oa lk ob lo oc ls mw mx my mz bi translated"><em class="na"> 200资源存在(并处理请求)</em></li><li id="f9df" class="mr ms ir kz b la nb ld nc lg nd lk ne lo nf ls mw mx my mz bi translated">资源不存在</li></ul><p id="fdb2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">关于后端web开发，至少有一些东西是你不明白的。</p><p id="9cf7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="na"> /img/:imgfile </em> </strong>端点会一直存在，它会一直发送响应。但是，如果文件不存在，那么这种带有额外信息的200代码的响应是没有意义的，这就像成功和失败都有相同的答案一样:</p><p id="38ec" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="na"> 200:拇指好，你的请求成功<br/></em></p><p id="38f4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这同样适用于服务器授权，并且想不出任何HTTP状态代码可以避开这个逻辑。对您的<em class="na"> API </em>正在处理的每个请求都响应200是没有意义的。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj of"><img src="../Images/6263c63719e01d89cf1f79b6ed07e1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*JAxOVyDrMfCKtGGtoLZxLg.jpeg"/></div></figure><p id="006e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果发生这种情况，每个客户端应用程序都应该在内部处理错误，就像它们是成功的请求一样，并且代码立即变得紧密耦合，以至于更改<em class="na"> API </em>(考虑到<strong class="kz is"> <em class="na">图像服务器</em> </strong>部分的基本要求)将需要为<em class="na"> API </em>调用重写应用程序的代码。</p><p id="5fba" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于您正在编写的任何代码来说，紧耦合都不是一个好兆头。</p><p id="2f2c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">大多数时候，如果我必须设计一个API，我会考虑如何使用简单的服务器配置来解决这个问题；如果需要任何额外的信息作为响应，我通常会发送一些内部状态代码和消息，以及请求正在应答的任何额外数据。</p><p id="eba5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于每个请求来说，code 200可能是有效响应代码的唯一场景是，当您不介意紧密耦合，也不介意重写客户端应用程序代码，或者您是负责开发API、应用程序等的唯一开发人员(并且您不介意吃自己的sh*t)。即使这样，我仍然不同意编写蹩脚的、紧耦合的代码；我永远也不会实施糟糕的开发实践。</p><p id="ab5d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">仔细考虑你的API响应代码；你身边的每一个使用你开发的API的开发者，都会为此感谢你(或者不会恨你，更少恨你，更爱你，等等)。)</p><p id="f1d8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">关于https://www.restapitutorial.com/httpstatuscodes.html<a class="ae kw" href="https://www.restapitutorial.com/httpstatuscodes.html" rel="noopener ugc nofollow" target="_blank">的进一步参考和说明</a></p></div></div>    
</body>
</html>