<html>
<head>
<title>React Sub Rendering: Simplifying complex render functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应子渲染:简化复杂的渲染功能</h1>
<blockquote>原文：<a href="https://itnext.io/react-sub-rendering-simplifying-complex-render-functions-8240fe8c82d4?source=collection_archive---------2-----------------------#2018-09-06">https://itnext.io/react-sub-rendering-simplifying-complex-render-functions-8240fe8c82d4?source=collection_archive---------2-----------------------#2018-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4446862539089b0b586f9dd66fc2b355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cpJ8Unas0i1o9X7LnhQQqg.png"/></div></div></figure><p id="40ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你有没有构建过一个带有渲染函数的React组件，这个渲染函数有一大堆杂乱的三元语句，用来根据你的组件状态决定渲染什么？别担心，这种事我们谁都会遇到的。</p><p id="bbb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将教你一个简单的技巧，你可以在有状态React组件中使用它来清理复杂的渲染逻辑。我称这种技术为“子渲染”。它来源于将大的复杂函数分成更小的简单子函数的过程。就像你把函数分成子函数一样，你也可以把渲染函数分成子渲染方法。</p><h1 id="baad" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">你想什么时候做？</h1><p id="1f47" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设我们有一个React组件，它使用外部API来获取结果列表。该组件在启动API调用之前，将在装载状态下启动。当被调用时，它应该返回一个带有结果的响应。但是这个API非常不稳定，所以如果出现错误，您还需要显示一些内容来处理错误。也有可能没有结果。在这种情况下，响应将是一个空数组。</p><p id="79da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该组件将有三种状态。这些状态是<code class="fe lz ma mb mc b">isLoading</code>、<code class="fe lz ma mb mc b">results</code>和<code class="fe lz ma mb mc b">hasError</code>。该组件还将利用其他地方定义的四个子组件(超出了本文的范围)。这些子组件是<code class="fe lz ma mb mc b">&lt;Loading /&gt;</code>、<code class="fe lz ma mb mc b">&lt;Results /&gt;</code>、<code class="fe lz ma mb mc b">&lt;NoResults /&gt;</code>和<code class="fe lz ma mb mc b">&lt;Error /&gt;</code>。除了<code class="fe lz ma mb mc b">&lt;Results /&gt;</code>组件，这些子组件都不需要任何道具。这只需要一个<code class="fe lz ma mb mc b">results</code> prop，它将是存储在主组件的<code class="fe lz ma mb mc b">results</code>状态中的响应有效负载。</p><p id="f55e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这有意义。让我们来谈谈不同的状态，以及它们应该如何影响最终呈现的内容。</p><h2 id="6d92" class="md kx iq bd ky me mf dn lc mg mh dp lg kj mi mj lk kn mk ml lo kr mm mn ls mo bi translated">正在加载</h2><p id="59d0" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><code class="fe lz ma mb mc b">isLoading</code>是一个布尔值，我们将其初始化为<code class="fe lz ma mb mc b">true</code>，因为当组件第一次挂载时，我们还没有获取结果。因此，在结果返回(满或空)或API调用出错之前，它一直保持为真。当这为真时，我们将渲染<code class="fe lz ma mb mc b">&lt;Loading /&gt;</code>组件。</p><h2 id="38ed" class="md kx iq bd ky me mf dn lc mg mh dp lg kj mi mj lk kn mk ml lo kr mm mn ls mo bi translated">结果</h2><p id="b0d9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设API调用没有任何问题，我们应该会收到一个结果列表。因为它是一个列表，我们将它初始化为一个空数组(<code class="fe lz ma mb mc b">[]</code>)。我们这样做是因为我们希望API响应总是一个数组。在没有结果的情况下，我们的响应负载中仍然会有一个空数组。假设端点不再处于<code class="fe lz ma mb mc b">isLoading: true</code>状态，我们将在<code class="fe lz ma mb mc b">&lt;Results /&gt;</code>组件中呈现结果。如果响应负载是一个空数组，那么我们将转而呈现<code class="fe lz ma mb mc b">&lt;NoResults /&gt;</code>组件。</p><h2 id="87da" class="md kx iq bd ky me mf dn lc mg mh dp lg kj mi mj lk kn mk ml lo kr mm mn ls mo bi translated">哈泽罗</h2><p id="956f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们有<code class="fe lz ma mb mc b">hasError</code>布尔值，以防API调用过程中出现错误。这在组件状态下被初始化为<code class="fe lz ma mb mc b">false</code>，只有在API调用失败时才被设置为true。如果<code class="fe lz ma mb mc b">hasError</code>为真，我们将渲染<code class="fe lz ma mb mc b">&lt;Error /&gt;</code>组件。</p><h1 id="3f77" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">运行中的渲染功能</h1><p id="e184" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">好了，关于我们要做什么，我们已经说得够多了。现在让我们开始行动吧！</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/98c9954811517cae2c548bc9c76833b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/0*0yjUnpHlwBIPAMs2"/></div></figure><p id="078f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我将省略一些代码，如处理组件状态更改的导入和API逻辑。因为这里的重点是解释渲染逻辑。</p><p id="0d8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现此呈现逻辑的最常见方式是使用嵌套的三元语句来实现，如下所示:</p><pre class="mq mr ms mt gt mu mc mv mw aw mx bi"><span id="0193" class="md kx iq mc b gy my mz l na nb">class MyComponent extends Component {<br/>  state = {<br/>    hasError: false,<br/>    isLoading: true,<br/>    results: [],<br/>  }<!-- --> </span><span id="140f" class="md kx iq mc b gy nc mz l na nb">  componentDidMount() {<br/>    // implement API call logic here<br/>  }</span><span id="fd11" class="md kx iq mc b gy nc mz l na nb">  render() {<br/>    const { hasError, isLoading, results } = this.state;</span><span id="1a45" class="md kx iq mc b gy nc mz l na nb">    return (<br/>      &lt;Container&gt;<br/>        {isLoading ? &lt;Loading /&gt; :<br/>          &lt;&gt;<br/>            {hasError ? &lt;Error /&gt; :<br/>              &lt;&gt;<br/>                {results.length === 0 ? &lt;NoResults /&gt; :<br/>                  &lt;Results results={results} /&gt;<br/>                }<br/>              &lt;/&gt;<br/>            }<br/>          &lt;/&gt;<br/>        }<br/>      &lt;/Container&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="dfae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，如果你不熟悉<code class="fe lz ma mb mc b">&lt;&gt;...&lt;/&gt;</code>语法。这是React片段的速记语法，你可以在我写在这里的博客文章<a class="ae nd" href="https://www.barrymichaeldoyle.com/fragment" rel="noopener ugc nofollow" target="_blank">中读到关于它们的所有内容。</a>我还偷偷加入了一个<code class="fe lz ma mb mc b">&lt;Container&gt;</code>组件，作为一个样式包装器，让我们的组件稍微复杂一点，以便演示。</p><p id="4056" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不知道你怎么想，但我发现这种逻辑乍一看很难理解。当你在写它的时候，它是非常有意义的，但是两天后回顾它，你可能会质疑你的理智。如果你不明白，我把算法写成一个小片段，帮助你掌握。</p><pre class="mq mr ms mt gt mu mc mv mw aw mx bi"><span id="1882" class="md kx iq mc b gy my mz l na nb">if (isLoading) {<br/>  return &lt;Loading /&gt;;<br/>} if (hasError) {<br/>  return &lt;Error /&gt;;<br/>} if (results.length === 0) {<br/>  return &lt;NoResults /&gt;;<br/>}<br/>return &lt;Results results={results} /&gt;;</span></pre><p id="05e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在记住，当编译器遇到<code class="fe lz ma mb mc b">return</code>语句时，它会离开函数。这就是我不写<code class="fe lz ma mb mc b">else if</code>声明的原因。这实际上是一个惊人的解决方案，我们可以用它来代替上面使用的复杂的嵌套三元逻辑。</p><p id="f402" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">但是我们上面嵌套的三元逻辑被包裹在一个</strong> <code class="fe lz ma mb mc b"><strong class="ka ir">&lt;Container /&gt;</strong></code> <strong class="ka ir">组件中所以我们不能这样做。现在我们该怎么办？</strong></p><p id="6b2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有两种可能的选择。</p><h2 id="60cf" class="md kx iq bd ky me mf dn lc mg mh dp lg kj mi mj lk kn mk ml lo kr mm mn ls mo bi translated">选项1:将所有的逻辑从包装器移到它自己的组件中</h2><p id="90dc" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">将包装器中的逻辑移到它自己的组件中是一项非常简单的任务。唯一令人恼火的是，您必须将所有的状态属性传递给组件。但是即使这样做也不需要太多的努力，这要感谢我们奇妙的ES6能力，它允许我们散布道具。最后，这样做将为您留下以下简单的渲染函数:</p><pre class="mq mr ms mt gt mu mc mv mw aw mx bi"><span id="2390" class="md kx iq mc b gy my mz l na nb">render() {<br/>  return (<br/>    &lt;Container&gt;<br/>      &lt;ComponentRenderer {...this.state} /&gt;<br/>    &lt;/Container&gt;<br/>  );<br/>}</span></pre><p id="2696" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您会将您的<code class="fe lz ma mb mc b">&lt;ComponentRenderer&gt;</code>无状态功能组件写成这样:</p><pre class="mq mr ms mt gt mu mc mv mw aw mx bi"><span id="4615" class="md kx iq mc b gy my mz l na nb">const ComponentRenderer = ({ hasError, isLoading, results }) =&gt; {<br/>  if (isLoading) {<br/>    return &lt;Loading /&gt;;<br/>  } if (hasError) {<br/>    return &lt;Error /&gt;;<br/>  } if (results.length === 0) {<br/>    return &lt;NoResults /&gt;;<br/>  }<br/>  return &lt;Results results={results} /&gt;;<br/>}</span></pre><p id="682d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个非常好的解决方案。我推荐它而不是我们最初的解决方案，因为从程序员的角度来看，它更容易逻辑阅读。它将渲染内容的逻辑移出了JSX，这肯定比将所有内容都放在JSX更好。</p><p id="462e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是还有另一种解决方案，它不需要创建一个全新的组件。</p><h2 id="ccda" class="md kx iq bd ky me mf dn lc mg mh dp lg kj mi mj lk kn mk ml lo kr mm mn ls mo bi translated">选项2:实现子渲染</h2><p id="f818" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在我开始谈论选项1切线之前，我确实是从子渲染开始这篇文章的。所以让我们回到正题！我将首先向您展示完整的示例，因为它几乎不言自明:</p><pre class="mq mr ms mt gt mu mc mv mw aw mx bi"><span id="8b78" class="md kx iq mc b gy my mz l na nb">class MyComponent extends Component {<br/>  state = {<br/>    hasError: false,<br/>    isLoading: true,<br/>    results: [],<br/>  }</span><span id="8d07" class="md kx iq mc b gy nc mz l na nb">  componentDidMount() {<br/>    // implement API call logic here<br/>  }</span><span id="6135" class="md kx iq mc b gy nc mz l na nb">  renderResults() {<br/>    const { hasError, isLoading, results } = this.state;</span><span id="cfff" class="md kx iq mc b gy nc mz l na nb">    if (isLoading) return &lt;Loading /&gt;;<br/>    if (hasError) return &lt;Error /&gt;;<br/>    if (results.length &lt; 1) return &lt;NoResults /&gt;;<br/>    return &lt;Results results={results} /&gt;;<br/>  }</span><span id="de33" class="md kx iq mc b gy nc mz l na nb">  render() {<br/>    return (<br/>      &lt;Container&gt;<br/>        {this.renderResults()}<br/>      &lt;/Container&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="2107" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">告诉过你这是不言自明的。如果你理解你的JavaScript和React基础，那么这应该是有意义的。</p><p id="d38e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了好玩，我把<code class="fe lz ma mb mc b">results.length === 0</code>改成了<code class="fe lz ma mb mc b">results.length &lt; 1</code>。本质上，它们做的是同样的事情，但是我确信做一个比做另一个有一些可笑的微小的性能提升。见鬼，现在我受到启发去研究并写下它。好吧，我又忘乎所以了。</p><p id="544a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个解决方案的优点是——就像选项1一样——它非常干净。您不需要创建一个全新的组件。最好的部分，你不需要传递任何参数！<code class="fe lz ma mb mc b">renderResults</code>事件处理程序已经可以通过<code class="fe lz ma mb mc b">this</code>访问组件的<code class="fe lz ma mb mc b">state</code>。如果你读过我关于<a class="ae nd" href="https://www.barrymichaeldoyle.com/bind-this" rel="noopener ugc nofollow" target="_blank">绑定这个</a>的帖子，这是一个不需要绑定到<code class="fe lz ma mb mc b">this</code>的事件处理程序的很好的例子。</p><h2 id="843c" class="md kx iq bd ky me mf dn lc mg mh dp lg kj mi mj lk kn mk ml lo kr mm mn ls mo bi translated">选项3:在每个单独的子组件中处理渲染逻辑</h2><p id="d2c4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">大声喊出来，Julius Koronci 对我的原始帖子发表了评论，指出了这个技巧。谢谢你帮我扩展这篇文章！</p><p id="9e37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简化渲染逻辑的另一种方法是将该逻辑移到需要渲染的上下文中。像这样:</p><pre class="mq mr ms mt gt mu mc mv mw aw mx bi"><span id="1e32" class="md kx iq mc b gy my mz l na nb">class MyComponent extends Component {<br/>  state = {<br/>    hasError: false,<br/>    isLoading: true,<br/>    results: [],<br/>  }<br/>  <br/>  componentDidMount() {<br/>    // implement API call logic here<br/>  }</span><span id="58c3" class="md kx iq mc b gy nc mz l na nb">render() {<br/>    const { hasError, isLoading, results } = this.state;</span><span id="c5e2" class="md kx iq mc b gy nc mz l na nb">return (<br/>      &lt;Container&gt;<br/>        &lt;Loading isLoading={isLoading} /&gt;<br/>        &lt;Error hasError={hasError} /&gt;<br/>        &lt;Results {...this.state} /&gt;<br/>      &lt;/Container&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="edc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们“渲染”每个子组件。不完全是。我们现在做的是将渲染逻辑移到子组件级别。例如，通过向子组件发送<code class="fe lz ma mb mc b">isLoading</code>道具来呈现<code class="fe lz ma mb mc b">&lt;Loading&gt;</code>子组件。在<code class="fe lz ma mb mc b">&lt;Loading&gt;</code>子组件中，我们将使用<code class="fe lz ma mb mc b">isLoading</code>道具来决定渲染什么。如果<code class="fe lz ma mb mc b">isLoading</code>为<code class="fe lz ma mb mc b">true</code>，返回加载组件内容。如果<code class="fe lz ma mb mc b">isLoading</code>为<code class="fe lz ma mb mc b">false</code>，则返回<code class="fe lz ma mb mc b">null</code>，即不渲染任何内容。</p><p id="d5c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该加载组件将被实现为无状态功能组件，如下所示:</p><pre class="mq mr ms mt gt mu mc mv mw aw mx bi"><span id="b174" class="md kx iq mc b gy my mz l na nb">const Loading = ({ isLoading }) =&gt; {<br/>  if (isLoading) {<br/>    return &lt;LoadingContent /&gt;;<br/>  }</span><span id="6e60" class="md kx iq mc b gy nc mz l na nb">return null;<br/>}</span></pre><p id="83fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，是的，你可以把它变成一个三进制语句，让它适合一两行。但是重要的是保持代码的可读性，以便为您自己和以后遇到这个函数的其他开发人员节省时间。</p><p id="e708" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于这一点的另一个注意是关于如何实现<code class="fe lz ma mb mc b">&lt;Results /&gt;</code>组件有一些变化。我必须将所有状态值传递给它，因为它仍然需要检查是否基于<code class="fe lz ma mb mc b">isLoading</code>和<code class="fe lz ma mb mc b">hasError</code>状态进行渲染。如果<code class="fe lz ma mb mc b">isLoading</code>或<code class="fe lz ma mb mc b">hasError</code>为真，则返回<code class="fe lz ma mb mc b">null</code>。</p><p id="7875" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您仍然需要将逻辑向下移动到该组件中，以便不呈现任何结果。这最终把我们带回到最初的问题上。或者你可以重复自己的做法，在主组件中留下<code class="fe lz ma mb mc b">&lt;NoResults /&gt;</code>，也根据<code class="fe lz ma mb mc b">isLoading</code>、<code class="fe lz ma mb mc b">hasError</code>和<code class="fe lz ma mb mc b">results</code>的长度来渲染。</p><p id="7790" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，这仍然是清理主要组件的可行解决方案。但在我看来。与其说这是一个<em class="ne">收拾你的烂摊子</em>的解决方案，不如说是一个<em class="ne">移动你的烂摊子</em>的解决方案。这可能会影响组件的可重用性，基本上是选项1的解决方案的进一步分裂。</p><h1 id="e05c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="b319" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">根据这篇文章的标题，你可能已经猜到我会选择选项2中讨论的子渲染方法。我更喜欢它，因为它让事情变得简单，所有内容都在一个地方易于阅读。呈现逻辑的范围是主要组件的状态。因为状态决定了应该呈现什么，所以将呈现逻辑保持在同一级别是有意义的。我非常喜欢将组件拆分成更小的组件。但前提是它能让事情看起来更容易理解。</p><p id="295c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于React组件中的子渲染，我要说的就是这些。一旦你在实践中看到它，它是相当自明的。我希望你从这篇文章中学到了一些新东西。如果你喜欢它，那么一定要喜欢它，为它鼓掌并分享它！</p><p id="df01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的灵感来自于<a class="ae nd" href="https://amzn.to/2LxtXDo" rel="noopener ugc nofollow" target="_blank">Code Complete:A Practical Handbook of Software Construction，第二版</a>。这本书总是激励我变得更好。变得更好是很棒的，所以如果你还没有变得更好，那就去看看吧！</p><p id="83a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae nd" href="https://www.facebook.com/barrymichaeldoyle" rel="noopener ugc nofollow" target="_blank">脸书</a>、<a class="ae nd" href="https://twitter.com/barrymdoyle" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae nd" href="https://medium.com/@barrymdoyle" rel="noopener">媒体</a>、<a class="ae nd" href="https://www.youtube.com/barrymichaeldoyle?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> YouTube </a>上关注我，或者甚至在<a class="ae nd" href="https://www.linkedin.com/in/barry-michael-doyle-11369683/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系，以保持对我发布的新内容的更新。</p><p id="a56a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在下面的评论中让我知道你在处理渲染逻辑时更喜欢做什么。我还没有真正弄清楚在这里做事情的最佳实践方式是什么。但我确实相信，无论你选择哪条路，都应该是一致的！</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="5157" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ne">原载于2018年9月6日</em><a class="ae nd" href="https://www.barrymichaeldoyle.com/sub-rendering/" rel="noopener ugc nofollow" target="_blank"><em class="ne">www.barrymichaeldoyle.com</em></a><em class="ne">。</em></p></div></div>    
</body>
</html>