<html>
<head>
<title>Promise handlers for cleaner async syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更清晰的异步语法的承诺处理程序</h1>
<blockquote>原文：<a href="https://itnext.io/promise-handlers-for-cleaner-async-syntax-771840da47b6?source=collection_archive---------2-----------------------#2022-04-22">https://itnext.io/promise-handlers-for-cleaner-async-syntax-771840da47b6?source=collection_archive---------2-----------------------#2022-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3bdb" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">使用指南</h2><div class=""/><div class=""><h2 id="1f3e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">await-wrapper是一个实用方法，允许更干净的承诺处理</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/24399bfa408dc914df8703157d0ec733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hx3bHMkQrS3pEmyxmLDsXw.png"/></div></div></figure><h2 id="e650" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">介绍</h2><p id="c372" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">当使用异步javascript时，有很多方法可以处理结果。我们可以使用回调并最终陷入回调地狱，我们可以连锁承诺，这很好，但最终会变得很长，或者我们可以使用异步/等待功能。很多时候使用async / await伴随着许多try / catch块，我们的代码最终看起来有点庞大。</p><p id="56cb" class="pw-post-body-paragraph ly lz it ma b mb mr kd md me ms kg mg lm mt mi mj lq mu ml mm lu mv mo mp mq im bi translated">在本文中，我们将看看这三种方法，然后看看一个帮助器方法，它将让您编写的代码看起来几乎是同步的。</p><h2 id="4d21" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">复试</h2><p id="62a6" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">只是谷歌回调地狱，这就是我要说的。</p><h2 id="71b3" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">承诺链</h2><p id="872b" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">使用承诺时最常见的方法是使用承诺链。承诺链是一段调用异步函数然后使用。然后还是。捕捉运算符。下面是一个有很大链条的承诺的例子。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mw"><img src="../Images/a469e65e73b96a71e097e42014434d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rlNjMeVyQJhA0EdgJL1sw.png"/></div></div></figure><p id="4d19" class="pw-post-body-paragraph ly lz it ma b mb mr kd md me ms kg mg lm mt mi mj lq mu ml mm lu mv mo mp mq im bi translated">链式方法是一种处理承诺的好方法，但它遭受了与回调地狱相同的命运，最终你有了一个承诺，它调用了一个承诺，调用了一个承诺，链条就这样继续下去。</p><h2 id="1b38" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">异步/等待</h2><p id="c8df" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">“promise进化”的下一步是异步await语法。这种语法允许开发人员摆脱承诺链，并且“看起来”是同步的。但是，它可能会变得很庞大，因为大多数异步await方法都需要一个try / catch块。promise方法提供的捕获。</p><p id="42f5" class="pw-post-body-paragraph ly lz it ma b mb mr kd md me ms kg mg lm mt mi mj lq mu ml mm lu mv mo mp mq im bi translated">有一个警告，这种语法只能在异步函数中使用。这意味着我们不需要调用一个承诺并链接它，而是必须编写一个函数，然后我们可以调用这个函数来调用我们的承诺。在下面的例子中，你可以看到一个异步函数的例子。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mx"><img src="../Images/e54768d11f3d1d3aed9d46247ffc0bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZY6xmGAeb7DOhTAX6zY09w.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated"><a class="ae nc" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fitnext.io%2Fasync-await-without-try-catch-in-javascript-6dcdf705f8b1&amp;psig=AOvVaw1NjxxjEpXh4a24tRjBQExC&amp;ust=1650706069926000&amp;source=images&amp;cd=vfe&amp;ved=0CAwQjRxqFwoTCMjassStp_cCFQAAAAAdAAAAABAr" rel="noopener ugc nofollow" target="_blank">学分</a></figcaption></figure><p id="863a" class="pw-post-body-paragraph ly lz it ma b mb mr kd md me ms kg mg lm mt mi mj lq mu ml mm lu mv mo mp mq im bi translated">然而，现在我们可以使用顶级等待。根据mozilla开发者文档，你现在可以在javascript模块中使用<a class="ae nc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await" rel="noopener ugc nofollow" target="_blank">顶级等待</a>。这允许您在不需要异步函数的情况下使用它。</p><h2 id="5066" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">awaitWrap</h2><p id="16ad" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">那么，在看到所有这些处理承诺的好方法之后，我们为什么还需要一个承诺处理器呢？答案是我们真的不知道，但是它可以很好地清理我们的代码，并提供一种处理错误和响应的好方法。</p><p id="7e01" class="pw-post-body-paragraph ly lz it ma b mb mr kd md me ms kg mg lm mt mi mj lq mu ml mm lu mv mo mp mq im bi translated">承诺处理器是一个简单的函数。它是一个将承诺作为参数并解决或拒绝它的函数。然而，我们并不只是返回值，而是返回一个包含该数据的对象。</p><p id="f506" class="pw-post-body-paragraph ly lz it ma b mb mr kd md me ms kg mg lm mt mi mj lq mu ml mm lu mv mo mp mq im bi translated">在下面的要点中，你可以看到一个简单的例子，说明如何使用这个包装函数来处理来自承诺的决议和拒绝。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="28ab" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">性能问题</h2><p id="f690" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">许多人可能注意到这个库的一件事是，我们实际上是在创造两个承诺。你原本要打电话的承诺和包装的等待。如果应用程序的性能是您的最高优先级，那么很容易传入resolveCallback或rejectCallback，当您使用返回的数据来控制代码流时，可以在处理程序中立即调用这些方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">等待带有回调的包装</figcaption></figure><h2 id="d14b" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">结论</h2><p id="c95c" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">一个人可以有太多的方式在他们的javascript代码中处理承诺。为了清理代码，我发现这个工具非常好用。如果你想使用它，可以通过NPM访问<a class="ae nc" href="https://www.npmjs.com/package/await-wrapper" rel="noopener ugc nofollow" target="_blank">。你也可以在</a><a class="ae nc" href="https://github.com/EvanBurbidge/await-wrapper" rel="noopener ugc nofollow" target="_blank"> Github这里</a>分叉代码。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="4e2f" class="pw-post-body-paragraph ly lz it ma b mb mr kd md me ms kg mg lm mt mi mj lq mu ml mm lu mv mo mp mq im bi translated">如果您想注册访问更多媒体内容，请点击以下<a class="ae nc" href="https://thewebuiguy.com/membership" rel="noopener ugc nofollow" target="_blank">链接</a>。这将使我能够写更多的故事，通过一个小的委员会从媒体。</p></div></div>    
</body>
</html>