<html>
<head>
<title>Using Rust and Ptrace to invoke Syscalls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust和Ptrace调用系统调用</h1>
<blockquote>原文：<a href="https://itnext.io/using-rust-and-ptrace-to-invoke-syscalls-262dc585fcd3?source=collection_archive---------0-----------------------#2022-11-11">https://itnext.io/using-rust-and-ptrace-to-invoke-syscalls-262dc585fcd3?source=collection_archive---------0-----------------------#2022-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6135c83a4feade7564f74cf0ac8a3611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfsWezPmKX0WjZb7pf6MIA.jpeg"/></div></div></figure><h1 id="5ad8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">🔊介绍</h1><p id="4f7e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky ir">预先警告本文将直接针对Linux </strong>🐧<strong class="ky ir"> x86_64 CPU架构发行版。</strong> <strong class="ky ir"> x86_32、ARM32和ARM64 CPU架构将无法工作</strong> <em class="lu">，但只要对代码稍加修改就绝对可行，以概括架构的特定寄存器结构和指令编码</em>。接下来，我在本教程中的设置将是一台windows机器，我将使用<a class="ae lv" href="https://learn.microsoft.com/en-us/windows/wsl/install" rel="noopener ugc nofollow" target="_blank"> WSL </a>加载一个我将要使用的<strong class="ky ir"> Ubuntu 20.04.4 LTS </strong>发行版。本文选择的语言将是<a class="ae lv" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Rust </strong> </a> <strong class="ky ir">。</strong>在撰写本文时，Rust的最新稳定版本是我将使用的<strong class="ky ir"> 1.65.0 </strong>。我使用的Rust Crate依赖项将引用它们各自的版本。如果你想跳过前面或者只看结果代码，完整的项目可以在<a class="ae lv" href="https://github.com/0xFounders/ptrace_syscalls" rel="noopener ugc nofollow" target="_blank">https://github.com/0xFounders/ptrace_syscalls</a>找到</p><h1 id="f391" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">📚旅程</h1><ol class=""><li id="b240" class="lw lx iq ky b kz la ld le lh ly ll lz lp ma lt mb mc md me bi translated">创建我们的测试受害者流程</li><li id="4337" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">创建我们的宿主进程</li><li id="08d7" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">在受害者进程中调用系统调用</li><li id="911c" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">指针参数</li><li id="a4c2" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">资源转储/未来阅读，未来工作</li></ol></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="fb4c" class="jy jz iq bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">🧪创建了我们的测试受害者流程</h1><p id="ba09" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于这个项目，我们需要一个过程来作为我们的测试。我们的测试过程最好是一个长时间运行的过程，用一些正常控制流的指示器来确认我们在增强后没有破坏任何东西。因此，由打印到控制台的简单无限while循环组成的程序将成为完美的测试受害者。</p><h2 id="fd5f" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">日志—<a class="ae lv" href="https://crates.io/crates/log" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/log</a></h2><p id="74d9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">日志箱只是一个轻型的<a class="ae lv" href="https://blessed.rs/crates" rel="noopener ugc nofollow" target="_blank">祝福</a>日志箱，我们将使用它来收集日志数据。它允许我们收集不同级别的可读性日志数据:跟踪、日志、信息、警告、错误。</p><h2 id="3010" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">漂亮_环境_记录者—<a class="ae lv" href="https://crates.io/crates/pretty_env_logger" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/pretty_env_logger</a></h2><p id="ac6c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">日志箱只是一个薄薄的门面，pretty_env_logger将实际处理收集的数据，并为我们输出到控制台。它也开箱即用，提供了很好的格式和颜色编码的文本。</p><h2 id="451e" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">履行</h2><p id="8344" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下面是我对测试的理想受害者过程的简单实现。请注意，我将与<a class="ae lv" href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html" rel="noopener ugc nofollow" target="_blank">货物工作区</a>一起工作，受害者箱和主人箱将一起在工作区。如果你想追求一个不同的工作流程，只要知道你如何运行你的货物应用程序可能会有所不同。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a6d4" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">为了检查完整性，下面是Visual Studio代码中的项目结构。请注意目标文件夹在父目录中，而不是在受害者文件夹下。这是因为我们的工作区工作流将所有成员构建输出收集到一个公共目标文件夹中。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/d12d7579d5b5677212a9279ab6be544e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzXEVDJFdzUGfOyYTvkStw.png"/></div></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="554a" class="jy jz iq bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">🏠创建我们的宿主进程</h1><h2 id="2b6d" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">Ptrace概述</h2><p id="c2b0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">从Linux手册页文档开始，我们可以快速了解Ptrace接口的一般设计意图。</p><p id="1dd9" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated"><a class="ae lv" href="https://man7.org/linux/man-pages/man2/ptrace.2.html" rel="noopener ugc nofollow" target="_blank">https://man7.org/linux/man-pages/man2/ptrace.2.html</a></p><blockquote class="nu nv nw"><p id="4c5a" class="kw kx lu ky b kz no lb lc ld np lf lg nx nq lj lk ny nr ln lo nz ns lr ls lt ij bi translated"><strong class="ky ir"> ptrace </strong>()系统调用提供了一种方法，通过这种方法，一个进程<br/>(“跟踪器”)可以观察和控制另一个<br/>进程(“被跟踪者”)的执行，并检查和更改被跟踪者的<br/>内存和寄存器。主要用于实现<br/>断点调试和系统调用跟踪。</p></blockquote><p id="aded" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">我们将挑战Ptrace的极限，以便在远程进程中从外部调用系统调用。例如，到本文结束时，我们将能够使用<a class="ae lv" href="https://man7.org/linux/man-pages/man2/mmap.2.html" rel="noopener ugc nofollow" target="_blank">mmap</a>/<a class="ae lv" href="https://man7.org/linux/man-pages/man3/munmap.3p.html" rel="noopener ugc nofollow" target="_blank">mun map</a>syscalls在用户空间进程中分配内存，并控制用户空间应用程序的指令指针和寄存器来调用任何任意的syscall。现在，我们将设置我们的主机简单地连接到进程，并检查当前控制流的寄存器。我们需要更多的板条箱来完成这项工作。</p><h2 id="8c9f" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">这个错误—<a class="ae lv" href="https://crates.io/crates/thiserror" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/thiserror</a></h2><p id="f662" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">另一个<a class="ae lv" href="https://blessed.rs/crates" rel="noopener ugc nofollow" target="_blank">受祝福的</a>板条箱</p><blockquote class="nu nv nw"><p id="3bba" class="kw kx lu ky b kz no lb lc ld np lf lg nx nq lj lk ny nr ln lo nz ns lr ls lt ij bi translated">为标准库的<code class="fe oa ob oc od b"><a class="ae lv" href="https://doc.rust-lang.org/std/error/trait.Error.html" rel="noopener ugc nofollow" target="_blank">std::error::Error</a></code>特征提供了一个方便的衍生宏。</p></blockquote><p id="1607" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">我们将使用此错误来促进错误处理，以提供一个没有恐慌的体验。</p><h2 id="4678" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">sysinfo—<a class="ae lv" href="https://crates.io/crates/sysinfo" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/sysinfo</a></h2><p id="3ecb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">sysinfo板条箱为我们提供了一个生活质量函数，通过名称而不是Pid来查找进程。这在快速构建原型时很有用，因为我们可以将目标流程名硬编码为“受害者”。你可以争论这是特性膨胀，包括整个机箱的依赖，仅仅通过名字获得一个进程的pid。我同意。但是，懒惰的🦥在实验时占上风…</p><h2 id="2ee3" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">https://crates.io/crates/nix</h2><p id="32ca" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">nix crate将为我们提供一些对ptrace的生活质量绑定，这些绑定抽象了一些功能，提供了更容易处理错误的结果类型。它还为页面和内存映射/保护提供了常量，我们将在后面的<em class="lu">指针参数</em>部分中用到。</p><h2 id="ea4c" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">履行</h2><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="af18" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">示范</h2><p id="0f9f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好极了，我们能够连接到受害者进程并截获它的当前寄存器，将它们打印到控制台。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/3c1fdb56ded53ad6c3a80279789ba553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xhh2-jVLXg2KebFuzmG8JA.jpeg"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">加入战斗，拦截记录</figcaption></figure><p id="604b" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">如果这对您毫无意义，我鼓励您看一看x86_64寄存器的结构。特别要注意rip寄存器，它是我们当前的指令指针，rax寄存器是返回值寄存器。一旦我们开始试图劫持受害者进程的控制流，rip寄存器就会引起我们的特别兴趣😈</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/d18aa6cc8f1e7b6a53746f86bfa42db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*ssNkUQJNS51XL0HskUumnw.jpeg"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">【https://web.stanford.edu/class/cs107/guide/x86-64.html T4】</figcaption></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="3f2e" class="jy jz iq bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">🖥️在受害者进程中调用系统调用</h1><h2 id="ba21" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">概观</h2><ol class=""><li id="bea1" class="lw lx iq ky b kz la ld le lh ly ll lz lp ma lt mb mc md me bi translated">使用ptrace拦截进程控制流并获取当前寄存器</li><li id="a7d3" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">缓存当前寄存器、当前指令指针和当前指令</li><li id="118d" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">将调用系统调用的汇编指令写入当前指令指针</li><li id="67ce" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">为syscall设置所有相应的寄存器参数</li><li id="845b" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">单步执行进程，期待SIGTRAP作为下一个信号</li><li id="2821" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">缓存结果寄存器作为系统调用的结果</li><li id="7ad8" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">恢复原始寄存器和原始指令，以继续正常的应用程序执行</li></ol><h2 id="85f6" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">系统调用程序集</h2><p id="3264" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">x86_64中syscall的操作码是0x0F05。因此，我们需要当前指令指针指向该操作码，以便将控制流转移到系统调用。我们不能简单地用ptrace写两个字节，因为它需要一个<em class="lu">字</em>，这个字很容易混淆，因为它实际上意味着x86_64上的u64。根据我在Windows生态系统中的经验，W  ORD通常指的是u16。这让我在这个项目中有些困惑。无论如何，我们可以轻松地将2字节操作码扩展为8字节，而无需任何操作指令NOP (0x90)。用NOP扩展指令以对齐它的技术有时被称为“NOP Sled”。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/e3ad0fa80276e8359f104d909f29c41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EoJ2DnEU2LupiUqlLa8Eg.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated"><a class="ae lv" href="https://www.felixcloutier.com/x86/syscall.html" rel="noopener ugc nofollow" target="_blank">https://www.felixcloutier.com/x86/syscall.html</a></figcaption></figure><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/56a75f7285e1b60bea5f2617f72e1137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RrUoXKa6K2uSdDrKK7c2Dw.jpeg"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">https://c9x.me/x86/html/file_module_x86_id_217.html<a class="ae lv" href="https://c9x.me/x86/html/file_module_x86_id_217.html" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><h2 id="05c7" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">系统调用—【https://crates.io/crates/syscalls T4】</h2><p id="4d67" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">系统调用箱将为相应的系统调用号/rax提供常量。请参考Sysno枚举在实现中的用法。</p><h2 id="53a6" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">履行</h2><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="df14" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">对于我们精明的读者来说，您将立即获得结果寄存器的rax值。rax寄存器将对应于syscall返回参数。在本例中，受害者进程的pid为13958，主机getpid syscall在rax寄存器中正确返回相同的PID 13958。我真的很感激你的理智检查，🧠.</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/e25fc411adfaabd231d695a0e9fe1d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nHgmhpYMKO9UjFkliN3Rg.jpeg"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">getpid系统调用</figcaption></figure><p id="27ff" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">现在系统调用接受一个参数怎么样，我将使用exit，其中第一个参数对应于应用程序退出代码。</p><pre class="ni nj nk nl gt on od oo bn op oq bi"><span id="1939" class="or jz iq od b be os ot l ou ov">sys_call(Sysno::exit, 42, 0, 0, 0, 0, 0)?;</span></pre><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/307e8a11f997918f6da2258dc821cc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSkVSFE47q98P1wlU-8IKA.jpeg"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">主机崩溃，受害者退出，但这是意料之中的，我们毕竟退出了。注意，退出代码是我们指定的整数42，所以参数被卡住了。</figcaption></figure><p id="4cda" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">嗯，一个自变量是输出变量的例子怎么样？我们可以使用<a class="ae lv" href="https://man7.org/linux/man-pages/man2/time.2.html" rel="noopener ugc nofollow" target="_blank">时间</a>系统调用。它需要一个指向time_t变量的指针来写入当前的unix时间戳。</p><pre class="ni nj nk nl gt on od oo bn op oq bi"><span id="5226" class="or jz iq od b be os ot l ou ov">// tyepdef time_t int64<br/>time_t time(time_t *tloc);</span></pre><p id="4f39" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">设置系统调用并提供输出变量</p><pre class="ni nj nk nl gt on od oo bn op oq bi"><span id="381a" class="or jz iq od b be os ot l ou ov">// Call time syscall<br/>let mut output = 0i64;<br/>let result = user_process.sys_call<br/> (Sysno::time, &amp;mut output as *mut _ as u64, 0, 0, 0, 0, 0)?;<br/>log::info!("Syscall Result: {:#?}", result);<br/>log::info!("Time: {}", output);</span></pre><p id="e352" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">还有…什么都没有？看起来不太对的时间是零。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/61844fe36cb9a8caef7fb26cfb866c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yf-m0S_nPnc81uYIUkzEOQ.jpeg"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">带有本地指针的时间系统调用</figcaption></figure><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/0e5b4e4345ff5a4f7fdf7f3a777c87b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*Se-pVNRqZf_n3guPAppjSw.jpeg"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">预期时间响应，unix i64时间戳</figcaption></figure><p id="10a9" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">如果我们运行date命令来输出当前的unix时间戳，我们可以注意到非常不同的输出。时间结果应该至少接近日期命令输出。除非我们在发烧的梦里😴回到1970年1月1日的午夜，时间不应该是0…</p><blockquote class="nu nv nw"><p id="a647" class="kw kx lu ky b kz no lb lc ld np lf lg nx nq lj lk ny nr ln lo nz ns lr ls lt ij bi translated">Unix时间是自1970年1月1日00:00:00 UTC以来经过的秒数，不包括闰秒。这个时间被命名为Unix纪元，因为它是Unix时间的开始。</p></blockquote><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oz"><img src="../Images/3d360ed282a095fc27ca142f8fa9a948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JoiB50Hqrkf-n7tv2PtzGw.jpeg"/></div></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d796" class="jy jz iq bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">↪️指针参数</h1><p id="2de2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">运行times syscall时出现问题的根本原因是我们在主机进程内存空间中指定了一个内存地址。同样，如果不使用特定的操作函数，我们就无法写入受害者进程内存，如果不使用这些操作，受害者也无法写入我们的主机进程内存。我们可以通过直接在受害者进程中分配内存并使用该空间的地址作为参数，然后从该内存中读取以检索输出来解决这个问题。毫不奇怪，我们将使用mmap和munmap系统调用来处理受害者进程中的数据管理。</p><h2 id="03b1" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated"><a class="ae lv" href="https://man7.org/linux/man-pages/man2/mmap.2.html" rel="noopener ugc nofollow" target="_blank"> Mmap </a></h2><blockquote class="nu nv nw"><p id="0810" class="kw kx lu ky b kz no lb lc ld np lf lg nx nq lj lk ny nr ln lo nz ns lr ls lt ij bi translated">mmap()在<br/>调用进程的虚拟地址空间中创建新的映射。新映射的起始地址是addr中指定的<br/>。length参数指定映射的<br/>长度(必须大于0)。</p><p id="cd38" class="kw kx lu ky b kz no lb lc ld np lf lg nx nq lj lk ny nr ln lo nz ns lr ls lt ij bi translated">如果addr为空，那么内核选择(页面对齐)<br/>地址来创建映射；这是创建新映射最方便的<br/>方法。</p></blockquote><pre class="ni nj nk nl gt on od oo bn op oq bi"><span id="2e1d" class="or jz iq od b be os ot l ou ov">void *mmap(void *addr, size_t length, int prot, int flags,<br/>                  int fd, off_t offset);</span></pre><h2 id="0dda" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">Munmap</h2><blockquote class="nu nv nw"><p id="54ed" class="kw kx lu ky b kz no lb lc ld np lf lg nx nq lj lk ny nr ln lo nz ns lr ls lt ij bi translated">函数munmap()应删除包含进程<br/>地址空间任何部分的整个<br/>页面的任何映射，从addr开始，一直到len字节。对这些页面的进一步引用<br/>将导致产生一个SIGSEGV信号<br/>给该过程。如果在指定的<br/>地址范围内没有映射，则munmap()无效。</p><p id="ec7b" class="kw kx lu ky b kz no lb lc ld np lf lg nx nq lj lk ny nr ln lo nz ns lr ls lt ij bi translated">实现可能要求addr是sysconf()返回的<br/>页面大小的倍数。</p></blockquote><pre class="ni nj nk nl gt on od oo bn op oq bi"><span id="0d37" class="or jz iq od b be os ot l ou ov">int munmap(void *addr, size_t len);</span></pre><h2 id="05b4" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">解决办法</h2><ol class=""><li id="3321" class="lw lx iq ky b kz la ld le lh ly ll lz lp ma lt mb mc md me bi translated">使用mmap syscall在受害者进程中保留虚拟内存</li><li id="f562" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">根据需要读取或写入虚拟内存</li><li id="1602" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt mb mc md me bi translated">从对我们在受害者中保留的虚拟内存的引用中提供syscall指针参数</li></ol><h2 id="b551" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">履行</h2><p id="3543" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们读写进程内存的⚠️How已经被重构为直接从进程的内存文件中读取。这将我们从ptrace的<em class="lu">字</em>大小限制<em class="lu">的要求中解放出来。</em>由于linux中的一切本质上都是文件，Rust的标准文件功能可以用来与进程的内存文件进行交互。这种实现上的改变将使我们与mmap内存的交互变得更加容易。这一变化的灵感来自牛逼的crate <a class="ae lv" href="https://crates.io/crates/pete" rel="noopener ugc nofollow" target="_blank"> pete </a>提供了更加详尽的安全rust ptrace api。pete板条箱的衍生代码将被相应地引用。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/c70ba75c8e4f4fe32e9d3e367286eebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*8_5k8vtlQfKF4Jr30L-_iA.jpeg"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">强制性Linux一切都是一个文件笑话</figcaption></figure><p id="a94a" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">⚠️In为了提供一个比较完整、正确的api，我们需要将大部分代码转移到一个单独的lib文件中，这样我们就有了一个namespace/mod文件来利用可见性修饰符。通过main.rs中的所有代码，main函数可以访问在实现中应该真正被视为私有的函数，因为它们是在同一个文件中定义的。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/23ebcc14de337d77a51bb1733d7c048b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TEWMLWhFr8GG5sNUJaMd4A.jpeg"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">真棒时间输出是现实的，而不是零d:)</figcaption></figure><p id="cb13" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">现在还有一个场景我们没有讨论，syscall中的输入指针参数怎么样。<a class="ae lv" href="https://linux.die.net/man/2/chdir" rel="noopener ugc nofollow" target="_blank"> chdir sycall </a>应该足够了。</p><pre class="ni nj nk nl gt on od oo bn op oq bi"><span id="be1f" class="or jz iq od b be os ot l ou ov">int chdir(const char *path);</span></pre><p id="ca0b" class="pw-post-body-paragraph kw kx iq ky b kz no lb lc ld np lf lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">并且，对main.rs wallah进行了一些小的编辑。</p><pre class="ni nj nk nl gt on od oo bn op oq bi"><span id="aa0a" class="or jz iq od b be os ot l ou ov">use std::ffi::CString;<br/><br/>use host::{HostError, HostResult, UserProcess};<br/>use nix::{<br/>    libc::{MAP_ANONYMOUS, MAP_PRIVATE, PROT_READ, PROT_WRITE},<br/>    unistd::Pid,<br/>};<br/>use syscalls::Sysno;<br/>use sysinfo::{ProcessExt, System, SystemExt};<br/><br/>fn main() -&gt; HostResult&lt;()&gt; {<br/>    pretty_env_logger::formatted_builder()<br/>        .filter_level(log::LevelFilter::Trace)<br/>        .init();<br/><br/>    let process_name = "victim";<br/>    log::info!("Host Process Pid: {}", std::process::id());<br/><br/>    // Create sysinfo object and refresh to collect current os state<br/>    let mut sys = System::new_all();<br/>    sys.refresh_all();<br/><br/>    // Find our target process or die<br/>    let process = sys<br/>        .processes_by_name(process_name)<br/>        .take(1)<br/>        .next()<br/>        .ok_or_else(|| HostError::ProcessNotFound(process_name.to_string()))?;<br/><br/>    // Cast our sysinfo::Pid into a nix::unistd::Pid<br/>    let pid = Pid::from_raw(process.pid().into());<br/><br/>    // Attach to the process<br/>    let user_process = UserProcess::attach(pid)?;<br/><br/>    // Refactor out the expect later, but the input should never fail because we know the input does not contain an internal 0 byte.<br/>    let output_message = CString::new("/home/chase").expect("CString::new failed");<br/><br/>    // We want the bytes of the Cstring.<br/>    let output_message = output_message.as_bytes();<br/><br/>    // Allocate 8 bytes of data, i64 is 8 bytes<br/>    let mut user_memory = user_process.allocate_memory(<br/>        0,<br/>        output_message.len() as u64,<br/>        (PROT_READ | PROT_WRITE) as u64,<br/>        (MAP_PRIVATE | MAP_ANONYMOUS) as u64,<br/>        u64::MAX,<br/>        0,<br/>    )?;<br/>    log::info!("UserMemory Result Address: {:#X}", user_memory.address());<br/><br/>    // Read the memory and demonstrate it is zero'd out<br/>    let read = user_process.read_user_memory(&amp;user_memory, user_memory.len() as usize)?;<br/>    log::info!("Allocated Memory: {:?}", read);<br/><br/>    // Write to the memory out cstring<br/>    user_process.write_user_memory(&amp;mut user_memory, 0, output_message)?;<br/><br/>    // We can check if the call succeeded by the resultant rax value.<br/>    let result = user_process<br/>        .sys_call(Sysno::chdir, user_memory.address(), 0, 0, 0, 0, 0)?<br/>        .rax;<br/><br/>    log::info!("Result {result:?}");<br/><br/>    Ok(())<br/>}</span></pre><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/8a70a92aa6e858284fbd9159e042dca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blsdCXEnfBxl-b2mC4LzFA.jpeg"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">在运行我们的程序后，进程的当前工作目录被改变，并显示我们期望的/home/chase</figcaption></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="c648" class="jy jz iq bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">结论</h1><p id="09ab" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们已经为在x86_64上使用ptrace在远程进程中调用syscall设计了一个相当不错的api。这很酷，但是我们目前受限于所提供的系统调用的能力。如果将来我们可以在受害者进程中调用用户空间函数，比如libc puts，这样我们就可以输出到受害者的控制台，这将非常有用。在下一篇文章中，我们将这样做，并学习如何识别外部进程中用户空间函数的地址，在受害者进程中使用调用<a class="ae lv" href="https://man7.org/linux/man-pages/man3/dlopen.3.html" rel="noopener ugc nofollow" target="_blank"> dlopen </a>来将任意共享对象加载到其地址空间中，这种技术被称为进程注入💉。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="a5c7" class="jy jz iq bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">资源转储/未来阅读，未来工作</h1><h2 id="8856" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">最终项目Github项目</h2><ul class=""><li id="7bb1" class="lw lx iq ky b kz la ld le lh ly ll lz lp ma lt pd mc md me bi translated">【https://github.com/0xFounders/ptrace_syscalls T4】</li></ul><h2 id="6319" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">资源</h2><ul class=""><li id="1f4a" class="lw lx iq ky b kz la ld le lh ly ll lz lp ma lt pd mc md me bi translated"><a class="ae lv" href="https://man7.org/linux/man-pages/man5/proc.5.html" rel="noopener ugc nofollow" target="_blank">https://man7.org/linux/man-pages/man5/proc.5.html</a></li><li id="37c8" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt pd mc md me bi translated"><a class="ae lv" href="https://hackeradam.com/x86-64-linux-syscalls/" rel="noopener ugc nofollow" target="_blank">https://hackeradam.com/x86-64-linux-syscalls/</a></li><li id="b5cf" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt pd mc md me bi translated"><a class="ae lv" href="https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-and-user-space-f" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/2535989/what-the-calling-conventions-for-UNIX-Linux-system-calls-and-user-space-f</a></li><li id="712d" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt pd mc md me bi translated"><a class="ae lv" href="https://blog.packagecloud.io/the-definitive-guide-to-linux-system-calls/" rel="noopener ugc nofollow" target="_blank">https://blog . package cloud . io/the-definitive-guide-to-Linux-system-calls/</a></li></ul><h2 id="12e1" class="mw jz iq bd ka mx my dn ke mz na dp ki lh nb nc km ll nd ne kq lp nf ng ku nh bi translated">未来的工作</h2><ul class=""><li id="ee77" class="lw lx iq ky b kz la ld le lh ly ll lz lp ma lt pd mc md me bi translated">支持x86_32</li><li id="55b3" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt pd mc md me bi translated">支撑臂32</li><li id="9876" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt pd mc md me bi translated">支撑臂64</li><li id="f830" class="lw lx iq ky b kz mf ld mg lh mh ll mi lp mj lt pd mc md me bi translated">(可能？)支持堆栈参数，例如，具有多于寄存器参数数量的syscall调用。我相对确定x86_64没有需要堆栈参数的系统调用，例如超过6个参数，尽管我不确定其他架构是否也是如此。</li></ul></div></div>    
</body>
</html>