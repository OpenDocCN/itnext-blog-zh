<html>
<head>
<title>Kubernetes explained deep enough: Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes解释得足够深刻:存储</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-explained-deep-enough-storage-eb16a66483c2?source=collection_archive---------2-----------------------#2021-01-08">https://itnext.io/kubernetes-explained-deep-enough-storage-eb16a66483c2?source=collection_archive---------2-----------------------#2021-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b13edf97611c2d12dc5a51657124485c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lsjEFol6Hj11gaifU2feQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图片来自<a class="ae jd" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1850170" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jd" href="https://pixabay.com/users/pexels-2286921/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1850170" rel="noopener ugc nofollow" target="_blank">像素</a></figcaption></figure><div class=""/><p id="a0ce" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第2部分:持久卷和持久卷声明</p><h1 id="d177" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">介绍</h1><p id="42e3" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是Kubernetes迷你系列的第二部<strong class="kf jh"> Kubernetes解释得够深刻了</strong></p><p id="a1ec" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于本博客的网络版以及关于docker、Kubernetes和Docker认证的更多信息，请访问:</p><div class="ip iq gp gr ir me"><a href="https://www.itcertificationsguide.com/#/" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd jh gy z fp mj fr fs mk fu fw jf bi translated">IT认证指南</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">描述</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">www.itcertificationsguide.com</p></div></div></div></a></div><p id="939b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://piotrzan.medium.com/kubernetes-explained-deep-enough-1ea2c6821501" rel="noopener">第一部分:简介</a></p><p id="eb7d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第2部分:Kubernetes解释得够深刻了:存储——这个博客</p><p id="b345" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://piotrzan.medium.com/kubernetes-explained-deep-enough-deployments-371755fbe2a3" rel="noopener">第三部分:Kubernetes解释得够深刻:部署</a></p><p id="f9d6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://piotrzan.medium.com/kubernetes-explained-deep-enough-configuration-cd4a9d1d8dcd" rel="noopener">第四部分:Kubernetes解释得够深刻:配置</a></p><p id="bc92" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://piotrzan.medium.com/kubernetes-explained-deep-enough-services-1a0647499616" rel="noopener">第5部分:服务可发现性、DNS、集群通信</a></p><blockquote class="mn mo mp"><p id="c9c3" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">如果您需要复习关于<a class="ae jd" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">持久卷</a>和<a class="ae jd" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims" rel="noopener ugc nofollow" target="_blank">持久卷声明</a>的内容，请访问Kubernetes文档</p><p id="1661" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">下图提供了基本定义</p></blockquote><h1 id="989b" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">它是如何工作的？</h1><p id="f413" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">集群管理员创建<em class="mq">持久卷</em>作为集群资源，开发人员使用<em class="mq">持久卷声明</em>来使用持久卷。这个过程有些手动，但是有一些方法可以通过<em class="mq">存储类和动态卷供应</em>来实现自动化，我们将在下一个练习中探讨这些方法。</p><p id="bb24" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图显示了pv、pvc、pod及其容器之间的典型交互，以创建、认领、使用和清理存储。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/965a2b422ad162e6f8750c672b63026b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFhNjKE6VGsctzY3TxfEOA.png"/></div></div></figure><h1 id="dfa6" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">它解决什么问题？</h1><p id="9140" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">PVs和PVC解决了几个问题:</p><ul class=""><li id="297d" class="mz na jg kf b kg kh kk kl ko nb ks nc kw nd la ne nf ng nh bi translated">销毁pod后启用持久化数据</li><li id="7eec" class="mz na jg kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated">将存储配置活动与其消耗分离开来(这使得集群管理员和开发人员之间的顾虑得以分离)</li><li id="2262" class="mz na jg kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated">启用pod之间的数据共享</li></ul><h1 id="e8f7" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何实施？</h1><h2 id="175f" class="nn lc jg bd ld no np dn lh nq nr dp ll ko ns nt lp ks nu nv lt kw nw nx lx ny bi translated">先决条件</h2><p id="8c92" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们将基于Azure AKS集群实现这个例子。</p><blockquote class="mn mo mp"><p id="3170" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated"><em class="jg">要使用terraform在Azure上创建AKS集群，请遵循</em> <a class="ae jd" href="https://piotrzan.medium.com/try-kubernetes-in-cloud-for-free-e5e431c507a7" rel="noopener"> <em class="jg">我的指南</em> </a> <em class="jg">或者使用</em> <a class="ae jd" href="https://docs.microsoft.com/en-us/azure/aks/kubernetes-walkthrough" rel="noopener ugc nofollow" target="_blank"> <em class="jg">微软AKS部署演练使用az CLI </em> </a></p></blockquote><p id="2d04" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将遵循上图中的步骤，看看这在实践中是如何工作的。</p><h2 id="0e3a" class="nn lc jg bd ld no np dn lh nq nr dp ll ko ns nt lp ks nu nv lt kw nw nx lx ny bi translated">创建Kubernetes资源</h2><p id="9193" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">此步骤假设您已经创建了带有文件共享的存储帐户，如果没有<a class="ae jd" href="https://docs.microsoft.com/en-us/azure/aks/azure-files-volume#create-an-azure-file-share" rel="noopener ugc nofollow" target="_blank">请按照以下步骤创建它</a>。</p><p id="e996" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建存储帐户和文件共享后，我们需要创建Kubernetes secret，并提供文件共享的凭据，以使pod能够访问文件共享</p><blockquote class="mn mo mp"><p id="8731" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated"><em class="jg">为了更容易地使用kubectl，我们将创建一个别名</em> <code class="fe nz oa ob oc b"><em class="jg">alias k=kubectl</em></code></p></blockquote><pre class="mv mw mx my gt od oc oe of aw og bi"><span id="b246" class="nn lc jg oc b gy oh oi l oj ok"># Define variables<br/>RG="&lt;resource group name where storage account is&gt;"<br/>AKS_PERS_STORAGE_ACCOUNT_NAME="&lt;storage account name&gt;"</span><span id="ed7a" class="nn lc jg oc b gy ol oi l oj ok"># Retrieve storage key<br/>STORAGEKEY=$(az storage account keys list --account-name $AKS_PERS_STORAGE_ACCOUNT_NAME --resource-group $RG \<br/>--query "[?keyName == 'key1'].value" -o tsv)</span><span id="8137" class="nn lc jg oc b gy ol oi l oj ok">echo $AKS_PERS_STORAGE_ACCOUNT_NAME<br/>echo $STORAGEKEY</span><span id="9443" class="nn lc jg oc b gy ol oi l oj ok"># Create secret to enable the pod to mount the PVC<br/>k create secret generic azure-secret --from literal=azurestorageaccountname=$AKS_PERS_STORAGE_ACCOUNT_NAME \<br/>--from-literal=azurestorageaccountkey=$STORAGEKEY</span></pre><p id="7d12" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦秘密被创造出来，我们就可以为这个练习创造资源。Kubectl使我们能够基于远程yaml文件创建资源，在本例中是来自练习Github存储库。</p><blockquote class="mn mo mp"><p id="0199" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated"><strong class="kf jh"> <em class="jg">在从远程源创建资源之前，总是检查文件的内容。</em> </strong></p></blockquote><pre class="mv mw mx my gt od oc oe of aw og bi"><span id="b513" class="nn lc jg oc b gy oh oi l oj ok"><em class="mq">#Persistent Volume bound to the file share</em> <br/>k apply -f https://raw.githubusercontent.com/Piotr1215/dca-exercises/master/k8s/storage-pv-pvc/1-create-pv.yaml <br/> <br/><em class="mq">#Persistent Volume Claim</em> <br/>k apply -f https://raw.githubusercontent.com/Piotr1215/dca-exercises/master/k8s/storage-pv-pvc/2-create-pvc.yaml  </span><span id="2125" class="nn lc jg oc b gy ol oi l oj ok"><em class="mq">#Pod with Persistent Volume Claim mounted as volume</em> <br/>k apply -f https://raw.githubusercontent.com/Piotr1215/dca-exercises/master/k8s/storage-pv-pvc/3-create-pod.yaml</span></pre><blockquote class="mn mo mp"><p id="b194" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated"><em class="jg">在不使用持久卷的情况下，可以在pod和Azure文件共享之间创建绑定。也可以让Azure动态提供文件共享给Kubernetes资源使用。出于练习和演示的目的，我们在这里详细说明。</em></p></blockquote><h1 id="ac06" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">让我们实验一下</h1><p id="7d2c" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们将重温<em class="mq">一节中的场景，它解决了什么问题？并验证这些陈述是正确的。</em></p><h2 id="dfeb" class="nn lc jg bd ld no np dn lh nq nr dp ll ko ns nt lp ks nu nv lt kw nw nx lx ny bi translated">销毁pod后启用持久化数据</h2><pre class="mv mw mx my gt od oc oe of aw og bi"><span id="27dd" class="nn lc jg oc b gy oh oi l oj ok"># Create a file inside a mounted folder of the pod<br/>k exec -it testpod -- sh<br/>cd /mnt/azure/<br/>echo "Will I still be here for new pod?" &gt; testfile.txt<br/>cat testfile.txt</span><span id="fdb2" class="nn lc jg oc b gy ol oi l oj ok"># Remove the pod<br/>k delete pod testpod</span><span id="0e86" class="nn lc jg oc b gy ol oi l oj ok"># Create pod again<br/>k apply -f https://raw.githubusercontent.com/Piotr1215/dca-exercises/master/k8s/storage-pv-pvc/3-create-pod.yaml</span><span id="2f59" class="nn lc jg oc b gy ol oi l oj ok"># Check if the file still exist in the mounted directory<br/>k exec -it testpod -- cat /mnt/azure/testfile.txt</span></pre><p id="866d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个命令应该产生文本:“我还会在这里等待新的pod吗？”</p><p id="6269" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">结论:</strong>我们已经成功地证明了在pod破坏事件之间数据是持久的。</p><h2 id="e6a3" class="nn lc jg bd ld no np dn lh nq nr dp ll ko ns nt lp ks nu nv lt kw nw nx lx ny bi translated">将存储资源调配活动与其消费相分离</h2><pre class="mv mw mx my gt od oc oe of aw og bi"><span id="6bb3" class="nn lc jg oc b gy oh oi l oj ok"># Increase persistent volume capacity<br/>k edit pv azurefile</span><span id="2cb9" class="nn lc jg oc b gy ol oi l oj ok"># Change storage to 10Gi, exit and save vim (:wq). Check pv<br/>k describe pv azurefile</span><span id="3fe5" class="nn lc jg oc b gy ol oi l oj ok"># Make sure that file is still there<br/>k exec -it testpod -- cat /mnt/azure/testfile.txt</span></pre><p id="4512" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">结论:</strong>我们已经成功地证明了数据集群管理员可以在不影响开发人员活动的情况下执行他们的任务。</p><h2 id="9037" class="nn lc jg bd ld no np dn lh nq nr dp ll ko ns nt lp ks nu nv lt kw nw nx lx ny bi translated">启用pod之间的数据共享</h2><pre class="mv mw mx my gt od oc oe of aw og bi"><span id="e1ac" class="nn lc jg oc b gy oh oi l oj ok"># Create another pod bound to the same persistent volume<br/>k apply -f https://raw.githubusercontent.com/Piotr1215/dca-exercises/master/k8s/storage-pv-pvc/4-create-pod2.yaml</span><span id="4868" class="nn lc jg oc b gy ol oi l oj ok"># Open new Azure Cloud session and exec into testpod<br/>k exec -it testpod -- sh<br/>cd /mnt/azure/<br/>ls</span><span id="6eda" class="nn lc jg oc b gy ol oi l oj ok"># Watch for file changes<br/>watch -n1 'ls ./*'</span><span id="d5a2" class="nn lc jg oc b gy ol oi l oj ok"># Swap to another shell and create file in testpod2<br/>k exec -it testpod2 -- touch /mnt/azure/new_testfile.txt</span></pre><p id="4efa" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个命令应该导致<em class="mq"> new_testfile.txt </em>立即出现在另一个shell中</p><p id="b95d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">结论:</strong>我们已经成功证明了pod之间可以实时共享数据。</p><h2 id="8895" class="nn lc jg bd ld no np dn lh nq nr dp ll ko ns nt lp ks nu nv lt kw nw nx lx ny bi translated">清除</h2><p id="c4d5" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">运行<code class="fe nz oa ob oc b">k get pv</code>显示持久卷<em class="mq">回收策略</em>处于<strong class="kf jh">回收</strong>模式。这意味着删除pod后，永久卷将保持可用。通过移除pod来测试它，并检查您的文件共享是否仍然存在。</p><blockquote class="mn mo mp"><p id="3a02" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">如果你使用免费订阅，不要忘记清理Azure上的资源。最简单的方法是删除创建所有资源的资源组。在我们的例子中<code class="fe nz oa ob oc b">az group delete --name ResourceGroupName</code></p></blockquote><h1 id="236f" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">挑战</h1><p id="7b61" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你想测试什么吗？思考一个场景，测试一下，然后在评论中告诉我们。</p></div></div>    
</body>
</html>