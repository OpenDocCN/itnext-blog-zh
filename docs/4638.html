<html>
<head>
<title>Full-Stack Flutter: Creating a Backend for Your App With AWS &amp; Serverless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">全栈抖动:用AWS和无服务器为你的应用创建后端</h1>
<blockquote>原文：<a href="https://itnext.io/full-stack-flutter-creating-a-backend-for-your-app-with-aws-serverless-6ee11ae7bd89?source=collection_archive---------0-----------------------#2020-08-11">https://itnext.io/full-stack-flutter-creating-a-backend-for-your-app-with-aws-serverless-6ee11ae7bd89?source=collection_archive---------0-----------------------#2020-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/84a9949859c4206c6c5f52344098fcac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfDCDJQi3Guw1BLet5Odvg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">AWS -&gt;无服务器-&gt; Flutter</figcaption></figure><p id="b10f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">作为一种如此受新开发人员欢迎的语言，许多使用Flutter的人甚至不知道如何或从哪里开始为他们的应用程序设置后端。有一些可用的解决方案，比如Firebase，大多数Flutter开发人员都使用它，但是，我们将讨论一个更广泛使用的后端，AWS。更具体地说，我们将介绍如何通过AWS(称为DynamoDb)建立NoSQL数据库，使用API Gateway &amp; Serverless with Node创建API(您也可以使用python)，以及在Flutter应用程序中处理API调用，以便对新创建的数据库执行CRUD操作。</p><p id="6924" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">希望到本文结束时，您将能够快速构建自己的数据库、连接到该数据库的API以及将这些API集成到您的应用程序中，这样您就可以在Flutter中为未来或当前的项目快速构建一个后端。通过AWS连接到SQL数据库可以遵循相同的过程，只需改变我们的API方法调用DB的方式。我将尝试从语言和数据库的角度介绍不同的选项，尽我所能地使用它们，并向您展示如何找到必要的资源来扩展本教程之外的功能。</p><p id="4bbf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> AWS账户设置:</strong></p><p id="fd78" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您还没有帐户，<a class="ae ld" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">导航到AWS </a>并点击“创建帐户”。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi le"><img src="../Images/10950769db7e7bde212cf3dd48666197.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*Dw8ka5vUxY1LZAZlo8wkfw.png"/></div></figure><p id="8b7a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">按照要求填写所需信息。您需要输入付款信息。尽管如果您遵循本教程，您不会被收取任何费用，但是根据您想要存储的数据量以及您读取/写入AWS的频率，您将开始相应地产生费用。对于AWS的定价信息，你可以使用<a class="ae ld" href="https://calculator.aws/#/addService" rel="noopener ugc nofollow" target="_blank">这个定价计算器</a>来看看你最终会支付多少。</p><p id="1a25" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一旦您设置了您的帐户并登录，您应该会被重定向到一个仪表板屏幕，如下所示。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lj"><img src="../Images/848f34ab0b224f236095831785e55196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZM4lBpUK0xcMSaCEJrPxQ.png"/></div></div></figure><p id="365f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">数据库设置:</strong></p><p id="2b53" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，我们将通过DynamoDB建立一个NoSQL数据库。在“查找服务”搜索栏中输入“DynamoDB”。一旦你到达那里，点击“创建表格”。您应该会看到类似如下的屏幕:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lk"><img src="../Images/5833633dcca5275b171babaaa4572711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0IoDvfz-NIL_QeFRT2vNSQ.png"/></div></div></figure><p id="f730" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于我的表的名称，我将称之为“Products ”,并有一个名为“ID”的主键。点击“创建”。</p><p id="1ad8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">恭喜你！您已经完成了数据库的设置！让我们简要回顾一下DynamoDB的布局，以及完成设置到底需要什么。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ll"><img src="../Images/7287e99206ce23b5504dcf736b90e4e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6zWT7wNpWikmHjbbfHycQ.png"/></div></div></figure><p id="651f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“项目”页面将是您最重要的选项卡。这将包含数据库的所有内容。如果您想手动添加数据，可以单击“创建项目”。但是，我们将为这个数据库设置CRUD操作，所以现在没有必要。</p><p id="4aea" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“概述”选项卡包含所有相关的数据库信息，其中最重要的是您的“ARN”标识符。我们将需要使用这个API来连接到我们的数据库。</p><p id="588e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">配置您的电脑:</strong></p><p id="1dfb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你还没有安装它，请确保将AWS Cli安装到你的计算机上:<a class="ae ld" href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/Cli/latest/user guide/install-Cli v2 . html</a>。</p><p id="ba75" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将需要配置我们的机器，以指向我们的新AWS帐户。为此，首先，转到您的AWS控制台。点击您的用户名-&gt;我的安全凭证。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/163a48ceb536dcde5445cd5387f92b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*R4WmGOH0FZorW9yS2CRTCA.png"/></div></figure><p id="2057" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，您想要创建一个安全密钥并下载它。我们将使用该文件通过终端/命令提示符登录。标题为rootkey.csv的excel文件应该有两个值:AWSAccessKeyId和AWSSecretKey。</p><p id="4552" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">打开终端/命令提示符，输入命令</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="cb77" class="ls lt it lo b gy lu lv l lw lx">aws configure</span></pre><p id="5ade" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">输入在rootkey.csv文件中找到的Id和SecretKey。当提示插入区域和输出格式时，只需单击enter并留空即可。它将为您设置为默认设置。</p><p id="ec78" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">无服务器:</strong></p><p id="6ae0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们要为数据库设置API。我们将通过无服务器实现这一点。为了节省大量时间，我们将使用NodeJs构建现有的模板repo。</p><div class="ly lz gp gr ma mb"><a href="https://github.com/serverless/examples/tree/master/aws-node-rest-api-with-dynamodb" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">无服务器/示例</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">这个例子演示了如何建立一个RESTful Web服务，允许你创建、列表、获取、更新和删除…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">github.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp jz mb"/></div></div></a></div><p id="1c72" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:您可能需要下载整个repo，然后只需提取您想要使用的特定文件夹。在我们的例子中，我们希望使用<strong class="kh iu">AWS-node-rest-API-with-dynamo db</strong>代码库。</p><h1 id="0d63" class="mq lt it bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated">无服务器的优势:</h1><p id="ba31" class="pw-post-body-paragraph kf kg it kh b ki nn kk kl km no ko kp kq np ks kt ku nq kw kx ky nr la lb lc im bi translated">通过无服务器完成所有工作的好处是，当我们最终部署我们的API时(我们将很快实现)，它将自动处理设置我们的lambda方法、设置API网关，并通过AWS处理cors所需的任何配置。或者，您可以在AWS中单独手动设置所有这些东西，但是这非常复杂，您可能会遇到许多问题。通过使用无服务器，我们可以在设置API时节省时间和精力。通过使用预定义的模板，我们可以重用大量代码，因为基本的CRUD操作已经为我们定义好了。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="cb75" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们要修改的第一个文件是我们的serverless.yaml文件。我们需要确保为DynamoDb表插入我们的ARN ID。</p><p id="bd7c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您会注意到在我们函数下面的底部有一个标记为“resources:”的部分。我们可以暂时移除它。出于本教程的目的，我们将创建没有很多配置的公共API，并尽量保持结构简单，以便于理解。</p><p id="bd3e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们想修改yaml文件的顶部，如下所示:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="70fd" class="ls lt it lo b gy lu lv l lw lx">provider:<br/>  name: aws<br/>  runtime: nodejs10.x<br/>  iamRoleStatements:<br/>    - Effect: Allow<br/>      Action:<br/>        - dynamodb:Query<br/>        - dynamodb:Scan<br/>        - dynamodb:GetItem<br/>        - dynamodb:PutItem<br/>        - dynamodb:UpdateItem<br/>        - dynamodb:DeleteItem<br/>      Resource: "insertYourArnHere"</span></pre><p id="2c06" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们对这段代码做了一个简单的修改。我们用dynamodb Overview选项卡中的“ARN”替换了我们的资源标签。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/666695164570feb7fa320cb35fad2809.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*fEPz_FQ1Pfpd92DzIVHjuw.png"/></div></figure><p id="3d72" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们接下来要检查我们的列表处理器方法。如果你看看我们yaml中的函数，你会看到一个列表:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="c917" class="ls lt it lo b gy lu lv l lw lx">list:<br/>  handler: todos/list.list<br/>  events:<br/>    - http:<br/>       path: todos<br/>       method: get<br/>       cors: true</span></pre><p id="1ca7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要分解这些属性的含义，首先是我们的“处理程序”。这是我们的方法的路径，当我们的API端点被点击时将被调用。我们的“events”属性展示了端点路径(如“path”旁边所示)、它是什么类型的API方法(“method”属性)，以及我们针对该端点的“cors”策略(“cors”)。我们将让我们的cors保持“true ”,以允许所有可以访问我们端点的流量访问它。</p><p id="90b6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的“list”方法已经完成了，但还是让我们看一看，这样您就可以理解调用该端点时发生了什么。</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="eecd" class="ls lt it lo b gy lu lv l lw lx">'use strict';<br/>const AWS = require('aws-sdk');<br/>const dynamoDb = new AWS.DynamoDB.DocumentClient();<br/>const params = {<br/>  TableName: "Products",<br/>};</span><span id="fa90" class="ls lt it lo b gy oa lv l lw lx">module.exports.list = (event, context, callback) =&gt; {<br/>  // fetch all todos from the database<br/>  dynamoDb.scan(params, (error, result) =&gt; {<br/>    // handle potential errors<br/>    if (error) {<br/>      console.error(error);<br/>      callback(null, {<br/>        statusCode: error.statusCode || 501,<br/>        headers: { 'Content-Type': 'text/plain' },<br/>        body: 'Couldn\'t fetch the todos.',<br/>      });<br/>      return;<br/>    }<br/>    // create a response<br/>    const response = {<br/>      statusCode: 200,<br/>      body: JSON.stringify(result.Items),<br/>    };<br/>    callback(null, response);<br/>  });<br/>};</span></pre><p id="a8f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于我们的每个方法，这将是我们正在设置的关键变量。Params告诉我们想要从哪个表中读取数据，我们想要什么样的过滤器属性，我们想要返回什么样的特定列，等等。对于list方法，我们所关心的是获取表中的所有数据，所以我们只需要“TableName”属性集。如果您在yaml文件中将product表名设置为环境变量，那么您可以将其保留为默认值，否则，一定要像我上面所做的那样将其设置为您的表名。</p><p id="835f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> dynamoDb.scan: </strong>这个方法将扫描表中的所有数据。如果它在尝试提取数据时遇到任何问题或错误，它将命中我们的错误语句，并返回一个错误状态代码以及一条消息，说明它不成功。在这种情况下，它的工作，我们返回一个200响应与我们的数据。</p><p id="9636" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">回调:</strong>如果成功，我们的回调将返回error if语句或文件底部定义的响应。</p><h1 id="46a5" class="mq lt it bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated"><strong class="ak">创建</strong></h1><p id="cb34" class="pw-post-body-paragraph kf kg it kh b ki nn kk kl km no ko kp kq np ks kt ku nq kw kx ky nr la lb lc im bi translated">我们需要的下一个关键端点是我们的create方法。我将修改它以适合我的例子，但是希望它足够清晰，你可以修改它以适合你的需要。唯一需要调整的是我们的params字段。我将对我的进行如下更改，以容纳我的表项。</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="909a" class="ls lt it lo b gy lu lv l lw lx">const params = {<br/>  TableName: "Products",<br/>  Item: {<br/>    ID: uuid.v1(),<br/>    name: data.name,<br/>    description: data.description,<br/>    price: data.price,<br/>    imageURL: data.imageURL<br/>  },<br/>};</span></pre><p id="ccf0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就像在我们的list方法中一样，我们的TableName变量应该是我们想要插入新项的表的名称。我们还希望确保删除检查data.text是否为字符串的if语句。我们并不关心这个，因为我们没有传递任何名为text的变量。</p><p id="b4f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">回到我们的“params”，我们的“Item”将是我们想要插入到表中的整行的值。请确保在设置DynamoDb表时包含您所定义的主键。在我的例子中，我还想插入一个带有名称、描述、价格和imageURL的产品。“data.xyz”值应该是您将传递到API端点主体中的元素的名称。“数据”等于经过解析的主体对象。</p><p id="eb24" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">恭喜，您现在已经设置了连接到AWS DynamoDb表的基本API端点！我们只剩下一步就可以利用我们设置的这些新端点了。在您的终端中，在该项目的根文件夹下运行以下命令:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="3cdd" class="ls lt it lo b gy lu lv l lw lx">npm install<br/>sls deploy</span></pre><p id="2bc6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">sls是用于无服务器的命令。如果您尚未在计算机上安装无服务器，请确保在“sls deploy”之前运行以下命令:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="ab13" class="ls lt it lo b gy lu lv l lw lx">npm i serverless</span></pre><p id="0d44" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您应该会看到一串黄色日志消息出现在您的终端中，2–5分钟后，您应该会看到屏幕上显示了您新创建的端点。它们应该看起来像这样:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="6307" class="ls lt it lo b gy lu lv l lw lx">endpoints:<br/>  POST - <a class="ae ld" href="https://s8npb3n9a0.execute-api.us-east-1.amazonaws.com/dev/todos" rel="noopener ugc nofollow" target="_blank">https://endpoint/dev/todos</a><br/>  GET - <a class="ae ld" href="https://s8npb3n9a0.execute-api.us-east-1.amazonaws.com/dev/todos" rel="noopener ugc nofollow" target="_blank">https://endpoint/dev/todos</a><br/>  GET - <a class="ae ld" href="https://s8npb3n9a0.execute-api.us-east-1.amazonaws.com/dev/todos/{id" rel="noopener ugc nofollow" target="_blank">https://endpoint/dev/todos/{id</a>}<br/>  PUT - <a class="ae ld" href="https://s8npb3n9a0.execute-api.us-east-1.amazonaws.com/dev/todos/{id" rel="noopener ugc nofollow" target="_blank">https://endpoint/dev/todos/{id</a>}<br/>  DELETE - <a class="ae ld" href="https://s8npb3n9a0.execute-api.us-east-1.amazonaws.com/dev/todos/{id" rel="noopener ugc nofollow" target="_blank">https://endpoint/dev/todos/{id</a>}</span></pre><p id="d8bf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们关心的端点是我们的“POST”端点以及我们的第一个“GET”端点，即以“/todos”结尾的端点。其他端点是我们还没有验证的，也没有修改来满足我们的需求。我们稍后会谈到这些。首先，我们想要测试我们的端点是否正常工作。为此，我们将使用名为“Postman”的应用程序。如果你还没有安装，你可以<a class="ae ld" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank">在这里</a>安装，或者使用你选择的应用程序。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/5efba4a913986b3f703520105d38c799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*er7M0c6iVlTPhH4qXBk98Q.png"/></div></div></figure><p id="0901" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">粘贴create方法的端点，并将类型设置为“POST”。在您的“主体”中，确保包含您在create方法中定义的所有字段。如果成功执行，您应该得到一个“200 OK”并看到创建的对象返回。如果我们在AWS上查看我们的表，我们会看到这个新值已经添加到我们的表中:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/93489a66a7efb5e93cdbc3d4afead549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gNeX3NW0U1w3J8-YPN-M0A.png"/></div></div></figure><p id="574b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您得到了除“200 OK”响应之外的任何其他响应，您可以通过检查您在【https://console.aws.amazon.com/cloudwatch/home】-&gt;“日志组”-&gt;yourlambdamethodthat failed找到的API日志来调试出了什么问题，并从那里进行调试。</p><p id="4e08" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们已经测试了我们的创建方法，让我们测试一下，以确保我们的list方法也能工作。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/16a913f739acef88a9dd327a3fe7b58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPcY8ZZeweloS8vheEaP9w.png"/></div></div></figure><p id="8524" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的响应应该看起来像上面看到的项目数组。</p><p id="850b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们已经测试并确认了我们的方法正在工作，我们将再做一个方法改变，我们的“更新”方法。</p><p id="1597" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">回到我们的项目，我们可以让我们的serverless.yaml文件保持原样，直接进入我们的update.js文件。</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="fdb3" class="ls lt it lo b gy lu lv l lw lx">const params = {<br/>  TableName: "Products",<br/>  Key: {<br/>    ID: event.pathParameters.id,<br/>  },<br/>  ExpressionAttributeNames: {<br/>    '#name': 'name',<br/>  },<br/>  ExpressionAttributeValues: {<br/>    ':name': data.name,<br/>  },<br/>  UpdateExpression: 'SET #name = :name',<br/>  ReturnValues: 'ALL_NEW',<br/>};</span></pre><p id="2cc3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在删除了检查data.text是否为字符串值的if语句之后，我们只需要修改update方法中的参数，就可以得到我们想要的结果。在更新值时，我们需要设置一些属性。首先，和我们所有的param变量一样，我们需要确保传递我们想要更新的表的名称。</p><p id="7939" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“Key”:这将是我们想要更新的值的ID(我们的主键)。我们希望将通过端点传递的id值传递给它(这是更新端点的/{id}部分)。为了访问这个值，我们称之为“event.pathParameters.id”值。</p><p id="47ed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“ExpressionAttributeNames”:这将设置我们想要更新的列的名称。</p><p id="247a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“ExpressionAttributeValues”:这将设置我们想要更新的列的值。</p><p id="ecfe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“UpdateExpression”:这是我们将想要更新的列名与值进行匹配的地方。您可能会认为可以写出完整的UpdateExpression，而不是编写所有这些变量名来表示值，但是DynamoDb UpdateExpressions不允许这样做。您还需要设置ExpressionAttributeNames和ExpressionAttributeValues。</p><p id="6650" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">完成后，只需运行:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="4b9b" class="ls lt it lo b gy lu lv l lw lx">sls deploy</span></pre><p id="8fd5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">再次，你现在可以使用你的更新方法。下面是我们测试Postman时它的样子:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/7cfb934fbb51d8d1937bf4f40b442245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3YPtmxs_9dnfXLSl622Pg.png"/></div></div></figure><p id="b71f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">正如您在上面看到的，我们传递了我们想要更改的值的ID以及我们想要更新的变量(需要匹配我们的方法),它将返回更新后的对象。</p><p id="0a1d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好了，我们已经1)建立了数据库，2)建立了API方法。剩下的唯一事情就是把我们的Flutter应用程序连接到我们的API上！</p><h1 id="b5e0" class="mq lt it bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated"><strong class="ak">颤振:</strong></h1><p id="0086" class="pw-post-body-paragraph kf kg it kh b ki nn kk kl km no ko kp kq np ks kt ku nq kw kx ky nr la lb lc im bi translated">出于我们的flutter应用程序的目的，我们将需要设置几个API方法。我将把这些方法放在名为“net”的文件夹下的单独文件中。</p><p id="84fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我们写出我们的方法之前，我们需要导入包:http。https://pub.dev/packages/http/install<a class="ae ld" href="https://pub.dev/packages/http/install" rel="noopener ugc nofollow" target="_blank"/></p><p id="bf4f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">添加依赖项:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="78a2" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">dependencies</strong>:<br/>  <strong class="lo iu">http</strong>: ^0.12.2</span></pre><p id="0ac3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来我们要做的是建立一个模型类来处理数据的读取。</p><p id="0a7f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">产品.飞镖:</strong></p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="8e6d" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">class </strong>Product {<br/>  <strong class="lo iu">final </strong>String <strong class="lo iu">name</strong>;<br/>  <strong class="lo iu">final </strong>String <strong class="lo iu">description</strong>;<br/>  <strong class="lo iu">final </strong>String <strong class="lo iu">price</strong>;<br/>  <strong class="lo iu">final </strong>String <strong class="lo iu">imageURL</strong>;<br/><br/>  <strong class="lo iu">const </strong>Product({<br/>    <strong class="lo iu">this</strong>.<strong class="lo iu">name</strong>,<br/>    <strong class="lo iu">this</strong>.<strong class="lo iu">description</strong>,<br/>    <strong class="lo iu">this</strong>.<strong class="lo iu">price</strong>,<br/>    <strong class="lo iu">this</strong>.<strong class="lo iu">imageURL</strong>,<br/>  });<br/><br/>  <strong class="lo iu">factory </strong>Product.fromJson(Map&lt;String, <strong class="lo iu">dynamic</strong>&gt; json) {<br/>    <strong class="lo iu">return </strong>Product(<br/>      name: json[<strong class="lo iu">'name'</strong>].toString(),<br/>      description: json[<strong class="lo iu">'description'</strong>].toString(),<br/>      price: json[<strong class="lo iu">'price'</strong>].toString(),<br/>      imageURL: json[<strong class="lo iu">'imageURL'</strong>].toString(),<br/>    );<br/>  }<br/>}</span></pre><p id="31cc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我的例子中，表中的每个产品都有4个不同的值:名称、描述、价格和imageURL。您希望确保添加的类的重要部分是“factory Product.fromJson(){}…”方法，以便我们可以轻松地将响应对象转换为我们的类结构。</p><p id="7b09" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们将为“list”端点创建未来的方法。</p><p id="bb93" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> get_list.dart: </strong></p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="febc" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">import 'dart:convert'</strong>;<br/><strong class="lo iu">import 'package:projectPath/model/product.dart'</strong>;<br/><strong class="lo iu">import 'package:http/http.dart' as </strong>http;<br/><br/>Future&lt;List&lt;Product&gt;&gt; getProducts() <strong class="lo iu">async </strong>{<br/>  <strong class="lo iu">var </strong>url =<br/>      <strong class="lo iu">"https://endpointHere/dev/todos"</strong>;<br/>  <strong class="lo iu">return </strong>http.get(url).then((http.Response response) {<br/>    <strong class="lo iu">final </strong>int statusCode = response.<strong class="lo iu">statusCode</strong>;<br/>    <strong class="lo iu">if </strong>(statusCode == 200) {<br/>      <strong class="lo iu">final </strong>temp = json.decode(response.<strong class="lo iu">body</strong>);<br/>      List&lt;Product&gt; data = [];<br/>      <strong class="lo iu">for </strong>(<strong class="lo iu">var </strong>item <strong class="lo iu">in </strong>temp) {<br/>        Product temp_product = Product.fromJson(item);<br/>        data.add(temp_product);<br/>      }<br/>      <strong class="lo iu">return </strong>data;<br/>    }<br/>    <strong class="lo iu">if </strong>(statusCode &lt; 200 || statusCode &gt; 400 || json == <strong class="lo iu">null</strong>) {<br/>      <strong class="lo iu">throw new </strong>Exception(<strong class="lo iu">"Error while fetching data"</strong>);<br/>    }<br/>    <strong class="lo iu">return null</strong>;<br/>  });<br/>}</span></pre><p id="e973" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于这个方法，我们将返回一种类型的:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="72da" class="ls lt it lo b gy lu lv l lw lx">List&lt;Product&gt;</span></pre><p id="6cf0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用我们新创建的产品类和我们导入的http包，我们将通过使用:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="fb21" class="ls lt it lo b gy lu lv l lw lx">http.get(url).then((http.Response response){}</span></pre><p id="abfb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">“response”将是我们的JSON格式的结果。剩下唯一要做的事情就是使用我们创建的fromJson方法将它解析到我们的Product类结构中:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="79a7" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">final </strong>temp = json.decode(response.<strong class="lo iu">body</strong>);<br/>List&lt;Product&gt; data = [];<br/><strong class="lo iu">for </strong>(<strong class="lo iu">var </strong>item <strong class="lo iu">in </strong>temp) {<br/>  Product temp_product = Product.fromJson(item);<br/>  data.add(temp_product);<br/>}</span></pre><p id="874b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这段代码将遍历我们的响应体，并为列表中的每个值创建一个产品对象。一旦我们将它解析成一个产品，我们将把它添加到我们的列表中，然后在我们遍历了全身响应后返回那个列表。</p><p id="4a1e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> create_item.dart: </strong></p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="a094" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">import 'package:projectPath/model/product.dart'</strong>;<br/><strong class="lo iu">import 'package:http/http.dart' as </strong>http;<br/><br/>Future&lt;<strong class="lo iu">void</strong>&gt; createItem(Product product) <strong class="lo iu">async </strong>{<br/>  <strong class="lo iu">var </strong>url = <strong class="lo iu">"https://yourAPIEndpointHere/dev/todos"</strong>;<br/>  <strong class="lo iu">return </strong>http<br/>      .post(url,<br/>          body: <strong class="lo iu">"{" </strong>+<br/>              <strong class="lo iu">"\"name\": \"</strong>${product.<strong class="lo iu">name</strong>}<strong class="lo iu">\", \"description\": \"</strong>${product.<strong class="lo iu">description</strong>}<strong class="lo iu">\", \"price\": \"</strong>${product.<strong class="lo iu">price</strong>}<strong class="lo iu">\", \"imageURL\": \"</strong>${product.<strong class="lo iu">imageURL</strong>}<strong class="lo iu">\" }"</strong>)<br/>      .then((http.Response response) {<br/>    <strong class="lo iu">final </strong>int statusCode = response.<strong class="lo iu">statusCode</strong>;<br/>    <strong class="lo iu">if </strong>(statusCode == 200) {<br/>      <strong class="lo iu">return</strong>;<br/>    } <strong class="lo iu">else </strong>{<br/>      <strong class="lo iu">throw new </strong>Exception(<strong class="lo iu">"Error while fetching data"</strong>);<br/>    }<br/>  });<br/>}</span></pre><p id="cd68" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了创建一个新的项目，我们将使用我们的POST端点，向它传递4个变量:名称、描述、价格和imageURL。</p><p id="abc3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如上所述，我们使用http.post()方法来调用端点，并向其传递一个body对象。在上面的例子中，我将值硬编码成JSON格式，以便API进行解析，但是您也可以创建一个模型方法，只需将您的对象转换成JSON对象，然后可以作为主体参数传递。</p><p id="f68b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们不关心这个端点的响应，只关心statusCode值。只要statusCode等于200，我们就知道它成功了。</p><p id="2883" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> update_item.dart: </strong></p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="4ae9" class="ls lt it lo b gy lu lv l lw lx"><strong class="lo iu">import 'package:http/http.dart' as </strong>http;<br/><br/>Future&lt;<strong class="lo iu">void</strong>&gt; updateName(String ID, String newName) <strong class="lo iu">async </strong>{<br/>  <strong class="lo iu">var </strong>url =<br/>      <strong class="lo iu">"https://endpoint/dev/todos/</strong>$ID<strong class="lo iu">"</strong>;<br/>  <strong class="lo iu">return </strong>http<br/>      .put(url, body: <strong class="lo iu">"{" </strong>+ <strong class="lo iu">"\"name\": \"</strong>$newName<strong class="lo iu">\" }"</strong>)<br/>      .then((http.Response response) {<br/>    <strong class="lo iu">final </strong>int statusCode = response.<strong class="lo iu">statusCode</strong>;<br/>    print(response);<br/>    print(statusCode);<br/>    <strong class="lo iu">if </strong>(statusCode == 200) {<br/>      print(<strong class="lo iu">"Success"</strong>);<br/>      <strong class="lo iu">return</strong>;<br/>    }<strong class="lo iu">else</strong>{<br/>      <strong class="lo iu">throw new </strong>Exception(<strong class="lo iu">"Error while fetching data"</strong>);<br/>    }<br/>  });<br/>}</span></pre><p id="aa38" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于我们的更新端点，我们将从我们的create方法中改变2件事。我们首先要确保我们使用的是PUT方法调用，而不是POST。其次，我们希望确保将我们的项目ID传递到我们的端点，而不是我们的主体。为此，我们只需将URL格式化如下:</p><pre class="lf lg lh li gt ln lo lp lq aw lr bi"><span id="9801" class="ls lt it lo b gy lu lv l lw lx">var url = "https://endpoint/dev/todos/$VariableHere</span></pre><p id="4ea7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">仅此而已。我们只关心响应中的statusCode，因此我们相应地编写if、else语句来检查返回值。</p><p id="ce02" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们完了。我们现在已经创建了调用3个新API端点的方法！</p><h1 id="22ac" class="mq lt it bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated"><strong class="ak">重述:</strong></h1><p id="de7b" class="pw-post-body-paragraph kf kg it kh b ki nn kk kl km no ko kp kq np ks kt ku nq kw kx ky nr la lb lc im bi translated">来覆盖我们所做的:</p><ul class=""><li id="bd78" class="od oe it kh b ki kj km kn kq of ku og ky oh lc oi oj ok ol bi translated">我们建立了一个新的AWS账户</li><li id="9412" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated">我们在AWS中建立了一个DynamoDb表</li><li id="8e24" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated">我们配置我们的机器通过AWS Cli包连接到AWS。</li><li id="2c3a" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated">我们用Node建立了我们的无服务器项目，通过lambda和API Gateway在AWS上创建API端点&amp;学习了如何用CloudWatch监控这些API。</li><li id="d7f3" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated">我们在Flutter项目中设置了一个模型类来处理存储在DynamoDb中的对象。</li><li id="d2cb" class="od oe it kh b ki om km on kq oo ku op ky oq lc oi oj ok ol bi translated">我们设置了未来的方法来处理我们拥有的每种类型的API调用:GET、PUT、POST。</li></ul><p id="d480" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就这样，你现在是一个全栈开发者了！您可以使用这个设置，并从它扩展到将来需要使用AWS中的数据库结构的项目。如果您想使用Postgres或SQL，您可以保持大部分无服务器设置不变，但只需稍微修改您的方法来调用不同的数据库结构，并且您的前端dart代码也可以保持不变。如果您希望在无服务器中使用Python而不是Node，您可以在无服务器Repo中找到使用相同设置的其他模板，但是使用Python而不是Node:</p><div class="ly lz gp gr ma mb"><a href="https://github.com/serverless/examples" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">无服务器/示例</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">一组随时可部署的无服务器框架服务。单击展开如果您不熟悉无服务器，我们…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">github.com</p></div></div><div class="mk l"><div class="or l mm mn mo mk mp jz mb"/></div></div></a></div><p id="bc82" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">有关如何查询DynamoDb表的更多资源，请参见以下AWS文档:</p><div class="ly lz gp gr ma mb"><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GettingStarted.NodeJs.html" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">Node.js和DynamoDB入门</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">在本教程中，您将使用AWS SDK for JavaScript编写简单的应用程序来执行以下Amazon…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">docs.aws.amazon.com</p></div></div></div></a></div></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="8898" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要获得更多每周的精彩内容，请务必在所有社交网站(媒体、Youtube、Twitter、Instagram、脸书)上关注<a class="os ot ep" href="https://medium.com/u/1b72487e1a47?source=post_page-----6ee11ae7bd89--------------------------------" rel="noopener" target="_blank"> BleylDev </a>。如果你有一个特殊的问题或话题想得到帮助，请随时联系我们。如果你觉得这篇文章有用，一定要留下一些掌声(你知道你可以为每篇文章鼓掌50次吗？试试吧！).</p></div></div>    
</body>
</html>