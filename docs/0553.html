<html>
<head>
<title>Angular APP_INITIALIZER + NgRx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular APP_INITIALIZER + NgRx</h1>
<blockquote>原文：<a href="https://itnext.io/angular-app-initializer-ngrx-1d1340532fe3?source=collection_archive---------2-----------------------#2018-03-30">https://itnext.io/angular-app-initializer-ngrx-1d1340532fe3?source=collection_archive---------2-----------------------#2018-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/7fcf862a568f48ba998b3a269970fca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*948oB3xoCLH6jd8OmL18RQ.png"/></div></figure><p id="e916" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">有什么问题？Angular 5的APP_INITIALIZER期望你的代码会为它的解析返回一个承诺。</strong></p><p id="500e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">为什么这是个问题？</strong>Angular的大部分架构已经升级为使用observables，但这一关键部分却没有。</p><p id="49a2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">背景故事:</strong>我们的应用程序允许深度链接到带有参数的页面，这些参数可以导致组件触发动作(比如搜索)，进而触发HTTP调用。问题是某些HTTP调用需要auth令牌、XSRF令牌等，它们需要在执行之前存在。如果我们没有所需的令牌，我们的系统将产生失败的HTTP调用，并显示401和500错误。</p><p id="dba0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以解决这个问题的一个简单、乏味且可能容易出错的方法是确保所有的<a class="ae ks" href="https://github.com/ngrx/platform/blob/master/docs/effects/README.md" rel="noopener ugc nofollow" target="_blank">效果</a>手动依赖于我们现有的令牌。这将需要每个开发人员添加到他们的效果中，这将产生一个HTTP调用来复制和粘贴代码。这有很多重复的代码，这也会让修复bug变得很痛苦。不好了。</p><p id="fd4a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">进入Angular的app生命周期钩子:<a class="ae ks" href="https://angular.io/api/core/APP_INITIALIZER" rel="noopener ugc nofollow" target="_blank"> App初始化</a>。阅读Angular团队的文档表明，应用程序初始化器是:</p><blockquote class="kt ku kv"><p id="ac54" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated">当应用程序被初始化时将被执行函数。</p></blockquote><p id="b1a9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好吧，很简单。深入研究代码，你会发现你必须为它提供一个工厂/服务，这个工厂/服务有一个名为load的方法，这个方法返回一个承诺。</p><p id="13c7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这一切都很好，除了我们正在使用Angular + NgRx (Observables)构建我们的应用程序，并且我们需要能够在知道我们拥有所需信息后进行调度和操作。</p><p id="bb31" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我尝试了几种不同的方法，从使用RxJs' <a class="ae ks" href="https://github.com/ReactiveX/rxjs/blob/master/compat/observable/of.ts" rel="noopener ugc nofollow" target="_blank"> of </a>操作符包装订阅，然后使用它的。toPromise()方法无济于事。</p><p id="eaf5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我决定采用这种方法，即创建一个新的承诺来包装我们的订阅，然后如果我们过滤掉操作，只查看保存或错误，如果我们收到“保存”，我们就解决我们的承诺，如果我们收到“错误”，我们就拒绝承诺。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d713" class="lj lk iq lf b gy ll lm l ln lo">@Injectable()<br/>class MyInitService {</span><span id="45d8" class="lj lk iq lf b gy lp lm l ln lo">  constructor(private subject: ActionsSubject) {}</span><span id="71e8" class="lj lk iq lf b gy lp lm l ln lo">  load(): Promise&lt;any&gt; {<br/>    const promise = new Promise((resolve, reject) =&gt;<br/>      this.subject.pipe(<br/>        filter(action =&gt; action instanceof InfoSaved ||<br/>                         action instanceof InfoError)<br/>        ).subscribe(action =&gt; {<br/>          if (action.type === ActionType.INFO_SAVED) {<br/>            resolve();<br/>          } else {<br/>            reject();<br/>          }<br/>        })<br/>      })<br/>      this.subject.next(new LoadInfo());<br/>      return promise;<br/>   }<br/>}</span><span id="9608" class="lj lk iq lf b gy lp lm l ln lo">function MyInitServiceFactory(service: MyInitService): Function {<br/>  return () =&gt; service.load();<br/>}</span></pre><p id="4a9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Angular团队提交了一个<a class="ae ks" href="https://github.com/angular/angular/issues/15088" rel="noopener ugc nofollow" target="_blank">bug</a>，所以这个解决方案暂时可以用。我希望这能对你有所帮助，或者如果你找到了不同的解决方案，我很乐意听听你的意见！</p><p id="c0a2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">干杯！</p></div></div>    
</body>
</html>