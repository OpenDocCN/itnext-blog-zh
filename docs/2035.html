<html>
<head>
<title>I’m breaking up with Groovy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我要和Groovy分手</h1>
<blockquote>原文：<a href="https://itnext.io/im-breaking-up-with-groovy-a60d7fda6d0d?source=collection_archive---------0-----------------------#2019-03-20">https://itnext.io/im-breaking-up-with-groovy-a60d7fda6d0d?source=collection_archive---------0-----------------------#2019-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f9b29a097ff72f84711ff33562d6dd59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85kshtocmc5EjYCK1rYqhw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://www.pexels.com/@burakkostak" rel="noopener ugc nofollow" target="_blank">布拉克·科斯塔克</a>经由【pexels.com】T2</figcaption></figure><p id="6879" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好像就在昨天，我才被介绍给groovy。十多年来，我一直是一名相当成功的java开发人员，有一天，我的一位同事说:“嘿，看看这个很棒的东西，它像Java，但更好。”</p><p id="daa2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我几乎立刻就被吸引住了。</p><p id="eeea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我喜欢用setters、getters、equals、hashCode和一个有意义的toString创建一个简单的Java bean，而不会用IDE生成的代码破坏我的代码库。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e469" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">class </strong>SimpleBean {<br/>    <strong class="lj iu">int value1<br/>    </strong>String <strong class="lj iu">value2<br/></strong>}</span></pre><p id="6d29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我惊叹于地图构造器的简单性:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f290" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">new </strong>SimpleBean(<br/>        <strong class="lj iu">value1</strong>: 5,<br/>        <strong class="lj iu">value2</strong>: <strong class="lj iu">"hello"</strong>,<br/>)</span></pre><p id="b674" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以及列表和映射初始值设定项:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f249" class="ln lo it lj b gy lp lq l lr ls">List&lt;String&gt; strings = [<strong class="lj iu">'s1'</strong>, <strong class="lj iu">'s2'</strong>, <strong class="lj iu">'s3'</strong>]<br/>Map&lt;String, Integer&gt; maps = [<br/>        <strong class="lj iu">s1</strong>: 25,<br/>        <strong class="lj iu">s2</strong>: 50,<br/>]</span></pre><p id="3aa4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和字符串插值，或甜蜜字符串插值:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a236" class="ln lo it lj b gy lp lq l lr ls">SimpleBean sb = <strong class="lj iu">new </strong>SimpleBean(<br/>        <strong class="lj iu">value1</strong>: 5,<br/>        <strong class="lj iu">value2</strong>: <strong class="lj iu">"hello"</strong>,<br/>)<br/><br/>String message = <strong class="lj iu">"</strong>${sb.value1}<strong class="lj iu"> some other string stuff </strong>${sb.value2}<strong class="lj iu">"</strong></span></pre><p id="1d9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">似乎我一天都不能不发现groovy的一些令人敬畏的东西。</p><ul class=""><li id="b3d7" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated">使用字段访问语法调用get/set</li><li id="153a" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated"><a class="ae kf" href="https://www.tutorialspoint.com/groovy/groovy_closures.htm" rel="noopener ugc nofollow" target="_blank">关闭</a></li><li id="f2fa" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">UFO，又名宇宙飞船，操作员<a class="ae kf" href="https://objectpartners.com/2010/02/08/the-groovy-spaceship-operator-explained/" rel="noopener ugc nofollow" target="_blank">(对，就是那个东西)</a></li><li id="2148" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated"><a class="ae kf" href="http://mrhaki.blogspot.com/2009/08/groovy-goodness-elvis-operator.html" rel="noopener ugc nofollow" target="_blank">猫王操作员</a></li><li id="a382" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated"><a class="ae kf" href="http://mrhaki.blogspot.com/2009/08/groovy-goodness-safe-navigation-to.html" rel="noopener ugc nofollow" target="_blank">空安全取消引用</a></li></ul><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4c9985a88b667d5a416283481ab10c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*luoZi_w_3ouJh2pf7q_erg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://www.pexels.com/@freestocks?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">freestocks.org</a>从<a class="ae kf" href="https://www.pexels.com/photo/wedding-couple-sitting-on-green-grass-in-front-of-body-of-water-at-sunset-70737/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄</figcaption></figure><p id="f457" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我可以继续下去。</p><p id="d0ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我恋爱了。</p><p id="64e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我很快向我所有的朋友宣扬groovy比他们原始的Java优越。我发誓我再也不会用Java了。</p><p id="33a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么我要，我已经很棒了。我们是天生的一对。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/e8499ab9795a45ba61eaf5cc678f542f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9F-2P7porZisq9XJS9xRQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://www.pexels.com/@jplenio?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Johannes Plenio </a>从<a class="ae kf" href="https://www.pexels.com/photo/silhouette-photography-of-boat-on-water-during-sunset-1118874/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</figcaption></figure><p id="72d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">麻烦开始于Java 8问世的时候。我本应该注意到这些警告信号，但我被对Groovy的热爱蒙蔽了双眼。</p><p id="a287" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于那些不了解情况的人来说，Java 8可能是自1.5以来最大的Java版本之一。它引入了许多新的语言结构，包括:</p><ul class=""><li id="fa53" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated"><a class="ae kf" href="https://www.geeksforgeeks.org/lambda-expressions-java-8/" rel="noopener ugc nofollow" target="_blank">兰达的</a></li><li id="1702" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated"><a class="ae kf" href="https://www.baeldung.com/java-8-streams" rel="noopener ugc nofollow" target="_blank">溪流</a></li><li id="6be9" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated"><a class="ae kf" href="http://tutorials.jenkov.com/java/modules.html" rel="noopener ugc nofollow" target="_blank">模块</a></li></ul><p id="8004" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一名优秀的Java开发人员，并希望总是尝试新事物，我开始在我的groovy代码中使用这些新东西。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/0fca809204a41ae70dd03ee0cc5b5d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ui6dmPR1awlHqKtpxORFw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自<a class="ae kf" href="https://www.pexels.com/photo/food-restaurant-summer-nuts-2424/" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae kf" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">像素</a></figcaption></figure><h2 id="c622" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">λ和流</h2><p id="3931" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">Lambda和streams就像花生酱和巧克力一样。它们让生活变得有价值:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="34fd" class="ln lo it lj b gy lp lq l lr ls">List&lt;SimpleBean&gt; myList = <strong class="lj iu">new </strong>ArrayList&lt;&gt;();<br/>myList.stream()<br/>        .filter(b -&gt; b.getValue1() &gt; 5)<br/>        .map(SimpleBean::getValue2)<br/>        .collect(Collectors.<em class="nf">toList</em>());</span></pre><p id="adc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Groovy有lamda，也有streams。但是我想像那些酷孩子一样使用新的Java 8，但是是用Groovy。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1532" class="ln lo it lj b gy lp lq l lr ls">List&lt;SimpleBean&gt; myList = []<br/>myList.stream()<br/>        .filter({ SimpleBean b -&gt; b.value1 &gt; 5 } <strong class="lj iu">as </strong>Predicate)<br/>        .map({SimpleBean b -&gt; b.value2} <strong class="lj iu">as </strong>Function)<br/>        .collect(Collectors.<em class="nf">toList</em>())</span></pre><p id="c0df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那是什么？？！我简单可爱的小脸蛋怎么了？Groovy对所有事情都使用闭包！这意味着，当你想使用一个一般类型的接口，比如谓词&gt;或函数,?&gt;时，你需要对你的非类型闭包进行类型转换，这样它才能工作。</p><h2 id="1e3d" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">GString vs String</h2><p id="c8c4" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">如前所述，早期的字符串插值是可怕的。我喜欢它。但是groovy做了一些奇怪的事情。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d2a9" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">"</strong>${sb.value1}<strong class="lj iu"> some other string stuff </strong>${sb.value2}<strong class="lj iu">"</strong></span></pre><p id="64a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是字符串。这是个惊喜。在需要呈现之前，它不会计算字符串。理论上，这意味着如果<em class="nf"> sb.value1 </em>改变，我可以使用相同的GString并显示不同的值。实际上，我从来不需要这个功能。实际上，这意味着很多时候我不得不帮助groovy和type将字符串转换成字符串。？？？</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e247" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">"</strong>${sb.value1}<strong class="lj iu"> some other string stuff </strong>${sb.value2}<strong class="lj iu">" as String</strong></span></pre><p id="55c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很奇怪吧？</p><h2 id="c5f8" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">类型检查</h2><p id="b6b2" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">起初，我觉得自己被证明是正确的。最后，我可以像那些自负的Python程序员一样嘲笑Java和它愚蠢的类型检查。谁需要它，我现在有groovy。我只需要def。</p><p id="a0f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我开始得到运行时异常:</p><ul class=""><li id="2f8b" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated">未知方法</li><li id="219f" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">没有这样的财产</li><li id="5d21" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">无法在…之间转换</li></ul><p id="518e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哦，对了。</p><p id="9c35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类型检查会发现所有这些。没关系，我将使用Groovy的内置类型检查，并开始用</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="55d9" class="ln lo it lj b gy lp lq l lr ls">@CompileStatic</span></pre><p id="c10b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这应该能解决问题。就这样发生了。但是现在Groovy实施了类型检查。我放了些奇怪的东西，比如:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="da7c" class="ln lo it lj b gy lp lq l lr ls">.setList([] as List&lt;String&gt;)</span></pre><p id="77dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我可以用Java非常简单地做到这一点:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="615e" class="ln lo it lj b gy lp lq l lr ls">.setList(Collections.emptyList())</span></pre><p id="de25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的Java是类型安全和不可变的。</p><p id="5d6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，关于不变的…</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/34961b250a59d64e3c418d414ba04d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*TofuWImbw62ngu-4R3HpCA.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">皮克斯贝</a>从<a class="ae kf" href="https://www.pexels.com/photo/human-fist-163431/" rel="noopener ugc nofollow" target="_blank">Pexels.com</a></figcaption></figure><h2 id="9c11" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">不变的</h2><p id="b82c" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">大多数人都同意不可变对象由以下部分组成:</p><ul class=""><li id="b32d" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated">状态被初始化一次的对象</li><li id="8389" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">状态不能改变</li><li id="e2dd" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">写入时复制</li></ul><p id="0809" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">起初，人们会想，哦，这在groovy中很容易做到。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="cb84" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">class </strong>SimpleBean {<br/>    <strong class="lj iu">final int value1<br/>    final </strong>String <strong class="lj iu">value2<br/></strong>}</span></pre><p id="d7b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成了。</p><p id="ad7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有，没有。我们需要一个构造函数，因为默认的构造函数不起作用。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5adf" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">class </strong>SimpleBean {<br/>    <strong class="lj iu">final int value1<br/>    final </strong>String <strong class="lj iu">value2<br/>    </strong>SimpleBean (<strong class="lj iu">int </strong>value, String value2) {<br/>        <strong class="lj iu">this</strong>.<strong class="lj iu">value1 </strong>= <strong class="lj iu">value1<br/>        this</strong>.<strong class="lj iu">value1 </strong>= value2<br/>    }<br/>}</span></pre><p id="0220" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在好了吗？不完全是。你看，通过提供一个构造函数，你使它不再工作。所以你真的需要提供一个地图构造器…手动的。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5ccd" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">class </strong>SimpleBean {<br/>    <strong class="lj iu">final int value1<br/>    final </strong>String <strong class="lj iu">value2<br/>    </strong>SimpleBean (<strong class="lj iu">int </strong>value, String value2) {<br/>        <strong class="lj iu">this</strong>.<strong class="lj iu">value1 </strong>= <strong class="lj iu">value1<br/>        this</strong>.<strong class="lj iu">value1 </strong>= value2<br/>    }<br/>    SimpleBean(Map&lt;?,?&gt; values) {<br/>        <strong class="lj iu">this</strong>.<strong class="lj iu">value1 </strong>= values[<strong class="lj iu">'value1'</strong>] <strong class="lj iu">as int<br/>        this</strong>.<strong class="lj iu">value2 </strong>= values[<strong class="lj iu">'value2'</strong>]<br/>    }<br/>}</span></pre><p id="c465" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们终于完成了，对吗？不完全是。虽然这可能行得通，但我们并没有真正以我们应该有的方式实现map构造函数，比如防止未知值等。但是在这一点上继续前进，进入一个核心问题。</p><p id="f207" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你看，Groovy并没有真正的<em class="nf"> final概念。</em>就此而言，它其实也没有<em class="nf">私有</em>的概念。大多数情况下，您可以自由地修改final字段，并访问内部私有成员。</p><p id="1463" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来吧，试试看！</p><p id="c116" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一种非常Python的做事方式。但是我们(Java开发者)喜欢控制。我们喜欢安全性和封装性。当涉及到不可变对象时，我们需要它！</p><p id="e55e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然可以，<em class="nf">正确地</em>在groovy中做不可变对象:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c274" class="ln lo it lj b gy lp lq l lr ls">@Immutable<br/><strong class="lj iu">class </strong>SimpleBean {<br/>    <strong class="lj iu">int value1<br/>    </strong>String <strong class="lj iu">value2<br/></strong>}</span></pre><p id="1e0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单。不知何故，它甚至加强了最终性质和私有变量。哈扎！</p><p id="6217" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只是没有。</p><p id="043f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我想要一个自定义的构造函数呢？</p><p id="8355" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">抱歉，不能为不可变对象提供构造函数。</p><p id="0bb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，那默认值呢？</p><p id="47a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不，也不能这么做。</p><p id="21f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非空强制呢？</p><p id="1a94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有。</p><p id="98f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上，如果你想要其中的任何一个，你需要为你的不可变对象创建一个构建器，希望并祈祷有人不要调用那个公共的构建器，它只是坐在那里，等着他们。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/b897b36d7e05a10fa354ec728e941832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvUzE5m09i2JdwMqpV-e4w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://www.pexels.com/photo/analogue-art-box-chest-366791/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kf" href="https://www.pexels.com/@david-bartus-43782?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">大卫·巴图斯</a>拍摄</figcaption></figure><h2 id="7173" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">Java模块</h2><p id="0953" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">Groovy在内部严重依赖反射。以至于在Java模块发布后的一段时间内，Groovy无法工作。即使有反射，你也不能访问你不应该访问的东西。公平地说，这破坏了许多其他库，slf4j、CORBA、Spring、Jenkins等等。任何依赖于具有自由访问权限的全局类路径的东西都会崩溃。</p><p id="f689" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我实际上已经习惯并欢迎的事情，因为它让我回到了我在OSGi的多级路径时代。但我没想到Groovy会如此受欢迎。</p><h2 id="06e2" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">真实</h2><p id="3049" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">你要么喜欢它，要么讨厌它。起初我很喜欢它:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f146" class="ln lo it lj b gy lp lq l lr ls">List items;<br/>if (items) {<br/>   ...<br/>}</span></pre><p id="1080" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是让我们深入研究一下。if子句中实际发生了什么。Groovy将尝试将条件子句中的项目转换为true。它并不总是相同的，也不总是显而易见的。在这种情况下，如果items为非null且非空，则该子句为true。相当良性。让我们试试别的:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="29fc" class="ln lo it lj b gy lp lq l lr ls">BigDecimal v1 = 0.00<br/>BigDecimal v2 = 0.000</span><span id="7197" class="ln lo it lj b gy ni lq l lr ls">v1 == v2</span></pre><p id="c780" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的等号是对还是错？首先，如果你不知道Java devs，groovy中的' == '不是等价检查。正如许多医生会告诉你的那样，这也不是“<em class="nf">等于</em>”的捷径。不，时髦是卑鄙的。如果可以，它将首先尝试一个“<em class="nf">与</em>的比较，然后它将依靠“<em class="nf">等于</em>”。所以上面的v1不等于v2，因为精度不同。但是由于groovy使用了compareTo，所以' == '的值将为true。现在你可以说0.00等于0.000，在某些情况下，我们想知道精度是否也不同。</p><p id="748a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就说到我的重点了。直到Groovy在运行时以奇怪的方式中断，有时Groovy在做什么并不明显。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/dd93a5f4cb7891f66b58858fba2253d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gW0ZNd7PiBwhDB5EZi1EWg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自<a class="ae kf" href="https://www.pexels.com/photo/newly-make-high-rise-building-162557/" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae kf" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">像素</a></figcaption></figure><h2 id="5e64" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">编译工具</h2><p id="7ecb" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">groovyc没问题，就像gcc没问题，javac没问题一样。意思是一点也不好。使用Maven编译groovy时，我反复纠结。现在，公平地说，这并不是groovy的错，而是Maven的错。</p><p id="5c05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多方法可以做到这一点。</p><ul class=""><li id="f2d8" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated">如果你需要Groovy 1.8，这是镇上唯一的游戏</li><li id="a246" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated"><a class="ae kf" href="https://groovy.github.io/gmaven/" rel="noopener ugc nofollow" target="_blank"> GMaven </a>(已弃用)</li><li id="f5f0" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated"><a class="ae kf" href="https://github.com/groovy/GMavenPlus" rel="noopener ugc nofollow" target="_blank"> GMaven Plus </a></li><li id="7cc3" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated"><a class="ae kf" href="https://github.com/groovy/groovy-eclipse/wiki/Groovy-Eclipse-Maven-plugin" rel="noopener ugc nofollow" target="_blank"> Groovy Eclipse Maven插件</a></li></ul><p id="3ed9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GMaven Plus没有集成到普通的Maven编译器中，虽然它声称支持联合编译(同时编译groovy和java ),但我发现它并不总是有效。尤其是当Java和Groovy之间存在某种循环依赖时。</p><p id="449d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Groovy Eclipse也好不到哪里去。很难配置。您需要确保对于您打算使用的groovy版本，您拥有正确版本的编译器和批处理库。它在联合编译方面做得很好。但是不做groovy文档或groovy执行。</p><p id="2b1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Gradle似乎确实比Maven更好地处理了groovy。</p><h2 id="b3f5" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">其他工具</h2><p id="73ed" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">作为第二语言，Groovy获得了第二工具。Checkstyle不起作用。Codenarc还不错，声纳也支持它。IDE基本上可以正确地使用它。Eclipse很糟糕，Intellij工作得相当好。</p><p id="c003" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意到一个趋势？</p><h2 id="159e" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">落后于Java</h2><p id="dbdb" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">作为一种建立在另一种语言之上的语言，从定义上来说，你总是在特性(java模块)上落后。或者，如果你试图创新和前进，你会冒特性冲突的风险(闭包和lambda)。如上所述，这两种情况在Groovy中都很常见。</p><h2 id="2022" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">版本兼容性</h2><p id="94fa" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">Groovy在这里做了一些好事，在这里也做了一些不太好的事情。我可以向他们推荐，我可以用一段为groovy 1.8编译的groovy代码在2.5中运行，干得好！</p><p id="298c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是为什么在微小的版本变化之间会出现问题呢？为什么会改变行为？你为什么撒谎？！？</p><p id="e5d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你使用Groovy，那么Groovy发行说明几乎是必读的。</p><p id="272d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是Groovy中的一个常见主题。他们改变事物。他们以我认为是重大改变的方式改变东西，但是他们没有在他们的版本号中反映出来。</p><p id="2ce5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，从Groovy 2.4到2.5，他们改变了CLI工具。从表面上看，这似乎没什么大不了的，所有的代码仍然可以编译。但是我们有几个工具，从命名的命令行参数，需要一个长的名字和两个破折号</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="bc6e" class="ln lo it lj b gy lp lq l lr ls">--name &lt;value&gt;</span></pre><p id="5fc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到只需要一个“-”。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="252d" class="ln lo it lj b gy lp lq l lr ls">-name &lt;value&gt;</span></pre><p id="77f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这破坏了我们的许多自动化工具，我们花了很长时间才弄明白。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/2dc253fda7ff08b6e79f0c840af8e57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4a_Zan4-WX7vh7G0XQZjw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由来自<a class="ae kf" href="https://www.pexels.com/photo/sunglasses-woman-girl-faceless-2867/" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae kf" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">像素</a></figcaption></figure><h2 id="925e" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">其他奇怪的狗屎</h2><p id="0244" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">您知道Groovy之前在每个类中插入一个字段作为编译的时间戳吗？我不知道，直到我对我们的库做了API分析检查，发现我们类的每个版本都与以前的版本二进制不兼容。</p><p id="05e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者如果在子类中重写了超方法，旧版本的Groovy不支持调用超方法。</p><p id="5215" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者groovy不支持许多现在标准的Java语法，比如:</p><ul class=""><li id="bfa3" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated">接口中的默认方法(即将推出Groovy 3)</li><li id="a1b5" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">Java尝试使用资源块(即将推出Groovy 3)</li><li id="2383" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">方法引用(即将推出的Groovy 3)</li><li id="7bed" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">嵌套代码块(即将推出Groovy 3)</li></ul><p id="91c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种事情已经成为一种文化基因在起作用。“哦，是的，那…#太棒了”</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/24a3b39d69e0e0d75c6232e6e9f488fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Rxw3Kqs3f-OpODXkvyS2Q.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自<a class="ae kf" href="https://www.pexels.com/photo/person-holding-tape-measure-1385749/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae kf" href="https://www.pexels.com/@rawpixel?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">rawpixel.com</a>的照片</figcaption></figure><h2 id="e2f4" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">膨胀</h2><p id="2386" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">随着Groovy的每一次发布，他们都会添加很多东西。乍一看，这似乎很棒。所有这些新的做事方法。但是Groovy试图成为每个人的一切。它给语言增加了许多负担。虽然语法可能更短，但是语法也更复杂，并且总是在变化。</p><p id="5237" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保持一个小的语言特性集是有道理的。做某事没有很多方法。取而代之的是一些正确的方法。以围棋为例。它决不是令人难以置信的功能丰富。恰恰相反。但是你可以在一个下午学会它的语法。</p><p id="0bc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了语法膨胀，还有库膨胀。作为库开发者，我们需要意识到我们给消费者带来的依赖性。</p><p id="127a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">依赖不是免费的。</p><ul class=""><li id="6cc1" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated">部署的应用程序规模增加</li><li id="4558" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">依赖性冲突的风险增加(不在OSGi :P)</li></ul><p id="55df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在groovy已经做了不同的事情来解决这些问题。通过隐藏它们的依赖关系，它们消除了类路径冲突问题，但是代码大小加倍了。所以他们重新使用OSS库，但是这又引入了冲突。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/2a8f7d68add299da081d02e1607a1ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zyJoV--Ti_1Zieym3zOmZA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由来自<a class="ae kf" href="https://www.pexels.com/photo/man-and-woman-sitting-on-bench-984953/" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae kf" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">像素</a></figcaption></figure><h1 id="1654" class="nn lo it bd mj no np nq mm nr ns nt mp nu nv nw ms nx ny nz mv oa ob oc my od bi translated">分手</h1><p id="bd28" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">所以我们站在这里。有一次Java开发人员带着Groovy跑了。新的热门事物。现在我想要回Java。Java 8增加了很多很棒的东西，比如消除Groovy闭包需求的流。但是，我如何获得大量我喜欢groovy的代码简化功能呢？</p><h2 id="bf04" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated"><a class="ae kf" href="https://projectlombok.org" rel="noopener ugc nofollow" target="_blank">龙目岛</a></h2><p id="4129" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">Lombok是javac的扩展。它在编译时插入代码。它插入的代码对其他库没有依赖性。代码很快，并且遵循良好的编程实践。最棒的是，它使阅读Java变得非常简单。</p><p id="52d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是，你没看错JAVA！你写作。java文件，并且可以在使用Lombok的类文件中编写任何java代码。</p><p id="74ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可变Bean(Get/Set/Equals/HashCode/ToString)</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7d96" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">import </strong>lombok.Data;<br/><br/>@Data<br/><strong class="lj iu">public class </strong>SimpleBean {<br/>    <strong class="lj iu">int value1</strong>;<br/>    String <strong class="lj iu">value2</strong>;<br/>}</span></pre><p id="d772" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不可变Bean:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="24e0" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">import </strong>lombok.Value;<br/><br/>@Value<br/><strong class="lj iu">public class </strong>SimpleBean {<br/>    <strong class="lj iu">int value1</strong>;<br/>    String <strong class="lj iu">value2</strong>;<br/>}</span></pre><p id="6d67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">具有构建器模式、默认值和非空强制的不可变bean:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9272" class="ln lo it lj b gy lp lq l lr ls">@Value<br/>@Builder<br/><strong class="lj iu">public class </strong>SimpleBean {<br/>    @Builder.Default<br/>    <strong class="lj iu">int value1</strong>=25;<br/>    @NonNull<br/>    String <strong class="lj iu">value2</strong>;<br/>}</span></pre><p id="5464" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我从哪里来。</p><p id="db02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">良好的</p><ol class=""><li id="e7ce" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld oe lz ma mb bi translated">我仍然写Groovy，</li><li id="736f" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld oe lz ma mb bi translated">我用Lombok写Java</li></ol><p id="ae84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我来说，groovy现在比Java更好的一点甚至不是真正的Groovy。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/71d15dd8090a5a0e41d4c01049af26fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZhtCFidrT5-pQHw7Bzvdw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自<a class="ae kf" href="https://www.pexels.com/photo/board-chalk-chalkboard-exam-459793/" rel="noopener ugc nofollow" target="_blank">像素</a> (CC0)的<a class="ae kf" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">像素</a></figcaption></figure><h2 id="0ee7" class="ln lo it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated"><a class="ae kf" href="http://spockframework.org" rel="noopener ugc nofollow" target="_blank">斯波克</a></h2><p id="6bf8" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们都写测试。但是编写Junit测试很烦人，因为我们被Java的语言特性所困扰。Spock是一个很棒的测试框架，它使用Groovy的语言特性来行善而不是作恶。我可以快速编写人类可读的测试。我可以快速轻松地模仿、模仿、侦查、注射。当测试失败时，我会得到非常有用的错误信息。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="22a7" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu">class </strong>SimpleBeanSpec <strong class="lj iu">extends </strong>Specification {<br/>    <strong class="lj iu">def "test simpleBean"</strong>() {<br/>        <strong class="lj iu">given</strong>:<br/>        SimpleBean bean = <strong class="lj iu">new </strong>SimpleBean()<br/>        <br/>        <strong class="lj iu">when</strong>:<br/>        bean.<strong class="lj iu">value1 </strong>= 25<br/>        <br/>        <strong class="lj iu">then</strong>:<br/>        bean.value1==25<br/>    }<br/>}</span></pre><p id="e8ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上，如果你没有用Spock编写你的测试，你真的应该这么做。因为我只在测试中使用Spock，所以所有的groovy依赖性和我在groovy中遇到的许多其他问题都消失了。</p><h1 id="4f1e" class="nn lo it bd mj no np nq mm nr ns nt mp nu nv nw ms nx ny nz mv oa ob oc my od bi translated">我想念…</h1><p id="827b" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我仍然怀念许多美好的事物。</p><p id="0903" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想念:</p><ul class=""><li id="6e1f" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated">易于创建列表和地图</li><li id="6c95" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">字符串插值</li><li id="7ab1" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">零解引用</li></ul><p id="467d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我发现我没有足够的想念他们来保证继续奋斗。我知道Groovy 3承诺修复我提出的许多问题。但是它也做了很多我不喜欢的事情。Groovy继续引入更多的语法。Groovy正在进行其他大的改变，比如改变解析器。最重要的是，他们仍然落后于Java。</p><p id="761c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许有一天，我会像老朋友一样回到Groovy，或者Java最终会添加一些我觉得它缺少的东西。或者也许，只是也许，会有别的事情发生…</p><p id="7fbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://kotlinlang.org" rel="noopener ugc nofollow" target="_blank">科特林</a>有人吗？</p></div></div>    
</body>
</html>