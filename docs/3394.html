<html>
<head>
<title>Tainting and Labeling Kubernetes Nodes to Run Special Workload — A quick guide that is finally NOT confusing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">污染和标记Kubernetes节点以运行特殊的工作负载——这是一个最终不会令人困惑的快速指南</h1>
<blockquote>原文：<a href="https://itnext.io/tainting-and-labeling-kubernetes-nodes-to-run-special-workload-a-quick-guide-that-is-finally-not-7a19b296fb49?source=collection_archive---------8-----------------------#2019-12-03">https://itnext.io/tainting-and-labeling-kubernetes-nodes-to-run-special-workload-a-quick-guide-that-is-finally-not-7a19b296fb49?source=collection_archive---------8-----------------------#2019-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/4cd98066b7f15097e0134cd714bc569f.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*r0_QdWubthangBlWNSJICg.png"/></div></figure><p id="d26c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好了，伙计们，我打算长话短说，这就是我要做的。我的意思是，这应该很容易，但官方文档(<a class="ae ks" href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" rel="noopener ugc nofollow" target="_blank"> 1 </a>，<a class="ae ks" href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#add-a-label-to-a-node" rel="noopener ugc nofollow" target="_blank"> 2 </a>)让它变得不必要的混乱。所以我想也许我可以填补这个空白。</p><p id="8cc0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我将在这个项目中使用我们在Buffer <a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/how-to-set-kubernetes-resource-requests-and-limits-a-saga-to-improve-cluster-stability-and-a7b1800ecff1">中的一个业务需求，作为这篇博文的例子。</a></p><h1 id="29bd" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">快速回顾</h1><p id="786f" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">因此，我们需要几个专用于运行cronjobs的节点，除此之外别无其他。同时，我们希望确保玉米作业被调度到这些节点，而不是其他节点。这意味着我们需要两样东西</p><ul class=""><li id="3360" class="lw lx iq jw b jx jy kb kc kf ly kj lz kn ma kr mb mc md me bi translated">不承担其他工作负载的受感染节点</li><li id="070c" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">仅到达目标节点的工作负载</li></ul><p id="d4c0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们从节点开始，然后是工作负载</p><h1 id="b305" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">节点</h1><p id="9251" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">由于需求被分解为两个方面(见上文)，我们需要为节点指定两件事情。一如既往，kops是我的首选武器。</p><p id="ebc9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在kops中，你可以这样做<code class="fe mk ml mm mn b">kops edit ig &lt;INSTANCE GROUP IN INTEREST&gt;</code></p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="7555" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">污染节点</h1><p id="fd5d" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">这将阻止其他工作负载被调度给它们。这是通过这两条线实现的</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="0c69" class="my ku iq mn b gy mz na l nb nc">taints: <br/>- dedicated=frequent-cronjob-nodes:NoSchedule</span></pre><h1 id="172c" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">标记节点</h1><p id="c4c1" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">这有助于专门的工作负载定位节点。这是通过这两条线实现的</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="5ab4" class="my ku iq mn b gy mz na l nb nc">nodeLabels: <br/>  kops.k8s.io/instancegroup: frequent-cronjob-nodes</span></pre><p id="e444" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我知道有些人不使用kop。如果你是其中之一，这里有两个命令可以帮助你</p><p id="d0f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mk ml mm mn b">kubectl taint nodes &lt;NODE IN INTEREST&gt; dedicated=frequent-cronjob-nodes:NoSchedule</code></p><p id="c996" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mk ml mm mn b">kubectl label nodes &lt;NODE IN INTEREST&gt; kops.k8s.io/instancegroup=frequent-cronjob-nodes</code></p><h1 id="ee2b" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">工作量</h1><p id="d111" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">与节点类似，我们需要对deployment/cronjob yaml文件做两件事。我包含了一个完整的yaml来保护我们的眼睛<a class="ae ks" href="https://twitter.com/caged/status/1039937162769096704" rel="noopener ugc nofollow" target="_blank">免受这个</a>的伤害(是的，你知道我在说什么)。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="24c3" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">容忍污点</h1><p id="25c4" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">这确保了可以将工作负载调度给受感染的节点。这是通过这些线实现的</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="5ffe" class="my ku iq mn b gy mz na l nb nc">tolerations: <br/>- key: dedicated <br/>  value: frequent-cronjob-nodes <br/>  operator: "Equal" <br/>  effect: NoSchedule</span></pre><h1 id="3717" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">指定目标节点</h1><p id="ded1" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">这确保了只将工作负载调度到指定的节点。这是通过这两条线实现的</p><pre class="mo mp mq mr gt mu mn mv mw aw mx bi"><span id="b071" class="my ku iq mn b gy mz na l nb nc">nodeSelector: <br/>  kops.k8s.io/instancegroup: frequent-cronjob-nodes</span></pre><h1 id="ef4e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">利润</h1><p id="487f" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">这就是了。现在，我们可以放心了，正确的工作负载将被分配到正确的节点。这样，我们可以开始为专门的工作负载构建一些专门的节点组，比如用于机器学习的GPU节点或用于本地缓存的内存密集型节点。</p><p id="451c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我希望这有所帮助。下次，如果您有任何问题，请随时通过<a class="ae ks" href="https://twitter.com/stevenc81" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我。:D</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="87d7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nk">最初发表于</em><a class="ae ks" href="https://gist.github.com/stevenc81/494044f7b90c75efdc0914200824dce2" rel="noopener ugc nofollow" target="_blank">T5【http://github.com】</a><em class="nk">。</em></p></div></div>    
</body>
</html>