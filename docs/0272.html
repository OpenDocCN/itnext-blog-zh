<html>
<head>
<title>Dependency Injection in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的依赖注入</h1>
<blockquote>原文：<a href="https://itnext.io/dependency-injection-in-typescript-1520375c499a?source=collection_archive---------3-----------------------#2018-02-05">https://itnext.io/dependency-injection-in-typescript-1520375c499a?source=collection_archive---------3-----------------------#2018-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c232ae524a2bdbd769ae7a0deb597d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0s9oLVEqZ-UIMy7ygLNxug.png"/></div></div></figure><p id="bf01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我非常喜欢成熟框架的一点是，它们都实现了某种依赖注入。最近，我在TypeScript中试用了这项技术，以便更好地理解<em class="kw">如何在表面下工作。</em></p><h1 id="cfda" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是依赖注入？</h1><p id="7671" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果你不知道DI是什么，我<strong class="ka ir">强烈</strong>推荐<a class="ae ma" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">接触一下</a>。既然这个帖子不应该是关于<em class="kw">什么的？</em>但是更多的关于<em class="kw">如何？</em>在这一点上，让我们尽量保持简单:</p><blockquote class="mb mc md"><p id="f31d" class="jy jz kw ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated"><em class="iq">依赖注入是一种一个对象提供另一个对象的依赖的技术。</em></p></blockquote><p id="a320" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那是什么意思？你的软件的某个<em class="kw">部分</em>(通常称为<em class="kw">注入器</em>)负责构建对象，而不是手动构建你的对象。</p><p id="1fbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象下面的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="97e6" class="mq ky iq mm b gy mr ms l mt mu">class Foo {<br/>}</span><span id="535b" class="mq ky iq mm b gy mv ms l mt mu">class Bar {<br/>  foo: Foo;<br/>  <br/>  constructor() {<br/>    this.foo = new Foo();<br/>  }<br/>}</span><span id="8cc2" class="mq ky iq mm b gy mv ms l mt mu">class Foobar {<br/>  foo: Foo;<br/>  bar: Bar;<br/>  <br/>  constructor() {<br/>    this.foo = new Foo();<br/>    this.bar = new Bar();<br/>  }<br/>}</span></pre><p id="f60a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是<em class="kw">不好的</em>,原因有很多，比如类之间有直接的、不可交换的依赖关系，测试会变得非常困难，遵循你的代码变得非常困难，组件的重用变得更加困难，等等..另一方面,<em class="kw">依赖注入将</em>依赖注入到你的构造函数中，使得所有这些<em class="kw">不好的</em>东西都过时了:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f489" class="mq ky iq mm b gy mr ms l mt mu">class Foo {<br/>}</span><span id="57e6" class="mq ky iq mm b gy mv ms l mt mu">class Bar {<br/>  constructor(foo: Foo) {<br/>  }<br/>}</span><span id="f201" class="mq ky iq mm b gy mv ms l mt mu">class Foobar {<br/>  constructor(foo: Foo, bar: Bar) {<br/>  }<br/>}</span></pre><p id="f6a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要获得<code class="fe mw mx my mm b">Foobar</code>的实例，您需要按照以下方式构建它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="05e5" class="mq ky iq mm b gy mr ms l mt mu">const foobar = new Foobar(new Foo(), new Bar(new Foo()));</span></pre><p id="125e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用负责创建对象的<em class="kw">注入器</em>，你可以简单地做如下事情:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="90dd" class="mq ky iq mm b gy mr ms l mt mu">const foobar = Injector.resolve&lt;Foobar&gt;(Foobar); // returns an instance of Foobar, with all injected dependencies</span></pre><p id="668a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">更好的</em>。</p><p id="10d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于<em class="kw">为什么</em>你应该依赖注入有很多理由，包括可测试性、可维护性、可读性等等..再说一遍，如果你还不知道，那是时候学习一些重要的东西了。</p><h1 id="2cc4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">TypeScript中的依赖注入</h1><p id="8d66" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这篇文章是关于我们自己的(也是最基本的)<code class="fe mw mx my mm b">Injector</code>的实现。如果您只是在寻找一些现有的解决方案来在您的项目中使用DI，那么您应该看看<a class="ae ma" href="http://inversify.io/" rel="noopener ugc nofollow" target="_blank"> InversifyJS </a>，这是一个非常简洁的用于TypeScript的IoC容器。</p><p id="7105" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们要做的是实现我们自己的注入器类，它能够通过注入所有必要的依赖项来解析实例。为此，我们将实现一个定义我们的服务的<code class="fe mw mx my mm b">@Service</code>装饰器(如果你习惯于Angular，你可能会知道这个是<code class="fe mw mx my mm b">@Injectable</code>)和将解析实例的实际<code class="fe mw mx my mm b">Injector</code>。</p><p id="8521" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在深入实现之前，您可能需要了解一些关于TypeScript和DI的知识:</p><h1 id="3930" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">反射和装饰者</h1><p id="245b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们将使用<a class="ae ma" href="https://www.npmjs.com/package/reflect-metadata" rel="noopener ugc nofollow" target="_blank"> reflect-metadata </a>包在运行时获得<a class="ae ma" href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" rel="noopener ugc nofollow" target="_blank">反射功能</a>。有了这个包，就有可能获得关于一个类是如何实现的信息——例如:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="498f" class="mq ky iq mm b gy mr ms l mt mu">const Service = () : ClassDecorator =&gt; {<br/>  return target =&gt; {<br/>    console.log(Reflect.getMetadata('design:paramtypes', target));<br/>  };<br/>};</span><span id="ca29" class="mq ky iq mm b gy mv ms l mt mu">class Bar {}</span><span id="e960" class="mq ky iq mm b gy mv ms l mt mu"><a class="ae ma" href="http://twitter.com/Service" rel="noopener ugc nofollow" target="_blank">@Service</a>()<br/>class Foo {<br/>  constructor(bar: Bar, baz: string) {}<br/>}</span></pre><p id="0d1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将记录:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5964" class="mq ky iq mm b gy mr ms l mt mu">[ [Function: Bar], [Function: String] ]</span></pre><p id="1110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们确实知道需要注入哪些依赖项。如果你不明白为什么这里的<code class="fe mw mx my mm b">Bar</code>是一个<code class="fe mw mx my mm b">Function</code>:我将在下一节讨论这个问题。</p><p id="9852" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重要的</strong>:需要注意的是，没有装饰器的<em class="kw">类没有任何元数据。这似乎是<code class="fe mw mx my mm b">reflect-metadata</code>的一个设计选择，尽管我不确定<a class="ae ma" href="https://stackoverflow.com/questions/48547005/why-is-reflect-metadata-only-working-when-using-a-decorator/" rel="noopener ugc nofollow" target="_blank">背后的原因</a>。</em></p><h1 id="2bdc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe mw mx my mm b">target</code>的类型</h1><p id="123b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一开始我很困惑的一件事是我的<code class="fe mw mx my mm b">Service</code>装饰师的<code class="fe mw mx my mm b">target</code>的类型。<code class="fe mw mx my mm b">Function</code>看起来很奇怪，因为它显然是一个<code class="fe mw mx my mm b">object</code>而不是一个函数。但那是因为JavaScript的工作方式；类只是<a class="ae ma" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank">特殊函数</a>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3911" class="mq ky iq mm b gy mr ms l mt mu">class Foo {<br/>    constructor() {<br/>        // the constructor<br/>    }<br/>    bar() {<br/>        // a method<br/>    }<br/>}</span></pre><p id="bdf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">成为</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="47af" class="mq ky iq mm b gy mr ms l mt mu">var Foo = /** <a class="ae ma" href="http://twitter.com/class" rel="noopener ugc nofollow" target="_blank">@class</a> */ (function () {<br/>    function Foo() {<br/>        // the constructor<br/>    }<br/>    Foo.prototype.bar = function () {<br/>        // a method<br/>    };<br/>    return Foo;<br/>}());</span></pre><p id="830f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编译后。</p><p id="1101" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是<code class="fe mw mx my mm b">Function</code>不是我们想要用于类型的，因为它太通用了。因为此时我们没有处理实际的实例，所以我们需要一个类型来描述用<code class="fe mw mx my mm b">new</code>调用我们的目标后得到的类型:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e0a9" class="mq ky iq mm b gy mr ms l mt mu">interface Type&lt;T&gt; {<br/>  new(...args: any[]): T;<br/>}</span></pre><p id="ab52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mm b">Type&lt;T&gt;</code>能够告诉我们一个对象的实例是什么——或者换句话说:当我们用<code class="fe mw mx my mm b">new</code>调用它时，我们得到了什么。回头看看我们的<code class="fe mw mx my mm b">@Service</code>装饰器，实际类型应该是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c193" class="mq ky iq mm b gy mr ms l mt mu">const Service = () : ClassDecorator =&gt; {<br/>  return target =&gt; {<br/>    // `target` in this case is `Type&lt;Foo&gt;`, not `Foo`<br/>  };<br/>};</span></pre><p id="149c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里困扰我的一件事是<code class="fe mw mx my mm b">ClassDecorator</code>，它看起来像这样:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cb09" class="mq ky iq mm b gy mr ms l mt mu">declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) =&gt; TFunction | void;</span></pre><p id="04ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很不幸，因为我们现在已经知道了对象的类型。要为类装饰器获得更灵活和通用的类型:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8769" class="mq ky iq mm b gy mr ms l mt mu">export type GenericClassDecorator&lt;T&gt; = (target: T) =&gt; void;</span></pre><h1 id="d0bf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">编译后接口消失了</h1><p id="c669" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">因为接口不是JavaScript的一部分，所以在你的TypeScript被编译后它们就消失了。没什么新的，但这意味着我们不能使用接口进行依赖注入。一个例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dd9e" class="mq ky iq mm b gy mr ms l mt mu">interface LoggerInterface {<br/>  write(message: string);<br/>}</span><span id="cc29" class="mq ky iq mm b gy mv ms l mt mu">class Server {<br/>  constructor(logger: LoggerInterface) {<br/>    this.logger.write('Service called');<br/>  }<br/>}</span></pre><p id="e1ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的注入器没有办法知道在这里注入什么，因为接口在运行时已经消失了。</p><p id="9874" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这实际上是一个遗憾，因为这意味着我们总是必须类型提示我们的真正的类，而不是接口。尤其是在测试的时候，这可能会变得非常不幸。</p><p id="0d57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一些变通办法，比如用类代替接口(这感觉很奇怪，会让接口失去意义)或者类似的方法</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b289" class="mq ky iq mm b gy mr ms l mt mu">interface LoggerInterface {<br/>  kind: 'logger';<br/>}</span><span id="6210" class="mq ky iq mm b gy mv ms l mt mu">class FileLogger implements LoggerInterface {<br/>  kind: 'logger';<br/>}</span></pre><p id="0c2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我真的不喜欢这种方法，因为它是多余的，而且很难看。</p><h1 id="3171" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">循环依赖会带来麻烦</h1><p id="9f1d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果你想做一些像这样的事情:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="aa6d" class="mq ky iq mm b gy mr ms l mt mu">@Service()<br/>class Bar {<br/>  constructor(foo: Foo) {}<br/>}</span><span id="4a14" class="mq ky iq mm b gy mv ms l mt mu">@Service()<br/>class Foo {<br/>  constructor(bar: Bar) {}<br/>}</span></pre><p id="410b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会得到一个<code class="fe mw mx my mm b">ReferenceError</code>，告诉你:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1947" class="mq ky iq mm b gy mr ms l mt mu">ReferenceError: Foo is not defined</span></pre><p id="8b6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">原因很明显:<code class="fe mw mx my mm b">Foo</code>在TypeScript试图获取关于<code class="fe mw mx my mm b">Bar</code>的信息时并不存在。</p><p id="64fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不想在这里详述，但是一个可能的解决方法是实现类似Angulars <a class="ae ma" href="https://github.com/angular/angular/blob/master/packages/core/src/di/forward_ref.ts" rel="noopener ugc nofollow" target="_blank"> forwardRef </a>的东西。</p><h1 id="1dfa" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实现我们自己的注射器</h1><p id="f691" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">好了，理论到此为止。让我们实现一个非常基本的注入器类。</p><p id="9d8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用从上面学到的所有东西，从我们的<code class="fe mw mx my mm b">@Service</code>装饰器开始。</p><h1 id="6b64" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe mw mx my mm b">@Service</code>装饰工</h1><p id="5b1b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们将修饰所有的服务，否则它们不会发出元数据(使得不可能注入依赖)。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2597" class="mq ky iq mm b gy mr ms l mt mu">// ServiceDecorator.ts</span><span id="9d50" class="mq ky iq mm b gy mv ms l mt mu">const Service = () : GenericClassDecorator&lt;Type&lt;object&gt;&gt; =&gt; {<br/>  return (target: Type&lt;object&gt;) =&gt; {<br/>    // do something with `target`, e.g. some kind of validation or passing it to the Injector and store them<br/>  };<br/>};</span></pre><h1 id="c205" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><code class="fe mw mx my mm b">Injector</code></h1><p id="2ce9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">注入器能够解析请求的实例。它可能有额外的功能，比如存储已解析的实例(我喜欢称它们为<em class="kw">共享实例</em>，但是为了简单起见，我们现在将尽可能简单地实现它。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="15a6" class="mq ky iq mm b gy mr ms l mt mu">// Injector.ts</span><span id="17db" class="mq ky iq mm b gy mv ms l mt mu">export const Injector = new class {<br/>  // Injector implementation<br/>};</span></pre><p id="6a80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导出一个常量而不是一个类(像<code class="fe mw mx my mm b">export class Injector [...]</code>)的原因是我们的注入器是一个<a class="ae ma" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">单例</a>。否则我们永远不会得到我们的<code class="fe mw mx my mm b">Injector</code>的同一个实例，这意味着每次你<code class="fe mw mx my mm b">import</code>注入器时，你都会得到一个没有注册服务的实例。像每个单身者一样，这也有一些缺点，尤其是在测试的时候。</p><p id="65f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要实现的下一件事是解析实例的方法:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6da2" class="mq ky iq mm b gy mr ms l mt mu">// Injector.ts</span><span id="8d10" class="mq ky iq mm b gy mv ms l mt mu">export const Injector = new class {<br/>  // resolving instances<br/>  resolve&lt;T&gt;(target: Type&lt;any&gt;): T {<br/>    // tokens are required dependencies, while injections are resolved tokens from the Injector<br/>    let tokens = Reflect.getMetadata('design:paramtypes', target) || [],<br/>        injections = tokens.map(token =&gt; Injector.resolve&lt;any&gt;(token));<br/>    <br/>    return new target(...injections);<br/>  }<br/>};</span></pre><p id="011c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。我们的<code class="fe mw mx my mm b">Injector</code>现在能够解析请求的实例。让我们回到开头的例子(现在稍微扩展了)并通过<code class="fe mw mx my mm b">Injector</code>解决它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1d19" class="mq ky iq mm b gy mr ms l mt mu"><a class="ae ma" href="http://twitter.com/Service" rel="noopener ugc nofollow" target="_blank">@Service</a>()<br/>class Foo {<br/>  doFooStuff() {<br/>    console.log('foo');<br/>  }<br/>}</span><span id="395c" class="mq ky iq mm b gy mv ms l mt mu"><a class="ae ma" href="http://twitter.com/Service" rel="noopener ugc nofollow" target="_blank">@Service</a>()<br/>class Bar {<br/>  constructor(public foo: Foo) {<br/>  }</span><span id="3484" class="mq ky iq mm b gy mv ms l mt mu">doBarStuff() {<br/>    console.log('bar');<br/>  }<br/>}</span><span id="15ce" class="mq ky iq mm b gy mv ms l mt mu"><a class="ae ma" href="http://twitter.com/Service" rel="noopener ugc nofollow" target="_blank">@Service</a>()<br/>class Foobar {<br/>  constructor(public foo: Foo, public bar: Bar) {<br/>  }<br/>}</span><span id="7ed5" class="mq ky iq mm b gy mv ms l mt mu">const foobar = Injector.resolve&lt;Foobar&gt;(Foobar);<br/>foobar.bar.doBarStuff();<br/>foobar.foo.doFooStuff();<br/>foobar.bar.foo.doFooStuff();</span></pre><p id="795b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">控制台输出:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fc65" class="mq ky iq mm b gy mr ms l mt mu">bar<br/>foo<br/>foo</span></pre><p id="871f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我们的<code class="fe mw mx my mm b">Injector</code>成功地注入了所有的依赖项。<em class="kw">哇呼！</em></p><h1 id="8461" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="649d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">依赖注入是一个你绝对应该利用的强大工具。这篇文章是关于<em class="kw">DI是如何工作的，应该会让你对如何实现你自己的注入器有所了解。</em></p><p id="fefe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有很多事情要做。举几个例子:</p><ul class=""><li id="6d33" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">错误处理</li><li id="61ca" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">处理循环依赖关系</li><li id="827f" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">存储已解析的实例</li><li id="426d" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">能够注入不止一个构造函数标记</li><li id="cc75" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">等等。</li></ul><p id="375b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但基本上这就是注射器的工作原理。</p><p id="ec58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和往常一样，完整的代码(包括例子和测试)可以在<a class="ae ma" href="https://github.com/nehalist/di-ts" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="0853" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">如果你喜欢这篇文章，请留下你的👏，关注我上</em> <a class="ae ma" href="https://twitter.com/nehalist" rel="noopener ugc nofollow" target="_blank"> <em class="kw">推特</em> </a> <em class="kw">并订阅</em> <a class="ae ma" href="https://nehalist.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">我的快讯</em> </a> <em class="kw">。原载于2018年2月5日</em><a class="ae ma" href="https://nehalist.io/dependency-injection-in-typescript/" rel="noopener ugc nofollow" target="_blank"><em class="kw">https://nehalist . io</em></a><em class="kw">。</em></p></div></div>    
</body>
</html>