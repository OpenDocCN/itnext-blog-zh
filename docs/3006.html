<html>
<head>
<title>Safe and automation friendly canary deployments with Helm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Helm的安全且自动化友好的金丝雀部署</h1>
<blockquote>原文：<a href="https://itnext.io/safe-and-automation-friendly-canary-deployments-with-helm-669394d2c48a?source=collection_archive---------5-----------------------#2019-09-14">https://itnext.io/safe-and-automation-friendly-canary-deployments-with-helm-669394d2c48a?source=collection_archive---------5-----------------------#2019-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2d372722be25b3253be80cd4d8f88079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMARUhBRvsX-YBgklquqkQ.jpeg"/></div></div></figure><div class=""/><p id="acda" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一系列实用、安全和可重复的Kubernetes部署方法的一部分。这些帖子是建筑<a class="ae kx" href="http://deliverybot.github.io" rel="noopener ugc nofollow" target="_blank"><em class="kw">delivery bot</em></a><em class="kw">的一部分，是从GitHub部署到Kubernetes的缺失环节。</em></p><p id="a4c7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Canary部署是在用户群子集上测试新代码的一种非常有效的方式。它们显著降低了部署的爆炸半径，这种部署可能很难通过仅将其暴露给一部分流量来实施。这篇文章将深入探讨如何在Kubernetes中实现这一点，而且是以一种部署自动化友好的方式。这篇文章假设你对舵图和Kubernetes资源有所了解。</p><figure class="kz la lb lc gt is gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/42ca1b0fb95d3a7f28dbae49fff44a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*tk_mHDWNGDdHTT53usv4Lg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">金丝雀部署</figcaption></figure><p id="742d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes的一个简单的canary部署涉及两个关键资源:服务和部署资源。canary部署的工作方式是让一个服务资源和两个不同的部署资源为该流量服务。其中一个部署资源将是canary版本，而另一个将是稳定版本。我们可以将金丝雀版本的副本数量保持得更低，以便只为更小比例的流量提供服务。如果你喜欢用Yaml思考，它大致看起来像下面的Kubernetes资源:</p><pre class="kz la lb lc gt lh li lj lk aw ll bi"><span id="5594" class="lm ln jb li b gy lo lp l lq lr">kind: Deployment<br/>metadata:<br/>  name: app-canary<br/>  labels:<br/>    app: app<br/>spec:<br/>  replicas: 1<br/>  ...<br/>    image: myapp:canary<br/>---<br/>kind: Deployment<br/>metadata:<br/>  name: app<br/>  labels:<br/>    app: app<br/>spec:<br/>  replicas: 5<br/>  ...<br/>    image: myapp:stable<br/>---<br/>kind: Service<br/>selector:<br/>  app: app # Selector will route traffic to both deployments.</span></pre><p id="3a50" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很容易想象，只要使用kubectl，甚至在Kubernetes文档<a class="ae kx" href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" rel="noopener ugc nofollow" target="_blank">中有一个很好的指南。这篇文章的问题是，我们将如何自动化这一点，另外如何用Helm做到这一点。</a></p><h2 id="d174" class="lm ln jb bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated"><strong class="ak">自动化金丝雀</strong></h2><p id="eb3d" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">首先，我们需要一个基本的掌舵图，包含我们上面讨论的资源。舵轮图应该是这样的:</p><pre class="kz la lb lc gt lh li lj lk aw ll bi"><span id="4bd7" class="lm ln jb li b gy lo lp l lq lr">~/charts/app<br/>├── Chart.yaml<br/>├── README.md<br/>├── templates<br/>│   ├── NOTES.txt<br/>│   ├── _helpers.tpl<br/>│   ├── deployment.yaml<br/>│   └── service.yaml<br/>└── values.yaml</span></pre><p id="9f04" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Helm的核心概念是管理多个版本。稳定版本是我们代码稳定版本的主要发布途径。然后，我们可以用我们的金丝雀代码部署金丝雀头盔释放。连接这些的部分是稳定版本必须将流量路由到金丝雀版本。我们将通过使用服务上的特定选择器来管理这一点:</p><pre class="kz la lb lc gt lh li lj lk aw ll bi"><span id="51c0" class="lm ln jb li b gy lo lp l lq lr">selector:<br/>  app.kubernetes.io/name: myapp</span></pre><p id="1025" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的部署资源(canary和stable)将在pod上指定此标签。只要我们在部署掌舵图的金丝雀版本时正确设置了这一点，我们就会看到流量将被路由到已部署的pod。</p><p id="2434" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们发布图表的稳定版本。这将类似于以下命令:</p><pre class="kz la lb lc gt lh li lj lk aw ll bi"><span id="002b" class="lm ln jb li b gy lo lp l lq lr">helm upgrade<br/>  --install myapp \<br/>  --namespace default \<br/>  --set app.name=myapp \      # Goes into app.kubernetes.io/name<br/>  --set app.version=v1 \      # Goes into app.kubernetes.io/version<br/>  --set image.tag=stable \<br/>  --set replicaCount=5</span></pre><p id="7363" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们测试一下我们的新金丝雀。要推出金丝雀部署，我们只需要区分两件事。版本名称需要不同，这样我们就不会实际上只是升级我们当前的稳定版本。版本和图像标签也需要不同，以便我们部署不同的代码，并且我们可以在部署资源标签中识别这种代码差异。</p><pre class="kz la lb lc gt lh li lj lk aw ll bi"><span id="8fa4" class="lm ln jb li b gy lo lp l lq lr">helm upgrade<br/>  --install <strong class="li jc">myapp-canary</strong> \<br/>  --namespace default \<br/>  --set app.name=myapp \      # Goes into app.kubernetes.io/name<br/>  --set <strong class="li jc">app.version=v2</strong> \      # Goes into app.kubernetes.io/version<br/>  --set <strong class="li jc">image.tag=canary</strong> \<br/>  --set replicaCount=1</span></pre><p id="8e07" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！如果您ping服务，您应该能够看到canary应用程序只是在部分时间路由流量。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="ce0a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在寻找将这种逻辑打包的部署自动化，看看<a class="ae kx" href="https://deliverybot.github.io" rel="noopener ugc nofollow" target="_blank"> Deliverybot </a>，特别是<a class="ae kx" href="https://github.com/deliverybot/helm" rel="noopener ugc nofollow" target="_blank"> Helm GitHub automation </a>。用于测试和实施这些想法的图表位于github.com/deliverybot/helm/charts的<a class="ae kx" href="https://github.com/deliverybot/helm/tree/master/charts/app" rel="noopener ugc nofollow" target="_blank">。这是关于如何进行自动化金丝雀部署的理论概述，但这些工具通过示例和具体概念将它付诸实践。</a></p><p id="c0b7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他职位:</p><ul class=""><li id="e021" class="mv mw jb ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">Kustomize:使用新的Kubernetes模板系统部署应用程序。</li><li id="3596" class="mv mw jb ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><a class="ae kx" href="https://medium.com/@colinjfw/best-practices-for-deploying-to-kubernetes-using-helm-73be1f3040d2" rel="noopener">使用Helm </a>部署到Kubernetes的最佳实践。</li></ul></div></div>    
</body>
</html>