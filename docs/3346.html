<html>
<head>
<title>Frontend dockerized build artifacts with NextJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NextJS的前端dockerized构建工件</h1>
<blockquote>原文：<a href="https://itnext.io/frontend-dockerized-build-artifacts-with-nextjs-9463f3da3362?source=collection_archive---------4-----------------------#2019-11-26">https://itnext.io/frontend-dockerized-build-artifacts-with-nextjs-9463f3da3362?source=collection_archive---------4-----------------------#2019-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b700d81ca7a2ca23026034ab5c38a89c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tSfmFLTulxJ5P03_x4yHQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来自<a class="ae kc" href="https://www.pexels.com/photo/aerial-photography-of-container-van-lot-3063470/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kc" href="https://www.pexels.com/@tomfisk?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">汤姆·菲斯克</a>的照片</figcaption></figure><p id="d61e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部署前端应用程序时，有几种方法可供选择。不错，只是不同的用例。您可以将其docker化(这是用您的应用程序资产和运行时制作一个docker容器)并将其部署到任何支持它的基础架构(Kubernetes等)，或者您可以走一条更简单(且目前更受欢迎)的路线，创建您的应用程序的静态版本，并通过CDN(内容交付网络)提供它，这带来了所有好处(没有服务器，内容更接近用户，因此体验更快，等等)。</p><p id="c331" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可能希望拥有运行时环境，大多数情况下至少有三个:开发、试运行和生产。这将影响您的构建和部署管道。假设您的最新应用程序版本在试运行环境中运行良好(经过测试),并决定将最新版本部署到生产环境中。根据构建方式的不同，您可能会在生产中得到一个不完整的应用程序版本，仅仅是因为存在不正确管理的不完整的依赖关系。因此，您的构建管道执行了生产分支(或标签)的另一个构建，现在我们向我们的用户发送了损坏的代码。不太好。</p><p id="004a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将我们的申请归档确实有所帮助。我们可以为每次提交创建一个docker映像，不受环境限制，标记并存储在我们的注册表中。我们可以放心地在任何环境中推广或运行这个docker映像。既然我们在帖子的标题上有NextJS，那么让我们看看如何对一个NextJS应用程序进行dockerize。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="fead" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">描述的Dockerfile文件有两个阶段。首先，将安装所有依赖项(包括开发依赖项)并进行生产构建，同时删除非生产依赖项。第二阶段将复制相关文件，包括构建和生产依赖项。给我们一个更精简的形象，然后我们可以运行:</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="793a" class="lm ln iq li b gy lo lp l lq lr">$ docker run -d -p 3000:3000 fe-app-image</span></pre><p id="b99e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们希望在运行时环境中运行相同的映像，我们还可以:</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="fe8f" class="lm ln iq li b gy lo lp l lq lr"># Development<br/>$ docker run -d -p 3000:3000 \<br/>-e API=<a class="ae kc" href="https://staging-api.myapp.com" rel="noopener ugc nofollow" target="_blank">https://dev-api.myapp.com</a> \<br/>fe-app-image</span><span id="35a1" class="lm ln iq li b gy ls lp l lq lr"># Staging<br/>$ docker run -d -p 3000:3000 \<br/>-e API=<a class="ae kc" href="https://staging-api.myapp.com" rel="noopener ugc nofollow" target="_blank">https://staging-api.myapp.com</a> \<br/>fe-app-image</span><span id="8b3a" class="lm ln iq li b gy ls lp l lq lr"># Production<br/>$ docker run -d -p 3000:3000 \<br/>-e API=<a class="ae kc" href="https://staging-api.myapp.com" rel="noopener ugc nofollow" target="_blank">https://api.myapp.com</a> \<br/>fe-app-image</span></pre><p id="0474" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者甚至用于本地开发或测试</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="caa0" class="lm ln iq li b gy lo lp l lq lr"># Local dev<br/>$ docker run -d -p 3000:3000 \<br/>-e API=<a class="ae kc" href="https://staging-api.myapp.com" rel="noopener ugc nofollow" target="_blank">http://1</a>92.168.1.87:5000 \<br/>fe-app-image</span></pre><p id="a1e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Docker图像很整洁。现在。对于我们的运行时环境，我们仍然依赖服务器来部署我们的应用程序，以便我们的用户可以访问它。我们描述的另一种选择是静态部署。这就是，构建你的应用程序，这样输出的只是一堆HTML、JS和CSS文件，我们可以将它们放在一个文件夹中，并通过CDN提供服务。这种方法的主要问题是缺乏运行时间。换句话说，我们不能让静态构建环境不可知。注入环境属性就成了我们需要解决的一个问题，通过配置端点(在应用加载前获取)，环境嗅探(检查应用运行的域并从中推断出env变量)，注入HTTP头(还不确定)。都需要额外的工作。(如果您解决了这个问题，请给出您的解决方案)。</p><p id="1aba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通常在静态部署中看到的是:每次我们想要部署到一个特定的环境中，我们都必须运行带有运行时变量的构建过程，这样构建就已经将它们融入其中了。这种方法是可行的，如果你正在进行静态部署的话，这可能就是你现在正在使用的方法。但是，仍然存在上述问题。如果一些依赖项在构建时发生了变化或者没有得到很好的管理，我们不能保证我们的构建会以同样的方式工作。</p><p id="9c9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如何避免这个问题，同时仍然进行静态部署。(不用维护服务器确实很吸引人)好吧，一种方法是仍然为你的应用程序创建一个docker镜像(使用上面描述的Dockerfile)。因此，构建时间与部署时间是分开的。</p><p id="6d88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在部署时，我们可以提取任何映像(轻松回滚FTW)并通过更改入口点来运行它，因此我们将导出它的静态资产，而不是运行应用程序。(多亏了<code class="fe lt lu lv li b">next export</code>命令，这在NextJS上是可行的)</p><pre class="lb lc ld le gt lh li lj lk aw ll bi"><span id="c687" class="lm ln iq li b gy lo lp l lq lr"># Deploying to production<br/>$ docker run \<br/>-e API=<a class="ae kc" href="https://staging-api.myapp.com" rel="noopener ugc nofollow" target="_blank">https://api.myapp.com</a> \<br/>-v ~/cd-folder/out:/app/out \ <br/>--entrypoint "node_modules/.bin/next" \<br/>fe-app-image export</span><span id="97d9" class="lm ln iq li b gy ls lp l lq lr"># Copy static assets from ~/cd-folder/out to your production CDN</span></pre><h2 id="290e" class="lm ln iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">为什么？</h2><ul class=""><li id="a9b9" class="mn mo iq kf b kg mp kk mq ko mr ks ms kw mt la mu mv mw mx bi translated">构建和部署是分开的。依赖性问题不再是一个问题。</li><li id="2300" class="mn mo iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">部署可选性:我们现在可以选择如何部署我们的应用程序。使用docker的Kubernetes或使用CDN的static deploy</li><li id="dac1" class="mn mo iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">轻松回滚。我们可以在docker注册表上构建、标记和存储我们所有的构建。然后，我们可以直接从注册表中选择要部署的版本。</li><li id="a4de" class="mn mo iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">更轻松的本地开发体验。任何开发团队成员，前端或不是可以运行任何版本的前端本地。</li><li id="9ca5" class="mn mo iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">SSR可选性。静态部署不完全支持SSR，只支持页面的特殊渲染。但是，您可以通过将您的应用程序再次部署为docker容器来支持它。</li><li id="bbaa" class="mn mo iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">更容易的本地自动化测试。运行你的docker容器指向一个江湖服务器<a class="ae kc" href="http://www.mbtest.org/" rel="noopener ugc nofollow" target="_blank">http://www.mbtest.org/</a></li></ul><p id="028b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">黑客快乐！</p></div></div>    
</body>
</html>