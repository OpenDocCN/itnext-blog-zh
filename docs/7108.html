<html>
<head>
<title>Create a custom parser like a PRO with PEGJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PEGJS创建一个像PRO一样的自定义解析器</h1>
<blockquote>原文：<a href="https://itnext.io/create-a-custom-parser-like-a-pro-with-pegjs-77e697313926?source=collection_archive---------0-----------------------#2022-06-15">https://itnext.io/create-a-custom-parser-like-a-pro-with-pegjs-77e697313926?source=collection_archive---------0-----------------------#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/184ad7b7e8c0bf5e4f34c0aa0f6f5a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/0*ARVSuorAmhVKhvee.jpg"/></div></figure><h2 id="7453" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">大问题需要大解决方案</h2><p id="a35b" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">正则表达式几十年前就存在了，开发人员几乎每天都使用它来搜索文本或执行快速替换。如果这样很好，那么？为什么是PEGJS？</p><p id="2717" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">关于它的简短故事从文档自动化开始。我当前的应用程序需要处理复杂而庞大的法律文档(我可以自信地说，大约118个word文档页面，使用常规字体大小或更大)。由于法律文档具有很强的可重用性，因此需要提供使用<em class="lq">条件逻辑</em>、<em class="lq">变量</em>、<em class="lq">常量</em>、<em class="lq">函数的能力，并根据处理时注入的数据传递外部值</em>来构建不同的PDF文档。正则表达式在一段时间内很好地解决了这个问题，直到我们发现我们需要使用嵌套条件、函数以及两者的组合来支持更复杂的场景。</p><p id="e246" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">然后正则表达式完全停止工作:</p><ul class=""><li id="caf5" class="lr ls iq ks b kt ll kx lm kd lt kh lu kl lv lk lw lx ly lz bi translated">事实证明，检测具有这种嵌套的嵌套条件并正确处理它是非常困难的。</li><li id="898e" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated">文档开始变得庞大，在100多行文本中查找错误是一项艰巨的任务。</li><li id="8c05" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated">运行所有这些开始成为CPU和RAM密集型任务。</li></ul><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/d8804f7dd3646dee086d619c826288ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*Kmwk5ex5UqcZLRwf.jpg"/></div></figure><p id="59a4" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">在与许多非常复杂的正则表达式斗争了两天之后，我决定改变我的思维方式，正如阿尔伯特·爱因斯坦所说:<em class="lq">“如果你想要不同的结果，就不要做同样的事情”</em>。我不久前听说了解析器，所以我看了一些Javascript选项。</p><ul class=""><li id="85b7" class="lr ls iq ks b kt ll kx lm kd lt kh lu kl lv lk lw lx ly lz bi translated"><a class="ae mk" href="https://chevrotain.io/docs/" rel="noopener ugc nofollow" target="_blank">雪佛兰</a></li><li id="8513" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><a class="ae mk" href="https://pegjs.org/" rel="noopener ugc nofollow" target="_blank">钉</a></li></ul><h1 id="bf17" class="ml jv iq bd jw mm mn mo jz mp mq mr kc ms mt mu kg mv mw mx kk my mz na ko nb bi translated">解析器到底是做什么的？</h1><p id="2ed1" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">解析器是一种软件，它将纯文本作为输入，并将其转换为有意义且可以解释的数据结构。根据定义，这已经解决了我的问题，耶！。在<a class="ae mk" href="https://en.wikipedia.org/wiki/Parsing" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Parsing</a>的精彩解说</p><h1 id="7d82" class="ml jv iq bd jw mm mn mo jz mp mq mr kc ms mt mu kg mv mw mx kk my mz na ko nb bi translated">派格斯来营救了</h1><p id="bea0" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated"><strong class="ks ir"> PEGJS </strong>是一个<strong class="ks ir"> <em class="lq">解析器生成器</em> </strong>，它从一个<strong class="ks ir"> <em class="lq">语法</em> </strong>生成<strong class="ks ir"> <em class="lq">解析器</em> </strong>。解析器可用于生成AST ( <em class="lq">抽象语法树</em>)，然后使用定制的<strong class="ks ir">I<em class="lq">interpreter</em></strong>(获取AST并遍历它的软件)处理AST。</p><p id="d679" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated"><strong class="ks ir">这就是我前进的步伐:</strong></p><ul class=""><li id="1dce" class="lr ls iq ks b kt ll kx lm kd lt kh lu kl lv lk lw lx ly lz bi translated">学习如何编写正确的语法来支持我在PEGJS上的自定义语言。</li><li id="a310" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated">基于我的语法从PEGJS解析器返回一个好的AST。</li><li id="0948" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir">写一个解释器来处理树并创建我的文档。</strong></li></ul><h1 id="2f98" class="ml jv iq bd jw mm mn mo jz mp mq mr kc ms mt mu kg mv mw mx kk my mz na ko nb bi translated">语言定义</h1><p id="6dc9" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">下面是需要支持的语法的概述。正如我们所看到的，纯文本结合了条件和一些奇怪的符号，解释如下。它看起来几乎像一个MD编辑器，但内部要复杂得多。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/5823f89d7d9d5ae696e7de20933706f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1542J6bZm5XYQsyBX1Eyw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">【https://peg-parser-viewer.herokuapp.com/ T4】</figcaption></figure><h2 id="ca78" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">条件式</h2><p id="d464" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">需要编写这样的条件，它可以接受几个操作符、标记、函数和分支:</p><ul class=""><li id="cd1f" class="lr ls iq ks b kt ll kx lm kd lt kh lu kl lv lk lw lx ly lz bi translated">相等=</li><li id="3d0d" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated">大于或等于≥</li><li id="01f0" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated">次要或等于≤</li><li id="3678" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated">更大&gt;</li><li id="6047" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated">minor&lt;</li><li id="7149" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated">Contains $=</li></ul><h2 id="4389" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Tokens</h2><ul class=""><li id="4764" class="lr ls iq ks b kt ku kx ky kd nl kh nm kl nn lk lw lx ly lz bi translated"><strong class="ks ir"><em class="lq">【q # 1】</em></strong>用于用户回答的特定问题的值</li><li id="152f" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"><em class="lq">【c # 1】</em></strong>为常数值</li><li id="bcea" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"><em class="lq">【v # 1】</em></strong>用于用户为重用性而创建的变量</li></ul><p id="1beb" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">这些标记表示从数据源获取的信息，因此文档内部的逻辑将使用动态数据进行处理。</p><h2 id="9260" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">功能</h2><p id="8d0a" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">该语言支持一组15个原生函数标记，接受1个参数作为输入，在处理最终被结果文本替换时必须执行。它还必须支持嵌套结构。</p><h2 id="05e7" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">反馈支持</h2><p id="3dbd" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">当语法错误时，语言需要向用户提供反馈。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/9f7f39bf7c088758db7332db76ce6bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*w7wUOZogsJOiCYl4.jpg"/></div></figure><h1 id="8c63" class="ml jv iq bd jw mm mn mo jz mp mq mr kc ms mt mu kg mv mw mx kk my mz na ko nb bi translated">编写PEGJS语法规则</h1><p id="8105" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">我用https://pegjs.org/online开始了我的旅程，那是创造一个有效语法的战场。在我的例子中，语法的输出是一棵树，我们可以根据需要将它发送给另一个组件(解释器)进行遍历和处理。我需要一个可以访问数据库的有状态解释器来获取问题、答案、常量和变量，以便在处理逻辑之前执行替换。</p><p id="53c3" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">peg是使用规则编写的，后面是解析表达式，可能是Javascript，它接受表达式并转换成有用的东西。</p><h1 id="5b10" class="ml jv iq bd jw mm mn mo jz mp mq mr kc ms mt mu kg mv mw mx kk my mz na ko nb bi translated">用PEG创建语法</h1><p id="2d54" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">PEG使用规则来定义语法。</p><h2 id="6907" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">代码规则</h2><p id="df44" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">一切都从一个<strong class="ks ir">规则开始<em class="lq">开始</em>规则链到另一个我命名为<strong class="ks ir">规则<em class="lq">代码</em>规则</strong>。</strong></p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c7dd" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">这意味着解析器希望任何形式的文本都遵循以下规则:</p><ul class=""><li id="192a" class="lr ls iq ks b kt ll kx lm kd lt kh lu kl lv lk lw lx ly lz bi translated"><strong class="ks ir"><em class="lq">question token</em></strong><em class="lq">:此规则解析一个特殊的问题令牌。</em></li><li id="a7ab" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"><em class="lq">variable token</em></strong><em class="lq">:该规则将用户创建的变量解析为系统中的变量特殊记号。</em></li><li id="912a" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"><em class="lq">constant token</em></strong><em class="lq">:该规则解析整个应用程序域中的静态值，如公司名称等。</em></li><li id="b07d" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"><em class="lq">UnderlineToken:</em></strong><em class="lq">因为文本支持MD格式，所以解析器需要知道这一点。</em></li><li id="a4f1" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"><em class="lq">TocToken:</em></strong><em class="lq">此规则解析目录。</em></li><li id="781b" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"><em class="lq">highlight token:</em></strong><em class="lq">这个规则解析一个特殊的标记，突出显示动态替换。</em></li><li id="c603" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"/></li><li id="dccf" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"><em class="lq">function语句:</em> </strong> <em class="lq">这个规则解析将由解释器执行的函数。</em></li><li id="5c27" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"> <em class="lq">文本:</em> </strong> <em class="lq">这只是构成我们正在构建的文档的文本、数字和符号。</em></li></ul><h2 id="342c" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">提问令牌规则</h2><p id="572b" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">问题令牌将具有格式<strong class="ks ir">【q # id】</strong>，ID是一个数字。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="644d" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">可变令牌规则</h2><p id="2e1c" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">变量令牌的格式为<strong class="ks ir">【v # id】</strong>，ID是一个数字。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="9aee" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">康斯坦托肯法则</h2><p id="c9fd" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">常量令牌的格式是<strong class="ks ir">【c # id】</strong>，ID是一个数字。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0067" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated"><strong class="ks ir"> <em class="lq">注意</em> </strong> : <em class="lq">我在每个规则的末尾使用了Javascript语法来处理输出，并将有效的叶节点返回到我的树中。由于ID是一个数组，我们将输出连接到一行文本</em>。我们可以通过在规则末尾打开和关闭括号来使用JS。</p><h2 id="9a5f" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">底线原则</h2><p id="9aed" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">这里没有什么特别的，我们期望开始或结束标记，它没有被处理，因为它的MD编辑器知道当它显示时该做什么。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="4f32" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">托托肯规则</h2><p id="cd1e" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">另一个简单的文本解析器表达式用于<em class="lq">目录</em>。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="e26e" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">HighlightToken规则</h2><p id="a37a" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">这是一个简单的文字，用来突出显示一些文本。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="72e6" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">ConditionalBooleanStatement规则</h2><p id="40d4" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">条件句更难理解，因为它结合了文字+其他规则。规则期望一个<strong class="ks ir"> <em class="lq">开括号</em> </strong> + <strong class="ks ir"> <em class="lq">空格</em> </strong>(可选)+另一个文字<strong class="ks ir"> <em class="lq"> if条件</em></strong>+<em class="lq">空格</em> (可选)+文字<strong class="ks ir"><em class="lq">=</em></strong><em class="lq">+</em><strong class="ks ir"><em class="lq">空格</em> </strong>(可选)+ <strong class="ks ir"> <em class="lq">开单引号</em> </strong>注意<strong class="ks ir"> <em class="lq"> body1 </em> </strong>和<strong class="ks ir"> <em class="lq"> body2 </em> </strong>使用<strong class="ks ir"><em class="lq">Code r</em></strong>ule<strong class="ks ir"><em class="lq"/></strong>这意味着我们期望文本、令牌、条件或函数内部提供一个本质上的递归嵌套结构。当解释器需要处理这些节点并识别其中的结构时，所有这些都很方便。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9545" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">注意我们使用了下面的<strong class="ks ir"> <em class="lq">或条件</em> </strong>条件规则。这用于条件上的&amp; &amp;和<strong class="ks ir"> || </strong>表达式，能够在一个条件中匹配多个条件。首先，我们期望<strong class="ks ir"> <em class="lq">和条件</em> </strong>规则后面跟着字面<strong class="ks ir">|</strong>，后面跟着<strong class="ks ir"> <em class="lq">和条件</em> </strong>规则。如果解析器不识别表达式，它将退回到<strong class="ks ir"> <em class="lq">和条件</em> </strong>规则，这意味着条件不包含<strong class="ks ir"><em class="lq">|</em>|</strong>运算符<strong class="ks ir">。</strong></p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="32b0" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated"><strong class="ks ir"> <em class="lq">和</em> </strong>条件规则有两种不同的用法。首先，这是<strong class="ks ir"><em class="lq">or条件</em> </strong>规则的回退规则。第二，这是一个由字面<strong class="ks ir"> <em class="lq"> &amp; &amp; </em> </strong>定义的<strong class="ks ir"> <em class="lq">和</em> </strong>运算符，后跟另一个<strong class="ks ir"> <em class="lq">条件语句</em> </strong>规则。如果解析器无法链接<strong class="ks ir"> <em class="lq">和</em> </strong>操作符，它将退回到下面解释的<strong class="ks ir"> <em class="lq">条件语句</em> </strong>规则<strong class="ks ir"> </strong>。注意规则末尾的Javascript表达式，它链接了多个条件，并返回一个包含给定条件的整个先前条件链的谓词对象。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="42f4" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated"><strong class="ks ir"> <em class="lq">条件语句</em> </strong>规则是一个相当常见的条件的原始定义。它包括3个部分:</p><ul class=""><li id="a5a6" class="lr ls iq ks b kt ll kx lm kd lt kh lu kl lv lk lw lx ly lz bi translated"><strong class="ks ir"> <em class="lq"> lhs </em> </strong>:左手侧数值。如果它不是一个值，它就退回到一个<strong class="ks ir"> <em class="lq">函数语句</em> </strong>规则。</li><li id="850d" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"> <em class="lq">运算符</em> </strong>:下面解释的用于比较的运算符。</li><li id="e42e" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated"><strong class="ks ir"> <em class="lq"> rhs </em> </strong>:右手侧数值。如果它不是一个值，它就退回到一个<strong class="ks ir"> <em class="lq">函数语句</em> </strong>规则。</li></ul><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="88b3" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated"><strong class="ks ir"> <em class="lq">运算符</em> </strong>规则是一个简单的规则，它包含了一系列要使用的有效运算符。至少应该使用一个操作符，这就是解析器表达式末尾有+符号的原因。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="11af" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">function语句规则</h2><p id="489a" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">该规则用于定义编写<strong class="ks ir"> <em class="lq">模板函数</em> </strong>的语法。这些功能将由后端的functions dispatcher组件执行。重要的是返回正确的结构，以便稍后在解释器组件中识别函数。</p><p id="711c" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated"><strong class="ks ir"><em class="lq">FunctionStatement</em></strong>规则需要<strong class="ks ir"><em class="lq">all function tokens</em></strong>列表中的任何函数标记，后跟一个<strong class="ks ir"> <em class="lq">开始文字括号+ QuestionToken或字符串或function statement规则。</em>T73】</strong></p><p id="4622" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">注意参数可以是<strong class="ks ir"> <em class="lq">令牌，字符串</em> </strong>或者其他<strong class="ks ir"> <em class="lq">函数</em> </strong>。对于标记，函数将在解释器解析标记后处理。在字符串规则的情况下，解释器不需要任何东西。同样，一个函数可以调用另一个函数，所以一个函数可以被另一个函数嵌套，所以解释器需要足够聪明，首先递归地调度嵌套的函数。</p><p id="65ff" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">类似于条件规则，我们返回一个表示函数结构的对象。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="f210" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">文本规则</h2><p id="1ca2" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">文本规则是代码规则使用的最新回退规则。它解析除了函数、标记和条件使用的特殊字符之外的所有内容，如[]或$。为了使用它们，我们使用逃脱技巧。因此，如果文本需要是文字[那么用户需要写\[。然后，下面的规则将使用代表转义字符的十六进制代码替换该字符。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="e35c" class="ml jv iq bd jw mm mn mo jz mp mq mr kc ms mt mu kg mv mw mx kk my mz na ko nb bi translated">AST输出示例</h1><p id="5440" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">让我们以下面的输入为例，生成一个<strong class="ks ir"> <em class="lq"> AST(抽象语法树)。</em>T11】</strong></p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="68d9" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">在解析器获取输入并成功解析之后，我们将获得以下带有节点和叶子的AST。现在可以将它发送给自定义解释器进行处理。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="da11" class="ml jv iq bd jw mm mn mo jz mp mq mr kc ms mt mu kg mv mw mx kk my mz na ko nb bi translated">编写解释器</h1><p id="2c29" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">最后，还有语法工作和一个有意义且可以处理的AST。这是解释器的任务，获取AST并将所有内容简化为一个纯文本模板。这个解释器是一个有状态的解释器，它在访问树和处理它之前从数据库接收大量数据。当树被访问时，每个节点被不同地对待。我们将在树中找到不同的节点:</p><ul class=""><li id="faa8" class="lr ls iq ks b kt ll kx lm kd lt kh lu kl lv lk lw lx ly lz bi translated">字符串节点，可能包含问题、变量或常量标记。</li><li id="1c0f" class="lr ls iq ks b kt ma kx mb kd mc kh md kl me lk lw lx ly lz bi translated">对象节点，可能是条件或函数。由于其嵌套结构，这些节点必须用递归处理。</li></ul><p id="f320" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">下面我们可以找到一个示例解释器来处理这个树，它就是我在下面列出的演示链接中使用的那个。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="f167" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">演示</h2><p id="ef74" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">这是我用NodeJS和CodeMirror作为编辑器准备的一个小演示。</p><p id="c606" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated"><a class="ae mk" href="https://peg-parser-viewer.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://peg-parser-viewer.herokuapp.com/</a></p><h2 id="1c6e" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h2><p id="1b75" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">使用PEGJS消除了正则表达式处理器的所有问题，它可以用来支持和处理超级复杂的文本结构，创建一个定制语言来处理我们的模板，等等。这是一个非常快的解析器，我能够在ms中处理120页的文本，这太棒了。解析器还提供错误位置反馈，使模板编辑更容易，并提供语法信心。</p><p id="cff2" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">我认为这足以解决我的问题，但我也很想尝试Chevrotain，它提供了许多文档和示例，但与使用PEGJS相比，需要更高的学习曲线。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nr"><img src="../Images/9f244038c45fac4cdb3990b89ca48880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iDcIrQqyTDFqSaNG"/></div></div></figure><h2 id="c115" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">接下来</h2><p id="db81" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">所有这些处理都不便宜，而且非常依赖CPU。我们将探索如何通过使用多处理方法来水平扩展该流程，以避免主事件循环中的长时间运行操作。</p></div></div>    
</body>
</html>