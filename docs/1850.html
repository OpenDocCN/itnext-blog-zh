<html>
<head>
<title>The ‘this’ keyword in JavaScript, demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的“this”关键字，不再神秘</h1>
<blockquote>原文：<a href="https://itnext.io/the-this-keyword-in-javascript-demystified-c389c92de26d?source=collection_archive---------0-----------------------#2019-02-11">https://itnext.io/the-this-keyword-in-javascript-demystified-c389c92de26d?source=collection_archive---------0-----------------------#2019-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c55bd8690bcabfee08af36b2166293ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u98adouc8-eKxM34eqi5Lw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">西蒙·艾布拉姆斯在<a class="ae kc" href="https://unsplash.com/search/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f318" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">刚开始学习JavaScript的时候，我花了一些时间去理解JavaScript中的<code class="fe lb lc ld le b">this</code>关键字，并能够快速识别出<code class="fe lb lc ld le b">this</code>关键字指向哪个对象。我发现理解<code class="fe lb lc ld le b">this</code>关键词最困难的事情是，你通常会忘记你在一门或多门JavaScript课程或学习资源中读到或看到人们解释的不同案例和情况。在ES6中引入箭头函数之后，事情变得更加混乱，因为箭头函数以不同的方式处理<code class="fe lb lc ld le b">this</code>关键字。我想写这篇文章来陈述我所学到的东西，并试图以一种能帮助任何像我一样正在学习JavaScript并且理解<code class="fe lb lc ld le b">this</code>关键词有困难的人的方式来解释它。</p><p id="203b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所知，任何JavaScript行被执行的环境(或范围)被称为“执行上下文”。Javascript运行时维护这些执行上下文的堆栈，并且位于该堆栈顶部的执行上下文当前正在被执行。<code class="fe lb lc ld le b">this</code>变量引用的对象在每次执行上下文改变时都会改变。</p><p id="78f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，执行上下文是全局的，这意味着如果代码作为简单函数调用的一部分被执行，那么<code class="fe lb lc ld le b">this</code>变量将引用全局对象。在浏览器的情况下，全局对象是<code class="fe lb lc ld le b">window</code>对象。例如，在Node.js环境中，一个特殊的对象global将是<code class="fe lb lc ld le b">this</code>的值。</p><p id="3509" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，尝试以下简单的函数调用:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4483" class="ln lo iq le b gy lp lq l lr ls">function foo () {<br/>  console.log("Simple function call");<br/>  console.log(this === window);<br/>}</span><span id="56b2" class="ln lo iq le b gy lt lq l lr ls">foo();</span></pre><p id="210b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过调用<code class="fe lb lc ld le b">foo()</code>，我们将得到以下输出:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0e7d" class="ln lo iq le b gy lp lq l lr ls">“Simple function call”<br/>true</span></pre><p id="1d44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就证明了这里的<code class="fe lb lc ld le b">this</code>指的是<code class="fe lb lc ld le b">global</code>对象，也就是我们例子中的<code class="fe lb lc ld le b">window</code>对象。</p><p id="9cac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，如果为任何函数启用了严格模式，那么<code class="fe lb lc ld le b">this</code>的值将是<code class="fe lb lc ld le b">undefined</code>，因为在严格模式下，全局对象引用<code class="fe lb lc ld le b">undefined</code>而不是<code class="fe lb lc ld le b">window</code>对象。</p><p id="0c26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试试下面的例子:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="807f" class="ln lo iq le b gy lp lq l lr ls">function foo () {<br/>  'use strict';<br/>  console.log("Simple function call");<br/>  console.log(this === window);<br/>}</span><span id="452a" class="ln lo iq le b gy lt lq l lr ls">foo();</span></pre><p id="5417" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们的输出将是:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="98a4" class="ln lo iq le b gy lp lq l lr ls">“Simple function call”<br/>false</span></pre><p id="183b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们想象一下，我们有下面的构造函数:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="7a7b" class="ln lo iq le b gy lp lq l lr ls">function Person(first_name, last_name) {<br/>    this.first_name = first_name;<br/>    this.last_name = last_name;<br/>  <br/>    this.displayName = function() {<br/>        console.log(`Name: ${this.first_name} ${this.last_name}`);<br/>    };<br/>}</span></pre><p id="979d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建一些人员实例:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c9f1" class="ln lo iq le b gy lp lq l lr ls">let john = new Person('John', 'Reid');<br/>john.displayName();</span></pre><p id="5218" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在控制台中尝试这样做，应该会得到以下输出:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f735" class="ln lo iq le b gy lp lq l lr ls">"Name: John Reid"</span></pre><p id="4214" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里发生了什么？当我们在<code class="fe lb lc ld le b">Person</code>上调用<code class="fe lb lc ld le b">new</code>时，JavaScript会在<code class="fe lb lc ld le b">Person</code>函数内部创建一个新对象，并保存为<code class="fe lb lc ld le b">this</code>。然后，<code class="fe lb lc ld le b">first_name</code>、<code class="fe lb lc ld le b">last_name</code>和<code class="fe lb lc ld le b">displayName</code>属性将被添加到新创建的<code class="fe lb lc ld le b">this</code>对象上。我使用了泰勒·麦金尼斯<a class="lu lv ep" href="https://medium.com/u/c52389e3ee63?source=post_page-----c389c92de26d--------------------------------" rel="noopener" target="_blank">的</a><a class="ae kc" href="https://tylermcginnis.com/javascript-visualizer" rel="noopener ugc nofollow" target="_blank"> JavaScript可视化工具</a>来看看这在幕后是什么样子的。这是我得到的:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/1742b3926b5a37e39e90ae52f13862e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wybUfnpHLdxaWJd-0314hQ.png"/></div></div></figure><p id="d983" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会注意到我们在<code class="fe lb lc ld le b">Person</code>的执行上下文中创建了一个<code class="fe lb lc ld le b">this</code>对象，并且这个对象有三个属性<code class="fe lb lc ld le b">first_name</code>、<code class="fe lb lc ld le b">last_name</code>和<code class="fe lb lc ld le b">displayName</code>。这个工具以一种有趣的方式将幕后发生的步骤制作成动画，帮助你理解<code class="fe lb lc ld le b">this</code>对象是如何创建和填充的。</p><p id="0726" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经讨论了与<code class="fe lb lc ld le b">this</code>关键字绑定相关的两种常见情况。还有一个案例我想提一下，可能也有点让人困惑。假设我们有这个函数:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="7fcc" class="ln lo iq le b gy lp lq l lr ls">function simpleFunction () {<br/>    console.log("Simple function call")<br/>    console.log(this === window); <br/>}</span></pre><p id="f456" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在知道，如果我们像下面这样做一个简单的函数调用，<code class="fe lb lc ld le b">this</code>关键字将引用全局对象，在我们的例子中，它是<code class="fe lb lc ld le b">window</code>对象。让我们这样做:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9afd" class="ln lo iq le b gy lp lq l lr ls">simpleFunction();</span></pre><p id="6aac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，我们得到这个作为我们的输出:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f7a6" class="ln lo iq le b gy lp lq l lr ls">“Simple function call”</span><span id="5240" class="ln lo iq le b gy lt lq l lr ls">true</span></pre><p id="39a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建一个简单的用户对象，如下所示:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ecfd" class="ln lo iq le b gy lp lq l lr ls">let user = {<br/>    count: 10,<br/>    simpleFunction: simpleFunction,<br/>    anotherFunction: function() {<br/>        console.log(this === window);<br/>    }<br/>}</span></pre><p id="21c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们有了一个引用我们的<code class="fe lb lc ld le b">simpleFunction </code>函数的<code class="fe lb lc ld le b">simpleFunction</code>属性。我们还添加了另一个属性作为名为<code class="fe lb lc ld le b">anotherFunction</code>的方法。</p><p id="c66c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们调用<code class="fe lb lc ld le b">user.simpleFunction()</code>，我们将在控制台的输出中得到这个:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5251" class="ln lo iq le b gy lp lq l lr ls">“Simple function call”<br/>false</span></pre><p id="135e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么会这样？因为<code class="fe lb lc ld le b">simpleFunction()</code>现在是<code class="fe lb lc ld le b">user</code>对象的一个属性，那么<code class="fe lb lc ld le b">this</code>关键字将引用<code class="fe lb lc ld le b">user</code>对象，而不是本例中的全局对象。</p><p id="f814" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们现在给<code class="fe lb lc ld le b">user.anotherFunction()</code>打电话，我们也应该期待同样的事情。我们的<code class="fe lb lc ld le b">this</code>关键字将引用<code class="fe lb lc ld le b">user</code>对象。因此，<code class="fe lb lc ld le b">console.log(this === window);</code>应该返回<code class="fe lb lc ld le b">false</code>，并且我们应该在控制台中得到这个输出:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ba28" class="ln lo iq le b gy lp lq l lr ls">false</span></pre><p id="041d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再来讨论一个案例。如果我们像下面这样做，会发生什么？</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="d431" class="ln lo iq le b gy lp lq l lr ls">let myFunction = user.anotherFunction;</span><span id="4a0c" class="ln lo iq le b gy lt lq l lr ls">myFunction();</span></pre><p id="8752" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您尝试这样做，应该会得到以下输出:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f357" class="ln lo iq le b gy lp lq l lr ls">true</span></pre><p id="a7b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是为什么会这样呢？在这种情况下，我们做一个简单的函数调用。正如我们现在已经知道的，如果一个方法作为一个简单的函数被调用，那么<code class="fe lb lc ld le b">this</code>关键字将引用全局对象，在我们的例子中它等于<code class="fe lb lc ld le b">window</code>对象，因此<code class="fe lb lc ld le b">console.log(this === window);</code>将打印<code class="fe lb lc ld le b">true</code>。</p><p id="4f2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看另一个例子:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="665f" class="ln lo iq le b gy lp lq l lr ls">var john = {<br/>    name: 'john',<br/>    yearOfBirth: 1990,<br/>    calculateAge: function() {<br/>        console.log(this);<br/>        console.log(2016 - this.yearOfBirth);</span><span id="f6ff" class="ln lo iq le b gy lt lq l lr ls">        function innerFunction() {<br/>            console.log(this);<br/>        }<br/>        innerFunction();<br/>    }<br/>}</span></pre><p id="e4ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们调用<code class="fe lb lc ld le b">john.calculateAge()</code>，现在会发生什么？我们应该得到类似这样的东西:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="b8a6" class="ln lo iq le b gy lp lq l lr ls">{name: "john", yearOfBirth: 1990, calculateAge: ƒ}<br/>26<br/>Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}</span></pre><p id="bc44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">calculateAge</code>函数中，<code class="fe lb lc ld le b">this</code>引用调用的‘John’对象。但是在<code class="fe lb lc ld le b">innerFunction</code>函数内部，这个<code class="fe lb lc ld le b">this</code>指的是全局对象，在这种情况下是<code class="fe lb lc ld le b">window</code>对象。有些人认为这是JS中的一个错误，但是规则说每当我们进行常规函数调用时，那么<code class="fe lb lc ld le b">this</code>将引用全局对象。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="b9ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还了解到JavaScript中的函数也是一种特殊类型的对象。每个函数都有<code class="fe lb lc ld le b">call</code>、<code class="fe lb lc ld le b">bind</code>和<code class="fe lb lc ld le b">apply</code>方法。这些方法可用于将自定义值<code class="fe lb lc ld le b">this</code>设置为函数的执行上下文。让我们看下面的例子:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="2053" class="ln lo iq le b gy lp lq l lr ls">function Person(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;</span><span id="c0ee" class="ln lo iq le b gy lt lq l lr ls">    this.displayName = function() {<br/>        console.log(`Name: ${this.firstName} ${this.lastName}`);<br/>    }<br/>}</span></pre><p id="2487" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建两个新人:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="291c" class="ln lo iq le b gy lp lq l lr ls">let person = new Person("John", "Reed");<br/>let person2 = new Person("Paul", "Adams");</span></pre><p id="07ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并呼叫:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f7dc" class="ln lo iq le b gy lp lq l lr ls">person.displayName();<br/>person2.displayName();</span></pre><p id="1bda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该会打印:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a951" class="ln lo iq le b gy lp lq l lr ls">Name: John Reed<br/>Name: Paul Adams</span></pre><p id="de83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们对<code class="fe lb lc ld le b">person</code>对象使用<code class="fe lb lc ld le b">call</code>:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a1e8" class="ln lo iq le b gy lp lq l lr ls">person.displayName.call(person2);</span></pre><p id="d7bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在这里做的是将<code class="fe lb lc ld le b">this</code>的值设置为<code class="fe lb lc ld le b">person2</code>对象。所以，这应该打印出来:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ad54" class="ln lo iq le b gy lp lq l lr ls">Name: Paul Adams</span></pre><p id="9783" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用<code class="fe lb lc ld le b">apply</code>，同样的情况也会发生:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0304" class="ln lo iq le b gy lp lq l lr ls">person.displayName.apply([person2]);</span></pre><p id="7635" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将获得:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e057" class="ln lo iq le b gy lp lq l lr ls">Name: Paul Adams</span></pre><p id="1fe2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">call</code>和<code class="fe lb lc ld le b">apply</code>方法之间唯一的区别是传递参数的方式。在<code class="fe lb lc ld le b">apply</code>的情况下，第二个参数是一个参数数组，在<code class="fe lb lc ld le b">call</code>方法的情况下，参数被单独传递。</p><p id="a908" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们也试着用<code class="fe lb lc ld le b">bind</code>方法做同样的事情。<code class="fe lb lc ld le b">bind</code>返回一个新方法，其中<code class="fe lb lc ld le b">this</code>引用传递的第一个参数。例如:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="025e" class="ln lo iq le b gy lp lq l lr ls">let person2Display = person.displayName.bind(person2);</span></pre><p id="a13a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们现在调用<code class="fe lb lc ld le b">person2Display</code>，我们也应该得到<code class="fe lb lc ld le b">Name: Paul Adams</code>。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h2 id="fe69" class="ln lo iq bd me mf mg dn mh mi mj dp mk ko ml mm mn ks mo mp mq kw mr ms mt mu bi translated">箭头功能</h2><p id="606f" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">作为ES6的一部分，引入了一种定义函数的新方法。它看起来像下面这样:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9279" class="ln lo iq le b gy lp lq l lr ls">let displayName = (firstName, lastName) =&gt; {<br/>    console.log(Name: ${firstName} ${lastName});<br/>};</span></pre><p id="1b51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与普通函数不同，箭头函数没有自己的<code class="fe lb lc ld le b">this</code>关键字。它们只是使用编写它们的函数的关键字<code class="fe lb lc ld le b">this</code>。他们有一个词法变量<code class="fe lb lc ld le b">this</code>。</p><p id="65d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个我们在ES5中曾经做过的事情的例子:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0f40" class="ln lo iq le b gy lp lq l lr ls">var box = {<br/>    color: 'green', // 1<br/>    position: 1, // 2<br/>    clickMe: function() { // 3<br/>        document.querySelector('body').addEventListener('click', function() {<br/>            var str = 'This is box number ' + this.position + ' and it is ' + this.color; // 4<br/>            alert(str);<br/>        });<br/>    }<br/>}</span></pre><p id="c33d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们打电话:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5b14" class="ln lo iq le b gy lp lq l lr ls">box.clickMe();</span></pre><p id="16f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将显示一条警告，内容为:“这是未定义的箱号，它是未定义的”。</p><p id="4d28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们一步一步来分析这里发生了什么。如果你看上面的例子，我加了一些注释<code class="fe lb lc ld le b">// 1</code>、<code class="fe lb lc ld le b">// 2</code>和<code class="fe lb lc ld le b">// 3</code>。在第<code class="fe lb lc ld le b">// 1</code>和<code class="fe lb lc ld le b">// 2</code>行，我们的<code class="fe lb lc ld le b">this</code>关键字可以访问<code class="fe lb lc ld le b">color</code>和<code class="fe lb lc ld le b">position</code>属性，因为它引用了<code class="fe lb lc ld le b">box</code>对象。</p><p id="29fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">clickMe</code>方法中，我们的<code class="fe lb lc ld le b">this</code>也可以访问<code class="fe lb lc ld le b">color</code>和<code class="fe lb lc ld le b">position</code>属性，因为它仍然引用<code class="fe lb lc ld le b">box</code>对象。但是，<code class="fe lb lc ld le b">clickMe</code>方法为<code class="fe lb lc ld le b">querySelector</code>定义了一个回调函数，这个回调函数现在是一个常规函数调用，所以我们的<code class="fe lb lc ld le b">this</code>现在将引用全局对象，在本例中是<code class="fe lb lc ld le b">body</code>对象。当然，<code class="fe lb lc ld le b">position</code>和<code class="fe lb lc ld le b">color</code>没有在<code class="fe lb lc ld le b">body</code>对象中定义，所以这就是为什么它们的值会是<code class="fe lb lc ld le b">undefined</code>，我们得到一个警告显示‘这是未定义的盒号，它是未定义的’。</p><p id="8aab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用ES5方法解决这个问题，方法如下:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="fe6c" class="ln lo iq le b gy lp lq l lr ls">var box = {<br/>    color: 'green',<br/>    position: 1,<br/>    clickMe: function() {<br/>        var self = this;<br/>        document.querySelector('body').addEventListener('click', function() {<br/>            var str = 'This is box number ' + self.position + ' and it is ' + self.color;<br/>            alert(str);<br/>        });<br/>    }<br/>}</span></pre><p id="8b24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加<code class="fe lb lc ld le b">var self = this</code>是让闭包函数使用引用<code class="fe lb lc ld le b">box</code>对象的<code class="fe lb lc ld le b">this</code>关键字的值的一种变通方法。我们现在只需要在回调函数中使用新的<code class="fe lb lc ld le b">self</code>变量。</p><p id="890a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们打电话:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="64ff" class="ln lo iq le b gy lp lq l lr ls">box.clickMe();</span></pre><p id="417a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该得到一个警告显示:“这是1号箱子，它是绿色的”。</p><p id="b213" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，箭头函数的使用对我们有什么帮助呢？让我们看看下面这个例子，它是基于我们讨论过的上一个例子。我们将用箭头函数替换<code class="fe lb lc ld le b">clickMe</code>内部点击事件监听器的回调函数:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="fe11" class="ln lo iq le b gy lp lq l lr ls">var box = {<br/>    color: 'green',<br/>    position: 1,<br/>    clickMe: function() {<br/>        document.querySelector('body').addEventListener('click', () =&gt; {<br/>            var str = 'This is box number ' + this.position + ' and it is ' + this.color;<br/>            alert(str);<br/>        });<br/>    }<br/>}</span></pre><p id="7cab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于箭头函数令人惊奇的事情是它们共享它们周围的词法关键字<code class="fe lb lc ld le b">this</code>。因此，在我们的例子中，它与它的外部函数共享关键字<code class="fe lb lc ld le b">this </code>。外部函数的这个<code class="fe lb lc ld le b">this</code>关键字引用了<code class="fe lb lc ld le b">box</code>对象，因此<code class="fe lb lc ld le b">this.position</code>和<code class="fe lb lc ld le b">this.color</code>将具有正确的值<code class="fe lb lc ld le b">green</code>和<code class="fe lb lc ld le b">1</code>。</p><p id="abfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们再举一个例子:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ea52" class="ln lo iq le b gy lp lq l lr ls">var box = {<br/>    color: 'green',<br/>    position: 1,<br/>    clickMe: () =&gt; {<br/>        document.querySelector('body').addEventListener('click', () =&gt; {<br/>            var str = 'This is box number ' + this.position + ' and it is ' + this.color;<br/>            alert(str);<br/>        });<br/>    }<br/>}</span></pre><p id="b3cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦！现在，我们得到一个警告说:'这是未定义的箱子号码，它是未定义的'。这里发生了什么？</p><p id="c3b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">click</code>事件侦听器的闭包的<code class="fe lb lc ld le b">this</code>关键字共享其周围的<code class="fe lb lc ld le b">this</code>关键字的值。在这种情况下，其周围是箭头功能<code class="fe lb lc ld le b">clickMe</code>。<code class="fe lb lc ld le b">clickMe</code> arrow函数的<code class="fe lb lc ld le b">this</code>关键字引用全局对象，在本例中是<code class="fe lb lc ld le b">window</code>对象。因此，<code class="fe lb lc ld le b">this.position</code>和<code class="fe lb lc ld le b">this.color</code>将是未定义的，因为我们的<code class="fe lb lc ld le b">window</code>对象不知道任何关于<code class="fe lb lc ld le b">position</code>或<code class="fe lb lc ld le b">color</code>属性的事情。</p><p id="b7db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想再给你看一个例子，这是一个关于<code class="fe lb lc ld le b">map</code>函数的常见例子，它在很多情况下都很有用。我们在上面定义了一个<code class="fe lb lc ld le b">Person</code>构造函数方法:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5ba2" class="ln lo iq le b gy lp lq l lr ls">function Person(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;</span><span id="f372" class="ln lo iq le b gy lt lq l lr ls">    this.displayName = function() {<br/>        console.log(`Name: ${this.firstName} ${this.lastName}`);<br/>    }<br/>}</span></pre><p id="86eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们给<code class="fe lb lc ld le b">Person</code>的原型添加一个名为<code class="fe lb lc ld le b">myFriends</code>的新方法:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4c2d" class="ln lo iq le b gy lp lq l lr ls">Person.prototype.myFriends = function(friends) {<br/>    var arr = friends.map(function(friend) {<br/>        return this.firstName + ' is friends with ' + friend;<br/>    });<br/>    console.log(arr);<br/>}</span></pre><p id="16dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建一个新人:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="17cd" class="ln lo iq le b gy lp lq l lr ls">let john = new Person("John", "Watson");</span></pre><p id="16f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们调用<code class="fe lb lc ld le b">john.myFriends(["Emma", "Tom"])</code>，我们将得到这样的输出:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="2b11" class="ln lo iq le b gy lp lq l lr ls">["undefined is friends with Emma", "undefined is friends with Tom"]</span></pre><p id="a805" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与我们上面讨论的例子非常接近。<code class="fe lb lc ld le b">myFriends</code>函数体中会有一个引用调用对象的<code class="fe lb lc ld le b">this</code>关键字。但是，<code class="fe lb lc ld le b">map</code>函数内部的闭包是一个普通的函数调用，所以<code class="fe lb lc ld le b">map</code>函数闭包内部的<code class="fe lb lc ld le b">this</code>关键字将引用全局对象，在这种情况下是<code class="fe lb lc ld le b">window</code>对象使得<code class="fe lb lc ld le b">this.firstName</code>的值未定义。现在我们知道如何解决这个问题了！我们至少有三种方法来解决这种情况:</p><ol class=""><li id="ef18" class="na nb iq kf b kg kh kk kl ko nc ks nd kw ne la nf ng nh ni bi translated">通过将<code class="fe lb lc ld le b">myFriends</code>函数体内的<code class="fe lb lc ld le b">this</code>赋给另一个变量，例如称为<code class="fe lb lc ld le b">self</code>，并在<code class="fe lb lc ld le b">map</code>函数的闭包内使用它:</li></ol><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6297" class="ln lo iq le b gy lp lq l lr ls">Person.prototype.myFriends = function(friends) {<br/>    // 'this' keyword maps to the calling object<br/>    var self = this;<br/>    var arr = friends.map(function(friend) {<br/>        // 'this' keyword maps to the global object<br/>        // here, 'this.firstName' is undefined.<br/>        return self.firstName + ' is friends with ' + friend;<br/>    });<br/>    console.log(arr);<br/>}</span></pre><p id="385f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.通过在<code class="fe lb lc ld le b">map</code>函数的闭包上使用<code class="fe lb lc ld le b">bind</code>:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="8f21" class="ln lo iq le b gy lp lq l lr ls">Person.prototype.myFriends = function(friends) {<br/>    // 'this' keyword maps to the calling object<br/>    var arr = friends.map(function(friend) {<br/>        // 'this' keyword maps to the global object<br/>        // here, 'this.firstName' is undefined.<br/>        return this.firstName + ' is friends with ' + friend;<br/>    }.bind(this));<br/>    console.log(arr);<br/>}</span></pre><p id="85d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用<code class="fe lb lc ld le b">bind</code>将返回映射回调函数的新副本，但是带有映射到外部<code class="fe lb lc ld le b">this</code>关键字的<code class="fe lb lc ld le b">this</code>关键字，在这种情况下，将是引用对象调用<code class="fe lb lc ld le b">myFriends</code>的<code class="fe lb lc ld le b">this</code>关键字。</p><p id="8eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.我们可以将<code class="fe lb lc ld le b">map</code>函数的回调创建为一个箭头函数:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="dfc7" class="ln lo iq le b gy lp lq l lr ls">Person.prototype.myFriends = function(friends) {<br/>    var arr = friends.map(friend =&gt; `${this.firstName} is friends with ${friend}`);<br/>    console.log(arr);<br/>}</span></pre><p id="d3e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，arrow函数定义中的<code class="fe lb lc ld le b">this</code>关键字将从其周围共享词法范围，这是我们已经创建的实例<code class="fe lb lc ld le b">myFriends</code>。</p><p id="ea31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上三种解决方案都应该给出这样的结果:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ce10" class="ln lo iq le b gy lp lq l lr ls">["John is friends with Emma", "John is friends with Tom"]</span></pre></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="8535" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一点上，我希望我已经设法让<code class="fe lb lc ld le b">this</code>这个关键词的概念对你来说变得有点平易近人了。在这篇文章中，我分享了一些我遇到过的常见情况以及如何处理它们，但是当然，随着您构建更多的项目，您将会遇到更多的情况。希望我的讲解可以帮助你在接近<code class="fe lb lc ld le b">this</code>关键词绑定话题时保持坚实的基础。如果您有任何问题、建议或改进，我总是很乐意了解更多信息，并与世界各地所有优秀的开发人员交流知识。请随意写评论，<a class="ae kc" href="https://www.twitter.com/_MohamadSafwat" rel="noopener ugc nofollow" target="_blank">发微博给我</a>，或者<a class="ae kc" href="mailto:mailmsafwat@gmail.com" rel="noopener ugc nofollow" target="_blank">给我留言</a>！</p></div></div>    
</body>
</html>