<html>
<head>
<title>Typing React (3) Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">键入React (3) Redux</h1>
<blockquote>原文：<a href="https://itnext.io/typing-react-3-redux-84e73e41db7f?source=collection_archive---------3-----------------------#2019-06-11">https://itnext.io/typing-react-3-redux-84e73e41db7f?source=collection_archive---------3-----------------------#2019-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/dc23fa3be495db7d192bdca3fd5e4627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIQhzeOwp7vi7DiycOqVjw.png"/></div></figure><p id="f651" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在以前的文章中，我们已经解释了如何在常规React和Material-UI中使用TypeScript。在这篇文章中，我将展示最重要和最困难的部分:redux。</p><p id="f25d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以前的文章可以在这里找到:</p><ul class=""><li id="bea0" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/typing-react-1-basic-488f661149f6">打字反应(1) —基本</a></li><li id="e124" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/typing-react-2-material-ui-9e95a4aec6bc">键入React(2) — Material-UI </a></li></ul><p id="2bd8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本文中使用的包是:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="4e74" class="lt lu it lp b gy lv lw l lx ly">$ npm install --save redux react-redux typesafe-actions \<br/>              rxjs redux-observable lodash reselect \<br/>              @types/react-redux</span></pre><p id="0b64" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用redux最常见和推荐的方式是用<code class="fe lz ma mb lp b">redux</code> + <code class="fe lz ma mb lp b">typesafe-actions</code> + <code class="fe lz ma mb lp b">redux-observable</code>的组合。配置有点复杂，所以我将一部分一部分地解释。</p><h1 id="5b26" class="mc lu it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">基本概念</h1><p id="b8f0" class="pw-post-body-paragraph jx jy it jz b ka mz kc kd ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku im bi translated">在本教程中，我将使用以下目录结构:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="a57a" class="lt lu it lp b gy lv lw l lx ly">src/<br/>  |- store<br/>  |    |- actions<br/>  |    |- reducers<br/>  |    |- epics<br/>  |    `- selectors<br/>  `- services</span></pre><p id="28f0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">目录名应该非常简单明了。</p><p id="c1f2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下图是<code class="fe lz ma mb lp b">redux</code> + <code class="fe lz ma mb lp b">typesafe-action</code> + <code class="fe lz ma mb lp b">redux-observable</code>的整体概念。</p><figure class="lk ll lm ln gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/f5050abd710bae30a27361a6070de330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UtG5BwFpshLocbCb.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">Redux商店的概念</figcaption></figure><ul class=""><li id="e65b" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">redux存储的核心部分是一个动作流。一个动作只是一段带有两个字段的数据:<code class="fe lz ma mb lp b">{ type: string; payload: any }</code>。由于是流，所以可以用<code class="fe lz ma mb lp b">rxjs</code> <code class="fe lz ma mb lp b">Observable</code>来表示。</li><li id="6677" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated">动作以两种方式生成:由组件调度，或者由Epic生成。</li><li id="87f8" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated">一个组件可以在任何时候调度一个动作。通常这是由一个事件触发的，比如在页面加载后调度一个<code class="fe lz ma mb lp b">LIST</code>事件，或者在用户点击一个按钮后调度一个<code class="fe lz ma mb lp b">SAVE</code>事件。</li><li id="8d67" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated">史诗是观看动作流的对象。当一个特定的动作出现在流中时，epic会做一些事情(通常是副作用)，然后将零个或多个动作(通常是一个)推回到流中。这里的“副作用”一词只是指依赖于存储之外的东西，例如API调用、DOM操作，甚至打印日志消息。</li><li id="2962" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated">缩减器监视动作流，并在必要时转换状态。</li></ul><p id="25af" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这看起来很复杂，所以举例说明会有好处。假设我们想从API中检索所有的待办事项:</p><ul class=""><li id="772d" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">组件调度一个类型为<code class="fe lz ma mb lp b">TODO:LIST:REQUEST</code>的动作。</li><li id="a80c" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated">Epic看到这个动作并触发一个API调用。API调用返回后，它从响应中提取Todo列表，用Todo列表数据组装一个<code class="fe lz ma mb lp b">TODO:LIST:SUCCESS</code>动作，然后将这个动作推回到流中。</li><li id="9369" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated">缩减器接收<code class="fe lz ma mb lp b">TODO:LIST:SUCCESS</code>动作并从中提取待办事项列表数据，然后用待办事项列表更新全局状态。</li></ul><h1 id="c5c3" class="mc lu it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">行动</h1><p id="d033" class="pw-post-body-paragraph jx jy it jz b ka mz kc kd ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku im bi translated">让我们从动作开始。有两个类别:</p><ul class=""><li id="546e" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">标准动作，单纯的一个动作；</li><li id="1031" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated">异步动作，由三个动作组成:<code class="fe lz ma mb lp b">REQUEST</code>、<code class="fe lz ma mb lp b">SUCCESS</code>、<code class="fe lz ma mb lp b">FAILURE</code>，用于异步调用。</li></ul><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="fe90" class="lt lu it lp b gy lv lw l lx ly">import { createAsyncAction, createStandardAction } from 'typesafe-actions';<br/>import { Todo } from 'Models';</span><span id="c037" class="lt lu it lp b gy nn lw l lx ly">// Standard action<br/>export const setNote = createStandardAction('NOTE:SET_NOTE')&lt;string&gt;();</span><span id="5d2e" class="lt lu it lp b gy nn lw l lx ly">// Asynchronized actions<br/>export const listTodo = createAsyncAction(<br/>  'TODO:LIST:REQUEST',<br/>  'TODO:LIST:SUCCESS',<br/>  'TODO:LIST:FAILURE',<br/>)&lt;void, Todo[], Error&gt;();</span></pre><p id="9f5d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">函数调用后的类型参数(如<code class="fe lz ma mb lp b">&lt;string&gt;</code>、<code class="fe lz ma mb lp b">&lt;void, Todo[], Error&gt;</code>)是动作的有效载荷类型。</p><h1 id="53af" class="mc lu it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">还原剂</h1><p id="de69" class="pw-post-body-paragraph jx jy it jz b ka mz kc kd ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku im bi translated">下面的代码示例显示了一个由两个主要字段组成的<a class="ae le" href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape" rel="noopener ugc nofollow" target="_blank">规范化存储</a>:<code class="fe lz ma mb lp b">byId</code>和<code class="fe lz ma mb lp b">allIds</code>。该准则涵盖的几个要点是:</p><ul class=""><li id="6510" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">您需要声明一个状态类型<code class="fe lz ma mb lp b">TodoState</code>来定义状态的形状。注意所有的对象都应该被标记为<code class="fe lz ma mb lp b">Readonly</code>以表明状态是不可变的。特别是，嵌套对象也应该标记为<code class="fe lz ma mb lp b">Readonly</code>。</li><li id="2dc3" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated">使用<code class="fe lz ma mb lp b">TodoState['byId']</code>访问属性类型。</li><li id="2dbe" class="kv kw it jz b ka lf ke lg ki lh km li kq lj ku la lb lc ld bi translated"><code class="fe lz ma mb lp b">RootAction</code>是一个聚合类型，我们将在后面解释。现在你只需要知道它代表了所有可能的行为。</li></ul><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="d5da" class="lt lu it lp b gy lv lw l lx ly">import _ from 'lodash';<br/>import { getType } from 'typesafe-actions';<br/>import { combineReducers } from 'redux';<br/>import { Todo } from 'Models';<br/>import { listTodo } from '../actions/todo';<br/>import { RootAction } from 'StoreTypes';<br/><br/>export type TodoState = Readonly&lt;{<br/>  byId: Readonly&lt;{ [key: number]: Todo }&gt;;<br/>  allIds: number[];<br/>  loading: boolean;<br/>}&gt;;<br/><br/>const initialState: TodoState = {<br/>  byId: {},<br/>  allIds: [],<br/>  loading: false,<br/>};<br/><br/>const byId = (state: TodoState['byId'] = initialState.byId, action: RootAction) =&gt; {<br/>  switch (action.type) {<br/>    case getType(listTodo.success):<br/>      return _.keyBy(action.payload, 'id');<br/>    default:<br/>      return state;<br/>  }<br/>};<br/><br/>const allIds = (state: TodoState['allIds'] = initialState.allIds, action: RootAction) =&gt; {<br/>  switch (action.type) {<br/>    case getType(listTodo.success):<br/>      return _.map(action.payload, 'id');<br/>    default:<br/>      return state;<br/>  }<br/>};<br/><br/>const loading = (<br/>  state: TodoState['loading'] = initialState.loading,<br/>  action: RootAction,<br/>) =&gt; {<br/>  switch (action.type) {<br/>    case getType(listTodo.request):<br/>      return true;<br/>    case getType(listTodo.success):<br/>    case getType(listTodo.failure):<br/>      return false;<br/>    default:<br/>      return state;<br/>  }<br/>};<br/><br/>export default combineReducers({ byId, allIds, loading });</span></pre><h1 id="76e5" class="mc lu it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">史诗</h1><p id="8e01" class="pw-post-body-paragraph jx jy it jz b ka mz kc kd ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku im bi translated">Epics是监视动作流并在特殊动作出现时做一些事情的函数。通常，它是一个带有一系列操作符的<code class="fe lz ma mb lp b">actions$.pipe()</code>调用。第一个操作符通常是一个<code class="fe lz ma mb lp b">filter(isOfType(getType(action)))</code>来过滤掉我们感兴趣的动作。并且操作符序列最终应该返回零个或多个动作，这些动作将被推回到动作流。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="ba88" class="lt lu it lp b gy lv lw l lx ly">export const ListTodoEpic: RootEpic = (actions$, store, { todos }) =&gt;<br/>  actions$.pipe(<br/>    filter(isOfType(getType(listTodo.request))),<br/>    mergeMap(action =&gt;<br/>      todos.listTodos$().pipe(map(listTodo.success)),<br/>    catchError(err =&gt; of(listTodo.failure(err))),<br/>  );</span></pre><p id="899d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，史诗不应该返回它感兴趣的动作！这将创建一个无限循环。例如:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="ef9d" class="lt lu it lp b gy lv lw l lx ly">// DON'T DO THIS!<br/>export const InfinityLoopEpic: RootEpic = (actions$, store, { todos }) =&gt;<br/>  actions$.pipe(<br/>    filter(isOfType(getType(listTodo.request))),<br/>    mergeMap(action =&gt; action),<br/>  );</span></pre><h1 id="29e6" class="mc lu it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">类型</h1><p id="d8ff" class="pw-post-body-paragraph jx jy it jz b ka mz kc kd ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku im bi translated">为了使输入更容易，我们可以声明一些全局类型。这是通过向<code class="fe lz ma mb lp b">reducers</code>、<code class="fe lz ma mb lp b">actions</code>和<code class="fe lz ma mb lp b">epics</code>目录添加一个<code class="fe lz ma mb lp b">index.ts</code>和一个<code class="fe lz ma mb lp b">types.d.ts</code>来声明类型来实现的。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="6d3f" class="lt lu it lp b gy lv lw l lx ly">// =================================<br/>// actions/index.ts<br/>import * as TodoActions from './todo';</span><span id="d86d" class="lt lu it lp b gy nn lw l lx ly">export default {<br/>  todos: TodoActions,<br/>};<br/></span><span id="7c6b" class="lt lu it lp b gy nn lw l lx ly">// =================================<br/>// reducers/index.ts<br/>import todos from './todo';<br/>import { combineReducers } from 'redux';<br/>export default combineReducers({<br/>  todos,<br/>});</span><span id="73cb" class="lt lu it lp b gy nn lw l lx ly">// =================================<br/>// epics/index.ts<br/>import { combineEpics } from 'redux-observable';<br/>import * as todoEpic from './todo';<br/>export default combineEpics(<br/>  ...Object.values(todoEpic),<br/>);</span></pre><p id="3b1f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意<code class="fe lz ma mb lp b">combineEpics</code>和<code class="fe lz ma mb lp b">combineReducers</code>采用不同的参数。<code class="fe lz ma mb lp b">combineEpics</code>采用单个史诗的列表(这就是为什么我们需要销毁导入的对象值)，而<code class="fe lz ma mb lp b">combineReducers</code>采用树形结构。</p><p id="012f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面的代码显示了如何定义根类型。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="b141" class="lt lu it lp b gy lv lw l lx ly">// store/types.d.ts<br/>declare module 'StoreTypes' {<br/>  import { StateType, ActionType } from 'typesafe-actions';<br/>  import { Services } from 'ServiceTypes';<br/>  import { Epic } from 'redux-observable';<br/>  export type Store = StateType&lt;typeof import('./index').default&gt;;<br/>  export type RootAction = ActionType&lt;typeof import('./actions').default&gt;;<br/>  export type RootState = StateType&lt;ReturnType&lt;typeof import('./reducers').default&gt;&gt;;<br/>  export type RootEpic = Epic&lt;RootAction, RootAction, RootState, Services&gt;;<br/>}</span></pre><h1 id="d297" class="mc lu it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">创建商店</h1><p id="09f3" class="pw-post-body-paragraph jx jy it jz b ka mz kc kd ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku im bi translated">现在，reducers和epics已经准备好了，我们可以编写代码来创建存储:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="9f06" class="lt lu it lp b gy lv lw l lx ly">import { applyMiddleware, createStore, compose } from 'redux';<br/>import { createEpicMiddleware } from 'redux-observable';</span><span id="01fa" class="lt lu it lp b gy nn lw l lx ly">import { RootAction, RootState } from 'StoreTypes';<br/>import { Services } from 'ServiceTypes';</span><span id="de76" class="lt lu it lp b gy nn lw l lx ly">import rootReducer from './reducers';<br/>import rootEpic from './epics';<br/>import services from '../services';</span><span id="29a3" class="lt lu it lp b gy nn lw l lx ly">export const epicMiddleware = createEpicMiddleware&lt;<br/>  RootAction,<br/>  RootAction,<br/>  RootState,<br/>  Services<br/>&gt;({ dependencies: services });</span><span id="2796" class="lt lu it lp b gy nn lw l lx ly">export const composeEnhancers =<br/>  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><span id="a672" class="lt lu it lp b gy nn lw l lx ly">// configure middlewares<br/>const middlewares = [epicMiddleware];<br/>// compose enhancers<br/>const enhancer = composeEnhancers(applyMiddleware(...middlewares));</span><span id="b77b" class="lt lu it lp b gy nn lw l lx ly">// rehydrate state on app start<br/>const initialState = {};</span><span id="ffaa" class="lt lu it lp b gy nn lw l lx ly">// create store<br/>const store = createStore(rootReducer, initialState, enhancer);</span><span id="c0a3" class="lt lu it lp b gy nn lw l lx ly">epicMiddleware.run(rootEpic);</span><span id="fce3" class="lt lu it lp b gy nn lw l lx ly">// export store singleton instance<br/>export default store;</span></pre><h1 id="4c13" class="mc lu it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">选择器</h1><p id="9f83" class="pw-post-body-paragraph jx jy it jz b ka mz kc kd ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku im bi translated">选择器的类型非常简单。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="30e1" class="lt lu it lp b gy lv lw l lx ly">import { createSelector } from 'reselect';<br/>import { RootState } from 'StoreTypes';</span><span id="b639" class="lt lu it lp b gy nn lw l lx ly">export const selectTodoEntities = (state: RootState) =&gt; state.todos.byId;<br/>export const selectTodoAllIds = (state: RootState) =&gt; state.todos.allIds;<br/>export const selectTodoLoading = (state: RootState) =&gt; state.todos.loading;</span><span id="3753" class="lt lu it lp b gy nn lw l lx ly">export const selectTodoList = createSelector(<br/>  [selectTodoEntities, selectTodoAllIds],<br/>  (entities, allIds) =&gt; allIds.map(id =&gt; entities[id]),<br/>);</span></pre><h1 id="d997" class="mc lu it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">成分</h1><p id="a0e6" class="pw-post-body-paragraph jx jy it jz b ka mz kc kd ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku im bi translated">最后一部分是将商店映射到组件。因为我们需要访问由<code class="fe lz ma mb lp b">mapStateToProps</code>和<code class="fe lz ma mb lp b">mapDispatchToProps</code>映射的属性，所以我们需要在<code class="fe lz ma mb lp b">IProps</code>类型中定义这些属性。所以我们可以这样定义<code class="fe lz ma mb lp b">IProps</code>:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="8486" class="lt lu it lp b gy lv lw l lx ly">import React, { useEffect } from 'react';<br/>import { connect } from 'react-redux';<br/>import { RootState } from 'StoreTypes';<br/>import { selectTodoList } from '../store/selectors/todo';<br/>import { Dispatch } from 'redux';<br/>import { listTodo } from '../store/actions/todo';<br/>import TodoItem from './TodoItem';</span><span id="f915" class="lt lu it lp b gy nn lw l lx ly">const mapStateToProps = (state: RootState) =&gt; ({<br/>  todos: selectTodoList(state),<br/>});</span><span id="1222" class="lt lu it lp b gy nn lw l lx ly">const mapDispatchToProps = (dispatch: Dispatch) =&gt; ({<br/>  listTodo: () =&gt; dispatch(listTodo.request()),<br/>});</span><span id="87c5" class="lt lu it lp b gy nn lw l lx ly">export interface IProps<br/>  extends ReturnType&lt;typeof mapStateToProps&gt;,<br/>    ReturnType&lt;typeof mapDispatchToProps&gt; {}</span><span id="8675" class="lt lu it lp b gy nn lw l lx ly">const TodoList = (props: IProps) =&gt; {<br/>  const { todos, listTodo } = props;</span><span id="8fe1" class="lt lu it lp b gy nn lw l lx ly">  useEffect(() =&gt; {<br/>    listTodo();<br/>  }, []);</span><span id="2b7c" class="lt lu it lp b gy nn lw l lx ly">  return (<br/>    &lt;div&gt;<br/>      {todos.map(todo =&gt; (<br/>        &lt;TodoItem todo={todo} /&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="e6f5" class="lt lu it lp b gy nn lw l lx ly">export default connect(mapStateToProps, mapDispatchToProps)(TodoList);</span></pre></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="b218" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">打redux就这么多。感谢阅读！</p></div></div>    
</body>
</html>