<html>
<head>
<title>Baseline Application Performance In AKS Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AKS第1部分中的基准应用程序性能</h1>
<blockquote>原文：<a href="https://itnext.io/baseline-application-performance-in-aks-part-1-b6d10c87985a?source=collection_archive---------3-----------------------#2020-12-22">https://itnext.io/baseline-application-performance-in-aks-part-1-b6d10c87985a?source=collection_archive---------3-----------------------#2020-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="c4fe" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">了解应用程序的资源消耗对于确保Kubernetes集群的正常性能至关重要。这是第1部分，也是第3部分，我们将重点关注静态应用程序，以了解应用程序在没有任何负载的情况下对资源的影响</p></blockquote><p id="48a9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">优化集群性能并不是Azure Kubernetes服务所独有的。本文中的所有概念和想法不仅适用于每个云提供商和K8应用程序，也适用于所有应用程序。</p><p id="7fcd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我写的另外三篇文章将帮助您理解为什么这些概念在Kubernetes中很重要。如果您没有见过它们，它们是:</p><blockquote class="jn jo jp"><p id="a67c" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">请求和限制</strong></p></blockquote><p id="d6fc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/aks-performance-resource-requests-and-limits-f76ac255fae1"> AKS性能:资源请求和限制| Chase over mir | 2020年11月| ITNEXT </a></p><blockquote class="jn jo jp"><p id="c787" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">资源配额</strong></p></blockquote><p id="f6a9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/aks-performance-resource-quotas-2934ce468be7"> AKS性能:资源配额。限制…的资源消耗|由Chase over mire | 2020年12月| ITNEXT </a></p><blockquote class="jn jo jp"><p id="ec0a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">极限范围</strong></p></blockquote><p id="b743" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/aks-performance-limit-ranges-8e18cbebe351"> AKS性能:极限范围。控制你的……资源数量|通过追逐超额| 2020年12月|下一次</a></p><p id="24d4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这篇文章将作为一个起点，比接下来的文章更简单一些。这里的想法是向您介绍<strong class="jt ir">一般</strong>性能分析，并向您展示如果您不得不或需要学习如何使用<strong class="jt ir">如何手动</strong> <strong class="jt ir">完成它。</strong></p><p id="5376" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">为什么手动？我想先手动操作一下，向你展示我们如何<em class="js">查看重要资源。我不建议在生产中使用这种方法，但是这些信息将帮助您了解如何收集重要信息。这旨在帮助您立即找到哪些资源是重要的。说到资源，让我们定义一下我们真正想要完成的是什么，好吗？</em></p><p id="22a7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在这篇文章中，我们有三个资源，我们现在想关注一下。从技术上来说，网络IO也是我们关心的问题，但是在本文中，我们不会重点讨论这个问题。</p><ol class=""><li id="a891" class="kt ku iq jt b ju jv jy jz kp kv kq kw kr kx ko ky kz la lb bi translated">中央处理器</li><li id="814b" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">记忆</li><li id="9dc3" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">磁盘IO</li></ol><p id="f770" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这些资源中的每一个都在确保集群实际可用方面发挥着关键作用。这些资源中的任何一个资源过度饱和都会导致应用程序的糟糕性能，并对用户产生潜在的负面影响。我们希望收集足够的数据，以确保我们不会对其中任何一项征税。</p><p id="0ed7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我将创建<strong class="jt ir">这些文章中的三个</strong>。静态应用程序(本文)、负载应用程序、应用程序爆发/耗尽。我们将使用这些数据来确定我们的要求和限制应该/需要是什么，并讨论一段时间内的有机增长以及我们如何保持领先于我们的消费。</p><h1 id="4310" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">入门指南</h1><blockquote class="jn jo jp"><p id="2ac0" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">您将需要一个集群</p></blockquote><blockquote class="mf"><p id="d98b" class="mg mh iq bd mi mj mk ml mm mn mo ko dk translated">这将被推广(目前)，以确保尽可能多的人可以消费这个。根据您的设置，您可能需要进行更全面的测试，但这些概念同样适用</p></blockquote><blockquote class="jn jo jp"><p id="d943" class="jq jr js jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko ij bi translated">我的集群</p></blockquote><p id="3125" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我将在较旧的集群版本1.17.11上完成所有这些工作。我有<strong class="jt ir"> 2个</strong>节点相当小，<a class="ae ks" href="https://docs.microsoft.com/en-us/azure/virtual-machines/dv3-dsv3-series" rel="noopener ugc nofollow" target="_blank"> Standard_D2s_v3 </a> <strong class="jt ir"> </strong>也就是2个CPU 8GB Mem <strong class="jt ir">。</strong>我有骨股票<strong class="jt ir"> P10 </strong> 500眼内压磁盘重视。</p><p id="02e5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">由于资源有限，了解应用程序对资源的影响以防止节点饱和对我来说非常重要。在本系列文章结束之前，我有一些需要完成的目标:</p><ol class=""><li id="9dbe" class="kt ku iq jt b ju jv jy jz kp kv kq kw kr kx ko ky kz la lb bi translated">了解应用程序的静态资源需求<em class="js">(我们在本文中了解到)</em></li><li id="803d" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">了解应用程序的低/中/高资源需求</li><li id="7406" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">了解应用程序的高峰负载资源需求</li><li id="8855" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">了解潜在的请求影响</li></ol><p id="9ed1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">如果我能在本系列结束时检查所有这些，那么我将能够正确地设计资源和请求限制、命名空间配额和限制范围，如果我选择使用这些工具的话。这些信息将确保我了解我的应用程序的能力，并允许我适当地利用我所拥有的资源。</p><blockquote class="jn jo jp"><p id="6686" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">应用程序</p></blockquote><p id="f449" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我将使用K8s pod作为官方K8s文档中<a class="ae ks" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/" rel="noopener ugc nofollow" target="_blank">水平pod自动缩放</a>的示例。所有人都可以使用它，我想要概述的核心概念也很容易实现。你当然不一定要用这个。我希望每个人都能轻松使用，不管他们的集群大小如何。</p><h1 id="3e1e" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">部署工作负载</h1><p id="fb37" class="pw-post-body-paragraph jq jr iq jt b ju mu jw jx jy mv ka kb kp mw ke kf kq mx ki kj kr my km kn ko ij bi translated">游戏时间。我将运行<code class="fe mz na nb nc b">kubectl apply -f <a class="ae ks" href="https://k8s.io/examples/application/php-apache.yaml" rel="noopener ugc nofollow" target="_blank">https://k8s.io/examples/application/php-apache.yaml</a></code>，然后等待使用<code class="fe mz na nb nc b">kubectl get pod --watch</code>创建它。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/067a98cbd83305c51ecd7a5d0a086b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*AMKxz08GNlSn5iHpJXQLiQ.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">使用—观察以监视状态变化。</figcaption></figure><p id="25ee" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">一旦我的应用程序开始运行，我们就可以开始考虑第一个需求，了解应用程序的静态资源需求。有一堆<em class="js">不同的</em>方法可以做到这一点，所以我将只专注于其中一种。在此之前，我想核实几件事。</p><p id="5ef2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">让我们从运行<strong class="jt ir"> exec </strong>开始，进入pod并以传统方式看待事物。我将运行<code class="fe mz na nb nc b">kubectl exec -it php-apache-5546ddcd97-cvkd7 bash</code>让自己进入pod，然后检查以确保CPU和内存符合我的预期。</p><p id="67d8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">运行<code class="fe mz na nb nc b">cat /proc/cpuinfo | grep "model name"</code>向我展示了基于我的标准B2 Sku的预期。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div class="gh gi np"><img src="../Images/3ab4e112ca51ce31ddff01383643a97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*AbVv-i-Ao7fxu-AbZTxRvg.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">2 vCPU，果然不出所料。</figcaption></figure><p id="31eb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">接下来我将运行<code class="fe mz na nb nc b">free -m</code>来感受一下pod是如何思考内存的。这里需要记住的是，您不能使用这个命令来确定内存需求，因为Linux会将未使用的内存用于磁盘缓存。不要担心，虽然这是故意的。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/22d167df20b71570180aacb027a9dbde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*xr3BAfnM8LxnsVMQQCnxmA.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">不要慌！Linux认为未使用的内存是浪费的内存。当应用程序需要时，它是免费的。</figcaption></figure><p id="71c4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在，我们已经确保pod拥有我们期望的资源，让我们将注意力集中在实际应用程序的需求上。如果你想知道的话，这一点是为了表明pod目前不受任何限制。在后面的文章中，这个未绑定的pod将成为集群的末日，这是许多人经常遇到的问题。</p><h1 id="7cd7" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">了解休息资源需求</h1><p id="fbf2" class="pw-post-body-paragraph jq jr iq jt b ju mu jw jx jy mv ka kb kp mw ke kf kq mx ki kj kr my km kn ko ij bi translated">现在是时候开始思考我上面提到的<strong class="jt ir">三</strong>资源了。</p><ol class=""><li id="ddb1" class="kt ku iq jt b ju jv jy jz kp kv kq kw kr kx ko ky kz la lb bi translated">中央处理器</li><li id="e085" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">记忆</li><li id="f083" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">磁盘IO</li></ol><p id="a0c0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们希望了解我们的应用程序在<strong class="jt ir"> rest </strong>的使用模式，这要求我们首先收集每个模式的信息。记得我说过我们将手动进行这个<strong class="jt ir"/>。手动收集这些信息将帮助您了解如何收集数据本身的基本知识(如果您还不知道的话),并让我们跳出框框思考如果没有其他选择，我们该如何做。我们需要收集所有这些信息<strong class="jt ir">和</strong>我们需要能够随着时间的推移<strong class="jt ir">对其进行分析</strong>以确保我们了解休息需求。</p><blockquote class="mf"><p id="79fc" class="mg mh iq bd mi mj nr ns nt nu nv ko dk translated">疯狂的人做疯狂的事，这是一件疯狂的事。在以后的文章中，我们将自动完成这项工作，或者使用令人敬畏的工具来完成这项工作，这将更符合逻辑，但信息量较少。一般来说，这种类型的收集背后的想法将用于实时调查，而不是用于历史分析的收集</p></blockquote><p id="be8e" class="pw-post-body-paragraph jq jr iq jt b ju mp jw jx jy mq ka kb kp mr ke kf kq ms ki kj kr mt km kn ko ij bi translated">通常你会同时收集所有这些，然后一点一点地分析。在这篇文章中，我们不打算用那种方式<em class="js">来做，因为我们想用强硬的方式来做。取而代之的是，我们将从托管节点收集分组或一次性的东西，然后将其聚合，以便于我们分析。</em></p><p id="048f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这是游戏计划。我将创建一个可怜的mans数据收集器，它在托管节点上每秒运行一次，收集排名前三的资源的统计信息，并将它们重新编码到一个文件中，供我们以后使用。我将只收集5分钟左右的数据，然后将它们汇总在一起并查看数据。</p><p id="0965" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在这篇文章中，我不打算花超过5分钟的时间，主要是因为我们使用的方法不需要太多的数据就能表达清楚。要明白，在一个真正的应用程序中，你需要比5分钟更多的数据。简而言之，你会得到这个数据集的要点，它将是非常平坦的减去一个指标。</p><p id="c9e7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我要做的是使用名为<a class="ae ks" href="https://github.com/kvaps/kubectl-node-shell" rel="noopener ugc nofollow" target="_blank">的节点外壳</a>访问我的托管节点，并直接从中收集数据。</p><blockquote class="jn jo jp"><p id="1db9" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">确定托管节点并获得访问权限</p></blockquote><p id="7d54" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我将运行<code class="fe mz na nb nc b">kubectl get pods -o wide</code>并查看我的托管节点</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/e71e0fd4d92b7a90b045576ffada743b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YaNQ4PCiTbSVc0YwUco7uA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">我们可以看到我的托管节点是aks-agent pool-19575414-vmss 000000</figcaption></figure><p id="8e9c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在进入我的节点之前，我想对我的PHP pod运行一个describe，这样我就可以获得容器ID。我将运行<code class="fe mz na nb nc b">kubectl describe pod php-apache-5546ddcd9f-cvkd7</code>，我们可以看到我的id。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi ob"><img src="../Images/0471b56fbba2494313066320755e01e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8l1NfY5Ln8MTI0jEqZ0-VA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">我们稍后将对此进行研究</figcaption></figure><p id="2138" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在，我将继续运行<code class="fe mz na nb nc b">kubectl node-shell aks-agentpool-19575414-vmss000000</code>来访问我的节点。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi oc"><img src="../Images/306423d9a34e2ea6c1934fffdc1bd275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CuL6QYkZbVSH2A3GR5qXCQ.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">一个额外的pod启动并用于SSH到托管节点，而您不需要做任何其他事情。</figcaption></figure><p id="6dc2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">获得访问权，游戏时间。我们现在可以找到容器的PID，并开始收集数据。有很多方法可以做到这一点，我会很懒，只运行<code class="fe mz na nb nc b">docker inspect -f '{{.State.Pid}}' &lt;container id&gt;</code>。</p><blockquote class="mf"><p id="1f61" class="mg mh iq bd mi mj nr ns nt nu nv ko dk translated">要明白，在一个真正的应用程序中，你需要比5分钟更多的数据。简而言之，仅用这个数据集，您就能得到要点。</p></blockquote><blockquote class="jn jo jp"><p id="d053" class="jq jr js jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko ij bi translated">收集数据</p></blockquote><p id="676f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们有很多方法可以手动完成这项工作。总的来说，如果你要收集CPU、内存和磁盘，你通常需要比单个应用程序更多的东西。大多数人都在想什么？我会打赌命令像PS，TOP，HTOP，IFTOP，IOTOP，可能还有SAR。</p><p id="73da" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">如果可能的话，我想每秒钟至少收集一次数据。从技术上来说<em class="js">大多数</em>云提供商计算资源节流在1分钟以下，我相信在Azure Disk的情况下是10ms，所以我们需要确保我们至少有1秒。</p><p id="d03b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">如果你正在收集数据&gt; 1秒，你需要确保小心<em class="js">为你平均</em>数据的任何事情。如果你收集数据，比如说每10秒钟平均5个IOPS，但是仅仅一秒钟就达到10个，那么这个平均值就不能正确反映这个巨大的峰值。我们将在后面的文章中详细讨论这一点。</p><blockquote class="jn jo jp"><p id="4ee3" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">CPU +内存</p></blockquote><p id="428b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们可以试试配料陀螺..</p><p id="db35" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><code class="fe mz na nb nc b"><strong class="jt ir">/var/lib/docker/containers# top -d 1 -b -p 26380 &gt;&gt; output.txt</strong></code></p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6f20cf1f0a386b1a2fcda01f5e0bd620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*kFgHEBbZRThZ1yky-q9cuQ.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">批处理top并解析输出…</figcaption></figure><p id="ae1c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">老实说，如果你说“嘿，你需要用内置工具从头开始做这个！”我可能不会这么做。另一个选择可能是运行ps aux对吗？我们可以这样做:</p><pre class="ne nf ng nh gt oe nc of og aw oh bi"><span id="49b0" class="oi li iq nc b gy oj ok l ol om">ps aux | awk -v date="$(date +"%Y-%m-%d %r")" '{print date "\t\t" $11 "\t\t" $3 "\t\t" $6/1024 " MB\t\t" "\t" $2}'<!-- -->| grep 26380</span></pre><blockquote class="mf"><p id="b7d9" class="mg mh iq bd mi mj mk ml mm mn mo ko dk translated">请注意，以这种方式收集数据<strong class="ak">在技术上确实有</strong>的资源开销，尽管它可能很小。</p></blockquote><blockquote class="jn jo jp"><p id="5759" class="jq jr js jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko ij bi translated">磁盘IO</p></blockquote><p id="3392" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我最喜欢的路线是一整天都不休息。我们知道我的pid <em class="js"> 26380 </em>是我想关注的人。很简单，我可以跑<code class="fe mz na nb nc b">iotop -b -q -d 1 -p 26380</code></p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6cad42b63bea8e4fa8ddb8ca2560f629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*gz_m5NrcDuLAReJZNlXuUQ.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">不太干净，但我们可以用这个</figcaption></figure><p id="7975" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">但是这里有一个小问题…我们根本没有时间戳。我们不能像用ps aux那样awk它，因为我们是在批处理模式下运行的，它只会在命令开始时显示第一个实例…让我们重新考虑一下。如果我们看一下IOTOP手册页，我们可以看到有一些方法可以控制它以批处理方式运行的时间。所以让我们这样来代替:<code class="fe mz na nb nc b">iotop -q -d 1 -n 300 -p 26380</code></p><p id="246a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在IOTOP将只运行5分钟，<code class="fe mz na nb nc b">n</code>是开关，<code class="fe mz na nb nc b">300</code>是秒数。这将让我们做一些更简单的计算…尽管它们可能很傻…以后。让我们称之为“暂时没问题”,并把它们缝合在一起。</p><blockquote class="jn jo jp"><p id="1fc8" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">把它放在一起</p></blockquote><p id="8c02" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们知道iotop命令在设计上已经运行了五分钟，所以我们只需要写一些东西来确保ps aux one也能运行。很简单。我会制作世界上最糟糕的剧本…</p><pre class="ne nf ng nh gt oe nc of og aw oh bi"><span id="3bed" class="oi li iq nc b gy oj ok l ol om">#!/bin/bash<br/>n=0<br/>iotop -q -d 1 -n 300 -p 26380 &gt;&gt; ioResults.txt &amp; #background this</span><span id="38f5" class="oi li iq nc b gy oo ok l ol om">while [ $n -le 301 ]<br/> do<br/> ps aux | awk -v date="$(date +"%Y-%m-%d %r")" '{print date "\t\t" $11 "\t\t" $3 "\t\t" $6/1024 " MB\t\t" "\t" $2}' &gt;&gt; cpumemResults.txt<br/> sleep 1<br/> n=$(( n+1 )) # increments $n<br/> done</span></pre><p id="20dd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">对于专业开发人员来说，是的，这是热垃圾，将完成工作的热垃圾。当你启动它的时候，它会把iotop推入一个后台进程，同时ps aux循环也会运行5分钟。现在我可以运行<code class="fe mz na nb nc b">./MyScript.sh</code>并等待它完成。</p><blockquote class="jn jo jp"><p id="0ade" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">替代方法</p></blockquote><p id="7803" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">总是有很多方法可以做到这一点，我可能会故意选择一个最可笑的可怕的方法。让我们看看我们可以用AKS 中我的特定设置来完成这个<em class="js">的其他方法。</em></p><blockquote class="jn jo jp"><p id="b5e2" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">使用Docker</p></blockquote><p id="10f6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">Docker有一个内置的<code class="fe mz na nb nc b">stats</code>命令，可以收集我们关心的几乎所有重要的东西，但是没有时间元素。我将从上面的pod中获取容器ID，然后运行<code class="fe mz na nb nc b">docker stats 26bcf99507ad175af2a53772cdbe5b22b82d1ee8abebf133a7563a00cb34bb9c — format “table {{.ID}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.BlockIO}}\t{{.NetIO}}”</code> theb观看魔术。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b94e5ba4ec1ddc302063b2e4549e521d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*r5Jgv8_8N2_PGUM6b9C4Yw.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">好吃的数据！</figcaption></figure><p id="1cc4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">太好了！关于集装箱使用的大量精彩信息…然而，它只是一遍又一遍地刷新屏幕，并没有给我们提供任何实际的时间框架，这使得它非常适合于目前的调查，而不是真正的长期分析…不过，如果我们想的话，我们可以绕过它。</p><p id="8ce4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">让我们考虑一下docker stats命令……它显然是从某个地方的<em class="js">提取数据的。稍微研究一下cgroups是如何工作的，就可以得到cgroups资源数据。我们也许可以想出一种手动收集数据的方法…然后做一些研究，找出数据是如何收集和整理的，然后创建一种历史收集这些数据的方法…</em></p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi oq"><img src="../Images/8b3011da43a90b75d41c7e18d115d955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_dDYUra0NCTR5pJMZyzkA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">选项选项如此多的选项…</figcaption></figure><p id="acbb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">数据就在那里，只需要提取/分析数据。如果你好奇的话，这是一个不错的选择。如果你准备接受挑战，去看看Kubernetes API如何收集统计数据，然后看看Prometheus这样的收集应用程序如何收集相同的统计数据。</p><p id="eb05" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">也许我们可以向Docker API请求统计数据？当然，我们也可以通过卷曲袜子来做到这一点</p><p id="9ba5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><code class="fe mz na nb nc b">curl — unix-socket /var/run/docker.sock <a class="ae ks" href="http://localhost/containers/26bcf99507ad175af2a53772cdbe5b22b82d1ee8abebf133a7563a00cb34bb9c" rel="noopener ugc nofollow" target="_blank">http://localhost/containers/26bcf99507ad175af2a53772cdbe5b22b82d1ee8abebf133a7563a00cb34bb9c</a>/stats</code></p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi or"><img src="../Images/4732533d628ae68d9d78e09522ffbc73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fKe49Zd-Gc2tOsLKJZBRw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">很多数据需要解析…我为我的容器ID创建了一个变量来缩短命令。</figcaption></figure><p id="939f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">如你所见，你有很多选择。一般来说，人们不想走这些路线，这就是为什么像Prometheus这样的应用程序存在的原因——我们将在以后的文章中讨论。</p><blockquote class="jn jo jp"><p id="d2e8" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">分析</p></blockquote><blockquote class="mf"><p id="12f6" class="mg mh iq bd mi mj mk ml mm mn mo ko dk translated">预计这个数据是平的，没有负载。</p></blockquote><p id="b72d" class="pw-post-body-paragraph jq jr iq jt b ju mp jw jx jy mq ka kb kp mr ke kf kq ms ki kj kr mt km kn ko ij bi translated">在运行了这个非常棒但显然并不可怕的脚本之后，我们只剩下两个文件，ioResult.txt和cpumemResult.txt。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi os"><img src="../Images/eccc2b0e3cb6b85a53191761604ede85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdupHyGikivj2Qx2RAer5Q.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">第二次迭代，没有真正的变化</figcaption></figure><p id="7465" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在坏消息是…我们知道我们的ps aux每秒钟运行5分钟，但它实际上排成一行了吗？这是人们通常不这样手动操作的原因之一。在我们的情况下，我们可以相对有信心，他们的球停在足够接近我们的需求。当我开始分析这个的时候会发生什么呢？</p><p id="f695" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">基本上，我在这里要做的就是将这些数据复制到excel中，将我想要的数据文本化到列中，然后将其绘制到图表上以供查看。这让我可以快速轻松地获取大量数据并将其可视化。</p><blockquote class="jn jo jp"><p id="92aa" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">CPU和内存</p></blockquote><p id="41ae" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们希望这个数据相当平坦，因为我们的应用程序还没有真正做任何事情。我们做一些快速简单的excel-fu并规划出我们的用法。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/d7983bca29f3368c91928474d2c2e75a.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*y0qho267KVxUUJTOKkE6nA.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">她平衬船长！</figcaption></figure><p id="4cf3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们几乎没有CPU来维持应用程序的运行。我们现在没有限制，所以如果需要的话，这个应用程序可以在整个CPU上运行。我们在这里可以看到，它甚至没有为任何静态工作注册1%的CPU时间。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/9573049fcd28debd735b6de98cbc2ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*5I3P3T5gp6TPG9Yy-R14Ug.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">平平！</figcaption></figure><p id="b207" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们也希望如此。我们的应用程序没有命中它，所以我们在这里有一个相当平坦的内存足迹。18MB也不算太寒酸。那么我们学到了什么？我们只需要很少的CPU和大约18MB的内存。</p><blockquote class="jn jo jp"><p id="c7d5" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">磁盘分析</p></blockquote><p id="1c27" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我要跳过阅读，因为没有。相反，让我们看看这300秒内的写入数据。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi ov"><img src="../Images/5d3c9961d0fe64924a66cd7e2885f504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kx6t1JkjyAxew1lVKX6Xtw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">捕获时间越长=数据越多=模式分析越好</figcaption></figure><p id="9748" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我修改了数据来绘制峰值、平均值和每秒钟，这样我们就可以看到一个趋势。现在，在5分钟内，除了写入活动中的短暂峰值，我们看不到太多模式。同样，对于真实的模式，你需要更多的样本来观察。我们学到了什么？我们的读取要求不是，而我们的写入平均约为45KBps，峰值高达631.5KBps <strong class="jt ir">休息时</strong>。</p><p id="2e85" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们可以使用iotop之类的东西来更好地理解这些书写模式，但是我们将在另一篇文章中讨论这个问题。记住，性能分析就像洋葱，通常需要抽象。哦，我的虚拟机太慢了…我看到我的CPU被限制了…是什么限制了它…哦，一个容器…是什么导致容器加盖…等等。</p><blockquote class="jn jo jp"><p id="9303" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">摘要</p></blockquote><p id="294d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在本文中，我谈到了理解应用程序性能足迹的重要性。从CPU和内存到磁盘IO，了解您的应用程序如何使用您的重要资源非常重要，以确保您可以正确构建和限制应用程序来保持其性能。</p><p id="6000" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">此外，我一步一步地研究了一种可能的方法，其中可以手动收集一些数据。使用Excel或其他工具，您可以轻松地将数据绘制出来，并将其可视化，以帮助您了解使用模式。我们只查看了5分钟的数据，在休息时，我们预计使用量持平，我们没有理由收集24小时的数据。采样时间越长，您对分析结果就越有信心。</p><p id="9d0f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在本系列的下一部分中，我将模拟应用程序上的各种用户负载，并再次执行相同的过程，显示应用程序在静态和各种负载下的资源消耗差异，以帮助我们了解用户请求的影响，从而允许我们智能地设置请求和限制，以防止可能导致性能下降的过饱和。</p><p id="0fd7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在我专注于手动收集数据，这样那些不知道如何做的人可以看到你如何<em class="js">可以</em>收集这些数据并将其可视化。除了学习之外，我不建议你使用这种方法，你也不应该依赖如此不完善的产品。在后面的文章中，我将使用产品级资源再次展示所有这些。</p></div></div>    
</body>
</html>