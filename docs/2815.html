<html>
<head>
<title>Reducing needed permissions in Istio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">减少Istio中所需的权限</h1>
<blockquote>原文：<a href="https://itnext.io/slashing-needed-permissions-in-istio-f05fe145698d?source=collection_archive---------8-----------------------#2019-08-07">https://itnext.io/slashing-needed-permissions-in-istio-f05fe145698d?source=collection_archive---------8-----------------------#2019-08-07</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="aba2" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">默认情况下，Istio需要比大多数用户想要给他们的pod和容器更多的权限才能运行(查看ContainerDays  2019的这个演示)。从Istio 1.2开始，幸运的是有了一个解决方案。这篇文章试图解释减少所需权限的机制，从而增加你的网格的安全性。</p><p id="1111" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">让我们先来看看变化前的情况</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div class="gi gj kn"><img src="../Images/660efd10d493cbcf20dc6197e2bc64ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*Xm84RT-pvoBMwd_BPWcFUg.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">吊舱里有一个边车的经典装置。</figcaption></figure><p id="ecc5" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">您会看到外部流量(红色箭头)进入pod到达Sidecar(特使代理)，Sidecar然后将请求转发到业务容器。为了实现这一点，有一个Init容器，它修改网络路由表(iptables ),将外部流量定向到sidecar，然后让这个代理与业务容器对话。当您执行<em class="kz"> kubectl get pod </em>时，您不会看到列出的init-container，而只会看到应用程序容器:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div class="gi gj la"><img src="../Images/f7f5e0611a80254c47f8ed61de77c9be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*X_kDl_UR3-2kruUq1aZvow.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">kubectl get pod的输出pod有两个用于商务和边车的容器</figcaption></figure><p id="6b62" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">您可以使用带有输出格式的<em class="kz"> kubectl </em>(或<em class="kz"> kubectl describe pod </em>)来查看init-container:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gi gj lb"><img src="../Images/a25c668793db7cf395507db5707c93a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YaZQYcok8-CybxGWwKbpPQ.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">获取pod详细信息以列出初始容器</figcaption></figure><p id="c895" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">iptables的修改只有在init-container(以及整个pod)使用<a class="ae km" href="http://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener ugc nofollow" target="_blank"> NET_ADMIN </a>特权运行时才能起作用。这样做的缺点是，pod中的每个容器都以NET_ADMIN的身份运行，恶意的业务代码也可能修改iptables，这是我们不希望看到的，因为这可能会允许pod与其他pod进行通信，而这是Kubernetes配置最初禁止的。</p><p id="a3e0" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">最重要的是，init-container坚持在特定的用户id下运行，这是OpenShift特别不喜欢的，因此需要授予应用程序额外的权限才能正常运行:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div class="gi gj la"><img src="../Images/6e3ef8b1499c37cd0acaeeeaf22d3b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*kszrNDE9fg3M3TmLUEU9JQ.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">为用户命名空间设置安全上下文约束</figcaption></figure><h2 id="493e" class="lg lh ir bd li lj lk dn ll lm ln dp lo jz lp lq lr kd ls lt lu kh lv lw lx ly bi translated">介绍Istio-CNI</h2><p id="ee8d" class="pw-post-body-paragraph jo jp ir jq b jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh md kj kk kl ik bi translated">要解决上述问题，我们需要从应用程序窗格中删除init-container，并确保iptables无论如何都会被更改。</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div class="gi gj me"><img src="../Images/e4b7d136e081124b5339b5b5f1055496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*iZbGqAUA_JN_zMB2566vBQ.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">我们使用节点级别的帮助者pod</figcaption></figure><p id="1eb5" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">一个新的组件<a class="ae km" href="https://github.com/istio/cni" rel="noopener ugc nofollow" target="_blank"> <em class="kz"> Istio-CNI插件</em> </a>，以istio-cni-node DaemonSet为代表(在<a class="ae km" href="https://maistra.io/" rel="noopener ugc nofollow" target="_blank"> Maistra </a>它被称为istio-node)已经被引入了这个目的(<a class="ae km" href="https://blog.openshift.com/increasing-security-of-istio-deployments-by-removing-the-need-for-privileged-containers/" rel="noopener ugc nofollow" target="_blank">我的一些同事去年已经写了这个想法</a>)。Istio-CNI观察新的pod，并通过检查<a class="ae km" href="https://istio.io/docs/setup/kubernetes/additional-setup/cni/#identifying-pods-requiring-traffic-redirection" rel="noopener ugc nofollow" target="_blank">pod是否满足某些标准(如具有istio-proxy容器或不在excluded_namespaces列表上</a>)来确定它们是否应该是网格的一部分。如果是这样，助手窗格将更新iptables。</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div class="gi gj mf"><img src="../Images/63a155b081a220da64054983b30fe216.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*NnkgOkDfv83f0nORdibvkA.png"/></div></figure><p id="df2d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在边车注射过程中，pod已贴上标签，标签名称为<em class="kz">k8s.v1.cni.cncf.io/networks</em>，告知Kubernetes将istio-system-istio-cni网络连接到pod。这使得pod等待，直到Istio-CNI网络出现(即，istio-cni-node pod已经完成其工作)。Kubernetes还更新配置以设置连接网络的状态。</p><p id="7d52" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">网络建立后，pod可以继续正常启动，之后边车和业务容器可以正常启动。</p><p id="444a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">再次检查pod，我们现在可以看到pod中不再有init-container:</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gi gj mg"><img src="../Images/d9d1b285f7a0fbf80ad70b70d8e092fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSUXjitXLEdtBlleyJLEsQ.png"/></div></div></figure><h2 id="9638" class="lg lh ir bd li lj lk dn ll lm ln dp lo jz lp lq lr kd ls lt lu kh lv lw lx ly bi translated">装置</h2><p id="7817" class="pw-post-body-paragraph jo jp ir jq b jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh md kj kk kl ik bi translated">Istio-CNI不是开箱即用的，但是你必须明确地安装它。</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div class="gi gj mh"><img src="../Images/3556c4856825785748992942023255d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*6TLEtEQSMGtm-iK_Sq4orA.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">安装时在Maistra上启用Istio-CNI</figcaption></figure><p id="5a74" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><a class="ae km" href="https://maistra.io/" rel="noopener ugc nofollow" target="_blank"> Maistra </a>下游<a class="ae km" href="https://github.com/maistra" rel="noopener ugc nofollow" target="_blank">项目</a>允许在TP12中打开Istio-CNI，之后将默认启用Istio-CNI。对于TP 12，您只需将两行Yaml添加到控制平面配置中，如上图所示。</p><h2 id="85fa" class="lg lh ir bd li lj lk dn ll lm ln dp lo jz lp lq lr kd ls lt lu kh lv lw lx ly bi translated">结论</h2><p id="9c5e" class="pw-post-body-paragraph jo jp ir jq b jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh md kj kk kl ik bi translated">随着Istio-CNI的引入和使用，用户业务代码不再需要任何特权。Istio-node仍然需要NET_ADMIN权限，但它被视为一个平台pod，就像Kubernetes中的许多其他平台一样——没有用户可以直接修改的部分。</p></div></div>    
</body>
</html>