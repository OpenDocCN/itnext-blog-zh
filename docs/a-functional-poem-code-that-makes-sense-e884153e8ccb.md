# 一首功能诗——有意义的代码

> 原文：<https://itnext.io/a-functional-poem-code-that-makes-sense-e884153e8ccb?source=collection_archive---------4----------------------->

![](img/80abd225c95f58166b8c86df278b9da8.png)

哟！鸣谢:ESSEPRESS。计算机输出缩微胶片

你好。

不久前，我又开始对自己的代码感觉良好。这并不是说我讨厌我以前写的东西，而是我觉得它一直缺少一些东西。虽然谈论一些唯一目的是帮助公司赚钱的东西的美学可能会感觉怪怪的，而且很多人都看不到，但是拜托，哪个开发人员不相信“美丽”的代码呢？代码除了可读性强和容易理解之外，还有点令人愉快，所以它的*外观*以一种非常好的方式影响一个人的生产力。

然而，我又开始对我的代码感觉良好，因为我的新项目很棒，我可以使用任何符合要求的技术。对我来说就是 JavaScript，我在[这篇](https://medium.com/@chasing_average/js-got-some-love-but-it-deserves-much-more-8c5f03966e61)博文中称赞了它。在其他 JS 优于其他多范式语言的优势中，我提到了一个事实，它允许你编写某种函数式代码，并且有像 *Ramda* 和 *Lodash FP* 这样的库，使得用 JavaScript 进行函数式编程更加容易。

# 创作一首功能诗

我不得不说，一旦有机会在商业应用程序中使用服务器端 JS，我就决定采纳自己的建议。我尝试了几次，但最终我想出了一种技巧来编写实际上有意义的功能性代码。这种方法的主要思想和基础是利用函数式编程的 compose 和 pipe 概念首先编写一个语句列表，然后开始描述每个语句的含义。听起来不是很有说服力？请不要关闭标签，让我用一些低质量的 helloworld 要点来说明这个想法。

假设我们希望实现一个服务，该服务验证 helloworld 对象，将其放入存储库中，安排电子邮件通知，并以操作状态进行响应。

首先，让我们看看如果这段代码是由一个了解承诺并且不介意在美学上妥协的程序员编写的，它会是什么样子:

现在，忘记这段代码，想象我们从一开始就使用这样一个模块:

上面是一个导入两个本地模块以及 Ramda npm 包的模块。如前所述，Ramda 是一个为你的代码增加一些功能魔法的库。它有 pipeP() API，允许我们管道化返回承诺的函数，并返回一个返回承诺的函数🤯。在管道中，每个函数都接收前一个函数的返回值作为其输入。管道从上到下执行。例如，你可以在维基百科上读到更多关于它们的信息。

让我们继续吧。现在我们将描述一些函数的作用:

如你所见，我已经“实现”了两个方法，分别叫做 **validateInput()** 和 **createResponse()** 返回承诺。值得注意的一点是，在我们的例子中，如果传递给它的 hello 对象无效，那么 **validateInput()** 抛出一个异常，否则返回输入对象。另一个变化是我们导入依赖项的方式——我们不再包含整个模块，而是使用析构来导入我们感兴趣的函数，这些函数的名称在当前上下文中有意义。

第二个变化的问题是，我们可能无法控制导入函数的输入和输出。因此，举例来说，如果 **addHelloToRepo()** 不返回任何值或者只返回输入对象，那么 **scheduleNotifications()** 将不会收到它所期望的参数，整个过程将会崩溃！多么不幸！我们可能应该放弃这种方法，忘记函数式编程，就像我们忘记 JQuery、Angular 和 COBOL 一样。

或者我们应该？让我们通过对我们的模块做一点小小的改变来扭转局面:

我们的问题的解决方案是一个名为 **forwardInput()** 的包装器，它利用一个名为 [*的概念来部分应用它的参数，这样我们就可以执行一个函数，然后返回它的输入参数。它是所谓的*高阶函数—* 返回另一个函数的函数。从现在开始，每当我们向管道添加一个新函数时，我们可以用 **forwardInput()** 包装它，以返回函数的输入参数，而不是返回值。*](https://en.wikipedia.org/wiki/Currying)

这是一个非常简单的例子，说明了我们如何编写有意义的函数式代码。对我来说，使用这种方法的好处如下:

1.  代码可读性更强——很容易导航和理解实际发生的事情。
2.  它鼓励你编写 [*纯函数*](https://en.wikipedia.org/wiki/Pure_function) *—* ，从而保证进一步的改变不会影响现有的功能。
3.  单元测试变得更容易，因为主管道中的每个新功能都意味着一组新的单元测试，并且不会对现有的单元测试产生太大影响。
4.  向这样的代码添加更改与首先实现它是相似的。所以应该很容易维护和增强。

说到维护…让我们稍微升级一下我们的代码。我想添加一些日志记录功能以及一个函数的占位符，该函数将在数据湖或其他类似的地方存储一个 hello 对象。像这样:

如你所见，我在这里撒了一点谎。虽然我确实实现了一个名为 **saveToDataLake()** 的函数，但它并没有做太多事情，只是扩展了一个 **skip()** 函数，记录被跳过步骤的名称并转发其输入。让我们假设，一旦运营人员和数据人员找到了数据湖的基础结构，这个功能就可以实现了🙄。

现在，当我们的模块接近完美时，在结束本文之前，我将对它做一些微小的修改。我将添加一些验证来检查 hello 对象是否已被添加到 DB 中，而没有任何问题:

现在，我们模块的唯一功能是:

1.  验证输入的 hello 对象。
2.  将它添加到某个存储库中，如果操作不成功，则抛出一个错误。
3.  安排电子邮件通知。
4.  跳过在数据湖中保存对象的未实现步骤。
5.  创建响应。
6.  在每个步骤后将信息写入日志。
7.  仍然可读。
8.  哇哦。

上例中的一些函数(例如 skip()、forwardInput()等。)非常通用，可以被其他模块重用。因此，在现实世界中，它们应该被移动到一个单独的模块中，甚至是一个库中。

# 就这样吗？

差不多了。

虽然我使用了 Ramda 来说明我新喜欢的编写代码的方法，但这并不是唯一的方法。可以用 compose 方法代替 pipe 和，用 lodash 代替 Ramda。如果你使用 Koa，你可以用中间件功能达到同样的效果。或者，如果您对***then then***语法没有意见，甚至可以使用“正常”承诺。可能性是无穷的，我严重怀疑是否有一种主流编程语言不会让你实现类似于我们上面的代码。现在尝试一下，你未来的自己可能会感激你！

还有一些链接可以帮助你理解我今天提到的一些概念和/或技术:

1.  [功能编程](https://en.wikipedia.org/wiki/Functional_programming)。
2.  当前值
3.  [纯功能](https://en.wikipedia.org/wiki/Pure_function)。
4.  [拉姆达](http://ramdajs.com)。
5.  [lodash/fp](https://github.com/lodash/lodash/wiki/FP-Guide) 。

# 啊啊啊，就是这样！

写出漂亮的代码，下次再见！