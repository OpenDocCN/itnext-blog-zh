<html>
<head>
<title>Using WebView with React Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将WebView与React导航结合使用</h1>
<blockquote>原文：<a href="https://itnext.io/using-webview-with-react-navigation-43344217111e?source=collection_archive---------0-----------------------#2019-08-12">https://itnext.io/using-webview-with-react-navigation-43344217111e?source=collection_archive---------0-----------------------#2019-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fe8e87821d81910d459bd1983df31837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*baQuXOiVTiTsVsRuqqqMYQ.png"/></div></div></figure><div class=""/><p id="4af1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近一直在做一个React原生应用，它有一些有趣的需求。它内置于Expo中，具有React导航功能，内容存储在外部服务器上，并通过WebView显示在应用程序中。</p><p id="ce48" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止一切正常</p><p id="1851" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，外部html文件中的链接有三种可能的结果——要么在浏览器中打开(标准<code class="fe kz la lb lc b">Linking.getUrl</code>)，在应用程序中作为新的StackView屏幕打开(<code class="fe kz la lb lc b">StackActions.push({ routeName: 'ScreenName'})</code>)，或者最棘手的是，打开堆栈导航器中定义的不同屏幕(<code class="fe kz la lb lc b">navigation.navigate('CustomScreen')</code>)。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="1530" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">初始设置</h1><p id="e14f" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">让我们从设置一个基本的StackNavigator和一个显示它的屏幕开始</p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="c80c" class="mv ll je lc b gy mw mx l my mz">import React from 'react';<br/>import { View } from 'react-native';<br/>import { createAppContainer, createStackNavigator } from 'react-navigation';</span><span id="f153" class="mv ll je lc b gy na mx l my mz">// SCREENS<br/>import WebViewScreen from 'WebViewScreen';</span><span id="998f" class="mv ll je lc b gy na mx l my mz">const MyStack  = createStackNavigator({<br/>  Landing: {<br/>    screen: WebViewScreen,<br/>    params: { url: '<a class="ae nb" href="http://www.damienmason.com/medium/react-navigation-webview.html" rel="noopener ugc nofollow" target="_blank">http://www.damienmason.com/medium/react-navigation-webview.html</a><a class="ae nb" href="http://www.damienmason.com/'" rel="noopener ugc nofollow" target="_blank">'</a> },<br/>  }<br/>});</span><span id="5d08" class="mv ll je lc b gy na mx l my mz">const MyNav = createAppContainer(MyStack);</span><span id="7fc8" class="mv ll je lc b gy na mx l my mz">const Medium = () =&gt; {<br/>  return &lt;MyNav /&gt;<br/>}<br/>export default Medium;</span></pre><p id="76da" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还需要制作WebViewScreen，这是一个基本的WebView，它从导航中提取url，并在应用程序中显示它。我包含了加载状态，因为我认为显示ActivityIndicator总比什么都不显示好，即使它只需要一秒钟的加载时间。</p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="7aa3" class="mv ll je lc b gy mw mx l my mz">import React, { Component } from 'react';<br/>import { View, ActivityIndicator, WebView } from 'react-native';</span><span id="6c28" class="mv ll je lc b gy na mx l my mz">class WebViewScreen extends Component {</span><span id="2e86" class="mv ll je lc b gy na mx l my mz">renderLoadingView() {<br/>    return (<br/>      &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center'}}&gt;<br/>        &lt;ActivityIndicator<br/>          size='large'<br/>        /&gt;<br/>      &lt;/View&gt;<br/>    );<br/>  }<br/>  render() {<br/>    const { url }  = this.props.navigation.state.params;<br/>    return(<br/>      &lt;WebView<br/>        source={{uri: url }}<br/>        renderLoading={this.renderLoadingView}<br/>        startInLoadingState={true}<br/>      /&gt;<br/>    );<br/>  }<br/>}<br/>export default WebViewScreen;</span></pre><p id="c1ba" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在一切都像预期的那样工作——应用程序显示加载了内容的导航堆栈视图，点击链接会打开任何默认浏览器。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nc"><img src="../Images/1021d3c9b1ba7210e764dbbd13c5d419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c79w81puOpZSN67FVlQmEQ.png"/></div></div></figure></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="726c" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">停止WebView的默认链接行为</h1><p id="bb3d" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">接下来，我们需要中断加载过程，并检查链接，看看应该如何处理它。为此，我们将使用<code class="fe kz la lb lc b">onNavigationStateChange</code>，第一步是停止加载webview。我们需要为WebView创建一个ref，然后我们可以调用<code class="fe kz la lb lc b">stopLoading</code></p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="18d1" class="mv ll je lc b gy mw mx l my mz">&lt;WebView<br/>  source={{uri: url }}<br/>  renderLoading={this.renderLoadingView}<br/>  startInLoadingState={true}<br/>  ref={(ref) =&gt; { this.webview = ref; }}<br/>  onNavigationStateChange={(event) =&gt; {<br/>    this.webview.stopLoading();<br/>  }}<br/>/&gt;</span></pre><p id="3f08" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尝试重新加载应用程序，您将看到第一个问题WebView的初始加载算作导航更改事件。所以我们需要检查以确保<code class="fe kz la lb lc b">event.url</code>不同于我们从导航参数中加载的url</p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="896c" class="mv ll je lc b gy mw mx l my mz">&lt;WebView<br/>  source={{uri: url }}<br/>  renderLoading={this.renderLoadingView}<br/>  startInLoadingState={true}<br/>  ref={(ref) =&gt; { this.webview = ref; }}<br/>  onNavigationStateChange={(event) =&gt; {<br/>    if (event.url !== url) {<br/>      this.webview.stopLoading();<br/>    }<br/>  }}<br/>/&gt;</span></pre><p id="a236" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了一个显示内容的WebView，但是不加载任何链接。打开一个外部链接是一个简单的<code class="fe kz la lb lc b">Linking.openURL(event.url)</code>命令，但是在应用程序中作为新的屏幕打开链接有点棘手。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="cbda" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">在应用程序中打开链接</h1><p id="a312" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">这里我们需要做的第一件事是用一个新屏幕设置StackNavigator。它使用相同的<code class="fe kz la lb lc b">WebViewScreen</code>，但是url参数作为一个属性提供给它</p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="6cdf" class="mv ll je lc b gy mw mx l my mz">Internal: {<br/>  screen: WebViewScreen,<br/>  params: { url: props =&gt; props.navigation.state.params.url },<br/>}</span></pre><p id="c62b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，在我们的WebView中，我们可以检查该url是否来自特定的域，并使用它来确定该链接是否应该被推送到新的<code class="fe kz la lb lc b">Internal</code>屏幕，或者以通常的方式打开。别忘了<code class="fe kz la lb lc b">import { StackActions } from 'react-navigation';</code></p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="19be" class="mv ll je lc b gy mw mx l my mz">onNavigationStateChange={(event) =&gt; {<br/>  if (event.url !== url) {<br/>    this.webview.stopLoading();<br/>    if (event.url.includes('<a class="ae nb" href="http://www.damienmason.com'" rel="noopener ugc nofollow" target="_blank">http://www.damienmason.com'</a>)) {<br/>      dispatch(<br/>        StackActions.push({<br/>          routeName: 'Internal',<br/>          params: { url: event.url },<br/>        })<br/>      )<br/>    } else {<br/>      Linking.openURL(event.url);<br/>    }<br/>  }<br/>}}</span></pre><p id="2870" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在这里使用的是<code class="fe kz la lb lc b">StackActions.push</code>而不是<code class="fe kz la lb lc b">navigation.navigate</code>,这样屏幕就会一个接一个地显示出来，即使技术上来说是同一个页面，但是输入了不同的url</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="0caf" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">添加自定标题</h1><p id="d0c8" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">我不会在这里说太多的细节，但是如果这是你需要的东西(对我来说，我们有一个带标题参数的自定义标题)，一个选择是在url的末尾添加一个标题，像<code class="fe kz la lb lc b">mypage.html#my_custom_page_title</code>，然后使用<code class="fe kz la lb lc b">event.url.substring(event.url.lastIndexOf('#')+1, event.url.length).replace(/_/g, ' ')</code>把它作为一个变量拉出来。第一部分抓取#后面的字符串，第二部分用空格替换下划线。你也可以对它进行camelcase或其他任何你想要的字符串操作，并把它作为一个参数反馈到下一个屏幕。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="6a9e" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">链接到自定义屏幕</h1><p id="5153" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">我们需要考虑的最后一种情况是如何链接到一个自定义屏幕，内容不是来自外部html源，而是直接编码到组件中。我将把它放在Medium.js文件中进行测试</p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="fd7a" class="mv ll je lc b gy mw mx l my mz">const CustomScreen = () =&gt; {<br/>  return &lt;View&gt;&lt;Text&gt;CustomScreen&lt;/Text&gt;&lt;/View&gt;<br/>}</span></pre><p id="cff7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有几种方法可以做到这一点，但重要的是WebView必须将链接视为真实的，所以它会尝试打开它并触发<code class="fe kz la lb lc b">onNavigationStateChange</code>，所以在我的例子中，我使用了<code class="fe kz la lb lc b"><a class="ae nb" href="http://local/CustomScreen" rel="noopener ugc nofollow" target="_blank">http://local/CustomScreen</a></code>作为html中的url。然后，在我的事件检查语句中，我们只需要查看它是否来自该url，如果是，则获取链接的结尾(final /)并在导航函数中使用它</p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="88a8" class="mv ll je lc b gy mw mx l my mz">else if (event.url.includes('<a class="ae nb" href="http://local/'" rel="noopener ugc nofollow" target="_blank">http://local/'</a>)) {<br/>  const pageLink = event.url.substring(event.url.lastIndexOf('/')+1, event.url.length);<br/>  navigate(pageLink)<br/>}</span></pre></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="14bf" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">又抓到你了</h1><p id="99b2" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">这将在iOS模拟器上按预期工作，但由于某种未知原因，它会继续加载本地url，所以如果你导航回屏幕，它会抛出一个错误。如果您不从WebView导航离开，它就不会发生，我真的不知道它在做什么，但为了避免让您头疼，我只需在调度后抛出一个<code class="fe kz la lb lc b">this.webview.reload()</code>—WebView屏幕将在堆栈导航动画发生时重新加载，这并不理想，但这是我能找到的最佳解决方案。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="60ea" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">还有一个</h1><p id="e41a" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">如果你绕回原来的屏幕，你会遇到另一个恼人的问题，那就是<code class="fe kz la lb lc b">onNavigationStateChange</code>被调用了两次，这意味着内部StackActions push发生了两次。它似乎也忽略了<code class="fe kz la lb lc b">webview.stopLoading()</code>。我能想到的最好的解决方案是使用<code class="fe kz la lb lc b"><a class="ae nb" href="http://local" rel="noopener ugc nofollow" target="_blank">http://local</a></code>选项链接回第一个屏幕。它没有出现在我的构建中，但它是值得注意的。如果你知道为什么会这样，请告诉我。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="a884" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">给我密码</h1><p id="3de2" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">索引. js</p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="9d4c" class="mv ll je lc b gy mw mx l my mz">import React from 'react';<br/>import { View, Text  } from 'react-native';<br/>import { createAppContainer, createStackNavigator } from 'react-navigation';</span><span id="38ba" class="mv ll je lc b gy na mx l my mz">// SCREENS<br/>import WebViewScreen from './WebViewScreen';</span><span id="8c9c" class="mv ll je lc b gy na mx l my mz">const CustomScreen = () =&gt; {<br/>  return &lt;View&gt;&lt;Text&gt;Custom Screen&lt;/Text&gt;&lt;/View&gt;<br/>}</span><span id="676a" class="mv ll je lc b gy na mx l my mz">const MyStack = createStackNavigator({<br/>  Landing: {<br/>    screen: WebViewScreen,<br/>    params: { url: '<a class="ae nb" href="http://www.damienmason.com/medium/react-navigation-webview.html'" rel="noopener ugc nofollow" target="_blank">http://www.damienmason.com/medium/react-navigation-webview.html'</a> },<br/>  },<br/>  Internal: {<br/>    screen: WebViewScreen,<br/>    params: { url: props =&gt; props.navigation.state.params.url },<br/>  },<br/>  CustomScreen: CustomScreen<br/>});</span><span id="5d0f" class="mv ll je lc b gy na mx l my mz">const MyNav = createAppContainer(MyStack);</span><span id="9b88" class="mv ll je lc b gy na mx l my mz">const Medium = () =&gt; {<br/>  return &lt;MyNav /&gt;<br/>}</span><span id="2bfe" class="mv ll je lc b gy na mx l my mz">export default Medium;</span></pre><p id="1549" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">WebViewScreen.js</p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="1e7a" class="mv ll je lc b gy mw mx l my mz">import React, { Component } from 'react';<br/>import { View, ActivityIndicator, Linking, WebView } from 'react-native';<br/>import { StackActions } from 'react-navigation';</span><span id="4703" class="mv ll je lc b gy na mx l my mz">class WebViewScreen extends Component {</span><span id="82e6" class="mv ll je lc b gy na mx l my mz">renderLoadingView() {<br/>    return (<br/>      &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center'}}&gt;<br/>        &lt;ActivityIndicator<br/>          size='large'<br/>        /&gt;<br/>      &lt;/View&gt;<br/>    );<br/>  }<br/>  render() {<br/>    const { navigate, state, dispatch } = this.props.navigation;<br/>    const { url }  = state.params;<br/>    return(<br/>      &lt;WebView<br/>        source={{uri: url }}<br/>        renderLoading={this.renderLoadingView}<br/>        startInLoadingState={true}<br/>        ref={(ref) =&gt; { this.webview = ref; }}<br/>        onNavigationStateChange={(event) =&gt; {<br/>          if (event.url !== url) {<br/>            this.webview.stopLoading();<br/>            if (event.url.includes('<a class="ae nb" href="http://www.damienmason.com'" rel="noopener ugc nofollow" target="_blank">http://www.damienmason.com'</a>)) {<br/>              dispatch(<br/>                StackActions.push({<br/>                  routeName: 'Internal',<br/>                  params: { url: event.url },<br/>                })<br/>              )<br/>            } else if (event.url.includes('<a class="ae nb" href="http://local/'" rel="noopener ugc nofollow" target="_blank">http://local/'</a>)) {<br/>              const pageLink = event.url.substring(event.url.lastIndexOf('/')+1, event.url.length);<br/>              navigate(pageLink)<br/>              this.webview.reload()<br/>            } else {<br/>              Linking.openURL(event.url);<br/>            }<br/>          }<br/>        }}<br/>      /&gt;<br/>    );<br/>  }<br/>}<br/>export default WebViewScreen;</span></pre><p id="8329" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和外部html中的示例链接</p><pre class="mn mo mp mq gt mr lc ms mt aw mu bi"><span id="7e51" class="mv ll je lc b gy mw mx l my mz">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Using WebView with React Navigation Example&lt;/title&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;h1&gt;Using WebView with React Navigation Example&lt;/h1&gt;<br/>    &lt;p&gt;&lt;a href="<a class="ae nb" href="http://www.medium.com" rel="noopener">http://www.medium.com</a>"&gt;Link to external screen&lt;/a&gt;&lt;/p&gt;<br/>    &lt;p&gt;&lt;a href="<a class="ae nb" href="http://www.damienmason.com/medium/react-navigation-webview-2.html" rel="noopener ugc nofollow" target="_blank">http://www.damienmason.com/medium/react-navigation-webview-2.html</a>"&gt;Link to internal screen&lt;/a&gt;&lt;/p&gt;<br/>    &lt;p&gt;&lt;a href="<a class="ae nb" href="http://local/CustomScreen" rel="noopener ugc nofollow" target="_blank">http://local/CustomScreen</a>"&gt;Link to custom screen&lt;/a&gt;&lt;/p&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="6101" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谢谢大家。我希望这对您自己的项目有所帮助。如果你需要更多的信息，请随时给我写信，或者分享你对如何处理这种工作的想法。</p></div></div>    
</body>
</html>