<html>
<head>
<title>Why I wrote a JS Test Runner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我为什么要编写JS测试运行程序</h1>
<blockquote>原文：<a href="https://itnext.io/why-i-wrote-a-js-test-runner-c1d50c3597f?source=collection_archive---------9-----------------------#2018-06-23">https://itnext.io/why-i-wrote-a-js-test-runner-c1d50c3597f?source=collection_archive---------9-----------------------#2018-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e47e2f61b7c1fd3f2e6333de8cd3a8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnaEJQFr16g4OhXF_CBIKQ.png"/></div></div></figure><p id="8eb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，充实我们项目测试的任务被丢给了我。概念证明是使用<a class="ae kw" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>编写的。将它们交给我的开发人员指出了Jest文档中的一个有趣的小引用:“有太多不同的匹配器要记住它们，所以本文将只尝试介绍最有用的那些”。你可能会想，匹配器到底是什么？他们是这些有趣的小助手，让你做类似<code class="fe kx ky kz la b">expect(sum(1, 1)).toBe(2)</code>的事情。这真的很有帮助，因为在Javascript中没有办法检查两个变量是否相等，就像<code class="fe kx ky kz la b">sum(1, 1) === 2</code>。或者如果你想在条件不满足时抛出一个错误，你不能像<code class="fe kx ky kz la b">assert(sum(1, 1) === 2, 'sum is broken again')</code>那样做。撇开讽刺不谈，对于一些更复杂的<code class="fe kx ky kz la b">expect</code>方法，如<code class="fe kx ky kz la b">toMatchObject</code>、<code class="fe kx ky kz la b">toThrow,</code>或<code class="fe kx ky kz la b">rejects</code>，还有一个争论。但是这些可以作为实用程序提供，而不是让测试运行的唯一方法。鉴于我不喜欢那里的哲学，我转向了<a class="ae kw" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="423f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="li">就像他们</em> <code class="fe kx ky kz la b"><em class="li">expect.yourCodeToBeWrittenInPseudoEnglish(true)</em></code> <em class="li">。</em></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="cdc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我以前用过摩卡，记得我喜欢它。它还声称支持<a class="ae kw" href="https://mochajs.org/#dynamically-generating-tests" rel="noopener ugc nofollow" target="_blank">动态生成测试</a>，这是我在Jest文档中找不到的。然而，我想基于异步获取的数据编写动态测试。这个简单的测试案例演示了异步生成测试并不是很好:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">Mocha无法异步生成动态测试</figcaption></figure><p id="1466" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您尝试运行它，Mocha将报告没有测试。有一些变通办法，就像<a class="ae kw" href="https://stackoverflow.com/a/35793665" rel="noopener ugc nofollow" target="_blank">这个问题的答案</a>中详述的那样，但是它们不是很干净。我想要更好的东西。</p><p id="880f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在网上搜索之后，我找到了这篇我非常喜欢的文章。我同意滥用全局变量和共享状态是Mocha、Jasmine、Jest和其他人的大问题。我特别喜欢这句话“测试断言应该非常简单，完全没有魔法”。这篇文章还向我介绍了我以前不熟悉的<a class="ae kw" href="https://testanything.org/" rel="noopener ugc nofollow" target="_blank">测试任何东西协议</a> (TAP)。文章认为你应该使用<a class="ae kw" href="https://github.com/substack/tape" rel="noopener ugc nofollow" target="_blank">胶带</a>包装。通读磁带上的文档，我注意到的第一件事是，如果我想要对承诺的支持，我需要使用一个名为<a class="ae kw" href="https://github.com/spion/blue-tape" rel="noopener ugc nofollow" target="_blank">蓝色磁带</a>的衍生产品。Blue Tape README有一些示例伪代码，所以我修改了它，以便它可以运行，然后测试它。正如你在这里看到的<a class="ae kw" href="https://github.com/spion/blue-tape/issues/31" rel="noopener ugc nofollow" target="_blank"/>，结果并不令人兴奋。这是他们的<em class="li">一个</em>例子中的代码，它甚至不能正确运行。这告诉了我关于图书馆我需要知道的一切。</p><p id="9a0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我正准备放弃使用摩卡咖啡。但是进一步搜索，我偶然发现了<a class="ae kw" href="http://www.node-tap.org/" rel="noopener ugc nofollow" target="_blank">节点点击</a>。我直接找到了Node-Tap文档，而不是找到它的推荐。这使得它看起来像是一个未使用的包，是某人作为周末项目构建的，然后一眼就放弃了。不过，我读得越多，就越兴奋。这终于是我要找的包裹了！作者列出了他对测试库的一些看法，我认为其中大部分都很有见地。第一个足够深刻，值得在这里重复:</p><blockquote class="lt lu lv"><p id="e11a" class="jy jz li ka b kb kc kd ke kf kg kh ki lw kk kl km lx ko kp kq ly ks kt ku kv ij bi translated">测试文件应该是可以直接运行的“普通”程序。</p></blockquote><p id="8430" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这真的引起了我的共鸣。这意味着你的测试不应该有让新开发人员困惑的全局变量。这意味着如果你想使用for循环添加测试用例，你可以。这意味着如果你想把测试用例放在一个<code class="fe kx ky kz la b">setTimeout</code>回调中，你可以。如果你在工作中写测试，那就意味着你以写代码为生。如果你以写代码为生，那么你可能可以处理写测试代码。</p><p id="04be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我急切地安装了node-tap，并编写了我的第一个测试用例。但正如node-tap作者所指出的“tutti i gusti，sono gusti”(没有对味道的解释)。这个一揽子计划坚持了它的承诺，但是仍然有一些我不喜欢的地方。看一下下面的代码:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="8fc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你能发现问题吗？对于那些没有看到它的人来说，问题是<code class="fe kx ky kz la b"><a class="ae kw" href="http://www.node-tap.org/api/#tplannumber" rel="noopener ugc nofollow" target="_blank">plan</a></code>或<code class="fe kx ky kz la b"><a class="ae kw" href="http://www.node-tap.org/api/#tend" rel="noopener ugc nofollow" target="_blank">end</a></code>从来没有被调用过，所以测试会失败，因为它是“未完成的”。如果你确实发现了问题，那么你可能已经被其他测试框架灌输了。想象一下，你是一个经验丰富的开发人员，但是你从来没有见过测试。查看代码，你可以看到函数<code class="fe kx ky kz la b">tap.test</code>被传递了一个字符串和一个函数，这可能是某种回调。查看回调，可以发现断言不会抛出错误。因此，您可以推断，如果断言抛出错误，测试很可能会失败。同样，您会推断，既然assert不会抛出，那么测试很可能会通过。但事实并非如此。相反，我们有一个框架，它的行为与一般人的直觉相反。</p><p id="a768" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经可以听到人们大声抗议:但是<code class="fe kx ky kz la b">plan</code>帮助我避免误报！看看下面两个测试案例:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">需要和不需要计划的测试用例</figcaption></figure><p id="6744" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个测试用例需要一个<code class="fe kx ky kz la b">plan</code>。如果不需要计划并且<code class="fe kx ky kz la b">someCondition</code>和<code class="fe kx ky kz la b">anotherCondition</code>都为假，那么测试将通过，即使你可能已经预料到它会在任何时候失败<code class="fe kx ky kz la b">anotherCondition</code>为假。但是如果你把它重构为第二个测试，那么你就不会有这个问题。此外，可能应该有两个测试用例，一个断言<code class="fe kx ky kz la b">someCondition</code>为真，另一个断言为假。作为一个公开的挑战，我要求你想出一个测试用例不能被重构的例子，以消除对<code class="fe kx ky kz la b">plan</code>的需求。</p><p id="97ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，我彻底泄气了。但是，正如我之前所说，如果你能写代码，那么你就能写测试代码。如果你能为测试编写代码，那么你就能为测试运行人员编写代码。所以我决定为Javascript编写一个测试运行程序。结果是<a class="ae kw" href="https://www.npmjs.com/package/cupping" rel="noopener ugc nofollow" target="_blank">拔罐</a>。</p><p id="1597" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个小而简单的库，试图举例说明我认为重要的原则，同时避免前面提到的其他测试库的缺陷。继续安装它，试用它，并让我知道你的想法。它可能不适合每个人，但我希望至少有一些人在使用它时会愉快地恢复精神。</p></div></div>    
</body>
</html>