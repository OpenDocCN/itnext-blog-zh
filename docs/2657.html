<html>
<head>
<title>Life after Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重生后的生活</h1>
<blockquote>原文：<a href="https://itnext.io/life-after-redux-21f33b7f189e?source=collection_archive---------0-----------------------#2019-07-06">https://itnext.io/life-after-redux-21f33b7f189e?source=collection_archive---------0-----------------------#2019-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="172e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki"> Redux是一个有用的工具，然而，React的新API可以提供暂停，以确定它是否是你下一个应用程序的必需品。</em></h2></div><blockquote class="kj kk kl"><p id="d54b" class="km kn ko kp b kq kr ju ks kt ku jx kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">在本文中，我将探讨如何将React的新useReducer挂钩与简单的事件总线结合起来，为您的应用程序架构提供急需的可伸缩性，同时防止Redux在大型应用程序中经常出现的一些问题。</p></blockquote></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/2c3e188125ee27c18c91bc917137ec8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_9GcuoDUbWGTSFjdIkduA.jpeg"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">照片由阿里夫·瓦希德在Unsplash上拍摄</figcaption></figure><h1 id="c9d1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">根据React的新功能进行重复</h1><p id="0a57" class="pw-post-body-paragraph km kn it kp b kq my ju ks kt mz jx kv na nb ky kz nc nd lc ld ne nf lg lh li im bi translated">流行的状态容器<a class="ae ng" href="https://github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>为前端应用程序提供了几个好处，包括在分离的组件之间共享数据，确保数据一致性，以及为代码组织提供模板。然而，React核心API的最新添加可能表明它可能值得重新考虑，Redux是否适合你的应用程序。</p><p id="a596" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">由于最近的API变化，思维的转变已经开始出现，导致超过三分之二的Redux功能现在可以在React core本身中找到。除此之外，有人会说缺失的部分在作为“独立”实体维护时比在一个大的额外依赖中提供了更多的灵活性。</p><p id="9a56" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">有些人<a class="ae ng" href="https://medium.com/octopus-labs-london/replacing-redux-with-react-hooks-and-context-part-1-11b72ffdb533" rel="noopener">已经研究了</a>使用新的<a class="ae ng" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">钩子</a>和<a class="ae ng" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API</a>进行状态管理的基本思想，但是我在这里想要探索的是如何将Redux分解成它的复合部分，然后替换那些React】而不是提供的部分，这实际上使我们能够创建比纯Redux更灵活的架构，并且没有它的一些隐含缺陷。</p><h1 id="382b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">探索Redux和一些权衡</h1><p id="9a70" class="pw-post-body-paragraph km kn it kp b kq my ju ks kt mz jx kv na nb ky kz nc nd lc ld ne nf lg lh li im bi translated">Redux是一个功能性的不可变状态管理容器，它使用动作对象来控制，动作对象实际上就像事件一样。它允许应用程序使用这些事件来表示对全局不可变数据对象的更新，该更新被传播到状态改变监听器。Redux的定义和有效特性之一是程序员使用Reducer函数(想想<code class="fe nh ni nj nk b">Array.prototype.reduce</code>)将任何给定的动作对象与存储的当前状态合并的方式。</p><p id="9a00" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">然而使用Redux既有好处也有坏处。让我们探讨一下在React应用程序中使用Redux的优缺点。</p><p id="b5ae" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">使用Redux有很多好处。</p><ul class=""><li id="c129" class="nl nm it kp b kq kr kt ku na nn nc no ne np li nq nr ns nt bi translated">它允许开发人员通过使用像<code class="fe nh ni nj nk b">react-redux</code>这样的助手库，轻松地在整个应用程序的不同组件之间共享状态数据。</li><li id="4101" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nq nr ns nt bi translated">您得到了控制流、中间件模式和可用的中间件扩展生态系统。</li><li id="99f8" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nq nr ns nt bi translated">通过使用单个主存储，您可以确保您的状态保持一致，这在Redux和Flux之前的某些MVC模式中是一个问题。</li><li id="8c59" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nq nr ns nt bi translated">随后，集中化允许开发人员随着时间的推移潜在地探索和调试应用程序状态，这是一种由<a class="ae ng" href="https://github.com/reduxjs/redux-devtools" rel="noopener ugc nofollow" target="_blank"> Redux Devtools </a>支持的技术，也称为时间旅行调试。</li><li id="07e1" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nq nr ns nt bi translated">状态缩减器模式是管理和配置原子状态变化的一种有效而简单的方式，重要的是Redux为JavaScript应用程序中的状态管理提供了一种公共语言和约定。</li></ul><p id="e76f" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">所以一切都很好，但是Redux仍然存在一些问题:</p><ul class=""><li id="6ba5" class="nl nm it kp b kq kr kt ku na nn nc no ne np li nq nr ns nt bi translated">Redux趋向于成为一个全球性的依赖，它的触角将遍及你的代码库。</li><li id="7030" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nq nr ns nt bi translated">这可能导致开发人员倾向于存储比实际需要多得多的全局状态。</li><li id="9f62" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nq nr ns nt bi translated">Redux被认为是一个状态管理容器，但经常被用作事件总线，这是一种依赖于上下文的实践，可以被认为是一种反模式。</li><li id="d204" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nq nr ns nt bi translated">Redux不能很好地处理开箱即用的异步性，甚至需要中间件来支持异步事件。</li><li id="d098" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nq nr ns nt bi translated">Redux也不处理开箱即用的副作用。</li><li id="f872" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nq nr ns nt bi translated">与其他隐式状态管理容器(如路由器)的集成一直存在问题。</li><li id="5957" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nq nr ns nt bi translated">因为有了新的React APIs，您实际上不需要Redux来管理您的应用程序数据。</li></ul><p id="8013" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">这些折衷中的一些可以通过将Redux拆分成单独的组件来部分解决，而其他的则不能。同时，我们可能会失去像Redux这样的标准库所提供的一些优势。为了查看我们的选项，现在让我们检查数据更改事务的流程，以便更好地理解Redux和现在都为我们提供了什么。</p><h1 id="6aaf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">分解数据事务</h1><p id="c8db" class="pw-post-body-paragraph km kn it kp b kq my ju ks kt mz jx kv na nb ky kz nc nd lc ld ne nf lg lh li im bi translated">在探索如何最好地使用React now带来的东西之前，有必要更深入地了解一下Redux在概念上的工作方式，以便我们能够与我们所拥有的新的内置React工具进行有意义的区分。</p><p id="8cda" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated"><code class="fe nh ni nj nk b">(state, action) =&gt; state</code>缩减器是Redux的核心，因为它控制数据事务的转换阶段。这是定义大部分前端业务层的关键配置，但围绕它还有子系统或构建块，它们构成了事务序列中的一个链。在构建Redux驱动的React应用程序时，您可能需要考虑类似如下的构建模块:</p><ol class=""><li id="7cf9" class="nl nm it kp b kq kr kt ku na nn nc no ne np li nz nr ns nt bi translated">一个<em class="ko">组件</em>以动作的形式向Redux中的<em class="ko">发布/订阅</em>或<em class="ko">事件总线</em>实现发送数据。</li><li id="62af" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nz nr ns nt bi translated"><em class="ko"> Pub/Sub </em>通过一系列的中间件发送数据，这些中间件操纵动作，进行突变或延迟。我喜欢称之为<em class="ko">事务预处理</em></li><li id="d088" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nz nr ns nt bi translated">最终，动作被发送到一个<em class="ko">事务引擎</em>，它运行一个纯粹的Reducer函数，将当前状态与给定的动作不变地合并，产生一个新的状态树。</li><li id="e9c3" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nz nr ns nt bi translated">新的状态树存储在<em class="ko">数据存储器</em>中，该数据存储器作为内存对象存在，但也可以缓存在其他地方，如本地存储器或数据库。</li><li id="9dd1" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nz nr ns nt bi translated"><em class="ko">状态依赖注入器</em>从数据存储器接收变化，并向需要它的组件提供新状态</li><li id="dd80" class="nl nm it kp b kq nu kt nv na nw nc nx ne ny li nz nr ns nt bi translated">接收者<em class="ko">组件</em>最终接收新状态并重新呈现显示更新的数据。</li></ol><p id="a315" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">你可以用下面的方式来考虑这个流程和提供每个部分的技术组合，其中<code class="fe nh ni nj nk b">react-redux</code>是状态依赖注入器，而<code class="fe nh ni nj nk b">redux</code>本身提供了几个部分。参见下图:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oa"><img src="../Images/5e0f2e1a2a5d9e58b1e508ea73f7814a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKiR5S5NePNWewLxlM4kcg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated"><em class="ki">Redux交易的构建模块</em></figcaption></figure><h1 id="29ca" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">那么React现在会带来什么呢？</h1><p id="47b9" class="pw-post-body-paragraph km kn it kp b kq my ju ks kt mz jx kv na nb ky kz nc nd lc ld ne nf lg lh li im bi translated">React的<a class="ae ng" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">新</a><a class="ae ng" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">API</a>提供了替换大量Redux组件以及所有<code class="fe nh ni nj nk b">react-redux</code>的设施。在它的<code class="fe nh ni nj nk b">useReducer</code> API中可以找到一个类似的事务引擎。<code class="fe nh ni nj nk b">useReducer</code>钩子也设法提供了一个不可变的数据存储。然后我们可以利用新的<code class="fe nh ni nj nk b">useContext</code> API作为状态依赖注入器。如果将客户端组件包括在内，可以说现在整个事务流的几乎三分之二是在React捆绑的特性中管理的。这是一个巨大的卸载量！</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oa"><img src="../Images/ae0848e9dfdcf9b2140ebf89326d0027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqgFoA9pG8qKBMumA-nyDg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated"><em class="ki">用React代替Redux </em></figcaption></figure><p id="34f9" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">现在，您可以看到缺少的是一个发布/订阅(或事件系统)和一个事务预处理器。</p><p id="7593" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">有些人可能会说，<code class="fe nh ni nj nk b">useReducer</code>已经提供了一个事件系统，因为它公开了一个可以被孩子共享的<code class="fe nh ni nj nk b">dispatch</code>函数。事情是这样的，因为React的纤程重写和最终一致的状态解析的细节，没有简单的方法将顺序事务预处理层应用到T2。基本上，这意味着使用<code class="fe nh ni nj nk b">dispatch</code>作为事件系统的客户端以及流入事务的反应端(与事件系统本身相反)的问题要少得多。您还获得了一个额外的优势，将您的事件调度程序从您的状态中分离出来，这在您临时将应用程序上下文捆绑在一起时变得非常重要，因为它们不应该混合数据。</p><p id="f07d" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">对于<code class="fe nh ni nj nk b">createContext</code>的性能，也有一些担心(见下面的评论),因为它能够将非常快的状态更新渲染到一个大的共享状态redux树中。你可以在<code class="fe nh ni nj nk b">react-redux</code>的<a class="ae ng" href="https://github.com/reduxjs/react-redux/issues/1177" rel="noopener ugc nofollow" target="_blank">技术挑战中看到这一点的证据，这些挑战正在转向创建一个环境</a>，因为他们正在努力为小的边缘情况支持预先存在的性能问题。通过将事件总线从状态管理中分离出来，您获得的一个好处是能够根据状态的性能需求来区别对待状态的每个部分。因此，在大多数情况下，使用React的<code class="fe nh ni nj nk b">createContext</code>就可以了，但是当您需要更快的更新性能时，一种可用的技术是直接监听来自事件总线的调度事件，并在需要时使用本地缓存进行内部管理。</p><p id="48ec" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">您可能会认为不避免Redux意味着您不得不失去对优秀工具工作流的访问，例如流行的Redux Devtools项目，但是，随着像<a class="ae ng" href="https://github.com/troch/reinspect" rel="noopener ugc nofollow" target="_blank"> reinspect </a>这样的项目允许开发人员将Devtools连接到useReducer和useState，现在Redux devtools不再有对Redux的硬性依赖。</p><h1 id="3297" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">添加事件系统</h1><p id="1cba" class="pw-post-body-paragraph km kn it kp b kq my ju ks kt mz jx kv na nb ky kz nc nd lc ld ne nf lg lh li im bi translated">那么你应该用什么作为你的事件系统呢？嗯，几乎任何你喜欢的东西。您可能会考虑类似RxJS的东西，因为您可以免费获得一个事务预处理引擎。比方说，如果你正在从redux-observable迁移一个应用程序，这可能是正确的举措。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ob"><img src="../Images/283fc313c1e0b28fc7927f645c2826da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UP6HVw7FEs248nsaHWBXeA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">使用RxJS作为事件总线和事务预处理系统</figcaption></figure><p id="d7b8" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">或者，我们可以使用节点的<a class="ae ng" href="https://www.npmjs.com/package/events" rel="noopener ugc nofollow" target="_blank"> EventEmitter </a>模块的同构端口来调度事件。这将工作，但它不支持监听通配符或名称间隔事件，这在我们想要将应用程序的各个部分分离出来以仅响应相关事件时会很有用。我发现成功的<a class="ae ng" href="https://github.com/EventEmitter2/EventEmitter2" rel="noopener ugc nofollow" target="_blank"> EventEmitter2 </a>允许通配符事件。这可能不适合所有人，但我的技巧是将它包装在一个<a class="ae ng" href="https://github.com/ryardley/ts-bus" rel="noopener ugc nofollow" target="_blank">简单的事件总线API中，该API包含良好的类型脚本支持</a>，仅提供我在事件总线中实际需要的一小部分功能。我为这项技术创建了自己的库，名为<code class="fe nh ni nj nk b"><a class="ae ng" href="https://github.com/ryardley/ts-bus" rel="noopener ugc nofollow" target="_blank">ts-bus</a></code>。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oc"><img src="../Images/d1e182b509988e78ee45d0fde378927f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTYx6G0XlweF3FeTX8gKGQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">仅使用事件总线</figcaption></figure><p id="f2c0" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">这两种安排都比单独使用Redux提供了更大的灵活性。</p><h1 id="dded" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">独立事件系统的一些好处</h1><p id="7cc3" class="pw-post-body-paragraph km kn it kp b kq my ju ks kt mz jx kv na nb ky kz nc nd lc ld ne nf lg lh li im bi translated">将事件系统从状态管理中分离出来有很多好处。</p><p id="3a5e" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated"><strong class="kp iu">你并不总是需要状态根据一个事件而改变<br/> </strong>虽然状态响应一个事件而改变是很常见的，但你并不总是需要将状态改变与一个事件联系起来。有时所需要的只是启动一个异步后台进程，并让它在完成时进行报告。在不需要的地方引入外部状态会增加复杂性和开销。</p><p id="d357" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated"><strong class="kp iu">您已经将您的依赖暴露限制在一个小的简单组件<br/> </strong>事件系统将成为任何大型应用程序的主要依赖危害，因为必须与另一个组件通信的每个组件都需要访问您的事件调度程序的实例。通过使用独立的事件系统，我们避免了将状态管理自动连接到所有应用程序组件。</p><p id="4c57" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated"><strong class="kp iu">您可以随心所欲地管理异步性</strong> <br/>事件不再与状态变化联系在一起，因此异步变得更加容易。想使用异步函数来管理异步事件吗？简单。您可以控制如何管理异步性，以及可以使用哪些状态依赖项。诚然，实现一个可取消的saga工作流更加困难，但这从一开始就不是一个容易解决的问题，而且实际上也很少需要。</p><p id="16e2" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">在单独的存储中跟踪状态很简单，例如路由器 <br/>偶尔状态需要被管理，但是不能在状态容器中被跟踪。这通常发生在导航中，其中状态通过某种路由器保存在浏览器URL中。拥有一个独立的事件系统意味着你可以很容易地为你的路由器提供一个抽象点。这项技术的另一个好处是，您不需要在整个应用程序中共享路由器代码。</p><p id="f5c0" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated"><strong class="kp iu">你拥有事件驱动架构的灵活性<br/> </strong>通过使用一个简单的事件发射器，你可以随心所欲地处理你的事件。无论是通过在服务工作者中运行处理程序，还是通过建立可观察的流或将计算卸载到服务器。向服务器发送事件，从服务器接收事件，同步第二个micro-Vue前端应用程序，用RxJS管理副作用；只要你能共享你的事件总线，你的应用程序架构就能支持它。这就是基于事件的架构的力量，你可以随心所欲地连接你的应用。</p><p id="abbc" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">作为一个例子，我们可以看到如何在概念上共享一个事件总线来在不同的前端框架之间进行通信。对于有几个团队在前端堆栈上工作的大型组织，或者对于缓慢地一部分一部分地重新编写系统的团队来说，这可能是一个很好的方法:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/dc95e36c8edfc6b82a65bc961ff830d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*lhjMDljTpWbOGqvetV4hIA.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">事件总线上的微前端通信示例。请注意，每个应用程序管理自己的状态，以避免代码库之间的依赖性</figcaption></figure><p id="dc77" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">或者，您可以通过类似<a class="ae ng" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>的桥接系统设置您的事件总线，例如在浏览器和工业事件流平台(如<a class="ae ng" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>)之间创建一个多路传输消息通道，以便为大型事件源应用程序提供信息。对于需要实时数据的金融交易所来说，这可能是一个好方法。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oe"><img src="../Images/7f4cc71aec648839641c416a54bc483f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cijwEMXOLvWomBiqm19ATw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">客户端和服务器之间同步事件的可能例子。</figcaption></figure><p id="47d6" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">最后，因为我们讨论的是基本的事件总线架构，而Redux包含一个事件总线，所以这些系统当然可以通过使用Redux本身来建立。这里需要注意的是，使用Redux时，你用总线拖动数据，这实际上可能弊大于利，因为<em class="ko">开发人员无意中在应该保持分离的系统之间共享了状态。</em></p><h1 id="d1fa" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="1400" class="pw-post-body-paragraph km kn it kp b kq my ju ks kt mz jx kv na nb ky kz nc nd lc ld ne nf lg lh li im bi translated">Redux是一个有价值的多功能库，但它不仅仅是一个状态管理容器。当您选择使用Redux时，您就选择了您的事件总线、您的数据存储、您的规范DI机制等等，并且依赖一个包来实现所有这些独立的应用程序功能可能并不是您在每种情况下都需要的。</p><p id="5cf4" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">虽然重新编写大型应用程序来删除Redux毫无意义，但由于Redux有成为全局依赖项的趋势，新的或较小的应用程序应该仔细考虑是否可以通过选择适当的事件总线和使用内置的React状态管理来满足他们的需求，因为这将导致更干净和更灵活的架构。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="35e2" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated">这篇文章是一篇活的文档，如果你想投稿或在这里看到任何不准确的地方，请联系我们。</p><p id="1374" class="pw-post-body-paragraph km kn it kp b kq kr ju ks kt ku jx kv na kx ky kz nc lb lc ld ne lf lg lh li im bi translated"><em class="ko">你可以在Twitter上以</em><a class="ae ng" href="https://twitter.com/rudiyardley" rel="noopener ugc nofollow" target="_blank"><em class="ko">@ Rudi Yardley</em></a><em class="ko">关注rudiyardley或者在Github上以</em><a class="ae ng" href="https://github.com/ryardley" rel="noopener ugc nofollow" target="_blank"><em class="ko">@</em>ryardley</a></p></div></div>    
</body>
</html>