<html>
<head>
<title>CRUD tables need to die.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CRUD表需要被淘汰。</h1>
<blockquote>原文：<a href="https://itnext.io/crud-tables-need-to-die-93d213b0d18a?source=collection_archive---------0-----------------------#2021-09-14">https://itnext.io/crud-tables-need-to-die-93d213b0d18a?source=collection_archive---------0-----------------------#2021-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5657" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">大多数业务数据都需要一个(双)时态的、不可变的、基于事件的模型。为什么我们不默认这个呢？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f638bee672b64fa69608d8b0c66564b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5DeOm1WTOiyUWblUOmdvw.jpeg"/></div></div></figure><p id="7098" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">许多web编程项目和特性都是从CRUD(创建、读取、更新、删除)模型中的数据建模开始的。这是Rails或Django风格的框架和ORM中的默认设置。这是他们在SQL课程里教的。您有一个“事物”表，然后您可以插入、选择、更新、删除查询。这很简单，也很有效。直到有人问你上周有多少东西处于“foo”状态，包括那些从那以后被删除或改变状态的东西。</p><h1 id="13ba" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">示例:贸易公司</h1><p id="1dc2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">先说个例子。Joe决定创办一家名为“贸易公司”的电子商务公司，作为第一项业务，他用一些简单的状态机创建了一个订单表。让我们暂时忽略一些东西，比如账单、运输、产品和钱。Joe启动了一个web框架，生成了第一个数据库表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">订单数据的CRUD表。使用基于enum的状态机。</figcaption></figure><p id="24e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">经过一段时间的发展和运营，该贸易公司聘请了一批营销，运营，财务，商业分析师等。Joe开始收到这样的请求:</p><ul class=""><li id="f79f" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp my mz na nb bi translated"><strong class="kw iu">客户完成订单平均需要多长时间</strong>？(订单状态:“待定”- &gt;“已完成”)</li><li id="25a9" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu">我们需要经常为客户编辑打错的信息吗？</strong>(某些订单字段多久编辑一次？)</li><li id="b2f1" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">有人篡改了订单金额字段吗？(假设订单有一个<code class="fe nh ni nj nk b">total_amount</code>列，或者我们可以从一个<code class="fe nh ni nj nk b">order_rows</code>表中对其求和；不管是哪种方式，我们都不能轻易地从一个简单的CRUD表中分辨出它们是否被编辑过。)</li><li id="9527" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu">我们所有的退款真的是来自“已完成”的订单，还是之前我们也对一些“失败”的订单进行了退款？CRUD失去了很多审计能力，这种能力不仅在业务用例中有用，在调试和错误修复中也很有用。</strong></li></ul><p id="1010" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这对Joe来说很尴尬，因为他无法回答这些问题，因为他的设计很粗糙。接下来，我们将研究几个不同的理论主题、行业术语以及从不同方向解决这个问题的术语。</p><h1 id="2b93" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">尺寸缓慢变化</h1><p id="308b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Joe正在处理一个在某些圈子里被称为渐变维度(SCD)的问题。这意味着他正在处理变化相对缓慢且不可预测的数据点。这与“所有时间和可预测的”相反，在这种情况下，我们的系统可能已经以一种好的方式处理它了。现在，在我们的例子中，当订单被退款时，我们通过将它翻转到“已退款”来覆盖告诉我们该订单在某个点“已完成”的信息。实际上，CRUD表中的任何更新也是如此，因为我们只存储任何列的当前状态。</p><p id="ac34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，有一个系统来思考SCD以及如何处理它们。在我们深入之前，请注意SCD是一个数据仓库概念，它们强调该领域的一些问题，而不是像我们的电子商务示例那样的在线交易系统。然而，这些差异并没有那么大。让我们列举不同的SCD案例:</p><ul class=""><li id="e730" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp my mz na nb bi translated">第0类:永远不会改变的事实。 <em class="nl">出生日期，原始分数等。这里的想法是，这些是静态的事实，不会随着时间的推移而改变。轻松点。</em></li><li id="7d4a" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu">类型1:覆盖。</strong> <em class="nl">又名CRUD，或Joe正在做的事情。换个领域然后点击它。保存()！</em></li><li id="7b63" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">类型2:改为添加新行。 <em class="nl"> Joe可以在order表中添加一个“version”列，并将所有更新转换为INSERTs！我们已经进入了不可改变的、只能附加的领域……</em></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Type2订单，order_id不能再作为主键。</figcaption></figure><ul class=""><li id="6f5d" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp my mz na nb bi translated"><strong class="kw iu">类型3:添加新列。</strong> <em class="nl">对于某些字段，使用“原始值”或“先前值”和“当前值”等列可能更有意义。这很容易做到，但不是很强大。</em></li><li id="82a3" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu">类型4:历史表。</strong> <em class="nl"> Joe可以创建一个名为“orders_history”的表，并在每次订单发生变化时对其进行快照。这很好，因为他不需要改变原始的“订单”表，并且有许多现有的工具可以实现这一点。您可能听说过“变更数据捕获”，我们稍后会谈到这一点。</em></li></ul><p id="90c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的实现类似于type1和type2:原始表只是常规的type1 CRUD表，而历史表看起来像我们的type2不可变的仅追加表。然后，我们只需将数据复制到历史表中(在事务内部！)每次有写操作。</p><ul class=""><li id="a73b" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp my mz na nb bi translated"><strong class="kw iu">Type5:N/a .</strong>T22】短篇小说:type 5不存在。说来话长，确实如此，但是类型有点不同。如果想更深入地了解这一点，可以对比一下 <a class="ae nm" href="https://adatis.co.uk/introduction-to-slowly-changing-dimensions-scd-types/" rel="noopener ugc nofollow" target="_blank"> <em class="nl">这些</em> </a> <em class="nl"> </em> <a class="ae nm" href="https://www.kimballgroup.com/2013/02/design-tip-152-slowly-changing-dimension-types-0-4-5-6-7/" rel="noopener ugc nofollow" target="_blank"> <em class="nl">两个</em> </a> <em class="nl">来源。</em></li><li id="7286" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu">类型6 </strong> : <strong class="kw iu">类型1+2+3 = 6的组合。他们在命名惯例上的确很聪明。我将推迟向 <a class="ae nm" href="https://en.wikipedia.org/wiki/Slowly_changing_dimension" rel="noopener ugc nofollow" target="_blank"> <em class="nl">维基百科</em> </a> <em class="nl">解释这一点，因为它主要只是类型2的优化。</em></strong></li></ul><h1 id="72a3" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">变更数据捕获</h1><p id="c280" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在讨论type4历史表时，我们提到了变更数据捕获(CDC)。我们还提到有很多工具可以做到这一点。在我们的例子中，CDC的目的是跟踪CRUD表的所有变化，这样我们就不需要在每次修改表中的内容时都手动进行。</p><p id="ed80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">进行CDC的一些巧妙方法包括读取MySQL的二进制日志或PostgreSQL的预写日志，它们可以用来精确跟踪SQL表中的所有更改。这一类别中流行的替代产品是Debezium，它可以将一个变更日志从CRUD表传输到Apache Kafka。正如你可能想象的那样，对于许多项目来说，这有点像核选项。一个更快的选择可能是使用ETL/ELT库，如<a class="ae nm" href="https://github.com/singer-io" rel="noopener ugc nofollow" target="_blank"> Singer </a>，它们通常有许多不同的集成策略可用，可以将数据捕获到各种数据仓库产品中，如雪花、BigQuery或Redshift。</p><h1 id="a21b" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">ETL与ELT、OLTP与OLAP、数据湖与仓库</h1><p id="3e73" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">有些人谈论OLTP(在线事务处理)和OLAP(在线分析处理)。因此，您在PostgreSQL中的CRUD表是OLTP，然后您通过ETL或ELT(提取、加载、转换)将数据带到OLAP系统进行分析。那么这个OLAP系统是一个数据仓库、数据湖还是一个分析数据库呢？这要看情况，让我们来定义这些词:</p><ul class=""><li id="a91f" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp my mz na nb bi translated"><strong class="kw iu"> OLTP </strong>:事务数据库，如MySQL或PostgreSQL，通常运行您的生产应用程序。</li><li id="d270" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu"> OLAP </strong>:分析数据库，典型的是你用CDC、ETL、ELT加载数据的地方……<em class="nl">参见:数据仓库</em></li><li id="d786" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu">数据湖</strong>:以非常原始的格式转储数据的地方，主要供数据科学家和数据工程师使用。<em class="nl">工具示例:S3、拼花地板、Avro、… </em></li><li id="0317" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu">数据仓库</strong>:放置具有良好查询功能的结构化数据的地方。也适用于业务分析师，而不仅仅是技术人员。<em class="nl">例子:雪花，红移，BigQuery。</em></li><li id="2929" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu"> ETL </strong>:读取数据，处理数据，将数据索引到数据仓库。<em class="nl">例子:CDC将原始数据带到Kafka，在将数据加载到数据仓库之前，经过几个非平凡逻辑步骤的处理和组合。</em></li><li id="778a" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">ELT :读取数据，将它原样转储到某个地方，在分析系统中进行进一步的处理。<em class="nl">示例:CDC将原始数据从OLTP转换为BigQuery，并使用SQL进行进一步转换。</em></li></ul><p id="74e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae nm" href="https://a16z.com/2020/10/15/the-emerging-architectures-for-modern-data-infrastructure/" rel="noopener ugc nofollow" target="_blank">安德森·霍洛维茨对2020年的行业做了一个很好的分析</a>如果你想了解更多信息。他们还解释了<a class="ae nm" href="https://www.youtube.com/watch?v=voC0ewDeltA" rel="noopener ugc nofollow" target="_blank"> ETL与ELT </a>的区别，如果你想知道更多关于这种区别的话。这里的要点是，你可以继续在生产中进行CRUD，只需将更改历史转储到你的工具中(湖、仓库、OLAP，谁在乎呢…)的选择。但你需要投资相当多的额外的铃铛和口哨来做到这一点。</p><h1 id="3f49" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">活动采购和CQRS</h1><p id="79b8" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">事件源的基本思想是，我们不是直接改变CRUD表，而是将<em class="nl">事件</em>生成到某种日志、流或事件存储中，然后作为这些<em class="nl">事件的结果，</em>我们可以在某处改变<em class="nl">状态</em>，比如在CRUD表中。<em class="nl">状态</em>总是必须直接从事件中导出，以便在任何时候都可以重新计算。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/564a464d3af56cb00c9823a529875de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*o2ASY5NgMWb12UmelDmrTA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">持续事件。在我们的例子中,“modelId”指的是“订单Id”。</figcaption></figure><p id="94cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，基本上有两种选择:1)写&amp;读事件或2)写<em class="nl">事件</em>并从<em class="nl">投影(</em>即本例中的<em class="nl">状态</em><em class="nl">)。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b0236021fc0dc8b4a48bf2eb8a557d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*9Da_q5c8Wgoi5JpllLJ2AQ.png"/></div></figure><p id="531a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">命令查询责任分离(CQRS)只是一种把你的读和写放在不同地方的花哨说法。如果没有CQRS，读取将只是读取事件流。然而，对于CQRS，写操作进入事件存储，读操作进入从事件流/日志维护的<em class="nl">投影(状态)</em>表。</p><p id="7fce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以想象，这里有各种各样的实现方法。我们的例子只是实现事件采购和CQRS的一种方式。通用的解决方案是写入某种类型的事件流，读取投影(甚至可能不是表)。事件可以在一个表中，也可以在一些事件队列系统中。您可以在事务数据库中使用事务来实现一致性，或者当某个工作者从队列中读取事件，然后创建状态投影时，您可能最终会实现一致性。等等。然而，Joe也许可以用<code class="fe nh ni nj nk b">order_events</code>和<code class="fe nh ni nj nk b">order_state</code>表走得很远。</p><h1 id="c54a" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">时间建模</h1><p id="d007" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在时态数据库中，我们存储与时间相关的数据。例如，在我们的Orders表中，我们可以有一个订单到达时间的时间戳。也许我们可以使用上面描述的方法之一，用时间戳存储订单状态的转换，这样我们就知道何时发生了变化。然而，时间和历史不止一个维度。</p><ul class=""><li id="c416" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp my mz na nb bi translated"><strong class="kw iu">有效时间</strong>是现实世界中某个事实为真的时间段。<br/><strong class="kw iu"><em class="nl"/></strong><em class="nl">1992年乔住在哪里？”<br/>“客户什么时候下的订单？”</em></li><li id="ab40" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu">事务时间</strong>是在数据库中记录事实的时间。<br/><em class="nl">“1992年，数据库认为乔住在哪里？”<br/>“我们什么时候把订单写到数据库的？”</em></li><li id="92aa" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><strong class="kw iu">决策时间</strong>是对事实做出决策的时间。<br/> <em class="nl">“我们什么时候知道了1992年乔的家乡？”<br/>“我们什么时候意识到需要将订单写入数据库？”</em></li></ul><p id="8d80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能看起来像是吹毛求疵，但是请考虑下面这种相当常见的财务审计情况，它需要一个<strong class="kw iu">双时态</strong>(有效时间+交易时间)<strong class="kw iu"> </strong>建模:</p><ol class=""><li id="b8a7" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp np mz na nb bi translated">“请现在从系统中报告2016年1月以来的销售情况，包括此后对数据的所有修正”</li><li id="f716" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp np mz na nb bi translated">“请报告2016年1月的销售额，因为最初是在2016年2月1日报告的”(因此不包括从那时到现在的数据修正)</li></ol><p id="9957" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果Joe决定使用某种不可变的基于事件的系统，如SCD type2或type4表或事件源，他将遇到一个问题。如果数据是不可变的，那么如何修复数据库中已经存在的错误呢？双时态建模解决了这个问题，因为您可以在事件、行或快照中声明信息为真时的有效时间<em class="nl">和信息写入数据库时的事务时间<em class="nl"/>。现在，您可以通过向新事件/行/快照添加一个到达过去的<em class="nl">有效时间范围</em>和<code class="fe nh ni nj nk b">now()</code>的<em class="nl">事务时间</em>来写入过去。你可以拥有永恒不变的蛋糕，也可以吃掉它。</em></p><p id="80c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:假设订单(id=123)在数据库中标记为“2020-01-01完成”，但我们后来发现该订单实际上已经在2019年退款。对于SCD类型2表中的双时间建模，我们可以用以下方式表达这种情况:</p><pre class="kj kk kl km gt nq nk nr ns aw nt bi"><span id="70e2" class="nu lr it nk b gy nv nw l nx ny">| order_id | valid_from | transaction_time | order_state | <br/>|========================================================|<br/>| 123      | 2020-01-01 | 2020-01-01       | "completed" |<br/>| 123      | 2019-11-28 | 2021-09-07       | "refunded"  |</span></pre><p id="a13e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过这确实需要仔细读取数据，我们可能还需要在那里添加一个可变的<code class="fe nh ni nj nk b">valid_to</code>列(或者使用一个更好的方案或者一个为我们处理双临时的系统)。</p><h1 id="a19a" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">从理论到实践:乔要做什么？</h1><p id="9ae0" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">既然Joe不能及时回到过去并修复他的数据库模型，这就引出了一个问题，为什么我们总是首先制作丢失业务关键信息的CRUD表？他可以用我们上面描述的几种不同的选择来创建贸易公司，他可以很容易地从他的同事那里找到问题的答案。</p><p id="b4ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，根据我们目前所了解的一切，我们可以指导Joe采取他喜欢的解决方案，这样他至少可以从现在开始保存贸易公司的数据。无论是他当前PostgreSQL数据库中的事件源或SCD，还是具有CDC +成熟分析堆栈的更大项目，Joe的同事都可以在未来获得答案。</p><h2 id="2997" class="nu lr it bd ls nz oa dn lw ob oc dp ma ld od oe mc lh of og me ll oh oi mg oj bi translated">为什么我们不默认使用仅追加(双)时态数据存储？</h2><p id="d55f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">由于我们无法预测业务数据的所有未来用例，这就引出了一个问题，为什么我们不总是从不可变的、仅追加的、双时态的数据模型开始，这种模型不会丢失信息，从而支持大多数用例？如果性能是一个因素，那么我们总是可以在那些罕见的情况下选择退出这些功能。</p><p id="6f2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么流行的web框架止步于CRUD，而把其他的都变成了粘在上面的插件、第三方库或DIY的东西？为什么感觉像是“危险的，只有在万不得已的情况下才使用”的方法是标准的，也是每个入门教材所教授的？世界上有哪些企业不需要可审计性、可靠的财务报告、历史分析等？？为什么像WooCommerce这样的流行电子商务框架完全忽略了这些概念(他们的订单模型实际上只是一个CRUD表)？</p><p id="71d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，我们有很多方法来设计我们自己摆脱这种混乱……对于那些有兴趣购买摆脱这种混乱的方法的人来说，有很多有趣的发展正在发生。</p><h2 id="f9ef" class="nu lr it bd ls nz oa dn lw ob oc dp ma ld od oe mc lh of og me ll oh oi mg oj bi translated">数据库支持</h2><p id="87fc" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">虽然用户可以在大多数数据库上实现(双)时态建模，但我们开始在一些产品中看到原生支持。</p><ul class=""><li id="b54a" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp my mz na nb bi translated"><a class="ae nm" href="https://en.wikipedia.org/wiki/SQL:2011" rel="noopener ugc nofollow" target="_blank"> SQL:2011 </a>包含简单时态建模的基本原语，支持我的许多数据库，如MariaDB、PostgreSQL(扩展)、Oracle 12c、Microsoft SQL、IBM DB2、SAP HANA、CockroachDB</li><li id="b98c" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><a class="ae nm" href="https://www.datomic.com" rel="noopener ugc nofollow" target="_blank"> Datomic </a>提供了一个只附加的时态数据库，它也支持双时态建模</li><li id="fe50" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated"><a class="ae nm" href="https://xtdb.com/main/index.html" rel="noopener ugc nofollow" target="_blank"> XTDB </a>(以前:<a class="ae nm" href="https://opencrux.com" rel="noopener ugc nofollow" target="_blank"> Crux </a>)是一个新的时态数据库，支持双时态</li><li id="7413" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">像BigQuery、RedShift、Snowflake这样的数据仓库工具倾向于在仅追加逻辑上操作，这意味着行不应该被更新或删除(即使您可能能够这样做)。</li></ul><h1 id="bde2" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="b2b3" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">是时候让CRUD表寿终正寝了。也许他们有一些用例，但它们不应该成为通行的标准。是时候默认面向未来的解决方案，停止覆盖有价值的业务数据了。幸运的是，我们有很多工具可以使用，而这篇文章只是触及了皮毛。</p><blockquote class="ok"><p id="7556" class="ol om it bd on oo op oq or os ot lp dk translated">我会写更多关于这里提到的各种主题的文章，所以请点击“鼓掌并继续关注:)</p></blockquote></div></div>    
</body>
</html>