<html>
<head>
<title>Proxying HTTP and gRPC requests in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中代理HTTP和gRPC请求</h1>
<blockquote>原文：<a href="https://itnext.io/proxying-http-and-grpc-requests-in-go-a3201219a37d?source=collection_archive---------3-----------------------#2022-09-11">https://itnext.io/proxying-http-and-grpc-requests-in-go-a3201219a37d?source=collection_archive---------3-----------------------#2022-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/afda3899b06e4412f2db5b72e2df263b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*mf1bsyoq2RLbnCEHdyE2gQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">golang gopher吃爆米花</figcaption></figure><p id="4495" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://hostfactor.io/" rel="noopener ugc nofollow" target="_blank">主机因子</a>处，所有传入流量都通过我们的代理层，所有传出TCP流量都被重定向到我们的应用代理。捕获传出的TCP流量非常重要，因为我们所有的内部服务都使用HTTP或gRPC (HTTP/2 ),我们希望防止任何用户服务器与我们的内部服务进行通信。在做了一些调查之后，我们在Go中找不到任何可以在一个服务器中代理HTTP/1和HTTP/2请求的简单库，所以我们决定创建一个。</p><p id="1125" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个例子，让我们假设我们想要阻塞对<code class="fe kx ky kz la b">blocked.hostfactor.io</code>的所有请求</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="f8a9" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">TCP服务器</h1><p id="c02c" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">因为HTTP/1和HTTP/2都在幕后使用TCP，所以我们可以从那里开始。</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="b8bd" class="mt lj iq la b gy mu mv l mw mx">addr, _ := net.ResolveTCPAddr("tcp", ":8080")<br/><br/>list, err := net.ListenTCP("tcp", addr)<br/>if err != nil {<br/> return err<br/>}<br/><br/>go func() {<br/> for {<br/>  conn, err := list.Accept()<br/>  if err != nil {<br/>   if errors.Is(err, net.ErrClosed) || errors.Is(err, io.EOF) {<br/>    return<br/>   }<br/>   continue<br/>  }<br/><br/>  go handleConn(conn.(*net.TCPConn))<br/> }<br/>}()</span></pre><p id="1346" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们在端口8080上启动一个简单的TCP服务器，并将连接传递给<code class="fe kx ky kz la b">handleConn</code> func。将HTTP/1/2作为TCP处理的好处在于，我们可以让一台服务器监听一个端口来处理这两种情况。让我们深入了解一下<code class="fe kx ky kz la b">handleConn</code></p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="410a" class="mt lj iq la b gy mu mv l mw mx">func handleConn(conn *net.TCPConn) {<br/> defer func() {<br/>  _ = conn.Close()<br/> }()<br/><br/> buf := make([]byte, 4096)<br/> n, err := conn.Read(buf)<br/> if err != nil {<br/>  return<br/> }<br/><br/> payload := buf[:n]<br/> req, err := http.ReadRequest(bufio.NewReader(bytes.NewBuffer(payload)))<br/> if err != nil {<br/>  return<br/> }<br/>...</span><span id="6ffe" class="mt lj iq la b gy my mv l mw mx">}</span></pre><p id="03b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">http.ReadRequest</code>允许您将原始的<code class="fe kx ky kz la b">[]byte</code>转换成<code class="fe kx ky kz la b">*http.Request </code>，这允许我们解析有效载荷。</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="772e" class="mt lj iq la b gy mu mv l mw mx">if req.ProtoMajor &gt;= 2 {<br/> err = l.handleHttp2(bytes.NewBuffer(payload), conn)<br/>} else {<br/> err = l.handleHttpReq(req, conn)<br/>}</span></pre><p id="b6e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">req.ProtoMajor</code>允许我们区分请求是HTTP/2 (gRPC)还是HTTP/1</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="ca00" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">处理HTTP/1</h1><p id="fe57" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">HTTP/1是最熟悉的情况，在Go中得到最多的支持，所以我们从这里开始。首先，我们必须检查主机是否等于我们禁用的<code class="fe kx ky kz la b">blocked.hostfactor.io</code>主机</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="2d49" class="mt lj iq la b gy mu mv l mw mx">// Check the host of the request<br/>if req.Host == "banned.hostfactor.io" {<br/> resp.StatusCode = http.StatusNotFound<br/>}</span></pre><p id="ecc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还可以检查路径、方法、头等。检查通过后，我们代表原始请求者发送请求</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="0162" class="mt lj iq la b gy mu mv l mw mx">// Required to forward the request<br/>req.RequestURI = ""<br/>var err error<br/>resp, err = http.DefaultClient.Do(req)<br/>if err != nil {<br/> return err<br/>}</span></pre><p id="f9c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们编写对conn的响应。</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="16a1" class="mt lj iq la b gy mu mv l mw mx">return resp.Write(w)</span></pre><p id="5459" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，它看起来像这样</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="2555" class="mt lj iq la b gy mu mv l mw mx">func handleHttpReq(req *http.Request, w net.Conn) error {<br/> resp := &amp;http.Response{}<br/> // Check the host of the request<br/> if req.Host == "banned.hostfactor.io" {<br/>  resp.StatusCode = http.StatusNotFound<br/> } else {<br/>  // Required to forward the request<br/>  req.RequestURI = ""<br/>  var err error<br/>  resp, err = http.DefaultClient.Do(req)<br/>  if err != nil {<br/>   return err<br/>  }<br/> }<br/> return resp.Write(w)<br/>}</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="bc03" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">处理HTTP/2 (gRPC)</h1><p id="1c87" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">HTTP/2和HTTP/1非常不同。在HTTP/1中，最小的数据单位是一个请求，而在HTTP/2中，请求和响应的消息被分解成帧。HTTP/1也使用纯文本字符串，而HTTP/2使用二进制编码，这在处理原始TCP连接时会引起一些麻烦。</p><p id="b4bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Go <code class="fe kx ky kz la b">http</code>包没有对应于HTTP/2的<code class="fe kx ky kz la b">http.ReadRequest</code>函数。相反，我们可以利用<code class="fe kx ky kz la b">golang.org/x/net/http2</code>包解析出这些通过TCP连接传入的帧。</p><p id="c952" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先需要的是一个<code class="fe kx ky kz la b">Framer</code></p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="b1e4" class="mt lj iq la b gy mu mv l mw mx">f := http2.NewFramer(conn, conn)</span></pre><p id="50c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个参数是一个<code class="fe kx ky kz la b">io.Writer</code>，第二个是一个<code class="fe kx ky kz la b">io.Reader</code>。一个<code class="fe kx ky kz la b">net.Conn</code>实现了这两者，所以我们可以使用相同的TCP连接来读和写。</p><p id="d5e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">HTTP/2要求在接收到RFC 7540 中的初始帧时发送设置确认，所以让我们在连接断开之前完成这项工作</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="75d3" class="mt lj iq la b gy mu mv l mw mx">err := f.WriteSettingsAck()<br/>if err != nil {<br/> return err<br/>}</span></pre><p id="e04d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经建立了连接，我们可以利用<code class="fe kx ky kz la b">Framer</code>从连接中读取数据帧。完美！唯一的问题是,<code class="fe kx ky kz la b">Framer</code>消耗了来自TCP连接的<code class="fe kx ky kz la b">[]byte</code>,如果请求有效，我们需要转发它🤔。因此，如果<code class="fe kx ky kz la b">Framer</code>正在消耗字节，我们如何在不重新实现HTTP/2的情况下将数据转发到原始主机？</p><p id="4523" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是<code class="fe kx ky kz la b">io.TeeReader</code>前来救援的地方。我们只是将从连接中读取的所有字节复制到一个缓冲区中，并将它们分派给原始主机(如果请求有效)</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="5536" class="mt lj iq la b gy mu mv l mw mx">dataBuffer := bytes.NewBuffer(make([]byte, 0))<br/>reader := io.TeeReader(conn, dataBuffer)<br/>f = http2.NewFramer(io.Discard, reader)<br/>decoder := hpack.NewDecoder(1024, nil)</span></pre><p id="4417" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每当<code class="fe kx ky kz la b">Framer</code>从连接中读取时，字节也将被写入<code class="fe kx ky kz la b">dataBuffer</code>🎉</p><p id="b840" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来将使用<code class="fe kx ky kz la b">decoder</code>通过<code class="fe kx ky kz la b">golang.org/x/net/http2/hpack</code>包实际解码报头</p><p id="2302" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要从<code class="fe kx ky kz la b">Framer</code>读取帧，并检查<code class="fe kx ky kz la b">HeadersFrame</code>以查看原始主机(以及请求中我们关心的任何其他元数据)</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="b2b9" class="mt lj iq la b gy mu mv l mw mx">auth := ""<br/>for auth == "" {<br/> frame, err := f.ReadFrame()<br/> if err != nil {<br/>  return err<br/> }<br/><br/> switch t := frame.(type) {<br/> case *http2.HeadersFrame:<br/>  out, err := decoder.DecodeFull(t.HeaderBlockFragment())<br/>  if err != nil {<br/>   return err<br/>  }<br/><br/>  for _, v := range out {<br/>   if v.Name == ":authority" {<br/>    auth = v.Value<br/>   }<br/>  }<br/> }<br/>}</span></pre><p id="4e77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上循环遍历这些帧，直到我们找到保存了<code class="fe kx ky kz la b">:authority</code>的<code class="fe kx ky kz la b">HeadersFrame</code>(<a class="ae kw" href="https://www.rfc-editor.org/rfc/rfc7540#section-8.1.2.3" rel="noopener ugc nofollow" target="_blank">相当于主机</a>的HTTP/1)。一旦找到，我们就停止读取帧。</p><p id="3f64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">酷！现在，我们已经通读了HTTP/2帧，并且知道要检查它是否有效的原始主机</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="946d" class="mt lj iq la b gy mu mv l mw mx">if auth == "blocked.hostfactor.io" {<br/>  return nil<br/>}</span></pre><p id="4836" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果<code class="fe kx ky kz la b">:authority</code>有效呢？我们如何将从<code class="fe kx ky kz la b">Framer</code>读取的所有数据发送到原始主机？首先，我们需要一个到原始主机的新TCP连接</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="b7cf" class="mt lj iq la b gy mu mv l mw mx">dialer, err := net.Dial("tcp", auth)<br/>if err != nil {<br/> return err<br/>}</span></pre><p id="8e1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，由于我们为客户机使用了一个原始的TCP连接，我们将不得不处理来自该连接的读和写。让我们从阅读方面开始</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="39f2" class="mt lj iq la b gy mu mv l mw mx">// The WaitGroup ensures that every byte is read before exiting<br/>wg := sync.WaitGroup{}<br/>wg.Add(1)<br/>dataSent := int64(0)<br/>go func() {<br/> // Copy any data we receive from the host into the original connection<br/> dataSent, err = io.Copy(conn, dialer)<br/> wg.Done()<br/>}()</span></pre><p id="95cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以处理对原始主机的写入</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="b0be" class="mt lj iq la b gy mu mv l mw mx">_, err = io.Copy(dialer, io.MultiReader(initial, dataBuffer, conn))<br/>wg.Wait()</span></pre><p id="9262" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">initial</code>是从请求方读取的初始字节，<code class="fe kx ky kz la b">dataBuffer</code>是我们从连接中读取以检查帧的字节，<code class="fe kx ky kz la b">conn</code>是原始字节。一个<code class="fe kx ky kz la b">MultiReader</code>简单地将所有这些链接在一起，这样它们就可以按顺序读取并发送给原始主机。这保证了我们到目前为止读取的所有数据都将被发送到原始主机。将所有这些放在一起看起来像</p><pre class="ml mm mn mo gt mp la mq mr aw ms bi"><span id="49a7" class="mt lj iq la b gy mu mv l mw mx">func handleHttp2(initial io.Reader, conn net.Conn) error {<br/> defer func() {<br/>   _ = conn.Close()<br/> }()<br/> dataBuffer := bytes.NewBuffer(make([]byte, 0))<br/> reader := io.TeeReader(conn, dataBuffer)<br/> f := http2.NewFramer(conn, conn)<br/> err := f.WriteSettingsAck()<br/> if err != nil {<br/>  return err<br/> }<br/><br/> f = http2.NewFramer(io.Discard, reader)<br/> decoder := hpack.NewDecoder(1024, nil)<br/><br/> auth := ""<br/> for auth == "" {<br/>  frame, err := f.ReadFrame()<br/>  if err != nil {<br/>   return err<br/>  }<br/><br/>  switch t := frame.(type) {<br/>  case *http2.HeadersFrame:<br/>   out, err := decoder.DecodeFull(t.HeaderBlockFragment())<br/>   if err != nil {<br/>    return err<br/>   }<br/><br/>   for _, v := range out {<br/>    if v.Name == ":authority" {<br/>     auth = v.Value<br/>    }<br/>   }<br/>  }<br/> }<br/><br/> if auth == "blocked.hostfactor.io" {<br/>  return nil<br/> }<br/><br/> dialer, err := net.Dial("tcp", auth)<br/> if err != nil {<br/>  return err<br/> }<br/><br/> _ = dialer.SetReadDeadline(time.Now().Add(5 * time.Second))<br/><br/> wg := sync.WaitGroup{}<br/> wg.Add(1)<br/> dataSent := int64(0)<br/> go func() {<br/>  // Copy any data we receive from the host into the original connection<br/>  dataSent, err = io.Copy(conn, dialer)<br/>  wg.Done()<br/> }()<br/><br/> _, err = io.Copy(dialer, io.MultiReader(initial, dataBuffer, conn))<br/> wg.Wait()<br/><br/> if errors.Is(err, os.ErrDeadlineExceeded) &amp;&amp; dataSent &gt; 0 {<br/>  return nil<br/> }<br/> return err<br/>}</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="ffa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你知道了！能够阻止任何通过HTTP/1或HTTP/2接收的流量的代理服务器。</p><p id="f454" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在<a class="ae kw" href="https://hostfactor.io/" rel="noopener ugc nofollow" target="_blank"> Host Factor </a>利用大量Go和其他几项现代技术来确保我们的客户拥有托管其应用程序的最佳体验。请检查一下！</p></div></div>    
</body>
</html>