<html>
<head>
<title>Understanding Kubernetes Maven Plugin resource fragments configuration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Kubernetes Maven插件资源片段配置</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-kubernetes-maven-plugin-resource-fragments-configuration-32b1d1e757a1?source=collection_archive---------1-----------------------#2021-06-19">https://itnext.io/understanding-kubernetes-maven-plugin-resource-fragments-configuration-32b1d1e757a1?source=collection_archive---------1-----------------------#2021-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/47d070768d1a77f5505555855fcc3df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*VPk4GCUqHoQwIQ_v5bqWCw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://github.com/eclipse/jkube" rel="noopener ugc nofollow" target="_blank">月食JKube </a></figcaption></figure><p id="889e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在我之前的<a class="ae jy" rel="noopener ugc nofollow" target="_blank" href="/understanding-kubernetes-maven-plugins-image-xml-configuration-e98ef633e231">博客文章</a>中，我谈到了Eclipse JKube Kubernetes Maven插件XML配置，以及如何使用它来配置Eclipse JKube的输出图像/清单。今天，在这篇博客中，我们将关注Eclipse JKube <a class="ae jy" href="https://www.eclipse.org/jkube/docs/kubernetes-maven-plugin#_resource_fragments" rel="noopener ugc nofollow" target="_blank">资源片段</a>:一个特定于Kubernetes清单(JSON/YAML)的配置选项。</p><h1 id="ce01" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是资源碎片？</h1><p id="2c8e" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">在Eclipse JKube术语中，资源片段是完整/部分的JSON/YAML片段，用户将它们放在这个项目的<code class="fe ma mb mc md b">src/main/jkube</code>目录中，以便根据自己的需要调整JKube固执己见的清单生成机制。这种用法通常适用于对Kubernetes基本类型有一定了解的用户。</p><p id="b6e6" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">假设一个用户想要向他的部署添加一个额外的环境变量。她也可以通过XML配置来完成，但是假设她在项目的<code class="fe ma mb mc md b">src/main/jkube</code>目录中添加了一个<code class="fe ma mb mc md b">deployment.yml</code>文件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="50de" class="mm ky iq md b gy mn mo l mp mq"><strong class="md ir">spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - env:<br/>            - name</strong>: FOO<br/>              <strong class="md ir">value</strong>: BAR</span></pre><p id="53d7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这个用户照常运行<code class="fe ma mb mc md b">mvn k8s:resource</code>目标后，可以在<code class="fe ma mb mc md b">target/classes/META-INF/jkube/kubernetes</code>文件夹中看到生成的清单。最终生成的清单将是Eclipse JKube固执己见的默认值和用户的YAML片段的合并输出:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/0385d42397f2ad00e6c6b8af224271d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBIJI_zAWTr5sqh306htpw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">用户提供的片段和最终由JKube生成的部署清单之间的差异</figcaption></figure><p id="6e62" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">正如你在截图中看到的，Eclipse JKube通过检查项目依赖关系添加了它自己的固执己见的标签、注释、名称(默认为<code class="fe ma mb mc md b">project.artifactId</code>)、容器。您还会注意到，用户指定的附加环境变量也保留在最终生成的YAML清单中。因此，通过指定完整YAML清单的一个片段，我们就可以调优JKube，这就是为什么这些片段被称为资源片段。</p><h1 id="9b81" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用资源片段:</h1><p id="89c8" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">为了使用资源片段配置选项，您需要在<code class="fe ma mb mc md b">src/main/jkube</code>中提供一个部分YAML文件，其中包含您想要在JKube的固执己见的清单中覆盖的内容。文件名取决于您试图配置的Kubernetes资源。例如，如果它是一个<code class="fe ma mb mc md b">Deployment</code>，你将添加一个<code class="fe ma mb mc md b">deployment.yml</code>文件；如果<code class="fe ma mb mc md b">Service</code>，你会添加一个<code class="fe ma mb mc md b">service.yaml</code>文件。您可以在Kubernetes Maven插件的文档中找到完整的类型到文件名的映射:</p><div class="mw mx gp gr my mz"><a href="https://www.eclipse.org/jkube/docs/kubernetes-maven-plugin#_kindfilename_type_mapping" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">org.eclipse.jkube/kubernetes-maven-plugin</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">5.2.5.构建配置有两种不同的模式来构建图像:内嵌插件配置和</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">www.eclipse.org</p></div></div></div></a></div><p id="9c87" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">下面是一个在<code class="fe ma mb mc md b">src/main/jkube</code>目录中指定片段的例子:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e3db" class="mm ky iq md b gy mn mo l mp mq">eclipse-jkube-sample-with-resource-fragments : $ tree src/main/jkube/<br/>src/main/jkube/<br/>├── configmap.yml<br/>├── deployment.yml<br/>├── sa.yml<br/>├── second-configmap.yaml<br/>└── service.yml</span><span id="5e11" class="mm ky iq md b gy ni mo l mp mq">0 directories, 6 files</span></pre><p id="23cb" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">正如你在这里看到的，我已经提供了定义<code class="fe ma mb mc md b">ConfigMap, Deployment</code>、<code class="fe ma mb mc md b">ServiceAccount</code>和<code class="fe ma mb mc md b">Service</code>的文件。您可以在下面的代码片段中看到所有这些文件的内容:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5f4b" class="mm ky iq md b gy mn mo l mp mq"><strong class="md ir">$</strong> cat src/main/jkube/configmap.yml <br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  creationTimestamp: 2017-12-27T18:36:28Z<br/>  name: game-config-env-file<br/>data:<br/>  allowed: '"true"'<br/>  enemies: aliens<br/>  lives: "3"</span><span id="77be" class="mm ky iq md b gy ni mo l mp mq"><strong class="md ir">$</strong> cat src/main/jkube/deployment.yml <br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - env:<br/>            - name: FOO<br/>              value: BAR</span><span id="f716" class="mm ky iq md b gy ni mo l mp mq"><strong class="md ir">$</strong> cat src/main/jkube/sa.yml <br/>metadata:<br/>  name: ribbon</span><span id="b534" class="mm ky iq md b gy ni mo l mp mq"><strong class="md ir">$ </strong>cat src/main/jkube/second-configmap.yaml  <br/>application.properties: |<br/>   spring.profiles.active=dev</span><span id="0af6" class="mm ky iq md b gy ni mo l mp mq"><strong class="md ir">$</strong> cat src/main/jkube/service.yml <br/>spec:<br/>  type: LoadBalancer<br/>  ports:<br/>    - name: http<br/>      port: 8080</span></pre><p id="2bc8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">请注意，在<code class="fe ma mb mc md b">configmap.yml</code>的一个案例中，我已经提供了完整的YAML货单。在其他情况下，我只是指定了次要的YAML清单，具体到我希望覆盖的关于JKube默认值的清单。您可以使用Kubernetes Maven插件来生成清单:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="f940" class="mm ky iq md b gy mn mo l mp mq">$ mvn k8s:resource<br/>[INFO] Scanning for projects...<br/>[INFO] <br/>[INFO] ---org.eclipse.jkube.quickstarts.maven:external-resources&gt;--<br/>[INFO] Building Eclipse JKube :: Quickstarts :: Maven :: External Resources 1.4.0-SNAPSHOT<br/>[INFO] --------------------------------[ jar ]---------------<br/>[INFO] <br/>[INFO] --- kubernetes-maven-plugin:1.4.0-SNAPSHOT:resource (default-cli) @ external-resources ---<br/>[INFO] k8s: Running generator spring-boot<br/>[INFO] k8s: spring-boot: Using Docker image quay.io/jkube/jkube-java-binary-s2i:0.0.9 as base / builder<br/>[INFO] k8s: Using resource templates from /home/rokumar/work/repos/jkube-testing/eclipse-jkube-sample-with-resource-fragments/src/main/jkube<br/>[INFO] k8s: jkube-healthcheck-spring-boot: Adding readiness probe on port 8080, path='/health', scheme='HTTP', with initial delay 10 seconds<br/>[INFO] k8s: jkube-healthcheck-spring-boot: Adding liveness probe on port 8080, path='/health', scheme='HTTP', with initial delay 180 seconds<br/>[INFO] k8s: jkube-service-discovery: Using first mentioned service port '8080' <br/>[INFO] k8s: jkube-revision-history: Adding revision history limit to 2</span><span id="b0ed" class="mm ky iq md b gy ni mo l mp mq">...</span><span id="0e70" class="mm ky iq md b gy ni mo l mp mq">[INFO] --------------------------------------------------<br/>[INFO] BUILD SUCCESS<br/>[INFO] ---------------------------------------------------<br/>[INFO] Total time:  3.705 s<br/>[INFO] Finished at: 2021-06-12T23:12:38+05:30<br/>[INFO] ---------------------------------------------------</span></pre><p id="4fde" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">您可以在JKube的输出目录中检查生成的清单，看看JKube是如何将您的片段与其固执己见的缺省值合并在一起的。您会注意到生成的Kubernetes资源遵循<code class="fe ma mb mc md b">${RESOURCE-NAME}-${KIND}</code>作为文件命名策略:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a407" class="mm ky iq md b gy mn mo l mp mq"><strong class="md ir">$ </strong>ls target/classes/META-INF/jkube/kubernetes -l<br/>total 32<br/>-rw-rw-r--. 1 rokumar rokumar 2438 Jun 12 23:12 external-resources-deployment.yml<br/>-rw-rw-r--. 1 rokumar rokumar  294 Jun 12 21:21 external-resources-ingress.yml<br/>-rw-rw-r--. 1 rokumar rokumar  860 Jun 12 23:12 external-resources-service.yml<br/>-rw-rw-r--. 1 rokumar rokumar  306 Jun 12 23:12 game-config-env-file-configmap.yml<br/>-rw-rw-r--. 1 rokumar rokumar  198 Jun 11 21:44 ribbon-1-serviceaccount.yml<br/>-rw-rw-r--. 1 rokumar rokumar  198 Jun 12 23:12 ribbon-serviceaccount.yml<br/>-rw-rw-r--. 1 rokumar rokumar  258 Jun 12 23:12 second-configmap.yml</span><span id="782d" class="mm ky iq md b gy ni mo l mp mq">$ cat target/classes/META-INF/jkube/kubernetes/external-resources-service.yml <br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  annotations:<br/>    prometheus.io/path: /metrics<br/>    jkube.io/git-branch: master<br/>    prometheus.io/port: "9779"<br/>    jkube.io/scm-url: <a class="ae jy" href="https://github.com/spring-projects/spring-boot/spring-boot-starter-parent/external-resources" rel="noopener ugc nofollow" target="_blank">https://github.com/spring-projects/spring-boot/spring-boot-starter-parent/external-resources</a><br/>    prometheus.io/scrape: "true"<br/>    jkube.io/git-url: <a class="ae jy" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:r0haaaan/eclipse-jkube-sample-with-resource-fragments.git<br/>    jkube.io/scm-tag: HEAD<br/>    jkube.io/git-commit: 1baf9f6f08ae8a1397a6e00fea62e75bfb659718<br/>  labels:<br/>    expose: "true"<br/>    app: external-resources<br/>    provider: jkube<br/>    version: 1.4.0-SNAPSHOT<br/>    group: org.eclipse.jkube.quickstarts.maven<br/>  name: external-resources<br/>spec:<br/>  ports:<br/>  - name: http<br/>    port: 8080<br/>    protocol: TCP<br/>  selector:<br/>    app: external-resources<br/>    provider: jkube<br/>    group: org.eclipse.jkube.quickstarts.maven<br/>  type: LoadBalancer</span></pre><h1 id="7df7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用原始资源片段:</h1><p id="c881" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated"><code class="fe ma mb mc md b">src/main/jkube</code>中提供的YAML片段是由Eclipse jbu be处理的，这意味着Eclipse jbu be会修改它们，并向您的输入片段添加一些自以为是的增强。Eclipse JKube有这个概念，即<a class="ae jy" href="https://www.eclipse.org/jkube/docs/kubernetes-maven-plugin#enrichers" rel="noopener ugc nofollow" target="_blank"> enrichers </a>(一组包含Kubernetes清单的小型配置逻辑的类)，它们利用<a class="ae jy" href="https://en.wikipedia.org/wiki/Visitor_pattern" rel="noopener ugc nofollow" target="_blank">访问者模式</a>来逐个“丰富”您的Kubernetes清单。</p><p id="d6aa" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">但是，当用户不希望jbue干扰其资源YAMLs，而只是希望将其与应用程序相关的清单一起部署时，就像做<code class="fe ma mb mc md b">kubectl apply -f /path/to/manifest.yml</code>一样，该怎么办呢？嗯，JKube也处理这个。您可以将这些YAML清单放在<code class="fe ma mb mc md b">src/main/jkube/raw</code>目录中:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="6a42" class="mm ky iq md b gy mn mo l mp mq"><strong class="md ir">$</strong> tree src/main/jkube/<br/>src/main/jkube/<br/>├── deployment.yml<br/>└── raw<br/>    ├── postgres-configmap.yml<br/>    ├── postgres-deployment.yml<br/>    └── postgres-service.yml</span><span id="9806" class="mm ky iq md b gy ni mo l mp mq">1 directory, 4 files</span></pre><p id="3469" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在上面的例子中，<code class="fe ma mb mc md b">raw/</code>目录中提供的所有YAML清单都将在应用阶段被Eclipse JKube应用。Eclipse JKube不会像处理放在<code class="fe ma mb mc md b">src/main/jkube</code>目录中的YAML清单那样添加任何额外的标签/注释。</p><h1 id="0dc2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">示例:使用Eclipse JKube将Postgres上的Spring Boot部署到Kubernetes</h1><p id="8f69" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">为了更好地理解片段，让我们举一个使用Postgres数据库的spring-boot应用程序的简单例子。为了将它部署到Kubernetes，我们还需要确保Postgres作为一个pod在Kubernetes集群中运行。在本例中，我们将使用原始资源片段设置postgres，并将Postgres的部署、服务和配置映射放在<code class="fe ma mb mc md b">src/main/jkube/raw</code>目录中:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="3800" class="mm ky iq md b gy mn mo l mp mq"><strong class="md ir">spring-boot-hibernate-crud-demo : $</strong> ls src/main/jkube/raw/ -l<br/>total 12<br/>rokumar 192 Jun 19 19:37 postgres-configmap.yml<br/>rokumar 479 Jun 19 19:26 postgres-deployment.yml<br/>rokumar 161 Jun 19 19:26 postgres-service.yml</span></pre><p id="4bfd" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><code class="fe ma mb mc md b">postgres-deployment.yml</code>将包含<code class="fe ma mb mc md b">Deployment</code>，用于控制波斯特格雷豆荚。<code class="fe ma mb mc md b">postgres-service.yml</code>会暴露这个部署。<code class="fe ma mb mc md b">postgres-configmap.yml</code>将包含像用户名，密码等凭证。请注意，该部署没有使用任何卷来保存数据，因为它只是用于演示目的。</p><p id="38ac" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">除了<code class="fe ma mb mc md b">raw/</code>目录中的这三份YAML清单。在<code class="fe ma mb mc md b">src/main/jkube</code>中我们有一个额外的<code class="fe ma mb mc md b">deployment.yml</code>，在这里我们定制了由Eclipse JKube生成的<code class="fe ma mb mc md b">Deployment</code>，以包含一些从<code class="fe ma mb mc md b">postgres-config</code> ConfigMap中读取的额外环境变量:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="8152" class="mm ky iq md b gy mn mo l mp mq"><strong class="md ir">spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - env:<br/>            - name:</strong> POSTGRESQL_USER<br/>   <strong class="md ir">           valueFrom:<br/>                configMapKeyRef:<br/>                  name:</strong> postgres-config<br/>                  key: POSTGRESQL_USER<br/>            - <strong class="md ir">name:</strong> POSTGRESQL_PASSWORD<br/><strong class="md ir">              valueFrom:<br/>                configMapKeyRef:<br/>                  name:</strong> postgres-config<br/>                  <strong class="md ir">key:</strong> POSTGRESQL_PASSWORD<br/>            - <strong class="md ir">name:</strong> POSTGRESQL_DATABASE<br/>              <strong class="md ir">valueFrom:<br/>                configMapKeyRef:<br/>                  name:</strong> postgres-config<br/>                  <strong class="md ir">key:</strong> POSTGRESQL_DATABASE</span></pre><p id="0b2a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们将修改我们的Spring Boot <code class="fe ma mb mc md b">application.yml</code>以从这些环境变量中读取数据库名称、用户名和密码:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="551e" class="mm ky iq md b gy mn mo l mp mq"><strong class="md ir">spring.datasource.url</strong>=jdbc:postgresql://${POSTGRES_SERVICE_HOST}:5432/${POSTGRESQL_DATABASE}?createDatabaseIfNotExist=true<br/><strong class="md ir">spring.datasource.username</strong>=${POSTGRESQL_USER}<br/><strong class="md ir">spring.datasource.password</strong>=${POSTGRESQL_PASSWORD}</span></pre><p id="edd1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">一旦一切都配置好了，您就可以将您的应用程序部署到Kubernetes了。我在本地用minikube集群测试了这一点，并遵循了以下命令:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a9a1" class="mm ky iq md b gy mn mo l mp mq"># Start minikube<br/>$ minikube start<br/></span><span id="9c65" class="mm ky iq md b gy ni mo l mp mq"># To point your shell to minikube's docker-daemon<br/>$ eval $(minikube -p minikube docker-env)<br/></span><span id="71ef" class="mm ky iq md b gy ni mo l mp mq"># Run Eclipse JKube build, resource, apply goals<br/>$ mvn package k8s:build k8s:resource k8s:apply</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nj"><img src="../Images/7e97edd5308ed6c79f5c0c630572f6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*efSvm-PoDA53R01NJBgbKg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">使用Eclipse JKube将Postgres应用程序上的Spring Boot部署到Kubernetes</figcaption></figure><p id="4bc3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">构建完成后检查应用程序窗格:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5f61" class="mm ky iq md b gy mn mo l mp mq">spring-boot-hibernate-crud-demo : $ kubectl get pods<br/>NAME                              READY   STATUS    RESTARTS   AGE<br/>postgres-cf987cb96-svvz4          1/1     Running   0          3m7s<br/>spring-boot-hibernate-crud-demo-5fc5697bf5-vvzwc   1/1     Running   1          3m7s<br/></span></pre><p id="cca0" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">一旦pods处于<code class="fe ma mb mc md b">Running</code>状态，尝试检查应用程序服务，我已经配置了Eclipse JKube来生成<code class="fe ma mb mc md b">NodePort</code>服务。我可以这样访问它:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="9b31" class="mm ky iq md b gy mn mo l mp mq">minikube service list</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nk"><img src="../Images/f30e78eeba060dfbb4a790b50278d5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krEKMv8GPIjY3jDNq7sX8Q.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">minikube服务列表</figcaption></figure><p id="05b3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在一个窗口中检查应用程序日志，并尝试通过一些api测试工具访问应用程序:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2327" class="mm ky iq md b gy mn mo l mp mq">kubectl logs pod/spring-boot-hibernate-crud-demo-5fc5697bf5-vvzwc -f</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nl"><img src="../Images/851706da21ee52532bed470721a9b7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7d0WpNiOjR3w62aXXJ01ig.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">在kubernetes中检查应用程序是否运行正常</figcaption></figure><p id="948a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">一旦一切按预期运行，您可以使用取消部署目标取消部署一切:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="6aa9" class="mm ky iq md b gy mn mo l mp mq">mvn k8s:undeploy</span></pre><h1 id="39d7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论:</h1><p id="476e" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">在这篇博客中，您了解了我们如何将原始的YAML清单(完整的或部分的)与Eclipse JKube一起使用，以便定制Kubernetes清单。这在XML配置可能不提供完整配置支持的各种情况下非常有用。你可以在Github仓库找到今天博客中使用的代码:</p><div class="mw mx gp gr my mz"><a href="https://github.com/r0haaaan/jkube-spring-boot-hibernate-crud-demo" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">r0haaaan/jkube-spring-boot-hibernate-crud-demo</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">这是一个演示Spring Boot项目，展示了如何使用Eclipse JKube来部署Spring Boot应用程序…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr js mz"/></div></div></a></div><p id="4c3c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">你可以在Kubernetes Maven插件文档中读到更多关于它的内容。如果您有任何问题，请随时通过我们的<a class="ae jy" href="https://gitter.im/eclipse/jkube" rel="noopener ugc nofollow" target="_blank"> Gitter频道</a>或通过<a class="ae jy" href="https://github.com/eclipse/jkube" rel="noopener ugc nofollow" target="_blank"> Github </a>联系我们。</p></div></div>    
</body>
</html>