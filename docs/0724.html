<html>
<head>
<title>Module Oriented Architecture — Part 1: Coupling and Decoupling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向模块的体系结构第1部分:耦合与解耦</h1>
<blockquote>原文：<a href="https://itnext.io/module-oriented-architecture-part-1-coupling-and-decoupling-4443dd7f598a?source=collection_archive---------6-----------------------#2018-05-15">https://itnext.io/module-oriented-architecture-part-1-coupling-and-decoupling-4443dd7f598a?source=collection_archive---------6-----------------------#2018-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="07b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的应用程序通常被分成更多的功能单元。我们试图遵循良好的软件工程实践，使我们的代码尽可能健壮和可维护。方法有很多，怎么做。本系列将讨论<strong class="jp ir"> <em class="kl">面向模块的架构</em> </strong>，它将功能分解成对象组，我们称之为<strong class="jp ir">模块</strong>。不要把这误认为是某种技术中特定表示的特定描述。术语“<strong class="jp ir">模块</strong>在这里是以非常一般的意义使用的。</p><p id="efcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本系列的下一部分将在<em class="kl"> Swift </em>中提供代码实现。它非常通用，所以对任何开发人员来说都不应该是一本难读的书，但对iOS开发人员来说肯定是最简单的。然而，该原理广泛适用于任何客户端本地技术。</p><h1 id="8fb1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">固体？</h1><p id="9d4d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">嗯，是的。不管开发范例和形式如何，我们坚持并遵守OOP的一些基本原则，我们尽可能地遵循这些原则来创建尽可能接近技术和组织目标的代码。哪些是这样的目标？我至少会想到下面这些:</p><p id="328d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">易于:</p><ul class=""><li id="b7bc" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">阅读</li><li id="220a" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">明白；理解</li><li id="a4d1" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">维持</li><li id="ba6a" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">调试</li><li id="0584" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">试验</li><li id="b888" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">变化</li><li id="a948" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">互换零件</li><li id="7ebf" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">添加不同的场景</li><li id="1ab2" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">扩展现有功能</li><li id="60b7" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">添加新功能</li></ul><p id="9164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">天哪，如今一切都需要变得简单..是我们懒还是怎么的？不，实际上，这都是关于<strong class="jp ir">让我们的业务在代码生命周期和生命周期</strong>中高效运行。</p><p id="a474" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单一责任原则可能是使用和滥用最多的原则之一。在一定程度上达到上述大部分目标是最重要的原则。然而，就其本身而言，它有一些限制，阻止我们从更好的代码进步到伟大的代码。</p><p id="5076" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的对立面是整体代码，旧的定义认为它比碎片化、低耦合更有效，但只有当我们观察执行速度时才会出现这种情况，执行速度正在成为应用程序开发和交付的最不重要的方面，所以我不会花任何时间来推理任何事情，我认为这幅图对我们所有人来说都是很清楚的。</p><h1 id="fc08" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">从耦合到松耦合，最后到解耦</h1><p id="dafb" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">遵循单一责任原则<strong class="jp ir">只有</strong>会将我们的代码(以一种积极的方式)分割成单独的，比如说，模块，类，甚至函数，这肯定会使我们的代码更容易:</p><ul class=""><li id="9475" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">阅读</li><li id="5f8d" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">明白；理解</li><li id="9754" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">维持</li><li id="d62b" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">调试</li></ul><p id="f9de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但有时不那么容易:</p><ul class=""><li id="1366" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">试验</li><li id="762c" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">变化</li></ul><p id="5e78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">绝对不容易做到:</p><ul class=""><li id="4fd5" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">互换零件</li><li id="7721" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">添加不同的场景</li><li id="7d1b" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">扩展现有功能</li><li id="d464" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">添加新功能</li></ul><h1 id="4f7e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">联系的</h1><p id="3694" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">功能分布在几个类中，但类型被明确引用</em> </strong></p><p id="a8c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">肯定不容易测试，因为它可能证明有些类型不容易创建模拟。尽管如此，就测试而言，这并不重要，仍然是可以管理的。只要更改包含在一个类中，它们仍然是可管理的。一旦我们想改变整个类型，我们就会陷入麻烦，因为我们必须改变引用它们的其他类的代码。如果我们想要添加不同的场景，我们将不得不求助于if-else和switch语句，类型检查，标志检查，所有讨厌的东西…</p><h1 id="ccdd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">松散耦合</h1><p id="4059" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">类通过接口/协议</em> </strong>连接</p><p id="111c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这或多或少解决了上述所有问题。我们当然可以轻松地模仿，我们可以通过接口将实际的实现注入到调用对象中，从而用策略模式实现不同的场景，应用抽象工厂……所有OOP的好处。</p><p id="0672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们解决所有的问题…在同一个平台/应用/系统中。</p><h1 id="76c7" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">（使两事物）分离</h1><p id="1585" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><strong class="jp ir"/></p><p id="e21c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的好例子有<strong class="jp ir"> HTTP，REST，微服务</strong>。不同的是，我们不再谈论单一系统，我们谈论分布式系统，就使用的技术而言是异构的，实际上，技术不再重要，它只是关于<strong class="jp ir"> <em class="kl">消息和定义其有效负载的约定，它是一个词汇，字典，被许多方面认可。</em>T15】</strong></p><p id="a167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧。但是这与应用程序和客户端架构有什么关系呢？嗯，确实是这样。你们中的大多数人已经在应用程序中实现了深度链接，你可以看到，一个基于惯例形成的URL请求是如何被解构的，并被用来激活和调用它所需要的功能/类，从而基本上在你的电子邮件或网页和你的应用程序中的类之间建立了单向连接，这实际上成为了URL资源。很神奇，不是吗？！:)</p><h1 id="7f45" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">统一资源定位器</h1><p id="d58b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">名字说明了一切:它是资源的通用地址。添加HTTP/REST，您就有了在资源之间异步传递请求和响应的约定。如果可以用它来建立不同系统之间的联系，为什么不把它作为同一个系统内部的解耦原则呢？</p><p id="ad8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在本系列的下一篇文章中读到这一点，在那里我们将使用我们在这里谈到的一切，并创建模块作为解耦架构的表示。</p><div class="md me gp gr mf mg"><a href="https://medium.com/p/2437e6a292e7" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">面向模块的体系结构.第2部分:路由和模块</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">我想在不同的层面上有很多方法，但我想开始将关注点分开是有意义的…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">medium.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu mv mg"/></div></div></a></div></div></div>    
</body>
</html>