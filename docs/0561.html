<html>
<head>
<title>How To Master Advanced React Design Patterns — Compound Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何掌握高级React设计模式——复合组件</h1>
<blockquote>原文：<a href="https://itnext.io/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-1-dd495fa1823?source=collection_archive---------0-----------------------#2018-04-02">https://itnext.io/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-1-dd495fa1823?source=collection_archive---------0-----------------------#2018-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/585ce2a891a5f48b1066aa4c98f5572d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEUqmeeTKf6dPqvvA0n_YA.png"/></div></div></figure><p id="506b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了庆祝React 16.3的正式发布，我决定分享一些我最近使用的技术，这些技术彻底改变了我创建React组件的方法。使用这些技术，我能够设计出完全可重用的组件，并且能够在许多不同的环境中灵活地使用这些组件。</p><p id="de8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-2-react-3c5662b997ab">点击这里查看本系列的第2部分:上下文API </a></p><p id="9bd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-3-render-d7517dfe72bc">点击这里查看本系列第三部分:渲染道具</a></p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="29b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的沙箱代表了一个整洁的stepper组件的初始代码，我将用它来展示其中的一些技术。就目前的情况来看，这个组件工作得非常好，并且完全按照设计来做，但是没有灵活性。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">步进组件需要一个道具，即开始阶段。</figcaption></figure><p id="87b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，“踏步机”组件的灵活性止于舞台道具；我们只能把舞台换到它开始的地方。</p><p id="136f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我需要将进度块放在右边怎么办？</p><p id="4e8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我需要一个有额外阶段的类似踏步机呢？</p><p id="91fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我需要更改阶段的内容，该怎么办？</p><p id="bac7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我想改变阶段的顺序呢？</p><p id="e2cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照现在的情况，我能实现这些改变的唯一方法是完全重写组件。以同样的方式重写会产生类似的结果。但是，如果将来还需要更多的修改，那么就需要重新编写组件。因此，让我们尝试一种不同的方法，重新连接组件，使其具有灵活性和可重用性，以便在任何未来的配置中使用。</p><p id="c5a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的第一部分中，我们将讨论一种叫做“复合组件”的设计模式</p><h1 id="497a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用复合组件设计模式</h1><p id="eb3f" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">首先，让我们看看“步进器”组件。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="b30c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“Stepper”组件基本上是一个组件，它包含一个存储当前stage的state对象、一个增加stage属性值的方法和一个返回包含两个子组件的div的render方法。</p><p id="f584" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，我们明确地将“进度”和“步骤”组件直接放在“步进器”组件中。为了减少这种静态方法，我们可以使用props对象来动态注入子组件。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/925c42df1507c3c8edacebff0fd34cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9qWcyCa_j9DRnITVN5Uwg.png"/></div></div></figure><p id="ff56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这种替代方法，我们可以使用Stepper.js文件中的props.children对象，并将“Progress”和“Steps”组件放在“Stepper”组件中。</p><p id="a011" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅仅这个简单的改变就能给我们带来立竿见影的效果。我们现在可以选择先渲染树中的哪个组件；我们可以选择进度块在左侧还是右侧。</p><p id="0584" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，这种方法有一个主要问题。“进度”和“步骤”组件不再能够访问“舞台”和“handleClick”道具。为了让每个子组件得到它们需要的道具，我们需要手动遍历每个子组件，并将道具注入其中。我们可以使用react API提供的许多助手方法来实现这一点。两个选项包括:- Children.map()和cloneElement()。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="82b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Children.map()类似于Array.map()方法。之所以需要它，是因为children.props有一个不透明的数据结构，使得Array.map()方法不适合这个用例。</p><p id="89de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顾名思义，cloneElement克隆传递给它的子组件。最关键的是，它还附带了注入额外道具的额外能力。嘣！</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="c871" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以将“进度”和“阶段”作为孩子添加到“步进器”组件中，一切都和以前一样。这一次我们可以决定每个组件的位置，或者如果我们想真正疯狂，我们可以在两侧都有一个进度块。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><h1 id="0b81" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">静态属性</h1><p id="cc52" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">另一个提高可读性和易用性的酷技术是使用类的静态属性。这允许我们直接在类上调用方法。</p><p id="4d8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这到底是什么意思？让我们看一看…</p><p id="7a9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要在Stepper组件中创建静态方法，并将它们分配给“Progress”和“Steps”组件:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="430f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在，我们可以直接从Stepper组件调用它们，而不是在许多地方导入Progress和Steps组件:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="0e22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经开始生成一个简单的、可读的、有点灵活的API。为什么不对“进度”组件使用一些相同的技术呢？让我们来看看它…</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="f46e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会注意到，它的刚性非常类似于我们之前看到的步进组件。让我们用更动态的children.props对象替换4个Stage组件，遍历添加所需道具的子对象，然后添加一个静态方法，这样就可以直接从Stepper类调用它。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="3f3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，我们可以根据需要在任意位置动态添加任意数量的舞台组件:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="eec0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以用Steps组件做同样的事情，尽管这个有点棘手，因为每个孩子都需要包装在一个<a class="ae kw" href="https://reactcommunity.org/react-transition-group/" rel="noopener ugc nofollow" target="_blank"> React的转换组</a>转换组件中。需要应用相同的循环技术，但是只有当stage prop与组件的num prop匹配时，组件才可见。如果有匹配，它被包装在一个转换组件中(ReactTransitionGroup文档解释了这样做的目的)并呈现在屏幕上。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="722e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在Stepper.js组件上添加相关的静态方法，我们可以按照我们想要的任何顺序添加任意数量的Step组件。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="1e5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创造了一种更加灵活和可重用的组件。我们现在可以选择有多少个阶段，每个阶段将进入什么文本，每个阶段的顺序，以及我们希望进度条在左边还是右边。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="0c1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，我们在灵活性方面仍然受到限制！如果我们想在Steps块的上方添加一个标题块会怎么样？</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ld lc l"/></div></figure><p id="54e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将破坏我们作为“步进器”的应用程序。“Steps”组件不再是“Stepper”组件的直接子组件，并且不能访问舞台道具。</p><p id="7f2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是为什么React 16.3的发布是一件大事！到目前为止，React的上下文API还处于试验阶段，但现在它已经正式发布了！</p><p id="5d25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的第2部分中，我将讨论我们如何实现context API，以便能够在树中的任何位置传递props，而不管Stepper在哪里。步骤”组件的位置，它将始终能够访问舞台道具。</p><p id="91ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://medium.com/@shaundavidhutch/using-advanced-design-patterns-to-create-flexible-and-reusable-react-components-part-2-react-3c5662b997ab" rel="noopener">点击此处查看本系列第二部分</a> <a class="ae kw" href="http://Click here to view part 2 in this series" rel="noopener ugc nofollow" target="_blank">:上下文API </a></p></div></div>    
</body>
</html>