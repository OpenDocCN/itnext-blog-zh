<html>
<head>
<title>Getting started with Celery and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">芹菜和Python入门</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-celery-and-python-3c5fb2425aa8?source=collection_archive---------3-----------------------#2022-02-07">https://itnext.io/getting-started-with-celery-and-python-3c5fb2425aa8?source=collection_archive---------3-----------------------#2022-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/42925d05c3ac43e4caa0204d86e15132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FVqEcPa8PSR9j25v.png"/></div></div></figure><p id="7e47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将谈论芹菜，它是什么，以及如何使用它。</p><h1 id="55a1" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">芹菜是什么</h1><p id="a319" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">来自官方<a class="ae lz" href="https://docs..org/en/stable/" rel="noopener ugc nofollow" target="_blank">网站</a>:</p><blockquote class="ma mb mc"><p id="b8a5" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">Celery是一个简单、灵活、可靠的分布式系统，用于处理大量的消息，同时提供维护这样一个系统所需的工具。</p></blockquote><p id="0013" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://en.wikipedia.org/wiki/Celery_(software)" rel="noopener ugc nofollow" target="_blank">维基百科</a>说:</p><blockquote class="ma mb mc"><p id="01fc" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">Celery是基于分布式消息传递的开源<strong class="ka ir">异步</strong>任务队列或作业队列。虽然它支持调度，但它的重点是实时操作。</p></blockquote><p id="2cae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，Celery非常适合处理可能被延迟且不需要实时交互的异步或长时间运行的任务。它还可以用于运行计划任务。任务<em class="md">是一段执行特定操作的代码。</em></p><h1 id="26c3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">芹菜用例</h1><p id="ee2e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">芹菜可能有许多用例，下面给出了其中一些:</p><ul class=""><li id="60e9" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated"><strong class="ka ir">发送邮件:- </strong>你可以把发送邮件的任务交给芹菜，并向用户显示一个<em class="md">感谢</em>页面，而不是让用户在填写注册表单后等待。你可能会说，它不需要时间来执行电子邮件发送代码，但如果电子邮件服务器没有响应，如果你让这部分同步，你的网站访问者将不得不等待，直到超时发生。</li><li id="92a8" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><strong class="ka ir">图片/其他文件上传及相关信息:- </strong>现在通过网页上传图片或其他类型的文档非常普遍。假设您想要提供一个工具来上传包含产品图片的产品信息。您还想根据自己的要求调整图像的大小，并用您的品牌名称对它们进行水印处理。用户在所有这些操作过程中等待看起来并不好。他想要的只是看到他的过程已经完成的文本，然后继续前进。你可以创建多个芹菜<em class="md">任务</em>来实现你的目标。</li><li id="5a03" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><strong class="ka ir">预定任务:- </strong> Celery还可以充当调度程序，可以用来执行周期性任务。</li></ul><h1 id="66e9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">芹菜概念</h1><p id="265d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">芹菜的基本架构如下所示:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/88be3aa39171a0fcc512b3b6aa5effdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/0*6I9gaFu9FcPc-3uY.png"/></div></figure><ul class=""><li id="46b1" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated"><strong class="ka ir">生产者:- </strong>这个应用程序负责推送消息与所有需要的信息。</li><li id="0ccc" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><strong class="ka ir"> Broker:- </strong>这个模块实际上是作为一个消息队列，像Redis或者RabbitMQ这样的应用程序可以在这里使用。</li><li id="5d5b" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><strong class="ka ir">Task</strong>:-Task是一个Python函数或任务，在序列化之后在代理中排队。然后，任务函数由负责反序列化并执行它的工作人员挑选。默认的序列化格式是JSON，你可以把它改成<code class="fe na nb nc nd b">msgpack</code>、YAML或者pickle。</li><li id="da89" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><strong class="ka ir">后端:- </strong>这个组件负责存储函数产生的结果</li></ul><h1 id="5382" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">开发设置</h1><p id="9e3a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用pip安装芹菜:</p><p id="01eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc nd b">pip install celery</code></p><p id="8bb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也需要一个经纪人，所以我用的是Redis的docker版本。</p><p id="a082" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc nd b">docker run -d -p 6379:6379 redis</code></p><p id="7820" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经安装了芹菜，Redis已经启动，让我们写一些代码。</p><p id="bd60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所述，每个逻辑单元/功能被称为一个<em class="md">任务。我正在编写一个将两个数相加并返回结果的函数。</em></p><pre class="mw mx my mz gt ne nd nf ng aw nh bi"><span id="3d3d" class="ni kx iq nd b gy nj nk l nl nm">from celery import Celery<br/><br/>BROKER_URL = 'redis://localhost:6379/0'<br/>BACKEND_URL = 'redis://localhost:6379/1'<br/>app = Celery('tasks', broker=BROKER_URL, backend=BACKEND_URL, )<br/><br/><br/>@app.task(name='Add two numbers')<br/>def add(x, y):<br/>    return x + y</span></pre><p id="82be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“任务”已经定义，是时候运行它了。函数<code class="fe na nb nc nd b">add</code>将在Redis中排队，它将在<code class="fe na nb nc nd b">delay()</code>函数的帮助下调用<code class="fe na nb nc nd b">apply_async()</code>函数，后者将序列化该函数以供进一步处理。现在是时候结束了。在<code class="fe na nb nc nd b">main.py</code>我会这样写:</p><pre class="mw mx my mz gt ne nd nf ng aw nh bi"><span id="fc8c" class="ni kx iq nd b gy nj nk l nl nm">from tasks import add<br/>result = add.delay(66, 4)<br/>print(result.id)</span></pre><p id="1c08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我提到的,<code class="fe na nb nc nd b">delay</code>实际上是将函数发送到队列中进行后续处理。它接受与原始函数相同的参数。</p><p id="bbc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc nd b">tasks.py</code>包含主逻辑和配置。<code class="fe na nb nc nd b">BACKEND_URL</code>和<code class="fe na nb nc nd b">BROKER_URL</code>包含存储相关信息的数据库的路径。任务装饰器负责将一个简单的函数转换成一个任务。您可以设置属性的<em class="md">名称</em>来为您的任务命名。</p><p id="c8be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们运行<code class="fe na nb nc nd b">main.py</code>来对任务进行排队。当我运行时，它会产生如下结果:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/f248f5ef2d4677f6c2c564c8522af728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LsVXz88j-h5iogO8.png"/></div></div></figure><p id="b7b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，它返回了一个任务id。在Redis端，它存储如下内容:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/1365f47338dc80366464f125b4dc53ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XHzo02qlgcOjOfq7.png"/></div></div></figure><p id="8167" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，任务ID和其他信息在这里都是可见的。为了更清楚起见，JSON数据也张贴在下面。</p><pre class="mw mx my mz gt ne nd nf ng aw nh bi"><span id="a89a" class="ni kx iq nd b gy nj nk l nl nm">["{\"body\": \"W1s2NiwgNF0sIHt9LCB7ImNhbGxiYWNrcyI6IG51bGwsICJlcnJiYWNrcyI6IG51bGwsICJjaGFpbiI6IG51bGwsICJjaG9yZCI6IG51bGx9XQ==\", \"content-encoding\": \"utf-8\", \"content-type\": \"application/json\", \"headers\": {\"lang\": \"py\", \"task\": \"Add two numbers\", \"id\": \"9f7f6727-ca61-4ec0-8098-99f56e7f2c02\", \"shadow\": null, \"eta\": null, \"expires\": null, \"group\": null, \"group_index\": null, \"retries\": 0, \"timelimit\": [null, null], \"root_id\": \"9f7f6727-ca61-4ec0-8098-99f56e7f2c02\", \"parent_id\": null, \"argsrepr\": \"(66, 4)\", \"kwargsrepr\": \"{}\", \"origin\": \"gen38551@adnans-mbp.home\", \"ignore_result\": false}, \"properties\": {\"correlation_id\": \"9f7f6727-ca61-4ec0-8098-99f56e7f2c02\", \"reply_to\": \"d4346397-09f4-37e4-9edd-0875769b6698\", \"delivery_mode\": 2, \"delivery_info\": {\"exchange\": \"\", \"routing_key\": \"celery\"}, \"priority\": 0, \"body_encoding\": \"base64\", \"delivery_tag\": \"d4987020-1d26-4566-9d77-f78c95fdec93\"}}"]</span></pre><p id="ed6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以看到<code class="fe na nb nc nd b">body</code>的值是base64。如果我解码<code class="fe na nb nc nd b">W1s2NiwgNF0sIHt9LCB7ImNhbGxiYWNrcyI6IG51bGwsICJlcnJiYWNrcyI6IG51bGwsICJjaGFpbiI6IG51bGwsICJjaG9yZCI6IG51bGx9XQ==</code>,它会给出以下输出:</p><p id="04c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc nd b">[[66, 4], {}, {"callbacks": null, "errbacks": null, "chain": null, "chord": null}]</code></p><p id="2fd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意值为66和4的列表。这些是您在函数中传递的参数。其他信息如任务名称、语言等也可以在上面的JSON中看到。</p><p id="d59f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，到目前为止，你所做的是，你把数据放入了被序列化的队列中。它还没有被消耗，为此你需要启动工人。您可以像下面这样调用工人:</p><p id="b00f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc nd b">celery -A tasks worker --loglevel=INFO</code></p><p id="84c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc nd b">-A</code>切换应用名称，此处为<code class="fe na nb nc nd b">tassks</code>。这个名字本身来自于任务文件的名字<code class="fe na nb nc nd b">tasks.py</code>。然后您告诉我们您想要调用一个带有日志级别的worker。但是等等，在我运行这个命令之前，让我运行芹菜工人命令，而不传递工人名称</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/b036c98c3366d52e5100e22e707bd767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TWqzEI9BSiwXMq1Z.png"/></div></div></figure><p id="0856" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，celery worker尝试连接默认值失败。另外，<code class="fe na nb nc nd b">[tasks]</code>部分是空的。现在，让我们运行正确的命令</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/85a449dcc55d4bb4490b36da8ab22e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cgg6WF_skRtTykYr.png"/></div></div></figure><p id="faa4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意代理、后端和任务名称的URL。现在你明白为什么需要传递应用程序名了。</p><p id="c587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以注意到任务<strong class="ka ir">添加了两个数字</strong>以及首先<em class="md">接收到</em>然后成功执行的任务id。注意图中的<strong class="ka ir"> 70 </strong>是<strong class="ka ir"> 66 </strong>和<strong class="ka ir"> 4的总和。</strong>因此，没有必要立即处理被推入队列的任务。</p><p id="57d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们也使用后端，任务执行的结果存储如下:</p><pre class="mw mx my mz gt ne nd nf ng aw nh bi"><span id="a763" class="ni kx iq nd b gy nj nk l nl nm">{ "status": "SUCCESS", "result": 70, "traceback": null, "children": [ ], "date_done": "2022-02-07T11:37:50.312117", "task_id": "9f7f6727-ca61-4ec0-8098-99f56e7f2c02" }</span></pre><h1 id="a74e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="a3ae" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">芹菜对可以推迟的任务很有帮助。其灵活的架构使其适用于多种用途。我刚刚讨论了它的基本用法。如果您正在寻找其他用途，您可以遵循这些文档。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="faa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="md">原载于2022年2月7日</em><a class="ae lz" href="http://blog.adnansiddiqi.me/getting-started-with-celery-and-python/" rel="noopener ugc nofollow" target="_blank"><em class="md">http://blog . adnansiddiqi . me</em></a><em class="md">。</em></p></div></div>    
</body>
</html>