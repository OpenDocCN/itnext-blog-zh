<html>
<head>
<title>Answering “What time is it?”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回答“现在几点了？”</h1>
<blockquote>原文：<a href="https://itnext.io/answering-what-time-is-it-8769105d65e0?source=collection_archive---------0-----------------------#2022-06-23">https://itnext.io/answering-what-time-is-it-8769105d65e0?source=collection_archive---------0-----------------------#2022-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f5ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">时间是人类长久以来试图获取的核心信息之一。在不同的年龄，出于不同的原因，记录时间是很重要的。随着软件为人类解决现实世界的问题，时间的概念&amp;测量时间的时钟也进入了计算机。这是我们在日常生活中以及在开发软件时认为理所当然的信息。作为一个好奇的人，我想了解计算机是如何记录时间的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/adec72de2db6a393af1506fed6695f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqasEVs-UWRESfr1HKsdGw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">日晷照片由<a class="ae lb" href="https://unsplash.com/@tcdinger?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">提莫·丁格尔</a>在<a class="ae lb" href="https://unsplash.com/s/photos/sundial?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="19dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管我们在Go中开始了这一旅程，但我们将需要穿透不同层次的抽象，如库、操作系统层和硬件。随着我们在堆栈中的位置越来越低，事情将变得更加异构，因为不同的操作系统和硬件以不同的形式公开这些功能。像Go这样的高级编程语言在隐藏这些方面做得很好，我认为这是它们存在的部分原因。由于您阅读这篇文章的时间有限，而我准备这篇文章的时间也有限，所以我们需要从中挑选一篇，并通过抽象层的一个特定分支。为此，我将尝试留下指针，这样如果您对其他分支感兴趣，您就可以跟踪它们。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="6a2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从一个非常简单的东西开始:一个打印当前时间的程序。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="d8aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行此输出:<code class="fe ll lm ln lo b">2022–06–20T22:14:04.907366Z</code>。</p><p id="474d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来很简单！</p><p id="0766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ll lm ln lo b">time.Now</code>返回一个<code class="fe ll lm ln lo b"><a class="ae lb" href="https://pkg.go.dev/time#Time" rel="noopener ugc nofollow" target="_blank">time.Time</a></code>对象，代表它被调用时的时间。</p><blockquote class="lp lq lr"><p id="8a20" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">时间以纳秒的精度表示时间中的瞬间。</p></blockquote><p id="4662" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请花一点时间想想一纳秒有多小。每秒钟有十亿纳秒。</p><p id="cbfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe ll lm ln lo b">time</code>包文档中还有另一条信息:</p><blockquote class="lp lq lr"><p id="c0d7" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">操作系统提供了“挂钟”和“单调时钟”，前者会随着时钟同步而变化，后者则不会。总的规则是，挂钟是用来报时的，单调钟是用来计时的。而不是拆分API，在这个包中时间按时间返回。现在包含挂钟读数和单调时钟读数；后来的计时操作使用挂钟读数，但后来的时间测量操作，特别是比较和减法，使用单调的时钟读数。</p></blockquote><p id="fb97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，既然我们对“告诉时间”更感兴趣，“挂钟”似乎是与我们相关的部分。然而，这个解释提供了一些有用的背景知识。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="4a8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们接下来会研究<code class="fe ll lm ln lo b">time.Now</code>。</p><p id="523b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ll lm ln lo b">time.Now</code>被定义为Go标准库的一部分，在这里<a class="ae lb" href="https://github.com/golang/go/blob/530511bacccdea0bb8a0fec644887c2613535c50/src/time/time.go#L1089-L1097" rel="noopener ugc nofollow" target="_blank">被定义为</a>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">见原文来源<a class="ae lb" href="https://github.com/golang/go/blob/530511bacccdea0bb8a0fec644887c2613535c50/src/time/time.go#L1088-L1097" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><p id="90c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住文档中的上述部分，其中一部分与“报时”——挂钟有关，另一部分用于“测量时间”——单调时钟。对我来说，这给我的感觉是，<code class="fe ll lm ln lo b">now</code>是与读取挂钟值相关的部分，其余部分与单调时钟以及<code class="fe ll lm ln lo b">Time</code>数据结构如何在内部存储这两个概念相关。通读数据结构中的注释还可以验证:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">见原文来源<a class="ae lb" href="https://github.com/golang/go/blob/530511bacccdea0bb8a0fec644887c2613535c50/src/time/time.go#L129-L150" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><p id="6d42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么，接下来我们将研究从<code class="fe ll lm ln lo b">time.Now</code>调用的<code class="fe ll lm ln lo b">now</code>。这就是我们在<code class="fe ll lm ln lo b">time.go</code>中看到的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">见原文来源<a class="ae lb" href="https://github.com/golang/go/blob/530511bacccdea0bb8a0fec644887c2613535c50/src/time/time.go#L1072-L1073" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><p id="caee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要更深入地研究go标准库。</p><p id="30ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe ll lm ln lo b">runtime</code>包中，这个函数有多种定义。有些(比如<a class="ae lb" href="https://github.com/golang/go/blob/f229e7031a6efb2f23241b5da000c3b3203081d6/src/runtime/timestub.go" rel="noopener ugc nofollow" target="_blank">这个</a>)是用Go写的(虽然在别的地方也可能指汇编写的零件)有些(比如<a class="ae lb" href="https://github.com/golang/go/blob/f229e7031a6efb2f23241b5da000c3b3203081d6/src/runtime/time_linux_amd64.s" rel="noopener ugc nofollow" target="_blank">这个</a>)是用汇编写的。这是一种在Go源代码中广泛使用的模式。我想这与语义相关的片段放在一起有关。</p><p id="bb99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">寻找合适的实施方案</strong></p><p id="1dc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免跑题，我不会在本文中涉及太多细节，但是对于不同的构建目标有不同的<code class="fe ll lm ln lo b">now</code>实现。</p><p id="c101" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先要知道的是，使用我们在编译期间针对的操作系统和架构的文件有一个命名约定:</p><blockquote class="lp lq lr"><p id="1ff4" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">如果去掉扩展名和可能的_test后缀后，文件名与以下任何模式匹配:</p><p id="5433" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">* _ GOOS<br/>* _ go arch<br/>* _ GOOS _ go arch</p><p id="be19" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">(示例:source_windows_amd64.go)其中GOOS和GOARCH分别表示任何已知的操作系统和体系结构值，则该文件被视为具有需要这些术语的隐式构建约束(除了文件中的任何显式约束之外)。</p></blockquote><p id="4174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与这些匹配的文件被认为满足隐式约束。此外，还有明确的约束。</p><p id="ec7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您查看上面链接的那些实现，它们都有一行包含类似于<code class="fe ll lm ln lo b">//go:build !faketime &amp;&amp; !windows &amp;&amp; !(linux &amp;&amp; amd64)</code>的内容。如果满足这些约束，Go编译器将使用有问题的源代码进行编译。例如，如果我们的目标是Windows，这个约束将不会被满足，而对于<code class="fe ll lm ln lo b">darwin</code>(或苹果设备)，它将被满足。你可以在Go <a class="ae lb" href="https://pkg.go.dev/cmd/go#hdr-Build_constraints" rel="noopener ugc nofollow" target="_blank">这里</a>找到更多关于构建约束的信息。</p><p id="5202" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">找到匹配后，Go编译器在这里使用的另一个构造是<code class="fe ll lm ln lo b">go:linkname</code>指令。它告诉编译器使用一个特定的局部符号，该符号在其他地方被另一个名字引用。你也可以在这里找到更多关于它的<a class="ae lb" href="https://pkg.go.dev/cmd/compile#hdr-Compiler_Directives" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b1dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，由于我们将根据构建目标跟踪不同的源代码，我们将需要假设一个。我决定跟随Linux arm64架构的实现，这将我们带到了<code class="fe ll lm ln lo b">time</code>中提到的<a class="ae lb" href="https://github.com/golang/go/blob/f229e7031a6efb2f23241b5da000c3b3203081d6/src/runtime/time_linux_amd64.s" rel="noopener ugc nofollow" target="_blank">一个</a>T3的汇编实现。</p><p id="1b49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ll lm ln lo b"><strong class="jp ir">time.now</strong></code> <strong class="jp ir">针对Linux arm64 </strong></p><p id="2d38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先是一个简短的免责声明:我必须提到我对汇编语言不是很熟悉。我研究过它，除了出于好奇四处打探之外，仅此而已。我可以阅读大多数基本代码，但我不能说我有太多的经验。如果你注意到任何不准确的地方，通过评论让我知道，我会纠正它。</p><p id="a890" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将参考<a class="ae lb" href="https://go.dev/doc/asm" rel="noopener ugc nofollow" target="_blank">围棋汇编指南</a>来导航这个。</p><p id="f107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">纵观<a class="ae lb" href="https://github.com/golang/go/blob/f229e7031a6efb2f23241b5da000c3b3203081d6/src/runtime/time_linux_amd64.s" rel="noopener ugc nofollow" target="_blank">的实现</a>，我看到3个主要部分:</p><ul class=""><li id="82ed" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">为调用其他函数做好准备，比如<code class="fe ll lm ln lo b">runtime·vdsoClockgettimeSym</code>，我们将在后面讨论</li><li id="8c80" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">尝试调用<code class="fe ll lm ln lo b">runtime·vdsoClockgettimeSym</code>读取实时&amp;单调时钟</li><li id="f8b3" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">如果<a class="ae lb" href="https://man7.org/linux/man-pages/man7/vdso.7.html" rel="noopener ugc nofollow" target="_blank"> vDSO </a>调用没有返回任何有用的东西——意味着它们不可用，使用syscall <code class="fe ll lm ln lo b">clock_gettime</code>作为后备</li></ul><p id="9d26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么是vDSO？</strong></p><p id="bb67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数操作系统的运行方式分为两种操作模式:内核(或特权)模式和用户模式。这也是为了限制对关键资源的访问，并在进程之间建立隔离。某些事情只能通过询问操作系统内核来完成。这些被称为系统调用或系统调用。当一个用户空间进程调用一个系统调用时，它实际上将控制权交给内核，并等待直到结果准备好。这会导致上下文在用户模式和内核模式之间来回切换，这会影响性能。</p><p id="b62b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这正是虚拟动态共享对象的用武之地。对于诸如挂钟之类的资源，由于该信息不是秘密并且旨在被共享，所以有时内核在用户空间中维护结果的表示，从而不需要在更快的操作模式之间切换。</p><p id="ef30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们在上面的<code class="fe ll lm ln lo b">time.now</code>实现中看到的。它试图通过vDSO检索时间信息，如果这不可用，它将使用常规的syscall。</p><p id="0f9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些vDSOs的存储位置取决于系统和架构。然而，简而言之，该进程知道用户存储器空间中的地址，该地址对应于列出不同对象的查找表。然后，用户进程可以使用查找表并读取信息，而无需任何上下文切换。</p><p id="7987" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">vDSO手册页对此进行了如下解释:</p><blockquote class="lp lq lr"><p id="eb1d" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir">寻找vDSO<br/></strong>vDSO的基址(如果存在的话)由<br/>内核通过AT_SYSINFO_EHDR标签传递给初始辅助向量中的每个程序(参见<br/> getauxval(3))。</p><p id="7efe" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">您不能假设vDSO映射在用户内存映射中的任何特定位置<br/>。每次创建一个新的进程映像<br/>(在execve(2)时间)，基址通常会在运行时被<br/>随机化。这样做是出于安全原因，为了<br/>防止“返回libc”攻击。</p></blockquote><p id="5101" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Go代码中，我们可以看到<a class="ae lb" href="https://github.com/golang/go/blob/8542bd8938efc8bb1bc681f4a0603c9f392e70b0/src/runtime/vdso_linux.go#L268" rel="noopener ugc nofollow" target="_blank">一个用于Linux的初始化代码</a>收集可用的vDSO条目，它是平台相关的(参见<a class="ae lb" href="https://github.com/golang/go/blob/2ebe77a2fda1ee9ff6fd9a3e08933ad1ebaea039/src/runtime/vdso_linux_arm64.go#L16" rel="noopener ugc nofollow" target="_blank"> this </a> for arm64)。该代码在Go程序启动时使用，并保存vDSO条目的位置，以备以后需要。</p><p id="c5eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">回落到</strong>T0】</p><p id="b85f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了明确起见，正如我们前面所讨论的，时间信息在用户空间中并不总是可用的。在这种情况下，系统调用<code class="fe ll lm ln lo b"><a class="ae lb" href="https://linux.die.net/man/3/clock_gettime" rel="noopener ugc nofollow" target="_blank">clock_gettime</a></code>读取不同类型的时钟。</p><p id="7789" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Brendan Gregg有一篇有趣的文章，关于使用vDSOs与使用syscalls相比有多大的不同。你可以在这里找到<a class="ae lb" href="https://www.brendangregg.com/blog/2021-09-26/the-speed-of-time.html" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="0e91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，我们已经到达了内核。在Linux源代码中，我们应该走两条路:</p><ol class=""><li id="fabf" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mk mc md me bi translated">了解<code class="fe ll lm ln lo b">clock_gettime</code>是如何实现的</li><li id="4b7e" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mc md me bi translated">如何建立和维护vDSOs</li></ol><p id="ae29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，一台单独的计算机本身并不知道&amp;也不记录时间。还有另一组进程来同步计算机之间的时间，称为<a class="ae lb" href="https://en.wikipedia.org/wiki/Network_Time_Protocol" rel="noopener ugc nofollow" target="_blank"> NTP </a>。</p><p id="8b9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个要研究的层面也许是这如何与我们的软件运行的硬件一起运作。</p><p id="cbde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我计划在以后的文章中讨论这些主要部分，并把它总结一下。关注或订阅标签。</p></div></div>    
</body>
</html>