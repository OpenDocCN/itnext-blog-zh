<html>
<head>
<title>Using Dependency Inversion in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中使用依赖倒置</h1>
<blockquote>原文：<a href="https://itnext.io/using-dependency-inversion-in-go-31d8bf9b3760?source=collection_archive---------1-----------------------#2020-09-07">https://itnext.io/using-dependency-inversion-in-go-31d8bf9b3760?source=collection_archive---------1-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="f0fd" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是依赖倒置？</h1><p id="6230" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">依赖倒置是指高级逻辑不应该依赖于它的低级实现。我们应用程序中的业务逻辑不应该关心我们是从一个AWS桶还是Google云存储中获取数据；我们应该能够在不中断程序的情况下轻松地交换这些实现。这使得我们的代码在变化面前保持稳定。我们还可以通过将这些依赖关系换成更容易测试的实现来使我们的应用程序可测试。</p><p id="9fbd" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">这在围棋中是怎么做到的？</strong></p><p id="2b76" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在Go中，接口使我们能够使用依赖倒置。我们能够在代码中使用不同的实现，只要它们满足我们定义的接口。我们使用依赖注入来告诉应用程序使用哪个实现。</p><h1 id="1230" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">工作示例</h1><p id="aada" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了演示这在Go中是如何工作的，我们将构建一个报价API，为我们的用户提供随机报价。下面是我们当前提供Kanye West报价的Go handler的截图。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/41ed0d0d28443259359dae8596cec594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgAucWP7UVO9RdH0G6MOWw.png"/></div></div></figure><p id="ec18" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这个处理程序很好地为用户提供了Kanye West的引用；这是您第一次在Go中编写HTTP处理程序时可能会想到的。它对提供报价的<a class="ae md" href="https://api.kanye.rest" rel="noopener ugc nofollow" target="_blank"><strong class="kq iu">https://API . kanye . rest</strong></a>进行HTTP调用并检查响应是否有效。当您调用处理程序时，您将收到一个带有引号的响应:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi me"><img src="../Images/b9d3b1fceddc36735fc5913f08399410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKKo-2uUdLddM5UoGrOZCg.png"/></div></div></figure><p id="94c4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然而，我们想开始测试处理程序，但目前没有办法不进行实际的HTTP调用。我们也没有办法测试当我们的依赖返回错误响应时会发生什么。这就是我们可以开始使用依赖倒置的地方。</p><p id="33ae" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们首先需要创建一个接口，这将定义我们的依赖行为。通过这样做，我们以后将能够在不同的实现中交换，只要它们共享相同的行为。这是我们的界面:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mf"><img src="../Images/57f895f8df9154f1301b487d8fae4b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLH5RXBnJhfWPFOJIHrj6g.png"/></div></div></figure><p id="1e29" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">任何具有名为“Get”的方法的结构都将满足客户端接口，该方法将字符串作为参数，并返回一个指针，该指针指向带有错误的来自net/http包的响应类型。这是我们感兴趣的行为。</p><p id="e746" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，我们需要一种方法将依赖注入到处理程序中，使它与我们选择使用的客户端接口的实现无关。Go中依赖注入的方法有很多。我将在下面概述几个:</p><h2 id="f7c6" class="mg jr it bd js mh mi dn jw mj mk dp ka kz ml mm ke ld mn mo ki lh mp mq km mr bi translated"><strong class="ak">高阶函数</strong></h2><p id="dc9e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以创建一个返回原始处理函数的高阶函数。这很方便，因为你只需要调用你需要使用的高阶函数，我们也不需要创建一个处理程序结构。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi ms"><img src="../Images/fb29136c905216c7b1fe139813e9d137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJxuaFUMtWh0zvN5qfATQQ.png"/></div></div></figure><p id="56a2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后，通过调用高阶函数，从主函数中注入我们的HTTP依赖项。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mt"><img src="../Images/b39c0c2cfba78dfa56a380ec6023162c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oflM2zjPXrVK96KZqt3ZTw.png"/></div></div></figure><h2 id="71c7" class="mg jr it bd js mh mi dn jw mj mk dp ka kz ml mm ke ld mn mo ki lh mp mq km mr bi translated"><strong class="ak">构造器</strong></h2><p id="44f6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以创建一个“handlers”结构，它有一个构造函数，我们在其中提供客户端实现。handlers结构有一个名为client的字段，我们的实现就存储在这个字段中。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mu"><img src="../Images/be3901cb4841c406170057915fa122d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8Ujrpdz00_0sLY607wJOQ.png"/></div></div></figure><p id="37a5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">通过使Kanye函数成为一个<strong class="kq iu"> handlers </strong> receiver方法，我们可以访问客户端字段。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mv"><img src="../Images/a0131bbc7e9443f36cac9bc6779d13cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZDZ4bd6LHeENi0i4HfqbQ.png"/></div></div></figure><p id="e97a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后，我们通过构造具有正确依赖关系的处理程序结构，从主函数注入HTTP客户机。</p><p id="46b9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这种方法的一个缺点是，当大量使用时，它会使您在主文件中构造大量的结构。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mw"><img src="../Images/8ecbc4652df1c80d2fe6ae18577d2d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ElicGJGSrTcYb1qw-T4vg.png"/></div></div></figure><h2 id="737c" class="mg jr it bd js mh mi dn jw mj mk dp ka kz ml mm ke ld mn mo ki lh mp mq km mr bi translated"><strong class="ak">使用选项</strong></h2><p id="7f9a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一种方法是使用我们的<strong class="kq iu">处理程序</strong>构造函数中的选项。在这种方法中，我们设置一个默认的实现来使用，除非用户给出一个替代方案作为选项。<strong class="kq iu">处理程序</strong>构造函数将是一个变量函数，因此可以给它选项，也可以不给。在下面的例子中，我们用CustomClient 导出了一个高阶选项函数<strong class="kq iu">，使用户可以方便地使用另一个客户端实现。</strong></p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mx"><img src="../Images/3f641f78128d4ea927e85c84cbf5a715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X4xvrvpXuOyupZsDLjBTPw.png"/></div></div></figure><p id="c02e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">使用构造函数，我们现在可以使用默认的实现(http。DefaultClient)，方法是不带任何参数调用<strong class="kq iu"> NewHandlers </strong>:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi my"><img src="../Images/b6475ee1d23fbd00bc5e3a4d35ef802a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUeJrLgQ75xjF1LeqK3guw.png"/></div></div></figure><p id="772f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">或者我们可以使用自定义客户端选项调用它，以使用非默认的:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mz"><img src="../Images/3bf4fb22da86a0fa6a5517fdcaa05de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K8MX2W-UZ4x-IjyCZMibZg.png"/></div></div></figure><p id="ea2b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">使用这种方法，当您想要使用默认实现时，您不需要自己构建这些实现，这样可以使您的主文件不那么复杂。</p><h1 id="0b3d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">测试实现</h1><p id="6fd6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们已经介绍了不同的依赖注入方法，我们将创建一个在测试中使用的客户端接口的实现。从这里开始，我们将使用高阶函数来注入依赖性。</p><p id="2a71" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">此时，我们可以自己编写一个test double，或者使用GoMock生成一个实现，允许我们通过存根来控制它的行为。对于这个例子，我们将使用GoMock。</p><p id="4606" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">通过将下面的代码行添加到我们的代码库，我们可以从客户端界面自动生成一个test double。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi na"><img src="../Images/ab11b1a14b664cac97e2374a9ad44a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DIwljA_8sRrYxQOQB5xbw.png"/></div></div></figure><p id="3c9a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">通过运行<strong class="kq iu"> go生成。/… </strong>我们生成以下代码:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nb"><img src="../Images/cf08fc1c75c2a58a60b966bc7be2265e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qf_GF3VzHjH-ZMQLS0ncwg.png"/></div></div></figure><p id="3309" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这是我们可以在测试中使用的客户端的实现。我们可以注入这个，而不是默认的HTTP客户端，并模拟对Kanye API进行真正的HTTP Get调用的行为。我们现在能够在不进行HTTP调用的情况下编写测试，并测试当我们得到不好的响应时会发生什么。</p><p id="9aaa" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">下面是我们现在可以编写的测试用例类型的一个例子。该测试使用银杏，一个行为驱动的开发测试框架。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nc"><img src="../Images/ae3bc49828b58334ad7fcb1fdbcc8d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rg_FMZGs6nQn_ZZVmrln4Q.png"/></div></div></figure><p id="29f6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">测试用例存根模拟客户端实现。我们检查它是用正确的URL字符串调用的，并告诉它返回我们的HTTP响应而不出错。我们可以检查发送给用户的HTTP状态代码和报价是否与我们预期的一样。</p><h1 id="8fd4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="ea30" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们已经介绍了如何使用依赖反转来改变我们的处理程序，以便它可以用于任何客户端实现。这种技术可以应用于任何类型的依赖关系。</p><p id="9393" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">依赖倒置是一个强大的工具，随着功能的增加，它可以创建更加稳定和健壮的程序。我们可以创建模拟依赖关系的测试，通过依赖概念而不是实现，我们减少了业务逻辑的变化量。</p><p id="7426" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果你想阅读更多关于依赖倒置的内容，我强烈推荐罗伯特·C·马丁的《干净的架构》。<a class="ae md" href="https://www.goodreads.com/book/show/18043011-clean-architecture" rel="noopener ugc nofollow" target="_blank">https://www . goodreads . com/book/show/18043011-clean-architecture</a></p><p id="ea41" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">所有代码示例都可以在这里找到:</p><p id="c483" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">https://github.com/cobbinma/quotes<a class="ae md" href="https://github.com/cobbinma/quotes" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>