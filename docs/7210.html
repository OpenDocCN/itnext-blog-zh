<html>
<head>
<title>Python Criticism from a Julia Perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱莉娅视角下的Python批评</h1>
<blockquote>原文：<a href="https://itnext.io/python-criticism-from-a-julia-perspective-f6613dfdd2b1?source=collection_archive---------0-----------------------#2022-07-17">https://itnext.io/python-criticism-from-a-julia-perspective-f6613dfdd2b1?source=collection_archive---------0-----------------------#2022-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="81cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一位Julia开发人员在反思今天使用Python 3.10的开箱即用体验</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/da409ae3ed1abae487fd3b147416e3cc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4jlfI2pD_679SJT6fiEQ-g.png"/></div></figure><p id="d0bd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi lm translated">Julia的开发者对YTHON的感觉异常熟悉。这不是意外。Python是启发Julia创作的语言之一。来自朱莉娅的<a class="ae lv" href="https://julialang.org/blog/2012/02/why-we-created-julia/" rel="noopener ugc nofollow" target="_blank">创作者:</a></p><blockquote class="lw"><p id="6402" class="lx ly it bd lz ma mb mc md me mf ll dk translated">我们是强大的Matlab用户。我们中的一些人是Lisp黑客。有些是Pythonistas，有些是ruby爱好者，还有一些是Perl黑客。</p><p id="7cb1" class="lx ly it bd lz ma mb mc md me mf ll dk translated">—朱莉娅·创作者</p></blockquote><p id="6a2e" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">这两种语言都可以用作交互式REPL(读取-评估-打印-循环)环境的脚本语言，与许多其他编程语言和环境优雅地接口。</p><p id="e9c0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="ml">注:这个故事是一个老故事的更新，是为</em> <a class="ae lv" href="https://erikexplores.substack.com/p/python-criticism-from-a-julia-perspective" rel="noopener ugc nofollow" target="_blank"> <em class="ml">的读者准备的，Erik探索了子堆栈上的</em> </a> <em class="ml">。不过，我也会在媒体上重新发布Substack材料。</em></p><p id="382e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">事实上，这种充当优雅粘合语言的能力是Python的主要卖点之一。20多年前，当我开始作为一名专业开发人员工作时，Python是我最先学会的用于文本处理和代码生成的语言之一。当时，Python在编写解析和处理文本的干净程序方面没有对手。</p><p id="f456" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Perl的程序员当时可能会大声反对，但是今天的Perl在哪里呢？对清晰易读的代码的关注战胜了Perl几乎不惜任何代价追求的灵活性。Perl最终成为只写语言。写代码很棒，但不是为了阅读。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="713a" class="mr ms it mn b gy mt mu l mv mw"># Excerpt from The 3rd Annual Obfuscated Perl Contest<br/><br/>undef $/;open(_,$0);/ \dx([\dA-F]*)/while(&lt;_&gt;);@&amp;=split(//,$1);@/=@&amp;;<br/>$".=chr(hex(join("",splice(@&amp;,0,2))))while(@&amp;); eval$”;</span></pre><p id="99b8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我开始使用Python时，感觉它比今天的Julia要晦涩得多。看看Python今天在哪里。Python不再是角落里的古怪小孩，而是主宰机器学习、数据科学和web开发的800磅大猩猩。从Stackoverflow的2022年开发者调查来看，如今唯一比Python更受欢迎的通用编程语言是JavaScript。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/2bcbe97db776c451c45bc4e936ef69c1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*5tfe_a9RvqmX0q1kVE57AQ.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">来自Stackoverflow调查2022</figcaption></figure><p id="2aa4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是我必须承认，2022年的Python并没有像2000年的Python那样给我带来积极的影响。为什么？Python的能力无疑呈指数级增长。但是我们对编程语言的期望也是如此。</p><p id="7b9a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">PyCharm等复杂的ide和TensorFlow、Django和Pandas等大型框架让Python开发人员做了很多事情。我不会考虑这一点，而是考虑语言本身的开箱即用体验。</p><h1 id="9524" class="nb ms it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">现代Python的复杂性</h1><p id="f771" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">今天的Python已经不是你爷爷辈的Python了。你遇到了Python 2.x vs 3.x的问题，<a class="ae lv" href="https://www.anaconda.com/blog/understanding-conda-and-pip" rel="noopener ugc nofollow" target="_blank"> Anaconda vs PIP </a>，<a class="ae lv" href="https://pipenv.pypa.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> pipenv </a>，virtualenv，<a class="ae lv" href="https://docs.python.org/3/library/venv.html" rel="noopener ugc nofollow" target="_blank"> venv </a>，<a class="ae lv" href="https://github.com/google/jax" rel="noopener ugc nofollow" target="_blank">JAX</a>vs<a class="ae lv" href="https://www.pypy.org" rel="noopener ugc nofollow" target="_blank">PyPy</a>vs<a class="ae lv" href="https://numba.pydata.org" rel="noopener ugc nofollow" target="_blank">Numba</a>，<a class="ae lv" href="https://cython.org" rel="noopener ugc nofollow" target="_blank"> Cython </a>等等。足够多的人感受到了它的痛苦，以至于把它变成了一部连环漫画。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/23965e398869814dbce443ae9fc83878.png" data-original-src="https://miro.medium.com/v2/format:webp/1*mHrDuetdLskvNHYucD9u3g.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">来自XKCD(https://m.xkcd.com/1987)</figcaption></figure><p id="a185" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我曾经接受过一个医生的咨询任务，他想开发一个应用程序来帮助她的诊断。她对编程有一些基本的经验，并跳进了今天对初学者来说最显而易见的路线:Python。</p><p id="2427" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是Python仍然是编程中易用性的黄金标准吗？我不这么认为。这位好医生来找我，因为她最终不得不放弃处理Python包系统和虚拟环境的复杂性。她偶然发现了朱莉娅，觉得这是一股新鲜空气。</p><h2 id="185a" class="mr ms it bd nc nx ny dn ng nz oa dp nk kz ob oc nm ld od oe no lh of og nq oh bi translated">用Python和Julia管理虚拟环境</h2><p id="11ac" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">为了处理Python 2.x和3.x的复杂性以及不同版本包的安装，我们需要一个虚拟环境。然而，Python并不是为虚拟环境而生的。这是用螺栓固定的东西。因此，有许多方法来创建虚拟环境。我碰巧使用了一个名为<a class="ae lv" href="https://virtualfish.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> VirtualFish </a>的工具，它可以与我在终端应用程序中使用的<a class="ae lv" href="https://fishshell.com" rel="noopener ugc nofollow" target="_blank">鱼壳</a>配合使用。这里有一个问题:根据您使用的Shell环境，您需要不同的软件来管理您的虚拟环境。</p><p id="350c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Python中的虚拟环境到底是什么？它包括为每个虚拟环境创建一个精心制作的Python目录结构，链接到不同库的具体版本和Python版本。这里有一个来自<code class="fe oi oj ok mn b">VirtualFish</code>的例子。我使用<code class="fe oi oj ok mn b">vf new</code>命令创建一个名为<code class="fe oi oj ok mn b">rockets</code>的新虚拟环境。你可以看到它在<code class="fe oi oj ok mn b">.virtualenvs/</code>目录下创建了无数的文件和文件夹。我们将为每个虚拟环境创建这样的结构。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="323b" class="mr ms it mn b gy mt mu l mv mw">❯ vf new rockets<br/>Creating rockets via /usr/local/opt/python@3.8/bin/python3.8 …<br/><br/>~ via 🐍 v3.8.12 (rockets)<br/>❯ tree -L 3 .virtualenvs/<br/>.virtualenvs/<br/>└── rockets<br/>    ├── bin<br/>    │   ├── activate<br/>    │   ├── activate.csh<br/>    │   ├── activate.fish<br/>    │   ├── activate.ps1<br/>    │   ├── activate.xsh<br/>    │   ├── activate_this.py<br/>    │   ├── easy_install<br/>    │   ├── easy_install3<br/>    │   ├── easy_install3.8<br/>    │   ├── pip<br/>    │   ├── pip3<br/>    │   ├── pip3.8<br/>    │   ├── python -&gt; /usr/local/opt/python@3.8/bin/python3.8<br/>    │   ├── python3 -&gt; python<br/>    │   ├── python3.8 -&gt; python<br/>    │   ├── wheel<br/>    │   ├── wheel3<br/>    │   └── wheel3.8<br/>    ├── lib<br/>    │   └── python3.8<br/>    └── pyvenv.cfg</span></pre><p id="5f92" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">shell中有一些钩子，可以确保您的整个系统都指向当前虚拟环境的目录结构。因此，安装虚拟环境管理器意味着向您的shell配置添加内容。我将以下文件添加到了我的fish启动配置中:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="21f7" class="mr ms it mn b gy mt mu l mv mw">~<br/>❯ cat .config/fish/conf.d/virtualfish-loader.fish<br/>set -g VIRTUALFISH_VERSION 2.5.1<br/>set -g VIRTUALFISH_PYTHON_EXEC /usr/local/opt/python@3.8/bin/python3.8<br/>source /usr/local/lib/python3.8/site-packages/virtualfish/virtual.fish<br/>emit virtualfish_did_setup_plugins⏎</span></pre><p id="fc11" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这种创建虚拟环境的方式不是没有问题的。系统可能会因其他工具而崩溃。有各种各样的虚拟环境系统，你必须知道是否可以一起使用。打包和部署这类东西并不简单。</p><p id="717e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">相比之下，在Julia中管理虚拟环境简直无聊透顶。环境只是一个包含两个文件的目录:</p><ul class=""><li id="aa53" class="ol om it ks b kt ku kw kx kz on ld oo lh op ll oq or os ot bi translated"><code class="fe oi oj ok mn b">Project.toml</code>——直接依赖</li><li id="a46d" class="ol om it ks b kt ou kw ov kz ow ld ox lh oy ll oq or os ot bi translated"><code class="fe oi oj ok mn b">Manifest.toml</code> -间接依赖关系</li></ul><p id="0a31" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这意味着您可以在Julia中轻松地对环境进行版本控制。您只需要带两个文件就可以在任何地方重新创建那个环境。让我告诉你我们如何在Julia中创建一个环境来进行比较。我将创建一个名为<code class="fe oi oj ok mn b">troll</code>的环境(为什么不呢？我是挪威人。我们用巨魔来命名一切事物)。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="3dce" class="mr ms it mn b gy mt mu l mv mw">❯ mkdir troll<br/><br/>❯ cd troll<br/><br/>~/troll<br/>❯ julia -q<br/>julia&gt;</span></pre><p id="1854" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们已经启动了朱莉娅，我们在朱莉娅REPL(阅读-评估-打印-循环)。当前处于Julia模式，提示为<code class="fe oi oj ok mn b">julia&gt;</code>。我们切换到包管理器模式，向环境添加依赖项。我们只是按下<code class="fe oi oj ok mn b">]</code>键来切换模式。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="c46e" class="mr ms it mn b gy mt mu l mv mw">julia&gt; ]<br/>(@v1.7) pkg&gt; activate .</span></pre><p id="9f95" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Julia给了我们一些反馈，告诉我们如何以及在哪里获取依赖项。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/6dd346e01549c565c6dbd8b977ae4271.png" data-original-src="https://miro.medium.com/v2/format:webp/1*-j5WT1cAPl4-HnybFEHarA.png"/></div></figure><p id="a5f7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们不必真的退出朱莉娅·REPL。我们可以简单地点击分号<code class="fe oi oj ok mn b">;</code>进入shell模式，并且我们可以使用常规的Unix实用程序如<code class="fe oi oj ok mn b">cat</code>来查看刚刚被修改的<code class="fe oi oj ok mn b">.toml</code>文件。<code class="fe oi oj ok mn b">Project.toml</code>文件包含我们添加的单个依赖项:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="05ae" class="mr ms it mn b gy mt mu l mv mw">shell&gt; cat Project.toml<br/>[deps]<br/>Dates = "ade2ca70-3891-5945-98fb-dc099432e06a"<br/><br/>shell&gt; cat Manifest.toml<br/># This file is machine-generated - editing it directly is not advised<br/><br/>julia_version = "1.7.2"<br/>manifest_format = "2.0"<br/><br/>[[deps.Dates]]<br/>deps = ["Printf"]<br/>uuid = "ade2ca70-3891-5945-98fb-dc099432e06a"<br/><br/>[[deps.Printf]]<br/>deps = ["Unicode"]<br/>uuid = "de0858da-6303-5e67-8744-51eddeeeb8d7"<br/><br/>[[deps.Unicode]]<br/>uuid = "4ec0a83e-493e-50e2-b9ac-8f72acf5a8f5"</span></pre><p id="b39e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当然，我们可以详细了解清单文件中所有这些不同内容的含义，但这不是本文的内容。我们正在尝试将当代Python与Julia进行比较。</p><p id="34c0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">从我们刚刚探索的两个系统中有几个重要的收获:</p><ul class=""><li id="6bab" class="ol om it ks b kt ku kw kx kz on ld oo lh op ll oq or os ot bi translated">Python要求选择一个与您使用的shell兼容的特定虚拟环境系统并安装它。</li><li id="046c" class="ol om it ks b kt ou kw ov kz ow ld ox lh oy ll oq or os ot bi translated">在Python中安装虚拟环境系统会修改您的shell的行为。</li></ul><p id="5ce0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于茱莉亚来说，没什么好装的。虚拟环境系统是Julia的一个组成部分，与包装系统交织在一起。你可以在朱莉娅·REPL内部激活和修改虚拟环境系统。它根本不会修改或触及您的外壳。您不必担心添加虚拟环境系统会搞乱您可能已经完成的其他shell配置。</p><p id="431a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Julia中，您可以轻松地将虚拟环境与您的项目一起携带，因为它们只是简单的文本文件，您可以将它们提交到您的版本控制系统，并保存在与您的项目相同的目录中。</p><p id="d1ad" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于Python来说，我看不到一种简单的方法来摆脱它在这个领域制造的混乱。过去的错误仍然存在，因为有大量的Python项目是在这些系统上构建的。添加一个新的更好的系统会产生一个所有软件开发人员都熟悉的众所周知的问题:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/372226f2f446a5ebcd58dc444f47db66.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9nMBMt-OugnruBr_M-WuEQ.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">添加一个新的更好的虚拟环境系统会造成什么损害？<a class="ae lv" href="https://xkcd.com/927/" rel="noopener ugc nofollow" target="_blank">https://xkcd.com/927/</a></figcaption></figure><h1 id="6ee3" class="nb ms it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">Python文档的问题</h1><p id="1ef2" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">对Julia最常见的抱怨之一是文档很糟糕，而Python因其丰富的优秀文档而受到称赞。我认为这是一种误解。</p><p id="5c92" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Julia有一个非常完善的文档系统。朱莉娅·REPL提供了一种帮助模式，你可以通过按<code class="fe oi oj ok mn b">?</code>进入该模式。在帮助模式下，评估实际的Julia代码以选择相关的方法。例如，Julia中的乘法符号可用于数字相乘或连接字符串。如果在帮助模式下将两个数相乘，我们会得到算术运算的文档。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="8fe0" class="mr ms it mn b gy mt mu l mv mw">help?&gt; 2 * 4<br/>  *(x, y...)<br/><br/><br/>  Multiplication operator. x*y*z*... calls this function with all<br/>  arguments, i.e. *(x, y, z, ...).<br/><br/>  Examples<br/>  ≡≡≡≡≡≡≡≡≡≡<br/><br/>  julia&gt; 2 * 7 * 8<br/>  112<br/><br/>  julia&gt; *(2, 7, 8)<br/>  112</span></pre><p id="28c8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一方面，如果我们提供文本字符串，我们得到的是字符串连接的文档:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="2305" class="mr ms it mn b gy mt mu l mv mw">help?&gt; "hello" * "world"<br/>  *(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -&gt; AbstractString<br/><br/><br/>  Concatenate strings and/or characters, producing a String. This is<br/>  equivalent to calling the string function on the arguments.<br/>  Concatenation of built-in string types always produces a value of type<br/>  String but other string types may choose to return a string of a<br/>  different type as appropriate.<br/><br/>  Examples<br/>  ≡≡≡≡≡≡≡≡≡≡<br/><br/>  julia&gt; "Hello " * "world"<br/>  "Hello world"<br/><br/>  julia&gt; 'j' * "ulia"<br/>  "julia"</span></pre><p id="fd9e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Python REPL文档没有这种复杂程度。但是Python文档有更大的问题:</p><ul class=""><li id="8855" class="ol om it ks b kt ku kw kx kz on ld oo lh op ll oq or os ot bi translated">没有语法突出显示或格式</li><li id="b8f6" class="ol om it ks b kt ou kw ov kz ow ld ox lh oy ll oq or os ot bi translated">没有示例代码</li><li id="b2dd" class="ol om it ks b kt ou kw ov kz ow ld ox lh oy ll oq or os ot bi translated">极其稀疏</li></ul><p id="1c9e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了说明这个问题，我拍摄了一些屏幕截图，展示了在每个REPL环境中查找类似类型的函数/方法的帮助会产生什么结果，左边是Julia，右边是Python。</p><h2 id="e1ad" class="mr ms it bd nc nx ny dn ng nz oa dp nk kz ob oc nm ld od oe no lh of og nq oh bi translated">打印字符串</h2><p id="369e" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">让我们先看看<code class="fe oi oj ok mn b">print</code>文档。这是语言初学者最常用的函数。请注意Julia帮助如何给出有用的代码示例，以及如何格式化非字符串值的重要细节。Python没有提到<code class="fe oi oj ok mn b">print</code>将如何处理非字符串值。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/427a2f2a64feb710a4dcb826f69882a7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*LHWTBIec5w27hSLzF-0q1g.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">用Julia和Python打印文档</figcaption></figure><h2 id="9c13" class="mr ms it bd nc nx ny dn ng nz oa dp nk kz ob oc nm ld od oe no lh of og nq oh bi translated">推送和附加集合</h2><p id="ee29" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">对于初学者来说，另一个常见的功能是在集合的末尾添加一个元素。Julia调用这个函数<code class="fe oi oj ok mn b">push!</code>，而Python调用它<code class="fe oi oj ok mn b">append</code>。同样，您可以看到Python文档是多么简单。它只是陈述最明显的，没有任何细节或代码示例。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/6ef1b95f0892a5a3a5a0da08f609cb06.png" data-original-src="https://miro.medium.com/v2/format:webp/1*B6lviGohlpC91IKXYcRAgg.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">用力！并为Julia和Python附加文档</figcaption></figure><p id="a3b6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我认为，帮助文档还说明了像Julia这样的函数式语言的另一个明显优势。帮助文档会立即让您看到这样一个事实:T2是一个适用于许多集合类型的通用函数。您还会被告知它在不同集合中的行为可能会有所不同。Python的OOP方法给了你一个更加孤立的世界。您无法立即判断该方法是否适用于许多不同的集合类型。朱莉娅帮助你用一般术语思考。你开始认为函数具有跨多种类型的相关行为。</p><h2 id="a88a" class="mr ms it bd nc nx ny dn ng nz oa dp nk kz ob oc nm ld od oe no lh of og nq oh bi translated">拆分字符串</h2><p id="23c0" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">Python和Julia都是处理文本的好语言。我经常使用的一个函数是<code class="fe oi oj ok mn b">split</code>将一个字符串转换成一个元素数组。同样，Julia变体有更丰富的文档和更多的例子来帮助开发人员。例如，Julia文档详细说明了定界符<code class="fe oi oj ok mn b">dlm</code>可以是什么。文档解释说它可以是字符串、正则表达式、函数、单个字符或字符集合。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/17588f448cfa3db8eff1ea49611d3c8c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*TjKNpneUX5OK4r7DcrJPaw.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">Julia和Python的分割字符串文档</figcaption></figure><p id="cbc7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Python文档实际上并没有说明分隔符<code class="fe oi oj ok mn b">sep</code>应该是哪种对象。</p><h2 id="4fc9" class="mr ms it bd nc nx ny dn ng nz oa dp nk kz ob oc nm ld od oe no lh of og nq oh bi translated">那么，为什么Julia Documentation的名声不好呢？</h2><p id="2148" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">许多Julia项目是年轻的和不成熟的，这意味着文档是不完整的或缺乏的。相比之下，Python有许多大型的成熟项目，随着时间的推移，这些项目已经建立了可靠的文档。</p><p id="d47e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">印象中的差异源于Python有各种各样的书籍、教程、指南和在线文档。Julia社区的资源要少得多，而且没有为所有流行的项目创建合适的文档。但是有一些重要的事情Julia做对了，而Python做得不够:Julia的内置文档系统显然更好。它理解Markdown语法，您可以添加代码示例，所有这些都可以通过文档生成工具提取出来。这意味着你在朱丽亚·REPL身上看到的帮助和你在网上看到的会相匹配。</p><p id="95be" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于Python来说，这是两个独立的世界。在Python REPL中，<code class="fe oi oj ok mn b">split</code>方法的帮助是非常简单的，但是在基于web的<a class="ae lv" href="https://docs.python.org/3/library/stdtypes.html#str" rel="noopener ugc nofollow" target="_blank">在线帮助系统</a>中要广泛得多。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/2be3721241295a064457b6b1bff95e79.png" data-original-src="https://miro.medium.com/v2/format:webp/1*nyVPwEZ7wF6CqkW1wI2ruQ.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">网上的Python分裂函数文档</figcaption></figure><p id="437e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你为朱丽亚看同样的<a class="ae lv" href="https://docs.julialang.org/en/v1/base/strings/#Base.split" rel="noopener ugc nofollow" target="_blank">文档(分割)</a>，你会发现它与你在朱丽亚·REPL中找到的完全相同。这是因为文档来源于同一个地方。</p><h1 id="c913" class="nb ms it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">弱类型布尔表达式</h1><p id="e9e9" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">许多语言中的一个常见操作是检查集合<code class="fe oi oj ok mn b">xs</code>是否为空。许多语言都有类似于<code class="fe oi oj ok mn b">empty</code>、<code class="fe oi oj ok mn b">isempty</code>或<code class="fe oi oj ok mn b">isEmpty</code>的功能。在朱丽亚，我会写:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="ee65" class="mr ms it mn b gy mt mu l mv mw">julia&gt; xs = [3, 4];<br/><br/>julia&gt; isempty(xs)<br/>false</span></pre><p id="bc05" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我记得多年后第一次回到Python时，我已经忘记了如何检查集合是否为空，所以我尝试了各种具有所提到名称的方法调用。它们都不起作用，因为，惊讶吧，惊讶吧，在Python中检查集合<code class="fe oi oj ok mn b">xs</code>是否为空时，您可以写:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="6f40" class="mr ms it mn b gy mt mu l mv mw">if not xs:<br/>  print "collection is empty"</span></pre><p id="c977" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这种奇怪之处的存在是因为Python世界有<strong class="ks iu">真</strong>和<strong class="ks iu">假</strong>的概念。在Python中，几乎所有不是0、0.0、<code class="fe oi oj ok mn b">false</code>或空集合的对象都被解释为<code class="fe oi oj ok mn b">true</code>。在我看来，这是一个相当糟糕的设计选择。它为布尔表达式和控制流语句提供了非常弱的类型。弱类型意味着更多的错误会从缝隙中溜走。</p><p id="569c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">也许这个设计选择更令人困惑的是，它完全违反了Python 禅宗中最神圣的戒律之一:</p><blockquote class="oz pa pb"><p id="ae42" class="kq kr ml ks b kt ku ju kv kw kx jx ky pc la lb lc pd le lf lg pe li lj lk ll im bi translated">显性比隐性好</p></blockquote><p id="0800" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这种语言设计选择意味着以下明显有问题的代码运行良好:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="8b8d" class="mr ms it mn b gy mt mu l mv mw">if 'B':<br/>	print("expression is true")</span></pre><p id="54df" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Julia中，如果您试图运行这个表达式，Julia会抛出一个类型错误异常:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="4af4" class="mr ms it mn b gy mt mu l mv mw">julia&gt; if 'B'<br/>           print("true expression")<br/>       end<br/>ERROR: TypeError: non-boolean (Char) used in boolean context</span></pre><h1 id="f6d5" class="nb ms it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">低功能可发现性</h1><p id="116f" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">如果你已经编程多年，你会开始意识到应该存在什么样的功能。你知道应该可以向集合中添加条目，拆分字符串，搜索条目。在Julia中，开箱即用，如果我写<code class="fe oi oj ok mn b">spli</code>并按tab键两次，我会得到以下显示的完成:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="e7b0" class="mr ms it mn b gy mt mu l mv mw">splice!    split       splitdir    splitdrive  splitext    splitpath<br/>julia&gt; spli</span></pre><p id="dcf7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是很多有用的信息。我被提醒，我可以将一个路径拆分成单独的部分，或者我可以拆分文件扩展名。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="5d16" class="mr ms it mn b gy mt mu l mv mw">julia&gt; splitext("foo.txt")<br/>("foo", ".txt")</span></pre><p id="5d52" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用Python，搜索功能更加复杂，因为它被划分到对象上的免费函数和方法中。为了发现<code class="fe oi oj ok mn b">split</code>的功能，我必须首先创建一个字符串对象，然后尝试完成(<a class="ae lv" href="https://bpython-interpreter.org" rel="noopener ugc nofollow" target="_blank"> bpython REPL </a>):</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="819c" class="mr ms it mn b gy mt mu l mv mw">&gt;&gt;&gt; "abc".spli<br/>┌──────────────────────────────────────────────────────────────┐<br/>│ split      splitlines                                        │<br/>└──────────────────────────────────────────────────────────────┘</span></pre><p id="7283" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">分割路径的功能在哪里？您可以看到，使用OOP方法，我们不会接触到相关的功能。像处理路径这样的常见操作隐藏在一个单独的模块中，您必须导入该模块才能找到路径分割和文件扩展名分割。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="5d41" class="mr ms it mn b gy mt mu l mv mw">&gt;&gt;&gt; import os.path<br/>&gt;&gt;&gt; os.path.split<br/>┌──────────────────────────────────────────────────────────────┐<br/>│ split              splitdrive         splitext               │<br/>└──────────────────────────────────────────────────────────────┘</span></pre><p id="a3e7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">拆分的反义词是连接:取几个元素，把它们组合成一个。我们可以在Julia中用制表符补全来做同样的事情，以发现连接事物的常见方式:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="4267" class="mr ms it mn b gy mt mu l mv mw">join     joinpath<br/>julia&gt; join</span></pre><p id="59c8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">通过写一个括号<code class="fe oi oj ok mn b">(</code>并再次按tab键，我可以进一步发现<code class="fe oi oj ok mn b">join</code>可以操作什么类型的对象:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="5a3c" class="mr ms it mn b gy mt mu l mv mw">julia&gt; join(<br/><br/>join(io::IO, iterator) in Base at strings/io.jl:342<br/>join(io::IO, iterator, delim) in Base at strings/io.jl:342<br/>join(io::IO, iterator, delim, last) in Base at strings/io.jl:326<br/>join(iterator) in Base at strings/io.jl:352<br/>join(iterator, delim) in Base at strings/io.jl:353<br/>join(iterator, delim, last) in Base at strings/io.jl:354</span></pre><p id="26ab" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这种完成给了我们一些有用的提示，我们不会立即假设，比如能够将输出从<code class="fe oi oj ok mn b">join</code>推入I/O对象，比如文件、网络套接字或标准输出。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="c95a" class="mr ms it mn b gy mt mu l mv mw"># Producing a string<br/>julia&gt; join('A':'F', ",")<br/>"A,B,C,D,E,F"<br/><br/># Sending result of join to stdout<br/>julia&gt; join(stdout, 'A':'F', ",")<br/>A,B,C,D,E,F</span></pre><p id="e8e5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于Python来说，<code class="fe oi oj ok mn b">join</code>并不是显而易见的地方。事实证明，Python中考虑join的方式是在分隔符上调用<code class="fe oi oj ok mn b">join</code>。这有多符合Python的禅？从概念上来说，被加入实际集合的东西不是吗？</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="0716" class="mr ms it mn b gy mt mu l mv mw">&gt;&gt;&gt; ":".join(["hello", "world"])<br/>'hello:world'</span></pre><p id="628f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我在使用Python时注意到的另一个问题是，Python的功能比Julia中的功能更不通用。例如，我不能连接非字符串对象。为什么不呢？</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="e7ff" class="mr ms it mn b gy mt mu l mv mw">&gt;&gt;&gt; ":".join([3, 5, 5])<br/>TypeError: sequence item 0: expected str instance, int found</span></pre><p id="09dc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Julia中，其行为类似于打印。您使用每个对象的默认字符串表示。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="bd2f" class="mr ms it mn b gy mt mu l mv mw">julia&gt; join([4, 5, 6], ":")<br/>"4:5:6"</span></pre><p id="dac8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Julia的<code class="fe oi oj ok mn b">join</code>函数给了我们一个发现<code class="fe oi oj ok mn b">joinpath</code>的简单方法，但是在Python中没有这样容易发现的<code class="fe oi oj ok mn b">join</code>连接。Python解决方案是:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="6158" class="mr ms it mn b gy mt mu l mv mw">&gt;&gt;&gt; import os.path<br/>&gt;&gt;&gt; os.path.join("foo", "bar")<br/>'foo/bar'<br/>&gt;&gt;&gt; os.path.join(["foo", "bar"])<br/>TypeError: expected str, bytes or os.PathLike object, not list</span></pre><p id="6669" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后一条语句再次证明了Python缺乏通用性。为什么连接列表中的元素不起作用？它在Julia身上完全没问题:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="b04d" class="mr ms it mn b gy mt mu l mv mw">julia&gt; joinpath("foo", "bar")<br/>"foo/bar"<br/><br/>julia&gt; joinpath(["foo", "bar"])<br/>"foo/bar"</span></pre><p id="45a8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我们想扩展这个功能并创建一个从我们的主目录开始的路径呢？这是一个常见的编程任务，在Julia中很容易完成。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="9e8f" class="mr ms it mn b gy mt mu l mv mw">julia&gt; joinpath(homedir(), "bar", "foo")<br/>"/Users/erikengheim/bar/foo</span></pre><p id="7042" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用Python，我们必须进入完全不同的领域，使用完全不同的功能:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="e2bf" class="mr ms it mn b gy mt mu l mv mw">&gt;&gt;&gt; os.path.expanduser("~/bar/foo")<br/>'/Users/erikengheim/bar/foo'</span></pre><p id="83d4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我觉得这个函数的命名比较差。寻找主目录路径的人不会去寻找这种名字的函数。</p><p id="6783" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我发誓我没有挑选这些例子。我只是选择我常用的功能。让我举另一个相关的例子。因为Python和Julia都用于脚本编写，所以很自然地会考虑处理文件的功能。假设我们想要删除一个文件。在Julia中，大多数文件函数反映了你在Unix shell中使用的名字，比如<code class="fe oi oj ok mn b">cp</code>、<code class="fe oi oj ok mn b">mv</code>和<code class="fe oi oj ok mn b">rm</code>，这使得它们很容易被发现。因此，要在Julia中删除一个文件或目录，我可以写:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="3614" class="mr ms it mn b gy mt mu l mv mw">julia&gt; rm("foo")                 # remove single file<br/>julia&gt; rm("foo", recursive=true) # remove all content of a directory</span></pre><p id="4599" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Python中，<code class="fe oi oj ok mn b">os</code>模块中没有<code class="fe oi oj ok mn b">rm</code>、<code class="fe oi oj ok mn b">delete</code>或<code class="fe oi oj ok mn b">rmdir</code>函数。相反，我们必须看一个完全不同的模块，名为<code class="fe oi oj ok mn b">shutil</code>，带有函数<code class="fe oi oj ok mn b">rmtree</code>。这让我觉得前后矛盾。你必须在一个完全不同的库中寻找一个有着不直观名字的密切相关的函数。</p><h1 id="62f8" class="nb ms it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">Python有限的通用性</h1><p id="2661" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">如果你所学的概念可以在许多组合中重复使用，语言在使用时会变得更加强大和灵活。这就是为什么好的软件设计倾向于强调正交特性的创建。如果你有清晰分离的特性，并且可以互相结合，那么软件会更容易使用。在绘图程序中，可以选择彼此独立的几何形状和颜色。想象一下，如果绘制红色方块是一个特定的工具，独立于绘制绿色圆圈的工具，该软件会有多复杂。</p><p id="0c33" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以下是如何在Julia中使用切片和范围的示例:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="2334" class="mr ms it mn b gy mt mu l mv mw">julia&gt; xs = [2, 4, 8, 10];<br/><br/>julia&gt; xs[1:3]<br/>3-element Vector{Int64}:<br/> 2<br/> 4<br/> 8<br/><br/>julia&gt; r = 1:3<br/>1:3<br/><br/>julia&gt; xs[r]<br/>3-element Vector{Int64}:<br/> 2<br/> 4<br/> 8<br/><br/>julia&gt; 2 in 1:3<br/>true</span></pre><p id="a9ad" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Python中，没有像在Julia中那样的通用范围操作符<code class="fe oi oj ok mn b">:</code>。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="88e9" class="mr ms it mn b gy mt mu l mv mw">&gt;&gt;&gt; xs = [2, 4, 8, 10]<br/>&gt;&gt;&gt; xs[0:3]<br/>[2, 4, 8]<br/><br/>&gt;&gt;&gt; r = 0:3<br/>    r = 0:3<br/>         ^<br/>SyntaxError: invalid syntax<br/><br/>&gt;&gt;&gt; r = slice(0, 3)<br/>&gt;&gt;&gt; xs[r]<br/>[2, 4, 8]<br/><br/>&gt;&gt;&gt; 2 in slice(0, 3)<br/>TypeError: argument of type 'slice' is not iterable<br/><br/>&gt;&gt;&gt; 2 in range(0, 3)<br/>True</span></pre><p id="0ea2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有很多例子表明Julia概念自然地扩展到了各种不同的上下文中，但是Python却不是这样。我可以通过省略Julia中的函数名来创建一个匿名函数:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="d32a" class="mr ms it mn b gy mt mu l mv mw">julia&gt; f = function(x)<br/>               x + 3<br/>           end<br/>#1 (generic function with 1 method)<br/><br/>julia&gt; f(1)<br/>4</span></pre><p id="e8bd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Python中不可能做到这一点。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="5d24" class="mr ms it mn b gy mt mu l mv mw">&gt;&gt;&gt; f = def(x):<br/>    f = def(x):<br/>        ^^^<br/>SyntaxError: invalid syntax</span></pre><p id="fa9c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">事实上，Python已经提出了大量处理匿名函数的解决方案。您有<code class="fe oi oj ok mn b">lambda</code>函数或<code class="fe oi oj ok mn b">with</code>语法结构。Julia有不同的方法来创建匿名函数，但是每种方法都是完全可以互换的。例如，所有这些形式都表示相同的意思:</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="80b3" class="mr ms it mn b gy mt mu l mv mw"># Julia anonymous functions<br/><br/>open(function(io) readline(io) end, "foo.txt")<br/><br/>open(io-&gt;readline(io), "foo.txt")<br/><br/>open("foo.txt") do io<br/>   readline(io)<br/>end</span></pre><p id="e3c4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Python中，您必须专门使用<code class="fe oi oj ok mn b">with</code>形式。不能使用lambda函数。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="18df" class="mr ms it mn b gy mt mu l mv mw">with openfile("foo.txt") as io:<br/>  print(readline(io))</span></pre><p id="3c0e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我们涵盖所有其他情况，这篇已经很长的文章会变得更长，但是当处理高阶函数如<code class="fe oi oj ok mn b">map</code>、<code class="fe oi oj ok mn b">filter</code>和<code class="fe oi oj ok mn b">reduce</code>时，你会看到同样的问题出现。你在处理字典和理解的时候会看到它。</p><h2 id="510f" class="mr ms it bd nc nx ny dn ng nz oa dp nk kz ob oc nm ld od oe no lh of og nq oh bi translated">在Julia中通过对象发现方法</h2><p id="9dbe" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">我想添加一个关于面向对象风格的方法发现的注释，因为来自OOP背景的人对Julia中的方法发现有很多抱怨。在Julia中，如果你想看到所有适用于参数<code class="fe oi oj ok mn b">(stdout, 42)</code>的方法，你应该写(TAB意味着TAB键):</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="ee59" class="mr ms it mn b gy mt mu l mv mw">julia&gt; ?(stdout, 42) TAB</span></pre><p id="f09d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这可能会给出大量的完成，因此您可以通过指定要搜索的模块来缩小搜索范围。在这里，我们在<code class="fe oi oj ok mn b">Base</code>模块中进行搜索(有太多的完成，为了清楚起见，我把它们编辑掉了)。</p><pre class="ki kj kk kl gt mm mn mo mp aw mq bi"><span id="8fb8" class="mr ms it mn b gy mt mu l mv mw">julia&gt; Base.?(stdout, 42)<br/>readuntil(s::IO, delim::T; keep) where T in Base at io.jl:823<br/>summary(io::IO, x) in Base at show.jl:2790<br/>summary(io::IO, x) in Base at show.jl:2790<br/>...</span></pre><p id="ccbd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个完成选项是Julia 1.8附带的。</p><h1 id="c847" class="nb ms it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">结论</h1><p id="4533" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">实际上，我还有很多其他的话题要讨论，由于这篇文章太长了，我决定不再讨论这些话题。我们可以看看外壳集成、外部函数调用、多维数组等等。</p><p id="d510" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最终，这将是打一匹死马，有什么意义呢？Julia是一种更新的语言，它受益于编程语言设计的大量经验，这些经验是吉多·范·罗苏姆在设计Python时所没有的。事实上，Julia本身在很大程度上归功于他在创建Python时所做的工作。引用艾萨克·牛顿的话:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/b3827e853f7dc2dbe00abf278d290d24.png" data-original-src="https://miro.medium.com/v2/format:webp/1*l_FW5X7s075ttmnbmc_Opg.jpeg"/></div></figure><p id="e300" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Python社区做出了许多创新，并有许多见解，这让后来的人受益匪浅。期望Python从第一天起就把一切都做好是不合理的。</p><p id="8082" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那么像这样的文章有什么意义呢？它是关于在我们今天拥有的丰富的编程语言生态系统中存在的许多其他优秀选择的意识。最大、最著名的语言并不一定意味着最好的语言或主宰未来的语言。</p><p id="a895" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">20年前，当我第一次涉足Python时，它还是个失败者。许多人会建议我坚持使用像Perl这样的语言，因为它有更大的开发社区和更多的工作机会。在我刚开始做开发的时候，Visual Basic和Pascal，尤其是通过Borland的Delphi，在市场上占主导地位。</p><p id="3bde" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在大多数情况下，你将使用的语言是很久以前的选择。但是作为初学者用什么语言，还是一个很不一样的选择。作为一名新开发人员，我花了很多时间在C/C++上。我认为那是个错误。作为初学者，你使用的具体语言远不如学习重要的概念重要，这些概念在所有语言中都很重要。</p><p id="5498" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就我个人而言，我认为Julia是当今非常好的初学者语言。比Python强多了。它教给你将在未来几年主导软件行业的概念。现代Python对工具和配置造成了太多的干扰。这不应该是初学者的主要关注点。</p><p id="2e69" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">旧语言自然会有更多的训练材料，但这也会对初学者不利。将会有大量与不再相关的版本和实践相关的过时材料。</p><p id="181e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">简而言之，我认为Python将在未来几年继续在业界占据主导地位，但我认为它不再是初学者的最佳选择。时代变了。</p></div></div>    
</body>
</html>