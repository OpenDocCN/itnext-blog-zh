<html>
<head>
<title>8 Visual Studio Code Assistant rules for nasty Angular bugs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">8 Visual Studio代码助手针对讨厌的角度错误的规则</h1>
<blockquote>原文：<a href="https://itnext.io/8-visual-studio-code-assistant-rules-for-nasty-angular-bugs-9f186277e0ab?source=collection_archive---------3-----------------------#2020-06-25">https://itnext.io/8-visual-studio-code-assistant-rules-for-nasty-angular-bugs-9f186277e0ab?source=collection_archive---------3-----------------------#2020-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c2c709da1fdfc8081e4177f1f38b3929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6eJdyhamYfAxzQJo2W9Rw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">弗里皮克/ <a class="ae kf" href="https://www.freepik.com/microone" rel="noopener ugc nofollow" target="_blank"> microone </a>(有执照)</figcaption></figure><p id="c5b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在用任何语言编程和使用任何框架时，都有你或你的队友会一次又一次犯同样错误的情况。ESLint不会检测到的。因为这将是林挺规则的完美代码。但是应用程序会崩溃或者表现不佳。最终，当您构建一个项目时，会发现其中的一些错误。因为有些规则只在这一步触发，而不是更早。或者更糟—在服务器上，在生产服务器上。</p><p id="e757" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是当我们深入研究我们在编程时所犯的错误时，这些错误基本上分为两类:简单错误和核心错误。核心错误是由一个错误的逻辑实现造成的，这里不讨论这些。因为你需要使用领域知识来修复它们。但是简单的错误——您可以自动检测它们。</p><p id="af72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单的错误是由使用不正确的名称或语法引起的。如果ESLint能检测到，那就太好了。但是如果不是这样——您的代码中可能有一个很难跟踪的问题。每次你犯这个错误都要花一些时间。</p><p id="af3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，Visual Studio代码的实时<a class="ae kf" href="https://marketplace.visualstudio.com/items?itemName=tomasz-smykowski.assistant" rel="noopener ugc nofollow" target="_blank">助手</a>扩展派上了用场。您可以定义正则表达式规则。当被触发时，您可以在代码旁边显示一条消息，其中包含一条错误信息以及如何修复它。</p><p id="b5b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我将向您展示我最喜欢的Angular(和TypeScript)助手规则:</p><h1 id="d3b4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">1.泄露CSS样式</h1><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6926" class="ml lf it mh b gy mm mn l mo mp">{<br/>“regex”: “^::ng-deep.*$”,<br/>“message”: “Prepend with :host, so that styles won’t leak”,<br/>“modifiers”: “gm”<br/>}</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/973d9028deb2d436727523881d76daab.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/1*SabVB54YdZdECrQxMMWB4Q.gif"/></div></figure><p id="2dc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，该规则在您将要编辑的SCSS中搜索以<a class="ae kf" href="https://angular.io/guide/component-styles" rel="noopener ugc nofollow" target="_blank"> ::ng-deep </a>开头的行。如果你要写一行以::ng-deep开头的代码，它会显示一条消息“前置:host，这样样式就不会泄漏”。我发现使用这个规则非常有用，因为单独使用::ng-deep会导致SCSS应用于整个应用程序。你不希望这一切发生。</p><p id="7a1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为Angular默认为每个组件提供CSS隔离。如果您使用这个命令，CSS将会泄漏，可能很难跟踪是谁泄漏了CSS，因为应用程序的某些其他部分的样式可能很糟糕，但是为什么呢？谁知道呢？</p><p id="28a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么我喜欢当助手显示这条消息的时候，我会一个人不小心写::ng-deep。隔离规则的适当形式应该是什么？：</p><p id="178e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mr ms mt mh b">:host ::ng-deep</code></p><p id="aacd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这条规则有例外吗？当然可以！例如，如果您设计对话框或mat-select列表项。这些使用覆盖。所以你用panelClass，than需要用::ng-deep。nameOfUniqueClass以防止样式泄漏。但这些都是罕见的例外。该消息仍会出现。因此，在这个案例中添加一个词是很好的。这是给你和你的队友的一个关于CSS隔离的信息。但是由于助手消息不会阻止构建过程，所以您可以自由地构建您的应用程序。</p><h1 id="66ba" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">2.名称错误的生命周期挂钩</h1><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ec52" class="ml lf it mh b gy mm mn l mo mp">{<br/>“regex”: “OnAfterViewInit”,<br/>“message”: “it should be ngAfterViewInit”<br/>}</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/631bf61d6171922ba00bf2343ee9aa64.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/1*DOBaYHiKu_vF5_1OPgGsDQ.gif"/></div></figure><p id="da47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我没有理由一次又一次地犯这个错误。OnInit的生命周期方法是ngOnInit，对于AfterViewInit—ngafterviewit。直截了当。也许我犯这个错误是因为我用PHP编程了很多，下意识地试图在这里找到一个合适的名字；)不管怎样，我发现有这样的辅助规则很有帮助。</p><h1 id="40c8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">3.错误的模板条件</h1><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a87c" class="ml lf it mh b gy mm mn l mo mp">{<br/>“regex”: “ ngIf”,<br/>“message”: “It should be *ngIf”<br/>}</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/9ecbf0910d32627f3c3205826a1e55e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/1*XZQCjTY3bqce7I2JmB5D1Q.gif"/></div></figure><p id="5797" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结构指令正确的拼写是<a class="ae kf" href="https://angular.io/api/common/NgIf" rel="noopener ugc nofollow" target="_blank"> *ngIf </a>，而不是ngIf。但是如果写ngIf=，会怎么样呢？实际上没什么。林特尔会很好。建筑商会同意的。Browser会很高兴的。只有你的老板会不高兴。因为没有人会用这个条件。它在那里，在代码中，但是它不会被正确地执行。因此，与其花几个小时寻找这个错别字，不如有一个辅助规则。</p><h1 id="6765" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">4.错误的属性类型声明</h1><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9527" class="ml lf it mh b gy mm mn l mo mp">{<br/>“regex”: “@Input\\(\\) .*: false;”,<br/>“message”: “Type of input should be boolean here, not false”<br/>}</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/c5ecf44ddc61900334b4e41903a3b330.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*Qskac91qBmg0JmEN3ZJElw.gif"/></div></figure><p id="2439" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我最好的助手法则。因为这是我最初写助手的原因。当你声明一个“false”或“true”类型的组件属性时，每个人都会很高兴。但是属性的值将是未定义的，并且属性的类型是错误的。一直都是。这种打字错误会导致很多问题，并且很难跟踪。而且，很容易犯这个错误，因为在JSON中你用“:”声明值，而在TypeScript代码中用=。这似乎是一件容易区分的事情，但有时并非如此。所以我定义了这个很好的规则。</p><h1 id="7eaf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">5.空*ngIf</h1><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="87ff" class="ml lf it mh b gy mm mn l mo mp">{<br/>“regex”: “\\*ngIf=\”\””,<br/>“message”: “ngIf can not be empty”<br/>}</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/2df49f3441c831ecababe3387ea6550d.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/1*qyNJ_Zaf7kBkUPMmTndNVA.gif"/></div></figure><p id="aa31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我曾经偶然发现过这个。但我马上想到，把它加入助理规则会很好。离开*ngIf会产生意想不到的结果，并且在默认情况下是一个错误。如果使用*ngIf，应该总会有一些条件。</p><h1 id="7dbf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">6.方括号方法</h1><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6e25" class="ml lf it mh b gy mm mn l mo mp">{<br/>“regex”: “\\(\\) \\[“,<br/>“message”: “Function body should be in curly brackets not square ones”<br/>}</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/e8ba9473523b76c62b490da7f7fe2381.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/1*TCDVJm8SCZNe3s6VprxJIw.gif"/></div></figure><p id="0951" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，您可以清楚地看到如何为Assistant编写正则表达式规则。<a class="ae kf" href="https://stackoverflow.com/a/400316/38940" rel="noopener ugc nofollow" target="_blank"> Regex特殊字符</a>如“{”需要用“\”转义。我们还需要用另一个“\”对“\”进行转义，因为“\”是JSON的特殊字符。这就是为什么我们有两个“\”。</p><p id="02fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不管怎样？这条规则告诉你什么时候创建一个方括弧内的方法体，而不是花括弧。与前面的相反，当你在Visual Studio代码中编写“method() []”时，你会在problems选项卡中得到很多错误信息，并且代码的整个部分会被加下划线。</p><p id="1b96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么为什么我增加了这条规则呢？因为显示的错误并不具体。他们说“方法”的每一行几乎都是错误的。但是他们不会告诉你的是，你用了方括号，需要修改。</p><p id="86cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我发现这个辅助规则对于了解正在发生的事情非常有用。</p><h1 id="42c9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">7.错误创建的Dayjs实例</h1><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="2b06" class="ml lf it mh b gy mm mn l mo mp">{<br/>“regex”: “new Dayjs()”,<br/>“message”: “New Dayjs() is created with dayjs() without new operator”<br/>}</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/2796e5cf864abd54b27673795b2f676d.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/1*JLMJarrXI5XUXnQM14ekgQ.gif"/></div></figure><p id="88a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个助手规则非常有趣，因为它展示了如何让使用库变得更容易。Dayjs是一个极简的日期和时间库。我发现它比Momentjs好，因为它在构建应用程序包中占用的空间少得多。</p><p id="3d05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我来说，作为一个OOP开发人员，Dayjs的一个新实例不是用“new”操作符完成的，而是用调用dayjs()方法完成的，这很烦人。由于“新”语法对我来说是默认语法，所以我决定提醒自己dayjs()是不同的，这样每次使用这个库时都可以节省一些宝贵的时间来理解它</p><h1 id="8598" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">8.错误变化检测</h1><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="9363" class="ml lf it mh b gy mm mn l mo mp">{<br/>“regex”: “if \\(\\!changes\\.”,<br/>“message”: “In ngOnChanges? It does not check if value is not provided for property”<br/>}</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/5d79693c69392d030d13d3e0b9d17756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/1*MYeePgMYM1A3_USzRchCvg.gif"/></div></figure><p id="6d85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生命周期钩子<a class="ae kf" href="https://angular.io/api/core/OnChanges" rel="noopener ugc nofollow" target="_blank"> ngOnChanges </a>是检查任何Input()属性是否已经改变的好方法。检查什么属性发生了变化是相当容易的，因为您可以编写:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3e7f" class="ml lf it mh b gy mm mn l mo mp">@Input() myProperty: boolean;<br/>@Input() completelyDifferentProperty: boolean;<br/>ngOnChanges(changes: SimpleChanges): void {<br/> …<br/> if (changes.myProperty) {<br/> this.specialMethod()<br/> }<br/>}</span></pre><p id="4cbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码很简单。但是当你回过头来决定，当myProperty为false时，你想触发specialMethod()时，你可以写:“if(！this . changes . my property)……”。这是错误的。因为它将检查检测到的更改是否不包括myProperty属性。例如，当completelyDifferentProperty值发生更改时，将调用specialMethod()。你可以看到适当的逻辑是如何从我们手中溜走的。</p><p id="44f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再说一次——每个人都会对这段代码感到满意，但它会导致非常严重且难以跟踪的问题。这就是为什么当您写“if(！idspnonenote)时，规则会通知您。变化…”</p><p id="cd83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时，您可能会考虑，为什么这些规则不够精确。因为可以用“如果(！变化)”为完全不同的场景。例如，您将在别处定义一个名为changes的变量并对其进行操作。肯定会触发这个规则。但是我喜欢做的，是为初学者写一些简单的规则，然后调整它们。因此，当我或团队成员偶然发现这种情况时，我们中的任何人都可以改进规则。</p><p id="83c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前，它包含的信息只适用于ngOnChanges，因此团队成员知道在其他地方可以忽略它。一个可能的改进是处理if()中的所有条件，而不仅仅是第一个条件。所以这是你的作业:)</p><h1 id="f6ac" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="c502" class="pw-post-body-paragraph kg kh it ki b kj nb kl km kn nc kp kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">Visual Studio代码助手非常有助于找出代码中的棘手错误。这需要一点过热，因为你需要意识到你犯了什么错误，并为它们编写正则表达式规则。但是一旦你这样做了，编码流程就会好很多。你不需要从一大堆错误中剔除一个错别字，你可以让你和你的团队更轻松，因为小错误不会导致你花费数分钟甚至数小时去发现它们。因此，编码变得更流畅，体验更好。对于linters和在构建阶段显示错误来说，这是一个很好的补充解决方案。</p><p id="7e1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi">***</p><p id="b4e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于Angular、TypeScript、React或者其他任何框架或语言，有什么有趣的助手规则可以分享吗？写下来，让我知道！我很乐意将它添加到<a class="ae kf" href="https://github.com/tomaszs/Assistant" rel="noopener ugc nofollow" target="_blank"> git </a>库和它在Visual Studio代码扩展<a class="ae kf" href="https://github.com/tomaszs/Assistant" rel="noopener ugc nofollow" target="_blank">市场</a>的页面上。</p><p id="ca15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你为这篇文章鼓掌，我会很高兴。谢谢！</p></div></div>    
</body>
</html>