<html>
<head>
<title>Lazy loading can do that?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">懒加载能做到？</h1>
<blockquote>原文：<a href="https://itnext.io/optimizing-angular-bb330ef88041?source=collection_archive---------5-----------------------#2019-05-27">https://itnext.io/optimizing-angular-bb330ef88041?source=collection_archive---------5-----------------------#2019-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/b24f64b7a79a90d758da2c456aa10e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*I7IBTjR9RETcv27qtqrCVA.png"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">快速棱角分明。</figcaption></figure><div class=""/><h1 id="ec7f" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">优化角度</h1><blockquote class="kw kx ky"><p id="746e" class="kz la lb lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc jc">优化</strong>主要是为了快速的用户体验。</p><p id="8944" class="kz la lb lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们将看看我们可以做什么类型的延迟加载，以及如何在优化角度的同时测量我们的结果。</p></blockquote><p id="7462" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">2019年6月7日更新:在<a class="mb mc ep" href="https://medium.com/u/c03affc1a047?source=post_page-----bb330ef88041--------------------------------" rel="noopener" target="_blank">的一个问题和一点研究之后，发现文章的一部分是不正确的。更准确地说，是在文章末尾谈到<strong class="lc jc">共享模块</strong>桶的部分。详见</a><a class="ae md" href="https://medium.com/@pairedprototype/wouldnt-tree-shaking-help-here-by-dropping-the-unused-components-7a17d0656eb8" rel="noopener">提问</a>和<a class="ae md" href="https://medium.com/@pairedprototype/wouldnt-tree-shaking-help-here-by-dropping-the-unused-components-7a17d0656eb8" rel="noopener">回应</a>。简而言之，有角度的产品构建树去掉了未使用的组件。</p><p id="facd" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">我们将对<strong class="lc jc">进行优化</strong>，主要是为了快速的用户体验。这意味着<strong class="lc jc">较小的包</strong>和<strong class="lc jc">不会下载<strong class="lc jc">不需要的</strong>代码。我们希望<strong class="lc jc">向</strong>发送用户<strong class="lc jc">需要的</strong>和<strong class="lc jc">不需要的</strong>字节</strong>。这样，我们的用户将会看到一个快速反应的网站，这正是他们所期待的。</p><p id="eb68" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">免责声明:<strong class="lc jc">这里不讨论服务器端渲染</strong>。我们将尝试优化在浏览器中交付和评估的javascript。</p><p id="7ba4" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">我们将看看我们可以做什么类型的延迟加载，以及如何在优化角度的同时测量我们的结果。</p><p id="e201" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">计划是这样的:我们先测量。我们会创造假设。然后我们会应用一些优化，衡量，看看假设是否正确。</p><p id="5b68" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">我已经创建了一个小的示例应用程序来进行优化。在https://github.com/gparlakov/optimizing-angular找到它</p><h2 id="05bd" class="me jz jb bd ka mf mg dn ke mh mi dp ki ly mj mk km lz ml mm kq ma mn mo ku mp bi translated">测量:</h2><p id="96e4" class="pw-post-body-paragraph kz la jb lc b ld mq lf lg lh mr lj lk ly ms ln lo lz mt lr ls ma mu lv lw lx ij bi translated">我们将使用这些工具:</p><p id="a1a2" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated"><a class="ae md" href="https://www.npmjs.com/package/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank"> Webpack捆绑包分析器</a>。这是一个工具，它从一个<code class="fe mv mw mx my b">ng build --stats-json</code>命令，即<code class="fe mv mw mx my b">dist/stats.json</code>中获取输出，并在一个非常好的图形界面中呈现出来。我们可以看到我们生产了多少个包，它们的去向和大小(Stat — <a class="ae md" href="https://www.npmjs.com/package/webpack-bundle-analyzer#stat" rel="noopener ugc nofollow" target="_blank"> raw </a>，Parsed—<a class="ae md" href="https://www.npmjs.com/package/webpack-bundle-analyzer#stat" rel="noopener ugc nofollow" target="_blank">processed</a>[<em class="lb">like after minimization】</em>和<a class="ae md" href="https://www.npmjs.com/package/webpack-bundle-analyzer#gzip" rel="noopener ugc nofollow" target="_blank"> Gzipped </a>)。这里有一个例子:</p><p id="c2de" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated"><code class="fe mv mw mx my b">ng build --prod --stats-json<br/>webpack-bundle-analyzer dist\stats.json</code></p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi mz"><img src="../Images/c5a98fbcefe811f621e7289abfbca632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ex-MzdA2u5TBGAbFsKlAAw.png"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">webpack-bundle-analyzer工具报告的屏幕截图。1.左上角—选中了“显示内容…”复选框能够2。顶部中间—主束。3.右下角—应用程序的组件。</figcaption></figure><div class="ip iq gp gr ir ni"><a href="https://gparlakov.github.io/optimizing-angular/stats/v1_eager_base_line/report.html" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jc gy z fp nn fr fs no fu fw ja bi translated">上面的交互式版本— Webpack Bundle Analyzer生成的报告。</h2></div></div></a></div><p id="3d7c" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">截图(或者如果你访问上面的链接)你会看到<code class="fe mv mw mx my b">main</code>包是迄今为止最大的——解析了1.17MB(占用了多少磁盘空间)和328KB Gzipped(估计**)。它包括angular运行时和库(@@angular - core.js，forms.js)，<code class="fe mv mw mx my b">ethers*</code>和<code class="fe mv mw mx my b">bip39*</code>，<code class="fe mv mw mx my b">primeng/components</code>——我们的UI组件和一堆更小和更大的js文件都捆绑在一起——包括我们的应用程序定制代码所在的<code class="fe mv mw mx my b">src</code>。这就回答了这个问题——为了绘制我们的应用程序，我们需要向浏览器发送多少javascript代码。</p><p id="d988" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这些是用于加密的库。我选择它们是因为我知道它们占地面积很大。它们将有助于展示优化的一个特定方面。</p><p id="d398" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated"><a class="ae md" href="https://developers.google.com/web/tools/chrome-devtools/network/" rel="noopener ugc nofollow" target="_blank">chrome dev<strong class="lc jc">网</strong>工具:</a></p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi np"><img src="../Images/d0aa88196393e644417d2f868a922991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdNolpqiSA0CErJDoSBnwQ.png"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">我们希望为最终用户优化加载时间。</figcaption></figure><p id="b4c5" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">它显示了资源(在本例中是filter to JS——注意上面的filter栏中选择的<code class="fe mv mw mx my b">JS</code>)加载的数量和速度。似乎这已经是一个快速加载的应用程序。但是考虑到只有三页内容，我认为我们可以做得更好。<br/>* *在<code class="fe mv mw mx my b">webpack-bundle-analyzer</code>报告(显示328KB main)和网络工具(显示373 KB)之间有些不一致。因为这是由angular development server ( <code class="fe mv mw mx my b">ng serve — prod</code>)提供的，我猜不同版本的gzip是原因。无论如何—我们将把报告中看到的<strong class="lc jc">包</strong>的<strong class="lc jc">大小</strong>作为<strong class="lc jc">指示</strong>到<strong class="lc jc">实际字节</strong>被<strong class="lc jc">传输</strong>并考虑到具体实现(nginx、IIS、Apache等)。)在挤压我们的包时可能会导致尺寸上的微小差异。</p><p id="77dc" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated"><a class="ae md" href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" rel="noopener ugc nofollow" target="_blank">和chrome dev工具<strong class="lc jc">性能</strong>工具</a>:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nq"><img src="../Images/466061de34b282b3bb22fc21a8010074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpE1fiXIQRMFurLtqRfQ1Q.png"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">Chrome性能工具截图。我们可以看到网络的统计数据(顶部)和我们的主线程正在做什么(底部)。</figcaption></figure><p id="f494" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">从上面的表演镜头中，我们可以看到<strong class="lc jc"> main.d72a…js </strong> bundle占用了网络的大部分空间，并且花费了大量的时间进行评估。</p><p id="8b1c" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">当<strong class="lc jc">测量</strong>时，注意使用<strong class="lc jc">隐姓埋名</strong>窗口(在Chrome和其他浏览器中的称呼)，或者禁用任何可能干扰的扩展。在我的例子中，我有两个扩展，增加了大约700 ms的测量时间。所以我所有的测量都是匿名的。</p><p id="7429" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">所有测量都是在<code class="fe mv mw mx my b">ng build</code>或<code class="fe mv mw mx my b">ng serve</code>命令中的<code class="fe mv mw mx my b">--prod</code>标志设置完成的。否则，我们将得到源地图、未混合的javascript和更多的包。</p><p id="bac2" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">综上所述，这是我们的基线:</p><h2 id="9b42" class="me jz jb bd ka mf mg dn ke mh mi dp ki ly mj mk km lz ml mm kq ma mn mo ku mp bi translated">基线</h2><p id="7c29" class="pw-post-body-paragraph kz la jb lc b ld mq lf lg lh mr lj lk ly ms ln lo lz mt lr ls ma mu lv lw lx ij bi translated">好了，我们有了我们的基线:<br/> <strong class="lc jc"> 1.17MB </strong>大小的<strong class="lc jc">main . js</strong>(328k gzipped)<br/><strong class="lc jc">830 ms</strong>加载时间。<br/> <strong class="lc jc"> 217ms </strong>评测main.js <br/>现在到了有趣的部分——优化。</p><h2 id="9155" class="me jz jb bd ka mf mg dn ke mh mi dp ki ly mj mk km lz ml mm kq ma mn mo ku mp bi translated">惰性负载</h2><p id="b98a" class="pw-post-body-paragraph kz la jb lc b ld mq lf lg lh mr lj lk ly ms ln lo lz mt lr ls ma mu lv lw lx ij bi translated">假设:延迟加载将有助于加快初始引导时间，加快用户体验。</p><p id="fe58" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">惰性加载是一种技术，只加载需要的模块，其余的留在服务器上，直到需要时再加载。比如我们的app有<strong class="lc jc">首页</strong>模块、<strong class="lc jc">登录</strong>模块、<strong class="lc jc">个人</strong>模块。每一个登陆首页的人都需要<strong class="lc jc">首页</strong>模块。但并不是每个人都会登录或使用个人资料页面。因此登录和个人模块将保留在服务器上，直到用户真正请求使用它们。这样，我们可以保持应用程序快速加载，并保存用户的数据计划。(同样，这个示例应用程序很小，有点做作，但相信我，我说得有道理)。</p><p id="4d9e" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">最初，我们在应用程序开始时就急切地加载了所有的模块和组件。因此，构建只创建了一个包——main . js——并将所有东西——供应商代码和我们的定制代码——连接到其中。我们最初的app-routing.module和app.module如下所示:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">请注意我们是如何在AppModule中导入LoginModule和PersonalModule的，在AppRoutingModule中我们直接路由到LoginComponent和PersonalComponent。</figcaption></figure><p id="a68c" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">为了指示我们的捆绑器(Webpack)为<code class="fe mv mw mx my b">personal</code>和<code class="fe mv mw mx my b">login</code>模块创建单独的捆绑包，我们不需要在我们的<code class="fe mv mw mx my b">app.module</code>中导入这些模块，而是使用特殊语法来延迟加载它们<em class="lb">(当然这是@angular/router的特殊语法，告诉angular延迟加载哪些模块)</em>:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">在app.module中，我们删除了登录和个人模块的导入。并在app-routing.module中添加了特殊语法</figcaption></figure><p id="95b1" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这足以导致两个新的包不会在第一个请求时立即加载。如果我们执行<code class="fe mv mw mx my b">ng build</code>和<code class="fe mv mw mx my b">webpack-bundle-analyzer</code>工具程序，我们会得到:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nq"><img src="../Images/26f13dab358b89b16855b4f9c8f691d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rT_vW4VRPOJaPCGNk96sg.png"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">请注意我们是如何将main.js包减半的。互动版:<a class="ae md" href="https://gparlakov.github.io/optimizing-angular/stats/v1_eager_base_line/report.html" rel="noopener ugc nofollow" target="_blank">https://gparlakov . github . io/optimizing-angular/stats/v2 _ lazy/report . html</a></figcaption></figure><p id="e074" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">如果我们测量网络，我们会得到:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nt"><img src="../Images/d6a9d04508e0c04f4034b53a1b502089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qGrJQi_5JpZa8R2hY-teQ.png"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">chrome网络开发工具的截图，显示了下载的js的大小和加载时间。</figcaption></figure><p id="fe89" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">运行性能工具，我们得到:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nu"><img src="../Images/7fe19e4975f3c3e6d384e173d2208718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uaiCgVf1PiwQSJ_am4IuVA.png"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">js执行时间为183毫秒的截图(每次尝试都会有所不同)</figcaption></figure><p id="58fc" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated"><strong class="lc jc">结果</strong></p><p id="bf0b" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated"><strong class="lc jc"> 455KB </strong>大小的<strong class="lc jc">main . js</strong>(126k gzipped)<br/><strong class="lc jc">~ 600 ms</strong>加载时间。(25%缩减)<br/><strong class="lc jc">183毫秒</strong>评估main.js (~20%)缩减</p><blockquote class="kw kx ky"><p id="f7d4" class="kz la lb lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">假设:延迟加载有助于加快初始引导时间，加快UX。</p></blockquote><p id="5960" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">假设被证实。</p><p id="626e" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">好吧，我们有进展了。请记住，当我们导航到<code class="fe mv mw mx my b">/login</code>和/或<code class="fe mv mw mx my b">/personal</code>时，我们必须为网络和javascript付出“代价”。尽管如此，在我们的主页上，我们已经大大加快了UX的速度。</p><h2 id="07e7" class="me jz jb bd ka mf mg dn ke mh mi dp ki ly mj mk km lz ml mm kq ma mn mo ku mp bi translated">大型依赖关系</h2><p id="95e9" class="pw-post-body-paragraph kz la jb lc b ld mq lf lg lh mr lj lk ly ms ln lo lz mt lr ls ma mu lv lw lx ij bi translated">接下来，我们可以看看<strong class="lc jc">个人</strong>模块。其中，它允许创建一个加密钱包。因为这就是我们的示例应用程序所处理的——加密！(这看起来可能有点做作，但我实际上不得不在优化一个生产应用程序时处理类似的设置—<a class="ae md" href="https://propy.com" rel="noopener ugc nofollow" target="_blank">https://propy.com</a>——在那里用crypto购买房地产是一件事。)</p><p id="6ccb" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated"><strong class="lc jc">个人</strong>模块依赖于<code class="fe mv mw mx my b">ethers</code>和<code class="fe mv mw mx my b">bip39</code>及其依赖关系，但仅在用户创建钱包时使用。这种情况通常在用户使用我们的应用程序时发生一次。永远不会。如果我们能指示Webpack为它们创建一个单独的包，并且只在需要的时候加载它，那就太好了。事实证明我们可以。简而言之，当使用<code class="fe mv mw mx my b">import()</code>来指示Webpack将这些模块视为惰性加载模块时，我们可以使用一种语法。我们需要将我们的<code class="fe mv mw mx my b">tsconfig.json</code>模块设置为<code class="fe mv mw mx my b">esNext</code>(或<code class="fe mv mw mx my b">commonjs</code>)以便成功构建Typescript。</p><p id="e1bf" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated"><strong class="lc jc">假设</strong> <em class="lb"> : </em>我们可以通过将很少使用和非常大的依赖项分离到自己的捆绑包中，来进一步提高我们的应用程序的感知速度。并且仅在需要时加载它们。</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">注意我们是如何在第19行和第20行导入ethers和bip39的(而不是在ts导入的第2行和第3行)。另外，请注意import()语句中的注释。它通知Webpack决定将什么分离到同一个包中。</figcaption></figure><p id="d736" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">所以现在在<code class="fe mv mw mx my b">ng build --prod --stats-json</code>之后运行我们的<code class="fe mv mw mx my b">webpack-bundle-analyzer</code>工具，我们得到:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nq"><img src="../Images/c2843e41cc1eb8b93811a0d4c20b1a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmMNPJoLQAyGZB6kh_ObKQ.png"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">显示bip39_ethers包(大小为622KB)、个人ng(大小为26KB)和登录(大小为8KB)的屏幕截图。互动版:<a class="ae md" href="https://gparlakov.github.io/optimizing-angular/stats/v3-lazier/report" rel="noopener ugc nofollow" target="_blank">https://gparlakov . github . io/optimizing-angular/stats/v3-lazier/report</a></figcaption></figure><p id="923e" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">所以现在我们只在用户决定创建一个新的钱包时才加载这个依赖项。</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nv"><img src="../Images/76e64426305f7be47fb91027a33afa0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTDSIL8mMH3y7tS7YKuy9w.png"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">选择了“创建钱包”选项卡的“<code class="fe mv mw mx my b">/personal’</code>页面的屏幕截图。bip39_ethers包尚未下载。</figcaption></figure><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nv"><img src="../Images/787305bfb2e5ea5e54c008a4b54be334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JACX6gLBCxmWd1fyc785w.png"/></div></div><figcaption class="iv iw gj gh gi ix iy bd b be z dk translated">点击“为我创建一个钱包”按钮后的屏幕截图:“bip39_ethers”捆绑包刚刚下载完毕。</figcaption></figure><p id="c2a0" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">我们没有改变初始javascript或页面加载时间的大小，但是我们通过将大量依赖推迟到最后一刻，为大量用户节省了大量数据。</p><blockquote class="kw kx ky"><p id="f3f0" class="kz la lb lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc jc">假设</strong> <em class="jb"> : </em>我们可以通过将很少使用和非常大的依赖项分离到它们自己的捆绑包中，来进一步提高我们的应用程序的感知速度。并且仅在需要时加载它们。</p></blockquote><p id="a5e6" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">假设被证实了。</p><h2 id="4ff1" class="me jz jb bd ka mf mg dn ke mh mi dp ki ly mj mk km lz ml mm kq ma mn mo ku mp bi translated"><strong class="ak">“共享”桶</strong></h2><p id="56b6" class="pw-post-body-paragraph kz la jb lc b ld mq lf lg lh mr lj lk ly ms ln lo lz mt lr ls ma mu lv lw lx ij bi translated">2019年6月7日更新:以下事实证明是不正确的。参见更新置顶和<a class="ae md" href="https://medium.com/@gparlakov/after-a-bit-of-research-heres-the-result-in-this-github-repo-1804df5e8373" rel="noopener">对<a class="ae md" href="https://medium.com/@pairedprototype/wouldnt-tree-shaking-help-here-by-dropping-the-unused-components-7a17d0656eb8" rel="noopener">问题</a>的回复</a>:</p><p id="5563" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">接下来，我想提一下共享模块。这是一个模块，获得所有将在我们的应用程序中共享的组件。为了保持<a class="ae md" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干燥</a>(我真的很讨厌这个原则，因为它经常导致灾难)，我们开发人员试图保持所有东西的可重用性。可重用==共享。在共享文件夹中创建新的共享组件。由于它在<strong class="lc jc"> /shared </strong>文件夹中，所以让我们在<strong class="lc jc"> shared </strong>模块中声明并导出它。有道理——对吗？</p><p id="f752" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">猴子看，猴子做，团队中的每个人都这样做。很明显是共享组件。放入<strong class="lc jc">/共享</strong>模块。在我们的应用程序中，共享模块中有两个组件。我一个人花了几个小时创造了它。其中之一——菜单组件是，它是我们的<a class="ae md" href="https://github.com/gparlakov/optimizing-angular/blob/19c2687bca586f67d43ac1c32926c0f1615d944b/src/app/app.module.ts#L17" rel="noopener ugc nofollow" target="_blank">根组件的模块</a>的依赖项。</p><p id="1d90" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">想象几个月的团队工作。<strong class="lc jc">共享的</strong>模块现在有数百个声明的组件。但是我们的应用程序组件只需要其中的一两个——其余的由特性模块使用。尽管如此，我们的主模块将导入并构建组件，我们的主包将包含所有代码。所以现在如果你想得到香蕉，你得到香蕉和猴子，拿着它和整个丛林！</p><p id="ab54" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">我们如何避免这种情况？我无法给出简单的答案。我的团队在撰写本文时遇到了这种情况，我们正在处理它:</p><ol class=""><li id="f336" class="nw nx jb lc b ld le lh li ly ny lz nz ma oa lx ob oc od oe bi translated">意识——告诉整个团队这是一个问题，以及为什么这是一个问题。</li><li id="e62d" class="nw nx jb lc b ld of lh og ly oh lz oi ma oj lx ob oc od oe bi translated">用自己的<strong class="lc jc">模块</strong>在<strong class="lc jc">/共享文件夹</strong>中创建<strong class="lc jc">新组件</strong>。现在任何需要它们的模块都可以导入它们。</li><li id="1ad2" class="nw nx jb lc b ld of lh og ly oh lz oi ma oj lx ob oc od oe bi translated"><strong class="lc jc">通过从<strong class="lc jc">共享模块</strong>中取出组件<strong class="lc jc">并将它们移动到它们自己的<strong class="lc jc">模块</strong>中，来修剪</strong>共享模块</strong>的多余部分。一次一个组件。这需要时间，但是值得。</li></ol><p id="675c" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">(你是做什么的——在评论里分享。)</p><p id="4eaa" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这里的假设是，如果团队中的每个人都意识到这个问题，并且我们一起努力，我们会一点一点地找到解决方案。</p><p id="9037" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">没有证据证明这一点，除此之外:我看到我的队友尽最大努力改善这种情况，并利用一切机会分离模块。我相信我们会成功的。一次一个模块。</p><p id="5163" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">2019年6月7日更新:一些困惑似乎源于这样一个事实，即我们使用的这个<code class="fe mv mw mx my b">shared</code>模块包含许多服务和组件。他们不会动摇。在这里可以看到一些未使用的服务仍然是大块的一部分<a class="ae md" href="https://github.com/gparlakov/tree-shake-angular/blob/7a0be3ce25ca85d1aecd244edb8c76a8d276ee45/dist/0.d59e8e1ca40426dafa22.chunk.js#L86-L91" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h2 id="c532" class="me jz jb bd ka mf mg dn ke mh mi dp ki ly mj mk km lz ml mm kq ma mn mo ku mp bi translated">概括一下:</h2><p id="cf1d" class="pw-post-body-paragraph kz la jb lc b ld mq lf lg lh mr lj lk ly ms ln lo lz mt lr ls ma mu lv lw lx ij bi translated">我们从一个<strong class="lc jc">急切地</strong>加载的应用程序开始，并设法将它分割成惰性加载模块。通过这种方式，我们潜在地提高了应用的感知性能，或者用技术术语来说:<strong class="lc jc"> snappyness </strong>。我们设法查明并进一步分离出很少使用的和大量的依赖项。这样可以保存用户的数据。我们谈了一点关于“共享”模块(水桶，如果你喜欢的话，厨房水槽)，以及为什么它是应用程序的敌人，因为它可以通过干净的依赖树被隔离到懒惰的加载模块。</p><p id="33de" class="pw-post-body-paragraph kz la jb lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">如果你想尝试一下，一步或更多，你可以。我已经标记了这些步骤:<a class="ae md" href="https://github.com/gparlakov/optimizing-angular/releases/tag/1-eager" rel="noopener ugc nofollow" target="_blank">1-渴望</a>，<a class="ae md" href="https://github.com/gparlakov/optimizing-angular/releases/tag/2-lazy" rel="noopener ugc nofollow" target="_blank">2-懒惰</a>，<a class="ae md" href="https://github.com/gparlakov/optimizing-angular/releases/tag/3-lazier" rel="noopener ugc nofollow" target="_blank">3-懒惰</a>，<a class="ae md" href="https://github.com/gparlakov/optimizing-angular/releases/tag/4-deshareify" rel="noopener ugc nofollow" target="_blank">4-去沙雷化</a>。</p></div></div>    
</body>
</html>