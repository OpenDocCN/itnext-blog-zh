<html>
<head>
<title>Advantages of Git Rebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git Rebase的优势</h1>
<blockquote>原文：<a href="https://itnext.io/advantages-of-git-rebase-af3b5f5448c6?source=collection_archive---------1-----------------------#2019-08-09">https://itnext.io/advantages-of-git-rebase-af3b5f5448c6?source=collection_archive---------1-----------------------#2019-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d45f4489e1f23bc7bc9356c411cd7156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TCeGG7hlFL8qHIZRlO3Mg.jpeg"/></div></div></figure><p id="a390" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关于<em class="kz"> git rebase </em>的一篇文章鼓励不要这么做。本文建议重定基础的唯一目的是获得一个好看的git日志历史。</p><blockquote class="la lb lc"><p id="dd85" class="kb kc kz kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated">我得出的结论是，这是虚荣心作祟。重置基础是一个纯粹的美学操作。</p></blockquote><p id="b57c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想列出几个好理由，说明为什么在我看来，改变基础是一个好的实践，可以给你的工作流带来很多好处。</p><h1 id="df76" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">rebase是什么意思？</h1><p id="844e" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">假设您有一个正在处理的特性分支，以及一个从其分支出来的主分支。您应该有这样的日志历史:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="79ce" class="ms lh it mo b gy mt mu l mv mw">$ git log --graph --oneline</span><span id="58e7" class="ms lh it mo b gy mx mu l mv mw">* f7d389gc (feature) — lorem ipsum<br/>* 6hy982dx — dolor sit<br/>* aer3ou71 — amet consecutur<br/>* nfk62s3z (master) — adipiscing elit<br/>* …</span></pre><p id="fa24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设你没有独自完成这个项目，其他开发人员正在为代码库做贡献。因此，当您处理您的分支时，主分支已经在远程git服务器上向前移动了。</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/3fabf891ef0131bf9cb1bfe13d9cad5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8LUeJZhpp80Ed77U1D9_Q.jpeg"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">git rebase —图1</figcaption></figure><p id="bd43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了继承在主分支上引入的变更，您可以改变基础，基本上将您的提交移动到主分支之上。<br/>假设您的特性分支名为<code class="fe nd ne nf mo b">feature</code>，您可能想要运行:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="20bc" class="ms lh it mo b gy mt mu l mv mw">$ git checkout feature<br/>$ git rebase master</span></pre><p id="10aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在重定基础过程之后，您可能会有如下状态:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="cd6c" class="ms lh it mo b gy mt mu l mv mw">* e2r3fa05 (feature) — lorem ipsum<br/>* qc85lx4w — dolor sit<br/>* ui9o7xpa — amet consecutur<br/>* i52dxqs3 (master) — proin sagittis<br/>* nfk62s3z — adipiscing elit<br/>* …</span></pre><h1 id="68cc" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">副作用</h1><p id="8e3e" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在git中，所有提交(除了初始提交)都包含对其父提交的引用。git在重定基础时所做的是，在分支提交历史的第一次提交中更改对父级的引用，这与主分支历史不同(在我们的例子中是<code class="fe nd ne nf mo b">aer3ou71</code>)。</p><p id="9aa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑每个提交的散列是几个组件散列的结果，其中包括父提交的散列。</p><p id="b7e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，假设新的父对象的散列将会不同，我们的重定基础提交将会得到一个新的散列。属于我们分支历史的其他提交也是如此。你可以在上面的片段中看到。</p><p id="0e46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果在运行rebase命令之前已经将分支推送到远程，您应该考虑这一点。在这种情况下，您的远程提交散列将与本地提交散列不同，所以如果现在您只是运行<code class="fe nd ne nf mo b">git push </code>，您将得到一个错误，说明操作无法完成，因为您的分支的本地和远程版本有分歧。为了解决这个问题，你只需要用力:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1db5" class="ms lh it mo b gy mt mu l mv mw">git push --force-with-lease</span></pre><h1 id="dde9" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">好的，明白了。但是我为什么要重定基数呢？</h1><p id="a42d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">我有三个理由来说明为什么它值得争论。</p><p id="6ed8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">增加测试可靠性</strong></p><p id="ac3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再看一下图1。如果您在重新基础化之前在您的特性分支上运行您的测试(左边的图)，您没有在您的代码基础中包括master的最后3次提交，所以您不能确定您的测试没有受到它们的影响。</p><p id="f754" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，如果您的测试通过了，您不确定在将您的分支合并到主测试中之后，它们是否还会通过。</p><p id="e37e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相反，重定基础允许您从master的最新提交中继承代码。</p><p id="fb85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">使调试更容易</strong></p><p id="b214" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想将应用程序回滚到以前的版本，以检查哪里引入了错误，如果您有一个干净的历史记录，您可以很容易地做到这一点。</p><p id="0e38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在提交可以有多个父提交的“意大利面条”历史中，主分支包含带代码的提交和合并提交，要发现引入bug的提交是非常棘手的。</p><p id="bd31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在我的另一篇文章“<a class="ae ng" href="https://medium.com/@alessiopieruccetti/the-importance-of-making-meaningful-commits-fd68e869f185" rel="noopener">有意义提交的重要性</a>”中更详细地解释了这个话题，因为有意义地提交也有助于这个操作。</p><p id="4e1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">合并前解决冲突</strong></p><p id="ffac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决冲突可能是痛苦和无聊的，尤其是当特性花了太长时间才准备好，并且它影响了代码库的许多不同部分时。</p><p id="9fc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你一下子解决了所有的冲突，解决起来可能会很棘手。相反，如果您在重定基时解决了冲突，git将提示冲突消息commit by commit，因此跟踪更改并找出如何解决冲突会更容易。</p><h1 id="98fd" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">小澄清</h1><p id="ced5" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在反对git rebase的同一篇文章中，我发现了一个让我高兴的说法:</p><blockquote class="la lb lc"><p id="99b9" class="kb kc kz kd b ke kf kg kh ki kj kk kl ld kn ko kp le kr ks kt lf kv kw kx ky im bi translated">通过调整基数，你是在欺骗自己和你的团队。你假装提交是今天写的，而事实上它们是昨天写的…</p></blockquote><p id="9c29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不确定这是什么意思，我猜这是因为作者在他的提交历史中或者可能在Github上看到的是最后的修改日期而不是创建日期。</p><p id="d0dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Git保存创建日期和最后修改日期:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="84c7" class="ms lh it mo b gy mt mu l mv mw">git show 007e3ae</span><span id="f2c2" class="ms lh it mo b gy mx mu l mv mw">commit 007e3ae4ab751f8ab2d9cebef87983a320399acc<br/>Author:     Alessio Pieruccetti &lt;<a class="ae ng" href="mailto:alessio@xxx.com" rel="noopener ugc nofollow" target="_blank">alessio@xxx.com</a>&gt;<br/>AuthorDate: Tue Jul 23 10:26:39 2019 +0100<br/>Commit:     Alessio Pieruccetti &lt;<a class="ae ng" href="mailto:alessio@xxx.com" rel="noopener ugc nofollow" target="_blank">alessio@xxx.com</a>&gt;<br/>CommitDate: Fri Aug 9 09:14:20 2019 +0100</span><span id="97c4" class="ms lh it mo b gy mx mu l mv mw">      Replaced exception type in User class</span></pre><p id="b06c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有几种不同的方法来显示提交历史中的创建日期，例如:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3c23" class="ms lh it mo b gy mt mu l mv mw">git log --pretty=fuller</span></pre><p id="72cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我的<code class="fe nd ne nf mo b">.gitconfig</code>里我有一个<code class="fe nd ne nf mo b">git history</code>的别名，像这样:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c82b" class="ms lh it mo b gy mt mu l mv mw">[alias]<br/>    history = log --graph --pretty=format:'%Cred%h%Creset %d -%Cblue %s%Creset %Cgreen(%ar) %Cblue&lt;%an&gt;%Creset' --abbrev-commit --date=relative</span></pre><p id="7a7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将显示您的日志很好地与相对创建日期(如<code class="fe nd ne nf mo b">2 days ago</code>)。</p><h1 id="9ae3" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="788c" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在我们的工作中，我经常发现有人支持或鄙视这个或那个工具/编程语言/实践。我认为每个工具都适用于某些环境。</p><p id="fd02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我阅读了反对TDD、敏捷开发等的文章。我的观点是，这些实践对于某些环境或产品来说很棒，但对于其他环境或产品来说可能会失败。</p><p id="b45d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">git工具也是如此。</p><p id="8f4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不想说服你用git rebase，只是想指出它有一些优点，还有git merge。使用哪一个取决于你，取决于你的经验，你对工具的信心以及你如何与你的队友合作。</p><p id="aa63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这有所帮助。</p></div></div>    
</body>
</html>