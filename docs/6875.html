<html>
<head>
<title>Observability, Part 2 Tracing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可观察性，第2部分跟踪</h1>
<blockquote>原文：<a href="https://itnext.io/observability-part-2-tracing-1537e8d79933?source=collection_archive---------0-----------------------#2022-03-29">https://itnext.io/observability-part-2-tracing-1537e8d79933?source=collection_archive---------0-----------------------#2022-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/37c1b009587c9a7730a7dbcb62bfb3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55LgdJeqcyxVU-6LRqO2tQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Grafana速度的节点图视图</figcaption></figure><p id="9124" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我最初的计划是涵盖我们用来收集普罗米修斯指标的许多出口商，这也是第1部分开始的地方。但是，我会根据我目前玩的游戏做一点调整。我将很快回到这项任务上来。然而这东西太酷了，不能等。</p><p id="aa43" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于那些读过我以前文章的人来说，你知道我最近一直在进行一项观察任务。我们已经在Grafana Stack (Grafana，Prometheus，Loki)上全押了，现在正在增加节奏。这将涵盖我们试图解决的所有三个可观察性领域:日志(Loki)、度量(Prometheus)和现在的跟踪(Tempo)。</p><p id="4c73" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我简要介绍了我们对<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/loki-to-the-rescue-7c3cc0989a7"> Loki </a>的使用，并将在未来继续探索。<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/observability-part-1-intro-postgres-exporter-efe57ee2d534">第一部分</a>和<a class="ae ld" href="https://medium.com/analytics-vidhya/trending-gitlab-iteration-data-in-prometheus-4ca78749e6b0" rel="noopener"> Gitlab Prometheus exporter </a>展示了一点我们的Prometheus用法。现在是三脚架的最后一脚，拍子。</p><h1 id="9b11" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">追踪，快速入门</h1><p id="f619" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">对于那些可能不熟悉跟踪或者听说过跟踪但不知道行话的人来说，这部分是以一种EIL5的方式为你准备的。</p><h2 id="2980" class="mh lf it bd lg mi mj dn lk mk ml dp lo kq mm mn ls ku mo mp lw ky mq mr ma ms bi translated">技术</h2><p id="cbee" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">有多种技术可以让你完成从Zipkin到Jaeger到OpenCensus和may付费选项的追踪。这些开源技术中的许多都被<a class="ae ld" href="https://opentelemetry.io/" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry </a>决定或吸收。OpenTelemetry(简称Otel)是CNCF 的一个<a class="ae ld" href="https://www.cncf.io/projects/opentelemetry/" rel="noopener ugc nofollow" target="_blank">孵化项目，目前有很多活跃的开发。Otel支持大量现成的语言。每种语言对日志、指标和跟踪都有不同的支持。他们正试图将所有3个标准化成通用的包和支持，以使可观察性变得容易！</a></p><h2 id="711b" class="mh lf it bd lg mi mj dn lk mk ml dp lo kq mm mn ls ku mo mp lw ky mq mr ma ms bi translated">条款</h2><p id="48c7" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated"><strong class="kh iu">跟踪</strong> —跟踪是应用程序正在进行的从开始到结束的活动。这方面的一个例子是被访问的API端点。</p><p id="b7d4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">Span</strong>—Span是跟踪的一部分，可以是内部函数、数据库查询或程序完成动作的其他离散活动(也称为跟踪)</p><p id="b33c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">自动插装</strong> — Otel提供了许多不同代码领域的自动插装，但这实际上取决于您使用的语言。</p><h1 id="b634" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">Python应用入门</strong></h1><p id="770e" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">在这篇文章中，我使用了一个Python FastAPI应用程序。这个应用程序是一个API，它有许多端点，并使用SQLAlchemy进行数据库访问。</p><p id="5843" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我通过docker-compose.yaml文件运行所有这些，该文件中有Postgres、Grafana、Tempo、Loki和我的应用程序。</p><h2 id="6a41" class="mh lf it bd lg mi mj dn lk mk ml dp lo kq mm mn ls ku mo mp lw ky mq mr ma ms bi translated">添加依赖项</h2><p id="295f" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">您需要在您的机器、venv、容器等上安装OpenTelemetry模块。我个人使用pip来安装这些，并让它处理所有其他需求，但这些将让您继续工作，并将为OpenTelemetry带来API和SDK</p><ul class=""><li id="4dc3" class="mt mu it kh b ki kj km kn kq mv ku mw ky mx lc my mz na nb bi translated">opentelemetry-exporter-otlp</li><li id="08e0" class="mt mu it kh b ki nc km nd kq ne ku nf ky ng lc my mz na nb bi translated">open telemetry-instrumentation-fast API</li><li id="dea2" class="mt mu it kh b ki nc km nd kq ne ku nf ky ng lc my mz na nb bi translated">开放式遥测-仪器-记录</li><li id="1a2a" class="mt mu it kh b ki nc km nd kq ne ku nf ky ng lc my mz na nb bi translated">开放式遥测-仪器-sqlalchemy</li></ul><p id="6195" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">安装后，您可以将它们添加到您的代码中:</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="8d6a" class="mh lf it bd lg mi mj dn lk mk ml dp lo kq mm mn ls ku mo mp lw ky mq mr ma ms bi translated">启用自动检测</h2><p id="35b9" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">这将为您提供一个跟踪ID和一两个跨度，但没有我个人所希望的那么详细，但是我将在下面的部分中介绍这一点！</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8179" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，我在docker-compose中发送到本地速度，因此您可能需要根据您的速度安装或OtelCollector进行必要的调整，如果您走这条路线的话。</p><h2 id="565f" class="mh lf it bd lg mi mj dn lk mk ml dp lo kq mm mn ls ku mo mp lw ky mq mr ma ms bi translated">对我个人来说缺失的一环</h2><p id="7a92" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">我想，嘿，这太棒了，都完成了，但不是为我个人。我从未在日志中看到任何traceIDs。对我来说，缺少的部分是确保“包含日志记录”，然后在我的API内部调用logging.info(“一些文本”)。</p><p id="75a8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为我们正在使用来自Otel的LoggingIntrumentation，它将把跟踪id和跨度id添加到日志行中，如下所示。第一行是日志调用，第二行是它的输出。</p><p id="4fcb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">logging.info("调用配置API ")</p><p id="3554" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">2022–03–29 15:01:27，658 INFO[root][relationships . py:366][trace _ id = 041 de 13035424 b 97 CBD 2 DC 81 BBC 2c DBC 5 span _ id = AE 96466432775 bb 7 resource . service . name = cloud api]—调用配置API</p><p id="ebac" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果没有日志行(默认情况下我没有)，您将看不到trace_id。</p><h2 id="078e" class="mh lf it bd lg mi mj dn lk mk ml dp lo kq mm mn ls ku mo mp lw ky mq mr ma ms bi translated">以速度查看轨迹</h2><p id="b39d" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">一旦你有了你的trace ID，你就可以通过Grafana把这个ID输入到Tempo中。导航到Grafana的Explore部分，选择速度数据源，输入Trace ID并点击“运行查询”</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/50797c33750f233fb17df913b35efd5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*7SDsQnNiPg5pwa5m-OAHsA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">查询跟踪ID</figcaption></figure><p id="735b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您也可以让Loki识别日志中的跟踪id，并通过衍生栏提供直接指向速度的链接。您将把它添加到Loki数据源，如下所示。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/7a5601ece19a1e116140d932227470a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KKdH2OmxYzxgVpbqE8P7A.png"/></div></div></figure><h2 id="cec4" class="mh lf it bd lg mi mj dn lk mk ml dp lo kq mm mn ls ku mo mp lw ky mq mr ma ms bi translated">添加对SQLAlchemy的支持</h2><p id="4afa" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">如果你注意到在我们上面的includes部分，我们用OpenTelemetry增加了对SQLAlchemy的支持。要实现这种支持，非常简单，只需在运行create_engine命令后添加一行即可(如下面的engine=行所示)</p><p id="325f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">engine = sqlalchemy . create _ engine(DB _ URL)</p><p id="b1cd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">SQLAlchemyInstrumentor()。仪表(发动机=发动机，)</p><p id="fd1c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，您将看到应用程序通过SQLAlchemy与数据库对话的时间跨度</p><h1 id="1d8b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">增加更有价值的跨度</h1><p id="47f6" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">自动检测获得了一些流向Tempo的数据，这很有价值，但我希望看到我正在运行的不同函数的跨度，以便我可以了解这些函数对性能的影响，并从性能角度隔离我需要攻击的地方。</p><p id="5519" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是通过创建一个新的span，然后用with语句包装函数调用来实现的。</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9a77" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以在任何想要添加额外跨度的地方添加这些，这样您就可以在任何需要的地方添加。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/4e05c6422996a9e1e1842e2d3544d606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJ2f0hhlxHuinpJSBnrFEg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">完全装备的API调用</figcaption></figure><h1 id="f8a2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">摘要</h1><p id="6695" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">这是我第一次尝试追踪，总之只花了几个小时。大部分时间都花在了试图弄清楚我必须在我想要检测的API中有一个日志行上。一旦我发现了那块宝石，就一帆风顺了。</p><p id="c4eb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我确信我只是触及了这里的表面，但是想分享一下我目前为止的发现。</p><p id="0a18" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">希望你觉得这有用，如果是这样，给我一个关注和鼓掌！</p></div></div>    
</body>
</html>