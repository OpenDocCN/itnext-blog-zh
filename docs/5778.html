<html>
<head>
<title>Adding State to Custom HTML Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向自定义HTML元素添加状态</h1>
<blockquote>原文：<a href="https://itnext.io/adding-state-to-custom-html-elements-639961c7c529?source=collection_archive---------3-----------------------#2021-05-23">https://itnext.io/adding-state-to-custom-html-elements-639961c7c529?source=collection_archive---------3-----------------------#2021-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c75" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有状态管理的反应式HTML元素？深入web组件的世界。</h2></div><p id="f0aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将使用状态管理和事件处理程序创建自己的HTML元素框架。我们将通过实际例子探索Web组件的世界。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/8b3bfbfea7062b4ef8c825be519d7bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C_Lu9H0XX-pUOBKw"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">由<a class="ae lu" href="https://unsplash.com/@cgower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托弗·高尔</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="706c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是HTML自定义元素？</h1><p id="298c" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">首先，我们来了解一下自定义元素。如果您已经知道它们是什么，请随意跳过文章的这一部分，继续下面的<em class="ms">向定制元素添加状态</em>。</p><p id="000a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自定义元素是2011年引入的Web组件的一部分。这与影子DOM和HTML模板一起。让我们深入一些，边开发边学习！</p><h2 id="70fe" class="mt lw it bd lx mu mv dn mb mw mx dp mf kr my mz mh kv na nb mj kz nc nd ml ne bi translated">创建第一个自定义元素</h2><p id="9676" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">自定义元素是控制HTML元素的JavaScript类。假设我们想为按钮<code class="fe nf ng nh ni b">&lt;my-button&gt;&lt;/my-button&gt;</code>添加一个定制的HTML元素，我们可以用下面的方法来实现。</p><p id="6dcf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们定义一个类<code class="fe nf ng nh ni b">MyButton</code>，它扩展了<code class="fe nf ng nh ni b">HTMLElement</code>类。它需要一个调用超级构造函数的构造函数。</p><p id="a8aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后使用<code class="fe nf ng nh ni b">customElements</code> API，我们可以为我们的类定义一个定制的HTML标签。<code class="fe nf ng nh ni b">customElements.define('html-tag', ComponentClass);</code>。</p><p id="3f12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们的HTML组件已经可以使用了！只需在网页上添加一个<code class="fe nf ng nh ni b">&lt;my-button&gt;&lt;/my-button&gt;</code> HTML标签。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5706" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">试一试并运行它。你会看到什么都没发生。这是因为我们还没有在这个HTML元素中做任何事情。</p><h2 id="08f4" class="mt lw it bd lx mu mv dn mb mw mx dp mf kr my mz mh kv na nb mj kz nc nd ml ne bi translated">使用阴影DOM</h2><p id="70e5" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">使用<em class="ms">影子DOM </em>和它的API可以操作这个组件的DOM。不通过影子DOM，我们不能直接修改这个定制元素的内容。</p><p id="86bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，<code class="fe nf ng nh ni b">this.attachShadow({mode: "open"});</code>将返回这个组件的一个影子Dom根节点。</p><p id="957d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用这个影子根来更新它的<code class="fe nf ng nh ni b">innerHTML</code>，添加孩子，等等。任何DOM操作都是可能的。</p><p id="4e5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们更新我们的组件，以实际显示一个按钮。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d9e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们现在试一试，我们实际上会在页面上看到一个<code class="fe nf ng nh ni b">&lt;my-button&gt;</code>元素。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/0506747b873c00cfe07770a63c7cca07.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*0WanSJIyJJX9DE7bCOCbug.png"/></div></figure><p id="f848" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们的第一个HTML定制元素！</p><h1 id="492e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">向自定义元素添加状态</h1><p id="17e7" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们前面的例子有点简单。就我们所见，定制元素本质上是非常原始和空洞的。使用它可以做任何事情，但是，这种灵活性也使得HTMLElement类非常抽象。</p><p id="0a3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想包含类似react的状态管理，该怎么办？如果我们想有一个更干净的方法来更新组件的HTML呢？我们可以很容易地扩展<code class="fe nf ng nh ni b">HTMLElement</code>类来为我们处理更多的事情。</p><h2 id="7343" class="mt lw it bd lx mu mv dn mb mw mx dp mf kr my mz mh kv na nb mj kz nc nd ml ne bi translated">我们的目标是什么？</h2><p id="ba78" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">先介绍状态管理。我们想让它做什么？我们希望能够<code class="fe nf ng nh ni b">getState(path)</code>和<code class="fe nf ng nh ni b">setState(path, value)</code>。每当状态改变时，我们也想重新呈现我们的元素。一种方法是将组件的呈现抽象成一个<code class="fe nf ng nh ni b">render</code>方法。到目前为止，API都是受React的启发。</p><p id="9d04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开始之前，我们需要为我们的元素取一个名字。让我们来看看这个，把我们的自定义元素类叫做<code class="fe nf ng nh ni b">EchoElement</code>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6707" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是HTMLElement的一个非常简单的实现，它允许我们处理状态，类似于React！让我们尝试一下，做一个点击计数器组件。</p><h2 id="9636" class="mt lw it bd lx mu mv dn mb mw mx dp mf kr my mz mh kv na nb mj kz nc nd ml ne bi translated">开发点击计数器</h2><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f099" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你看到那有多快了吗？这种方式很容易建立新的组件。只需很少的设置，就可以设置类似React的组件。</p><p id="0f92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你会发现，我们的按钮没有链接到任何<code class="fe nf ng nh ni b">onclick</code>处理程序。单击该按钮现在不会做任何事情。但是，该组件应该可以成功地呈现在我们的页面上。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/3dc1285607dddf3fb2e2ed52c50e5603.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*VW0517kHBg1oJWv9Vffzog.png"/></div></figure><h2 id="50c8" class="mt lw it bd lx mu mv dn mb mw mx dp mf kr my mz mh kv na nb mj kz nc nd ml ne bi translated">设置点击处理程序</h2><p id="0005" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在我们的<code class="fe nf ng nh ni b">EchoElement</code>类中设置一个全局<code class="fe nf ng nh ni b">onclick</code>方法怎么样？这样，任何未来的<code class="fe nf ng nh ni b">EchoElement</code>组件都可以利用我们的点击处理程序。</p><p id="1b99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的构造函数中，让我们绑定<code class="fe nf ng nh ni b">onclick</code>函数，如果它是由子组件定义的。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fedf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们还需要更新我们的<code class="fe nf ng nh ni b">_doRender</code>函数来设置<code class="fe nf ng nh ni b">onclick</code>处理程序，如果它被定义的话。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9f06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe nf ng nh ni b">EchoElement</code>都准备好了！接下来让我们更新我们的<code class="fe nf ng nh ni b">ClickCounter</code>类，加入一个<code class="fe nf ng nh ni b">onclick</code>来更新我们的点击计数器。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="2197" class="mt lw it bd lx mu mv dn mb mw mx dp mf kr my mz mh kv na nb mj kz nc nd ml ne bi translated">最后试验</h2><p id="3f1a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">现在，试一试，你应该看到计数更新。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/eb99cd20080965cc84ba6d332b972ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*dQRf2YFGUvR2PUMWvNJP5g.png"/></div></figure><p id="2cc3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使页面上有多个点击计数器，它们也会彼此独立工作。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e0d59001a560fb4e45235ef1b262ce0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*letKamlXimo-6RYIxkLnzg.png"/></div></figure><h1 id="0a64" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">与React的比较</h1><p id="0435" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这是需要提一下的。虽然我们围绕状态管理使用了一些基本的React概念，但这根本无法与整个React生态系统相比，后者要大得多。我们创建的<code class="fe nf ng nh ni b">EchoElement </code>类只有30行长！</p><p id="f43c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们受到React中的状态管理的启发，在React中，一切都被很好地划分为组件。我们只是试图模仿这一点，并向您展示如何在定制元素的世界中尽情发挥您的创造力。如果这是可能的，想象一下我们可以围绕定制元素创建什么样的其他库和框架！</p><h1 id="7e80" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="267b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">自定义元素有优点也有缺点。首先，自定义元素确实以一种很好的方式将所有东西分开。正如我们所见，设置成本非常低，创建新的<code class="fe nf ng nh ni b">EchoElement</code>组件非常快速和容易。扩展<code class="fe nf ng nh ni b">HTMLElements</code>非常容易。</p><p id="1d2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与React生态系统相比，它提供的功能非常少。有了围绕定制元素的适当框架，这就不仅仅是一个简单的HTML扩展了。Web组件的一个流行框架是<a class="ae lu" href="https://polymer-library.polymer-project.org/3.0/docs/devguide/feature-overview" rel="noopener ugc nofollow" target="_blank">聚合物</a>。</p><p id="95d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你对自定义元素有什么看法？你喜欢《T2》的制作吗？请在评论中告诉我们！</p><h1 id="033f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">进一步阅读</h1><p id="4c54" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank">Mozilla MDN上提供了关于Web组件的更多信息。</a></p><p id="f293" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lu" href="https://polymer-library.polymer-project.org/3.0/docs/devguide/feature-overview" rel="noopener ugc nofollow" target="_blank">聚合物网络组件库。</a></p><h1 id="c43a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">完整代码</h1><p id="3562" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">您可以在以下要点中找到本文的完整工作代码。将其保存为HTML文件，在浏览器中打开，应该就可以开始了。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="fce4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lu" href="https://kevinvr.medium.com/membership" rel="noopener">订阅我的媒体</a>到<strong class="kk iu">解锁</strong> <strong class="kk iu">所有</strong> <strong class="kk iu">文章</strong>。通过使用我的链接订阅，你是支持我的工作，没有额外的费用。你会得到我永远的感激。</p></div></div>    
</body>
</html>