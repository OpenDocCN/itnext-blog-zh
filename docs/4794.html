<html>
<head>
<title>App Trimming in .NET 5: Reduce Your App Sizes Dramatically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用修剪。NET 5:大幅缩减应用程序的大小</h1>
<blockquote>原文：<a href="https://itnext.io/app-trimming-in-net-5-reduce-your-app-sizes-dramatically-39891e2bedc1?source=collection_archive---------1-----------------------#2020-09-21">https://itnext.io/app-trimming-in-net-5-reduce-your-app-sizes-dramatically-39891e2bedc1?source=collection_archive---------1-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c270" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated"><span class="l kp kq kr bm ks kt ku kv kw di"> O </span> ne的主要区别来自。NET框架和。网芯就是那个。NET Core支持自包含部署；一切都捆绑在一起，包括运行时和应用程序。这带来了简单的部署，但是也有缺点:因为包含了运行时，所以增加了应用程序的大小。</p><p id="5ba3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您有一个小型的桌面或web应用程序，但是部署大小是200MB，这听起来不太好，对吗？</p><p id="cc3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">里。NET Core 3 </strong>，为了解决这个问题。NET团队引入了一个<a class="ae kx" href="https://docs.microsoft.com/en-us/dotnet/core/deploying/trim-self-contained" rel="noopener ugc nofollow" target="_blank">工具</a>，它可以找到未使用的程序集，并将其从最终部署中移除。在<strong class="js iu">中。NET 5 </strong>他们向前走了一步；它不仅可以<strong class="js iu">移除未使用的程序集</strong>，而且<strong class="js iu">还可以通过打开程序集并移除应用程序未使用的类型和成员来移除程序集</strong>中未使用的代码</p><p id="2b17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一个大问题:修剪使用静态分析来查找未使用的成员、组件等。例如，使用反射来处理方法或加载程序集，微调器不知道是否需要这些类型，所以它只是丢弃它们。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/3b914f0be6bd5fa5e51d2c1c19390275.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*WP47tCyMmuNX9OraLdVyQQ.gif"/></div></figure><p id="0fcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应用程序修剪是来自的一个很好的功能。NET，我真的很高兴在本文的不同例子中使用它。</p><blockquote class="lg"><p id="2fb0" class="lh li it bd lj lk ll lm ln lo lp kn dk translated">在写这篇文章的时候。NET RC1几天前刚刚发布，我用它来做所有的例子。</p></blockquote></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="cb49" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">应用程序大小缩减</h2><p id="1d72" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">没有什么比一个简单的控制台hello-world应用程序更好的了，对吗？</p><pre class="kz la lb lc gt mv mw mx my aw mz bi"><span id="1dd5" class="lx ly it mw b gy na nb l nc nd">dotnet new console -o HelloWorld</span></pre><p id="2a29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面简单的一行在<code class="fe ne nf ng mw b">HelloWorld</code>文件夹中创建了一个新的控制台应用程序。让我们尝试将框架依赖部署作为基线，并将其与自包含部署进行比较。</p><pre class="kz la lb lc gt mv mw mx my aw mz bi"><span id="20a3" class="lx ly it mw b gy na nb l nc nd">dotnet publish -c Release</span></pre><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/f91dd486657b3760854cbdc82e2ffcfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GmMcL6LVDe0pLz8EJVm77A.png"/></div></div></figure><p id="93ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有五个文件和154KB。让我们做一个独立的。</p><pre class="kz la lb lc gt mv mw mx my aw mz bi"><span id="5049" class="lx ly it mw b gy na nb l nc nd">dotnet publish -r win10-x64 -c Release</span></pre><p id="4501" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ne nf ng mw b">-r runtime</code>参数告诉dotnet编译器进行独立发布。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/931dd66273f5402ec1d283d4b998dc0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8GpEnX45_i3uLQz96r0Yg.png"/></div></div></figure><p id="a17d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出将是<strong class="js iu"> 222 </strong>文件和<strong class="js iu"> 65.5MB </strong>大小。</p><p id="50e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要惊讶，因为这是正常的。NET 5运行时包含在输出中，这就是应用程序调整器发挥作用的地方。</p><pre class="kz la lb lc gt mv mw mx my aw mz bi"><span id="a928" class="lx ly it mw b gy na nb l nc nd">dotnet publish -r win10-x64 -c Release -p:PublishTrimmed=True -p:TrimMode=CopyUsed</span></pre><p id="cafe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">《T2》和《T3》讲述了。NET publisher裁剪应用程序，只移除未使用的程序集。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nn"><img src="../Images/5cbf622e51215f98c7a413b3e883505c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6OxwiIQLcf1xB3Ze8JNqQ.png"/></div></div></figure><p id="9b78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">72档和<strong class="js iu"> 25.2 MB </strong>。就尺寸而言，这是一个巨大的缩减，几乎比原来小了62%。</p><p id="97aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">会员级修剪怎么样？</p><pre class="kz la lb lc gt mv mw mx my aw mz bi"><span id="64e2" class="lx ly it mw b gy na nb l nc nd">dotnet publish -r win10-x64 -c Release -p:PublishTrimmed=True -p:TrimMode=Link</span></pre><p id="ad01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相同的结果，这是有意义的，因为我们的应用程序只是一个<code class="fe ne nf ng mw b">Console.WriteLine("HelloWorld")</code>。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d00d38ecb1efd873fc9776c34ca61a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*LUyo3jRFilkrCQe83hNynQ.png"/></div></figure><h2 id="bfea" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">更复杂的应用程序</h2><p id="e10f" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">举个例子，我有一个web API项目；结果相当有趣:</p><ul class=""><li id="8150" class="np nq it js b jt ju jx jy kb nr kf ns kj nt kn nu nv nw nx bi translated">自带:<strong class="js iu"> 88.4MB </strong></li><li id="1179" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">自带汇编级微调:<strong class="js iu"> 35.6MB </strong></li><li id="4d9f" class="np nq it js b jt ny jx nz kb oa kf ob kj oc kn nu nv nw nx bi translated">自带成员级微调:<strong class="js iu"> 35.1MB </strong></li></ul><p id="8513" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在成员修剪中，虽然差别很小，但app trimmer完成了工作！</p><blockquote class="lg"><p id="566c" class="lh li it bd lj lk ll lm ln lo lp kn dk translated">成员级调整还从程序集中去除了<a class="ae kx" href="https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#readytorun-images" rel="noopener ugc nofollow" target="_blank"> ReadyToRun </a> (R2R)代码——结果更小，但是应用程序启动会更慢。</p></blockquote></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="a5d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以在csproj文件中定义这些参数，如下例所示:</p><pre class="kz la lb lc gt mv mw mx my aw mz bi"><span id="68f0" class="lx ly it mw b gy na nb l nc nd">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;<br/>    &lt;PropertyGroup&gt;<br/>        &lt;OutputType&gt;Exe&lt;/OutputType&gt;<br/>        &lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;<br/>        &lt;RuntimeIdentifier&gt;win10-x64&lt;/RuntimeIdentifier&gt;<br/>        &lt;PublishTrimmed&gt;true&lt;/PublishTrimmed<br/>        &lt;TrimMode&gt;Link&lt;/TrimMode&gt;<br/>    &lt;/PropertyGroup&gt;<br/>&lt;/Project&gt;</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="0c1d" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">动态代码怎么样？</h2><p id="c039" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">在开始，我们谈到了静态分析器，以及它如何找到未使用的部分，它可以修剪部分代码的动态加载反射。</p><p id="a2c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在的早期版本中。NET中，很容易通过在csproj中定义特定的程序集来告诉链接器不要移除它们。如下图所示:</p><pre class="kz la lb lc gt mv mw mx my aw mz bi"><span id="cba4" class="lx ly it mw b gy na nb l nc nd">&lt;ItemGroup&gt;<br/>  &lt;LinkerRootAssemblies Include="MyAssembly" /&gt;<br/>&lt;/ItemGroup&gt;</span></pre><p id="e0de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">英寸NET 5中，有一个新的更好的解决方法，使用类注释:</p><p id="2dd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> [ </strong> <a class="ae kx" href="https://github.com/dotnet/aspnetcore/blob/404d81767784552b0a148cb8c437332ebe726ae9/src/Shared/CodeAnalysis/DynamicallyAccessedMembersAttribute.cs#L29" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">动态访问成员</strong> </a> <strong class="js iu"> ] </strong></p><blockquote class="od oe of"><p id="1965" class="jq jr og js b jt ju jv jw jx jy jz ka oh kc kd ke oi kg kh ki oj kk kl km kn im bi translated">应用于系统的实例。Type(或包含类型名的字符串)告诉微调器该类型的哪些成员将被动态访问。</p></blockquote><p id="bf16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> [ </strong> <a class="ae kx" href="https://github.com/dotnet/runtime/blob/a5159b1a8840632ad34cf59c5aaf77040cb6ceda/src/libraries/System.Private.CoreLib/src/System/Diagnostics/CodeAnalysis/UnconditionalSuppressMessageAttribute.cs#L21" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">无条件支持消息</strong> </a> <strong class="js iu"> ] </strong></p><blockquote class="od oe of"><p id="d525" class="jq jr og js b jt ju jv jw jx jy jz ka oh kc kd ke oi kg kh ki oj kk kl km kn im bi translated">如果用例已知是安全的，用于抑制来自修剪器的警告消息。例如，如果一个“等于”方法是通过检索一个类型的所有字段并循环比较每个字段来编写的。如果一个字段未被使用，并因此被修整，则不需要比较该字段是否相等。</p></blockquote><p id="561f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">[</strong><a class="ae kx" href="https://github.com/dotnet/runtime/blob/6072e4d3a7a2a1493f514cdf4be75a3d56580e84/src/libraries/System.Private.CoreLib/src/System/Diagnostics/CodeAnalysis/RequiresUnreferencedCodeAttribute.cs#L15" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">requires un referenced code</strong></a><strong class="js iu">】</strong></p><blockquote class="od oe of"><p id="01e7" class="jq jr og js b jt ju jv jw jx jy jz ka oh kc kd ke oi kg kh ki oj kk kl km kn im bi translated">告诉微调器该方法与微调不兼容，因此在调用该方法的地方应该出现警告。这将取消对此方法调用的代码路径的警告，从而减少噪音，并使开发人员更清楚他们调用的哪些方法有问题。</p></blockquote><p id="d401" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"/><a class="ae kx" href="https://github.com/dotnet/runtime/blob/6072e4d3a7a2a1493f514cdf4be75a3d56580e84/src/libraries/System.Private.CoreLib/src/System/Diagnostics/CodeAnalysis/DynamicDependencyAttribute.cs#L21" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">动态依赖性</strong></a><strong class="js iu"/></p><blockquote class="od oe of"><p id="3595" class="jq jr og js b jt ju jv jw jx jy jz ka oh kc kd ke oi kg kh ki oj kk kl km kn im bi translated">指定从一个方法到其他代码的显式依赖关系，如果该方法被保留，其他代码也将被保留。在依赖项不是由方法表达，而是由外部因素(如本机代码)表达的情况下使用。</p></blockquote><p id="15ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我强烈推荐阅读文章<a class="ae kx" href="https://devblogs.microsoft.com/dotnet/customizing-trimming-in-net-core-5/" rel="noopener ugc nofollow" target="_blank">定制修剪。NET 5 </a>由<a class="ae kx" href="https://devblogs.microsoft.com/dotnet/author/samspmicrosoft-com/" rel="noopener ugc nofollow" target="_blank">萨姆·斯潘塞</a>(项目经理，。NET核心团队)关于控制app修剪器。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="3211" class="lx ly it bd lz ma mb dn mc md me dp mf kb mg mh mi kf mj mk ml kj mm mn mo mp bi translated">概述</h2><p id="436c" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">应用程序微调是一个神奇的功能。NET <strong class="js iu">，其中</strong>添加了真正强大的功能。NET Core 3，但总是有一个陷阱:通过使用app-trimmer，您的应用程序可能会因为错误的调整而表现不同。</p><p id="8ec8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何避免这种情况？</p><p id="b987" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过不同的测试场景，特别是e2e测试。</p></div></div>    
</body>
</html>