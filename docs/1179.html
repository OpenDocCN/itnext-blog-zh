<html>
<head>
<title>A file-system browser component for Electron/Vue.js applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于Electron/Vue.js应用程序的文件系统浏览器组件</h1>
<blockquote>原文：<a href="https://itnext.io/a-file-system-browser-component-for-electron-vue-js-applications-eab285fbb3cb?source=collection_archive---------0-----------------------#2018-08-06">https://itnext.io/a-file-system-browser-component-for-electron-vue-js-applications-eab285fbb3cb?source=collection_archive---------0-----------------------#2018-08-06</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="7cfe" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">许多应用程序需要浏览文件系统中的文件。例如，大多数程序员的文本编辑器(我是用微软的Visual Studio代码写的)包括一个显示文件系统的侧边栏。因此，在Electron/Vue.js应用程序中使用这样的组件非常重要。在本文中，我们将研究实现这种组件的一种方法。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj km"><img src="../Images/ba80137025da742e2818f5846a6d6260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3ZjO6Xy77mDr5xfS.jpg"/></div></div></figure><p id="281e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">本文转载自:<a class="ae ky" href="https://techsparx.com/nodejs/electron/file-browser-component.html" rel="noopener ugc nofollow" target="_blank">https://techsparx . com/nodejs/electron/file-browser-component . html</a></p><p id="6495" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">按照本文，克隆以下存储库:</p><ul class=""><li id="0724" class="kz la ir jq b jr js jv jw jz lb kd lc kh ld kl le lf lg lh bi translated"><a class="ae ky" href="https://github.com/robogeek/vue-file-tree-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/robogeek/vue-file-tree-demo</a>—示范应用</li><li id="4311" class="kz la ir jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><a class="ae ky" href="https://github.com/robogeek/vue-file-tree" rel="noopener ugc nofollow" target="_blank">https://github.com/robogeek/vue-file-tree</a>—显示文件树的组件</li></ul><p id="f114" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">让我们初始化应用程序:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="c961" class="ls lt ir lo b gz lu lv l lw lx">$ vue init simulatedgreg/electron-vue electron-vue-file-browse</span><span id="c3d6" class="ls lt ir lo b gz ly lv l lw lx">? Application Name electron-vue-file-browse<br/>? Project description Electron/Vue.js file browser<br/>? Select which Vue plugins to install vue-electron, vue-router<br/>? Use linting with ESLint? No<br/>? Set up unit testing with Karma + Mocha? No<br/>? Set up end-to-end testing with Spectron + Mocha? No<br/>? What build tool would you like to use? builder<br/>? author David Herron &lt;david@davidherron.com&gt;</span><span id="c0ca" class="ls lt ir lo b gz ly lv l lw lx">   vue-cli · Generated "electron-vue-file-browse".</span><span id="cb9f" class="ls lt ir lo b gz ly lv l lw lx">---</span><span id="b885" class="ls lt ir lo b gz ly lv l lw lx">All set. Welcome to your new electron-vue project!</span><span id="52e8" class="ls lt ir lo b gz ly lv l lw lx">Make sure to check out the documentation for this boilerplate at<br/>https://simulatedgreg.gitbooks.io/electron-vue/content/.</span><span id="0905" class="ls lt ir lo b gz ly lv l lw lx">Next Steps:</span><span id="05f2" class="ls lt ir lo b gz ly lv l lw lx">  $ cd electron-vue-file-browse<br/>  $ yarn (or `npm install`)<br/>  $ yarn run dev (or `npm run dev`)</span></pre><p id="c0b3" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">位于<code class="fe lz ma mb lo b">simulatedgreg/electron-vue</code>的工作区包括一个非常有用的框架，用于使用Vue.js开发电子应用程序。我已经将它配置为使用<code class="fe lz ma mb lo b">vue-electron</code>和<code class="fe lz ma mb lo b">vue-router</code>，但不使用其他组件，并且不包含任何ESLint或单元测试特性。你可能会发现用不同的方式回答这些问题很有用。该框架同时支持<code class="fe lz ma mb lo b">electron-builder</code>和<code class="fe lz ma mb lo b">electron-packager</code>，我选择了前者。</p><p id="ecb9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">接下来，我们设置依赖关系:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="ee01" class="ls lt ir lo b gz lu lv l lw lx">$ cd electron-vue-file-browse<br/>$ npm install buefy walkdir path-directories vue-awesome sl-vue-tree --save<br/>$ npm install<br/>$ npm run dev</span></pre><p id="35a1" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">最后一步现在有点没用，因为我们还没有进行配置。</p><p id="ddad" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">选择的依赖项包括:</p><ul class=""><li id="70c6" class="kz la ir jq b jr js jv jw jz lb kd lc kh ld kl le lf lg lh bi translated"><em class="mc"> Buefy </em>是使用布尔玛作为组件的Vue.js包</li><li id="2eda" class="kz la ir jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><em class="mc"> Walkdir </em>支持跟踪给定目录下文件的变化</li><li id="5c97" class="kz la ir jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><em class="mc">路径目录</em>有助于拆分目录名，这对构建文件浏览器对象树很有用</li><li id="4de9" class="kz la ir jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated">vue-awesome 将字体awesome图标封装成Vue.js组件</li><li id="bf97" class="kz la ir jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated">sl-vue-tree是一个不错的树形视图组件。我们将使用它来存储文件系统内容</li></ul><p id="4356" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">让我们开始骨骼应用程序的手术。</p><h1 id="02a7" class="md lt ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><code class="fe lz ma mb lo b">src/main/main.js</code> -主流程中的主模块</h1><p id="8036" class="pw-post-body-paragraph jo jp ir jq b jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ne kj kk kl ik bi translated">我们将在<code class="fe lz ma mb lo b">main.js</code>中做一些有选择的修改来调整应用程序的启动方式。</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="4046" class="ls lt ir lo b gz lu lv l lw lx">import { <br/>  app, BrowserWindow, ipcMain, dialog <br/>} from 'electron';<br/>import path from 'path';<br/>import walkdir from 'walkdir';</span></pre><p id="d5e7" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">如图所示更改导入。</p><p id="e3c8" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在提供的<code class="fe lz ma mb lo b">createWindow</code>函数的末尾添加这行代码:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="9bad" class="ls lt ir lo b gz lu lv l lw lx">scanDirectory();</span></pre><p id="3178" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">然后添加这个函数的实现:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="3ddf" class="ls lt ir lo b gz lu lv l lw lx">const rootdir = '/Volumes/Extra/akasha-tools/electron-vue-file-browse';</span><span id="1fbb" class="ls lt ir lo b gz ly lv l lw lx">function scanDirectory() {<br/>  walkdir('src', {})<br/>  .on('file', (fn, stat) =&gt; {<br/>    mainWindow.webContents.send('file', fn.slice(rootdir.length + 1), stat);<br/>  })<br/>  .on('directory', (fn, stat) =&gt; {<br/>    mainWindow.webContents.send('directory', fn.slice(rootdir.length + 1), stat);<br/>  })<br/>  .on('error', (fn, err) =&gt; {<br/>    console.error(`!!!! ${fn} ${err}`);<br/>  });<br/>}</span></pre><p id="34a4" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">其思想是“遍历”一个选定的目录树，发送出关于该树中文件的信息。因为这是一个测试应用程序，所以有一些硬编码的值。对于一个真正的应用程序，我们需要一个文件浏览器对话框来选择一个目录。</p><p id="9ea4" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">walkdir模块(<a class="ae ky" href="https://www.npmjs.com/package/walkdir" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/walkdir</a>)"<em class="mc">遍历目录树，根据找到的内容发出事件。</em>“当它遍历目录树时，它发出关于它所发现的事件。我们只是将这些事件转发给呈现器进程。</p><p id="cf7d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><code class="fe lz ma mb lo b">fn</code>参数是找到的完整路径名。在研究这个应用程序时，似乎更有用的不是发送完整的路径名，而是发送正在扫描的根目录后面的段。因此，我们使用<code class="fe lz ma mb lo b">slice</code>函数来适当地修剪字符串。</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="1bdb" class="ls lt ir lo b gz lu lv l lw lx">ipcMain.on('rescan-directory', () =&gt; {<br/>  scanDirectory();<br/>});</span></pre><p id="34a9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">此消息可以从呈现器进程发送，以使主进程重新扫描目录结构。</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="a814" class="ls lt ir lo b gz lu lv l lw lx">process.on('unhandledRejection', (reason, p) =&gt; {<br/>  console.error(`Unhandled Rejection at: ${util.inspect(p)} reason: ${reason}`);<br/>});</span></pre><p id="6ac5" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这将捕获任何未处理的承诺拒绝错误。参见:<a class="ae ky" href="https://techsparx.com/nodejs/esnext/unhandled-promises.html" rel="noopener ugc nofollow" target="_blank">处理未处理的承诺拒绝，避免应用程序崩溃</a></p><h1 id="e471" class="md lt ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><code class="fe lz ma mb lo b">src/renderer/main.js</code> -渲染器进程中的主模块</h1><p id="a619" class="pw-post-body-paragraph jo jp ir jq b jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ne kj kk kl ik bi translated">将<code class="fe lz ma mb lo b">main.js</code>更改为以下内容</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="2855" class="ls lt ir lo b gz lu lv l lw lx">import Vue from 'vue'</span><span id="a064" class="ls lt ir lo b gz ly lv l lw lx">import { ipcRenderer } from 'electron';</span><span id="e35d" class="ls lt ir lo b gz ly lv l lw lx">import App from './App';<br/>import router from './router';<br/>import Buefy from 'buefy';<br/>import 'buefy/lib/buefy.css';</span><span id="8d5a" class="ls lt ir lo b gz ly lv l lw lx">Vue.use(Buefy);</span><span id="4e3a" class="ls lt ir lo b gz ly lv l lw lx">if (!process.env.IS_WEB) Vue.use(require('vue-electron'))<br/>Vue.config.productionTip = false</span><span id="7278" class="ls lt ir lo b gz ly lv l lw lx">export const messageBus = new Vue({<br/>});</span><span id="8cbf" class="ls lt ir lo b gz ly lv l lw lx">/* eslint-disable no-new */<br/>new Vue({<br/>  components: { App },<br/>  router,<br/>  template: '&lt;App/&gt;'<br/>}).$mount('#app')<br/></span><span id="6fa8" class="ls lt ir lo b gz ly lv l lw lx">ipcRenderer.on('file', (event, fn, stat) =&gt; {<br/>  messageBus.$emit('file', fn, stat);<br/>});</span><span id="c9c9" class="ls lt ir lo b gz ly lv l lw lx">ipcRenderer.on('directory', (event, fn, stat) =&gt; {<br/>  messageBus.$emit('directory', fn, stat);<br/>});</span></pre><p id="9d85" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">其中一些是从框架继承来的，其余的初始化对我们加载的一些依赖项以及有用对象的支持。</p><p id="ae7a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们初始化Buefy(UI工具包)、<code class="fe lz ma mb lo b">sl-tree-vue</code>(树查看器)和<code class="fe lz ma mb lo b">vue-awesome</code>(字体真棒)。</p><p id="fb13" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><code class="fe lz ma mb lo b">messageBus</code>对象是一个额外的Vue实例，我们将使用它在应用程序中发送消息。Vue.js非常支持子组件向其父组件发送消息。但是开箱即用，它不直接支持在任何两个组件之间发送消息。我们将使用<code class="fe lz ma mb lo b">messageBus</code>来这样做——因为所有的Vue实例都包含发送和监听消息的功能。</p><p id="c91c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们看到两条这样的消息——从主进程接收到<code class="fe lz ma mb lo b">file</code>和<code class="fe lz ma mb lo b">directory</code>事件，然后在<code class="fe lz ma mb lo b">messageBus</code>上发出。</p><h1 id="48e5" class="md lt ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><code class="fe lz ma mb lo b">src/renderer/router/index.js</code> -路由器</h1><p id="c0e2" class="pw-post-body-paragraph jo jp ir jq b jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ne kj kk kl ik bi translated">对于这个应用程序，路由器并不是真正必需的，但是我在上面说了“是”，所以代码在这里。在这个模块中，您可以处理多个应用程序页面。目前，<code class="fe lz ma mb lo b">/</code> URL只有一个路由，它引用了一个<code class="fe lz ma mb lo b">LandingPage</code>组件。改成这样:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="1fbe" class="ls lt ir lo b gz lu lv l lw lx">export default new Router({<br/>  routes: [<br/>    {<br/>      path: '/',<br/>      name: 'file-browser-page',<br/>      component: require('@/components/FileBrowserMain').default<br/>    },<br/>    {<br/>      path: '*',<br/>      redirect: '/'<br/>    }<br/>  ]<br/>});</span></pre><h1 id="78e1" class="md lt ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><code class="fe lz ma mb lo b">src/renderer/components/FileBrowserMain.vue</code></h1><p id="30c0" class="pw-post-body-paragraph jo jp ir jq b jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ne kj kk kl ik bi translated">到目前为止，我们所做的是将该组件定位为应用程序的主窗口。我们将把它实现为一个单文件模板，它将依次演示如何使用面向文件系统的树浏览器。</p><p id="569d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在<code class="fe lz ma mb lo b">src/renderer/components</code>中删除所有提供的文件。这些文件组成了演示应用程序，我们不需要任何代码。</p><p id="983c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">创造<code class="fe lz ma mb lo b">FileBrowserTree.vue</code>来遏制这种:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="c573" class="ls lt ir lo b gz lu lv l lw lx">&lt;template&gt;<br/>  &lt;div id="wrapper" class="columns is-gapless is-mobile"&gt;<br/>    &lt;file-browser-tree <br/>          id="file-tree"<br/>          ref="filetree"<br/>          class="column"<br/>          @nodeClick="nodeClick"<br/>          @nodeDoubleClick="nodeDoubleClick"<br/>          @nodeDrop="nodeDrop"&gt;</span><span id="9905" class="ls lt ir lo b gz ly lv l lw lx">    &lt;template slot="context-menu"&gt;<br/>        &lt;div @click="doDashboard"&gt;Dashboard&lt;/div&gt;<br/>        &lt;div @click="doCustomers"&gt;Customers&lt;/div&gt;<br/>    &lt;/template&gt;</span><span id="bfc5" class="ls lt ir lo b gz ly lv l lw lx">    &lt;/file-browser-tree&gt;</span><span id="8faa" class="ls lt ir lo b gz ly lv l lw lx">    &lt;div id="file-info-view" class="column"&gt;<br/>        &lt;span v-html="fileInfo"&gt;&lt;/span&gt;<br/>        &lt;button class="button is-primary" @click="rescan"&gt;Rescan&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="4b8a" class="ls lt ir lo b gz ly lv l lw lx">&lt;script&gt;</span><span id="e2cf" class="ls lt ir lo b gz ly lv l lw lx">const path = require('path');<br/>const util = require('util');<br/>import { messageBus } from '../main.js';<br/>import { ipcRenderer } from 'electron';</span><span id="fa1c" class="ls lt ir lo b gz ly lv l lw lx">import FileBrowserTree from 'vue-file-tree';</span><span id="c582" class="ls lt ir lo b gz ly lv l lw lx">export default {<br/>  name: 'file-browser-main',<br/>  components: {<br/>    'file-browser-tree': FileBrowserTree,<br/>  },<br/>  data() {<br/>    return {<br/>      fileInfo: "",<br/>      nodes: []<br/>    }<br/>  },<br/>  methods: {<br/>    nodeClick(event, node) {<br/>      this.fileInfo = `<br/>        &lt;table&gt;<br/>        &lt;tr&gt;&lt;th&gt;ACTION&lt;/th&gt;&lt;th&gt;CLICK&lt;/th&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Filename&lt;/th&gt;&lt;td&gt;${node.data.pathname}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Created&lt;/th&gt;&lt;td&gt;${node.data.stat.ctime}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Access&lt;/th&gt;&lt;td&gt;${node.data.stat.atime}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Modified&lt;/th&gt;&lt;td&gt;${node.data.stat.mtime}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Size&lt;/th&gt;&lt;td&gt;${node.data.stat.size}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Mode&lt;/th&gt;&lt;td&gt;${node.data.stat.mode}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;/table&gt;<br/>        `;<br/>    },<br/>    nodeDoubleClick(node) {<br/>      this.fileInfo = `<br/>        &lt;table&gt;<br/>        &lt;tr&gt;&lt;th&gt;ACTION&lt;/th&gt;&lt;th&gt;DOUBLE-CLICK&lt;/th&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Filename&lt;/th&gt;&lt;td&gt;${node.data.pathname}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Created&lt;/th&gt;&lt;td&gt;${node.data.stat.ctime}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Access&lt;/th&gt;&lt;td&gt;${node.data.stat.atime}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Modified&lt;/th&gt;&lt;td&gt;${node.data.stat.mtime}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Size&lt;/th&gt;&lt;td&gt;${node.data.stat.size}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Mode&lt;/th&gt;&lt;td&gt;${node.data.stat.mode}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;/table&gt;<br/>        `;<br/>    },<br/>    nodeDrop(node) {<br/>      this.fileInfo = `<br/>        &lt;table&gt;<br/>        &lt;tr&gt;&lt;th&gt;ACTION&lt;/th&gt;&lt;th&gt;DROP&lt;/th&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Filename&lt;/th&gt;&lt;td&gt;${node[0].data.pathname}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Created&lt;/th&gt;&lt;td&gt;${node[0].data.stat.ctime}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Access&lt;/th&gt;&lt;td&gt;${node[0].data.stat.atime}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Modified&lt;/th&gt;&lt;td&gt;${node[0].data.stat.mtime}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Size&lt;/th&gt;&lt;td&gt;${node[0].data.stat.size}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;tr&gt;&lt;th&gt;Mode&lt;/th&gt;&lt;td&gt;${node[0].data.stat.mode}&lt;/td&gt;&lt;/tr&gt;<br/>        &lt;/table&gt;<br/>        `;<br/>    },<br/>    doCustomers() {<br/>        console.log(`doCustomers`);<br/>        this.$refs.filetree.contextMenuIsVisible = false;<br/>    },<br/>    doDashboard() {<br/>        console.log(`doDashboard`);<br/>        this.$refs.filetree.contextMenuIsVisible = false;<br/>    },<br/>    rescan() {<br/>      this.nodes = [];<br/>      ipcRenderer.send('rescan-directory');<br/>    }<br/>  },<br/>  created: function() {<br/>    console.log(util.inspect(path));<br/>      messageBus.$on('file', (fn, stat) =&gt; { <br/>        this.$refs.filetree.addPathToTree(fn, stat, false);<br/>      });<br/>      messageBus.$on('directory', (fn, stat) =&gt; { <br/>        this.$refs.filetree.addPathToTree(fn, stat, true);<br/>      });<br/>  }<br/>}<br/>&lt;/script&gt;</span><span id="fb2f" class="ls lt ir lo b gz ly lv l lw lx">&lt;style&gt;<br/>  @import url('https://fonts.googleapis.com/css?family=Source+Sans+Pro');</span><span id="0dac" class="ls lt ir lo b gz ly lv l lw lx">  * {<br/>    box-sizing: border-box;<br/>    margin: 0;<br/>    padding: 0;<br/>  }</span><span id="cac8" class="ls lt ir lo b gz ly lv l lw lx">  body { font-family: 'Source Sans Pro', sans-serif; }</span><span id="5c05" class="ls lt ir lo b gz ly lv l lw lx">  #wrapper {<br/>    height: 100vh;<br/>    width: 100vw;<br/>  }</span><span id="2c6e" class="ls lt ir lo b gz ly lv l lw lx">  #file-tree, #file-info-view {<br/>    height: 100%;<br/>    overflow: scroll;<br/>  }</span><span id="df18" class="ls lt ir lo b gz ly lv l lw lx">&lt;/style&gt;</span></pre><p id="a5f6" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在<code class="fe lz ma mb lo b">&lt;template&gt;</code>中我们有一个简单的Buefy <code class="fe lz ma mb lo b">columns</code>组件。左侧栏是文件浏览器，右侧是显示信息的区域。右侧还包括一个按钮，用于重新扫描目录内容。</p><p id="324f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><em class="mc">重新扫描</em>按钮会向主进程发送一条消息。如果你回头看主进程，你会看到这个消息导致所选的目录被扫描。</p><p id="8743" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">当选择的目录被扫描时，一系列的消息从主进程被发送到这里。这些消息或者是<code class="fe lz ma mb lo b">file</code>或者是<code class="fe lz ma mb lo b">directory</code>事件，并且包含路径名和对应于文件的<code class="fe lz ma mb lo b">stat</code>对象。这些消息在事件处理程序中被处理，并转化为将路径名添加到树对象的<code class="fe lz ma mb lo b">addPathToTree</code>调用。我们稍后会谈到这一点。</p><p id="6b53" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">注意:<code class="fe lz ma mb lo b">&lt;file-browser-tree ... ref="filetree" ...&gt;&lt;/file-browser-tree&gt;</code></p><p id="fcdf" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><code class="fe lz ma mb lo b">ref=</code>属性允许我们这样引用组件的对象:<code class="fe lz ma mb lo b">this.$refs.filetree.addPathToTree(fn, stat, false);</code></p><p id="a6e5" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">Vue.js确保<code class="fe lz ma mb lo b">$refs</code>对象有对应于每个具有<code class="fe lz ma mb lo b">ref=</code>属性的组件的字段。该组件将在本文中进一步讨论。</p><p id="0acc" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">该组件发出的事件有三个处理程序:</p><ul class=""><li id="1c9f" class="kz la ir jq b jr js jv jw jz lb kd lc kh ld kl le lf lg lh bi translated"><code class="fe lz ma mb lo b">nodeClick</code>处理项目上的点击</li><li id="eb1e" class="kz la ir jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><code class="fe lz ma mb lo b">nodeDoubleClick</code>处理项目上的双击</li><li id="ff08" class="kz la ir jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><code class="fe lz ma mb lo b">nodeDrop</code>处理项目上的拖放操作</li></ul><p id="b7a2" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在这个演示应用程序中，每个都在信息窗格中打印信息。</p><p id="4be2" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">文件树组件还支持右键单击激活的上下文菜单。我们使用<code class="fe lz ma mb lo b">&lt;template slot-name="context-menu"&gt;</code>将菜单选项注入菜单。它会在鼠标指针的位置自动弹出。演示应用程序中的上下文菜单项只是简单的例子，每个菜单项都调用一个处理程序方法。这些处理程序方法的一个重要步骤是:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="5f48" class="ls lt ir lo b gz lu lv l lw lx">this.$refs.filetree.contextMenuIsVisible = false;</span></pre><p id="f94c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这行代码指示文件树组件关闭菜单。</p><h1 id="bdc8" class="md lt ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><code class="fe lz ma mb lo b">vue-file-tree</code>组件</h1><p id="b7c7" class="pw-post-body-paragraph jo jp ir jq b jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ne kj kk kl ik bi translated">我们已经多次提到这个组件，现在是时候研究它了。</p><p id="e850" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">组件的存储库有一个完整的构建配置和其他脚本。看见</p><p id="dc39" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><a class="ae ky" href="https://github.com/robogeek/vue-file-tree" rel="noopener ugc nofollow" target="_blank">https://github.com/robogeek/vue-file-tree</a>了解详情。在本文中，我们将只研究<code class="fe lz ma mb lo b">.vue</code>文件。</p><p id="6b91" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">要在您的应用程序中使用该组件，请将以下内容添加到应用程序中<code class="fe lz ma mb lo b">package.json</code>的<code class="fe lz ma mb lo b">dependencies</code>部分:<code class="fe lz ma mb lo b">"vue-file-tree": "github:robogeek/vue-file-tree",</code>。然后按照自述文件中的进一步说明进行操作，或者根据前面给出的代码进行操作。</p><p id="6e96" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">此组件的模板:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="db61" class="ls lt ir lo b gz lu lv l lw lx">&lt;template&gt;<br/>    &lt;span&gt;<br/>    &lt;sl-vue-tree<br/>            id="vue-file-tree"<br/>            ref="slvuetree"<br/>            :value="nodes"<br/>            :allowMultiselect="false"<br/>            @nodeclick="nodeClick"<br/>            @nodedblclick="nodeDoubleClick"<br/>            @select="nodeSelect"<br/>            @toggle="nodeToggle"<br/>            @drop="nodeDrop"<br/>            @nodecontextmenu="nodeContextMenu"<br/>            @externaldrop.prevent="onExternalDropHandler"&gt;</span><span id="3fe0" class="ls lt ir lo b gz ly lv l lw lx">        &lt;template slot="toggle" slot-scope="{ node }"&gt;<br/>            &lt;span v-if="!node.isLeaf"&gt;<br/>                &lt;font-awesome-icon <br/>                    icon="caret-right" <br/>                    v-if="!node.isExpanded"&gt;&lt;/font-awesome-icon&gt;<br/>                &lt;font-awesome-icon <br/>                    icon="caret-down"<br/>                    v-else-if="node.isExpanded"&gt;&lt;/font-awesome-icon&gt;<br/>            &lt;/span&gt;<br/>        &lt;/template&gt;</span><span id="305b" class="ls lt ir lo b gz ly lv l lw lx">        &lt;template slot="title" slot-scope="{ node }"&gt;<br/>            &lt;font-awesome-icon <br/>                :icon="[ 'fab', 'js' ]" <br/>                v-if='node.data.type === "application/javascript"'&gt;&lt;/font-awesome-icon&gt;<br/>            &lt;font-awesome-icon <br/>                icon="table" <br/>                v-else-if='node.data.type === "application/json"'&gt;&lt;/font-awesome-icon&gt;<br/>            &lt;font-awesome-icon <br/>                icon="image" <br/>                v-else-if='node.data.type === "IMAGE"'&gt;&lt;/font-awesome-icon&gt;<br/>            &lt;font-awesome-icon <br/>                icon="code" <br/>                v-else-if='node.data.type === "EJS"'&gt;&lt;/font-awesome-icon&gt;<br/>            &lt;font-awesome-icon <br/>                :icon="[ 'fab', 'vuejs' ]" <br/>                v-else-if='node.data.type === "VUEJS"'&gt;&lt;/font-awesome-icon&gt;<br/>            &lt;font-awesome-icon <br/>                icon="file" <br/>                v-else-if="node.isLeaf"&gt;&lt;/font-awesome-icon&gt;<br/>            {{ node.title }} &lt;/template&gt;<br/></span><span id="1a58" class="ls lt ir lo b gz ly lv l lw lx">        &lt;template slot="sidebar" slot-scope="{ node }"&gt;<br/>            &lt;font-awesome-icon <br/>                icon="circle" <br/>                v-if="node.data.isModified"&gt;&lt;/font-awesome-icon&gt;<br/>        &lt;/template&gt;<br/>    &lt;/sl-vue-tree&gt;<br/></span><span id="9a72" class="ls lt ir lo b gz ly lv l lw lx">    &lt;aside class="menu vue-file-tree-contextmenu" <br/>            ref="contextmenu" <br/>            v-show="contextMenuIsVisible"&gt;<br/>        &lt;slot name="context-menu"&gt;&lt;/slot&gt;<br/>    &lt;/aside&gt;</span><span id="eaa4" class="ls lt ir lo b gz ly lv l lw lx">    &lt;/span&gt;<br/>&lt;/template&gt;</span></pre><p id="e346" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们正在做的是实现另一个组件的包装器，它的库是:<a class="ae ky" href="https://github.com/holiber/sl-vue-tree" rel="noopener ugc nofollow" target="_blank">https://github.com/holiber/sl-vue-tree</a></p><p id="d296" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们实现了许多事件处理程序和其他配置来配置默认行为，这些默认行为作为显示文件系统中文件的树组件是有意义的。</p><p id="d9b9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">sl-vue-tree组件支持许多可以注入HTML的<em class="mc">槽</em>。我们添加了以下内容:</p><ul class=""><li id="17c5" class="kz la ir jq b jr js jv jw jz lb kd lc kh ld kl le lf lg lh bi translated"><code class="fe lz ma mb lo b">toggle</code>这决定了对于展开的目录节点和关闭的目录节点，显示哪个箭头按钮。</li><li id="712a" class="kz la ir jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><code class="fe lz ma mb lo b">title</code>这描述了树组件的一行。我们希望根据文件类型显示一个图标。我们有办法选择这些代码来选择正确的图标。</li><li id="043b" class="kz la ir jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><code class="fe lz ma mb lo b">sidebar</code>这描述了出现在树显示最右边的图标。</li></ul><p id="81de" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们也有自己的槽<code class="fe lz ma mb lo b">context-menu</code>，这是上下文菜单HTML到达的地方。在这种情况下，我们使用一个Buefy菜单组件。该组件的显示由<code class="fe lz ma mb lo b">contextMenuIsVisible</code>数据项控制。</p><p id="6f26" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">显然，我们使用的是字体真棒图标集。</p><p id="c4f8" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">接下来，我们添加<code class="fe lz ma mb lo b">&lt;script&gt;</code>标签:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="6843" class="ls lt ir lo b gz lu lv l lw lx">&lt;script&gt;</span><span id="4163" class="ls lt ir lo b gz ly lv l lw lx">import path from 'path';<br/>import util from 'util';<br/>import splitter from './path-splitdirs';</span><span id="1cb5" class="ls lt ir lo b gz ly lv l lw lx">import mime from 'mime';</span><span id="52ee" class="ls lt ir lo b gz ly lv l lw lx">import slVueTree from 'sl-vue-tree';<br/>// import 'sl-vue-tree/dist/sl-vue-tree-dark.css';</span><span id="9213" class="ls lt ir lo b gz ly lv l lw lx">import { library } from '@fortawesome/fontawesome-svg-core';<br/>import {<br/>  faCaretRight, faCaretDown, faTable, faImage, faFile, faCircle, faCode<br/>} from '@fortawesome/free-solid-svg-icons';<br/>import { faJs, faVuejs } from '@fortawesome/free-brands-svg-icons';<br/>import { FontAwesomeIcon } from '@fortawesome/vue-fontawesome';</span><span id="50c2" class="ls lt ir lo b gz ly lv l lw lx">library.add(faJs, faVuejs, faCaretRight, faCaretDown, faTable, faImage, faFile, faCircle, faCode);<br/></span><span id="f3a7" class="ls lt ir lo b gz ly lv l lw lx">/* var nodes = [<br/>    {title: 'Item1', isLeaf: true},<br/>    {title: 'Item2', isLeaf: true, data: { visible: false }},<br/>    {title: 'Folder1'},<br/>    {<br/>      title: 'Folder2', isExpanded: true, children: [<br/>        {title: 'Item3', isLeaf: true},<br/>        {title: 'Item4', isLeaf: true, data: { isModified: true }}<br/>      ]<br/>    }<br/>]; */</span><span id="c4b2" class="ls lt ir lo b gz ly lv l lw lx">export default {</span><span id="44ae" class="ls lt ir lo b gz ly lv l lw lx">    data() {<br/>        return {<br/>            nodes: [],<br/>            contextMenuIsVisible: false<br/>        }<br/>    },<br/>    components: {<br/>        'sl-vue-tree': slVueTree,<br/>        'font-awesome-icon': FontAwesomeIcon<br/>    },<br/>    created() {<br/>        /*<br/>         * Derived from Buefy's b-dropdown<br/>         * https://github.com/buefy/buefy/blob/dev/src/components/dropdown/Dropdown.vue<br/>         */<br/>        if (typeof window !== 'undefined') {<br/>            document.addEventListener('click', this.clickedOutside)<br/>        }<br/>    },<br/>    methods: {<br/>        nodeClick(node, event) {<br/>            this.$emit('nodeClick', event, node);<br/>        },<br/>        nodeDoubleClick(node, event) {<br/>            console.log(`nodeDoubleClick ${node.title} ${node.data.type} isLeaf ${node.isLeaf} ${util.inspect(node)}`);<br/>            if (!node.isLeaf) {<br/>                this.$refs.slvuetree.onToggleHandler(event, node);<br/>                return;<br/>            }<br/>            this.$emit('nodeDoubleClick', node);<br/>        },<br/>        nodeSelect(node) {<br/>            console.log(`nodeSelect ${util.inspect(node)}`);<br/>        },<br/>        nodeToggle(node) {<br/>            console.log(`nodeToggle ${util.inspect(node)}`);<br/>        },<br/>        nodeDrop(node) {<br/>            console.log(`nodeDrop ${util.inspect(node)}`);<br/>            this.$emit('nodeDrop', node);<br/>        },<br/>        nodeContextMenu(node, event) {<br/>            console.log(`nodeContextMenu ${util.inspect(node)}`);<br/>            this.contextMenuIsVisible = true;<br/>            const $contextMenu = this.$refs.contextmenu;<br/>            $contextMenu.style.left = event.clientX + 'px';<br/>            $contextMenu.style.top = event.clientY + 'px';<br/>        },<br/>        /**<br/>         * Close dropdown if clicked outside.<br/>         * Derived from Buefy's b-dropdown<br/>         * https://github.com/buefy/buefy/blob/dev/src/components/dropdown/Dropdown.vue<br/>         */<br/>        clickedOutside(event) {<br/>            if (!this.isInWhiteList(event.target)) this.contextMenuIsVisible = false;<br/>        },<br/>        // If the "clickOutside" is on a target where we should ignore the click<br/>        // then we should ignore this.  <br/>        // See: https://github.com/buefy/buefy/blob/dev/src/components/dropdown/Dropdown.vue<br/>        isInWhiteList(el) { return false; },<br/>        onExternalDropHandler(cursorPosition, event) {<br/>            console.log('external drop', cursorPosition, util.inspect(event));<br/>        },<br/>        addPathToTree(fn, stat, isDir) {<br/>            console.log(`addPathToTree ${fn} ${util.inspect(stat)} ${isDir}`);<br/>            console.log(`addPathToTree ${util.inspect(process)}`);<br/>            console.log(util.inspect(path));<br/>            fn = path.normalize(fn);<br/>            console.log(`addPathToTree NORMALIZED ${fn}`);<br/>            const basenm = path.basename(fn);<br/>            console.log(`addPathToTree BASENAME ${basenm}`);</span><span id="add4" class="ls lt ir lo b gz ly lv l lw lx">            const split = splitter(fn);</span><span id="a714" class="ls lt ir lo b gz ly lv l lw lx">            console.log(`addPathToTree dirs ${util.inspect(split)}`);<br/>            let curnodes = this.nodes;<br/>            for (let dir of split.dirs) {<br/>                if (dir === '.') continue;<br/>                let found = undefined;<br/>                for (let cur of curnodes) {<br/>                    if (cur.isLeaf === false &amp;&amp; cur.title === dir) {<br/>                        found = cur;<br/>                        break;<br/>                    }<br/>                }<br/>                if (!found) {<br/>                    let newnode = {<br/>                        title: dir, <br/>                        isLeaf: false, <br/>                        children: [], <br/>                        data: { <br/>                            type: "DIRECTORY",<br/>                            pathname: fn, <br/>                            stat <br/>                        }<br/>                    };<br/>                    console.log(`addPathToTree !found push newnode ${util.inspect(newnode)}`);<br/>                    curnodes.push(newnode);<br/>                    curnodes = newnode.children;<br/>                } else {<br/>                    curnodes = found.children;<br/>                }<br/>            }<br/>            let newnode = {<br/>                title: basenm, <br/>                isLeaf: !isDir, <br/>                data: { <br/>                    type: mime.getType(fn),<br/>                    pathname: fn,<br/>                    stat<br/>                }<br/>            };<br/>            if (!newnode.data.type) newnode.data.type = "text/plain";<br/>            if (newnode.data.type.startsWith('image/')) newnode.data.type = "IMAGE";<br/>            if (fn.endsWith('.ejs')) newnode.data.type = "EJS";<br/>            if (fn.endsWith('.vue')) newnode.data.type = "VUEJS";<br/>            if (!newnode.isLeaf) newnode.children = [];<br/>            console.log(`addPathToTree FINAL push newnode ${util.inspect(newnode)}`);<br/>            curnodes.push(newnode);<br/>        }<br/>    }<br/>}</span><span id="4f54" class="ls lt ir lo b gz ly lv l lw lx">&lt;/script&gt;</span></pre><p id="2a85" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在顶部，我们导入各种必需的模块。这包括<code class="fe lz ma mb lo b">sl-vue-tree</code>组件，和一些字体很棒的图标。这两个组件都成为该组件可用的Vue.js组件。</p><p id="46ad" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><code class="fe lz ma mb lo b">sl-vue-tree</code>组件期望特定数据结构中的数据项。入乡随俗，所以我们必须给这个组件一个正确的数据结构。数据结构的一个例子在这里显示的注释中。</p><p id="d88c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><code class="fe lz ma mb lo b">addPathToTree</code>函数接收前面描述的<code class="fe lz ma mb lo b">file</code>和<code class="fe lz ma mb lo b">directory</code>消息。它接收一个简单的路径名字符串和一个Stat对象。这里的任务是将信息转换成<code class="fe lz ma mb lo b">sl-vue-tree</code>所需的结构。</p><p id="61bf" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我在开发这个组件时遇到了一个问题。创建目录结构要求是将路径名字符串分割成段。以独立于操作系统的方式做到这一点需要仔细考虑。</p><p id="f01a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">起初使用了<em class="mc">路径目录</em>模块(<code class="fe lz ma mb lo b">https://github.com/jy95/path-directories</code>)。它接受一个路径名，并根据Windows或POSIX文件路径约定将其可靠地分割成段。不幸的是，正如所写的那样，它在Node.js上运行得很好，但是这个<code class="fe lz ma mb lo b">vue-file-tree</code>组件是打包的，假设它在web浏览器中运行。其中<em class="mc">路径目录</em>假设一个<code class="fe lz ma mb lo b">path</code>模块与Node.js兼容，打包的Vue.js组件接收一个<code class="fe lz ma mb lo b">path</code>模块，该模块提供Node.js功能的一个子集。</p><p id="b613" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">因此，对替换进行了编码:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="6e19" class="ls lt ir lo b gz lu lv l lw lx">const _path = require('path');<br/>const normalize = require('normalize-path');<br/>const parsePath = require('parse-filepath');</span><span id="7bc9" class="ls lt ir lo b gz ly lv l lw lx">let isWin32 = false;<br/>let isPosix = true;</span><span id="cc72" class="ls lt ir lo b gz ly lv l lw lx">module.exports = function(path2split) {<br/>    path2split = normalize(path2split);<br/>    if (path2split.match(/^[a-zA-Z]\:/)) { isWin32 = true; isPosix = false; }<br/>    if (path2split.indexOf('\\') &gt;= 0) { isWin32 = true; isPosix = false; }<br/>    let path = isWin32 ? _path.win32 : _path.posix;<br/>    if (!path) path = _path;<br/>    let parsed = path.parse ? path.parse(path2split) : parsePath(path2split);<br/>    if (parsed.root === '') parsed.root = '.';<br/>    let dir = parsed.dir;<br/>    let dirz = [];<br/>    do {<br/>        dirz.unshift(path.basename(dir));<br/>        dir = path.dirname(dir);<br/>    } while (dir !== parsed.root);<br/>    parsed.dirs = dirz;<br/>    return parsed;<br/>}</span></pre><p id="ad23" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">该模块处理路径名规范化，并健壮地分割路径，而不管文件系统约定如何。它返回由<code class="fe lz ma mb lo b">path.parse</code>函数提供的对象，增加了一个<code class="fe lz ma mb lo b">dirs</code>属性，包含路径名的目录部分，但是被分成一个数组。</p><p id="acbe" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><code class="fe lz ma mb lo b">addPathToTree</code>所做的就是将文件路径名的每一段添加到<code class="fe lz ma mb lo b">sl-vue-tree</code>所要求的数据结构中。然后Vue.js安排将这个结构交给<code class="fe lz ma mb lo b">sl-vue-tree</code>,这导致文件系统树显示。</p><p id="e763" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">其他方法处理来回的各种事件。</p><p id="3738" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">最后我们到了<code class="fe lz ma mb lo b">&lt;style&gt;</code>部分:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="fe73" class="ls lt ir lo b gz lu lv l lw lx">&lt;style&gt;<br/>.vue-file-tree-contextmenu {<br/>    position: absolute;<br/>    background-color: white;<br/>    color: black;<br/>    border-radius: 2px;<br/>    cursor: pointer;<br/>}</span><span id="83a0" class="ls lt ir lo b gz ly lv l lw lx">.vue-file-tree-contextmenu &gt; div {<br/>    padding: 10px;<br/>}</span><span id="ef8b" class="ls lt ir lo b gz ly lv l lw lx">.vue-file-tree-contextmenu &gt; div:hover {<br/>    background-color: rgba(100, 100, 255, 0.5);<br/>}</span><span id="a6df" class="ls lt ir lo b gz ly lv l lw lx">#vue-file-tree {<br/>    height: 100%;<br/>}</span><span id="92ab" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree {<br/>    position: relative;<br/>    cursor: default;<br/>    user-select: none;<br/>}</span><span id="051d" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree.sl-vue-tree-root {<br/>    border: 1px solid rgb(9, 22, 29);<br/>    background-color: rgb(9, 22, 29);<br/>    color: rgba(255, 255, 255, 0.5);<br/>    border-radius: 3px;<br/>}</span><span id="d22e" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree-root &gt; .sl-vue-tree-nodes-list {<br/>    overflow: hidden;<br/>    position: relative;<br/>    padding-bottom: 4px;<br/>}</span><span id="c7ec" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree-selected &gt; .sl-vue-tree-node-item {<br/>    background-color: #13242d;<br/>    color: white;<br/>}</span><span id="908f" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree-node-item:hover,<br/>.sl-vue-tree-node-item.sl-vue-tree-cursor-hover {<br/>    color: white;<br/>}</span><span id="d888" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree-node-item {<br/>    position: relative;<br/>    display: flex;<br/>    flex-direction: row;</span><span id="a5c3" class="ls lt ir lo b gz ly lv l lw lx">    padding-left: 10px;<br/>    padding-right: 10px;<br/>    line-height: 28px;<br/>    border: 1px solid transparent;<br/>}<br/></span><span id="e906" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree-node-item.sl-vue-tree-cursor-inside {<br/>    border: 1px solid rgba(255, 255, 255, 0.5);<br/>}</span><span id="3cda" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree-gap {<br/>    width: 25px;<br/>    min-height: 1px;</span><span id="1ed9" class="ls lt ir lo b gz ly lv l lw lx">}</span><span id="1b72" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree-toggle {<br/>    display: inline-block;<br/>    text-align: left;<br/>    width: 20px;<br/>}</span><span id="1f71" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree-sidebar {<br/>    margin-left: auto;<br/>}</span><span id="e1a9" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree-cursor {<br/>    position: absolute;<br/>    border: 1px solid rgba(255, 255, 255, 0.5);<br/>    height: 1px;<br/>    width: 100%;<br/>}</span><span id="e5e2" class="ls lt ir lo b gz ly lv l lw lx">.sl-vue-tree-drag-info {<br/>    position: absolute;<br/>    background-color: rgba(0,0,0,0.5);<br/>    opacity: 0.5;<br/>    margin-left: 20px;<br/>    padding: 5px 10px;<br/>}<br/>&lt;/style&gt;</span></pre><p id="8319" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这些CSS声明处理两个任务:a)上下文菜单，b)文件树组件的样式</p><h1 id="9bd6" class="md lt ir bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">运行应用程序</h1><p id="805e" class="pw-post-body-paragraph jo jp ir jq b jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ne kj kk kl ik bi translated">我们现在一切就绪，准备出发。<code class="fe lz ma mb lo b">electron-vue</code>框架使这变得容易:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="9a49" class="ls lt ir lo b gz lu lv l lw lx">$ npm run dev</span><span id="5b4c" class="ls lt ir lo b gz ly lv l lw lx">&gt; electron-vue-file-browse@0.0.0 dev /Volumes/Extra/akasha-tools/electron-vue-file-browse<br/>&gt; node .electron-vue/dev-runner.js</span><span id="b5eb" class="ls lt ir lo b gz ly lv l lw lx">         ___                      __                                                                <br/>   __   /\_ \       __     ___   /\ \__    _ __    ___     ___              __  __  __  __     __   <br/> / ,.`\ \//\ \    / ,.`\  /'___\ \ \ ,_\  /\` __\ / __`\ /' _ `\   _______ /\ \/\ \/\ \/\ \  / ,.`\ <br/>/\  __/   \_\ \_ /\  __/ /\ \__/  \ \ \/  \ \ \/ /\ \_\ \/\ \/\ \ /\______\\ \ \/ |\ \ \_\ \/\  __/ <br/>\ \____\  /\____\\ \____\\ \____\  \ \ \_  \ \_\ \ \____/\ \_\ \_\\/______/ \ \___/ \ \____/\ \____\<br/> \/____/  \/____/ \/____/ \/____/   \ \__\  \/_/  \/___/  \/_/\/_/           \/__/   \/___/  \/____/<br/>                                     \/__/                                                          <br/>  getting ready...</span><span id="9368" class="ls lt ir lo b gz ly lv l lw lx">┏ Main Process ---------------</span><span id="de8f" class="ls lt ir lo b gz ly lv l lw lx">  compiling...</span><span id="0d43" class="ls lt ir lo b gz ly lv l lw lx">┗ ----------------------------</span><span id="5d58" class="ls lt ir lo b gz ly lv l lw lx">┏ Renderer Process -----------</span><span id="3bf9" class="ls lt ir lo b gz ly lv l lw lx">  Hash: b470657ee609c4cee744<br/>  Version: webpack 3.12.0<br/>  Time: 8084ms<br/>        Asset       Size  Chunks                    Chunk Names<br/>  renderer.js    1.13 MB       0  [emitted]  [big]  renderer<br/>   styles.css     304 kB       0  [emitted]  [big]  renderer<br/>   index.html  508 bytes          [emitted]         <br/>     [0] ./node_modules/vue/dist/vue.esm.js 292 kB {0} [built]<br/>     [1] ./node_modules/vue-hot-reload-api/dist/index.js 6.24 kB {0} [built]<br/>     [5] ./src/renderer/main.js 623 bytes {0} [built]<br/>     [6] external "electron" 42 bytes {0} [not cacheable]<br/>    [12] multi ./.electron-vue/dev-client ./src/renderer/main.js 40 bytes {0} [built]<br/>    [13] ./.electron-vue/dev-client.js 731 bytes {0} [built]<br/>    [14] (webpack)-hot-middleware/client.js?noInfo=true&amp;reload=true 7.77 kB {0} [built]<br/>    [16] external "querystring" 42 bytes {0} [not cacheable]<br/>    [19] (webpack)-hot-middleware/client-overlay.js 2.21 kB {0} [built]<br/>    [25] ./src/renderer/App.vue 1.84 kB {0} [built]<br/>    [29] ./src/renderer/router/index.js 273 bytes {0} [built]<br/>    [37] external "buefy" 42 bytes {0} [not cacheable]<br/>    [38] ./node_modules/buefy/lib/buefy.css 41 bytes {0} [built]<br/>    [39] external "vue-electron" 42 bytes {0} [not cacheable]<br/>    [41] ./node_modules/style-loader/lib/addStyles.js 8.7 kB [built]<br/>      + 28 hidden modules<br/>  Child html-webpack-plugin for "index.html":<br/>           Asset     Size  Chunks  Chunk Names<br/>      index.html  1.45 MB       0  <br/>         [0] ./node_modules/html-webpack-plugin/lib/loader.js!./src/index.ejs 1.3 kB {0} [built]<br/>         [1] ./node_modules/lodash/lodash.js 540 kB {0} [built]<br/>         [2] (webpack)/buildin/module.js 517 bytes {0} [built]<br/>  Child extract-text-webpack-plugin node_modules/extract-text-webpack-plugin/dist node_modules/css-loader/index.js!node_modules/buefy/lib/buefy.css:<br/>         [0] ./node_modules/css-loader!./node_modules/buefy/lib/buefy.css 318 kB {0} [built]<br/>         [1] ./node_modules/css-loader/lib/css-base.js 2.26 kB {0} [built]</span><span id="8f38" class="ls lt ir lo b gz ly lv l lw lx">┗ ----------------------------</span></pre><p id="c583" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">当应用程序在<em class="mc"> dev </em>模式下运行时，框架支持热重新加载。</p><p id="fd04" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">扫描目录树时，会打印以下消息:</p><pre class="kn ko kp kq gu ln lo lp lq aw lr bi"><span id="0db2" class="ls lt ir lo b gz lu lv l lw lx">┏ Electron -------------------</span><span id="fbee" class="ls lt ir lo b gz ly lv l lw lx">  walkdir sending FILE /Volumes/Extra/akasha-tools/electron-vue-file-browse/src/index.ejs<br/>  walkdir sending DIR /Volumes/Extra/akasha-tools/electron-vue-file-browse/src/main<br/>  walkdir sending DIR /Volumes/Extra/akasha-tools/electron-vue-file-browse/src/renderer<br/>  <br/>┗ ----------------------------</span><span id="51b6" class="ls lt ir lo b gz ly lv l lw lx">┏ Electron -------------------</span><span id="fb66" class="ls lt ir lo b gz ly lv l lw lx">  walkdir sending FILE /Volumes/Extra/akasha-tools/electron-vue-file-browse/src/main/index.dev.js<br/>  <br/>┗ ----------------------------</span></pre><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj km"><img src="../Images/c06fc937ac7fceb9d77139a5a60dd480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xMO-auDi5IJHX2v6.jpg"/></div></div></figure><p id="30a3" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这是应用程序在执行过程中的样子。</p></div></div>    
</body>
</html>