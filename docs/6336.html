<html>
<head>
<title>The Micro-Frontend Chaos (and how to solve it)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端混乱(以及如何解决)</h1>
<blockquote>原文：<a href="https://itnext.io/the-micro-frontend-chaos-and-how-to-solve-it-960b0a90c58?source=collection_archive---------1-----------------------#2021-10-19">https://itnext.io/the-micro-frontend-chaos-and-how-to-solve-it-960b0a90c58?source=collection_archive---------1-----------------------#2021-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="33ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微前端，这可能是完全隔离的多应用平台缺少的部分，它将为我们提供所需的灵活性和敏捷性，但成本是多少？</p><p id="6aa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑—一个<a class="ae kl" href="https://www.youtube.com/watch?v=wgip0pm4cdI" rel="noopener ugc nofollow" target="_blank">视频讲座</a>现已推出！</p><h1 id="1da4" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">为什么我们需要微前端？</h1><p id="0d29" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在过去的十年中，前端应用程序的复杂性增加了。许多业务逻辑不再保留在后端，而是也存在于客户端，这影响了应用程序的复杂性，并引入了一个新的整体—前端应用程序。</p><p id="0711" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着前端变得更大，同时承担多个责任域(例如，导航、用户、授权)，前端应用程序作为单个应用程序来开发、部署和托管。</p><p id="9c6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用每个模块、库，有时甚至是应用程序的目录时，这种分离通常已经存在于代码库中。</p><p id="dc1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微前端允许我们不仅在代码基础上，而且在开发、部署和服务中使用这些不同的应用程序，以便提供:</p><ul class=""><li id="4c06" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">松散耦合的应用</li><li id="a971" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">更快的开发、调试和测试流程</li><li id="9fba" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">性能—更小的区块</li><li id="832b" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">测试、开发和部署时完全隔离</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/68226adcc0d2889142e4f88da86f4508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VSSMHez3-MDIoroZ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">不同团队持有的E2E域名</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="34fc" class="km kn iq bd ko kp na kr ks kt nb kv kw kx nc kz la lb nd ld le lf ne lh li lj bi translated">概观</h1><p id="14bf" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在本文中，我们将回顾构建在shell之外的前端应用程序和代表一个域的3个应用程序:</p><ul class=""><li id="9c17" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">shell——用作基于URL路径加载每个微应用程序的入口点。外壳应用程序还将触发对路由守卫的授权。</li><li id="11fd" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">导航—负责导航逻辑和状态，包括导航条组件、导航服务</li><li id="bcf4" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">用户—负责用户逻辑和状态，包括用户查询和存储逻辑、用户信息组件和用户管理页面</li><li id="e871" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">Feed —负责获取和呈现Feed项目，每个项目都包含用户逻辑和状态，包括用户查询和存储逻辑。</li></ul><p id="645f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个应用程序都构建了以下层</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0a3b3e3e9d3d461fde3120c3d668ba3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/0*Sj-P83F8J7lvHIB-"/></div></figure><ul class=""><li id="c4a7" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">复合层—这一层包含一组应用程序页面及其相应的路由</li><li id="f8c7" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">小部件层——这一层包含一组与领域相关的组件，用于构建组合层上的不同页面</li><li id="9968" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">业务逻辑层——这一层包含一组负责领域业务逻辑的服务和实用程序。</li><li id="c196" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">通信层—这一层包含一组用于与不同服务提供商通信的服务(例如后端服务)。</li><li id="e85f" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">存储层—这一层包含将数据持久存储到存储对象<br/>中的逻辑—内存状态、挂钩(如<br/>)磁盘—本地存储、索引数据库、cookies等</li></ul><h1 id="dc3f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">混乱</h1><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ng"><img src="../Images/ad5dae751876f87c3b26e651128dbc35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P6WtU8FMhOHQb8_I"/></div></div></figure><p id="bf3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，导航应用程序和提要应用程序与用户应用程序之间存在明确的关系。</p><p id="1356" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢<a class="ae kl" href="https://webpack.js.org/concepts/module-federation/" rel="noopener ugc nofollow" target="_blank">模块联合</a>，我们可以在运行时加载微前端应用程序，而不需要构建整个依赖图。<br/>这为我们提供了独立构建和部署每个应用的能力。但是，尽管如此，我们需要记住，所有这些应用程序将作为用户浏览器上的一个整体并排托管。</p><p id="8aa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这带来了前端应用程序稳定性问题的全新方面:</p><ul class=""><li id="b831" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">当我们部署新版本的应用程序(我们场景中的用户)时会发生什么？</li><li id="4b3d" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">我们如何识别受影响的区域？</li><li id="840a" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">我们如何保证每个部署背后没有隐藏重大变化？</li><li id="cacf" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">我们如何防止托管在一起的多个应用程序之间的紧密耦合？</li></ul><p id="0585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，假设一个开发人员修改了来自<em class="nh">用户</em>应用程序的一个小部件，这个小部件被<em class="nh">提要</em>和<em class="nh">导航</em>应用程序使用。现在，让我们想象一下开发人员所做的改变正在破坏契约(组件API——输入/输出，又名。道具)。<br/>这将导致在现有应用程序中加载新版本时出现运行时错误。<br/>结果呢？部署新用户应用程序后，我们的前端应用程序出现级联故障。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ni"><img src="../Images/4f10350f8744f581253af5329e9c7e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ge63EgUG9Gkkef0yzVznzg.png"/></div></div></figure><h1 id="15be" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">解决问题</h1><p id="4e90" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">首先，让我们回顾一下微前端应用的要求:</p><ol class=""><li id="63d2" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk nj lv lw lx bi translated">每个应用程序都应该作为一个独立的单元来构建、测试和服务。</li><li id="7757" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nj lv lw lx bi translated">单个应用程序的修改应该可供任何其他应用程序使用。</li><li id="4901" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nj lv lw lx bi translated">应用程序小部件和服务应该是可重用和可互换的。</li><li id="91f7" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nj lv lw lx bi translated">应用内部模型和业务逻辑的封装——修改不应该影响应用消费者。</li><li id="3c55" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk nj lv lw lx bi translated">识别每个修改的依赖图——将帮助我们只触发相关的测试套件和构建。</li></ol><p id="b88f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们回顾一下上一节中的方法:<br/>该方法涵盖了需求列表中的第1到第3项。但是，对于向我们承诺产品稳定性的项目4和项目5，它仍然失败。</p><p id="8018" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回顾一下处理这种混乱的不同方法:</p><h2 id="0c84" class="nk kn iq bd ko nl nm dn ks nn no dp kw jy np nq la kc nr ns le kg nt nu li nv bi translated">图书馆方法</h2><p id="cdb6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">为了增加应用程序的稳定性，我们需要防止隐藏的破坏性更改。<br/>通过库方法，这可以在使用npm包版本时轻松实现。由于我们的应用程序的每个构建都密封了它所使用的库版本，我们可以防止使用可能包含重大更改的库版本。</p><p id="05db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用模块联合，我们可以设置共享库，作为此配置的一部分，我们可以使用npm包版本控制约定设置满意的包版本。</p><p id="f11d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法有助于我们将整体结构分成4层:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nw"><img src="../Images/0598d0e5cab8ad8131a5a0cf61f89c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j2GHz2Clai1wnSnk"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图书馆4层方法</figcaption></figure><ul class=""><li id="9ef4" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">核心库—这一层包含与领域无关的库，这些库为我们的特性库层提供了构建块。</li><li id="c62e" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">功能库层—这一层包含特定于领域的业务逻辑、存储逻辑和小部件。这些小部件是基于核心库组件包和属于特定责任领域的附加组件开发的。</li><li id="4bab" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">合成应用程序—这一层包含特定于域的路由和页面。这些页面是基于作为“特性库”层的一部分开发的小部件、服务和业务逻辑构建的。</li><li id="f712" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">shell——应用程序的入口点，通常充当容器和路由器，根据路径加载每个微应用程序。外壳应用程序也可能触发授权逻辑。</li></ul><p id="051f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这种方法涵盖了第1、3-5条，但第2条是需要付出的代价。因为库的修改不会自动反映到每个消费者应用程序，而是需要重建和重新部署这些应用程序。</p><p id="4e62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">设置</strong></p><p id="4d76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nh">结构:</em></p><pre class="me mf mg mh gt nx ny nz oa aw ob bi"><span id="bcca" class="nk kn iq ny b gy oc od l oe of">- apps<br/>  - user<br/>  - feed<br/>  - navigation<br/>  - shell<br/>- libs<br/>  - users-lib<br/>  - feed-lib<br/>  - navigation-lib<br/>  - auth</span></pre><p id="332d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nh">网络包配置:</em></p><pre class="me mf mg mh gt nx ny nz oa aw ob bi"><span id="333d" class="nk kn iq ny b gy oc od l oe of">plugins: [<br/>  new ModuleFederationPlugin({<br/>      name: "user",<br/>      filename: "remoteEntry.js",<br/>      exposes: {<br/>          './bootstrap': './apps/user/bootstrap.module.ts',<br/>      },<br/>      shared: share({<br/>        "@angular/core": { singleton: true, strictVersion: true, requiredVersion: '^12.0.0' },<br/>        "@angular/common": { singleton: true, strictVersion: true, requiredVersion: '^12.0.0' },<br/>        "@angular/common/http": { singleton: true, strictVersion: true, requiredVersion: '^12.0.0' },<br/>        "@angular/router": { singleton: true, strictVersion: true, requiredVersion: '^12.0.0' },<br/>        "@mfe/auth": { singleton: true, strictVersion: true, requiredVersion: '^1.0.0' },<br/>        "@mfe/user": { singleton: true, strictVersion: true, requiredVersion: '^1.5.0' },        ...sharedMappings.getDescriptors()<br/>      })</span><span id="1157" class="nk kn iq ny b gy og od l oe of">  }),<br/>  sharedMappings.getPlugin()<br/>],</span></pre><p id="90df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong></p><ul class=""><li id="dff9" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">跨应用程序共享的小部件、服务和页面(组合)。</li><li id="fa49" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">防止破坏更改—在构建期间使用已使用库的密封版本。</li></ul><p id="e635" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><ul class=""><li id="c152" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">数据损坏—可能是由于同一库的多个版本之间的冲突(覆盖状态，例如本地存储)。</li><li id="7206" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">包大小增加—由于版本不同，库可能会被加载多次。</li><li id="1d2e" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">部署图的复杂性——关键的修改需要重新构建和重新部署整个依赖图。</li></ul><h2 id="a23c" class="nk kn iq bd ko nl nm dn ks nn no dp kw jy np nq la kc nr ns le kg nt nu li nv bi translated">反腐败层级方法</h2><p id="4f9e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><strong class="jp ir">什么是反腐层？</strong></p><p id="0a13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反腐败层是应用程序为集成使用而公开的一组公共API，这些公共API充当合同，以便隔离应用程序的内部模型和业务逻辑复杂性。<br/>和用作导出的模块、组件、外观*和适配器*类。</p><p id="ed12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该层可以是单向或双向的(获取或接收数据)。</p><p id="0d41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nh">立面</em> </strong></p><p id="54ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为复杂的应用程序提供简单接口的服务，封装了启动应用程序的复杂性。<br/>外观可能提供有限的功能，这些是与微前端应用程序集成所需的子集</p><p id="b74e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nh">适配器</em> </strong></p><p id="88c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种服务，负责将一个对象的接口和数据模型转换为另一个被消费者接受的结构/接口。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/573764f493e61d6fbc9226d5210efbce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/0*SQpih4uITdEE_5pQ"/></div></figure><p id="67b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新的4层方法</strong></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nw"><img src="../Images/4b30e8f1c336973e5088e71aa1727074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xl439lCKY-vqrRfZ"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">反腐败4层方法</figcaption></figure><p id="4d43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一的修改是将功能层从库转换到应用程序，这允许我们无缝地为消费者提供这些小部件和服务。话虽如此，我们仍然需要防止突破性的变化，这就是反腐败层发生的地方</p><ul class=""><li id="e9a7" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">核心库—这一层包含与领域无关的库，这些库为我们的特性库层提供了构建块。</li><li id="784f" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">特性<strong class="jp ir">应用</strong>层——这一层包含特定领域的业务逻辑、存储逻辑和小部件。<br/>这些小部件是基于核心库组件包和特定领域的附加组件开发的。<br/>暴露的逻辑和元件由<strong class="jp ir">防腐蚀层</strong>保护，以防止破坏性改变。</li><li id="fdb5" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">合成应用程序—这一层包含特定于域的路由和页面。这些页面是基于作为“特性应用”层的一部分开发的小部件、服务和业务逻辑构建的。</li><li id="3315" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">shell——应用程序的入口点，通常充当容器和路由器，根据路径加载每个微应用程序。外壳应用程序也可能触发授权逻辑。</li></ul><p id="a3ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">设置</strong></p><p id="5709" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nh">结构:</em></p><pre class="me mf mg mh gt nx ny nz oa aw ob bi"><span id="641e" class="nk kn iq ny b gy oc od l oe of">- apps<br/>  - user<br/>    - src<br/>      - modules<br/>        - bootstrap<br/>          - bootstrap.module.ts<br/>    - public-api.ts<br/>    - public-api.d.ts<br/>  - feed<br/>     - src<br/>      - modules<br/>        - bootstrap<br/>          - bootstrap.module.ts<br/>    - public-api.ts<br/>    - public-api.d.ts<br/>  - navigation<br/>    - src<br/>      - modules<br/>        - bootstrap<br/>          - bootstrap.module.ts<br/>    - public-api.ts<br/>    - public-api.d.ts<br/>  - shell<br/>- libs<br/>  - auth</span></pre><p id="2d1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nh">网络包配置:</em></p><pre class="me mf mg mh gt nx ny nz oa aw ob bi"><span id="f4aa" class="nk kn iq ny b gy oc od l oe of">plugins: [<br/>  new ModuleFederationPlugin({<br/>      name: "user",<br/>      filename: "remoteEntry.js",<br/>      exposes: {<br/>          './public-api': './apps/user/public-api.ts',<br/>      },<br/>      shared: share({<br/>        "@angular/core": { singleton: true, strictVersion: true, requiredVersion: '^12.0.0' },<br/>        "@angular/common": { singleton: true, strictVersion: true, requiredVersion: '^12.0.0' },<br/>        "@angular/common/http": { singleton: true, strictVersion: true, requiredVersion: '^12.0.0' },<br/>        "@angular/router": { singleton: true, strictVersion: true, requiredVersion: '^12.0.0' },<br/>        "@mfe/auth": { singleton: true, strictVersion: true, requiredVersion: '^1.0.0' },<br/>        ...sharedMappings.getDescriptors()<br/>      })</span><span id="01d5" class="nk kn iq ny b gy og od l oe of">}),<br/>  sharedMappings.getPlugin()<br/>],</span></pre><p id="d22a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nh"> tsconfig: </em></p><p id="2197" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了帮助我们识别不同应用程序之间的依赖图，我们将公开定义文件，这些文件将用于我们应用程序的构建步骤，并将针对外观和适配器接口应用静态代码分析</p><pre class="me mf mg mh gt nx ny nz oa aw ob bi"><span id="5000" class="nk kn iq ny b gy oc od l oe of">{<br/>...<br/>"paths": {<br/>  "@mfe/feed": ["apps/feed/public-api.d.ts"],<br/>  "@mfe/navigation-bar": ["apps/navigation-bar/public-api.d.ts"],<br/>  "@mfe/user": ["apps/user/public-api.d.ts"]<br/>}</span><span id="03c6" class="nk kn iq ny b gy og od l oe of">...<br/>}</span></pre><p id="1ed0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong></p><ul class=""><li id="69e9" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">跨应用程序共享的小部件、服务和页面(组合)</li><li id="fe71" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">升级的无缝传播</li><li id="f647" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">使用反腐败层防止破坏更改。</li><li id="fec6" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">由于封装，重构变得更加简单。</li></ul><p id="5453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><ul class=""><li id="d507" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">需要维护的另一层</li><li id="e4b4" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">教育和学习曲线</li><li id="1106" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">集成测试需要承诺牢不可破的变化</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/66faf86da865002933c082bb635ac666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/0*OnpuLIXm8NhNiyJb"/></div></figure><h1 id="c029" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">奖金</h1><p id="0c9f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/o-b-one/module-federation" rel="noopener ugc nofollow" target="_blank"> Angular演示项目</a>使用反腐败层</p><p id="c79a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/o-b-one/react-mfe" rel="noopener ugc nofollow" target="_blank"> React演示项目</a>使用反腐败层(与下面的图片和描述略有不同)</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oj"><img src="../Images/99445c8849b002472cff830dfd0b1b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FAnMPcOFaHJxKkGyuHdjwg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">微前端演示应用程序</figcaption></figure><p id="4480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前端应用程序构建于:</p><ul class=""><li id="b13a" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">外壳应用程序</li><li id="7883" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">饲料应用(蓝色)</li><li id="6e0b" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">导航应用程序(紫色)</li><li id="adc6" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">用户应用程序(黄色)</li></ul><p id="07d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提要和导航都使用用户应用程序的组件和功能。<br/>外壳应用程序使用提要、导航和用户的合成应用程序来服务不同的页面。</p></div></div>    
</body>
</html>