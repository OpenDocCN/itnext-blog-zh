<html>
<head>
<title>Cloud Native RPA’s with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的云本机RPA</h1>
<blockquote>原文：<a href="https://itnext.io/cloud-native-rpas-with-python-a22cdb6690d0?source=collection_archive---------5-----------------------#2019-05-29">https://itnext.io/cloud-native-rpas-with-python-a22cdb6690d0?source=collection_archive---------5-----------------------#2019-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/fd381c9677b99661a99b5d39b93b6101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*XEZLhCybfYw-WTptKqttMg.jpeg"/></div></figure><p id="005a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">使用可破坏的基础设施在Python中构建云原生RPA</strong></p><p id="9aa1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在本文中，我们将:</p><ul class=""><li id="04ec" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">设置虚拟桌面来开发和运行RPA。我们的RPA将在docker容器内运行的linux虚拟桌面上运行。这允许我们尽可能地将代码从基础架构中分离出来，并确保“云原生”RPA。</li><li id="572c" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">构建一个从SEC官网下载财务数据的RPA。由于SEC数据库名为EDGAR，我们将称此RPA为“EDGAR_investigator”。</li><li id="a387" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">确保我们的RPA与其持久数据分离，并且有可能在任何基础架构上运行</li></ul><p id="5bd4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要求:</p><ul class=""><li id="cbf6" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">对Python、RPA和业务流程有基本了解</li><li id="0825" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">安装在服务器上的Docker Desktop或Docker and Compose(运行和开发我们的云原生RPA)</li></ul><p id="6b94" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">关于RPA是什么以及开发它们时的一些最佳实践的概述，请查看我以前的文章<a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/the-modern-enterprise-business-in-code-c6a5e0f4ed7e">文章</a>。</p><p id="aa70" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本教程的所有内容都可以在以下存储库中找到:</p><p id="f11d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">【https://github.com/dkatz23238/pybotlib-tutorial T4】</p><p id="471b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">介绍Pybotlib </strong></p><p id="d11b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Pybotlib为几个python库提供了一个高级包装器，并为用Python开发RPA提供了一些最佳实践。让我们回顾一下每个pybotlib RPA都必须经历的一些基础知识。完成后，我们将开始使用python代码和预构建的docker映像构建我们的云本机RPA。</p><p id="7293" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在pybotlib中，您可以创建一个“虚拟代理”对象来维护执行业务流程所需的整体状态和行为，而不是让解耦的任务按顺序执行。它代表了您的RPA及其功能。要创建VirtualAgent对象，必须指定以下参数:</p><ul class=""><li id="e87f" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">bot _ name:RPA的唯一标识符</li><li id="7d05" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">downloads_directory:存储通过互联网下载的文件的位置</li><li id="e077" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">firefoxProfile:主机上的目录，firefox可以在其中找到profiles.ini文件，并在加载firefox webdriver时实例化一个配置文件。通常位于/home/$USER/。mozilla/firefox</li></ul><p id="ddcc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所有操作都是通过单个对象实例pybotlib.VirtualAgent执行的。一旦我们创建了VirtualAgent对象，我们将继续为它创建一个日志文件来记录消息，最后打开一个web浏览器。要开始使用RPA浏览web，您必须调用get_geckodriver脚本，该脚本下载firefox-geckodriver的最新版本并将其放在当前工作目录中。创建RPA日志文件不需要任何依赖关系。</p><p id="1304" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">关于pybotlib的所有细节可以通过下面链接中的文档获得:</p><div class="lk ll gp gr lm ln"><a href="https://pybotlib.readthedocs.io/en/latest/" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd iu gy z fp ls fr fs lt fu fw is bi translated">欢迎使用pybotlib - pybotlib 0.0.1文档</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">编辑描述</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">pybotlib.readthedocs.io</p></div></div></div></a></div><p id="e472" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在下一节中，我们将启动一个虚拟桌面来运行以下代码。</p><p id="eb42" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以下代码显示了大多数RPA脚本应该从使用pybotlib开始。它导入所需的包，下载最新的geckodriver，实例化VirtualAgent，初始化web驱动程序，最后访问某个网站(在本例中是google.com)。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="050e" class="mf mg it mb b gy mh mi l mj mk">import os<br/>from pybotlib import VirtualAgent<br/>from pybotlib.utils import get_geckodriver<br/><br/># Downloads the geckodriver<br/>get_geckodriver()<br/># Any file downloaded will be saved to the current working dir<br/># under a folder called bot_downloads<br/>bot_download_dir = os.path.join(os.getcwd(),"bot_downloads")<br/><br/>mybot=VirtualAgent(<br/>    bot_name="my_first_robot",<br/>    downloads_directory=bot_download_dir,<br/>    # In order to load specific profiles from host machine<br/>    firefoxProfile="/home/$USER/.mozilla/firefox" )<br/># Start a web browser that can be accessed via mybot.driver or other mybot methods<br/>mybot.create_log_file()<br/>mybot.initialize_driver()<br/>mybot.get("http://www.google.com")<br/>mybot.log("I am accessing google")</span></pre><p id="45dd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦我们实例化了RPA，我们将继续规划和协调它需要执行的一系列活动。在我们脚本的最后，我们将做一些清理工作:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b13c" class="mf mg it mb b gy mh mi l mj mk">mybot.driver.quit()<br/>mybot.log_bot_completion()<br/></span></pre><p id="f72c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在RPA脚本运行期间的任何时候，都可以通过pybotlib.driver访问控制firefox的selenium webdriver，或者您可以调用webdriver之上的其他方法。一些便利的方法可以让浏览网页变得更容易，其中之一就是“virtual agent . find _ by _ tag _ and _ attr()”。</p><p id="696d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该方法将返回所有带有特定标签和属性的HTML元素，这些标签和属性对应于您决定的一些评估字符串。VirtualAgent对象必须已经实例化，并且webdriver已经初始化。<br/>如果我们想使用className = "hugebutton "搜索网页上的所有按钮，您可以使用以下代码:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8e25" class="mf mg it mb b gy mh mi l mj mk">mybutton = mybot.find_by_tag_and_attr(“button”, “className”, “hugebutton”, 1)</span></pre><p id="722d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您还可以直接与webdriver交互，并使用所提供的任何Selenium方法。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="dbc4" class="mf mg it mb b gy mh mi l mj mk"># Example<br/>mybot.driver.refresh()</span></pre><p id="eb03" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">设置我们的环境</strong></p><p id="b7bc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们知道了基础知识，让我们开始创建我们的RPA代码。最佳做法是让我们的整个RPA通过单个入口点运行，例如名为run_RPA.py或类似的python程序。为了实现这一点，我们将组织我们的代码。</p><p id="8ae6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">分离输入/输出数据并使RPA执行尽可能无状态也是最佳做法。我们开发的任何RPA都应该能够旋转，“检查”是否有未完成的工作要做，并相应地以最少的人工交互来执行这项工作。</p><p id="071e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用云文件存储是分离输入和输出数据的最佳方法。在本例中，我们将使用Google Sheets电子表格选项卡作为业务流程的输入，我们将启动一个minio对象存储容器，监听端口9000以存储我们的输出数据文件。我们的输入文件将是一个电子表格，其中包含需要查找的公司，我们的输出将只是一个文件夹，其中包含来自上述公司的SEC报告。我们的RPA应该能够加速旋转，检查是否有待处理的行，处理它们，然后保存输出。让我们创建我们的RPA将在其上运行的可变基础架构。一个包含两个图像的简单docker文件就足够了，一个容器将运行完整的Ubuntu桌面环境，另一个将运行我们的文件存储(在这种情况下，我们将使用minio)。我们可以为输出使用任何类型的对象存储，只要我们将RPA设计为“可销毁”,即任何需要持久存储的数据都存储在桌面环境之外的某个地方。对于您的组织来说，拥有一个包含所有持久数据的中央虚拟桌面可能更实用，但是您横向扩展RPA操作的规模越大，拥有一个不可变的基础架构就越方便。我们也可以使用minio作为我们的数据输入源，但是使用google sheet会比手动编辑电子表格并上传更加用户友好。</p><p id="5666" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们回到编码上来。</p><p id="e72b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先让我们创建一个“docker-compose.yml”。</p><p id="3b27" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该文件的内容应该如下:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1179" class="mf mg it mb b gy mh mi l mj mk">version: "3"<br/><br/>services:<br/>  virtual-desktop:<br/>    image: dorowu/ubuntu-desktop-lxde-vnc:bionic-lxqt<br/>    ports:<br/>      - "5910:5900"<br/>    environment:<br/>      - USER=robot<br/>      - PASSWORD=robot<br/>      - MINIO_ACCESS_KEY=V42FCGRVMK24JJ8DHUYG<br/>      - MINIO_SECRET_KEY=bKhWxVF3kQoLY9kFmt91l+tDrEoZjqnWXzY9Eza<br/>  minio:<br/>    hostname: minio<br/>    image: minio/minio<br/>    container_name: minio<br/>    ports:<br/>      - "9000:9000"<br/>    environment:<br/>      - MINIO_ACCESS_KEY=123456<br/>      - MINIO_SECRET_KEY=password<br/>    command: server /data</span></pre><p id="563d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们要做的就是启动我们的容器，并开始开发我们的RPA。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ff5a" class="mf mg it mb b gy mh mi l mj mk">docker-compose up -d</span></pre><p id="e2e4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们现在可以使用任何VNC客户端连接到我们的虚拟桌面。您可以在windows或Mac上使用RealVNC。Ubuntu有一个内置的远程桌面客户端，可以创造奇迹。桌面应该可以通过<a class="ae lj" href="http://127.0.0.1:5910`" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5910 </a>访问。如果您想通过浏览器访问桌面，您可以映射noVNC http端口并通过浏览器访问它。请注意，默认情况下，安全性是关闭的。在虚拟桌面中创建的用户称为robot，其密码为robot。这可以在docker-compose.yml文件中更改。</p><p id="49a5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">需要安装python 3.7并将其设置为默认版本的初始配置。建议快速检查以确保firefox能够正常运行。在资源非常有限的情况下运行可能会导致问题。</p><p id="929f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">容器启动后，通过远程桌面连接到Ubuntu容器，并打开一个终端(Shift + Ctrl + t)。运行以下命令进行初始配置:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0166" class="mf mg it mb b gy mh mi l mj mk">sudo apt-get update &amp;&amp; sudo apt-get install python3.7 nano python3-pip curl wget git &amp;&amp; alias python=python3.7 &amp;&amp; echo ‘alias python=python3.7’ &gt;&gt; /home/robot/.bashrc<br/># Remember that the password for robot is robot<br/>python -m pip install pybotlib ipython</span></pre><p id="5cbf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这些命令中，我们安装了python 3.7，将其设置为使用python word时调用的默认命令，并从python包索引中安装了pybotlib。出于调试目的，我们还安装了Ipython解释器。我们可以打开交互式解释器，检查我们的安装是否正确。</p><p id="7dcc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先通过运行以下命令启动IPython:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="631b" class="mf mg it mb b gy mh mi l mj mk">python — m IPython</span></pre><p id="a7f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后键入以下命令，并确保它成功执行。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e89d" class="mf mg it mb b gy mh mi l mj mk">import pybotlib</span></pre><p id="75ee" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> RPA开发</strong></p><p id="3428" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们在虚拟桌面中设置一个目录结构，并将其命名为edgar-RPA。我们将创建一个名为run_RPA.py的文件。<br/>这都可以从命令行完成。在虚拟桌面内打开另一个终端，并执行:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2271" class="mf mg it mb b gy mh mi l mj mk">mkdir /home/robot/Desktop/edgar-RPA<br/>touch /home/robot/Desktop/edgar-RPA/run_RPA.py</span></pre><p id="0572" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将在run_RPA.py文件中写入我们的RPA。您可以在您的主机上编辑文档，然后通过远程客户端将您的代码复制并粘贴到在虚拟桌面内运行的默认文本编辑器中，也可以直接在虚拟桌面内编辑。如果你选择后者，我推荐你下载atom到虚拟桌面上作为文本编辑器，因为默认程序对于编写代码来说是非常可怕的。如果你想回到过去，你可以使用nano或vim在虚拟桌面的终端中编写代码。</p><p id="a162" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您想使用nano，请确保从虚拟桌面的终端安装它。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0591" class="mf mg it mb b gy mh mi l mj mk">sudo apt-get install nano</span></pre><p id="f21b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我倾向于在主机上使用visual studio代码或atom，从编辑器中复制并粘贴文本。</p><p id="1c83" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们用前面几节中的初始pybotlib样板代码填充run_RPA.py。我们将在末尾添加几行代码来退出web浏览器。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="95d4" class="mf mg it mb b gy mh mi l mj mk">import os<br/>from pybotlib import VirtualAgent<br/>from pybotlib.utils import get_geckodriver<br/>from time import sleep<br/># Downloads the geckodriver<br/>get_geckodriver()<br/># Any file downloaded will be saved to the current working dir<br/># under a folder called bot_downloads<br/>bot_download_dir = os.path.join(os.getcwd(),"bot_downloads")<br/><br/>mybot=VirtualAgent(<br/>  bot_name="my_first_robot",<br/>  downloads_directory=bot_download_dir,<br/>  # In order to load specific profiles from host machine<br/>  firefoxProfile="/home/robot/.mozilla/firefox" )<br/># Start a web browser that can be accessed via mybot.driver or other mybot methods<br/>mybot.create_log_file()<br/>mybot.initialize_driver()<br/>mybot.get("http://www.google.com")<br/>mybot.log("I am accessing google")<br/>sleep(5)<br/>mybot.log_bot_completion()<br/>mybot.driver.quit()</span></pre><p id="657d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，让我们通过在虚拟桌面的终端中运行以下命令来测试到目前为止一切正常。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f2d8" class="mf mg it mb b gy mh mi l mj mk">python run_RPA.py</span></pre><p id="1a0f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">确保我们当前的工作目录是包含我们代码的文件夹。Firefox应该会打开并访问google，然后在5秒钟后关闭。您还可以通过键入echo $来检查程序的退出状态。，除0之外的任何值都意味着出错。</p><p id="3aab" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我们继续之前，让我们将项目文件夹初始化为一个git存储库，它可以在Ubuntu虚拟桌面的潜在实例中克隆和执行。<br/>你可以使用任何你喜欢的在线回购，在这种情况下，我将在github UI中创建一个私有的github存储库，url如下:【https://github.com/dkatz23238/testfinanceRPA.git T4】，然后在我目前工作的虚拟桌面中执行以下命令。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ce71" class="mf mg it mb b gy mh mi l mj mk">cd /home/robot/Desktop/edgar-RPA<br/>git init<br/>git add .<br/>git commit -m “first commit”<br/>git remote add origin <a class="ae lj" href="https://github.com/dkatz23238/testfinanceRPA.git" rel="noopener ugc nofollow" target="_blank">https://github.com/dkatz23238/testfinanceRPA.git</a><br/>git push -u origin master</span></pre><p id="5b49" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们可以跟踪代码的进度并对其进行版本化。</p><p id="6756" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们从创建RPA的功能元素开始。我建议我们创建一个名为RPA_activities.py的单独文件，将我们的活动从该文件导入run_RPA.py文件，并从该文件执行我们的RPA。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9794" class="mf mg it mb b gy mh mi l mj mk">touch /home/robot/Desktop/edgar-RPA/RPA_activities.py</span></pre><p id="a119" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如前所述，RPA将从SEC网站下载具体的财务报告。任何RPA通常都需要输入和输出业务数据，选择使用什么可以有所不同，但对于这个RPA，我将选择使用Google Sheets电子表格作为输入，并使用minio对象存储作为文档输出。我们可以在GSheet中创建一个电子表格，并生成一个仅供RPA使用的查看URL。这些数据可以由我们的RPA读入熊猫。数据帧使用:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="dcb7" class="mf mg it mb b gy mh mi l mj mk">pybotlib.utils.pandas_read_google_sheets(sheet_id)</span></pre><p id="6bd2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的RPA的功能元素将是一个函数，它将VirtualAgent实例作为输入，并通过导航网站的前端从SEC网站下载一系列报告。将定义第二个函数来实例化我们的VirtualAgent，然后将数据保存到我们选择的相应存储中。我们必须向RPA传递一些env变量，它将使用这些变量来访问不同的附加资源。现在，我们将在执行RPA之前在shell中定义它们。首先让我们对我们的文件进行一些修改，以便在一个文件中包含我们的活动，然后我们的第二个文件将简单地导入活动，并按照我们定义的方式执行它们。在本文中，我不会深入研究RPA如何下载报告的细节，这纯粹是通过pybotlib中提供的selenium webdriver和helper函数导航前端来完成的。</p><p id="e643" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">RPA_activities.py</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d2cb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">run_RPA.py</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7c88" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如您所见，我们已经将代码和业务逻辑移到RPA_activites.py文件中，我们的run_RPA.py文件只是将RPA作为RPA的入口点来调用和运行。</p><p id="6e85" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">关于我们导航SEC网页前端的具体方法，请参考Selenium webdriver文档以及github中pybotlib的README.md。</p><p id="34bd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此时，我们要做的就是定义环境变量并执行RPA。请记住，我们有一个minio实例正在运行，RPA将在其中保存数据。</p><p id="9483" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的RPA代码利用了必须预定义的环境变量，以便RPA访问某些连接的资源或出于其他原因。环境变量是构建代码的一个很好的工具，它可以很容易地变得尽可能无状态，并使用某些信息(如URL、密钥和密码)来访问附加的资源。这是12因素应用程序开发方法的基本概念，您可以从这里了解更多信息</p><p id="4a7d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">从虚拟桌面终端内执行的以下代码应该可以端到端地运行我们的RPA。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="beb6" class="mf mg it mb b gy mh mi l mj mk">export MINIO_URL=minio;<br/>export MINIO_ACCESS_KEY=123456;<br/>export MINIO_SECRET_KEY=password;<br/>export MINIO_OUTPUT_BUCKET_NAME=financials;<br/>export GSHEET_ID=1pBecz5Db9eK0QDR_oePmamdaFtEiCaO69RaE-Ozduko;<br/>export DISPLAY=:1;<br/>python run_RPA.py</span></pre><p id="700c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">RPA完成后，我们可以通过minio URL中的浏览器访问文件。<br/>我们的最后一步是创建一个可以在虚拟桌面内的任何地方执行的单一shell脚本，并运行我们的RPA。</p><p id="41a2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们需要做的就是将上述命令添加到shell脚本中，使我们成为RPA的单一入口点。我们可以将RPA的全部内容推送到git存储库，从头开始测试克隆存储库并重新执行RPA。这将确保我们的RPA满足“可破坏条件”。让我们让我们的RPA在做最后一次推送之前不打印我们的env变量，从而使我们的RPA更加安全友好。</p><p id="55e0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">目前，此RPA足以演示本文的目的，但是对此RPA的增强将是添加测试、更好的异常处理和自动化部署。这些主题将在下一篇文章中讨论。</p><p id="207b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的最终项目将包含以下文件:</p><p id="9bb8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">埃德加-RPA<br/>—run _ RPA . py<br/>—RPA _ activites . py<br/>—run _ RPA . sh</p><p id="8bc5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">将目录切换到文件夹并运行/bin/bash run_RPA.sh应该可以运行我们的端到端流程。最后，我们可以添加初始命令来下载依赖项并为run_RPA.sh脚本分配别名，将其推送到git，然后进行克隆和重新运行测试，以确保我们的RPA可以在运行我们特定虚拟桌面映像的任何docker容器中的任何基础架构上运行。</p><p id="b960" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们还可以向run_RPA.sh添加环境变量，以便从远程shell执行RPA，而无需登录GUI。为此，我们可以将以下环境变量添加到run_RPA.sh脚本中。这个上面已经加了。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="668d" class="mf mg it mb b gy mh mi l mj mk">export DISPLAY=:1</span></pre><p id="9d04" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们最终的run_RPA.sh脚本将如下所示</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="001f" class="mf mg it mb b gy mh mi l mj mk">#! /bin/bash<br/>export MINIO_URL=minio;<br/>export MINIO_ACCESS_KEY=123456;<br/>export MINIO_SECRET_KEY=password;<br/>export MINIO_OUTPUT_BUCKET_NAME=financials;<br/>export GSHEET_ID=1pBecz5Db9eK0QDR_oePmamdaFtEiCaO69RaE-Ozduko;<br/>export DISPLAY=:1;<br/># Pip will only use the current users directory<br/>python3.7 -m pip install — user robot — no-cache-dir pybotlib;<br/>python3.7 run_RPA.py;</span></pre><p id="6024" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们可以从主机进入虚拟桌面，远程执行RPA。<br/>为了测试此功能，我们可以从我们的主机访问一个正在运行的shell，以访问RPA要在其上运行的虚拟桌面。在包含docker-compose-yml文件的目录中，下面的命令将从我们的主机启动客户机中的一个shell。注意，产生的新shell对应于容器，而不是主机。从这里，我们可以进入code directory文件夹，将RPA作为bash命令运行，并通过我们的远程桌面客户端观察我们的启动是否正常，就像您通过用户界面登录一样。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fcc8" class="mf mg it mb b gy mh mi l mj mk">docker-compose exec — user robot virtual-desktop /bin/bash</span><span id="38d7" class="mf mg it mb b gy mn mi l mj mk"># From within the new shell we can navigate to our code directory # and run the shell script.<br/>sudo -H -u robot bash -c bash run_RPA.sh</span></pre><p id="5400" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此时，我们可以将虚拟桌面映像部署到任何支持docker的基础架构，克隆我们新创建的RPA并执行它。这可能会让您节省大量计算时间成本，因为您可以根据需要扩展大量RPA来满足工作需求。</p><p id="873f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我希望你喜欢我的文章，并随时通过我的任何社交媒体档案与我联系。</p></div></div>    
</body>
</html>