<html>
<head>
<title>Introducing a metadata management system that uses NebulaGraph as a graph database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍一个使用NebulaGraph作为图形数据库的元数据管理系统</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-a-metadata-management-system-that-uses-nebulagraph-as-a-graph-database-2ab5777f8d73?source=collection_archive---------4-----------------------#2022-08-11">https://itnext.io/introducing-a-metadata-management-system-that-uses-nebulagraph-as-a-graph-database-2ab5777f8d73?source=collection_archive---------4-----------------------#2022-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/112c5a9cbce37816bc2dc066e90f7bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L6z0Y72rWVmuafih.jpg"/></div></div></figure><blockquote class="jy jz ka"><p id="01e2" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了建立元数据管理和数据沿袭系统，我是否必须创建自己的图形模型和所有东西？感谢许多伟大的开源项目，答案是:不！</p></blockquote><p id="ed6e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">今天，我想与一些最好的开源项目分享我坚持的参考数据基础设施堆栈，这些项目包括现代ETL、仪表板、元数据治理和数据沿袭管理。</p><h1 id="9dc4" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">元数据治理系统</h1><p id="3e4e" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">元数据治理系统是一个提供单一视图的系统，该视图显示所有数据在何处以及如何被格式化、生成、转换、消费、呈现和拥有。</p><p id="9995" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">元数据治理就像所有数据仓库、数据库、表、仪表板、ETL作业等的目录。有了元数据治理系统，人们就不必问一些多余的问题，比如“大家好，我可以更改这个表的模式吗？”、“嘿，谁知道我怎么能找到table-view-foo-bar的原始数据？”这可能就是为什么我们需要一个成熟数据堆栈中的元数据治理系统来处理相对大规模的数据和团队(或不断增长的数据和团队)。</p><p id="0aaf" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">对于另一个术语，数据沿袭是元数据的一种类型，应该尽可能地进行管理，以确保数据驱动团队中的信任链。数据谱系揭示了数据的生命周期——它旨在显示完整的数据流，从开始到结束。</p><h1 id="08be" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">参考溶液</h1><h2 id="43bc" class="mg le iq bd lf mh mi dn lj mj mk dp ln la ml mm lr lb mn mo lv lc mp mq lz mr bi translated">动机</h2><p id="ddc6" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">元数据和数据沿袭本质上都适合图形模型字段。数据历程中面向关系的查询，例如，“查找每个给定组件(即表)的所有n深度数据历程”，本质上是图形数据库中的查找所有路径查询。</p><p id="a1a2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这也解释了我作为一个分布式图形数据库NebulaGraph的开源软件(OSS)贡献者的一个观察结果:(从他们在讨论中的查询/图形建模，我可以告诉)许多已经在他们的技术栈中利用NebulaGraph的团队，正在从头开始建立他们自己的数据血统系统。</p><p id="bc8f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">元数据治理系统需要以下一些组件:</p><ul class=""><li id="21bf" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">元数据提取器:元数据提取器是数据堆栈的不同部分，如数据库、数据仓库、仪表板、ETL管道和应用程序，向元数据治理系统推送数据或从中提取数据。</li><li id="51e7" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">元数据存储:存储部分可以是数据库，甚至是大型JSON清单文件。</li><li id="35cc" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">元数据目录:这可能是一个提供API和/或GUI接口来读/写元数据和数据沿袭的系统。</li></ul><p id="4bf4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在NebulaGraph社区中，我看到许多图形数据库用户构建他们自己的数据谱系系统。目睹这项工作没有被标准化或共同贡献是令人发痒的，因为他们的大部分工作基本上是解析来自知名大数据项目的元数据，并将其存储在图形数据库中。</p><p id="f82a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然后，我创建了这个固执己见的参考数据基础设施堆栈，将一些最好的开源项目放在一起。希望那些打算在NebulaGraph上定义和迭代他们自己的图形建模方式，并创建内部元数据和数据线性提取管道的人可以从这个项目中受益，拥有一个相对完善、设计精美的元数据治理系统，开箱即用，具有完全进化的图形模型。</p><p id="7a49" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">为了使参考项目自包含且可运行，我尝试将数据基础设施层堆叠在一起，而不仅仅是与元数据相关的层。因此，它可能会帮助新的数据工程师，他们想尝试看看开源将现代数据实验室推进到了什么程度。</p><p id="7c04" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这是该参考数据堆栈中所有组件的图表，其中我将大多数组件视为元数据源:</p><h1 id="f31e" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">数据堆栈</h1><p id="fe16" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">首先，我们来介绍一下组件。</p><p id="7bc9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">数据库和数据仓库</p><p id="5e6f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">为了处理和消费原始和中间数据，我们需要一个或多个数据库和/或仓库。</p><p id="be66" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">它可以是任何DB/DW，包括Hive、Apache Delta、TiDB、Cassandra、MySQL或Postgres。在这个项目中，我们简单地选择一个最流行的:PostgreSQL。我们的参考实验室提供第一项服务:</p><p id="c1ff" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">✅ —数据仓库:PostgreSQL</p><p id="e873" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">数据操作</p><p id="a8b0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们应该有某种类型的数据操作设置，以使管道和环境可重复、可测试并受版本控制。</p><p id="b8a4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在这里，我们使用GitLab创建的<a class="ae ng" href="https://gitlab.com/meltano/meltano" rel="noopener ugc nofollow" target="_blank"> Meltano </a>。</p><p id="1db2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Meltano是一个工作正常的DataOps平台，它以优雅的方式连接了作为提取和加载(EL)的<a class="ae ng" href="https://singer.io/" rel="noopener ugc nofollow" target="_blank">歌手</a>和作为转换(T)的<a class="ae ng" href="https://getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt </a>。它还连接到其他一些数据基础设施实用程序，如Apache Superset和Apache Airflow。</p><p id="796f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">现在，我们已经准备好数据操作了。</p><p id="67e5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">✅——吉托普斯:梅尔塔诺</p><p id="486e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">抽取、转换、加载至目的端（extract-transform-load的缩写）</p><p id="b56b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在引擎盖下，我们将通过利用<a class="ae ng" href="https://singer.io/" rel="noopener ugc nofollow" target="_blank"> Singer </a>和Meltano将来自许多不同数据源的数据E(提取)和L(加载)到数据目标，并用<a class="ae ng" href="https://getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt </a>进行T(转换)。</p><p id="91cb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">✅-艾尔:歌手</p><p id="8a1c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">✅ —时间:dbt</p><p id="de0e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">数据可视化</p><p id="bfe7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">创建仪表板、图表和表格来获得所有数据的洞察力怎么样？</p><p id="6598" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Apache超集是我们可以选择的最好的可视化平台之一。现在让我们把它添加到我们的包中吧！</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/33d7bc8db5ed5e3e964a36253fef5c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o3PmIjjo_iSuIH2f.png"/></div></div></figure><p id="2a53" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">✅-仪表板:Apache超集</p><p id="bce3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">作业编排</p><p id="27d2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在大多数情况下，我们的数据操作作业增长到需要协调的长时间执行的规模，这里出现了<a class="ae ng" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache气流</a>。</p><p id="5a05" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">✅ — DAG:阿帕奇气流</p><p id="1a31" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">元数据治理</p><p id="8d64" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">随着越来越多的组件和数据被引入到数据基础架构中，数据库、表、模式、仪表板、Dag、应用程序的所有生命周期中都将存在大量元数据。他们的管理员和团队可以被集中管理、连接和发现。</p><p id="9438" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><a class="ae ng" href="https://www.amundsen.io/amundsen/" rel="noopener ugc nofollow" target="_blank"> Linux基金会Amundsen </a>就是解决这个问题的最好项目之一。</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/7add872f7455cfb901b0b5515f39115c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6GACACTqdN2qGGTy.png"/></div></div></figure><p id="fe0a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">✅ —数据发现:Linux基金会阿蒙森</p><p id="7c9a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">使用图形数据库作为事实的来源来加速多跳查询，并使用Elasticsearch作为全文搜索引擎，Amundsen在下一个级别中平滑而漂亮地索引了所有元数据及其谱系。</p><p id="d51c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">默认情况下，<a class="ae ng" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>被用作图形数据库。然而，我将在这个项目中使用<a class="ae ng" href="http://nebula-graph.io/" rel="noopener ugc nofollow" target="_blank">星云图</a>，因为我更熟悉它。</p><p id="91ed" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">✅ —全文搜索:弹性搜索</p><p id="3a47" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">✅——图形数据库:星云图</p><p id="1473" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">现在，随着堆栈中组件的出现，让我们将它们组装起来。</p><h1 id="e638" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">环境引导，组件概述</h1><p id="0cd6" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">参考runnable项目是开源的，您可以在下面找到它:</p><ul class=""><li id="e36d" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated"><a class="ae ng" href="https://github.com/wey-gu/data-lineage-ref-solution" rel="noopener ugc nofollow" target="_blank">https://github.com/wey-gu/data-lineage-ref-solution</a></li></ul><p id="ea26" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我会尽力让事情变得干净和孤立。假设您运行在一个类似UNIX的系统上，该系统有互联网连接并安装了Docker Compose。</p><blockquote class="jy jz ka"><p id="b189" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">请参考</em> <a class="ae ng" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">此处</em> </a> <em class="iq">安装Docker和Docker Compose后再前进。</em></p></blockquote><p id="875a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我在Ubuntu 20.04 LTS X86_64上运行它，但在Linux的其他发行版或版本上应该不会有任何问题。</p><h2 id="8175" class="mg le iq bd lf mh mi dn lj mj mk dp ln la ml mm lr lb mn mo lv lc mp mq lz mr bi translated">运行数据仓库/数据库</h2><p id="b737" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">首先，让我们安装Postgres作为我们的数据仓库。</p><p id="5091" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这个oneliner将帮助用docker创建一个在后台运行的Postgres，当它被停止时将被清理掉(— rm)。</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="15f1" class="mg le iq nn b gy nr ns l nt nu">docker run --rm --name postgres \<br/>    -e POSTGRES_PASSWORD=lineage_ref \<br/>    -e POSTGRES_USER=lineage_ref \<br/>    -e POSTGRES_DB=warehouse -d \<br/>    -p 5432:5432 postgres</span></pre><p id="f029" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然后我们可以用Postgres CLI或GUI客户机来验证它。</p><blockquote class="jy jz ka"><p id="6cf7" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">提示:您可以使用VS代码扩展:</em> <a class="ae ng" href="https://marketplace.visualstudio.com/items?itemName=mtxr.sqltools" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> SQL工具</em> </a> <em class="iq">快速连接到多个RDBMS(MariaDB、Postgres等。)甚至像Cassandra这样的非SQL DBMS。</em></p></blockquote><h2 id="e380" class="mg le iq bd lf mh mi dn lj mj mk dp ln la ml mm lr lb mn mo lv lc mp mq lz mr bi translated">为ETL设置数据操作工具链</h2><p id="0540" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">然后，让我们用Singler得到Meltano并安装dbt。</p><p id="fba6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Meltano帮助我们管理ETL工具(作为插件)和它们的所有配置(管道)。这些元信息位于Meltano配置及其<a class="ae ng" href="https://docs.meltano.com/concepts/project#system-database" rel="noopener ugc nofollow" target="_blank">系统数据库</a>中，其中的配置是基于文件的(可以用git管理)。默认情况下，系统数据库是SQLite。</p><p id="52f8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">安装Meltano</p><p id="706d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">使用Meltano的工作流程是启动一个meltano项目，并开始将E、L和T添加到配置文件中。项目的启动只需要一个CLI命令调用:meltano init yourprojectname，为此，我们可以使用Python的package manager: pip或通过Docker映像安装meltano:</p><ul class=""><li id="2113" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">在python虚拟环境中安装Meltano和pip:</li></ul><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="b601" class="mg le iq nn b gy nr ns l nt nu">mkdir .venv<br/># example in a debian flavor Linux distro<br/>sudo apt-get install python3-dev python3-pip python3-venv python3-wheel -y<br/>python3 -m venv .venv/meltano<br/>source .venv/meltano/bin/activate<br/>python3 -m pip install wheel<br/>python3 -m pip install meltano</span><span id="6210" class="mg le iq nn b gy nv ns l nt nu"># init a project<br/>mkdir meltano_projects &amp;&amp; cd meltano_projects<br/># replace &lt;yourprojectname&gt; with your own one<br/>touch .env<br/>meltano init &lt;yourprojectname&gt;</span></pre><ul class=""><li id="9aaa" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">通过Docker安装Meltano</li></ul><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="994f" class="mg le iq nn b gy nr ns l nt nu">docker pull meltano/meltano:latest<br/>docker run --rm meltano/meltano --version</span><span id="5945" class="mg le iq nn b gy nv ns l nt nu"># init a project<br/>mkdir meltano_projects &amp;&amp; cd meltano_projects</span><span id="5b77" class="mg le iq nn b gy nv ns l nt nu"># replace &lt;yourprojectname&gt; with your own one<br/>touch .env<br/>docker run --rm -v "$(pwd)":/projects \<br/>             -w /projects --env-file .env \<br/>             meltano/meltano init &lt;yourprojectname&gt;</span></pre><p id="5600" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">除了meltano init，还有一些其他的命令，比如meltano etl来执行etl执行，meltano调用<plugin>来调用插件的命令，总是检查<a class="ae ng" href="https://docs.meltano.com/reference/command-line-interface" rel="noopener ugc nofollow" target="_blank"> cheatsheet </a>来快速参考。</plugin></p><p id="1675" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">梅尔塔诺界面</p><p id="62d6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Meltano还带有一个基于网络的用户界面，要启动它，只需运行:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="9429" class="mg le iq nn b gy nr ns l nt nu">meltano ui</span></pre><p id="d8c8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">它在监听<a class="ae ng" href="http://localhost:5000." rel="noopener ugc nofollow" target="_blank"> http://localhost:5000。</a></p><p id="17b6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">对于Docker，只需运行暴露了5000端口的容器，这里我们最终没有提供ui，因为容器的默认命令已经是meltano ui了。</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="6635" class="mg le iq nn b gy nr ns l nt nu">docker run -v "$(pwd)":/project \<br/>             -w /project \<br/>             -p 5000:5000 \<br/>             meltano/meltano</span></pre><p id="38b6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">梅尔塔诺项目示例</p><p id="e1a3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在写这篇文章的时候，我注意到<a class="ae ng" href="https://github.com/pnadolny13" rel="noopener ugc nofollow" target="_blank"> Pat Nadolny </a>已经在一个带有dbt的Meltano示例数据集上创建了<a class="ae ng" href="https://github.com/pnadolny13/meltano_example_implementations/tree/main/meltano_projects/singer_dbt_jaffle" rel="noopener ugc nofollow" target="_blank">优秀示例</a>(还带有<a class="ae ng" href="https://github.com/pnadolny13/meltano_example_implementations/tree/main/meltano_projects/dbt_orchestration" rel="noopener ugc nofollow" target="_blank"> Airflow </a>和<a class="ae ng" href="https://github.com/pnadolny13/meltano_example_implementations/tree/main/meltano_projects/jaffle_superset" rel="noopener ugc nofollow" target="_blank">超集</a>)!).我们不会重新创建的例子，而是使用帕特的伟大的。</p><blockquote class="jy jz ka"><p id="8a84" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">注意，Andrew Stewart创建了另一个版本，它的配置文件版本稍旧。</em></p></blockquote><p id="162b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">您可以跟随<a class="ae ng" href="https://github.com/pnadolny13/meltano_example_implementations/tree/main/meltano_projects/singer_dbt_jaffle" rel="noopener ugc nofollow" target="_blank">到这里</a>来运行一个管道:</p><ul class=""><li id="5455" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated"><a class="ae ng" href="https://hub.meltano.com/taps/csv" rel="noopener ugc nofollow" target="_blank"> tap-CSV </a> (Singer)，从CSV文件中提取数据</li><li id="dbca" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated"><a class="ae ng" href="https://hub.meltano.com/targets/postgres" rel="noopener ugc nofollow" target="_blank"> target-postgres </a> (Singer)，加载数据到postgres</li><li id="0770" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated"><a class="ae ng" href="https://hub.meltano.com/transformers/dbt" rel="noopener ugc nofollow" target="_blank"> dbt </a>，将数据转换成聚合表或视图</li></ul><blockquote class="jy jz ka"><p id="1d85" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">您应该省略用docker运行本地Postgres的步骤，因为我们已经创建了一个。请确保在您的中更改Postgres用户和密码。环境文件。</em></p></blockquote><p id="60fa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">基本上是这样的(如上安装meltano):</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="b5dc" class="mg le iq nn b gy nr ns l nt nu">git clone https://github.com/pnadolny13/meltano_example_implementations.git<br/>cd meltano_example_implementations/meltano_projects/singer_dbt_jaffle/<br/>meltano install<br/>touch .env<br/>echo PG_PASSWORD="lineage_ref" &gt;&gt; .env<br/>echo PG_USERNAME="lineage_ref" &gt;&gt; .env<br/># Extract and Load(with Singer)<br/>meltano run tap-csv target-postgres</span><span id="5752" class="mg le iq nn b gy nv ns l nt nu"># Trasnform(with dbt)<br/>meltano run dbt:run<br/># Generate dbt docs<br/>meltano invoke dbt docs generate<br/># Serve generated dbt docs<br/>meltano invoke dbt docs to serve<br/># Then visit <a class="ae ng" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></span></pre><p id="9252" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">现在，我假设您已经按照singer_dbt_jaffle的<a class="ae ng" href="https://github.com/pnadolny13/meltano_example_implementations/tree/main/meltano_projects/singer_dbt_jaffle" rel="noopener ugc nofollow" target="_blank"> README.md </a>完成了对它的测试，我们可以连接到Postgres实例来查看加载和转换后的数据，如下所示，截图来自VS代码的SQLTool:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4a9a389f8fb4074d850a140b792ec247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ikG2NtEWj-rhIIZ_.png"/></div></div></figure><h2 id="59f6" class="mg le iq bd lf mh mi dn lj mj mk dp ln la ml mm lr lb mn mo lv lc mp mq lz mr bi translated">为仪表板设置BI平台</h2><p id="1afd" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">现在，我们将数据存储在数据仓库中，通过ETL工具链将不同的数据源导入其中。如何使用这些数据？</p><p id="6dd5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">像仪表板这样的BI工具可能是帮助我们从数据中获得洞察力的一种方式。</p><p id="1559" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">有了Apache超集，基于这些数据源的仪表板和图表可以被流畅而漂亮地创建和管理。</p><p id="22e4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这个项目的焦点不在Apache超集本身，因此，我们简单地重用了Pat Nadolny在meltano示例中创建的实用程序<a class="ae ng" href="https://github.com/pnadolny13/meltano_example_implementations/tree/main/meltano_projects/jaffle_superset" rel="noopener ugc nofollow" target="_blank">中的示例。</a></p><p id="b39c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">自举梅尔塔诺和超集</p><p id="0ef9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">创建一个安装了Meltano的python venv:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="f0b8" class="mg le iq nn b gy nr ns l nt nu">mkdir .venv<br/>python3 -m venv .venv/meltano<br/>source .venv/meltano/bin/activate<br/>python3 -m pip install wheel<br/>python3 -m pip install meltano</span></pre><p id="6ce4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">遵循<a class="ae ng" href="https://github.com/pnadolny13/meltano_example_implementations/tree/main/meltano_projects/jaffle_superset" rel="noopener ugc nofollow" target="_blank"> Pat的指南</a>，稍作修改:</p><ul class=""><li id="5105" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">克隆repo，进入jaffle_superset项目</li></ul><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="0af5" class="mg le iq nn b gy nr ns l nt nu">git clone https://github.com/pnadolny13/meltano_example_implementations.git<br/>cd meltano_example_implementations/meltano_projects/jaffle_superset/</span></pre><ul class=""><li id="d6c7" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">修改meltano配置文件，让Superset连接到我们创建的Postgres:</li></ul><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="45fb" class="mg le iq nn b gy nr ns l nt nu">vim meltano_projects/jaffle_superset/meltano.yml</span></pre><p id="cfd5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在我的例子中，我将主机名改为10.1.1.111，这是我当前主机的IP地址。但是，如果您在macOS机器上运行它，这应该没问题，更改前后的差异是:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="030b" class="mg le iq nn b gy nr ns l nt nu">--- a/meltano_projects/jaffle_superset/meltano.yml<br/>+++ b/meltano_projects/jaffle_superset/meltano.yml<br/>@@ -71,7 +71,7 @@ plugins:<br/>               A list of database driver dependencies can be found here https://superset.apache.org/docs/databases/installing-database-drivers<br/>     config:<br/>       database_name: my_postgres<br/>-      sqlalchemy_uri: postgresql+psycopg2://${PG_USERNAME}:${PG_PASSWORD}@host.docker.internal:${PG_PORT}/${PG_DATABASE}<br/>+      sqlalchemy_uri: postgresql+psycopg2://${PG_USERNAME}:${PG_PASSWORD}@10.1.1.168:${PG_PORT}/${PG_DATABASE}<br/>       tables:<br/>       - model.my_meltano_project.customers<br/>       - model.my_meltano_project.orders</span></pre><ul class=""><li id="de92" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">将Postgres凭据添加到。环境文件:</li></ul><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="7070" class="mg le iq nn b gy nr ns l nt nu">echo PG_USERNAME=lineage_ref &gt;&gt; .env<br/>echo PG_PASSWORD=lineage_ref &gt;&gt; .env</span></pre><ul class=""><li id="0a45" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">安装Meltano项目，运行ETL管道</li></ul><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="d1d9" class="mg le iq nn b gy nr ns l nt nu">meltano install<br/>meltano run tap-csv target-postgres dbt:run</span></pre><ul class=""><li id="13c1" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">启动超集，请注意ui不是meltano命令，而是配置文件中的用户自定义动作。</li></ul><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="5f0d" class="mg le iq nn b gy nr ns l nt nu">meltano invoke superset:ui</span></pre><ul class=""><li id="83f2" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">在另一个终端中，运行定义的命令load_datasources</li></ul><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="45bb" class="mg le iq nn b gy nr ns l nt nu">meltano invoke superset:load_datasources</span></pre><ul class=""><li id="2471" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">通过<a class="ae ng" href="http://localhost:8088/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8088/ </a>在网络浏览器中访问超集</li></ul><p id="e391" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们现在应该看到超集Web界面:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/9856c29ebbb81182f21e878b3b0032d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gQYMDVjuyy7hH72F.png"/></div></div></figure><p id="7a44" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">创建仪表板！</p><p id="e90e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">让我们试着在这个Meltano项目中定义的Postgres中创建一个关于ETL数据的仪表板:</p><ul class=""><li id="521e" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">单击+仪表板，填写仪表板名称，然后单击保存，然后单击+创建新图表</li></ul><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/5d0ea587810394f3e7ba029983f643a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hUJKMeqr0Djqggt3.png"/></div></div></figure><ul class=""><li id="2e5f" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">在新的图表视图中，我们应该选择一个图表类型和数据集。在这里，我选择了orders表作为数据源和饼图图表类型:</li></ul><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/70817c3c5460220747515ff137ebf96b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*upBTyF8ALezA00tS.png"/></div></div></figure><ul class=""><li id="b758" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">单击“CREATE NEW CHART ”(创建新图表)后，我们将进入图表定义视图，在该视图中，我选择了“Query of status ”(状态查询)作为维度，选择了“COUNT(数量)”作为指标。因此，我们可以看到每个订单状态分布的饼图。</li></ul><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7993f30ab04a59848d2a8f517d250f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hFvdErAAKBRU1AKk.png"/></div></div></figure><ul class=""><li id="0500" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">单击保存，它将询问该图表应添加到哪个仪表板，选择后，单击保存并转到仪表板。</li></ul><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8d1222769f98b1261e6b7c4a177ee7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GYXDnmduLWm5Vhzs.png"/></div></div></figure><ul class=""><li id="e072" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">然后，在仪表板中，我们可以看到所有的图表。您可以看到，我还添加了另一个显示客户订单数量分布的图表:</li></ul><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/905ae53a08bfdbe2c91db4a80b86d79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BCvIPbP6KmXyT7sx.png"/></div></div></figure><ul class=""><li id="05fb" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">我们可以设置刷新间隔，或者按您的意愿点击按钮下载仪表板。</li></ul><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/de685f1b087917ac6e8205260661950e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4S3hgpS5VPVE5Uxn.png"/></div></div></figure><p id="db37" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">挺爽的啊？目前，我们有一个简单但典型的数据堆栈，就像任何爱好数据实验室一样，一切都是开源的！</p><p id="c694" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">假设我们有100个CSV格式的数据集，数据仓库中有200个表，几个数据工程师运行不同的项目，使用和生成不同的应用程序、仪表板和数据库。当有人想要发现其中的一些表、数据集、仪表板和管道，然后甚至修改其中的一些时，这在通信工程中被证明是相当昂贵的。</p><p id="e414" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">接下来是我们参考项目的主要部分:元数据发现。</p><h2 id="ef6e" class="mg le iq bd lf mh mi dn lj mj mk dp ln la ml mm lr lb mn mo lv lc mp mq lz mr bi translated">元数据发现</h2><p id="3d17" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">然后，我们正在逐步部署Amundsen的NebulaGraph和Elasticsearch。</p><blockquote class="jy jz ka"><p id="c52a" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">注:暂时作为阿蒙森后端</em>  <em class="iq">的</em> <a class="ae ng" href="https://github.com/amundsen-io/amundsen/pull/1817" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> PR NebulaGraph还没有合并，我是</em> </a><a class="ae ng" href="https://github.com/amundsen-io/rfcs/pull/48" rel="noopener ugc nofollow" target="_blank"> <em class="iq">和阿蒙森团队</em> </a> <em class="iq">一起努力让它实现的。</em></p></blockquote><p id="87e3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">有了Amundsen，我们可以在一个地方发现和管理整个数据堆栈的所有元数据。阿蒙森主要有两部分:</p><ul class=""><li id="6f19" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">元数据摄取</li><li id="b4ec" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated"><a class="ae ng" href="https://www.amundsen.io/amundsen/databuilder/" rel="noopener ugc nofollow" target="_blank">阿蒙森数据生成器</a></li><li id="581b" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">元数据目录</li><li id="431b" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated"><a class="ae ng" href="https://www.amundsen.io/amundsen/frontend/" rel="noopener ugc nofollow" target="_blank">阿蒙森前端服务</a></li><li id="473d" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated"><a class="ae ng" href="https://www.amundsen.io/amundsen/metadata/" rel="noopener ugc nofollow" target="_blank">阿蒙森元数据服务</a></li><li id="adca" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">阿蒙森搜索服务公司</li></ul><p id="a6a7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们将利用Data builder从不同来源提取元数据，并将元数据保存到元服务的后端存储和搜索服务的后端存储中，然后我们可以从前端服务或通过元数据服务的API来搜索、发现和管理它们。</p><p id="2a55" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">部署阿蒙森</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="e38b" class="mg le iq nn b gy nr ns l nt nu">Metadata service</span></pre><p id="37eb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们将部署一个Amundsen集群及其docker-compose文件。由于NebulaGraph后端支持尚未合并，所以我们引用我的fork。</p><p id="2df3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">首先，让我们克隆带有所有子模块的repo:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="6560" class="mg le iq nn b gy nr ns l nt nu">git clone -b amundsen_nebula_graph --recursive git@github.com:wey-gu/amundsen.git<br/>cd amundsen</span></pre><p id="a121" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然后，启动所有目录服务及其后端存储:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="4b85" class="mg le iq nn b gy nr ns l nt nu">docker-compose -f docker-amundsen-nebula.yml up</span></pre><blockquote class="jy jz ka"><p id="444f" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">您可以添加-d来让容器在后台运行:</em></p></blockquote><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="57f4" class="mg le iq nn b gy nr ns l nt nu">docker-compose -f docker-amundsen-nebula.yml up -d</span></pre><p id="e0fe" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这将停止群集:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="26d8" class="mg le iq nn b gy nr ns l nt nu">docker-compose -f docker-amundsen-nebula.yml stop</span></pre><p id="ac7a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这将删除群集:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="1008" class="mg le iq nn b gy nr ns l nt nu">docker-compose -f docker-amundsen-nebula.yml down</span></pre><p id="e92d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">由于这个docker-compose文件是供开发人员轻松使用和破解Amundsen的，而不是用于生产部署，所以它是从代码库构建图像，这在第一次会花费一些时间。</p><p id="1b4b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">部署完成后，请稍等片刻，我们将使用Data builder将一些虚拟数据加载到其存储中。</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="cfbc" class="mg le iq nn b gy nr ns l nt nu">Data builder</span></pre><p id="d5a3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Amundsen Data builder就像Meltano，但用于元数据到元数据服务和搜索服务后端存储的ETL:Nebula Graph和Elasticsearch。这里的数据构建器只是一个python模块，ETL作业既可以作为脚本运行，也可以与Apache Airflow等DAG平台协调运行。</p><p id="7bcd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">随着<a class="ae ng" href="https://github.com/amundsen-io/amundsen/tree/main/databuilder" rel="noopener ugc nofollow" target="_blank">阿蒙森数据生成器</a>的安装:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="48e5" class="mg le iq nn b gy nr ns l nt nu">cd databuilder<br/>python3 -m venv .venv<br/>source .venv/bin/activate<br/>python3 -m pip install wheel<br/>python3 -m pip install -r requirements.txt<br/>python3 setup.py install</span></pre><p id="5086" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">让我们调用这个示例数据构建器ETL脚本来填充一些虚拟数据。</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="8492" class="mg le iq nn b gy nr ns l nt nu">python3 example/scripts/sample_data_loader_nebula.py</span><span id="c1cd" class="mg le iq nn b gy nv ns l nt nu">Verify Amundsen</span></pre><p id="ef0c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在访问Amundsen之前，我们需要创建一个测试用户:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="3aa4" class="mg le iq nn b gy nr ns l nt nu"># run a container with curl attached to amundsenfrontend<br/>docker run -it --rm --net container:amundsenfrontend nicolaka/netshoot</span><span id="02d3" class="mg le iq nn b gy nv ns l nt nu"># Create a user with id test_user_id<br/>curl -X PUT -v http://amundsenmetadata:5002/user \<br/>    -H "Content-Type: application/json" \<br/>    --data \<br/>    '{"user_id":"test_user_id","first_name":"test","last_name":"user", "email":"test_user_id@mail.com"}'</span><span id="9b16" class="mg le iq nn b gy nv ns l nt nu">exit</span></pre><p id="579d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然后我们可以在<a class="ae ng" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>查看UI，并尝试搜索test，它应该会返回一些结果。</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/871f7925daf543f1da8707fd7684b2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gD-hjlJGuyV1C73j.png"/></div></div></figure><p id="b441" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然后，您可以自己点击并浏览在sample_data_loader_nebula.py期间加载到Amundsen的那些虚拟元数据。</p><p id="e7c8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">此外，您可以使用Nebula Studio访问图形数据库(http://localhost:7001)。</p><blockquote class="jy jz ka"><p id="05ed" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">注意在Nebula Studio中，登录的默认字段是:</em></p></blockquote><ul class=""><li id="d6df" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">主机:graphd:9669</li><li id="97ae" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">用户:root</li><li id="6eaf" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">密码:星云</li></ul><p id="feed" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">该图显示了Amundsen组件的更多细节:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="64c1" class="mg le iq nn b gy nr ns l nt nu">┌────────────────────────┐ ┌────────────────────────────────────────┐<br/>       │ Frontend:5000          │ │ Metadata Sources                       │<br/>       ├────────────────────────┤ │ ┌────────┐ ┌─────────┐ ┌─────────────┐ │<br/>       │ Metaservice:5001       │ │ │        │ │         │ │             │ │<br/>       │ ┌──────────────┐       │ │ │ Foo DB │ │ Bar App │ │ X Dashboard │ │<br/>  ┌────┼─┤ Nebula Proxy │       │ │ │        │ │         │ │             │ │<br/>  │    │ └──────────────┘       │ │ │        │ │         │ │             │ │<br/>  │    ├────────────────────────┤ │ └────────┘ └─────┬───┘ └─────────────┘ │<br/>┌─┼────┤ Search searvice:5002   │ │                  │                     │<br/>│ │    └────────────────────────┘ └──────────────────┼─────────────────────┘<br/>│ │    ┌─────────────────────────────────────────────┼───────────────────────┐<br/>│ │    │                                             │                       │<br/>│ │    │ Databuilder     ┌───────────────────────────┘                       │<br/>│ │    │                 │                                                   │<br/>│ │    │ ┌───────────────▼────────────────┐ ┌──────────────────────────────┐ │<br/>│ │ ┌──┼─► Extractor of Sources           ├─► nebula_search_data_extractor │ │<br/>│ │ │  │ └───────────────┬────────────────┘ └──────────────┬───────────────┘ │<br/>│ │ │  │ ┌───────────────▼────────────────┐ ┌──────────────▼───────────────┐ │<br/>│ │ │  │ │ Loader filesystem_csv_nebula   │ │ Loader Elastic FS loader     │ │<br/>│ │ │  │ └───────────────┬────────────────┘ └──────────────┬───────────────┘ │<br/>│ │ │  │ ┌───────────────▼────────────────┐ ┌──────────────▼───────────────┐ │<br/>│ │ │  │ │ Publisher nebula_csv_publisher │ │ Publisher Elasticsearch      │ │<br/>│ │ │  │ └───────────────┬────────────────┘ └──────────────┬───────────────┘ │<br/>│ │ │  └─────────────────┼─────────────────────────────────┼─────────────────┘<br/>│ │ └────────────────┐   │                                 │<br/>│ │    ┌─────────────┼───►─────────────────────────┐ ┌─────▼─────┐<br/>│ │    │ Nebula Graph│   │                         │ │           │<br/>│ └────┼─────┬───────┴───┼───────────┐     ┌─────┐ │ │           │<br/>│      │     │           │           │     │MetaD│ │ │           │<br/>│      │ ┌───▼──┐    ┌───▼──┐    ┌───▼──┐  └─────┘ │ │           │<br/>│ ┌────┼─►GraphD│    │GraphD│    │GraphD│          │ │           │<br/>│ │    │ └──────┘    └──────┘    └──────┘  ┌─────┐ │ │           │<br/>│ │    │ :9669                             │MetaD│ │ │  Elastic  │<br/>│ │    │ ┌────────┐ ┌────────┐ ┌────────┐  └─────┘ │ │  Search   │<br/>│ │    │ │        │ │        │ │        │          │ │  Cluster  │<br/>│ │    │ │StorageD│ │StorageD│ │StorageD│  ┌─────┐ │ │  :9200    │<br/>│ │    │ │        │ │        │ │        │  │MetaD│ │ │           │<br/>│ │    │ └────────┘ └────────┘ └────────┘  └─────┘ │ │           │<br/>│ │    ├───────────────────────────────────────────┤ │           │<br/>│ └────┤ Nebula Studio:7001                        │ │           │<br/>│      └───────────────────────────────────────────┘ └─────▲─────┘<br/>└──────────────────────────────────────────────────────────┘</span></pre><h1 id="d56a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">连接点，元数据发现</h1><p id="5bdc" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">随着基础环境的建立，让我们把一切放在一起。</p><p id="4b55" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">还记得我们将一些数据像这样输出到PostgreSQL吗？</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3b7bbb89b2484d9fe88bc0b021f218b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4WCR4RzuqQv8IBIK.png"/></div></div></figure><p id="cbb2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们如何让Amundsen发现关于这些数据和ETL的元数据？</p><h2 id="7989" class="mg le iq bd lf mh mi dn lj mj mk dp ln la ml mm lr lb mn mo lv lc mp mq lz mr bi translated">提取Postgres元数据</h2><p id="91f9" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">我们从数据源开始:首先是Postgres。</p><p id="0cb6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们为python3安装了Postgres客户端:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="8ac3" class="mg le iq nn b gy nr ns l nt nu">sudo apt-get install libpq-dev<br/>pip3 install Psycopg2</span></pre><p id="defd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Postgres元数据ETL的执行</p><p id="87d3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">运行脚本来解析Postgres元数据:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="9137" class="mg le iq nn b gy nr ns l nt nu">export CREDENTIALS_POSTGRES_USER=lineage_ref<br/>export CREDENTIALS_POSTGRES_PASSWORD=lineage_ref<br/>export CREDENTIALS_POSTGRES_DATABASE=warehouse</span><span id="7e87" class="mg le iq nn b gy nv ns l nt nu">python3 example/scripts/sample_postgres_loader_nebula.py</span></pre><p id="3f24" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果您查看将Postgres元数据加载到Nebula的示例脚本的代码，您会发现主要代码行非常简单:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="a945" class="mg le iq nn b gy nr ns l nt nu"># part 1: PostgressMetadata --&gt; CSV --&gt; Nebula Graph<br/>job = DefaultJob(<br/>      conf=job_config,<br/>      task=DefaultTask(<br/>          extractor=PostgresMetadataExtractor(),<br/>          loader=FsNebulaCSVLoader()),<br/>      publisher=NebulaCsvPublisher())</span><span id="bf90" class="mg le iq nn b gy nv ns l nt nu">...<br/># part 2: Metadata stored in NebulaGraph --&gt; Elasticsearch<br/>extractor = NebulaSearchDataExtractor()<br/>task = SearchMetadatatoElasticasearchTask(extractor=extractor)</span><span id="86f7" class="mg le iq nn b gy nv ns l nt nu">job = DefaultJob(conf=job_config, task=task)</span></pre><p id="6199" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">第一项工作是在以下路径加载数据:postgresmetadata→CSV→Nebula Graph</p><ul class=""><li id="a5a4" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">PostgresMetadataExtractor用于从Postgres中提取/拉取元数据，参见此处的<a class="ae ng" href="https://www.amundsen.io/amundsen/databuilder/#postgresmetadataextractor" rel="noopener ugc nofollow" target="_blank">获取其文档。</a></li><li id="49aa" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">FsNebulaCSVLoader用于将提取的数据以CSV文件的形式直接存储</li><li id="7a9b" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">NebulaCsvPublisher用于将元数据以CSV格式发布到NebulaGraph</li></ul><p id="27f1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">第二项工作是加载路径:存储在NebulaGraph中的元数据→ Elasticsearch</p><ul class=""><li id="c432" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">NebulaSearchDataExtractor用于获取存储在星云图中的元数据</li><li id="3a7c" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">searchmetadatatoelastic asearchtask用于使用Elasticsearch索引元数据。</li></ul><blockquote class="jy jz ka"><p id="7351" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">注意，在生产中，我们可以在脚本中或通过像Apache Airflow这样的编排平台来触发这些作业。</em></p></blockquote><p id="0f34" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">验证Postgres提取</p><p id="ee72" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">搜索支付或直接访问<a class="ae ng" href="http://localhost:5000/table_detail/warehouse/postgres/public/payments," rel="noopener ugc nofollow" target="_blank">http://localhost:5000/table _ detail/warehouse/postgres/public/payments，</a>您可以看到来自我们Postgres的元数据，如:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/011c313ab8c2e6643399ba375da7f03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J07hCN---pJGcbLA.png"/></div></div></figure><p id="793c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然后，像添加标签、所有者和描述这样的元数据管理操作也可以像上面的屏幕截图一样轻松完成。</p><h2 id="33cf" class="mg le iq bd lf mh mi dn lj mj mk dp ln la ml mm lr lb mn mo lv lc mp mq lz mr bi translated">正在提取dbt元数据</h2><p id="f899" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">实际上，我们也可以从<a class="ae ng" href="https://www.getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt </a>本身提取元数据。</p><p id="6376" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Amundsen <a class="ae ng" href="https://www.amundsen.io/amundsen/databuilder/#dbtextractor" rel="noopener ugc nofollow" target="_blank"> DbtExtractor </a>将解析catalog.json或manifest.json文件，以将元数据加载到Amundsen存储中(NebulaGraph和Elasticsearch)。</p><p id="47f6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在上面的meltano章节中，我们已经用meltano invoke dbt docs generate生成了该文件，如下所示的输出告诉我们catalog.json文件:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="471e" class="mg le iq nn b gy nr ns l nt nu">14:23:15  Done.<br/>14:23:15  Building catalog<br/>14:23:15  Catalog written to /home/ubuntu/ref-data-lineage/meltano_example_implementations/meltano_projects/singer_dbt_jaffle/.meltano/transformers/dbt/target/catalog.json</span></pre><p id="65a7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">dbt元数据ETL的执行</p><p id="ca96" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">下面是一个带有示例dbt输出文件的示例脚本:</p><p id="906f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">示例dbt文件:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="4db3" class="mg le iq nn b gy nr ns l nt nu">$ ls -l example/sample_data/dbt/<br/>total 184<br/>-rw-rw-r-- 1 w w   5320 May 15 07:17 catalog.json<br/>-rw-rw-r-- 1 w w 177163 May 15 07:17 manifest.json</span></pre><p id="ec66" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们可以用以下代码加载这个示例dbt清单:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="a071" class="mg le iq nn b gy nr ns l nt nu">python3 example/scripts/sample_dbt_loader_nebula.py</span></pre><p id="5acb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">从这几行python代码中，我们可以将这些过程描述为:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="8c67" class="mg le iq nn b gy nr ns l nt nu"># part 1: Dbt manifest --&gt; CSV --&gt; Nebula Graph<br/>job = DefaultJob(<br/>      conf=job_config,<br/>      task=DefaultTask(<br/>          extractor=DbtExtractor(),<br/>          loader=FsNebulaCSVLoader()),<br/>      publisher=NebulaCsvPublisher())</span><span id="4496" class="mg le iq nn b gy nv ns l nt nu">...<br/># part 2: Metadata stored in NebulaGraph --&gt; Elasticsearch<br/>extractor = NebulaSearchDataExtractor()<br/>task = SearchMetadatatoElasticasearchTask(extractor=extractor)</span><span id="870e" class="mg le iq nn b gy nv ns l nt nu">job = DefaultJob(conf=job_config, task=task)</span></pre><p id="d267" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">与Postgres meta ETL的唯一区别是extractor=DbtExtractor()，它提供了以下配置来获取有关dbt项目的以下信息:</p><ul class=""><li id="4d2a" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">数据库名称</li><li id="dca2" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">目录_json</li><li id="5bf4" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">清单_json</li></ul><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="a070" class="mg le iq nn b gy nr ns l nt nu">job_config = ConfigFactory.from_dict({<br/>  'extractor.dbt.database_name': database_name,<br/>  'extractor.dbt.catalog_json': catalog_file_loc,  # File<br/>  'extractor.dbt.manifest_json': json.dumps(manifest_data),  # JSON Dumped objecy<br/>  'extractor.dbt.source_url': source_url})</span></pre><p id="d974" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">验证dbt提取</p><p id="bab2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">搜索dbt_demo或访问<a class="ae ng" href="http://localhost:5000/table_detail/dbt_demo/snowflake/public/raw_inventory_value" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/table _ detail/dbt _ demo/snow flake/public/raw _ inventory _ value</a>查看:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/713b76421b5afee052b3d7aa47e8e1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BpkLUuccTssT4QFe.png"/></div></div></figure><blockquote class="jy jz ka"><p id="3629" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">提示:我们可以有选择地启用调试日志来查看发送给Elasticsearch和Nebula Graph的内容！</em></p></blockquote><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="d237" class="mg le iq nn b gy nr ns l nt nu">- logging.basicConfig(level=logging.INFO)<br/>+ logging.basicConfig(level=logging.DEBUG)</span></pre><p id="b59a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">或者，在Nebula Studio中浏览导入的数据:</p><p id="ab3f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">首先点击“从顶点开始”，填写顶点id:雪花://dbt _ demo . public/fact _ warehouse _ inventory</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b510d166a7876a3c6dc61edb44277ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eChcsb_RJR1WRBKB.png"/></div></div></figure><p id="f271" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然后，我们可以看到顶点显示为粉红色的点。让我们使用以下命令修改扩展选项:</p><ul class=""><li id="03f2" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">方向:双向</li><li id="a2c8" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">步骤:单用3个</li></ul><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0ecbdffca16b71bfbf7e88198784c72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zMH8wufYLq6othaV.png"/></div></div></figure><p id="a6f3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">双击顶点(点)，它将双向扩展3步:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4d768032a04d86ba8a36a992eda6bf61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9fT_tNY7sxRgZaBh.png"/></div></div></figure><p id="bd63" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">从这个图来看，元数据的洞察力非常容易被探索，对吗？</p><blockquote class="jy jz ka"><p id="9a8b" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">提示，您可以点击👁图标来选择要显示的一些属性，这是我在捕获上述屏幕之前完成的。</em></p></blockquote><p id="3617" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">此外，我们在Nebula Studio中看到的内容也与Amundsen元数据服务的数据模型相呼应:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/3af9cd19e35faa1ff646813db71adbf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ufqiAmZTNzQsdqKp.png"/></div></div></figure><p id="816a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">最后，记住我们已经利用dbt在meltano中转换了一些数据，清单文件路径是。melt ano/transformers/dbt/target/catalog . JSON，可以尝试创建一个数据构建器作业来导入它。</p><h2 id="c3ca" class="mg le iq bd lf mh mi dn lj mj mk dp ln la ml mm lr lb mn mo lv lc mp mq lz mr bi translated">提取超集元数据</h2><p id="b8dc" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated"><a class="ae ng" href="https://www.amundsen.io/amundsen/databuilder/databuilder/extractor/dashboard/apache_superset/apache_superset_metadata_extractor.py" rel="noopener ugc nofollow" target="_blank">仪表板</a>、<a class="ae ng" href="https://www.amundsen.io/amundsen/databuilder/databuilder/extractor/dashboard/apache_superset/apache_superset_chart_extractor.py" rel="noopener ugc nofollow" target="_blank">图表</a>和<a class="ae ng" href="https://www.amundsen.io/amundsen/databuilder/databuilder/extractor/dashboard/apache_superset/apache_superset_table_extractor.py" rel="noopener ugc nofollow" target="_blank">与表格</a>的关系可以通过Amundsen data builder提取，因为我们已经设置了一个超集仪表板，让我们尝试获取它的元数据。</p><p id="b4f7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">超集元数据ETL的执行</p><p id="cfe8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">示例超集脚本将从超集获取数据，并将元数据加载到Nebula Graph和Elasticsearch中。</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="5a5e" class="mg le iq nn b gy nr ns l nt nu">python3 sample_superset_data_loader_nebula.py</span></pre><p id="7c52" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果我们将日志记录级别设置为DEBUG，我们实际上可以看到这样的行:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="c280" class="mg le iq nn b gy nr ns l nt nu"># fetching metadata from superset<br/>DEBUG:urllib3.connectionpool:http://localhost:8088 "POST /api/v1/security/login HTTP/1.1" 200 280<br/>INFO:databuilder.task.task:Running a task<br/>DEBUG:urllib3.connectionpool:Starting new HTTP connection (1): localhost:8088<br/>DEBUG:urllib3.connectionpool:http://localhost:8088 "GET /api/v1/dashboard?q=(page_size:20,page:0,order_direction:desc) HTTP/1.1" 308 374<br/>DEBUG:urllib3.connectionpool:http://localhost:8088 "GET /api/v1/dashboard/?q=(page_size:20,page:0,order_direction:desc) HTTP/1.1" 200 1058<br/>...</span><span id="5e27" class="mg le iq nn b gy nv ns l nt nu"># insert Dashboard</span><span id="cad9" class="mg le iq nn b gy nv ns l nt nu">DEBUG:databuilder.publisher.nebula_csv_publisher:Query: INSERT VERTEX `Dashboard` (`dashboard_url`, `name`, published_tag, publisher_last_updated_epoch_ms) VALUES  "superset_dashboard://my_cluster.1/3":("http://localhost:8088/superset/dashboard/3/","my_dashboard","unique_tag",timestamp());<br/>...</span><span id="e5aa" class="mg le iq nn b gy nv ns l nt nu"># insert a DASHBOARD_WITH_TABLE relationship/edge</span><span id="f702" class="mg le iq nn b gy nv ns l nt nu">INFO:databuilder.publisher.nebula_csv_publisher:Importing data in edge files: ['/tmp/amundsen/dashboard/relationships/Dashboard_Table_DASHBOARD_WITH_TABLE.csv']<br/>DEBUG:databuilder.publisher.nebula_csv_publisher:Query:<br/>INSERT edge `DASHBOARD_WITH_TABLE` (`END_LABEL`, `START_LABEL`, published_tag, publisher_last_updated_epoch_ms) VALUES "superset_dashboard://my_cluster.1/3"-&gt;"postgresql+psycopg2://my_cluster.warehouse/orders":("Table","Dashboard","unique_tag", timestamp()), "superset_dashboard://my_cluster.1/3"-&gt;"postgresql+psycopg2://my_cluster.warehouse/customers":("Table","Dashboard","unique_tag", timestamp());</span></pre><p id="ea00" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">验证超集仪表板提取</p><p id="8248" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">通过在Amundsen中搜索，我们现在可以查看仪表板信息。我们也可以从星云工作室核实。</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/93b0e063cb0fe1ee9101fb95298f0d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lpH7lwgroUSPzWvJ.png"/></div></div></figure><blockquote class="jy jz ka"><p id="c848" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">注意，也可从</em> <a class="ae ng" href="https://www.amundsen.io/amundsen/databuilder/docs/dashboard_ingestion_guide/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">仪表板摄取指南</em> </a> <em class="iq"> : </em>中查看Amundsen中的仪表板型号</p></blockquote><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6e07a1dccf62e2031b967a564c61184b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nySukrFVEz32O0Ln.png"/></div></div></figure><h2 id="efce" class="mg le iq bd lf mh mi dn lj mj mk dp ln la ml mm lr lb mn mo lv lc mp mq lz mr bi translated">用超集预览数据</h2><p id="fd9f" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">超集可以用来预览这样的表数据。相应的文档可以参考<a class="ae ng" href="https://www.amundsen.io/amundsen/frontend/docs/configuration/#preview-client" rel="noopener ugc nofollow" target="_blank">这里的</a>，其中/superset/sql_json/的API将被Amundsen Frontend调用。</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/a831b789d393998584945ea340ca747b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ekZmmibCLbDWa6Sn.png"/></div></div></figure><h2 id="f1ca" class="mg le iq bd lf mh mi dn lj mj mk dp ln la ml mm lr lb mn mo lv lc mp mq lz mr bi translated">启用数据沿袭</h2><p id="7970" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">默认情况下，不启用数据沿袭，我们可以通过以下方式启用它:</p><ol class=""><li id="4bf7" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz oa my mz na bi translated">转到Amundsen repo，这也是我们运行docker-compose-f docker-Amundsen-nebula . yml up命令的地方</li></ol><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="319b" class="mg le iq nn b gy nr ns l nt nu">cd amundsen</span></pre><ol class=""><li id="f2c2" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz oa my mz na bi translated">修改前端JS配置:</li></ol><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="72c1" class="mg le iq nn b gy nr ns l nt nu">--- a/frontend/amundsen_application/static/js/config/config-default.ts<br/>+++ b/frontend/amundsen_application/static/js/config/config-default.ts<br/>   tableLineage: {<br/>-    inAppListEnabled: false,<br/>-    inAppPageEnabled: false,<br/>+    inAppListEnabled: true,<br/>+    inAppPageEnabled: true,<br/>     externalEnabled: false,<br/>     iconPath: 'PATH_TO_ICON',<br/>     isBeta: false,</span></pre><ol class=""><li id="df5e" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz oa my mz na bi translated">现在让我们再次为docker映像运行build，其中前端映像将被重新构建。</li></ol><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="4074" class="mg le iq nn b gy nr ns l nt nu">docker-compose -f docker-amundsen-nebula.yml build</span></pre><p id="c47a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然后，重新运行up -d以确保使用新配置重新创建前端容器:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="4b6f" class="mg le iq nn b gy nr ns l nt nu">docker-compose -f docker-amundsen-nebula.yml up -d</span></pre><p id="de1c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们可以看到这样的情况:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="5cda" class="mg le iq nn b gy nr ns l nt nu">$ docker-compose -f docker-amundsen-nebula.yml up -d<br/>...<br/>Recreating amundsenfrontend           ... done</span></pre><p id="d04a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">之后，我们可以访问<a class="ae ng" href="http://localhost:5000/lineage/table/gold/hive/test_schema/test_table1" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/Lineage/table/gold/hive/test _ schema/test _ table 1</a>来查看沿袭显示为:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f2db10f51fa9a4a2ac9931783d4bdd5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5qkeVSyWF0AWv8DG.png"/></div></div></figure><p id="f0aa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我们可以单击下游(如果有)来查看此表的下游资源:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/35bda01ebadf94c73050042876f10444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g7J3z0xPRtrNAj1B.png"/></div></div></figure><p id="c983" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">或者单击沿袭查看图表:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d245231c1adf5aa2edfa709b92d06c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B6gx743FmZMo64an.png"/></div></div></figure><p id="da14" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">也有用于血统查询的API。这里有一个使用cURL进行查询的例子，我们像以前创建用户一样利用netshoot容器。</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="8384" class="mg le iq nn b gy nr ns l nt nu">docker run -it --rm --net container:amundsenfrontend nicolaka/netshoot</span><span id="e22e" class="mg le iq nn b gy nv ns l nt nu">curl "http://amundsenmetadata:5002/table/snowflake://dbt_demo.public/raw_inventory_value/lineage?depth=3&amp;direction=both"</span></pre><p id="e927" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">上面的API调用是在上游和下游两个方向上查询linage，深度为3的表雪花://dbt _ demo . public/raw _ inventory _ value。</p><p id="87b0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">结果应该是这样的:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="f977" class="mg le iq nn b gy nr ns l nt nu">{<br/>  "depth": 3,<br/>  "downstream_entities": [<br/>    {<br/>      "level": 2,<br/>      "usage": 0,<br/>      "key": "snowflake://dbt_demo.public/fact_daily_expenses",<br/>      "parent": "snowflake://dbt_demo.public/fact_warehouse_inventory",<br/>      "badges": [],<br/>      "source": "snowflake"<br/>    },<br/>    {<br/>      "level": 1,<br/>      "usage": 0,<br/>      "key": "snowflake://dbt_demo.public/fact_warehouse_inventory",<br/>      "parent": "snowflake://dbt_demo.public/raw_inventory_value",<br/>      "badges": [],<br/>      "source": "snowflake"<br/>    }<br/>  ],<br/>  "key": "snowflake://dbt_demo.public/raw_inventory_value",<br/>  "direction": "both",<br/>  "upstream_entities": []<br/>}</span></pre><p id="0ad9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">事实上，这个血统数据是在我们的<a class="ae ng" href="https://github.com/amundsen-io/amundsen/blob/main/databuilder/databuilder/extractor/dbt_extractor.py" rel="noopener ugc nofollow" target="_blank"> DbtExtractor </a>执行期间提取和加载的，其中extractor.dbt.{DbtExtractor。EXTRACT_LINEAGE}默认为True，因此创建了世系元数据并加载到Amundsen。</p><p id="33ef" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">获得星云图中的血统</p><p id="34c0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">使用图形数据库作为元数据存储的两个优点是:</p><ul class=""><li id="10ad" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">图形查询本身是一个灵活的DSL for lineage API，例如，此查询帮助我们执行Amundsen元数据API的等效查询以获取lineage:</li></ul><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="bdbc" class="mg le iq nn b gy nr ns l nt nu">MATCH p=(t:Table) -[:HAS_UPSTREAM|:HAS_DOWNSTREAM *1..3]-&gt;(x)<br/>WHERE id(t) == "snowflake://dbt_demo.public/raw_inventory_value" RETURN p</span></pre><ul class=""><li id="7e79" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">我们现在甚至可以在Nebula Graph Studio的控制台中查询它，然后单击View Subgraphs使它呈现在图形视图中。</li></ul><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a322fbca254a00be4a61fc725c4ed4ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qf97W9ZfbxYRmpW_.png"/></div></div></figure><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/86358f6539135e66bd452de2d4b5df94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ElQgKxh2oSe-JoZs.png"/></div></div></figure><p id="6cc6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">提取数据沿袭</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="858d" class="mg le iq nn b gy nr ns l nt nu">Dbt</span></pre><p id="3fcf" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如上所述，<a class="ae ng" href="https://www.amundsen.io/amundsen/databuilder/#dbtextractor" rel="noopener ugc nofollow" target="_blank"> DbtExtractor </a>将提取表级血统，以及dbt ETL管道中定义的其他信息。</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="d96e" class="mg le iq nn b gy nr ns l nt nu">Open Lineage</span></pre><p id="9ee1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Amundsen的另一个开箱即用的LineageExtractor是<a class="ae ng" href="https://www.amundsen.io/amundsen/databuilder/#openlineagetablelineageextractor" rel="noopener ugc nofollow" target="_blank">openlinegetablelineageextractor</a>。</p><p id="5da9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><a class="ae ng" href="https://openlineage.io/" rel="noopener ugc nofollow" target="_blank"> Open lineage </a>是一个在一个地方收集不同来源的Lineage数据的开放框架，它可以将Lineage信息输出为JSON文件，由<a class="ae ng" href="https://www.amundsen.io/amundsen/databuilder/#openlineagetablelineageextractor" rel="noopener ugc nofollow" target="_blank">openlinegetablelineageextractor</a>提取:</p><pre class="nh ni nj nk gt nm nn no np aw nq bi"><span id="610f" class="mg le iq nn b gy nr ns l nt nu">dict_config = {<br/>    # ...<br/>    f'extractor.openlineage_tablelineage.{OpenLineageTableLineageExtractor.CLUSTER_NAME}': 'datalab',<br/>    f'extractor.openlineage_tablelineage.{OpenLineageTableLineageExtractor.OL_DATASET_NAMESPACE_OVERRIDE}': 'hive_table',<br/>    f'extractor.openlineage_tablelineage.{OpenLineageTableLineageExtractor.TABLE_LINEAGE_FILE_LOCATION}': 'input_dir/openlineage_nd.json',<br/>}<br/>...</span><span id="690f" class="mg le iq nn b gy nv ns l nt nu">task = DefaultTask(<br/>    extractor=OpenLineageTableLineageExtractor(),<br/>    loader=FsNebulaCSVLoader())</span></pre><h1 id="7296" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">概述</h1><p id="ded2" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">元数据治理/发现的整体思想是:</p><ul class=""><li id="bfb5" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">将所有组件作为元数据源放入堆栈(从任何DB或DW到dbt、Airflow、Openlineage、超集等。)</li><li id="9a4a" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">使用Databuilder(作为脚本或DAG)运行元数据ETL，使用NebulaGraph(或其他图形数据库)和Elasticsearch进行存储和索引</li><li id="0790" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">从前端UI(带有预览的超集)或API消费、管理和发现元数据</li><li id="1307" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">从查询和UI中获得更多可能性、灵活性和对NebulaGraph的洞察力</li></ul><h1 id="ed46" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">上游项目</h1><p id="b50a" class="pw-post-body-paragraph kb kc iq ke b kf mb kh ki kj mc kl km la md kp kq lb me kt ku lc mf kx ky kz ij bi translated">本参考项目中使用的所有项目按字典顺序排列如下。</p><ul class=""><li id="7cd0" class="ms mt iq ke b kf kg kj kk la mu lb mv lc mw kz mx my mz na bi translated">阿蒙森</li><li id="c65c" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">阿帕奇气流</li><li id="6484" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">Apache超集</li><li id="d96a" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">dbt</li><li id="c805" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">弹性搜索</li><li id="f09d" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">梅尔塔诺</li><li id="35c6" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated"><a class="ae ng" href="https://nebula-graph.io" rel="noopener ugc nofollow" target="_blank">星云图</a></li><li id="13da" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">开放血统</li><li id="e6c7" class="ms mt iq ke b kf nb kj nc la nd lb ne lc nf kz mx my mz na bi translated">歌手</li></ul></div></div>    
</body>
</html>