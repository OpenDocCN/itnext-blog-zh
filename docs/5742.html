<html>
<head>
<title>Class Eval &amp; Instance Eval In Ruby Metaprogramming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby元编程中的类求值和实例求值</h1>
<blockquote>原文：<a href="https://itnext.io/class-eval-instance-eval-in-ruby-metaprogramming-7fef0f0e163e?source=collection_archive---------3-----------------------#2021-05-16">https://itnext.io/class-eval-instance-eval-in-ruby-metaprogramming-7fef0f0e163e?source=collection_archive---------3-----------------------#2021-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3c914ad50b9f9bdc1521c3d341cb0185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxClFXW4X5w_NkWf1IL_Ag.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Ruby中的类和实例评估</figcaption></figure><p id="e09f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Ruby的<code class="fe la lb lc ld b">class_eval</code>和<code class="fe la lb lc ld b">instance_eval</code>虽然名字相似，但行为却颇为违反直觉。</p><p id="4d30" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">对每一种的简单解释是</strong>:</p><blockquote class="le lf lg"><p id="5e8b" class="kc kd lh ke b kf kg kh ki kj kk kl km li ko kp kq lj ks kt ku lk kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">ClassName.class_eval</code>:用于在类对象上定义一个实例方法，应用于该类的所有实例。</p><p id="1cd4" class="kc kd lh ke b kf kg kh ki kj kk kl km li ko kp kq lj ks kt ku lk kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">ClassName.instance_eval</code>:用于定义一个与类对象关联的类方法，但是对该类的实例对象不可见。</p></blockquote><p id="cf93" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的<code class="fe la lb lc ld b">Person</code>类的例子中，<code class="fe la lb lc ld b">class_eval</code>允许我们在<code class="fe la lb lc ld b">Person</code>类之外定义一个方法<code class="fe la lb lc ld b">hello</code>，而不用用标准语法重新打开这个类。当我们直到运行时才知道要将这个方法添加到哪个类时，这是很有用的。</p><p id="3fe2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的例子中，<code class="fe la lb lc ld b">instance_eval</code>允许我们在类对象实例的上下文中定义方法<code class="fe la lb lc ld b">say_hello</code>。这意味着<code class="fe la lb lc ld b">Person.instance_eval</code>是在<code class="fe la lb lc ld b">Person</code>对象的上下文中计算的。</p><p id="baae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简单来说，<code class="fe la lb lc ld b">Person.class_eval</code>会创建实例方法，<code class="fe la lb lc ld b">Person.instance_eval</code>会创建类方法。</p><p id="0448" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">从技术上更简化上面的</strong>，<code class="fe la lb lc ld b">class_eval</code>相当于在class语句中键入如下代码:</p><p id="9e0b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">Person.class_eval do def test 'hello...!!!' ; end</code>行为与下面完全相同:</p><p id="7d91" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">class Person def test 'hello...!!!'; end</code></p><p id="7030" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，我们可以得出结论，我们可以用<code class="fe la lb lc ld b">instance_eval</code>打开一个不是类的对象，用<code class="fe la lb lc ld b">class_eval</code>打开一个类定义，并用<code class="fe la lb lc ld b">def</code>定义方法。</p><p id="b808" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，你应该选择最能表达你意图的方法。如果你在想，“<strong class="ke ir">我想打开这个对象，并且<br/>并不特别在意它是一个类</strong>，”那么<code class="fe la lb lc ld b">instance_eval</code>就可以了。如果你在想，“<strong class="ke ir">我想在这里开一个公开课</strong>，”那么<code class="fe la lb lc ld b">class_eval</code>几乎肯定是一个更好的匹配。</p><p id="0d87" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望以上的概念现在对你们所有人都很清楚，如果需要，请提出任何建议或编辑意见。</p></div></div>    
</body>
</html>