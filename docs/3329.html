<html>
<head>
<title>Design patterns in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点中的设计模式</h1>
<blockquote>原文：<a href="https://itnext.io/design-patterns-in-nodejs-990fed17c49c?source=collection_archive---------0-----------------------#2019-11-23">https://itnext.io/design-patterns-in-nodejs-990fed17c49c?source=collection_archive---------0-----------------------#2019-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="56e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于Node中一些最有用的模式的快速指南，包括用例及代码示例。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1fa0a8ede7da7f04432383801888e5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ukxIgJ604czSiIr5"/></div></div></figure><p id="8d4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设计模式是软件设计中常见问题的典型解决方案。每个模式就像一个蓝图，您可以定制它来解决代码中的特定设计问题。</p><p id="b584" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你正面临一个软件设计的问题，很有可能有人曾经面临过。看看最常见的模式，因为你可能很幸运，有人创造了一个模式来解决这个问题。</p><p id="929b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们是软件设计中常见问题的<strong class="js iu">尝试、优化和测试解决方案</strong>的工具包。即使你从未遇到过这些问题，了解模式仍然是有用的，因为它<strong class="js iu">教你如何使用面向对象设计的原则解决各种问题</strong>。</p><p id="349e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设计模式也改善了团队中的沟通。如果你说:<em class="la">“嘿，我正在创建一个工厂来解决那个”</em>，每个人都会明白你的建议背后的想法。如果你知道模式和它的名字，不需要解释什么是工厂。</p><p id="1ec7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从Node中一些有用的模式以及它们有助于解决的问题开始。</p><h1 id="81d8" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">工厂模式</h1><p id="9757" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">事实上，在JS中，功能范式通常比面向对象设计更受青睐。在创建新的对象实例时尤其如此。使用<em class="la"> new </em>操作符或<em class="la"> Object.create() </em>从原型创建一个新对象在几个方面都不太灵活或方便。</p><p id="bd21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">工厂允许我们将对象的创建和实现分开。它充当新实例的包装。在工厂内部，我们可以使用上一段提到的闭包，创建不同的组合实例。基本上，你需要的一切。消费者将对内部发生的事情一无所知。</p><p id="9206" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，JS无法在函数中定义<em class="la">公共</em>或<em class="la">私有</em>方法，但是，通过工厂，我们可以<strong class="js iu">强制封装</strong>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi me"><img src="../Images/3808c96353ab855c52f6ad0a97382f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aOijtJXjx56wuHQBm9HMMA.png"/></div></div></figure><p id="b418" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过这种方式，我们将工程师的创造依赖于工厂，因此消费者可以从中抽象。另一方面，<em class="la"> privateSkills </em>无法从函数外部访问，迫使<strong class="js iu">封装</strong>。</p><h1 id="42ad" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">代理模式</h1><p id="f817" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">代理是一个对象，它控制对另一个对象的访问，这个对象叫做主题。两者都有相同的接口，这允许我们透明地交换一个给另一个。代理拦截所有或部分本应在主体上执行的操作，修改它们的行为。</p><p id="1d56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代理在很多情况下都很有用，比如数据验证、安全、缓存、延迟加载、日志记录或者让远程对象看起来像本地对象。</p><p id="e2e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一些实现代理的技术，比如对象扩充、对象合成或者只是使用ES6中引入的<a class="ae mf" href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Proxy" rel="noopener ugc nofollow" target="_blank"> <em class="la">代理</em> </a> <em class="la"> </em>对象。组合可以被认为是创建代理的最安全的方式，因为它不会修改主题，所以我们将在代码示例中使用它。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/2123a05e06725e3b6e940c6c2bd14716.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*73Mxo36cwuvcKT698znOLA.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">代理模式</figcaption></figure><p id="442c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也可以用原型来完成，但是我更喜欢利用JS提供的所有灵活性。</p><p id="d18e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，代理截取修改结果的<em class="la"> hello </em>方法，并委托<em class="la"> goodbye </em>方法。对于大型函数，您可能需要委托大多数方法。在这种情况下，<a class="ae mf" href="https://www.npmjs.com/package/delegates" rel="noopener ugc nofollow" target="_blank">代表NPM包</a>应该有所帮助。</p><h1 id="6750" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">装饰图案</h1><p id="75f2" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">它非常类似于代理，但是它不是增强或修改行为，而是增加了新的功能。继承的不同之处在于，decorator不会将行为添加到同一个类的所有对象中，而只是添加到被修饰的实例中。与代理模式一样，合成和对象增强是主要的技术。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ml"><img src="../Images/b6fcdb2931c4243724bcce78febf1d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*VrO3BEqkx4viqegqZ987Ow.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">装饰图案</figcaption></figure><p id="1790" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="la"> DecoratedUser </em>接收两个参数来帮助修改say函数。结构非常相似，但是方法行为发生了变化。</p><h1 id="d428" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">中间件模式</h1><p id="424b" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">它代表一个类似于流的处理<strong class="js iu">管道</strong>。在Node中，这种模式的使用远远超出了Express框架的界限。它可以是一组处理单元、处理程序、过滤器和任何函数，用于执行任何类型数据的预处理和后处理。事实上，它提供了灵活性，允许我们毫不费力地获得一个插件基础设施，提供了一种用新的过滤器和处理器扩展系统的不引人注目的方式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/1535afeab04b95ccdfb0dad020c0f9a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*dWMuOSIJsuU27gZfuxJwRQ.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">中间件模式</figcaption></figure><p id="8c52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个表示中，我们有一个传入的请求，它正在进入我们的应用程序的核心，遍历许多中间件。这部分流程称为<strong class="js iu">入站</strong>或<strong class="js iu">下游。</strong>流程到达核心app后，会以相反的顺序再次遍历所有中间件，这样它们就可以在执行app逻辑后执行动作。这部分被称为<strong class="js iu">出境</strong>或<strong class="js iu">上游。</strong></p><p id="f9d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我用<a class="ae mf" href="https://github.com/zeromq/zeromq.js" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> ZeroMQ </strong> </a>创建了一个例子，抽象出通过ZMQ套接字传递的数据的预处理和后处理，这样我们就可以透明地处理JSON对象(序列化/反序列化)，还可以压缩通过网络传输的消息。</p><p id="10d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里  <strong class="js iu">可以找到代码<a class="ae mf" href="https://github.com/boxgames1/nodejs-patterns/tree/master/design-patterns/middleware" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">。</strong>它包含4个文件:</a></strong></p><ul class=""><li id="5d7a" class="mn mo it js b jt ju jx jy kb mp kf mq kj mr kn ms mt mu mv bi translated">zmqMiddleware.js :负责在接收或发送新消息时执行中间件管道。</li><li id="ad28" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated"><a class="ae mf" href="https://github.com/boxgames1/nodejs-patterns/blob/master/design-patterns/middleware/jsonMiddleware.js" rel="noopener ugc nofollow" target="_blank"> jsonMiddleware.js </a>:序列化和反序列化JSON消息的中间件。</li><li id="c6a5" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated"><a class="ae mf" href="https://github.com/boxgames1/nodejs-patterns/blob/master/design-patterns/middleware/server.js" rel="noopener ugc nofollow" target="_blank"> server.js </a>:它将一个套接字回复绑定到本地端口7000，创建一个管理器实例，添加JSON中间件，并创建一个入站函数来处理来自客户端的请求</li><li id="2f9f" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated"><a class="ae mf" href="https://github.com/boxgames1/nodejs-patterns/blob/master/design-patterns/middleware/client.js" rel="noopener ugc nofollow" target="_blank"> client.js </a>:通过socket连接到本地端口7000，创建一个管理器实例，添加JSON中间件，创建一个函数来处理来自服务器的响应，最后设置一个发送<em class="la"> ping </em>请求的定时器。</li></ul><h1 id="a989" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">命令模式</h1><p id="8099" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">这是节点中另一个非常重要的模式。命令是封装了稍后执行动作所需的所有信息的任何对象。因此，我们不是直接调用函数，而是创建一个对象来表示执行这种调用的意图。它是围绕四个主要组件构建的，这四个组件可以根据我们想要实现模式的方式而变化:</p><ul class=""><li id="2207" class="mn mo it js b jt ju jx jy kb mp kf mq kj mr kn ms mt mu mv bi translated"><strong class="js iu">命令</strong>:封装了调用函数所需信息的对象。</li><li id="1384" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated"><strong class="js iu">客户端:</strong>创建命令并提供给调用者。</li><li id="f151" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated"><strong class="js iu">调用者:</strong>这个负责在目标上执行命令。</li><li id="9dc3" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated"><strong class="js iu">目标:</strong>调用的主题。它可以是一个单独的函数，也可以是一个对象的方法。</li></ul><p id="04d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用命令模式有几个优点。其中一些是:</p><ul class=""><li id="9373" class="mn mo it js b jt ju jx jy kb mp kf mq kj mr kn ms mt mu mv bi translated">可以将命令安排在以后运行</li><li id="d4a3" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated">保留系统中执行的操作的历史记录</li><li id="7280" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated">可以序列化并通过网络发送，因此可以分发。</li><li id="2381" class="mn mo it js b jt mw jx mx kb my kf mz kj na kn ms mt mu mv bi translated">如果还没有执行，可以取消预定的命令</li></ul><p id="50ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我创建了一个允许<em class="la">撤销</em>和<em class="la">序列化的例子。</em>代码可以在<a class="ae mf" href="https://github.com/boxgames1/nodejs-patterns/tree/master/design-patterns/command" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">这里找到</strong> </a> <strong class="js iu">。它展示了将一个操作包装在一个命令中是如何打开一个可能性的世界，而这只是冰山一角</strong></p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="b283" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我是奥利弗·阿隆索，在西班牙远程工作的软件工程师。你可以在<a class="ae mf" href="https://oliveralonso.dev/" rel="noopener ugc nofollow" target="_blank">我的网络</a>或<a class="ae mf" href="https://github.com/boxgames1" rel="noopener ugc nofollow" target="_blank"> Github账户中找到更多关于我的资料。</a></p><p id="09b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读！</p></div></div>    
</body>
</html>