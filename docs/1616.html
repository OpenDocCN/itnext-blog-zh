<html>
<head>
<title>Building Better Angular Libraries — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建更好的角度库—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/building-better-angular-libraries-part-1-217b3af7a3a1?source=collection_archive---------1-----------------------#2018-12-12">https://itnext.io/building-better-angular-libraries-part-1-217b3af7a3a1?source=collection_archive---------1-----------------------#2018-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/05596b586791ce48404a8c00c9da4cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R69Gbax0_W7OJ61UPhohxw.png"/></div></div></figure><p id="621c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你有没有想过，作为潜在的图书馆开发者，我们需要做些什么才能让我们的消费者方便地使用我们的图书馆？什么会让他们回来要求更多？在这篇文章中，我将试着强调一些简单的事情，我们可以做这些事情来使我们的图书馆获得巨大的成功。</p><p id="549e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们希望在Angular应用中使用第三方库时，我们通常会考虑以下几点:</p><ol class=""><li id="c156" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">装置</li><li id="a5ec" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">易用性</li><li id="2dc2" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">功能丰富性</li><li id="bee1" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">可升级性</li><li id="dbf7" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">易测性</li></ol><p id="2edf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">#3和#5是图书馆最常见的吸引人的品质。</p><p id="97e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这两篇文章中，我们将学习如何使用<code class="fe lk ll lm ln b">@angular/cli</code>和<code class="fe lk ll lm ln b">schematics</code>在安装、使用和升级过程中增强开发人员的体验。</p><p id="5cbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始之前，让我们创建一个新的工作区。在此工作区中，我们将创建我们的库。我们还将创建另一个使用我们库的工作空间。</p><blockquote class="lo lp lq"><p id="9fcd" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated">为什么我们有工作区和图书馆？从版本6开始，Angular引入了workspace，它能够处理多个项目，并在根目录下创建一个默认应用程序</p></blockquote><h1 id="30dc" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">先决条件</h1><p id="4ed0" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">为了能够跟得上本文的内容，建议先熟悉<a class="ae my" href="https://angular.io" rel="noopener ugc nofollow" target="_blank"> Angular </a>，安装<a class="ae my" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a> &gt; v6。</p><h1 id="cf56" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">建立</h1><ol class=""><li id="4a87" class="kw kx iq ka b kb mt kf mu kj mz kn na kr nb kv lb lc ld le bi translated">创建一个文件夹，我们将在其中测试我们将在本文中探索的所有概念</li></ol><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="f6d6" class="nk lw iq ln b gy nl nm l nn no">mkdir library-test<br/>cd library-test</span></pre><p id="ff34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.创建库工作区</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="1a24" class="nk lw iq ln b gy nl nm l nn no">ng new superhero-library-workspace</span></pre><blockquote class="lo lp lq"><p id="f61a" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated"><code class="fe lk ll lm ln b"><em class="iq">ng new workspace_name</em></code>命令将提示一些关于我们将在默认项目中使用什么的问题(路由/样式表等)。选择你喜欢的任何东西。</p></blockquote><p id="dddb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.为库的使用者创建另一个工作区</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="d6f1" class="nk lw iq ln b gy nl nm l nn no">ng new library-consumer</span></pre><p id="f9ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.在库工作区中创建库</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="24f8" class="nk lw iq ln b gy nl nm l nn no">cd superhero-library-workspace<br/>ng generate library superhero-library</span></pre><p id="6a96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第2步中，我们创建一个工作区，它的默认web应用程序可以作为我们的图书馆演示网站。在这个工作空间中，我们<em class="lr">生成了</em>一个类型为<em class="lr">库</em>的项目(步骤4)。</p><p id="365c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想要创建一个库并将其发布到任何存储库(公共的或私有的)，这几乎就是我们所需要的全部。</p><h1 id="0be7" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">建筑、出版和消费——传统的方式</h1><p id="04e6" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">在我们优化本库的可用性之前。让我们构建我们已经创建的库，将其发布到一个公共存储库(在本例中是NPM ),并在另一个项目中使用它。</p><h2 id="eaf1" class="nk lw iq bd lx np nq dn mb nr ns dp mf kj nt nu mj kn nv nw mn kr nx ny mr nz bi translated">建筑物</h2><p id="4ee8" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">为了简洁起见，我们假设库中的现成模块和组件足够好，可以投入生产。</p><p id="cd44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经准备好构建我们的<code class="fe lk ll lm ln b">superhero-library</code>代码，我们可以导航到库(<code class="fe lk ll lm ln b">superhero-library-workspace</code>)工作区的根文件夹，并运行下面的命令:</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="1de4" class="nk lw iq ln b gy nl nm l nn no">ng build superhero-library</span></pre><blockquote class="lo lp lq"><p id="7716" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated">当我们添加我们的库(步骤#4)时，<code class="fe lk ll lm ln b"><em class="iq">@angular/cli</em></code>创建了这个库并向<code class="fe lk ll lm ln b"><em class="iq">angular.json</em></code>文件添加了必要的配置，这允许我们构建、测试和lint我们新添加的库。</p></blockquote><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/2772721648f8a8bda001a93f6d68f7f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_6FhSHGdUOrYytfGyfHjQ.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">构建库</figcaption></figure><h2 id="ad6e" class="nk lw iq bd lx np nq dn mb nr ns dp mf kj nt nu mj kn nv nw mn kr nx ny mr nz bi translated">出版</h2><p id="2699" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">由于我们想要将我们的库发布到<a class="ae my" href="http://npmjs.org" rel="noopener ugc nofollow" target="_blank"> NPM </a>，运行下面的命令，并在提示登录到存储库时提供NPM凭证(如果还没有完成，<a class="ae my" href="https://www.npmjs.com/signup" rel="noopener ugc nofollow" target="_blank">创建一个npmjs帐户</a>)。</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="b631" class="nk lw iq ln b gy nl nm l nn no">npm adduser</span></pre><blockquote class="lo lp lq"><p id="c3fd" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated">这是一次性操作，如果您已经登录，可以跳过。</p></blockquote><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/e575c3d5fa5dfa4738cea6a4f4e09b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcOzewqWs6L1oxDDkvIjJw.png"/></div></div></figure><p id="5802" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">登录后，<code class="fe lk ll lm ln b">cd</code>进入<code class="fe lk ll lm ln b">build</code>命令生成的<code class="fe lk ll lm ln b">dist/superhero-library</code>文件夹(来自上一步),运行下面的命令将库发布到NPM。</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="34aa" class="nk lw iq ln b gy nl nm l nn no">cd dist/superhero-library<br/>npm publish</span></pre><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/9d21f7ff40d6933976ed091a62a1b56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tShTYmzbTfbTyfzr47aow.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">npm发布</figcaption></figure><h2 id="193e" class="nk lw iq bd lx np nq dn mb nr ns dp mf kj nt nu mj kn nv nw mn kr nx ny mr nz bi translated">强烈的</h2><p id="3ccd" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我们创建并出版的图书馆现在可以在这里找到。它非常精简，除了呈现我们生成库时创建的默认组件之外，目前没有做太多事情。</p><p id="3aee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在我们专门为此创建的<code class="fe lk ll lm ln b">library-consumer</code>中使用<code class="fe lk ll lm ln b">superhero-library</code>版本<code class="fe lk ll lm ln b">0.0.1</code>。</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="d21b" class="nk lw iq ln b gy nl nm l nn no">cd library-consumer</span><span id="c60c" class="nk lw iq ln b gy oh nm l nn no">npm install --save superhero-library@0.0.1</span></pre><p id="88d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将从公共的NPM存储库中带来这个库，并将其安装在我们的用户中。</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/1f716a58bffec80df7d203abf98550cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wCQ3rvqIm7_mtaknMyKdQ.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">已安装的库</figcaption></figure><p id="18dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，通过将从<code class="fe lk ll lm ln b">superhero-library</code>导出的模块包含在主模块的<code class="fe lk ll lm ln b">imports</code>部分中，可以在<code class="fe lk ll lm ln b">library-consumer</code>项目中使用这个模块。但这是常规流程，本文的目的是帮助我们制作更好的库，这样用户就不必手动执行这些和其他琐碎的任务。</p><p id="28af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们看看如何在每个接触点提升消费者体验。</p><h1 id="2017" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">装置</h1><p id="cce6" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">多亏了<code class="fe lk ll lm ln b">@angular/cli</code>，我们不需要做太多事情来简化安装(这已经够简单了)。<code class="fe lk ll lm ln b">ng add</code>命令是围绕<code class="fe lk ll lm ln b">npm install</code>命令的功能包装器，有一些细微的区别。</p><ol class=""><li id="b2e0" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">可以通过<code class="fe lk ll lm ln b">angular.json</code>配置使用<code class="fe lk ll lm ln b">yarn</code>代替<code class="fe lk ll lm ln b">npm</code></li><li id="7e2f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">一旦软件包安装完毕，默认执行<code class="fe lk ll lm ln b">ng-add</code>原理图</li></ol><blockquote class="lo lp lq"><p id="bcb1" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated"><a class="ae my" href="https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2" rel="noopener ugc nofollow" target="_blank">此</a>是深入了解原理图的绝佳资源。</p><p id="24b9" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated">在本文中(以及后面的文章中)。我们将采取小步骤，仅讨论我们希望使用的部分原理图。</p></blockquote><p id="1d9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe lk ll lm ln b">library-consumer</code>工作区中，如果我们尝试<code class="fe lk ll lm ln b">ng add</code>我们现有的<code class="fe lk ll lm ln b">superhero-library</code>我们会看到以下错误:</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/5b6b1471ad8dfbf10f9301953b052310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9xsUhYamLovP2CGrlyBgA.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">ng添加示意图错误</figcaption></figure><p id="f06d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面我们看到的相当于我们之前运行的<code class="fe lk ll lm ln b">npm install</code>命令，只是现在Angular CLI告诉我们<code class="fe lk ll lm ln b">superhero-library</code>缺少schematics支持(因为它找不到schematics入口点)。</p><h2 id="fbf4" class="nk lw iq bd lx np nq dn mb nr ns dp mf kj nt nu mj kn nv nw mn kr nx ny mr nz bi translated">图表</h2><p id="c812" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">在<a class="ae my" href="https://www.npmjs.com/package/@angular-devkit/schematics" rel="noopener ugc nofollow" target="_blank">主原理图包</a>的NPM库中可以找到最简单、最简明的角度原理图描述。</p><blockquote class="ok"><p id="86f3" class="ol om iq bd on oo op oq or os ot kv dk translated">Schematics是转换现有文件系统的生成器。他们可以创建文件、重构现有文件或移动文件。</p><p id="0587" class="ol om iq bd on oo op oq or os ot kv dk translated">schematics与其他生成器(如Yeoman或Yarn Create)的区别在于，Schematics是纯描述性的；在一切准备好提交之前，不会对实际的文件系统应用任何更改。通过设计，在原理图中没有副作用。</p></blockquote><p id="c806" class="pw-post-body-paragraph jy jz iq ka b kb ou kd ke kf ov kh ki kj ow kl km kn ox kp kq kr oy kt ku kv ij bi translated">什么是原理图:</p><p id="77a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—它们是生成器，即它们是函数</p><p id="6c9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—它们是描述性的，即仅描述他们希望实现的目标，例如添加一个模块</p><p id="6620" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哪些原理图不是:</p><p id="0130" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">—一种访问文件系统并直接修改文件的方法</p><h1 id="593e" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">易用性</h1><p id="9e7b" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">能够容易地安装一个库关系到它的整体易用性。在本节中，我们将讨论角度示意图如何帮助我们实现同样的目标。</p><p id="d820" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于我们对schematics的简单了解，让我们探索一下schematics能为我们做什么(更具体地说是为我们的<code class="fe lk ll lm ln b">superhero-library</code>)。</p><p id="288b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在继续之前，要知道<code class="fe lk ll lm ln b">@angular-devkit</code>提供了<code class="fe lk ll lm ln b">schematics-cli</code>，它可以用来手工生成我们将要做的事情。我们不使用CLI，因为生成的schematics项目包含逻辑示意图的最终状态，并且我们正在尝试一步一步地实现这一点。</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="f37d" class="nk lw iq ln b gy nl nm l nn no">// optionally install the schematics-cli</span><span id="0c30" class="nk lw iq ln b gy oh nm l nn no">npm install -g <!-- -->@angular-devkit/schematics-cli</span></pre><p id="46a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要做的第一件事是为我们的应用程序创建一个schematics入口点。当使用<code class="fe lk ll lm ln b">ng add</code>将库添加到工作区/项目时，<code class="fe lk ll lm ln b">@angular/cli</code>解析库的<code class="fe lk ll lm ln b">package.json</code>文件，并寻找由库支持的各种原理图组成的<code class="fe lk ll lm ln b">schematics</code>文件。如果<code class="fe lk ll lm ln b">@angular/cli</code>找到原理图，它执行<code class="fe lk ll lm ln b">ng-add</code>原理图。</p><p id="a004" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们项目的这个阶段，我们希望创建一个库，当通过<code class="fe lk ll lm ln b">ng add</code>安装时，它可以自动将其主模块注入到消费应用程序中。</p><p id="972c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们首先创建一个名为<code class="fe lk ll lm ln b">collection.json</code>的文件，它将包含我们所有的<code class="fe lk ll lm ln b">schematics</code>，然后我们将它定义为<code class="fe lk ll lm ln b">package.json</code>文件中的入口点。</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="b336" class="nk lw iq ln b gy nl nm l nn no">cd projects/superhero-project</span></pre><p id="7929" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建如下所示的<code class="fe lk ll lm ln b">collection.json</code>文件:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="d281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该原理图文件仅包含一个<code class="fe lk ll lm ln b">schematic</code>(此时)。它被命名为<code class="fe lk ll lm ln b">ng-add</code>，它是在<code class="fe lk ll lm ln b">ng add</code>操作期间被触发的原理图(注意原理图名称中的<code class="fe lk ll lm ln b">—</code>，它是必需的)。</p><p id="ec9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除此之外，我们还有定义文档结构的<code class="fe lk ll lm ln b">$schema</code>。这特别有用，因为它在向<code class="fe lk ll lm ln b">collection.json</code>文件添加不正确的属性时会警告我们。</p><p id="c6a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在需要用<code class="fe lk ll lm ln b">collection.json</code>文件的路径更新<code class="fe lk ll lm ln b">package.json</code>文件。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="1284" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得我们的项目得到了支持。我们仍然需要实现通过<code class="fe lk ll lm ln b">ng-add</code>命令安装库时执行的实际逻辑。</p><p id="ba85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">早些时候，我们在创建<code class="fe lk ll lm ln b">ng-add</code>原理图时声明了一个<code class="fe lk ll lm ln b">factory</code>。此<code class="fe lk ll lm ln b">factory</code>在<code class="fe lk ll lm ln b">ng-add</code>原理图被调用时执行。</p><p id="5ee8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该工厂可以访问传递给被调用的原理图的所有命令行参数(在本例中为<code class="fe lk ll lm ln b">ng-add</code>),并返回一个<code class="fe lk ll lm ln b">Rule</code>,它是一个生成器函数，告诉<code class="fe lk ll lm ln b">@angular</code>我们希望在消费应用程序中进行什么更改。</p><p id="3d9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于schematics是声明性的，我们确实可以访问<code class="fe lk ll lm ln b">Tree</code>——消费应用程序文件结构的当前状态，以及<code class="fe lk ll lm ln b">SchematicContext</code>——当前执行环境中的原理图配置和设置。</p><p id="6c20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们希望创建一个<code class="fe lk ll lm ln b">Rule</code>，它可以修改消费应用程序的<code class="fe lk ll lm ln b">Tree</code>，并在<code class="fe lk ll lm ln b">MainModule</code>中插入我们的<code class="fe lk ll lm ln b">SuperHeroModule</code>。</p><p id="c0a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这些操作非常常见，所以有一些库可以用来执行这些任务。我们将使用<code class="fe lk ll lm ln b"><a class="ae my" href="https://www.npmjs.com/package/schematics-utilities" rel="noopener ugc nofollow" target="_blank">schematics-utilities</a></code>来实现这一点。</p><p id="b43e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先安装它:</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="e016" class="nk lw iq ln b gy nl nm l nn no">cd projects/superhero-library</span><span id="8523" class="nk lw iq ln b gy oh nm l nn no">npm install --save schematics-utilities</span></pre><blockquote class="lo lp lq"><p id="fff7" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated">确保仅将逻辑示意图特定的依赖项添加到库package.json，而不是工作空间package.json</p></blockquote><p id="06f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular项目使用<code class="fe lk ll lm ln b">ng-packagr</code>来构建项目，所以在我们的例子中，当我们添加<code class="fe lk ll lm ln b">schematics-utilities</code>作为依赖项时，我们需要显式地将这个依赖项列入白名单。</p><p id="f315" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是必要的，因为它违背了在库上只有<code class="fe lk ll lm ln b">peerDependencies</code>的惯例，并且我们要求我们的消费者也在他们的应用程序中安装<code class="fe lk ll lm ln b">schematic-utilities</code>。这个白名单可以在<code class="fe lk ll lm ln b">ng-package.json</code>文件中提供。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="c6c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实用程序库还不能使用。它为我们提供了修改<code class="fe lk ll lm ln b">Tree</code>的便捷方法，我们将使用其中一些方法将<code class="fe lk ll lm ln b">superhero-library</code>模块导入到消费应用<code class="fe lk ll lm ln b">MainModule</code>中。</p><p id="c189" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在原理图描述的位置创建工厂，做了这些更改后，我们的<code class="fe lk ll lm ln b">superhero-library/schematics/ng-add/index.ts</code>文件如下所示:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">指示ng-add规则的注释代码</figcaption></figure><p id="0384" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在发布更新后的库之前，我们需要做的最后一件事是将我们的<code class="fe lk ll lm ln b">schematic</code>从<code class="fe lk ll lm ln b">TypeScript</code>编译成<code class="fe lk ll lm ln b">JavaScript</code>。</p><p id="cbc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们可以创建一个<code class="fe lk ll lm ln b">tsconfig.schematics.json</code>文件，用于编译我们的代码，并放在我们的<code class="fe lk ll lm ln b">superhero-library</code>的<code class="fe lk ll lm ln b">dist</code>文件夹中。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">rootDir和outDir表示我们的TypeScript编译器的输入和输出</figcaption></figure><p id="c341" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！我们已经创建了启用示意图的库，并准备将其发布到NPM注册中心。</p><p id="de1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们需要执行以下步骤:</p><ol class=""><li id="5ebc" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">撞上<code class="fe lk ll lm ln b">superhero-library</code>版本号</li><li id="3ed3" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">重建我们的<code class="fe lk ll lm ln b">superhero-library</code></li><li id="21a1" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">重建我们的示意图，放在<code class="fe lk ll lm ln b">dist</code></li><li id="62ed" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">将<code class="fe lk ll lm ln b">collections.json</code>文件从项目复制到<code class="fe lk ll lm ln b">dist</code></li></ol><blockquote class="lo lp lq"><p id="ab58" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated">每次我们改变和重建我们的库时，我们都需要重建我们的原理图，因为<code class="fe lk ll lm ln b"><em class="iq">dist</em></code>文件夹会被覆盖，<code class="fe lk ll lm ln b"><em class="iq">schematics</em></code>和<code class="fe lk ll lm ln b"><em class="iq">collection.json</em></code>文件会被删除。</p></blockquote><p id="04f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们可以将下面的脚本放在<code class="fe lk ll lm ln b">superhero-library-workspace</code>的根目录下，并通过<code class="fe lk ll lm ln b">package.json</code>脚本调用它。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="1073" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以从<code class="fe lk ll lm ln b">superhero-library-workspace</code> <code class="fe lk ll lm ln b">package.json</code>文件的<code class="fe lk ll lm ln b">scripts</code>部分调用，如下所示:</p><pre class="nc nd ne nf gt ng ln nh ni aw nj bi"><span id="9439" class="nk lw iq ln b gy nl nm l nn no">{<br/>    ...</span><span id="8964" class="nk lw iq ln b gy oh nm l nn no">    "scripts": { </span><span id="32b5" class="nk lw iq ln b gy oh nm l nn no">        "package": "sh pack.sh",</span><span id="6617" class="nk lw iq ln b gy oh nm l nn no">    },</span><span id="d906" class="nk lw iq ln b gy oh nm l nn no">    ...<br/>}</span></pre><p id="0af3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行时，我们会看到以下内容:</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/0482eeb8ae95af2f5542484b71853b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWdyoNgOfVH2-qZu5lpGoA.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">建立图书馆，示意图和复制收藏</figcaption></figure><p id="2fa5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且<code class="fe lk ll lm ln b">dist</code>文件夹现在如预期的那样被重新创建。</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/d9bf327bdef7fbeaa89bbbe732b044fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*u7bM1Byq9f7umzh4SwRCrg.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">生成的分发文件夹</figcaption></figure><p id="dc52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在准备将这个包发布到NPM，并在我们的<code class="fe lk ll lm ln b">library-consumer</code>工作空间中使用它。</p><blockquote class="lo lp lq"><p id="611c" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated">记得在libraries package.json文件中添加库的主要/次要/补丁版本</p></blockquote><p id="88b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了发布，我们可以扩展我们的<code class="fe lk ll lm ln b">pack.sh</code>文件并添加命令来代表我们发布(假设<code class="fe lk ll lm ln b">npm adduser</code>已经成功运行)。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div></figure><blockquote class="lo lp lq"><p id="358e" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated">由于<code class="fe lk ll lm ln b"><em class="iq">ng add</em></code>支持对我们来说是一个很大的改变，所以在执行package命令之前，我将把<code class="fe lk ll lm ln b"><em class="iq">superhero-library</em></code>包中的项目版本提升到1.0.0。</p></blockquote><p id="e32c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以从<code class="fe lk ll lm ln b">superhero-library-workspace</code>的根目录运行<code class="fe lk ll lm ln b">npm run package</code>命令，我们的新版本发布了:</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pd"><img src="../Images/6dc3c3abc3225bc5fa0f72fe40fb3399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DECM9Uh52k2gf4gffuXmQ.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">用更新版本发布的包</figcaption></figure><p id="fb68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里<a class="ae my" href="https://www.npmjs.com/package/superhero-library/v/1.0.0" rel="noopener ugc nofollow" target="_blank">成功推包可用。现在，为了消费它，我们可以使用<code class="fe lk ll lm ln b">ng add</code>命令将<code class="fe lk ll lm ln b">superhero-library</code>添加到我们的<code class="fe lk ll lm ln b">library-consumer</code>中。</a></p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pe"><img src="../Images/70e25070d298e63e7f706e930467d312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*045du5o6RMv2JqXBP8nUfw.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">超级英雄库1.0.0通过ng add安装</figcaption></figure><p id="97db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以验证我们的<code class="fe lk ll lm ln b">library-consumer</code>已经按预期更新:</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pf"><img src="../Images/fb2df13cb7a0eb9fa43c13b5619cc1f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9_nTaBY0NFfVtrnc5NEYQ.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">基于ng-add示意图的更新模块</figcaption></figure><h1 id="2944" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论</h1><p id="f993" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">现在我们已经有了基本的原理图，我们的项目也已经启动。我们准备继续学习更复杂的操作，这些操作可以使用<code class="fe lk ll lm ln b">schematics</code>来执行，这反过来可以用来增强本文中列出的其他开发人员的体验。</p><p id="75e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文中使用的全部代码可以在<a class="ae my" href="https://github.com/40x/ng-schematics-example" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="7635" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第2部分即将推出。</p></div><div class="ab cl pg ph hu pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="ij ik il im in"><p id="f551" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lr">如果你喜欢这个博客，一定要为它鼓掌，</em> <a class="ae my" href="https://medium.com/@kashyap.mukkamala" rel="noopener"> <em class="lr">阅读更多</em> </a> <em class="lr">或者关注我的</em><a class="ae my" href="https://www.linkedin.com/in/kashyap-mukkamala/" rel="noopener ugc nofollow" target="_blank"><em class="lr">LinkedIn</em></a><em class="lr">和</em><a class="ae my" href="https://twitter.com/JSSculptor" rel="noopener ugc nofollow" target="_blank"><em class="lr">Twitter</em></a><em class="lr">。</em></p></div></div>    
</body>
</html>