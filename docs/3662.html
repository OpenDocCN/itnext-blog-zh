<html>
<head>
<title>Laravel: The mysterious “Ordered UUID”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拉勒维尔:神秘的“有序的UUID”</h1>
<blockquote>原文：<a href="https://itnext.io/laravel-the-mysterious-ordered-uuid-29e7500b4f8?source=collection_archive---------0-----------------------#2020-01-27">https://itnext.io/laravel-the-mysterious-ordered-uuid-29e7500b4f8?source=collection_archive---------0-----------------------#2020-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="40f7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">UUID最好的v4和UUID最好的v1，但顺序相反</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5da9007ec00caef5063e8c5af76f0594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1gDYXslEY8tSoFyU"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/p/9f2b93cf6795" rel="noopener">在应用程序的公共部分与UUID合作</a>是隐藏一个表可能拥有的记录的真实数量的最简单的方法，出于隐私和安全的原因，同时保持一个特定的记录可从外部检索而不给出太多信息。</p><p id="b3c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你不需要自己创建UUID，或者添加一个包。Laravel 6.0已经附带了一个助手，允许创建两种类型的UUID:</p><ul class=""><li id="efb1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://laravel.com/docs/5.7/helpers#method-str-uuid" rel="noopener ugc nofollow" target="_blank"> UUID v4 </a>，基于全部122位的随机性。</li><li id="8db6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://laravel.com/docs/5.7/helpers#method-str-ordered-uuid" rel="noopener ugc nofollow" target="_blank">有序UUID </a>，基于48位时间戳和72位随机性。</li></ul><p id="64de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所读到的,“有序的UUID”有点新。它介于UUID v1(基于时间，可猜测)和UUID v4(基于随机，不太可能猜测)之间。这台UUID的特别之处在于……嗯，它可以方便地<strong class="ky ir">订购</strong>。换句话说，您可以从最新的或最早的开始对它们进行排序，而不必调用其他列，因为第一个字节是从它生成时起的时间戳。</p><p id="302a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然它的随机性比<em class="mg">小</em>，但它可以变得<strong class="ky ir">非常可靠</strong>，因为在‭4.722.366.482.869.645.213.695‬碰撞的几率是每0.00001秒(十<a class="ae kv" href="https://en.wikipedia.org/wiki/Microsecond" rel="noopener ugc nofollow" target="_blank">微秒</a>)一次。我的基准是什么？赢得强力球或看一部好的《星球大战》电影的可能性。</p><h1 id="8eb9" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">“我自己的UUID之路”的数据库领域</h1><p id="e0c7" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在继续之前，必须了解SQL数据库引擎和UUIDs之间的关系。你看，一些引擎让开发人员处理它，因为它被认为是非标准的SQL数据类型，而其他引擎提供了一种方法来<em class="mg">处理</em>它们，但不是完全处理。</p><ul class=""><li id="19bb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">对于UUID，微软SQL Server 有一个名为<a class="ae kv" href="https://docs.microsoft.com/en-us/sql/t-sql/data-types/uniqueidentifier-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> uniqueidentifier </a>的列。它还提供了一种<a class="ae kv" href="https://docs.microsoft.com/en-us/sql/t-sql/functions/newid-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">创建完全随机的GUID </a>的方法。</li><li id="6614" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">MySQL 什么都不做。你<em class="mg">应该</em>使用16字节的二进制列。有一个函数<a class="ae kv" href="https://dev.mysql.com/doc/refman/8.0/en/miscellaneous-functions.html#function_uuid" rel="noopener ugc nofollow" target="_blank">创建一个UUID v1 </a>并且<a class="ae kv" href="https://dev.mysql.com/doc/refman/8.0/en/trigger-syntax.html" rel="noopener ugc nofollow" target="_blank">在插入</a>之前触发它。</li><li id="a9f3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> MariaDB </strong>与MySQL处于相同的状态，但是<a class="ae kv" href="https://mariadb.com/kb/en/guiduuid-performance/" rel="noopener ugc nofollow" target="_blank">提供了有效使用UUID的指南</a>。</li><li id="bb54" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> PostgreSQL </strong>有一个<a class="ae kv" href="https://www.postgresql.org/docs/9.1/datatype-uuid.html" rel="noopener ugc nofollow" target="_blank">特殊的列类型来处理UUID </a>。加载<code class="fe ne nf ng nh b"><a class="ae kv" href="https://www.postgresql.org/docs/9.4/uuid-ossp.html" rel="noopener ugc nofollow" target="_blank">uuid-ossp</a></code> <a class="ae kv" href="https://www.postgresql.org/docs/9.4/uuid-ossp.html" rel="noopener ugc nofollow" target="_blank">扩展</a>将允许您创建任何UUID，并且<a class="ae kv" href="https://dba.stackexchange.com/questions/122623/default-value-for-uuid-column-in-postgres" rel="noopener ugc nofollow" target="_blank">在向表中插入记录时将其定义为默认的</a>。</li></ul><p id="8b1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您很大程度上依赖于应用程序本身来创建您的UUID，这可能是好的，也可能不是。对我来说，让数据库而不是应用程序来处理UUID的创建和解析使它不依赖于应用程序。如果有一天我们改变了应用程序，你将不得不以某种方式添加一个UUID函数，如果它不可用的话。</p><p id="49be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有可能在插入记录之前创建一个触发器，以便在数据库中自动创建一个UUID，我认为您应该这样做。最初几分钟，它会走在滚烫的熔岩上，但是一旦你出去了，你就再也不会回去了。</p><blockquote class="ni nj nk"><p id="da2f" class="kw kx mg ky b kz la jr lb lc ld ju le nl lg lh li nm lk ll lm nn lo lp lq lr ij bi translated">注意，大多数数据库告诉你不要使用<code class="fe ne nf ng nh b">CHAR</code>而是<code class="fe ne nf ng nh b">BINARY</code>，因为UUID本身是一个二进制字符串。如果您对36个字符使用<code class="fe ne nf ng nh b"><em class="iq">CHAR</em></code>，那么对于UUID，您将从16个字节跳到288个字节。你已经被警告了。</p></blockquote><h1 id="659d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">两全其美，两全其美之外</h1><p id="52e5" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated"><code class="fe ne nf ng nh b">Str::orderedUuid()</code>返回类似UUID v4的东西，但它不是真正的<em class="mg">UUID。这是因为它是在标准<a class="ae kv" href="https://tools.ietf.org/html/rfc4122" rel="noopener ugc nofollow" target="_blank"> RFC 4122 </a>之外生成的，但是仍然在UUID v4领域之内，所以没有机器在验证它时会有问题。</em></p><p id="9ea0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些数据是如何产生的？嗯，制作UUID的“编解码器”被称为<code class="fe ne nf ng nh b"><a class="ae kv" href="https://github.com/ramsey/uuid/blob/master/src/Codec/TimestampFirstCombCodec.php" rel="noopener ugc nofollow" target="_blank">TimestampFirstCombCodec</a></code>，它将时间戳的48位放在第一个字节而不是最后一个字节。</p><p id="6197" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查整个过程:</p><ol class=""><li id="8b3c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr no ly lz ma bi translated">它根据给定的“散列”(随机字节)加上时间戳创建一个随机字符串。</li><li id="e087" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr no ly lz ma bi translated">之后，它将时间戳从最后一个交换到第一个。</li><li id="925a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr no ly lz ma bi translated">将UUID v4标识符(版本和变体)添加到字符串中。</li><li id="e0a8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr no ly lz ma bi translated">返回字符串</li></ol><p id="62e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，你会得到这样的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/a67aaaf9e53c869bfa69ee4a141293e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RiWs-QIgEHZggB1R-9Z4Q.png"/></div></div></figure><p id="1444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个图像是不言自明的:我们有48位来定义时间戳，精度为0.00001。去掉版本和变体，2个字节标识它是UUID v4，我们剩下72位的随机性。</p><h1 id="e71c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">在模型中使用它</h1><p id="8e2c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如果您有一个包含UUID列的模型，您可以让Laravel使用Trait或覆盖construct方法来填充UUID。</p><p id="240f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个特性将允许您在多个模型中重用相同的初始化逻辑，</p><pre class="kg kh ki kj gt nq nh nr ns aw nt bi"><span id="9d29" class="nu mi iq nh b gy nv nw l nx ny">// app/FillWithUuid.php</span><span id="6d0f" class="nu mi iq nh b gy nz nw l nx ny">trait FillWithUuid<br/>{<br/>    public function initializeFillWithUuid()<br/>    {<br/>        $this-&gt;attributes['uuid'] = Str::orderedUuid();<br/>    }<br/>}</span></pre><p id="5b62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然构造覆盖仅适用于特定的模型:</p><pre class="kg kh ki kj gt nq nh nr ns aw nt bi"><span id="2aea" class="nu mi iq nh b gy nv nw l nx ny">// app/MyModel.php</span><span id="76a9" class="nu mi iq nh b gy nz nw l nx ny">public function __construct(array $attributes = [])<br/>{<br/>    $attributes['uuid'] = Str::orderedUuid();</span><span id="5265" class="nu mi iq nh b gy nz nw l nx ny">    parent::__construct($attributes);<br/>}</span></pre><p id="dd99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当通过<code class="fe ne nf ng nh b">creating</code>事件创建一个模型时，你也可以使用特征的<code class="fe ne nf ng nh b">boot()</code>方法，比如<code class="fe ne nf ng nh b">bootFillWithUuid()</code>，来添加UUID，这对于一些人来说可能看起来更干净。</p><p id="b5c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我之前所写的，时间戳在其他任何事情之前。这意味着您可以要求数据库按存储UUID的列对记录进行排序，大多数情况下，该列具有相同的名称。例如，按照它们被<em class="mg">持久化</em>到数据库的时间对它们进行排序:</p><pre class="kg kh ki kj gt nq nh nr ns aw nt bi"><span id="e47f" class="nu mi iq nh b gy nv nw l nx ny">MyModel::limit(15)-&gt;orderByDesc('uuid')-&gt;get();</span></pre><p id="832a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在<code class="fe ne nf ng nh b">uuid</code>列上有一个索引(或唯一索引),这种类型的查询会变得非常快，因为数据库不会扫描整个表来检索结果，但是索引本身与整个表相比会变得非常小。</p><blockquote class="ni nj nk"><p id="f3eb" class="kw kx mg ky b kz la jr lb lc ld ju le nl lg lh li nm lk ll lm nn lo lp lq lr ij bi translated">从某种角度来看，一个包含1，000，000行的表的UUIDs索引大约为16MB。如果像存储字符串一样存储，索引权重大约为288MB。不要把UUID像绳子一样储存起来。<strong class="ky ir">从不</strong>。</p></blockquote><p id="91ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了确保万无一失，我让SQLite向我解释它如何使用<code class="fe ne nf ng nh b">uuid</code>列上的惟一索引从<code class="fe ne nf ng nh b">test_table</code>表中检索记录。</p><pre class="kg kh ki kj gt nq nh nr ns aw nt bi"><span id="4060" class="nu mi iq nh b gy nv nw l nx ny">EXPLAIN QUERY PLAN<br/>SELECT * FROM test_table ORDER BY uuid DESC LIMIT 15</span><span id="262c" class="nu mi iq nh b gy nz nw l nx ny">// Without index<br/>&gt;&gt; SCAN TABLE test_table<br/>&gt;&gt; USE TEMP B-TREE FOR ORDER BY</span><span id="f480" class="nu mi iq nh b gy nz nw l nx ny">// With index on "uuid"<br/>&gt;&gt; SCAN TABLE test_table <br/>&gt;&gt; USING INDEX test_table_uuid_unique</span></pre><h1 id="7b00" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">警告</h1><p id="831d" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">有两件事你必须意识到这一点”UUID命令道。</p><p id="5327" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，时间戳不使用碳甚至日期工厂。这意味着:你将得到你的<strong class="ky ir">服务器的真实时间戳</strong>。在某些边缘情况下，这种行为可能会破坏测试。幸运的是你可以创建自己的UUID工厂，<a class="ae kv" href="https://github.com/laravel/framework/blob/6.x/src/Illuminate/Support/Str.php#L640-L649" rel="noopener ugc nofollow" target="_blank"/><code class="fe ne nf ng nh b"><a class="ae kv" href="https://github.com/laravel/framework/blob/6.x/src/Illuminate/Support/Str.php#L640-L649" rel="noopener ugc nofollow" target="_blank">Str</a></code><a class="ae kv" href="https://github.com/laravel/framework/blob/6.x/src/Illuminate/Support/Str.php#L640-L649" rel="noopener ugc nofollow" target="_blank">助手允许</a>的东西。对于大多数人来说，这是微不足道的。</p><p id="ad3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二点，也是最明显的一点，有序UUID公开了时间戳本身，因此任何看到UUID的人都可以知道记录是何时保存到数据库中的，但不知道表中有多少记录。如果您需要完全随机的标识符，您应该<strong class="ky ir">使用UUID v4，同时使用<code class="fe ne nf ng nh b">created_at</code>列从最新或最老的开始排序您的记录。</strong></p></div></div>    
</body>
</html>