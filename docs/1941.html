<html>
<head>
<title>A Toolkit to Harness the Full Power of JavaScript Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个充分利用JavaScript函数的工具包</h1>
<blockquote>原文：<a href="https://itnext.io/a-toolkit-to-harness-the-full-power-of-javascript-functions-633baaaba337?source=collection_archive---------2-----------------------#2019-02-27">https://itnext.io/a-toolkit-to-harness-the-full-power-of-javascript-functions-633baaaba337?source=collection_archive---------2-----------------------#2019-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ed001befa0af3f5bf028b11b8f792655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osWfdGGwqORztwX_mVqJwQ.jpeg"/></div></div></figure><p id="e649" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">函数构成了JavaScript语言中不可或缺的角色——它们是执行逻辑的手段。但是Javascript中的函数不仅仅是“做事情”的代码块。充分利用它们的潜力，JavaScript函数与<a class="ae lf" rel="noopener ugc nofollow" target="_blank" href="/the-power-of-functional-programming-in-javascript-cc9797a42b60">函数式编程</a>的范例完美契合，并为编码人员提供创建可扩展且高效的代码的能力。让我们看看如何！</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="561f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">JavaScript函数的正式定义</h1><p id="b47f" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">函数是被定义<strong class="ka ir">一次</strong>的代码块，但是可以被调用或执行<strong class="ka ir">任意次</strong>。一个函数由一系列被称为<strong class="ka ir">函数体</strong>的语句组成。可以将值传递给一个函数，函数将始终返回一个值(要么<em class="mq"> undefined </em>如果没有显式设置，否则函数的<strong class="ka ir"> <em class="mq"> return </em> </strong>语句中规定的值)。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9e40" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">function</strong> helloWorld(){<br/>   <strong class="mw ir">return</strong> 'hello world';<br/>}</span><span id="5895" class="na lo iq mw b gy nf nc l nd ne">helloWorld();   <em class="mq">// </em>returns<em class="mq"> 'hello world'</em></span><span id="01ce" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">function</strong> noReturnValue(){<br/>   const t = 'hello world';<br/>}</span><span id="cb8d" class="na lo iq mw b gy nf nc l nd ne">noReturnValue();  // returns <em class="mq">undefined</em></span></pre><p id="08d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript函数也是<strong class="ka ir">一级对象</strong>，因为它们可以像任何其他对象一样拥有<strong class="ka ir">属性</strong>和<strong class="ka ir">方法</strong>。它们实际上是<a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">功能</strong> </a>对象。</p><p id="62be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript函数因此可以被认为是可以被调用的<strong class="ka ir"> <em class="mq">对象。</em></strong></p><p id="2173" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，可以用有趣的方式操纵和利用JavaScript函数。例如，它们可以是</p><ol class=""><li id="d7cc" class="ng nh iq ka b kb kc kf kg kj ni kn nj kr nk kv nl nm nn no bi translated"><strong class="ka ir"> <em class="mq">赋给变量</em> </strong></li><li id="dfe1" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated"><strong class="ka ir"> <em class="mq">存储在对象的属性或数组中的元素</em> </strong></li><li id="fca1" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated"><strong class="ka ir"> <em class="mq">作为参数传递给其他函数</em> </strong></li><li id="5f3b" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated"><strong class="ka ir"> <em class="mq">作为其他功能的结果返回</em> </strong></li><li id="7db0" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated"><strong class="ka ir"> <em class="mq">通过</em> </strong>功能对象分配属性</li><li id="ff2f" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated"><strong class="ka ir"> <em class="mq">嵌套在其他功能</em> </strong>内</li></ol><p id="c8b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看这些令人敬畏的功能的一些例子！</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="2d18" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak"> 1。给变量分配函数</strong></h1><p id="5c3d" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">考虑这个函数:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6325" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">const</strong> square = <strong class="mw ir">function</strong>(x) {<br/>   <strong class="mw ir">return</strong> x * x;<br/>};</span></pre><p id="38d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该定义创建了一个新的函数对象，并将其赋给变量<strong class="ka ir"> <em class="mq"> square </em> </strong>。</p><p id="f809" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，函数<strong class="ka ir">没有被命名为</strong>。当以这种方式定义一个函数时(即把它赋给一个变量)，函数的名字实际上是不重要的，因此是不需要的。可以将该函数赋给另一个变量，并且仍然以同样的方式工作。</p><p id="6191" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以这种方式分配给变量的函数称为<strong class="ka ir"> <em class="mq">函数字面量</em> </strong>。函数文字非常灵活，非常适合只使用一次且不需要命名的函数。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="70e8" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">const</strong> a = square(4);   <em class="mq">// a contains the number 16</em><br/><strong class="mw ir">const</strong> b = square;   <em class="mq">// Now b refers to the </em><strong class="mw ir"><em class="mq">same</em></strong><em class="mq"> function that a does</em><br/><strong class="mw ir">const</strong> c = b(5);   <em class="mq">// c contains the number 25</em></span></pre></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="08f2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak"> 2。在对象属性中存储函数</strong></h1><p id="bc60" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">功能也可以分配给<strong class="ka ir">对象属性</strong>而不是全局属性。在这种情况下，它们被称为<strong class="ka ir">方法</strong>。</p><blockquote class="nu"><p id="b8f2" class="nv nw iq bd nx ny nz oa ob oc od kv dk translated">方法是Javascript函数，存储为对象的属性，并通过该对象调用。</p></blockquote><pre class="oe of og oh oi mv mw mx my aw mz bi"><span id="2f68" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">const</strong> o = new <strong class="mw ir">Object</strong>();</span><span id="6fef" class="na lo iq mw b gy nf nc l nd ne">o.square = <strong class="mw ir">function</strong>(x){    <em class="mq">// 'square' is a method of object 'o'</em><br/>   <strong class="mw ir">return</strong> x * x;<br/>}</span><span id="aa49" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">const</strong> y = o.square(16);    <em class="mq">// 256 </em></span><span id="8965" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">const</strong> squareRoot = <strong class="mw ir">function</strong>(x){    <em class="mq">// a function literal</em><br/>  <strong class="mw ir">return</strong> Math.sqrt(x);<br/>}</span><span id="378b" class="na lo iq mw b gy nf nc l nd ne">o.root = squareRoot;   <em class="mq">// 'root' is now a method of object 'o'</em><br/>o.root(4);  <em class="mq">// 2</em></span></pre><p id="a2ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将函数分配给数组元素:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="05e1" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">const</strong> a = new Array(3);</span><span id="9a6b" class="na lo iq mw b gy nf nc l nd ne">a[0] = <strong class="mw ir">function</strong>(x){return x * x;}<br/>a[1] = 20;<br/>a[2] = a[0](a[1]);  // the array element can now be invoked</span></pre><h1 id="f104" class="ln lo iq bd lp lq oj ls lt lu ok lw lx ly ol ma mb mc om me mf mg on mi mj mk bi translated">旁白:JavaScript方法和“this”关键字</h1><p id="6af2" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">正如我们刚刚看到的，方法是作为对象的属性存储并通过该对象调用的函数。</p><p id="e07a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何用作<strong class="ka ir">方法</strong>的<strong class="ka ir">函数</strong>都被有效地传递了一个隐式参数:<strong class="ka ir">调用它的对象</strong>。</p><p id="a36a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个方法通过其被调用的对象成为方法体中<strong class="ka ir"> <em class="mq">这个</em> </strong>关键字的值。</p><p id="781c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以通过<strong class="ka ir"> <em class="mq">这个</em> </strong>关键字来引用这个方法的对象。</p><p id="c887" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">对象文字:</strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="da67" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">const</strong> calculator = {<br/>   operand1 : 1,<br/>   operand2: 2,<br/>   compute: function(){<br/>       this.result = this.operand1 + this.operand2;<br/>   }<br/>}</span><span id="2446" class="na lo iq mw b gy nf nc l nd ne">calculator.compute();<br/>console.log(calculator.result);   // 3</span></pre><p id="4b16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">函数构造器:</strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3924" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">function</strong> Person(first, last, age, eyeColor) {<br/>   this.firstName = first;<br/>   this.lastName = last;<br/>   this.age = age;<br/>   this.eyeColor = eyeColor;<br/>   this.name = function() {<br/>      <strong class="mw ir">return</strong> this.firstName + “ “ + this.lastName;<br/>   };<br/>}</span><span id="c098" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">const</strong> father = new Person(‘Patrick’, ‘Henry’, 56, ‘blue’);</span><span id="361f" class="na lo iq mw b gy nf nc l nd ne">console.log(father.name());  // <em class="mq">'Patrick Henry'</em></span></pre><p id="ec53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> ES6类:</strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e64f" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">class</strong> Individual{</span><span id="fca4" class="na lo iq mw b gy nf nc l nd ne">constructor(){<br/>      this.status = 'indifferent';<br/>   }</span><span id="68fc" class="na lo iq mw b gy nf nc l nd ne">smile(){<br/>      this.status = 'happy';<br/>   }</span><span id="3b46" class="na lo iq mw b gy nf nc l nd ne">frown(){<br/>      this.status = 'sad';<br/>   }</span><span id="b7bc" class="na lo iq mw b gy nf nc l nd ne">};</span><span id="1ea0" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">const</strong> Jack = new Individual();  <em class="mq">// new object created here</em><br/>Jack.smile();  <em class="mq">// invoking the object's method 'smile()'</em><br/>console.log(Jack.status);  // <em class="mq">'happy'</em></span></pre><h1 id="129f" class="ln lo iq bd lp lq oj ls lt lu ok lw lx ly ol ma mb mc om me mf mg on mi mj mk bi translated">旁白:将“this”关键字与apply()、call()和bind()一起使用</h1><p id="c18a" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">好了，那么<strong class="ka ir"> <em class="mq">这个</em> </strong>关键字指的是调用方法的对象。但是你能在一个普通的JavaScript函数中利用这个关键字吗？</p><p id="cfbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">是</strong>！JavaScript还提供了<strong class="ka ir"> <em class="mq"> apply() </em> </strong> <em class="mq">，</em> <strong class="ka ir"> <em class="mq"> call() </em> </strong>和<strong class="ka ir"> <em class="mq"> bind() </em> </strong>助手方法，允许我们调用函数<strong class="ka ir">，就像调用对象</strong>的方法一样。</p><p id="00da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><strong class="ka ir"><em class="mq">call()，apply() </em> </strong>和<strong class="ka ir"> <em class="mq"> bind() </em> </strong>助手方法的第一个</strong>参数是<strong class="ka ir">对象，函数必须在该对象上被调用</strong>；该参数成为函数体中this关键字的值。</p><p id="3a12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何剩余的<strong class="ka ir"> <em class="mq">调用</em> () </strong>的参数都是传递给被调用函数的<strong class="ka ir">值</strong>。</p><p id="7a92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，向函数f()传递两个数字，并作为对象o的方法调用它:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="69a5" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">const</strong> o = {<br/>   total: 23<br/>}</span><span id="2850" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">const</strong> f = function(a, b){<br/>   <strong class="mw ir">return</strong> this.total + a + b;<br/>}</span><span id="d789" class="na lo iq mw b gy nf nc l nd ne">f.<strong class="mw ir">call</strong>(o, 1, 2);  <em class="mq">// 26</em></span></pre><p id="318f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="mq"> apply </em> () </strong>方法类似于<strong class="ka ir"> <em class="mq"> call </em> () </strong>方法，只是参数可以作为<strong class="ka ir">数组</strong>传递给函数:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7b29" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">const</strong> o = {<br/>   total: 25<br/>}</span><span id="e27d" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">const</strong> f = function(a, b){<br/>   <strong class="mw ir">return</strong> this.total + a + b;<br/>}</span><span id="0469" class="na lo iq mw b gy nf nc l nd ne">f.<strong class="mw ir">apply</strong>(o, [1, 2]);  <em class="mq">// 28</em></span></pre><p id="e4ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="mq">bind</em>()</strong>——作为ECMAScript 5的一部分添加——返回一个绑定函数，当稍后执行<strong class="ka ir"/>时，该函数将具有<strong class="ka ir"> <em class="mq">这个</em> </strong>关键字的正确上下文。</p><p id="de1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以<strong class="ka ir"> <em class="mq">绑定</em> () </strong>可以在函数需要的时候使用<strong class="ka ir">稍后</strong>随时调用。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="bbb4" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">const</strong> bound = f.<strong class="mw ir">bind</strong>(o, 1, 2); <em class="mq">// create a bound function with the   context which will be invoked later</em></span><span id="73e1" class="na lo iq mw b gy nf nc l nd ne">console.dir(bound);  <em class="mq">// returns a function</em></span><span id="1519" class="na lo iq mw b gy nf nc l nd ne">console.log(bound());  <em class="mq">// invokes the bound function</em></span></pre></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="eefc" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak"> 3。将函数作为参数传递给另一个函数</strong></h1><p id="1fd6" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">因为JavaScript函数是一个对象，所以允许将它作为参数传递给另一个函数。事实上，像<a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">array . prototype . sort()</strong></a>，<a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">array . prototype . reduce()</strong></a>，<a class="ae lf" href="https://www.w3schools.com/jsref/met_win_settimeout.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> setTimeout() </strong> </a>，<a class="ae lf" href="https://www.w3schools.com/jsref/met_win_setinterval.asp" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">setInterval()</strong></a>这样的helper方法都希望在它们的参数中有一个函数。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4d68" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">function</strong> add(x, y) {<br/>   <strong class="mw ir">return</strong> x + y;<br/>}<br/><strong class="mw ir">function</strong> subtract(x, y) {<br/>   <strong class="mw ir">return</strong> x - y;<br/>}<br/><strong class="mw ir">function</strong> divide(x, y) {<br/>   <strong class="mw ir">return</strong> x % y;<br/>}<br/><strong class="mw ir">function</strong> multiply(x, y) {<br/>   <strong class="mw ir">return</strong> x * y;<br/>}</span><span id="4529" class="na lo iq mw b gy nf nc l nd ne"><em class="mq">// this function has the 'operator' function as one of its arguments</em><br/><strong class="mw ir">function</strong> operate(operator, operand1, operand2){<br/>   <strong class="mw ir">return</strong> operator(operand1, operand2);<br/>}</span><span id="1bd2" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">const</strong> i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));</span></pre><p id="6119" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Array.sort() </strong>方法:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9c3c" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">const</strong> myList = ['the', 'quick', 'brown', 'fox', 'jumped', 'over', 'the', 'lazy', 'dog'];</span><span id="b46e" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">const</strong> compareFunction = (a, b) =&gt; {<br/><strong class="mw ir">   return</strong> ( a &lt; b ) ? -1 : ( a &gt; b ) ? 1 : 0;<br/>}</span><span id="03e5" class="na lo iq mw b gy nf nc l nd ne"><em class="mq">// sort my list alphabetically<br/></em>myList.sort((a, b) =&gt; compareFunction(a, b));</span></pre></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="e6e4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">4.从函数返回函数</h1><p id="a67f" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">作为函数的结果返回函数是完全可以接受的。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3e4d" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">function</strong> makeCake() {<br/>   let status = 0;<br/>   <strong class="mw ir">return </strong>{<strong class="mw ir"><br/>      </strong>bakeInOven: <strong class="mw ir">function</strong>(){<br/>            status += 1;<br/>            return `status = ${status}`;<br/>      },<br/>      addIcing: <strong class="mw ir">function</strong>(){<br/>            status += 1;<br/>            return `status = ${status}`;<br/>      },<br/>      addCandles: <strong class="mw ir">function</strong>(){<br/>            status += 1;<br/>            return `status = ${status}`;<br/>      }<br/>    }<strong class="mw ir"><br/></strong>}</span><span id="94ed" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">const</strong> cake = makeCake();</span><span id="b80e" class="na lo iq mw b gy nf nc l nd ne">cake.bakeInOven();  // "status = 1"<br/>cake.addIcing();    // "status = 2"<br/>cake.addCandles();  // "status = 3"</span></pre></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="bf57" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">5.定义函数对象的属性</h1><p id="568d" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">如前所述，每个JavaScript函数实际上都是一个<code class="fe oo op oq mw b"><strong class="ka ir">Function</strong></code>对象。这可以从返回true的代码<code class="fe oo op oq mw b">(function(){}).constructor === Function</code>中看出。</p><p id="4d36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，当一个函数需要一个值在调用中保持不变的变量时，使用<strong class="ka ir"> Function </strong>对象的属性会很方便，而不是通过定义一个全局变量来混淆名称空间。</p><p id="29ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，假设您想编写一个函数，无论何时调用，它都会返回一个唯一的整数。该函数决不能两次返回相同的值。为了做到这一点，函数需要跟踪它已经返回的值，并且这些信息必须在函数调用中保持不变。</p><p id="cded" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以将该信息存储在一个全局变量中，但这是不必要的，因为该信息仅由函数本身使用。最好将信息存储在函数对象的<strong class="ka ir">属性中。</strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a445" class="na lo iq mw b gy nb nc l nd ne"><em class="mq">/* Create and initialise the “static” variable. Function declarations are processed before code is executed, so we can do this assignment before the function declaration. */</em></span><span id="b55f" class="na lo iq mw b gy nf nc l nd ne">uniqueInteger.counter = 0;</span><span id="5ffd" class="na lo iq mw b gy nf nc l nd ne"><em class="mq">/* Here’s the function. It returns a different value each time it is called and uses a “static” property of itself to keep track of the last value it returned. */</em></span><span id="faab" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">function</strong> uniqueInteger(){<br/>   <em class="mq">// increment and return our “static” variable<br/>   </em><strong class="mw ir">return</strong> uniqueInteger.counter ++; <br/>}</span><span id="b154" class="na lo iq mw b gy nf nc l nd ne">const i = uniqueInteger(); <em class="mq">// 0</em><br/>const j = uniqueInteger(); <em class="mq">// 1</em><br/>const k = uniqueInteger(); <em class="mq">// 2</em><br/>const l = uniqueInteger(); <em class="mq">// 3</em></span></pre></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="5ca7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">6.函数内嵌套函数</h1><p id="a6e1" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在Javascript中，函数可以嵌套在其他函数中</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d6dd" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">function</strong> hypothenuse (a, b) {<br/>   <strong class="mw ir">function</strong> square(x) { return x * x};<br/><strong class="mw ir">   return</strong> Math.sqrt(square(a) + square(b));<br/>}</span><span id="e04e" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">const</strong> h = hypothenuse(5,8);<br/><em class="mq">// 9.433981132056603</em></span></pre><p id="c971" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript函数本质上是要执行的代码和执行它们的范围的组合。这种代码和范围的组合被称为<strong class="ka ir">闭包</strong>。所有的JavaScript函数都是闭包。闭包变得有趣的地方在于<strong class="ka ir">嵌套函数</strong>的情况。</p><h1 id="14cc" class="ln lo iq bd lp lq oj ls lt lu ok lw lx ly ol ma mb mc om me mf mg on mi mj mk bi translated">旁白:函数范围和闭包</h1><blockquote class="nu"><p id="4f8e" class="nv nw iq bd nx ny nz oa ob oc od kv dk translated">JavaScript中的函数是词法范围的，而不是动态范围的。这意味着它们在定义<strong class="ak">的</strong>范围内运行，而不是在执行<strong class="ak">的</strong>范围内运行。</p></blockquote><p id="9bed" class="pw-post-body-paragraph jy jz iq ka b kb or kd ke kf os kh ki kj ot kl km kn ou kp kq kr ov kt ku kv ij bi translated">迷茫？好了，让我们后退一步，探索JavaScript中的作用域是如何工作的，然后再来看看这个相当神秘的语句。</p><p id="6abd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个函数被<strong class="ka ir">定义</strong>时，<strong class="ka ir">当前作用域链</strong>被保存，并成为函数的<strong class="ka ir">内部状态的一部分。</strong></p><p id="6305" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在顶层，作用域链仅仅由<strong class="ka ir">全局对象</strong>组成。</p><p id="0b26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，当你定义一个<strong class="ka ir">嵌套函数</strong>时，词法链<strong class="ka ir">也包括包含函数</strong>。这意味着嵌套函数可以访问其包含函数的所有参数和局部变量。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d007" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">function</strong> foo(arg) {<br/>   <strong class="mw ir">function</strong> bar() {<br/>      console.log(`arg: ${arg}`);<br/>   }<br/>   bar();<br/>}</span><span id="3508" class="na lo iq mw b gy nf nc l nd ne">console.log(foo('hello'));  // arg: hello</span></pre><p id="240e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">arg的直接作用域是<strong class="ka ir"> <em class="mq"> foo() </em> </strong>，但是在嵌套作用域<strong class="ka ir"> <em class="mq"> bar() </em> </strong>中也是可以访问的。关于嵌套，<strong class="ka ir"> foo()是外部作用域</strong>而<strong class="ka ir"> bar()是内部作用域</strong>。</p><p id="8f40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过<strong class="ka ir">调用对象，可以以这种方式共享作用域链。</strong></p><h1 id="6f95" class="ln lo iq bd lp lq oj ls lt lu ok lw lx ly ol ma mb mc om me mf mg on mi mj mk bi translated"><strong class="ak">调用对象解释</strong></h1><p id="d3f8" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">当javascript解释器调用一个函数时，它执行以下操作:</p><ol class=""><li id="89f0" class="ng nh iq ka b kb kc kf kg kj ni kn nj kr nk kv nl nm nn no bi translated"><strong class="ka ir">它将作用域设置为定义函数时有效的作用域链。</strong></li><li id="1d38" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">它将一个新对象(称为<strong class="ka ir">调用对象</strong>)添加到作用域链的前面。</li><li id="8692" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">这个对象用一个名为<strong class="ka ir"> <em class="mq">自变量</em> </strong>的属性初始化，该属性引用了函数的<a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">自变量</strong> </a>对象。</li><li id="a973" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">接下来，函数的<strong class="ka ir">命名参数</strong>被添加到调用对象中。</li><li id="bef7" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">函数中声明的任何<strong class="ka ir">局部变量</strong>也在该对象中定义。</li></ol><p id="6fe8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这个调用对象在作用域链的<strong class="ka ir">头</strong>处，所以局部变量、函数参数和自变量对象<strong class="ka ir">都在函数</strong>的作用域内。</p><p id="159f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑在函数<strong class="ka ir"> f </strong>中定义的函数<strong class="ka ir"> g </strong>。当调用<strong class="ka ir"> f </strong>时，作用域链由调用f的<strong class="ka ir">调用对象、</strong>后跟<strong class="ka ir">全局对象组成。</strong></p><p id="8b03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> g </strong>是在<strong class="ka ir"> f </strong>内定义的<strong class="ka ir">，因此范围链被保存为<strong class="ka ir"> g </strong>定义的一部分。</strong></p><p id="64e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当<strong class="ka ir"> g </strong>然后<strong class="ka ir">被调用</strong>时，作用域链包括三个对象:</p><ul class=""><li id="dea0" class="ng nh iq ka b kb kc kf kg kj ni kn nj kr nk kv ow nm nn no bi translated"><strong class="ka ir">自己的调用对象</strong></li><li id="3fe5" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv ow nm nn no bi translated"><strong class="ka ir">f的调用对象</strong></li><li id="9b2e" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv ow nm nn no bi translated"><strong class="ka ir">全球对象</strong></li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="693f" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">function</strong> f(){</span><span id="c3cd" class="na lo iq mw b gy nf nc l nd ne">   /* <strong class="mw ir">my scope chain when invoked consists of </strong><br/>     1) my own call object <br/>     2) the global object */</span><span id="ec1d" class="na lo iq mw b gy nf nc l nd ne"><strong class="mw ir">    function</strong> g(){</span><span id="a8de" class="na lo iq mw b gy nf nc l nd ne">       /* <strong class="mw ir">my</strong> <strong class="mw ir">scope chain when invoked consists of </strong><br/>             1) my own call object <br/>             2) the call object of f when I was defined<br/>             3) the global object */</span><span id="7713" class="na lo iq mw b gy nf nc l nd ne">    }<br/>}</span></pre><p id="566d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果嵌套函数仅在外部函数中使用<strong class="ka ir">，那么对嵌套函数的唯一引用仅在<strong class="ka ir">调用对象</strong>中。然后，当外部函数返回时，嵌套函数引用call对象，call对象引用嵌套函数，但是由于没有对任何一个的其他引用，两个对象都可以用于<strong class="ka ir">垃圾收集</strong>。</strong></p><p id="184b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果你在<strong class="ka ir">全局作用域中引用了嵌套函数，事情就不同了。</strong>在这种情况下，嵌套函数被<strong class="ka ir">导出到其定义的</strong>范围之外。</p><p id="ab65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何在全局范围内设置对嵌套函数的引用？通过使用嵌套函数作为外部函数的<strong class="ka ir">返回值，或者通过将嵌套函数作为某个其他对象</strong>的属性。</p><p id="4786" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，嵌套函数有一个<strong class="ka ir">外部引用</strong>，嵌套函数<strong class="ka ir">保留其对外部函数</strong>的调用对象的引用。</p><p id="4ab6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，<strong class="ka ir">调用那个<strong class="ka ir">的对象</strong>，外部函数<strong class="ka ir">的一个特定调用</strong>继续存在</strong>，并且函数参数和局部变量的名称和值保存到这个对象中。</p><p id="94dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，<em class="mq">闭包</em>是函数和词法环境的组合，函数在词法环境中被<strong class="ka ir">声明为</strong>。<strong class="ka ir">这个环境由闭包创建时在作用域内的所有局部变量组成</strong> <strong class="ka ir">(它的诞生作用域)</strong>。</p><p id="277e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个名字来源于这样一个事实，闭包“封闭”了函数的自由变量。如果变量没有在函数中声明，也就是说，如果它来自“外部”，那么它就是自由的</p><blockquote class="nu"><p id="b333" class="nv nw iq bd nx ny nz oa ob oc od kv dk translated">如果一个函数离开了它的作用域，它会通过它的call对象保持与最初定义时存在的<strong class="ak">作用域链的连接。</strong></p></blockquote><p id="89aa" class="pw-post-body-paragraph jy jz iq ka b kb or kd ke kf os kh ki kj ot kl km kn ou kp kq kr ov kt ku kv ij bi translated">让我们来看一些实际的闭包例子。</p><p id="f25f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">关闭示例1: </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="8544" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">function</strong> createIncrementer(startValue) {<br/>   <strong class="mw ir">return</strong> <strong class="mw ir">function</strong> (step) {<br/>      startValue += step;<br/>      <strong class="mw ir">return</strong> startValue;<br/>   };<br/>}</span></pre><p id="7838" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由<strong class="ka ir"> createIncrementer() </strong>返回的函数不会失去与<strong class="ka ir"> startValue </strong>的连接—变量<strong class="ka ir">为函数提供跨函数调用</strong>持续的状态:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="002f" class="na lo iq mw b gy nb nc l nd ne">const counterA = createIncrementer(5);<br/>const counterB = createIncrementer(10);</span><span id="69f6" class="na lo iq mw b gy nf nc l nd ne">counterA(2);    // 7<br/>counterB(2);    // 12<br/>counterA(7);    // 14<br/>counterB(7);    // 19</span></pre><p id="3850" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，有一个<strong class="ka ir">对嵌套函数的外部引用</strong>，嵌套函数<strong class="ka ir">保留了对外部函数</strong>的调用对象的引用。在这种情况下，外部函数<strong class="ka ir">的那个<strong class="ka ir">的一个特定调用</strong>的调用对象继续存在</strong>，并且函数参数和局部变量的名称和值保存到该对象中。</p><p id="8629" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">关闭示例2: </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a2bc" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">function</strong> makeBrowser() {<br/>   const name = 'Mozilla';<br/>   <strong class="mw ir">function</strong> displayName() {<br/>      console.log(name); <br/>   }<br/>   <strong class="mw ir">return</strong> displayName; <br/>}</span><span id="4496" class="na lo iq mw b gy nf nc l nd ne">const myBrowser = makeBrowser();<br/>myBrowser();  // <em class="mq">'Mozilla'</em></span></pre><p id="c6c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，<strong class="ka ir"> makeBrowser </strong>是对运行<strong class="ka ir"> makeBrowser </strong>时创建的函数<strong class="ka ir"> displayName </strong>的实例的引用。<strong class="ka ir"> displayName </strong>的实例维护了对其词法环境的引用，变量<strong class="ka ir"> name </strong>存在于该环境中。因此，当调用<strong class="ka ir"> makeBrowser </strong>时，变量<strong class="ka ir"> name </strong>仍然可用，并且“Mozilla”被记录到控制台。</p><p id="9af4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">关闭示例3: </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="b468" class="na lo iq mw b gy nb nc l nd ne"><strong class="mw ir">function</strong> makeAdder(x) { <br/>   <strong class="mw ir">return</strong> <strong class="mw ir">function</strong>(y) { <br/>      <strong class="mw ir">return</strong> x + y; <br/>   }; <br/>} <br/>const add5 = makeAdder(5);<br/>const add10 = makeAdder(10);<br/>console.log(add5(2)); // <em class="mq">7</em><br/>console.log(add10(2)); // <em class="mq">12</em></span></pre><p id="c6f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，定义了函数<strong class="ka ir"> makeAdder(x) </strong>，它接受一个参数x，并返回一个新函数。它返回的函数只接受一个参数y，并返回x和y的和。</p><p id="165f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本质上，makeAdder是一个函数工厂——它创建可以向参数添加特定值的函数。这里我们使用我们的函数工厂创建两个新函数——一个给它的参数加5，另一个加10。</p><p id="918f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> add5 </strong>和<strong class="ka ir"> add10 </strong>都是闭包。它们共享相同的函数体定义，但是<strong class="ka ir">存储不同的词法环境</strong>。在add5的词法环境中，x是5，而在add10的词法环境中，x是10。</p><p id="4d60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">关闭示例4: </strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="09f0" class="na lo iq mw b gy nb nc l nd ne">const uniqueId = (<strong class="mw ir">function</strong>() { <br/>   // the call object of this function holds our value</span><span id="6a38" class="na lo iq mw b gy nf nc l nd ne">   let id = 0; // this is the private persistent value</span><span id="0752" class="na lo iq mw b gy nf nc l nd ne">   return <strong class="mw ir">function</strong>(){<br/>      <strong class="mw ir">return</strong> id++; // return and increment<br/>   }</span><span id="fa4c" class="na lo iq mw b gy nf nc l nd ne">})(); // invoke the outer function after defining it</span></pre><p id="8bec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许您想编写一个能够在调用中记住某个值的函数，但是该值不能存储在局部变量中，因为call对象不会在调用中保持不变。</p><p id="0133" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">全局变量可以工作，但是会污染全局名称空间。</p><p id="2139" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们使用一个闭包来创建一个只有你的函数可以访问的持久私有变量。</p><p id="1c9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">外层函数返回一个可以访问持久值的嵌套函数(当嵌套函数被定义时，持久值被锁定在其作用域链中)。</p><p id="4547" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将这个嵌套函数存储在uniqueId变量中。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2799" class="na lo iq mw b gy nb nc l nd ne">let i = uniqueId();  // 0<br/>let j = uniqueId();  // 1<br/>let k = uniqueId();  // 2<br/>let l = uniqueId();  // 3</span></pre><p id="bf03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">闭包是有用的，因为它允许您将一些数据(词法环境)与操作这些数据的函数相关联。</p><p id="f84e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这与面向对象编程有明显的相似之处，在面向对象编程中，对象允许我们将一些数据(对象的属性)与一个或多个方法相关联。</p><p id="4604" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，您可以在任何通常只使用一个方法的地方使用闭包。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="0b20" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">参考</h1><div class="ox oy gp gr oz pa"><a href="https://books.google.co.za/books/about/JavaScript.html?id=2weL0iAfrEMC&amp;printsec=frontcover&amp;source=kp_read_button&amp;redir_esc=y#v=onepage&amp;q&amp;f=false" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">JavaScript:权威指南</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">这第五版是完全修订和扩展，以涵盖JavaScript，因为它是在今天的Web 2.0使用…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">books.google.co.za</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po jw pa"/></div></div></a></div><div class="ox oy gp gr oz pa"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">功能</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">一般来说，函数是一个“子程序”,可以被外部代码调用(或者在…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">developer.mozilla.org</p></div></div><div class="pj l"><div class="pp l pl pm pn pj po jw pa"/></div></div></a></div><p id="bb84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lf" href="http://speakingjs.com/es5/ch16.html" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">http://speakingjs.com/es5/ch16.html</strong></a></p><div class="ox oy gp gr oz pa"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">关闭</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">闭包是函数和声明该函数的词法环境的组合。</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">developer.mozilla.org</p></div></div><div class="pj l"><div class="pq l pl pm pn pj po jw pa"/></div></div></a></div><div class="ox oy gp gr oz pa"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">功能</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">函数构造器创建一个新的函数对象。直接调用构造函数可以创建函数…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">developer.mozilla.org</p></div></div><div class="pj l"><div class="pr l pl pm pn pj po jw pa"/></div></div></a></div></div></div>    
</body>
</html>