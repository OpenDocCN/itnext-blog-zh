<html>
<head>
<title>Why should you write your own API gateway — from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您应该从头开始编写自己的API网关</h1>
<blockquote>原文：<a href="https://itnext.io/why-should-you-write-your-own-api-gateway-from-scratch-378074bfc49e?source=collection_archive---------1-----------------------#2021-06-02">https://itnext.io/why-should-you-write-your-own-api-gateway-from-scratch-378074bfc49e?source=collection_archive---------1-----------------------#2021-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8c545c8d48d8ac9d02f80a11d549dd24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fPuyh2MCUWviykN0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@lailagebhard?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莱拉·格布哈德</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="a979" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">每个拥有微服务的组织都需要控制谁可以在什么条件下访问这些服务。API网关是这个问题不可避免的解决方案。</p><p id="adc0" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">但是，您是否应该使用现有的可配置代理，如<a class="ae kc" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> Envoy </a>、<a class="ae kc" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Ngnix </a>、<a class="ae kc" href="https://github.com/Netflix/zuul" rel="noopener ugc nofollow" target="_blank"> Zuul </a>、<a class="ae kc" href="https://docs.konghq.com/enterprise/" rel="noopener ugc nofollow" target="_blank"> Kong </a>、<a class="ae kc" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> aws API gateway </a>(这个列表还可以继续下去)？这些项目中的每一个都有其优点和缺点，都有自己的配置语言、用户社区、书籍、文档和教程。</p><p id="4b95" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这篇文章中，我认为你不需要，你需要的一切都可以通过几条golang线来实现。</p><p id="33cc" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这是可能的，因为<code class="fe li lj lk ll b">"net/http/httputil"</code>里的好东西。这个包是<code class="fe li lj lk ll b">"net/http"</code>的扩展，包含网络实用程序。</p><p id="faaa" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">其中之一是<code class="fe li lj lk ll b">httputil.ReverseProxy</code>，顾名思义，可以处理透明转发HTTP请求所需的所有网络相关的东西，只需一行代码:<code class="fe li lj lk ll b">Proxy(targetUrl).ServeHTTP(ctx.Writer, ctx.Request)</code></p><p id="4707" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">它可以与任何golang HTTP框架一起工作，如<a class="ae kc" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> <strong class="km ir"> gin </strong> </a>或<a class="ae kc" href="https://github.com/valyala/fasthttp" rel="noopener ugc nofollow" target="_blank"> <strong class="km ir"> fast-http </strong> </a>，现有最快的服务器框架之一。</p><p id="4884" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">反向代理不限于透明的反向代理。它可用于修改拦截的请求及其响应。</p><p id="b077" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">例如，假设一个常见的场景，每个请求都需要:</p><ul class=""><li id="2c21" class="lm ln iq km b kn ko kr ks kv lo kz lp ld lq lh lr ls lt lu bi translated">笨拙的</li><li id="9a45" class="lm ln iq km b kn lv kr lw kv lx kz ly ld lz lh lr ls lt lu bi translated">一个公制发射</li><li id="47c8" class="lm ln iq km b kn lv kr lw kv lx kz ly ld lz lh lr ls lt lu bi translated">根据请求路径中的约定，路由到特定的微服务</li><li id="00ad" class="lm ln iq km b kn lv kr lw kv lx kz ly ld lz lh lr ls lt lu bi translated">已验证(用未加密的用户详细信息设置请求头)</li><li id="681d" class="lm ln iq km b kn lv kr lw kv lx kz ly ld lz lh lr ls lt lu bi translated">经授权的</li><li id="c603" class="lm ln iq km b kn lv kr lw kv lx kz ly ld lz lh lr ls lt lu bi translated">速率受限</li><li id="2d26" class="lm ln iq km b kn lv kr lw kv lx kz ly ld lz lh lr ls lt lu bi translated">在staging env上，如果是500，响应主体需要修改并包含错误消息，以改善开发体验</li><li id="b4e4" class="lm ln iq km b kn lv kr lw kv lx kz ly ld lz lh lr ls lt lu bi translated">在prod env上，它必须包含错误的散列，以便以后在搜索日志时使用。</li></ul><p id="3899" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">配置NGNIX，ZUUL，或者ENVOY做上面的列表可能是可以的，我承认我没有尝试过。但肯定不会是在公园散步，无论上面的代理有多么丰富的功能，它都无法与自定义代码的灵活性相比。</p><p id="dac6" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">下面的例子包含了87行golang，其中除了认证/授权/速率限制部分之外，还包含了上述所有内容，这部分内容不在讨论范围之内，但本质上将作为请求中间件来实现。</p><p id="af92" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们来深究一下，说说有意思的部分。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">完整的api网关示例</figcaption></figure><ul class=""><li id="a215" class="lm ln iq km b kn ko kr ks kv lo kz lp ld lq lh lr ls lt lu bi translated"><code class="fe li lj lk ll b">Target</code>函数返回被寻址微服务的内部k8s地址。例如，对<code class="fe li lj lk ll b">/api/product/frontend/users</code>的请求将变成<code class="fe li lj lk ll b">http://svc.product.frontend.cluster.local:10000/api/users</code>(一个内部k8s DNS)。这里的约定是请求路径包括服务名和服务名称空间，k8s服务名是<code class="fe li lj lk ll b">svc-NAME</code>。</li><li id="c45a" class="lm ln iq km b kn lv kr lw kv lx kz ly ld lz lh lr ls lt lu bi translated"><code class="fe li lj lk ll b">p.ModifyResponse</code>包含修改响应和记录错误的代码，</li><li id="4436" class="lm ln iq km b kn lv kr lw kv lx kz ly ld lz lh lr ls lt lu bi translated"><code class="fe li lj lk ll b">models.FailedToFindProxyTarget.Inc()</code>指标报告</li><li id="621b" class="lm ln iq km b kn lv kr lw kv lx kz ly ld lz lh lr ls lt lu bi translated"><code class="fe li lj lk ll b">Proxy(targetUrl).ServeHTTP(ctx.Writer, ctx.Request)</code> -请求转发(重写)</li></ul><p id="acb3" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">就是这样。如果你想要任何自定义行为，可以在这里介绍。通过一些额外的golang魔法，上述内容还可以作为gRPC和graphql请求的网关。</p><p id="ae37" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">一点也不麻烦，性能稳定，网关可以轻松地扩展到您需要的任意数量的实例，并以无限种方式进行扩展。并且为它的逻辑编写测试根本不需要动脑筋。</p><p id="cbe1" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果这对你有用，请在下面的评论中告诉我。</p><p id="47df" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">干杯！</p></div></div>    
</body>
</html>