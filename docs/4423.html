<html>
<head>
<title>Container from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始的容器</h1>
<blockquote>原文：<a href="https://itnext.io/container-from-scratch-348838574160?source=collection_archive---------0-----------------------#2020-06-27">https://itnext.io/container-from-scratch-348838574160?source=collection_archive---------0-----------------------#2020-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/09494c6ae4bbd682cf9dfd3401dc0453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vTiSw8CmL-iXjEBMBs8GHQ.jpeg"/></div></div></figure><p id="cfa0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文最初发表于:<a class="ae kw" href="https://www.prabhujayakumar.dev/blog/container-from-scratch" rel="noopener ugc nofollow" target="_blank">https://www.prabhujayakumar.dev/blog/container-from-scratch</a></p><p id="516c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我的第一个博客，我想分享我对容器的认识</p><p id="02e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如今，在生产中采用容器来运行企业应用软件已经急剧增加。并且大多数容器部署都在使用docker。Docker成为运行容器化应用程序的事实上的技术。但是docker是建立在什么之上的呢？它是如何将应用程序容器化的？我将在本文中尝试回答这些问题。</p><h1 id="355b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">对集装箱的需求</strong></h1><p id="7782" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在进入容器之前，让我们清楚地了解什么是过程？</p><p id="1850" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个程序开始执行时，就创建了一个进程。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/604a5fcd801ab1b87bd71e9f19c28099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFYSnKuvNIoELkisT0sujQ.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">过程</figcaption></figure><p id="d94d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们怎样才能执行一个程序？执行程序的要求是什么？</p><p id="e90f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个程序需要libs、env和资源才能投入执行，从而创建一个进程。例如，要执行一个python脚本，我们需要python二进制和一些python模块、python环境和资源，如cpu、内存、磁盘。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/ed8a0b61e3a8620cafaef90f3778c5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DpCUm9tkbmFkPhtZCxuLdQ.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">流程执行要求</figcaption></figure><p id="f380" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑一个Web应用程序，它由许多运行在不同语言和不同版本上的微服务组成。这些微服务不过是后端的一个流程。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/757b9322b79094e8013ce1af996235d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnMfsjYXWS_sA04S3bLIxA.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">Web应用程序的微服务</figcaption></figure><p id="9750" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">话虽如此，想象一下在物理机器上运行这些服务…</p><p id="d3f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那不是一项容易的任务，仅仅是可能的</p><p id="b5bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是为什么呢？在一台物理机上运行同一个web应用程序的所有这些服务的挑战是什么？</p><p id="e2bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是，假设应用程序有两个使用不同Java版本的Java服务，那么JAVA_HOME的值是多少？单个物理机中不能有2个JAVA_HOME集。</p><p id="f571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们在一台机器上运行N个服务，我们必须为每个服务分配端口，这样就不会发生端口冲突。想想运行2个版本的postgres，5432端口上的pg10和5433端口上的pg9.6。所以所有的服务都应该知道它运行的端口。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/4dce9d09bad8148b4a21a2cb5f137872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6TZ2xRVmVuWJqDu_9KRgg.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">在主机中运行web应用的所有微服务</figcaption></figure><p id="d80e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用一个词来概括上面提到的挑战，没有孤立。</p><p id="2e7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于有不同版本的libs，因此需要不同的env，每个服务都需要相互隔离。</p><p id="f298" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了隔离进程，人们开始使用虚拟机。让我们看看虚拟机是如何解决这个问题的。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/91629bcd5f50f3d457d821f607bf4259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-An2efdRGkT5_g1ub0Xxg.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">虚拟计算机</figcaption></figure><p id="8a79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虚拟机是由运行在主机上的虚拟机管理程序创建的独立的来宾操作系统。</p><p id="1169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种独立的客户操作系统有助于实现隔离的库、环境和资源。</p><p id="64b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在这种情况下使用虚拟机存在一些挑战。</p><p id="6aac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑通过创建所需的虚拟机(1个虚拟机对应1个服务)，在一台物理机上运行上述所有服务(流程)。</p><p id="258f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以清楚地看到运行10多台虚拟机的物理机的性能开销。原因是，每个虚拟机中的客户操作系统都有自己的内存管理、网络管理等等。</p><p id="543d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不仅如此，在使用虚拟机时，适当的资源利用成为一项艰巨的任务。</p><p id="445b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虚拟机方法中这种开销背后的主要原因是，虚拟机管理程序通过为每个虚拟机创建来宾操作系统来虚拟化硬件。</p><p id="3c39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想要的是能够隔离库、环境和资源而不必创建单独的操作系统的东西。为什么我们不能使用主机操作系统本身的资源管理，而不是虚拟化硬件，这会导致开销？</p><p id="b94b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，我们有一种叫做“容器”的东西，它能够为我们做同样的事情。</p><p id="e27b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">容器只不过是一个通过使用一些linux技术(如namespace和cgroup)实现的独立进程。</p><p id="98d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们深入容器，它们如何为进程提供隔离，什么是名称空间和cgroup，以及它们是如何使用的。</p><p id="7f26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">容器是运行在主机上由名称空间隔离的一组进程。</p><p id="5c37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它提供操作系统级虚拟化。因此，我们可以称之为“轻量级虚拟机”</p><p id="5680" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在对什么是容器有了一个基本的了解。下一步是我们如何创造它？我知道我们中的许多人使用docker运行命令创建容器。但是，这是唯一的选择吗？没有，像lxc，podman等其他工具很少。如何使用这些工具创建容器？后端流程是什么？</p><p id="4b87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解这一点，让我们看看如何使用linux技术(如namespace和cgroup)从头开始创建一个容器。</p><h1 id="e3b8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">戈朗的简易集装箱</strong></h1><p id="4dec" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们创建一个简单的go程序，它将command作为参数，并通过创建一个新进程来执行该命令。假设这个围棋程序是一个docker。要在docker中执行命令，我们将使用“docker run”命令，同样，这里我们使用“go run container.go run”</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="78a9" class="ms ky iq mo b gy mt mu l mv mw">package main</span><span id="c1db" class="ms ky iq mo b gy mx mu l mv mw">import (</span><span id="d94b" class="ms ky iq mo b gy mx mu l mv mw">  "fmt"</span><span id="a3af" class="ms ky iq mo b gy mx mu l mv mw">  "os"</span><span id="39c2" class="ms ky iq mo b gy mx mu l mv mw">  "os/exec"</span><span id="da67" class="ms ky iq mo b gy mx mu l mv mw">)</span><span id="1a52" class="ms ky iq mo b gy mx mu l mv mw">// go run container.go run &lt;cmd&gt; &lt;args&gt;</span><span id="05db" class="ms ky iq mo b gy mx mu l mv mw">// docker run &lt;cmd&gt; &lt;args&gt;</span><span id="e683" class="ms ky iq mo b gy mx mu l mv mw">func main() {</span><span id="cb86" class="ms ky iq mo b gy mx mu l mv mw">  switch os.Args[1] {</span><span id="04a7" class="ms ky iq mo b gy mx mu l mv mw">    case "run":</span><span id="b12f" class="ms ky iq mo b gy mx mu l mv mw">      run()</span><span id="c5bf" class="ms ky iq mo b gy mx mu l mv mw">    default:</span><span id="cb36" class="ms ky iq mo b gy mx mu l mv mw">      panic("invalid command!!")</span><span id="fc64" class="ms ky iq mo b gy mx mu l mv mw">  }</span><span id="d1e9" class="ms ky iq mo b gy mx mu l mv mw">}</span><span id="c8ee" class="ms ky iq mo b gy mx mu l mv mw">func run() {</span><span id="319f" class="ms ky iq mo b gy mx mu l mv mw">  fmt.Printf("Running %v as PID %d \n", os.Args[2:], os.Getpid())</span><span id="a8f1" class="ms ky iq mo b gy mx mu l mv mw">  cmd := exec.Command(os.Args[2], os.Args[3:]...)\</span><span id="8c56" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdin = os.Stdin</span><span id="4e32" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdout = os.Stdout</span><span id="6d3d" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stderr = os.Stderr</span><span id="4aa6" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Run()</span><span id="05b6" class="ms ky iq mo b gy mx mu l mv mw">}</span></pre><p id="81f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的程序将给定的参数作为命令执行。如下图所示，“go run container run echo hello container”执行命令“echo hello container”。它通过创建一个可视为容器的新进程来执行命令。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/dd0fbb7f444d652f4d3b17be45544785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lfxNTarOwADc2Yp7Fwp-0A.gif"/></div></div></figure><p id="9bf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，让我们使用`/bin/bash '创建一个进程，并为该容器分配一个专用的主机名。但是更改容器内的主机名，也会更改主机的主机名。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/310d17cd4f8e3d28c078a2b3307a1a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wxP33BLWBDwYsxTCF8kE-Q.gif"/></div></div></figure><p id="9bf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发生这种情况是因为该容器没有隔离主机名。因此，为了创建主机名的隔离，我们可以为容器分配新的UTS名称空间。在golang中，我们可以通过使用“syscall”包来实现这一点。</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="4a2c" class="ms ky iq mo b gy mt mu l mv mw">func run() {</span><span id="d991" class="ms ky iq mo b gy mx mu l mv mw">  fmt.Printf(“Running %v as PID %d \n”, os.Args[2:], os.Getpid())</span><span id="1425" class="ms ky iq mo b gy mx mu l mv mw">  cmd := exec.Command(os.Args[2], os.Args[3:]…)</span><span id="3949" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdin = os.Stdin</span><span id="e0ef" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdout = os.Stdout</span><span id="93fa" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stderr = os.Stderr</span><span id="6326" class="ms ky iq mo b gy mx mu l mv mw">  cmd.SysProcAttr = &amp;syscall.SysProcAttr{</span><span id="0023" class="ms ky iq mo b gy mx mu l mv mw">    Cloneflags: syscall.CLONE_NEWUTS,</span><span id="4f1d" class="ms ky iq mo b gy mx mu l mv mw">  }</span><span id="714e" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Run()</span><span id="fa96" class="ms ky iq mo b gy mx mu l mv mw">}</span></pre><p id="8850" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果您更改容器的主机名，这不会影响主机的主机名，因为容器有自己的UTS名称空间。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/1f868892093da9718b74e1746bee450f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XNWE6SrfSUvpR6Hcs30uyA.gif"/></div></div></figure><p id="fc3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我想从golang程序中使用syscall ` syscall . set hostname([]byte(" container-demo "))`将主机名自动分配给容器。但是，在上面的程序中，我可以把这一行放在哪里呢？进程是在' cmd.Run()'上创建的，并在同一行上退出。因此，让我们派生一个子进程，并在其中设置主机名。</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="ed08" class="ms ky iq mo b gy mt mu l mv mw">package main</span><span id="cfbe" class="ms ky iq mo b gy mx mu l mv mw">import (</span><span id="48be" class="ms ky iq mo b gy mx mu l mv mw">  “fmt”</span><span id="5561" class="ms ky iq mo b gy mx mu l mv mw">  “os”</span><span id="758a" class="ms ky iq mo b gy mx mu l mv mw">  “os/exec”</span><span id="c243" class="ms ky iq mo b gy mx mu l mv mw">  “syscall”</span><span id="db9e" class="ms ky iq mo b gy mx mu l mv mw">)</span><span id="879a" class="ms ky iq mo b gy mx mu l mv mw">// go run container.go run &lt;cmd&gt; &lt;args&gt;</span><span id="b401" class="ms ky iq mo b gy mx mu l mv mw">// docker run &lt;cmd&gt; &lt;args&gt;</span><span id="72d5" class="ms ky iq mo b gy mx mu l mv mw">func main() {</span><span id="4f4c" class="ms ky iq mo b gy mx mu l mv mw">  switch os.Args[1] {</span><span id="9bbb" class="ms ky iq mo b gy mx mu l mv mw">    case “run”:</span><span id="c093" class="ms ky iq mo b gy mx mu l mv mw">      run()</span><span id="b7bf" class="ms ky iq mo b gy mx mu l mv mw">    case “child”:</span><span id="7760" class="ms ky iq mo b gy mx mu l mv mw">      child()</span><span id="6b2b" class="ms ky iq mo b gy mx mu l mv mw">    default:</span><span id="0589" class="ms ky iq mo b gy mx mu l mv mw">      panic(“invalid command!!”)</span><span id="390f" class="ms ky iq mo b gy mx mu l mv mw">  }</span><span id="7578" class="ms ky iq mo b gy mx mu l mv mw">}</span><span id="f0eb" class="ms ky iq mo b gy mx mu l mv mw">func run() {</span><span id="94e0" class="ms ky iq mo b gy mx mu l mv mw">  fmt.Printf(“Running %v as PID %d \n”, os.Args[2:], os.Getpid())</span><span id="e43d" class="ms ky iq mo b gy mx mu l mv mw">  args := append([]string{“child”}, os.Args[2:]…)</span><span id="bfcc" class="ms ky iq mo b gy mx mu l mv mw">  cmd := exec.Command(“/proc/self/exe”, args…)</span><span id="f592" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdin = os.Stdin</span><span id="6f44" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdout = os.Stdout</span><span id="505c" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stderr = os.Stderr</span><span id="d2d2" class="ms ky iq mo b gy mx mu l mv mw">  cmd.SysProcAttr = &amp;syscall.SysProcAttr{</span><span id="230f" class="ms ky iq mo b gy mx mu l mv mw">    Cloneflags: syscall.CLONE_NEWUTS,</span><span id="87f2" class="ms ky iq mo b gy mx mu l mv mw">  }</span><span id="24fb" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Run()</span><span id="355c" class="ms ky iq mo b gy mx mu l mv mw">}</span><span id="fe58" class="ms ky iq mo b gy mx mu l mv mw">func child() {</span><span id="9879" class="ms ky iq mo b gy mx mu l mv mw">  fmt.Printf(“Running %v as PID %d \n”, os.Args[2:], os.Getpid())</span><span id="d68e" class="ms ky iq mo b gy mx mu l mv mw">  syscall.Sethostname([]byte(“container-demo”))</span><span id="04cc" class="ms ky iq mo b gy mx mu l mv mw">  cmd := exec.Command(os.Args[2], os.Args[3:]…)</span><span id="b5ae" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdin = os.Stdin</span><span id="2b21" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdout = os.Stdout</span><span id="fe41" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stderr = os.Stderr</span><span id="2ae7" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Run()</span><span id="451e" class="ms ky iq mo b gy mx mu l mv mw">}</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/ccc1bd3ccdc88fc95c57e52ba325cab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kYIkVGi2c05zfvxfrkZeXg.gif"/></div></div></figure><p id="1e1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的另一个问题是，容器能够看到主机上运行的所有进程。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/b17c0c10c8083009a951905287a83f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bPFX5h5bF8NI_QHKz59feQ.gif"/></div></div></figure><p id="56f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">容器应该只能看到在该容器中运行的进程，这可以通过使用PID名称空间来实现。</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="b3c7" class="ms ky iq mo b gy mt mu l mv mw">cmd.SysProcAttr = &amp;syscall.SysProcAttr{</span><span id="cdbd" class="ms ky iq mo b gy mx mu l mv mw">  Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID,</span><span id="a8f6" class="ms ky iq mo b gy mx mu l mv mw">}</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/503b0691765da2482378b461d6002cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xHxnl38JbQzr6CTbIj-i-w.gif"/></div></div></figure><p id="f6fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使这样，容器也能够看到主机的进程。原因是`/proc `;容器使用与主机相同的根文件系统。因此，一个不同的根文件系统将被用于容器，并将`/proc '装入其中。</p><p id="6daa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">`/containerfs `目录包含操作系统的文件，该操作系统几乎没有二进制文件，如python和核心linux实用程序。因此，将这个目录挂载为container的根文件系统使得它对于linux实用程序来说是自给自足的，而对于二进制文件来说不依赖于主机。它还为此容器提供了单独的环境。</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="4203" class="ms ky iq mo b gy mt mu l mv mw">func child() {</span><span id="d34a" class="ms ky iq mo b gy mx mu l mv mw">  fmt.Printf(“Running %v as PID %d \n”, os.Args[2:], os.Getpid())</span><span id="d514" class="ms ky iq mo b gy mx mu l mv mw">  syscall.Sethostname([]byte(“container-demo”))</span><span id="94ee" class="ms ky iq mo b gy mx mu l mv mw">  cmd := exec.Command(os.Args[2], os.Args[3:]…)</span><span id="8f7d" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdin = os.Stdin</span><span id="d3aa" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdout = os.Stdout</span><span id="9ca0" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stderr = os.Stderr</span><span id="2fd5" class="ms ky iq mo b gy mx mu l mv mw">  syscall.Chroot(“/containerfs”)</span><span id="5afa" class="ms ky iq mo b gy mx mu l mv mw">  os.Chdir(“/”)</span><span id="edd5" class="ms ky iq mo b gy mx mu l mv mw">  syscall.Mount(“proc”, “proc”, “proc”, 0, “”)</span><span id="06ab" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Run()</span><span id="cc1b" class="ms ky iq mo b gy mx mu l mv mw">}</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/e153cd0461d46bfbf6619e01e21381c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*knUwXYv5SbLhRdwpCt795g.gif"/></div></div></figure><p id="0ca9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们已经使用PID名称空间实现了进程id隔离。类似地，我们可以使用网络和用户名称空间提供网络和用户的隔离。</p><p id="5e7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，名称空间是关于你能在容器中看到什么。它允许我们创建系统的受限视图，如进程树、网络接口、挂载和用户。以下是可用于提供隔离的各种名称空间:</p><ul class=""><li id="56e0" class="na nb iq ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">UTS(Unix分时)名称空间:主机名和域名</li><li id="5a12" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">PID命名空间:进程号</li><li id="f61c" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">挂载名称空间:挂载点</li><li id="2085" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">IPC命名空间:进程间通信资源</li><li id="ef15" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">网络命名空间:网络资源</li><li id="7187" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">用户名称空间:用户和组ID号</li></ul><p id="e3c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们看看资源管理在容器中是如何工作的。我有一个python脚本`<em class="no"> hungry.py` </em>,它每0.5秒消耗10mb的内存。使用container.go程序运行此python脚本，允许容器进程消耗主机中的所有可用内存。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/448cd48737bead5b001b209ff2288a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*W9u5KYtZFSU_y1kgxsm7NQ.gif"/></div></div></figure><p id="2b7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了管理内存、cpu、磁盘块等资源，我们可以使用cgroups。</p><p id="ea13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个系统在“/sys/fs/cgroup/”中都有控制组，内存使用“/sys/fs/cgroup/memory”中的默认值。您可以看到“/ sys/fs/cgroup/memory/memory . limit _ in _ bytes”中的值非常大，允许一个进程消耗主机中尽可能多的可用内存。</p><p id="dbf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个go程序中，我创建了一个控制组“prabhu ”,并给定了100mb的最大内存限制，同时禁用了交换内存。并且还将容器的进程id分配给c group‘prabhu’的任务。</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="2d2f" class="ms ky iq mo b gy mt mu l mv mw">func child() {</span><span id="f815" class="ms ky iq mo b gy mx mu l mv mw">  fmt.Printf(“Running %v as PID %d \n”, os.Args[2:], os.Getpid())</span><span id="8806" class="ms ky iq mo b gy mx mu l mv mw">  syscall.Sethostname([]byte(“container-demo”))</span><span id="2799" class="ms ky iq mo b gy mx mu l mv mw">  controlgroup()</span><span id="12ed" class="ms ky iq mo b gy mx mu l mv mw">  cmd := exec.Command(os.Args[2], os.Args[3:]…)</span><span id="2bc4" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdin = os.Stdin</span><span id="ac5d" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stdout = os.Stdout</span><span id="2234" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Stderr = os.Stderr</span><span id="2e57" class="ms ky iq mo b gy mx mu l mv mw">  syscall.Chroot(“/containerfs”)</span><span id="87c6" class="ms ky iq mo b gy mx mu l mv mw">  os.Chdir(“/”)</span><span id="f39a" class="ms ky iq mo b gy mx mu l mv mw">  syscall.Mount(“proc”, “proc”, “proc”, 0, “”)</span><span id="5d5c" class="ms ky iq mo b gy mx mu l mv mw">  cmd.Run()</span><span id="2356" class="ms ky iq mo b gy mx mu l mv mw">}</span><span id="0a18" class="ms ky iq mo b gy mx mu l mv mw">func controlgroup() {</span><span id="df93" class="ms ky iq mo b gy mx mu l mv mw">  cgPath := filepath.Join(“/sys/fs/cgroup/memory”, “prabhu”)</span><span id="7ab3" class="ms ky iq mo b gy mx mu l mv mw">  os.Mkdir(cgPath, 0755)</span><span id="e315" class="ms ky iq mo b gy mx mu l mv mw">  ioutil.WriteFile(filepath.Join(cgPath, “memory.limit_in_bytes”), []byte(“100000000”), 0700)</span><span id="b456" class="ms ky iq mo b gy mx mu l mv mw">  ioutil.WriteFile(filepath.Join(cgPath, “memory.swappiness”), []byte(“0”), 0700)</span><span id="4a08" class="ms ky iq mo b gy mx mu l mv mw">  ioutil.WriteFile(filepath.Join(cgPath, “tasks”), []byte(strconv.Itoa(os.Getpid())), 0700)</span><span id="c5a3" class="ms ky iq mo b gy mx mu l mv mw">}</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/b6596103bf01c17faff7ff894be772ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lADI5Zgm4XTYXQhZqSOH3Q.gif"/></div></div></figure><p id="92cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为分配给容器进程的cgroup `prabhu '只允许100mb的内存，所以一旦python进程试图超过这个内存限制，它就会被杀死。</p><p id="0e44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用cgroups，系统管理员获得了对分配、区分优先级、拒绝、管理和监视系统资源的细粒度控制。硬件资源可以在任务和用户之间适当划分，从而提高整体效率。因此我们可以在容器生态系统中使用cgroups进行资源管理。</p><p id="1798" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我创建了一个简单的容器，使用相应的名称空间隔离主机名、mount(`/proc `)和进程树，还使用cgroups对容器进行了内存管理。</p><h1 id="f8fe" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">结论</strong></h1><p id="89af" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">容器只是运行在单个主机上的隔离的进程组，这种隔离利用了Linux内核中内置的几种底层技术，如名称空间、cgroups和chroots。</p><p id="fb06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是docker如何将应用程序与许多其他功能(如根据Docker映像存储和传输文件)封装在一起。</p><p id="e331" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker并不是帮助运行容器的唯一技术。还有其他选项，如RedHat的Podman，CoreOS的LXC Linux Containers和rkt(项目现已关闭)。</p><p id="fd78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">灵感来自<a class="ae kw" href="https://www.youtube.com/watch?v=Utf-A4rODH8" rel="noopener ugc nofollow" target="_blank">在围棋中从零开始建造一个容器——利兹·赖斯</a></p></div></div>    
</body>
</html>