<html>
<head>
<title>Discussing Backend For Front-end</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">讨论前端的后端</h1>
<blockquote>原文：<a href="https://itnext.io/backend-for-front-end-66d62319f0ae?source=collection_archive---------3-----------------------#2022-07-26">https://itnext.io/backend-for-front-end-66d62319f0ae?source=collection_archive---------3-----------------------#2022-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6978658db60996e144794c706cfa0e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t12f2ksV4PJNNV21r8zoqQ.jpeg"/></div></div></figure><p id="55dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去，应用程序很简单。浏览器向webapp端点发送了请求；后者从数据库获取数据并返回响应。</p><p id="b3ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">移动客户端的兴起以及与其他应用程序的集成打破了这种简单性。我想在这篇文章中讨论一个解决复杂性的方法。</p><h1 id="3b5f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">系统架构日益增加的复杂性</h1><p id="1ab3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们首先对上面的简单架构进行建模。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/d5ed854aff590c9f64664ea6b46c8dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nplphhxf0F2w0dR1.png"/></div></div></figure><p id="3362" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">移动客户端改变了这种方式。移动客户端的显示区域更小:平板电脑的显示区域更小，手机的显示区域更小。</p><p id="d8fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个可能的解决方案是返回所有数据，让每个客户端过滤掉不必要的数据。不幸的是，电话客户端的带宽也很差。不是每部手机都有5G功能。即使是这种情况，如果它位于偏僻的地方，连接点只提供H+,也没有用。</p><p id="7b3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，过度提取不是一个选项。每个客户端需要不同的数据子集。借助monoliths，可以根据每个客户端提供多个端点。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/f613864e56e2a713ec522b51f329a5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I6PH6XauYtR2sgNT.png"/></div></div></figure><p id="fc87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">人们可以在最前面设计一个特定层的web应用程序。这种层检测发出请求的客户端，并过滤掉响应中不相关的数据。web应用程序中的过量提取不是问题。</p><p id="450f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如今，微服务风靡一时。每个人和他们的邻居都想实现微服务架构。</p><p id="cb17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微服务的背后是双披萨团队的理念。每个团队都是独立的，负责单个微服务或单个前端应用。为了避免开发工作之间的耦合，每个微服务团队都发布其API合同，并非常小心地处理变更。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/659ecd32753cc2eb0338cef0d9cdc4be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t6xbbeusPE4KpfvT.png"/></div></div></figure><p id="47b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个微服务都需要为每种类型的客户端提供严格必要的数据，以避免上述的过度获取问题。对于少量的微服务，让每个微服务根据客户端过滤数据是不方便的；人数众多的话，这是不可能的。<em class="me">因此</em>，微服务数量和不同客户端数量之间的笛卡尔因子使得每个微服务上的专用数据端点的成本呈指数级增长。</p><h1 id="103e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">解决方案:后端对前端</h1><p id="e05b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">BFF背后的想法是将逻辑从每个微服务移动到一个专用的可部署端点。后者负责:</p><ul class=""><li id="c9ce" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">从每个所需的微服务中获取数据</li><li id="4a03" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">提取相关部分</li><li id="c12e" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">聚集它们</li><li id="afe8" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">最后以与特定客户端相关的格式返回它们</li></ul><p id="4471" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同一个团队开发了客户端<strong class="ka ir">和</strong>及其关联的BFF。BFF提供了与微服务相同的权衡:通过增加系统复杂性来提高开发速度。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/3487bbc2592f412d9a3b32e8bcaf09c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NCstwfRRZASa0mt_.png"/></div></div></figure><h1 id="b87a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">独立部署单元与API网关</h1><p id="dddf" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">关于BFF的文献暗示了专门的部署单位，如上图所示。有些帖子，像这个<a class="ae mt" href="https://www.manuelkruisz.com/blog/posts/api-gateway-vs-bff" rel="noopener ugc nofollow" target="_blank"> one </a>，用API网关反对BFF。但是概念图不应该与部署图一一对应。</p><p id="7dda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像在许多领域一样，人们应该更多地关注事物的组织方面，而不是技术方面。在这种情况下，最关键的一点是负责前端的团队也要对BFF负责。无论是单独的部署单元还是API网关配置的一部分，都是实现细节。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/dce88659855c187c7248ce85149516ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j0zB8iRxk519AJYy.png"/></div></div></figure><p id="4d67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，使用Apache APISIX，每个团队可以将他们的BFF代码作为一个单独的插件独立部署。</p><h1 id="16ab" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">性能考虑因素</h1><p id="e231" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">对于独石，情况如下:</p><ul class=""><li id="2c68" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">从客户端到monolith的请求需要一个特定的时间<em class="me"> T </em>。它是通过互联网的，<em class="me"> T </em>大概就是长。</li><li id="192a" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">与<em class="me"> T </em>相比，对数据库的不同内部调用可以忽略不计。</li></ul><p id="f721" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦迁移到微服务，客户端需要依次调用每个微服务。因此，对于顺序调用，时间变为<em class="me">σ(T1，T2，Ti，Tn) </em>。因为这是不可接受的，所以客户端通常使用并行调用。时间变成<em class="me"> max(T1，T2，Ti，Tn) </em>。注意，即使这样，客户端也需要执行<em class="me"> n </em>个请求。</p><p id="9a2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在BFF案例中，我们回到一个请求，在<em class="me"> T </em>时间内，无论实现如何。与整体相比，BFF对微服务有额外的请求<code class="fe mu mv mw mx b">t1</code>、<code class="fe mu mv mw mx b">t2</code>、<code class="fe mu mv mw mx b">ti</code>、<code class="fe mu mv mw mx b">tn</code>，但它们可能位于一起。因此，总的时间会比一整块长，但由于每个<code class="fe mu mv mw mx b">t</code>比<code class="fe mu mv mw mx b">T</code>短得多，它不会对用户体验产生太大影响。</p><h1 id="2201" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="8336" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">你可能不应该实现微服务。如果你这样做，微服务不应该返回全部数据，让客户端负责清理它们。因此，微服务需要返回所需的确切数据，这取决于客户端。它在微服务和它的客户端之间引入了强耦合。</p><p id="0221" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你想去掉这个耦合。为了实现这一点，后端对前端的方法将清理逻辑从每个服务提取到一个专用的组件中，该组件也负责聚合数据。<strong class="ka ir">每个客户团队还负责他们专用的BFF </strong>:当客户改变其数据需求时，团队可以部署适应新需求的新BFF版本。</p><p id="c9f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">BFF是一个概念性的解决方案。没有什么要求提取/清理/聚集逻辑必须位于特定的位置。它可以是专用的部署单元，也可以是API网关中的插件。</p><p id="f281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在以后的文章中，我将演示这篇文章中描述的不同步骤。</p><p id="372a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="bd8b" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated"><a class="ae mt" href="https://samnewman.io/patterns/architectural/bff/" rel="noopener ugc nofollow" target="_blank">模式:后端对前端</a></li><li id="81e7" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><a class="ae mt" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern" rel="noopener ugc nofollow" target="_blank">API网关模式与客户端到微服务的直接通信</a></li><li id="8f1c" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><a class="ae mt" href="https://www.manuelkruisz.com/blog/posts/api-gateway-vs-bff" rel="noopener ugc nofollow" target="_blank"> API网关对前端对后端</a></li></ul></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="7f1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="me">原载于</em> <a class="ae mt" href="https://blog.frankel.ch/backend-for-frontend/" rel="noopener ugc nofollow" target="_blank"> <em class="me">一个Java极客</em></a><em class="me">2022年7月23日</em></p></div></div>    
</body>
</html>