<html>
<head>
<title>Best Practices in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度的最佳实践</h1>
<blockquote>原文：<a href="https://itnext.io/best-practices-in-angular-a8926fa02ae2?source=collection_archive---------0-----------------------#2018-05-29">https://itnext.io/best-practices-in-angular-a8926fa02ae2?source=collection_archive---------0-----------------------#2018-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="488c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个简单的介绍，介绍了可以应用到Angular项目中的最佳实践。请注意，这些最佳实践可以应用于其他语言，但是我们在本文中的重点将是TypeScript。</p><p id="ccaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是最佳实践和可读代码？这不是一门科学，我的观点可能与你的不同。本文的目的是为您提供信息和一些提示，让您在每种情况下决定最佳方法。这些建议从会议、同事和客户那里得到了很多好的反馈。因此，我希望我能帮助你。</p><p id="132b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先说一个你要真心实意回答的问题。你的代码审查是这样的吗？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/7ce8a6b64c2875d58151968db10d34b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*08K7rvDDBm50xZqMt0P-9A.jpeg"/></div></figure><p id="c930" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果是这样，你如何使你的代码更容易阅读？</p><p id="1971" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单！你只需要遵循这篇文章给你的一些建议。再说一次，这是我的工作方式，我热爱它。你可以有不同于我的观点，并且完全有效。所以，让我们从这次开始。😊</p><h1 id="70e5" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">角度CLI</h1><p id="ee73" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><a class="ae lw" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Angular CLI </strong> </a>是构建Angular应用程序的最佳方式。要进行全局安装，请运行以下命令:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi lx"><img src="../Images/4f29f3f7bc97f09cb5483d17ffaf4302.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*IiOfC0KtQYzoRNhwNkKbNQ.jpeg"/></div></div></figure><p id="2997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CLI有脚手架(也称为schematics)工具，用于为您创建新项目和生成新代码。然而，这不是主要的好处。CLI的主要好处是它自动化了使用<code class="fe mc md me mf b">ng serve</code>进行实时开发的构建管道，以及使用<code class="fe mc md me mf b">ng build -prod</code>下载到浏览器的生产代码。</p><h1 id="9bbf" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">升力原理</h1><p id="80e6" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">让我们来看看电梯的原理是什么。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/fcbe8a9b646c8b447cadada870348dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*FM25cOAVUScwyKtfmXCbYQ.jpeg"/></div></figure><p id="dc08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个原则帮助你快速找到代码。所以，如果你不使用这个原则，问问你自己:为了构建一个特征，你能多快地打开和处理你需要的所有文件？我的建议是:尊重并使用电梯。</p><h2 id="c53a" class="mh ku iq bd kv mi mj dn kz mk ml dp ld jy mm mn lh kc mo mp ll kg mq mr lp ms bi translated"><strong class="ak">有意义的名字</strong></h2><p id="e052" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">给方法、变量和参数起一个好名字是非常重要的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/685d14122b755cfafc65365bad325c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*6OAFz73zB7Zy8l2yNIQ2NA.jpeg"/></div></figure><p id="63d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个代码示例表明很难阅读和理解这个方法的行为。但是如果你看下一个例子，你会发现它更简单。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/3630684cc9cd1fdf9d9363d80ec1f89a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*LE-SMqdoKOTKv85GnaX8Iw.jpeg"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h2 id="305d" class="mh ku iq bd kv mi mj dn kz mk ml dp ld jy mm mn lh kc mo mp ll kg mq mr lp ms bi translated"><strong class="ak"> 5秒法则</strong></h2><p id="0284" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">如果你不能在5秒钟内理解，你可能需要重构。放松，我知道你在想我疯了，但我说的5秒是一个比喻。目标是理解你的代码需要容易被每个人获得。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h2 id="be12" class="mh ku iq bd kv mi mj dn kz mk ml dp ld jy mm mn lh kc mo mp ll kg mq mr lp ms bi translated"><strong class="ak">可读性组织</strong></h2><ul class=""><li id="7a81" class="nc nd iq jp b jq lr ju ls jy ne kc nf kg ng kk nh ni nj nk bi translated">最重要的东西先放。</li><li id="0019" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated">后跟方法的属性。</li><li id="4b78" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated">分组排序。</li><li id="5ed0" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated">一致的命名和拼写很重要。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/dd09dd8c50b49e6e6813358e7792d6bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*kSPriwF-mQQRyaF3V2layQ.jpeg"/></div></figure><ul class=""><li id="69d1" class="nc nd iq jp b jq jr ju jv jy nr kc ns kg nt kk nh ni nj nk bi translated"><strong class="jp ir">每个文件一个项目<br/> → </strong>一个文件必须只有一个组件，对于服务或指令也是如此。</li><li id="3c85" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><strong class="jp ir">单一主体责任<br/> → </strong>单一类或模块应该只有一个单一责任。</li><li id="9505" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><strong class="jp ir">符号命名<br/> → </strong>属性和方法必须是camel case(如currentUser)。<br/> →类(组件、服务、指令……)必须大写，称为Pascal case(如UserComponent)。<br/> →组件和服务应在名称上有各自的后缀。</li></ul><blockquote class="nu nv nw"><p id="48de" class="jn jo nx jp b jq jr js jt ju jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj kk ij bi translated"><em class="iq">用户组件</em></p><p id="1169" class="jn jo nx jp b jq jr js jt ju jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj kk ij bi translated"><em class="iq">用户服务</em></p></blockquote><p id="b6e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">→进口</p><blockquote class="nu nv nw"><p id="4508" class="jn jo nx jp b jq jr js jt ju jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj kk ij bi translated"><em class="iq">外部进口优先</em></p><p id="fe0d" class="jn jo nx jp b jq jr js jt ju jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj kk ij bi translated"><em class="iq">在从自己的应用程序导入文件之前给一个空行</em></p><p id="dd9f" class="jn jo nx jp b jq jr js jt ju jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj kk ij bi translated"><em class="iq">这为我们提供了一种识别外部文件和应用程序文件的简单方法</em></p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ob"><img src="../Images/e52ce788d4828803d89c0cb7ace3322f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQiZ0OojCeL6nGWoKEAj3g.jpeg"/></div></div></figure><ul class=""><li id="f8ef" class="nc nd iq jp b jq jr ju jv jy nr kc ns kg nt kk nh ni nj nk bi translated"><strong class="jp ir">小功能<br/> → </strong>小功能更好读，更快理解用途。如果你的函数超过10行，你需要问问自己，把它分成更小的函数是否更好。这可能很难做到，但不幸的是，在现实世界中，我们看到许多巨大的函数，由于其大小和复杂性而难以阅读。在我看来，这是每个人都应该遵循的重要惯例。</li></ul><h1 id="3826" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">首先通过代码提供清晰度</strong></h1><ul class=""><li id="905e" class="nc nd iq jp b jq lr ju ls jy ne kc nf kg ng kk nh ni nj nk bi translated"><strong class="jp ir">自描述代码</strong></li><li id="e775" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><strong class="jp ir">用常量替换魔法字符串(代码重用)</strong></li><li id="3654" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><strong class="jp ir">用代码解释，不要用注释</strong></li><li id="1718" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><strong class="jp ir">注释必须可读并可维护</strong></li><li id="04a0" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><strong class="jp ir">避免注释:<br/> → </strong>解释代码“做什么”。<br/> →过时不正确(错误的评论比没有评论更糟糕)。<br/> →取而代之，拥有一个名副其实的函数。<br/> →代码从不说谎，评论有时会。</li><li id="41f1" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><strong class="jp ir">在下列情况下使用注释:<br/> → </strong>解释你为什么这样做。<br/> →解释后果。<br/> → API文件。</li></ul><h1 id="95ed" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">角度组件最佳实践</strong></h1><ul class=""><li id="f8ba" class="nc nd iq jp b jq lr ju ls jy ne kc nf kg ng kk nh ni nj nk bi translated">建议在组件前加上前缀。如果您使用Angular CLI创建组件，默认情况下，CLI将为您的组件加上前缀:<code class="fe mc md me mf b">selector: ‘app-component-name’</code>。您可以决定是保留“app”作为前缀，还是将其更改为项目名称。如果您正在使用功能模块部分，您可以使用每个功能模块的名称通过前缀来区分每个组件。例如，如果你的项目名称是'<strong class="jp ir">数码商店'</strong>，你可以把' ds '作为前缀。(' ds-component-name ')。</li><li id="16ae" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated">将HTML、CSS和TypeScript文件分开也是一个好的做法。这允许我们有更有组织性和可读性的文件。</li><li id="ce25" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated">输入<br/> →你可以在组件装饰器中声明输入装饰器，靠近选择器、模板等。但这是不可取的。这里的最佳实践是在类内部声明它，就像这样。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/48729c71071a09bc84c24fe71b3e1fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*2Kdheh2UL0QFmQP9ZGIxQg.jpeg"/></div></figure><p id="9781" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">→对于输出装饰器，规则完全相同。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi od"><img src="../Images/8423c2b6cf52c164d7ca82466e903a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RoHONnQ6LMWv0igI2-9E_g.jpeg"/></div></div></figure><ul class=""><li id="b878" class="nc nd iq jp b jq jr ju jv jy nr kc ns kg nt kk nh ni nj nk bi translated"><strong class="jp ir">将复杂的逻辑委托给服务<br/> → </strong>我们希望我们的组件尽可能简单。这意味着如果我们的组件需要做一些复杂的逻辑，我们需要决定这个逻辑是否属于这个组件。如果我们讨论的是一两行逻辑，也许把它留在组件中是可以的。在我看来，组件没有责任执行复杂的逻辑。我们可以把这个留给服务，这样我们的组件就像一个收到包裹的邮递员，知道它必须把它发送给某人，而不需要知道包裹的内容。这是您需要在自己的应用程序中做出的最终决定。</li><li id="e2ed" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><strong class="jp ir">组件成员序列<br/> → </strong>公共方法必须在私有方法之前声明。这更容易阅读或找到，因为这样我们可以防止私有方法在大量公共方法中丢失。注意，默认情况下，所有方法都是公共的，所以要声明私有方法，需要在方法名前写private关键字。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/2bfa90d957da086a2e88d4d3bb1ff695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*mcqv9eOKz1QUTOpxaAHA3w.jpeg"/></div></figure><ul class=""><li id="b91a" class="nc nd iq jp b jq jr ju jv jy nr kc ns kg nt kk nh ni nj nk bi translated"><strong class="jp ir">实现生命周期挂钩接口<br/> → </strong>我们必须声明生命周期挂钩接口，以便在我们没有使用我们声明的接口时发出警告。例如，当我们使用<code class="fe mc md me mf b">ngOnInit</code>时，如果我们像这样声明实现:</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi of"><img src="../Images/c1c555218a80ede50c8eccbf8832ef81.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*8uJluPhDPnm8gLs2bGZ9SA.jpeg"/></div></figure><p id="cb2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们不创建它，我们将收到一个警告，告诉我们缺少<code class="fe mc md me mf b">ngOnInit</code>:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi og"><img src="../Images/ddb0b7b7087381605eef0737cf833d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6ebLkRIkuw_-16oMruWKQ.jpeg"/></div></div></figure><h1 id="37f3" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">角度服务最佳实践</strong></h1><ul class=""><li id="c5c6" class="nc nd iq jp b jq lr ju ls jy ne kc nf kg ng kk nh ni nj nk bi translated"><strong class="jp ir">使服务成为可注入的<br/> → </strong>这只有在一个服务注入另一个服务时才有必要，但建议每次都使用，因为你永远不知道服务什么时候需要注入另一个服务(依赖注入)，也很难记住我们决定不使用可注入装饰器。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/6917f98079584c804752b3260266edea.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*6PRgOTcC9-eXzDxywb36eA.jpeg"/></div></figure><p id="2bfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">→我们可以使用构造函数内部的<code class="fe mc md me mf b">@Inject</code>并移除全局<code class="fe mc md me mf b">@Injectable</code>，但除非需要，否则不建议这样做。例如，如果您注入的服务没有使用<code class="fe mc md me mf b">service</code>数据类型作为这个服务。这个要求很少，通常我们不需要这个。建议始终使用<code class="fe mc md me mf b">@Injectable</code>。此外，我们将需要更多的代码，因为我们将需要这样做的所有参数。</p><ul class=""><li id="26e6" class="nc nd iq jp b jq jr ju jv jy nr kc ns kg nt kk nh ni nj nk bi translated"><strong class="jp ir">使用服务进行数据检索<br/> → </strong>就像我们上面所说的，你应该使用单一主体责任。我们的组件必须调用一个服务来获取一些数据。例如，我们可以直接调用组件中的API代码很简单，但是为了遵守这个原则，最好将这个逻辑放在服务中。该服务可以调用API、localStorage或者在开发过程中帮助我们的虚拟结构，但是对于我们的组件来说，这应该是透明的。如果我们需要更新服务中的调用，组件保持不变。组件不需要考虑如何获取数据，也不需要知道数据是来自API还是本地存储。组件的责任只是知道他有必要调用服务。该服务有义务知道从哪里以及如何获取数据。所以，请避免直接在组件上调用API的诱惑。</li></ul><h1 id="c061" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="3681" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">为了提高应用程序的性能，我建议你考虑使用提前编译、延迟加载，并注意包的大小。在我的下一篇文章中，我将深入探讨这些问题，敬请关注！</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi oi"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="oj ok gp gr ol om"><a href="https://gitconnected.com/learn/angular" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">学习角度-最佳角度教程(2019) | gitconnected</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">前48角教程-免费学习角。课程由开发人员提交和投票，使您能够…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">gitconnected.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kr om"/></div></div></a></div></div></div>    
</body>
</html>