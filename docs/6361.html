<html>
<head>
<title>Server Sent Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器发送的事件</h1>
<blockquote>原文：<a href="https://itnext.io/server-sent-events-45b8da8f0d89?source=collection_archive---------1-----------------------#2021-10-26">https://itnext.io/server-sent-events-45b8da8f0d89?source=collection_archive---------1-----------------------#2021-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c46a3b35658da8e41eb1e6e82b68bdd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*5j4e0Rf-9Tuft6w-2Be8kg.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">帕万·特里库塔姆在<a class="ae jy" href="https://unsplash.com/s/photos/old-phone?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="27a5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们如何保持应用程序上的信息实时更新，而不需要不断轮询服务器？</p><p id="3d4e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">围绕这个概念有几种技术，包括WebSockets或更复杂的协议，如MQTT。</p><p id="f662" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在这篇文章中，我们将探索一些已经在你的浏览器上可用的更简单的东西。</p><h1 id="e3ae" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">服务器发送的事件</h1><p id="5cce" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">浏览器<a class="ae jy" href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events" rel="noopener ugc nofollow" target="_blank"> Web API服务器发送事件</a>有一个EventSource JavaScript接口，允许你订阅一个<em class="ma">文本/事件流</em>并将这些事件冒泡到你的Web应用中。</p><blockquote class="mb mc md"><p id="28f7" class="jz ka ma kb b kc kd ke kf kg kh ki kj me kl km kn mf kp kq kr mg kt ku kv kw ij bi translated">传统上，网页必须向服务器发送请求以接收新数据；也就是说，页面从服务器请求数据。使用服务器发送的事件，服务器可以通过向网页推送消息，随时向网页发送新数据。这些传入的消息可以被视为网页内的<a class="ae jy" href="https://developer.mozilla.org/en-US/docs/Web/API/Event" rel="noopener ugc nofollow" target="_blank"> <em class="iq">事件</em> </a> <em class="iq"> +数据</em>。</p></blockquote><h2 id="a89c" class="mh ky iq bd kz mi mj dn ld mk ml dp lh kk mm mn ll ko mo mp lp ks mq mr lt ms bi translated">接收事件</h2><p id="3eaf" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">为了接收事件，您需要做的就是将EventSource对象指向<em class="ma">文本/事件流</em>页面的URL，并为您感兴趣的事件类型实现监听器。</p><blockquote class="mb mc md"><p id="4a01" class="jz ka ma kb b kc kd ke kf kg kh ki kj me kl km kn mf kp kq kr mg kt ku kv kw ij bi translated"><strong class="kb ir">警告:</strong>当<strong class="kb ir">不在HTTP/2 </strong>上使用时，SSE受到最大打开连接数的限制，这在打开多个标签页时会特别痛苦，因为每个浏览器的限制是<em class="iq"/>并且被设置为一个非常低的数字(6)。该问题在<a class="ae jy" href="https://bugs.chromium.org/p/chromium/issues/detail?id=275955" rel="noopener ugc nofollow" target="_blank"> Chrome </a>和<a class="ae jy" href="https://bugzilla.mozilla.org/show_bug.cgi?id=906896" rel="noopener ugc nofollow" target="_blank"> Firefox </a>中已被标记为“不会修复”。这个限制是针对每个浏览器+域的，这意味着您可以打开6个跨越所有选项卡到<code class="fe mt mu mv mw b">www.example1.com</code>的SSE连接，以及另外6个到<code class="fe mt mu mv mw b">www.example2.com</code>的SSE连接(根据<a class="ae jy" href="https://stackoverflow.com/a/5326159/1905229" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a>)。当使用HTTP/2时，服务器和客户端之间协商最大并发<em class="iq"> HTTP流数量</em>(默认为100)。</p></blockquote><h2 id="7581" class="mh ky iq bd kz mi mj dn ld mk ml dp lh kk mm mn ll ko mo mp lp ks mq mr lt ms bi translated">发送事件</h2><p id="d4fa" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">只有服务器可以发送事件，这不是双向的。</p><p id="dec8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">不仅MIME类型必须是<em class="ma"> text/event-stream </em>，而且每个通知都是以一对换行符结束的文本块的形式发送的。</p><p id="9624" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">生成消息的NodeJs代码的简单示例如下所示:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2c54" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果你将浏览器直接指向这样一个页面，你会看到这样一个例子:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0a10" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">“事件:消息”或“事件:”代表相同的概念。如果您没有指定要订阅的内容，您将获得这些类型的消息，即没有事件或事件设置为“消息”的消息。</p><p id="65a4" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">您可以订阅多个事件，例如示例中的“est”或“pdt”或两者。</p><p id="88bb" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">不管你订阅什么，你总是会收到“消息”或未指定的事件。</p><h1 id="f2f4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">外部系统实现</h1><p id="5607" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">在外部系统中实现这一点非常困难。</p><p id="fb73" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们有一个带有几个参数的块，作为事件的源，以及订阅什么类型的事件，几个块事件将我们从EventSource收到的内容冒泡到我们的应用程序中。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8a8f2194f55a104c714c5bb37c849032.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*ZKZDYP2FjUkM6vRzGpCuxA.png"/></div></figure><h2 id="c43c" class="mh ky iq bd kz mi mj dn ld mk ml dp lh kk mm mn ll ko mo mp lp ks mq mr lt ms bi translated">处理JavaScript</h2><p id="4c9a" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">我们实例化EventSource，将事件侦听器映射到应用程序上的事件触发方法:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="500a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们在OnDestroy上发布这些事件:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="b184" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">演示应用程序</h1><p id="da50" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">我想出了一个最简单但最没用的演示。</p><p id="fdea" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">对于未指定的事件，服务器端将每秒发送一个UTC日期，还将发送一个“est”事件，日期为东部夏令时，最后发送一个“pdt”事件，日期为太平洋夏令时。</p><p id="c1ff" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">EventSource块被设置为订阅我在NodeJs中完成的<em class="ma">文本/事件流</em>页面，我还想订阅“est”和“pdt”。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7040e7bc9c34a8bc7cd2a4c27bfd53eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*mf_0C-ywV3spFg32fefIWA.png"/></div></figure><p id="a518" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然后我们实现事件处理程序:</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/db24b905b919ea25fd400b8a3c63bd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FsmcV2U-rJIn1_hxUEAf-Q.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">在消息处理程序上</figcaption></figure><p id="9c67" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">结果是一个网页，实时显示服务器发送的日期事件。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nk"><img src="../Images/ad21dc4c74bc5b78b0360ca9057a87a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dDMjI2b4RWYUYzhFj79kw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://rb-demos-dev.outsystemscloud.com/WebAPIServerSentEventsTDD/" rel="noopener ugc nofollow" target="_blank">查看本页直播</a></figcaption></figure><h1 id="03a1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">应用程序</h1><p id="16f9" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">那么我们可以或应该在哪里使用它呢？</p><p id="8245" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">首先记住，这是一个单向的通信系统，从服务器到客户端，所以如果你需要两种方式，你最好使用WebSockets，MQTT或类似的。</p><p id="7375" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">QOS无法控制客户端是否真的收到了消息，这基本上是一发了之的事情。</p><p id="a863" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我确实看到了很多使用案例，在这些案例中，你希望你的网络应用程序实时获取绝对最新的信息。</p><p id="c2a6" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">你甚至可以只发送一个ping，告诉应用程序有一些新的信息，所以去获取最新的。您可以在ping上发送足够的信息，以便应用程序只刷新发生了变化的内容(请记住QOS)。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="a3a5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">像往常一样，<a class="ae jy" href="https://www.outsystems.com/forge/component-overview/11783/web-api-server-sent-events" rel="noopener ugc nofollow" target="_blank">组件</a>和<a class="ae jy" href="https://rb-demos.outsystemscloud.com/WebAPIServerSentEventsTDD/" rel="noopener ugc nofollow" target="_blank">演示</a>可以在铁匠铺上找到，还有更多关于这个主题的内容。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/4f366fbc08c2efb9f7a7f34d3112e8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*5GrksTL9kAl0J55k9m-HZQ.png"/></div></figure><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/40e92d80b78ff062375c49b1a307efaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*OSihmcjPSX99y3SZW6mhTg.png"/></div></figure><p id="792c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在您需要做的就是注册参加OutSystems开发者大会。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nu"><img src="../Images/1cce2873f2c3ac762b7ca83ee6d11dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqeKHc-9wP6vO0CvV5Eb3g.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">在这里注册<a class="ae jy" href="https://www.outsystems.com/nextstep/osdc/" rel="noopener ugc nofollow" target="_blank">的</a></figcaption></figure><p id="1e74" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">很明显，去开发一些应用程序。</p></div></div>    
</body>
</html>