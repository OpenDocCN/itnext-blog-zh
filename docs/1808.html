<html>
<head>
<title>useFetch: React custom hook for Fetch API with Suspense and Concurrent Mode in Mind</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">useFetch:考虑到暂停和并发模式，对Fetch API的自定义挂钩做出反应</h1>
<blockquote>原文：<a href="https://itnext.io/usefetch-react-custom-hook-for-fetch-api-with-suspense-and-concurrent-mode-in-mind-1d3ba9250e0?source=collection_archive---------1-----------------------#2019-02-03">https://itnext.io/usefetch-react-custom-hook-for-fetch-api-with-suspense-and-concurrent-mode-in-mind-1d3ba9250e0?source=collection_archive---------1-----------------------#2019-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d236" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">直到我们有了react-cache或用于不同的目的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b358d9d190dc2a0db82ac67dcade9502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CK6noyEux5KRB5P1n79a4g.png"/></div></div></figure><h2 id="febc" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">介绍</h2><p id="134b" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">虽然我不喜欢在没有钩子的情况下编写React，但react-cache似乎仍然很遥远。当然，数据获取中的缓存很重要，然而我想寻求仅用React钩子实现的可能性。这些在未来可能会过时，但我今天想要一些东西，那就是“useFetch”。在不需要复杂缓存的情况下，如果没有react-cache，这仍然是有用的。</p><p id="1ffa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经开始开发“useFetch”作为构建自定义钩子的教程。</p><div class="ly lz gp gr ma mb"><a rel="noopener  ugc nofollow" target="_blank" href="/react-hooks-tutorial-on-developing-a-custom-hook-for-data-fetching-8ad5840db7ae"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">React Hooks开发数据获取定制钩子教程</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">钩子进入反应16.7。</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">itnext.io</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ky mb"/></div></div></a></div><p id="5e77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此后，添加了对AbortController的支持，如果您像typeahead建议的那样获取一次性数据，这是令人难以置信的。</p><p id="8bcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，为了让这个“useFetch”挂钩更有用，本文描述了对悬念和并发反应的支持。</p><h2 id="2f83" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">反应悬念</h2><div class="ly lz gp gr ma mb"><a href="https://reactjs.org/docs/code-splitting.html#suspense" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">代码分解-反应</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">用于构建用户界面的JavaScript库</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">reactjs.org</p></div></div><div class="mk l"><div class="mq l mm mn mo mk mp ky mb"/></div></div></a></div><p id="5a96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">悬念目前在代码分割部分描述。然而，它的一般用途是捕捉组件树中的承诺并呈现回退元素。当承诺被解决时，它将呈现一棵正常的树。悬念的好处是你可以在树上的任何地方放置悬念，你甚至可以只在树的顶端放置一个悬念。</p><p id="608f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个不确定的点是，当数据提取的暂停被释放时，该功能是否会相同。没关系。我们应该能够跟上即将到来的变化。</p><h2 id="c0d2" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">并发反应</h2><div class="ly lz gp gr ma mb"><a href="https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#react-16x-q2-2019-the-one-with-concurrent-mode" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">React 16.x路线图- React博客</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">你可能在以前的博文中听说过类似“钩子”、“悬念”和“并发渲染”的特性…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">reactjs.org</p></div></div><div class="mk l"><div class="mr l mm mn mo mk mp ky mb"/></div></div></a></div><p id="875d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前还没有关于并发模式的文档。据我理解，我们需要关心的是a)渲染函数可以被多次调用，b)渲染阶段和提交阶段不同步。至于a)，render函数应该是纯的或者至少调用两次也不应该改变世界。对于b)，我们不应该假设多个组件的调用顺序。不过，我可能还是有些误解。我希望将来能有一些关于React钩子的指导方针。</p><h2 id="7c86" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">图书馆</h2><div class="ly lz gp gr ma mb"><a href="https://github.com/dai-shi/react-hooks-fetch" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">戴式/反应钩取</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">用于获取API的React自定义挂钩。通过在…上创建一个帐户，为dai-shi/react-hooks-fetch开发做出贡献</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">github.com</p></div></div><div class="mk l"><div class="ms l mm mn mo mk mp ky mb"/></div></div></a></div><p id="e711" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看“useFetch”是如何实现的。如果你想知道它是如何使用的，请跳到下一节。</p><p id="a82e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，有一些效用函数，有两个值得注意的:</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="136c" class="la lb it mu b gy my mz l na nb">const <strong class="mu iu">useForceUpdate</strong> = () =&gt; useReducer(state =&gt; !state, false)[1];</span></pre><p id="72eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个自定义挂钩，用于强制重新渲染。</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="a6cd" class="la lb it mu b gy my mz l na nb">const <strong class="mu iu">createPromiseResolver</strong> = () =&gt; {<br/>  let resolve;<br/>  const promise = new Promise((r) =&gt; { resolve = r; });<br/>  return { resolve, promise };<br/>};</span></pre><p id="b9e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一种创造可以从外部解决的承诺的天真方式。</p><p id="fb13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是钩子的主要部分:</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="e74e" class="la lb it mu b gy my mz l na nb">export const useFetch = (input, opts = defaultOpts) =&gt; {<br/>  const forceUpdate = useForceUpdate();<br/>  const error = <strong class="mu iu">useRef</strong>(null);<br/>  const loading = <strong class="mu iu">useRef</strong>(false);<br/>  const data = <strong class="mu iu">useRef</strong>(null);<br/>  const promiseResolver = <strong class="mu iu">useMemo</strong>(createPromiseResolver, [input, opts]);</span></pre><p id="0515" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们用<code class="fe nc nd ne mu b">useRef</code>定义一些变量，用<code class="fe nc nd ne mu b">useMemo</code>定义promiseResolver。</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="1102" class="la lb it mu b gy my mz l na nb">  // ...continued<br/>  useEffect(() =&gt; {<br/>    let finished = false;<br/>    const abortController = new AbortController();<br/>    (async () =&gt; {<br/>      if (!input) return;<br/>      // start fetching<br/>      loading.current = true;<br/>      <strong class="mu iu">forceUpdate()</strong>;<br/>      const onFinish = (e, d) =&gt; {<br/>        if (!finished) {<br/>          finished = true;<br/>          error.current = e;<br/>          data.current = d;<br/>          loading.current = false;<br/>        }<br/>      };<br/>      try {<br/>        const { readBody = defaultReadBody, ...init } = opts;<br/>        const response = await fetch(input, {<br/>          ...init,<br/>          signal: abortController.signal,<br/>        });<br/>        // check response<br/>        if (response.ok) {<br/>          const body = await readBody(response);<br/>          onFinish(null, body);<br/>        } else {<br/>          onFinish(createFetchError(response), null);<br/>        }<br/>      } catch (e) {<br/>        onFinish(e, null);<br/>      }<br/>      // finish fetching<br/>      <strong class="mu iu">promiseResolver.resolve()</strong>;<br/>    })();<br/>    const cleanup = () =&gt; {<br/>      if (!finished) {<br/>        finished = true;<br/>        <strong class="mu iu">abortController.abort()</strong>;<br/>      }<br/>      error.current = null;<br/>      loading.current = false;<br/>      data.current = null;<br/>    };<br/>    return cleanup;<br/>  }, <strong class="mu iu">[input, opts]</strong>);</span></pre><p id="fda4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，太久了。一些注意事项:a) <code class="fe nc nd ne mu b">forceUpdate()</code>在变量更新时被调用。b)异步函数结束时，调用<code class="fe nc nd ne mu b">primiseResolver.resolve()</code>。c)<code class="fe nc nd ne mu b">cleanup</code>用于中止正在运行的获取并清除变量。d)<code class="fe nc nd ne mu b">useEffect</code>的输入数组是<code class="fe nc nd ne mu b">[input, opts]</code>。</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="e9cf" class="la lb it mu b gy my mz l na nb">  // ...continued<br/>  if (loading.current) <strong class="mu iu">throw</strong> promiseResolver.promise;<br/>  <strong class="mu iu">return</strong> {<br/>    error: error.current,<br/>    data: data.current,<br/>  };<br/>};</span></pre><p id="d14d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，它返回一些变量，但在此之前，如果它仍然处于加载状态，它抛出一个承诺，以便悬念捕捉它并显示一个后备加载组件。</p><h2 id="541f" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">如何使用它</h2><p id="651d" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">让我展示一个最小的例子。</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="5401" class="la lb it mu b gy my mz l na nb">import React, { <strong class="mu iu">Suspense</strong> } from 'react';<br/>import ReactDOM from 'react-dom';<br/><br/>import { <strong class="mu iu">useFetch</strong> } from 'react-hooks-fetch';<br/><br/>const Err = ({ error }) =&gt; &lt;span&gt;Error:{error.message}&lt;/span&gt;;<br/><br/>const DisplayRemoteData = () =&gt; {<br/>  const url = 'https://jsonplaceholder.typicode.com/posts/1';<br/>  const { error, data } = <strong class="mu iu">useFetch</strong>(url);<br/>  if (error) return &lt;Err error={error} /&gt;;<br/>  if (!data) return null;<br/>  return &lt;span&gt;RemoteData:{data.title}&lt;/span&gt;;<br/>};<br/><br/>const App = () =&gt; (<br/>  &lt;<strong class="mu iu">Suspense</strong> fallback={&lt;span&gt;Loading...&lt;/span&gt;}&gt;<br/>    &lt;DisplayRemoteData /&gt;<br/>  &lt;/<strong class="mu iu">Suspense</strong>&gt;<br/>);<br/><br/>ReactDOM.render(&lt;App /&gt;, document.getElementById('app'));</span></pre><p id="ffba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe nc nd ne mu b">useFetch</code>的组件不处理加载状态，组件外部的<code class="fe nc nd ne mu b">Suspense</code>处理并显示加载状态。一个重要的注意事项是第<code class="fe nc nd ne mu b">if (!data) return null;</code>行，它是必需的，因为它最初是空的。目前这不是很好，我们想知道是否有解决方法。</p><p id="d3a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在codesandbox中试试这个例子。</p><div class="ly lz gp gr ma mb"><a href="https://codesandbox.io/s/github/dai-shi/react-hooks-fetch/tree/master/examples/01_minimal" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">react-hooks-fetch-example-code sandbox</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">为web应用程序定制的在线代码编辑器</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">codesandbox.io</p></div></div><div class="mk l"><div class="nf l mm mn mo mk mp ky mb"/></div></div></a></div><p id="d4d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在带有codesandbox链接的GitHub repo中，您还可以找到其他一些例子。</p><h2 id="0118" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">最终注释</h2><p id="b92d" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">起初，我希望使用悬念和错误边界来显示加载状态和错误状态，这样带有<code class="fe nc nd ne mu b">useFetch</code>的主组件只关心成功的情况。事实证明，这或多或少涉及到黑客攻击，我最终通过一个钩子返回了正常的错误变量。在<a class="ae ng" href="https://reactjs.org/docs/react-component.html#error-boundaries" rel="noopener ugc nofollow" target="_blank">文档</a>中还有一个注释:</p><blockquote class="nh ni nj"><p id="db0c" class="jq jr nk js b jt ju jv jw jx jy jz ka nl kc kd ke nm kg kh ki nn kk kl km kn im bi translated">仅使用错误边界从意外异常中恢复；<strong class="js iu">不要试图用它们来控制流程。</strong></p></blockquote><p id="7768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">悬念也很难与AbortController合作。在写作的时候，它很像一个黑客。有兴趣的，这里的代码是<a class="ae ng" href="https://github.com/dai-shi/react-hooks-fetch/blob/0fbd03e6581a3e8e9ef13b4ce72ae3c2101ebc5a/examples/04_abort/src/App.tsx" rel="noopener ugc nofollow" target="_blank">这里是</a>。我真的想找到一个更好的方法来解决这个问题。我很好奇react-cache句柄是如何中止的。在此之前，我们会继续改进它。</p><h2 id="609e" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">变更日志</h2><ul class=""><li id="c707" class="no np it js b jt lt jx lu kb nq kf nr kj ns kn nt nu nv nw bi translated"><em class="nk">【2019–02–04】:首次发布。</em></li><li id="0965" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn nt nu nv nw bi translated"><em class="nk">【2019–02–05】:提高代码简单性。</em></li></ul></div></div>    
</body>
</html>