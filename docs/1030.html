<html>
<head>
<title>Typescript dependency injection: setting up InversifyJS IoC for a TS project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript依赖项注入:为TS项目设置InversifyJS IoC</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-dependency-injection-setting-up-inversifyjs-ioc-for-a-ts-project-f25d48799d70?source=collection_archive---------1-----------------------#2018-07-09">https://itnext.io/typescript-dependency-injection-setting-up-inversifyjs-ioc-for-a-ts-project-f25d48799d70?source=collection_archive---------1-----------------------#2018-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/88f780b8b66b48a73a08841d0ca50021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oSuBauRQ4pjd68HL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约翰·卡莱尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a8e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是每次我们想要使用一个特定的类时都要处理手工创建的类依赖关系。我们可以建立一种机制来为我们创建它们，并自动向类提供依赖关系。这种机制被称为控制反转(IoC)容器，在本文中，我将展示如何通过使用InversifyJS设置依赖容器来改进您的类型脚本代码。</p><h1 id="f360" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用依赖注入(DI)之前的项目设置</h1><p id="2a06" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我将向您展示一个基于节点演示项目的示例，该项目包含一个依赖于其他两个类的服务类，以及使用该服务的主TypeScript文件。项目的结构是这样的</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="643c" class="mn lc iq mj b gy mo mp l mq mr">src/<br/> dependencies.ts<br/> service.ts<br/> main.ts</span></pre><p id="011b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你也可以在GitHub<a class="ae kc" href="https://github.com/AndrejsAbrickis/ts-inversify-blog" rel="noopener ugc nofollow" target="_blank">https://github.com/AndrejsAbrickis/ts-inversify-blog</a>上看到</p><h2 id="41d3" class="mn lc iq bd ld ms mt dn lh mu mv dp ll ko mw mx lp ks my mz lt kw na nb lx nc bi translated">dependencies.ts</h2><p id="3e19" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这个TypeScript文件导出两个行为相同的类。它们都有一个私有字段<code class="fe nd ne nf mj b">name</code>来表示类名。两者都有返回类名的私有方法<code class="fe nd ne nf mj b">getName()</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/7fd001f1e2d045acc8af07bf6c730e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IFnG1IAWHQ4C8okPvMJc7g.png"/></div></div></figure><h2 id="64ef" class="mn lc iq bd ld ms mt dn lh mu mv dp ll ko mw mx lp ks my mz lt kw na nb lx nc bi translated">服务. ts</h2><p id="f4a3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">服务类所做的只是返回它正在使用的依赖项名称的数组。由于我们不能直接访问类的只读名称字段，我们必须使用实例方法<code class="fe nd ne nf mj b">getName</code>。为了使用该方法，我们必须使用<code class="fe nd ne nf mj b">new</code>关键字实例化这些类</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/2c8e73c1e6343f6a1f9881d57cf4a534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5N1q7nvrmdfPaj31nIxi3w.png"/></div></div></figure><h2 id="0d69" class="mn lc iq bd ld ms mt dn lh mu mv dp ll ko mw mx lp ks my mz lt kw na nb lx nc bi translated">主页面</h2><p id="5a18" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当执行时，主文件“新建”(手动创建一个类的新实例)服务类，调用它的<code class="fe nd ne nf mj b">getAllNames</code>方法并记录该方法的结果</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/7e1fa6d81dd023b2c07bd3e40ad13c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nE3QcuM8GCoFdzCASJHHYw.png"/></div></div></figure><p id="1a13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，在开发过程中，我们使用了几次<code class="fe nd ne nf mj b">new</code>关键字。这只是一个服务和两个依赖关系的简单例子。想象一下，在有几十个甚至几百个类的真实项目中这样做。</p><h1 id="7369" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将inversify添加到项目中</h1><p id="3820" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了在项目中实现DI，我将使用InversifyJS作为IoC(控制反转)容器。</p><p id="77d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要将<code class="fe nd ne nf mj b">inversify</code>和<code class="fe nd ne nf mj b">reflect-metadata</code>添加到项目中</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a881" class="mn lc iq mj b gy mo mp l mq mr">yarn add -D inversify reflect-metadata</span></pre><p id="69c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二:通过向<code class="fe nd ne nf mj b">compilerOptions</code>部分添加额外设置来更新<code class="fe nd ne nf mj b">tsconfig.json</code></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/4b016c5456261ff4026072391b35c57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vh8Uv-Q4J9gkl89UrMXbjA.png"/></div></div></figure><h1 id="bbe5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用依赖注入(DI)后的项目设置</h1><p id="58a5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在安装了InversifyJS并且TypeScript编译器被配置为支持InversifyJS之后，我们可以更新我们的应用程序的代码。</p><h2 id="cfe5" class="mn lc iq bd ld ms mt dn lh mu mv dp ll ko mw mx lp ks my mz lt kw na nb lx nc bi translated">di-容器. ts</h2><p id="7b6b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在享受依赖注入的甜蜜果实之前，我们必须配置IoC容器，以便类可以从集中式容器中解析它们自己的依赖。</p><p id="227a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过创建一个新的inversify容器并为其提供类的绑定来实现这一点。绑定允许容器将请求的依赖项映射到它的一个实例。</p><p id="15dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我对类<code class="fe nd ne nf mj b">DependencyA</code>和<code class="fe nd ne nf mj b">DependencyB</code>使用了<code class="fe nd ne nf mj b">toSelf()</code>绑定。它指示容器在请求(注入)特定类时返回类的实例。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/de19e2b282b145baf417b978be1aba7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pl9-vWshBlCep7ANz8JxtQ.png"/></div></div></figure><h2 id="9db8" class="mn lc iq bd ld ms mt dn lh mu mv dp ll ko mw mx lp ks my mz lt kw na nb lx nc bi translated">dependencies.ts</h2><p id="61b5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在容器设置好之后，可以通过从inversify导入<code class="fe nd ne nf mj b">injectable</code> decorator并用<code class="fe nd ne nf mj b">@injectable</code>decorator装饰类来使依赖项成为可注入的。这个装饰器将在TypeScript编译期间使用<code class="fe nd ne nf mj b">reflect-metadata</code>包进行处理并应用于JavaScript输出。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/f048aaf916c825c7d2c98ee644627ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NR9K3F_KiviYa720NOn8bw.png"/></div></div></figure><h2 id="ccfa" class="mn lc iq bd ld ms mt dn lh mu mv dp ll ko mw mx lp ks my mz lt kw na nb lx nc bi translated">服务. ts</h2><p id="ccea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在可以从服务类中删除关键字<code class="fe nd ne nf mj b">new</code>。并且可以通过使用<code class="fe nd ne nf mj b">@inject</code> decorator将依赖关系直接注入到类的构造函数中。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/e1848a7177aa7c52d93101e1f545b145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3NoY0D76F4BOPP9Z53VMA.png"/></div></div></figure><p id="9d64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下示例将从IoC容器中检索<code class="fe nd ne nf mj b">DependencyA</code>类的实例，并将其作为参数<code class="fe nd ne nf mj b">dependencyA</code>传递给构造函数</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6706" class="mn lc iq mj b gy mo mp l mq mr"><a class="ae kc" href="http://twitter.com/inject" rel="noopener ugc nofollow" target="_blank">@inject</a>(DependencyA) dependencyA: DependencyA</span></pre><h2 id="aec9" class="mn lc iq bd ld ms mt dn lh mu mv dp ll ko mw mx lp ks my mz lt kw na nb lx nc bi translated">主页面</h2><p id="c77c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先通过addin <code class="fe nd ne nf mj b">import 'reflect-metadata';</code>更新导入。inversify要求将<code class="fe nd ne nf mj b">@inject()</code>和<code class="fe nd ne nf mj b">@injectable</code>decorator应用于应用程序的编译输出。</p><p id="de8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，我们可以导入应用程序的容器，并且可以通过将<code class="fe nd ne nf mj b">service</code>声明更改为</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c789" class="mn lc iq mj b gy mo mp l mq mr">const service: Service = DIContainer.resolve&lt;Service&gt;(Service);</span></pre><p id="1d9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们不再需要手动创建<code class="fe nd ne nf mj b">Service</code>类依赖关系，因为每当容器被要求解析<code class="fe nd ne nf mj b">Service</code>类时，它就会为我们做这件事。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/aeb37bc9b7176e0b6355d112f9dd5de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtnEmXxXMM0bzd3hOT3HIg.png"/></div></div></figure><h1 id="266a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c16b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">依赖注入是一种模式，它消除了每次我们想要使用一个特定的类时手动创建类依赖的责任。相反，我们配置控制反转(IoC)容器来为我们做这件事。</p><p id="5962" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为这种模式的主要好处是我们可以模仿和替换依赖的具体实例。因此，我们可以更容易地为我们的类行为编写测试，而不需要手动创建所有的依赖关系。通过利用接口和IoC容器，我们可以使我们的代码更具可扩展性。</p><p id="8cd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在Github<a class="ae kc" href="https://github.com/AndrejsAbrickis/ts-inversify-blog" rel="noopener ugc nofollow" target="_blank">https://github.com/AndrejsAbrickis/ts-inversify-blog</a>上看到这两个实现<code class="fe nd ne nf mj b">befora DI</code>和<code class="fe nd ne nf mj b">after DI</code>。要查看编译后的类型脚本，克隆repo，运行</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f7a2" class="mn lc iq mj b gy mo mp l mq mr">yarn &amp;&amp; yarn build</span></pre><p id="5a4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ad14" class="mn lc iq mj b gy mo mp l mq mr">npm install &amp;&amp; npm build</span></pre><p id="dbd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并查看输出的<code class="fe nd ne nf mj b">./dist</code>目录。</p><p id="a77c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯！</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="94eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你觉得这篇文章很有用，并且想阅读更多关于随机网络开发的话题，请为这篇文章鼓掌或者在这里发表评论。和往常一样，你可以在Twitter@andrejsabrickis上找到我</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="73ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我离开之前，简单说一下我们正在招聘。目前，我们公司正在寻找有创造力和思想开放的软件工程师来帮助我们发展领先的点对点投资市场。如果你有兴趣或者你知道有谁会感兴趣的话，不要犹豫，可以在Twitter上亲自联系我<a class="ae kc" href="https://twitter.com/andrejsabrickis" rel="noopener ugc nofollow" target="_blank"><em class="nt">@ andrejsabrickis</em></a><em class="nt">。另外，在</em><a class="ae kc" href="https://www.mintos.com/en/about-us/careers/#all-roles" rel="noopener ugc nofollow" target="_blank"><em class="nt">Mintos</em></a><em class="nt">查看我们目前的工作机会。</em></p><p id="cccd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nt">干杯！<br/> /Andrejs/ </em></p></div></div>    
</body>
</html>