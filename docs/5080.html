<html>
<head>
<title>White-label apps in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter中的白牌应用</h1>
<blockquote>原文：<a href="https://itnext.io/white-label-apps-in-flutter-613b2d0a80ce?source=collection_archive---------0-----------------------#2020-12-06">https://itnext.io/white-label-apps-in-flutter-613b2d0a80ce?source=collection_archive---------0-----------------------#2020-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8da0d439e159dfd0ef19b6875c6f74c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlxrZj4S-tePDcC5Bi79yg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://unsplash.com/@frostroomhead" rel="noopener ugc nofollow" target="_blank"> Rodion Kutsaev </a>在<a class="ae jg" href="https://unsplash.com/photos/VKfqHv7qjNs" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="acee" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">在Flutter中，各种风格在不同的环境下都能很好地工作，但是如果我们想要为不同的客户提供一个带有白色标签变体的公共代码库呢？</em></p><p id="6f94" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如今，白色标签是一个常见的主题，至少这是我们作为一家移动代理商在<a class="ae jg" href="https://pinch.nl/en" rel="noopener ugc nofollow" target="_blank"> Pinch </a>所经历的。为什么不应该呢？作为一家拥有多个品牌的公司，很容易为每个品牌推出应用程序，同时共享相同的代码库:对开发人员来说效率更高，对客户来说成本更低！但是，尽管在iOS &amp; Android等原生环境中的路径非常清晰，但目前还没有针对Flutter的真正解决方案。我们可以在代码中多样化，但是我们如何保持一切整洁？我们如何保持我们的主要代码库的整洁，而不是用特定风格的代码把它弄得乱七八糟，或者把一种风格的资产从另一种风格中分离出来，而不是在创建发布版本时把每个资产都拉进我们的应用程序，以缩小应用程序的规模？🤔</p><h1 id="b9d6" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">那么，问题是什么？</h1><p id="5187" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在深入更技术性的东西之前，让我们后退一步，看看这里的实际问题。原生Android和iOS应用中的白色标签是通过产品风格和模式完成的。在这方面有足够多的东西可以找到，但我们在这里处理的是Flutter应用程序，而不仅仅是本机应用程序。这意味着如果我们想要创建合适的白标签应用程序，我们实际上有2层要处理:本地和Flutter。</p><p id="8934" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">原生</strong>层包含应用图标、应用ID &amp;和应用名称等内容。<strong class="ki jk"> Flutter </strong>包含图像、字符串、字体等其他东西&amp;主题化。</p><p id="eefd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记住这一点，让我们先看看最显而易见的解决方案，看看为什么它不能真正满足我的需求。</p><h1 id="7daa" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">风味飘动</h1><p id="778e" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">所以，当你开始谷歌搜索时，你会发现的第一件事显然是<a class="ae jg" href="https://flutter.dev/docs/deployment/flavors" rel="noopener ugc nofollow" target="_blank"> Flutter文档</a>。这里有多篇文章描述了如何在Flutter中实现flavors。简而言之，您将利用本机变体来指定您的口味:iOS中Android &amp;模式中的产品口味。之后，您可以检查Dart代码中的味道，并从那时起对它做任何您想做的事情。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mi"><img src="../Images/e9944f3afd670129ed35ca1a5d2fb30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCQh3BEwoMo8io4S1sVXIg.png"/></div></div></figure><p id="b42c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它完成了任务，而且效果很好。我们已经在一些应用中使用类似的设置来分离开发和生产环境。我们在Android中指定了产品风格，在iOS中指定了模式，然后使用一个<code class="fe mn mo mp mq b">FlavorConfig</code>类根据风格初始化它的值(它使用一个<code class="fe mn mo mp mq b">MethodChannel</code>从本机获取)。</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3d40" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止一切顺利，但是如果我们把白色标签加入其中会发生什么呢？看到我们希望每个白标有2个环境，事情可能会在代码中变得很难控制。在每个需要特定风格代码的地方，都需要有switch-case和/或if-else语句。</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f4e8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不理想😅这是可行的，但是可维护性和可读性确实受到了影响。除此之外，当创建发布版本时，我们基本上是将所有的代码&amp;所有的资产都拉入到版本中。实际上，可能会出现更多的问题，但(幸运的是)我们从来没有到那一步。</p><p id="67ae" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理想情况下，我们希望将所有与风味相关的东西彼此分开，并与主代码库分开。是的，这正是我在即将推出的解决方案中试图实现的目标！</p><h1 id="c720" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解决方案:依赖！</h1><blockquote class="mt mu mv"><p id="a194" class="kg kh le ki b kj kk kl km kn ko kp kq mw ks kt ku mx kw kx ky my la lb lc ld im bi translated">旁注:如果您想直接跳到实现，只需向前滚动到下一部分👌</p></blockquote><p id="7ee4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想要实现的是为每一种口味都有单独的目录，所以我们保持一切都很好并且包含在内。添加新的白标应该像复制粘贴现有的白标并调整值以适应新的白标一样简单。</p><p id="a443" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我来说，最有效和最清晰的方法是完全抛弃产品风格和模式。相反，我在我的基础项目中添加了一个本地<code class="fe mn mo mp mq b">flavor</code>依赖项，其中包含了所有特定风格的Flutter东西:资产、字符串、主题化，甚至小部件。之后，我创建了第二个Flutter项目，它依赖于<code class="fe mn mo mp mq b">base</code>项目。通过在那里添加一个本地<code class="fe mn mo mp mq b">flavor</code>依赖项，但是实际上将其定义为一个依赖项覆盖，我们最终只使用了白标项目的<code class="fe mn mo mp mq b">flavor</code>依赖项，所以我们放弃(或者更好地说:覆盖)了基础项目的<code class="fe mn mo mp mq b">flavor</code>依赖项。接下来:白标项目的入口点(<code class="fe mn mo mp mq b">main()</code>)将实际引用基础项目的入口点。那是什么意思？这意味着最后，我们利用基础项目中的Flutter代码，并结合白标项目的flavor目录中的内容。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/0d8cf8d760cff6a9dfb81a18dc9aa382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ZOwMf0rEvyjLVEjchNCbA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">最终，我们只会得到基础项目的Flutter代码和白标项目的Flavor目录的内容。</figcaption></figure><p id="54f9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了让Flutter端很好地包含在内，我们还保持了原生组件的分离。因为一个白标项目是它自己的Flutter项目，它有自己的Android &amp; iOS文件夹。尽管这意味着一些样板文件，但它确实意味着我们将像应用程序图标、应用程序名称和应用程序ID这样的东西保留在白标项目中，而不是共享代码库中。</p><h1 id="78d2" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">变得技术化</h1><p id="8d6a" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这在理论上听起来很棒，但实际上看起来如何呢？</p><p id="4edd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我首先在我的(现有的)Flutter项目的根目录下创建了一个名为<code class="fe mn mo mp mq b">flavor</code>的目录。通过在该目录中添加一个<code class="fe mn mo mp mq b">lib </code>文件夹和一个<code class="fe mn mo mp mq b">pubspec.yaml</code>文件，我们实际上可以把它看作一个(本地)依赖项:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="069e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们转到<code class="fe mn mo mp mq b">base</code>项目的<code class="fe mn mo mp mq b">pubspec.yaml</code>，我们可以简单地通过路径定义来添加本地<code class="fe mn mo mp mq b">flavor</code>依赖项:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0415" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就像正常添加依赖项一样，但是我们通过依赖项的路径来定义它的位置。</p><p id="5491" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在<code class="fe mn mo mp mq b">flavor</code>目录中添加一些东西！首先，在名为<code class="fe mn mo mp mq b">flavor_strings.dart</code>的<code class="fe mn mo mp mq b">lib</code>文件夹中创建一个新的Dart类。我们将在其中输入一个字符串作为应用程序的名称:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c55c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，只需在您的应用程序中使用<code class="fe mn mo mp mq b">FlavorStrings.flavorName</code>字符串！我们将在接下来的步骤中覆盖它🙂</p><blockquote class="mt mu mv"><p id="7673" class="kg kh le ki b kj kk kl km kn ko kp kq mw ks kt ku mx kw kx ky my la lb lc ld im bi translated">旁注:因为<code class="fe mn mo mp mq b">flavor</code>是一个本地依赖项，所以把它当作一个本地依赖项对待！相对导入是行不通的，所以一定要用全包导入。</p></blockquote><p id="8b8e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">添加白标项目<br/> </strong>现在我们已经建立了我们的共享代码库，是时候为我们的第一个白标创建一个新的Flutter项目了。确保基础项目和白标项目在同一个文件夹中！当新项目启动并运行时，我们要做的第一件事是将<code class="fe mn mo mp mq b">flavor</code>目录从基础项目复制粘贴到白标项目中。之后，让我们更改我们的白标项目中的<code class="fe mn mo mp mq b">flavorName</code>字符串，这样我们就可以在以后验证一切都正常工作了！</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b455" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不错！所以现在我们已经定义了我们的白标特定字符串，继续前进并跳转到白标项目的<code class="fe mn mo mp mq b">pubspec.yaml</code>文件。我们将在这里向我们的共享代码库添加一个依赖项，并用我们的白标项目中的新目录覆盖基础项目的flavor目录:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5a0b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一件事！进入白标项目的<code class="fe mn mo mp mq b">main.dart</code>类。在这里导入基础项目的<code class="fe mn mo mp mq b">main.dart</code>类，从白标项目的main函数中调用main函数:</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d8e8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相当简单，但我们在这里所做的就是确保当我们运行我们的白标项目时，它基本上会运行我们的共享代码库。</p><p id="e48a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好东西！</p><blockquote class="mt mu mv"><p id="6c03" class="kg kh le ki b kj kk kl km kn ko kp kq mw ks kt ku mx kw kx ky my la lb lc ld im bi translated">我知道这可能需要通读一篇文章，所以要获得完整的项目概述，只需看一看<a class="ae jg" href="https://github.com/ThomasMiddel/flutter_whitelabel" rel="noopener ugc nofollow" target="_blank">这个资源库</a></p></blockquote><h1 id="0c85" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">利弊</h1><p id="4eeb" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我首先要说的是，这不是灵丹妙药。来自Android的我想我可能有点被那里的处理方式宠坏了，但仍然:我认为这个解决方案总体上是非常清晰和可维护的。它对每个白标都有明确的划分，发布版本将只包含与我们正在构建的白标内容相结合的共享代码库。没有来自其他白色标签的内容或代码！</p><p id="f876" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我现在遇到的主要缺点(仍有可能微调)是有一些样板文件，因为我们有2个Flutter项目用于1个white-label，并且本机端的可维护性有点低。想想你放在<code class="fe mn mo mp mq b">MainActivity</code>或<code class="fe mn mo mp mq b">AppDelegate</code>中的逻辑，或者比如碰撞minSdk版本。这必须在每个白标中单独完成，而不是在共享代码库中一次完成。</p><p id="a0da" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">就是这样！我希望这篇文章能为你提供一些关于Flutter中白色标签的答案。我认为这个模板仍然有改进的空间，但它是一个很好的基础，让你有希望开始！保持安全，继续编码。🐦</em></p></div></div>    
</body>
</html>