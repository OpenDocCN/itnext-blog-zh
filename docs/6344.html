<html>
<head>
<title>Implementing the Health Check API Pattern with Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rust实现健康检查API模式</h1>
<blockquote>原文：<a href="https://itnext.io/implementing-the-health-check-api-pattern-with-rust-eaef04cb4d2d?source=collection_archive---------5-----------------------#2021-10-20">https://itnext.io/implementing-the-health-check-api-pattern-with-rust-eaef04cb4d2d?source=collection_archive---------5-----------------------#2021-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7a045b0d9a1e3c0a53d72f5c5005d69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ptMVo9mZOUAnKpFyoLv3w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@spacex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae kc" href="https://unsplash.com/s/photos/rocket?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ec49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本周，当我准备将一个基于Rust的后端服务部署到Kubernetes集群时，我意识到我还没有将我的后端服务配置为由<a class="ae kc" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> kubelet </strong> </a>探测，以进行<a class="ae kc" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a>和<a class="ae kc" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">就绪</strong> </a>检查。我能够通过添加一个<code class="fe lb lc ld le b">/health</code> API端点来完成这个需求，这个端点根据服务的当前状态用一个<code class="fe lb lc ld le b">Ok</code>或<code class="fe lb lc ld le b">ServiceUnavailable</code> HTTP状态来响应。</p><p id="3fe2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<code class="fe lb lc ld le b">/health</code> API端点解决方案是<a class="ae kc" href="https://microservices.io/patterns/observability/health-check-api.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">健康检查API模式</strong> </a>的一个实现，该模式用于检查您的API服务的健康状况。在像<a class="ae kc" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Spring </strong> </a>这样的web框架中，像<a class="ae kc" href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">Spring Actuator</strong></a>这样的嵌入式解决方案可供您集成到您的Spring项目中。然而，在许多web框架中，您必须自己构建这种健康检查API行为。</p><p id="f4d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博文中，我们将使用<a class="ae kc" href="https://actix.rs/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">actix-web</strong></a>web框架实现健康检查API模式，该框架使用<a class="ae kc" href="https://github.com/launchbadge/sqlx" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> sqlx </strong> </a>连接到本地PostgreSQL数据库实例。</p><h1 id="3224" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">先决条件</h1><p id="14f2" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">开始之前，确保您的机器上安装了<a class="ae kc" href="https://doc.rust-lang.org/cargo/getting-started/installation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Cargo </strong> </a>和<a class="ae kc" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Rust </strong> </a>。<em class="mi">安装这些工具最简单的方法就是使用</em><a class="ae kc" href="https://rustup.rs/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mi">rust up</em></strong></a><em class="mi">。</em></p><p id="898a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要在您的机器上安装<a class="ae kc" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Docker </strong> </a>，这样我们就可以轻松地创建并连接到PostgreSQL数据库实例。</p><p id="2c85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这是你第一次看到<a class="ae kc" href="https://rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Rust </strong> </a>编程语言，我希望这篇博文能启发你更深入地了解一种有趣的静态类型语言和生态系统。</p><p id="0718" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mi">如果你想跟随你身边的代码，我已经在</em><a class="ae kc" href="https://github.com/tjmaynes/gists/tree/main/rust/health-check-rust" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="mi">GitHub</em></strong></a><em class="mi">上提供了这个项目的源代码。</em></p><h1 id="5e22" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建新的Actix-Web项目</h1><p id="7938" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">让我们打开您最喜欢的<a class="ae kc" href="https://github.com/alacritty/alacritty" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">命令行终端</strong> </a>并通过<code class="fe lb lc ld le b">cargo new my-service --bin</code>创建一个新的Cargo项目。</p><blockquote class="mj mk ml"><p id="d27b" class="kd ke mi kf b kg kh ki kj kk kl km kn mm kp kq kr mn kt ku kv mo kx ky kz la ij bi translated"><em class="iq"/><code class="fe lb lc ld le b"><em class="iq">--bin</em></code><em class="iq">标志会告诉Cargo自动创建一个</em> <code class="fe lb lc ld le b"><em class="iq">main.rs</em></code> <em class="iq">文件，让Cargo知道这个项目不是一个库而是会产生一个可执行文件。</em></p></blockquote><p id="e658" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们通过运行命令<code class="fe lb lc ld le b">cargo run</code>来检查我们是否能够运行项目。运行这个命令后，您应该会得到如下所示的输出。</p><pre class="mp mq mr ms gt mt le mu mv aw mw bi"><span id="6acb" class="mx lg iq le b gy my mz l na nb">Finished dev [unoptimized + debuginfo] target(s) in 0.00s<br/>     Running `target/debug/health-endpoint`<br/>Hello, world!</span></pre><p id="5528" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Easy-peezee，对吗？</p><p id="1c62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们启动并运行PostgreSQL实例。</p><h1 id="8335" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">运行PostgreSQL</h1><p id="ccdf" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在使用Docker Compose创建PostgreSQL实例之前，我们需要创建一个初始SQL脚本来创建数据库。让我们将下面的代码添加到项目根目录下名为<code class="fe lb lc ld le b">db</code>的目录中一个名为<code class="fe lb lc ld le b">init.sql</code>的SQL文件中。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3cbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个脚本将检查名为“member”的数据库是否已经存在，如果不存在，它将为我们创建数据库。接下来，让我们将下面的YAML复制到一个<code class="fe lb lc ld le b">docker-compose.yml</code>文件中并运行<code class="fe lb lc ld le b">docker compose up</code>。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="bbf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过一些丰富多彩的文字🌈在控制台窗口中，您应该已经启动并运行了PostgreSQL。</p><p id="4a37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在我们已经确认了我们的服务运行，并且我们有一个PostgreSQL实例在本地运行，让我们打开您最喜欢的<a class="ae kc" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">文本编辑器</strong> </a>或<a class="ae kc" href="https://www.jetbrains.com/idea/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> IDE </strong> </a>并将我们的项目依赖项添加到我们的<code class="fe lb lc ld le b">Cargo.toml</code>文件中。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fdea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe lb lc ld le b">sqlx</code>，我们希望确保在编译期间包含“postgres”特性，因此我们有PostgreSQL驱动程序来连接到我们的PostgreSQL数据库。接下来，我们要确保包含了<code class="fe lb lc ld le b">runtime-actix-native-tls</code>特性，这样sqlx就可以支持使用<a class="ae kc" href="https://tokio.rs/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> tokio </strong> </a> <em class="mi">运行时</em>的<code class="fe lb lc ld le b">actix-web</code>框架。最后，让我们包括<code class="fe lb lc ld le b">serde</code>和<code class="fe lb lc ld le b">serde_json</code>来序列化我们的健康检查API响应体，以便稍后在帖子中使用。</p><blockquote class="mj mk ml"><p id="887d" class="kd ke mi kf b kg kh ki kj kk kl km kn mm kp kq kr mn kt ku kv mo kx ky kz la ij bi translated"><strong class="kf ir">注:</strong>对于初来乍到的铁锈，你可能会在心里想，“管它呢？Actix运行时？我以为actix-web只是Rust的一个web框架。”是的，而且还不止这些。由于Rust的设计没有考虑任何特定的<a class="ae kc" href="https://en.wikipedia.org/wiki/Runtime_system" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">运行时</strong> </a>，所以您当前所处的问题领域需要一个特定的运行时。有专门用于处理客户机/服务器通信需求的运行时，例如<a class="ae kc" href="https://docs.rs/tokio/1.12.0/tokio/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Tokio </strong> </a>，这是一个流行的事件驱动的非阻塞I/O运行时。<a class="ae kc" href="https://docs.rs/actix/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Actix </strong> </a>，actix-web背后的底层运行时，是一个基于<a class="ae kc" href="https://en.wikipedia.org/wiki/Actor_model" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> actor的</strong> </a>消息传递框架，构建在tokio运行时之上。</p></blockquote><p id="cc99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，现在我们已经添加了依赖项，让我们继续创建我们的<code class="fe lb lc ld le b">actix-web</code>服务。为此，让我们用以下Rust代码替换<code class="fe lb lc ld le b">src/main.rs</code>文件中的内容:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9769" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码给了我们一个运行在端口<code class="fe lb lc ld le b">8080</code>上的HTTP服务器和一个总是返回<code class="fe lb lc ld le b">Ok</code> HTTP响应状态代码的<code class="fe lb lc ld le b">/health</code>端点。</p><p id="dc99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到您的终端，运行<code class="fe lb lc ld le b">cargo run</code>查看服务启动并运行。在一个新标签页中，继续运行<code class="fe lb lc ld le b">curl -i localhost:8080/health</code>并看到您收到如下响应:</p><pre class="mp mq mr ms gt mt le mu mv aw mw bi"><span id="d8cb" class="mx lg iq le b gy my mz l na nb">$ curl -i localhost:8080/health<br/>HTTP/1.1 200 OK<br/>content-length: 8<br/>content-type: application/json<br/>date: Wed, 22 Sep 2021 17:16:47 GMT</span><span id="7113" class="mx lg iq le b gy ne mz l na nb">Healthy!%</span></pre><p id="b40f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经启动并运行了基本的健康API端点，那么让我们更改健康API的行为，以便在到PostgreSQL数据库的连接处于活动状态时返回一个<code class="fe lb lc ld le b">Ok</code> HTTP响应状态代码。为此，我们首先需要使用<code class="fe lb lc ld le b">sqlx</code>建立一个数据库连接。</p><h1 id="bfbe" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建数据库连接</h1><p id="a711" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在使用sqlx的<a class="ae kc" href="https://docs.rs/sqlx/0.5.7/sqlx/postgres/struct.PgConnection.html#method.connect" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> connect </strong> </a>方法建立数据库连接之前，我们需要创建一个数据库连接字符串，格式为<code class="fe lb lc ld le b">&lt;database-type&gt;://&lt;user&gt;:&lt;password&gt;@&lt;db-host&gt;:&lt;db-port&gt;/&lt;db-name&gt;</code>，它与我们的本地PostgreSQL设置相匹配。</p><p id="7eac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，不要硬编码我们的数据库连接字符串，让我们通过一个名为<code class="fe lb lc ld le b">DATABASE_URL</code>的环境变量使<a class="ae kc" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">可配置</strong> </a>，并在我们的每个<code class="fe lb lc ld le b">cargo run</code>调用之前预先考虑该变量，如下所示:</p><pre class="mp mq mr ms gt mt le mu mv aw mw bi"><span id="892a" class="mx lg iq le b gy my mz l na nb">DATABASE_URL=postgres://root:postgres@localhost:5432/member?sslmode=disable cargo run</span></pre><p id="0323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了可用的<code class="fe lb lc ld le b">DATABASE_URL</code>环境变量，让我们在<code class="fe lb lc ld le b">main</code>函数中添加一行来获取新导出的环境变量。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fb34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们再写一些代码，在我们的<code class="fe lb lc ld le b">main</code>函数中创建一个数据库连接。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8d1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在将数据库连接传递给健康端点处理程序之前，我们首先需要创建一个代表服务共享可变状态的<code class="fe lb lc ld le b">struct</code>。Actix-web使我们能够在路由之间共享我们的数据库连接，这样我们就不会在每个请求上创建一个新的数据库连接，这是一个昂贵的操作，会降低我们服务的性能。</p><p id="e346" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这一点，我们需要创建一个Rust <code class="fe lb lc ld le b">struct</code>(在我们的<code class="fe lb lc ld le b">main</code>函数之上)，我们称之为包含我们的<code class="fe lb lc ld le b">db_conn</code>引用的<code class="fe lb lc ld le b">AppState</code>。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c252" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在我们的<code class="fe lb lc ld le b">db_conn</code>实例化下面，我们将创建一个AppState dat对象，它被包装在一个<code class="fe lb lc ld le b">web::Data</code>包装器中。<code class="fe lb lc ld le b">web::Data</code>包装器将允许我们在请求处理程序中访问AppState引用。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="542e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们将应用程序的<code class="fe lb lc ld le b">app_data</code>设置为我们克隆的<code class="fe lb lc ld le b">app_state</code>变量，并用<code class="fe lb lc ld le b">move</code>语句更新我们的<code class="fe lb lc ld le b">HttpServer::new</code>闭包。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="eac5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不克隆<code class="fe lb lc ld le b">app_state</code>变量，Rust会抱怨说<code class="fe lb lc ld le b">app_state</code>变量不是在我们的闭包里创建的，Rust也没有办法保证<code class="fe lb lc ld le b">app_state</code>在被调用时不会被破坏。关于这方面的更多信息，请查看<a class="ae kc" href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">铁锈所有权</strong> </a>和<a class="ae kc" href="https://hashrust.com/blog/moves-copies-and-clones-in-rust/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">复制特征</strong> </a>文档。</p><p id="8471" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们的服务代码应该如下所示:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8ff9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经将包含数据库连接的<code class="fe lb lc ld le b">app_state</code>对象传递到了<code class="fe lb lc ld le b">App</code>实例中，让我们继续更新<code class="fe lb lc ld le b">get_health_status</code>函数来检查我们的数据库连接是否有效。</p><h1 id="498e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">数据库连接检查</h1><p id="c12e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了从我们的<code class="fe lb lc ld le b">get_health_status</code>函数中捕获我们的<code class="fe lb lc ld le b">AppState</code>数据，我们需要给我们的<code class="fe lb lc ld le b">get_health_status</code>函数添加一个<code class="fe lb lc ld le b">Data&lt;AppState&gt;</code>参数。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b346" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们编写一个轻量级PostgreSQL查询，使用<code class="fe lb lc ld le b">SELECT 1</code>查询来检查我们的数据库连接。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9e03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们更新<code class="fe lb lc ld le b">HttpResponse</code>响应，当我们的数据库连接时返回一个<code class="fe lb lc ld le b">Ok</code>，当没有连接时返回<code class="fe lb lc ld le b">ServiceUnavailable</code>。同样，为了调试的目的，让我们包含一个比<code class="fe lb lc ld le b">healthy</code>或<code class="fe lb lc ld le b">not healthy</code>更有用的响应体，通过序列化一个Rust <code class="fe lb lc ld le b">struct</code>，使用<code class="fe lb lc ld le b">serde_json</code>，描述<em class="mi">为什么</em>我们的健康检查成功或失败。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="92e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们用<code class="fe lb lc ld le b">cargo run</code>命令运行我们的服务:</p><pre class="mp mq mr ms gt mt le mu mv aw mw bi"><span id="9e0e" class="mx lg iq le b gy my mz l na nb">DATABASE_URL=postgres://root:postgres@localhost:5432/member?sslmode=disable cargo run</span></pre><p id="2de4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，打开另一个终端选项卡，运行下面的<code class="fe lb lc ld le b">curl</code>命令:</p><pre class="mp mq mr ms gt mt le mu mv aw mw bi"><span id="2c32" class="mx lg iq le b gy my mz l na nb">curl -i localhost:8080/health</span></pre><p id="cc39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将返回以下响应:</p><pre class="mp mq mr ms gt mt le mu mv aw mw bi"><span id="ddc4" class="mx lg iq le b gy my mz l na nb">HTTP/1.1 200 OK<br/>content-length: 27<br/>content-type: application/json<br/>date: Tue, 12 Oct 2021 15:56:00 GMT</span><span id="4a7f" class="mx lg iq le b gy ne mz l na nb">{"database_connected":true}%</span></pre><p id="b621" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们通过<code class="fe lb lc ld le b">docker compose stop</code>关闭我们的数据库，那么两秒钟后，当您再次调用前面的<code class="fe lb lc ld le b">curl</code>命令时，您应该会看到一个<code class="fe lb lc ld le b">ServiceUnavailable</code> HTTP响应。</p><pre class="mp mq mr ms gt mt le mu mv aw mw bi"><span id="67be" class="mx lg iq le b gy my mz l na nb">HTTP/1.1 503 Service Unavailable<br/>content-length: 28<br/>content-type: application/json<br/>date: Tue, 12 Oct 2021 16:07:03 GMT</span><span id="c3be" class="mx lg iq le b gy ne mz l na nb">{"database_connected":false}%</span></pre><h1 id="779b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="a39e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我希望这篇博文可以作为实现健康检查API模式的有用指南。您可以将更多信息应用到您的<code class="fe lb lc ld le b">/health</code> API端点，例如，如果适用的话，当前用户的数量、缓存连接检查等。确保后端服务看起来“健康”所需的任何信息。这因服务而异。</p><p id="6fad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你愿意支持我成为一名作家，可以考虑注册成为一名灵媒。只要每月5美元，你就可以无限制地使用媒体。感谢你阅读我的博文！</p></div></div>    
</body>
</html>