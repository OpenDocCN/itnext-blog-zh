# 防止现有系统发生重大变化

> 原文：<https://itnext.io/how-to-safely-refactor-old-code-part-1-a1a853263fec?source=collection_archive---------2----------------------->

![](img/2b013b492d3b5de8a392677683e3b80d.png)

万圣节灯光表演软件

## 安全重构旧代码:第 1 部分

在这个系列中，我们一步步地回顾安全重构旧代码的概念设计模式。我编写本指南是为了适应任何类型的重构场景，示例项目是 Node.js with RxJS。

*这是一个三部曲系列的第一篇*

*   **[*第 1 部分:防止现有系统的突破性变化*](https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-1-a1a853263fec)**
*   **[*第二部分:不要只是重构，要让它具有可维护性*](https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-2-2d09451b4e8f)**
*   **[*第三部分:重构 AJAX 调用和可观察对象*](https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-3-f285a6200988)**

# **历史**

**去年我设计了一个万圣节智能灯项目，当孩子们来“不给糖就捣蛋”的时候，给我的房子增添一点闹鬼的气氛。**

**因为我想以 npm 包的形式发布这个项目，所以我需要为当前的库版本更新它，并使它看起来更好。仅仅一年时间，RxJS 和我的经验已经发生了很多变化，所以我需要做很多重构工作。**

**这个应用程序是关键任务。它必须在万圣节响起，而且只能在孩子们在的时候响起。如果做不到这一点，我们就完全失去了效果。**

# **第一步:单元测试**

**当进行重构时，首先需要确保不破坏或改变现有的功能。移动文件是一回事，但是升级软件包和更改代码会导致一些大的倒退。**

**你需要做的第一件事就是**为你现有的代码创建单元测试**。如果已经有了，可以跳过这一步；虽然，有可能那些旧的单元测试是缺乏的。首先**确保他们通过**。接下来，确保你现有的测试覆盖了你将要重构的领域。**

**在这个特定的项目中，我没有任何单元测试。这是一个快速的一次性项目，当时我完全不知道如何对 RxJS 进行单元测试。要添加单元测试，代码需要是可测试的。与大多数缺乏测试的项目一样，如果不进行一些小的重构，它们将完全不可测试。**

**作为一个目标，我需要针对当前的代码库编写单元测试，而不需要进行重大的架构更改。当我在一个工作的、单元测试的状态下提交了所有东西之后，我就可以开始真正的重构和升级库版本了。**

**虽然您可以完全跳过添加单元测试，直接进行重构，但您不可避免地会得到只有在真正的用户面前投入生产时才会崩溃的代码。更糟糕的是，您可能会错过甚至不知道在哪里的需求！在过去的项目中，我已经这样做了很多次，每次都因此而遭受痛苦。**

**虽然万圣节灯光项目简单得可笑，而且真的不需要所有这些开销，但我将使用它向您展示您在实际制作项目中会遇到的问题。**

# **添加单元测试**

**这是目前《守则》的要点:**

**我们不能围绕它编写单元测试，但是我们可以对我们的`filter`和`map`转换器中的所有单个功能进行单元测试。**

## **开始简单**

**先说`isHalloween`:**

**您可能会认为这个超级简单的布尔函数对于单元测试来说会很简单，但事实并非如此。基于今天的日期，我们不能让这个单元测试通过或失败；无论我们何时运行测试，它都需要保持一致。当单元测试这个函数时，我们需要能够传入一个日期，看看它是否正确地认为这个日期在万圣节之夜的范围内。**

**现在测试这段代码的唯一真正方法是等待万圣节的晚上，调用函数，希望它返回`true`。因为我们直接调用`moment`并且不传递日期，所以我们错过了单元测试的一个关键部分；纯粹的功能和再现性。**

**如你所见，我们不能对它进行单元测试。我们不得不重构功能来进行单元测试，即使重构的行为有可能破坏代码。**

## **尝试其他东西**

**这可能是一个孤立的问题，所以让我们看看是否有其他的东西可以进行单元测试:**

**我们没有传入`colorSets`，而是在`getColorSetAtIndex`和`getRandomColorSetIndex`中关闭了它，但是只有`getColorSetAtIndex`是可测试的。另一方面,`getRandomColorSetIndex`是不可能测试的，因为每次你调用它，函数都会返回不同的东西。**

**即使`getRandomColorSetIndex`本质上不是纯的，我们仍然可以尝试对它进行单元测试。它没有输入，所以我们只需要确保输出是我们的`colorSets`数组中的一个索引。如果我们运行这个函数 10-30 次，我们可以得到一个很好的随机数据样本，看看它是否返回我们想要的值。不过，我不建议在任何情况下这样做。它不包括边缘情况，可能只有*看起来*有效。**

**如果你对数据进行了采样并运行了大量的函数，你将会在测试代码的同时测试`Math.random`。你不希望在你的单元测试中测试别人的代码，也不希望你的测试工作不一致。抽样一堆随机数意味着你的测试可能会随机中断。**

**一个更好的想法是通过传递一个随机化函数而不是隐式依赖于`Math.random`来使函数变得纯粹。这样，你就可以绝对肯定它是如何处理你扔给它的任何数字的。这种类型的模仿被称为依赖注入，在我们没有纯函数的情况下是必要的。**

## **AJAX 函数**

**最后，我们将看看我们的 AJAX 方法:`doScaryLightFlash`和`getDataFromPromise`。**

**我们在`getCycles`中还有另一个`Math.random`，在`doScaryLightFlash`中有一个直接使用`fetch`的 AJAX 调用。因为我们自己没有使用依赖注入和传入`fetch`，所以我们没有办法模拟 AJAX 调用。**

**这就给我们留下了`getDataFromPromise`。这个功能完全可以测试！`fromPromise`是将一个承诺转化为一个可观察的承诺，所以只要我们模仿来自`fetch`的 AJAX 响应承诺，我们就可以测试它，没有问题。**

## **没有达到我们的目标**

**在我们的可观测链的 5 个函数中，我们只有 2 个可以进行单元测试。更糟糕的是，这两个不包含任何应用程序的核心业务逻辑。**

**我们的目标是通过首先编写单元测试来安全地进行重构，但是我们在这一过程中的每一步都被卡住了！对于一个相对简单的单进程应用程序，你会认为这将更容易重构。吸取教训。**

**由于核心业务逻辑在别处，我反对对这两个功能进行单元测试。坦白说，这是浪费时间。我们需要放眼全局，想出一种方法来测试我们的核心业务逻辑。**

**我们希望万圣节的时候灯光能做一个很酷的动画。我们只能确定代码去年有效。自从去年我升级了 Node.js、yarn 和 pm2，我真的不知道它是否还能像以前一样工作。**

**既然没有重构就无法进行单元测试，那就让我们进入第二步:**集成测试**。有了集成测试，我们应该能够编写某种可重复的测试，而不需要对现有的代码做太多的修改。**

# **添加集成测试**

**集成测试是对一组数据进行单元测试的一种方式。这些与端到端(E2E)测试的不同之处在于，我们不想在应用程序之外进行调用，也不应该依赖于副作用。**

**要进行任何类型的集成测试，我们都需要将我们的主要代码体包装在一个函数中，并传递给它 props。这些道具可以包括可观察对象本身和任何其他外部依赖性。**

**并不总是需要传递所有的依赖项。例如，我们不打算对 RxJS 管道操作符使用依赖注入，但是我们需要模拟像 AJAX 调用这样的副作用，否则它们是不可测试的。**

**正如我们已经看到的，这段代码有很多副作用，但是最重要的副作用是调用 LIFX HTTP API。只要我们能够捕获出站数据调用，我们就可以模拟响应并继续前进。**

**为了给这个项目编写一个有效的集成测试，我试图为破解 Node.js 想出一个好的模式。我希望当我们重构代码并正确测试大图功能时，它不会崩溃。**

**由于我们无法控制`fetch`函数，我们只能使用 DNS 代理和我们自己的 HTTP 服务器。我们可以改为修改`hosts`文件，但是我们需要在运行集成测试的任何时候这样做。不会发生的！**

## **未能添加集成测试**

**经过相当多的摆弄，让 DNS 代理工作，我决定不值得。它要求我有一个有效的 TLS 证书来伪造 HTTPS 的电话，更不用说集成测试文件膨胀的事实。如果没有现成的库，我首先必须编写一个集成测试库，测试它，然后在这个项目中使用它。不会吧。**

**我们还有一招绝招: **E2E 测试**！但是那些也不行。E2E 测试应该是自动化的。对于这个特殊的项目，需要在一个干净的房间里安装一组带有颜色传感器的 LIFX 灯。这就像为自动驾驶汽车编写软件来进行简单的 E2E 测试一样。就是不可行。**

**另一种方法是调用 AJAX 函数并检测灯光，以确定它们的当前状态是否与我们的颜色计算相匹配。这需要确保我们考虑到`Math.random`呼叫。这个想法也不会以任何可靠的方式起作用。**

# **可重复的手动 E2E 测试**

**我没有一个专门的 QA 人员负责这个项目，但我肯定可以编写可重复的测试，在我的命令下运行。手动部分是我需要亲自观察灯光，看它是否变化。虽然不理想，但这是唯一可行的解决方案。**

**对于这个应用程序来说，真的没有什么好的办法。据我们所知，它只在万圣节的时候才会发光，所以如果不注释掉`isHalloween`，很难测试。显然，注释掉万圣节检查并提交它会使它无论日期如何都会闪烁，所以我们需要做一点点重构，以便仅在运行我们的测试时从管道中移除`isHalloween`。**

**经过一点点非破坏性的重构，我们得到了一些可测试的东西:**

**`lifxHalloween.js`是我们新的索引文件。`isHalloween`已被移到它自己的文件中，`flashRandomLight`现在包含了我们可观察到的管道的大部分，减去了`isHalloween`检查。唯一真正的变化是创建了`flashRandomLight`函数。因为我们现在可以单独测试这个函数，所以这个重构是相当安全的。**

**因为我们已经注意到了`isHalloween`并且可观察链的其余部分需要一些重构来使其可测试，我们将不得不假设它如预期的那样工作。**

**由于每个人对使用哪个测试框架都有自己的看法，所以我暂时使用 Node.js 内置的断言库*。通常，我也会使用测试运行程序，但是在这种情况下，我们只测试一个文件，所以没问题。***

***我把它称为规范文件(集成和 E2E 测试)而不是测试文件(单元测试)。测试是针对单个模块应该如何工作，而规格是高层次的业务规格。***

***当它运行时，这个测试针对你的 LIFX 帐户中的一个特定的灯:你的配置文件中的灯，首先检查`false`的情况，然后检查`true`的情况。在这两种情况下，它将在运行测试后立即记录到控制台。这样，你就可以确定是哪种情况导致了光的触发。***

***但是对我来说，这一切都发生得太快了，所以我最终让测试变得复杂了一些，并将它们设置为相隔 2 秒钟运行。在这一点上，我很沮丧我用 Node.js 的断言库定制了这个，而不是使用一个更熟悉的测试框架。***

***好消息，代码工作了！现在我们有了一些既可重复又能确保重构时代码不被破坏的东西。***

# ***结论***

***尽早编写单元测试，或者至少编写易于测试的代码。通常，我没有时间进行单元测试，但是我已经确保编写我最近的代码，就好像我要对它进行单元测试一样。***

***一般来说，重构的时候，你需要需求。没有适当的业务需求的重构代码几乎总是会导致遗漏需求。否则，当业务部门告诉您在项目上花费的一个月没有解决他们想要的问题时，您将不得不最终做出重大的架构更改。它发生在我的一个同事身上；不要让它发生在你身上！确保你意识到你要改变的代码的所有含义，而不是假设业务需求。***

***想想如果你不得不重构这个项目。如果你不知道它会如何破裂，你愿意改变多少？***

***结帐 [**第二部分**](https://medium.com/@Sawtaytoes/how-to-safely-refactor-old-code-part-2-2d09451b4e8f) 我们开始重构的地方！***

# ***更多阅读***

***如果你喜欢你所读的，你也应该看看我关于智能家居和函数式编程的其他文章:***

*   ***[RxJS 和可观察的 Flic 按钮](https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407)***
*   ***[通过轻触按钮控制物联网设备](https://medium.com/flicblog/controlling-iot-devices-with-the-flic-of-a-button-1349c81bddef)***
*   ***[为什么 Linus Tech Tips 不理解智能灯泡](https://medium.com/@Sawtaytoes/why-linustechtips-doesnt-understand-smart-bulbs-1ceadfad8cf7)***
*   ***[使用带归约器的递归](/an-emoji-lovers-guide-to-functional-programming-part-6-5c1d441d36af)***
*   ***[把暴风雨的云变成晴朗的云](/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3)***