<html>
<head>
<title>Hot reloading native ES2015 modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">热重装原生ES2015模块</h1>
<blockquote>原文：<a href="https://itnext.io/hot-reloading-native-es2015-modules-dc54cd8cca01?source=collection_archive---------5-----------------------#2018-08-28">https://itnext.io/hot-reloading-native-es2015-modules-dc54cd8cca01?source=collection_archive---------5-----------------------#2018-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1e88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我的同事曾经讽刺地评论的那样，曾经有一段时间JavaScript只能在浏览器中工作，而现在它本质上是一种编译语言。现在，不要误解我，像webpack、rollup或package这样的工具给现代前端开发带来了巨大的优势。即使现在浏览器已经支持本地模块，你仍然应该捆绑你的代码用于生产。但是发展呢？JavaScript bundlers也改进了一些东西:我特别喜欢的一个改进是热重载。事实上，我非常喜欢它，所以我决定看看是否有可能使用原生ES2015模块实现类似的东西。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="306b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些不熟悉的人来说，热重装就是不用重装整个页面就能替换更新的模块。通常，整个系统包括:</p><ul class=""><li id="c3ff" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">文件监视器</li><li id="b98d" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">WebSocket或EventSource连接，通知客户端文件的更改</li><li id="979b" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">处理热更新的运行时代码。</li></ul><p id="fc48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在<a class="ae kl" href="https://webpack.js.org/concepts/hot-module-replacement/" rel="noopener ugc nofollow" target="_blank"> webpack </a>或<a class="ae kl" href="https://parceljs.org/hmr.html" rel="noopener ugc nofollow" target="_blank">package</a>文档中找到关于这个特性的内部和公共API的更多细节。对于本文，我将提供一个小例子:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="e0b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从<code class="fe lo lp lq lr b">text.mjs</code>模块中导入<code class="fe lo lp lq lr b">text</code>变量，并将其放入文件<code class="fe lo lp lq lr b">body</code>中。然后我们订阅<code class="fe lo lp lq lr b">text.mjs</code>更新，并保持正文与模块内容同步。</p><p id="8f9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将尝试在不捆绑的情况下为原生ES2015模块实现此功能。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="bbef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总有一天，<a class="ae kl" href="https://github.com/whatwg/loader" rel="noopener ugc nofollow" target="_blank"> WHATWG Loader规范</a>将会完成，并有望提供所有必要的API来轻松实现热模块替换。但是即使在今天，原生JavaScript模块也有一些有趣的属性，这在某些情况下是可能的。首先，导入是动态绑定:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="208d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，每次我们改变<code class="fe lo lp lq lr b">counter</code>，所有其他依赖于它的模块都接收新值，就好像<code class="fe lo lp lq lr b">counter</code>和<code class="fe lo lp lq lr b">increment</code>函数都在同一个模块中定义一样。</p><p id="194f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个属性，对重载部件很重要:模块名是URL，不同的URL被认为是不同的模块，即使它们最终解析为同一个文件。为了演示它，让我们稍微改变一下前面的例子:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="8cac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<code class="fe lo lp lq lr b">counter</code>现在是从不同的URL导入的，<code class="fe lo lp lq lr b">increment</code>调用不会改变它。<code class="fe lo lp lq lr b">counter.mjs</code>和<code class="fe lo lp lq lr b">counter.mjs?someQueryParameter</code>是两个独立的模块。如果我们在浏览器开发工具中查看网络选项卡，我们也会看到它们是两个不同的请求:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/f4e4fe1e0775b65fc8b0fa17f4edd6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*R6mgSQ2yDWcinXIoL_mOTA.png"/></div></figure><p id="6ddd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解了这一点，我们可以实现一个服务器，它将能够热重装ES2015模块，但有一些限制(见下文)。它将按以下方式工作:</p><ul class=""><li id="57c4" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">服务器将运行文件监视器和WebSocket端点。每次模块改变时，它将向所有连接的客户端广播改变的模块名称和修改时间。</li><li id="f0c6" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">在前端，我们将实现小型WebSocket客户端，这将允许我们订阅特定模块的更新。</li><li id="3585" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">在<code class="fe lo lp lq lr b">module.mjs?mtime=&lt;anything&gt; </code>航线下，我们将提供原始模块。</li><li id="0505" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">在<code class="fe lo lp lq lr b">module.mjs</code>下，我们将生成并提供具有自我更新能力的代理模块，而不是原始源代码:</li></ul><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lm ln l"/></div></figure><ol class=""><li id="ed5c" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk lv kz la lb bi translated">我们从原始模块导入每个导出的名称。</li><li id="99ba" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk lv kz la lb bi translated">我们将导入分配给模块局部变量。我们使用可变的<code class="fe lo lp lq lr b">let</code>绑定，这样我们可以在以后重新分配它们。</li><li id="304c" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk lv kz la lb bi translated">我们以原始名称导出模块局部变量。</li><li id="a20c" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk lv kz la lb bi translated">我们订阅原始模块更新通知。</li><li id="9ab5" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk lv kz la lb bi translated">每次我们收到更新，我们用一个新的<code class="fe lo lp lq lr b">mtime</code>查询参数重新导入模块。由于URL语义，这将导致浏览器加载更新的模块。</li><li id="1b86" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk lv kz la lb bi translated">我们将模块局部变量更新为我们在步骤5之后收到的值。</li></ol><p id="b71f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个代理模块是这种技术的核心思想。因为它具有相同的导出，并且在相同的URL下提供服务，所以它可以透明地替换原来的。由于ES2015模块的动态绑定特性，每个消费者都会自动收到代理模块导出的所有更新。</p><p id="480e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法也有两个局限性:</p><ol class=""><li id="2b4b" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk lv kz la lb bi translated">如果出口名称或编号发生变化，我们无法更新模块。在这种情况下，我们将退回到整页重载</li><li id="9bc9" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk lv kz la lb bi translated">如果原始模块导出可变绑定，就像在我们的<code class="fe lo lp lq lr b">counter</code>例子中，我们不能生成代理模块:因为我们将所有的导出重新分配给不同的变量，它们不能像在原始模块中那样正确地更新。因此，我们不会为这些模块生成代理，如果它们发生变化，我们会重新加载整个页面。</li></ol><p id="fc32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文还遗漏了一些东西:在最后一个演示中，有一个API对模块重载(<code class="fe lo lp lq lr b">accept</code>和<code class="fe lo lp lq lr b">dispose </code>回调)做出反应，更新通知传播到模块父节点，直到它们被处理。</p><p id="8e46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在我的<a class="ae kl" href="https://github.com/SevInf/heiss" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>找到源代码和演示，或者用这个<a class="ae kl" href="https://www.npmjs.com/package/heiss" rel="noopener ugc nofollow" target="_blank"> npm包</a>在你自己的代码上试试。让我知道你的想法。这种或任何类似的方法有任何前景吗？</p></div></div>    
</body>
</html>