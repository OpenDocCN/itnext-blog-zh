<html>
<head>
<title>Using Material Web Components within the neo.mjs application worker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在neo.mjs应用程序工作器中使用材料Web组件</h1>
<blockquote>原文：<a href="https://itnext.io/using-material-web-components-within-the-neo-mjs-application-worker-50d3790ea48?source=collection_archive---------1-----------------------#2021-08-13">https://itnext.io/using-material-web-components-within-the-neo-mjs-application-worker-50d3790ea48?source=collection_archive---------1-----------------------#2021-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a366" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a> JavaScript前端UI框架围绕着“应用工作者是主角”的概念。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/96ef3d303e22eaa8672ec908da913353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQEbjjK_ORkFNOLklWfRRA.png"/></div></div></figure><p id="1679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为你的应用程序，包括你的组件，存在于应用程序<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">工作器</a>中，一个经常出现的问题是:</p><p id="8329" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“我们可以在neo应用程序中使用外部Web组件吗？”</p><p id="c3fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个UI框架或库的主要目标都是动态操作DOM，所以答案是肯定的。</p><h1 id="091a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">内容</h1><ol class=""><li id="e00f" class="lw lx iq jp b jq ly ju lz jy ma kc mb kg mc kk md me mf mg bi translated">介绍</li><li id="77a5" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">简单的方法</li><li id="02b9" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">创建包装组件</li><li id="821f" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">我们如何获得按钮的点击事件？</li><li id="1d83" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">我们如何包含依赖项(库)？</li><li id="7dba" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">我们如何尊重不同的环境？</li><li id="eba2" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">创建textfield包装</li><li id="e5df" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">演示视频</li><li id="2441" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">源代码</li><li id="7317" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">在线演示</li><li id="9ab8" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">使用Web组件有意义吗？</li><li id="9b2c" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">最后的想法</li></ol><h1 id="e9b3" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">1.介绍</h1><p id="19a1" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我正在使用谷歌的材料网络组件:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/material-components/material-web" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">GitHub -材料-组件/材料-web:材料设计web组件</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">材料设计Web组件。通过创建一个关于…的帐户，为材料组件/材料网络的发展做出贡献</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kw ms"/></div></div></a></div><p id="a548" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们仍然是版本1 (v0.22.1)之前的版本，所以API可能会有一些变化。</p><p id="e108" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过，我们将要深入的概念适用于任何类型的web组件。</p><p id="3d3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于本文，我为button和textfield组件创建了包装器，我们可以将它们放入neo.mjs组件树中:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0da50aaae4b665b144eb86cd3d444ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*8An9EtZijCMiOwd3f7Nn_Q.png"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/dfba2159f80f294a93b10c4be343c706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*54kGnSsSv3gDgLEH24cYDg.png"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/f3fed1c0422161d5de304de099038514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*2BNw2zVDEXZ9t9kaqbI7KA.png"/></div></figure><h1 id="78a9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">2.简单的方法</h1><p id="fa1e" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">组件。Base有一个vdom(虚拟dom)配置，我们可以随意定制。我们可以将组件放入容器的项目配置中:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f90d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这在包含主线程依赖项(libs)的情况下已经很好了，但是动态地更改vdom属性或调用我们的web组件实例上的方法并不容易，这些实例位于主线程内部。</p><h1 id="4bf1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.创建包装组件</h1><p id="3795" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">更聪明的方法是创建一个新的neo组件类:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/component/mwc/Button.mjs" rel="noopener ugc nofollow" target="_blank">src/component/mwc/button . mjs</a></p><p id="6fc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用配置系统将定制类配置(字段)映射到web组件DOM属性:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3e27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果我们正在定义一个<code class="fe nm nn no np b">label_</code>配置，我们可以选择使用:</p><p id="b9f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nm nn no np b">beforeGetLabel(value)</code></p><p id="3804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nm nn no np b">beforeSetLabel(value, oldValue)</code></p><p id="6979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nm nn no np b">afterSetLabel(value, oldValue)</code></p><p id="fd76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组件。基地已经有了<code class="fe nm nn no np b">changeVdomRootKey()</code>的方法，所以我们需要做的就是:</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="b208" class="nu kz iq np b gy nv nw l nx ny"><em class="nz">/**<br/> * Triggered after the label config got changed.<br/> * </em><strong class="np ir"><em class="nz">@param </em></strong><em class="nz">{String} value<br/> * </em><strong class="np ir"><em class="nz">@param </em></strong><em class="nz">{String} oldValue<br/> * </em><strong class="np ir"><em class="nz">@protected<br/> </em></strong><em class="nz">*/<br/></em>afterSetLabel(value, oldValue) {<br/>    this.changeVdomRootKey('label', value);<br/>}</span></pre><p id="84c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以在创建新实例时直接使用我们的配置:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0d3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以在运行时动态地改变我们的配置:</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="540d" class="nu kz iq np b gy nv nw l nx ny">const myButton = Neo.create(MwcButton, {<br/>    label: 'foo'<br/>});</span><span id="0b2e" class="nu kz iq np b gy oa nw l nx ny">myButton.label = 'bar';</span><span id="7477" class="nu kz iq np b gy oa nw l nx ny">myButton.set({<br/>    icon : 'edit',<br/>    label: 'baz'<br/>});</span></pre><p id="91ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想一次改变多个配置，使用<code class="fe nm nn no np b">set()</code>是个好办法，因为这只会触发虚拟DOM引擎一次。</p><h1 id="ea96" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">4.我们如何获得按钮的点击事件？</h1><p id="8850" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我们的neo组件包装器位于应用程序工作器中，而我们的web组件位于主线程中。</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="7597" class="nu kz iq np b gy nv nw l nx ny">afterSetHandler(value, oldValue) {<br/>    if (value) {<br/>        let me           = this,<br/>            domListeners = me.domListeners;<br/><br/>        domListeners.push({click: value, scope: me});<br/>        me.domListeners = domListeners;<br/>    }<br/>}</span></pre><p id="d904" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用组件。基本的<code class="fe nm nn no np b">domListeners</code>配置并添加一个点击监听器。</p><p id="9b6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">引擎盖下</strong>(不要求遵循文章)</p><p id="b425" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个将在<code class="fe nm nn no np b">manager.DomEvents</code>中注册，它也位于app worker范围内。</p><p id="abd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，点击事件是全局的(一个监听器连接到<code class="fe nm nn no np b">document.body</code>，但是如果需要，我们可以添加一个<code class="fe nm nn no np b">local: true</code>配置。</p><p id="b499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个组件都有一个惟一的id，它也将应用于DOM，所以框架可以匹配它们。</p><p id="ee92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果点击事件发生在主线程内部，一个<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" rel="noopener ugc nofollow" target="_blank"> postMessage </a>将被发送到应用工作器。<code class="fe nm nn no np b">manager.DomEvents</code>现在可以匹配组件的DOM路径并相应地触发事件</p><p id="382a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">发动机罩下的末端</strong></p><p id="35fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以简单地使用我们的处理程序配置:</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="2275" class="nu kz iq np b gy nv nw l nx ny">handler: data =&gt; <strong class="np ir"><em class="nz">console</em></strong>.log('click', data.component.id)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ob"><img src="../Images/07bb110cf8b88396e803dc13fa1f0b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0L0C63pqYtjG_O1fVNdZQg.png"/></div></div></figure><h1 id="9e0d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">5.我们如何包含依赖项(库)？</h1><p id="0dc1" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">一种方法是将脚本标签添加到应用程序的index.html文件中，因为web组件必须位于一个主线程中。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bd52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过这并不是很好，因为我们希望在真正需要的时候延迟加载依赖项，并且我们希望每个环境有不同的版本。</p><p id="0cbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们确实想创建一个新的主线程插件:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/main/addon/Mwc.mjs" rel="noopener ugc nofollow" target="_blank">src/main/addon/mwc . mjs</a></p><p id="06be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在我们的<code class="fe nm nn no np b">neo-config.json</code>文件中包含主线程插件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5fce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到了我们的按钮类中的<code class="fe nm nn no np b">constructor</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个ctor调用将加载我们的谷歌MWC依赖异步，我们设置好了。</p><h1 id="3613" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">6.我们如何尊重不同的环境？</h1><p id="e248" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">这是我花了大部分时间处理的棘手部分。</p><div class="mp mq gp gr mr ms"><a href="https://github.com/material-components/material-web/tree/master/packages/textfield" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">材料-网络/包/主材料的文本字段-组件/材料-网络</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">重要提示:材料Web组件仍在开发中，在1.0版本发布之前可能会有重大更改。文本…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="oc l nd ne nf nb ng kw ms"/></div></div></a></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi od"><img src="../Images/005edfb21f6587540eada677a84e031f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQOSU1DoYGZnW_VKWU-rPQ.png"/></div></div></figure><p id="fce6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谷歌已经基于ES2017实现了他们的Web组件，这很好。</p><p id="ded9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">！！！但是！！！他们正在使用裸模块说明符，这真令人失望。</strong></p><p id="3638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">含义:导入语句是以浏览器无法理解的格式编写的。</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="097d" class="nu kz iq np b gy nv nw l nx ny">import {TextAreaCharCounter} from './mwc-textfield-base';</span></pre><p id="ee1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它大多只是缺少文件扩展名，有时没有真正的路径。</p><p id="2436" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您回头看看索引文件:我从CDN添加了模块，在这种情况下，所有“错误的”导入路径都被替换为URL。</p><p id="e829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法在没有任何构建/转换的浏览器中工作得非常好，这意味着:除了不完整的导入语句，代码是可以运行的。</p><p id="85fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将很快创建一个功能请求。</p><p id="d250" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在neo.mjs中，我们有3个不同的环境:</p><ol class=""><li id="2b65" class="lw lx iq jp b jq jr ju jv jy oe kc of kg og kk md me mf mg bi translated"><strong class="jp ir">开发</strong> <br/>直接在浏览器中运行，无需任何构建或编译</li><li id="5478" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><strong class="jp ir">dist/development</strong><br/><a class="ae kl" href="https://github.com/webpack/webpack" rel="noopener ugc nofollow" target="_blank">基于Webpack </a>使用源地图构建(这就是你在Angular或React中所说的开发模式)</li><li id="377a" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><strong class="jp ir">分销/生产</strong> <br/>基于缩小的webpack构建，不使用源地图</li></ol><p id="e7f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，我们希望以最好的方式支持所有3个env。现在让我们来看看插件的主线:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b09a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的dev env，我们必须坚持使用CDN。如果有JS模块驱动的输出，那就更好了。对于第一次页面加载，通过CDN加载库可能需要几秒钟的时间。</p><p id="b874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们确实需要告诉webpack忽略这个导入。</p><p id="7a6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe nm nn no np b">dist</code>环境，我们可以简单地安装节点模块，然后自己使用裸模块说明符。Webpack将相应地创建分割块。</p><p id="c3e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的主线程插件中的4个方法通过远程配置暴露给应用工作者。这样，我们可以在我们的应用程序工作范围内直接调用它们作为承诺。例如:</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="9143" class="nu kz iq np b gy nv nw l nx ny"><strong class="np ir"><em class="nz">Neo</em></strong>.<strong class="np ir"><em class="nz">main</em></strong>.<strong class="np ir"><em class="nz">addon</em></strong>.Mwc.loadButtonModule();</span></pre><h1 id="4d18" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">7.创建textfield包装</h1><p id="ba8e" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我们再次将组件配置映射到vdom顶级属性。我将跳过这一部分，专注于重要的部分。</p><p id="eceb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到完整的源代码:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/component/mwc/TextField.mjs" rel="noopener ugc nofollow" target="_blank">src/component/mwc/textfield . mjs</a></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="138e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">textfield在其API中提供了一些方法，比如<code class="fe nm nn no np b">checkValidity()</code>和<code class="fe nm nn no np b">reportValidity()</code>。</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="ce5f" class="nu kz iq np b gy nv nw l nx ny">checkValidity() {<br/>    return <strong class="np ir"><em class="nz">Neo</em></strong>.<strong class="np ir"><em class="nz">main</em></strong>.<strong class="np ir"><em class="nz">addon</em></strong>.Mwc.checkValidity(this.id);<br/>}</span></pre><p id="bf37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只是在我们的主线程插件中定义了这两个方法，并通过远程API将它们暴露给应用工作者:</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="c6bc" class="nu kz iq np b gy nv nw l nx ny">checkValidity(id) {<br/>    return <strong class="np ir"><em class="nz">document</em></strong>.getElementById(id).checkValidity();<br/>}</span></pre><p id="a554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于工人通信是异步的，我们需要触发该方法作为承诺。在我们基于组件的方法中，我们只是返回这个承诺。</p><p id="c94f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在textfield演示应用程序中，我使用了:</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="5a60" class="nu kz iq np b gy nv nw l nx ny">exampleComponent.checkValidity().then(value =&gt; <strong class="np ir"><em class="nz">console</em></strong>.log(value))</span></pre><p id="318c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以使用async &amp; await。</p><p id="8e65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们添加了一个<code class="fe nm nn no np b">input</code> <code class="fe nm nn no np b">domListener</code>，它被绑定到:</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="8fce" class="nu kz iq np b gy nv nw l nx ny">onInputValueChange(data) {<br/>    let me       = this,<br/>        value    = data.value,<br/>        oldValue = me.value;<br/><br/>    if (value !== oldValue) {<br/>        me.value = value;<br/>    }<br/>}</span></pre><p id="9bf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有变化，我们需要更新我们的<code class="fe nm nn no np b">value</code>配置来保持状态同步。</p><pre class="kn ko kp kq gt nq np nr ns aw nt bi"><span id="a5b6" class="nu kz iq np b gy nv nw l nx ny">afterSetValue(value, oldValue) {<br/>    let me = this;<br/><br/>    me.changeVdomRootKey('value', value);<br/><br/>    me.fire('change', {<br/>        component: me,<br/>        oldValue : oldValue,<br/>        value    : value<br/>    });<br/>}</span></pre><p id="5648" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还想触发一个基于应用工人的事件，其他组件或控制器可以订阅该事件。</p><p id="e5f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在其中一个演示中，我们可以使用neo textfield配置web组件字段的值。如果我们在web组件中输入:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b039" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这很容易做到。如果我们添加视图模型(<code class="fe nm nn no np b">model.Component</code>)和绑定，那就更简单了。</p><h1 id="e894" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">8.演示视频</h1><p id="56e4" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">这里是4个不同的演示应用程序的快速浏览。记录实例时，您可以直接在控制台内更改基于neo组件的配置。</p><p id="129b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在选项卡式按钮演示中，关注控制台日志:我们正在从DOM中移除空卡片(选项卡)，但是当向后导航时，neo组件id保持不变(相同的JS实例)。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oh nl l"/></div></figure><h1 id="2370" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">9.源代码</h1><p id="6f67" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">你可以在这里找到2个组件:<br/> <a class="ae kl" href="https://github.com/neomjs/neo/tree/dev/src/component/mwc" rel="noopener ugc nofollow" target="_blank"> src/component/mwc </a></p><p id="c7c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主线程附加:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/main/addon/Mwc.mjs" rel="noopener ugc nofollow" target="_blank">src/main/addon/mwc . mjs</a></p><p id="1e39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4个演示应用的代码:<br/> <a class="ae kl" href="https://github.com/neomjs/neo/tree/dev/examples/component/mwc" rel="noopener ugc nofollow" target="_blank">示例/组件/mwc </a></p><h1 id="53cc" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">10.在线演示</h1><div class="mp mq gp gr mr ms"><a href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/component/mwc/buttons/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">新MWC纽扣</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">编辑描述</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">neomjs.github.io</p></div></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/component/mwc/button/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">新MWC按钮</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">编辑描述</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">neomjs.github.io</p></div></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/component/mwc/textFields/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">新MWC文本字段</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">编辑描述</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">neomjs.github.io</p></div></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/component/mwc/textField/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">新MWC文本字段</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">编辑描述</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">neomjs.github.io</p></div></div></div></a></div><p id="d8ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以从URL中删除<code class="fe nm nn no np b">dist/production</code>来在dev模式下运行演示。虽然dist/prod可以在所有主流浏览器中运行，但开发模式仅限于Chromium和Safari Tech Preview。</p><h1 id="fe2d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">11.使用Web组件有意义吗？</h1><p id="5c82" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">这绝对是一个很大的权衡。</p><p id="89f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你使用不同的组件库，它们中的每一个都将自己创建基本的逻辑，并且这个逻辑不会被共享→导致一个更大的文件。</p><p id="f3e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您已经收集了大量的Web组件，那么本文的方法可以让您的应用程序在neo.mjs workers设置中运行，这是一个很大的性能提升。</p><p id="24fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，Web组件存在于主线程中。使用的基于neo的组件越多，性能提升越大(尽可能保持主线程空闲)。</p><p id="77df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Neo组件有能力<code class="fe nm nn no np b">mount()</code>和<code class="fe nm nn no np b">unmount()</code>他们的DOM。在基于<code class="fe nm nn no np b">TabContainer</code>的例子(视频)中，你会注意到我们点击一个按钮，得到一个类似id:1的日志。切换到第二个选项卡会删除DOM。向后导航并再次单击按钮logs id:1→这是同一个neo组件JS实例。</p><p id="88d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，对于Web组件来说，情况并非如此:每次我们重新挂载DOM时，都会创建新的JS实例。对于按钮或文本字段这样的简单组件来说，这没什么大不了的，但是想象一下缓冲网格或日历。</p><p id="e633" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nm nn no np b">layout.Card</code>(用在<code class="fe nm nn no np b">tab.Container</code>里面)有一个配置叫做:<code class="fe nm nn no np b">removeInactiveCards</code>。默认值为真:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/layout/Card.mjs#L52" rel="noopener ugc nofollow" target="_blank">src/layout/card . mjs # L52</a></p><p id="2fbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于使用Web组件的用例，您可以将此更改为<code class="fe nm nn no np b">false</code>。然而，这样你就有了一个更大的DOM标记。这不会影响布局性能，因为带有<code class="fe nm nn no np b">display: 'none'</code>的节点被排除在基于浏览器的布局/回流计算之外，但会影响内存使用。</p><p id="a6a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，框架中已经添加了很多小部件。例如，对于按钮和文本字段，您只需调整样式，使它们看起来“有质感”。</p><p id="839b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常欢迎您为新部件以及现有部件的新功能创建功能请求单:<br/> <a class="ae kl" href="https://github.com/neomjs/neo/issues" rel="noopener ugc nofollow" target="_blank"> neomjs/neo/issues </a></p><h1 id="ae3f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">12.最后的想法</h1><p id="72d2" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">到目前为止，我已经为button和textfield组件创建了包装器。显然，MWC图书馆里还有更多。</p><p id="97a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果您想在neo.mjs框架中看到更多的包装组件，或者您对这个主题不感兴趣，我希望得到您的反馈。</strong></p><p id="191f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">知道这一点尤其重要，因为我很可能会继续致力于内部小部件(如日历)，除非创建更多Web组件包装器的需求很大。</p><p id="842d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">读完这篇文章后，您肯定知道如何自己完成这项工作:欢迎您帮助为Google的MWC创建更多的包装器组件，或者建议/研究不同的Web组件库包装器。</p><p id="20a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在neo repo中找到更多令人惊叹的性能演示→在线示例:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">GitHub - neomjs/neo:应用工人驱动的前端框架</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序。不需要照顾一个…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="oi l nd ne nf nb ng kw ms"/></div></div></a></div><p id="514d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我强烈建议深入研究它们，因为并行使用多个CPU可以显著提升性能。</p><p id="09e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如有疑问和反馈，欢迎您加入Slack频道:</p><div class="mp mq gp gr mr ms"><a href="https://join.slack.com/t/neomjs/shared_invite/zt-6c50ueeu-3E1~M4T9xkNnb~M_prEEOA" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">在Slack上加入neo.mjs</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">我们知道切换浏览器很麻烦，但是我们希望你的Slack体验是快速、安全和最好的…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">join.slack.com</p></div></div><div class="nb l"><div class="oj l nd ne nf nb ng kw ms"/></div></div></a></div><p id="80e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最诚挚的问候&amp;快乐编码，<br/>托比亚斯</p></div></div>    
</body>
</html>