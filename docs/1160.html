<html>
<head>
<title>I’m making an offline first WordPress PWA, part 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我正在做一个离线的第一个WordPress PWA，第6部分</h1>
<blockquote>原文：<a href="https://itnext.io/im-making-an-offline-first-wordpress-pwa-part-6-1f4beea6e641?source=collection_archive---------5-----------------------#2018-08-01">https://itnext.io/im-making-an-offline-first-wordpress-pwa-part-6-1f4beea6e641?source=collection_archive---------5-----------------------#2018-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="45b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">单页应用程序</h2></div><p id="99a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该系列由以下部分组成:</p><blockquote class="lb lc ld"><p id="73c4" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-1-6ae90ea672a4">第一部分——HTTPS</a></p><p id="ae64" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-2-b313659bfc9c">第二部分——manifest . JSON</a></p><p id="f9c8" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-3-1ddf61891121">第3部分——带工具箱的服务人员</a></p><p id="685c" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-4-be2d06e6ff28">第4部分—应用外壳模型</a></p><p id="7664" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-5-e3293faefb88">第5部分—先离线</a></p><p id="0467" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-6-1f4beea6e641">第6部分——单页App </a>(本部分)</p><p id="c655" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/im-making-an-offline-first-wordpress-pwa-part-7-5d1ee68ec6bd">第7部分—优化</a></p></blockquote><p id="cbdb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在前一部分，我其实达到了我的目的，至少部分达到了。博客的首页离线工作，由于应用程序外壳模型和服务人员的缓存，几乎可以立即加载。</p><p id="21d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，换句话说，个人博客文章的页面需要改进。目前，它们的工作就像任何普通的页面一样，如果用户离线或网络连接不稳定，这就不好了。</p><p id="9d9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的第一个想法是按照我在头版上做的那样去做。服务器端呈现的模板将仅由占位符组成，这些占位符在客户端被替换为真实内容。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/bc146e118068d80eb3f202961331d0e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QuxBX5xkMjdgg_zsYyMb7w.png"/></div></div></figure><p id="f2b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我后来意识到这种方法没有任何好处。假设有两篇带有以下URL的博客文章:</p><pre class="lo lp lq lr gt lz lm ma mb aw mc bi"><span id="9d98" class="md me iq lm b gy mf mg l mh mi">/blog/hello-world/<br/>/blog/blog-post-1/</span></pre><p id="6023" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将这些保存在缓存中，就像首页一样，我可以将它添加到服务人员中:</p><pre class="lo lp lq lr gt lz lm ma mb aw mc bi"><span id="d0da" class="md me iq lm b gy mf mg l mh mi">workbox.routing.registerRoute(/\/blog\/.+/, workbox.strategies.staleWhileRevalidate());</span></pre><p id="56f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是服务人员会将这些博客帖子视为缓存中的两个不同对象。当然它们是不同的，但是根据应用外壳模型，它们应该共享相同的模板。缓存中应该有三个对象:</p><ol class=""><li id="6997" class="mj mk iq kh b ki kj kl km ko ml ks mm kw mn la mo mp mq mr bi translated">模板</li><li id="aa56" class="mj mk iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">第一篇博客文章的JSON数据</li><li id="846d" class="mj mk iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">第二篇博文的JSON数据</li></ol><p id="d7c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是客户端渲染的结果如下:</p><ol class=""><li id="dc3a" class="mj mk iq kh b ki kj kl km ko ml ks mm kw mn la mo mp mq mr bi translated">第一篇博客文章的HTML(占位符)</li><li id="a906" class="mj mk iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">第二篇博客文章的HTML(占位符)</li><li id="969f" class="mj mk iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">第一篇博客文章的JSON数据</li><li id="34fc" class="mj mk iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">第二篇博文的JSON数据</li></ol><p id="398f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是它在开发人员工具中的外观:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mx"><img src="../Images/eef60f46393aadd8616516c72dddcb74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17cWuFxqwWrvOnv_DcCMQQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">首页，两个博客帖子，一个标题图像，以及所有帖子和两个个人的JSON数据。</figcaption></figure><p id="2d3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我有两个选择，因为这没有意义:</p><ol class=""><li id="40e3" class="mj mk iq kh b ki kj kl km ko ml ks mm kw mn la mo mp mq mr bi translated">遵循我的原则，将单个博客帖子切换到常规的服务器端渲染。</li><li id="2fa5" class="mj mk iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">违背我的原则，完全押在客户端渲染上，用Vue组件做SPA(单页应用)。</li></ol><p id="69fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">违反了我的原则，我已经做了，所以我可以(和应该吗？)继续那样做。毕竟，这只是一个实验🤷🏼‍♂️</p><h2 id="fb4f" class="md me iq bd nc nd ne dn nf ng nh dp ni ko nj nk nl ks nm nn no kw np nq nr ns bi translated">SPA PWA</h2><p id="79d0" class="pw-post-body-paragraph kf kg iq kh b ki nt jr kk kl nu ju kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">我喜欢这些首字母缩略词让我感觉多么聪明！</p><p id="c7ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论如何，在Vue路由器的帮助下，我可以相当容易地将博客转换成SPA。</p><div class="ny nz gp gr oa ob"><a href="https://router.vuejs.org" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">简介| Vue路由器</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">Vue.js的官方路由器。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">router.vuejs.org</p></div></div><div class="ok l"><div class="ol l om on oo ok op lx ob"/></div></div></a></div><p id="f4b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不会详细说明它是如何工作的，但我可以简单描述一下它是如何制作的。</p><h2 id="1fc8" class="md me iq bd nc nd ne dn nf ng nh dp ni ko nj nk nl ks nm nn no kw np nq nr ns bi translated">index.php</h2><p id="4e71" class="pw-post-body-paragraph kf kg iq kh b ki nt jr kk kl nu ju kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">该文件或多或少只包含以下内容:</p><pre class="lo lp lq lr gt lz lm ma mb aw mc bi"><span id="49e8" class="md me iq lm b gy mf mg l mh mi">&lt;div id="app"&gt;<br/>  &lt;router-view&gt;&lt;/router-view&gt;<br/>&lt;/div&gt;</span></pre><p id="c38f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lj lk ll lm b">&lt;router-view&gt;</code>将被替换为当前路线应该显示的Vue组件。</p><h2 id="c15a" class="md me iq bd nc nd ne dn nf ng nh dp ni ko nj nk nl ks nm nn no kw np nq nr ns bi translated">app.js</h2><p id="e286" class="pw-post-body-paragraph kf kg iq kh b ki nt jr kk kl nu ju kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">这是所有活动发生的地方。最重要的事情发生在第8-17行之间。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="3001" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">组件<code class="fe lj lk ll lm b">index</code>应该显示在首页，当单个帖子被访问时，<code class="fe lj lk ll lm b">singlePostContainer</code>正在被使用。</p><p id="6711" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和以前一样，<code class="fe lj lk ll lm b">index</code>组件从JSON API用AJAX加载所有博客文章。<code class="fe lj lk ll lm b">singlePostContainer</code>做完全一样的事情，当然是为了一个帖子。</p><h2 id="ed97" class="md me iq bd nc nd ne dn nf ng nh dp ni ko nj nk nl ks nm nn no kw np nq nr ns bi translated">serviceworker.js</h2><p id="b281" class="pw-post-body-paragraph kf kg iq kh b ki nt jr kk kl nu ju kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">这种新的解决方案意味着服务人员需要在缓存中存储以下内容:</p><ol class=""><li id="4f57" class="mj mk iq kh b ki kj kl km ko ml ks mm kw mn la mo mp mq mr bi translated">首页的模板(根据应用外壳模型的“外壳”)</li><li id="6906" class="mj mk iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">CSS，JavaScript和图像。(JS文件负责大部分渲染工作)</li><li id="6e0b" class="mj mk iq kh b ki ms kl mt ko mu ks mv kw mw la mo mp mq mr bi translated">博客文章的JSON数据。</li></ol><p id="75c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lj lk ll lm b">serviceworker.js</code>已按以下方式更新:</p><pre class="lo lp lq lr gt lz lm ma mb aw mc bi"><span id="0181" class="md me iq lm b gy mf mg l mh mi">// The latest blog posts<br/>workbox.routing.registerRoute('/wp-json/wp/v2/posts', workbox.strategies.networkFirst());</span><span id="f5db" class="md me iq lm b gy os mg l mh mi">// A single blog post<br/>workbox.routing.registerRoute(/\/wp-json\/wp\/v2\/posts\/.+/, workbox.strategies.staleWhileRevalidate());</span></pre><p id="b180" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lj lk ll lm b">networkFirst()</code>策略是因为我希望用户总是能够获得所有最新博客文章的最新列表。如果用户离线，它们将作为后备从缓存中提供。</p><p id="eba8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单个博客帖子在发布后可能不会更新太多，所以这就是我对它们使用<code class="fe lj lk ll lm b">staleWhileRevalidate()</code>策略的原因。这意味着服务工作人员将从缓存中获取JSON数据，还会发出网络请求并在后台更新缓存。换句话说，博文会在第二次访问时立即加载。</p><p id="841d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还激活了WordPress插件<a class="ae li" href="https://wordpress.org/plugins/autoptimize/" rel="noopener ugc nofollow" target="_blank">自动优化</a>来优化CSS/JS文件。我已经向服务人员添加了以下内容，以便将这些文件缓存到:</p><pre class="lo lp lq lr gt lz lm ma mb aw mc bi"><span id="2427" class="md me iq lm b gy mf mg l mh mi">workbox.routing.registerRoute(/wp-content\/cache\/autoptimize\/.+/, workbox.strategies.cacheFirst());</span></pre><p id="a31a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这里使用<code class="fe lj lk ll lm b">cacheFirst()</code>策略，因为这些文件永远不会被更新。如果我对我的任何文件进行了更改，自动优化将为优化后的文件赋予一个全新且唯一的名称(见下面的截图)。</p><p id="d198" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是所有更改后缓存的样子:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ot"><img src="../Images/b4220e87776024923463289ef076ea5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PZEXrHhJUldL6WTwYGW8g.png"/></div></div></figure><p id="1f09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，它包含一个HTML文件、几个CSS/JS文件、一个标题图像和JSON数据。一旦新的自动优化文件被存储，删除旧的自动优化文件当然很好，但那是另一次冒险。</p><p id="e5d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的服务人员如下所示:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="eb66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是这个系列的最后一部分吗？我的目标现在完全实现了:博客是一个离线工作的PWA！但是仍然有一些可以调整的地方。Developer tools中的性能审计给出了以下分数，这不是很讨人喜欢:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ou"><img src="../Images/e69b204963d6515471e2700bcb7a30a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uE7G8IhIfhM65f6Sa1dqMQ.png"/></div></div></figure><p id="5e58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你像我一样，经常用#perfmatters这样的标签发微博，这个项目就不会这样结束。所以我想我会在第7部分见到你！</p></div></div>    
</body>
</html>