<html>
<head>
<title>React and Flask Full Stack Web app: Component-oriented and Data-driven</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和Flask全栈Web app:面向组件和数据驱动</h1>
<blockquote>原文：<a href="https://itnext.io/react-and-flask-full-stack-web-app-component-oriented-and-data-driven-dd60e005266?source=collection_archive---------1-----------------------#2019-01-03">https://itnext.io/react-and-flask-full-stack-web-app-component-oriented-and-data-driven-dd60e005266?source=collection_archive---------1-----------------------#2019-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aa2d3321190e5274519ad1aabef14997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFEIw5lJ2boG3GyieNubAw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图1 </strong>:拼图:以逻辑的方式将碎片拼在一起，以得出正确的答案</figcaption></figure><p id="c3e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">软件开发最根本的问题是复杂性。只有一种处理复杂性的基本方法。打败他们的细节:分而治之的策略。查看各个部分，确定如何控制各个部分，制造纠纷并加以利用。</p><p id="5bac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看到如何使我们的web应用程序<strong class="kf ir">面向组件</strong>和<strong class="kf ir">数据驱动</strong>。我们将从第1部分继续，在那里我们学习了如何用flask、NPM、Webpack和Reactjs构建一个全栈web应用程序。</p><blockquote class="lc ld le"><p id="853c" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">你可以在这里获得我们在第1部分<a class="ae lb" href="https://github.com/Eyongkevin/hello_template" rel="noopener ugc nofollow" target="_blank">中构建的项目代码。请克隆它并按照<strong class="kf ir">自述文件</strong>的说明启动并运行它。这个博客将会详细介绍这个GitHub链接</a><a class="ae lb" href="https://github.com/Eyongkevin/React-and-Flask-Full-Stack-Web-app-Component-oriented-and-Data-driven" rel="noopener ugc nofollow" target="_blank">中的实现。然而，如果你跟随这篇博文，你会收获更多。</a></p></blockquote><h2 id="c778" class="lj lk iq bd kc ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">案例研究:创建我们的媒体文章</h2><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/9c43e9243fe781804984406232224a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUNxLzDbS4hFN9qxj3FwEg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图2 </strong>:显示文章图像、点击次数、文章标题、文章描述、作者图像和作者姓名的媒体文章</figcaption></figure><p id="03c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的目的是向您展示如何在React-Flask web应用程序中使用面向组件和数据驱动的概念。</p><p id="4e43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将构建这个简单的中型文章web应用程序，它只显示文章列表，包括<strong class="kf ir">文章图片、<br/>点击次数、文章标题、文章描述、作者图片</strong>和<strong class="kf ir">作者姓名。</strong></p><p id="35e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的web应用程序由三个组件组成:<strong class="kf ir">标题组件、文章列表组件</strong>和<strong class="kf ir">文章组件</strong> t。我们将浏览每个组件，并将一起构建它。然而，让我们首先刷新一下组件到底是什么。</p><h2 id="e355" class="lj lk iq bd kc ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated"><strong class="ak">什么是组件？</strong></h2><p id="f890" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">React组件是一个带有render方法的JavaScript类，该方法返回组件UI的描述。因此，基本上，组件是自包含的、特定于关注点的，并且是React UIs的构建块。</p><p id="9b4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React应用程序中，一切都是由组件组成的。使用组件开发应用程序允许一种“<strong class="kf ir">分而治之</strong>”的方法，其中没有特定的部分需要特别复杂。这使得用较小的组件创建复杂的、功能更丰富的组件变得容易。</p><p id="9d10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React组件具有一些优点，包括:</p><ul class=""><li id="b7a4" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">鼓励关注点分离</li><li id="d429" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">可重复使用的</li><li id="8139" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">它是用普通的javaScript编写的，而不是传统上用于web应用程序ui的模板语言或HTML指令。这使得React能够使用全功能编程语言来呈现视图，这对于构建抽象的能力来说是一个很大的优势。</li></ul><p id="2b0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">声明React组件有两种方式:</p><ol class=""><li id="f8ed" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mz mr ms mt bi translated"><strong class="kf ir">为ES6类</strong></li></ol><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="4246" class="lj lk iq nb b gy nf ng l nh ni">class HelloWorld extends React.Component{<br/> render(){<br/>  return(<br/>   &lt;p&gt; Hello World &lt;/p&gt;<br/>  );<br/> }<br/>}</span></pre><blockquote class="lc ld le"><p id="fae6" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">ES6引入了类声明语法。ES6类是JavaScript基于原型的继承模型的语法糖。<br/>你可以从MDN 上的<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank">文档中阅读更多关于ES6类的内容</a></p></blockquote><p id="8f7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2。使用React.createClass()方法</strong></p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="d1d8" class="lj lk iq nb b gy nf ng l nh ni">const HelloWorld = React.createClass({<br/>    render(){ return(&lt;p&gt; Hello World &lt;/p&gt;)}})</span></pre><blockquote class="lc ld le"><p id="bad5" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">如果您对JavaScript有所了解，您会注意到<strong class="kf ir">返回值</strong>的语法看起来不像传统的JavaScript。是脸书写的<strong class="kf ir"> JSX </strong> (JavaScript扩展语法)。使用JSX使我们能够以熟悉的、类似HTML的语法为组件视图编写标记。最后，这段JSX代码编译成普通的javaScript。</p></blockquote><h2 id="6da0" class="lj lk iq bd kc ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">我们的组件层次结构</h2><p id="3fa5" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如前所述，我们的应用程序将包含3个组件。下面是我们组件的层次结构。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8f13212ad2b0b6a4f7098573234d70f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*MmYBeejKvtW8LVaFc3ZBLw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图3 </strong>:我们3个组件的层次结构</figcaption></figure><p id="c473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们将应用程序的接口分成不同的组件类:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/ab09e1bbf5cd56859f065a2076bd48ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqMdF08mgggx3LkomoFB_A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图4 </strong>:我们的应用程序接口分解成不同的组件类</figcaption></figure><p id="5c91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的<strong class="kf ir">图4 </strong>中，我们看到三种不同的颜色代表我们不同的组件。</p><ul class=""><li id="1912" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">红色代表<strong class="kf ir">物品清单组件</strong>。该组件是父组件。</li><li id="4750" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">蓝色代表将显示页面主标题的<strong class="kf ir">标题组件</strong>。</li><li id="529c" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">金黄色代表将显示文章的<strong class="kf ir">文章组件</strong>。</li></ul><blockquote class="lc ld le"><p id="0f2c" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><strong class="kf ir"> <em class="iq">我觉得越来越无聊了</em> </strong>。重复和理论到此为止。让我们编码。</p></blockquote><p id="535e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">物品组件</strong></p><p id="239b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建文件<code class="fe nk nl nm nb b"><em class="lf">hello_template/templates/static/js/components/Article.jsx </em></code>并输入下面的代码</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a512" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">语义UI和图片:</strong>你会从上面的代码中注意到一些事情。图像的<strong class="kf ir">造型</strong>和<strong class="kf ir">来源</strong>。我使用语义用户界面的风格。您可以按如下方式安装该库:</p><p id="d336" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 1。</strong>安装来自<a class="ae lb" href="https://www.npmjs.com/package/semantic-ui" rel="noopener ugc nofollow" target="_blank"> npm </a>的语义UI React或遵循<a class="ae lb" href="https://www.npmjs.com/package/semantic-ui" rel="noopener ugc nofollow" target="_blank">文档</a>。语义UI React为我们的组件提供了JavaScript</p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="f1a8" class="lj lk iq nb b gy nf ng l nh ni">$ npm i semantic-ui-react --save</span></pre><p id="333c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2。</strong>在你的<code class="fe nk nl nm nb b"><em class="lf">hello_template/templates/static/</em>index.html</code>文件中添加语义UI CDN链接</p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="461e" class="lj lk iq nb b gy nf ng l nh ni">&lt;link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.3.1/semantic.min.css"&gt;&lt;/link&gt;</span></pre><blockquote class="lc ld le"><p id="0d8c" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><strong class="kf ir">注意</strong>:我们要用<code class="fe nk nl nm nb b">npm</code>做的每一个安装都应该在<code class="fe nk nl nm nb b">package.json</code>所在的<code class="fe nk nl nm nb b">hello_template/templates/static/</code>目录下打开的终端上。</p><p id="a48e" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">我们的<code class="fe nk nl nm nb b"><em class="iq">Article.jsx</em></code> <em class="iq">引用的是</em> <code class="fe nk nl nm nb b"><em class="iq">public/images/article/</em></code> <em class="iq">和</em> <code class="fe nk nl nm nb b"><em class="iq">public/images/avatars/</em></code> <em class="iq">的图像。您可以在此</em>  <em class="iq">从已完成的项目Github </em> <a class="ae lb" href="https://github.com/Eyongkevin/React-and-Flask-Full-Stack-Web-app-Component-oriented-and-Data-driven/tree/master/templates/public/images" rel="noopener ugc nofollow" target="_blank"> <em class="iq">下载图片文件夹，并将其包含在</em> <code class="fe nk nl nm nb b"><em class="iq">hello_template/templates/public/</em></code> <em class="iq">目录下</em> <strong class="kf ir"> <em class="iq">或</em> </strong> <em class="iq">您可以提供自己的图片。</em></a></p></blockquote><p id="77bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">运行物品组件</strong></p><p id="313e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们运行我们的组件，看看是否一切正常。因为我们的web应用程序是flask-react web应用程序，所以flask的一个经验法则是，我们对应用程序的不同上下文有不同的视图。我们仍然可以使用相同的视图。但是我决定把它们分开，这样可以保持我的作品的整洁和易于维护。所以我们有两件事要编辑。我们的视野和路线。</p><p id="413c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">视图:视图是flask特有的，使我们能够控制如何与web请求交互。创建目录<code class="fe nk nl nm nb b">hello_template/templates/medium_articles/</code>。在这个目录中，创建两个文件<code class="fe nk nl nm nb b">__init__.py</code>和<code class="fe nk nl nm nb b">views.py</code>。在<code class="fe nk nl nm nb b">views.py</code>文件中，输入以下代码</p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="7ae9" class="lj lk iq nb b gy nf ng l nh ni">from flask import render_template, Blueprint<br/>medium_blueprint = Blueprint('medium_article',__name__)</span><span id="08f9" class="lj lk iq nb b gy np ng l nh ni"><a class="ae lb" href="http://twitter.com/medium_blueprint" rel="noopener ugc nofollow" target="_blank">@medium_blueprint</a>.route('/articlelist')<br/>def index():<br/> return render_template("index.html")</span></pre><blockquote class="lc ld le"><p id="a9d9" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">在这段代码以及本文的任何其他代码中，确保在适当的地方缩进代码</p></blockquote><p id="eb8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的代码做两件重要的事情</p><ul class=""><li id="a53a" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">它为我们的媒体文章创建了一个蓝图</li><li id="0a21" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">它监听URL <code class="fe nk nl nm nb b">‘/articlelist’</code>并呈现位于<code class="fe nk nl nm nb b">hello_template/templates/</code>目录中的模板文件<code class="fe nk nl nm nb b">index.html</code></li></ul><blockquote class="lc ld le"><p id="29b2" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">我在第一部分解释了蓝图。</p></blockquote><p id="4b26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，是注册我们的蓝图。编辑<code class="fe nk nl nm nb b">hello_template/templates/__init__.py</code>文件如下:</p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="360c" class="lj lk iq nb b gy nf ng l nh ni">from flask import Flask<br/>app = Flask(__name__,<br/>  static_folder = './public',<br/>  template_folder="./static")</span><span id="6bda" class="lj lk iq nb b gy np ng l nh ni">from templates.hello.views import hello_blueprint<br/><strong class="nb ir">from templates.medium_articles.views import medium_blueprint</strong><br/># register the blueprints<br/>app.register_blueprint(hello_blueprint)<br/><strong class="nb ir">app.register_blueprint(medium_blueprint)</strong></span></pre><p id="6e5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> React路由器</strong> : React路由器是向React应用程序添加路由的最流行的解决方案。</p><blockquote class="lc ld le"><p id="42d9" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">请参考<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/a-template-for-creating-a-full-stack-web-application-with-flask-npm-webpack-and-reactjs-be2294b111bd">第1部分</a>了解关于React路由器及其安装的详细说明。此外，如果您按照建议从第1部分的项目开始工作，那么React路由器已经安装好了</p></blockquote><p id="b67c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编辑<code class="fe nk nl nm nb b">hello_template/templates/static/js/routes.js</code>文件如下:</p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="2c3d" class="lj lk iq nb b gy nf ng l nh ni">import React from 'react';<br/>import { HashRouter, Route, hashHistory } from 'react-router-dom';<br/>import Home from './components/Home';<br/><strong class="nb ir">import ArticleList from './components/ArticleList';</strong></span><span id="03d2" class="lj lk iq nb b gy np ng l nh ni">// import more components</span><span id="19ef" class="lj lk iq nb b gy np ng l nh ni">//The exact param disables the partial matching for a route and makes sure that it only<br/>// returns the route if the path is an EXACT match to the current url.<br/>export default (<br/>    &lt;HashRouter history={hashHistory}&gt;<br/>     &lt;div&gt;<br/>      &lt;Route exact path='/' component={Home} /&gt;<br/>      <strong class="nb ir">&lt;Route  path='/articlelist' component={ArticleList} /&gt;</strong><br/>     &lt;/div&gt;<br/>    &lt;/HashRouter&gt;<br/>);</span></pre><p id="7ae4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据上面的代码，我们做了两件事:</p><ul class=""><li id="f93f" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">我们导入了文章列表组件</li><li id="c85d" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">我们提供了组件的路由路径。</li></ul><p id="32f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">物品列表组件</strong></p><p id="f6d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经注意到在我们上面的代码中，我们使用了articlelist而不是article。这是因为我们的文章组件将包含在文章列表组件中。</p><p id="7f04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将编写文章列表组件。创建文件<code class="fe nk nl nm nb b"><em class="lf">hello_template/templates/static/js/components/ArticleList.jsx</em></code> <em class="lf">并在其中输入以下代码:</em></p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="85b6" class="lj lk iq nb b gy nf ng l nh ni">import React, { Component } from 'react';<br/>import Article from './Article';</span><span id="6721" class="lj lk iq nb b gy np ng l nh ni">export default class ArticleList extends Component {<br/>    render() {<br/>       return (<br/>          &lt;div className='ui unstackable items'&gt;<br/>             &lt;Article /&gt;<br/>          &lt;/div&gt;</span><span id="1735" class="lj lk iq nb b gy np ng l nh ni">)<br/>    }<br/>}</span></pre><p id="3236" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从上面的代码中注意到两件事</p><ul class=""><li id="fd05" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">我们导入了文章组件</li><li id="79ca" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">我们在文章列表组件中调用了文章组件。因此，ArticleList组件现在是Article组件的父组件</li></ul><p id="d0d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">运行</strong></p><p id="1423" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按照<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/a-template-for-creating-a-full-stack-web-application-with-flask-npm-webpack-and-reactjs-be2294b111bd">第一部分</a>中<strong class="kf ir">运行应用</strong>下的说明启动并运行项目，然后在你最喜欢的浏览器中打开这个地址<code class="fe nk nl nm nb b"><a class="ae lb" href="http://127.0.0.1:5000/#/articlelist/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/#/articlelist/</a></code>。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/88f4f0a8667ee444547dd21b354e99ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BiKKKXhLY68VvGTRBpJLSw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图5 </strong>:我们在Firefox网络浏览器上运行的网络应用程序显示了一篇文章</figcaption></figure><h2 id="0f0c" class="lj lk iq bd kc ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">使文章数据驱动</h2><p id="cc8f" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">到目前为止，我们用不太理想的数据对文章组件进行了硬编码。因此，我们需要我们的文章组件根据我们给它的数据动态呈现。</p><p id="04b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建文件<code class="fe nk nl nm nb b">hello_template/templates/static/js/articleData.js</code>并在其中输入代码:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9593" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe nk nl nm nb b">articleData.js</code>包含一个JavaScript对象<code class="fe nk nl nm nb b">articleData.article</code>，这是一个JavaScript对象数组，每个对象代表一个文章对象。每件物品都有一个独特的<code class="fe nk nl nm nb b">id</code>和一些属性，包括<code class="fe nk nl nm nb b">title</code>、<code class="fe nk nl nm nb b">description</code>、<code class="fe nk nl nm nb b">clapps</code>等等。</p><p id="5df3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">使用道具</strong></p><p id="821f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望我们的文章组件不再使用静态的、硬编码的属性。相反，我们希望它能够接受从其父级ArticleList传下来的数据。以这种方式设置我们的组件结构使我们的ArticleList组件能够动态呈现任意数量的文章组件，每个组件都有自己独特的属性。数据流将如下所示:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/047d2475e9af2022edab2509401e6034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*iQ1e9fV42ebFT-wwsJhZew.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图6 </strong>:从父到子的数据流</figcaption></figure><p id="7d19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React through props中，数据从父节点流向子节点。当一个家长渲染一个孩子时，它可以发送孩子所依赖的道具。我们可以像this.props一样在子组件中访问这些属性</p><p id="15d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看实际情况。让我们修改文章列表，将道具传递给文章组件。让我们从<code class="fe nk nl nm nb b">articleData.article</code>数组中取出第一个对象，并将其用作一篇文章的数据。让我们修改<code class="fe nk nl nm nb b"><em class="lf">hello_template/templates/static/js/components/ArticleList.jsx</em></code></p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="9947" class="lj lk iq nb b gy nf ng l nh ni">import React, { Component } from 'react';<br/>import Article from './Article';<br/><strong class="nb ir">import articleData from '../articleData'</strong></span><span id="b99e" class="lj lk iq nb b gy np ng l nh ni">export default class ArticleList extends Component {<br/>    render() {<br/>       <strong class="nb ir">const article = articleData.article[0];</strong><br/>       return (<br/>          &lt;div className='ui unstackable items'&gt;<br/>  &lt;Article  <strong class="nb ir">article={article}</strong>/&gt;<br/> &lt;/div&gt;</span><span id="b6aa" class="lj lk iq nb b gy np ng l nh ni">)<br/>    }<br/>}</span></pre><p id="d8e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的代码中，我们导入了我们的<code class="fe nk nl nm nb b">articleData.js</code>，然后我们从articleData.article数组中取出了第一个对象，然后我们将它作为prop传递给我们的article组件。</p><p id="3942" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们修改Article组件来访问父组件(ArticleList)发送的属性</p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="de0f" class="lj lk iq nb b gy nf ng l nh ni">import React, { Component } from 'react';</span><span id="5b3b" class="lj lk iq nb b gy np ng l nh ni">export default class Article extends Component {<br/>    render() {<br/> <strong class="nb ir">const {article} = this.props</strong><br/>       return (<br/>          &lt;div className='item'&gt;<br/>  &lt;div className='image'&gt;<br/>   &lt;img src=<strong class="nb ir">{article.productImageUrl}</strong> /&gt;<br/>  &lt;/div&gt;<br/>  &lt;div className='middle aligned content'&gt;<br/>   &lt;div className='header'&gt;<br/>   &lt;i className='large caret up icon' /&gt;<br/>   &lt;b&gt;<strong class="nb ir">{article.clapps}</strong>&lt;/b&gt;<br/>   &lt;/div&gt;<br/>   &lt;div className='description'&gt;<br/>    &lt;a href=<strong class="nb ir">{article.url}</strong>&gt;<strong class="nb ir">{article.title}</strong>&lt;/a&gt;<br/>    &lt;p&gt;<strong class="nb ir">{article.description}</strong>&lt;/p&gt;<br/>   &lt;/div&gt;<br/>   &lt;div className='extra'&gt;<br/>    &lt;span&gt;Published by: &lt;/span&gt;<br/>    &lt;img className='ui avatar image'    src=<strong class="nb ir">{article.submitterAvatarUrl}</strong> /&gt;<br/>    &lt;span className='author'&gt;<strong class="nb ir">{article.author}</strong> &lt;/span&gt;<br/>   &lt;/div&gt;<br/>  &lt;/div&gt;<br/> &lt;/div&gt;</span><span id="3c7a" class="lj lk iq nb b gy np ng l nh ni">)<br/>    }<br/>}</span></pre><blockquote class="lc ld le"><p id="8fe0" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">从上面的代码中，我们用<code class="fe nk nl nm nb b">this.props</code>访问文章道具，然后我们用作为道具接收的数据替换所有硬编码的静态数据</p></blockquote><p id="0766" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果刷新浏览器，您将看到没有任何变化。然而，我们的应用程序现在是数据驱动的。</p><p id="ce4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">渲染多条</strong></p><p id="318d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你注意到了，我们的<code class="fe nk nl nm nb b">articleData.js</code>有3个文章对象。它可能会更多，我们想展示所有的文章。我们将让ArticleList生成一组文章组件。每个都将从articleData数组中的单个对象派生。我们将使用<a class="ae lb" href="https://medium.com/@tonyparkerkenz/javascript-array-prototype-map-b95e245f43c1" rel="noopener">地图</a>来做到这一点。让我们修改一下我们的<code class="fe nk nl nm nb b"><em class="lf">hello_template/templates/static/js/components/ArticleList.jsx</em></code></p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="9430" class="lj lk iq nb b gy nf ng l nh ni">import React, { Component } from 'react';<br/>import Article from './Article';<br/>import articleData from '../articleData'</span><span id="6d8c" class="lj lk iq nb b gy np ng l nh ni">export default class ArticleList extends Component {<br/>    render() {<br/><strong class="nb ir">       const articleSort = articleData.article.sort((a,b)=&gt;(<br/>  b.clapps - a.clapps));<br/> const articleCom = articleSort.map((a)=&gt;(<br/>  &lt;Article key={'article-'+a.id} article={a} /&gt;</strong><br/>  )<br/> );<br/>       return (<br/>          &lt;div className='ui unstackable items'&gt;<br/>               <strong class="nb ir">{articleCom}</strong><br/>          &lt;/div&gt;</span><span id="b6d4" class="lj lk iq nb b gy np ng l nh ni">)<br/>    }<br/>}</span></pre><p id="23bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的代码中，我们首先根据鼓掌次数对文章进行排序。然后，我们使用<a class="ae lb" href="https://medium.com/@tonyparkerkenz/javascript-array-prototype-map-b95e245f43c1" rel="noopener"> map </a>创建每个文章组件对象，将它们各自从articleData数组派生的对象作为道具传递。所以我们的<a class="ae lb" href="https://medium.com/@tonyparkerkenz/javascript-array-prototype-map-b95e245f43c1" rel="noopener">映射</a>将返回一个商品组件数组，按照映射的要求，每个数组对象需要有一个惟一的键。所以这里我们使用每个文章对象id作为键。</p><p id="2fc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，刷新浏览器，您将看到所有三篇文章显示</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/7e249a787c40261f29e8e3548fc86d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHJdbXQlYAn-VnNVNElfbg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">图7 </strong>:我们的web应用程序显示所有三篇文章</figcaption></figure><p id="cb49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">割台组件</strong></p><p id="18af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列表中的最后一个组件是标题组件。这将在页面顶部显示标题。创建文件<code class="fe nk nl nm nb b"><em class="lf">hello_template/templates/static/js/components/Header.jsx</em></code>，并在其中粘贴以下代码:</p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="b912" class="lj lk iq nb b gy nf ng l nh ni">import React, { Component } from 'react';<br/> export default class Header extends Component {<br/>  render() {<br/>    return (<br/> &lt;div className='header-page'&gt;<br/> &lt;img className='ui logo image' src={this.props.logo} /&gt;<br/>  &lt;span className='header'&gt;<br/>   Medium Articles<br/>  &lt;/span&gt;<br/> &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="0b05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的Header组件只显示一个文本'<strong class="kf ir"> Medium Articles </strong>'和一个徽标。我们会注意到标识'<strong class="kf ir"> src </strong>'已经从道具中获得为<code class="fe nk nl nm nb b">this.props.logo</code>。这告诉我们这个组件是一个子组件，在本例中，是ArticleList组件的子组件。让我们修改<code class="fe nk nl nm nb b"><em class="lf">hello_template/templates/static/js/components/ArticleList.jsx</em></code>来包含我们的头组件:</p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="b052" class="lj lk iq nb b gy nf ng l nh ni">import React, { Component } from 'react';<br/>import Article from './Article';<br/>import articleData from '../articleData'<br/><strong class="nb ir">import Header from './Header';</strong></span><span id="1030" class="lj lk iq nb b gy np ng l nh ni">export default class ArticleList extends Component {<br/>    render() {<br/>       const articleSort = articleData.article.sort((a,b)=&gt;(<br/>  b.clapps - a.clapps));<br/> const articleCom = articleSort.map((a)=&gt;(<br/>  &lt;Article key={'article-'+a.id} article={a} /&gt;<br/>  )<br/> )<br/>       return (<br/><strong class="nb ir">    &lt;div className='container'&gt;<br/>         &lt;Header logo={articleData.logo}/&gt;</strong><br/>         &lt;div className='ui unstackable items'&gt;<br/>              {articleCom}<br/>         &lt;/div&gt;<br/>    <strong class="nb ir">&lt;/div&gt;</strong></span><span id="809d" class="lj lk iq nb b gy np ng l nh ni">)<br/>    }<br/>}</span></pre><p id="5b98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们做一些造型。在<code class="fe nk nl nm nb b"><em class="lf">hello_template/templates/public/css/main.css</em></code>中添加以下CSS代码</p><pre class="mc md me mf gt na nb nc nd aw ne bi"><span id="4d82" class="lj lk iq nb b gy nf ng l nh ni">.header-page {<br/>  overflow: hidden;<br/>  background-color: #f1f1f1;<br/>  padding: 20px 10px;<br/>  text-align: center;<br/>  line-height: 25px;<br/>  color: black;<br/>  font-size:40px;<br/>  border-radius: 4px;<br/>}</span><span id="8f0b" class="lj lk iq nb b gy np ng l nh ni">.header{<br/> color:black;<br/> text-align: center;<br/> font-size:40px;<br/> background-color: #f1f1f1;</span><span id="8182" class="lj lk iq nb b gy np ng l nh ni">}<br/>.logo{<br/> width:40px;<br/> height: 30px;<br/> clear:right;<br/>}<br/>.author{<br/>color:#808080;<br/>}</span></pre><p id="883c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在刷新你的浏览器。如果一切正常，你的浏览器应该会显示一个类似于<strong class="kf ir">图2 </strong>的页面。如果没有，请再次阅读这篇文章，并尝试找出你可能错过了什么</p><h2 id="796b" class="lj lk iq bd kc ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">仅此而已。您刚刚将web应用程序转变为面向组件和数据驱动的。</h2><p id="1ef9" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">谢谢你的时间，我会相应地更新这篇文章。你可以通过评论、建议和分享这篇文章来做出贡献，这样我们就可以一起教育这个世界。</p><p id="4470" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我会发布更多这样的文章，所以请确保你在媒体上关注我，这样你就不会错过我的任何新发布。</p><p id="cd7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">新年快乐</strong></p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a23ffc1311a21940efc4dd288ef84932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/1*T4lDmQEwgIhrBFvPkrRljA.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图8:2019年新年快乐</figcaption></figure><p id="f7ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">放下昨天。让今天成为一个新的开始，尽你所能做到最好，你就会到达上帝希望你去的地方。愿你所有的梦想和愿望都成真，愿繁荣触摸你的双脚。祝你新年快乐。</p></div></div>    
</body>
</html>