<html>
<head>
<title>How to add some caching in your lambdas without external service — aka stateful lambdas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在没有外部服务的情况下在您的lambdas中添加一些缓存—也称为有状态lambdas</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-add-some-caching-in-your-lambdas-without-external-service-aka-stateful-lambdas-1d9c2d4c2083?source=collection_archive---------4-----------------------#2021-10-18">https://itnext.io/how-to-add-some-caching-in-your-lambdas-without-external-service-aka-stateful-lambdas-1d9c2d4c2083?source=collection_archive---------4-----------------------#2021-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/ffbd45adfbeba10d7c60e5914b18cf12.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*Ddlvi2WI20276ErIt42VJg.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">AWS lambdas</figcaption></figure><p id="c3c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你知道你可以在不同的lambda调用之间保持一些数据的持久性吗？如果您想存储一个临时缓存或加速每次调用，这很有用。让我们看看lambdas如何在引擎盖下工作，以及我们如何利用它。</p><h1 id="c324" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">用例1:持久性</h1><p id="4712" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><strong class="ka ir">今天，有人问我，跨多个lambda调用保持JWT的最佳解决方案是什么。</strong>如果你的lambda调用一个API，你不希望每次调用都生成一个新的JWT。一个解决方案是将令牌存储在Elasticache或DynamoDB中，但这将是多余的，我们希望更喜欢遵循<a class="ae lz" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank">之吻</a>原则。</p><h1 id="5ca3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">用例2:加速</h1><p id="a870" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这种方法有用的另一个场景是<strong class="ka ir">，当您需要加载一些静态内容</strong>时。假设您的lambda检查一封电子邮件是否存在于存储在s3中的黑名单中。当然，列表的大小应该适合lambda内存。您不希望每次都下载数据源，或者避免静态s3发行版上的HTTP调用。</p><p id="c8b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:如果您的数据可以按需重新生成，并且您的数据可以同时存在于多个lambdas上，则此方法有效。第一个场景，在3辆lambdas上有3辆JWT是可以的，它们都是有效的，可以单独再生。第二种情况，数据是只读的。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="1232" class="kw kx iq bd ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt bi translated">简单的解决方案</h1><blockquote class="mm mn mo"><p id="5628" class="jy jz mp ka b kb kc kd ke kf kg kh ki mq kk kl km mr ko kp kq ms ks kt ku kv ij bi translated">在处理程序之外处理代码。句号。</p></blockquote><p id="f574" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更好地理解解决方案，我们需要了解lambdas是如何工作的。lambda只是一个运行应用程序的容器，每次调用时都会调用处理程序。你可以把它想象成运行一个API并调用一个端点，或者加载一个库并调用一个方法。</p><p id="e151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">lambda初学者的一个常见陷阱是认为每次调用都会启动一个新的lambda。不，事实上，如果你经常打电话，容器会保持温暖。保持lambda预热的一种技术是通过一个<a class="ae lz" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-create-rule-schedule.html" rel="noopener ugc nofollow" target="_blank"> Eventbridge规则</a>周期性地调用它。</p><p id="260a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个快速的虚拟测试来演示lambda的持久性</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="e177" class="nc kx iq my b gy nd ne l nf ng">counter = 0<br/><br/>def lambda_handler(event, context):<br/>    global counter<br/>    <br/>    if counter &gt;= 5:<br/>        counter = 0<br/>        <br/>    counter = counter + 1<br/>    print(counter)<br/><br/>    return counter</span></pre><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/790491392cbfc1424f4b5806a3bfa4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsYuqGIVkVkoGkgB3LrNGA.png"/></div></div></figure><p id="fbd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们看到的，在多次调用之间，计数器变量被重用。</p><p id="dd10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在第一个场景</strong>中，您需要一个条件来检查令牌的有效性，并在需要时重新生成一个新令牌，如下所示:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="bc96" class="nc kx iq my b gy nd ne l nf ng">token = None<br/>def get_token:<br/>    global token<br/>    if token and token.expiration &lt; time()<br/>        return token</span><span id="4709" class="nc kx iq my b gy nm ne l nf ng">    token = call_api_auth()</span><span id="06c8" class="nc kx iq my b gy nm ne l nf ng">return token</span></pre><p id="6b4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在第二个场景</strong>中，通过在函数的第一次实例化期间加载数据集，您可以在后续调用中节省大量时间。这里你可以有一个定期重新加载列表的条件。</p><h1 id="1404" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="b7da" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">即使这种方法在某些场景中是有用的，不要忘记你不能依赖lambda的持久性，根据定义，它是短暂的。你必须在你的函数被终止、重启或者有两个容器同时运行的情况下处理这个错误。</p></div></div>    
</body>
</html>