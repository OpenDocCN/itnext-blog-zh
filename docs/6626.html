<html>
<head>
<title>Accessibility as a design pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为设计模式的可访问性</h1>
<blockquote>原文：<a href="https://itnext.io/accessibility-as-a-design-pattern-d58940601cab?source=collection_archive---------2-----------------------#2022-01-09">https://itnext.io/accessibility-as-a-design-pattern-d58940601cab?source=collection_archive---------2-----------------------#2022-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6923d932b16ac04db109da03d2cb06e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LK8X5pKKkdU5LSZ6xHirdg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:<a class="ae kc" href="https://www.3playmedia.com/blog/whitepaper-solving-web-accessibility-leaving-no-one-behind/" rel="noopener ugc nofollow" target="_blank">3播放媒体</a></figcaption></figure><p id="c2d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通常认为易访问性是需要额外开发工作的东西，把它作为一个好的特性，针对一小部分有特殊需求的用户。但是这种思路没有抓住要点，我们没有意识到可访问性标准如何改善我们构建前端界面的日常体验，从而产生更健康、更可读的代码、更干净的测试以及更好的应用程序整体架构。更不用说它平等地惠及所有用户。</p><p id="faa0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的几个月里，我一直试图理解，为什么前端开发人员(包括我自己)讨厌编写测试，为什么我们如此坚定地认为“前端测试很难”。我的探索集中在可访问性的主题上，特别是<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA" rel="noopener ugc nofollow" target="_blank"> ARIA </a>，作为一种缺失的成分，它会使我们测试代码的体验更加愉快。</p><h1 id="e134" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">暧昧的邪恶</h1><p id="ad6e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">作为开发人员，我们花很多时间考虑命名约定——本质上，我们重视正确命名的变量和函数，因为它们减少了歧义，使我们能够向阅读或使用代码的其他人清楚地传达我们的意图。类型安全是消除歧义的另一个例子——它确保我们的代码被解释为预期的，给假设和误用留下很小的空间。</p><p id="159e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我们如此关注代码本身，但我们并不经常考虑代码产生的结果。我们编写漂亮的React组件，遵循既定的设计模式和严格的命名约定，我们用单元测试覆盖它们，但是我们不太关心这些组件的HTML输出有多模糊，尤其是当它们在一个页面上组合在一起时。</p><p id="1de6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部分问题是我们正在使用CSS，它提供了一定程度的视觉歧义——间距、边框和框阴影允许我们将页面解构为逻辑单元，这些逻辑单元具有隐含的语义意义。使用视觉边界，我们知道元素的开始和结束，我们可以与我们想要交互的元素进行交互，而不会被无意义的文本块所迷惑。</p><p id="ea04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，去掉所有的CSS，你只剩下一堆你自己、屏幕阅读器和测试人员都无法理解的HTML。</p><h1 id="5d75" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可读代码的乐趣</h1><p id="b6a6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们喜欢使用自然语言向我们的语音助手发出命令。代码只不过是我们给计算机的一系列命令，所以最可读的代码自然是接近人类语言的代码。</p><p id="9831" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我对前端测试的思考中，我开始在编写Cypress测试和使用Alexa导航网站之间进行比较。如果有一种Alexa技术可以与网页交互，它会使用一个类似于Cypress的引擎，并在其上安装一个测试库。</p><blockquote class="me mf mg"><p id="7c72" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">— Alexa，找到一个登录表单<br/> — Alexa，在用户名栏输入John . doe<br/>—Alexa，在密码栏输入secret<br/>—Alexa，按提交按钮</p></blockquote><p id="9bb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样的情况可以用代码来表达:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="58ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过一些语法上的技巧，我们可以让测试读起来像自然语言。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="70e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以更进一步，将每个命令映射到一个Gherkin关键字(这将需要一些工具来确保一旦“看到”一个地标，就在其边界内执行连续的调用)。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d379" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，在一个页面上，所有这些都是不可能的，这个页面有一个样式类似表单的表单，但是没有通过HTML代码表达相同的语义。它可以看起来像鸭子，像鸭子一样嘎嘎叫，但它可能只是一只风格独特的布谷鸟。</p><p id="e15d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可访问性的基石是用户界面的跨设备互操作性，为了实现这一点，我们必须首先确保我们的界面是机器友好的，而不是仅仅基于理解的主观性，这种理解受到单个用户的物理特征的影响，并且仅仅由应用程序的视觉外观决定(至少在人工“智能”足够智能以从外观推断语义之前是如此)。</p><h1 id="11c5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用HTML表达意思</h1><p id="b60b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如上所述，CSS是一个强大的工具，可以帮助我们传达意思，但仅仅依赖CSS是错误的。首先，CSS是特定于媒体的，常识告诉我们，你不应该将CSS发送到不能呈现它的设备上。其次，你应该保持<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/improving-design-systems-with-solid-principles-part-i-separation-of-concerns-c14088ed09c3"> <em class="mh">关注点分离</em></a>CSS是为了样式化和主题化——无论你在BEM上多么努力，它都不是将你的HTML标记上下文化的正确方式(除了如果你使用CSS模块的话，所有的一切都不在窗口中)。属性是强大的，可以帮助填补某些用例，但我们已经有大量的工具可供使用，包括HTML本身和ARIA指南，它们是由一群聪明的人设计的，他们看到了更大的图景。标准是确定性和断言性的，因此它们可以很容易地表达为测试命令。例如，ARIA指南:</p><blockquote class="me mf mg"><p id="c4ab" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated"><em class="iq">所需的上下文角色定义了允许此</em> <a class="ae kc" href="https://www.w3.org/TR/wai-aria/#dfn-role" rel="noopener ugc nofollow" target="_blank"> <em class="iq">角色</em> </a> <em class="iq">的所属容器。如果某个角色有所需的上下文，作者</em>必须<em class="iq">确保具有该角色的元素包含在具有所需上下文角色的元素内(或</em><a class="ae kc" href="https://www.w3.org/TR/wai-aria/#dfn-owned-element" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">拥有的】)。例如，角色为</em> <code class="fe mr ms mt mu b"><em class="iq">listitem</em></code> <em class="iq">的元素只有包含在角色为</em> <code class="fe mr ms mt mu b"><em class="iq">list</em></code> <em class="iq">的元素内部(或为其所有)时才有意义。</em></p></blockquote><p id="9a8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以用伪代码表示为:</p><pre class="ml mm mn mo gt mv mu mw mx aw my bi"><span id="8596" class="mz lc iq mu b gy na nb l nc nd">expect(listItem).toBeOwnedBy(list);<br/>expect(list).toOwn(listItem);</span></pre><p id="06c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试驱动开发是一种很好的方法，但是如果没有一个确定的方法和一个命令框架，这并不容易。测试驱动的思维可能应该在TDD之前——在你写测试之前设计你的测试。首先确定您希望您的测试如何阅读，创建实用程序来实现这一点，并以满足可测试性标准的方式编写您的组件。我们经常回溯性地编写集成和e2e测试，结果读起来就像是在测试我们的CSS选择器命名约定。还要记住，对于复杂的用例，您可以从组件库中导出Cypress命令，并将它们作为插件导入到您的应用程序中(就像测试库一样)。</p><p id="c414" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试是与用户的合同，而不是与用户的屏幕，重要的是用户可以与应用程序进行有意义的交互，不管他们在给定的一天喜欢使用什么设备。如果有一个命令行工具来与网站交互，岂不是很棒？</p><pre class="ml mm mn mo gt mv mu mw mx aw my bi"><span id="0e76" class="mz lc iq mu b gy na nb l nc nd">hj list forms <a class="ae kc" href="http://mysite.com" rel="noopener ugc nofollow" target="_blank">http://mysite.com</a><br/>1. Login<br/>2. Register<br/>3. Newsletter Signup</span><span id="2a47" class="mz lc iq mu b gy ne nb l nc nd">hj fill Login<br/>Username: <br/>Password:<br/>Submit?</span></pre><p id="0b94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们上面看到的测试用例在HTML标记方面非常简单。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e578" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是问题是我们不知道这个特殊的表单是一个登录表单。如果我们在同一个页面上添加一个注册表单，我们会遇到一个模糊的问题——我们不再能够区分这两个表单，因为它们有一组相似的字段。我们可以给表单和表单元素添加id，或者使用CSS选择器，但是这并不能解决模糊性的问题——屏幕阅读器上的人仍然不知道其中的区别。</p><h2 id="4c9f" class="mz lc iq bd ld nf ng dn lh nh ni dp ll ko nj nk lp ks nl nm lt kw nn no lx np bi translated">标记的地标</h2><p id="8d81" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过为所有标志性角色提供有意义的标签来消除界面的歧义，比如<code class="fe mr ms mt mu b">form</code>、<code class="fe mr ms mt mu b">list</code>、<code class="fe mr ms mt mu b">region</code>、<code class="fe mr ms mt mu b">dialog</code>等。HTML和ARIA标准允许我们使用<code class="fe mr ms mt mu b">&lt;label&gt;</code>、<code class="fe mr ms mt mu b">aria-label</code>、<code class="fe mr ms mt mu b">aria-labelledby</code>来实现这一点。</p><p id="2d60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来澄清一个臭名昭著的待办事项列表:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="02b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以毫无问题地与我们的列表进行交互，这使得任何人都可以轻松地对测试进行代码审查(而不必知道组件的实现细节)。我们不需要难以阅读的id、数据属性、CSS选择器、第n个子选择器等等。一个额外的好处是，没有屏幕的设备也可以像您的测试运行人员一样与界面进行交互。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="9535" class="mz lc iq bd ld nf ng dn lh nh ni dp ll ko nj nk lp ks nl nm lt kw nn no lx np bi translated">关系标记</h2><p id="0530" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">HTML本身很大程度上依赖于层次来表达元素之间的关系。使用ARIA，我们可以在元素之间建立更复杂的语义关系。</p><p id="23ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个例子，让我们看看上下文错误，因为这是一个足够常见的用例，导致测试中复杂的选择器杂耍。</p><p id="92e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们构建一个文件上传组件，它将文件堆叠到一个列表中，验证文件类型，并在验证失败时显示一个错误。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e98e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用ARIA，我们可以在元素之间建立关系，然后可以用它来抽象重复查询，以及对不是直接后代的元素的复杂查询。在上面的例子中，我们指出输入和行项目都是由与第二个上传的项目相关的相同错误描述的，因此处理测试中的断言变得更加容易。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2030" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结合ARIA角色、语义HTML标签和定义元素之间的关系，我们可以开始赋予我们的标记以意义，使我们更容易在测试中定位元素，同时增强我们用户的体验。</p><p id="bedf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有CSS，你的微调器有什么意义吗？如果用户看不到屏幕，他们知道页面上发生了什么吗？他们是否知道他们犯了一个错误，或者现在可以安全地提交带有所有上传文件的表单了？</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="12cf" class="mz lc iq bd ld nf ng dn lh nh ni dp ll ko nj nk lp ks nl nm lt kw nn no lx np bi translated">状态和准备</h2><p id="6219" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Cypress中的可重试性是一个非常有用的特性，但是它也让我们忘记了去想，用户如何知道在他们的操作之后，一些事情已经发生了，而另一些事情已经准备好进行交互了呢？例如，如果用户看不到屏幕，他们如何知道下拉菜单已经出现，他们应该做出选择？</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="726f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以确保弹出窗口的可见性被正确地传达给用户(不假设如果Cypress可以重试，那么用户也可以)。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="8222" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="fd3b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我留给你们两个术语来思考:<strong class="kf ir">测试驱动的可访问性</strong>和<strong class="kf ir">可访问性驱动的测试</strong>。</p><p id="3b83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将ARIA作为可测试性标准是一个很好的机会，可以提高我们应用程序的可访问性，同时改善我们自己的测试体验。当然，除了标签和关系之外，易访问性还有更多损失，但是我们必须从某个地方开始。</p><p id="ecd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ARIA规范的设计考虑到了辅助技术，但事实仍然是测试运行程序与屏幕阅读器并没有太大的不同——两者都依赖标记来完成工作，加上一点语义，两者都能在这方面表现出色。</p><p id="3e59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">远离CSS选择器和自定义数据属性，更多地依赖已建立的ARIA准则，这为消除HTML标记的歧义提供了一个很好的机会，提高了代码库及其最终结果的可用性，并为不同的用户组提供了大量的体验。</p></div></div>    
</body>
</html>