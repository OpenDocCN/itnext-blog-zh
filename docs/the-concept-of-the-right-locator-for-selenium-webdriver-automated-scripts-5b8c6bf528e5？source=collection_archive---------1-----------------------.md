# Selenium WebDriver 自动化脚本的正确定位器的概念。

> 原文：<https://itnext.io/the-concept-of-the-right-locator-for-selenium-webdriver-automated-scripts-5b8c6bf528e5?source=collection_archive---------1----------------------->

![](img/fa69314028578db4d4802c7ac9363a9b.png)

卡尔·海尔达尔在 [Unsplash](https://unsplash.com/@carlheyerdahl?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

如果您创建自动化测试，那么您可能会花费大量的自动化脚本开发时间来寻找页面上的元素，比如按钮和输入。然而，找到正确的 web 元素是很有挑战性的，尤其是当它们缺少惟一的 id 或类名时。例如角形框架。这个框架完美地方便了前端开发者的开发。然而，这使得自动化脚本开发人员的生活非常困难。问题是 Angular 创建的页面元素带有每次页面刷新后生成的标识符。这使得不可能使用它们来自动化测试。

在本文中，我将尝试描述 CSS 和 XPath 定位器。两者有什么区别？哪个定位器“更好”或“更差”，哪个“更快”和“正确”。实际上，什么是“正确的”定位器，如何实现它，以及如何使用它？

所有初露头角的自动化测试工程师我建议在阅读这篇文章之前先阅读和学习 CSS 和 XPath (CSS 和 XPath)

没有这些知识，首先，你将很难理解它是关于什么的，其次，你将无法编写 UI 自动化脚本。

Web 元素是呈现在网页上的单个实体。用户在网页上看到的一切(甚至一些他看不到的东西)都是元素:标题、按钮、输入字段、文本区域。元素在 HTML 中由标记名、属性和内容指定。它们也可能有子元素，例如包含行的表。CSS 可以应用于元素，用颜色、大小、位置等来设计它们的样式。编程语言通常将 Web 元素作为文档**对象模型(DOM)** 中的节点来访问。

Web 元素和定位器是两回事。为什么需要定位器？作为人类用户，我们与网页进行视觉交互:我们通过浏览器查看、滚动、点击和输入。然而，测试自动化以编程的方式与 Web 页面进行交互:它需要一种编码的方式来查找和操作那些相同的元素。传统的自动化不会像人一样“看”页面，而是搜索 DOM。Selenium WebDriver 分离了元素位置和交互的关注点。WebDriver 提供了以下定位器:

*   身份证明
*   名字
*   类别名
*   CSS 选择器
*   XPath

我有意排除了链接文本和部分链接文本。使用这些定位器被认为是不好的做法。页面上的文本可能会不断变化。此外，Selenium WebDriver 中的这些定位器类型被标记为不推荐使用，可以在未来的版本中删除。

你如何在网页上找到元素？为了简化，我使用谷歌的 Chrome 开发工具。要在 Chrome 中检查任何网页，只需在页面的任何地方点击 F12。

大多数课程、书籍和文章都说，能够编写正确的定位器是非常重要和必要的。在这种情况下，没有给出“正确的”定位器的概念，也没有明确的定义。

让我们看看，比如，这些定位器哪个是对的？

找到元素是成功的一半。形成唯一的定位器查询是另一半。如果定位器太宽泛，那么它可能会返回误报。然而，如果一个定位器太具体，那么每当 DOM 改变时，它就很容易被破坏，并且对其他人来说也很难阅读。最好的原则是:编写唯一标识目标元素的最简单的定位器查询。

```
**CSS** article[class='post']
**XPath**
*//article[@class='post']*
```

我个人认为第一种选择要好得多。为什么？他更简洁易读，更容易理解。

总的来说，说实话，我更喜欢用这个优先顺序:

*   ID(如果唯一)
*   名称(如果唯一)
*   类别名
*   CSS 选择器
*   没有文本或索引的 XPath
*   带文本和/或索引的 XPath

在我的大多数自动化脚本中。这就是为什么:

唯一的 id、名称和类名使得定位器非常容易编写:查询很短，不需要额外的锚点。总是鼓励团队中的开发人员使用唯一的标识符，比如所有元素的类名。然而，许多元素没有它们，这意味着定位器必须依靠更复杂的 CSS 选择器和 XPath。

**层叠样式表(CSS)** 是一种样式表语言，用于描述以 HTML 等标记语言编写的文档的表示。

当在 CSS 和 XPath 之间选择时，我更喜欢选择 CSS。

原因如下:

1) CSS 定位器可读性更强:

```
**CSS**
div[id='sb_ifc0']
**XPath**
*//*[@id='sb_ifc0']*
```

2)CSS 更快。我将不再赘述，也不再举例分析。如果你非常关心和关注这个问题，需要关注链接 [Selenium — CSS 还是 XPath speed？](http://sidelnikovmike.blogspot.ru/2013/11/selenium-css-xpath.html)

3)几乎所有的浏览器都实现了 CSS 引擎，这样开发者就可以在自己的项目中使用 CSS 表格。

4) CSS 不断更新(CSS2，CSS2.1，CSS3)。

不幸的是，CSS 的缺点也是存在的:

1.  我们只能深入 DOM 层次结构。
2.  您不能访问父节点。
3.  不能通过文本搜索元素。

**XPath(XML path)**—XML 文档元素的查询语言。为访问 XSLT 转换文件中的 XML 文档部分而设计的是标准联盟
[W3C](https://www.w3.org/) 。由于许多浏览器都支持 XHTML，所以我们可以使用 XPath 来查找网页上的元素。

1.  XPath 的速度不逊于(或略逊于)CSS。
2.  因为 XPath 与编程语言非常相似。它清晰易读，有可能理解我们谈论的是什么元素。
3.  使用 XPath，由于建立了关系链，您可以访问页面中最隐藏的元素。
4.  XPath 最重要的优点是我们可以在 DOM 层次结构中来回移动。这意味着使用 XPath 我们可以找到父元素和子元素。

**我个人的观点是** : CSS 定位器更适合用在我的 Selenium 自动化脚本中。

我的定位器非常漂亮、简洁，可读性很强:

```
**CSS** div[class='_Rm']
**XPath**
*//*[@class='_Rm' and contains(text(),'www.seleniumhq.org')]*
```

不幸的是，错误和误报经常发生。Chrome DevTools 让测试定位器变得容易，但它不是万能的。
有时，当我不明白为什么定位器对自动化脚本不起作用时，我会做以下事情:

1.  从我的 IDE 调试运行测试用例。
2.  在定位器上设置断点。等待测试用例在断点处停止。
3.  在当前 Chrome 窗口中输入 DevTools。
4.  检查 DOM 并测试活动页面上的定位器。

**片状测试。**

对我来说,“正确的”定位器是工作稳定、美观、简洁、可读性强的定位器。创建这样一个定位器所需的时间不超过 10 分钟。

# 引入易变的测试缓解工具

这是一个新的 [Gradle 插件](https://github.com/gradle/test-retry-gradle-plugin)并构建了扫描改进，旨在减轻你的古怪测试。

```
plugins {
    id 'org.gradle.test-retry' version '1.0.0'
}

test {
    retry {
        failOnPassedAfterRetry = true
        maxFailures = 42
        maxRetries = 1
    }
}
```