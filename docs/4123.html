<html>
<head>
<title>Two-phased canary rollout with Gloo, part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gloo的两阶段金丝雀展示，第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/two-phased-canary-rollout-with-gloo-part-2-ffa556a503b0?source=collection_archive---------3-----------------------#2020-05-01">https://itnext.io/two-phased-canary-rollout-with-gloo-part-2-ffa556a503b0?source=collection_archive---------3-----------------------#2020-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="85f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/two-phased-canary-rollout-with-gloo-part-1-ec5b267cdc9e?source=friends_link&amp;sk=773b1875d156b88171b0266031bbb0d6">的最后一部分</a>中，我们看到了如何使用Gloo建立一个两阶段的方法来测试和推出新版本的服务。</p><ul class=""><li id="9add" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">在第一阶段，您重定向一小部分流量，以便验证新版本的功能。</li><li id="2a1b" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">一旦满意，您就进入第二阶段，在此期间，您使用加权目的地将负载逐渐转移到服务的新版本，直到您完成任务并且旧版本可以退役。</li></ul><p id="0a14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将研究如何改进该工作流设计，以便我们可以跨许多团队拥有的许多服务进行扩展，同时考虑如何在组织中的不同角色之间划分职责，并确保平台妥善处理配置错误。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/16bef20995b2a0602f3779be59b1992a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uyI5xieY1aIByiVbOwbkrg.png"/></div></div></figure><h1 id="02ee" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">跨多个团队扩展</h1><p id="b31b" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">正如我们在上一篇文章中看到的，Gloo使用<a class="ae kl" href="https://docs.solo.io/gloo/latest/introduction/architecture/concepts/#virtual-services" rel="noopener ugc nofollow" target="_blank">虚拟服务</a>来管理特定域的路由。通过修改虚拟服务对象上的路由，我们能够在Gloo中执行我们的两阶段升级工作流。</p><p id="f98a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之前，我们为名为echo的单个服务执行工作流。现在，我们将引入另一个由不同团队拥有的服务foxtrot，并考虑如何将这个工作流扩展到多个团队。</p><p id="62b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别是，我们将寻找一种能够满足以下关键目标的方法:</p><ul class=""><li id="172f" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">避免特定团队或个人的瓶颈</li><li id="90bb" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">限制一个团队破坏另一个团队的服务健康的风险</li><li id="908a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">非常适合组织的角色方法、基于角色的访问控制和Kubernetes</li></ul><h2 id="0e45" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">选项1:共享虚拟服务</h2><p id="a111" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">简单的扩展方法是使用单一的虚拟服务，用相同的资源管理echo和foxtrot服务的所有路由。</p><p id="a30a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">马上，我们可以看到一个问题。因为我们所有的路由都是由一个对象控制的，所以我们要么需要向两个团队授予对该对象的写权限，要么需要通过一个中央管理团队的所有权限。后一种方法很可能是两害相权取其轻，而且随着分散的开发团队数量的增加，您会给中央管理团队带来越来越大的负担。</p><h2 id="07d6" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">选项2:跨域分离所有权</h2><p id="ced8" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我们可以考虑的第一个选择是用不同的域对每个服务建模，以便在不同的对象上管理路由。例如，如果我们的主域是<code class="fe nb nc nd ne b">example.com</code>，我们可以为每个子域提供一个虚拟服务:<code class="fe nb nc nd ne b">echo.example.com</code>和<code class="fe nb nc nd ne b">foxtrot.example.com</code>。</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="f84c" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: VirtualService<br/>metadata:<br/>  name: echo<br/>  namespace: echo<br/>spec:<br/>  virtualHost:<br/>    domains:<br/>      - 'echo.example.com'<br/>    routes:<br/>      - matchers:<br/>          - prefix: /echo<br/>...<br/>---<br/>apiVersion: gateway.solo.io/v1<br/>kind: VirtualService<br/>metadata:<br/>  name: foxtrot<br/>  namespace: foxtrot<br/>spec:<br/>  virtualHost:<br/>    domains:<br/>      - 'foxtrot.example.com'<br/>...</span></pre><p id="99b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以更干净地将路线的所有权分散到两个服务中，让每个团队拥有自己的虚拟服务。Gloo可以很容易地观察两个名称空间，因此您可以将虚拟服务与每个团队拥有的其他资源存储在一起。</p><p id="38f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，在一些组织中(比如联系我的那个用户)，域和路由的所有权是分开的——一个开发运营团队负责DNS和证书管理，一个开发团队负责特定的路由。这意味着这两个虚拟服务的所有权仍然是共享的，只是没有在开发团队之间共享。</p><p id="96cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这样的组织，更好的方法是让一个管理团队拥有根虚拟服务，并且该团队能够委托一个或多个路由的所有权。</p><h2 id="1582" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">选项3:通过委派在路由表之间分离所有权</h2><p id="470c" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">为了解决这些问题，我们将利用Gloo中一个名为delegation的特性。通过委托，我们可以在一个叫做<a class="ae kl" href="https://docs.solo.io/gloo/latest/guides/traffic_management/destination_types/delegation/" rel="noopener ugc nofollow" target="_blank"> RouteTable </a>的不同对象上定义我们的路线。在虚拟服务中，我们可以定义一个委托动作，并引用路由表。这使得我们能够将领域的所有权与特定路线的所有权分离开来，并且将不同开发团队中不同路线的所有权分离开来。</p><p id="21e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这听起来是最令人满意的方法，所以现在让我们看看这在Gloo中是如何工作的。</p><h1 id="d706" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">设置您的环境</h1><p id="eb34" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我假设你对<a class="ae kl" href="https://www.solo.io/blog/two-phased-canary-rollout-with-gloo/" rel="noopener ugc nofollow" target="_blank">第1部分</a>中详述的两阶段方法有一个很好的理解。我还假设您有一个Kubernetes集群，并且已经按照我在第1部分中的解释安装了Gloo，并且准备开始部署服务。</p><p id="9b7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更容易地遵循本指南，我建议运行以下步骤，将所有引用的资源放入您的工作目录中。所有的kubectl命令都采用这个工作目录:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="0314" class="mp ln iq ne b gy nj nk l nl nm">git clone <a class="ae kl" href="https://github.com/solo-io/gloo-ref-arch" rel="noopener ugc nofollow" target="_blank">https:<em class="nn">//github.com/solo-io/gloo-ref-arch</em></a><em class="nn"><br/></em>cd gloo-ref-arch<br/>git checkout blog-21-apr-20<br/>cd two-phased-canary/part2</span></pre><h1 id="a6cc" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">部署应用程序</h1><p id="cd94" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">首先，我们将把echo部署到echo名称空间:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="367b" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f echo.yaml</span></pre><p id="ec14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将把foxtrot部署到foxtrot名称空间:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="c35a" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f foxtrot.yaml</span></pre><p id="473e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该等艾可和狐步舞准备好再继续前进。</p><h2 id="818d" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">在Gloo中将服务建模为上游</h2><p id="1638" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">让我们将echo建模为Gloo中的<a class="ae kl" href="https://docs.solo.io/gloo/latest/introduction/architecture/concepts/#upstreams" rel="noopener ugc nofollow" target="_blank">上游</a>目的地:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="4cda" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gloo.solo.io/v1<br/>kind: Upstream<br/>metadata:<br/>  name: echo<br/>  namespace: gloo-system<br/>spec:<br/>  kube:<br/>    selector:<br/>      app: echo<br/>    serviceName: echo<br/>    serviceNamespace: echo<br/>    servicePort: 8080<br/>    subsetSpec:<br/>      selectors:<br/>        - keys:<br/>            - version</span></pre><p id="2470" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其部署到集群:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="c924" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f upstream-echo.yaml</span></pre><p id="5309" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们对狐步舞做同样的事情，将其建模为上游<a class="ae kl" href="https://docs.solo.io/gloo/latest/introduction/architecture/concepts/#upstreams" rel="noopener ugc nofollow" target="_blank"/>:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="1750" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gloo.solo.io/v1<br/>kind: Upstream<br/>metadata:<br/>  name: foxtrot<br/>  namespace: gloo-system<br/>spec:<br/>  kube:<br/>    selector:<br/>      app: foxtrot<br/>    serviceName: foxtrot<br/>    serviceNamespace: foxtrot<br/>    servicePort: 8080<br/>    subsetSpec:<br/>      selectors:<br/>        - keys:<br/>            - version</span></pre><p id="fad3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其部署到集群:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="ca61" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f upstream-foxtrot.yaml</span></pre><h2 id="5de5" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">设置路由表</h2><p id="b6d6" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在，让我们创建一个路由表，其中包含到回送上游的路由:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="7ee8" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: echo-routes<br/>  namespace: echo<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - prefix: /echo<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: echo<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v2</span></pre><p id="f279" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其部署到集群:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="5c36" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f rt-echo-1.yaml</span></pre><p id="8e11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建狐步舞的路由表:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="3fc3" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: foxtrot-routes<br/>  namespace: foxtrot<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - prefix: /foxtrot<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: foxtrot<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v1</span></pre><p id="7df3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其部署到集群:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="7d11" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f rt-foxtrot-1.yaml</span></pre><p id="8049" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，我们将这些路由表资源分别存储在echo和foxtrot名称空间中。这是为了模拟echo和foxtrot团队直接拥有这些资源。我们可以假设当我们对那些资源进行变更时，我们正在模拟那些团队。</p><h2 id="4a71" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">用虚拟服务把它连接起来</h2><p id="dd15" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">最后，我们可以通过创建一个虚拟服务，将两个服务连接到一个特定的域(在本例中是<code class="fe nb nc nd ne b">*</code>)。在我们的场景中，我们假设一个中央运营团队拥有该域，因此我们将把这个配置保存在<code class="fe nb nc nd ne b">gloo-system</code>名称空间中。</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="6700" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: VirtualService<br/>metadata:<br/>  name: app<br/>  namespace: gloo-system<br/>spec:<br/>  virtualHost:<br/>    domains:<br/>      - '*'<br/>    routes:<br/>      - matchers:<br/>          - prefix: /echo<br/>        delegateAction:<br/>          selector:<br/>            namespaces:<br/>              - echo<br/>      - matchers:<br/>          - prefix: /foxtrot<br/>        delegateAction:<br/>          selector:<br/>            namespaces:<br/>              - foxtrot</span></pre><p id="0fe9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其部署到集群:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="1b06" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f vs.yaml</span></pre><h2 id="56c4" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">测试路线</h2><p id="fe54" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">此时，我们应该能够通过Gloo向这两个服务发送请求:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="b2b4" class="mp ln iq ne b gy nj nk l nl nm">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v1</span><span id="9e9b" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/foxtrot<br/>version:foxtrot-v1</span></pre><h1 id="3d04" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">运行两阶段canary工作流</h1><p id="fc27" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在，echo或foxtrot团队可以通过编辑相应的路由表，在他们的服务上运行两阶段工作流。我们将模仿狐步舞团队，开始推出v2。</p><h2 id="d6ef" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">狐步舞队开始第一阶段</h2><p id="3849" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">对于第一阶段，我们需要部署foxtrot服务的v2，然后更新路由表，向v2发送包含报头<code class="fe nb nc nd ne b">stage: canary</code>的请求。</p><p id="48c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以部署foxtrot-v2并等待它被部署:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="6aad" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f foxtrot-v2.yaml</span></pre><p id="b78e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等到命名空间“foxtrot”中的pod准备就绪。使用<code class="fe nb nc nd ne b">kubectl get pods -n foxtrot</code>检查状态。</p><p id="fb15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要更新路线，这样我们就可以开始测试foxtrot v2:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="fc87" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: foxtrot-routes<br/>  namespace: foxtrot<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - headers:<br/>            - name: stage<br/>              value: canary<br/>          prefix: /foxtrot<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: foxtrot<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v2<br/>    - matchers:<br/>        - prefix: /foxtrot<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: foxtrot<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v1</span></pre><p id="6561" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其部署到集群:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="43f5" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f rt-foxtrot-2.yaml</span></pre><h2 id="9c32" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">测试路线</h2><p id="351b" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在我们可以测试以确保我们可以向foxtrot v2发送请求。我们的其他路线应该继续像以前一样:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="a011" class="mp ln iq ne b gy nj nk l nl nm">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v1</span><span id="ac9b" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/foxtrot<br/>version:foxtrot-v1</span><span id="daf2" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/foxtrot -H "stage: canary"<br/>version:foxtrot-v2</span></pre><p id="80fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个请求现在被发送到v2，因为提供了金丝雀头。</p><h2 id="7677" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">狐步舞队开始第二阶段</h2><p id="f741" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在我们可以切换到阶段2，用加权目的地更新狐步舞路由表:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="9cfd" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: foxtrot-routes<br/>  namespace: foxtrot<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - headers:<br/>            - name: stage<br/>              value: canary<br/>          prefix: /foxtrot<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: foxtrot<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v2<br/>    - matchers:<br/>        - prefix: /foxtrot<br/>      routeAction:<br/>        multi:<br/>          destinations:<br/>            - destination:<br/>                upstream:<br/>                  name: foxtrot<br/>                  namespace: gloo-system<br/>                subset:<br/>                  values:<br/>                    version: v1<br/>              weight: 100<br/>            - destination:<br/>                upstream:<br/>                  name: foxtrot<br/>                  namespace: gloo-system<br/>                subset:<br/>                  values:<br/>                    version: v2<br/>              weight: 0</span></pre><p id="6fbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其部署到集群:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="10db" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f rt-foxtrot-3.yaml</span></pre><p id="16bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们预计这些航线将继续像以前一样运行。</p><h2 id="3975" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">Echo团队开始v2推广</h2><p id="5e88" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">当foxtrot团队正在推出foxtrot的v2时，假设echo团队准备开始测试echo服务的新版本。</p><p id="b96d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以部署echo-v2并等待它被部署:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="82e0" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f echo-v2.yaml</span></pre><p id="f3c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等待命名空间“echo”中的窗格准备就绪。使用<code class="fe nb nc nd ne b">kubectl get pods -n echo</code>检查状态。</p><p id="d854" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们需要更新路由，以便开始测试echo v2:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="ddfa" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: echo-routes<br/>  namespace: echo<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - headers:<br/>            - name: stage<br/>              value: canary<br/>          prefix: /echo<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: echo<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v2<br/>    - matchers:<br/>        - prefix: /echo<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: echo<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v1</span></pre><p id="9a45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将其部署到集群中:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="aa2c" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f rt-echo-2.yaml</span></pre><h2 id="d2f2" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">测试路线</h2><p id="e899" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在，我们应该能够测试echo或foxtrot服务的v2，因为每个团队都在进行金丝雀部署。</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="0c71" class="mp ln iq ne b gy nj nk l nl nm">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v1</span><span id="1155" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/echo -H "stage: canary"<br/>version:echo-v2</span><span id="a112" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/foxtrot<br/>version:foxtrot-v1</span><span id="f854" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/foxtrot -H "stage: canary"<br/>version:foxtrot-v2</span></pre><h1 id="d1f3" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">处理无效配置</h1><p id="e0e2" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">正如我们现在看到的，使用路由表允许我们将canary部署扩展到多个开发团队，而不需要让团队拥有他们自己的域配置。团队可以并行管理他们自己的canary部署，而不需要协调。至少，这是真的，直到有人开始创作无效配置。我们将看到Gloo响应无效配置的默认行为对于我们的用例来说是不可取的；但是，我们可以解决这个问题，并通过简单的设置更改来改变行为。</p><h2 id="39a1" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">存在无效配置时的默认Gloo行为</h2><p id="571a" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">通常，当Gloo遇到无效配置时，它会尝试继续向Envoy提供最后一次已知的正确配置。这样，错误就不会导致工作路由被删除，并且一旦配置被修复，Envoy将再次开始接收更新。这并不是万无一失的——只有当Gloo和Envoy在内存中拥有最后一个已知配置时，它才会起作用，并且不会在pod重启后继续存在。但是在出现问题时，它保留了适当的降级语义，并且通常是特定用例的理想行为。</p><p id="81bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看在我们的用例中是什么样子的。让我们通过引用一个不存在的上游目的地来模拟echo团队编写无效的配置。</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="1526" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: echo-routes<br/>  namespace: echo<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - headers:<br/>            - name: stage<br/>              value: canary<br/>          prefix: /echo<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: echo-typo<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v2<br/>    - matchers:<br/>        - prefix: /echo<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: echo<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v1</span></pre><p id="95b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将其部署到集群中:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="027b" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f rt-echo-3.yaml</span></pre><p id="1d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与此同时，foxtrot团队正在努力完成阶段2，并调整权重，开始将100%的流量发送到v2目的地:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="20eb" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: foxtrot-routes<br/>  namespace: foxtrot<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - headers:<br/>            - name: stage<br/>              value: canary<br/>          prefix: /foxtrot<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: foxtrot<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v2<br/>    - matchers:<br/>        - prefix: /foxtrot<br/>      routeAction:<br/>        multi:<br/>          destinations:<br/>            - destination:<br/>                upstream:<br/>                  name: foxtrot<br/>                  namespace: gloo-system<br/>                subset:<br/>                  values:<br/>                    version: v1<br/>              weight: 0<br/>            - destination:<br/>                upstream:<br/>                  name: foxtrot<br/>                  namespace: gloo-system<br/>                subset:<br/>                  values:<br/>                    version: v2<br/>              weight: 100</span></pre><p id="df48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将其部署到集群中:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="c04c" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f rt-foxtrot-4.yaml</span></pre><h2 id="32ac" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">测试路线</h2><p id="f7c1" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在，我们可以通过运行<code class="fe nb nc nd ne b">glooctl check</code>来判断是否有错误:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="af4e" class="mp ln iq ne b gy nj nk l nl nm">➜ glooctl check<br/>Checking deployments... OK<br/>Checking pods... OK<br/>Checking upstreams... OK<br/>Checking upstream groups... OK<br/>Checking auth configs... OK<br/>Checking secrets... OK<br/>Checking virtual services... Found virtual service with warnings: gloo-system app<br/>Reason: warning:<br/>  Route Warning: InvalidDestinationWarning. Reason: *v1.Upstream {echo-typo gloo-system} not found<br/>Route Warning: InvalidDestinationWarning. Reason: *v1.Upstream {echo-typo gloo-system} not found<br/>Problems detected!</span></pre><p id="9a35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们测试路由，我们将看到以下行为:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="f740" class="mp ln iq ne b gy nj nk l nl nm">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v1</span><span id="e9c8" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/echo -H "stage: canary"<br/>version:echo-v2</span><span id="3fcf" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/foxtrot<br/>version:foxtrot-v1</span><span id="dd3f" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/foxtrot -H "stage: canary"<br/>version:foxtrot-v2</span></pre><p id="3027" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，在整个代理配置中有一个错误，所以Gloo继续为Envoy提供最后一个已知的良好配置。这意味着狐步舞团队将权重设置为v2的更改并不适用。狐步舞队被封锁，等待回声队修复他们的配置。</p><p id="69e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当考虑一个跨大型开发组织使用的API网关时，如果一个团队的错误阻碍了另一个团队的进展，我们会认为这是一个危险信号。幸运的是，Gloo有一个名为<a class="ae kl" href="https://docs.solo.io/gloo/latest/guides/traffic_management/configuration_validation/invalid_route_replacement/" rel="noopener ugc nofollow" target="_blank">路由替换</a>的特性，可以改变代理行为并解决这个问题。</p><h2 id="f9c4" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">改变无效配置的行为</h2><p id="f4c0" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">让我们创建一个名为<code class="fe nb nc nd ne b">settings-patch.yaml</code>的文件，其中包含以下Gloo设置的补丁:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="2c5f" class="mp ln iq ne b gy nj nk l nl nm">spec:<br/>  gloo:<br/>    invalidConfigPolicy:<br/>      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators<br/>        should run `glooctl check` to find and fix config errors.<br/>      invalidRouteResponseCode: 404<br/>      replaceInvalidRoutes: true</span></pre><p id="9565" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将改变Gloo的行为，以便在配置不良的情况下，它用404和错误消息替换受错误影响的路由，作为直接响应。在我们的例子中，新的echo路由表无效，因此路由被替换；但是，Gloo将使用foxtrot路由表中的路由更新Envoy，因为该对象是有效的。它也将继续服务于旧的<code class="fe nb nc nd ne b">echo</code>路线。</p><p id="3cd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用以下命令应用补丁:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="75e3" class="mp ln iq ne b gy nj nk l nl nm">kubectl patch -n gloo-system settings default --type merge --patch "$(cat settings-patch.yaml)"</span></pre><h2 id="be54" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">测试路线</h2><p id="3c54" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在，如果我们运行与上面相同的测试，我们将看到以下结果:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="b96e" class="mp ln iq ne b gy nj nk l nl nm">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v1</span><span id="0fb1" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/echo -H "stage: canary"<br/>Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.</span><span id="dc03" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/foxtrot<br/>version:foxtrot-v2</span><span id="203d" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/foxtrot -H "stage: canary"<br/>version:foxtrot-v2</span></pre><h2 id="ad2d" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">完成狐步舞展示</h2><p id="5c35" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在我们已经设置了Gloo来替换无效路线并保留有效路线，foxtrot团队可以完成他们的首次展示了。</p><p id="4ade" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于所有流量都已转移到v2，我们现在可以清理路由:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="6774" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: foxtrot-routes<br/>  namespace: foxtrot<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - prefix: /foxtrot<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: foxtrot<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v2</span></pre><p id="226f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用以下命令来部署它:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="01f8" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f rt-foxtrot-5.yaml</span></pre><p id="3757" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以删除<code class="fe nb nc nd ne b">v1</code> foxtrot部署，它不再为任何流量提供服务。</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="1452" class="mp ln iq ne b gy nj nk l nl nm">kubectl delete -f foxtrot-v1.yaml</span></pre><p id="0de7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们检查一下，以确保狐步舞仍然健康:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="bc73" class="mp ln iq ne b gy nj nk l nl nm">➜ curl $(glooctl proxy url)/foxtrot<br/>version:foxtrot-v2</span></pre><h2 id="394c" class="mp ln iq bd lo mq mr dn ls ms mt dp lw jy mu mv ma kc mw mx me kg my mz mi na bi translated">修复回显配置</h2><p id="f696" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我们还可以恢复无效的echo配置，以解除对echo团队的封锁。我们将恢复到旧的路由表:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="ab23" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: echo-routes<br/>  namespace: echo<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - headers:<br/>            - name: stage<br/>              value: canary<br/>          prefix: /echo<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: echo<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v2<br/>    - matchers:<br/>        - prefix: /echo<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: echo<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v1</span></pre><p id="b1c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将其部署到集群中:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="6c62" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f rt-echo-2.yaml</span></pre><p id="208b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将看到通过运行<code class="fe nb nc nd ne b">glooctl check</code>来清除错误:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="565d" class="mp ln iq ne b gy nj nk l nl nm">➜ glooctl check<br/>Checking deployments... OK<br/>Checking pods... OK<br/>Checking upstreams... OK<br/>Checking upstream groups... OK<br/>Checking auth configs... OK<br/>Checking secrets... OK<br/>Checking virtual services... OK<br/>Checking gateways... OK<br/>Checking proxies... OK<br/>No problems detected.</span></pre><p id="c323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将看到echo的路由再次按预期工作:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="64fc" class="mp ln iq ne b gy nj nk l nl nm">➜ curl $(glooctl proxy url)/echo<br/>version:echo-v1</span><span id="70e7" class="mp ln iq ne b gy no nk l nl nm">➜ curl $(glooctl proxy url)/echo -H "stage: canary"<br/>version:echo-v2</span></pre><h1 id="2416" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">将这种方法推广到真正的自助团队</h1><p id="24f9" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">到目前为止，我们的解决方案仍然要求拥有该域的运营团队在每次向我们的应用程序添加新服务时，向虚拟服务添加新路由。我们可以通过使用标签选择器将路由表与虚拟服务相关联来消除这种依赖性。</p><p id="1583" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用<code class="fe nb nc nd ne b">apiGroup: example</code>标记每个路由表:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="3072" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: echo-routes<br/>  namespace: echo<br/>  labels:<br/>    apiGroup: example<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - headers:<br/>            - name: stage<br/>              value: canary<br/>          prefix: /echo<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: echo<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v2<br/>    - matchers:<br/>        - prefix: /echo<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: echo<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v1</span><span id="d7ca" class="mp ln iq ne b gy no nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: RouteTable<br/>metadata:<br/>  name: foxtrot-routes<br/>  namespace: foxtrot<br/>  labels:<br/>    apiGroup: example<br/>spec:<br/>  routes:<br/>    - matchers:<br/>        - prefix: /foxtrot<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: foxtrot<br/>            namespace: gloo-system<br/>          subset:<br/>            values:<br/>              version: v2</span></pre><p id="0733" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用以下命令将这些应用于我们的集群:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="930b" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f rt-echo-4.yaml<br/>kubectl apply -f rt-foxtrot-6.yaml</span></pre><p id="fe63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以更新我们的虚拟服务，在它的选择器中有一个使用这个标签<code class="fe nb nc nd ne b">apiGroup: example</code>的单一路由，这样服务在创建时就立即被绑定到域。</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="207f" class="mp ln iq ne b gy nj nk l nl nm">apiVersion: gateway.solo.io/v1<br/>kind: VirtualService<br/>metadata:<br/>  name: app<br/>  namespace: gloo-system<br/>spec:<br/>  virtualHost:<br/>    domains:<br/>      - '*'<br/>    routes:<br/>      - matchers:<br/>          - prefix: /<br/>        delegateAction:<br/>          selector:<br/>            labels:<br/>              apiGroup: example<br/>            namespaces:<br/>              - "*"</span></pre><p id="02e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用以下命令将其应用于集群:</p><pre class="lb lc ld le gt nf ne ng nh aw ni bi"><span id="3241" class="mp ln iq ne b gy nj nk l nl nm">kubectl apply -f vs-2.yaml</span></pre><p id="4769" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们的路由完全像以前一样工作，但是当新名称空间中的新服务上线时，我们不再需要更新虚拟服务。</p><p id="502a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这引入了一个潜在的风险，即不同的团队可能试图定义相同的路线，尽管这可能是一个可接受的风险，以支持完全自助服务的团队，并且我们可能能够找到其他方法来实施可伸缩的约定。</p><p id="be4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经看到我们的用户通过这种方法帮助自助服务开发团队的一种方式是将Gloo路线以及部署、服务、上游和其他配置打包到一个helm图表中。团队可以用适合他们服务的值来定制舵图，从而为约定提供更强的防护。</p><p id="92f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过将更多验证集成到CI/CD管道中，或者使用webhook(如开放策略代理服务器)阻止无效配置写入集群，可以增加对无效路由的更严格保护。</p><h1 id="14ad" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">摘要</h1><p id="e146" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在这篇文章中，我们着眼于扩展我们的两阶段金丝雀展示工作流程。我们通过将不同的路由表委派给不同的团队，在多个开发团队之间进行了扩展。通过委托，我们实现了拥有域的开发运营团队和拥有不同路线的开发团队的更清晰的责任分离。最后，很容易在Gloo中定制行为，以确保两个团队可以并行操作，而不需要协调，并且没有一个团队通过编写无效配置来阻止另一个团队的风险。</p><p id="b413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别感谢Ievgenii Shepeliuk对<a class="ae kl" href="https://www.solo.io/blog/two-phased-canary-rollout-with-gloo/" rel="noopener ugc nofollow" target="_blank">第1部分</a>提供反馈，并分享路由表在他的组织中是如何使用的。要深入了解Gloo在新时代解决方案中的应用，请查看我们的<a class="ae kl" href="https://www.solo.io/blog/end-user-case-study-hrzn-igaming-platform-by-new-age-solutions/" rel="noopener ugc nofollow" target="_blank">案例研究</a>。</p><h1 id="6b45" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">加入Gloo社区</h1><p id="fede" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">除了企业客户群之外，Gloo还有一个庞大且不断增长的开源用户社区。要了解更多关于Gloo的信息:</p><ul class=""><li id="def2" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">查看<a class="ae kl" href="https://github.com/solo-io/gloo" rel="noopener ugc nofollow" target="_blank">回购</a>，在这里你可以看到代码和文件问题</li><li id="e9ff" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">查看<a class="ae kl" href="https://docs.solo.io/gloo/latest" rel="noopener ugc nofollow" target="_blank">文档</a>，其中有大量的指南和示例</li><li id="ff78" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">加入slack频道并开始与Solo工程团队和用户社区聊天</li></ul><p id="51be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想与我联系(反馈总是被感激！)，你可以在Slack上找到我或者发邮件给我<a class="ae kl" href="mailto:rick.ducott@solo.io" rel="noopener ugc nofollow" target="_blank"> rick.ducott@solo.io </a>。</p></div></div>    
</body>
</html>