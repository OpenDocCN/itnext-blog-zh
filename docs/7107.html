<html>
<head>
<title>Increase Productivity with Bash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Bash提高生产力</h1>
<blockquote>原文：<a href="https://itnext.io/easy-bash-scripting-tips-to-increase-productivity-7227f6d12756?source=collection_archive---------4-----------------------#2022-06-14">https://itnext.io/easy-bash-scripting-tips-to-increase-productivity-7227f6d12756?source=collection_archive---------4-----------------------#2022-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8d0f73da05de756d5048a601395228dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*w7qzmkrfCSvhZtO-ECYkfA.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">命令行</figcaption></figure><p id="4e01" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你有没有发现自己一遍又一遍地在终端上输入同样的命令？如果你像我一样，你可能厌倦了这一点，并希望它自动化。这里有一些关于如何使用bash加速工作流的技巧。</p><h1 id="d322" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么是Bash？</h1><p id="5dac" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">Bash是一种为Unix shells编写的脚本语言。你的Mac终端是一个Unix Shell和Linux终端。如果你使用的是windows，你需要下载类似于运行在Unix上的<a class="ae mg" href="https://gitforwindows.org/" rel="noopener ugc nofollow" target="_blank"> Git Bash </a>的东西。</p><h1 id="082d" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">Bash vs Zsh</h1><p id="1d63" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">Z Shell，简称Zsh，是Bash的一个扩展，它附带了大量有用的插件，如自动cd(只需键入路线)、拼写检查、更强大的制表符补全、插件支持、主题化和令人敬畏的框架。有很多关于如何在Medium上设置Zsh和Oh-My-Zsh的教程，我强烈推荐你去看看。</p><div class="mh mi gp gr mj mk"><a href="https://medium.com/@caulfieldOwen/youre-missing-out-on-a-better-mac-terminal-experience-d73647abf6d7" rel="noopener follow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">你错过了更好的Mac终端体验</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">Mac命令行应用程序，插件，调整和提示，使您的终端完全符合您的要求:功能…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">medium.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my jz mk"/></div></div></a></div><h1 id="2b7a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">。bashrc/。zshrc</h1><p id="32bc" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">要开始编写一些简单的脚本，您需要根据使用bash或zsh来找到您的<code class="fe mz na nb nc b">.bashrc</code>或<code class="fe mz na nb nc b">.zshrc</code>文件。从现在起，我将只参考<code class="fe mz na nb nc b">.zshrc</code>文件，但是我知道你可以在你的<code class="fe mz na nb nc b">.bashrc</code>中做大多数相同的事情。</p><p id="e71c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要打开您的<code class="fe mz na nb nc b">.zshrc</code>文件，只需在您的终端中运行以下命令:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="7f42" class="nl le it nc b gy nm nn l no np">$ open ~/.zshrc</span></pre><p id="5399" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您应该已经在文本编辑器中打开了您的<code class="fe mz na nb nc b">.zshrc</code>文件，并且可以开始编辑了。如果你安装了Oh-my-zsh，你会发现里面已经有很多东西了。大部分都会用#符号注释掉。现在忽略它，滚动到文件的底部，我们将在那里添加代码。</p><h1 id="c1b3" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">别名</h1><p id="5cee" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">我们能做的提高生产力的最简单的事情就是开始写一些别名。别名只是更长命令的快捷方式。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="136a" class="nl le it nc b gy nm nn l no np">alias gp="git push"</span></pre><p id="673c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">将别名<code class="fe mz na nb nc b">gp</code>添加到<code class="fe mz na nb nc b">git push</code>命令中。所以无论何时你想运行“git push ”,你只需要在命令行中输入<code class="fe mz na nb nc b">gp</code>。一开始并不能节省很多时间，但是在你推了几千次之后，它就累积起来了。</p><p id="e5b8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里还有一些别名的例子</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="b49b" class="nl le it nc b gy nm nn l no np">alias ui="cd path/to/ui/repository"</span></pre><p id="b85b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个频繁使用的回购协议的别名。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="f17f" class="nl le it nc b gy nm nn l no np">alias gcd="git checkout develop"</span></pre><p id="2357" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">变更开发分支机构的别名。</p><p id="b84c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要保存这些别名，只需将它们添加到您。zshrc文件并保存它，但是一定要重新加载您的终端，通过运行以下命令来查看它们的应用:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="f13d" class="nl le it nc b gy nm nn l no np">$ source ~/.zshrc</span></pre><p id="3b0a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">也可以把它变成一个别名。)</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="7efe" class="nl le it nc b gy nm nn l no np">alias reload="source ~/.zshrc"</span></pre><h1 id="8955" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">功能</h1><p id="ddd2" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">现在让我们假设您想要做一些比别名更复杂的事情，并且您想要将几个步骤自动化到一个命令中。这就是函数派上用场的地方。这里有一个我日常使用的函数的例子。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="7fea" class="nl le it nc b gy nm nn l no np">pullindev() {<br/> git checkout develop<br/> git fetch<br/> git pull<br/> git checkout -<br/> git merge develop<br/>}</span></pre><p id="6307" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">该函数名为<code class="fe mz na nb nc b">pullindev</code> <strong class="kh iu"> </strong>，它切换到开发分支，提取和提取，然后切换回您之前所在的分支，并在开发中合并。我用它来使我的特性分支与develop保持同步，而不必分别输入每个命令。我只需输入<code class="fe mz na nb nc b">pullindev</code> <strong class="kh iu"> </strong>并等待我的分支更新。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e0ec9221686664a14c635933120a1911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*n599xdcRyd-2rpA_dF_GIQ.gif"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">运行中的pullindev示例</figcaption></figure><p id="a934" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">函数很容易编写，因为我们大多数人都熟悉语法。简单地定义一个函数并在里面写一些bash。最容易编写的函数是当你只需要连续运行一堆命令时，但有时你可能想做一些更复杂的逻辑。</p><p id="cf78" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，Bash是一种完整的语言，能够为循环定义变量、if语句。编写复杂逻辑和自动化困难任务所需的一切。</p><p id="69a2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在编写复杂的Bash脚本时，可以参考这个<a class="ae mg" href="https://devhints.io/bash" rel="noopener ugc nofollow" target="_blank"> Bash备忘单</a>。</p><h2 id="15ec" class="nl le it bd lf nr ns dn lj nt nu dp ln kq nv nw lr ku nx ny lv ky nz oa lz ob bi translated">更复杂的例子</h2><p id="766b" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">在我的工作中，我们使用JIRA来跟踪新功能。我们使用JIRA卡id作为分支的前缀，并以卡id开始每次git提交，以跟踪每次提交的目的。</p><p id="087d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">示例:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="6db9" class="nl le it nc b gy nm nn l no np">$ git commit -m "DDP-1209: fixed typo"</span></pre><p id="643f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我想实现自动化，所以我创建了一个bash脚本，它可以从我的分支名称中读取JIRA卡id，然后将其添加到我的提交消息中。下面是代码:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="0a85" class="nl le it nc b gy nm nn l no np">commit () {<br/> branch="$(git branch | grep \* | cut -d ' ' -f2)"<br/> IFS='-' read -rA arrBranch &lt;&lt;&lt; "$branch"<br/> story="$arrBranch[1]-$arrBranch[2]"<br/> branchPrefix=${arrBranch[1]}<br/> commitMessage="$story: $1"</span><span id="3513" class="nl le it nc b gy oc nn l no np"> if [ "$branchPrefix" != "DDP" ]; then<br/>   commitMessage="$1"<br/>   read -q "REPLY?Branch name does not start with 'DDP'. would you      like still include prefix in commit? [y/n] "<br/>   echo<br/> if [[ $REPLY =~ ^[Yy]$ ]]; then<br/>    echo "Enter in a prefix:"<br/>    read ANSWER<br/>    commitMessage="$ANSWER: $1"<br/>   fi<br/> fi<br/> <br/> git add .<br/> git commit -m "$commitMessage"<br/>}</span></pre><p id="54cc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们来分解一下。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="4e60" class="nl le it nc b gy nm nn l no np">branch="$(git branch | grep \* | cut -d ' ' -f2)"</span></pre><p id="2d29" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这通过将<strong class="kh iu"> git branch </strong>结果通过管道传输到grep中来获取当前分支名称，并搜索以*开头的行，然后从分支名称中删除星号和空格。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="078a" class="nl le it nc b gy nm nn l no np">IFS='-' read -rA arrBranch &lt;&lt;&lt; "$branch"</span></pre><p id="375b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在每个<code class="fe mz na nb nc b">‘-’</code>处拆分分支机构名称。类似于跑<code class="fe mz na nb nc b">branch.split(‘-’)</code>。一个特征分支应该是这样的:<code class="fe mz na nb nc b">DDP-1209-my-new-feature</code></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="39d1" class="nl le it nc b gy nm nn l no np">story="$arrBranch[1]-$arrBranch[2]"</span></pre><p id="7408" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">创建变量<code class="fe mz na nb nc b">story</code>，它是拆分中的前两个项目，因此对于我们的示例，分支故事将等于<code class="fe mz na nb nc b">DDP-1209</code></p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="222d" class="nl le it nc b gy nm nn l no np">branchPrefix=${arrBranch[1]}</span></pre><p id="1557" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">将branchPrefix变量设置为第一个split，<code class="fe mz na nb nc b">DDP</code>以便稍后检查前缀是否正确。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="da38" class="nl le it nc b gy nm nn l no np">commitMessage="$story: $1"</span></pre><p id="78a0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">创建变量<code class="fe mz na nb nc b">commitMessage</code>，它是你的JIRA故事(卡片)id加上你输入的任何信息。即<code class="fe mz na nb nc b">commit “my commit message”</code>在这里<code class="fe mz na nb nc b">$1</code>等于“我的提交消息”</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="b0f7" class="nl le it nc b gy nm nn l no np">if [ "$branchPrefix" != "DDP" ]; then<br/>   commitMessage="$1"<br/>   read -q "REPLY?Branch name does not start with 'DDP'. would you      like still include prefix in commit? [y/n] "<br/>   echo<br/> if [[ $REPLY =~ ^[Yy]$ ]]; then<br/>    echo "Enter in a prefix:"<br/>    read ANSWER<br/>    commitMessage="$ANSWER: $1"<br/>   fi<br/> fi</span></pre><p id="484c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果branchPrefix不是<code class="fe mz na nb nc b">DDP</code>,通知客户分支不是以DDP开始，并询问他们是否仍然希望包括分支前缀。如果他们键入<code class="fe mz na nb nc b">y</code>，然后询问客户他们想添加什么作为前缀，并将他们的答案附加到<code class="fe mz na nb nc b">commitMessage</code>。</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="46ca" class="nl le it nc b gy nm nn l no np">git add .<br/>git commit -m "$commitMessage"</span></pre><p id="0697" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">存放所有用于提交的更改，并使用带前缀的提交消息提交。现在，当我想要提交我的更改时，我所要做的就是键入:</p><pre class="nd ne nf ng gt nh nc ni nj aw nk bi"><span id="de3a" class="nl le it nc b gy nm nn l no np">$ commit "my commit message"</span></pre><p id="f935" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它会自动将我的JIRA卡id添加到我的提交中，并自动保存我所有的更改，为我每天的提交节省了大量时间。</p><h1 id="0b60" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="a674" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">Bash脚本是一种简单的方法，通过自动化您每天在终端中输入的简单命令来提高您的生产率。您可以使用别名来创建易于使用的更长命令的快捷方式、自动化一系列简单命令的函数，并且可以编写更长更复杂的bash脚本来自动化需要更复杂逻辑的复杂任务。坐下来，放松，让自动化来完成工作。</p></div></div>    
</body>
</html>