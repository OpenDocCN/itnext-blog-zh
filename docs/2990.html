<html>
<head>
<title>Unleash the power within your Kubernetes Helm Charts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">释放你的Kubernetes头盔图表的力量</h1>
<blockquote>原文：<a href="https://itnext.io/unleash-the-power-within-your-kubernetes-helm-charts-7651b052fd52?source=collection_archive---------0-----------------------#2019-09-12">https://itnext.io/unleash-the-power-within-your-kubernetes-helm-charts-7651b052fd52?source=collection_archive---------0-----------------------#2019-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f675" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几个我希望在开始使用K8S时就知道的图表技巧。他们彻底改变了我们的基础设施自动化理念。</p><h1 id="5c76" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">从基础到高级</h1><p id="872f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在大多数应用程序图表实现中，除了部署yaml之外，我们还可能包括入口、配置映射或秘密。我们大多数人会止步于此，继续迎接其他挑战。然而，Helm Chart比我们想象的更强大，因为它打开了由Kubernetes驱动的整个自助服务生态系统的大门。</p><h1 id="a8bb" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">背景</h1><p id="0fdb" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">产品开发团队(Dev)和DevOps团队之间经常发生争斗。开发团队希望尽可能快地交付特性，而不需要等待基础设施的改变；DevOps团队希望保证主动选择最好的基础设施解决方案<strong class="js iu"/>。</p><p id="52cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我真的很喜欢这个游戏，因为这个过程鼓励健康的竞争，并迫使开发人员和开发人员都<em class="lr">提高他们的游戏</em>。</p><h1 id="c542" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">目标</h1><p id="6e01" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><em class="lr">“Dev永远不要等devo PS”</em>。相反，DevOps应该在开发团队需要之前预见并解决即将到来的微服务和基础设施问题(如下)。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/b796e1eace1f10f2500a5afd0e7a301d.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*-d8FeXANo7WRGWjaN1gajA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">微服务关注。美国红帽子的公司出品的计算机操作系统</figcaption></figure><p id="3033" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Kubernetes之前，没有简单或优雅的解决方案来实现这一点。</p><ul class=""><li id="abd8" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">幸运的是，有了Kubernetes，我们有了这个游戏的基础和必要的工具。</li><li id="9301" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">通过采用Istio，我们可以将DevOps体验提升到一个新的水平。这些Istio特性是为解决基础设施和微服务问题而全新构建的。</li><li id="5aab" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">使用操作员/控制器扩展和定制我们的CRD系列，并使用舵轮图将它们联合起来，我们可以释放更多的能量。</li></ul><p id="b748" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有兴趣构建一个超级赛亚人图，并让它以自助方式为您完成所有工作，请继续阅读以了解如何实现。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/90bd5113180a7a8b80cd4ae7fb23e25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*sVQgily0GYs-ZxKzzd3v2Q.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">龙珠超赛亚人悟空形态</figcaption></figure><h1 id="2ab4" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">不断发展的景观</h1><p id="cab3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">回顾过去5年多的时间，这一格局经历了几个阶段的演变:</p><ol class=""><li id="8242" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mt mk ml mm bi translated">传统的<a class="ae mu" href="https://en.wikipedia.org/wiki/Application_server" rel="noopener ugc nofollow" target="_blank">应用服务器</a></li><li id="6299" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mt mk ml mm bi translated">Dockerized微服务。传统上，使用具有有限微服务能力的Spring-boot +网飞操作系统。(<strong class="js iu">所以昨天！😜</strong>)</li><li id="a196" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mt mk ml mm bi translated">采用<em class="lr">Kubernetes/Mesos/Nomad/Swarm</em>进行容器编排</li><li id="7ed9" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mt mk ml mm bi translated">带服务网格的kubernetes:Istio，LinkerD等(<strong class="js iu">是</strong>，<strong class="js iu"> K8S是容器编排大战的赢家！</strong>)</li></ol><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/4606ad559d0218df8d3aca211f95617e.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*EJa4oiA2TjG67DMaThcbmA.png"/></div></figure><p id="925b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上图是我自己旅途中的一个例子。四年前，Mesos比Kubernetes更成熟，提供了更多的特性/框架，比如马拉松调度器和Kafka API框架。很多团队都采用了这个方案，比如2015年，<a class="ae mu" href="https://www.infoq.com/news/2015/05/mesos-powers-apple-siri/" rel="noopener ugc nofollow" target="_blank">苹果用Apache Mesos </a>重建Siri后端。</p><p id="e551" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，从2-3年前开始，Kubernetes击败了所有其他竞争对手，成为这场容器编排战争的明显赢家。</p><p id="238e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，我们所有的应用程序和基础设施组件在Mesos中都是基于容器的，将它们迁移到Kubernetes非常容易，尤其是使用打包系统:Helm Charts。</p><p id="b150" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">老实说，一开始，对我来说，Helm chart只是另一个新的包装系统。然而，我用得越多，它向我展示的力量就越大，这彻底改变了我的自动化哲学。</p><h1 id="0094" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">超级赛亚人航海图</h1><p id="a8a6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在大家都在采用“<em class="lr">管道作为代码”。</em>大多数CI/CD工具都支持这个特性，包括<a class="ae mu" href="https://cloud.google.com/tekton/" rel="noopener ugc nofollow" target="_blank">Tekton</a>(Knative pipelines)<a class="ae mu" href="https://concourse-ci.org/" rel="noopener ugc nofollow" target="_blank">concoursci</a>、Jenkins等。这通常与“<em class="lr"> Infrastructure as Code”一起使用，</em>表示在您的管道内部，一些任务可能会调用Terraform或Ansible模块来完成与基础架构相关的工作。</p><p id="d85a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们倾向于将这些基础设施管道用于各种任务，例如管理队列、数据库、文件存储、对象存储、秘密存储、API路由、消息路由等。其中，以下是应用程序和基础架构的一些<strong class="js iu">共同关注点</strong>:</p><ul class=""><li id="36a1" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated"><strong class="js iu">数据库自动化</strong>:由<a class="ae mu" href="https://flywaydb.org/" rel="noopener ugc nofollow" target="_blank"> flyway </a>、<a class="ae mu" href="https://www.liquibase.org/" rel="noopener ugc nofollow" target="_blank"> liquibase </a>等管理的DDL/DML/DCL</li><li id="1fe3" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated"><strong class="js iu"> API路由</strong>:添加/更新rest API路径，如<code class="fe mw mx my mz b">/api/blogs</code></li><li id="5f11" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated"><strong class="js iu">交通管理</strong>:金丝雀发布、黑暗启动、零停机部署、蓝绿部署</li><li id="5cae" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated"><strong class="js iu">队列</strong>:新应用程序的消息队列创建(AWS SQS，GCP发布)</li><li id="a9ad" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated"><strong class="js iu">消息路由</strong>:订阅过滤器消息过滤(AWS SNS)</li><li id="7127" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated"><strong class="js iu">对象/文件存储</strong> : S3或EFS/NFS文件夹创建。</li><li id="3f5b" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated"><strong class="js iu">认证和授权</strong>:保护和限制服务到服务的流量。</li></ul><p id="f4a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以前，对于同一环境中的微服务，我们在基础设施管道中处理这些任务。问题是这些管道随着时间的推移增长很快，特别是当你有数百个微服务的时候(<strong class="js iu">或</strong> <strong class="js iu">数以千计像优步</strong>)。最终，它们变成了一个庞然大物，在每个环境中为每个需求运行需要很长时间。</p><p id="2f38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个微服务的世界里，事情发展得更快，需要更频繁的变化，例如:</p><ul class=""><li id="950d" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">不断有新的微服务加入集群。</li><li id="bd3c" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">不相关的微服务在不需要时会被弃用</li><li id="bf2e" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">云资源需求随时变化。(从S3迁移到EFS)</li><li id="4c75" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">安全需求动态地、主动地变化(对新API的授权)</li></ul><p id="345f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们必须为每个新需求不断更新管道，测试它，在所有环境中推广它。DevOps会很快成为瓶颈。</p><p id="cbcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，有了舵图，我们可以结合几种强大的解决方案来解决这些问题。</p><h1 id="748b" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">多重解决方案</h1><h2 id="252a" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated">CRD解决方案</h2><blockquote class="nm nn no"><p id="bc7e" class="jq jr lr js b jt ju jv jw jx jy jz ka np kc kd ke nq kg kh ki nr kk kl km kn im bi translated"><strong class="js iu">一个<em class="it">定制资源</em>是Kubernetes API </strong>的扩展，在默认的Kubernetes安装中不一定可用。它代表了特定Kubernetes安装的定制。然而，许多核心Kubernetes功能现在都是使用定制资源构建的，这使得Kubernetes更加模块化。</p></blockquote><p id="c699" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在大多数情况下，我们利用内置的K8S CRDs，如Ingress、ConfigMap或Secret。为了使它更加强大和智能，我们还使用可选的CRD，它们与强大的工具一起安装，如Istio、<a class="ae mu" href="https://gloo.solo.io/" rel="noopener ugc nofollow" target="_blank"> Gloo </a>、Knative Serving、Knaitve Eventing等。以下是一些常见的CRD用法示例:</p><ul class=""><li id="544a" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">API路由:<a class="ae mu" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank"> K8S入口</a>，<a class="ae mu" href="https://istio.io/docs/reference/config/networking/v1alpha3/virtual-service/" rel="noopener ugc nofollow" target="_blank"> Istio虚拟服务</a>，<a class="ae mu" href="https://medium.com/solo-io/5-minutes-with-gloo-the-anatomy-of-a-virtualservice-4deb4cfc558e" rel="noopener"> Gloo虚拟服务</a></li><li id="5afd" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">高级流量管理(金丝雀发布，黑暗启动):Istio VirtualService，Gloo VirtualSerivce</li><li id="908d" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">身份验证:Istio网格策略，策略，目标规则</li><li id="040e" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">授权:<a class="ae mu" href="https://istio.io/docs/reference/config/authorization/istio.rbac.v1alpha1/" rel="noopener ugc nofollow" target="_blank"> Istio服务角色，服务角色绑定</a></li></ul><h2 id="875a" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated">基于初始化容器的解决方案</h2><blockquote class="nm nn no"><p id="fab5" class="jq jr lr js b jt ju jv jw jx jy jz ka np kc kd ke nq kg kh ki nr kk kl km kn im bi translated">一个Pod可以有多个运行应用程序的容器，但是它也可以有一个或多个in it容器，<strong class="js iu">，这些容器在应用程序容器启动之前运行</strong>。在Pod启动期间，<strong class="js iu">在网络和卷初始化之后，每个init容器按顺序</strong>启动。在下一个容器启动之前，每个容器必须成功退出。</p></blockquote><p id="45f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的任务可以很容易地放入Init-container中。此外，我们可以在需要时轻松管理每个步骤的顺序。示例:</p><ul class=""><li id="cffc" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">数据库自动化:DDL和DML变化(flyway/liquibase)</li><li id="7fec" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">特定于应用程序的Pod权限(AWS IAM+Kube2IAM获取权限)。</li><li id="b371" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">特定于应用程序的存储创建(AWS S3)</li><li id="e1c0" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">特定于应用程序的消息队列订阅(AWS SNS/SQS)</li></ul><h2 id="f8f0" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated">kubernetes-基于工作的解决方案</h2><p id="68a4" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">与Init-containers相比，Kubernetes job有自己的优势。尽管它们都完成了。<strong class="js iu"> K8S作业可以保证只运行一次。</strong>当使用init-containers时，如果您的副本集有多个pod，每个pod将运行它的init-container，我们必须小心并确保它们总是<strong class="js iu">幂等的</strong>。</p><p id="ff8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，<strong class="js iu">图钩</strong>可以在K8S作业上使用，控制作业执行的<code class="fe mw mx my mz b"> execution cycle</code>和<code class="fe mw mx my mz b">weight</code>，如下代码段所示。</p><ul class=""><li id="05ac" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated"><a class="ae mu" href="https://github.com/helm/helm/blob/master/docs/charts_hooks.md#the-available-hooks" rel="noopener ugc nofollow" target="_blank">执行周期</a>顾名思义很简单，比如预安装、后安装和预删除。</li><li id="71bd" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">权重有助于建立确定的执行顺序。对于每个周期，Tiller按重量和名称(重量相同的钩子)升序排列钩子。例如，-5，0，5按此顺序执行。</li></ul><pre class="lt lu lv lw gt ns mz nt nu aw nv bi"><span id="a516" class="na kp it mz b gy nw nx l ny nz">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: my-job-preinstall-first-to-run<br/>  annotations:<br/>    "helm.sh/hook": pre-install<br/>    "helm.sh/hook-weight": "-5"</span></pre><p id="081f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lr">提示:确保在下一个头盔展开前清理工作，因为重复的工作是不允许的。图表钩子可以用来实现这一点，比如</em> <strong class="js iu"> <em class="lr">预装</em> </strong> <em class="lr">钩子。</em></p><h2 id="935c" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated">基于运营商和定制CRD的解决方案</h2><p id="0ff7" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为了让它更上一层楼，我们定义了自己的CRDs，让开发者的应用程序图表能够管理自己的云资源，比如SNS、SQS队列，这些在上面的<strong class="js iu">共享关注点</strong>中提到过。与K8S Job和Init-Container相比，应用程序图表中的CRD更干净、更一致、对开发团队更友好。</p><p id="c264" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有几个流行的框架非常方便。他们的设计都很固执己见，所以挑你最喜欢的吧。</p><ul class=""><li id="def7" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated"><a class="ae mu" href="https://github.com/operator-framework" rel="noopener ugc nofollow" target="_blank"> CoreOS运营商框架</a></li><li id="bf1c" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated"><a class="ae mu" href="https://github.com/awslabs/aws-service-operator" rel="noopener ugc nofollow" target="_blank"> AWS服务框架</a></li><li id="165e" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated"><a class="ae mu" href="https://github.com/rancher/terraform-controller" rel="noopener ugc nofollow" target="_blank">牧场主地形控制器</a></li></ul><p id="e87f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mu" href="https://operatorhub.io/" rel="noopener ugc nofollow" target="_blank"> Operatorhub </a>是K8S社区分享操作员的好地方，在你写自己的之前一定要去看看。可能有人已经创建了一个。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/eb32be1a2cdf503063a73f694062d23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iy64r-L0-Hm_irDOVjo_wg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><a class="ae mu" href="https://operatorhub.io/" rel="noopener ugc nofollow" target="_blank">https://operatorhub.io/</a></figcaption></figure><h1 id="06f4" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">两个网关的图表</h1><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi of"><img src="../Images/0a8a0f018aa8e786c49330e61cb84be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nk9KhECNsa8vBPtXyWyqHg.jpeg"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">英格拉姆·平恩的版本</figcaption></figure><p id="91dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个最近的用例，我正在将我们的API网关(入口控制器)从Nginx-Ingress控制器迁移到<a class="ae mu" href="https://github.com/solo-io/gloo" rel="noopener ugc nofollow" target="_blank"> Gloo API网关</a>，这是一个Envoy支持的网关。它给了我们很多有用的特性，包括Canary release、Dark launch、轻量级直接Knative支持(如果没有安装Istio)、CloudEvent支持(从Gloo调用Lambda)等。</p><p id="77f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lr">如果你也有兴趣了解更多关于入口控制器的信息，我这里有一篇</em> <a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-ingress-controllers-how-to-choose-the-right-one-part-1-41d3554978d2"> <em class="lr">博客</em> </a> <em class="lr">帖子，里面有更多细节</em>。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi og"><img src="../Images/0cfc9a20fab2592cfd45d8434dee8ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*jdd4hm-S2U2TXCcHfhiMrg.png"/></div></figure><p id="feb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，我想以一种更平稳、更安全的方式来实现这一点，这意味着我只想在一些较低的环境中部署Gloo API Gateway，并在将其推广到较高的环境之前对其进行彻底的测试。</p><p id="9994" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们保留了现有的<em class="lr"> </em> <code class="fe mw mx my mz b">Ingress file</code> <em class="lr"> </em>和新的<code class="fe mw mx my mz b"> Gloo VirtualService file</code>，而不是在管道或应用程序图表中添加混乱的条件逻辑，它们都用于定义API路由规则。这里的诀窍是只有其中一个会被激活。哪个被激活取决于哪个入口控制器正在运行。只有当我们完成了所有的混沌测试，并准备推广Gloo gateway，我们才会以自己的速度进行，不会影响任何其他开发团队。</p><p id="7728" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lr">提示:确保所有Gloo CRDs都已展开，以避免警告</em></p><h2 id="0eea" class="na kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated">给我看看代码</h2><p id="be88" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><strong class="js iu">内置<em class="lr"> Nginx入口控制器</em> </strong>的K8S入口CRD</p><pre class="lt lu lv lw gt ns mz nt nu aw nv bi"><span id="616d" class="na kp it mz b gy nw nx l ny nz">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: blogs<br/>spec:<br/>  rules:<br/>  - host: "example.com"<br/>    http:<br/>      paths:<br/>      - path: /api/blogs<br/>        backend:<br/>          serviceName: blogs<br/>          servicePort: 8080</span></pre><p id="d378" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Gloo虚拟服务CRD<em class="lr">Gloo API网关</em>T33】</strong></p><pre class="lt lu lv lw gt ns mz nt nu aw nv bi"><span id="0903" class="na kp it mz b gy nw nx l ny nz">apiVersion: gateway.solo.io/v1<br/>kind: VirtualService<br/>metadata:<br/>  name: blogs<br/>  namespace: dev<br/>spec:<br/>  displayName: blogs<br/>  virtualHost:<br/>    domains:<br/>    - "example.com"<br/>    name: "dev.blogs"<br/>    routes:<br/>    - matcher:<br/>        prefix: "/api/blogs"<br/>      routeAction:<br/>        single:<br/>          upstream:<br/>            name: "dev-blogs-8080"<br/>            namespace: dev<br/>      routePlugins:<br/>        timeout: 100</span></pre><h1 id="cd42" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">摘要</h1><p id="c3f0" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">嗯，就是这样。我们讨论了舵图的几种使用模式，这些模式使应用程序变得更加自主和智能。有些可能适合您，有些可能不适合您的用例。然而，我希望这是信息，可以帮助你想出其他创造性的想法来满足你自己的需要。</p></div></div>    
</body>
</html>