<html>
<head>
<title>Linux: processes core dumps, systemd-coredump and Debian</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux:处理核心转储、systemd-coredump和Debian</h1>
<blockquote>原文：<a href="https://itnext.io/linux-processes-core-dumps-systemd-coredump-and-debian-cf2ddb11ef9e?source=collection_archive---------3-----------------------#2020-03-14">https://itnext.io/linux-processes-core-dumps-systemd-coredump-and-debian-cf2ddb11ef9e?source=collection_archive---------3-----------------------#2020-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2ae50e2de4a88a58b3a26616c4125865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5i2-JXYGCRt26iGc5AqHfA.png"/></div></div></figure><p id="6fbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要从Debian 9上的fro ma PHP进程中获取一个转储。</p><p id="398e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将采用Linux内核机制来创建和管理进程转储。</p><p id="73e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">内核的转储是以另一种方式创建的，请查看<a class="ae kw" href="https://wiki.archlinux.org/index.php/Kdump" rel="noopener ugc nofollow" target="_blank"> Kdump </a> на Arch Wiki。</p><h2 id="de5b" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">Linux核心转储</h2><p id="704d" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">如果内核执行了无效的操作并且必须停止，它将创建一个进程转储。</p><p id="5497" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，内核将向这样一个进程发送一个特殊的信号，以便该进程可以自己或使用标准机制来处理它，并将使内核应用该机制来创建该进程的内存转储。</p><p id="030d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的列表可以在内核源代码的<code class="fe lv lw lx ly b"><a class="ae kw" href="https://elixir.bootlin.com/linux/v5.5.8/source/include/linux/signal.h#L413" rel="noopener ugc nofollow" target="_blank">SIG_KERNEL_COREDUMP_MASK</a></code>宏中找到:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="43e4" class="kx ky iq ly b gy mh mi l mj mk">...<br/>#define SIG_KERNEL_COREDUMP_MASK (\<br/>        rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \<br/>  rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \<br/>        rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \<br/>  rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \<br/>        rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \<br/>  SIGEMT_MASK	<br/>...</span></pre><p id="145d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由<code class="fe lv lw lx ly b"><a class="ae kw" href="https://elixir.bootlin.com/linux/v5.5.8/source/include/linux/signal.h#L433" rel="noopener ugc nofollow" target="_blank">sig_kernel_coredump</a></code>宏使用:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="9132" class="kx ky iq ly b gy mh mi l mj mk">...<br/>#define sig_kernel_coredump(sig)	siginmask(sig, SIG_KERNEL_COREDUMP_MASK)<br/>...</span></pre><p id="e9b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数在出现致命错误时被调用，并依次调用<code class="fe lv lw lx ly b"><a class="ae kw" href="https://elixir.bootlin.com/linux/v5.5.8/source/kernel/signal.c#L2716" rel="noopener ugc nofollow" target="_blank">do_coredump()</a></code>函数:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="cb7c" class="kx ky iq ly b gy mh mi l mj mk">...<br/>  fatal:<br/>                ...<br/>    if (sig_kernel_coredump(signr)) {<br/>      if (print_fatal_signals)<br/>        print_fatal_signal(ksig-&gt;info.si_signo);<br/>      proc_coredump_connector(current);<br/>                        ...<br/>      do_coredump(&amp;ksig-&gt;info);<br/>    }<br/>...</span></pre><p id="438e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而<code class="fe lv lw lx ly b"><a class="ae kw" href="https://elixir.bootlin.com/linux/v5.5.8/source/fs/coredump.c#L565" rel="noopener ugc nofollow" target="_blank">do_coredump()</a></code>将创建一个内存转储，并将它保存在硬盘上。</p><h2 id="8e1f" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">信号和转储创建</h2><p id="a6cf" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">让我们检查它是如何工作的。</p><p id="4613" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以一个简单的C代码为例:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="51e2" class="kx ky iq ly b gy mh mi l mj mk">#include &lt;stdio.h&gt;<br/>#include &lt;unistd.h&gt;<br/><br/>int main() {<br/><br/>    while(1) {<br/>        pid_t pid = getpid();<br/>        printf ("Working with PID %lu\n", pid);<br/>        sleep(5);<br/>    }<br/>}</span></pre><p id="be54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建并运行:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="9773" class="kx ky iq ly b gy mh mi l mj mk">$ gcc make_dump.c -o make_dump<br/>./make_dump<br/>Working with PID 2714790</span></pre><p id="d04b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一个终端—发送一个信号，例如<code class="fe lv lw lx ly b"><a class="ae kw" href="https://ru.wikipedia.org/wiki/SIGSEGV" rel="noopener ugc nofollow" target="_blank">SIGSEGV</a></code> ( <em class="ml">分段冲突</em>)，代码11:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="62ff" class="kx ky iq ly b gy mh mi l mj mk">$ kill -s SIGSEGV 2714790</span></pre><p id="3d82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行应用程序的终端中检查其输出:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="4c41" class="kx ky iq ly b gy mh mi l mj mk">$ ./make_dump<br/>Working with PID 2714790<br/>…<br/>Working with PID 2714790<br/>Segmentation fault (core dumped)</span></pre><p id="82f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查转储文件:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="c236" class="kx ky iq ly b gy mh mi l mj mk">$ ls -l /tmp/ | grep 2714790<br/>-rw — — — — 1 setevoy setevoy 380928 Mar 10 11:24 coredump-make_dump.2714790</span></pre><p id="5988" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，您可以为任何已经运行的进程创建一个转储，例如——run<code class="fe lv lw lx ly b">sleep</code>:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="f664" class="kx ky iq ly b gy mh mi l mj mk">$ sleep 100 &amp;<br/>[1] 2761144</span><span id="eea9" class="kx ky iq ly b gy mm mi l mj mk">$ kill -s SIGSEGV 2761144\<br/>[1]+ Segmentation fault (core dumped) sleep 100</span><span id="db07" class="kx ky iq ly b gy mm mi l mj mk">$ file /tmp/coredump-sleep.2761144/tmp/coredump-sleep.2761144: ELF 64-bit LSB core file, x86–64, version 1 (SYSV), SVR4-style, from ‘sleep 100’, real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: ‘/usr/bin/sleep’, platform: ‘x86_64’</span></pre><h2 id="bafe" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">GDB —创建核心转储</h2><p id="e708" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">除了发送信号之外，您还可以使用<code class="fe lv lw lx ly b"><a class="ae kw" href="https://rtfm.co.ua/c-otladka-s-gdb-primery/" rel="noopener ugc nofollow" target="_blank">gdb</a></code>中的<code class="fe lv lw lx ly b">gcore</code>:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="d52d" class="kx ky iq ly b gy mh mi l mj mk">$ sleep 100 &amp;<br/>[1] 2762961</span><span id="c78d" class="kx ky iq ly b gy mm mi l mj mk">$ sudo gcore 2762961<br/>…<br/>Saved corefile core.2762961<br/>file core.2762961<br/>core.2762961: ELF 64-bit LSB core file</span></pre><h2 id="467d" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">GDB —读取核心转储</h2><p id="e43c" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">要检查转储的内容，您可以使用<code class="fe lv lw lx ly b">gdb</code>并将可执行文件作为第一个参数传递，将转储文件的路径作为第二个参数传递:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="287e" class="kx ky iq ly b gy mh mi l mj mk">$ gdb make_dump coredump-make_dump.2714790<br/>…<br/>[New LWP 2714790]<br/>Core was generated by `./make_dump’.<br/>Program terminated with signal SIGSEGV, Segmentation fault.<br/>0 0x00007f50d566e27e in clock_nanosleep@GLIBC_2.2.5 () from /usr/lib/libc.so.6<br/>(gdb)</span></pre><h2 id="2ba0" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated"><code class="fe lv lw lx ly b">kernel.core_pattern</code></h2><p id="e429" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在转储创建期间，内核将检查决定如何处理转储的参数<code class="fe lv lw lx ly b">kernel.core_pattern</code>。</p><p id="0947" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里你可以用指定符指定一个路径和一个文件名，或者给它传递外部转储处理程序，比如<code class="fe lv lw lx ly b"><a class="ae kw" href="https://www.freedesktop.org/software/systemd/man/systemd-coredump.html" rel="noopener ugc nofollow" target="_blank">systemd-coredump</a></code> (рассмотрим ниже).</p><p id="e11c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看<em class="ml">核心转储文件的命名</em>文档<a class="ae kw" href="http://man7.org/linux/man-pages/man5/core.5.html" rel="noopener ugc nofollow" target="_blank">此处&gt; &gt; &gt; </a>。</p><p id="3eff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里最常用的选项是:</p><ul class=""><li id="cb56" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated"><code class="fe lv lw lx ly b">%e</code>可执行文件的文件名(不带路径前缀)</li><li id="1afd" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><code class="fe lv lw lx ly b">%p</code>转储进程的PID，如进程所在的PID名称空间所示</li><li id="47cd" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><code class="fe lv lw lx ly b">%t</code>转储时间，以自纪元1970-01-01 00:00:00 +0000 (UTC)以来的秒数表示</li></ul><p id="d221" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在上面的GDB中观察到的文件<em class="ml">/tmp/coredump-make _ dump . 2714790</em>由<code class="fe lv lw lx ly b">kernel.core_pattern = /tmp/coredump-%e.%p</code>组成:</p><ol class=""><li id="a3ee" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv nb mt mu mv bi translated"><code class="fe lv lw lx ly b">/tmp</code>目录</li><li id="4428" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv nb mt mu mv bi translated"><code class="fe lv lw lx ly b">%e</code> -文件名以<em class="ml"> coredump </em>开头+一个可执行名факла<em class="ml">make _ dump</em></li><li id="ee10" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv nb mt mu mv bi translated"><code class="fe lv lw lx ly b">%p</code> -和一个被终止的进程PID - <em class="ml"> 2714790 </em></li></ol><p id="2b26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，不使用直接路径和文件名，您可以通过管道<code class="fe lv lw lx ly b">|</code>将转储数据传递给<code class="fe lv lw lx ly b">/dev/null</code>或类似于<code class="fe lv lw lx ly b">systemd-coredump</code>的处理程序。</p><h2 id="b5bd" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated"><code class="fe lv lw lx ly b">limits.conf</code></h2><p id="f0d0" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在创建转储之前，内核还将检查<code class="fe lv lw lx ly b">/etc/security/limits.conf</code>中<code class="fe lv lw lx ly b">core</code>的<em class="ml">软</em>和<em class="ml">硬</em>限制:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="e2d8" class="kx ky iq ly b gy mh mi l mj mk">$ cat /etc/security/limits.conf | grep core<br/>- core — limits the core file size (KB)<br/>* soft core 0</span></pre><p id="e36e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者直接在您当前的环境中检查:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="420a" class="kx ky iq ly b gy mh mi l mj mk">$ ulimit -c<br/>unlimited</span></pre><p id="c8b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个运行过程的极限可以从<code class="fe lv lw lx ly b">/proc</code>中找到其极限:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="b6e7" class="kx ky iq ly b gy mh mi l mj mk">$ ./make_dump<br/>Working with PID 2753034</span></pre><p id="3531" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和限制:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="1b13" class="kx ky iq ly b gy mh mi l mj mk">$ cat /proc/2753034/limits<br/>Limit Soft Limit Hard Limit Units<br/>…<br/>Max core file size unlimited unlimited bytes<br/>…</span></pre><h2 id="51bc" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated"><code class="fe lv lw lx ly b">fs.suid_dumpable</code></h2><p id="02ac" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">有时，如果进程进行了suid操作，例如使用<code class="fe lv lw lx ly b"><a class="ae kw" href="http://man7.org/linux/man-pages/man2/seteuid.2.html" rel="noopener ugc nofollow" target="_blank">setuid()</a></code> syscall，则无法创建转储。</p><p id="d160" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，行为由<code class="fe lv lw lx ly b">fs.suid_dumpable</code>控制:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="b908" class="kx ky iq ly b gy mh mi l mj mk">$ sysctl fs.suid_dumpable<br/>fs.suid_dumpable = 2</span></pre><p id="3c3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它可以接受0、1或2，参见<a class="ae kw" href="http://man7.org/linux/man-pages/man5/proc.5.html" rel="noopener ugc nofollow" target="_blank">手册proc </a>:</p><ul class=""><li id="db9f" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">0: ( <em class="ml">默认</em>)这提供了传统的(Linux 2.6.13之前)行为。不会为已更改凭据(通过调用seteuid或类似方法)或其二进制文件未启用读取权限的进程生成核心转储。</li><li id="2299" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">1: (" <em class="ml">调试</em>")所有进程尽可能转储内核。</li><li id="a793" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">2: (" <em class="ml"> suidsafe </em>")任何通常不会被转储的二进制文件(见上面的“0”)都被转储为只对root可读。</li></ul><h2 id="4069" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated"><code class="fe lv lw lx ly b">systemd-coredump</code></h2><p id="3200" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">当然，<code class="fe lv lw lx ly b"><a class="ae kw" href="https://www.freedesktop.org/software/systemd/man/systemd-coredump.html" rel="noopener ugc nofollow" target="_blank">systemd</a></code>有它自己的转储处理器——已经提到过<code class="fe lv lw lx ly b"><a class="ae kw" href="https://www.freedesktop.org/software/systemd/man/systemd-coredump.html" rel="noopener ugc nofollow" target="_blank">systemd-coredump</a></code>。</p><p id="8e8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Arch上默认使用Linux，因为Debian 9可以安装<code class="fe lv lw lx ly b">apt</code>:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="5959" class="kx ky iq ly b gy mh mi l mj mk">$ sudo apt -y install systemd-coredump</span></pre><p id="a93d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">配置文件— <code class="fe lv lw lx ly b">/etc/systemd/coredump.conf</code>。</p><p id="d9d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装后配置内核—通过管道将转储发送到<code class="fe lv lw lx ly b">systemd-coredump</code>:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="f681" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# echo ‘|/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %e’ &gt; /proc/sys/kernel/core_pattern</span></pre><p id="e6d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查一下:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="51e6" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# cat /proc/sys/kernel/core_pattern<br/>|/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %e</span></pre><p id="3630" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一些转储:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="5a72" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# sleep 10 &amp;<br/>[1] 27117</span><span id="741e" class="kx ky iq ly b gy mm mi l mj mk">root@bttrm-production-app-1:/home/admin# kill -s 11 27117<br/>[1]+ Segmentation fault (core dumped) sleep 10</span></pre><h2 id="0518" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated"><code class="fe lv lw lx ly b">coredumpctl</code></h2><p id="2739" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">要使用由<code class="fe lv lw lx ly b">systemd-coredump</code>管理的转储，可以使用<code class="fe lv lw lx ly b">coredumpctl</code>实用程序:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="1b1b" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# coredumpctl<br/>TIME PID UID GID SIG COREFILE EXE<br/>Mon 2020–03–09 20:10:16 EET 20882 0 0 11 present /home/admin/dump_test<br/>…<br/>Tue 2020–03–10 09:04:14 EET 16786 1003 1003 11 present /usr/sbin/php-fpm7.4<br/>Tue 2020–03–10 12:23:43 EET 27117 0 0 11 present /bin/sleep</span></pre><p id="d201" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="ml"> SIG </em>列中，我们可以看到一个信号被发送到被终止的进程，在这些情况下，它是<em class="ml"> 11 </em> == <code class="fe lv lw lx ly b">SIGSEGV</code>。</p><p id="05c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">转储文件位于<code class="fe lv lw lx ly b">/var/lib/systemd/coredump</code>目录下:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="dce6" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# ll /var/lib/systemd/coredump/<br/>total 125376<br/>-rw-r — — — 1 root root 25208 Mar 9 20:10 core.dump_test.0.6bb23c691d354e9dbf4382d109a5c1d4.20882.1583777416000000000000.lz4<br/>…<br/>-rw-r — — — 1 root root 33962 Mar 10 12:23 core.sleep.0.6bb23c691d354e9dbf4382d109a5c1d4.27117.1583835823000000000000.lz4</span></pre><p id="8eda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要观察转储的内容，请使用带有某些匹配条件的信息，例如PID:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="e567" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# coredumpctl info 27117<br/>PID: 27117 (sleep)<br/>UID: 0 (root)<br/>GID: 0 (root)<br/>Signal: 11 (SEGV)<br/>Timestamp: Tue 2020–03–10 12:23:43 EET (3min 3s ago)<br/>Command Line: sleep 10<br/>Executable: /bin/sleep<br/>…<br/>Hostname: bttrm-production-app-1<br/>Storage: /var/lib/systemd/coredump/core.sleep.0.6bb23c691d354e9dbf4382d109a5c1d4.27117.1583835823000000000000.lz4<br/>Message: Process 27117 (sleep) of user 0 dumped core.<br/>Stack trace of thread 27117:<br/>0 0x00007fc1a8053270 __nanosleep (libc.so.6)<br/>1 0x000056159fa6f91f n/a (sleep)<br/>2 0x000056159fa6f700 n/a (sleep)<br/>3 0x000056159fa6c9a4 n/a (sleep)<br/>4 0x00007fc1a7fbb2e1 __libc_start_main (libc.so.6)<br/>5 0x000056159fa6ca7a n/a (sleep)</span></pre><h2 id="85d5" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">Debian —没有创建核心转储</h2><p id="313f" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">上面描述的一切在两台装有Arch Linux的笔记本电脑上运行良好，但是在我项目的装有Debian 9的服务器上，转储是以一种通常的方式创建的，没有<code class="fe lv lw lx ly b">systemd-coredump</code>。</p><p id="8ed5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lv lw lx ly b">core_pattern</code>配置:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="2521" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# cat /proc/sys/kernel/core_pattern<br/>/tmp/core-%e.%p</span></pre><p id="afde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行一个进程，用11信号杀死它，检查<code class="fe lv lw lx ly b">/tmp</code> -这里没有转储。</p><p id="9a1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次运行应用程序:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="a75b" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# ./dump_test<br/>Working with PID 27954</span></pre><p id="0d68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并检查其极限:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="ed05" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# cat /proc/27954/limitsLimit Soft Limit Hard Limit Units<br/>…<br/>Max core file size 0 unlimited bytes<br/>…</span></pre><p id="7167" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ml">软</em>限制被设置为零值，例如，由于内核对转储文件的使用不能超过0字节，转储被完全禁用。</p><p id="f5e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将其设置为<em class="ml">无限制</em>:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="a901" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# ulimit -S -c unlimited</span></pre><p id="6c35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次运行应用程序，立即检查限制:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="9e87" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# ./dump_test 1&gt;/dev/null &amp;<br/>[3] 28399</span><span id="43be" class="kx ky iq ly b gy mm mi l mj mk">root@bttrm-production-app-1:/home/admin# cat /proc/$!/limits<br/>Limit Soft Limit Hard Limit Units<br/>Max cpu time unlimited unlimited seconds<br/>Max file size unlimited unlimited bytesMax data size unlimited unlimited bytes<br/>Max stack size 8388608 unlimited bytes<br/>Max core file size unlimited unlimited bytes<br/>…</span></pre><p id="03fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建转储:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="1d44" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# sleep 10 &amp;<br/>[4] 28613</span><span id="2f2b" class="kx ky iq ly b gy mm mi l mj mk">root@bttrm-production-app-1:/home/admin# kill -s 11 $!</span></pre><p id="5765" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查一下:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="88b5" class="kx ky iq ly b gy mh mi l mj mk">root@bttrm-production-app-1:/home/admin# ls -l /tmp/coredump-sleep.28613<br/>-rw — — — — 1 root root 380928 Mar 10 12:47 /tmp/coredump-sleep.28613</span></pre><p id="f0d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成了。</p><h2 id="b6ca" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">有用的链接</h2><ul class=""><li id="5f1e" class="mn mo iq ka b kb lq kf lr kj nc kn nd kr ne kv ms mt mu mv bi translated"><a class="ae kw" href="https://linux-audit.com/understand-and-configure-core-dumps-work-on-linux/" rel="noopener ugc nofollow" target="_blank">了解并配置Linux上的核心转储</a></li><li id="b3a7" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><a class="ae kw" href="https://www.fromdual.com/hunting-the-core" rel="noopener ugc nofollow" target="_blank">猎杀核心</a></li><li id="72cc" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><a class="ae kw" href="https://wiki.archlinux.org/index.php/Core_dump" rel="noopener ugc nofollow" target="_blank">核心转储</a> (Arch Wiki)</li><li id="8db0" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><a class="ae kw" href="https://ma.ttias.be/generate-php-core-dumps-segfaults-php-fpm/" rel="noopener ugc nofollow" target="_blank">在PHP-FPM中的segfaults上生成PHP核心转储</a></li><li id="5310" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><a class="ae kw" href="https://bugs.php.net/bugs-generating-backtrace.php" rel="noopener ugc nofollow" target="_blank">生成gdb回溯</a></li><li id="b41f" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><a class="ae kw" href="https://blog.amet13.name/2015/05/eaccelerator-coredump-php-fpm.html" rel="noopener ugc nofollow" target="_blank">проблемасe加速器и генерация核心转储для php-fpm </a></li><li id="2f94" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><a class="ae kw" href="https://jvns.ca/blog/2018/04/28/debugging-a-segfault-on-linux/" rel="noopener ugc nofollow" target="_blank">如何在Linux上获得segfault的核心转储</a></li><li id="4d4c" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><a class="ae kw" href="https://bencane.com/2011/09/22/kill-creating-a-core-dump/" rel="noopener ugc nofollow" target="_blank">终止:创建核心转储</a></li></ul></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="73f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ml">最初发布于</em> <a class="ae kw" href="https://rtfm.co.ua/en/linux-processes-core-dumps-systemd-coredump-and-debian/" rel="noopener ugc nofollow" target="_blank"> <em class="ml"> RTFM: Linux，devo PSисистемноеадммиитиииииованниое</em></a><em class="ml">。</em></p></div></div>    
</body>
</html>