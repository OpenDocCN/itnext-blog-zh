# 微服务和松耦合的神话

> 原文：<https://itnext.io/microservices-and-the-myth-of-loose-coupling-9bbca007ac1a?source=collection_archive---------2----------------------->

在上一篇文章中，我们讨论了什么是微服务，为什么它们看起来是一个好主意，以及直觉设计的陷阱。

 [## 微服务很简单。他们为什么这么努力？

### 这是关于现代分布式软件的系列文章的第一部分和介绍…

andrasgerlits.medium.com](https://andrasgerlits.medium.com/why-does-developing-microservices-look-so-easy-if-its-so-hard-d72a28ce7be1) 

在本文中，我们将研究什么是松耦合，并尝试按照这些原则设计一个非常简单的解决方案。

维基百科中的这个定义定义了“松散耦合”,就像我听到人们使用这个术语一样:

> 其中组件彼此弱关联(具有可破坏的关系),因此，一个组件的变化对另一个组件的存在或性能的影响最小。

松散耦合是弱关联。这种想法是，一个子系统中的变化对另一个子系统的影响应该尽可能小，无论是隐含的关于另一个子系统如何工作的知识、代码变化还是服务中断。

让我们做一些天马行空的思考。

## 定义一些简单的东西

让我们以来自*微服务. io* 的[第一个微服务架构](https://microservices.io/patterns/microservices.html)为例，这是谷歌在搜索“*微服务示例*”时抛出的(至少对我来说)。作为所有的例子，这可能是可以想象的最简单的一个，随着实践，每个人都质疑它们的适用性，但正如我们稍后会发现的，这已经比我们(嗯，我)可以在精神上管理的要复杂得多。

我们有 4 个子系统，所有这些子系统彼此松散耦合，其中门户或 API 用于查询和更新整体的状态。4 项服务:

*   **账户**
*   **库存**
*   **发货**
*   **网络用户界面**

其中的每一个都负责维护系统的一些元素，但是它们之间并不直接对话。这些服务意味着一些操作。我们将坚持最低限度。

首先，我们需要一种注册新客户的方法，这些客户有一些送货地址。为了创建这个流程，我们必须在我们的 **web UI** 中引入一个表单，并且我们需要添加一些验证。当新客户注册时，只有两件事可能出错(从业务角度来看):

*   客户的电子邮件可能已经存在
*   它的送货地址可能不在允许的城市列表中

这意味着**帐户服务**有一个数据库，其中包含它可以检查的现有客户帐户，并且**运输服务**有另一个数据库，其中包含允许的城市列表。

有两种方法可以做到这一点，即“先验证”和“后清理”方法。让我们两个都看看。

## 验证第一种方法

为了验证表单，我们必须询问两个服务是否支持表单上提供的值，因此我们向每个服务发送两个请求，并等待它们的回答。如果他们同意，我们就可以继续并拯救用户。

不能吗？

嗯，不一定。我们希望这是一个非常受欢迎的服务，这也是我们选择分布式设计的原因。考虑一下，如果存在一个允许的城市列表，那么必须有一种方法来添加/删除这个列表中的城市(即:这个列表是*可变的*)。我们也知道我们不允许多个客户端并行注册。什么会出错？

时间。在分布式系统中，我收集信息的时间和我依靠收到的信息存储数据的时间是不同的。我们可以假定，在大多数情况下，我们刚才使用的数据仍然是可靠的，但不是所有时候。我们需要识别我们查看的所有信息，以做出可以存储新客户记录的决定。

*   现有客户端是否有相同的电子邮件
*   地址是否在允许的城市列表中

这两者都可以在信息检索和存储之间改变。**更糟糕的是，我们在这里暗示我们了解会计和运输服务的内部。** **这显然打破了松散耦合原则。**我们假设我们知道这些服务是如何做出决定的，因此可以推断在更新过程中哪些信息会发生变化。

就每项服务而言，它们都工作正常。他们为他们所服务的简单请求提供了正确的答案，也就是说，他们验证并存储了正确的答案，但是他们最终得出了错误的结论。

接下来让我们看看清理方法。

## 事后清理方法

为了避开我们在前面的例子中发现的限制，我们将指示每个服务做我们要求它做的事情，如果它们不能做要求它们做的事情，就返回一个错误代码。我们要求受影响的服务使用“新客户端”事件，如果它们对此有问题，就向发起者报告错误代码。这意味着我们将问题转移到了特定的服务上，这使得一切更加独立，因此我们不再需要担心每个服务的内部逻辑。

相反，我们有两个问题。

首先，因为这两个操作中的任何一个都可以否决最初的“创建客户机”操作，所以我们需要一种方法来撤销任何地方的更改，即使其中只有一个有问题。在**会计**中有一个没有发货地址的客户是没有意义的，在**发货**中有一个没有客户的地址也是毫无意义的。

第二，因为我们现在必须在 **web UI** 上将这些潜在的问题报告回客户端表单，所以我们必须“知道”客户端在某处有一个半成品状态，以防操作失败。例如，如果地址无效，我们需要提示用户，我们还需要撤销在**会计**中保存的客户记录。我们将称这个算法为**协调器**。在最初引用的文章的例子中，这个问题的建议解决方案是[传奇模式](https://microservices.io/patterns/data/saga.html)。这告诉我们，如果发生这种情况，我们返回到**会计**服务，并要求它删除它存储的记录。简单，干净，自成一体。

还记得我们的系统是如何设计容错的吗？自从我们引入了 **orchestrator** 之后，我们现在要担心另一点信息，它不再像在数据库表中有一条记录那么简单。由于 **orchestrator** 是一段正在执行的代码，并且由于它必须在托管它的计算机丢失后仍然存在，我们现在需要引入某种持久的工作流解决方案，它可以存储正在执行的[有限状态机](https://en.wikipedia.org/wiki/Finite-state_machine)的状态，这样，如果它失败了，我们可以按预期恢复操作。如果做得不够，我们的数据库要么会有一些没有客户的送货地址，要么相反，换句话说，我们会让我们的系统处于不可预测的状态。

好吧，假设我们及时考虑了所有这些，我们引入了一个持久的、有状态的工作流解决方案，我们有一个到处都有多个冗余的工作设置。我们说完了吗？嗯，不完全是。

## 并行操作

我们已经提到了这样一个事实，即我们在由某人维护的 **shipping** 服务中有一个允许的城市列表。这假定了另一个操作:“维护城市”。假设这个列表是用一个简单的操作更新的，这个操作永远不会出错，它返回一个地址列表，操作员必须通知这个列表关于发货的变化。这怎么成问题了？

嗯，这本身不是问题，问题来自于并行发生的两个过程之间的交互。记住这个(越来越复杂)练习的要点是**减少耦合**，即:减少子系统之间隐含的信息量。

孤立地看，到目前为止，**航运**服务有三项业务:

*   新地址
*   删除地址
*   维护城市

该服务可以保证，当城市被更新并且返回违规地址列表时，它们是正确的，并且当添加新地址时，它会对照最新的允许城市列表进行检查，所以如果我们单独看服务，一切都很好。

这个问题源于这样一个事实，即一个地址在通过另一个服务的验证之前不是一个“真正的”地址，由于松散耦合原则，我们不知道这一点，这可能导致地址被返回给操作者，而没有客户记录。我们已经确定这是错误的行为，所以现在，运营商在根据他们从“维护城市”操作中收到的列表寻找要通知的客户时，必须将这些知识级联到软件中。

有很多方法可以解决这个问题，但它最终会回来困扰我们。事实上，运营商的 UI 软件(第五个服务)现在必须知道，我们需要为没有客户端记录的地址创建一个特例，因为我们可能会存储半成品“创建客户端”操作的状态，因为之前做出的一些设计决策正是我们试图通过最初的松散耦合来避免的问题。事实是“耦合”必须去某个地方，除非子系统参与昂贵的两阶段提交或其他一些通常不切实际的整体式设置。

在下一篇文章中，我们将通过一个稍微复杂一点的例子来看看我们需要做些什么来解决这类问题。

[https://andrasgerlits . medium . com/micro services-clearing-up-the-definitions-f 679 ebb 794 CB](https://andrasgerlits.medium.com/microservices-clearing-up-the-definitions-f679ebb794cb)