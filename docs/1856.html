<html>
<head>
<title>JavaScript debugging techniques at FrontEnd side</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端JavaScript调试技术</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-debugging-techniques-at-frontend-side-ae6d5110ad81?source=collection_archive---------6-----------------------#2019-02-11">https://itnext.io/javascript-debugging-techniques-at-frontend-side-ae6d5110ad81?source=collection_archive---------6-----------------------#2019-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84d5a7c7f1c0701da3f9b9a592041257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EAlxWCsiV4x39VjYRzhOUw.png"/></div></div></figure><p id="970c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有很多策略可以调试代码中的问题。从我的经验来看，没有一个简单的策略可以解决所有问题。总的来说，我发现三种主要的策略，从最流行到最不流行。</p><ol class=""><li id="5da3" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">蛮力法</strong>。这种方法最常见，效率最低。在这里，开发人员只是打印出所有相关的内存堆栈，并观察与预期数据不一致的潜在位置。</li><li id="5440" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">回溯法</strong>。这种方法适用于相当小的应用程序。该过程从检测到特定症状的地方开始。从那里开始，对整个源代码进行反向跟踪。这里的步骤是:观察谁是特定函数的调用者，找到它的调用者，检查与该函数相关的问题是否出现在那里。如果没有，则转到该函数的调用方，依此类推。</li><li id="dae0" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">原因消除方法</strong>。这种方法很少使用。也叫<strong class="ka ir">归纳演绎</strong>。与错误发生相关的数据被组织起来以隔离潜在的原因。开发人员创建一个错误原因假设，并组成一个特殊的数据形状传递给函数，该函数将证明或否定该假设。</li><li id="0a6f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">自己的经验方法</strong>。它需要对产品及其潜在的弱点有很好的了解。在这种情况下，开发人员已经知道所报告的错误的原因，因为他们知道API可能会被意外更改，并且源代码对这种更改非常敏感。或者数据类型已更改，但源代码没有相应的失败检查。</li></ol><p id="e035" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们概述一些调试过程的实用方法。</p><h1 id="2293" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">带有日志输出的简单调试方法</h1><p id="ae4c" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">在这种方法中，开发人员只需在代码中添加打印输出(console.log、alert等)。这有助于理解与代码相关的一些中间状态。这种方法介于蛮力和回溯方法之间(不过更接近蛮力)。在处于开发模式的系统中，已经有大量的日志消息，添加额外的日志并将这些日志与代码中的具体位置相匹配变得非常困难。当然，所有这些信息都应该记在开发人员的脑子里，并且很有可能将注意力从解决问题转移到记住<code class="fe mn mo mp mq b">console.logs</code>的位置，并在最后让你的思维溢出。在这种情况下，开发人员应该已经依靠<a class="ae mr" href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" rel="noopener ugc nofollow" target="_blank">源映射</a>工具来避免处理精简代码。</p><h1 id="1d5b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">用REPL调试</h1><p id="fad9" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><a class="ae mr" href="https://www.tutorialspoint.com/nodejs/nodejs_repl_terminal.htm" rel="noopener ugc nofollow" target="_blank"> REPL </a>代表读取评估打印循环。这样的工具代表了一个类似外壳的计算机环境，可以在其中输入命令，系统以交互模式输出响应。如果开发人员能够访问源代码模块，就很容易建立原因消除方法策略。例如，开发人员已经定位了错误代码的潜在位置，通过REPL可以传递一个假设数据来证明这是一个正确的错误位置。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/6db9eb72690a1adc4b04856372611d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*AuGKppbZ2nHeTx6kaIV59w.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">node.js的REPL</figcaption></figure><h1 id="dd6f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用开发人员工具调试</h1><p id="cd4d" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">开发者工具是从系统获得详细反馈的好地方。例如<a class="ae mr" href="https://developers.google.com/web/tools/chrome-devtools/" rel="noopener ugc nofollow" target="_blank"> Chrome Developer Tools </a>不仅可以帮助调试JS代码本身，还可以调试网络调用、内存堆、闭包、在感兴趣的函数调用上设置断点、调试浏览器DOM以及与之相关的css计算。</p><p id="c811" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但主要是我想继续用断点<a class="ae mr" href="http://How To Pause Your Code With Breakpoints In Chrome DevTools" rel="noopener ugc nofollow" target="_blank">功能</a>暂停代码。这是回溯法策略的完美例子。它有助于在感兴趣的地方停止代码，观察其调用堆栈(并导航到直接或间接调用方)，检查它们等等。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/5979f74fe71859a604cd6d0632f4d4c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ED6UQtdXwc0V8CwIQUJHgg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">调试器暂停时的源模块视图</figcaption></figure><p id="2567" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在图片的右下角，你可以看到<strong class="ka ir">调用栈</strong>，在它的帮助下，你可以导航到父调用者并观察他们的代码。这个部分还有<strong class="ka ir">范围</strong>部分，它有助于研究闭包范围。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/5bc5301825642e498b44fa7921cadd9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*me0JlMrCTlbyUfJDABaI1w.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">关于调试器暂停状态的部分:线程、监视、调用堆栈、范围、断点</figcaption></figure><p id="0583" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Scope部分的帮助下，很容易观察当前的<a class="ae mr" href="https://hackernoon.com/javascript-execution-context-and-lexical-environment-explained-528351703922" rel="noopener ugc nofollow" target="_blank">词法环境</a>并分析内部传递的数据是否正确。这给了开发人员一个应用原因消除方法策略的机会。为此，您可以将作用域的某个部分存储为一个全局变量，并在此基础上进行一些操作。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e8d9ef1be68aad9d933fc8afae21869e.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*s8-AXthStenCOzcy_u0HpA.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">将作用域中的某个对象保存为全局变量</figcaption></figure><p id="1b5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，这些数据将在控制台部分以相应的名称(通常命名为temp1、temp2、…)访问，开发人员可以对其进行一些操作。</p><p id="63b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了从代码中的当前断点开始导航，使用了特殊的导航面板或相应的热键。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/cf3f91ebfdc628640d777ab49231b5da.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*XiHQ0NINBzQai2jVRUo0mw.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">从当前断点处开始导航</figcaption></figure><p id="60ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果系统没有一个保存状态的地方，调试过程就相当困难。有时需要放一堆断点来发现不一致。但即使在这种情况下，Chrome Dev Tools也有一个名为Breakpoints的特殊部分，它描述了你已经放在源代码中的所有断点。</p><p id="6a9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个帮助你免费调试的有趣方法是不离开Chrome直接修改你的代码(称为工作区的特性)。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/1bf950c04f810ba49883b38cefbc9f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsrSrrMvUjZhceMhpYnc2w.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">Chrome中的工作空间管理</figcaption></figure><p id="b0ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有需要做的就是把具体的文件夹和源代码放到这个源代码标签中，你的代码映射就会出现在这里。现在，您可以直接编辑本地文件，而无需离开浏览器。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/5b110ba67db05d770cb1dca672b24ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCLEsZsKrhhxsYq4-wRVuw.png"/></div></div></figure><p id="fec3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时候感觉很多余，因为你的编辑器甚至IDE可以做更酷的事情。但对于一些代码哇效果保证刮的例子:)</p><h1 id="6fe2" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="57c0" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">根据所选择的调试方法，市场上有多种工具可供选择。例如，每个大的库都有一些由社区发布的调试最佳实践和工具。</p><p id="66a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">WebStorm IDE提供了一个很棒的工具包，可以使用各种预置进行安装调试。但是总体思路、外观和感觉体验与Chrome开发工具中的非常相似。在我们公司，我们积极使用它来调试NodeJS代码库。</p><p id="2873" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为你的应用程序编写单元或行为测试已经可以帮助避免大多数潜在的问题，甚至有助于提高作者对功能的关键部分以及这些部分应该做什么的理解。在这种情况下，原因排除法可以应用于编写测试的阶段，在这个阶段，您假设一些定义的输入属性应该导致函数的一些定义的输出…</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/eebffba60627e992ad90bc7ff90180a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lJHPn0l10EAXI1P_2dYpA.png"/></div></div></figure><p id="d516" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您觉得这篇文章有帮助，请点击👏按钮并在下面随意评论！</p></div></div>    
</body>
</html>