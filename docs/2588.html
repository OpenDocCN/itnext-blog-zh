<html>
<head>
<title>Serverless, Durable functions, how YOU can learn to implement the Fan-out/fan-in pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器、持久的函数，如何学习实现扇出/扇入模式</h1>
<blockquote>原文：<a href="https://itnext.io/serverless-durable-functions-how-you-can-learn-to-implement-the-fan-out-fan-in-pattern-b6a6ae671cfc?source=collection_archive---------5-----------------------#2019-06-18">https://itnext.io/serverless-durable-functions-how-you-can-learn-to-implement-the-fan-out-fan-in-pattern-b6a6ae671cfc?source=collection_archive---------5-----------------------#2019-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/11d03758df850a7d10baf4a8797691c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkKFylNkNmeW8OdxTc48Ow.jpeg"/></div></div></figure><p id="8192" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，很乐意接受您对主题或改进的建议/Chris</p><blockquote class="kx ky kz"><p id="7943" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">持久函数使你能够编写大型复杂的应用程序流。最好的部分是，它使用你知道的无服务器功能。你只需要专注于定义事情应该如何流动。</em></p></blockquote><p id="e2a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一部分<a class="ae kw" href="https://dev.to/azure/durable-functions-stateful-long-running-functions-in-serverless-part-i-5bm" rel="noopener ugc nofollow" target="_blank">第一部分——持久功能</a>中，我们尝试学习不同的核心概念，例如:</p><ul class=""><li id="34cd" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir"> Orchestrator函数</strong>，这是包含您的业务流程的函数</li><li id="de49" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">活动功能</strong>，执行实际工作的功能</li><li id="a31b" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">客户端功能</strong>，入口点</li></ul><p id="5ea4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一篇文章中，我们构建了一个应用程序，一个接一个地执行许多活动功能。<br/>以这种方式执行功能有一个名字，<em class="la">链接</em>，是一种已知的应用模式。</p><p id="df71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将了解:</p><ul class=""><li id="33b3" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir">应用模式</strong>，让我们仔细看看持久功能使用的最常见的架构模式。</li><li id="d1c7" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">扇出/扇入</strong>，我们将特别放大<em class="la">扇出/扇入</em>图案。</li><li id="35a4" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">实验室</strong>，作为我们学习<em class="la">扇出/扇入</em>模式的一部分，我们将用它来构建一些东西，以确保我们理解核心概念</li></ul><h1 id="3ea8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">资源</h1><p id="57bc" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">- <a class="ae kw" href="https://azure.microsoft.com/en-gb/free/?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank">免费账户Azure账户</a>你需要在Azure上注册使用持久函数<br/> - <a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/quickstart-js-vscode?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank">用JavaScript创建你的第一个持久函数</a>快速入门，带你创建持久函数<br/> - <a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-concepts?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank">持久函数概念</a>在这里阅读更多关于概念和模式以及如何实现所述模式的内容。<br/> - <a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-checkpointing-and-replay#orchestrator-code-constraints?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank"> Orchestrator功能约束</a>您需要了解的约束。<br/> - <a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-external-events?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank">具有持久功能的事件处理</a> <br/>如何引发和处理事件。<br/> - <a class="ae kw" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-concepts?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank">应用模式</a> <br/>对您可以实现的不同应用模式的描述</p><h1 id="516a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">应用模式</h1><p id="b463" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">对于持久函数，我们可以使用不止一种模式。让我们从更高的角度来看一下我们拥有的最常见的应用程序模式:</p><ul class=""><li id="46b4" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">链接，一系列函数以特定的顺序执行，这是我们在持久函数系列的第一篇文章中使用的模式</li><li id="e21f" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">扇出/扇入</strong>，并行执行多个功能，然后等待所有功能完成</li><li id="a09b" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">异步HTTP API</strong>，实现这种模式的一种常见方式是让HTTP调用触发长时间运行的动作。然后，将客户端重定向到一个状态端点，客户端轮询该端点以了解操作何时完成</li><li id="6bcd" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">监控</strong>，指的是工作流程中一个灵活的、循环的流程。一个例子是轮询直到满足特定条件</li><li id="5a53" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">许多自动化流程都涉及到某种形式的人工交互。让人类参与自动化过程是很棘手的，因为人们不像云服务那样高度可用和响应迅速。自动化流程可以通过使用超时和补偿逻辑来实现这一点</li></ul><h1 id="ab00" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">扇出/扇入</h1><p id="a671" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">下图很好地解释了这种模式:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a8b5e2b20aca0f8b8e377d9cb844c606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/0*75EF4zTc6EADOdGQ.png"/></div></figure><p id="9aca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个模式中，我们开始执行函数<code class="fe na nb nc nd b">F1</code>。此后，我们有三个并行函数，我们希望在继续执行函数<code class="fe na nb nc nd b">F3</code>之前执行它们。我们执行这三个并行函数的顺序并不重要。关键是他们都需要完成，然后我们才能继续。</p><p id="4d62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有很多问题，比如:</p><ol class=""><li id="6ce5" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv ne lk ll lm bi translated">我什么时候会使用这种模式</li><li id="423a" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv ne lk ll lm bi translated">如果我使用这个模式，我将如何实现它？</li></ol><p id="62a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着依次回答每个问题。<em class="la">什么时候</em>你会用？这种行为在很多工作流中都有体现。一个非常常见的领域可能是工厂中的装配线。假设我们有一个玩具汽车工厂。想象一下，你从制造底盘开始，这将是第<code class="fe na nb nc nd b">F1</code>步。然后，它移动到一个工位，在那里3个不同的装配工都需要把他们自己的东西添加到这个产品上。一个人加轮子，第二个人车门，第三个人加发动机。然后，当它们完成时，它移动到最后一个工位F3，在那里玩具车获得一层油漆。</p><p id="dbb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是了。漂亮的车和快乐的孩子。:)</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/019f98bdfd86348865a2652cc91be0a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tg7Pd5fSyByYJIGw.jpg"/></div></div></figure><p id="2094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你可能在某个地方工作，在那里你做的事情没有让孩子们开心那么有魅力，但原则是一样的。你有一个由几个步骤组成的东西，你想让一些步骤并行执行，一些按顺序执行。</p><p id="def2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们试着回答另一个问题，即<em class="la">如何</em>。</p><p id="add8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在持久函数中有一些很好的构造，这些构造使我们能够并行运行，并使我们能够等待一组活动，直到它们都处理完。</p><p id="60e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你问的那些结构是什么？他们有三个人:</p><ol class=""><li id="3884" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv ne lk ll lm bi translated"><strong class="ka ir">引发</strong>外部事件</li><li id="6ad3" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv ne lk ll lm bi translated"><strong class="ka ir">等待</strong>外部事件</li><li id="7715" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv ne lk ll lm bi translated"><strong class="ka ir">决策</strong>逻辑</li></ol><p id="e8de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的第一个看起来像这样:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="ae2c" class="nk lt iq nd b gy nl nm l nn no">await client.raiseEvent(instanceId, 'EventName', &lt;value&gt;);</span></pre><p id="9d13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个构造如下所示:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="3e97" class="nk lt iq nd b gy nl nm l nn no">yield context.df.waitForExternalEvent("EventName");</span></pre><p id="e904" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三个构造如下所示:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="ca20" class="nk lt iq nd b gy nl nm l nn no">yield context.df.Task.all([gate, gate2, gate3]);</span></pre><p id="8697" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它需要更多的解释。它回答了我们应该如何等待的问题。上面说我将<code class="fe na nb nc nd b">gate</code>、<code class="fe na nb nc nd b">gate2</code>和<code class="fe na nb nc nd b">gate3</code>全部解决，然后再采取下一步行动。在Orchestrator函数中一起使用时，它可能看起来像这样:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="2e8d" class="nk lt iq nd b gy nl nm l nn no">const gate = context.df.waitForExternalEvent("WheelsAddedEvent");<br/><br/>const gate2 = context.df.waitForExternalEvent("DoorsAddedEvent");<br/><br/>const gate3 = context.df.waitForExternalEvent("SteeringAddedEvent");<br/><br/>yield context.df.Task.all([gate, gate2, gate3]);<br/><br/>const result = yield context.df.callActivity("Send_Car_To_Be_Painted");</span></pre><p id="81e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，上面说，任何上述事件可以以任何顺序发生，但我们将只发送我们的玩具车被油漆，如果所有需要的汽车部件都已添加。</p><p id="c7d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以想象你现在在想什么。那养个事件呢？。我什么时候做那个？想象一下，在每一个组装点，你做的实际工作是添加轮子、门或转向，在你完成之后，你调用一个REST端点，这个端点最终引发它各自的事件。让我用一张图展示一下:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/bd78a302adfa69429c142006ade3860d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K60ey1DJMR-WSqG2.png"/></div></div></figure><p id="7b5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理解如何构建这样一个流程可能还有点模糊。别担心，我们会在下一个标题中展示这一点。</p><h1 id="f072" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">实验室——夏尔的晚餐会议</h1><p id="e927" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在本实验中，我们将使用我们刚刚介绍的所有概念，即如何引发事件、等待事件以及介绍两种不同的决策逻辑方法。</p><p id="33d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个演示的主题是LOTR或指环王，更具体地说是电影霍比特人的开始。那里发生了什么？这一切都是从夏尔的一个晚宴开始的，在那里，探险队的所有成员都聚在一起，共进晚餐，然后他们就出发了。当然，它们最后会吃掉比尔博所有的食物，但那是另一回事了。</p><p id="ae12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，选择这个场景来演示持久功能的原因是它代表了一种<em class="la">扇出/扇入</em>模式。一些最初的事情发生了。然后一个接一个的晚宴客人到了，顺序无所谓。当他们都到达并吃过晚餐后，他们终于可以继续他们的冒险了。</p><blockquote class="kx ky kz"><p id="eae9" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">好了，我们需要</em>在持久函数中编排<em class="iq">这一点，那么我们从哪里开始呢？</em></p></blockquote><p id="bbfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先确定我们有哪些<em class="la">事件</em>。如果你没记错你的霍比特人电影，晚餐客人一个接一个到达。所以客人<em class="la">到达</em>是一个事件。我们也有一些决策逻辑。一旦所有参加晚宴的客人都聚集在一起，他们就开始谈论他们的大计划。所以我们需要等所有人都到达后才能继续。有了这些知识，我们实际上可以开始推敲我们的orchestrator逻辑，就像这样:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="ad97" class="nk lt iq nd b gy nl nm l nn no">const gate = context.df.waitForExternalEvent("BilboArrived");<br/><br/>const gate2 = context.df.waitForExternalEvent("DvalinArrived");<br/><br/>const gate3 = context.df.waitForExternalEvent("GandalfArrived");<br/><br/>yield context.df.Task.all([gate, gate2, gate3]);<br/><br/>const result = yield context.df.callActivity("Talk_Shop");</span></pre><p id="8b34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面我们已经创建了三个不同的事件<code class="fe na nb nc nd b">BilboArrived</code>、<code class="fe na nb nc nd b">DvalinArrived</code>、<code class="fe na nb nc nd b">GandalfArrived</code>，最后，我们有一个活动，当所有的晚餐客人都到位后，我们就开始<code class="fe na nb nc nd b">Talk_Shop</code>。</p><blockquote class="kx ky kz"><p id="5ebd" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">是的，是的，我知道还有很多客人，但以上将说明原则:)</em></p></blockquote><p id="7077" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从我们的概览图中我们了解到，我们可以创建带有HTTP触发器的普通Azure函数，当完成时可以引发事件，所以差不多就是这样，接下来让我们将它变成实际的代码。</p><h1 id="d8ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">支持我们的项目</h1><p id="f1c0" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们首先调用我们的命令面板，或者是<code class="fe na nb nc nd b">CMD + SHIFT + P</code>或者是<code class="fe na nb nc nd b">View &gt; Command Palette</code>，然后我们选择下面的选项</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/9d56b54eedabe0d8eeee58886ea1c447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ngF0yxLI9mywpjud.png"/></div></div></figure><p id="5425" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是创建一个<code class="fe na nb nc nd b">HttpStart</code>函数。我们再次调用命令面板，选择创建Azure函数并选择<code class="fe na nb nc nd b">Durable Functions HTTP Starter</code>。</p><p id="51c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们选择创建一个orchestrator函数。我们遵循与上面相同的步骤，但是我们选择了名为<code class="fe na nb nc nd b">Durable Functions Orchestrator</code>的步骤。</p><p id="e2e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们选择创建一个普通的<code class="fe na nb nc nd b">Azure Function</code>，我们选择它作为一个HTTP触发器，并将其命名为<code class="fe na nb nc nd b">QuestParty</code>。</p><p id="b265" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们创建一个<code class="fe na nb nc nd b">Durable Functions activity</code>，并选择将其命名为<code class="fe na nb nc nd b">Talk_Shop</code>。</p><p id="f462" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的目录应该如下所示</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/29ca4e48844f71b4b9140dd3dc56e7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/0*_B2xzbPea1Tdx6h-.png"/></div></figure><h1 id="d6e7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">设置orchestrator</h1><p id="f93d" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好了，我们已经画出了这个可能的样子，但是再来一次:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="bcf4" class="nk lt iq nd b gy nl nm l nn no">const taskGandalf = context.df.waitForExternalEvent("Gandalf");<br/>const taskBilbo = context.df.waitForExternalEvent("Bilbo");<br/>const taskDvalin = context.df.waitForExternalEvent("Dvalin");<br/><br/>yield context.df.Task.all([taskGandalf, taskBilbo, taskDvalin]);<br/><br/>const result = yield context.df.callActivity("Talk_Shop");<br/><br/>return result;</span></pre><p id="331c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码说我们正在等待事件<code class="fe na nb nc nd b">Bilbo</code>、<code class="fe na nb nc nd b">Dvalin</code>、<code class="fe na nb nc nd b">Gandalf</code>，没有特定的顺序，下面的代码行说在我们继续之前这三个事件都需要发生:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="6e5d" class="nk lt iq nd b gy nl nm l nn no">yield context.df.Task.all([taskGandalf, taskBilbo, taskDvalin]);</span></pre><p id="0d4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，我们的最后一步是调用活动<code class="fe na nb nc nd b">Talk_Shop</code>:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="08a1" class="nk lt iq nd b gy nl nm l nn no">const result = yield context.df.callActivity("Talk_Shop");</span></pre><p id="882b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是配器。</p><h1 id="1a1e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">设置HTTP触发的<code class="fe na nb nc nd b">QuestParty</code>功能</h1><p id="19fa" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好，那么这个函数是由HTTP触发的。我们可以看到，如果我们进入<code class="fe na nb nc nd b">QuestParty/function.json</code>，特别是这个绑定条目:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="0ab9" class="nk lt iq nd b gy nl nm l nn no">{<br/>  "authLevel": "anonymous",<br/>  "type": "httpTrigger",<br/>  "direction": "in",<br/>  "name": "req",<br/>  "methods": [<br/>    "get",<br/>    "post"<br/>  ]<br/>}</span></pre><p id="7927" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，我们不得不添加一个东西来使它发挥作用，即这个条目:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="10ce" class="nk lt iq nd b gy nl nm l nn no">{<br/>  "name": "starter",<br/>  "type": "orchestrationClient",<br/>  "direction": "in"<br/>}</span></pre><p id="724d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使我们能够与编排客户端实例对话，我们将需要它来引发事件。现在，让我们看看下一个<code class="fe na nb nc nd b">QuestParty/index.js</code>的代码:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="c911" class="nk lt iq nd b gy nl nm l nn no">const df = require("durable-functions");<br/><br/>module.exports = async function (context, req) {<br/>  context.log('Quest party member arrival');<br/><br/>  const { who, instanceId }  = req.query;<br/><br/>  const client = df.getClient(context);<br/><br/>  const fellowshipMembers = ['Gandalf', 'Bilbo', 'Dvalin'];<br/>  const found = fellowshipMembers.find(m =&gt; who);<br/><br/>  if(!found)  {<br/>      context.res = {<br/>          status: 400,<br/>          body: `Someone unknown called ${who} just entered Bilbos house, crap!`<br/>      };<br/>  } else {<br/>      await client.raiseEvent(instanceId, who, true);<br/>      context.res = {<br/>          // status: 200, /* Defaults to 200 */<br/>          body: `Another hungry member ${who} entered Bilbos house`<br/>      };<br/>  }<br/>};</span></pre><p id="43b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们从查询参数中获取了两条非常重要的信息，即<code class="fe na nb nc nd b">who</code>和<code class="fe na nb nc nd b">instanceId</code>。<code class="fe na nb nc nd b">who</code>是我们传递一个类似<code class="fe na nb nc nd b">Gandalf</code>、<code class="fe na nb nc nd b">Dvalin</code>或<code class="fe na nb nc nd b">Bilbo</code>的论点。<code class="fe na nb nc nd b">instanceId</code>是对特定函数调用实例的引用。因此，如果我们想要影响一个特定的执行实例，我们需要知道那个特定的id。但是它是从哪里来的呢？你第一次调用<code class="fe na nb nc nd b">HttpStart/index.js</code>时，我们得到一个<code class="fe na nb nc nd b">instanceId</code>:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="62f9" class="nk lt iq nd b gy nl nm l nn no">module.exports = async function (context, req) {<br/>    const client = df.getClient(context);<br/>    const instanceId = await client.startNew(<br/>      req.params.functionName, <br/>      undefined, req.body<br/>    );<br/><br/>    context.log(`Started orchestration with ID = '${instanceId}'.`);<br/><br/>    return client.createCheckStatusResponse(<br/>      context.bindingData.req, <br/>      instanceId<br/>    );<br/>};</span></pre><p id="9d94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重点是，如果我们想要调用我们的REST API <code class="fe na nb nc nd b">QuestParty</code>，我们需要给它两个不同的参数来调用正确的执行实例，同时将正确的信息传递回编排函数。</p><p id="caaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理论到此为止。让我们启动并调试它。</p><h1 id="4f50" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">调试</h1><p id="d672" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好的，所以理解事物如何工作的最好方法就是简单地调试它。我们将通过点击<code class="fe na nb nc nd b">Debug &gt; Start Debugging</code>来做到这一点。</p><p id="22dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将为我们提供以下信息:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/a1d97e043ef8bdcc23e43d5a69125032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c2MKkL_Tf9E-kf12.png"/></div></div></figure><p id="ec78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面可以看出，我们有两个可以达到的端点:</p><ol class=""><li id="a421" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv ne lk ll lm bi translated"><a class="ae kw" href="http://localhost:7071/api/orchestrators/%7BfunctionName%7D" rel="noopener ugc nofollow" target="_blank">http://localhost:7071/API/orchestrators/{ function name }</a>这将触及我们的入口点并启动编排</li><li id="0d1a" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv ne lk ll lm bi translated"><a class="ae kw" href="http://localhost:7071/api/QuestParty" rel="noopener ugc nofollow" target="_blank">http://localhost:7071/API/QuestParty</a></li></ol><p id="d292" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从第一个开始，通过这样调用它来开始我们的编排:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="b803" class="nk lt iq nd b gy nl nm l nn no"><a class="ae kw" href="http://http://localhost:7071/api/orchestrators/Orchestrator" rel="noopener ugc nofollow" target="_blank">http://http://localhost:7071/api/orchestrators/Orchestrator</a></span></pre><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/90d3e383332312a99b65109cf17cce37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n7iiPiOKxf_Lxh4b.png"/></div></div></figure><p id="180a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们遍历所有内容，并在浏览器中收到以下内容:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/04ad9735f2d30e70b0c6f399ce8cf903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7GbdhlJr1NuQ5olw.png"/></div></div></figure><p id="b11c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们突出了重要的部分，即我们的执行标识符。如果我们想要引用这个特定的函数调用，我们需要跟踪它。</p><p id="a92a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还记得我们的编排是如何被告知等待事件<code class="fe na nb nc nd b">Gandalf</code>、<code class="fe na nb nc nd b">Bilbo</code>或<code class="fe na nb nc nd b">Dvalin</code>的吗？是时候触发这些事件了，不管我们从哪三个开始。让我们来看看另一个端点，例如:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="af48" class="nk lt iq nd b gy nl nm l nn no">http://localhost:7071/api/QuestParty?instanceId={the id we saw in the browser}&amp;who=Gandalf</span></pre><p id="6ad4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给定上面的示例URL，我们将触发事件<code class="fe na nb nc nd b">Gandalf</code>，给定代码是如何在<code class="fe na nb nc nd b">QuestParty/index.js</code>中编写的。因此，让我们从浏览器中复制<code class="fe na nb nc nd b">id</code>并点击浏览器中的<code class="fe na nb nc nd b">QuestParty</code> URL，看看会发生什么:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/dec5f5c3686d9b1bb6ca6c628c84338b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eVTgF5DeDTc_YTVf.png"/></div></div></figure><p id="e765" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们应该像这样点击VS代码和我们的<code class="fe na nb nc nd b">QuestParty</code>代码:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/dc28a1837b4cb2532315354c6926f3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HJaEHNyNM3bYMFm0.png"/></div></div></figure><p id="0e7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到接下来要发生的事情是我们的事件<code class="fe na nb nc nd b">Gandalf</code>将要被引发。所以我们让调试器继续运行。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/5f7f72ae8d33b24b2d845788bd8ae620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*iM6CDRgbDaPjhimi.gif"/></div></figure><p id="1055" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们对<code class="fe na nb nc nd b">QuestParty</code>端点进行另一个浏览器调用:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="8f2b" class="nk lt iq nd b gy nl nm l nn no">http://localhost:7071/api/QuestParty?instanceId={the id we saw in the browser}&amp;who={Dvalin, Gandalf or Bilbo}</span></pre><p id="bc42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用<code class="fe na nb nc nd b">Dvalin</code>和<code class="fe na nb nc nd b">Bilbo</code>分别作为参数<code class="fe na nb nc nd b">who</code>的args。在我们继续每次调用的调试器后，我们将在orchestrator中结束:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/87ddb82ee8f40476ac0c85535f83450c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WnnjTgNosbag1TWd.png"/></div></div></figure><p id="8380" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在上面看到的，我们的决策逻辑已经实现，所有三个事件<code class="fe na nb nc nd b">Gandalf</code>、<code class="fe na nb nc nd b">Bilbo</code>和<code class="fe na nb nc nd b">Dvalin</code>都已经发生，这意味着:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="bae7" class="nk lt iq nd b gy nl nm l nn no">yield context.df.Task.all(taskGandalf, taskBilbo, taskDvalin)</span></pre><p id="50e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我们不再停留在上一行，而是经过它，我们的最后一项任务是调用活动<code class="fe na nb nc nd b">Talk_Shop</code>。</p><p id="a3c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有它，每个人都在这里，准备执行一个任务。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e12f6f8bbc8bf99ca33dd7b7a5ac5b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*6FKEU3Woy5HYGJJ8.gif"/></div></figure><h1 id="54cc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">决策逻辑</h1><p id="a084" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们目前正在使用<code class="fe na nb nc nd b">Task</code>类上的方法<code class="fe na nb nc nd b">all()</code>来确定我们何时可以继续。<em class="la"> all </em>意味着我们必须等待所有定义的任务完成后才能继续。我们可以使用另一种有用的方法，即<code class="fe na nb nc nd b">any()</code>。这仅仅意味着，如果上述任何事件发生，我们可以继续。想象一下这样一种情况，三个经理中有一个需要签收一张发票，那么方法<code class="fe na nb nc nd b">any()</code>就是合适的方法，就像这样:</p><pre class="mw mx my mz gt ng nd nh ni aw nj bi"><span id="a9a7" class="nk lt iq nd b gy nl nm l nn no">const taskSignedCEO = context.df.waitForExternalEvent("InvoiceSignedCEO");</span><span id="4b2c" class="nk lt iq nd b gy nr nm l nn no">const taskSignedCFO = context.df.waitForExternalEvent("InvoiceSignedCFO");</span><span id="67e0" class="nk lt iq nd b gy nr nm l nn no">const taskSignedManager = context.df.waitForExternalEvent("InvoiceSignedManager");<br/><br/>yield context.df.Task.any([taskSignedCEO, taskSignedCFO, taskSignedManager]);<br/><br/>const result = yield context.df.callActivity("Set_Invoice_As_Processed");<br/><br/>return result;</span></pre><h1 id="63e0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="c18c" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">这一次我们讨论了持久功能的应用模式。在我看来，这使得持久功能变得非常强大和有用。我们谈到了了解<code class="fe na nb nc nd b">instanceId</code>或至少某种唯一标识符的重要性，以了解您正在处理的具体编排调用，只要它是唯一的，允许您回来继续处理相同的订单、组装或您正在处理的任何事情。</p><p id="9559" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们还讨论了特定的模式<em class="la">扇出/扇入</em>，并举例说明了如何在装配线上使用该模式，以及如何等待矮人/霍比特人/魔法师参加晚宴。无论您的业务类型如何，持久功能都可以极大地帮助您协调业务流程。</p><h2 id="e75c" class="nk lt iq bd lu ns nt dn ly nu nv dp mc kj nw nx mg kn ny nz mk kr oa ob mo oc bi translated">承认</h2><p id="28f5" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">感谢您对这篇文章的支持:)</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="20b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">原发布于2019年6月18日</em><a class="ae kw" href="https://dev.to/azure/durable-functions-application-patterns-13p2" rel="noopener ugc nofollow" target="_blank"><em class="la">https://dev . to</em></a><em class="la">。</em></p></div></div>    
</body>
</html>