<html>
<head>
<title>The Notorious FSC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">臭名昭著的FSC</h1>
<blockquote>原文：<a href="https://itnext.io/the-notorious-fsc-37bf78d80464?source=collection_archive---------3-----------------------#2018-10-27">https://itnext.io/the-notorious-fsc-37bf78d80464?source=collection_archive---------3-----------------------#2018-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="10bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我很幸运有时间开始学习如何反应。对于任何建筑商来说，工具箱里都有一项令人惊叹的技术。在完成了<a class="ae kl" href="https://reactjs.org/tutorial/tutorial.html" rel="noopener ugc nofollow" target="_blank">教程</a>并自己做了一点试验后，我拿起了一本罗宾·维鲁奇的<a class="ae kl" href="https://www.robinwieruch.de/the-road-to-learn-react" rel="noopener ugc nofollow" target="_blank"> <em class="km">学习反应之路</em> </a> <em class="km"> </em>。如果你对React感兴趣，你可能也读过——如果没有，帮自己一个忙，去看看吧！就是反应出你不知道的<a class="ae kl" href="https://github.com/getify/You-Dont-Know-JS" rel="noopener ugc nofollow" target="_blank"><em class="km">JS</em></a>对于Javascript的意义。</p><p id="031b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我有一个坏习惯，就是忘乎所以，发表过于密集(阅读:太长)的博客文章。作为我React之旅的一部分，我的一个目标是将我学到的重要东西写在博客上…一边写一边改进我的帖子。每个人都应该有足够的知识来变得有趣，但要比一部中篇小说短。我们走着瞧。🙂</p><p id="6d07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我想谈谈React中不吉利的命名“FSC”或<em class="km">功能性无状态组件</em>。不是从专家的角度，而是作为和你一起学习它们的人。它们是什么？你应该什么时候使用它们？我们将回答这些问题，并在此过程中重构一个简单的组件…</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/4f0c3c075d4ed42e5ab02dc48c1a615b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*pE22HxlYrdel5w6TA1NhEA.jpeg"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">像FSC这样的城市不必不透明！</figcaption></figure><h1 id="766d" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么，什么时候，为什么？</h1><p id="373c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我们来拆开“FSC”——<em class="km">功能性</em>、<em class="km">无状态</em>、<em class="km">组件</em>。原来名字里有很多东西。与<em class="km"> ES6类组件</em>构建在<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank"> ES6类</a>之上不同，FSC是使用…等等… <em class="km">函数</em>组成的！嗯，好吧。我们一直在使用函数，这并不可怕。所以我们有两种表示React组件的方式…我们如何选择一种呢？嗯，课程是ES6的，所以它们一定更好，对吗？请继续阅读！</p><p id="7f3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别是有了像<a class="ae kl" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>这样为你处理传输的现代工具，我认为可以肯定地说<em class="km">你可以用功能组件做任何你不能用类组件</em>做的事情。你经常会看到完全基于类的简单的无状态教程。这样做的一个好处是<em class="km">一致性</em>——组件有一个共同的外观和感觉，所以你可以说在浏览代码时有更少的认知负荷。我认为在某些情况下，模板化或生成样板文件也更容易。</p><p id="bb17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反之则不然… <em class="km">你可以用类组件做FSCs不支持的事情</em>。线索就在名字里:<em class="km">无状态</em>。FSC只能访问<a class="ae kl" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">属性</a>，不维护<a class="ae kl" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">本地状态</a> ( <code class="fe mc md me mf b">this.state</code>)。这也意味着您失去了对生命周期方法的访问(FSC本身，或其返回的JSX，实际上是render方法)。</p><p id="6689" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如有人可能认为一致的组件方法使代码更容易阅读一样，另一方面是<em class="km">FSC需要更少的代码行</em>(更少的潜在错误)并且在浏览代码时呈现更少的“噪音”。如果你的应用程序需要状态，你将失去一些“一致性”，因为你仍然需要一个或多个类组件。</p><p id="cabf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，过多考虑性能是不成熟的优化，但大型项目可能会看到将类组件重构为FSC的好处——如果不需要状态，就可以避免管理其生命周期的潜在开销，还可能看到更小的包大小。</p><p id="5455" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，即使在FSC中，您仍然可以在接收<code class="fe mc md me mf b">props</code>和返回JSX之间工作。您可以在您的FSC中添加自定义功能或其他代码，它们只是不会像<code class="fe mc md me mf b">constructor()</code>、<code class="fe mc md me mf b">componentDidMount()</code>、<code class="fe mc md me mf b">componentWillUnmount()</code>等那样与<a class="ae kl" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">组件生命周期</a>中的特定阶段相关联。</p><h1 id="3cdf" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">变得真实</h1><p id="db3e" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">一个片段抵得上一千个博客，所以让我们重构一个简单的组件……<a class="ae kl" href="https://reactjs.org/docs/thinking-in-react.html" rel="noopener ugc nofollow" target="_blank"><em class="km">React</em></a>中的思考是一个有趣的练习，它会带你将一个模拟组件变成一个真实的组件。在<a class="ae kl" href="https://codepen.io/gaearon/pen/BwWzwm" rel="noopener ugc nofollow" target="_blank">的示例解决方案</a>中，一切都被一致地实现为ES6类。教学的明智选择(甚至可能是您的个人偏好)，但是让我们将一个组件重构为FSC来巩固上述理论。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">一个简单的React ES6类组件。</figcaption></figure><p id="2a4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我是初学者，这是教程中的一个示例组件，由比我聪明的人编写……正如你所料，它已经很容易阅读了。当我们重构的时候，保持开放的心态，试着<strong class="jp ir">想象我们观察到的任何小收益在一个大项目中被放大</strong>。</p><p id="f204" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始处理代码之前，问一个问题总是好的，“<strong class="jp ir">这是重构的好候选吗？”</strong>根据我们目前所知，我们看到<code class="fe mc md me mf b">ProductCategoryRow</code>没有引用<code class="fe mc md me mf b">this.state</code>或任何生命周期方法。很好，看起来我们可以安全地把它变成一个函数:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">与FSC的组件相同。</figcaption></figure><p id="c441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的工作原理是一样的，现在我们只是接收<code class="fe mc md me mf b">props</code>作为函数参数。除了那个小的改变，我们旧的渲染方法变成了我们的FSC。这已经减少了需要考虑的代码行，但是ES6语法糖帮助我们消除了更多的视觉混乱。组合<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank"> <em class="km">箭头函数</em> </a>、<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> <em class="km">析构赋值</em> </a>和<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Function_body" rel="noopener ugc nofollow" target="_blank"> <em class="km">简洁体</em> </a>产生一个将注意力吸引到输入和输出的简化函数:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">ES6语法糖</figcaption></figure><p id="333c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">属性在函数签名中被析构，所以如果你传递更多的参数，只需添加参数...默认值也可以。从技术上来说，你可以选择简洁的黄金，去掉回车的括号，但是这会让一些语法高亮变得疯狂。😱</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">我们的FSC去11！</figcaption></figure><h1 id="5b07" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/7e9765eb37f09fda8bc36feb69190530.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*lfNScY5N4r7QcrozfrsLXw.jpeg"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">FSCs可以简化你的代码。</figcaption></figure><p id="4274" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你和我一样是React新手，希望这有助于澄清什么是FSC，什么时候它们是合适的，以及如何使用它们。我们从<em class="km">十二</em>行代码中取出一个非常简单的组件到<em class="km">七</em> ( <em class="km"> &gt; 40%缩减</em>)，这就给出了添加功能的一行代码(传入<code class="fe mc md me mf b">children</code>)。当设想如何简化围绕生产代码的测试来匹配时，这真是令人大开眼界！ES6语法确实提高了可读性和可维护性，并且由于有了像<a class="ae kl" href="https://facebook.github.io/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>和<a class="ae kl" href="https://babeljs.io" rel="noopener ugc nofollow" target="_blank"> babel </a>这样的工具，大多数人都可以使用它。</p><p id="3345" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个尺寸肯定不能适合所有… <em class="km">在现实世界中，你可能会有结合了ES6类和功能性无状态组件的应用</em>。对于初学者或中等规模的项目，FSCs可能是一个不成熟的优化。你需要知道取舍，并为工作选择合适的工具。对于某些人来说，一个更简洁的代码库，用更少的代码行来隐藏错误，可能就足以证明重构的合理性。</p></div></div>    
</body>
</html>