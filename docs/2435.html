<html>
<head>
<title>Boosting your kubectl productivity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高您的kubectl生产力</h1>
<blockquote>原文：<a href="https://itnext.io/boosting-your-kubectl-productivity-b348f7c25712?source=collection_archive---------3-----------------------#2019-05-23">https://itnext.io/boosting-your-kubectl-productivity-b348f7c25712?source=collection_archive---------3-----------------------#2019-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/68a8577b386af92e2d57edb488c72d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ARTbu6hVchCyFGly.jpg"/></div></div></figure><p id="e459" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">本故事最初发表于</em><a class="ae la" href="https://learnk8s.io/blog/kubectl-productivity" rel="noopener ugc nofollow" target="_blank"><em class="kz">learn k8s . io</em></a><em class="kz">。</em></p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="d23a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您使用Kubernetes，那么kubectl可能是您最常用的工具之一。每当你花费大量时间使用一个特定的工具时，很好地了解它并学习如何有效地使用它是值得的。</p><p id="3a9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文包含一系列技巧和诀窍，可以让您更高效地使用kubectl。同时，它旨在加深您对Kubernetes各方面工作方式的理解。</p><p id="c38b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文的目标不仅是让您的Kubernetes日常工作更加高效，而且更加愉快！</p><h1 id="f4c7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">内容</h1><ul class=""><li id="7299" class="mg mh it kd b ke mi ki mj km mk kq ml ku mm ky mn mo mp mq bi translated"><a class="ae la" href="#0430" rel="noopener ugc nofollow"> <strong class="kd iu">简介:kubectl是什么？</strong>T11】</a></li><li id="4e85" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae la" href="#b8ce" rel="noopener ugc nofollow"> <strong class="kd iu"> 1。用命令完成</strong>保存输入</a></li><li id="0c8c" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae la" href="#5ba7" rel="noopener ugc nofollow">②<strong class="kd iu">。快速查找资源规格</strong> </a></li><li id="7979" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae la" href="#c563" rel="noopener ugc nofollow"> <strong class="kd iu"> 3。使用自定义列输出格式</strong> </a></li><li id="7319" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae la" href="#0910" rel="noopener ugc nofollow">T25】4。轻松在集群和名称空间之间切换 </a></li><li id="1d15" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae la" href="#8d1d" rel="noopener ugc nofollow"> <strong class="kd iu"> 5。用自动生成的别名</strong> </a>保存输入</li><li id="ce07" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae la" href="#6329" rel="noopener ugc nofollow"> <strong class="kd iu"> 6。用插件</strong> </a>扩展kubectl</li></ul><h1 id="0430" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">简介:什么是kubectl？</h1><p id="f10c" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">在学习如何更有效地使用kubectl之前，您应该对它是什么以及它是如何工作的有一个基本的了解。</p><p id="efce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从用户的角度来看，kubectl是你控制Kubernetes的驾驶舱。它允许您执行所有可能的Kubernetes操作。</p><p id="df3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从技术的角度来看，kubectl是Kubernetes API的客户端。</p><p id="2a39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubernetes API是一个<strong class="kd iu"> HTTP REST API </strong>。这个API是真正的Kubernetes <strong class="kd iu">用户界面</strong>。Kubernetes完全通过这个API控制。这意味着每个Kubernetes操作都被公开为一个API端点，并且可以通过对这个端点的HTTP请求来执行。</p><p id="8469" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，kubectl的主要工作是执行对Kubernetes API的HTTP请求:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/95e2a250672bba11926e995b3fa95edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zyFjI_hbcaGLTxMmLco04w.png"/></div></div></figure><blockquote class="ne nf ng"><p id="52d8" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it"> Kubernetes是一个完全以</em> <strong class="kd iu"> <em class="it">资源为中心的</em> </strong> <em class="it">系统。也就是说，Kubernetes维护着一个资源的内部状态，所有的Kubernetes操作都是对这些资源的</em> <a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#resource-operations" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="it"> CRUD操作</em> </strong> </a> <em class="it">。通过操纵这些资源，您完全控制了Kubernetes(并且Kubernetes根据资源的当前状态计算出该做什么)。由于这个原因，Kubernetes</em><a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="it">API引用</em> </strong> </a> <em class="it">被组织为一个资源类型及其相关操作的列表。</em></p></blockquote><p id="f264" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们考虑一个例子。</p><p id="5884" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您想要创建一个<a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#replicaset-v1-apps" rel="noopener ugc nofollow" target="_blank"> ReplicaSet </a>资源。为此，您可以在名为<code class="fe nk nl nm nn b">replicaset.yaml</code> file的文件中定义副本集，然后运行以下命令:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="d00a" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kubectl create -f replicaset.yaml</strong></span></pre><p id="8017" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然，这会在Kubernetes中创建您的副本集。但是幕后发生了什么呢？</p><p id="d341" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubernetes有一个<em class="kz"> create ReplicaSet </em>操作，和所有Kubernetes操作一样，它被公开为一个API端点。此操作的特定API端点如下:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="38b4" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">POST /apis/apps/v1/namespaces/{namespace}/replicasets</strong></span></pre><blockquote class="ne nf ng"><p id="7e35" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">你可以在</em> <a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13" rel="noopener ugc nofollow" target="_blank"> <em class="it"> API引用</em> </a> <em class="it">中找到所有Kubernetes操作的API端点(包括端点</em>  <em class="it">上面的</em> <a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#create-replicaset-v1-apps" rel="noopener ugc nofollow" target="_blank"> <em class="it">)。要向端点发出实际请求，您需要将API服务器的URL添加到API参考中列出的端点路径前面。</em></a></p></blockquote><p id="4aaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，当您执行上面的命令时，kubectl向上面的API端点发出一个HTTP POST请求。副本集定义(您在<code class="fe nk nl nm nn b">replicaset.yaml</code>文件中提供的)在请求体中传递。</p><p id="790e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是kubectl为所有与Kubernetes集群交互的<em class="kz">命令工作的方式。在所有这些情况下，kubectl只是向适当的Kubernetes API端点发出HTTP请求。</em></p><blockquote class="ne nf ng"><p id="90e8" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">注意，完全可以使用类似</em> <code class="fe nk nl nm nn b"><em class="it">curl</em></code> <em class="it">的工具，通过手动向Kubernetes API发出HTTP请求来控制Kubernetes。Kubectl只是让你更容易使用Kubernetes API。</em></p></blockquote><p id="f299" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些是kubectl是什么以及它如何工作的基础。但是关于Kubernetes API，每个kubectl用户都应该知道更多。为此，让我们简单地探究一下Kubernetes的内部结构。</p><h2 id="59e9" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">Kubernetes内部</h2><p id="4c74" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">Kubernetes由一组独立的组件组成，这些组件作为独立的进程在集群的节点上运行。一些组件运行在主节点上，另一些运行在工作节点上，每个组件都有非常具体的功能。</p><p id="1b23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些是主节点上最重要的组件:</p><ul class=""><li id="b4a8" class="mg mh it kd b ke kf ki kj km oi kq oj ku ok ky mn mo mp mq bi translated"><strong class="kd iu">存储后端:</strong>存储资源定义(通常使用<a class="ae la" href="https://coreos.com/etcd/" rel="noopener ugc nofollow" target="_blank"> etcd </a>)</li><li id="f08b" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd iu"> API服务器:</strong>提供Kubernetes API并管理存储后端</li><li id="73d7" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd iu">控制器管理器:</strong>确保资源状态符合规范</li><li id="3c24" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd iu">调度器:</strong>将pod调度到工作节点</li></ul><p id="a89e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是工作节点上最重要的组件:</p><ul class=""><li id="9b6b" class="mg mh it kd b ke kf ki kj km oi kq oj ku ok ky mn mo mp mq bi translated"><strong class="kd iu"> Kubelet: </strong>管理工作节点上容器的执行</li></ul><p id="09d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了了解这些组件是如何协同工作的，我们来看一个例子。</p><p id="ab79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您刚刚执行了<code class="fe nk nl nm nn b">kubectl create -f replicaset.yaml</code>，kubectl向<a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#create-replicaset-v1-apps" rel="noopener ugc nofollow" target="_blank"><em class="kz">create ReplicaSet</em>API端点</a>发出HTTP POST请求(传递您的replica set资源定义)。</p><p id="eb08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在集群中，什么影响导致了这种情况？在下面观看:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/341cf19429f1c1e56443cd06e3a27d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bJ1jhLvNvta_bnjBXX9XTg.gif"/></div></div></figure><p id="8478" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是文字描述。</p><p id="11e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对<em class="kz">创建复制集</em>端点的API请求由<strong class="kd iu"> API服务器</strong>处理。API服务器对请求进行身份验证，并将您的ReplicaSet资源定义保存在存储后端。</p><p id="b0a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该事件触发<strong class="kd iu">复制集控制器</strong>，它是<strong class="kd iu">控制器管理器</strong>的子进程。复制集控制器监视存储后端中复制集资源的创建、更新和删除，并在发生这种情况时通过事件得到通知。</p><p id="d02e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">复制集控制器的工作是确保复制集的所需数量的复制盒存在。在我们的示例中，还不存在Pod，因此ReplicaSet控制器创建这些Pod定义(根据ReplicaSet定义中的Pod模板)并将它们保存在存储后端。</p><p id="2591" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">新Pod的创建触发了<strong class="kd iu">调度器</strong>，它监视尚未调度到工作节点的Pod定义。调度程序为每个Pod选择一个合适的工作节点，并使用此信息更新存储后端中的Pod定义。</p><blockquote class="ne nf ng"><p id="5c3d" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">注意，到目前为止，集群中没有任何工作负载代码正在运行。到目前为止所做的就是在主节点上的存储后端创建和更新资源。</em></p></blockquote><p id="ade9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个事件触发了<strong class="kd iu"> kubelets </strong>,这些kubelets监视被调度到它们的工人节点的pod。您的ReplicaSet Pods已被调度到的worker节点的kubelet指示已配置的容器运行时(可能是Docker)下载所需的容器映像并运行容器。</p><p id="1236" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至此，您的ReplicaSet应用程序终于开始运行了！</p><h2 id="4aa6" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">Kubernetes API的作用</h2><p id="afe4" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">从上面的例子可以看出，Kubernetes组件(除了API服务器和存储后端)通过观察存储后端的资源变化和操纵存储后端的资源来工作。</p><p id="467a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这些组件<strong class="kd iu">并不</strong>直接访问存储后端，而只是通过Kubernetes API 访问<strong class="kd iu">。</strong></p><p id="acaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑下面的例子:</p><ul class=""><li id="5b12" class="mg mh it kd b ke kf ki kj km oi kq oj ku ok ky mn mo mp mq bi translated">复制集控制器使用带有<code class="fe nk nl nm nn b">watch</code>参数的<a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#list-replicaset-v1-apps" rel="noopener ugc nofollow" target="_blank"> <em class="kz">列表复制集</em> API端点</a> API操作来监视复制集资源的变化。</li><li id="abaa" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">复制集控制器使用<a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#create-pod-v1-core" rel="noopener ugc nofollow" target="_blank"> <em class="kz">创建Pod </em> API端点</a>来创建Pod。</li><li id="165c" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">调度程序使用<a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#patch-pod-v1-core" rel="noopener ugc nofollow" target="_blank"> <em class="kz">补丁程序盒</em> API端点</a>来更新盒中关于所选工作节点的信息。</li></ul><p id="1eff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，这是kubectl 也使用的<strong class="kd iu">相同的API。</strong></p><p id="7db3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubernetes API对内部组件和外部用户的双重使用是Kubernetes的基本设计理念。</p><p id="9403" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这些知识，您可以总结Kubernetes的工作方式如下:</p><ol class=""><li id="d338" class="mg mh it kd b ke kf ki kj km oi kq oj ku ok ky om mo mp mq bi translated">存储后端存储Kubernetes的状态(即资源)。</li><li id="1fb3" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky om mo mp mq bi translated">API服务器以Kubernetes API的形式提供了一个到存储后端的接口。</li><li id="e4f9" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky om mo mp mq bi translated">所有其他Kubernetes组件和用户通过Kubernetes API读取、观察和操作Kubernetes的状态(即资源)。</li></ol><p id="3949" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">熟悉这些概念<strong class="kd iu">将会帮助你更好地理解kubectl并充分利用它！</strong></p><p id="1708" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看一系列具体的技巧和诀窍，来帮助您提高kubectl的生产率。</p><h1 id="b8ce" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.使用命令完成保存键入</h1><p id="ccfd" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">提高kubectl生产率的最有用但经常被忽视的技巧之一是命令完成。</p><p id="3329" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">命令补全允许您使用<em class="kz">标签</em>键自动补全kubectl命令的各个部分。这适用于子命令、选项和参数，包括难以键入的内容，如资源名称。</p><p id="f642" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，您可以看到kubectl命令的运行:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/9bcd1590bab34660aebe83ea26c2de22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IVc0-HBKK1M1urCa.gif"/></div></div></figure><p id="4290" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">命令完成对<a class="ae la" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> Bash </strong> </a>和<a class="ae la" href="https://www.zsh.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> Zsh </strong> </a>炮弹有效。</p><p id="ee8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae la" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion" rel="noopener ugc nofollow" target="_blank">官方文档</a>包含了设置命令完成的详细说明，但以下章节为您提供了一个概述。</p><h2 id="a8ce" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">命令完成是如何工作的</h2><p id="37fa" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">一般来说，命令完成是一个shell特性，它通过一个<strong class="kd iu">完成脚本</strong>来工作。完成脚本是为特定命令定义完成行为的外壳脚本。提供完成脚本可以完成相应的命令。</p><p id="69d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubectl可以使用以下命令自动生成并打印出Bash和Zsh的完成脚本:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="5325" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kubectl completion bash<br/></strong><em class="kz"># or</em><br/><strong class="nn iu">kubectl completion zsh</strong></span></pre><p id="8e45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">理论上，将这个命令的输出放在适当的shell中可以完成kubectl命令。</p><p id="33b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，实际上，Bash(包括Linux和macOS之间的差异)和Zsh的细节是不同的。以下部分解释了所有这些情况:</p><ul class=""><li id="410f" class="mg mh it kd b ke kf ki kj km oi kq oj ku ok ky mn mo mp mq bi translated"><a class="ae la" href="#8bfa" rel="noopener ugc nofollow"> <strong class="kd iu">为Linux上的Bash设置命令完成</strong> </a></li><li id="6d97" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae la" href="#bdc4" rel="noopener ugc nofollow"> <strong class="kd iu">为macOS上的Bash设置命令完成</strong> </a></li><li id="080d" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><a class="ae la" href="#b4ae" rel="noopener ugc nofollow"> <strong class="kd iu">为Zsh </strong> </a>设置命令完成</li></ul><h2 id="8bfa" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">Linux上的Bash</h2><p id="e332" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">Bash的完成脚本依赖于<a class="ae la" href="https://github.com/scop/bash-completion" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">Bash-completion</strong></a>项目，所以您必须首先安装它。</p><p id="08f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以用<a class="ae la" href="https://github.com/scop/bash-completion#installation" rel="noopener ugc nofollow" target="_blank">各种包管理器</a>安装bash-completion。例如:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="024a" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">sudo apt-get install bash-completion<br/></strong><em class="kz"># or<br/></em><strong class="nn iu">yum install bash-completion</strong></span></pre><p id="f46d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用以下命令测试bash-completion是否正确安装:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="593b" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">type _init_completion</strong></span></pre><p id="6460" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这输出了shell函数的代码，那么bash-completion已经被正确地安装了。如果命令输出一个<code class="fe nk nl nm nn b">not found</code>错误，您必须将下面一行添加到您的<code class="fe nk nl nm nn b">~/.bashrc</code>文件中:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="95af" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">source /usr/share/bash-completion/bash_completion</strong></span></pre><blockquote class="ne nf ng"><p id="a685" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">您是否必须将这一行添加到您的</em> <code class="fe nk nl nm nn b"><em class="it">~/.bashrc</em></code> <em class="it">文件中，取决于您用来安装bash-completion的包管理器。因为它是必要的，因为它不是。</em></p></blockquote><p id="c6f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦安装了bash-completion，您就必须进行设置，以便kubectl <strong class="kd iu">完成脚本</strong>可以在您的所有shell会话中获得。</p><p id="c8c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一种方法是将下面一行添加到您的<code class="fe nk nl nm nn b">~/.bashrc</code>文件中:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="9a62" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">source &lt;(kubectl completion bash)</strong></span></pre><p id="f2c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一种可能是将kubectl完成脚本添加到<code class="fe nk nl nm nn b">/etc/bash_completion.d</code>目录中(如果不存在，就创建它):</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="e60d" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kubectl completion bash &gt;/etc/bash_completion.d/kubectl</strong></span></pre><blockquote class="ne nf ng"><p id="6241" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it"/><code class="fe nk nl nm nn b"><em class="it">/etc/bash_completion.d</em></code><em class="it">目录中的所有补全脚本都由bash-completion自动获取。</em></p></blockquote><p id="2584" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两种方法是等效的。</p><p id="8a8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在重新加载您的shell之后，kubectl命令完成应该可以工作了！</p><p id="e2a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae la" href="#5ba7" rel="noopener ugc nofollow"> <strong class="kd iu">跳到下一节→ </strong> </a></p><h2 id="bdc4" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">苹果电脑上的狂欢</h2><p id="95ae" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">对于macOS，有一点复杂。原因是macOS上的Bash默认版本是3.2，已经相当过时了。不幸的是，kubectl完成脚本至少需要Bash 4.1，因此不能与Bash 3.2一起工作。</p><blockquote class="ne nf ng"><p id="37ea" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">苹果在macOS中包含Bash过时版本的原因是新版本使用了</em> <a class="ae la" href="https://en.wikipedia.org/wiki/GNU_General_Public_License" rel="noopener ugc nofollow" target="_blank"> <em class="it"> GPLv3许可</em> </a> <em class="it">，苹果不支持。</em></p></blockquote><p id="387d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着，要在macOS上使用kubectl命令补全，您必须<strong class="kd iu">安装Bash的新版本</strong>。你甚至可以把它作为你新的默认shell，这样可以省去你以后很多这种麻烦。其实并不难，你可以在我之前写的一篇<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/upgrading-bash-on-macos-7138bd1066ba"> <strong class="kd iu">在macOS上升级Bash</strong></a>的文章中找到说明。</p><p id="35c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在继续之前，确保你现在使用的确实是Bash 4.1或更新版本(用</strong> <code class="fe nk nl nm nn b"><strong class="kd iu">bash --version</strong></code> <strong class="kd iu">了解一下)。</strong></p><p id="d271" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Bash的完成脚本依赖于<a class="ae la" href="https://github.com/scop/bash-completion" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">Bash-completion</strong></a>项目，所以你必须先安装它。</p><p id="b105" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以用<a class="ae la" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> Homebrew </a>安装bash-completion:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="5880" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">brew install bash-completion@2</strong></span></pre><blockquote class="ne nf ng"><p id="0e65" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it"/><code class="fe nk nl nm nn b"><em class="it">@2</em></code><em class="it">代表</em> <strong class="kd iu"> <em class="it">的bash-completion v2</em></strong><em class="it">。kubectl完成脚本需要bash-completion v2，bash-completion v2至少需要Bash 4.1。这就是不能在低于4.1的Bash版本上使用kubectl完成脚本的原因。</em></p></blockquote><p id="0cf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nk nl nm nn b">brew install</code>命令的输出包括一个“警告”部分，指示将下面几行添加到您的<code class="fe nk nl nm nn b">~/.bash_profile</code>文件中:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="481a" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">export BASH_COMPLETION_COMPAT_DIR=/usr/local/etc/bash_completion.d<br/>[[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]] &amp;&amp;<br/>  . "/usr/local/etc/profile.d/bash_completion.sh"</strong></span></pre><p id="69c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了完成bash-completion的安装，您必须这样做。然而，我建议将这些行添加到您的<code class="fe nk nl nm nn b">~/.bashrc</code>而不是<code class="fe nk nl nm nn b">~/.bash_profile</code>文件中。这确保了bash完成在子shells中也是可用的。</p><p id="9f7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重新加载shell后，可以使用以下命令测试bash-completion是否正确安装:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="1fb8" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">type _init_completion</strong></span></pre><p id="97d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这输出了一个shell函数的代码，那么就万事俱备了。</p><p id="5a50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您必须进行设置，以便kubectl <strong class="kd iu">完成脚本</strong>可以在您的所有shell会话中获得。</p><p id="5c2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一种方法是将下面一行添加到您的<code class="fe nk nl nm nn b">~/.bashrc</code>文件中:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="1749" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">source &lt;(kubectl completion bash)</strong></span></pre><p id="dbfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一种可能性是将kubectl完成脚本添加到<code class="fe nk nl nm nn b">/usr/local/etc/bash_completion.d</code>目录中:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="5dcd" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kubectl completion bash &gt;/usr/local/etc/bash_completion.d/kubectl</strong></span></pre><blockquote class="ne nf ng"><p id="2752" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated">只有在你安装了bash-completion with Homebrew的情况下，这才有效。在这种情况下，bash-completion将所有完成脚本都放在这个目录中。</p></blockquote><p id="9de3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你也<a class="ae la" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-with-homebrew-on-macos" rel="noopener ugc nofollow" target="_blank">用家酿</a>安装了kubectl，你甚至不需要做上面的步骤，因为完成脚本应该已经被kubectl家酿公式放在<code class="fe nk nl nm nn b">/usr/local/etc/bash_completion.d</code>目录中了。在这种情况下，在安装bash-completion之后，kubectl completion应该会自动开始工作。</p><p id="f228" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，所有这些方法都是等价的。</p><p id="3ab5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在重新加载您的shell之后，kubectl完成应该可以工作了！</p><p id="41f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae la" href="#5ba7" rel="noopener ugc nofollow"> <strong class="kd iu">跳到下一节→ </strong> </a></p><h2 id="b4ae" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">Zsh</h2><p id="bb21" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">Zsh的完成脚本没有任何依赖性。因此，您所要做的就是进行设置，以便它可以在您的所有shell会话中获得。</p><p id="9e12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以通过将下面一行添加到您的<code class="fe nk nl nm nn b">~/.zshrc</code>文件中来做到这一点:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="0271" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">source &lt;(kubectl completion zsh)</strong></span></pre><p id="e035" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您在重新加载shell后得到一个<code class="fe nk nl nm nn b">command not found: compdef</code>错误，您必须启用<code class="fe nk nl nm nn b">compdef</code>内置，这可以通过将以下内容添加到您的<code class="fe nk nl nm nn b">~/.zshrc</code>文件的开头来实现:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="6daa" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">autoload -Uz compinit<br/>compinit</strong></span></pre><h1 id="5ba7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">2.快速查找资源规格</h1><p id="2ead" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">创建YAML资源定义时，需要了解这些资源的字段及其含义。查找这些信息的一个地方是在<a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/" rel="noopener ugc nofollow" target="_blank"> API参考</a>中，它包含了所有资源的完整规范。</p><p id="37a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，每次你需要查找某个东西的时候都要切换到网络浏览器是一件很乏味的事情。因此，kubectl提供了<code class="fe nk nl nm nn b">kubectl explain</code>命令，它可以在您的终端上打印出所有资源的资源规格。</p><p id="b2af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nk nl nm nn b">kubectl explain</code>的用法如下:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="7128" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kubectl explain resource[.field]...</strong></span></pre><p id="b314" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该命令输出所请求的资源或字段的规范。<code class="fe nk nl nm nn b">kubectl explain</code>显示的信息与API参考中的信息相同。</p><p id="ee36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，您可以看到<code class="fe nk nl nm nn b">kubectl explain</code>正在运行:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/cccb2fccac2d7e720a77c8cfbcf3155e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mtmIJFPYnE-BxT68HkBY9Q.gif"/></div></div></figure><p id="9f1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，<code class="fe nk nl nm nn b">kubectl explain</code>只显示一个级别的字段。您可以显示带有<code class="fe nk nl nm nn b">--recursive</code>标志的<strong class="kd iu">整个字段树</strong>:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="224f" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kubectl explain deployment.spec --recursive</strong></span></pre><p id="3104" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您不确定哪些<strong class="kd iu">资源名称</strong>可以与<code class="fe nk nl nm nn b">kubectl explain</code>一起使用，您可以使用以下命令显示所有这些名称:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="2010" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kubectl api-resources</strong></span></pre><p id="07da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该命令以复数形式显示资源名称(如<code class="fe nk nl nm nn b">deployments</code>而不是<code class="fe nk nl nm nn b">deployment</code>)。它还显示那些有资源的简称(例如<code class="fe nk nl nm nn b">deploy</code>)。不用担心这些差异。所有这些名称变体对于kubectl都是等价的。也就是说，对于<code class="fe nk nl nm nn b">kubectl explain</code>，你可以使用其中的任何一个。</p><p id="1904" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，以下所有命令都是等效的:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="07c9" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kubectl explain deployments.spec<br/></strong><em class="kz"># or<br/></em><strong class="nn iu">kubectl explain deployment.spec<br/></strong><em class="kz"># or<br/></em><strong class="nn iu">kubectl explain deploy.spec</strong></span></pre><h1 id="c563" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">3.使用自定义列输出格式</h1><p id="ff77" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated"><code class="fe nk nl nm nn b">kubectl get</code>命令的默认输出格式(用于<em class="kz">读取</em>资源)如下:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="dfa4" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">$ kubectl get pods<br/></strong>NAME                      READY   STATUS    RESTARTS   AGE<br/>engine-544b6b6467-22qr6   1/1     Running   0          78d<br/>engine-544b6b6467-lw5t8   1/1     Running   0          78d<br/>engine-544b6b6467-tvgmg   1/1     Running   0          78d<br/>web-ui-6db964458-8pdw4    1/1     Running   0          78d</span></pre><p id="8e8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一种很好的人类可读格式，但是它只包含有限的信息。正如您所看到的，每个资源只显示了一些字段(与完整的资源定义相比)。</p><p id="85a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是<a class="ae la" href="https://kubernetes.io/docs/reference/kubectl/overview/#custom-columns" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">自定义列输出格式</strong> </a>的用武之地。它允许您自由定义列和要在其中显示的数据。您可以选择资源的任何<em class="kz">字段作为单独的列显示在输出中</em></p><p id="165f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">自定义列输出选项的用法如下:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="47c5" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">-o custom-columns=&lt;header&gt;:&lt;jsonpath&gt;[,&lt;header&gt;:&lt;jsonpath&gt;]...</strong></span></pre><p id="4a34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您必须将每个输出列定义为一个<code class="fe nk nl nm nn b">&lt;header&gt;:&lt;jsonpath&gt;</code>对:</p><ul class=""><li id="9596" class="mg mh it kd b ke kf ki kj km oi kq oj ku ok ky mn mo mp mq bi translated"><code class="fe nk nl nm nn b">&lt;header&gt;</code>是该列的名称，你可以选择任何你想要的。</li><li id="3191" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><code class="fe nk nl nm nn b">&lt;jsonpath&gt;</code>是一个选择资源域的表达式(下面将详细解释)。</li></ul><p id="5d32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个简单的例子:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="268d" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">$ kubectl get pods -o custom-columns='NAME:metadata.name'<br/></strong>NAME<br/>engine-544b6b6467-22qr6<br/>engine-544b6b6467-lw5t8<br/>engine-544b6b6467-tvgmg<br/>web-ui-6db964458-8pdw4</span></pre><p id="9269" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，输出由显示所有pod名称的单个列组成。</p><p id="bffe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">选择Pod名称的表达式是<code class="fe nk nl nm nn b">metadata.name</code>。这是因为Pod的名称是在Pod资源的<code class="fe nk nl nm nn b">metadata</code>字段的<code class="fe nk nl nm nn b">name</code>字段中定义的(您可以在<a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#pod-v1-core" rel="noopener ugc nofollow" target="_blank"> API参考</a>或使用<code class="fe nk nl nm nn b">kubectl explain pod.metadata.name</code>来查找)。</p><p id="2049" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，假设您想要向输出中添加一个额外的列，例如，显示每个Pod正在运行的节点。为此，您只需向自定义列选项添加适当的列规范:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="80c6" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">$ kubectl get pods -o custom-columns=\<br/>'NAME:metadata.name,NODE:spec.nodeName'<br/></strong>NAME                      NODE<br/>engine-544b6b6467-22qr6   ip-10-0-80-67.ec2.internal<br/>engine-544b6b6467-lw5t8   ip-10-0-36-80.ec2.internal<br/>engine-544b6b6467-tvgmg   ip-10-0-118-34.ec2.internal<br/>web-ui-6db964458-8pdw4    ip-10-0-118-34.ec2.internal</span></pre><p id="f9a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">选择节点名的表达式是<code class="fe nk nl nm nn b">spec.nodeName</code>。这是因为一个Pod被调度到的节点被保存在Pod的<code class="fe nk nl nm nn b">spec.nodeName</code>字段中(参见<code class="fe nk nl nm nn b">kubectl explain pod.spec.nodeName</code>)。</p><blockquote class="ne nf ng"><p id="7106" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">注意，Kubernetes资源字段是</em> <strong class="kd iu"> <em class="it">区分大小写</em> </strong> <em class="it">。</em></p></blockquote><p id="a001" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以用这种方式将资源的任何域设置为输出列。只需浏览资源规范，并尝试您喜欢的任何领域！</p><p id="aeee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是首先，让我们仔细看看这些字段选择表达式。</p><h2 id="96d6" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">JSONPath表达式</h2><p id="098c" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">选择资源字段的表达式基于<a class="ae la" href="https://goessner.net/articles/JsonPath/index.html" rel="noopener ugc nofollow" target="_blank"> JSONPath </a>。</p><p id="5a74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JSONPath是一种从JSON文档中提取数据的语言(类似于XML的XPath)。选择单个字段只是JSONPath最基本的用法。它有很多特性，比如列表选择器、过滤器等等。</p><p id="49bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，使用<code class="fe nk nl nm nn b">kubectl explain</code>，只支持JSONPath功能的一个子集。下面总结了这些受支持的功能以及使用示例:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="4dcb" class="ns lj it nn b gy nt nu l nv nw"><em class="kz"># Select all elements of a list<br/></em><strong class="nn iu">kubectl get pods -o custom-columns='DATA:spec.containers[*].image'</strong></span><span id="4efc" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Select a specific element of a list<br/></em><strong class="nn iu">kubectl get pods -o custom-columns='DATA:spec.containers[0].image'</strong></span><span id="17af" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Select those elements of a list that match a filter expression<br/></em><strong class="nn iu">kubectl get pods -o custom-columns='DATA:spec.containers[?(@.image!="nginx")].image'</strong></span><span id="76a1" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Select all fields under a specific location, regardless of their name<br/></em><strong class="nn iu">kubectl get pods -o custom-columns='DATA:metadata.*'</strong></span><span id="4a41" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Select all fields with a specific name, regardless of their location<br/></em><strong class="nn iu">kubectl get pods -o custom-columns='DATA:..image'</strong></span></pre><p id="131a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">特别重要的是<code class="fe nk nl nm nn b">[]</code>操作符。Kubernetes资源的许多字段都是列表，这个操作符允许您选择这些列表中的项目。它通常与通配符<code class="fe nk nl nm nn b">[*]</code>一起使用来选择列表中的所有项目。</p><p id="5481" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面你会发现一些使用这种符号的例子。</p><h2 id="eb3b" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">示例应用</h2><p id="662d" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">使用自定义列输出格式的可能性是无限的，因为您可以在输出中显示资源的任何字段或字段组合。这里有一些示例应用程序，但是您可以自行探索并找到对您有用的应用程序！</p><blockquote class="ne nf ng"><p id="ee30" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><strong class="kd iu"> <em class="it">提示:</em> </strong> <em class="it">如果你经常使用其中一个命令，你可以为它创建一个</em> <a class="ae la" href="https://en.wikipedia.org/wiki/Alias_(command)#Creating_aliases" rel="noopener ugc nofollow" target="_blank"> <em class="it"> shell别名</em> </a> <em class="it">。</em></p></blockquote><p id="f8e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="kz">显示pod的容器图像</em> </strong></p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="02eb" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">$ kubectl get pods -o custom-columns=\<br/>'NAME:metadata.name,IMAGES:spec.containers[*].image'</strong><br/>NAME                       IMAGES<br/>engine-544b6b6467-22qr6    rabbitmq:3.7.8-management,nginx<br/>engine-544b6b6467-lw5t8    rabbitmq:3.7.8-management,nginx<br/>engine-544b6b6467-tvgmg    rabbitmq:3.7.8-management,nginx<br/>web-ui-6db964458-8pdw4     wordpress</span></pre><p id="d065" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该命令显示每个窗格的所有容器图像的名称。</p><blockquote class="ne nf ng"><p id="cd5e" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated">请记住，一个Pod可能包含多个容器。在这种情况下，单个窗格的容器图像在同一列中显示为逗号分隔的列表。</p></blockquote><p id="f97c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">显示节点的可用区域</strong></p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="510c" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">$ kubectl get nodes -o custom-columns=\<br/>'NAME:metadata.name,ZONE:metadata.labels.failure-domain\.beta\.kubernetes\.io/zone'</strong><br/>NAME                          ZONE<br/>ip-10-0-118-34.ec2.internal   us-east-1b<br/>ip-10-0-36-80.ec2.internal    us-east-1a<br/>ip-10-0-80-67.ec2.internal    us-east-1b</span></pre><p id="fc30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您的Kubernetes集群部署在公共云基础设施(如AWS、Azure或GCP)上，这个命令会很有用。它显示每个节点所在的<em class="kz">可用区域</em>。</p><blockquote class="ne nf ng"><p id="84ec" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it"/>可用性区域<em class="it">是一个云概念，表示地理</em>区域<em class="it">内的一个复制点。</em></p></blockquote><p id="55e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个节点的可用区域通过特殊的<code class="fe nk nl nm nn b"><a class="ae la" href="https://kubernetes.io/docs/reference/kubernetes-api/labels-annotations-taints/#failure-domainbetakubernetesiozone" rel="noopener ugc nofollow" target="_blank">failure-domain.beta.kubernetes.io/zone</a></code>标签获得。如果群集运行在公共云基础架构上，则会自动创建此标签，其值会设置为节点可用性区域的名称。</p><p id="7fd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">标签不是Kubernetes资源规范的一部分，所以在<a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/" rel="noopener ugc nofollow" target="_blank"> API参考</a>中找不到上面的标签。但是，如果将节点输出为YAML或JSON，您可以看到它(以及所有其他标签):</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="3a83" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kubectl get nodes -o yaml<br/></strong><em class="kz"># or<br/></em><strong class="nn iu">kubectl get nodes -o json</strong></span></pre><p id="3b52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了探索<a class="ae la" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/" rel="noopener ugc nofollow" target="_blank">资源规范</a>之外，这通常是发现关于您的资源的更多信息的好方法。</p><h1 id="0910" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">4.轻松在集群和名称空间之间切换</h1><p id="6d0b" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">当kubectl必须向Kubernetes API发出请求时，它会读取系统上所谓的<strong class="kd iu"> kubeconfig </strong>文件，以获取它需要访问的所有连接参数，并向API服务器发出请求。</p><blockquote class="ne nf ng"><p id="ebb8" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">默认的kubeconfig文件是</em> <code class="fe nk nl nm nn b"><em class="it">~/.kube/config</em></code> <em class="it">。这个文件通常是由某个命令自动创建或更新的(例如，</em> <code class="fe nk nl nm nn b"><em class="it">aws eks update-kubeconfig</em></code> <em class="it">或</em> <code class="fe nk nl nm nn b"><em class="it">gcloud container clusters get-credentials</em></code> <em class="it">，如果您使用托管Kubernetes服务的话)。</em></p></blockquote><p id="e254" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您使用<strong class="kd iu">多个集群</strong>时，您在kubeconfig文件中配置了<em class="kz">多个</em>集群的连接参数。这意味着，你需要一种方法来告诉kubectl去<em class="kz">你想要它连接这些集群中的哪一个</em>。</p><p id="9d74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在一个集群内，您可以设置<strong class="kd iu">多个</strong> <a class="ae la" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">名称空间</strong> </a>(一个名称空间是物理集群内的一种“虚拟”集群)。Kubectl还决定对来自kubeconfig文件的请求使用哪个名称空间。因此，您需要一种方法来告诉kubectl <em class="kz">您希望它使用这些名称空间中的哪一个。</em></p><p id="07c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一节解释了这是如何工作的，以及如何毫不费力地做到这一点。</p><blockquote class="ne nf ng"><p id="3a6f" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">注意，您也可以通过在</em> <code class="fe nk nl nm nn b"><a class="ae la" href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#the-kubeconfig-environment-variable" rel="noopener ugc nofollow" target="_blank"><em class="it">KUBECONFIG</em></a></code> <em class="it">环境变量中列出多个kubeconfig文件。在这种情况下，所有这些文件将在执行时合并成一个有效的配置。您也可以用每个kubectl命令的</em> <code class="fe nk nl nm nn b"><em class="it">--kubeconfig</em></code> <em class="it">选项覆盖默认的kubeconfig文件。参见</em> <a class="ae la" href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/" rel="noopener ugc nofollow" target="_blank"> <em class="it">官方</em> </a> <em class="it"> </em> <a class="ae la" href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/" rel="noopener ugc nofollow" target="_blank"> <em class="it">文档</em> </a> <em class="it">。</em></p></blockquote><h2 id="265a" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">Kubeconfig文件</h2><p id="c65d" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">让我们看看kubeconfig文件实际包含了什么:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/8ab3a82ce0d5e9a61dc45013641e19e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Dr6Z3FeMZw-2-FUII1tCg.png"/></div></div></figure><p id="8070" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，kubeconfig文件由一组<strong class="kd iu">上下文</strong>组成。上下文包含以下三个元素:</p><ul class=""><li id="b5af" class="mg mh it kd b ke kf ki kj km oi kq oj ku ok ky mn mo mp mq bi translated"><strong class="kd iu">集群:</strong>集群的API服务器的URL</li><li id="cb01" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd iu">用户:</strong>集群的特定用户的身份验证凭据</li><li id="e55d" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><strong class="kd iu">名称空间:</strong>连接到集群时使用的名称空间</li></ul><blockquote class="ne nf ng"><p id="1ba5" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated">在实践中，人们经常在他们的kubeconfig文件中为每个集群使用一个上下文。然而，每个集群也可以有多个上下文，不同之处在于它们的用户<em class="it">或</em>名称空间<em class="it">。但是这似乎不太常见，因此通常在集群和上下文之间存在一对一的映射。</em></p></blockquote><p id="35aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在任何给定时间，这些上下文中的一个被设置为<strong class="kd iu">当前上下文</strong>(通过kubeconfig文件中的专用字段):</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/d48f510e808b86f033bfbad15b1899a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYRs-Qp6MhH3AbcuvFsdKg.png"/></div></div></figure><p id="4bed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当kubectl读取kubeconfig文件时，它总是使用来自<em class="kz">当前上下文</em>的信息。因此，在上面的例子中，kubectl将连接到<em class="kz"> Hare </em>集群。</p><p id="b9f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，要切换到另一个集群，您只需更改kubeconfig文件中的当前上下文:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/87a0d5a437a35999ad995f5f2ad99512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djETK43aCc4IFOyqn2VB8A.png"/></div></div></figure><p id="a39e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，kubectl现在将连接到<em class="kz"> Fox </em>集群。</p><p id="b104" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了切换到同一个集群中的另一个名称空间，您可以更改当前上下文的<em class="kz">名称空间</em>元素的值:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/029410c5a110ce9b209ac98fa00fe452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfTzKtN_Camw0mnZpo4FwQ.png"/></div></div></figure><p id="d873" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，kubectl现在将使用<em class="kz"> Fox </em>集群中的<em class="kz"> Prod </em>名称空间(而不是之前设置的<em class="kz"> Test </em>名称空间)。</p><blockquote class="ne nf ng"><p id="90eb" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">注意，kubectl还提供了</em> <code class="fe nk nl nm nn b"><em class="it">--cluster</em></code> <em class="it">、</em> <code class="fe nk nl nm nn b"><em class="it">--user</em></code> <em class="it">、</em> <code class="fe nk nl nm nn b"><em class="it">--namespace</em></code> <em class="it">和</em> <code class="fe nk nl nm nn b"><em class="it">--context</em></code> <em class="it">选项，允许您覆盖单个元素和当前上下文本身，而不管kubeconfig文件中设置了什么。</em>见<code class="fe nk nl nm nn b"><em class="it">kubectl options</em></code> <em class="it">。</em></p></blockquote><p id="ded2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">理论上，您可以通过手动编辑kubeconfig文件来完成这些更改。但是这当然是乏味的。以下部分介绍了各种工具，这些工具允许您自动完成这些更改。</p><h2 id="cf1b" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">使用kubectx</h2><p id="e0c5" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">一个非常流行的在集群和名称空间之间切换的工具是<a class="ae la" href="https://github.com/ahmetb/kubectx/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> kubectx </strong> </a>。</p><p id="0337" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该工具提供了<code class="fe nk nl nm nn b">kubectx</code>和<code class="fe nk nl nm nn b">kubens</code>命令，允许您分别更改当前的上下文和名称空间。</p><blockquote class="ne nf ng"><p id="ee63" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">如上所述，如果每个集群只有一个上下文，那么改变当前上下文就意味着改变集群。</em></p></blockquote><p id="06a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，您可以看到这两个命令在起作用:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/a08ee6a7bfa015878746203b6e1978f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ALre0sYF2SFikpyl.gif"/></div></div></figure><blockquote class="ne nf ng"><p id="5c4c" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">在幕后，这些命令只是编辑kubeconfig文件，如前一节所述。</em></p></blockquote><p id="666f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要安装kubectx，只需遵循GitHub页面上的<a class="ae la" href="https://github.com/ahmetb/kubectx/#installation" rel="noopener ugc nofollow" target="_blank">说明。</a></p><p id="7602" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nk nl nm nn b">kubectx</code>和<code class="fe nk nl nm nn b">kubens</code>都通过完成脚本提供<strong class="kd iu">命令完成</strong>。这允许您自动完成上下文名称和名称空间，这样您就不必完全键入它们。您也可以在<a class="ae la" href="https://github.com/ahmetb/kubectx/#installation" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>上找到设置完成的说明。</p><p id="689f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">kubectx另一个有用的特性是<a class="ae la" href="https://github.com/ahmetb/kubectx/#interactive-mode" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">交互模式</strong> </a>。这与<a class="ae la" href="https://github.com/junegunn/fzf" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> fzf </strong> </a>工具协同工作，后者你必须单独安装(实际上，安装fzf，自动启用kubectx交互模式)。交互式模式允许您通过交互式模糊搜索界面(由fzf提供)选择目标上下文或名称空间。</p><h2 id="fc55" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">使用外壳别名</h2><p id="43f5" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">实际上，您真的不需要单独的工具来改变当前的上下文和名称空间，因为kubectl也提供了这样做的命令。特别是，<code class="fe nk nl nm nn b">kubectl config</code>命令提供了编辑kubeconfig文件的子命令。以下是其中的一些:</p><ul class=""><li id="53fd" class="mg mh it kd b ke kf ki kj km oi kq oj ku ok ky mn mo mp mq bi translated"><code class="fe nk nl nm nn b">kubectl config get-contexts</code>:列出所有上下文</li><li id="7bc9" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><code class="fe nk nl nm nn b">kubectl config current-context</code>:获取当前上下文</li><li id="9a18" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><code class="fe nk nl nm nn b">kubectl config use-context</code>:改变当前上下文</li><li id="276e" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated"><code class="fe nk nl nm nn b">kubectl config set-context</code>:改变上下文的一个元素</li></ul><p id="3361" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，直接使用这些命令不是很方便，因为它们需要键入很长时间。但是您可以将它们包装成更容易执行的shell别名。</p><p id="0e20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我基于这些命令创建了一组别名，它们提供了与kubectx类似的功能。在这里你可以看到他们的行动:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/a1e3f00f8b1a344fc2753b077081bcc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hxGoRGNf475MDKux.gif"/></div></div></figure><blockquote class="ne nf ng"><p id="6f0d" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">注意别名使用</em><a class="ae la" href="https://github.com/junegunn/fzf" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="it">fzf</em></strong></a><em class="it">提供交互式模糊搜索界面(类似kubectx的交互方式)。也就是说，你需要</em> <a class="ae la" href="https://github.com/junegunn/fzf#installation" rel="noopener ugc nofollow" target="_blank"> <em class="it">安装fzf </em> </a> <em class="it">才能使用这些别名。</em></p></blockquote><p id="2709" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是别名的定义:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="8534" class="ns lj it nn b gy nt nu l nv nw"><em class="kz"># Get current context<br/></em><strong class="nn iu">alias krc='kubectl config current-context'</strong></span><span id="99e4" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># List all contexts<br/></em><strong class="nn iu">alias klc='kubectl config get-contexts -o name | sed "s/^/  /;\|^  $(krc)$|s/ /*/"'</strong></span><span id="3504" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Change current context<br/></em><strong class="nn iu">alias kcc='kubectl config use-context "$(klc | fzf -e | sed "s/^..//")"'</strong></span><span id="ba45" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Get current namespace<br/></em><strong class="nn iu">alias krn='kubectl config get-contexts --no-headers "$(krc)" | awk "{print \$5}" | sed "s/^$/default/"'</strong></span><span id="2ded" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># List all namespaces<br/></em><strong class="nn iu">alias kln='kubectl get -o name ns | sed "s|^.*/|  |;\|^  $(krn)$|s/ /*/"'</strong></span><span id="9364" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Change current namespace<br/></em><strong class="nn iu">alias kcn='kubectl config set-context --current --namespace "$(kln | fzf -e | sed "s/^..//")"'</strong></span></pre><p id="e95b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了<strong class="kd iu">安装这些别名</strong>，你只需要把上面的定义添加到你的<code class="fe nk nl nm nn b">~/.bashrc</code>或者<code class="fe nk nl nm nn b">~/.zshrc</code>文件中，然后重新加载你的shell！</p><h2 id="2769" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">使用插件</h2><p id="6074" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">Kubectl允许安装插件，这些插件可以像本地命令一样被调用。例如，你可以安装一个名为<em class="kz"> kubectl-foo </em>的插件，然后调用它作为<code class="fe nk nl nm nn b">kubectl foo</code>。</p><blockquote class="ne nf ng"><p id="8832" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it"> Kubectl插件将在本文</em>  <em class="it">后面的</em> <a class="ae la" href="https://learnk8s.io/blog/kubectl-productivity/#6-extend-kubectl-with-plugins" rel="noopener ugc nofollow" target="_blank"> <em class="it">一节中详细介绍。</em></a></p></blockquote><p id="c96b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果能够像那样改变当前的上下文和名称空间，那不是很好吗？比如运行<code class="fe nk nl nm nn b">kubectl ctx</code>改变上下文，运行<code class="fe nk nl nm nn b">kubectl ns</code>改变命名空间？</p><p id="0e59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我创建了两个插件来做到这一点:</p><ul class=""><li id="3e1d" class="mg mh it kd b ke kf ki kj km oi kq oj ku ok ky mn mo mp mq bi translated"><a class="ae la" href="https://github.com/weibeld/kubectl-ctx" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> kubectl-ctx </strong> </a></li><li id="6172" class="mg mh it kd b ke mr ki ms km mt kq mu ku mv ky mn mo mp mq bi translated">【T42<strong class="kd iu">ku bectl-ns</strong>T45】</li></ul><p id="33dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在内部，插件建立在上一节的别名之上。</p><p id="9bae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，您可以看到正在运行的插件:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/7f62d9a694fec497fad899b5c39a5869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fSQtx-nm_n3Y4hj5.gif"/></div></div></figure><blockquote class="ne nf ng"><p id="7be8" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">注意，插件使用</em><a class="ae la" href="https://github.com/junegunn/fzf" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="it">fzf</em></strong></a><em class="it">提供交互式模糊搜索界面。也就是说，你需要</em> <a class="ae la" href="https://github.com/junegunn/fzf#installation" rel="noopener ugc nofollow" target="_blank"> <em class="it">安装fzf </em> </a> <em class="it">才能使用这些插件。</em></p></blockquote><p id="8056" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要<strong class="kd iu">安装插件</strong>，你只需要将名为<code class="fe nk nl nm nn b"><a class="ae la" href="https://raw.githubusercontent.com/weibeld/kubectl-ctx/master/kubectl-ctx" rel="noopener ugc nofollow" target="_blank">kubectl-ctx</a></code>和<code class="fe nk nl nm nn b"><a class="ae la" href="https://raw.githubusercontent.com/weibeld/kubectl-ns/master/kubectl-ns" rel="noopener ugc nofollow" target="_blank">kubectl-ns</a></code>的shell脚本下载到你的<code class="fe nk nl nm nn b">PATH</code>中的任意目录下<em class="kz">并使其可执行(比如用<code class="fe nk nl nm nn b">chmod +x</code>)。就是这样！紧接着，你应该可以使用<code class="fe nk nl nm nn b">kubectl ctx</code>和<code class="fe nk nl nm nn b">kubectl ns</code>！</em></p><h1 id="8d1d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">5.使用自动生成的别名保存键入</h1><p id="4283" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">Shell别名通常是节省输入的好方法。<a class="ae la" href="https://github.com/ahmetb/kubectl-aliases" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">kubectl-aliases</strong></a><strong class="kd iu"/>项目将这一想法铭记于心，并为常见的kubectl命令提供了大约<strong class="kd iu"> 800个别名</strong>。</p><p id="8223" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能想知道你怎么可能记住800个化名？实际上，您不需要记住它们，因为它们都是根据一个简单的方案生成的，下面显示了一些别名示例:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi or"><img src="../Images/ff72297dc9c6fdb4397a271d8bc58db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qsbAiXVZzXduhhh2HajRGA.png"/></div></div></figure><p id="8bbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，别名由<strong class="kd iu">组件</strong>组成，每个组件代表一个kubectl命令的特定元素。每个别名可以有一个<strong class="kd iu">基本命令</strong>、<strong class="kd iu">操作</strong>和<strong class="kd iu">资源</strong>的组件，以及多个<strong class="kd iu">选项</strong>的组件，你只要按照上面的方案从左到右“填充”这些组件即可。</p><blockquote class="ne nf ng"><p id="c014" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">请注意，当前和完整的详细方案在</em> <a class="ae la" href="https://github.com/ahmetb/kubectl-aliases#syntax-explanation" rel="noopener ugc nofollow" target="_blank"> <em class="it"> GitHub页面</em> </a> <em class="it">上。在那里你还可以找到</em> <a class="ae la" href="https://github.com/ahmetb/kubectl-aliases/blob/master/.kubectl_aliases" rel="noopener ugc nofollow" target="_blank"> <em class="it">别名</em> </a> <em class="it">的完整列表。</em></p></blockquote><p id="1631" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，别名<code class="fe nk nl nm nn b">kgpooyamlall</code>代表命令<code class="fe nk nl nm nn b">kubectl get pods -o yaml --all-namespaces</code>:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi os"><img src="../Images/cddb440b3a9a25ded1bc010a6fadacee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*KV9dCqV3yO9hX1ElHVyc4w.png"/></div></figure><p id="a44b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，大多数选项组件的相对顺序并不重要。所以，<code class="fe nk nl nm nn b">kgpooyamlall</code>相当于<code class="fe nk nl nm nn b">kgpoalloyaml</code>。</p><p id="58cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您不需要使用别名的所有组件。例如，<code class="fe nk nl nm nn b">k</code>、<code class="fe nk nl nm nn b">kg</code>、<code class="fe nk nl nm nn b">klo</code>、<code class="fe nk nl nm nn b">ksys</code>或<code class="fe nk nl nm nn b">kgpo</code>也是有效的别名。此外，您可以在命令行中将别名与其他单词结合使用。</p><p id="ee77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，您可以使用<code class="fe nk nl nm nn b">k proxy</code>来运行<code class="fe nk nl nm nn b">kubectl proxy</code>:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/d5817020458ba4e32b7a958bec7addb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*dW2EnAKxfGX2wGrUZDhZ9w.png"/></div></figure><p id="9b7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者您可以使用<code class="fe nk nl nm nn b">kg roles</code>来运行<code class="fe nk nl nm nn b">kubectl get roles</code>(角色资源目前不存在别名组件):</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/5475404f87199a0d54b7ec8718f4abfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*bAJ-UgvNN77l-pkfvMrydw.png"/></div></figure><p id="cb80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要获得特定的Pod，您可以使用<code class="fe nk nl nm nn b">kgpo my-pod</code>来运行<code class="fe nk nl nm nn b">kubectl get pod my-pod</code>:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/aaa697683e4673c75f978af9c92172f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*LgNRqsRGB1L_3Ktft-vY9A.png"/></div></figure><p id="7e1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，有些别名甚至<em class="kz">要求</em>在命令行上有进一步的参数。例如，<code class="fe nk nl nm nn b">kgpol</code>别名代表<code class="fe nk nl nm nn b">kubectl get pods -l</code>。<code class="fe nk nl nm nn b">-l</code>选项需要一个参数(标签规范)。所以，你必须使用这个别名，比如，像这样:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/b6077629e73238f041cff529ced7faa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*RQCbgZQxNeZNoCPzKJmMVQ.png"/></div></figure><blockquote class="ne nf ng"><p id="c6c8" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">由于这个原因，你可以使用</em><code class="fe nk nl nm nn b"><em class="it">a</em></code><em class="it"/><code class="fe nk nl nm nn b"><em class="it">f</em></code><em class="it">，</em> <code class="fe nk nl nm nn b"><em class="it">l</em></code> <em class="it">组件只在一个别名的末尾。</em></p></blockquote><p id="fd09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一般来说，一旦掌握了这种方案，就可以直观地从要执行的命令中推断出别名，省去了大量的打字工作！</p><h2 id="260a" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">装置</h2><p id="145b" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">要安装kubectl-aliases，您只需从GitHub下载<code class="fe nk nl nm nn b"><a class="ae la" href="https://raw.githubusercontent.com/ahmetb/kubectl-aliases/master/.kubectl_aliases" rel="noopener ugc nofollow" target="_blank">.kubectl-aliases</a></code>文件，并将其放在您的<code class="fe nk nl nm nn b">~/.bashrc</code>或<code class="fe nk nl nm nn b">~/.zshrc</code>文件中:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="2589" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">source ~/.kubectl_aliases</strong></span></pre><p id="ee08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样！在重新加载您的shell之后，您应该能够使用所有800个kubectl别名了！</p><h2 id="2e7f" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">完成</h2><p id="0bab" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">正如您所看到的，您经常在命令行中将更多的单词添加到别名中。例如:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="4f1c" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kgpooyaml test-pod-d4b77b989</strong></span></pre><p id="b58d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您使用kubectl命令补全，那么您可能习惯于自动补全诸如资源名称之类的东西。但是当你使用化名的时候你还能做到吗？</p><p id="0a61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">这是一个重要的问题，因为如果它不起作用，就会抵消这些别名的一些好处！</strong></p><p id="2228" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">答案取决于您使用哪种shell。</p><p id="e554" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于<strong class="kd iu"> Zsh </strong>，别名的完成是现成的。</p><p id="18c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不幸的是，对于<strong class="kd iu"> Bash </strong>，缺省情况下别名的补全不起作用。好消息是，它可以通过一些额外的步骤来实现。下一节将解释如何做到这一点。</p><h2 id="a5f6" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">在Bash中启用别名完成</h2><p id="8bc9" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">Bash的问题是它试图在别名上完成(每当你按下<em class="kz"> Tab </em>时)，而不是在别名命令上(像Zsh)。因为您没有针对所有800个别名的完成脚本，所以这是行不通的。</p><p id="8fb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae la" href="https://github.com/cykerway/complete-alias" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">complete-alias</strong></a>项目为这个问题提供了一个通用的解决方案。它利用别名的完成机制，在内部将别名扩展为别名命令，并返回扩展命令的完成建议。这意味着，它使别名的完成行为与别名命令完全相同。</p><p id="009a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下文中，我将首先解释如何安装complete-alias，然后解释如何配置它来为所有的kubectl别名启用补全。</p><p id="cc8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="kz">安装完成-别名</em> </strong></p><p id="3577" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，complete-alias依赖于<a class="ae la" href="https://github.com/scop/bash-completion" rel="noopener ugc nofollow" target="_blank"> bash-completion </a>。因此，您需要确保在安装complete-alias之前安装bash-completion。关于这一点的说明已经在之前的<a class="ae la" href="https://learnk8s.io/blog/kubectl-productivity/#bash-on-linux" rel="noopener ugc nofollow" target="_blank"> Linux </a>和<a class="ae la" href="https://learnk8s.io/blog/kubectl-productivity/#bash-on-macos" rel="noopener ugc nofollow" target="_blank"> macOS </a>中给出。</p><blockquote class="ne nf ng"><p id="9a0a" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><strong class="kd iu"><em class="it">macOS用户重要注意事项:</em> </strong> <em class="it">与</em> <a class="ae la" href="https://learnk8s.io/blog/kubectl-productivity/#bash-on-macos" rel="noopener ugc nofollow" target="_blank"> <em class="it"> kubectl完成脚本</em> </a> <em class="it">一样，complete-alias无法与Bash 3.2一起使用，Bash 3.2是MAC OS上Bash的默认版本。特别是complete-alias依赖于Bash-completion v2(</em><code class="fe nk nl nm nn b"><em class="it">brew install bash-completion@2</em></code><em class="it">)，至少需要Bash 4.1。也就是说，要在macOS上使用complete-alias，需要</em> <a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/upgrading-bash-on-macos-7138bd1066ba"> <em class="it">安装Bash </em> </a> <em class="it">的更新版本。</em></p></blockquote><p id="54de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要安装complete-alias，您只需从<a class="ae la" href="https://github.com/cykerway/complete-alias" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>下载<code class="fe nk nl nm nn b"><a class="ae la" href="https://raw.githubusercontent.com/cykerway/complete-alias/master/bash_completion.sh" rel="noopener ugc nofollow" target="_blank">bash_completion.sh</a> </code>脚本，并将其放入您的<code class="fe nk nl nm nn b">~/.bashrc</code>文件:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="2e87" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">source ~/bash_completion.sh</strong></span></pre><p id="72b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重新加载shell后，complete-alias应该会正确安装。</p><p id="ab5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="kz">为kubectl别名</em>启用补全</strong></p><p id="10a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从技术上讲，complete-alias提供了<code class="fe nk nl nm nn b">_complete_alias</code>外壳功能。该函数检查别名并返回别名命令的完成建议。</p><p id="7f4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要将它与一个特定的别名联系起来，您必须使用<code class="fe nk nl nm nn b"><a class="ae la" href="https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins" rel="noopener ugc nofollow" target="_blank">complete</a></code> Bash内置函数将<code class="fe nk nl nm nn b">_complete_alias</code>设置为别名的<em class="kz">完成函数</em>。</p><p id="ec63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">举个例子，让我们以代表<code class="fe nk nl nm nn b">kubectl</code>命令的<code class="fe nk nl nm nn b">k</code>别名为例。要将<code class="fe nk nl nm nn b">_complete_alias</code>设置为该别名的完成函数，您必须执行以下命令:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="1ff4" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">complete -F _complete_alias k</strong></span></pre><p id="2208" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样做的效果是，每当您在<code class="fe nk nl nm nn b">k</code>别名上自动完成时，就会调用<code class="fe nk nl nm nn b">_complete_alias</code>函数，该函数检查别名并为<code class="fe nk nl nm nn b">kubectl</code>命令返回完成建议。</p><p id="c2b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为另一个例子，让我们以代表<code class="fe nk nl nm nn b">kubectl get</code>的<code class="fe nk nl nm nn b">kg</code>别名为例:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="8c56" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">complete -F _complete_alias kg</strong></span></pre><p id="edb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，这样做的效果是，当您在<code class="fe nk nl nm nn b">kg</code>上自动完成时，您会得到与<code class="fe nk nl nm nn b">kubectl get</code>相同的完成建议。</p><blockquote class="ne nf ng"><p id="87a5" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">注意，可以用这种方式将complete-alias用于</em>系统上的任何<em class="it">别名。</em></p></blockquote><p id="c113" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，要完成所有的kubectl别名，您只需为它们运行上面的命令。下面的代码片段正好做到了这一点(假设您将kubectl-aliases安装到了<code class="fe nk nl nm nn b">~/.kubectl-aliases</code>):</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="92f6" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">for _a in $(sed '/^alias /!d;s/^alias //;s/=.*$//' ~/.kubectl_aliases); do<br/>  complete -F _complete_alias "$_a"<br/>done</strong></span></pre><p id="fff4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只需将这个片段添加到您的<code class="fe nk nl nm nn b">~/.bashrc</code>文件中，重新加载您的shell，现在您应该能够对所有800个kubectl别名使用补全了！</p><h1 id="6329" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">6.用插件扩展kubectl</h1><p id="dccf" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">从<a class="ae la" href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.12.md#sig-cli-1" rel="noopener ugc nofollow" target="_blank">版本1.12 </a>开始，kubectl包含了一个<a class="ae la" href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/" rel="noopener ugc nofollow" target="_blank">插件机制</a>，允许你用定制命令扩展kubectl。</p><p id="1db5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个可以作为<code class="fe nk nl nm nn b">kubectl hello</code>调用的kubectl插件的例子:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/a0ed8acf1e5b46e24a67ac62bde80f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2Lg4xRAultad6kdzef19-Q.gif"/></div></div></figure><blockquote class="ne nf ng"><p id="13e1" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">如果你熟悉的话，kubectl插件机制紧密遵循</em> <a class="ae la" href="https://adamcod.es/2013/07/12/how-to-create-git-plugin.html" rel="noopener ugc nofollow" target="_blank"> <em class="it"> Git插件机制</em> </a> <em class="it">的设计。</em></p></blockquote><p id="be14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本节将向您展示如何安装插件，在哪里可以找到现有的插件，以及如何创建自己的插件。</p><h2 id="d5bc" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">安装插件</h2><p id="d94b" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">Kubectl插件是作为简单的可执行文件分发的，文件名的形式是<code class="fe nk nl nm nn b">kubectl-x</code>。前缀<code class="fe nk nl nm nn b">kubectl-</code>是强制的，接下来是新的kubectl子命令，允许调用插件。</p><p id="0372" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，上面显示的<em class="kz"> hello </em>插件将作为名为<code class="fe nk nl nm nn b">kubectl-hello</code>的文件分发。</p><p id="0fa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要<a class="ae la" href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/#installing-kubectl-plugins" rel="noopener ugc nofollow" target="_blank">安装插件</a>，你只需要将<code class="fe nk nl nm nn b">kubectl-<em class="kz">x</em></code>文件复制到你<code class="fe nk nl nm nn b">PATH</code>中的<em class="kz">任意</em>目录下，并使其可执行(比如用<code class="fe nk nl nm nn b">chmod +x</code>)。紧接着，您可以用<code class="fe nk nl nm nn b">kubectl <em class="kz">x</em></code>调用插件。</p><p id="ee1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用以下命令列出系统上当前安装的所有插件:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="8487" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">kubectl plugin list</strong></span></pre><p id="7fe6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您有多个同名插件，或者有一个不可执行的插件文件，此命令也会显示警告。</p><h2 id="a435" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">用krew查找和安装插件</h2><p id="2f77" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">Kubectl插件可以像软件包一样被共享和重用。但是在哪里可以找到别人分享的插件呢？</p><p id="88b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个项目旨在为共享、查找、安装和管理kubectl插件提供一个统一的解决方案。该项目称自己为“kubectl插件的包管理器”(名字<em class="kz"> krew </em>是对<a class="ae la" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> <em class="kz"> brew </em> </a>的暗示)。</p><p id="668f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Krew围绕着一个kubectl插件的<a class="ae la" href="https://github.com/GoogleContainerTools/krew-index" rel="noopener ugc nofollow" target="_blank">索引</a>，你可以从中选择和安装。在这里你可以看到krew的行动:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/8a192e9ee8dcd4b3a1bfa52f9ca222e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Nqtn4Mu6Pvv7CqPecxWS_g.gif"/></div></div></figure><p id="8eb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，krew本身就是一个kubectl插件。这意味着，<strong class="kd iu">安装krew </strong>在本质上就像安装任何其他的kubectl插件一样。你可以在<a class="ae la" href="https://github.com/GoogleContainerTools/krew/#installation" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>找到krew的详细安装说明。</p><p id="bca4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最重要的krew命令如下:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="40d7" class="ns lj it nn b gy nt nu l nv nw"><em class="kz"># Search the krew index (with an optional search query)<br/></em><strong class="nn iu">kubectl krew search [&lt;query&gt;]</strong></span><span id="c573" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Display information about a plugin<br/></em><strong class="nn iu">kubectl krew info &lt;plugin&gt;</strong></span><span id="762e" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Install a plugin<br/></em><strong class="nn iu">kubectl krew install &lt;plugin&gt;</strong></span><span id="1526" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Upgrade all plugins to the newest versions<br/></em><strong class="nn iu">kubectl krew upgrade</strong></span><span id="3677" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># List all plugins that have been installed with krew<br/></em><strong class="nn iu">kubectl krew list</strong></span><span id="33d5" class="ns lj it nn b gy oo nu l nv nw"><em class="kz"># Uninstall a plugin<br/></em><strong class="nn iu">kubectl krew remove &lt;plugin&gt;</strong></span></pre><p id="115d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，用krew安装插件不会<strong class="kd iu">而不是</strong>阻止用传统方式<a class="ae la" href="https://learnk8s.io/blog/kubectl-productivity/#installing-plugins" rel="noopener ugc nofollow" target="_blank">安装插件。即使你使用krew，你仍然可以通过其他方式安装你在别处找到的插件(或者自己创建的插件)。</a></p><blockquote class="ne nf ng"><p id="4272" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">注意，</em> <code class="fe nk nl nm nn b"><em class="it">kubectl krew list</em></code> <em class="it">命令只列出已经安装了krew的插件，而</em> <code class="fe nk nl nm nn b"><em class="it">kubectl plugin list</em></code> <em class="it">命令列出了</em>所有<em class="it">插件，即那些安装了krew的插件和那些通过其他方式安装的插件。</em></p></blockquote><h2 id="32bf" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">在别处寻找插件</h2><p id="01a3" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">Krew仍然是一个年轻的项目，目前在<a class="ae la" href="https://github.com/GoogleContainerTools/krew-index/" rel="noopener ugc nofollow" target="_blank"> krew索引</a>中只有大约30个插件。如果你在那里没有找到你需要的，你可以在其他地方寻找插件，比如在GitHub上。</p><p id="2b8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我推荐去看看<a class="ae la" href="https://github.com/topics/kubectl-plugins" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">kubectl-plugins</strong></a>GitHub专题。你会发现那里有几十个值得一看的插件。</p><h2 id="7bbc" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">创建自己的插件</h2><p id="3c10" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">当然，你可以<a class="ae la" href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/#writing-kubectl-plugins" rel="noopener ugc nofollow" target="_blank">创建自己的kubectl插件</a>，而且这样做非常容易。</p><p id="5e1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你只需要创建一个你想做的可执行文件，以<code class="fe nk nl nm nn b">kubectl-<em class="kz">x</em></code>的形式给它命名，然后按照上面描述的<a class="ae la" href="https://learnk8s.io/blog/kubectl-productivity/#installing-plugins" rel="noopener ugc nofollow" target="_blank">安装它。</a></p><p id="c78e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可执行文件可以是任何类型的，Bash脚本，编译的Go程序，Python脚本，这都没关系。唯一的要求就是可以直接被操作系统执行。</p><p id="6750" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们现在创建一个示例插件。在前面的<a class="ae la" href="https://learnk8s.io/blog/kubectl-productivity/#3-use-the-custom-columns-output-format" rel="noopener ugc nofollow" target="_blank">小节</a>中，您使用了一个kubectl命令来列出每个pod的容器图像。您可以很容易地将这个命令转换成一个插件，您可以用例如<code class="fe nk nl nm nn b">kubectl img</code>来调用它。</p><p id="8c4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此，只需创建一个名为<code class="fe nk nl nm nn b">kubectl-img</code>的文件，其内容如下:</p><pre class="na nb nc nd gt no nn np nq aw nr bi"><span id="73b5" class="ns lj it nn b gy nt nu l nv nw"><strong class="nn iu">#!/bin/bash<br/>kubectl get pods -o custom-columns=\<br/>'NAME:metadata.name,IMAGES:spec.containers[*].image'</strong></span></pre><p id="3db2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在用<code class="fe nk nl nm nn b">chmod +x kubectl-img</code>使文件可执行，并把它移到你的<code class="fe nk nl nm nn b">PATH</code>中的任何目录。在那之后，你就可以用<code class="fe nk nl nm nn b">kubectl img</code>开始使用插件了！</p><blockquote class="ne nf ng"><p id="4dde" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><em class="it">如前所述，kubectl插件可以用</em>任何<em class="it">编程或脚本语言编写。如果您使用shell脚本，那么您的优势在于可以很容易地从插件中调用kubectl。但是，你可以用真正的编程语言编写更复杂的插件，例如，使用一个</em> <a class="ae la" href="https://kubernetes.io/docs/reference/using-api/client-libraries/" rel="noopener ugc nofollow" target="_blank"> <em class="it"> Kubernetes客户端库</em> </a> <em class="it">。如果使用Go，还可以使用</em><a class="ae la" href="https://github.com/kubernetes/cli-runtime" rel="noopener ugc nofollow" target="_blank"><em class="it">CLI-runtime</em></a><em class="it">库，这个库是专门为编写kubectl插件而存在的。</em></p></blockquote><h2 id="b8cc" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">共享您的插件</h2><p id="743a" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">如果你认为你的某个插件可能对其他人有用，请在<strong class="kd iu"> GitHub </strong>上分享。一定要添加到<a class="ae la" href="https://github.com/topics/kubectl-plugins" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">ku bectl-plugins</strong></a>主题中，让别人也能找到。</p><p id="7755" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您也可以请求将您的插件添加到<a class="ae la" href="https://github.com/GoogleContainerTools/krew-index/" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> krew索引</strong> </a>。你可以在<a class="ae la" href="https://github.com/GoogleContainerTools/krew/blob/master/docs/DEVELOPER_GUIDE.md" rel="noopener ugc nofollow" target="_blank"> krew GitHub库</a>中找到如何操作的说明。</p><h2 id="611a" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">命令完成</h2><p id="0569" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">目前，插件机制不幸地还不支持命令完成。这意味着您需要完整地输入插件名称，以及插件的任何参数。</p><p id="7049" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，在kubectl GitHub库中有一个开放的<a class="ae la" href="https://github.com/kubernetes/kubectl/issues/585" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">特性请求</strong> </a>。所以，这个特性有可能在未来的某个时候实现。</p><h1 id="26e0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">那都是乡亲们！</h1><blockquote class="ne nf ng"><p id="4c94" class="kb kc kz kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated"><strong class="kd iu"> <em class="it">不要错过接下来的故事、实验或提示。</em> </strong> <em class="it">如果你喜欢这篇文章，请继续关注。将新内容直接发送到您的收件箱，提升您在Kubernetes的<br/>专业技能。</em> <a class="ae la" href="https://learnk8s.io/newsletter" rel="noopener ugc nofollow" target="_blank"> <em class="it">现在就订阅</em> </a> <em class="it">。</em></p></blockquote><p id="89c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">最初发表于</em><a class="ae la" href="https://learnk8s.io/blog/kubectl-productivity" rel="noopener ugc nofollow" target="_blank"><em class="kz">learn k8s . io</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>