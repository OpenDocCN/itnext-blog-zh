<html>
<head>
<title>Kong Proof-of-Concept using Minikube</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kong使用Minikube进行概念验证</h1>
<blockquote>原文：<a href="https://itnext.io/kong-proof-of-concept-using-minikube-5f8ca932083f?source=collection_archive---------5-----------------------#2019-11-26">https://itnext.io/kong-proof-of-concept-using-minikube-5f8ca932083f?source=collection_archive---------5-----------------------#2019-11-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="3089" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">如何在大约15分钟内完成概念验证</h1><p id="61f6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">本指南是对我之前的一个故事的更新。</p><p id="a11b" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">为什么是另一个向导？因为它以更简单的方式解决了同样的问题。<br/>一般来说，简化是提取信息的艺术。这都是关于组织想法和概念，只提取有意义的部分。</p><p id="fb9e" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">本指南将带您了解一个从头开始设置API网关的工作示例，该网关将使用JWT和ACL来授权用户访问端点。其他部分可参考<a class="ae lm" href="https://docs.konghq.com/" rel="noopener ugc nofollow" target="_blank">孔优秀文档</a>。</p><blockquote class="ls lt lu"><p id="c96c" class="ko kp lv kq b kr ln kt ku kv lo kx ky lw lp lb lc lx lq lf lg ly lr lj lk ll im bi translated">"简单是最高级的复杂。"莱昂纳多·达·芬奇(1452-1519)</p></blockquote><h1 id="109f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">上下文:研究不同的API网关</h1><p id="ad46" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Sumup上，我们希望研究不同的API网关，在这种情况下，我们正在构建API服务，需要基于角色允许或限制某些调用，使用JWTs、速率限制等身份验证令牌。简而言之，我们需要一些微服务请求网关，通过插件处理负载平衡、日志记录、认证、速率限制、转换等等。<a class="ae lm" href="https://konghq.com/wp-content/uploads/2019/01/GigaOm-API-Platform-Benchmark-Kong-Apigee-1-25-19-1.pdf" rel="noopener ugc nofollow" target="_blank">当然这个应该可以缩放</a>。</p><p id="14b9" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我和@limoges 决定建立一个快速的概念验证来展示像Kong这样的工具的能力。这篇文章是在他的帮助下完成和审阅的。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/280b22f905d8b9e25c27ca3cfeb6bc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BvWSxhKOISHh55hI"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">“老办法”对孔</figcaption></figure><blockquote class="ls lt lu"><p id="b857" class="ko kp lv kq b kr ln kt ku kv lo kx ky lw lp lb lc lx lq lf lg ly lr lj lk ll im bi translated">关于插件和集成的更多信息，你可以查看<a class="ae lm" href="https://docs.konghq.com/hub/" rel="noopener ugc nofollow" target="_blank"> Kong Hub </a>。</p></blockquote><h1 id="af74" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">为孔做一个展示</h1><p id="4bf6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在进一步讨论API网关之前，我们希望创建一个概念验证，以便对问题空间和可用工具进行自我教育。</p><p id="99e0" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">本指南是一个简短的示例，说明如何在一个示例应用程序中使用setup Kong。在SumUp，我们在Kubernetes中运行应用程序，因此我们希望在Kubernetes集群上进行概念验证。</p><p id="019b" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">这个概念验证将帮助我们探索API网关的所有<em class="lv">非功能性需求</em>。</p><p id="fb13" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">严肃地说，这不是一个生产就绪的环境，只是一种快速而肮脏的方式来创建他们可以用来开发的开发人员沙箱。</p><h1 id="34bd" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">1.使用Minikube创建我们的“集群”</h1><p id="4fd8" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将使用minikube-version 1.15.6，因为1.16上的一些api被弃用</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="a87c" class="mu jr it mq b gy mv mw l mx my"><strong class="mq iu">&gt; minikube start --kubernetes-version v1.15.6</strong><br/>😄  minikube v1.5.2 on Ubuntu 19.10<br/>✨  Automatically selected the 'virtualbox' driver (alternates: [none])<br/>🔥  Creating virtualbox VM (CPUs=2, Memory=2000MB, Disk=20000MB) ...<br/>🐳  Preparing Kubernetes v1.15.6 on Docker '18.09.9' ...<br/>💾  Downloading kubeadm v1.15.6<br/>💾  Downloading kubelet v1.15.6<br/>🚜  Pulling images ...<br/>🚀  Launching Kubernetes ... <br/>⌛  Waiting for: apiserver<br/>🏄  Done! kubectl is now configured to use "minikube"</span></pre><h1 id="0cae" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">2.在我们的集群上设置Helm v2</h1><p id="0ca1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们希望使用Kong helm图表来简化这个过程，所以我们需要在我们的集群上安装Tiller (Helm的服务器端组件)。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="04cc" class="mu jr it mq b gy mv mw l mx my"><strong class="mq iu">&gt; curl -L </strong><a class="ae lm" href="https://git.io/get_helm.sh" rel="noopener ugc nofollow" target="_blank"><strong class="mq iu">https://git.io/get_helm.sh</strong></a><strong class="mq iu"> | bash # Install helm</strong></span><span id="0cc3" class="mu jr it mq b gy mz mw l mx my"><strong class="mq iu">&gt; helm init # Setup Tiller</strong><br/>Helm v2.16.1 <br/>Run 'helm init' to configure helm.<br/>$HELM_HOME has been configured at /home/pablo/.helm.</span><span id="8541" class="mu jr it mq b gy mz mw l mx my">Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.</span></pre><h1 id="6e8e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">3.设置孔</h1><p id="f132" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一步是简单地用<a class="ae lm" href="https://hub.helm.sh/charts/stable/kong" rel="noopener ugc nofollow" target="_blank">舵图</a>安装<a class="ae lm" href="https://konghq.com/" rel="noopener ugc nofollow" target="_blank">孔</a>。因为我们是好公民，所以我们将把与Kong相关的所有内容放在一个名为<em class="lv"> kong </em>的名称空间中。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="7507" class="mu jr it mq b gy mv mw l mx my"><strong class="mq iu">&gt; kubectl create ns kong</strong></span><span id="8f7b" class="mu jr it mq b gy mz mw l mx my"><strong class="mq iu">&gt; helm install --version 0.26.1 \<br/>--name kong stable/kong \<br/>--namespace kong \<br/>--set ingressController.enabled=true \<br/>--set image.tag=1.4 \<br/>--set admin.useTLS=false</strong></span></pre><p id="8990" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">孔掌舵图安装会给你一个获取<em class="lv">代理</em>地址和<em class="lv">管理</em>地址的命令。正如您可能已经知道的，代理地址将被用作您的服务的入口点，而<em class="lv"> Admin </em>让您可以访问Kong HTTP API。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="0782" class="mu jr it mq b gy mv mw l mx my"><strong class="mq iu">&gt; kubectl get services --namespace kong</strong><br/>NAME                        TYPE        ...<br/>kong-kong-admin             NodePort    ...<br/>kong-kong-proxy             NodePort    ...<br/>kong-postgresql             ClusterIP   ...<br/>kong-postgresql-headless    ClusterIP   ...</span></pre><p id="c4e3" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">因为我们会多次引用<em class="lv">管理</em>和<em class="lv">代理</em>地址，所以让我们导出它们。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="ab12" class="mu jr it mq b gy mv mw l mx my"><strong class="mq iu">&gt; export PROXY_ADDR=$(minikube service -n kong kong-kong-proxy --url | head -1)</strong></span><span id="0d69" class="mu jr it mq b gy mz mw l mx my"><strong class="mq iu">&gt; export ADMIN_ADDR=$(minikube service -n kong kong-kong-admin --url | head -1)</strong></span><span id="ecf3" class="mu jr it mq b gy mz mw l mx my"><strong class="mq iu">&gt; echo $PROXY_ADDR # This will differ for you.</strong><br/><a class="ae lm" href="http://192.168.64.7:30076" rel="noopener ugc nofollow" target="_blank">http://192.168.64.7:30076</a></span><span id="2272" class="mu jr it mq b gy mz mw l mx my"><strong class="mq iu">&gt; curl -i $PROXY_ADDR</strong><br/>HTTP/1.1 404 Not Found<br/>Date: Mon, 25 Nov 2019 16:50:59 GMT<br/>Content-Type: application/json; charset=utf-8<br/>Connection: keep-alive<br/>Content-Length: 48<br/>X-Kong-Response-Latency: 2<br/>Server: kong/1.4.0<br/>{“message”:”no Route matched with those values”}%</span></pre><p id="73a1" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">因为我们没有在集群上运行http服务，所以我们得到一个404。</p><h1 id="75d8" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">4.设置KONGA(可选)</h1><p id="20c5" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Konga是一个优秀的图形化管理界面，用于管理Kong，我们可以用下面的清单简单地设置它。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="86b7" class="mu jr it mq b gy mv mw l mx my"># We can create a file containing this manifest <br/># or pipe it to `kubectl`.<br/>apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: konga<br/>  namespace: kong<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        name: konga<br/>        app: konga<br/>    spec:<br/>      containers:<br/>      - name: konga<br/>        image: pantsel/konga<br/>        ports:<br/>        - containerPort: 1337<br/>        env:<br/>          - name: NO_AUTH<br/>            value: "true"<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: konga-svc<br/>  namespace: kong<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>  - name: kong-proxy<br/>    port: 1337<br/>    targetPort: 1337<br/>    nodePort: 30338<br/>    protocol: TCP<br/>  selector:<br/>    app: konga</span></pre><p id="4ff4" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">因为我们将通过浏览器查看Konga，所以让我们获取那个地址。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="2f15" class="mu jr it mq b gy mv mw l mx my">export KONGA_ADDR=$(minikube service -n kong konga-svc — url | head -1)</span></pre><p id="8935" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">在浏览器中打开<code class="fe na nb nc mq b">$KONG_ADDR</code>，我们将不得不设置与<em class="lv">孔管理HTTP API </em>的连接。</p><p id="95df" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们可以给这个连接起一个名字，并将URL设置为<code class="fe na nb nc mq b">$ADMIN_ADDR</code>。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nd"><img src="../Images/a889c57e2e2ad174fa3177c2d0c05261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9XIWvdj2UDro0QuPhSKMuQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">加载Konga仪表板</figcaption></figure><h1 id="86a1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">5.安装HTTP应用程序</h1><p id="1d45" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为我们最感兴趣的是HTTP请求，所以我们可以使用简单的echo-server应用程序，它只是将HTTP请求打印回给我们，并附带一些关于pods之类的其他细节。</p><p id="c367" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们将应用程序放在Kong后面，并使用Kong的入口类。</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="7f34" class="mu jr it mq b gy mv mw l mx my"><strong class="mq iu">&gt; curl -sL bit.ly/echo-server | kubectl apply -f -</strong><br/>service/echo created<br/>deployment.apps/echo created</span></pre><h2 id="0a7f" class="mu jr it bd js ne nf dn jw ng nh dp ka kz ni nj ke ld nk nl ki lh nm nn km no bi translated">使用Kong代理(需要检查下级)</h2><p id="2822" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">创建一个入口规则来代理之前创建的echo服务器:</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="e198" class="mu jr it mq b gy mv mw l mx my"><strong class="mq iu">&gt; echo "<br/>apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: demo<br/>  annotations:<br/>    # This annotation is optional since the ingress class will<br/>    # default to "kong" behind the scene.<br/>    # You can validate the right ingress is being used by the<br/>    # `X-Kong-Upstream-Latency` header being added to requests.<br/>    </strong><a class="ae lm" href="http://kubernetes.io/ingress.class" rel="noopener ugc nofollow" target="_blank"><strong class="mq iu">kubernetes.io/ingress.class</strong></a><strong class="mq iu">: "kong"<br/>spec:<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /foo<br/>        backend:<br/>          serviceName: echo<br/>          servicePort: 80<br/>" | kubectl apply -f -</strong><br/>ingress.extensions/demo created</span></pre><p id="12ba" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">验证入口正在工作:<br/> <em class="lv">(注意孔入口发回的</em> <code class="fe na nb nc mq b"><em class="lv">X-Kong-*</em></code> <em class="lv">响应头。)</em></p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="2043" class="mu jr it mq b gy mv mw l mx my">&gt; <strong class="mq iu">curl -i $PROXY_IP/foo   </strong><br/>HTTP/1.1 200 OK<br/>Content-Type: text/plain; charset=UTF-8<br/>Transfer-Encoding: chunked<br/>Connection: keep-alive<br/>Date: Mon, 25 Nov 2019 17:19:13 GMT<br/>Server: echoserver<br/><em class="lv">X-Kong-Upstream-Latency: 4<br/>X-Kong-Proxy-Latency: 4</em><br/>Via: kong/1.4.0</span><span id="5a22" class="mu jr it mq b gy mz mw l mx my">Hostname: echo-599d77c5c7-m9zbh</span><span id="4b0d" class="mu jr it mq b gy mz mw l mx my">Pod Information:<br/> node name: minikube<br/> pod name: echo-599d77c5c7-m9zbh<br/> pod namespace: default<br/> pod IP: 172.17.0.15</span><span id="baf6" class="mu jr it mq b gy mz mw l mx my">Server values:<br/> server_version=nginx: 1.12.2 - lua: 10010</span><span id="14ee" class="mu jr it mq b gy mz mw l mx my">Request Information:<br/> client_address=172.17.0.14<br/> method=GET<br/> real path=/<br/> query=<br/> request_version=1.1<br/> request_scheme=http<br/> request_uri=<a class="ae lm" href="http://192.168.99.110:8080/" rel="noopener ugc nofollow" target="_blank">http://192.168.99.110:8080/</a></span><span id="6710" class="mu jr it mq b gy mz mw l mx my">Request Headers:<br/> accept=*/*  <br/> connection=keep-alive  <br/> host=192.168.99.110:30400  <br/> user-agent=curl/7.65.3  <br/> x-forwarded-for=172.17.0.1  <br/> x-forwarded-host=192.168.99.110  <br/> x-forwarded-port=8000  <br/> x-forwarded-proto=http  <br/> x-real-ip=172.17.0.1</span><span id="0247" class="mu jr it mq b gy mz mw l mx my">Request Body:<br/> -no body in request-</span></pre><h1 id="259f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">5.设置授权</h1><blockquote class="ls lt lu"><p id="2b69" class="ko kp lv kq b kr ln kt ku kv lo kx ky lw lp lb lc lx lq lf lg ly lr lj lk ll im bi translated"><a class="ae lm" href="https://docs.konghq.com/hub/kong-inc/acl/" rel="noopener ugc nofollow" target="_blank"> <em class="it"> ACL </em> </a> <em class="it">(访问控制列表)<br/>通过将使用任意ACL组名的消费者列入白名单或黑名单来限制对服务或路由的访问。该插件要求已经在服务或路由上启用了</em> <a class="ae lm" href="https://docs.konghq.com/about/faq/#how-can-i-add-authentication-to-a-microservice-api" rel="noopener ugc nofollow" target="_blank"> <em class="it">认证插件</em> </a> <em class="it">。</em></p><p id="407d" class="ko kp lv kq b kr ln kt ku kv lo kx ky lw lp lb lc lx lq lf lg ly lr lj lk ll im bi translated"><em class="it">J</em><a class="ae lm" href="https://docs.konghq.com/hub/kong-inc/jwt/" rel="noopener ugc nofollow" target="_blank"><em class="it">WT</em></a><em class="it">(JSON Web令牌)<br/>验证包含HS256或RS256签名的JSON Web令牌的请求(如</em><a class="ae lm" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"><em class="it">RFC 7519</em></a><em class="it">中所指定)。您的每个消费者都将拥有JWT凭证(公钥和私钥)，必须使用这些凭证来签署他们的jwt。</em></p></blockquote><p id="b5fb" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">为了做到这一点，我们必须采取5个步骤:</p><ol class=""><li id="3937" class="np nq it kq b kr ln kv lo kz nr ld ns lh nt ll nu nv nw nx bi translated">创建一个名为<strong class="kq iu"> hello的消费者。</strong></li><li id="6a58" class="np nq it kq b kr ny kv nz kz oa ld ob lh oc ll nu nv nw nx bi translated">将<strong class="kq iu">你好</strong>添加到一个群中，我们将其命名为<strong class="kq iu">允许</strong>。</li><li id="c9cc" class="np nq it kq b kr ny kv nz kz oa ld ob lh oc ll nu nv nw nx bi translated">给消费者增加一个JWT。</li><li id="3186" class="np nq it kq b kr ny kv nz kz oa ld ob lh oc ll nu nv nw nx bi translated">将JWT插件添加到路线中。</li><li id="6966" class="np nq it kq b kr ny kv nz kz oa ld ob lh oc ll nu nv nw nx bi translated">将ACL插件添加到路由中。</li></ol><p id="8b0b" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">因此，让我们从创建一个消费者开始:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi od"><img src="../Images/dbbb2c47104ef868456b5530e61fd0d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*T7UWVUHeQLq_5QjgMVGhag.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">使用Konga创建新消费者</figcaption></figure><p id="fb42" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">然后，我们将我们的使用与我们创建的组相关联:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oe"><img src="../Images/58022b5d7d20507fbf8b34750342cbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXZDlSbDMTVVjKgP-WKiOQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">在消费者面板下可以找到组</figcaption></figure><p id="3003" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">然后，我们为消费者创建一个JWT；缺省值是可取的，否则您将玩弄密钥和声明:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oe"><img src="../Images/9c3bdddee17d08abbe8ada7e0c70d88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icggwvPHN4xf0IyRcKGxxw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">什么都不做，只需按提交</figcaption></figure><p id="f82d" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">太好了。消费者设置完成。现在让我们来看看路线。</p><p id="18d6" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们添加ACL插件，并将之前创建的组列入白名单:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi of"><img src="../Images/fef83ebdb5b2e7e0479035fc4bdcb51d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgwgkspBsrUMQSRIWfZn8g.png"/></div></div></figure><p id="203e" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">然后我们添加JWT插件:<br/>(这是唯一的关键步骤。您绝对需要<strong class="kq iu">授权</strong>头名称，否则在HTTP头中设置令牌将不起作用。)</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi og"><img src="../Images/3e57c2ed8d2d32515de3e06c3e4545be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gR_iVV1QinIiKkIfgxVAgw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">确保在标题名称中添加<strong class="bd js">授权</strong></figcaption></figure><p id="a5cd" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">就是这样。我们已经设置了使用ACL+JWT的路由。现在，我们要做的就是使用它。让我们测试一下端点:</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="0e34" class="mu jr it mq b gy mv mw l mx my"><strong class="mq iu">&gt; curl -i $PROXY_ADDR/foo</strong><br/>HTTP/1.1 401 Unauthorized<br/>Date: Tue, 26 Nov 2019 14:11:27 GMT<br/>Content-Type: application/json; charset=utf-8<br/>Connection: keep-alive<br/>Content-Length: 26<br/>X-Kong-Response-Latency: 8<br/>Server: kong/1.4.0</span><span id="1b23" class="mu jr it mq b gy mz mw l mx my">{"message":"Unauthorized"}</span></pre><p id="f027" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">太好了。所以现在我们需要得到令牌。<br/>前往<a class="ae lm" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> jwt.io </a>并使用神奇工具:</p><p id="e0f8" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">1.在有效负载中:将<code class="fe na nb nc mq b">iss</code>设置为您的消费者的JWT凭证中的<code class="fe na nb nc mq b">key</code>的值。</p><p id="e91c" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">2.在验证签名中:将<code class="fe na nb nc mq b">secret</code>设置为<code class="fe na nb nc mq b">secret</code>的值，这也可以在消费者的JWT凭证中找到。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7f302ea619de8e23f4657f62fc904326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*KXUHn8H93u5DpHkj8g7CQw.png"/></div></figure><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oi"><img src="../Images/6271dfbfe69c9befaf63f5eb2a3b8928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rZuLvkWunjquCSBpZtoBA.png"/></div></div></figure><p id="a37e" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">现在，我们来试试这个:</p><pre class="ma mb mc md gt mp mq mr ms aw mt bi"><span id="5c8a" class="mu jr it mq b gy mv mw l mx my">› curl -i -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJWVGlIeWNGUGszbzdJQkhTZVhlQ2xwYXpsWGxnTWNqOCJ9.XODg0ay6fioNZZqkPiVW_u0N_4UpZgHqX3cVevAzSXo' $PROXY_ADDR/foo<br/>HTTP/1.1 200 OK<br/>Content-Type: text/plain; charset=UTF-8<br/>Transfer-Encoding: chunked<br/>Connection: keep-alive<br/>Date: Tue, 26 Nov 2019 10:22:19 GMT<br/>Server: echoserver<br/>X-Kong-Upstream-Latency: 4<br/>X-Kong-Proxy-Latency: 12<br/>Via: kong/1.4.0</span><span id="d4bc" class="mu jr it mq b gy mz mw l mx my">Hostname: echo-599d77c5c7-ktlr7</span><span id="84bf" class="mu jr it mq b gy mz mw l mx my">Pod Information:<br/>        node name:      minikube<br/>        pod name:       echo-599d77c5c7-ktlr7<br/>        pod namespace:  default<br/>        pod IP: 172.17.0.15</span><span id="987e" class="mu jr it mq b gy mz mw l mx my">Server values:<br/>        server_version=nginx: 1.12.2 - lua: 10010</span><span id="0620" class="mu jr it mq b gy mz mw l mx my">Request Information:<br/>        client_address=172.17.0.12<br/>        method=GET<br/>        real path=/<br/>        query=<br/>        request_version=1.1<br/>        request_scheme=http<br/>        request_uri=<a class="ae lm" href="http://192.168.64.7:8080/" rel="noopener ugc nofollow" target="_blank">http://192.168.64.7:8080/</a></span><span id="7432" class="mu jr it mq b gy mz mw l mx my">Request Headers:<br/>        accept=*/*<br/>        authorization=Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJWVGlIeWNGUGszbzdJQkhTZVhlQ2xwYXpsWGxnTWNqOCJ9.XODg0ay6fioNZZqkPiVW_u0N_4UpZgHqX3cVevAzSXo<br/>        connection=keep-alive<br/>        host=192.168.64.7:30585<br/>        user-agent=curl/7.54.0<br/>        x-consumer-groups=baddies-allowed<br/>        x-consumer-id=5ed91a70-12fe-450f-b0a1-3dbbbe9a7997<br/>        x-consumer-username=baddies<br/>        x-forwarded-for=172.17.0.1<br/>        x-forwarded-host=192.168.64.7<br/>        x-forwarded-port=8000<br/>        x-forwarded-proto=http<br/>        x-real-ip=172.17.0.1</span><span id="f0f0" class="mu jr it mq b gy mz mw l mx my">Request Body:<br/>        -no body in request-</span></pre><p id="dc1a" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">大获成功！</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oj"><img src="../Images/d60ee56a63ef9c7687af3d3f4f5b9935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfnYWlxONWOJrBDbZEWvtg.png"/></div></div></figure><p id="b622" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">所以，就这样了。我希望你觉得它有用，并且步骤容易遵循。如果我遗漏了什么，请评论和/或提问——很高兴得到反馈。</p></div></div>    
</body>
</html>