<html>
<head>
<title>The rules of reusable components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可重用组件的规则</h1>
<blockquote>原文：<a href="https://itnext.io/the-rules-of-reusable-components-2b221c138bcf?source=collection_archive---------1-----------------------#2018-11-10">https://itnext.io/the-rules-of-reusable-components-2b221c138bcf?source=collection_archive---------1-----------------------#2018-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ac30e75f867852a7efeb1da755f50298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLg1-G2UAlaKpBopRnmCRg.png"/></div></div></figure><p id="21c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我花了很多时间开发新的可重用UI组件。</p><p id="396c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着在开发过程中，我倾向于提取放在共享库或样式指南中的UI组件。</p><p id="c768" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些组件将在整个项目中重复使用。当集成到功能中时，通常具有不同的样式或布局。</p><p id="eb03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一路上，我学到了一些帮助我节省时间和痛苦的规则。</p><h2 id="cd71" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">1.保持布局流畅</h2><p id="5698" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我数不清一个组件有多少次是固定宽度的，这影响了一个响应式的设计。这意味着我必须进去摆弄现有的道具，这些道具是为网站中的另一个功能设置的。不太好。</p><p id="bd64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过保留组件<code class="fe lu lv lw lx b">100% width</code>,您将布局责任传递给了父组件。</p><p id="160b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，使用<code class="fe lu lv lw lx b">CardOne</code>比使用<code class="fe lu lv lw lx b">CardTwo</code>要容易得多。因为<code class="fe lu lv lw lx b">CardOne</code>会在屏幕尺寸变化时响应父列的变化。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="1bb8" class="kw kx iq lx b gy mg mh l mi mj">const CardOne = ({ title }) =&gt; (<br/>  &lt;div style={{ padding: "20px 30px", background: "white" }}&gt;{title}&lt;/div&gt;<br/>);<br/><br/>const CardTwo = ({ title }) =&gt; (<br/>  &lt;div style={{ width: 600, padding: "10px", background: "white" }}&gt;<br/>    {title}<br/>  &lt;/div&gt;<br/>);<br/><br/>const App = () =&gt; (<br/>  &lt;div className="row"&gt;<br/>    &lt;div className="col-md-6"&gt;<br/>      &lt;CardOne title="I'm Fluid" /&gt;<br/>    &lt;/div&gt;<br/>    &lt;div className="col-md-6"&gt;<br/>      &lt;CardTwo title="I will break this layout" /&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>);</span></pre><h2 id="be88" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">2.允许传递额外的道具</h2><p id="e19a" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">原来，您的按钮组件需要一个特定的数据属性来与您正在使用的库一起工作，以实现一个特定的特性。可惜<code class="fe lu lv lw lx b">Button</code>组件只允许<code class="fe lu lv lw lx b">className</code>、<code class="fe lu lv lw lx b">children</code>和<code class="fe lu lv lw lx b">onClick</code>。</p><p id="f174" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们如何解决这个问题？</p><p id="787a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">现代ES6 JavaScript允许你传播函数参数和对象</a>。这可以用来为组件提供道具。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="0cf9" class="kw kx iq lx b gy mg mh l mi mj">// Before -&gt; &lt;button className="button"&gt;Click me&lt;/button&gt;<br/><br/>const Button = ({ children, className, onClick }) =&gt; (<br/>  &lt;button onClick={onClick} className={`${styles.button} ${className || ""}`}&gt;<br/>    {children}<br/>  &lt;/button&gt;<br/>);<br/><br/>// After -&gt; &lt;button className="button" data-theme="dark"&gt;Click me&lt;/button&gt;<br/><br/>const Button = ({ className, ...props }) =&gt; (<br/>  &lt;button className={`${styles.button} ${className || ""}`} {...props} /&gt;<br/>);<br/><br/>// Example<br/><br/>const App = ({ onActivate }) =&gt; (<br/>  &lt;SpecificFeature&gt;<br/>    &lt;Button data-theme="dark" onClick={onActivate}&gt;<br/>      Click me<br/>    &lt;/Button&gt;<br/>  &lt;/SpecificFeature&gt;<br/>);</span></pre><h1 id="15eb" class="ml kx iq bd ky mm mn mo lb mp mq mr le ms mt mu lh mv mw mx lk my mz na ln nb bi translated">3.把逻辑往上推/保持沉默</h1><p id="cd64" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">阻碍可重用性的最大问题之一是特定于某个特性的有状态逻辑是在可重用组件中实现的。</p><p id="d0b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设你有一个<code class="fe lu lv lw lx b">Dropdown</code>组件。点击链接时在导航中使用的。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="c9be" class="kw kx iq lx b gy mg mh l mi mj">const DropdownItem = ({ className, ...props }) =&gt; (<br/>  &lt;li className={`dropdown-item ${className || ""}`} {...props} /&gt;<br/>);</span><span id="abde" class="kw kx iq lx b gy nc mh l mi mj">class Dropdown extends React.Component {<br/>  state = { toggled: false };</span><span id="6457" class="kw kx iq lx b gy nc mh l mi mj">  toggle = () =&gt; this.setState(state =&gt; ({ toggled: !state.toggled }));</span><span id="688a" class="kw kx iq lx b gy nc mh l mi mj">  render() {<br/>    return (<br/>      &lt;div className="navbar-link"&gt;<br/>        &lt;span onClick={this.toggle}&gt; {this.props.title} &lt;/span&gt;<br/>        {this.state.toggled &amp;&amp; (<br/>          &lt;ul className="dropdown"&gt; {this.props.children} &lt;/ul&gt;<br/>        )}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="e895" class="kw kx iq lx b gy nc mh l mi mj">const Navbar = () =&gt; (<br/>  &lt;div className="navbar"&gt;<br/>    &lt;div className="navbar-brand"&gt;Example&lt;/div&gt;<br/>    &lt;ul className="navbar-menu"&gt;<br/>      &lt;Dropdown title="My Account"&gt;<br/>        &lt;DropdownItem&gt;One&lt;/DropdownItem&gt;<br/>        &lt;DropdownItem&gt;Two&lt;/DropdownItem&gt;<br/>      &lt;/Dropdown&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/div&gt;<br/>);</span></pre><p id="7f84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的问题是:</p><ol class=""><li id="a500" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated"><code class="fe lu lv lw lx b">Dropdown</code>处理打开和关闭下拉菜单的逻辑。这使得在更复杂的场景中重用<code class="fe lu lv lw lx b">Dropdown</code>变得更加困难(例如:只有当请求成功时才打开下拉菜单)。</li><li id="ada8" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated"><code class="fe lu lv lw lx b">Dropdown</code>具有与<code class="fe lu lv lw lx b">Navbar</code>组件相关的标记。</li></ol><p id="4f74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们重构<code class="fe lu lv lw lx b">Dropdown</code>组件来提升逻辑。我们最终得到一个更加可重用的<code class="fe lu lv lw lx b">Dropdown</code>组件。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="fe9b" class="kw kx iq lx b gy mg mh l mi mj">const DropdownItem = ({ className, ...props }) =&gt; (<br/>  &lt;li className={`dropdown-item ${className || ""}`} {...props} /&gt;<br/>);</span><span id="1f48" class="kw kx iq lx b gy nc mh l mi mj">const Dropdown = ({ className, ...props }) =&gt; (<br/>  &lt;ul className={`dropdown ${className || ""}`} {...props} /&gt;<br/>);</span><span id="a445" class="kw kx iq lx b gy nc mh l mi mj">class Navbar extends React.Component {<br/>  state = { showUserOptions: false };</span><span id="a741" class="kw kx iq lx b gy nc mh l mi mj">  toggleOptions = () =&gt;<br/>    this.setState(state =&gt; ({<br/>      showUserOptions: !state.showUserOptions<br/>    }));</span><span id="5887" class="kw kx iq lx b gy nc mh l mi mj">  render() {<br/>    return (<br/>      &lt;div className="navbar"&gt;<br/>        &lt;div className="navbar-brand"&gt;Example&lt;/div&gt;<br/>        &lt;ul className="navbar-menu"&gt;<br/>          &lt;div className="navbar-link"&gt;<br/>            &lt;span onClick={this.toggleOptions}&gt;My Account&lt;/span&gt;<br/>            {this.state.showUserOptions &amp;&amp; (<br/>              &lt;Dropdown&gt;<br/>                &lt;DropdownItem&gt;One&lt;/DropdownItem&gt;<br/>                &lt;DropdownItem&gt;Two&lt;/DropdownItem&gt;<br/>              &lt;/Dropdown&gt;<br/>            )}<br/>          &lt;/div&gt;<br/>        &lt;/ul&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><h1 id="df61" class="ml kx iq bd ky mm mn mo lb mp mq mr le ms mt mu lh mv mw mx lk my mz na ln nb bi translated">摘要</h1><ul class=""><li id="0230" class="nd ne iq ka b kb lp kf lq kj nr kn ns kr nt kv nu nj nk nl bi translated">保持组件布局流畅。</li><li id="f765" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv nu nj nk nl bi translated">允许额外的道具传入组件。</li><li id="ea5a" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv nu nj nk nl bi translated">尽可能地让逻辑远离它们。</li></ul></div></div>    
</body>
</html>