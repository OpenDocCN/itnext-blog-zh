<html>
<head>
<title>Add confirmation dialog to React events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">添加确认对话框以对事件做出反应</h1>
<blockquote>原文：<a href="https://itnext.io/add-confirmation-dialog-to-react-events-f50a40d9a30d?source=collection_archive---------0-----------------------#2018-09-13">https://itnext.io/add-confirmation-dialog-to-react-events-f50a40d9a30d?source=collection_archive---------0-----------------------#2018-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bd9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个简单呈现组件的例子，它为任何反应事件增加了一个确认步骤，比如表单提交或者按钮点击。</p><p id="c2da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您已经做了无数次了——您有一个需要额外确认步骤的表单。也许是为了鼓励用户仔细检查输入的数据，或者只是礼貌地告诉他们将要发生什么。这里有一个很好的(不幸的是，有点粗糙的)方法来使用渲染道具组件。</p><h1 id="57ca" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">出发点</h1><p id="1922" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">假设您有一个表单:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="c40a" class="lx km iq lt b gy ly lz l ma mb">&lt;form onSubmit={<strong class="lt ir">handleSubmit</strong>}&gt;<br/>   // form<br/>&lt;/form&gt;</span></pre><p id="a623" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当提交表单时，<code class="fe mc md me lt b">handleSubmit</code>事件处理程序被调用，发生了一些事情。现在您想添加一个确认步骤。您可能只是创建一个不同的处理程序，它打开一个modal并添加<code class="fe mc md me lt b">handleSubmit</code>处理程序来提交modal中的按钮:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ae36" class="lx km iq lt b gy ly lz l ma mb">{isOpen &amp;&amp; (<br/>  &lt;Dialog&gt;<br/>    Are you sure?</span><span id="8acb" class="lx km iq lt b gy mf lz l ma mb">    &lt;button onClick={<strong class="lt ir">closeConfirmationModal</strong>}&gt;No&lt;/button&gt;<br/>    &lt;button onClick={<strong class="lt ir">handleSubmit</strong>}&gt;Yes&lt;/button&gt;<br/>  &lt;/Dialog&gt;<br/>)}</span><span id="e627" class="lx km iq lt b gy mf lz l ma mb">&lt;form onSubmit={<strong class="lt ir">openConfirmationModal</strong>}<br/>   // ... form<br/>&lt;/form&gt;</span></pre><p id="7113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…类似这样的东西。唯一的问题是如果你想在不同的组件中重用相同的行为。如何把它变成一个可复用的组件？</p><h1 id="1be1" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">渲染道具组件</h1><p id="1721" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在考虑实现之前，让我们先画出可能的用例。</p><p id="1bd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们前一个例子可能是这样的:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="3d63" class="lx km iq lt b gy ly lz l ma mb">&lt;Confirm&gt;<br/>  {<strong class="lt ir">confirm</strong> =&gt; (<br/>    &lt;form onSubmit={<strong class="lt ir">confirm</strong>(handleSubmit)}&gt;<br/>      // ... form<br/>    &lt;/form&gt;<br/>  )}<br/>&lt;/Confirm&gt;</span></pre><p id="e803" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个确认处理都在<code class="fe mc md me lt b">Confirm</code>组件内部，我们只是将<code class="fe mc md me lt b">handleSubmit</code>事件处理程序作为回调传递给<code class="fe mc md me lt b">confirm</code>处理程序。</p><p id="5b1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最棒是，我们可以使用这个render prop组件来拦截任何React事件，比如按钮点击:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="fdd9" class="lx km iq lt b gy ly lz l ma mb">&lt;Confirm&gt;<br/>  {<strong class="lt ir">confirm</strong> =&gt; (<br/>    &lt;button onClick={<strong class="lt ir">confirm</strong>(launch)}&gt;Launch!&lt;/button&gt;<br/>  )}<br/>&lt;/Confirm&gt;</span></pre><p id="fa08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">API看起来很好很干净，那么有什么问题呢？合成事件的汇集。</p><h1 id="5e58" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">履行</h1><p id="6a17" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">实现很简单。对于一个模态，我们将使用Ryan Florence<a class="mh mi ep" href="https://medium.com/u/162352c45b6e?source=post_page-----f50a40d9a30d--------------------------------" rel="noopener" target="_blank">制作的</a><a class="ae mg" href="https://ui.reach.tech/dialog" rel="noopener ugc nofollow" target="_blank"> @reach/dialog </a>。首先，我们用<code class="fe mc md me lt b">openConfirmationDialog</code>处理程序调用子进程，然后有条件地在它旁边呈现对话框:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="cad9" class="lx km iq lt b gy ly lz l ma mb">&lt;React.Fragment&gt;<br/>  {this.props.children(this.openConfirmationDialog)}</span><span id="61c0" class="lx km iq lt b gy mf lz l ma mb">  {this.state.open &amp;&amp; (<br/>    &lt;Dialog&gt;<br/>      &lt;h1&gt;{this.props.title}&lt;/h1&gt;<br/>      &lt;p&gt;{this.props.description}&lt;/p&gt;</span><span id="63e9" class="lx km iq lt b gy mf lz l ma mb">      &lt;button onClick={this.hideConfirmationDialog}&gt;Cancel&lt;/button&gt;<br/>      &lt;button onClick={this.confirm}&gt;OK&lt;/button&gt;<br/>    &lt;/Dialog&gt;<br/>  )}<br/>&lt;/React.Fragment&gt;</span></pre><p id="0725" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将<a class="ae mg" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">孩子作为函数</a>调用是一种常见的React模式。您可以将它视为局部高阶组件，而不是包装整个组件，您只需将呈现方法的一部分传递给它。</p><p id="e1a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有一个呈现方法，让我们开始实现事件处理程序。</p><h2 id="d6e0" class="lx km iq bd kn mj mk dn kr ml mm dp kv jy mn mo kz kc mp mq ld kg mr ms lh mt bi translated">合成事件的汇集</h2><p id="42b8" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果您曾经试图在异步处理程序中传递React事件，您会在控制台中得到一个很好的错误，这是不可能的，因为React事件对象是重用的。这意味着当你试图在事件被触发之后访问它，它已经是一个完全不同的事件了。</p><p id="0a07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是很好的<a class="ae mg" href="https://reactjs.org/docs/events.html#event-pooling" rel="noopener ugc nofollow" target="_blank">文档</a>，它可能会在未来的版本中被删除，但现在我们必须处理它。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4cc1" class="lx km iq lt b gy ly lz l ma mb">openDialogModal = callback =&gt; event =&gt; {<br/>  // prevent default event action, e.g: form submission<br/>  event.preventDefault()</span><span id="7be1" class="lx km iq lt b gy mf lz l ma mb">  // we need to destructure the event<br/>  // and get the current target value (e.g: select value<br/>  event = {<br/>    ...event,<br/>    target: { ...event.target, value: event.target.value }<br/>  }</span><span id="c565" class="lx km iq lt b gy mf lz l ma mb">  this.setState({<br/>    open: true,</span><span id="c58c" class="lx km iq lt b gy mf lz l ma mb">    // save original callback with event in closure<br/>    callback: () =&gt; callback(event)<br/>  })<br/>}</span></pre><p id="7831" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<em class="mu"> hackish </em>的部分。</p><p id="acfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看了文件，有一个提示:</p><blockquote class="mv mw mx"><p id="7b8c" class="jn jo mu jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated">如果您想以异步方式访问事件属性，您应该在事件上调用<code class="fe mc md me lt b">event.persist()</code>，这将从池中移除合成事件，并允许用户代码保留对事件的引用。</p></blockquote><p id="2218" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，<code class="fe mc md me lt b">event.persist()</code>对阅读<code class="fe mc md me lt b">event.target.value</code>不起作用。不知道为什么，但即使我没有得到任何关于事件被重用的错误或警告，它仍然返回当前的目标值。看起来，如果您拦截了将更新输入值的事件，并试图稍后读取该值，它将从当前DOM值中读取该值。</p><p id="c2c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，回到例子。</p><h2 id="25de" class="lx km iq bd kn mj mk dn kr ml mm dp kv jy mn mo kz kc mp mq ld kg mr ms lh mt bi translated">剩余处理程序</h2><p id="4984" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">两个失踪的经手人就简单多了。</p><p id="cdb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个是<code class="fe mc md me lt b">this.confirm</code>，它应该用原始事件调用原始处理程序并关闭模态:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="2fe7" class="lx km iq lt b gy ly lz l ma mb">confirm = () =&gt; {<br/>  this.state.callback()<br/>  this.hide()<br/>}</span></pre><p id="188b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用<code class="fe mc md me lt b">openConfirmationModal</code>中的<code class="fe mc md me lt b">event</code>解决了这个问题，所以现在我们只调用存储在闭包中的事件并隐藏模态。这将我们带到最后一个事件，它只是一个回调和关闭模式的清理:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4bc0" class="lx km iq lt b gy ly lz l ma mb">hide = () =&gt; this.setState({ open: false, callback: null })</span></pre><h1 id="31fa" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">例子</h1><p id="e90d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果你想尝试一下，这里有一个沙盒:</p><figure class="lo lp lq lr gt nb"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">确认组件示例</figcaption></figure><p id="579c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个向表单提交添加确认步骤、更改选择值和单击按钮的例子。</p><h1 id="9d7e" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="1429" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">首先，我对这个简单的解决方案感到兴奋，它保持了组件的整洁，并且不需要对事件处理逻辑进行任何更改。</p><p id="14a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我发现了事件池的问题，但我可以忍受。</p><p id="3677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你有什么看法？有没有更好的方法坚持<code class="fe mc md me lt b">event.target.value</code>？或者更好的处理确认的方法？请在这里或在Twitter上告诉我:</p><figure class="lo lp lq lr gt nb"><div class="bz fp l di"><div class="ni nd l"/></div></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="02b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘿！我是<a class="ae mg" href="https://tomasehrlich.cz/" rel="noopener ugc nofollow" target="_blank">全栈开发人员</a>，在空闲时间，我正在开发<a class="ae mg" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> LinguiJS </a>，这是一个面向JavaScript的i18n库。该库从头到尾解决了i18n，提供了用于翻译的组件、用于管理消息目录的CLI以及离线编译消息以节省包大小。它是react-intl的替代方案，但也适用于<a class="ae mg" href="https://t.co/NigOTsQhaY" rel="noopener ugc nofollow" target="_blank"> vanilla JS </a>。看看<a class="ae mg" href="https://lingui.github.io/js-lingui/tutorials/react.html" rel="noopener ugc nofollow" target="_blank"> React教程</a>或者说<a class="ae mg" href="https://lingui.github.io/js-lingui/misc/react-intl.html" rel="noopener ugc nofollow" target="_blank">和react-intl </a>有什么不同。</p><p id="1c34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对i18n感兴趣，可以看看本周发布的LinguiJS v2.7，它包含了用于国际化的宏(由<a class="mh mi ep" href="https://medium.com/u/db72389e89d8?source=post_page-----f50a40d9a30d--------------------------------" rel="noopener" target="_blank"> Kent C. Dodds </a>编写的<a class="ae mg" href="https://github.com/kentcdodds/babel-plugin-macros" rel="noopener ugc nofollow" target="_blank"> babel-plugin-macros </a>的可插拔编译时插件):</p><figure class="lo lp lq lr gt nb"><div class="bz fp l di"><div class="ni nd l"/></div></figure><p id="e349" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对我做的事情和写的文章感兴趣，请在Twitter上关注我:</p><div class="nq nr gp gr ns nt"><a href="https://twitter.com/tomas_ehrlich" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">托马斯·埃利希(@托马斯_埃利希)|推特</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">托马斯·埃利希的最新推文(@托马斯_埃利希)。#铁人三项运动员，网站和移动应用程序开发人员，著有……</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">twitter.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh oi nt"/></div></div></a></div></div></div>    
</body>
</html>