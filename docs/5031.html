<html>
<head>
<title>GraphQL Microservices — C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL微服务— C#</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-schema-stitching-c-2ccfd209d3ce?source=collection_archive---------2-----------------------#2020-11-21">https://itnext.io/graphql-schema-stitching-c-2ccfd209d3ce?source=collection_archive---------2-----------------------#2020-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0dc082f84d12006241f20d9a7a673d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fgMfXIQUosXMC_P-VdWuQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Nathana rebou as在<a class="ae kf" href="https://unsplash.com/s/photos/stitching?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9fc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/no-more-rest-long-live-graphql-apis-with-c-55962ba8f942?source=friends_link&amp;sk=48049f8e2b81b446de3c0cabf813f684">我的上一篇文章</a>中，我解释了为什么你可以考虑使用GraphQL API来代替REST。我使用了一个订单汇总页面的例子，其中一个移动应用程序可能需要发出多个HTTP请求来获取所有数据。这些都是个别电话，因为这是一个微服务架构:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/c20f1822f927401e3056947dd6e3b9ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*__Y4rKT9Kv0MwRaL.png"/></div></div></figure><p id="5b44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我展示了一个整体图表的例子，这并不是一个公平的比较:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lj"><img src="../Images/969a140c976d583eb74cefb65c6a0352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hOfA_Qxgq1PLmhPD.png"/></div></div></figure><p id="6ace" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">monolith Graph服务使我们能够展示移动应用程序的单一模式:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h2 id="0c2e" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">我们如何在微服务架构中拥有这种模式？</h2><blockquote class="mf"><p id="1f1c" class="mg mh it bd mi mj mk ml mm mn mo ld dk translated"><strong class="ak">模式拼接。</strong></p></blockquote><p id="a902" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我们可以将模式划分为多个服务，如下所示:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/005e896641f3bfd00c277783170c6387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TZqF85mTjOTMDzem-K5Cw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">按服务划分的订单汇总</figcaption></figure><p id="d53d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了进行这种划分，我们需要一个入口点来协调服务之间的调用，我们称之为Graph Stitcher。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lj"><img src="../Images/3e594db91370e685aa07b021a9631d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y47Lkujn3tjlXOt-cYa9Rw.png"/></div></div></figure><p id="087e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几个要点:</p><ul class=""><li id="0420" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated">GraphStitcher定义了一个“缝合模式”，它是其他服务模式的组合。</li><li id="2819" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">订单、配置文件和产品是产品/图形端点，图形网关只是委托。</li><li id="7821" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">GraphStitcher不仅仅是一个聚合器，它还可以覆盖/扩展模式。</li></ul><h1 id="3722" class="nj ln it bd lo nk nl nm lr nn no np lu nq nr ns lx nt nu nv ma nw nx ny md nz bi translated">C# —热巧克力演示</h1><p id="3584" class="pw-post-body-paragraph kg kh it ki b kj oa kl km kn ob kp kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">这是一个很长的设置，所以如果你想跟着做，这里是<a class="ae kf" href="https://github.com/RaphaelYoshiga/GraphStitchingDemo" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="5168" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们开始设置图形拼接器之前，让我们确保我们正在运行客户服务。所以在<a class="ae kf" href="http://localhost:5000/playground" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/playground</a>，我们应该会收到:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/868a51b6327d8eabbf70af9521c09a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRwD4ot8D0jxxMPl0RE78w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">客户服务模式示例</figcaption></figure><h2 id="27c0" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">设置装订机</h2><p id="55fe" class="pw-post-body-paragraph kg kh it ki b kj oa kl km kn ob kp kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">将它添加到空的。net core web应用程序:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="aab8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重要的是:</p><ul class=""><li id="85ab" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated">AddStitchedSchema——这就是我们判断我们的模式来自远程服务的方式。</li><li id="20ea" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">用来自AddStiched模式的构建器，我们做"<em class="og">构建器。AddSchemaFromHttp(图形。SchemaName) </em>“告诉HotChocolate框架将调用委派到哪里。</li><li id="462c" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">服务。AddHttpClient——我们添加一个命名的HTTP客户端，<strong class="ki iu">,它与模式具有相同的名称</strong></li></ul><p id="dd75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个简单的非动态版本:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="18ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们应该能够将来自图形拼接器的请求代理到客户服务中</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lj"><img src="../Images/77d9edb4876bd21871f883188aaf6e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nZTRAn9MJSeoNsVqG5Q-A.png"/></div></div></figure><p id="c64a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">制图师游乐场:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/151ebf395856ba360d0820be53ad7490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ai8S2YPehDwHJm-8K9H7iw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图形装订机将呼叫委托给客户服务</figcaption></figure><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/5edf10746ef1108811f1d91ed2578b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*O8M8WWsAGpi9Aw8h6fvvxw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">带有名字、id、姓氏和头衔的客户模式</figcaption></figure><p id="6449" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以工作，但是正如您所看到的，Customer没有原始模式中的“orders”字段。</p><h2 id="88db" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">添加另一个模式:</h2><p id="e1bd" class="pw-post-body-paragraph kg kh it ki b kj oa kl km kn ob kp kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">根据GraphSticher的Startup.cs，我们有一个“graphProviders”列表，所以如果我们将它添加到列表中，GraphSticher现在应该支持订单查询。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/220ad1c6926b2a505ef3c44635293f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NNjWoI1LO8HaFwpt55Ncmw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">具有客户服务和订单服务模式的图形拼接器</figcaption></figure><p id="b5ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管如此，我们可以按customerId查询订单，但不能直接从customer对象访问订单。</p><h2 id="a4e0" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">扩展客户对象</h2><p id="76a3" class="pw-post-body-paragraph kg kh it ki b kj oa kl km kn ob kp kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">为了向客户对象添加订单，我们需要扩展客户类型以添加“订单”属性，并告诉HotChocolate如何解决这个问题:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="2c9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需要用“AddExtensionsFromFile”注册模式的扩展，如下所示:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="2080" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">瞧啊。客户现在有一个链接到“订单”的属性:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/e491de0ff08ca3ce886b5b2bf78cfe1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PdvfRLvADNRUFaIGny-cIg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Stitcher现在在客户类型中有“订单”</figcaption></figure><p id="87a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只是提醒你我们的模式:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/005e896641f3bfd00c277783170c6387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TZqF85mTjOTMDzem-K5Cw.png"/></div></div></figure><h2 id="5da1" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">将产品链接至订单:项目:</h2><p id="06b2" class="pw-post-body-paragraph kg kh it ki b kj oa kl km kn ob kp kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">将产品添加到“graphProviders”中后，我们必须将扩展添加到项目类型中:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="01a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但这不就意味着每种产品都有单独的需求吗？</p><ul class=""><li id="b75b" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated">产品(标识号:1)</li><li id="8cec" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">产品(标识号:2)</li></ul><p id="3b60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">乍一看，是的，但不是，<a class="ae kf" href="https://chillicream.com/docs/hotchocolate/v10/stitching/#batching" rel="noopener ugc nofollow" target="_blank"> HotChocolate将通过使用别名出色地批量处理</a>对产品(id: {productId})的请求。假设我们要求两种产品:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h2 id="7979" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">在产品服务中批处理数据库查询</h2><p id="ea03" class="pw-post-body-paragraph kg kh it ki b kj oa kl km kn ob kp kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">因为产品服务现在接收带有别名的查询，所以我们可以利用<a class="ae kf" href="https://chillicream.com/docs/hotchocolate/v10/data-fetching/" rel="noopener ugc nofollow" target="_blank">数据加载器</a>来确保我们批处理请求并进行单个数据库调用:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><h2 id="39c8" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">最后的结果是:</h2><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/bcacf9b0f647bd9dfb7e9a04720a3f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDWxd3G28BljOb-bZ5o8Pg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">GraphQL游乐场从Stitcher与所有相关的服务工作</figcaption></figure><h1 id="86ef" class="nj ln it bd lo nk nl nm lr nn no np lu nq nr ns lx nt nu nv ma nw nx ny md nz bi translated">参考资料:</h1><ul class=""><li id="26ab" class="mv mw it ki b kj oa kn ob kr om kv on kz oo ld na nb nc nd bi translated"><a class="ae kf" href="https://chillicream.com/docs/hotchocolate/v10/stitching/" rel="noopener ugc nofollow" target="_blank">热巧克力文档</a></li></ul><h1 id="9cc1" class="nj ln it bd lo nk nl nm lr nn no np lu nq nr ns lx nt nu nv ma nw nx ny md nz bi translated">设计考虑</h1><p id="e7b6" class="pw-post-body-paragraph kg kh it ki b kj oa kl km kn ob kp kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">我采用了微服务在查询时彼此不了解的方法，但是作为替代，服务可以像GraphStitcher那样直接查询它们的依赖关系。</p><p id="d914" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，配置文件服务可能在客户中有属性“orders ”,但是突然客户服务提供了订单的模式。然后，如果我们将客户服务和订单服务添加到缝合器中，模式将被复制，它可能会中断，也可能不会。</p><p id="00ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还要考虑到，如果服务相互了解，它们就是必须在CI/CD管道中配置的依赖关系。</p><p id="6717" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我决定缝合的方式是一种更好的前进方式。</p><h1 id="d317" class="nj ln it bd lo nk nl nm lr nn no np lu nq nr ns lx nt nu nv ma nw nx ny md nz bi translated">结论</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ffd4be73bc5b6a305340a4370074184e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnA2suh5UmziiAz024XDrA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">乔·凯恩在<a class="ae kf" href="https://unsplash.com/s/photos/happy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3691" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你打算使用GraphQL API，你很可能会想在微服务架构中使用它，为此你需要一个<strong class="ki iu">图形拼接器来组合多个模式</strong>。</p><p id="4c1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在有了更多的GraphQL经验，这个东西是强大的，它允许消费者有很大的灵活性，可以使应用程序更有效。但是这种灵活性来自良好的工程实践，比如字典、批处理等的使用，这些实践是中级到高级的，所以你需要记住学习曲线和潜在的不良实现。</p></div></div>    
</body>
</html>