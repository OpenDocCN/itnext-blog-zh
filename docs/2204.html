<html>
<head>
<title>GraphQL &amp; Complex Client State: Why We Reached For Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL和复杂客户端状态:我们为什么要使用Redux</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-complex-client-state-why-we-reached-for-redux-804d767695c2?source=collection_archive---------2-----------------------#2019-04-16">https://itnext.io/graphql-complex-client-state-why-we-reached-for-redux-804d767695c2?source=collection_archive---------2-----------------------#2019-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">(但也许没必要)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cf9a65e7daf64bf8dfa40a0077ec8e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TiFZe_vdHsLGoVrk"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">班尼特·威廉姆森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="685e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">这无意中描述了一些模式，人们可能认为这些模式有点像</em><strong class="lb iu"><em class="lv"/></strong><em class="lv">在React应用程序中优雅地使用Redux和GraphQL。随着GraphQL状态管理最近取得更多进展，我可能会鼓励走这条路。然而在当时，我不确定我们</em> <strong class="lb iu"> <em class="lv">没有</em> </strong> <em class="lv">需要Redux… </em></p><p id="84d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2018年4月，我们启动了一个客户端项目，旨在取代非常旧的ActionScript (Flash)应用程序。(是的，现在古ECMA语在编译中使用。swf文件)。</p><p id="1c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的应用程序需要与多个后端服务对话，我们必须从某个节点(或某种web)服务器提供单页面应用程序本身，所以我们认为GraphQL可能是一个不错的选择。</p><p id="6b29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们很快就能够在客户端后面实现GraphQL层，与我们的内部/域内REST服务进行对话，并拥有一个根据需要获取第三方数据的框架。</p><h2 id="0707" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">好人</h2><p id="fb4d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们选择使用<a class="ae ky" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> ApolloClient </a>作为我们的React应用程序的GraphQL内存存储提供者。ApolloClient是一个非常活跃的T21，自从我们开始以来已经走过了很长的路。真的很棒。如果你正在考虑GraphQL(无论是客户端还是服务器),帮自己一个忙，看看Apollo的人在做什么。</p><p id="2ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们马上开始看到无需任何异步获取样板文件的好处，以前是以一种选择的方式提供的(thunk、epic、saga等)。GraphQL绝对不需要这些代码。使用一个HOC或render prop(如果您喜欢这类东西)，您可以编写查询来声明您的组件需要的数据，这样就完成了。有什么不喜欢的？</p><p id="9f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“第一阶段”的特性集非常平滑。除了使用GraphQL查询，我们开始使用一些小的变化来调用我们的下游服务，以持久化其他REST服务和命令——向队列添加工作负载等。</p><h2 id="7a4d" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">坏事</h2><p id="fabe" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在“第二阶段”特性集期间，开发有点困难。对于这一部分，我们的数据打包在一个庞大的文档中。(JSON中有大约5000行代码)文档包含了各种各样的信息(很可能是独立的关注点)。与服务端点的合同是整个文档。</p><p id="53c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你说改文档？不太可能，使用该文档的前端体验每年带来2 . 5亿美元的收入。</p><p id="b1dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文档的每个部分都由一个单独的UI管理——姑且称之为“编辑器”。每个编辑器都有一组独特的输入和控件，常见的用例是用户能够保存他们的更改或退出。</p><p id="a122" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，我们在UX找到了这样一个工作流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/8ddc6ec4ad1bd5fcbe7159199aefbdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELGpAV5Zj-YYBnN7Xiv9dQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">疯狂的状态管理工作流使用一个大文档库和UI编辑小片段。</figcaption></figure><p id="a209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，我们已经使用Redux来处理应用程序中的确认模式和通知——这些事情与服务器状态无关。使用Redux，我们发现对上述工作流建模就像对是否显示通知建模一样简单。</p><p id="29f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，我们的支持BFF(“后端对前端”)端是GraphQL，所以当需要持久化文档时，我们现在有了这种有趣的混合方法，我个人认为这很酷。这里有一个要点示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Redux中间件在某些动作上调用GraphQL变异</figcaption></figure><h2 id="ff1c" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">丑陋的</h2><p id="c52e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">虽然上面的例子看起来是两全其美的，但我们现在有机会将GraphQL客户端简单地嵌入到我们的Redux操作中，作为一种可接受的模式。没有任何强制的指导方针，我们很快也从这一层调用查询。</p><p id="90dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们从一开始就决定在redux层中获取数据，这可能会看起来更干净一些，但是由于我们开始将GraphQL查询捆绑到我们的组件，我们最终像这样将数据推入redux:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将数据从graphql HOC推送到redux组件上</figcaption></figure><h2 id="8771" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">外卖食品</h2><p id="3979" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我不觉得响应redux动作而执行突变有多可怕，但我更喜欢一种更干净的方式来耦合GraphQL和Redux——或者最好使用其中的一个。</p><p id="3066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我觉得我们可以通过应用程序更一致地实施某种更好的模式。话又说回来，我不确定我是否完成了一个应用程序而没有想到这一点。</p><p id="df67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">两个月后……</em></p><p id="0d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最终发表这篇文章之前，我决定先看一眼<a class="ae ky" href="https://www.apollographql.com/docs/react/essentials/local-state" rel="noopener ugc nofollow" target="_blank">https://www . apollographql . com/docs/react/essentials/local-state</a>。在我看来，至少可以将Apollo客户端缓存重新定位为一个统一存储，支持直接客户端写入:</p><blockquote class="mx my mz"><p id="317f" class="kz la lv lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">“直接写入缓存不需要GraphQL变异或解析函数”</p></blockquote><p id="b0a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了。仍然有相当多的冗余特性，如中间件、多年的开发、可靠的开发工具、<a class="ae ky" href="https://medium.com/@benipsen/introducing-redux-fusion-an-alternative-approach-to-react-reduxs-connect-method-for-rxjs-44248895b47d" rel="noopener">商店实现可观察的</a>、社区规模等。但是我非常期待继续从Apollo和GraphQL社区整体上看到更多的好东西。</p></div></div>    
</body>
</html>