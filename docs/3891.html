<html>
<head>
<title>NextJS OAuth with Passport and Github</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Passport和Github的NextJS OAuth</h1>
<blockquote>原文：<a href="https://itnext.io/nextjs-oauth-with-passport-and-github-159e324f4900?source=collection_archive---------3-----------------------#2020-03-19">https://itnext.io/nextjs-oauth-with-passport-and-github-159e324f4900?source=collection_archive---------3-----------------------#2020-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d86dc0562dcb18674de8eecd441250c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yig5jDeD59gzSN2j2AwLIw.png"/></div></div></figure><div class=""/><p id="11f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将在NextJS客户端和Express API之间设置OAuth。在这篇文章中，我假设了JavaScript、Nodejs和Expressjs的知识。然而，我把事情解释得很好，足以让任何人跟上并理解事情。</p><p id="87c5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章由两部分组成。</p><ol class=""><li id="5fa8" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><code class="fe lf lg lh li b">API</code>——涉及REST API后端部分，它有端点的OAuth集合和一个删除概要文件端点。这将包括创建REST端点、GitHub OAuth和用于存储用户详细信息的MongoDB数据库。</li><li id="6e8b" class="kw kx jb ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">UI</code> -该部分包括设置一个Nextjs服务器端渲染应用程序，该应用程序有一个用于登录的页面。</li></ol><p id="e7c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，要让OAuth工作，请看下图。</p><figure class="lp lq lr ls gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lo"><img src="../Images/9112218874bc5cbdb67b1aa1319e650e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gr9eYPj0UaZS-RUk"/></div></div></figure><p id="e1ca" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户点击登录按钮，调用我们的API <code class="fe lf lg lh li b">/auth/github</code>。我们的API使用GitHub passport库将用户重定向到他们的GitHub帐户，以批准或拒绝身份验证。在用户批准身份验证之后，Passportjs将使用用户详细信息回调我们的身份验证回调端点<code class="fe lf lg lh li b">/auth/github/callback</code>。然后，我们使用用户详细信息来生成一个令牌，我们使用该令牌将用户重定向回我们的UI，并完成身份验证过程。</p><p id="727c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe lf lg lh li b">npm init</code>创建一个新的Nodejs应用程序。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="2d52" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装包<code class="fe lf lg lh li b">express</code>、<code class="fe lf lg lh li b">body-parser</code>、<code class="fe lf lg lh li b">passport</code>、<code class="fe lf lg lh li b">passport-github</code>、<code class="fe lf lg lh li b">jsonwebtoken</code>和<code class="fe lf lg lh li b">mongoose</code>组成我们的API服务器。</p><pre class="lp lq lr ls gt lv li lw lx aw ly bi"><span id="b996" class="lz ma jb li b gy mb mc l md me">npm i --save express passport passport-github mongoose jsonwebtoken</span></pre><p id="0374" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的基本服务器看起来会像这样。使用body-parser解析请求体并在端口3001上侦听。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="b72b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们允许cors，这样我们的UI将能够调用API，而没有跨来源请求的限制。这将是一个安装在应用程序请求链中的中间件。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="3a03" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时我们要做的下一件事是设置passport来为下游流程序列化用户。Passport将在收到OAuth响应时序列化用户，然后将一切交给我们。在OAuth协商完成后，我们将处理会话并使用cookie验证自己。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="8af0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以上面的代码将被passport和passport-github之间的通信所使用，现在是时候设置OAuth部分了，它将与Github API对话，这将包括登录端点。为此，我们将使用一个专用的路由<code class="fe lf lg lh li b">/auth</code>和一些使用Mongoose的数据库实用程序来存储来自OAuth调用的用户详细信息。</p><h1 id="8994" class="mf ma jb bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">设置数据层</h1><p id="d74b" class="pw-post-body-paragraph jy jz jb ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">这包括你喜欢的任何东西，但我使用Mongoose连接到一个本地mongodb。Mongoose对于建立快速连接和模型很有用。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="9ddd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当应用程序启动时，启动数据库服务连接。编辑<code class="fe lf lg lh li b">app.js</code>并要求db。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="dab8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们创建用户模型。只包含<code class="fe lf lg lh li b">oAuthId</code>——GitHub上的用户id和<code class="fe lf lg lh li b">oAuthData</code>——其余的数据。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="a523" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们创建DB实用程序，用于从Mongodb创建和获取用户</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="b309" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经准备好创建我们的身份验证端点了。但在此之前，请进入<a class="ae nh" href="https://github.com/settings/developers" rel="noopener ugc nofollow" target="_blank"> GitHub OAuth应用</a>设置并创建一个新应用。获取值<code class="fe lf lg lh li b">Client ID</code>和<code class="fe lf lg lh li b">Client Secret</code>，并设置为本地环境，如下所示</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="43e2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在创建下面的文件，保存login调用和intern调用GitHub APIs的端点。在这里，我们调用GitHub并进行身份验证，然后生成一个新的令牌，我们在URL查询中将其发送回UI</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="31e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们将路线上传到我们的应用程序，编辑<code class="fe lf lg lh li b">app.js</code>并添加路线。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="b008" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的API现在可以开始接受OAuth请求了</p><p id="ba32" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lf lg lh li b">npx create-next-app</code>创建一个新的Nextjs应用程序，并按照说明进行操作。创建一个nextjs应用程序后，我们将编辑索引页面，使其具有一个登录按钮。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="6fa9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在这一点上，点击登录应该会重定向次数，并把我们带回到在浏览器cookie部分有一个名为<code class="fe lf lg lh li b">authorization</code>的cookie的索引页面。所以我们要做的下一件事就是在使用Nextjs服务器为我们的页面提供服务时找到这个cookie。</p><p id="def2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了设置cookie，因为令牌是在登录后在重定向URL中发送的，所以我们在下一个应用程序中使用了一个<a class="ae nh" href="https://nextjs.org/docs/advanced-features/custom-document" rel="noopener ugc nofollow" target="_blank">定制文档</a>。这将帮助我们在服务器端拦截请求，并使用<a class="ae nh" href="https://www.npmjs.com/package/nookies" rel="noopener ugc nofollow" target="_blank"> Nookies </a>设置cookie</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="0d03" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在服务器端读取cookie，我们使用<a class="ae nh" href="https://www.npmjs.com/package/nookies" rel="noopener ugc nofollow" target="_blank"> Nookies </a>来读取令牌，同时在请求查询参数中考虑它。</p><pre class="lp lq lr ls gt lv li lw lx aw ly bi"><span id="db97" class="lz ma jb li b gy mb mc l md me">npm install — save nookies</span></pre><p id="2aaf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们向索引页面组件添加一个<code class="fe lf lg lh li b">getInitialProps</code>来读取cookie。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="d7d6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在成功登录之后，应该不会显示登录，因为在服务器端呈现过程中，我们找到了cookie，并将其作为一个道具返回给组件，以便在对API的任何后续请求中使用。让我们使用令牌来获取用户配置文件。</p><p id="a57b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们知道cookie在服务器端呈现期间是可用的，因此我们可以使用它来执行需要身份验证的API调用，例如获取用户配置文件。</p><p id="fa85" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们向用户配置文件添加一个端点</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="04f6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并挂载在app上。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="b225" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们修改索引页面以在服务器端呈现时获取用户。我们在get initial props或query中使用从cookies中获取的令牌。</p><figure class="lp lq lr ls gt is"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="a051" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你在这篇文章中学到了一些东西。我们使用cookies来管理对REST API的认证，REST API使用passportjs对GitHub进行认证。您可以使用这种方法对任何其他OAuth API进行身份验证，比如Google、Twitter和脸书。</p><p id="4e73" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里使用的全部代码在<a class="ae nh" href="https://github.com/zemuldo/nextjs-oauth" rel="noopener ugc nofollow" target="_blank"> GitHub </a>干杯！</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="0799" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="np">最初发表于</em><a class="ae nh" href="https://zemuldo.com/blog/5e6d256f7f7b5b001984784f" rel="noopener ugc nofollow" target="_blank">T5【http://zemuldo.com】</a><em class="np">。</em></p></div></div>    
</body>
</html>