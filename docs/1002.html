<html>
<head>
<title>Beginning .NET Core development with docker on Linux, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始。用docker在Linux上开发. NET核心，第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/beginning-net-core-development-with-docker-on-linux-6595a7eebdaa?source=collection_archive---------0-----------------------#2018-07-03">https://itnext.io/beginning-net-core-development-with-docker-on-linux-6595a7eebdaa?source=collection_archive---------0-----------------------#2018-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/23f2f6b2f9f3a8415d10268b9fac88dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7d8QOJeM1Us3OfcF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">特雷文·鲁迪在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3b8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。NET core带来了许多变革。NET应用程序的编写不仅仅是跨平台开发的能力。我目前选择的主要开发平台是Linux，我想建立一个开发工作流程，包括。NET core作为单页JavaScript应用程序的后端。当我在做的时候，我认为它应该使用docker容器来简化构建和部署。</p><p id="099d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终的结果是<a class="ae kc" href="https://github.com/dfcook/core-docker" rel="noopener ugc nofollow" target="_blank">这里是</a>，但是我想走完每个阶段，并尝试解释每个配置文件的用途以及特定设置的用途。当我在Linux上运行时，我希望在Windows机器上运行不会太难。我已经验证了代码可以在Mac上运行，没有任何改动。</p><p id="1021" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是文章的第1部分，重点是。NET容器构建和介绍一些docker命令。第2部分将添加UI层，并研究如何组合容器。</p><h2 id="3dad" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">先决条件</h2><ol class=""><li id="b957" class="lu lv iq kf b kg lw kk lx ko ly ks lz kw ma la mb mc md me bi translated"><a class="ae kc" href="https://www.microsoft.com/net/learn/get-started/linux/ubuntu18-04" rel="noopener ugc nofollow" target="_blank">。NET Core SDK </a></li><li id="7127" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated"><a class="ae kc" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="3bd3" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated"><a class="ae kc" href="https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions" rel="noopener ugc nofollow" target="_blank">节点</a></li><li id="4082" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated"><a class="ae kc" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>——或者任何编辑器，我喜欢VS代码，它有docker的扩展，允许我们以图形方式查看部署的图像和容器。</li></ol><h2 id="205e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">我们正在建造的东西</h2><p id="c085" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在这个故事中，没有太多的C#或JavaScript编码，我将使用dotnet和Vue cli来生成基本的应用程序，并让JavaScript应用程序调用dotnet应用程序并显示一些基本数据。这个故事的重点是展示应用程序是如何封装在容器中并组合在一起的。</p><h2 id="06d4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">为什么要用docker？</h2><p id="c1ac" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">Docker容器使得在不同的机器上复制你的应用程序变得非常容易。例如，一旦我在Linux上完成开发，我就去我的mac，克隆repo并运行“docker-compose up”。下载并构建后，无需进一步安装，应用程序就可以在我的浏览器中使用了。</p><p id="7fc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">容器还提供隔离——容器中使用的依赖项和设置不会影响机器上运行的任何其他软件。这有助于避免依赖性冲突。</p><p id="fa0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用docker可以极大地简化部署，映像可以在构建后从中央集线器中提取，应用程序从开发阶段转移到试运行阶段再转移到生产阶段时不需要重新构建。</p><h2 id="f0d5" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">让我们开始—构建我们的API</h2><p id="e167" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">首先，创建一个名为core-docker的文件夹，然后在你的终端中打开它。输入以下内容:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="af40" class="lb lc iq ms b gy mw mx l my mz">mkdir core-api<br/>cd core-api</span><span id="143c" class="lb lc iq ms b gy na mx l my mz">dotnet new webapi<br/>dotnet restore</span></pre><p id="9f48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将创建一个新的webapi项目并恢复其所有依赖项。的最新版本。NET默认启用HTTPS重定向，我们在这里不需要它，所以我在Startup.cs中做了一个小小的改动</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/e2d138f6e2454ded48ef2aabab6350e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rF1Pxk9ah8oYRHgZa2Dhmg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Startup.cs</figcaption></figure><p id="5e53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，在您的终端中输入“dotnet run”，api将开始在端口5000上运行，如果您在浏览器中导航到<a class="ae kc" href="http://localhost:5000/api/Values" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/API/Values</a>，您应该会看到一个JSON响应["value1 "，" value2"]。</p><h2 id="51b2" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">建立形象</h2><p id="b27d" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们有一个正在运行的API，所以让我们把它放在一个容器中。添加一个名为Dockerfile的文件，并在Visual Studio代码中打开，这将提示您安装我推荐的相关扩展。</p><p id="62bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的API的other文件由两部分组成，一部分用于构建，另一部分用于运行:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/667d8ac6cc2c6576359e45866cf6bd02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*GKWAMVNvKhuvCr6JzAvVFA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Dockerfile文件</figcaption></figure><p id="0102" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你以前没有使用过docker，这可能看起来很令人生畏，但是它相对简单。每行以一个命令开始(FROM、COPY、RUN等)，每个命令将从上到下依次执行。</p><ol class=""><li id="3423" class="lu lv iq kf b kg kh kk kl ko nd ks ne kw nf la mb mc md me bi translated">FROM指定了要使用的docker映像，在第1行中，我们指定了将用于构建应用程序的dotnet 2.1 SDK映像。</li><li id="7a99" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">WORKDIR指定映像中的工作目录。我们将使用/app作为我们的工作目录。</li><li id="3a19" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">COPY将文件从本地文件系统复制到映像中。我们将首先复制csproj文件并运行restore，然后复制所有剩余的文件并运行dotnet publish来构建我们的应用程序。</li><li id="ec75" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">文件的运行时部分使用不同的docker基础映像，aspnetcore-runtime映像，它复制构建中的所有文件，然后定义应用程序入口点。</li></ol><p id="790f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用此文件进行构建，请执行以下命令:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="876a" class="lb lc iq ms b gy mw mx l my mz">docker build -t core-api .</span></pre><p id="a3f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能是一个相当漫长的过程，但是每个中间步骤都显示了它的状态，您应该看到类似这样的内容:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/b9b38b69487acf29178a45a867ff90d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOG-NIbLQ988-EekA4T7mQ.png"/></div></div></figure><p id="6d27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您现在运行:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9186" class="lb lc iq ms b gy mw mx l my mz">docker image ls</span></pre><p id="1a91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将列出系统上的所有映像，您应该会看到新构建的core-api:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/eb810596217eb046cf24ea5d461538b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PNJBGfijkTGznRhvxq63Gw.png"/></div></div></figure><p id="197f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一步需要注意一些有趣的事情，如果你看看docker build的输出，你会发现在每一步之后都会出现很多ID。这是因为docker将每个命令递增地应用到您的图像，并创建一个新层。使用docker history命令可以看到这些层:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="70b5" class="lb lc iq ms b gy mw mx l my mz">docker image history core-api:latest</span></pre><p id="5ae0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，流程的不同阶段会相互影响。如果您查看第一条FROM语句，我们将它标记为“build ”,稍后在“runtime”部分，我们将在COPY语句中引用“build”。</p><p id="4666" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想删除图像，你可以使用docker rm，这可以带图像名或ID:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="7f8b" class="lb lc iq ms b gy mw mx l my mz">docker image rm 7c67428fb17a</span></pre><p id="ede3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在docker中看到数百张图片，你可以要求它自动删除它们:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="7708" class="lb lc iq ms b gy mw mx l my mz">docker image prune</span></pre><p id="e29e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者甚至要求docker对图像、容器和网络进行全面清理:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="b44a" class="lb lc iq ms b gy mw mx l my mz">docker system prune</span></pre><h2 id="3fd9" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">部署容器</h2><p id="1b8f" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">现在我们有了一个映像，我们构建的应用程序，我们需要启动并运行它。我们使用docker的“run”命令来实现这一点:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="97c3" class="lb lc iq ms b gy mw mx l my mz">docker run core-api:latest</span></pre><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/321fd3b93ac6b42ef4081e0e8b036fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oi3KTpGzekxGuv_d3CH-DA.png"/></div></div></figure><p id="be5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是启动容器的最简单方式，如果您随后运行:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ef8a" class="lb lc iq ms b gy mw mx l my mz">docker container ls</span></pre><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/5bf84eee26d0962aab41a99eb02df39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9CGLAO7anI_dZvwXzFOWA.png"/></div></div></figure><p id="f6f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以看到容器已经启动并运行，但处于生产模式，而不是我们使用dotnet命令启动它时的开发模式。此外，如果您访问http://localhost/api/Values ，您应该会得到一个错误，而不是我们期望的JSON响应。看看docker给我们的容器起的名字，这是docker发明的一个随机生成的名字，如果我们希望将来能够一致地引用我们的容器，这个名字就不太好了。</p><p id="defb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用命令行参数解决所有这些问题。首先停止我们的容器运行并删除它:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="3ca8" class="lb lc iq ms b gy mw mx l my mz">docker container stop stoic_goldstine<br/>docker container rm stoic_goldstine</span></pre><p id="ff6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(您需要用从docker容器返回的容器名称替换stoic_goldstine)</p><p id="3052" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，使用以下命令再次启动容器:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9aef" class="lb lc iq ms b gy mw mx l my mz">docker run --name core-api --env ASPNETCORE_ENVIRONMENT=Development -p 80:80 core-api:latest</span></pre><p id="7527" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了3个参数，name是容器启动并运行时的名称，env允许我们将环境变量传递给正在运行的容器，也许最重要的是，-p允许我们将容器上的端口映射到我们机器上的端口。</p><p id="6081" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当这个容器启动时，您可以使用ls命令并查看我们提供的名称和端口映射:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/35beb083a23e6a276b0d90682929692f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3ifbVCbaHH_WifW7bIhPg.png"/></div></div></figure><p id="66c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你去<a class="ae kc" href="http://localhost/api/Values" rel="noopener ugc nofollow" target="_blank">http://localhost/API/Values</a>，你应该得到预期的JSON响应。</p><h2 id="d4a1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">任务完成了</h2><p id="435e" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这部分到此为止。第2部分将创建一个与API对话的简单web UI，将它添加到自己的容器中，然后将我们的容器组合在一起以完成我们的开发环境。</p></div></div>    
</body>
</html>